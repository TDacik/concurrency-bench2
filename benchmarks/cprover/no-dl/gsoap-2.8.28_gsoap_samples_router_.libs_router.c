// tag-#anon#ST[ARR16{S64}_S64_'__fds_bits']
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_3;

// tag-#anon#ST[U32'n1'|U32'n2']
// file stdsoap2.h line 1270
struct anonymous_2;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'|ARR8{U16}_U16_'__u6_addr16'|ARR4{U32}_U32_'__u6_addr32']
// file /usr/include/netinet/in.h line 211
union anonymous_1;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_0;

// tag-#anon#UN[SYM#tag-sockaddr#'addr'|SYM#tag-sockaddr_in#'in'|SYM#tag-sockaddr_storage#'storage']
// file ../../../gsoap/stdsoap2.h line 2657
union anonymous;

// tag-Namespace
// file ../../../gsoap/stdsoap2.h line 1797
struct Namespace;

// tag-SOAP_ENV__Code
// file soapStub.h line 93
struct SOAP_ENV__Code;

// tag-SOAP_ENV__Detail
// file soapStub.h line 106
struct SOAP_ENV__Detail;

// tag-SOAP_ENV__Fault
// file ../../../gsoap/stdsoap2.h line 2485
struct SOAP_ENV__Fault;

// tag-SOAP_ENV__Header
// file ../../../gsoap/stdsoap2.h line 2484
struct SOAP_ENV__Header;

// tag-SOAP_ENV__Reason
// file soapStub.h line 121
struct SOAP_ENV__Reason;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 156
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-header
// file router.c line 262
struct header;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-linger
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 383
struct linger;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-soap
// file ../../../gsoap/stdsoap2.h line 2003
struct soap;

// tag-soap_attribute
// file ../../../gsoap/stdsoap2.h line 1866
struct soap_attribute;

// tag-soap_bhead
// file ../../../gsoap/stdsoap2.h line 1814
struct soap_bhead;

// tag-soap_blist
// file ../../../gsoap/stdsoap2.h line 1820
struct soap_blist;

// tag-soap_clist
// file ../../../gsoap/stdsoap2.h line 1857
struct soap_clist;

// tag-soap_code_map
// file stdsoap2.h line 2749
struct soap_code_map;

// tag-soap_cookie
// file ../../../gsoap/stdsoap2.h line 1877
struct soap_cookie;

// tag-soap_dime
// file ../../../gsoap/stdsoap2.h line 1918
struct soap_dime;

// tag-soap_dom_attribute
// file ../../../gsoap/stdsoap2.h line 2005
struct soap_dom_attribute;

// tag-soap_dom_element
// file ../../../gsoap/stdsoap2.h line 2004
struct soap_dom_element;

// tag-soap_double_nan
// file stdsoap2.h line 1270
union soap_double_nan;

// tag-soap_flist
// file ../../../gsoap/stdsoap2.h line 2755
struct soap_flist;

// tag-soap_ilist
// file ../../../gsoap/stdsoap2.h line 2479
struct soap_ilist;

// tag-soap_mime
// file ../../../gsoap/stdsoap2.h line 1940
struct soap_mime;

// tag-soap_mime_encoding
// file ../../../gsoap/stdsoap2.h line 1956
enum soap_mime_encoding { SOAP_MIME_NONE=0, SOAP_MIME_7BIT=1, SOAP_MIME_8BIT=2, SOAP_MIME_BINARY=3, SOAP_MIME_QUOTED_PRINTABLE=4, SOAP_MIME_BASE64=5, SOAP_MIME_IETF_TOKEN=6, SOAP_MIME_X_TOKEN=7 };

// tag-soap_mlist
// file ../../../gsoap/stdsoap2.h line 2642
struct soap_mlist;

// tag-soap_multipart
// file ../../../gsoap/stdsoap2.h line 1893
struct soap_multipart;

// tag-soap_nlist
// file ../../../gsoap/stdsoap2.h line 1805
struct soap_nlist;

// tag-soap_pblk
// file ../../../gsoap/stdsoap2.h line 1840
struct soap_pblk;

// tag-soap_plist
// file ../../../gsoap/stdsoap2.h line 1827
struct soap_plist;

// tag-soap_plugin
// file ../../../gsoap/stdsoap2.h line 2489
struct soap_plugin;

// tag-soap_xlist
// file ../../../gsoap/stdsoap2.h line 1988
struct soap_xlist;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 153
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/netinet/in.h line 252
struct sockaddr_in6;

// tag-sockaddr_storage
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 166
struct sockaddr_storage;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-t__Routing
// file soapStub.h line 46
struct t__Routing;

// tag-t__RoutingTable
// file soapStub.h line 47
struct t__RoutingTable;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

#ifndef NULL
#define NULL ((void*)0)
#endif

// __ctype_get_mb_cur_max
// file /usr/include/stdlib.h line 139
extern unsigned long int __ctype_get_mb_cur_max(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __isinf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 192
extern signed int __isinf(double);
// __isinff
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 192
extern signed int __isinff(float);
// __isinfl
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 192
extern signed int __isinfl(long double);
// __isnan
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 230
extern signed int __isnan(double);
// __isnanf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 230
extern signed int __isnanf(float);
// __isnanl
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 230
extern signed int __isnanl(long double);
// __xpg_strerror_r
// file /usr/include/string.h line 422
extern signed int __xpg_strerror_r(signed int, char *, unsigned long int);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// atol
// file /usr/include/stdlib.h line 150
extern signed long int atol(const char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// buffer_body
// file router.c line 720
signed int buffer_body(struct soap *sender);
// close
// file /usr/include/unistd.h line 356
extern signed int close(signed int);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// copy_body
// file router.c line 740
signed int copy_body(struct soap *sender, struct soap *receiver);
// copy_header
// file router.c line 625
signed int copy_header(struct soap *sender, struct soap *receiver, const char *endpoint, const char *action);
// create_header
// file router.c line 709
signed int create_header(struct soap *server, signed int method, const char *endpoint, const char *action, unsigned long int count);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fcntl
// file /usr/include/fcntl.h line 146
extern signed int fcntl(signed int, signed int, ...);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fplugin
// file stdsoap2.c line 18365
static void * fplugin(struct soap *soap, const char *id);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// frecv
// file stdsoap2.c line 925
static unsigned long int frecv(struct soap *soap, char *s, unsigned long int n);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// fsend
// file stdsoap2.c line 562
static signed int fsend(struct soap *soap, const char *s, unsigned long int n);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 213
extern signed int fstat(signed int, struct stat *);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gmtime_r
// file /usr/include/time.h line 249
extern struct tm * gmtime_r(const signed long int *, struct tm *);
// http_200
// file stdsoap2.c line 6353
static signed int http_200(struct soap *soap);
// http_405
// file stdsoap2.c line 6341
static signed int http_405(struct soap *soap);
// http_error
// file stdsoap2.c line 6309
static const char * http_error(struct soap *soap, signed int status);
// http_get
// file stdsoap2.c line 6328
static signed int http_get(struct soap *soap);
// http_parse
// file stdsoap2.c line 5894
static signed int http_parse(struct soap *soap);
// http_parse_header
// file stdsoap2.c line 6067
static signed int http_parse_header(struct soap *soap, const char *key, const char *val);
// http_post
// file stdsoap2.c line 6364
static signed int http_post(struct soap *soap, const char *endpoint, const char *host, signed int port, const char *path, const char *action, unsigned long int count);
// http_post_header
// file stdsoap2.c line 6520
static signed int http_post_header(struct soap *soap, const char *key, const char *val);
// http_response
// file stdsoap2.c line 6537
static signed int http_response(struct soap *soap, signed int status, unsigned long int count);
// http_send_header
// file stdsoap2.c line 6500
static signed int http_send_header(struct soap *soap, const char *s);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// lookup
// file router.c line 510
const char * lookup(struct t__RoutingTable *route, const char *key, const char *userid, const char *passwd);
// make_connect
// file router.c line 570
signed int make_connect(struct soap *server, const char *endpoint);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// mbtowc
// file /usr/include/stdlib.h line 865
extern signed int mbtowc(signed int *, const char *, unsigned long int);
// memcpy
// file /usr/include/string.h line 42
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 46
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 62
extern void * memset(void *, signed int, unsigned long int);
// mktime
// file /usr/include/time.h line 199
extern signed long int mktime(struct tm *);
// new_attribute
// file dom.c line 1084
static struct soap_dom_attribute * new_attribute(struct soap *soap);
// new_element
// file dom.c line 1070
static struct soap_dom_element * new_element(struct soap *soap);
// open
// file /usr/include/fcntl.h line 156
extern signed int open(const char *, signed int, ...);
// options
// file router.c line 394
void options(signed int argc, char **argv);
// out_attribute
// file dom.c line 259
static signed int out_attribute(struct soap *soap, const char *prefix, const char *name, const char *text, signed int isearly);
// out_element
// file dom.c line 204
static signed int out_element(struct soap *soap, struct soap_dom_element *node, const char *prefix, const char *name);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// process_request
// file router.c line 476
void * process_request(void *soap);
// pthread_create
// file /usr/include/pthread.h line 233
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 271
extern signed int pthread_detach(unsigned long int);
// pthread_mutex_lock
// file /usr/include/pthread.h line 762
extern signed int pthread_mutex_lock(union anonymous_0 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 773
extern signed int pthread_mutex_unlock(union anonymous_0 *);
// pthread_self
// file /usr/include/pthread.h line 275
extern unsigned long int pthread_self(void);
// random
// file /usr/include/stdlib.h line 321
extern signed long int random(void);
// read
// file /usr/include/unistd.h line 363
extern signed long int read(signed int, void *, unsigned long int);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// recvfrom
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 174
extern signed long int recvfrom(signed int, void *, unsigned long int, signed int, struct sockaddr *, unsigned int *);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_3 *, struct anonymous_3 *, struct anonymous_3 *, struct timeval *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// sendto
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 163
extern signed long int sendto(signed int, const void *, unsigned long int, signed int, struct sockaddr *, unsigned int);
// server_connect
// file router.c line 593
signed int server_connect(struct soap *server, const char *endpoint, const char *action, const char *userid, const char *passwd);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// soap_LONG642s
// file stdsoap2.c line 13110
const char * soap_LONG642s(struct soap *soap, signed long int n);
// soap_QName
// file stdsoap2.c line 14170
static const char * soap_QName(struct soap *soap, const char *s, signed long int minlen, signed long int maxlen);
// soap_QName2s
// file ../../../gsoap/stdsoap2.h line 3214
const char * soap_QName2s(struct soap *soap, const char *s);
// soap_ULONG642s
// file stdsoap2.c line 13986
const char * soap_ULONG642s(struct soap *soap, unsigned long int n);
// soap_accept
// file ../../../gsoap/stdsoap2.h line 2910
signed int soap_accept(struct soap *soap);
// soap_add_att
// file dom.c line 1398
struct soap_dom_element * soap_add_att(struct soap_dom_element *elt, struct soap_dom_attribute *node);
// soap_add_atts
// file dom.c line 1455
struct soap_dom_element * soap_add_atts(struct soap_dom_element *elt, struct soap_dom_attribute *atts);
// soap_add_elt
// file dom.c line 1425
struct soap_dom_element * soap_add_elt(struct soap_dom_element *elt, struct soap_dom_element *node);
// soap_add_elts
// file dom.c line 1488
struct soap_dom_element * soap_add_elts(struct soap_dom_element *elt, struct soap_dom_element *elts);
// soap_append_lab
// file stdsoap2.c line 11552
signed int soap_append_lab(struct soap *soap, const char *s, unsigned long int n);
// soap_array_begin_out
// file stdsoap2.c line 10654
signed int soap_array_begin_out(struct soap *soap, const char *tag, signed int id, const char *type, const char *offset);
// soap_array_pointer_lookup
// file stdsoap2.c line 7600
signed int soap_array_pointer_lookup(struct soap *soap, const void *p, const void *a, signed int n, signed int type, struct soap_plist **ppp);
// soap_array_reference
// file stdsoap2.c line 7896
signed int soap_array_reference(struct soap *soap, const void *p, const void *a, signed int n, signed int t);
// soap_att
// file dom.c line 1200
struct soap_dom_attribute * soap_att(struct soap_dom_element *elt, const char *ns, const char *tag);
// soap_att_add
// file dom.c line 2116
struct soap_dom_attribute * soap_att_add(struct soap_dom_attribute *att, const char *ns, const char *tag);
// soap_att_add_w
// file dom.c line 2150
struct soap_dom_attribute * soap_att_add_w(struct soap_dom_attribute *att, const char *ns, const signed int *tag);
// soap_att_bool
// file dom.c line 2193
struct soap_dom_attribute * soap_att_bool(struct soap_dom_attribute *att, signed long int b);
// soap_att_copy
// file dom.c line 2279
struct soap_dom_attribute * soap_att_copy(struct soap_dom_attribute *att, struct soap_dom_attribute *node);
// soap_att_double
// file dom.c line 2227
struct soap_dom_attribute * soap_att_double(struct soap_dom_attribute *att, double x);
// soap_att_find
// file dom.c line 2761
struct soap_dom_attribute * soap_att_find(struct soap_dom_element *elt, const char *ns, const char *patt);
// soap_att_find_next
// file dom.c line 2792
struct soap_dom_attribute * soap_att_find_next(struct soap_dom_attribute *att, const char *ns, const char *patt);
// soap_att_first
// file dom.c line 2532
struct soap_dom_attribute * soap_att_first(struct soap_dom_element *elt);
// soap_att_get
// file dom.c line 2598
struct soap_dom_attribute * soap_att_get(struct soap_dom_element *elt, const char *ns, const char *tag);
// soap_att_get_LONG64
// file dom.c line 2467
signed long int soap_att_get_LONG64(struct soap_dom_attribute *att);
// soap_att_get_double
// file dom.c line 2489
double soap_att_get_double(struct soap_dom_attribute *att);
// soap_att_get_int
// file dom.c line 2423
signed int soap_att_get_int(struct soap_dom_attribute *att);
// soap_att_get_long
// file dom.c line 2445
signed long int soap_att_get_long(struct soap_dom_attribute *att);
// soap_att_get_ns
// file dom.c line 2359
const char * soap_att_get_ns(struct soap_dom_attribute *att);
// soap_att_get_tag
// file dom.c line 2376
const char * soap_att_get_tag(struct soap_dom_attribute *att);
// soap_att_get_text
// file dom.c line 2511
const char * soap_att_get_text(struct soap_dom_attribute *att);
// soap_att_get_w
// file dom.c line 2625
struct soap_dom_attribute * soap_att_get_w(struct soap_dom_element *elt, const char *ns, const signed int *tag);
// soap_att_int
// file dom.c line 2211
struct soap_dom_attribute * soap_att_int(struct soap_dom_attribute *att, signed long int n);
// soap_att_is_false
// file dom.c line 2408
signed int soap_att_is_false(struct soap_dom_attribute *att);
// soap_att_is_true
// file dom.c line 2393
signed int soap_att_is_true(struct soap_dom_attribute *att);
// soap_att_match
// file dom.c line 2306
signed int soap_att_match(struct soap_dom_attribute *att, const char *ns, const char *patt);
// soap_att_match_w
// file dom.c line 2331
signed int soap_att_match_w(struct soap_dom_attribute *att, const char *ns, const signed int *patt);
// soap_att_new
// file dom.c line 2032
struct soap_dom_attribute * soap_att_new(struct soap *soap, const char *ns, const char *tag);
// soap_att_new_w
// file dom.c line 2049
struct soap_dom_attribute * soap_att_new_w(struct soap *soap, const char *ns, const signed int *tag);
// soap_att_next
// file dom.c line 2547
struct soap_dom_attribute * soap_att_next(struct soap_dom_attribute *att);
// soap_att_set
// file dom.c line 2066
struct soap_dom_attribute * soap_att_set(struct soap_dom_attribute *att, const char *ns, const char *tag);
// soap_att_set_w
// file dom.c line 2091
struct soap_dom_attribute * soap_att_set_w(struct soap_dom_attribute *att, const char *ns, const signed int *tag);
// soap_att_size
// file dom.c line 2928
unsigned long int soap_att_size(struct soap_dom_element *elt, const char *ns, const char *patt);
// soap_att_text
// file dom.c line 2243
struct soap_dom_attribute * soap_att_text(struct soap_dom_attribute *att, const char *text);
// soap_att_text_w
// file dom.c line 2261
struct soap_dom_attribute * soap_att_text_w(struct soap_dom_attribute *att, const signed int *text);
// soap_att_w
// file dom.c line 1221
struct soap_dom_attribute * soap_att_w(struct soap_dom_element *elt, const char *ns, const signed int *tag);
// soap_attachment
// file stdsoap2.c line 8020
signed int soap_attachment(struct soap *soap, const char *tag, signed int id, const void *p, const void *a, signed int n, const char *aid, const char *atype, const char *aoptions, const char *type, signed int t);
// soap_attachment_forward
// file stdsoap2.c line 2212
signed int soap_attachment_forward(struct soap *soap, unsigned char **ptr, signed int *size, char **id, char **type, char **options);
// soap_attr_value
// file stdsoap2.c line 11250
const char * soap_attr_value(struct soap *soap, const char *name, signed int flag);
// soap_attribute
// file stdsoap2.c line 11098
signed int soap_attribute(struct soap *soap, const char *name, const char *value);
// soap_base642s
// file stdsoap2.c line 17364
const char * soap_base642s(struct soap *soap, const char *s, char *t, unsigned long int l, signed int *n);
// soap_begin
// file ../../../gsoap/stdsoap2.h line 3051
void soap_begin(struct soap *soap);
// soap_begin_count
// file stdsoap2.c line 7623
signed int soap_begin_count(struct soap *soap);
// soap_begin_recv
// file ../../../gsoap/stdsoap2.h line 3005
signed int soap_begin_recv(struct soap *soap);
// soap_begin_send
// file ../../../gsoap/stdsoap2.h line 2993
signed int soap_begin_send(struct soap *soap);
// soap_begin_serve
// file stdsoap2.c line 16443
signed int soap_begin_serve(struct soap *soap);
// soap_begin_shaky
// file stdsoap2.c line 8588
signed short int soap_begin_shaky(struct soap *soap);
// soap_bind
// file ../../../gsoap/stdsoap2.h line 2909
signed int soap_bind(struct soap *soap, const char *host, signed int port, signed int backlog);
// soap_block_size
// file ../../../gsoap/stdsoap2.h line 3130
unsigned long int soap_block_size(struct soap *soap, struct soap_blist *b);
// soap_body_begin_in
// file stdsoap2.c line 16998
signed int soap_body_begin_in(struct soap *soap);
// soap_body_begin_out
// file stdsoap2.c line 16962
signed int soap_body_begin_out(struct soap *soap);
// soap_body_end_in
// file stdsoap2.c line 17016
signed int soap_body_end_in(struct soap *soap);
// soap_body_end_out
// file stdsoap2.c line 16982
signed int soap_body_end_out(struct soap *soap);
// soap_byte2s
// file stdsoap2.c line 13207
const char * soap_byte2s(struct soap *soap, char n);
// soap_char
// file stdsoap2.c line 1544
static signed int soap_char(struct soap *soap);
// soap_check_and_mark
// file stdsoap2.c line 10964
signed int soap_check_and_mark(struct soap *soap, const void *p, signed int t, char **mark);
// soap_check_faultdetail
// file soapC.c line 156
const char * soap_check_faultdetail(struct soap *soap);
// soap_check_faultsubcode
// file soapC.c line 120
const char * soap_check_faultsubcode(struct soap *soap);
// soap_check_mime_attachments
// file stdsoap2.c line 15896
signed int soap_check_mime_attachments(struct soap *soap);
// soap_check_result
// file stdsoap2.c line 11083
void soap_check_result(struct soap *soap, const char *tag);
// soap_cleanup
// file stdsoap2.c line 5684
void soap_cleanup(struct soap *soap);
// soap_closesock
// file ../../../gsoap/stdsoap2.h line 3038
signed int soap_closesock(struct soap *soap);
// soap_clr_attr
// file stdsoap2.c line 11395
void soap_clr_attr(struct soap *soap);
// soap_clr_dime
// file stdsoap2.c line 16223
void soap_clr_dime(struct soap *soap);
// soap_clr_mime
// file stdsoap2.c line 16238
void soap_clr_mime(struct soap *soap);
// soap_code
// file stdsoap2.c line 1439
struct soap_code_map * soap_code(struct soap_code_map *code_map, const char *str);
// soap_code_bits
// file stdsoap2.c line 1490
signed long int soap_code_bits(struct soap_code_map *code_map, const char *str);
// soap_code_int
// file stdsoap2.c line 1457
signed long int soap_code_int(struct soap_code_map *code_map, const char *str, signed long int other);
// soap_code_list
// file stdsoap2.c line 1519
const char * soap_code_list(struct soap *soap, struct soap_code_map *code_map, signed long int code);
// soap_code_str
// file stdsoap2.c line 1475
const char * soap_code_str(struct soap_code_map *code_map, signed long int code);
// soap_connect
// file stdsoap2.c line 17114
signed int soap_connect(struct soap *soap, const char *endpoint, const char *action);
// soap_connect_command
// file stdsoap2.c line 17125
signed int soap_connect_command(struct soap *soap, signed int http_command, const char *endpoints, const char *action);
// soap_copy
// file ../../../gsoap/stdsoap2.h line 3043
struct soap * soap_copy(struct soap *soap);
// soap_copy_context
// file stdsoap2.c line 9370
struct soap * soap_copy_context(struct soap *copy, struct soap *soap);
// soap_copy_fault
// file stdsoap2.c line 18151
static signed int soap_copy_fault(struct soap *soap, const char *faultcode, const char *faultsubcodeQName, const char *faultstring, const char *faultdetailXML);
// soap_copy_stream
// file stdsoap2.c line 9468
void soap_copy_stream(struct soap *copy, struct soap *soap);
// soap_count_attachments
// file stdsoap2.c line 15363
static unsigned long int soap_count_attachments(struct soap *soap);
// soap_current_namespace
// file stdsoap2.c line 3020
const char * soap_current_namespace(struct soap *soap, const char *tag);
// soap_dateTime2s
// file stdsoap2.c line 14869
const char * soap_dateTime2s(struct soap *soap, signed long int n);
// soap_dealloc
// file stdsoap2.c line 8316
void soap_dealloc(struct soap *soap, void *p);
// soap_decode
// file stdsoap2.c line 6270
static const char * soap_decode(char *buf, unsigned long int len, const char *val, const char *sep);
// soap_decode_key
// file stdsoap2.c line 6242
const char * soap_decode_key(char *buf, unsigned long int len, const char *val);
// soap_decode_val
// file stdsoap2.c line 6255
const char * soap_decode_val(char *buf, unsigned long int len, const char *val);
// soap_default_SOAP_ENV__Code
// file soapC.c line 751
void soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a);
// soap_default_SOAP_ENV__Detail
// file soapC.c line 663
void soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a);
// soap_default_SOAP_ENV__Fault
// file soapC.c line 422
void soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a);
// soap_default_SOAP_ENV__Header
// file soapC.c line 841
void soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a);
// soap_default_SOAP_ENV__Reason
// file soapC.c line 582
void soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a);
// soap_default_byte
// file soapC.c line 348
void soap_default_byte(struct soap *soap, char *a);
// soap_default_int
// file soapC.c line 384
void soap_default_int(struct soap *soap, signed int *a);
// soap_default_string
// file soapC.c line 1386
void soap_default_string(struct soap *soap, char **a);
// soap_default_t__Routing
// file soapC.c line 1016
void soap_default_t__Routing(struct soap *soap, struct t__Routing *a);
// soap_default_t__RoutingTable
// file soapC.c line 908
void soap_default_t__RoutingTable(struct soap *soap, struct t__RoutingTable *a);
// soap_default_xsd__anyAttribute
// file dom.c line 192
void soap_default_xsd__anyAttribute(struct soap *soap, struct soap_dom_attribute *node);
// soap_default_xsd__anyType
// file dom.c line 170
void soap_default_xsd__anyType(struct soap *soap, struct soap_dom_element *node);
// soap_del
// file stdsoap2.c line 7478
void soap_del(struct soap *soap);
// soap_del_xsd__anyAttribute
// file dom.c line 796
void soap_del_xsd__anyAttribute(struct soap_dom_attribute *a);
// soap_del_xsd__anyType
// file dom.c line 744
void soap_del_xsd__anyType(struct soap_dom_element *a);
// soap_delegate_deletion
// file stdsoap2.c line 8435
void soap_delegate_deletion(struct soap *soap, struct soap *soap_to);
// soap_delete
// file stdsoap2.c line 8387
void soap_delete(struct soap *soap, void *p);
// soap_dime_option
// file stdsoap2.c line 15440
char * soap_dime_option(struct soap *soap, unsigned short int optype, const char *option);
// soap_dom_call
// file dom.c line 3135
signed int soap_dom_call(struct soap *soap, const char *endpoint, const char *action, struct soap_dom_element *in, struct soap_dom_element *out);
// soap_dom_find
// file dom.c line 3055
struct soap_dom_element * soap_dom_find(struct soap_dom_element *begin, struct soap_dom_element *end, const char *ns, const char *patt, signed int type);
// soap_dom_find_next
// file dom.c line 3091
struct soap_dom_element * soap_dom_find_next(struct soap_dom_element *elt, struct soap_dom_element *end, const char *ns, const char *patt, signed int type);
// soap_dom_next_attribute
// file dom.c line 3004
struct soap_dom_attribute * soap_dom_next_attribute(struct soap_dom_attribute *att);
// soap_dom_next_element
// file dom.c line 3020
struct soap_dom_element * soap_dom_next_element(struct soap_dom_element *elt, struct soap_dom_element *end);
// soap_done
// file ../../../gsoap/stdsoap2.h line 3049
void soap_done(struct soap *soap);
// soap_double2s
// file stdsoap2.c line 13530
const char * soap_double2s(struct soap *soap, double n);
// soap_dup_xsd__anyAttribute
// file dom.c line 769
struct soap_dom_attribute * soap_dup_xsd__anyAttribute(struct soap *soap, struct soap_dom_attribute *d, struct soap_dom_attribute *a);
// soap_dup_xsd__anyType
// file dom.c line 713
struct soap_dom_element * soap_dup_xsd__anyType(struct soap *soap, struct soap_dom_element *d, struct soap_dom_element *a);
// soap_element
// file stdsoap2.c line 10288
signed int soap_element(struct soap *soap, const char *tag, signed int id, const char *type);
// soap_element_begin_in
// file ../../../gsoap/stdsoap2.h line 3084
signed int soap_element_begin_in(struct soap *soap, const char *tag, signed int nillable, const char *type);
// soap_element_begin_out
// file ../../../gsoap/stdsoap2.h line 3070
signed int soap_element_begin_out(struct soap *soap, const char *tag, signed int id, const char *type);
// soap_element_end_in
// file ../../../gsoap/stdsoap2.h line 3086
signed int soap_element_end_in(struct soap *soap, const char *tag);
// soap_element_end_out
// file ../../../gsoap/stdsoap2.h line 3079
signed int soap_element_end_out(struct soap *soap, const char *tag);
// soap_element_href
// file stdsoap2.c line 10863
signed int soap_element_href(struct soap *soap, const char *tag, signed int id, const char *ref, const char *val);
// soap_element_id
// file ../../../gsoap/stdsoap2.h line 3076
signed int soap_element_id(struct soap *soap, const char *tag, signed int id, const void *p, const void *a, signed int n, const char *type, signed int t, char **mark);
// soap_element_nil
// file stdsoap2.c line 10907
signed int soap_element_nil(struct soap *soap, const char *tag);
// soap_element_null
// file stdsoap2.c line 10880
signed int soap_element_null(struct soap *soap, const char *tag, signed int id, const char *type);
// soap_element_ref
// file stdsoap2.c line 10843
signed int soap_element_ref(struct soap *soap, const char *tag, signed int id, signed int href);
// soap_element_result
// file stdsoap2.c line 11064
signed int soap_element_result(struct soap *soap, const char *tag);
// soap_element_start_end_out
// file stdsoap2.c line 10695
signed int soap_element_start_end_out(struct soap *soap, const char *tag);
// soap_elt
// file dom.c line 1242
struct soap_dom_element * soap_elt(struct soap_dom_element *elt, const char *ns, const char *tag);
// soap_elt_bool
// file dom.c line 1526
struct soap_dom_element * soap_elt_bool(struct soap_dom_element *elt, signed long int b);
// soap_elt_copy
// file dom.c line 1634
struct soap_dom_element * soap_elt_copy(struct soap_dom_element *elt, struct soap_dom_element *node);
// soap_elt_depth
// file dom.c line 1936
unsigned long int soap_elt_depth(struct soap_dom_element *elt);
// soap_elt_double
// file dom.c line 1560
struct soap_dom_element * soap_elt_double(struct soap_dom_element *elt, double x);
// soap_elt_find
// file dom.c line 2823
struct soap_dom_element * soap_elt_find(struct soap_dom_element *elt, const char *ns, const char *patt);
// soap_elt_find_next
// file dom.c line 2840
struct soap_dom_element * soap_elt_find_next(struct soap_dom_element *elt, const char *ns, const char *patt);
// soap_elt_find_next_type
// file dom.c line 2891
struct soap_dom_element * soap_elt_find_next_type(struct soap_dom_element *elt, const char *ns, const char *patt, signed int type);
// soap_elt_find_type
// file dom.c line 2858
struct soap_dom_element * soap_elt_find_type(struct soap_dom_element *elt, const char *ns, const char *patt, signed int type);
// soap_elt_first
// file dom.c line 2562
struct soap_dom_element * soap_elt_first(struct soap_dom_element *elt);
// soap_elt_get
// file dom.c line 2656
struct soap_dom_element * soap_elt_get(struct soap_dom_element *elt, const char *ns, const char *tag);
// soap_elt_get_LONG64
// file dom.c line 1825
signed long int soap_elt_get_LONG64(struct soap_dom_element *elt);
// soap_elt_get_double
// file dom.c line 1847
double soap_elt_get_double(struct soap_dom_element *elt);
// soap_elt_get_int
// file dom.c line 1781
signed int soap_elt_get_int(struct soap_dom_element *elt);
// soap_elt_get_long
// file dom.c line 1803
signed long int soap_elt_get_long(struct soap_dom_element *elt);
// soap_elt_get_next
// file dom.c line 2712
struct soap_dom_element * soap_elt_get_next(struct soap_dom_element *elt);
// soap_elt_get_node
// file dom.c line 1885
const void * soap_elt_get_node(struct soap_dom_element *elt, signed int type);
// soap_elt_get_ns
// file dom.c line 1717
const char * soap_elt_get_ns(struct soap_dom_element *elt);
// soap_elt_get_nth
// file dom.c line 2738
struct soap_dom_element * soap_elt_get_nth(struct soap_dom_element *elt, unsigned long int n);
// soap_elt_get_tag
// file dom.c line 1734
const char * soap_elt_get_tag(struct soap_dom_element *elt);
// soap_elt_get_text
// file dom.c line 1869
const char * soap_elt_get_text(struct soap_dom_element *elt);
// soap_elt_get_type
// file dom.c line 1901
signed int soap_elt_get_type(struct soap_dom_element *elt, const void **node);
// soap_elt_get_w
// file dom.c line 2683
struct soap_dom_element * soap_elt_get_w(struct soap_dom_element *elt, const char *ns, const signed int *tag);
// soap_elt_index
// file dom.c line 1957
unsigned long int soap_elt_index(struct soap_dom_element *elt);
// soap_elt_int
// file dom.c line 1544
struct soap_dom_element * soap_elt_int(struct soap_dom_element *elt, signed long int n);
// soap_elt_is_false
// file dom.c line 1766
signed int soap_elt_is_false(struct soap_dom_element *elt);
// soap_elt_is_true
// file dom.c line 1751
signed int soap_elt_is_true(struct soap_dom_element *elt);
// soap_elt_len
// file dom.c line 1980
unsigned long int soap_elt_len(struct soap_dom_element *elt);
// soap_elt_match
// file dom.c line 1664
signed int soap_elt_match(struct soap_dom_element *elt, const char *ns, const char *patt);
// soap_elt_match_w
// file dom.c line 1689
signed int soap_elt_match_w(struct soap_dom_element *elt, const char *ns, const signed int *patt);
// soap_elt_new
// file dom.c line 1112
struct soap_dom_element * soap_elt_new(struct soap *soap, const char *ns, const char *tag);
// soap_elt_new_w
// file dom.c line 1129
struct soap_dom_element * soap_elt_new_w(struct soap *soap, const char *ns, const signed int *tag);
// soap_elt_next
// file dom.c line 2577
struct soap_dom_element * soap_elt_next(struct soap_dom_element *elt);
// soap_elt_node
// file dom.c line 1613
struct soap_dom_element * soap_elt_node(struct soap_dom_element *elt, const void *node, signed int type);
// soap_elt_nth
// file dom.c line 2002
unsigned long int soap_elt_nth(struct soap_dom_element *elt);
// soap_elt_parent
// file dom.c line 1919
struct soap_dom_element * soap_elt_parent(struct soap_dom_element *elt);
// soap_elt_set
// file dom.c line 1146
struct soap_dom_element * soap_elt_set(struct soap_dom_element *elt, const char *ns, const char *tag);
// soap_elt_set_w
// file dom.c line 1173
struct soap_dom_element * soap_elt_set_w(struct soap_dom_element *elt, const char *ns, const signed int *tag);
// soap_elt_size
// file dom.c line 2956
unsigned long int soap_elt_size(struct soap_dom_element *elt, const char *ns, const char *patt);
// soap_elt_size_type
// file dom.c line 2974
unsigned long int soap_elt_size_type(struct soap_dom_element *elt, const char *ns, const char *patt, signed int type);
// soap_elt_text
// file dom.c line 1576
struct soap_dom_element * soap_elt_text(struct soap_dom_element *elt, const char *text);
// soap_elt_text_w
// file dom.c line 1594
struct soap_dom_element * soap_elt_text_w(struct soap_dom_element *elt, const signed int *text);
// soap_elt_w
// file dom.c line 1282
struct soap_dom_element * soap_elt_w(struct soap_dom_element *elt, const char *ns, const signed int *tag);
// soap_embed
// file stdsoap2.c line 7509
signed int soap_embed(struct soap *soap, const void *p, const void *a, signed int n, signed int t);
// soap_embedded
// file ../../../gsoap/stdsoap2.h line 2977
void soap_embedded(struct soap *soap, const void *p, signed int t);
// soap_embedded_id
// file ../../../gsoap/stdsoap2.h line 2980
signed int soap_embedded_id(struct soap *soap, signed int id, const void *p, signed int t);
// soap_encode_url
// file stdsoap2.c line 6653
unsigned long int soap_encode_url(const char *s, char *t, unsigned long int len);
// soap_encode_url_string
// file stdsoap2.c line 6680
const char * soap_encode_url_string(struct soap *soap, const char *s);
// soap_end
// file ../../../gsoap/stdsoap2.h line 3052
void soap_end(struct soap *soap);
// soap_end_block
// file ../../../gsoap/stdsoap2.h line 3132
void soap_end_block(struct soap *soap, struct soap_blist *b);
// soap_end_count
// file stdsoap2.c line 7695
signed int soap_end_count(struct soap *soap);
// soap_end_recv
// file ../../../gsoap/stdsoap2.h line 3006
signed int soap_end_recv(struct soap *soap);
// soap_end_send
// file ../../../gsoap/stdsoap2.h line 2994
signed int soap_end_send(struct soap *soap);
// soap_end_send_flush
// file stdsoap2.c line 8936
signed int soap_end_send_flush(struct soap *soap);
// soap_end_shaky
// file stdsoap2.c line 8603
void soap_end_shaky(struct soap *soap, signed short int f);
// soap_enter
// file stdsoap2.c line 8153
struct soap_ilist * soap_enter(struct soap *soap, const char *id, signed int t, unsigned long int n);
// soap_envelope_begin_in
// file stdsoap2.c line 16923
signed int soap_envelope_begin_in(struct soap *soap);
// soap_envelope_begin_out
// file stdsoap2.c line 16768
signed int soap_envelope_begin_out(struct soap *soap);
// soap_envelope_end_in
// file stdsoap2.c line 16948
signed int soap_envelope_end_in(struct soap *soap);
// soap_envelope_end_out
// file stdsoap2.c line 16813
signed int soap_envelope_end_out(struct soap *soap);
// soap_fault
// file soapC.c line 63
void soap_fault(struct soap *soap);
// soap_faultcode
// file soapC.c line 99
const char ** soap_faultcode(struct soap *soap);
// soap_faultdetail
// file soapC.c line 139
const char ** soap_faultdetail(struct soap *soap);
// soap_faultstring
// file soapC.c line 131
const char ** soap_faultstring(struct soap *soap);
// soap_faultsubcode
// file soapC.c line 107
const char ** soap_faultsubcode(struct soap *soap);
// soap_first_block
// file ../../../gsoap/stdsoap2.h line 3128
char * soap_first_block(struct soap *soap, struct soap_blist *b);
// soap_float2s
// file stdsoap2.c line 13362
const char * soap_float2s(struct soap *soap, float n);
// soap_flush
// file ../../../gsoap/stdsoap2.h line 2935
signed int soap_flush(struct soap *soap);
// soap_flush_raw
// file stdsoap2.c line 852
signed int soap_flush_raw(struct soap *soap, const char *s, unsigned long int n);
// soap_force_closesock
// file stdsoap2.c line 5668
signed int soap_force_closesock(struct soap *soap);
// soap_free
// file ../../../gsoap/stdsoap2.h line 3042
void soap_free(struct soap *soap);
// soap_free_iht
// file stdsoap2.c line 8109
static void soap_free_iht(struct soap *soap);
// soap_free_ns
// file stdsoap2.c line 9226
static void soap_free_ns(struct soap *soap);
// soap_free_pht
// file stdsoap2.c line 7487
static void soap_free_pht(struct soap *soap);
// soap_free_stream
// file stdsoap2.c line 9610
void soap_free_stream(struct soap *soap);
// soap_free_temp
// file stdsoap2.c line 9175
void soap_free_temp(struct soap *soap);
// soap_get
// file stdsoap2.c line 1611
signed int soap_get(struct soap *soap);
// soap_get_PointerToSOAP_ENV__Code
// file soapC.c line 1288
struct SOAP_ENV__Code ** soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type);
// soap_get_PointerToSOAP_ENV__Detail
// file soapC.c line 1227
struct SOAP_ENV__Detail ** soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type);
// soap_get_PointerToSOAP_ENV__Reason
// file soapC.c line 1169
struct SOAP_ENV__Reason ** soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type);
// soap_get_PointerTot__Routing
// file soapC.c line 1344
struct t__Routing ** soap_get_PointerTot__Routing(struct soap *soap, struct t__Routing **p, const char *tag, const char *type);
// soap_get_SOAP_ENV__Code
// file soapC.c line 829
struct SOAP_ENV__Code * soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type);
// soap_get_SOAP_ENV__Detail
// file soapC.c line 739
struct SOAP_ENV__Detail * soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type);
// soap_get_SOAP_ENV__Fault
// file soapC.c line 570
struct SOAP_ENV__Fault * soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type);
// soap_get_SOAP_ENV__Header
// file soapC.c line 898
struct SOAP_ENV__Header * soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type);
// soap_get_SOAP_ENV__Reason
// file soapC.c line 651
struct SOAP_ENV__Reason * soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type);
// soap_get__QName
// file soapC.c line 1378
char ** soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type);
// soap_get_byte
// file soapC.c line 376
char * soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type);
// soap_get_header_attribute
// file stdsoap2.c line 6218
const char * soap_get_header_attribute(struct soap *soap, const char *line, const char *key);
// soap_get_http_body
// file stdsoap2.c line 16851
char * soap_get_http_body(struct soap *soap, unsigned long int *len);
// soap_get_int
// file soapC.c line 412
signed int * soap_get_int(struct soap *soap, signed int *p, const char *tag, const char *type);
// soap_get_mime_attachment
// file stdsoap2.c line 15911
struct soap_multipart * soap_get_mime_attachment(struct soap *soap, void *handle);
// soap_get_pi
// file stdsoap2.c line 1708
static signed int soap_get_pi(struct soap *soap);
// soap_get_string
// file soapC.c line 1422
char ** soap_get_string(struct soap *soap, char **p, const char *tag, const char *type);
// soap_get_t__Routing
// file soapC.c line 1113
struct t__Routing * soap_get_t__Routing(struct soap *soap, struct t__Routing *p, const char *tag, const char *type);
// soap_get_t__RoutingTable
// file soapH.h line 202
struct t__RoutingTable * soap_get_t__RoutingTable(struct soap *soap, struct t__RoutingTable *p, const char *tag, const char *type);
// soap_get_version
// file stdsoap2.c line 10049
void soap_get_version(struct soap *soap);
// soap_getattrval
// file stdsoap2.c line 11419
static signed int soap_getattrval(struct soap *soap, char *s, unsigned long int *n, signed int d);
// soap_getbase64
// file stdsoap2.c line 2046
unsigned char * soap_getbase64(struct soap *soap, signed int *n, signed int malloc_flag);
// soap_getchar
// file stdsoap2.c line 1421
signed int soap_getchar(struct soap *soap);
// soap_getchunkchar
// file stdsoap2.c line 1094
static signed int soap_getchunkchar(struct soap *soap);
// soap_getdime
// file stdsoap2.c line 15684
signed int soap_getdime(struct soap *soap);
// soap_getdimefield
// file stdsoap2.c line 15598
static char * soap_getdimefield(struct soap *soap, unsigned long int n);
// soap_getdimehdr
// file stdsoap2.c line 15633
signed int soap_getdimehdr(struct soap *soap);
// soap_getelement
// file soapC.c line 184
void * soap_getelement(struct soap *soap, signed int *type);
// soap_getfault
// file soapC.c line 94
signed int soap_getfault(struct soap *soap);
// soap_getheader
// file soapC.c line 30
signed int soap_getheader(struct soap *soap);
// soap_gethex
// file stdsoap2.c line 1910
unsigned char * soap_gethex(struct soap *soap, signed int *n);
// soap_getindependent
// file soapC.c line 169
signed int soap_getindependent(struct soap *soap);
// soap_getline
// file ../../../gsoap/stdsoap2.h line 3003
signed int soap_getline(struct soap *soap, char *buf, signed int len);
// soap_getmime
// file stdsoap2.c line 15868
signed int soap_getmime(struct soap *soap);
// soap_getmimehdr
// file stdsoap2.c line 15804
signed int soap_getmimehdr(struct soap *soap);
// soap_getoffsets
// file stdsoap2.c line 2865
signed int soap_getoffsets(const char *attr, const signed int *size, signed int *offset, signed int dim);
// soap_getposition
// file stdsoap2.c line 2893
signed int soap_getposition(const char *attr, signed int *pos);
// soap_getsizes
// file stdsoap2.c line 2840
unsigned long int soap_getsizes(const char *attr, signed int *size, signed int dim);
// soap_getutf8
// file stdsoap2.c line 1831
signed int soap_getutf8(struct soap *soap);
// soap_has_copies
// file stdsoap2.c line 2474
static signed int soap_has_copies(struct soap *soap, const char *start, const char *end);
// soap_hash
// file stdsoap2.c line 7416
unsigned long int soap_hash(const char *s);
// soap_header
// file soapC.c line 55
void soap_header(struct soap *soap);
// soap_hex2s
// file stdsoap2.c line 17473
const char * soap_hex2s(struct soap *soap, const char *s, char *t, unsigned long int l, signed int *n);
// soap_id_enter
// file ../../../gsoap/stdsoap2.h line 3026
void * soap_id_enter(struct soap *soap, const char *id, void *p, signed int t, unsigned long int n, const char *type, const char *arrayType, void * (*finstantiate)(struct soap *, signed int, const char *, const char *, unsigned long int *), signed int (*fbase)(signed int, signed int));
// soap_id_enter::fbase_object
//
signed int fbase_object(signed int, signed int);
// soap_id_enter::finstantiate_object
//
void * finstantiate_object(struct soap *, signed int, const char *, const char *, unsigned long int *);
// soap_id_forward
// file ../../../gsoap/stdsoap2.h line 3023
void * soap_id_forward(struct soap *soap, const char *href, void *p, unsigned long int i, signed int t, signed int tt, unsigned long int n, unsigned int k, void (*finsert)(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **), signed int (*fbase)(signed int, signed int));
// soap_id_forward::fbase_object
//
signed int fbase_object(signed int, signed int);
// soap_id_forward::finsert_object
//
void finsert_object(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **);
// soap_id_lookup
// file ../../../gsoap/stdsoap2.h line 3022
void * soap_id_lookup(struct soap *soap, const char *id, void **p, signed int t, unsigned long int n, unsigned int k, signed int (*fbase)(signed int, signed int));
// soap_id_lookup::fbase_object
//
signed int fbase_object(signed int, signed int);
// soap_id_nullify
// file stdsoap2.c line 8879
signed int soap_id_nullify(struct soap *soap, const char *id);
// soap_id_smart
// file stdsoap2.c line 8837
void ** soap_id_smart(struct soap *soap, const char *id, signed int t, unsigned long int n);
// soap_ignore_element
// file soapC.c line 257
signed int soap_ignore_element(struct soap *soap);
// soap_inLONG64
// file stdsoap2.c line 13168
signed long int * soap_inLONG64(struct soap *soap, const char *tag, signed long int *p, const char *type, signed int t);
// soap_inULONG64
// file stdsoap2.c line 14044
unsigned long int * soap_inULONG64(struct soap *soap, const char *tag, unsigned long int *p, const char *type, signed int t);
// soap_in_PointerToSOAP_ENV__Code
// file soapC.c line 1259
struct SOAP_ENV__Code ** soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type);
// soap_in_PointerToSOAP_ENV__Detail
// file soapC.c line 1198
struct SOAP_ENV__Detail ** soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type);
// soap_in_PointerToSOAP_ENV__Reason
// file soapC.c line 1140
struct SOAP_ENV__Reason ** soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type);
// soap_in_PointerTot__Routing
// file soapC.c line 1315
struct t__Routing ** soap_in_PointerTot__Routing(struct soap *soap, const char *tag, struct t__Routing **a, const char *type);
// soap_in_SOAP_ENV__Code
// file soapC.c line 780
struct SOAP_ENV__Code * soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type);
// soap_in_SOAP_ENV__Detail
// file soapC.c line 690
struct SOAP_ENV__Detail * soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type);
// soap_in_SOAP_ENV__Fault
// file soapC.c line 479
struct SOAP_ENV__Fault * soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type);
// soap_in_SOAP_ENV__Header
// file soapC.c line 861
struct SOAP_ENV__Header * soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type);
// soap_in_SOAP_ENV__Reason
// file soapC.c line 608
struct SOAP_ENV__Reason * soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type);
// soap_in__QName
// file soapC.c line 1365
char ** soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type);
// soap_in_byte
// file soapC.c line 363
char * soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type);
// soap_in_int
// file soapC.c line 399
signed int * soap_in_int(struct soap *soap, const char *tag, signed int *a, const char *type);
// soap_in_string
// file soapC.c line 1409
char ** soap_in_string(struct soap *soap, const char *tag, char **a, const char *type);
// soap_in_t__Routing
// file soapC.c line 1052
struct t__Routing * soap_in_t__Routing(struct soap *soap, const char *tag, struct t__Routing *a, const char *type);
// soap_in_t__RoutingTable
// file soapC.c line 944
struct t__RoutingTable * soap_in_t__RoutingTable(struct soap *soap, const char *tag, struct t__RoutingTable *a, const char *type);
// soap_in_xsd__anyAttribute
// file dom.c line 671
struct soap_dom_attribute * soap_in_xsd__anyAttribute(struct soap *soap, const char *tag, struct soap_dom_attribute *node, const char *type);
// soap_in_xsd__anyType
// file dom.c line 516
struct soap_dom_element * soap_in_xsd__anyType(struct soap *soap, const char *tag, struct soap_dom_element *node, const char *type);
// soap_inbyte
// file ../../../gsoap/stdsoap2.h line 3225
char * soap_inbyte(struct soap *soap, const char *tag, char *p, const char *type, signed int t);
// soap_indateTime
// file stdsoap2.c line 15087
signed long int * soap_indateTime(struct soap *soap, const char *tag, signed long int *p, const char *type, signed int t);
// soap_indouble
// file stdsoap2.c line 13626
double * soap_indouble(struct soap *soap, const char *tag, double *p, const char *type, signed int t);
// soap_infloat
// file stdsoap2.c line 13502
float * soap_infloat(struct soap *soap, const char *tag, float *p, const char *type, signed int t);
// soap_inint
// file ../../../gsoap/stdsoap2.h line 3224
signed int * soap_inint(struct soap *soap, const char *tag, signed int *p, const char *type, signed int t);
// soap_init_REQUIRE_lib_v20828
// file ../../../gsoap/stdsoap2.h line 3047
void soap_init_REQUIRE_lib_v20828(struct soap *soap, signed int imode, signed int omode);
// soap_init_iht
// file stdsoap2.c line 8096
static void soap_init_iht(struct soap *soap);
// soap_init_logs
// file stdsoap2.c line 9242
static void soap_init_logs(struct soap *soap);
// soap_init_pht
// file stdsoap2.c line 7428
static void soap_init_pht(struct soap *soap);
// soap_initialize
// file stdsoap2.c line 9645
void soap_initialize(struct soap *soap);
// soap_inliteral
// file ../../../gsoap/stdsoap2.h line 3237
char ** soap_inliteral(struct soap *soap, const char *tag, char **p);
// soap_inlong
// file stdsoap2.c line 13075
signed long int * soap_inlong(struct soap *soap, const char *tag, signed long int *p, const char *type, signed int t);
// soap_inshort
// file stdsoap2.c line 13328
signed short int * soap_inshort(struct soap *soap, const char *tag, signed short int *p, const char *type, signed int t);
// soap_instring
// file ../../../gsoap/stdsoap2.h line 3236
char ** soap_instring(struct soap *soap, const char *tag, char **p, const char *type, signed int t, signed int flag, signed long int minlen, signed long int maxlen, const char *pattern);
// soap_int2s
// file stdsoap2.c line 12928
const char * soap_int2s(struct soap *soap, signed int n);
// soap_inunsignedByte
// file stdsoap2.c line 13698
unsigned char * soap_inunsignedByte(struct soap *soap, const char *tag, unsigned char *p, const char *type, signed int t);
// soap_inunsignedInt
// file stdsoap2.c line 13862
unsigned int * soap_inunsignedInt(struct soap *soap, const char *tag, unsigned int *p, const char *type, signed int t);
// soap_inunsignedLong
// file stdsoap2.c line 13951
unsigned long int * soap_inunsignedLong(struct soap *soap, const char *tag, unsigned long int *p, const char *type, signed int t);
// soap_inunsignedShort
// file stdsoap2.c line 13775
unsigned short int * soap_inunsignedShort(struct soap *soap, const char *tag, unsigned short int *p, const char *type, signed int t);
// soap_inwliteral
// file stdsoap2.c line 15241
signed int ** soap_inwliteral(struct soap *soap, const char *tag, signed int **p);
// soap_inwstring
// file stdsoap2.c line 14701
signed int ** soap_inwstring(struct soap *soap, const char *tag, signed int **p, const char *type, signed int t, signed long int minlen, signed long int maxlen, const char *pattern);
// soap_is_embedded
// file stdsoap2.c line 7960
signed int soap_is_embedded(struct soap *soap, struct soap_plist *pp);
// soap_is_shaky
// file stdsoap2.c line 8613
static signed int soap_is_shaky(struct soap *soap, void *p);
// soap_is_single
// file stdsoap2.c line 7983
signed int soap_is_single(struct soap *soap, struct soap_plist *pp);
// soap_isnumeric
// file stdsoap2.c line 13470
static signed int soap_isnumeric(struct soap *soap, const char *type);
// soap_isxdigit
// file stdsoap2.c line 1112
static signed int soap_isxdigit(signed int c);
// soap_link
// file stdsoap2.c line 8507
struct soap_clist * soap_link(struct soap *soap, void *p, signed int t, signed int n, signed int (*fdelete)(struct soap_clist *));
// soap_link::fdelete_object
//
signed int fdelete_object(struct soap_clist *);
// soap_long2s
// file stdsoap2.c line 13021
const char * soap_long2s(struct soap *soap, signed long int n);
// soap_lookup
// file stdsoap2.c line 8136
struct soap_ilist * soap_lookup(struct soap *soap, const char *id);
// soap_lookup_ns
// file stdsoap2.c line 10199
struct soap_nlist * soap_lookup_ns(struct soap *soap, const char *tag, unsigned long int n);
// soap_lookup_plugin
// file stdsoap2.c line 18380
void * soap_lookup_plugin(struct soap *soap, const char *id);
// soap_lookup_type
// file ../../../gsoap/stdsoap2.h line 3019
signed int soap_lookup_type(struct soap *soap, const char *id);
// soap_malloc
// file ../../../gsoap/stdsoap2.h line 3008
void * soap_malloc(struct soap *soap, unsigned long int n);
// soap_mark_cycle
// file stdsoap2.c line 11026
signed int soap_mark_cycle(struct soap *soap, struct soap_plist *pp);
// soap_mark_dup
// file stdsoap2.c line 11038
void soap_mark_dup(struct soap *soap, void *a, struct soap_plist *pp);
// soap_mark_lookup
// file stdsoap2.c line 10994
void * soap_mark_lookup(struct soap *soap, const void *p, signed int t, struct soap_plist **ppp, char **mark);
// soap_markelement
// file soapC.c line 324
void soap_markelement(struct soap *soap, const void *ptr, signed int type);
// soap_match_array
// file stdsoap2.c line 3152
signed int soap_match_array(struct soap *soap, const char *type);
// soap_match_cid
// file stdsoap2.c line 16035
signed int soap_match_cid(struct soap *soap, const char *s, const char *t);
// soap_match_namespace
// file stdsoap2.c line 2992
signed int soap_match_namespace(struct soap *soap, const char *id1, const char *id2, unsigned long int n1, unsigned long int n2);
// soap_match_tag
// file ../../../gsoap/stdsoap2.h line 3066
signed int soap_match_tag(struct soap *soap, const char *tag1, const char *tag2);
// soap_memdup
// file stdsoap2.c line 2243
void * soap_memdup(struct soap *soap, const void *s, unsigned long int n);
// soap_move
// file stdsoap2.c line 1752
signed int soap_move(struct soap *soap, unsigned long int n);
// soap_name_match
// file dom.c line 1030
static signed int soap_name_match(const char *name, const char *patt);
// soap_new_REQUIRE_lib_v20828
// file stdsoap2.c line 7443
struct soap * soap_new_REQUIRE_lib_v20828(signed int imode, signed int omode);
// soap_new_block
// file ../../../gsoap/stdsoap2.h line 3124
struct soap_blist * soap_new_block(struct soap *soap);
// soap_new_multipart
// file stdsoap2.c line 16253
static struct soap_multipart * soap_new_multipart(struct soap *soap, struct soap_multipart **first, struct soap_multipart **last, char *ptr, unsigned long int size);
// soap_next_block
// file ../../../gsoap/stdsoap2.h line 3129
char * soap_next_block(struct soap *soap, struct soap_blist *b);
// soap_next_multipart
// file stdsoap2.c line 16325
struct soap_multipart * soap_next_multipart(struct soap_multipart *content);
// soap_ns_to_find
// file dom.c line 973
static const char * soap_ns_to_find(struct soap *soap, const char *tag);
// soap_ns_to_get
// file dom.c line 953
static const char * soap_ns_to_get(struct soap *soap, const char *tag);
// soap_ns_to_set
// file dom.c line 933
static const char * soap_ns_to_set(struct soap *soap, const char *tag);
// soap_nth
// file dom.c line 1358
struct soap_dom_element * soap_nth(struct soap_dom_element *elt, unsigned long int n);
// soap_nth_elt
// file dom.c line 1324
struct soap_dom_element * soap_nth_elt(struct soap_dom_element *elt, const char *ns, const char *tag, unsigned long int n);
// soap_nth_elt_w
// file dom.c line 1342
struct soap_dom_element * soap_nth_elt_w(struct soap_dom_element *elt, const char *ns, const signed int *tag, unsigned long int n);
// soap_open_logfile
// file stdsoap2.c line 9258
void soap_open_logfile(struct soap *soap, signed int i);
// soap_outLONG64
// file stdsoap2.c line 13122
signed int soap_outLONG64(struct soap *soap, const char *tag, signed int id, const signed long int *p, const char *type, signed int n);
// soap_outULONG64
// file stdsoap2.c line 13998
signed int soap_outULONG64(struct soap *soap, const char *tag, signed int id, const unsigned long int *p, const char *type, signed int n);
// soap_out_PointerToSOAP_ENV__Code
// file soapC.c line 1248
signed int soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, signed int id, struct SOAP_ENV__Code * const *a, const char *type);
// soap_out_PointerToSOAP_ENV__Detail
// file soapC.c line 1190
signed int soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, signed int id, struct SOAP_ENV__Detail * const *a, const char *type);
// soap_out_PointerToSOAP_ENV__Reason
// file soapC.c line 1132
signed int soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, signed int id, struct SOAP_ENV__Reason * const *a, const char *type);
// soap_out_PointerTot__Routing
// file soapC.c line 1307
signed int soap_out_PointerTot__Routing(struct soap *soap, const char *tag, signed int id, struct t__Routing * const *a, const char *type);
// soap_out_SOAP_ENV__Code
// file soapC.c line 767
signed int soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, signed int id, struct SOAP_ENV__Code *a, const char *type);
// soap_out_SOAP_ENV__Detail
// file soapC.c line 679
signed int soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, signed int id, struct SOAP_ENV__Detail *a, const char *type);
// soap_out_SOAP_ENV__Fault
// file soapC.c line 452
signed int soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, signed int id, struct SOAP_ENV__Fault *a, const char *type);
// soap_out_SOAP_ENV__Header
// file soapC.c line 853
signed int soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, signed int id, struct SOAP_ENV__Header *a, const char *type);
// soap_out_SOAP_ENV__Reason
// file soapC.c line 596
signed int soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, signed int id, struct SOAP_ENV__Reason *a, const char *type);
// soap_out__QName
// file soapC.c line 1360
signed int soap_out__QName(struct soap *soap, const char *tag, signed int id, char * const *a, const char *type);
// soap_out_byte
// file soapC.c line 358
signed int soap_out_byte(struct soap *soap, const char *tag, signed int id, const char *a, const char *type);
// soap_out_int
// file soapC.c line 394
signed int soap_out_int(struct soap *soap, const char *tag, signed int id, const signed int *a, const char *type);
// soap_out_string
// file soapC.c line 1404
signed int soap_out_string(struct soap *soap, const char *tag, signed int id, char * const *a, const char *type);
// soap_out_t__Routing
// file soapC.c line 1036
signed int soap_out_t__Routing(struct soap *soap, const char *tag, signed int id, struct t__Routing *a, const char *type);
// soap_out_t__RoutingTable
// file soapC.c line 930
signed int soap_out_t__RoutingTable(struct soap *soap, const char *tag, signed int id, struct t__RoutingTable *a, const char *type);
// soap_out_xsd__anyAttribute
// file dom.c line 456
signed int soap_out_xsd__anyAttribute(struct soap *soap, const char *tag, signed int id, struct soap_dom_attribute *node, const char *type);
// soap_out_xsd__anyType
// file dom.c line 304
signed int soap_out_xsd__anyType(struct soap *soap, const char *tag, signed int id, struct soap_dom_element *node, const char *type);
// soap_outbyte
// file ../../../gsoap/stdsoap2.h line 3249
signed int soap_outbyte(struct soap *soap, const char *tag, signed int id, const char *p, const char *type, signed int n);
// soap_outdateTime
// file stdsoap2.c line 14960
signed int soap_outdateTime(struct soap *soap, const char *tag, signed int id, const signed long int *p, const char *type, signed int n);
// soap_outdouble
// file stdsoap2.c line 13563
signed int soap_outdouble(struct soap *soap, const char *tag, signed int id, const double *p, const char *type, signed int n);
// soap_outfloat
// file stdsoap2.c line 13395
signed int soap_outfloat(struct soap *soap, const char *tag, signed int id, const float *p, const char *type, signed int n);
// soap_outint
// file ../../../gsoap/stdsoap2.h line 3251
signed int soap_outint(struct soap *soap, const char *tag, signed int id, const signed int *p, const char *type, signed int n);
// soap_outliteral
// file ../../../gsoap/stdsoap2.h line 3262
signed int soap_outliteral(struct soap *soap, const char *tag, char * const *p, const char *type);
// soap_outlong
// file stdsoap2.c line 13033
signed int soap_outlong(struct soap *soap, const char *tag, signed int id, const signed long int *p, const char *type, signed int n);
// soap_outshort
// file stdsoap2.c line 13295
signed int soap_outshort(struct soap *soap, const char *tag, signed int id, const signed short int *p, const char *type, signed int n);
// soap_outstring
// file ../../../gsoap/stdsoap2.h line 3261
signed int soap_outstring(struct soap *soap, const char *tag, signed int id, char * const *p, const char *type, signed int n);
// soap_outunsignedByte
// file stdsoap2.c line 13665
signed int soap_outunsignedByte(struct soap *soap, const char *tag, signed int id, const unsigned char *p, const char *type, signed int n);
// soap_outunsignedInt
// file stdsoap2.c line 13820
signed int soap_outunsignedInt(struct soap *soap, const char *tag, signed int id, const unsigned int *p, const char *type, signed int n);
// soap_outunsignedLong
// file stdsoap2.c line 13909
signed int soap_outunsignedLong(struct soap *soap, const char *tag, signed int id, const unsigned long int *p, const char *type, signed int n);
// soap_outunsignedShort
// file stdsoap2.c line 13742
signed int soap_outunsignedShort(struct soap *soap, const char *tag, signed int id, const unsigned short int *p, const char *type, signed int n);
// soap_outwliteral
// file stdsoap2.c line 15195
signed int soap_outwliteral(struct soap *soap, const char *tag, signed int * const *p, const char *type);
// soap_outwstring
// file stdsoap2.c line 14679
signed int soap_outwstring(struct soap *soap, const char *tag, signed int id, signed int * const *p, const char *type, signed int n);
// soap_patt_match
// file dom.c line 1014
static signed int soap_patt_match(const char *name, const char *patt);
// soap_peek_element
// file ../../../gsoap/stdsoap2.h line 3088
signed int soap_peek_element(struct soap *soap);
// soap_pointer_enter
// file stdsoap2.c line 7560
signed int soap_pointer_enter(struct soap *soap, const void *p, const void *a, signed int n, signed int type, struct soap_plist **ppp);
// soap_pointer_lookup
// file stdsoap2.c line 7537
signed int soap_pointer_lookup(struct soap *soap, const void *p, signed int type, struct soap_plist **ppp);
// soap_poll
// file stdsoap2.c line 5427
signed int soap_poll(struct soap *soap);
// soap_pop_block
// file ../../../gsoap/stdsoap2.h line 3126
void soap_pop_block(struct soap *soap, struct soap_blist *b);
// soap_pop_namespace
// file stdsoap2.c line 2975
void soap_pop_namespace(struct soap *soap);
// soap_post_check_mime_attachments
// file stdsoap2.c line 15883
void soap_post_check_mime_attachments(struct soap *soap);
// soap_prefix_of
// file dom.c line 921
static const char * soap_prefix_of(struct soap *soap, const char *ns);
// soap_print_fault
// file ../../../gsoap/stdsoap2.h line 3160
void soap_print_fault(struct soap *soap, struct _IO_FILE *fd);
// soap_print_fault_location
// file stdsoap2.c line 18303
void soap_print_fault_location(struct soap *soap, struct _IO_FILE *fd);
// soap_push_block
// file ../../../gsoap/stdsoap2.h line 3125
void * soap_push_block(struct soap *soap, struct soap_blist *b, unsigned long int n);
// soap_push_namespace
// file stdsoap2.c line 2916
struct soap_nlist * soap_push_namespace(struct soap *soap, const char *id, const char *ns);
// soap_push_ns
// file stdsoap2.c line 10212
static struct soap_nlist * soap_push_ns(struct soap *soap, const char *id, const char *ns, signed short int utilized);
// soap_push_prefix
// file dom.c line 817
static const char * soap_push_prefix(struct soap *soap, const char *id, unsigned long int n, const char *ns, signed int isearly, signed int iselement);
// soap_put_PointerToSOAP_ENV__Code
// file soapC.c line 1281
signed int soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code * const *a, const char *tag, const char *type);
// soap_put_PointerToSOAP_ENV__Detail
// file soapC.c line 1220
signed int soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail * const *a, const char *tag, const char *type);
// soap_put_PointerToSOAP_ENV__Reason
// file soapC.c line 1162
signed int soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason * const *a, const char *tag, const char *type);
// soap_put_PointerTot__Routing
// file soapC.c line 1337
signed int soap_put_PointerTot__Routing(struct soap *soap, struct t__Routing * const *a, const char *tag, const char *type);
// soap_put_SOAP_ENV__Code
// file soapC.c line 822
signed int soap_put_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a, const char *tag, const char *type);
// soap_put_SOAP_ENV__Detail
// file soapC.c line 732
signed int soap_put_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a, const char *tag, const char *type);
// soap_put_SOAP_ENV__Fault
// file soapC.c line 563
signed int soap_put_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a, const char *tag, const char *type);
// soap_put_SOAP_ENV__Header
// file soapC.c line 891
signed int soap_put_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a, const char *tag, const char *type);
// soap_put_SOAP_ENV__Reason
// file soapC.c line 644
signed int soap_put_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a, const char *tag, const char *type);
// soap_put__QName
// file soapC.c line 1371
signed int soap_put__QName(struct soap *soap, char * const *a, const char *tag, const char *type);
// soap_put_byte
// file soapC.c line 369
signed int soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type);
// soap_put_int
// file soapC.c line 405
signed int soap_put_int(struct soap *soap, const signed int *a, const char *tag, const char *type);
// soap_put_string
// file soapC.c line 1415
signed int soap_put_string(struct soap *soap, char * const *a, const char *tag, const char *type);
// soap_put_t__Routing
// file soapC.c line 1106
signed int soap_put_t__Routing(struct soap *soap, struct t__Routing *a, const char *tag, const char *type);
// soap_put_t__RoutingTable
// file soapC.c line 1001
signed int soap_put_t__RoutingTable(struct soap *soap, struct t__RoutingTable *a, const char *tag, const char *type);
// soap_putbase64
// file stdsoap2.c line 2001
signed int soap_putbase64(struct soap *soap, const unsigned char *s, signed int n);
// soap_putdime
// file stdsoap2.c line 15511
signed int soap_putdime(struct soap *soap);
// soap_putdimefield
// file stdsoap2.c line 15425
static signed int soap_putdimefield(struct soap *soap, const char *s, unsigned long int n);
// soap_putdimehdr
// file stdsoap2.c line 15466
signed int soap_putdimehdr(struct soap *soap);
// soap_putelement
// file soapC.c line 301
signed int soap_putelement(struct soap *soap, const void *ptr, const char *tag, signed int id, signed int type);
// soap_putfault
// file soapC.c line 87
signed int soap_putfault(struct soap *soap);
// soap_putheader
// file soapC.c line 38
signed int soap_putheader(struct soap *soap);
// soap_puthex
// file stdsoap2.c line 1882
signed int soap_puthex(struct soap *soap, const unsigned char *s, signed int n);
// soap_puthttphdr
// file stdsoap2.c line 17515
signed int soap_puthttphdr(struct soap *soap, signed int status, unsigned long int count);
// soap_putindependent
// file soapC.c line 288
signed int soap_putindependent(struct soap *soap);
// soap_putmime
// file stdsoap2.c line 16124
signed int soap_putmime(struct soap *soap);
// soap_putmimehdr
// file stdsoap2.c line 16096
signed int soap_putmimehdr(struct soap *soap, struct soap_multipart *content);
// soap_putoffsets
// file stdsoap2.c line 2798
char * soap_putoffsets(struct soap *soap, const signed int *offset, signed int dim);
// soap_putsizesoffsets
// file stdsoap2.c line 2766
char * soap_putsizesoffsets(struct soap *soap, const char *type, const signed int *size, const signed int *offset, signed int dim);
// soap_pututf8
// file stdsoap2.c line 1781
signed int soap_pututf8(struct soap *soap, unsigned long int c);
// soap_receiver_fault
// file stdsoap2.c line 18191
signed int soap_receiver_fault(struct soap *soap, const char *faultstring, const char *faultdetailXML);
// soap_receiver_fault_subcode
// file stdsoap2.c line 18202
signed int soap_receiver_fault_subcode(struct soap *soap, const char *faultsubcodeQName, const char *faultstring, const char *faultdetailXML);
// soap_recv
// file ../../../gsoap/stdsoap2.h line 2949
signed int soap_recv(struct soap *soap);
// soap_recv_empty_response
// file stdsoap2.c line 18005
signed int soap_recv_empty_response(struct soap *soap);
// soap_recv_fault
// file stdsoap2.c line 17925
signed int soap_recv_fault(struct soap *soap, signed int check);
// soap_recv_header
// file stdsoap2.c line 17032
signed int soap_recv_header(struct soap *soap);
// soap_recv_raw
// file ../../../gsoap/stdsoap2.h line 2948
signed int soap_recv_raw(struct soap *soap);
// soap_reference
// file ../../../gsoap/stdsoap2.h line 2978
signed int soap_reference(struct soap *soap, const void *p, signed int t);
// soap_register_plugin_arg
// file stdsoap2.c line 18339
signed int soap_register_plugin_arg(struct soap *soap, signed int (*fcreate)(struct soap *, struct soap_plugin *, void *), void *arg);
// soap_register_plugin_arg::fcreate_object
//
signed int fcreate_object(struct soap *, struct soap_plugin *, void *);
// soap_resolve
// file stdsoap2.c line 2501
signed int soap_resolve(struct soap *soap);
// soap_resolve_attachment
// file stdsoap2.c line 16063
static void soap_resolve_attachment(struct soap *soap, struct soap_multipart *content);
// soap_response
// file stdsoap2.c line 6603
signed int soap_response(struct soap *soap, signed int status);
// soap_retry
// file stdsoap2.c line 12008
void soap_retry(struct soap *soap);
// soap_revert
// file ../../../gsoap/stdsoap2.h line 3091
void soap_revert(struct soap *soap);
// soap_s2LONG64
// file stdsoap2.c line 13136
signed int soap_s2LONG64(struct soap *soap, const char *s, signed long int *p);
// soap_s2QName
// file stdsoap2.c line 14136
signed int soap_s2QName(struct soap *soap, const char *s, char **t, signed long int minlen, signed long int maxlen);
// soap_s2ULONG64
// file stdsoap2.c line 14012
signed int soap_s2ULONG64(struct soap *soap, const char *s, unsigned long int *p);
// soap_s2base64
// file stdsoap2.c line 17321
char * soap_s2base64(struct soap *soap, const unsigned char *s, char *t, signed int n);
// soap_s2byte
// file stdsoap2.c line 13232
signed int soap_s2byte(struct soap *soap, const char *s, char *p);
// soap_s2dateTime
// file stdsoap2.c line 14974
signed int soap_s2dateTime(struct soap *soap, const char *s, signed long int *p);
// soap_s2double
// file stdsoap2.c line 13577
signed int soap_s2double(struct soap *soap, const char *s, double *p);
// soap_s2float
// file stdsoap2.c line 13409
signed int soap_s2float(struct soap *soap, const char *s, float *p);
// soap_s2hex
// file stdsoap2.c line 17446
char * soap_s2hex(struct soap *soap, const unsigned char *s, char *t, signed int n);
// soap_s2int
// file stdsoap2.c line 12953
signed int soap_s2int(struct soap *soap, const char *s, signed int *p);
// soap_s2long
// file stdsoap2.c line 13047
signed int soap_s2long(struct soap *soap, const char *s, signed long int *p);
// soap_s2short
// file stdsoap2.c line 13309
signed int soap_s2short(struct soap *soap, const char *s, signed short int *p);
// soap_s2string
// file stdsoap2.c line 14078
signed int soap_s2string(struct soap *soap, const char *s, char **t, signed long int minlen, signed long int maxlen);
// soap_s2unsignedByte
// file stdsoap2.c line 13679
signed int soap_s2unsignedByte(struct soap *soap, const char *s, unsigned char *p);
// soap_s2unsignedInt
// file stdsoap2.c line 13834
signed int soap_s2unsignedInt(struct soap *soap, const char *s, unsigned int *p);
// soap_s2unsignedLong
// file stdsoap2.c line 13923
signed int soap_s2unsignedLong(struct soap *soap, const char *s, unsigned long int *p);
// soap_s2unsignedShort
// file stdsoap2.c line 13756
signed int soap_s2unsignedShort(struct soap *soap, const char *s, unsigned short int *p);
// soap_s2wchar
// file stdsoap2.c line 14455
signed int soap_s2wchar(struct soap *soap, const char *s, signed int **t, signed long int minlen, signed long int maxlen);
// soap_save_block
// file ../../../gsoap/stdsoap2.h line 3131
char * soap_save_block(struct soap *soap, struct soap_blist *b, char *p, signed int flag);
// soap_select_mime_boundary
// file stdsoap2.c line 16338
static void soap_select_mime_boundary(struct soap *soap);
// soap_send
// file stdsoap2.c line 882
signed int soap_send(struct soap *soap, const char *s);
// soap_send2
// file stdsoap2.c line 896
signed int soap_send2(struct soap *soap, const char *s1, const char *s2);
// soap_send3
// file stdsoap2.c line 911
signed int soap_send3(struct soap *soap, const char *s1, const char *s2, const char *s3);
// soap_send_empty_response
// file stdsoap2.c line 17982
signed int soap_send_empty_response(struct soap *soap, signed int httpstatuscode);
// soap_send_fault
// file ../../../gsoap/stdsoap2.h line 3156
signed int soap_send_fault(struct soap *soap);
// soap_send_raw
// file ../../../gsoap/stdsoap2.h line 2947
signed int soap_send_raw(struct soap *soap, const char *s, unsigned long int n);
// soap_sender_fault
// file stdsoap2.c line 18169
signed int soap_sender_fault(struct soap *soap, const char *faultstring, const char *faultdetailXML);
// soap_sender_fault_subcode
// file stdsoap2.c line 18180
signed int soap_sender_fault_subcode(struct soap *soap, const char *faultsubcodeQName, const char *faultstring, const char *faultdetailXML);
// soap_serialize_PointerToSOAP_ENV__Code
// file soapC.c line 1239
void soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code * const *a);
// soap_serialize_PointerToSOAP_ENV__Detail
// file soapC.c line 1181
void soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail * const *a);
// soap_serialize_PointerToSOAP_ENV__Reason
// file soapC.c line 1123
void soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason * const *a);
// soap_serialize_PointerTot__Routing
// file soapC.c line 1298
void soap_serialize_PointerTot__Routing(struct soap *soap, struct t__Routing * const *a);
// soap_serialize_SOAP_ENV__Code
// file soapC.c line 758
void soap_serialize_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a);
// soap_serialize_SOAP_ENV__Detail
// file soapC.c line 671
void soap_serialize_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a);
// soap_serialize_SOAP_ENV__Fault
// file soapC.c line 436
void soap_serialize_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a);
// soap_serialize_SOAP_ENV__Header
// file soapC.c line 846
void soap_serialize_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a);
// soap_serialize_SOAP_ENV__Reason
// file soapC.c line 588
void soap_serialize_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a);
// soap_serialize__QName
// file soapC.c line 1352
void soap_serialize__QName(struct soap *soap, char * const *a);
// soap_serialize_string
// file soapC.c line 1396
void soap_serialize_string(struct soap *soap, char * const *a);
// soap_serialize_t__Routing
// file soapC.c line 1025
void soap_serialize_t__Routing(struct soap *soap, struct t__Routing *a);
// soap_serialize_t__RoutingTable
// file soapC.c line 915
void soap_serialize_t__RoutingTable(struct soap *soap, struct t__RoutingTable *a);
// soap_serialize_xsd__anyAttribute
// file dom.c line 152
void soap_serialize_xsd__anyAttribute(struct soap *soap, struct soap_dom_attribute *node);
// soap_serialize_xsd__anyType
// file dom.c line 124
void soap_serialize_xsd__anyType(struct soap *soap, struct soap_dom_element *node);
// soap_serializefault
// file soapC.c line 81
void soap_serializefault(struct soap *soap);
// soap_serializeheader
// file soapC.c line 49
void soap_serializeheader(struct soap *soap);
// soap_set_attr
// file ../../../gsoap/stdsoap2.h line 3302
signed int soap_set_attr(struct soap *soap, const char *name, const char *value, signed int flag);
// soap_set_dime
// file stdsoap2.c line 16191
void soap_set_dime(struct soap *soap);
// soap_set_dime_attachment
// file stdsoap2.c line 16285
signed int soap_set_dime_attachment(struct soap *soap, char *ptr, unsigned long int size, const char *type, const char *id, unsigned short int optype, const char *option);
// soap_set_embedded
// file stdsoap2.c line 8002
void soap_set_embedded(struct soap *soap, struct soap_plist *pp);
// soap_set_endpoint
// file ../../../gsoap/stdsoap2.h line 2933
void soap_set_endpoint(struct soap *soap, const char *endpoint);
// soap_set_error
// file stdsoap2.c line 18111
static signed int soap_set_error(struct soap *soap, const char *faultcode, const char *faultsubcodeQName, const char *faultstring, const char *faultdetailXML, signed int soaperror);
// soap_set_fault
// file stdsoap2.c line 17628
void soap_set_fault(struct soap *soap);
// soap_set_local_namespaces
// file stdsoap2.c line 10136
void soap_set_local_namespaces(struct soap *soap);
// soap_set_mime
// file stdsoap2.c line 16206
void soap_set_mime(struct soap *soap, const char *boundary, const char *start);
// soap_set_mime_attachment
// file stdsoap2.c line 16304
signed int soap_set_mime_attachment(struct soap *soap, char *ptr, unsigned long int size, enum soap_mime_encoding encoding, const char *type, const char *id, const char *location, const char *description);
// soap_set_namespaces
// file stdsoap2.c line 10079
signed int soap_set_namespaces(struct soap *soap, struct Namespace *p);
// soap_set_receiver_error
// file stdsoap2.c line 18142
signed int soap_set_receiver_error(struct soap *soap, const char *faultstring, const char *faultdetailXML, signed int soaperror);
// soap_set_recv_logfile
// file stdsoap2.c line 9315
void soap_set_recv_logfile(struct soap *soap, const char *logfile);
// soap_set_sender_error
// file stdsoap2.c line 18131
signed int soap_set_sender_error(struct soap *soap, const char *faultstring, const char *faultdetailXML, signed int soaperror);
// soap_set_sent_logfile
// file stdsoap2.c line 9328
void soap_set_sent_logfile(struct soap *soap, const char *logfile);
// soap_set_test_logfile
// file stdsoap2.c line 9341
void soap_set_test_logfile(struct soap *soap, const char *logfile);
// soap_set_validation_fault
// file stdsoap2.c line 17611
static const char * soap_set_validation_fault(struct soap *soap, const char *s, const char *t);
// soap_set_version
// file stdsoap2.c line 10023
void soap_set_version(struct soap *soap, signed short int version);
// soap_short2s
// file stdsoap2.c line 13284
const char * soap_short2s(struct soap *soap, signed short int n);
// soap_size
// file stdsoap2.c line 2819
unsigned long int soap_size(const signed int *size, signed int dim);
// soap_size_block
// file stdsoap2.c line 2612
unsigned long int soap_size_block(struct soap *soap, struct soap_blist *b, unsigned long int n);
// soap_sprint_fault
// file stdsoap2.c line 18276
char * soap_sprint_fault(struct soap *soap, char *buf, unsigned long int len);
// soap_store_lab
// file stdsoap2.c line 11538
signed int soap_store_lab(struct soap *soap, const char *s, unsigned long int n);
// soap_strdup
// file stdsoap2.c line 2257
char * soap_strdup(struct soap *soap, const char *s);
// soap_strerror
// file stdsoap2.c line 18042
static const char * soap_strerror(struct soap *soap);
// soap_string
// file stdsoap2.c line 14112
static const char * soap_string(struct soap *soap, const char *s, signed long int minlen, signed long int maxlen);
// soap_string_in
// file stdsoap2.c line 12129
char * soap_string_in(struct soap *soap, signed int flag, signed long int minlen, signed long int maxlen, const char *pattern);
// soap_string_out
// file stdsoap2.c line 12036
signed int soap_string_out(struct soap *soap, const char *s, signed int flag);
// soap_strtrim
// file stdsoap2.c line 2294
char * soap_strtrim(struct soap *soap, char *s);
// soap_tag_cmp
// file ../../../gsoap/stdsoap2.h line 2938
signed int soap_tag_cmp(const char *s, const char *t);
// soap_tag_match
// file dom.c line 998
static signed int soap_tag_match(const char *name, const char *tag);
// soap_tagsearch
// file stdsoap2.c line 10168
const char * soap_tagsearch(const char *big, const char *little);
// soap_tell
// file stdsoap2.c line 1769
unsigned long int soap_tell(struct soap *soap);
// soap_timegm
// file stdsoap2.c line 14831
signed long int soap_timegm(struct tm *T);
// soap_traverse_xsd__anyAttribute
// file dom.c line 160
void soap_traverse_xsd__anyAttribute(struct soap *soap, struct soap_dom_attribute *node, const char *s, void (*p)(struct soap *, void *, signed int, const char *, const char *), void (*q)(struct soap *, void *, signed int, const char *, const char *));
// soap_traverse_xsd__anyAttribute::p_object
//
void p_object(struct soap *, void *, signed int, const char *, const char *);
// soap_traverse_xsd__anyAttribute::q_object
//
void q_object(struct soap *, void *, signed int, const char *, const char *);
// soap_traverse_xsd__anyType
// file dom.c line 142
void soap_traverse_xsd__anyType(struct soap *soap, struct soap_dom_element *node, const char *s, void (*p)(struct soap *, void *, signed int, const char *, const char *), void (*q)(struct soap *, void *, signed int, const char *, const char *));
// soap_traverse_xsd__anyType::p_object
//
void p_object(struct soap *, void *, signed int, const char *, const char *);
// soap_traverse_xsd__anyType::q_object
//
void q_object(struct soap *, void *, signed int, const char *, const char *);
// soap_try_connect_command
// file stdsoap2.c line 17160
static signed int soap_try_connect_command(struct soap *soap, signed int http_command, const char *endpoint, const char *action);
// soap_type_punned
// file stdsoap2.c line 8859
static signed int soap_type_punned(struct soap *soap, struct soap_ilist *ip);
// soap_unlink
// file stdsoap2.c line 8531
signed int soap_unlink(struct soap *soap, const void *p);
// soap_unmark
// file ../../../gsoap/stdsoap2.h line 2989
void soap_unmark(struct soap *soap, char *mark);
// soap_unsignedByte2s
// file stdsoap2.c line 13654
const char * soap_unsignedByte2s(struct soap *soap, unsigned char n);
// soap_unsignedInt2s
// file stdsoap2.c line 13809
const char * soap_unsignedInt2s(struct soap *soap, unsigned int n);
// soap_unsignedLong2s
// file stdsoap2.c line 13897
const char * soap_unsignedLong2s(struct soap *soap, unsigned long int n);
// soap_unsignedShort2s
// file stdsoap2.c line 13731
const char * soap_unsignedShort2s(struct soap *soap, unsigned short int n);
// soap_update_pointers
// file stdsoap2.c line 2404
void soap_update_pointers(struct soap *soap, const char *dst, const char *src, unsigned long int len);
// soap_url
// file stdsoap2.c line 6639
const char * soap_url(struct soap *soap, const char *s, const char *t);
// soap_utf8len
// file stdsoap2.c line 1867
unsigned long int soap_utf8len(const char *s);
// soap_utilize_ns
// file stdsoap2.c line 10259
static void soap_utilize_ns(struct soap *soap, const char *tag);
// soap_valid_mime_boundary
// file stdsoap2.c line 16372
static signed int soap_valid_mime_boundary(struct soap *soap);
// soap_value
// file stdsoap2.c line 15284
const char * soap_value(struct soap *soap);
// soap_wchar2s
// file stdsoap2.c line 14555
const char * soap_wchar2s(struct soap *soap, const signed int *s);
// soap_wstrdup
// file stdsoap2.c line 2274
signed int * soap_wstrdup(struct soap *soap, const signed int *s);
// soap_wstring
// file stdsoap2.c line 14489
static const signed int * soap_wstring(struct soap *soap, const char *s, signed long int minlen, signed long int maxlen);
// soap_wstring_in
// file stdsoap2.c line 12762
signed int * soap_wstring_in(struct soap *soap, signed int flag, signed long int minlen, signed long int maxlen, const char *pattern);
// soap_wstring_out
// file stdsoap2.c line 12681
signed int soap_wstring_out(struct soap *soap, const signed int *s, signed int flag);
// soap_wstrtrim
// file stdsoap2.c line 2317
signed int * soap_wstrtrim(struct soap *soap, signed int *s);
// soap_xop_forward
// file stdsoap2.c line 2188
signed int soap_xop_forward(struct soap *soap, unsigned char **ptr, signed int *size, char **id, char **type, char **options);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// strchr
// file /usr/include/string.h line 231
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 140
extern signed int strcmp(const char *, const char *);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 394
extern unsigned long int strlen(const char *);
// strncat
// file /usr/include/string.h line 136
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 143
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 128
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 258
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 337
extern char * strstr(const char *, const char *);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoll
// file /usr/include/stdlib.h line 209
extern signed long long int strtoll(const char *, char ** restrict , signed int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// strtoull
// file /usr/include/stdlib.h line 214
extern unsigned long long int strtoull(const char *, char ** restrict , signed int);
// tcp_accept
// file stdsoap2.c line 5087
static signed int tcp_accept(struct soap *soap, signed int s, struct sockaddr *a, signed int *n);
// tcp_closesocket
// file stdsoap2.c line 5209
static signed int tcp_closesocket(struct soap *soap, signed int sk);
// tcp_connect
// file stdsoap2.c line 4191
static signed int tcp_connect(struct soap *soap, const char *endpoint, const char *host, signed int port);
// tcp_disconnect
// file stdsoap2.c line 5110
static signed int tcp_disconnect(struct soap *soap);
// tcp_error
// file stdsoap2.c line 4088
static const char * tcp_error(struct soap *soap);
// tcp_init
// file stdsoap2.c line 4066
static signed int tcp_init(struct soap *soap);
// tcp_select
// file stdsoap2.c line 4976
static signed int tcp_select(struct soap *soap, signed int sk, signed int flags, signed int timeout);
// tcp_shutdownsocket
// file stdsoap2.c line 5222
static signed int tcp_shutdownsocket(struct soap *soap, signed int sk, signed int how);
// timegm
// file /usr/include/time.h line 319
extern signed long int timegm(struct tm *);
// wctomb
// file /usr/include/stdlib.h line 869
extern signed int wctomb(char *, signed int);
// write
// file /usr/include/unistd.h line 369
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous_3
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous_2
{
  // n1
  unsigned int n1;
  // n2
  unsigned int n2;
};

union anonymous_1
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_0
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_storage
{
  // ss_family
  unsigned short int ss_family;
  // __ss_align
  unsigned long int __ss_align;
  // __ss_padding
  char __ss_padding[112l];
};

union anonymous
{
  // addr
  struct sockaddr addr;
  // in
  struct sockaddr_in in;
  // storage
  struct sockaddr_storage storage;
};

struct Namespace
{
  // id
  const char *id;
  // ns
  const char *ns;
  // in
  const char *in;
  // out
  char *out;
};

struct SOAP_ENV__Code
{
  // SOAP_ENV__Value
  char *SOAP_ENV__Value;
  // SOAP_ENV__Subcode
  struct SOAP_ENV__Code *SOAP_ENV__Subcode;
};

struct SOAP_ENV__Detail
{
  // __any
  char *__any;
  // __type
  signed int __type;
  // fault
  void *fault;
};

struct SOAP_ENV__Fault
{
  // faultcode
  char *faultcode;
  // faultstring
  char *faultstring;
  // faultactor
  char *faultactor;
  // detail
  struct SOAP_ENV__Detail *detail;
  // SOAP_ENV__Code
  struct SOAP_ENV__Code *SOAP_ENV__Code;
  // SOAP_ENV__Reason
  struct SOAP_ENV__Reason *SOAP_ENV__Reason;
  // SOAP_ENV__Node
  char *SOAP_ENV__Node;
  // SOAP_ENV__Role
  char *SOAP_ENV__Role;
  // SOAP_ENV__Detail
  struct SOAP_ENV__Detail *SOAP_ENV__Detail;
};

struct SOAP_ENV__Header
{
  // dummy
  char dummy;
};

struct SOAP_ENV__Reason
{
  // SOAP_ENV__Text
  char *SOAP_ENV__Text;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct header
{
  // next
  struct header *next;
  // line
  char line[8192l];
};

struct in6_addr
{
  // __in6_u
  union anonymous_1 __in6_u;
};

struct linger
{
  // l_onoff
  signed int l_onoff;
  // l_linger
  signed int l_linger;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct soap_ilist
{
  // next
  struct soap_ilist *next;
  // type
  signed int type;
  // size
  unsigned long int size;
  // ptr
  void *ptr;
  // spine
  void **spine;
  // link
  void *link;
  // copy
  void *copy;
  // flist
  struct soap_flist *flist;
  // smart
  void *smart;
  // shaky
  signed short int shaky;
  // id
  char id[1l];
};

struct soap_plist
{
  // next
  struct soap_plist *next;
  // ptr
  const void *ptr;
  // dup
  void *dup;
  // array
  const void *array;
  // size
  signed int size;
  // type
  signed int type;
  // id
  signed int id;
  // mark1
  char mark1;
  // mark2
  char mark2;
};

struct soap_dime
{
  // count
  unsigned long int count;
  // size
  unsigned long int size;
  // chunksize
  unsigned long int chunksize;
  // buflen
  unsigned long int buflen;
  // flags
  char flags;
  // ptr
  char *ptr;
  // id
  const char *id;
  // type
  const char *type;
  // options
  const char *options;
  // list
  struct soap_multipart *list;
  // first
  struct soap_multipart *first;
  // last
  struct soap_multipart *last;
};

struct soap_mime
{
  // boundary
  char *boundary;
  // start
  const char *start;
  // list
  struct soap_multipart *list;
  // first
  struct soap_multipart *first;
  // last
  struct soap_multipart *last;
};

struct soap
{
  // state
  signed short int state;
  // version
  signed short int version;
  // mode
  signed int mode;
  // imode
  signed int imode;
  // omode
  signed int omode;
  // float_format
  const char *float_format;
  // double_format
  const char *double_format;
  // long_double_format
  const char *long_double_format;
  // dime_id_format
  const char *dime_id_format;
  // http_version
  const char *http_version;
  // http_content
  const char *http_content;
  // encodingStyle
  const char *encodingStyle;
  // actor
  const char *actor;
  // lang
  const char *lang;
  // recv_timeout
  signed int recv_timeout;
  // send_timeout
  signed int send_timeout;
  // connect_timeout
  signed int connect_timeout;
  // accept_timeout
  signed int accept_timeout;
  // socket_flags
  signed int socket_flags;
  // connect_flags
  signed int connect_flags;
  // bind_flags
  signed int bind_flags;
  // accept_flags
  signed int accept_flags;
  // linger_time
  unsigned short int linger_time;
  // namespaces
  struct Namespace *namespaces;
  // local_namespaces
  struct Namespace *local_namespaces;
  // nlist
  struct soap_nlist *nlist;
  // blist
  struct soap_blist *blist;
  // clist
  struct soap_clist *clist;
  // alist
  void *alist;
  // shaky
  signed short int shaky;
  // iht
  struct soap_ilist *iht[1999l];
  // pht
  struct soap_plist *pht[4096l];
  // pblk
  struct soap_pblk *pblk;
  // pidx
  signed short int pidx;
  // header
  struct SOAP_ENV__Header *header;
  // fault
  struct SOAP_ENV__Fault *fault;
  // idnum
  signed int idnum;
  // user
  void *user;
  // data
  void *data[4l];
  // plugins
  struct soap_plugin *plugins;
  // userid
  const char *userid;
  // passwd
  const char *passwd;
  // authrealm
  const char *authrealm;
  // ntlm_challenge
  const char *ntlm_challenge;
  // ntlm_auth
  signed short int ntlm_auth;
  // ntlm_stage
  signed short int ntlm_stage;
  // fpost
  signed int (*fpost)(struct soap *, const char *, const char *, signed int, const char *, const char *, unsigned long int);
  // fget
  signed int (*fget)(struct soap *);
  // fput
  signed int (*fput)(struct soap *);
  // fdel
  signed int (*fdel)(struct soap *);
  // fopt
  signed int (*fopt)(struct soap *);
  // fhead
  signed int (*fhead)(struct soap *);
  // fform
  signed int (*fform)(struct soap *);
  // fposthdr
  signed int (*fposthdr)(struct soap *, const char *, const char *);
  // fresponse
  signed int (*fresponse)(struct soap *, signed int, unsigned long int);
  // fparse
  signed int (*fparse)(struct soap *);
  // fparsehdr
  signed int (*fparsehdr)(struct soap *, const char *, const char *);
  // fheader
  signed int (*fheader)(struct soap *);
  // fresolve
  signed int (*fresolve)(struct soap *, const char *, struct in_addr *);
  // fconnect
  signed int (*fconnect)(struct soap *, const char *, const char *, signed int);
  // fdisconnect
  signed int (*fdisconnect)(struct soap *);
  // fclosesocket
  signed int (*fclosesocket)(struct soap *, signed int);
  // fshutdownsocket
  signed int (*fshutdownsocket)(struct soap *, signed int, signed int);
  // fopen
  signed int (*fopen)(struct soap *, const char *, const char *, signed int);
  // faccept
  signed int (*faccept)(struct soap *, signed int, struct sockaddr *, signed int *);
  // fclose
  signed int (*fclose)(struct soap *);
  // fsend
  signed int (*fsend)(struct soap *, const char *, unsigned long int);
  // frecv
  unsigned long int (*frecv)(struct soap *, char *, unsigned long int);
  // fpoll
  signed int (*fpoll)(struct soap *);
  // fseterror
  void (*fseterror)(struct soap *, const char **, const char **);
  // fignore
  signed int (*fignore)(struct soap *, const char *);
  // fserveloop
  signed int (*fserveloop)(struct soap *);
  // fplugin
  void * (*fplugin)(struct soap *, const char *);
  // fmalloc
  void * (*fmalloc)(struct soap *, unsigned long int);
  // fsvalidate
  signed int (*fsvalidate)(struct soap *, const char *, const char *);
  // fwvalidate
  signed int (*fwvalidate)(struct soap *, const char *, const signed int *);
  // feltbegin
  signed int (*feltbegin)(struct soap *, const char *);
  // feltendin
  signed int (*feltendin)(struct soap *, const char *, const char *);
  // feltbegout
  signed int (*feltbegout)(struct soap *, const char *);
  // feltendout
  signed int (*feltendout)(struct soap *, const char *);
  // fprepareinitsend
  signed int (*fprepareinitsend)(struct soap *);
  // fprepareinitrecv
  signed int (*fprepareinitrecv)(struct soap *);
  // fpreparesend
  signed int (*fpreparesend)(struct soap *, const char *, unsigned long int);
  // fpreparerecv
  signed int (*fpreparerecv)(struct soap *, const char *, unsigned long int);
  // fpreparefinalsend
  signed int (*fpreparefinalsend)(struct soap *);
  // fpreparefinalrecv
  signed int (*fpreparefinalrecv)(struct soap *);
  // recverror
  signed int recverror;
  // ffiltersend
  signed int (*ffiltersend)(struct soap *, const char **, unsigned long int *);
  // ffilterrecv
  signed int (*ffilterrecv)(struct soap *, char *, unsigned long int *, unsigned long int);
  // fdimereadopen
  void * (*fdimereadopen)(struct soap *, void *, const char *, const char *, const char *);
  // fdimewriteopen
  void * (*fdimewriteopen)(struct soap *, const char *, const char *, const char *);
  // fdimereadclose
  void (*fdimereadclose)(struct soap *, void *);
  // fdimewriteclose
  void (*fdimewriteclose)(struct soap *, void *);
  // fdimeread
  unsigned long int (*fdimeread)(struct soap *, void *, char *, unsigned long int);
  // fdimewrite
  signed int (*fdimewrite)(struct soap *, void *, const char *, unsigned long int);
  // fmimereadopen
  void * (*fmimereadopen)(struct soap *, void *, const char *, const char *, const char *);
  // fmimewriteopen
  void * (*fmimewriteopen)(struct soap *, void *, const char *, const char *, const char *, enum soap_mime_encoding);
  // fmimereadclose
  void (*fmimereadclose)(struct soap *, void *);
  // fmimewriteclose
  void (*fmimewriteclose)(struct soap *, void *);
  // fmimeread
  unsigned long int (*fmimeread)(struct soap *, void *, char *, unsigned long int);
  // fmimewrite
  signed int (*fmimewrite)(struct soap *, void *, const char *, unsigned long int);
  // master
  signed int master;
  // socket
  signed int socket;
  // sendsk
  signed int sendsk;
  // recvsk
  signed int recvsk;
  // os
  const char **os;
  // is
  const char *is;
  // sendfd
  signed int sendfd;
  // recvfd
  signed int recvfd;
  // bufidx
  unsigned long int bufidx;
  // buflen
  unsigned long int buflen;
  // ahead
  signed int ahead;
  // cdata
  signed short int cdata;
  // body
  signed short int body;
  // level
  unsigned int level;
  // count
  unsigned long int count;
  // length
  unsigned long int length;
  // labbuf
  char *labbuf;
  // lablen
  unsigned long int lablen;
  // labidx
  unsigned long int labidx;
  // buf
  char buf[65536l];
  // msgbuf
  char msgbuf[1024l];
  // tmpbuf
  char tmpbuf[1024l];
  // tag
  char tag[1024l];
  // id
  char id[1024l];
  // href
  char href[1024l];
  // type
  char type[1024l];
  // arrayType
  char arrayType[1024l];
  // arraySize
  char arraySize[1024l];
  // arrayOffset
  char arrayOffset[1024l];
  // other
  signed short int other;
  // root
  signed short int root;
  // position
  signed int position;
  // positions
  signed int positions[16l];
  // attributes
  struct soap_attribute *attributes;
  // encoding
  signed short int encoding;
  // mustUnderstand
  signed short int mustUnderstand;
  // null
  signed short int null;
  // ns
  signed short int ns;
  // part
  signed short int part;
  // event
  signed short int event;
  // peeked
  signed short int peeked;
  // evlev
  unsigned int evlev;
  // alloced
  signed int alloced;
  // chunksize
  unsigned long int chunksize;
  // chunkbuflen
  unsigned long int chunkbuflen;
  // endpoint
  char endpoint[1024l];
  // path
  char path[1024l];
  // host
  char host[1024l];
  // action
  char *action;
  // prolog
  const char *prolog;
  // ip
  unsigned long int ip;
  // port
  signed int port;
  // keep_alive
  signed short int keep_alive;
  // tcp_keep_alive
  signed short int tcp_keep_alive;
  // tcp_keep_idle
  unsigned int tcp_keep_idle;
  // tcp_keep_intvl
  unsigned int tcp_keep_intvl;
  // tcp_keep_cnt
  unsigned int tcp_keep_cnt;
  // max_keep_alive
  unsigned int max_keep_alive;
  // proxy_http_version
  const char *proxy_http_version;
  // proxy_host
  const char *proxy_host;
  // proxy_port
  signed int proxy_port;
  // proxy_userid
  const char *proxy_userid;
  // proxy_passwd
  const char *proxy_passwd;
  // proxy_from
  const char *proxy_from;
  // status
  signed int status;
  // error
  signed int error;
  // errmode
  signed int errmode;
  // errnum
  signed int errnum;
  // dom
  struct soap_dom_element *dom;
  // dime
  struct soap_dime dime;
  // mime
  struct soap_mime mime;
  // xlist
  struct soap_xlist *xlist;
  // logfile
  const char *logfile[3l];
  // fdebug
  struct _IO_FILE *fdebug[3l];
  // mht
  struct soap_mlist *mht[4096l];
  // wsuid
  const char *wsuid;
  // c14nexclude
  const char *c14nexclude;
  // c14ninclude
  const char *c14ninclude;
  // cookies
  struct soap_cookie *cookies;
  // cookie_domain
  const char *cookie_domain;
  // cookie_path
  const char *cookie_path;
  // cookie_max
  signed int cookie_max;
  // ipv6_multicast_if
  unsigned int ipv6_multicast_if;
  // ipv4_multicast_if
  char *ipv4_multicast_if;
  // ipv4_multicast_ttl
  unsigned char ipv4_multicast_ttl;
  // peer
  union anonymous peer;
  // peerlen
  unsigned long int peerlen;
  // fsslauth
  void *fsslauth;
  // fsslverify
  void *fsslverify;
  // bio
  void *bio;
  // ssl
  void *ssl;
  // ctx
  void *ctx;
  // session
  void *session;
  // dh_params
  void *dh_params;
  // rsa_params
  void *rsa_params;
  // ssl_flags
  unsigned short int ssl_flags;
  // keyfile
  const char *keyfile;
  // keyid
  const char *keyid;
  // password
  const char *password;
  // cafile
  const char *cafile;
  // capath
  const char *capath;
  // crlfile
  const char *crlfile;
  // session_host
  char session_host[1024l];
  // session_port
  signed int session_port;
  // c_locale
  void *c_locale;
  // d_stream
  void *d_stream;
  // z_crc
  signed int z_crc;
  // z_dict
  const char *z_dict;
  // z_dict_len
  unsigned int z_dict_len;
  // zlib_state
  signed short int zlib_state;
  // zlib_in
  signed short int zlib_in;
  // zlib_out
  signed short int zlib_out;
  // z_buf
  char *z_buf;
  // z_buflen
  unsigned long int z_buflen;
  // z_level
  unsigned short int z_level;
  // z_ratio_in
  float z_ratio_in;
  // z_ratio_out
  float z_ratio_out;
};

struct soap_attribute
{
  // next
  struct soap_attribute *next;
  // flag
  signed short int flag;
  // value
  char *value;
  // size
  unsigned long int size;
  // ns
  const char *ns;
  // visible
  signed short int visible;
  // name
  char name[1l];
};

struct soap_bhead
{
  // next
  struct soap_bhead *next;
  // size
  unsigned long int size;
};

struct soap_blist
{
  // next
  struct soap_blist *next;
  // head
  struct soap_bhead *head;
  // size
  unsigned long int size;
};

struct soap_clist
{
  // next
  struct soap_clist *next;
  // ptr
  void *ptr;
  // type
  signed int type;
  // size
  signed int size;
  // fdelete
  signed int (*fdelete)(struct soap_clist *);
};

struct soap_code_map
{
  // code
  signed long int code;
  // string
  const char *string;
};

struct soap_cookie
{
  // next
  struct soap_cookie *next;
  // name
  char *name;
  // value
  char *value;
  // domain
  char *domain;
  // path
  char *path;
  // expire
  signed long int expire;
  // maxage
  signed long int maxage;
  // version
  unsigned int version;
  // secure
  signed short int secure;
  // session
  signed short int session;
  // env
  signed short int env;
  // modified
  signed short int modified;
};

struct soap_dom_attribute
{
  // next
  struct soap_dom_attribute *next;
  // nstr
  const char *nstr;
  // name
  const char *name;
  // text
  const char *text;
  // soap
  struct soap *soap;
};

struct soap_dom_element
{
  // next
  struct soap_dom_element *next;
  // prnt
  struct soap_dom_element *prnt;
  // elts
  struct soap_dom_element *elts;
  // atts
  struct soap_dom_attribute *atts;
  // nstr
  const char *nstr;
  // name
  const char *name;
  // lead
  const char *lead;
  // text
  const char *text;
  // code
  const char *code;
  // tail
  const char *tail;
  // node
  const void *node;
  // type
  signed int type;
  // soap
  struct soap *soap;
};

union soap_double_nan
{
  // iv
  struct anonymous_2 iv;
  // dv
  double dv;
  // fv
  float fv;
};

struct soap_flist
{
  // next
  struct soap_flist *next;
  // type
  signed int type;
  // ptr
  void *ptr;
  // level
  unsigned int level;
  // index
  unsigned long int index;
  // finsert
  void (*finsert)(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **);
};

struct soap_multipart
{
  // next
  struct soap_multipart *next;
  // ptr
  char *ptr;
  // size
  unsigned long int size;
  // id
  const char *id;
  // type
  const char *type;
  // options
  const char *options;
  // encoding
  enum soap_mime_encoding encoding;
  // location
  const char *location;
  // description
  const char *description;
};

struct soap_nlist
{
  // next
  struct soap_nlist *next;
  // level
  unsigned int level;
  // index
  signed short int index;
  // ns
  const char *ns;
  // id
  char id[1l];
};

struct soap_pblk
{
  // next
  struct soap_pblk *next;
  // plist
  struct soap_plist plist[32l];
};

struct soap_plugin
{
  // next
  struct soap_plugin *next;
  // id
  const char *id;
  // data
  void *data;
  // fcopy
  signed int (*fcopy)(struct soap *, struct soap_plugin *, struct soap_plugin *);
  // fdelete
  void (*fdelete)(struct soap *, struct soap_plugin *);
};

struct soap_xlist
{
  // next
  struct soap_xlist *next;
  // ptr
  unsigned char **ptr;
  // size
  signed int *size;
  // id
  char *id;
  // type
  char **type;
  // options
  char **options;
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct t__Routing
{
  // key
  char *key;
  // endpoint
  char *endpoint;
  // userid
  char *userid;
  // passwd
  char *passwd;
};

struct t__RoutingTable
{
  // __size
  signed int __size;
  // __ptr
  struct t__Routing *__ptr;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};


// connect_flag
// file router.c line 274
static signed int connect_flag = 0;
// h_error_codes
// file stdsoap2.c line 453
static struct soap_code_map h_error_codes[6l] = { { .code=(signed long int)1, .string="Host not found" },
    { .code=(signed long int)2, .string="Try Again" },
    { .code=(signed long int)3, .string="No Recovery" },
    { .code=(signed long int)4, .string="No Data" },
    { .code=(signed long int)4, .string="No Address" },
    { .code=(signed long int)0, .string=(const char *)(void *)0 } };
// h_http_error_codes
// file stdsoap2.c line 477
static struct soap_code_map h_http_error_codes[39l] = { { .code=(signed long int)200, .string="OK" },
    { .code=(signed long int)201, .string="Created" },
    { .code=(signed long int)202, .string="Accepted" },
    { .code=(signed long int)203, .string="Non-Authoritative Information" },
    { .code=(signed long int)204, .string="No Content" },
    { .code=(signed long int)205, .string="Reset Content" },
    { .code=(signed long int)206, .string="Partial Content" },
    { .code=(signed long int)300, .string="Multiple Choices" },
    { .code=(signed long int)301, .string="Moved Permanently" },
    { .code=(signed long int)302, .string="Found" },
    { .code=(signed long int)303, .string="See Other" },
    { .code=(signed long int)304, .string="Not Modified" },
    { .code=(signed long int)305, .string="Use Proxy" },
    { .code=(signed long int)307, .string="Temporary Redirect" },
    { .code=(signed long int)400, .string="Bad Request" },
    { .code=(signed long int)401, .string="Unauthorized" },
    { .code=(signed long int)402, .string="Payment Required" },
    { .code=(signed long int)403, .string="Forbidden" },
    { .code=(signed long int)404, .string="Not Found" },
    { .code=(signed long int)405, .string="Method Not Allowed" },
    { .code=(signed long int)406, .string="Not Acceptable" },
    { .code=(signed long int)407, .string="Proxy Authentication Required" },
    { .code=(signed long int)408, .string="Request Time-out" },
    { .code=(signed long int)409, .string="Conflict" },
    { .code=(signed long int)410, .string="Gone" },
    { .code=(signed long int)411, .string="Length Required" },
    { .code=(signed long int)412, .string="Precondition Failed" },
    { .code=(signed long int)413, .string="Request Entity Too Large" },
    { .code=(signed long int)414, .string="Request-URI Too Large" },
    { .code=(signed long int)415, .string="Unsupported Media Type" },
    { .code=(signed long int)416, .string="Requested range not satisfiable" },
    { .code=(signed long int)417, .string="Expectation Failed" },
    { .code=(signed long int)500, .string="Internal Server Error" },
    { .code=(signed long int)501, .string="Not Implemented" },
    { .code=(signed long int)502, .string="Bad Gateway" },
    { .code=(signed long int)503, .string="Service Unavailable" },
    { .code=(signed long int)504, .string="Gateway Time-out" },
    { .code=(signed long int)505, .string="HTTP Version not supported" },
    { .code=(signed long int)0, .string=(const char *)(void *)0 } };
// html_entity_codes
// file stdsoap2.c line 350
static struct soap_code_map html_entity_codes[97l] = { { .code=(signed long int)160, .string="nbsp" },
    { .code=(signed long int)161, .string="iexcl" },
    { .code=(signed long int)162, .string="cent" },
    { .code=(signed long int)163, .string="pound" },
    { .code=(signed long int)164, .string="curren" },
    { .code=(signed long int)165, .string="yen" },
    { .code=(signed long int)166, .string="brvbar" },
    { .code=(signed long int)167, .string="sect" },
    { .code=(signed long int)168, .string="uml" },
    { .code=(signed long int)169, .string="copy" },
    { .code=(signed long int)170, .string="ordf" },
    { .code=(signed long int)171, .string="laquo" },
    { .code=(signed long int)172, .string="not" },
    { .code=(signed long int)173, .string="shy" },
    { .code=(signed long int)174, .string="reg" },
    { .code=(signed long int)175, .string="macr" },
    { .code=(signed long int)176, .string="deg" },
    { .code=(signed long int)177, .string="plusmn" },
    { .code=(signed long int)178, .string="sup2" },
    { .code=(signed long int)179, .string="sup3" },
    { .code=(signed long int)180, .string="acute" },
    { .code=(signed long int)181, .string="micro" },
    { .code=(signed long int)182, .string="para" },
    { .code=(signed long int)183, .string="middot" },
    { .code=(signed long int)184, .string="cedil" },
    { .code=(signed long int)185, .string="sup1" },
    { .code=(signed long int)186, .string="ordm" },
    { .code=(signed long int)187, .string="raquo" },
    { .code=(signed long int)188, .string="frac14" },
    { .code=(signed long int)189, .string="frac12" },
    { .code=(signed long int)190, .string="frac34" },
    { .code=(signed long int)191, .string="iquest" },
    { .code=(signed long int)192, .string="Agrave" },
    { .code=(signed long int)193, .string="Aacute" },
    { .code=(signed long int)194, .string="Acirc" },
    { .code=(signed long int)195, .string="Atilde" },
    { .code=(signed long int)196, .string="Auml" },
    { .code=(signed long int)197, .string="Aring" },
    { .code=(signed long int)198, .string="AElig" },
    { .code=(signed long int)199, .string="Ccedil" },
    { .code=(signed long int)200, .string="Egrave" },
    { .code=(signed long int)201, .string="Eacute" },
    { .code=(signed long int)202, .string="Ecirc" },
    { .code=(signed long int)203, .string="Euml" },
    { .code=(signed long int)204, .string="Igrave" },
    { .code=(signed long int)205, .string="Iacute" },
    { .code=(signed long int)206, .string="Icirc" },
    { .code=(signed long int)207, .string="Iuml" },
    { .code=(signed long int)208, .string="ETH" },
    { .code=(signed long int)209, .string="Ntilde" },
    { .code=(signed long int)210, .string="Ograve" },
    { .code=(signed long int)211, .string="Oacute" },
    { .code=(signed long int)212, .string="Ocirc" },
    { .code=(signed long int)213, .string="Otilde" },
    { .code=(signed long int)214, .string="Ouml" },
    { .code=(signed long int)215, .string="times" },
    { .code=(signed long int)216, .string="Oslash" },
    { .code=(signed long int)217, .string="Ugrave" },
    { .code=(signed long int)218, .string="Uacute" },
    { .code=(signed long int)219, .string="Ucirc" },
    { .code=(signed long int)220, .string="Uuml" },
    { .code=(signed long int)221, .string="Yacute" },
    { .code=(signed long int)222, .string="THORN" },
    { .code=(signed long int)223, .string="szlig" },
    { .code=(signed long int)224, .string="agrave" },
    { .code=(signed long int)225, .string="aacute" },
    { .code=(signed long int)226, .string="acirc" },
    { .code=(signed long int)227, .string="atilde" },
    { .code=(signed long int)228, .string="auml" },
    { .code=(signed long int)229, .string="aring" },
    { .code=(signed long int)230, .string="aelig" },
    { .code=(signed long int)231, .string="ccedil" },
    { .code=(signed long int)232, .string="egrave" },
    { .code=(signed long int)233, .string="eacute" },
    { .code=(signed long int)234, .string="ecirc" },
    { .code=(signed long int)235, .string="euml" },
    { .code=(signed long int)236, .string="igrave" },
    { .code=(signed long int)237, .string="iacute" },
    { .code=(signed long int)238, .string="icirc" },
    { .code=(signed long int)239, .string="iuml" },
    { .code=(signed long int)240, .string="eth" },
    { .code=(signed long int)241, .string="ntilde" },
    { .code=(signed long int)242, .string="ograve" },
    { .code=(signed long int)243, .string="oacute" },
    { .code=(signed long int)244, .string="ocirc" },
    { .code=(signed long int)245, .string="otilde" },
    { .code=(signed long int)246, .string="ouml" },
    { .code=(signed long int)247, .string="divide" },
    { .code=(signed long int)248, .string="oslash" },
    { .code=(signed long int)249, .string="ugrave" },
    { .code=(signed long int)250, .string="uacute" },
    { .code=(signed long int)251, .string="ucirc" },
    { .code=(signed long int)252, .string="uuml" },
    { .code=(signed long int)253, .string="yacute" },
    { .code=(signed long int)254, .string="thorn" },
    { .code=(signed long int)255, .string="yuml" },
    { .code=(signed long int)0, .string=(const char *)(void *)0 } };
// input_file
// file router.c line 268
static const char *input_file = (const char *)(void *)0;
// method
// file router.c line 273
static signed int method = 2000;
// mime_codes
// file stdsoap2.c line 537
static struct soap_code_map mime_codes[8l] = { { .code=(signed long int)1, .string="7bit" },
    { .code=(signed long int)2, .string="8bit" },
    { .code=(signed long int)3, .string="binary" },
    { .code=(signed long int)4, .string="quoted-printable" },
    { .code=(signed long int)5, .string="base64" },
    { .code=(signed long int)6, .string="ietf-token" },
    { .code=(signed long int)7, .string="x-token" },
    { .code=(signed long int)0, .string=(const char *)(void *)0 } };
// namespaces
// file router.c line 778
struct Namespace namespaces[6l] = { { .id="SOAP-ENV", .ns="http://schemas.xmlsoap.org/soap/envelope/", .in=((const char *)NULL),
    .out=((char *)NULL) },
    { .id="SOAP-ENC", .ns="http://schemas.xmlsoap.org/soap/encoding/", .in=((const char *)NULL),
    .out=((char *)NULL) },
    { .id="xsi", .ns="http://www.w3.org/2001/XMLSchema-instance", .in="http://www.w3.org/*/XMLSchema-instance",
    .out=((char *)NULL) },
    { .id="xsd", .ns="http://www.w3.org/2001/XMLSchema", .in="http://www.w3.org/*/XMLSchema",
    .out=((char *)NULL) },
    { .id="t", .ns="http://tempuri.org", .in=((const char *)NULL), .out=((char *)NULL) },
    { .id=(const char *)(void *)0, .ns=(const char *)(void *)0, .in=((const char *)NULL),
    .out=((char *)NULL) } };
// port_number
// file router.c line 267
static signed int port_number = 0;
// routing
// file router.c line 248
static struct t__Routing routing[4l] = { { .key="dime", .endpoint="http://websrv.cs.fsu.edu/~engelen/dimesrv.cgi", .userid=((char *)NULL),
    .passwd=((char *)NULL) },
    { .key="http://*/dime", .endpoint="http://websrv.cs.fsu.edu/~engelen/dimesrv.cgi", .userid=((char *)NULL),
    .passwd=((char *)NULL) },
    { .key="magic", .endpoint="http://www.cs.fsu.edu/~engelen/magicserver.cgi", .userid=((char *)NULL),
    .passwd=((char *)NULL) },
    { .key=(char *)(void *)0, .endpoint=(char *)(void *)0, .userid=((char *)NULL),
    .passwd=((char *)NULL) } };
// routing_file
// file router.c line 271
static const char *routing_file = "router.xml";
// server_timeout
// file router.c line 272
static signed int server_timeout = 0;
// service_action
// file router.c line 270
static const char *service_action = (const char *)(void *)0;
// service_endpoint
// file router.c line 269
static const char *service_endpoint = (const char *)(void *)0;
// soap_base64i
// file stdsoap2.c line 330
const char soap_base64i[81l] = { '>', 'X', 'X', 'X', '?', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 0, 1, 2, 3, 4, 5, 6, 7, 8, '\t', '\n', 11, 12, '\r', 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 'X', 'X', 'X', 'X', 'X', 'X', 26, 27, 28, 29, 30, 31, ' ', '!', '"', '#', '_', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', 0 };
// soap_base64o
// file stdsoap2.c line 329
const char soap_base64o[65l] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/', 0 };
// soap_double_nan
// file stdsoap2.c line 328
union soap_double_nan soap_double_nan = { .iv={ .n1=0xFFFFFFFF, .n2=0xFFFFFFFF } };
// soap_enc1
// file stdsoap2.c line 321
static const char soap_enc1[42l] = { 'h', 't', 't', 'p', ':', '/', '/', 's', 'c', 'h', 'e', 'm', 'a', 's', '.', 'x', 'm', 'l', 's', 'o', 'a', 'p', '.', 'o', 'r', 'g', '/', 's', 'o', 'a', 'p', '/', 'e', 'n', 'c', 'o', 'd', 'i', 'n', 'g', '/', 0 };
// soap_enc2
// file stdsoap2.c line 323
static const char soap_enc2[40l] = { 'h', 't', 't', 'p', ':', '/', '/', 'w', 'w', 'w', '.', 'w', '3', '.', 'o', 'r', 'g', '/', '2', '0', '0', '3', '/', '0', '5', '/', 's', 'o', 'a', 'p', '-', 'e', 'n', 'c', 'o', 'd', 'i', 'n', 'g', 0 };
// soap_env1
// file stdsoap2.c line 320
static const char soap_env1[42l] = { 'h', 't', 't', 'p', ':', '/', '/', 's', 'c', 'h', 'e', 'm', 'a', 's', '.', 'x', 'm', 'l', 's', 'o', 'a', 'p', '.', 'o', 'r', 'g', '/', 's', 'o', 'a', 'p', '/', 'e', 'n', 'v', 'e', 'l', 'o', 'p', 'e', '/', 0 };
// soap_env2
// file stdsoap2.c line 322
static const char soap_env2[40l] = { 'h', 't', 't', 'p', ':', '/', '/', 'w', 'w', 'w', '.', 'w', '3', '.', 'o', 'r', 'g', '/', '2', '0', '0', '3', '/', '0', '5', '/', 's', 'o', 'a', 'p', '-', 'e', 'n', 'v', 'e', 'l', 'o', 'p', 'e', 0 };
// soap_indent
// file stdsoap2.c line 334
static const char soap_indent[21l] = { '\n', '\t', '\t', '\t', '\t', '\t', '\t', '\t', '\t', '\t', '\t', '\t', '\t', '\t', '\t', '\t', '\t', '\t', '\t', '\t', 0 };
// soap_padding
// file stdsoap2.c line 344
static const char soap_padding[4l] = { 0, 0, 0, 0 };
// soap_rpc
// file stdsoap2.c line 324
static const char soap_rpc[35l] = { 'h', 't', 't', 'p', ':', '/', '/', 'w', 'w', 'w', '.', 'w', '3', '.', 'o', 'r', 'g', '/', '2', '0', '0', '3', '/', '0', '5', '/', 's', 'o', 'a', 'p', '-', 'r', 'p', 'c', 0 };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;

// buffer_body
// file router.c line 720
signed int buffer_body(struct soap *sender)
{
  char *s;
  struct soap_blist *return_value_soap_new_block_1;
  return_value_soap_new_block_1=soap_new_block(sender);
  void *return_value_memcpy_3;
  signed int return_value_soap_end_recv_6;
  if(return_value_soap_new_block_1 == ((struct soap_blist *)NULL))
    return sender->error;

  else
  {
    do
    {
      void *return_value_soap_push_block_2;
      return_value_soap_push_block_2=soap_push_block(sender, (struct soap_blist *)(void *)0, sender->buflen - sender->bufidx);
      s = (char *)return_value_soap_push_block_2;
      if(s == ((char *)NULL))
        return 20;

      _Bool tmp_if_expr_4;
      if(!(s == ((char *)NULL)))
        tmp_if_expr_4 = (unsigned long int)(sender->buflen - sender->bufidx) >= (unsigned long int)(sender->buflen - sender->bufidx) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_4 = (_Bool)0;
      if(tmp_if_expr_4)
      {
        return_value_memcpy_3=memcpy((void *)s, (const void *)(sender->buf + (signed long int)sender->bufidx), sender->buflen - sender->bufidx);
        (signed int)!(return_value_memcpy_3 != NULL);
      }

      else
        34;
      signed int return_value_soap_recv_raw_5;
      return_value_soap_recv_raw_5=soap_recv_raw(sender);
      if(!(return_value_soap_recv_raw_5 == 0))
        break;

    }
    while((_Bool)1);
    if(sender->error == -1)
      sender->error = 0;

    _Bool tmp_if_expr_7;
    if(!(sender->error == 0))
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      return_value_soap_end_recv_6=soap_end_recv(sender);
      tmp_if_expr_7 = return_value_soap_end_recv_6 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
      return sender->error;

    else
    {
      sender->length = sender->blist->size;
      return 0;
    }
  }
}

// copy_body
// file router.c line 740
signed int copy_body(struct soap *sender, struct soap *receiver)
{
  unsigned long int return_value_soap_block_size_1;
  signed int return_value_soap_recv_raw_2;
  signed int return_value_soap_recv_raw_4;
  if(!(sender->blist == ((struct soap_blist *)NULL)))
  {
    char *p;
    p=soap_first_block(sender, (struct soap_blist *)(void *)0);
    while(!(p == ((char *)NULL)))
    {
      return_value_soap_block_size_1=soap_block_size(sender, (struct soap_blist *)(void *)0);
      soap_send_raw(receiver, p, return_value_soap_block_size_1);
      p=soap_next_block(sender, (struct soap_blist *)(void *)0);
    }
    soap_end_block(sender, (struct soap_blist *)(void *)0);
  }

  else
  {
    if((0x00000003 & sender->mode) == 0x00000003)
    {
      sender->chunkbuflen = sender->buflen;
      sender->buflen = sender->bufidx;
      sender->chunksize = (unsigned long int)0;
      do
      {
        return_value_soap_recv_raw_2=soap_recv_raw(sender);
        if(!(return_value_soap_recv_raw_2 == 0))
          break;

        signed int return_value_soap_send_raw_3;
        return_value_soap_send_raw_3=soap_send_raw(receiver, sender->buf + (signed long int)sender->bufidx, sender->buflen - sender->bufidx);
        if(!(return_value_soap_send_raw_3 == 0))
          return receiver->error;

      }
      while((_Bool)1);
    }

    else
    {
      soap_send_raw(receiver, sender->buf + (signed long int)sender->bufidx, sender->buflen - sender->bufidx);
      if(!(sender->buflen + -sender->bufidx >= sender->length))
      {
        sender->length = sender->length - (sender->buflen - sender->bufidx);
        do
        {
          return_value_soap_recv_raw_4=soap_recv_raw(sender);
          if(!(return_value_soap_recv_raw_4 == 0))
            break;

          signed int return_value_soap_send_raw_5;
          return_value_soap_send_raw_5=soap_send_raw(receiver, sender->buf, sender->buflen);
          if(!(return_value_soap_send_raw_5 == 0))
            return receiver->error;

          if(sender->buflen >= sender->length)
            break;

          sender->length = sender->length - sender->buflen;
        }
        while((_Bool)1);
      }

    }
    signed int return_value_soap_end_recv_6;
    return_value_soap_end_recv_6=soap_end_recv(sender);
    if(!(return_value_soap_end_recv_6 == 0))
      return sender->error;

  }
  signed int return_value_soap_end_send_7;
  return_value_soap_end_send_7=soap_end_send(receiver);
  if(!(return_value_soap_end_send_7 == 0))
    return receiver->error;

  else
    return 0;
}

// copy_header
// file router.c line 625
signed int copy_header(struct soap *sender, struct soap *receiver, const char *endpoint, const char *action)
{
  struct header *h;
  struct header *p;
  char *s;
  char *t;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct header) /*8200ul*/ );
  h = (struct header *)return_value_malloc_1;
  signed int return_value_strncmp_3;
  do
  {
    signed int return_value_soap_getline_2;
    return_value_soap_getline_2=soap_getline(sender, h->line, 8192);
    if(!(return_value_soap_getline_2 == 0))
    {
      free((void *)h);
      sender->error = -1;
      return sender->error;
    }

    t=strchr(h->line, 32);
    _Bool tmp_if_expr_4;
    if(t == ((char *)NULL))
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_strncmp_3=strncmp(t, " 100 ", (unsigned long int)5);
      tmp_if_expr_4 = return_value_strncmp_3 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
      break;

    do
    {
      signed int return_value_soap_getline_5;
      return_value_soap_getline_5=soap_getline(sender, h->line, 8192);
      if(!(return_value_soap_getline_5 == 0))
      {
        free((void *)h);
        sender->error = -1;
        return sender->error;
      }

    }
    while(!(h->line[0l] == 0));
  }
  while((_Bool)1);
  p = h;
  void *return_value_malloc_6;
  return_value_malloc_6=malloc(sizeof(struct header) /*8200ul*/ );
  p->next = (struct header *)return_value_malloc_6;
  p = p->next;
  p->next = (struct header *)(void *)0;
  signed int return_value_soap_getline_7;
  return_value_soap_getline_7=soap_getline(sender, p->line, 8192);
  _Bool tmp_if_expr_8;
  signed int return_value_strncmp_11;
  signed int return_value_strncmp_12;
  signed int tmp_if_expr_10;
  if(!(return_value_soap_getline_7 == 0))
  {
    for( ; !(h == ((struct header *)NULL)); h = p)
    {
      p = h->next;
      free((void *)h);
    }
    sender->error = -1;
    return sender->error;
  }

  else
  {
    if(!(p->line[0l] == 0))
    {
      t=strchr(p->line, 58);
      s = t;
      if(!(t == ((char *)NULL)))
      {
        *t = (char)0;
        do
        {
          t = t + 1l;
          if(!(*t == 0))
            tmp_if_expr_8 = (signed int)*t <= 32 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_8 = (_Bool)0;
        }
        while(tmp_if_expr_8);
      }

      sender->fparsehdr(sender, p->line, t);
      if(!(s == ((char *)NULL)))
        *s = (char)58;

    }

    s=strstr(h->line, "HTTP/");
    if(!(s == ((char *)NULL)))
    {
      return_value_strncmp_11=strncmp(h->line, "GET ", (unsigned long int)4);
      _Bool tmp_if_expr_13;
      if(return_value_strncmp_11 == 0)
        tmp_if_expr_13 = (_Bool)1;

      else
      {
        return_value_strncmp_12=strncmp(h->line, "POST ", (unsigned long int)5);
        tmp_if_expr_13 = !(return_value_strncmp_12 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_13)
      {
        unsigned long int m;
        m=strlen(sender->endpoint);
        unsigned long int n = ((m + (unsigned long int)(s - h->line)) - (unsigned long int)5) - (unsigned long int)((signed int)h->line[0l] == 80);
        if(n >= sizeof(char [1024l]) /*1024ul*/ )
          n = sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1;

        signed int tmp_if_expr_9;
        if(!(n + -m >= sizeof(char [1024l]) /*1024ul*/ ))
        {
          strncpy(sender->path, h->line + (signed long int)4 + (signed long int)((signed int)h->line[0l] == 80), n - m);
          sender->path[(signed long int)(unsigned long int)(n - m)] = (char)0;
          tmp_if_expr_9 = (signed int)sender->path[(signed long int)(unsigned long int)(n - m)];
        }

        else
        {
          sender->path[(signed long int)0] = (char)0;
          tmp_if_expr_9 = (signed int)sender->path[(signed long int)0];
        }
        (void)(tmp_if_expr_9 != 0 ? (_Bool)1 : (_Bool)0);
        if(!(sender->endpoint + (signed long int)m == ((char *)NULL)))
        {
          if(!(n + -m >= sizeof(char [1024l]) /*1024ul*/  + -m))
          {
            strncpy(sender->endpoint + (signed long int)m, sender->path, n - m);
            (sender->endpoint + (signed long int)m)[(signed long int)(unsigned long int)(n - m)] = (char)0;
            tmp_if_expr_10 = (signed int)(sender->endpoint + (signed long int)m)[(signed long int)(unsigned long int)(n - m)];
          }

          else
          {
            (sender->endpoint + (signed long int)m)[(signed long int)0] = (char)0;
            tmp_if_expr_10 = (signed int)(sender->endpoint + (signed long int)m)[(signed long int)0];
          }
          if(!(tmp_if_expr_10 == 0))
            (_Bool)1;

          else
            (_Bool)0;
        }

        else
          (_Bool)0;
      }

    }

    _Bool tmp_if_expr_14;
    if(endpoint == ((const char *)NULL))
      tmp_if_expr_14 = (_Bool)1;

    else
      tmp_if_expr_14 = !(*endpoint != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_14)
      endpoint = sender->endpoint;

    _Bool tmp_if_expr_15;
    if(action == ((const char *)NULL))
      tmp_if_expr_15 = (_Bool)1;

    else
      tmp_if_expr_15 = !(*action != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_15)
      action = sender->action;

    signed int return_value_server_connect_16;
    return_value_server_connect_16=server_connect(receiver, endpoint, action, receiver->userid, receiver->passwd);
    if(!(return_value_server_connect_16 == 0))
    {
      for( ; !(h == ((struct header *)NULL)); h = p)
      {
        p = h->next;
        free((void *)h);
      }
      return receiver->error;
    }

    else
    {
      receiver->count = sender->length;
      soap_begin_send(receiver);
      receiver->mode = receiver->mode & ~0x00000003;
      receiver->mode = receiver->mode | 0x00000001;
      if(!(h == ((struct header *)NULL)))
      {
        receiver->fposthdr(receiver, h->line, (const char *)(void *)0);
        p = h->next;
        free((void *)h);
        h = p;
      }

      if((0x00000003 & sender->mode) == 0x00000003)
      {
        signed int return_value_soap_flush_17;
        return_value_soap_flush_17=soap_flush(receiver);
        if(!(return_value_soap_flush_17 == 0))
          return receiver->error;

        receiver->mode = receiver->mode & ~0x00000003;
        receiver->mode = receiver->mode | 0x00000003;
      }

      return 0;
    }
  }
}

// create_header
// file router.c line 709
signed int create_header(struct soap *server, signed int method, const char *endpoint, const char *action, unsigned long int count)
{
  signed int return_value_server_connect_1;
  return_value_server_connect_1=server_connect(server, endpoint, action, (const char *)(void *)0, (const char *)(void *)0);
  if(!(return_value_server_connect_1 == 0))
    return server->error;

  else
  {
    soap_begin_send(server);
    server->mode = server->mode & ~0x00000003;
    server->mode = server->mode | 0x00000001;
    server->status = method;
    server->error=server->fpost(server, server->endpoint, server->host, server->port, server->path, action, count);
    return server->error;
  }
}

// fplugin
// file stdsoap2.c line 18365
static void * fplugin(struct soap *soap, const char *id)
{
  struct soap_plugin *p = soap->plugins;
  signed int return_value_strcmp_1;
  for( ; !(p == ((struct soap_plugin *)NULL)); p = p->next)
  {
    _Bool tmp_if_expr_2;
    if(p->id == id)
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_strcmp_1=strcmp(p->id, id);
      tmp_if_expr_2 = !(return_value_strcmp_1 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
      return p->data;

  }
  return (void *)0;
}

// frecv
// file stdsoap2.c line 925
static unsigned long int frecv(struct soap *soap, char *s, unsigned long int n)
{
  signed int r;
  signed int retries = 100;
  signed int sk;
  soap->errnum = 0;
  void *return_value_memcpy_1;
  if(!(soap->is == ((const char *)NULL)))
  {
    unsigned long int l;
    l=strlen(soap->is);
    if(!(n >= l))
      l = n;

    if(n >= l && !(s == ((char *)NULL)))
    {
      return_value_memcpy_1=memcpy((void *)s, (const void *)soap->is, l);
      (signed int)!(return_value_memcpy_1 != NULL);
    }

    else
      34;
    soap->is = soap->is + (signed long int)l;
    return l;
  }

  sk = soap->recvsk;
  if(sk == -1)
    sk = soap->socket;

  signed long int return_value_recv_3;
  if(!(sk == -1))
    while((_Bool)1)
    {
      if(!(soap->recv_timeout == 0))
        do
        {
          r=tcp_select(soap, sk, 0x1 | 0x4, soap->recv_timeout);
          if(r >= 1)
            break;

          if(r == 0)
            return (unsigned long int)0;

          r = soap->errnum;
          if(!(r == 11))
            return (unsigned long int)0;

        }
        while((_Bool)1);

      if(!((0x00000004 & soap->omode) == 0))
      {
        unsigned int k = (unsigned int)sizeof(union anonymous) /*128ul*/ ;
        memset((void *)&soap->peer, 0, sizeof(union anonymous) /*128ul*/ );
        signed long int return_value_recvfrom_2;
        return_value_recvfrom_2=recvfrom(sk, (void *)s, (unsigned long int)n, soap->socket_flags, &soap->peer.addr, &k);
        r = (signed int)return_value_recvfrom_2;
        soap->peerlen = (unsigned long int)k;
      }

      else
      {
        return_value_recv_3=recv(sk, (void *)s, (unsigned long int)n, soap->socket_flags);
        r = (signed int)return_value_recv_3;
      }
      if(r >= 0)
        return (unsigned long int)r;

      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      r = *return_value___errno_location_4;
      if(!(r == 4) && !(r == 11))
      {
        soap->errnum = r;
        return (unsigned long int)0;
      }

      signed int tmp_if_expr_5;
      if(!(soap->recv_timeout == 0))
        tmp_if_expr_5 = soap->recv_timeout;

      else
        tmp_if_expr_5 = 5;
      r=tcp_select(soap, sk, 0x1 | 0x4, tmp_if_expr_5);
      if(r == 0)
      {
        if(!(soap->recv_timeout == 0))
          return (unsigned long int)0;

      }

      if(!(r >= 0))
      {
        r = soap->errnum;
        if(!(r == 11))
          return (unsigned long int)0;

      }

      signed int tmp_post_6 = retries;
      retries = retries - 1;
      if(!(tmp_post_6 >= 1))
        return (unsigned long int)0;

    }

  signed long int return_value_read_7;
  return_value_read_7=read(soap->recvfd, (void *)s, n);
  r = (signed int)return_value_read_7;
  if(r >= 0)
    return (unsigned long int)r;

  else
  {
    signed int *return_value___errno_location_8;
    return_value___errno_location_8=__errno_location();
    soap->errnum = *return_value___errno_location_8;
    return (unsigned long int)0;
  }
}

// fsend
// file stdsoap2.c line 562
static signed int fsend(struct soap *soap, const char *s, unsigned long int n)
{
  signed int nwritten;
  signed int err;
  signed int sk = soap->sendsk;
  if(sk == -1)
    sk = soap->socket;

  signed long int return_value_sendto_1;
  signed long int return_value_send_2;
  signed long int return_value_sendto_5;
  signed long int return_value_send_6;
  _Bool tmp_if_expr_4;
  signed long int return_value_send_8;
  for( ; !(n == 0ul); s = s + (signed long int)nwritten)
  {
    if(!(sk == -1))
    {
      if(!(soap->send_timeout == 0))
        do
        {
          signed int fsend__1__1__1__1__1__1__r;
          fsend__1__1__1__1__1__1__r=tcp_select(soap, sk, 0x2 | 0x4, soap->send_timeout);
          if(fsend__1__1__1__1__1__1__r >= 1)
            break;

          if(fsend__1__1__1__1__1__1__r == 0)
            return -1;

          err = soap->errnum;
          if(err == 0)
            return soap->error;

          if(!(err == 11))
            return -1;

        }
        while((_Bool)1);

      if(!((0x00000004 & soap->omode) == 0))
      {
        if(!(soap->peerlen == 0ul))
        {
          return_value_sendto_1=sendto(sk, (const void *)(char *)s, (unsigned long int)n, soap->socket_flags, &soap->peer.addr, (unsigned int)(unsigned long int)soap->peerlen);
          nwritten = (signed int)return_value_sendto_1;
        }

        else
        {
          return_value_send_2=send(sk, (const void *)s, (unsigned long int)n, soap->socket_flags);
          nwritten = (signed int)return_value_send_2;
        }
        if(!(nwritten >= 0))
        {
          signed int udp_repeat;
          signed int udp_delay;
          if(!((6 & soap->connect_flags) == 0))
            udp_repeat = 2;

          else
            udp_repeat = 1;
          signed long int return_value_random_3;
          return_value_random_3=random();
          udp_delay = (signed int)((unsigned int)(signed int)return_value_random_3 % (unsigned int)201 + (unsigned int)50);
          do
          {
            tcp_select(soap, sk, 0x4, -1000 * udp_delay);
            if(!(soap->peerlen == 0ul))
            {
              return_value_sendto_5=sendto(sk, (const void *)(char *)s, (unsigned long int)n, soap->socket_flags, &soap->peer.addr, (unsigned int)(unsigned long int)soap->peerlen);
              nwritten = (signed int)return_value_sendto_5;
            }

            else
            {
              return_value_send_6=send(sk, (const void *)s, (unsigned long int)n, soap->socket_flags);
              nwritten = (signed int)return_value_send_6;
            }
            udp_delay = udp_delay << 1;
            if(udp_delay >= 501)
              udp_delay = 500;

            if(!(nwritten >= 0))
            {
              udp_repeat = udp_repeat - 1;
              tmp_if_expr_4 = udp_repeat > 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_4 = (_Bool)0;
          }
          while(tmp_if_expr_4);
        }

        if(!(nwritten >= 0))
        {
          signed int *return_value___errno_location_7;
          return_value___errno_location_7=__errno_location();
          err = *return_value___errno_location_7;
          if(!(err == 0) && !(err == 4))
          {
            soap->errnum = err;
            return -1;
          }

          nwritten = 0;
        }

      }

      else
      {
        return_value_send_8=send(sk, (const void *)s, (unsigned long int)(signed int)n, soap->socket_flags);
        nwritten = (signed int)return_value_send_8;
      }
      if(!(nwritten >= 1))
      {
        signed int r = 0;
        signed int *return_value___errno_location_9;
        return_value___errno_location_9=__errno_location();
        err = *return_value___errno_location_9;
        if(err == 11)
        {
          signed int tmp_if_expr_10;
          if(!(soap->send_timeout == 0))
            tmp_if_expr_10 = soap->send_timeout;

          else
            tmp_if_expr_10 = -10000;
          r=tcp_select(soap, sk, 0x2 | 0x4, tmp_if_expr_10);
          if(r == 0)
          {
            if(!(soap->send_timeout == 0))
              return -1;

          }

          if(!(r >= 0))
            return -1;

        }

        else
          if(!(err == 0) && !(err == 4))
          {
            soap->errnum = err;
            return -1;
          }

        nwritten = 0;
      }

    }

    else
    {
      signed long int return_value_write_11;
      return_value_write_11=write(soap->sendfd, (const void *)s, (unsigned long int)(unsigned int)n);
      nwritten = (signed int)return_value_write_11;
      if(!(nwritten >= 1))
      {
        signed int *return_value___errno_location_12;
        return_value___errno_location_12=__errno_location();
        err = *return_value___errno_location_12;
        if(!(err == 0) && !(err == 4) && !(err == 11))
        {
          soap->errnum = err;
          return -1;
        }

        nwritten = 0;
      }

    }
    n = n - (unsigned long int)nwritten;
  }
  return 0;
}

// http_200
// file stdsoap2.c line 6353
static signed int http_200(struct soap *soap)
{
  signed int return_value_soap_send_empty_response_1;
  return_value_soap_send_empty_response_1=soap_send_empty_response(soap, 200);
  return return_value_soap_send_empty_response_1;
}

// http_405
// file stdsoap2.c line 6341
static signed int http_405(struct soap *soap)
{
  (void)soap;
  return 405;
}

// http_error
// file stdsoap2.c line 6309
static const char * http_error(struct soap *soap, signed int status)
{
  const char *msg = soap_padding;
  (void)soap;
  (void)status;
  msg=soap_code_str(h_http_error_codes, (signed long int)status);
  if(msg == ((const char *)NULL))
    msg = soap_padding;

  return msg;
}

// http_get
// file stdsoap2.c line 6328
static signed int http_get(struct soap *soap)
{
  (void)soap;
  return 15;
}

// http_parse
// file stdsoap2.c line 5894
static signed int http_parse(struct soap *soap)
{
  char header[8192l];
  char *s;
  unsigned short int httpcmd = (unsigned short int)0;
  signed int status = 0;
  soap->endpoint[0l] = (char)0;
  soap->userid = (const char *)(void *)0;
  soap->passwd = (const char *)(void *)0;
  soap->authrealm = (const char *)(void *)0;
  soap->proxy_from = (const char *)(void *)0;
  _Bool tmp_if_expr_5;
  do
  {
    soap->length = (unsigned long int)0;
    soap->http_content = (const char *)(void *)0;
    soap->action = (char *)(void *)0;
    soap->status = 0;
    soap->body = (signed short int)1;
    signed int return_value_soap_getline_1;
    return_value_soap_getline_1=soap_getline(soap, soap->msgbuf, (signed int)sizeof(char [1024l]) /*1024ul*/ );
    if(!(return_value_soap_getline_1 == 0))
    {
      if(soap->error == -1)
        return -1;

      soap->error = 414;
      return soap->error;
    }

    s=strchr(soap->msgbuf, 32);
    if(!(s == ((char *)NULL)))
    {
      unsigned long int return_value_strtoul_2;
      return_value_strtoul_2=strtoul(s, &s, 10);
      soap->status = (signed int)(unsigned short int)return_value_strtoul_2;
      _Bool tmp_if_expr_3;
      if(1 + (signed int)*s >= 1)
        tmp_if_expr_3 = (signed int)*s <= 32 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(!tmp_if_expr_3)
        soap->status = 0;

    }

    else
      soap->status = 0;
    do
    {
      signed int return_value_soap_getline_4;
      return_value_soap_getline_4=soap_getline(soap, header, 8192);
      if(!(return_value_soap_getline_4 == 0))
      {
        if(soap->error == -1)
        {
          soap->error = 0;
          break;
        }

        return soap->error;
      }

      if(header[0l] == 0)
        break;

      s=strchr(header, 58);
      if(!(s == ((char *)NULL)))
      {
        char *t;
        *s = (char)0;
        do
        {
          s = s + 1l;
          if(!(*s == 0))
            tmp_if_expr_5 = (signed int)*s <= 32 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_5 = (_Bool)0;
        }
        while(tmp_if_expr_5);
        if((signed int)*s == 34)
          s = s + 1l;

        unsigned long int return_value_strlen_6;
        return_value_strlen_6=strlen(s);
        t = (s + (signed long int)return_value_strlen_6) - (signed long int)1;
        for( ; !(s >= t); t = t - 1l)
          if((signed int)*t >= 33)
            break;

        if(t >= s)
        {
          if((signed int)*t == 34)
            t = t - 1l;

        }

        t[(signed long int)1] = (char)0;
        soap->error=soap->fparsehdr(soap, header, s);
        if(!(soap->error == 0))
        {
          if(!(soap->error >= 1000))
            return soap->error;

          status = soap->error;
          soap->error = 0;
        }

      }

    }
    while((_Bool)1);
  }
  while(soap->status == 100);
  s=strstr(soap->msgbuf, "HTTP/");
  if(!(s == ((char *)NULL)))
  {
    if(!((signed int)s[7l] == 49))
    {
      if((signed int)soap->keep_alive == 1)
        soap->keep_alive = (signed short int)0;

      if(soap->status == 0)
      {
        if((0x00000003 & soap->omode) == 0x00000003)
          soap->omode = soap->omode & ~0x00000003 | 0x00000002;

      }

    }

  }

  if(!((signed int)soap->keep_alive >= 0))
    soap->keep_alive = (signed short int)1;

  signed int return_value_strncmp_11;
  signed int return_value_strncmp_10;
  signed int return_value_strncmp_9;
  signed int return_value_strncmp_8;
  signed int return_value_strncmp_7;
  unsigned long int return_value_strlen_15;
  if(soap->status == 0)
  {
    unsigned long int l = (unsigned long int)0;
    if(!(s == ((char *)NULL)))
    {
      l = (unsigned long int)5;
      signed int return_value_strncmp_12;
      return_value_strncmp_12=strncmp(soap->msgbuf, "POST ", l);
      if(return_value_strncmp_12 == 0)
        httpcmd = (unsigned short int)1;

      else
      {
        l = (unsigned long int)4;
        return_value_strncmp_11=strncmp(soap->msgbuf, "PUT ", l);
        if(return_value_strncmp_11 == 0)
          httpcmd = (unsigned short int)2;

        else
        {
          l = (unsigned long int)4;
          return_value_strncmp_10=strncmp(soap->msgbuf, "GET ", l);
          if(return_value_strncmp_10 == 0)
            httpcmd = (unsigned short int)3;

          else
          {
            l = (unsigned long int)7;
            return_value_strncmp_9=strncmp(soap->msgbuf, "DELETE ", l);
            if(return_value_strncmp_9 == 0)
              httpcmd = (unsigned short int)4;

            else
            {
              l = (unsigned long int)8;
              return_value_strncmp_8=strncmp(soap->msgbuf, "OPTIONS ", l);
              if(return_value_strncmp_8 == 0)
                httpcmd = (unsigned short int)5;

              else
              {
                l = (unsigned long int)5;
                return_value_strncmp_7=strncmp(soap->msgbuf, "HEAD ", l);
                if(return_value_strncmp_7 == 0)
                  httpcmd = (unsigned short int)6;

              }
            }
          }
        }
      }
    }

    if(!(s == ((char *)NULL)) && !(httpcmd == 0))
    {
      unsigned long int m;
      unsigned long int n;
      unsigned long int k;
      for( ; 1 + (signed int)soap->msgbuf[(signed long int)l] >= 1; l = l + 1ul)
        if((signed int)soap->msgbuf[(signed long int)l] >= 33)
          break;

      m=strlen(soap->endpoint);
      n = ((m + (unsigned long int)(s - soap->msgbuf)) - l) - (unsigned long int)1;
      if(n >= sizeof(char [1024l]) /*1024ul*/ )
        n = sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1;

      if(!(n >= m))
        m = n;

      k = (n - m) + (unsigned long int)1;
      if(k >= sizeof(char [1024l]) /*1024ul*/ )
        k = sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1;

      for( ; k >= 1ul; k = k - 1ul)
      {
        if(!(1 + (signed int)soap->msgbuf[-1l + (signed long int)k + (signed long int)l] >= 1))
          break;

        if((signed int)soap->msgbuf[-1l + (signed long int)k + (signed long int)l] >= 33)
          break;

      }
      signed int tmp_if_expr_13;
      if(!(k >= sizeof(char [1024l]) /*1024ul*/ ))
      {
        strncpy(soap->path, soap->msgbuf + (signed long int)l, k);
        soap->path[(signed long int)(unsigned long int)k] = (char)0;
        tmp_if_expr_13 = (signed int)soap->path[(signed long int)(unsigned long int)k];
      }

      else
      {
        soap->path[(signed long int)0] = (char)0;
        tmp_if_expr_13 = (signed int)soap->path[(signed long int)0];
      }
      (void)(tmp_if_expr_13 != 0 ? (_Bool)1 : (_Bool)0);
      _Bool tmp_if_expr_17;
      if(!(soap->path[0l] == 0))
        tmp_if_expr_17 = (signed int)soap->path[0l] != 47 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_17 = (_Bool)0;
      if(tmp_if_expr_17)
      {
        signed int tmp_if_expr_14;
        if(!(k >= sizeof(char [1024l]) /*1024ul*/ ))
        {
          strncpy(soap->endpoint, soap->path, k);
          soap->endpoint[(signed long int)(unsigned long int)k] = (char)0;
          tmp_if_expr_14 = (signed int)soap->endpoint[(signed long int)(unsigned long int)k];
        }

        else
        {
          soap->endpoint[(signed long int)0] = (char)0;
          tmp_if_expr_14 = (signed int)soap->endpoint[(signed long int)0];
        }
        (void)(tmp_if_expr_14 != 0 ? (_Bool)1 : (_Bool)0);
      }

      else
      {
        return_value_strlen_15=strlen(soap->endpoint);
        signed int tmp_if_expr_16;
        if(!(return_value_strlen_15 + k >= sizeof(char [1024l]) /*1024ul*/ ))
        {
          strncat(soap->endpoint, soap->path, k);
          soap->endpoint[(signed long int)((unsigned long int)sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
          tmp_if_expr_16 = (signed int)soap->endpoint[(signed long int)((unsigned long int)sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)];
        }

        else
        {
          soap->endpoint[(signed long int)0] = (char)0;
          tmp_if_expr_16 = (signed int)soap->endpoint[(signed long int)0];
        }
        (void)(tmp_if_expr_16 != 0 ? (_Bool)1 : (_Bool)0);
      }
      if((signed int)httpcmd >= 2)
      {
        switch((signed int)httpcmd)
        {
          case 2:
            soap->error=soap->fput(soap);
          case 3:
            soap->error=soap->fget(soap);
          case 4:
            soap->error=soap->fdel(soap);
          case 5:
            soap->error=soap->fopt(soap);
          case 6:
            soap->error=soap->fhead(soap);
        }
        soap->error = 405;
        if(soap->error == 0)
          soap->error = 1000;

        return soap->error;
      }

      if(!(status == 0))
      {
        soap->error = status;
        return soap->error;
      }

    }

    else
      if(!(status == 0))
      {
        soap->error = status;
        return soap->error;
      }

      else
        if(!(s == ((char *)NULL)))
        {
          soap->error = 405;
          return soap->error;
        }

    return 0;
  }

  signed int return_value_soap_set_receiver_error_21;
  if(!(soap->body == 0))
  {
    _Bool tmp_if_expr_18;
    if(soap->status >= 200)
      tmp_if_expr_18 = soap->status <= 299 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_18 = (_Bool)0;
    _Bool tmp_if_expr_19;
    if(tmp_if_expr_18)
      tmp_if_expr_19 = (_Bool)1;

    else
      tmp_if_expr_19 = soap->status == 400 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr_20;
    if(tmp_if_expr_19)
      tmp_if_expr_20 = (_Bool)1;

    else
      tmp_if_expr_20 = soap->status == 500 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_20)
    {
      soap->error = 0;
      return soap->error;
    }

    soap->keep_alive = (signed short int)0;
    s=soap_get_http_body(soap, (unsigned long int *)(void *)0);
    if(!(s == ((char *)NULL)))
    {
      return_value_soap_set_receiver_error_21=soap_set_receiver_error(soap, soap->msgbuf, s, soap->status);
      return return_value_soap_set_receiver_error_21;
    }

  }

  else
    if(soap->status >= 200)
    {
      if(!(soap->status >= 300))
      {
        soap->error = soap->status;
        return soap->error;
      }

    }

  signed int return_value_soap_set_receiver_error_22;
  return_value_soap_set_receiver_error_22=soap_set_receiver_error(soap, "HTTP Error", soap->msgbuf, soap->status);
  return return_value_soap_set_receiver_error_22;
}

// http_parse_header
// file stdsoap2.c line 6067
static signed int http_parse_header(struct soap *soap, const char *key, const char *val)
{
  signed int return_value_soap_tag_cmp_35;
  return_value_soap_tag_cmp_35=soap_tag_cmp(key, "Host");
  signed int return_value_soap_tag_cmp_34;
  const char *return_value_soap_get_header_attribute_5;
  const char *return_value_soap_get_header_attribute_6;
  unsigned long int return_value_strlen_9;
  signed int return_value_soap_tag_cmp_33;
  signed int return_value_soap_tag_cmp_32;
  signed int return_value_soap_tag_cmp_10;
  signed int return_value_soap_tag_cmp_31;
  signed int return_value_soap_tag_cmp_30;
  signed int return_value_soap_tag_cmp_13;
  signed int return_value_soap_tag_cmp_27;
  signed int return_value_soap_tag_cmp_28;
  signed int return_value_soap_tag_cmp_24;
  signed int return_value_soap_tag_cmp_25;
  signed int return_value_soap_tag_cmp_23;
  signed int return_value_soap_tag_cmp_22;
  unsigned long int return_value_strlen_19;
  signed int return_value_soap_tag_cmp_21;
  signed int return_value_soap_tag_cmp_20;
  if(return_value_soap_tag_cmp_35 == 0)
  {
    strncpy(soap->endpoint, "http://", sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
    soap->endpoint[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
    (void)(soap->endpoint[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(soap->endpoint);
    signed int tmp_if_expr_2;
    if(!(1015ul + return_value_strlen_1 >= sizeof(char [1024l]) /*1024ul*/ ))
    {
      strncat(soap->endpoint, val, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)9);
      soap->endpoint[(signed long int)((unsigned long int)sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
      tmp_if_expr_2 = (signed int)soap->endpoint[(signed long int)((unsigned long int)sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)];
    }

    else
    {
      soap->endpoint[(signed long int)0] = (char)0;
      tmp_if_expr_2 = (signed int)soap->endpoint[(signed long int)0];
    }
    (void)(tmp_if_expr_2 != 0 ? (_Bool)1 : (_Bool)0);
  }

  else
  {
    return_value_soap_tag_cmp_34=soap_tag_cmp(key, "Content-Type");
    if(return_value_soap_tag_cmp_34 == 0)
    {
      const char *action;
      soap->http_content=soap_strdup(soap, val);
      const char *return_value_soap_get_header_attribute_8;
      return_value_soap_get_header_attribute_8=soap_get_header_attribute(soap, val, "application/dime");
      if(!(return_value_soap_get_header_attribute_8 == ((const char *)NULL)))
        soap->imode = soap->imode | 0x00000080;

      else
      {
        return_value_soap_get_header_attribute_5=soap_get_header_attribute(soap, val, "multipart/related");
        _Bool tmp_if_expr_7;
        if(!(return_value_soap_get_header_attribute_5 == ((const char *)NULL)))
          tmp_if_expr_7 = (_Bool)1;

        else
        {
          return_value_soap_get_header_attribute_6=soap_get_header_attribute(soap, val, "multipart/form-data");
          tmp_if_expr_7 = return_value_soap_get_header_attribute_6 != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_7)
        {
          const char *return_value_soap_get_header_attribute_3;
          return_value_soap_get_header_attribute_3=soap_get_header_attribute(soap, val, "boundary");
          soap->mime.boundary=soap_strdup(soap, return_value_soap_get_header_attribute_3);
          const char *return_value_soap_get_header_attribute_4;
          return_value_soap_get_header_attribute_4=soap_get_header_attribute(soap, val, "start");
          soap->mime.start=soap_strdup(soap, return_value_soap_get_header_attribute_4);
          soap->imode = soap->imode | 0x00000100;
        }

      }
      action=soap_get_header_attribute(soap, val, "action");
      if(!(action == ((const char *)NULL)))
      {
        if((signed int)*action == 34)
        {
          soap->action=soap_strdup(soap, action + (signed long int)1);
          if(!(*soap->action == 0))
          {
            return_value_strlen_9=strlen(soap->action);
            soap->action[(signed long int)(return_value_strlen_9 - (unsigned long int)1)] = (char)0;
          }

        }

        else
          soap->action=soap_strdup(soap, action);
      }

    }

    else
    {
      return_value_soap_tag_cmp_33=soap_tag_cmp(key, "Content-Length");
      if(return_value_soap_tag_cmp_33 == 0)
      {
        soap->length=strtoul(val, (char ** restrict )(void *)0, 10);
        if(soap->length == 0ul)
          soap->body = (signed short int)0;

      }

      else
      {
        return_value_soap_tag_cmp_32=soap_tag_cmp(key, "Content-Encoding");
        if(return_value_soap_tag_cmp_32 == 0)
        {
          signed int return_value_soap_tag_cmp_11;
          return_value_soap_tag_cmp_11=soap_tag_cmp(val, "deflate");
          if(return_value_soap_tag_cmp_11 == 0)
            return 31;

          else
          {
            return_value_soap_tag_cmp_10=soap_tag_cmp(val, "gzip");
            if(return_value_soap_tag_cmp_10 == 0)
              return 31;

          }
        }

        else
        {
          return_value_soap_tag_cmp_31=soap_tag_cmp(key, "Transfer-Encoding");
          if(return_value_soap_tag_cmp_31 == 0)
          {
            soap->imode = soap->imode & ~0x00000003;
            signed int return_value_soap_tag_cmp_12;
            return_value_soap_tag_cmp_12=soap_tag_cmp(val, "chunked");
            if(return_value_soap_tag_cmp_12 == 0)
              soap->imode = soap->imode | 0x00000003;

          }

          else
          {
            return_value_soap_tag_cmp_30=soap_tag_cmp(key, "Connection");
            if(return_value_soap_tag_cmp_30 == 0)
            {
              signed int return_value_soap_tag_cmp_14;
              return_value_soap_tag_cmp_14=soap_tag_cmp(val, "keep-alive");
              if(return_value_soap_tag_cmp_14 == 0)
                soap->keep_alive = (signed short int)-((signed int)soap->keep_alive);

              else
              {
                return_value_soap_tag_cmp_13=soap_tag_cmp(val, "close");
                if(return_value_soap_tag_cmp_13 == 0)
                  soap->keep_alive = (signed short int)0;

              }
            }

            else
            {
              return_value_soap_tag_cmp_27=soap_tag_cmp(key, "Authorization");
              _Bool tmp_if_expr_29;
              if(return_value_soap_tag_cmp_27 == 0)
                tmp_if_expr_29 = (_Bool)1;

              else
              {
                return_value_soap_tag_cmp_28=soap_tag_cmp(key, "Proxy-Authorization");
                tmp_if_expr_29 = !(return_value_soap_tag_cmp_28 != 0) ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_29)
              {
                signed int return_value_soap_tag_cmp_15;
                return_value_soap_tag_cmp_15=soap_tag_cmp(val, "Basic *");
                if(return_value_soap_tag_cmp_15 == 0)
                {
                  signed int n;
                  char *s;
                  soap_base642s(soap, val + (signed long int)6, soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1, &n);
                  soap->tmpbuf[(signed long int)n] = (char)0;
                  s=strchr(soap->tmpbuf, 58);
                  if(!(s == ((char *)NULL)))
                  {
                    *s = (char)0;
                    soap->userid=soap_strdup(soap, soap->tmpbuf);
                    soap->passwd=soap_strdup(soap, s + (signed long int)1);
                  }

                }

              }

              else
              {
                return_value_soap_tag_cmp_24=soap_tag_cmp(key, "WWW-Authenticate");
                _Bool tmp_if_expr_26;
                if(return_value_soap_tag_cmp_24 == 0)
                  tmp_if_expr_26 = (_Bool)1;

                else
                {
                  return_value_soap_tag_cmp_25=soap_tag_cmp(key, "Proxy-Authenticate");
                  tmp_if_expr_26 = !(return_value_soap_tag_cmp_25 != 0) ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_26)
                {
                  const char *return_value_soap_get_header_attribute_16;
                  return_value_soap_get_header_attribute_16=soap_get_header_attribute(soap, val + (signed long int)6, "realm");
                  soap->authrealm=soap_strdup(soap, return_value_soap_get_header_attribute_16);
                }

                else
                {
                  return_value_soap_tag_cmp_23=soap_tag_cmp(key, "Expect");
                  if(return_value_soap_tag_cmp_23 == 0)
                  {
                    signed int return_value_soap_tag_cmp_18;
                    return_value_soap_tag_cmp_18=soap_tag_cmp(val, "100-continue");
                    if(return_value_soap_tag_cmp_18 == 0)
                    {
                      soap->error=soap->fposthdr(soap, "HTTP/1.1 100 Continue", (const char *)(void *)0);
                      _Bool tmp_if_expr_17;
                      if(!(soap->error == 0))
                        tmp_if_expr_17 = (_Bool)1;

                      else
                      {
                        soap->error=soap->fposthdr(soap, (const char *)(void *)0, (const char *)(void *)0);
                        tmp_if_expr_17 = soap->error != 0 ? (_Bool)1 : (_Bool)0;
                      }
                      if(tmp_if_expr_17)
                        return soap->error;

                    }

                  }

                  else
                  {
                    return_value_soap_tag_cmp_22=soap_tag_cmp(key, "SOAPAction");
                    if(return_value_soap_tag_cmp_22 == 0)
                    {
                      if((signed int)*val == 34)
                      {
                        soap->action=soap_strdup(soap, val + (signed long int)1);
                        if(!(*soap->action == 0))
                        {
                          return_value_strlen_19=strlen(soap->action);
                          soap->action[(signed long int)(return_value_strlen_19 - (unsigned long int)1)] = (char)0;
                        }

                      }

                      else
                        soap->action=soap_strdup(soap, val);
                    }

                    else
                    {
                      return_value_soap_tag_cmp_21=soap_tag_cmp(key, "Location");
                      if(return_value_soap_tag_cmp_21 == 0)
                      {
                        strncpy(soap->endpoint, val, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
                        soap->endpoint[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
                        (void)(soap->endpoint[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
                      }

                      else
                      {
                        return_value_soap_tag_cmp_20=soap_tag_cmp(key, "X-Forwarded-For");
                        if(return_value_soap_tag_cmp_20 == 0)
                          soap->proxy_from=soap_strdup(soap, val);

                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

// http_post
// file stdsoap2.c line 6364
static signed int http_post(struct soap *soap, const char *endpoint, const char *host, signed int port, const char *path, const char *action, unsigned long int count)
{
  const char *s;
  signed int err;
  unsigned long int l;
  switch(soap->status)
  {
    case 2002:
    {
      s = "GET";
      break;
    }
    case 2003:
    {
      s = "PUT";
      break;
    }
    case 2004:
    {
      s = "DELETE";
      break;
    }
    case 2005:
    {
      s = "CONNECT";
      break;
    }
    default:
      s = "POST";
  }
  _Bool tmp_if_expr_6;
  signed int return_value_soap_tag_cmp_1;
  _Bool tmp_if_expr_3;
  signed int return_value_soap_tag_cmp_2;
  _Bool tmp_if_expr_5;
  signed int return_value_soap_tag_cmp_4;
  if(endpoint == ((const char *)NULL))
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    return_value_soap_tag_cmp_1=soap_tag_cmp(endpoint, "http:*");
    if(!(return_value_soap_tag_cmp_1 == 0))
    {
      return_value_soap_tag_cmp_2=soap_tag_cmp(endpoint, "https:*");
      tmp_if_expr_3 = return_value_soap_tag_cmp_2 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
    {
      return_value_soap_tag_cmp_4=soap_tag_cmp(endpoint, "httpg:*");
      tmp_if_expr_5 = return_value_soap_tag_cmp_4 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_5 = (_Bool)0;
    tmp_if_expr_6 = tmp_if_expr_5 ? (_Bool)1 : (_Bool)0;
  }
  char *return_value_strchr_9;
  char *return_value_strchr_11;
  if(tmp_if_expr_6)
    return 0;

  else
  {
    unsigned long int return_value_strlen_7;
    return_value_strlen_7=strlen(endpoint);
    unsigned long int return_value_strlen_8;
    return_value_strlen_8=strlen(soap->http_version);
    l = return_value_strlen_7 + return_value_strlen_8 + (unsigned long int)80;
    if(l >= 1025ul)
    {
      soap->error = 20;
      return soap->error;
    }

    else
    {
      if(soap->status == 2005)
        snprintf(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , "%s %s:%d HTTP/%s", s, (const void *)soap->host, soap->port, soap->http_version);

      else
        if(!(soap->proxy_host == ((const char *)NULL)) && !(endpoint == ((const char *)NULL)))
          snprintf(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , "%s %s HTTP/%s", s, endpoint, soap->http_version);

        else
          snprintf(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , "%s /%s HTTP/%s", s, (signed int)*path == 47 ? path + (signed long int)1 : path, soap->http_version);
      err=soap->fposthdr(soap, soap->tmpbuf, (const char *)(void *)0);
      if(!(err == 0))
        return err;

      else
      {
        if(!(port == 80))
        {
          _Bool tmp_if_expr_10;
          if(!((signed int)*host == 91))
          {
            return_value_strchr_9=strchr(host, 58);
            tmp_if_expr_10 = return_value_strchr_9 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_10 = (_Bool)0;
          if(tmp_if_expr_10)
            snprintf(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , "[%s]:%d", host, port);

          else
            snprintf(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , "%s:%d", host, port);
        }

        else
        {
          _Bool tmp_if_expr_12;
          if(!((signed int)*host == 91))
          {
            return_value_strchr_11=strchr(host, 58);
            tmp_if_expr_12 = return_value_strchr_11 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_12 = (_Bool)0;
          if(tmp_if_expr_12)
            snprintf(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , "[%s]", host);

          else
          {
            strncpy(soap->tmpbuf, host, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
            soap->tmpbuf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
            (void)(soap->tmpbuf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
          }
        }
        err=soap->fposthdr(soap, "Host", soap->tmpbuf);
        if(!(err == 0))
          return err;

        else
        {
          err=soap->fposthdr(soap, "User-Agent", "gSOAP/2.8");
          if(!(err == 0))
            return err;

          else
          {
            err=soap_puthttphdr(soap, 0, count);
            if(!(err == 0))
              return err;

            else
            {
              if(!(soap->userid == ((const char *)NULL)))
              {
                if(!(soap->passwd == ((const char *)NULL)))
                {
                  unsigned long int return_value_strlen_13;
                  return_value_strlen_13=strlen(soap->userid);
                  unsigned long int return_value_strlen_14;
                  return_value_strlen_14=strlen(soap->passwd);
                  l = return_value_strlen_13 + return_value_strlen_14;
                  strncpy(soap->tmpbuf, "Basic ", sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
                  soap->tmpbuf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
                  (void)(soap->tmpbuf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
                  snprintf(soap->tmpbuf + (signed long int)262, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)262, "%s:%s", soap->userid, soap->passwd);
                  unsigned long int return_value_strlen_15;
                  return_value_strlen_15=strlen(soap->tmpbuf + (signed long int)262);
                  soap_s2base64(soap, (const unsigned char *)(soap->tmpbuf + (signed long int)262), soap->tmpbuf + (signed long int)6, (signed int)return_value_strlen_15);
                  err=soap->fposthdr(soap, "Authorization", soap->tmpbuf);
                  if(!(err == 0))
                    return err;

                }

              }

              if(!(soap->proxy_userid == ((const char *)NULL)))
              {
                if(!(soap->proxy_passwd == ((const char *)NULL)))
                {
                  unsigned long int return_value_strlen_16;
                  return_value_strlen_16=strlen(soap->proxy_userid);
                  unsigned long int return_value_strlen_17;
                  return_value_strlen_17=strlen(soap->proxy_passwd);
                  l = return_value_strlen_16 + return_value_strlen_17;
                  strncpy(soap->tmpbuf, "Basic ", sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
                  soap->tmpbuf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
                  (void)(soap->tmpbuf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
                  snprintf(soap->tmpbuf + (signed long int)262, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)262, "%s:%s", soap->proxy_userid, soap->proxy_passwd);
                  unsigned long int return_value_strlen_18;
                  return_value_strlen_18=strlen(soap->tmpbuf + (signed long int)262);
                  soap_s2base64(soap, (const unsigned char *)(soap->tmpbuf + (signed long int)262), soap->tmpbuf + (signed long int)6, (signed int)return_value_strlen_18);
                  err=soap->fposthdr(soap, "Proxy-Authorization", soap->tmpbuf);
                  if(!(err == 0))
                    return err;

                }

              }

              if(!(action == ((const char *)NULL)))
              {
                snprintf(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , "\"%s\"", action);
                err=soap->fposthdr(soap, "SOAPAction", soap->tmpbuf);
                return err;
              }

              else
              {
                signed int return_value;
                return_value=soap->fposthdr(soap, (const char *)(void *)0, (const char *)(void *)0);
                return return_value;
              }
            }
          }
        }
      }
    }
  }
}

// http_post_header
// file stdsoap2.c line 6520
static signed int http_post_header(struct soap *soap, const char *key, const char *val)
{
  signed int return_value_soap_send_raw_2;
  signed int return_value_http_send_header_3;
  if(!(key == ((const char *)NULL)))
  {
    signed int return_value_http_send_header_1;
    return_value_http_send_header_1=http_send_header(soap, key);
    if(!(return_value_http_send_header_1 == 0))
      return soap->error;

    if(!(val == ((const char *)NULL)))
    {
      return_value_soap_send_raw_2=soap_send_raw(soap, ": ", (unsigned long int)2);
      _Bool tmp_if_expr_4;
      if(!(return_value_soap_send_raw_2 == 0))
        tmp_if_expr_4 = (_Bool)1;

      else
      {
        return_value_http_send_header_3=http_send_header(soap, val);
        tmp_if_expr_4 = return_value_http_send_header_3 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_4)
        return soap->error;

    }

  }

  signed int return_value_soap_send_raw_5;
  return_value_soap_send_raw_5=soap_send_raw(soap, "\r\n", (unsigned long int)2);
  return return_value_soap_send_raw_5;
}

// http_response
// file stdsoap2.c line 6537
static signed int http_response(struct soap *soap, signed int status, unsigned long int count)
{
  signed int err;
  char http[16l];
  signed int code = status;
  const char *line;
  _Bool tmp_if_expr_1;
  if(!(soap->master == -1))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = soap->socket != (signed int)-1 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    snprintf(http, sizeof(char [16l]) /*16ul*/ , "HTTP/%s", soap->http_version);

  else
  {
    strncpy(http, "Status:", sizeof(char [16l]) /*16ul*/  - (unsigned long int)1);
    http[(signed long int)(sizeof(char [16l]) /*16ul*/  - (unsigned long int)1)] = (char)0;
    (void)(http[(signed long int)(sizeof(char [16l]) /*16ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
  }
  _Bool tmp_if_expr_5;
  signed int return_value_strcmp_4;
  if(status == 0 || status == 1002 || status == 1003)
  {
    _Bool tmp_if_expr_2;
    if(!(count == 0ul))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = (soap->omode & 0x00000003) == 0x00000003 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      code = 200;

    else
      code = 202;
  }

  else
    if(status >= 600 || !(status >= 200))
    {
      const char *s;
      const char **return_value_soap_faultcode_3;
      return_value_soap_faultcode_3=soap_faultcode(soap);
      s = *return_value_soap_faultcode_3;
      if(status >= 15 && !(status >= 20))
        code = 405;

      else
      {
        _Bool tmp_if_expr_6;
        if((signed int)soap->version == 2)
        {
          if(s == ((const char *)NULL))
            tmp_if_expr_5 = (_Bool)1;

          else
          {
            return_value_strcmp_4=strcmp(s, "SOAP-ENV:Sender");
            tmp_if_expr_5 = !(return_value_strcmp_4 != 0) ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_6 = tmp_if_expr_5 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_6 = (_Bool)0;
        if(tmp_if_expr_6)
          code = 400;

        else
          code = 500;
      }
    }

  line=http_error(soap, code);
  snprintf(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , "%s %d %s", (const void *)http, code, line);
  err=soap->fposthdr(soap, soap->tmpbuf, (const char *)(void *)0);
  unsigned long int return_value_strlen_7;
  if(!(err == 0))
    return err;

  else
  {
    if(status == 401)
    {
      _Bool tmp_if_expr_8;
      if(!(soap->authrealm == ((const char *)NULL)))
      {
        return_value_strlen_7=strlen(soap->authrealm);
        tmp_if_expr_8 = return_value_strlen_7 + (unsigned long int)14 < sizeof(char [1024l]) /*1024ul*/  ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_8 = (_Bool)0;
      const char *tmp_if_expr_9;
      if(tmp_if_expr_8)
        tmp_if_expr_9 = soap->authrealm;

      else
        tmp_if_expr_9 = "gSOAP Web Service";
      snprintf(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , "Basic realm=\"%s\"", tmp_if_expr_9);
      err=soap->fposthdr(soap, "WWW-Authenticate", soap->tmpbuf);
      if(!(err == 0))
        return err;

    }

    else
      if(status == 307 || status >= 301 && !(status >= 304))
      {
        err=soap->fposthdr(soap, "Location", soap->endpoint);
        if(!(err == 0))
          return err;

      }

    err=soap->fposthdr(soap, "Server", "gSOAP/2.8");
    _Bool tmp_if_expr_10;
    if(!(err == 0))
      tmp_if_expr_10 = (_Bool)1;

    else
    {
      err=soap_puthttphdr(soap, status, count);
      tmp_if_expr_10 = err != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_10)
      return err;

    else
    {
      signed int return_value;
      return_value=soap->fposthdr(soap, (const char *)(void *)0, (const char *)(void *)0);
      return return_value;
    }
  }
}

// http_send_header
// file stdsoap2.c line 6500
static signed int http_send_header(struct soap *soap, const char *s)
{
  const char *t;
  unsigned long int return_value_strlen_1;
  do
  {
    t=strchr(s, 10);
    if(t == ((const char *)NULL))
    {
      return_value_strlen_1=strlen(s);
      t = s + (signed long int)return_value_strlen_1;
    }

    signed int return_value_soap_send_raw_2;
    return_value_soap_send_raw_2=soap_send_raw(soap, s, (unsigned long int)(t - s));
    if(!(return_value_soap_send_raw_2 == 0))
      return soap->error;

    s = t + (signed long int)1;
  }
  while(!(*t == 0));
  return 0;
}

// lookup
// file router.c line 510
const char * lookup(struct t__RoutingTable *route, const char *key, const char *userid, const char *passwd)
{
  signed int return_value_soap_tag_cmp_2;
  signed int return_value_soap_tag_cmp_4;
  struct t__RoutingTable *return_value_soap_get_t__RoutingTable_7;
  if(key == ((const char *)NULL))
    return (const char *)(void *)0;

  else
  {
    if(route->__ptr == ((struct t__Routing *)NULL))
    {
      route->__ptr = routing;
      route->__size = 999999999;
    }

    else
      if(!(route->__size == 0))
      {
        route->__ptr = route->__ptr + 1l;
        route->__size = route->__size - 1;
      }

    while((_Bool)1)
    {
      if(!(route->__ptr == ((struct t__Routing *)NULL)))
        while(!(route->__size == 0))
        {
          if(route->__ptr->key == ((char *)NULL))
            break;

          signed int return_value_soap_tag_cmp_6;
          return_value_soap_tag_cmp_6=soap_tag_cmp(key, route->__ptr->key);
          if(return_value_soap_tag_cmp_6 == 0)
          {
            _Bool tmp_if_expr_1;
            if(route->__ptr->userid == ((char *)NULL))
              tmp_if_expr_1 = (_Bool)1;

            else
              tmp_if_expr_1 = !(route->__ptr->passwd != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
            _Bool tmp_if_expr_3;
            if(passwd == ((const char *)NULL) || userid == ((const char *)NULL) || tmp_if_expr_1)
              tmp_if_expr_3 = (_Bool)1;

            else
            {
              return_value_soap_tag_cmp_2=soap_tag_cmp(userid, route->__ptr->userid);
              tmp_if_expr_3 = !(return_value_soap_tag_cmp_2 != 0) ? (_Bool)1 : (_Bool)0;
            }
            _Bool tmp_if_expr_5;
            if(tmp_if_expr_3)
              tmp_if_expr_5 = (_Bool)1;

            else
            {
              return_value_soap_tag_cmp_4=soap_tag_cmp(passwd, route->__ptr->passwd);
              tmp_if_expr_5 = !(return_value_soap_tag_cmp_4 != 0) ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_5)
              return route->__ptr->endpoint;

          }

          route->__ptr = route->__ptr + 1l;
          route->__size = route->__size - 1;
        }

      if(!(route->__size == 0))
      {
        static struct t__RoutingTable routing_table = { .__size=0, .__ptr=(struct t__Routing *)(void *)0 };
        if(!(routing_table.__ptr == ((struct t__Routing *)NULL)))
          *route = routing_table;

        else
          if(!(routing_file == ((const char *)NULL)))
          {
            union anonymous_0 lock;
            pthread_mutex_lock(&lock);
            static struct soap soap = { .state=(signed short int)0, .version=0, .mode=0,
    .imode=0, .omode=0, .float_format=((const char *)NULL), .double_format=((const char *)NULL),
    .long_double_format=((const char *)NULL),
    .dime_id_format=((const char *)NULL),
    .http_version=((const char *)NULL),
    .http_content=((const char *)NULL), .encodingStyle=((const char *)NULL),
    .actor=((const char *)NULL),
    .lang=((const char *)NULL), .recv_timeout=0,
    .send_timeout=0, .connect_timeout=0, .accept_timeout=0,
    .socket_flags=0, .connect_flags=0, .bind_flags=0,
    .accept_flags=0, .linger_time=0, .namespaces=((struct Namespace *)NULL),
    .local_namespaces=((struct Namespace *)NULL),
    .nlist=((struct soap_nlist *)NULL),
    .blist=((struct soap_blist *)NULL), .clist=((struct soap_clist *)NULL),
    .alist=NULL, .shaky=0,
    .iht={ ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL), ((struct soap_ilist *)NULL) }, .pht={ ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL), ((struct soap_plist *)NULL) },
    .pblk=((struct soap_pblk *)NULL),
    .pidx=0, .header=((struct SOAP_ENV__Header *)NULL),
    .fault=((struct SOAP_ENV__Fault *)NULL),
    .idnum=0,
    .user=NULL, .data={ NULL, NULL, NULL, NULL }, .plugins=((struct soap_plugin *)NULL),
    .userid=((const char *)NULL),
    .passwd=((const char *)NULL), .authrealm=((const char *)NULL),
    .ntlm_challenge=((const char *)NULL), .ntlm_auth=0,
    .ntlm_stage=0, .fpost=((signed int (*)(struct soap *, const char *, const char *, signed int, const char *, const char *, unsigned long int))NULL), .fget=((signed int (*)(struct soap *))NULL),
    .fput=((signed int (*)(struct soap *))NULL),
    .fdel=((signed int (*)(struct soap *))NULL),
    .fopt=((signed int (*)(struct soap *))NULL),
    .fhead=((signed int (*)(struct soap *))NULL),
    .fform=((signed int (*)(struct soap *))NULL),
    .fposthdr=((signed int (*)(struct soap *, const char *, const char *))NULL),
    .fresponse=((signed int (*)(struct soap *, signed int, unsigned long int))NULL),
    .fparse=((signed int (*)(struct soap *))NULL),
    .fparsehdr=((signed int (*)(struct soap *, const char *, const char *))NULL),
    .fheader=((signed int (*)(struct soap *))NULL),
    .fresolve=((signed int (*)(struct soap *, const char *, struct in_addr *))NULL),
    .fconnect=((signed int (*)(struct soap *, const char *, const char *, signed int))NULL),
    .fdisconnect=((signed int (*)(struct soap *))NULL),
    .fclosesocket=((signed int (*)(struct soap *, signed int))NULL),
    .fshutdownsocket=((signed int (*)(struct soap *, signed int, signed int))NULL),
    .fopen=((signed int (*)(struct soap *, const char *, const char *, signed int))NULL),
    .faccept=((signed int (*)(struct soap *, signed int, struct sockaddr *, signed int *))NULL),
    .fclose=((signed int (*)(struct soap *))NULL),
    .fsend=((signed int (*)(struct soap *, const char *, unsigned long int))NULL),
    .frecv=((unsigned long int (*)(struct soap *, char *, unsigned long int))NULL),
    .fpoll=((signed int (*)(struct soap *))NULL),
    .fseterror=((void (*)(struct soap *, const char **, const char **))NULL),
    .fignore=((signed int (*)(struct soap *, const char *))NULL),
    .fserveloop=((signed int (*)(struct soap *))NULL),
    .fplugin=((void * (*)(struct soap *, const char *))NULL),
    .fmalloc=((void * (*)(struct soap *, unsigned long int))NULL),
    .fsvalidate=((signed int (*)(struct soap *, const char *, const char *))NULL),
    .fwvalidate=((signed int (*)(struct soap *, const char *, const signed int *))NULL),
    .feltbegin=((signed int (*)(struct soap *, const char *))NULL),
    .feltendin=((signed int (*)(struct soap *, const char *, const char *))NULL),
    .feltbegout=((signed int (*)(struct soap *, const char *))NULL),
    .feltendout=((signed int (*)(struct soap *, const char *))NULL),
    .fprepareinitsend=((signed int (*)(struct soap *))NULL),
    .fprepareinitrecv=((signed int (*)(struct soap *))NULL),
    .fpreparesend=((signed int (*)(struct soap *, const char *, unsigned long int))NULL),
    .fpreparerecv=((signed int (*)(struct soap *, const char *, unsigned long int))NULL),
    .fpreparefinalsend=((signed int (*)(struct soap *))NULL),
    .fpreparefinalrecv=((signed int (*)(struct soap *))NULL),
    .recverror=0,
    .ffiltersend=((signed int (*)(struct soap *, const char **, unsigned long int *))NULL), .ffilterrecv=((signed int (*)(struct soap *, char *, unsigned long int *, unsigned long int))NULL),
    .fdimereadopen=((void * (*)(struct soap *, void *, const char *, const char *, const char *))NULL),
    .fdimewriteopen=((void * (*)(struct soap *, const char *, const char *, const char *))NULL),
    .fdimereadclose=((void (*)(struct soap *, void *))NULL),
    .fdimewriteclose=((void (*)(struct soap *, void *))NULL),
    .fdimeread=((unsigned long int (*)(struct soap *, void *, char *, unsigned long int))NULL),
    .fdimewrite=((signed int (*)(struct soap *, void *, const char *, unsigned long int))NULL),
    .fmimereadopen=((void * (*)(struct soap *, void *, const char *, const char *, const char *))NULL),
    .fmimewriteopen=((void * (*)(struct soap *, void *, const char *, const char *, const char *, enum soap_mime_encoding))NULL),
    .fmimereadclose=((void (*)(struct soap *, void *))NULL),
    .fmimewriteclose=((void (*)(struct soap *, void *))NULL),
    .fmimeread=((unsigned long int (*)(struct soap *, void *, char *, unsigned long int))NULL),
    .fmimewrite=((signed int (*)(struct soap *, void *, const char *, unsigned long int))NULL),
    .master=0,
    .socket=0, .sendsk=0, .recvsk=0, .os=((const char **)NULL),
    .is=((const char *)NULL), .sendfd=0,
    .recvfd=0, .bufidx=0ul, .buflen=0ul, .ahead=0,
    .cdata=0, .body=0, .level=0u, .count=0ul,
    .length=0ul, .labbuf=((char *)NULL), .lablen=0ul,
    .labidx=0ul, .buf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .msgbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .tmpbuf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .tag={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .id={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .href={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .type={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .arrayType={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .arraySize={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .arrayOffset={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .other=0,
    .root=0, .position=0, .positions={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .attributes=((struct soap_attribute *)NULL),
    .encoding=0,
    .mustUnderstand=0, .null=0, .ns=0,
    .part=0, .event=0, .peeked=0, .evlev=0u,
    .alloced=0, .chunksize=0ul, .chunkbuflen=0ul,
    .endpoint={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .path={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .host={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .action=((char *)NULL),
    .prolog=((const char *)NULL), .ip=0ul,
    .port=0, .keep_alive=0, .tcp_keep_alive=0, .tcp_keep_idle=0u,
    .tcp_keep_intvl=0u, .tcp_keep_cnt=0u,
    .max_keep_alive=0u, .proxy_http_version=((const char *)NULL),
    .proxy_host=((const char *)NULL),
    .proxy_port=0, .proxy_userid=((const char *)NULL),
    .proxy_passwd=((const char *)NULL), .proxy_from=((const char *)NULL),
    .status=0, .error=0,
    .errmode=0, .errnum=0, .dom=((struct soap_dom_element *)NULL), .dime={ .count=0ul, .size=0ul, .chunksize=0ul, .buflen=0ul,
    .flags=0, .ptr=((char *)NULL), .id=((const char *)NULL),
    .type=((const char *)NULL), .options=((const char *)NULL),
    .list=((struct soap_multipart *)NULL), .first=((struct soap_multipart *)NULL),
    .last=((struct soap_multipart *)NULL) },
    .mime={ .boundary=((char *)NULL), .start=((const char *)NULL), .list=((struct soap_multipart *)NULL),
    .first=((struct soap_multipart *)NULL),
    .last=((struct soap_multipart *)NULL) },
    .xlist=((struct soap_xlist *)NULL),
    .logfile={ ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) }, .fdebug={ ((struct _IO_FILE *)NULL), ((struct _IO_FILE *)NULL), ((struct _IO_FILE *)NULL) },
    .mht={ ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL), ((struct soap_mlist *)NULL) },
    .wsuid=((const char *)NULL),
    .c14nexclude=((const char *)NULL), .c14ninclude=((const char *)NULL),
    .cookies=((struct soap_cookie *)NULL), .cookie_domain=((const char *)NULL),
    .cookie_path=((const char *)NULL),
    .cookie_max=0, .ipv6_multicast_if=0u,
    .ipv4_multicast_if=((char *)NULL), .ipv4_multicast_ttl=0,
    .peer={ .storage={ .ss_family=0, .__ss_align=0ul, .__ss_padding={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } } }, .peerlen=0ul,
    .fsslauth=NULL, .fsslverify=NULL, .bio=NULL,
    .ssl=NULL, .ctx=NULL, .session=NULL, .dh_params=NULL,
    .rsa_params=NULL, .ssl_flags=0, .keyfile=((const char *)NULL),
    .keyid=((const char *)NULL), .password=((const char *)NULL),
    .cafile=((const char *)NULL), .capath=((const char *)NULL),
    .crlfile=((const char *)NULL), .session_host={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .session_port=0,
    .c_locale=NULL, .d_stream=NULL, .z_crc=0,
    .z_dict=((const char *)NULL), .z_dict_len=0u,
    .zlib_state=0, .zlib_in=0, .zlib_out=0,
    .z_buf=((char *)NULL), .z_buflen=0ul, .z_level=0,
    .z_ratio_in=0.000000f, .z_ratio_out=0.000000f };
            if((signed int)soap.state == 0)
              soap_init_REQUIRE_lib_v20828(&soap, 0x00000000, 0x00000000);

            soap.recvfd=open(routing_file, 00);
            if(!(soap.recvfd >= 0))
            {
              pthread_mutex_unlock(&lock);
              break;
            }

            signed int return_value_soap_begin_recv_8;
            return_value_soap_begin_recv_8=soap_begin_recv(&soap);
            if(return_value_soap_begin_recv_8 == 0)
            {
              return_value_soap_get_t__RoutingTable_7=soap_get_t__RoutingTable(&soap, &routing_table, "router", (const char *)(void *)0);
              if(return_value_soap_get_t__RoutingTable_7 == ((struct t__RoutingTable *)NULL))
              {
                close(soap.recvfd);
                pthread_mutex_unlock(&lock);
                break;
              }

            }

            soap_end_recv(&soap);
            close(soap.recvfd);
            *route = routing_table;
            pthread_mutex_unlock(&lock);
          }

      }

      else
        break;
    }
    return (const char *)(void *)0;
  }
}

// main
// file router.c line 287
signed int main(signed int argc, char **argv)
{
  options(argc, argv);
  signed int return_value_strcmp_1;
  signed int return_value_soap_recv_3;
  if(!(port_number == 0))
  {
    unsigned long int tid;
    struct soap soap;
    struct soap *tsoap;
    signed int m;
    signed int main__1__1__s;
    signed int i;
    soap_init_REQUIRE_lib_v20828(&soap, 0x00000000, 0x00000000);
    soap.bind_flags = 2;
    m=soap_bind(&soap, (const char *)(void *)0, port_number, 100);
    if(m == -1)
    {
      soap_print_fault(&soap, stderr);
      exit(1);
    }

    fprintf(stderr, "Socket connection successful %d\n", m);
    i = 1;
    do
    {
      main__1__1__s=soap_accept(&soap);
      if(main__1__1__s == -1)
      {
        if(!(soap.errnum == 0))
          soap_print_fault(&soap, stderr);

        else
          fprintf(stderr, "router timed out\n");
        break;
      }

      fprintf(stderr, "Thread %d accepts socket %d connection from IP %d.%d.%d.%d\n", i, main__1__1__s, (signed int)(soap.ip >> 24) & 0xFF, (signed int)(soap.ip >> 16) & 0xFF, (signed int)(soap.ip >> 8) & 0xFF, (signed int)soap.ip & 0xFF);
      tsoap=soap_copy(&soap);
      pthread_create(&tid, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))process_request, (void *)tsoap);
      i = i + 1;
    }
    while((_Bool)1);
  }

  else
  {
    struct soap client;
    struct soap server;
    signed int err;
    soap_init_REQUIRE_lib_v20828(&client, 0x00000000, 0x00000000);
    soap_init_REQUIRE_lib_v20828(&server, 0x00000000, 0x00000000);
    if(!(argc >= 2))
    {
      char *s;
      s=getenv("REQUEST_METHOD");
      _Bool tmp_if_expr_2;
      if(!(s == ((char *)NULL)))
      {
        return_value_strcmp_1=strcmp(s, "GET");
        tmp_if_expr_2 = !(return_value_strcmp_1 != 0) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        method = 2002;

      else
      {
        s=getenv("Content-Length");
        if(!(s == ((char *)NULL)))
          client.length=strtoul(s, (char ** restrict )(void *)0, 10);

      }
      service_action=getenv("HTTP_SOAPAction");
      if(service_action == ((const char *)NULL))
        service_action=getenv("QUERY_STRING");

    }

    if(method == 2000)
    {
      signed int c;
      if(!(input_file == ((const char *)NULL)))
      {
        client.recvfd=open(input_file, 00);
        if(!(client.recvfd >= 0))
        {
          fprintf(stderr, "router: cannot open file '%s' for reading\n", input_file);
          exit(1);
        }

      }

      _Bool tmp_if_expr_4;
      if(client.bufidx >= client.buflen)
      {
        return_value_soap_recv_3=soap_recv(&client);
        tmp_if_expr_4 = return_value_soap_recv_3 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_4 = (_Bool)0;
      signed int tmp_if_expr_5;
      if(tmp_if_expr_4)
        tmp_if_expr_5 = -1;

      else
        tmp_if_expr_5 = (signed int)(unsigned char)(&client)->buf[(signed long int)(&client)->bufidx];
      c = tmp_if_expr_5;
      if(c == 71 || c == 80)
      {
        signed int return_value_copy_header_6;
        return_value_copy_header_6=copy_header(&client, &server, service_endpoint, service_action);
        if(!(return_value_copy_header_6 == 0))
        {
          client.error = server.error;
          err = client.error;
          soap_send_fault(&client);
          return err;
        }

      }

      else
      {
        struct stat sb;
        signed int return_value_fstat_7;
        return_value_fstat_7=fstat(client.recvfd, &sb);
        if(return_value_fstat_7 == 0 && sb.st_size >= 1l)
          client.length = (unsigned long int)sb.st_size;

        else
        {
          err=buffer_body(&client);
          if(!(err == 0))
          {
            soap_send_fault(&client);
            return err;
          }

        }
        signed int return_value_create_header_8;
        return_value_create_header_8=create_header(&server, 2000, service_endpoint, service_action, client.length);
        if(!(return_value_create_header_8 == 0))
        {
          client.error = server.error;
          err = client.error;
          soap_send_fault(&client);
          return err;
        }

      }
      err=copy_body(&client, &server);
      if(!(err == 0))
      {
        soap_send_fault(&client);
        return err;
      }

    }

    else
    {
      signed int return_value_create_header_9;
      return_value_create_header_9=create_header(&server, 2002, service_endpoint, service_action, (unsigned long int)0);
      if(!(return_value_create_header_9 == 0))
      {
        client.error = server.error;
        err = client.error;
        soap_send_fault(&client);
        return err;
      }

      soap_end_send(&server);
    }
    soap_begin(&server);
    copy_header(&server, &client, (const char *)(void *)0, (const char *)(void *)0);
    err=copy_body(&server, &client);
    if(!(err == 0))
      return err;

    soap_closesock(&client);
    soap_closesock(&server);
    soap_end(&client);
    soap_end(&server);
    soap_done(&client);
    soap_done(&server);
  }
  return 0;
}

// make_connect
// file router.c line 570
signed int make_connect(struct soap *server, const char *endpoint)
{
  char host[1024l];
  signed int port;
  strncpy(host, server->host, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
  host[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
  (void)(host[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
  port = server->port;
  soap_set_endpoint(server, endpoint);
  server->connect_timeout = server_timeout;
  server->recv_timeout = server_timeout;
  server->send_timeout = server_timeout;
  signed int return_value_strcmp_1;
  if(!(server->host[0l] == 0))
  {
    _Bool tmp_if_expr_2;
    if(server->socket == -1)
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_strcmp_1=strcmp(server->host, host);
      tmp_if_expr_2 = return_value_strcmp_1 != 0 ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr_3;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = server->port != port ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
    {
      soap_closesock(server);
      server->socket=server->fopen(server, endpoint, server->host, server->port);
      if(server->socket == -1)
        return server->error;

    }

  }

  return 0;
}

// new_attribute
// file dom.c line 1084
static struct soap_dom_attribute * new_attribute(struct soap *soap)
{
  struct soap_dom_attribute *att;
  void *return_value_soap_malloc_1;
  return_value_soap_malloc_1=soap_malloc(soap, sizeof(struct soap_dom_attribute) /*40ul*/ );
  att = (struct soap_dom_attribute *)return_value_soap_malloc_1;
  if(!(att == ((struct soap_dom_attribute *)NULL)))
    soap_default_xsd__anyAttribute(soap, att);

  return att;
}

// new_element
// file dom.c line 1070
static struct soap_dom_element * new_element(struct soap *soap)
{
  struct soap_dom_element *elt;
  void *return_value_soap_malloc_1;
  return_value_soap_malloc_1=soap_malloc(soap, sizeof(struct soap_dom_element) /*104ul*/ );
  elt = (struct soap_dom_element *)return_value_soap_malloc_1;
  if(!(elt == ((struct soap_dom_element *)NULL)))
    soap_default_xsd__anyType(soap, elt);

  return elt;
}

// options
// file router.c line 394
void options(signed int argc, char **argv)
{
  signed int i;
  signed int flag;
  char *arg;
  i = 1;
  signed long int return_value_atol_1;
  signed long int return_value_atol_2;
  signed long int return_value_atol_7;
  signed long int return_value_atol_8;
  for( ; !(i >= argc); i = i + 1)
  {
    arg = argv[(signed long int)i];
    if((signed int)*arg == 45)
    {
      flag = 1;
      while(!(flag == 0))
      {
        arg = arg + 1l;
        if(*arg == 0)
          break;

        switch((signed int)*arg)
        {
          case 104:
          {
            fprintf(stderr, "Usage: router [-c] [-p<port>] [-e<endpoint> | -g<endpoint>] [-a<action>] [-r<routingfile>] [-t<sec>] [<msgfile>]\n-a\taction value override (SOAP Action)\n-c\tconnect directly to endpoint\n-e\tendpoint URL\n-g\tget content (instead of HTTP POST)\n-p\tstart stand-alone router on port\n-r\trouting table\n-t\ttimeout in seconds");
            exit(0);
          }
          case 112:
          {
            flag = 0;
            arg = arg + 1l;
            if(!(*arg == 0))
            {
              return_value_atol_1=atol(arg);
              port_number = (signed int)return_value_atol_1;
            }

            else
            {
              _Bool tmp_if_expr_3;
              if(!(i >= argc))
              {
                i = i + 1;
                tmp_if_expr_3 = argv[(signed long int)i] != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_3 = (_Bool)0;
              if(tmp_if_expr_3)
              {
                return_value_atol_2=atol(argv[(signed long int)i]);
                port_number = (signed int)return_value_atol_2;
              }

              else
              {
                fprintf(stderr, "router: -p requires <port>\n");
                exit(1);
              }
            }
            break;
          }
          case 103:
            method = 2002;
          case 101:
          {
            flag = 0;
            arg = arg + 1l;
            if(!(*arg == 0))
              service_endpoint = arg;

            else
            {
              _Bool tmp_if_expr_4;
              if(!(i >= argc))
              {
                i = i + 1;
                tmp_if_expr_4 = argv[(signed long int)i] != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_4 = (_Bool)0;
              if(tmp_if_expr_4)
                service_endpoint = argv[(signed long int)i];

              else
              {
                fprintf(stderr, "router: -e and -g require <endpoint>\n");
                exit(1);
              }
            }
            break;
          }
          case 97:
          {
            flag = 0;
            arg = arg + 1l;
            if(!(*arg == 0))
              service_action = arg;

            else
            {
              _Bool tmp_if_expr_5;
              if(!(i >= argc))
              {
                i = i + 1;
                tmp_if_expr_5 = argv[(signed long int)i] != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_5 = (_Bool)0;
              if(tmp_if_expr_5)
                service_action = argv[(signed long int)i];

              else
              {
                fprintf(stderr, "router: -a requires <action>\n");
                exit(1);
              }
            }
            break;
          }
          case 114:
          {
            flag = 0;
            arg = arg + 1l;
            if(!(*arg == 0))
              routing_file = arg;

            else
            {
              _Bool tmp_if_expr_6;
              if(!(i >= argc))
              {
                i = i + 1;
                tmp_if_expr_6 = argv[(signed long int)i] != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_6 = (_Bool)0;
              if(tmp_if_expr_6)
                routing_file = argv[(signed long int)i];

              else
              {
                fprintf(stderr, "router: -r requires <routingfile>\n");
                exit(1);
              }
            }
            break;
          }
          case 116:
          {
            flag = 0;
            arg = arg + 1l;
            if(!(*arg == 0))
            {
              return_value_atol_7=atol(arg);
              server_timeout = (signed int)return_value_atol_7;
            }

            else
            {
              _Bool tmp_if_expr_9;
              if(!(i >= argc))
              {
                i = i + 1;
                tmp_if_expr_9 = argv[(signed long int)i] != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_9 = (_Bool)0;
              if(tmp_if_expr_9)
              {
                return_value_atol_8=atol(argv[(signed long int)i]);
                server_timeout = (signed int)return_value_atol_8;
              }

              else
              {
                fprintf(stderr, "router: -t requires <timeout>\n");
                exit(1);
              }
            }
            break;
          }
          case 99:
          {
            connect_flag = 1;
            break;
          }
          default:
            fprintf(stderr, "router: unknown option -%c\n", *arg);
        }
      }
    }

    else
      input_file = arg;
  }
}

// out_attribute
// file dom.c line 259
static signed int out_attribute(struct soap *soap, const char *prefix, const char *name, const char *text, signed int isearly)
{
  char *s;
  const char *t;
  unsigned long int l;
  signed int err;
  if(text == ((const char *)NULL))
    text = "";

  _Bool tmp_if_expr_6;
  if(prefix == ((const char *)NULL))
    tmp_if_expr_6 = (_Bool)1;

  else
    tmp_if_expr_6 = !(*prefix != 0) ? (_Bool)1 : (_Bool)0;
  signed int return_value_strncmp_3;
  signed int return_value_soap_attribute_1;
  signed int return_value_soap_set_attr_4;
  if(tmp_if_expr_6)
  {
    if(!((0x00010000 & soap->mode) == 0))
    {
      return_value_strncmp_3=strncmp(name, "xmlns", (unsigned long int)5);
      if(return_value_strncmp_3 == 0)
      {
        _Bool tmp_if_expr_2;
        if((signed int)name[5l] == 58)
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = (signed int)name[(signed long int)5] == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
        {
          return_value_soap_attribute_1=soap_attribute(soap, name, text);
          return return_value_soap_attribute_1;
        }

      }

    }

    if(!(isearly == 0))
    {
      return_value_soap_set_attr_4=soap_set_attr(soap, name, text, 2);
      return return_value_soap_set_attr_4;
    }

    signed int return_value_soap_attribute_5;
    return_value_soap_attribute_5=soap_attribute(soap, name, text);
    return return_value_soap_attribute_5;
  }

  t=strchr(name, 58);
  if(!(t == ((const char *)NULL)))
    t = t + 1l;

  else
    t = name;
  unsigned long int return_value_strlen_7;
  return_value_strlen_7=strlen(prefix);
  unsigned long int return_value_strlen_8;
  return_value_strlen_8=strlen(t);
  l = return_value_strlen_7 + return_value_strlen_8;
  if(!(1ul + l >= sizeof(char [1024l]) /*1024ul*/ ))
    s = soap->msgbuf;

  else
  {
    void *return_value_malloc_9;
    return_value_malloc_9=malloc(l + (unsigned long int)2);
    s = (char *)return_value_malloc_9;
    if(s == ((char *)NULL))
    {
      soap->error = 20;
      return soap->error;
    }

  }
  snprintf(s, l + (unsigned long int)2, "%s:%s", prefix, t);
  if(!(isearly == 0))
    err=soap_set_attr(soap, s, text, 2);

  else
    err=soap_attribute(soap, s, text);
  if(!(s == soap->msgbuf))
    free((void *)s);

  return err;
}

// out_element
// file dom.c line 204
static signed int out_element(struct soap *soap, struct soap_dom_element *node, const char *prefix, const char *name)
{
  signed int return_value_soap_send_1;
  if(!(node->lead == ((const char *)NULL)))
  {
    return_value_soap_send_1=soap_send(soap, node->lead);
    if(!(return_value_soap_send_1 == 0))
      return soap->error;

  }

  _Bool tmp_if_expr_12;
  if(!(node->type == 0))
    tmp_if_expr_12 = node->node != NULL ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_12 = (_Bool)0;
  _Bool tmp_if_expr_5;
  unsigned long int return_value_strlen_6;
  const char *return_value_soap_push_prefix_7;
  if(tmp_if_expr_12)
  {
    char *out_element__1__1__s = (char *)(void *)0;
    struct Namespace *p;
    if(!(prefix == ((const char *)NULL)))
    {
      if(!(*prefix == 0))
      {
        unsigned long int out_element__1__1__1__l;
        unsigned long int return_value_strlen_2;
        return_value_strlen_2=strlen(prefix);
        unsigned long int return_value_strlen_3;
        return_value_strlen_3=strlen(name);
        out_element__1__1__1__l = return_value_strlen_2 + return_value_strlen_3;
        void *return_value_malloc_4;
        return_value_malloc_4=malloc(out_element__1__1__1__l + (unsigned long int)2);
        out_element__1__1__s = (char *)return_value_malloc_4;
        if(out_element__1__1__s == ((char *)NULL))
        {
          soap->error = 20;
          return soap->error;
        }

        snprintf(out_element__1__1__s, out_element__1__1__1__l + (unsigned long int)2, "%s:%s", prefix, name);
      }

    }

    p = soap->local_namespaces;
    do
    {
      if(!(p == ((struct Namespace *)NULL)))
        tmp_if_expr_5 = p->id != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      if(!tmp_if_expr_5)
        break;

      if(!(p->ns == ((const char *)NULL)))
      {
        return_value_strlen_6=strlen(p->id);
        return_value_soap_push_prefix_7=soap_push_prefix(soap, p->id, return_value_strlen_6, p->ns, 1, 0);
        if(return_value_soap_push_prefix_7 == ((const char *)NULL))
          return soap->error;

      }

      p = p + 1l;
    }
    while((_Bool)1);
    soap_putelement(soap, node->node, out_element__1__1__s != ((char *)NULL) ? out_element__1__1__s : name, 0, node->type);
    if(!(out_element__1__1__s == ((char *)NULL)))
      free((void *)out_element__1__1__s);

  }

  else
  {
    _Bool tmp_if_expr_11;
    if(!(prefix == ((const char *)NULL)))
      tmp_if_expr_11 = *prefix != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_11 = (_Bool)0;
    if(tmp_if_expr_11)
    {
      unsigned long int l;
      unsigned long int return_value_strlen_8;
      return_value_strlen_8=strlen(prefix);
      unsigned long int return_value_strlen_9;
      return_value_strlen_9=strlen(name);
      l = return_value_strlen_8 + return_value_strlen_9;
      char *s;
      if(!(1ul + l >= sizeof(char [1024l]) /*1024ul*/ ))
        s = soap->msgbuf;

      else
      {
        void *return_value_malloc_10;
        return_value_malloc_10=malloc(l + (unsigned long int)2);
        s = (char *)return_value_malloc_10;
        if(s == ((char *)NULL))
        {
          soap->error = 20;
          return soap->error;
        }

      }
      snprintf(s, l + (unsigned long int)2, "%s:%s", prefix, name);
      soap_element(soap, s, 0, (const char *)(void *)0);
      if(!(s == soap->msgbuf))
        free((void *)s);

    }

    else
      if(!((signed int)*name == 45))
      {
        signed int m = soap->mode;
        if(!((0x00400000 & soap->mode) == 0))
          soap->mode = soap->mode & ~0x00002000;

        soap_element(soap, name, 0, (const char *)(void *)0);
        soap->mode = m;
      }

  }
  return soap->error;
}

// process_request
// file router.c line 476
void * process_request(void *soap)
{
  struct soap *client = (struct soap *)soap;
  struct soap server;
  signed int c;
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  pthread_detach(return_value_pthread_self_1);
  soap_init_REQUIRE_lib_v20828(&server, 0x00000000, 0x00000000);
  soap_begin(client);
  _Bool tmp_if_expr_3;
  signed int return_value_soap_recv_2;
  if(client->bufidx >= client->buflen)
  {
    return_value_soap_recv_2=soap_recv(client);
    tmp_if_expr_3 = return_value_soap_recv_2 != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3 = (_Bool)0;
  signed int tmp_if_expr_4;
  if(tmp_if_expr_3)
    tmp_if_expr_4 = -1;

  else
    tmp_if_expr_4 = (signed int)(unsigned char)client->buf[(signed long int)client->bufidx];
  c = tmp_if_expr_4;
  if(c == 71 || c == 80)
  {
    signed int return_value_copy_header_5;
    return_value_copy_header_5=copy_header(client, &server, (const char *)(void *)0, (const char *)(void *)0);
    if(!(return_value_copy_header_5 == 0))
      client->error = server.error;

  }

  else
  {
    buffer_body(client);
    signed int return_value_create_header_6;
    return_value_create_header_6=create_header(&server, method, service_endpoint, service_action, client->length);
    if(!(return_value_create_header_6 == 0))
      client->error = server.error;

  }
  if(client->error == 0)
  {
    copy_body(client, &server);
    soap_begin(&server);
    copy_header(&server, client, (const char *)(void *)0, (const char *)(void *)0);
    copy_body(&server, client);
  }

  else
    soap_send_fault(client);
  soap_closesock(client);
  soap_closesock(&server);
  soap_end(&server);
  soap_end(client);
  soap_done(&server);
  soap_free(client);
  return (void *)0;
}

// server_connect
// file router.c line 593
signed int server_connect(struct soap *server, const char *endpoint, const char *action, const char *userid, const char *passwd)
{
  const char *return_value_lookup_1;
  if(!(action == ((const char *)NULL)))
  {
    if(!(*action == 0))
    {
      struct t__RoutingTable route;
      route.__ptr = (struct t__Routing *)(void *)0;
      route.__size = 0;
      fprintf(stderr, "Searching services on action %s...\n", action);
      do
      {
        return_value_lookup_1=lookup(&route, action, userid, passwd);
        if(return_value_lookup_1 == ((const char *)NULL))
          break;

        fprintf(stderr, "Attempting to connect to '%s'\n", route.__ptr->endpoint);
        signed int return_value_make_connect_2;
        return_value_make_connect_2=make_connect(server, route.__ptr->endpoint);
        if(return_value_make_connect_2 == 0)
          return 0;

      }
      while((_Bool)1);
    }

  }

  const char *return_value_lookup_3;
  if(!(endpoint == ((const char *)NULL)))
  {
    if(!(*endpoint == 0))
    {
      struct t__RoutingTable server_connect__1__2__route;
      server_connect__1__2__route.__ptr = (struct t__Routing *)(void *)0;
      server_connect__1__2__route.__size = 0;
      fprintf(stderr, "Searching services on endpoint %s...\n", endpoint);
      do
      {
        return_value_lookup_3=lookup(&server_connect__1__2__route, endpoint, userid, passwd);
        if(return_value_lookup_3 == ((const char *)NULL))
          break;

        fprintf(stderr, "Attempting to connect to '%s'\n", server_connect__1__2__route.__ptr->endpoint);
        signed int return_value_make_connect_4;
        return_value_make_connect_4=make_connect(server, server_connect__1__2__route.__ptr->endpoint);
        if(return_value_make_connect_4 == 0)
          return 0;

      }
      while((_Bool)1);
    }

  }

  if(!(endpoint == ((const char *)NULL)) && !(connect_flag == 0))
  {
    if(!(*endpoint == 0))
    {
      fprintf(stderr, "Connect to endpoint %s...\n", endpoint);
      signed int return_value_make_connect_5;
      return_value_make_connect_5=make_connect(server, endpoint);
      if(return_value_make_connect_5 == 0)
        return 0;

    }

  }

  server->error = 28;
  return server->error;
}

// soap_LONG642s
// file stdsoap2.c line 13110
const char * soap_LONG642s(struct soap *soap, signed long int n)
{
  snprintf(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , "%ld", n);
  return soap->tmpbuf;
}

// soap_QName
// file stdsoap2.c line 14170
static const char * soap_QName(struct soap *soap, const char *s, signed long int minlen, signed long int maxlen)
{
  unsigned long int return_value_soap_utf8len_1;
  unsigned long int return_value_strlen_2;
  signed int return_value_strncmp_7;
  signed int return_value_strncmp_3;
  signed int return_value_soap_append_lab_9;
  _Bool tmp_if_expr_12;
  signed int return_value_soap_append_lab_11;
  _Bool tmp_if_expr_15;
  signed int return_value_soap_append_lab_14;
  _Bool tmp_if_expr_20;
  signed int return_value_soap_append_lab_17;
  _Bool tmp_if_expr_19;
  signed int return_value_soap_append_lab_18;
  if(!(s == ((const char *)NULL)))
  {
    if(maxlen >= 0l || minlen >= 1l)
    {
      signed long int l;
      if(!((0x02000000 & soap->mode) == 0))
      {
        return_value_soap_utf8len_1=soap_utf8len(s);
        l = (signed long int)return_value_soap_utf8len_1;
      }

      else
      {
        return_value_strlen_2=strlen(s);
        l = (signed long int)return_value_strlen_2;
      }
      if(!(l >= minlen) || !(maxlen >= l))
      {
        soap->error = 45;
        return (const char *)(void *)0;
      }

    }

    soap->labidx = (unsigned long int)0;
    do
    {
      unsigned long int n;
      struct soap_nlist *np;
      const char *p = (const char *)(void *)0;
      signed short int flag = (signed short int)0;
      const char *r = (const char *)(void *)0;
      unsigned long int m = (unsigned long int)0;
      for( ; !(*s == 0); s = s + 1l)
      {
        if(!(1 + (signed int)*s >= 1))
          break;

        if((signed int)*s >= 33)
          break;

      }
      if(*s == 0)
        break;

      n = (unsigned long int)1;
      for( ; !(s[(signed long int)n] == 0); n = n + 1ul)
        if(1 + (signed int)s[(signed long int)n] >= 1)
        {
          if(!((signed int)s[(signed long int)n] >= 33))
            break;

        }

      np = soap->nlist;
      _Bool tmp_if_expr_6;
      if(np == ((struct soap_nlist *)NULL))
        tmp_if_expr_6 = (_Bool)1;

      else
        tmp_if_expr_6 = (signed int)*s == 35 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr_8;
      if(tmp_if_expr_6)
        tmp_if_expr_8 = (_Bool)1;

      else
      {
        return_value_strncmp_7=strncmp(s, "xml:", (unsigned long int)4);
        tmp_if_expr_8 = !(return_value_strncmp_7 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_8)
      {
        r = s;
        m = n;
      }

      else
      {
        const char *q;
        p = s;
        for( ; !(*p == 0) && !(p >= s + (signed long int)n); p = p + 1l)
          if((signed int)*p == 58)
            break;

        if((signed int)*p == 58)
        {
          unsigned long int k = (unsigned long int)(p - s);
          for( ; !(np == ((struct soap_nlist *)NULL)); np = np->next)
          {
            return_value_strncmp_3=strncmp(np->id, s, k);
            if(return_value_strncmp_3 == 0)
            {
              if(np->id[(signed long int)k] == 0)
                break;

            }

          }
          p = p + 1l;
        }

        else
        {
          for( ; !(np == ((struct soap_nlist *)NULL)); np = np->next)
            if(np->id[0l] == 0)
              break;

          p = s;
        }
        if(!(np == ((struct soap_nlist *)NULL)))
        {
          _Bool tmp_if_expr_4;
          if((signed int)np->index >= 0)
            tmp_if_expr_4 = soap->local_namespaces != ((struct Namespace *)NULL) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4 = (_Bool)0;
          _Bool tmp_if_expr_5;
          if(tmp_if_expr_4)
          {
            q = (soap->local_namespaces + (signed long int)np->index)->id;
            tmp_if_expr_5 = q != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_5 = (_Bool)0;
          if(tmp_if_expr_5)
          {
            unsigned long int soap_QName__1__1__2__1__2__4__1__k;
            soap_QName__1__1__2__1__2__4__1__k=strlen(q);
            if(!((signed int)q[-1l + (signed long int)soap_QName__1__1__2__1__2__4__1__k] == 95))
            {
              r = q;
              m = soap_QName__1__1__2__1__2__4__1__k;
            }

            else
            {
              flag = (signed short int)1;
              r = (soap->local_namespaces + (signed long int)np->index)->ns;
              m=strlen(r);
            }
          }

          else
            if(!(np->ns == ((const char *)NULL)))
            {
              flag = (signed short int)1;
              r = np->ns;
              m=strlen(r);
            }

            else
            {
              soap->error = 9;
              return (const char *)(void *)0;
            }
        }

        else
          if(!(s[(signed long int)n] == 0))
          {
            r = s;
            m = n;
          }

          else
            flag = (signed short int)1;
      }
      _Bool tmp_if_expr_10;
      if(!(flag == 0))
      {
        return_value_soap_append_lab_9=soap_append_lab(soap, "\"", (unsigned long int)1);
        tmp_if_expr_10 = return_value_soap_append_lab_9 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_10 = (_Bool)0;
      _Bool tmp_if_expr_13;
      if(tmp_if_expr_10)
        tmp_if_expr_13 = (_Bool)1;

      else
      {
        if(!(m == 0ul))
        {
          return_value_soap_append_lab_11=soap_append_lab(soap, r, m);
          tmp_if_expr_12 = return_value_soap_append_lab_11 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_12 = (_Bool)0;
        tmp_if_expr_13 = tmp_if_expr_12 ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_16;
      if(tmp_if_expr_13)
        tmp_if_expr_16 = (_Bool)1;

      else
      {
        if(!(flag == 0))
        {
          return_value_soap_append_lab_14=soap_append_lab(soap, "\"", (unsigned long int)1);
          tmp_if_expr_15 = return_value_soap_append_lab_14 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_15 = (_Bool)0;
        tmp_if_expr_16 = tmp_if_expr_15 ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_21;
      if(tmp_if_expr_16)
        tmp_if_expr_21 = (_Bool)1;

      else
      {
        if(!(p == ((const char *)NULL)))
        {
          return_value_soap_append_lab_17=soap_append_lab(soap, ":", (unsigned long int)1);
          if(!(return_value_soap_append_lab_17 == 0))
            tmp_if_expr_19 = (_Bool)1;

          else
          {
            return_value_soap_append_lab_18=soap_append_lab(soap, p, n - (unsigned long int)(p - s));
            tmp_if_expr_19 = return_value_soap_append_lab_18 != 0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_20 = tmp_if_expr_19 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_20 = (_Bool)0;
        tmp_if_expr_21 = tmp_if_expr_20 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_21)
        return (const char *)(void *)0;

      s = s + (signed long int)n;
      if(!(*s == 0))
      {
        signed int return_value_soap_append_lab_22;
        return_value_soap_append_lab_22=soap_append_lab(soap, " ", (unsigned long int)1);
        if(!(return_value_soap_append_lab_22 == 0))
          return (const char *)(void *)0;

      }

    }
    while((_Bool)1);
    signed int return_value_soap_append_lab_23;
    return_value_soap_append_lab_23=soap_append_lab(soap, soap_padding, (unsigned long int)1);
    if(!(return_value_soap_append_lab_23 == 0))
      return (const char *)(void *)0;

    return soap->labbuf;
  }

  return (const char *)(void *)0;
}

// soap_QName2s
// file ../../../gsoap/stdsoap2.h line 3214
const char * soap_QName2s(struct soap *soap, const char *s)
{
  const char *t = (const char *)(void *)0;
  signed int return_value_strncmp_1;
  signed int return_value_soap_tag_cmp_2;
  signed int return_value_soap_tag_cmp_3;
  signed int return_value_strcmp_5;
  signed int return_value_soap_append_lab_9;
  _Bool tmp_if_expr_12;
  signed int return_value_soap_append_lab_11;
  if(!(s == ((const char *)NULL)))
  {
    soap->labidx = (unsigned long int)0;
    do
    {
      unsigned long int n;
      const char *q = (const char *)(void *)0;
      const char *r = (const char *)(void *)0;
      unsigned long int m = (unsigned long int)0;
      for( ; !(*s == 0); s = s + 1l)
      {
        if(!(1 + (signed int)*s >= 1))
          break;

        if((signed int)*s >= 33)
          break;

      }
      if(*s == 0)
        break;

      n = (unsigned long int)0;
      for( ; !(s[(signed long int)n] == 0); n = n + 1ul)
        if(1 + (signed int)s[(signed long int)n] >= 1)
        {
          if(!((signed int)s[(signed long int)n] >= 33))
            break;

        }

      if(!((signed int)*s == 34))
      {
        if(!((0x00010000 & soap->mode) == 0))
          soap_utilize_ns(soap, s);

        if(!((0x00008000 & soap->mode) == 0))
        {
          r=strchr(s, 58);
          if(!(r == ((const char *)NULL)))
          {
            if(!(soap->nlist == ((struct soap_nlist *)NULL)))
            {
              return_value_strncmp_1=strncmp(soap->nlist->id, s, (unsigned long int)(r - s));
              if(return_value_strncmp_1 == 0)
              {
                if(soap->nlist->id[r - s] == 0)
                {
                  n = n - (unsigned long int)((r - s) + (signed long int)1);
                  s = r + (signed long int)1;
                }

              }

            }

          }

        }

        r = s;
        m = n + (unsigned long int)1;
      }

      else
      {
        s = s + 1l;
        q=strchr(s, 34);
        if(!(q == ((const char *)NULL)))
        {
          struct Namespace *p = soap->local_namespaces;
          if(!(p == ((struct Namespace *)NULL)))
            for( ; !(p->id == ((const char *)NULL)); p = p + 1l)
            {
              if(!(p->ns == ((const char *)NULL)))
              {
                return_value_soap_tag_cmp_2=soap_tag_cmp(s, p->ns);
                if(return_value_soap_tag_cmp_2 == 0)
                  break;

              }

              if(!(p->in == ((const char *)NULL)))
              {
                return_value_soap_tag_cmp_3=soap_tag_cmp(s, p->in);
                if(return_value_soap_tag_cmp_3 == 0)
                  break;

              }

            }

          q = q + 1l;
          _Bool tmp_if_expr_8;
          if(!(p == ((struct Namespace *)NULL)))
            tmp_if_expr_8 = p->id != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_8 = (_Bool)0;
          if(tmp_if_expr_8)
          {
            r = p->id;
            _Bool tmp_if_expr_4;
            if(!((0x00008000 & soap->mode) == 0))
              tmp_if_expr_4 = soap->nlist != ((struct soap_nlist *)NULL) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_4 = (_Bool)0;
            _Bool tmp_if_expr_6;
            if(tmp_if_expr_4)
            {
              return_value_strcmp_5=strcmp(soap->nlist->id, r);
              tmp_if_expr_6 = !(return_value_strcmp_5 != 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_6 = (_Bool)0;
            if(tmp_if_expr_6)
              q = q + 1l;

            else
              m=strlen(r);
          }

          else
          {
            char *x;
            x=soap_strdup(soap, s);
            x[(q - s) - (signed long int)1] = (char)0;
            signed int tmp_post_7 = soap->idnum;
            soap->idnum = soap->idnum + 1;
            snprintf(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , "xmlns:_%d", tmp_post_7);
            soap_set_attr(soap, soap->tmpbuf, x, 1);
            r = soap->tmpbuf + (signed long int)6;
            m=strlen(r);
          }
        }

      }
      _Bool tmp_if_expr_10;
      if(!(m == 0ul))
      {
        return_value_soap_append_lab_9=soap_append_lab(soap, r, m);
        tmp_if_expr_10 = return_value_soap_append_lab_9 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_10 = (_Bool)0;
      _Bool tmp_if_expr_13;
      if(tmp_if_expr_10)
        tmp_if_expr_13 = (_Bool)1;

      else
      {
        if(!(q == ((const char *)NULL)))
        {
          return_value_soap_append_lab_11=soap_append_lab(soap, q, n - (unsigned long int)(q - s));
          tmp_if_expr_12 = return_value_soap_append_lab_11 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_12 = (_Bool)0;
        tmp_if_expr_13 = tmp_if_expr_12 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_13)
        return (const char *)(void *)0;

      s = s + (signed long int)n;
    }
    while((_Bool)1);
    t=soap_strdup(soap, soap->labbuf);
  }

  return t;
}

// soap_ULONG642s
// file stdsoap2.c line 13986
const char * soap_ULONG642s(struct soap *soap, unsigned long int n)
{
  snprintf(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , "%lu", n);
  return soap->tmpbuf;
}

// soap_accept
// file ../../../gsoap/stdsoap2.h line 2910
signed int soap_accept(struct soap *soap)
{
  signed int n = (signed int)sizeof(union anonymous) /*128ul*/ ;
  signed int err;
  signed int len = (signed int)sizeof(char [65536l]) /*65536ul*/ ;
  signed int set = 1;
  soap->error = 0;
  memset((void *)&soap->peer, 0, sizeof(union anonymous) /*128ul*/ );
  soap->socket = (signed int)-1;
  soap->errmode = 0;
  soap->keep_alive = (signed short int)0;
  if(soap->master == -1)
  {
    soap->errnum = 0;
    const char *return_value_tcp_error_1;
    return_value_tcp_error_1=tcp_error(soap);
    soap_set_receiver_error(soap, return_value_tcp_error_1, "no master socket in soap_accept()", 28);
    return (signed int)-1;
  }

  signed int return_value_fcntl_6;
  signed int return_value_fcntl_7;
  signed int return_value_setsockopt_16;
  signed int return_value_setsockopt_19;
  signed int return_value_fcntl_29;
  signed int return_value_fcntl_30;
  if(!((0x00000004 & soap->omode) == 0))
  {
    soap->socket = soap->master;
    return soap->socket;
  }

  else
  {
    _Bool tmp_if_expr_4;
    if(!(soap->accept_timeout == 0))
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = soap->send_timeout != 0 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr_5;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = soap->recv_timeout != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
      do
      {
        signed int r;
        signed int tmp_if_expr_2;
        if(!(soap->accept_timeout == 0))
          tmp_if_expr_2 = soap->accept_timeout;

        else
          tmp_if_expr_2 = 60;
        r=tcp_select(soap, soap->master, 0x7, tmp_if_expr_2);
        if(r >= 1)
          break;

        if(r == 0)
        {
          if(!(soap->accept_timeout == 0))
          {
            soap_set_receiver_error(soap, "Timeout", "accept failed in soap_accept()", 28);
            return (signed int)-1;
          }

        }

        if(!(r >= 0))
        {
          r = soap->errnum;
          if(!(r == 4))
          {
            soap_closesock(soap);
            const char *return_value_tcp_error_3;
            return_value_tcp_error_3=tcp_error(soap);
            soap_set_receiver_error(soap, return_value_tcp_error_3, "accept failed in soap_accept()", 28);
            return (signed int)-1;
          }

        }

      }
      while((_Bool)1);

    if(!(soap->accept_timeout == 0))
    {
      return_value_fcntl_6=fcntl(soap->master, 3);
      fcntl(soap->master, 4, return_value_fcntl_6 | 04000);
    }

    else
    {
      return_value_fcntl_7=fcntl(soap->master, 3);
      fcntl(soap->master, 4, return_value_fcntl_7 & ~04000);
    }
    n = (signed int)sizeof(union anonymous) /*128ul*/ ;
    soap->socket=soap->faccept(soap, soap->master, &soap->peer.addr, &n);
    soap->peerlen = (unsigned long int)n;
    if(!(soap->socket == -1))
    {
      char *s = soap->host;
      char port[16l];
      signed int i;
      getnameinfo(&soap->peer.addr, (unsigned int)n, soap->host, (unsigned int)sizeof(char [1024l]) /*1024ul*/ , port, (unsigned int)sizeof(char [16l]) /*16ul*/ , 1 | 2);
      soap->ip = (unsigned long int)0;
      i = 0;
      _Bool tmp_if_expr_8;
      if(!(i >= 4))
        tmp_if_expr_8 = *s != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_8 = (_Bool)0;
      if(tmp_if_expr_8)
      {
        unsigned long int return_value_strtoul_9;
        return_value_strtoul_9=strtoul(s, &s, 10);
        soap->ip = (soap->ip << 8) + (unsigned long int)(unsigned int)return_value_strtoul_9;
        if(!(*s == 0))
          s = s + 1l;

        i = i + 1;
      }

      signed long int return_value_strtol_10;
      return_value_strtol_10=strtol(port, (char ** restrict )(void *)0, 10);
      soap->port = (signed int)return_value_strtol_10;
      if(!((13 & soap->accept_flags) == 0))
      {
        struct linger linger;
        memset((void *)&linger, 0, sizeof(struct linger) /*8ul*/ );
        linger.l_onoff = 1;
        linger.l_linger = (signed int)soap->linger_time;
        signed int return_value_setsockopt_13;
        return_value_setsockopt_13=setsockopt(soap->socket, 1, 13, (const void *)(char *)&linger, (unsigned int)sizeof(struct linger) /*8ul*/ );
        if(!(return_value_setsockopt_13 == 0))
        {
          signed int *return_value___errno_location_11;
          return_value___errno_location_11=__errno_location();
          soap->errnum = *return_value___errno_location_11;
          const char *return_value_tcp_error_12;
          return_value_tcp_error_12=tcp_error(soap);
          soap_set_receiver_error(soap, return_value_tcp_error_12, "setsockopt SO_LINGER failed in soap_accept()", 28);
          soap_closesock(soap);
          return (signed int)-1;
        }

      }

      if(!((-14 & soap->accept_flags) == 0))
      {
        return_value_setsockopt_16=setsockopt(soap->socket, 1, soap->accept_flags & ~13, (const void *)(char *)&set, (unsigned int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_setsockopt_16 == 0))
        {
          signed int *return_value___errno_location_14;
          return_value___errno_location_14=__errno_location();
          soap->errnum = *return_value___errno_location_14;
          const char *return_value_tcp_error_15;
          return_value_tcp_error_15=tcp_error(soap);
          soap_set_receiver_error(soap, return_value_tcp_error_15, "setsockopt failed in soap_accept()", 28);
          soap_closesock(soap);
          return (signed int)-1;
        }

      }

      if(!(((soap->imode | soap->omode) & 0x00000010) == 0))
      {
        return_value_setsockopt_19=setsockopt(soap->socket, 1, 9, (const void *)(char *)&set, (unsigned int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_setsockopt_19 == 0))
        {
          signed int *return_value___errno_location_17;
          return_value___errno_location_17=__errno_location();
          soap->errnum = *return_value___errno_location_17;
          const char *return_value_tcp_error_18;
          return_value_tcp_error_18=tcp_error(soap);
          soap_set_receiver_error(soap, return_value_tcp_error_18, "setsockopt SO_KEEPALIVE failed in soap_accept()", 28);
          soap_closesock(soap);
          return (signed int)-1;
        }

      }

      signed int return_value_setsockopt_22;
      return_value_setsockopt_22=setsockopt(soap->socket, 1, 7, (const void *)(char *)&len, (unsigned int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_setsockopt_22 == 0))
      {
        signed int *return_value___errno_location_20;
        return_value___errno_location_20=__errno_location();
        soap->errnum = *return_value___errno_location_20;
        const char *return_value_tcp_error_21;
        return_value_tcp_error_21=tcp_error(soap);
        soap_set_receiver_error(soap, return_value_tcp_error_21, "setsockopt SO_SNDBUF failed in soap_accept()", 28);
        soap_closesock(soap);
        return (signed int)-1;
      }

      signed int return_value_setsockopt_25;
      return_value_setsockopt_25=setsockopt(soap->socket, 1, 8, (const void *)(char *)&len, (unsigned int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_setsockopt_25 == 0))
      {
        signed int *return_value___errno_location_23;
        return_value___errno_location_23=__errno_location();
        soap->errnum = *return_value___errno_location_23;
        const char *return_value_tcp_error_24;
        return_value_tcp_error_24=tcp_error(soap);
        soap_set_receiver_error(soap, return_value_tcp_error_24, "setsockopt SO_RCVBUF failed in soap_accept()", 28);
        soap_closesock(soap);
        return (signed int)-1;
      }

      signed int return_value_setsockopt_28;
      return_value_setsockopt_28=setsockopt(soap->socket, 6, 1, (const void *)(char *)&set, (unsigned int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_setsockopt_28 == 0))
      {
        signed int *return_value___errno_location_26;
        return_value___errno_location_26=__errno_location();
        soap->errnum = *return_value___errno_location_26;
        const char *return_value_tcp_error_27;
        return_value_tcp_error_27=tcp_error(soap);
        soap_set_receiver_error(soap, return_value_tcp_error_27, "setsockopt TCP_NODELAY failed in soap_accept()", 28);
        soap_closesock(soap);
        return (signed int)-1;
      }

      soap->keep_alive = (signed short int)(((soap->imode | soap->omode) & 0x00000010) != 0);
      _Bool tmp_if_expr_31;
      if(!(soap->send_timeout == 0))
        tmp_if_expr_31 = (_Bool)1;

      else
        tmp_if_expr_31 = soap->recv_timeout != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_31)
      {
        return_value_fcntl_29=fcntl(soap->socket, 3);
        fcntl(soap->socket, 4, return_value_fcntl_29 | 04000);
      }

      else
      {
        return_value_fcntl_30=fcntl(soap->socket, 3);
        fcntl(soap->socket, 4, return_value_fcntl_30 & ~04000);
      }
      return soap->socket;
    }

    signed int *return_value___errno_location_32;
    return_value___errno_location_32=__errno_location();
    err = *return_value___errno_location_32;
    if(!(err == 0) && !(err == 4) && !(err == 11))
    {
      soap->errnum = err;
      const char *return_value_tcp_error_33;
      return_value_tcp_error_33=tcp_error(soap);
      soap_set_receiver_error(soap, return_value_tcp_error_33, "accept failed in soap_accept()", 28);
      soap_closesock(soap);
      return (signed int)-1;
    }

  }
}

// soap_add_att
// file dom.c line 1398
struct soap_dom_element * soap_add_att(struct soap_dom_element *elt, struct soap_dom_attribute *node)
{
  if(!(node == ((struct soap_dom_attribute *)NULL)) && !(elt == ((struct soap_dom_element *)NULL)))
  {
    struct soap_dom_attribute *last;
    struct soap_dom_attribute **next = &elt->atts;
    last = elt->atts;
    for( ; !(last == ((struct soap_dom_attribute *)NULL)); last = last->next)
      if(last->next == ((struct soap_dom_attribute *)NULL))
        next = &last->next;

    *next=new_attribute(elt->soap);
    if(!(*next == ((struct soap_dom_attribute *)NULL)))
      soap_att_copy(*next, node);

  }

  return elt;
}

// soap_add_atts
// file dom.c line 1455
struct soap_dom_element * soap_add_atts(struct soap_dom_element *elt, struct soap_dom_attribute *atts)
{
  if(!(atts == ((struct soap_dom_attribute *)NULL)) && !(elt == ((struct soap_dom_element *)NULL)))
  {
    struct soap_dom_attribute *last;
    struct soap_dom_attribute **next = &elt->atts;
    last = elt->atts;
    for( ; !(last == ((struct soap_dom_attribute *)NULL)); last = last->next)
      if(last->next == ((struct soap_dom_attribute *)NULL))
        next = &last->next;

    for( ; !(atts == ((struct soap_dom_attribute *)NULL)); atts = atts->next)
    {
      *next=new_attribute(elt->soap);
      if(!(*next == ((struct soap_dom_attribute *)NULL)))
      {
        soap_att_copy(*next, atts);
        next = &(*next)->next;
      }

    }
  }

  return elt;
}

// soap_add_elt
// file dom.c line 1425
struct soap_dom_element * soap_add_elt(struct soap_dom_element *elt, struct soap_dom_element *node)
{
  if(!(elt == ((struct soap_dom_element *)NULL)) && !(node == ((struct soap_dom_element *)NULL)))
  {
    struct soap_dom_element *last;
    struct soap_dom_element **next = &elt->elts;
    last = elt->elts;
    for( ; !(last == ((struct soap_dom_element *)NULL)); last = last->next)
      if(last->next == ((struct soap_dom_element *)NULL))
        next = &last->next;

    *next=new_element(elt->soap);
    if(!(*next == ((struct soap_dom_element *)NULL)))
    {
      soap_elt_copy(*next, node);
      (*next)->prnt = elt;
    }

  }

  return elt;
}

// soap_add_elts
// file dom.c line 1488
struct soap_dom_element * soap_add_elts(struct soap_dom_element *elt, struct soap_dom_element *elts)
{
  if(!(elt == ((struct soap_dom_element *)NULL)) && !(elts == ((struct soap_dom_element *)NULL)))
  {
    struct soap_dom_element *last;
    struct soap_dom_element **next = &elt->elts;
    last = elt->elts;
    for( ; !(last == ((struct soap_dom_element *)NULL)); last = last->next)
      if(last->next == ((struct soap_dom_element *)NULL))
        next = &last->next;

    for( ; !(elts == ((struct soap_dom_element *)NULL)); elts = elts->next)
    {
      *next=new_element(elt->soap);
      if(!(*next == ((struct soap_dom_element *)NULL)))
      {
        soap_elt_copy(*next, elts);
        (*next)->prnt = elt;
        next = &(*next)->next;
      }

    }
  }

  return elt;
}

// soap_append_lab
// file stdsoap2.c line 11552
signed int soap_append_lab(struct soap *soap, const char *s, unsigned long int n)
{
  void *return_value_memcpy_2;
  if(soap->labidx + n >= soap->lablen)
  {
    char *t = soap->labbuf;
    if(soap->lablen == 0ul)
      soap->lablen = (unsigned long int)256;

    for( ; soap->labidx + n >= soap->lablen; soap->lablen = soap->lablen << 1)
      ;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(soap->lablen);
    soap->labbuf = (char *)return_value_malloc_1;
    if(soap->labbuf == ((char *)NULL))
    {
      if(!(t == ((char *)NULL)))
        free((void *)t);

      soap->error = 20;
      return soap->error;
    }

    if(!(t == ((char *)NULL)))
    {
      _Bool tmp_if_expr_3;
      if(!(soap->labbuf == ((char *)NULL)))
        tmp_if_expr_3 = (unsigned long int)soap->lablen >= (unsigned long int)soap->labidx ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(tmp_if_expr_3)
      {
        return_value_memcpy_2=memcpy((void *)soap->labbuf, (const void *)t, soap->labidx);
        (signed int)!(return_value_memcpy_2 != NULL);
      }

      else
        34;
      free((void *)t);
    }

  }

  void *return_value_memcpy_4;
  if(!(s == ((const char *)NULL)))
  {
    _Bool tmp_if_expr_5;
    if(!(soap->labbuf + (signed long int)soap->labidx == ((char *)NULL)))
      tmp_if_expr_5 = (unsigned long int)(soap->lablen - soap->labidx) >= (unsigned long int)n ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
    {
      return_value_memcpy_4=memcpy((void *)(soap->labbuf + (signed long int)soap->labidx), (const void *)s, n);
      (signed int)!(return_value_memcpy_4 != NULL);
    }

    else
      34;
    soap->labidx = soap->labidx + n;
  }

  return 0;
}

// soap_array_begin_out
// file stdsoap2.c line 10654
signed int soap_array_begin_out(struct soap *soap, const char *tag, signed int id, const char *type, const char *offset)
{
  _Bool tmp_if_expr_2;
  if(type == ((const char *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = !(*type != 0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = (signed int)soap->version == 0 ? (_Bool)1 : (_Bool)0;
  signed int return_value_soap_element_begin_out_1;
  if(tmp_if_expr_3)
  {
    return_value_soap_element_begin_out_1=soap_element_begin_out(soap, tag, id, (const char *)(void *)0);
    return return_value_soap_element_begin_out_1;
  }

  signed int return_value_soap_element_4;
  return_value_soap_element_4=soap_element(soap, tag, id, (const char *)(void *)0);
  signed int return_value_soap_attribute_5;
  if(!(return_value_soap_element_4 == 0))
    return soap->error;

  else
  {
    if((signed int)soap->version == 1)
    {
      if(!(offset == ((const char *)NULL)))
      {
        return_value_soap_attribute_5=soap_attribute(soap, "SOAP-ENC:offset", offset);
        if(!(return_value_soap_attribute_5 == 0))
          return soap->error;

      }

      signed int return_value_soap_attribute_6;
      return_value_soap_attribute_6=soap_attribute(soap, "SOAP-ENC:arrayType", type);
      if(!(return_value_soap_attribute_6 == 0))
        return soap->error;

    }

    else
    {
      const char *s;
      s=strrchr(type, 91);
      if(!(s == ((const char *)NULL)) && !((unsigned long int)(s - type) >= sizeof(char [1024l]) /*1024ul*/ ))
      {
        signed int tmp_if_expr_7;
        if(!((unsigned long int)(s - type) >= sizeof(char [1024l]) /*1024ul*/ ))
        {
          strncpy(soap->tmpbuf, type, (unsigned long int)(s - type));
          soap->tmpbuf[(signed long int)(unsigned long int)(s - type)] = (char)0;
          tmp_if_expr_7 = (signed int)soap->tmpbuf[(signed long int)(unsigned long int)(s - type)];
        }

        else
        {
          soap->tmpbuf[(signed long int)0] = (char)0;
          tmp_if_expr_7 = (signed int)soap->tmpbuf[(signed long int)0];
        }
        (void)(tmp_if_expr_7 != 0 ? (_Bool)1 : (_Bool)0);
        signed int return_value_soap_attribute_8;
        return_value_soap_attribute_8=soap_attribute(soap, "SOAP-ENC:itemType", soap->tmpbuf);
        if(!(return_value_soap_attribute_8 == 0))
          return soap->error;

        s = s + 1l;
        if(!(*s == 0))
        {
          strncpy(soap->tmpbuf, s, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
          soap->tmpbuf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
          (void)(soap->tmpbuf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
          unsigned long int return_value_strlen_9;
          return_value_strlen_9=strlen(soap->tmpbuf);
          soap->tmpbuf[(signed long int)(return_value_strlen_9 - (unsigned long int)1)] = (char)0;
          signed int return_value_soap_attribute_10;
          return_value_soap_attribute_10=soap_attribute(soap, "SOAP-ENC:arraySize", soap->tmpbuf);
          if(!(return_value_soap_attribute_10 == 0))
            return soap->error;

        }

      }

    }
    if(!((0x00010000 & soap->mode) == 0))
      soap_utilize_ns(soap, type);

    signed int return_value_soap_element_start_end_out_11;
    return_value_soap_element_start_end_out_11=soap_element_start_end_out(soap, (const char *)(void *)0);
    return return_value_soap_element_start_end_out_11;
  }
}

// soap_array_pointer_lookup
// file stdsoap2.c line 7600
signed int soap_array_pointer_lookup(struct soap *soap, const void *p, const void *a, signed int n, signed int type, struct soap_plist **ppp)
{
  struct soap_plist *pp;
  *ppp = (struct soap_plist *)(void *)0;
  if(a == NULL || p == NULL)
    return 0;

  else
  {
    pp = soap->pht[(signed long int)(unsigned long int)((unsigned long int)a >> 3 & (unsigned long int)(4096 - 1))];
    for( ; !(pp == ((struct soap_plist *)NULL)); pp = pp->next)
      if(pp->type == type)
      {
        if(pp->array == a)
        {
          if(pp->size == n)
          {
            *ppp = pp;
            return pp->id;
          }

        }

      }

    return 0;
  }
}

// soap_array_reference
// file stdsoap2.c line 7896
signed int soap_array_reference(struct soap *soap, const void *p, const void *a, signed int n, signed int t)
{
  struct soap_plist *pp;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  if(a == NULL || p == NULL)
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    if(soap->encodingStyle == ((const char *)NULL))
      tmp_if_expr_1 = !((soap->omode & (0x00000080 | 0x00000100 | 0x00000200 | 0x20000000)) != 0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = (soap->omode & 0x00020000) != 0 ? (_Bool)1 : (_Bool)0;
  signed int return_value_soap_pointer_enter_4;
  if(tmp_if_expr_3)
    return 1;

  else
  {
    signed int return_value_soap_array_pointer_lookup_5;
    return_value_soap_array_pointer_lookup_5=soap_array_pointer_lookup(soap, p, a, n, t, &pp);
    if(!(return_value_soap_array_pointer_lookup_5 == 0))
    {
      if((signed int)pp->mark1 == 0)
      {
        pp->mark1 = (char)2;
        pp->mark2 = (char)2;
      }

    }

    else
    {
      return_value_soap_pointer_enter_4=soap_pointer_enter(soap, p, a, n, t, &pp);
      if(return_value_soap_pointer_enter_4 == 0)
        return 1;

    }
    return (signed int)pp->mark1;
  }
}

// soap_att
// file dom.c line 1200
struct soap_dom_attribute * soap_att(struct soap_dom_element *elt, const char *ns, const char *tag)
{
  struct soap_dom_attribute *return_value_soap_att_add_1;
  if(elt == ((struct soap_dom_element *)NULL))
    return (struct soap_dom_attribute *)(void *)0;

  else
  {
    if(!(elt->atts == ((struct soap_dom_attribute *)NULL)))
    {
      return_value_soap_att_add_1=soap_att_add(elt->atts, ns, tag);
      return return_value_soap_att_add_1;
    }

    elt->atts=soap_att_new(elt->soap, ns, tag);
    return elt->atts;
  }
}

// soap_att_add
// file dom.c line 2116
struct soap_dom_attribute * soap_att_add(struct soap_dom_attribute *att, const char *ns, const char *tag)
{
  struct soap_dom_attribute *return_value_soap_att_set_1;
  signed int return_value_soap_tag_match_6;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  signed int return_value_strcmp_3;
  if(!(tag == ((const char *)NULL)) && !(att == ((struct soap_dom_attribute *)NULL)))
  {
    const char *ns1 = ns;
    if(att->name == ((const char *)NULL))
    {
      return_value_soap_att_set_1=soap_att_set(att, ns, tag);
      return return_value_soap_att_set_1;
    }

    if(ns1 == ((const char *)NULL))
      ns1=soap_ns_to_set(att->soap, tag);

    while(!(att == ((struct soap_dom_attribute *)NULL)))
    {
      if(!(att->name == ((const char *)NULL)))
      {
        return_value_soap_tag_match_6=soap_tag_match(att->name, tag);
        if(!(return_value_soap_tag_match_6 == 0))
        {
          _Bool tmp_if_expr_5;
          if(ns1 == att->nstr)
            tmp_if_expr_5 = (_Bool)1;

          else
          {
            if(!(ns1 == ((const char *)NULL)))
              tmp_if_expr_2 = att->nstr != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_2 = (_Bool)0;
            if(tmp_if_expr_2)
            {
              return_value_strcmp_3=strcmp(ns1, att->nstr);
              tmp_if_expr_4 = !(return_value_strcmp_3 != 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_4 = (_Bool)0;
            tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_5)
            return att;

        }

      }

      if(att->next == ((struct soap_dom_attribute *)NULL))
      {
        att->next=soap_att_new(att->soap, ns, tag);
        return att->next;
      }

      att = att->next;
    }
  }

  return att;
}

// soap_att_add_w
// file dom.c line 2150
struct soap_dom_attribute * soap_att_add_w(struct soap_dom_attribute *att, const char *ns, const signed int *tag)
{
  struct soap_dom_attribute *return_value_soap_att_set_1;
  signed int return_value_soap_tag_match_6;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  signed int return_value_strcmp_3;
  if(!(tag == ((const signed int *)NULL)) && !(att == ((struct soap_dom_attribute *)NULL)))
  {
    const char *name;
    name=soap_wchar2s(att->soap, tag);
    const char *ns1 = ns;
    if(att->name == ((const char *)NULL))
    {
      return_value_soap_att_set_1=soap_att_set(att, ns, name);
      return return_value_soap_att_set_1;
    }

    if(ns1 == ((const char *)NULL))
      ns1=soap_ns_to_set(att->soap, name);

    while(!(att == ((struct soap_dom_attribute *)NULL)))
    {
      if(!(att->name == ((const char *)NULL)))
      {
        return_value_soap_tag_match_6=soap_tag_match(att->name, name);
        if(!(return_value_soap_tag_match_6 == 0))
        {
          _Bool tmp_if_expr_5;
          if(ns1 == att->nstr)
            tmp_if_expr_5 = (_Bool)1;

          else
          {
            if(!(ns1 == ((const char *)NULL)))
              tmp_if_expr_2 = att->nstr != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_2 = (_Bool)0;
            if(tmp_if_expr_2)
            {
              return_value_strcmp_3=strcmp(ns1, att->nstr);
              tmp_if_expr_4 = !(return_value_strcmp_3 != 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_4 = (_Bool)0;
            tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_5)
            return att;

        }

      }

      if(att->next == ((struct soap_dom_attribute *)NULL))
      {
        att->next=soap_att_new(att->soap, ns, (const char *)(void *)0);
        if(!(att->next == ((struct soap_dom_attribute *)NULL)))
          att->next->name = name;

        return att->next;
      }

      att = att->next;
    }
  }

  return att;
}

// soap_att_bool
// file dom.c line 2193
struct soap_dom_attribute * soap_att_bool(struct soap_dom_attribute *att, signed long int b)
{
  if(!(att == ((struct soap_dom_attribute *)NULL)))
    att->text = b != 0l ? "true" : "false";

  return att;
}

// soap_att_copy
// file dom.c line 2279
struct soap_dom_attribute * soap_att_copy(struct soap_dom_attribute *att, struct soap_dom_attribute *node)
{
  if(!(att == ((struct soap_dom_attribute *)NULL)))
  {
    att->nstr = node->nstr;
    att->name = node->name;
    att->text = node->text;
  }

  return att;
}

// soap_att_double
// file dom.c line 2227
struct soap_dom_attribute * soap_att_double(struct soap_dom_attribute *att, double x)
{
  const char *return_value_soap_double2s_1;
  return_value_soap_double2s_1=soap_double2s(att->soap, x);
  struct soap_dom_attribute *return_value_soap_att_text_2;
  return_value_soap_att_text_2=soap_att_text(att, return_value_soap_double2s_1);
  return return_value_soap_att_text_2;
}

// soap_att_find
// file dom.c line 2761
struct soap_dom_attribute * soap_att_find(struct soap_dom_element *elt, const char *ns, const char *patt)
{
  struct soap_dom_attribute *att = (struct soap_dom_attribute *)(void *)0;
  signed int return_value_soap_patt_match_2;
  struct soap_dom_attribute *return_value_soap_att_find_next_1;
  signed int return_value_soap_name_match_4;
  struct soap_dom_attribute *return_value_soap_att_find_next_3;
  if(!(elt == ((struct soap_dom_element *)NULL)))
  {
    att = elt->atts;
    if(!(att == ((struct soap_dom_attribute *)NULL)))
    {
      if(ns == ((const char *)NULL) && !(patt == ((const char *)NULL)))
        ns=soap_ns_to_find(elt->soap, patt);

      if(!(patt == ((const char *)NULL)))
      {
        return_value_soap_patt_match_2=soap_patt_match(att->name, patt);
        if(return_value_soap_patt_match_2 == 0)
        {
          return_value_soap_att_find_next_1=soap_att_find_next(att, ns, patt);
          return return_value_soap_att_find_next_1;
        }

      }

      if(!(ns == ((const char *)NULL)))
      {
        _Bool tmp_if_expr_6;
        if(!(att->nstr == ((const char *)NULL)))
          tmp_if_expr_6 = (_Bool)1;

        else
          tmp_if_expr_6 = *ns != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_6)
        {
          _Bool tmp_if_expr_5;
          if(att->nstr == ((const char *)NULL))
            tmp_if_expr_5 = (_Bool)1;

          else
          {
            return_value_soap_name_match_4=soap_name_match(att->nstr, ns);
            tmp_if_expr_5 = !(return_value_soap_name_match_4 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_5)
          {
            return_value_soap_att_find_next_3=soap_att_find_next(att, ns, patt);
            return return_value_soap_att_find_next_3;
          }

        }

      }

    }

  }

  return att;
}

// soap_att_find_next
// file dom.c line 2792
struct soap_dom_attribute * soap_att_find_next(struct soap_dom_attribute *att, const char *ns, const char *patt)
{
  signed int return_value_soap_patt_match_1;
  signed int return_value_soap_name_match_2;
  if(!(att == ((struct soap_dom_attribute *)NULL)))
  {
    struct soap_dom_attribute *node;
    if(ns == ((const char *)NULL) && !(patt == ((const char *)NULL)))
      ns=soap_ns_to_find(att->soap, patt);

    node = att->next;
    for( ; !(node == ((struct soap_dom_attribute *)NULL)); node = node->next)
    {
      if(!(patt == ((const char *)NULL)))
      {
        return_value_soap_patt_match_1=soap_patt_match(node->name, patt);
        if(return_value_soap_patt_match_1 == 0)
          goto __CPROVER_DUMP_L11;

      }

      if(!(ns == ((const char *)NULL)))
      {
        _Bool tmp_if_expr_4;
        if(!(node->nstr == ((const char *)NULL)))
          tmp_if_expr_4 = (_Bool)1;

        else
          tmp_if_expr_4 = *ns != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_4)
        {
          _Bool tmp_if_expr_3;
          if(node->nstr == ((const char *)NULL))
            tmp_if_expr_3 = (_Bool)1;

          else
          {
            return_value_soap_name_match_2=soap_name_match(node->nstr, ns);
            tmp_if_expr_3 = !(return_value_soap_name_match_2 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_3)
            goto __CPROVER_DUMP_L11;

        }

      }

      return node;

    __CPROVER_DUMP_L11:
      ;
    }
  }

  return (struct soap_dom_attribute *)(void *)0;
}

// soap_att_first
// file dom.c line 2532
struct soap_dom_attribute * soap_att_first(struct soap_dom_element *elt)
{
  return elt->atts;
}

// soap_att_get
// file dom.c line 2598
struct soap_dom_attribute * soap_att_get(struct soap_dom_element *elt, const char *ns, const char *tag)
{
  signed int return_value_soap_tag_match_5;
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(!(tag == ((const char *)NULL)) && !(elt == ((struct soap_dom_element *)NULL)))
  {
    struct soap_dom_attribute *att;
    if(ns == ((const char *)NULL))
      ns=soap_ns_to_get(elt->soap, tag);

    att = elt->atts;
    for( ; !(att == ((struct soap_dom_attribute *)NULL)); att = att->next)
      if(!(att->name == ((const char *)NULL)))
      {
        return_value_soap_tag_match_5=soap_tag_match(att->name, tag);
        if(!(return_value_soap_tag_match_5 == 0))
        {
          _Bool tmp_if_expr_1;
          if(att->nstr == ((const char *)NULL))
            tmp_if_expr_1 = !(*ns != 0) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_1 = (_Bool)0;
          _Bool tmp_if_expr_4;
          if(tmp_if_expr_1)
            tmp_if_expr_4 = (_Bool)1;

          else
          {
            if(!(att->nstr == ((const char *)NULL)))
            {
              return_value_strcmp_2=strcmp(att->nstr, ns);
              tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_3 = (_Bool)0;
            tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_4)
            return att;

        }

      }

  }

  return (struct soap_dom_attribute *)(void *)0;
}

// soap_att_get_LONG64
// file dom.c line 2467
signed long int soap_att_get_LONG64(struct soap_dom_attribute *att)
{
  signed int return_value_soap_s2LONG64_1;
  if(!(att == ((struct soap_dom_attribute *)NULL)))
  {
    signed long int n;
    if(!(att->text == ((const char *)NULL)))
    {
      return_value_soap_s2LONG64_1=soap_s2LONG64(att->soap, att->text, &n);
      if(return_value_soap_s2LONG64_1 == 0)
        return n;

    }

    att->soap->error = 0;
  }

  return (signed long int)0;
}

// soap_att_get_double
// file dom.c line 2489
double soap_att_get_double(struct soap_dom_attribute *att)
{
  signed int return_value_soap_s2double_1;
  if(!(att == ((struct soap_dom_attribute *)NULL)))
  {
    double x;
    if(!(att->text == ((const char *)NULL)))
    {
      return_value_soap_s2double_1=soap_s2double(att->soap, att->text, &x);
      if(return_value_soap_s2double_1 == 0)
        return x;

    }

    att->soap->error = 0;
  }

  return soap_double_nan.dv;
}

// soap_att_get_int
// file dom.c line 2423
signed int soap_att_get_int(struct soap_dom_attribute *att)
{
  signed int return_value_soap_s2int_1;
  if(!(att == ((struct soap_dom_attribute *)NULL)))
  {
    signed int n;
    if(!(att->text == ((const char *)NULL)))
    {
      return_value_soap_s2int_1=soap_s2int(att->soap, att->text, &n);
      if(return_value_soap_s2int_1 == 0)
        return n;

    }

    att->soap->error = 0;
  }

  return 0;
}

// soap_att_get_long
// file dom.c line 2445
signed long int soap_att_get_long(struct soap_dom_attribute *att)
{
  signed int return_value_soap_s2long_1;
  if(!(att == ((struct soap_dom_attribute *)NULL)))
  {
    signed long int n;
    if(!(att->text == ((const char *)NULL)))
    {
      return_value_soap_s2long_1=soap_s2long(att->soap, att->text, &n);
      if(return_value_soap_s2long_1 == 0)
        return n;

    }

    att->soap->error = 0;
  }

  return (signed long int)0;
}

// soap_att_get_ns
// file dom.c line 2359
const char * soap_att_get_ns(struct soap_dom_attribute *att)
{
  if(!(att == ((struct soap_dom_attribute *)NULL)))
    return att->nstr;

  else
    return (const char *)(void *)0;
}

// soap_att_get_tag
// file dom.c line 2376
const char * soap_att_get_tag(struct soap_dom_attribute *att)
{
  if(!(att == ((struct soap_dom_attribute *)NULL)))
    return att->name;

  else
    return (const char *)(void *)0;
}

// soap_att_get_text
// file dom.c line 2511
const char * soap_att_get_text(struct soap_dom_attribute *att)
{
  if(!(att == ((struct soap_dom_attribute *)NULL)))
    return att->text;

  else
    return (const char *)(void *)0;
}

// soap_att_get_w
// file dom.c line 2625
struct soap_dom_attribute * soap_att_get_w(struct soap_dom_element *elt, const char *ns, const signed int *tag)
{
  signed int return_value_soap_tag_match_5;
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(!(tag == ((const signed int *)NULL)) && !(elt == ((struct soap_dom_element *)NULL)))
  {
    const char *name;
    name=soap_wchar2s((struct soap *)(void *)0, tag);
    struct soap_dom_attribute *att = (struct soap_dom_attribute *)(void *)0;
    if(ns == ((const char *)NULL))
      ns=soap_ns_to_get(elt->soap, name);

    att = elt->atts;
    for( ; !(att == ((struct soap_dom_attribute *)NULL)); att = att->next)
      if(!(att->name == ((const char *)NULL)))
      {
        return_value_soap_tag_match_5=soap_tag_match(att->name, name);
        if(!(return_value_soap_tag_match_5 == 0))
        {
          _Bool tmp_if_expr_1;
          if(att->nstr == ((const char *)NULL))
            tmp_if_expr_1 = !(*ns != 0) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_1 = (_Bool)0;
          _Bool tmp_if_expr_4;
          if(tmp_if_expr_1)
            tmp_if_expr_4 = (_Bool)1;

          else
          {
            if(!(att->nstr == ((const char *)NULL)))
            {
              return_value_strcmp_2=strcmp(att->nstr, ns);
              tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_3 = (_Bool)0;
            tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_4)
            break;

        }

      }

    if(!(name == ((const char *)NULL)))
      free((void *)name);

    return att;
  }

  return (struct soap_dom_attribute *)(void *)0;
}

// soap_att_int
// file dom.c line 2211
struct soap_dom_attribute * soap_att_int(struct soap_dom_attribute *att, signed long int n)
{
  const char *return_value_soap_LONG642s_1;
  return_value_soap_LONG642s_1=soap_LONG642s(att->soap, n);
  struct soap_dom_attribute *return_value_soap_att_text_2;
  return_value_soap_att_text_2=soap_att_text(att, return_value_soap_LONG642s_1);
  return return_value_soap_att_text_2;
}

// soap_att_is_false
// file dom.c line 2408
signed int soap_att_is_false(struct soap_dom_attribute *att)
{
  _Bool tmp_if_expr_4;
  signed int return_value_strcmp_1;
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(!(att->text == ((const char *)NULL)))
  {
    return_value_strcmp_1=strcmp(att->text, "false");
    if(return_value_strcmp_1 == 0)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_strcmp_2=strcmp(att->text, "0");
      tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
    }
    tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_4 = (_Bool)0;
  return (signed int)tmp_if_expr_4;
}

// soap_att_is_true
// file dom.c line 2393
signed int soap_att_is_true(struct soap_dom_attribute *att)
{
  _Bool tmp_if_expr_4;
  signed int return_value_strcmp_1;
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(!(att->text == ((const char *)NULL)))
  {
    return_value_strcmp_1=strcmp(att->text, "true");
    if(return_value_strcmp_1 == 0)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_strcmp_2=strcmp(att->text, "1");
      tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
    }
    tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_4 = (_Bool)0;
  return (signed int)tmp_if_expr_4;
}

// soap_att_match
// file dom.c line 2306
signed int soap_att_match(struct soap_dom_attribute *att, const char *ns, const char *patt)
{
  _Bool tmp_if_expr_1;
  if(att == ((struct soap_dom_attribute *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(att->name != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
  signed int return_value_soap_patt_match_2;
  signed int return_value_soap_name_match_3;
  if(tmp_if_expr_1)
    return 0;

  else
  {
    if(ns == ((const char *)NULL) && !(patt == ((const char *)NULL)))
      ns=soap_ns_to_find(att->soap, patt);

    if(!(patt == ((const char *)NULL)))
    {
      return_value_soap_patt_match_2=soap_patt_match(att->name, patt);
      if(return_value_soap_patt_match_2 == 0)
        return 0;

    }

    if(!(ns == ((const char *)NULL)))
    {
      _Bool tmp_if_expr_5;
      if(!(att->nstr == ((const char *)NULL)))
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = *ns != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
      {
        _Bool tmp_if_expr_4;
        if(att->nstr == ((const char *)NULL))
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_soap_name_match_3=soap_name_match(att->nstr, ns);
          tmp_if_expr_4 = !(return_value_soap_name_match_3 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
          return 0;

      }

    }

    return 1;
  }
}

// soap_att_match_w
// file dom.c line 2331
signed int soap_att_match_w(struct soap_dom_attribute *att, const char *ns, const signed int *patt)
{
  const char *s;
  signed int r = 1;
  _Bool tmp_if_expr_1;
  if(att == ((struct soap_dom_attribute *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(att->name != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
  signed int return_value_soap_patt_match_5;
  signed int return_value_soap_name_match_2;
  if(tmp_if_expr_1)
    return 0;

  else
  {
    s=soap_wchar2s((struct soap *)(void *)0, patt);
    if(ns == ((const char *)NULL) && !(s == ((const char *)NULL)))
      ns=soap_ns_to_find(att->soap, s);

    _Bool tmp_if_expr_6;
    if(!(s == ((const char *)NULL)))
    {
      return_value_soap_patt_match_5=soap_patt_match(att->name, s);
      tmp_if_expr_6 = !(return_value_soap_patt_match_5 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_6 = (_Bool)0;
    if(tmp_if_expr_6)
      r = 0;

    else
      if(!(ns == ((const char *)NULL)))
      {
        _Bool tmp_if_expr_4;
        if(!(att->nstr == ((const char *)NULL)))
          tmp_if_expr_4 = (_Bool)1;

        else
          tmp_if_expr_4 = *ns != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_4)
        {
          _Bool tmp_if_expr_3;
          if(att->nstr == ((const char *)NULL))
            tmp_if_expr_3 = (_Bool)1;

          else
          {
            return_value_soap_name_match_2=soap_name_match(att->nstr, ns);
            tmp_if_expr_3 = !(return_value_soap_name_match_2 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_3)
            r = 0;

        }

      }

    if(!(s == ((const char *)NULL)))
      free((void *)s);

    return r;
  }
}

// soap_att_new
// file dom.c line 2032
struct soap_dom_attribute * soap_att_new(struct soap *soap, const char *ns, const char *tag)
{
  struct soap_dom_attribute *return_value_new_attribute_1;
  return_value_new_attribute_1=new_attribute(soap);
  struct soap_dom_attribute *return_value_soap_att_set_2;
  return_value_soap_att_set_2=soap_att_set(return_value_new_attribute_1, ns, tag);
  return return_value_soap_att_set_2;
}

// soap_att_new_w
// file dom.c line 2049
struct soap_dom_attribute * soap_att_new_w(struct soap *soap, const char *ns, const signed int *tag)
{
  struct soap_dom_attribute *return_value_new_attribute_1;
  return_value_new_attribute_1=new_attribute(soap);
  struct soap_dom_attribute *return_value_soap_att_set_w_2;
  return_value_soap_att_set_w_2=soap_att_set_w(return_value_new_attribute_1, ns, tag);
  return return_value_soap_att_set_w_2;
}

// soap_att_next
// file dom.c line 2547
struct soap_dom_attribute * soap_att_next(struct soap_dom_attribute *att)
{
  return att->next;
}

// soap_att_set
// file dom.c line 2066
struct soap_dom_attribute * soap_att_set(struct soap_dom_attribute *att, const char *ns, const char *tag)
{
  if(!(att == ((struct soap_dom_attribute *)NULL)))
  {
    att->name=soap_strdup(att->soap, tag);
    if(ns == ((const char *)NULL))
      att->nstr=soap_ns_to_set(att->soap, tag);

    else
      att->nstr=soap_strdup(att->soap, ns);
  }

  return att;
}

// soap_att_set_w
// file dom.c line 2091
struct soap_dom_attribute * soap_att_set_w(struct soap_dom_attribute *att, const char *ns, const signed int *tag)
{
  if(!(att == ((struct soap_dom_attribute *)NULL)))
  {
    att->name=soap_wchar2s(att->soap, tag);
    if(ns == ((const char *)NULL))
      att->nstr=soap_ns_to_set(att->soap, att->name);

    else
      att->nstr=soap_strdup(att->soap, ns);
  }

  return att;
}

// soap_att_size
// file dom.c line 2928
unsigned long int soap_att_size(struct soap_dom_element *elt, const char *ns, const char *patt)
{
  unsigned long int n = (unsigned long int)0;
  if(!(elt == ((struct soap_dom_element *)NULL)))
  {
    struct soap_dom_attribute *att;
    att=soap_att_find(elt, ns, patt);
    if(!(att == ((struct soap_dom_attribute *)NULL)))
    {
      n = n + 1ul;
      do
      {
        att=soap_att_find_next(att, ns, patt);
        if(att == ((struct soap_dom_attribute *)NULL))
          break;

        n = n + 1ul;
      }
      while((_Bool)1);
    }

  }

  return n;
}

// soap_att_text
// file dom.c line 2243
struct soap_dom_attribute * soap_att_text(struct soap_dom_attribute *att, const char *text)
{
  if(!(att == ((struct soap_dom_attribute *)NULL)))
    att->text=soap_strdup(att->soap, text);

  return att;
}

// soap_att_text_w
// file dom.c line 2261
struct soap_dom_attribute * soap_att_text_w(struct soap_dom_attribute *att, const signed int *text)
{
  if(!(att == ((struct soap_dom_attribute *)NULL)))
    att->text=soap_wchar2s(att->soap, text);

  return att;
}

// soap_att_w
// file dom.c line 1221
struct soap_dom_attribute * soap_att_w(struct soap_dom_element *elt, const char *ns, const signed int *tag)
{
  struct soap_dom_attribute *return_value_soap_att_add_w_1;
  if(elt == ((struct soap_dom_element *)NULL))
    return (struct soap_dom_attribute *)(void *)0;

  else
  {
    if(!(elt->atts == ((struct soap_dom_attribute *)NULL)))
    {
      return_value_soap_att_add_w_1=soap_att_add_w(elt->atts, ns, tag);
      return return_value_soap_att_add_w_1;
    }

    elt->atts=soap_att_new_w(elt->soap, ns, tag);
    return elt->atts;
  }
}

// soap_attachment
// file stdsoap2.c line 8020
signed int soap_attachment(struct soap *soap, const char *tag, signed int id, const void *p, const void *a, signed int n, const char *aid, const char *atype, const char *aoptions, const char *type, signed int t)
{
  struct soap_plist *pp;
  signed int i;
  signed int return_value_soap_element_id_1;
  if(a == NULL || p == NULL || aid == ((const char *)NULL) && atype == ((const char *)NULL))
  {
    return_value_soap_element_id_1=soap_element_id(soap, tag, id, p, a, n, type, t, (char **)(void *)0);
    return return_value_soap_element_id_1;
  }

  i=soap_array_pointer_lookup(soap, p, a, n, t, &pp);
  signed int return_value_strcmp_8;
  signed int return_value_soap_element_href_3;
  signed int return_value_soap_element_end_out_5;
  signed int return_value_soap_element_href_7;
  signed int tmp_if_expr_12;
  if(i == 0)
  {
    i=soap_pointer_enter(soap, p, a, n, t, &pp);
    if(!(i == 0))
      goto __CPROVER_DUMP_L2;

    soap->error = 20;
    return -1;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    if(!(id >= 1))
      id = i;

    if(aid == ((const char *)NULL))
    {
      snprintf(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , soap->dime_id_format, id);
      aid=soap_strdup(soap, soap->tmpbuf);
    }

    _Bool tmp_if_expr_9;
    if(!((0x00000200 & soap->mode) == 0))
    {
      return_value_strcmp_8=strcmp(tag, "xop:Include");
      tmp_if_expr_9 = return_value_strcmp_8 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_9 = (_Bool)0;
    if(tmp_if_expr_9)
    {
      signed int return_value_soap_element_begin_out_2;
      return_value_soap_element_begin_out_2=soap_element_begin_out(soap, tag, 0, type);
      _Bool tmp_if_expr_4;
      if(!(return_value_soap_element_begin_out_2 == 0))
        tmp_if_expr_4 = (_Bool)1;

      else
      {
        return_value_soap_element_href_3=soap_element_href(soap, "xop:Include", 0, "xmlns:xop=\"http://www.w3.org/2004/08/xop/include\" href", aid);
        tmp_if_expr_4 = return_value_soap_element_href_3 != 0 ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_6;
      if(tmp_if_expr_4)
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        return_value_soap_element_end_out_5=soap_element_end_out(soap, tag);
        tmp_if_expr_6 = return_value_soap_element_end_out_5 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_6)
        return soap->error;

    }

    else
    {
      return_value_soap_element_href_7=soap_element_href(soap, tag, 0, "href", aid);
      if(!(return_value_soap_element_href_7 == 0))
        return soap->error;

    }
    if(!((0x00000008 & soap->mode) == 0))
    {
      if(!((signed int)pp->mark1 == 3))
      {
        struct soap_multipart *content;
        if(!((0x00000200 & soap->mode) == 0))
          content=soap_new_multipart(soap, &soap->mime.first, &soap->mime.last, (char *)a, (unsigned long int)n);

        else
          content=soap_new_multipart(soap, &soap->dime.first, &soap->dime.last, (char *)a, (unsigned long int)n);
        if(content == ((struct soap_multipart *)NULL))
        {
          soap->error = 20;
          return -1;
        }

        signed int return_value_strncmp_13;
        return_value_strncmp_13=strncmp(aid, "cid:", (unsigned long int)4);
        if(return_value_strncmp_13 == 0)
        {
          if(!((0x00000200 & soap->mode) == 0))
          {
            unsigned long int l;
            unsigned long int return_value_strlen_10;
            return_value_strlen_10=strlen(aid);
            l = return_value_strlen_10 - (unsigned long int)1;
            char *s;
            void *return_value_soap_malloc_11;
            return_value_soap_malloc_11=soap_malloc(soap, l);
            s = (char *)return_value_soap_malloc_11;
            if(!(s == ((char *)NULL)))
            {
              s[(signed long int)0] = (char)60;
              if(!(s + 1l == ((char *)NULL)))
              {
                if(!(l + 18446744073709551613ul >= l + 18446744073709551615ul))
                {
                  strncpy(s + (signed long int)1, aid + (signed long int)4, l - (unsigned long int)3);
                  (s + (signed long int)1)[(signed long int)(unsigned long int)(l - (unsigned long int)3)] = (char)0;
                  tmp_if_expr_12 = (signed int)(s + (signed long int)1)[(signed long int)(unsigned long int)(l - (unsigned long int)3)];
                }

                else
                {
                  (s + (signed long int)1)[(signed long int)0] = (char)0;
                  tmp_if_expr_12 = (signed int)(s + (signed long int)1)[(signed long int)0];
                }
                if(!(tmp_if_expr_12 == 0))
                  (_Bool)1;

                else
                  (_Bool)0;
              }

              else
                (_Bool)0;
              s[(signed long int)(l - (unsigned long int)2)] = (char)62;
              s[(signed long int)(l - (unsigned long int)1)] = (char)0;
              content->id = s;
            }

          }

          else
            content->id = aid + (signed long int)4;
        }

        else
          content->id = aid;
        content->type = atype;
        content->options = aoptions;
        content->encoding = (enum soap_mime_encoding)SOAP_MIME_BINARY;
        pp->mark1 = (char)3;
      }

    }

    else
      pp->mark2 = (char)3;
    return -1;
  }
}

// soap_attachment_forward
// file stdsoap2.c line 2212
signed int soap_attachment_forward(struct soap *soap, unsigned char **ptr, signed int *size, char **id, char **type, char **options)
{
  struct soap_xlist *xp;
  *ptr = (unsigned char *)(void *)0;
  *size = 0;
  *id = (char *)(void *)0;
  *type = (char *)(void *)0;
  *options = (char *)(void *)0;
  if(soap->href[0l] == 0)
    return 0;

  else
  {
    *id=soap_strdup(soap, soap->href);
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct soap_xlist) /*48ul*/ );
    xp = (struct soap_xlist *)return_value_malloc_1;
    if(xp == ((struct soap_xlist *)NULL))
    {
      soap->error = 20;
      return soap->error;
    }

    else
    {
      xp->next = soap->xlist;
      xp->ptr = ptr;
      xp->size = size;
      xp->id = *id;
      xp->type = type;
      xp->options = options;
      soap->xlist = xp;
      return 0;
    }
  }
}

// soap_attr_value
// file stdsoap2.c line 11250
const char * soap_attr_value(struct soap *soap, const char *name, signed int flag)
{
  struct soap_attribute *tp;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  if((signed int)*name == 45)
    return soap_padding;

  else
  {
    tp = soap->attributes;
    for( ; !(tp == ((struct soap_attribute *)NULL)); tp = tp->next)
    {
      signed int return_value_soap_match_tag_1;
      return_value_soap_match_tag_1=soap_match_tag(soap, tp->name, name);
      if(return_value_soap_match_tag_1 == 0)
        break;

    }
    _Bool tmp_if_expr_6;
    if(!(tp == ((struct soap_attribute *)NULL)))
      tmp_if_expr_6 = (signed int)tp->visible == 2 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_6 = (_Bool)0;
    if(tmp_if_expr_6)
    {
      _Bool tmp_if_expr_3;
      if(flag == 4)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        if(flag == 2)
          tmp_if_expr_2 = (soap->mode & 0x00001000) != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
        soap->error = 43;

      else
        return tp->value;
    }

    else
    {
      _Bool tmp_if_expr_5;
      if(flag == 3)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        if(flag == 1)
          tmp_if_expr_4 = (soap->mode & 0x00001000) != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_5)
        soap->error = 42;

      else
        soap->error = 0;
    }
    return (const char *)(void *)0;
  }
}

// soap_attribute
// file stdsoap2.c line 11098
signed int soap_attribute(struct soap *soap, const char *name, const char *value)
{
  _Bool tmp_if_expr_3;
  signed int return_value_soap_set_attr_1;
  signed int return_value_soap_send_6;
  signed int return_value_soap_send_raw_8;
  signed int return_value_soap_string_out_9;
  signed int return_value_soap_send_raw_11;
  if(!((0x00010000 & soap->mode) == 0))
  {
    signed int return_value_strncmp_2;
    return_value_strncmp_2=strncmp(name, "xmlns", (unsigned long int)5);
    _Bool tmp_if_expr_4;
    if(return_value_strncmp_2 == 0)
    {
      if((signed int)name[5l] == 58)
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = (signed int)name[(signed long int)5] == 0 ? (_Bool)1 : (_Bool)0;
      tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
      soap_push_ns(soap, name + (signed long int)5 + (signed long int)((signed int)name[(signed long int)5] == 58), value, (signed short int)0);

    else
    {
      return_value_soap_set_attr_1=soap_set_attr(soap, name, value, 1);
      if(!(return_value_soap_set_attr_1 == 0))
        return soap->error;

    }
  }

  else
  {
    signed int return_value_soap_send_raw_5;
    return_value_soap_send_raw_5=soap_send_raw(soap, " ", (unsigned long int)1);
    _Bool tmp_if_expr_7;
    if(!(return_value_soap_send_raw_5 == 0))
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      return_value_soap_send_6=soap_send(soap, name);
      tmp_if_expr_7 = return_value_soap_send_6 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
      return soap->error;

    if(!(value == ((const char *)NULL)))
    {
      return_value_soap_send_raw_8=soap_send_raw(soap, "=\"", (unsigned long int)2);
      _Bool tmp_if_expr_10;
      if(!(return_value_soap_send_raw_8 == 0))
        tmp_if_expr_10 = (_Bool)1;

      else
      {
        return_value_soap_string_out_9=soap_string_out(soap, value, 1);
        tmp_if_expr_10 = return_value_soap_string_out_9 != 0 ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_12;
      if(tmp_if_expr_10)
        tmp_if_expr_12 = (_Bool)1;

      else
      {
        return_value_soap_send_raw_11=soap_send_raw(soap, "\"", (unsigned long int)1);
        tmp_if_expr_12 = return_value_soap_send_raw_11 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_12)
        return soap->error;

    }

  }
  return 0;
}

// soap_base642s
// file stdsoap2.c line 17364
const char * soap_base642s(struct soap *soap, const char *s, char *t, unsigned long int l, signed int *n)
{
  unsigned long int i;
  unsigned long int j;
  signed int c;
  unsigned long int m;
  const char *p;
  _Bool tmp_if_expr_1;
  if(s == ((const char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*s != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    if(!(n == ((signed int *)NULL)))
      *n = 0;

    if(!(soap->error == 0))
      return (const char *)(void *)0;

    return soap_padding;
  }

  else
  {
    if(t == ((char *)NULL))
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(s);
      l = ((return_value_strlen_2 + (unsigned long int)3) / (unsigned long int)4) * (unsigned long int)3 + (unsigned long int)1;
      void *return_value_soap_malloc_3;
      return_value_soap_malloc_3=soap_malloc(soap, l);
      t = (char *)return_value_soap_malloc_3;
    }

    if(t == ((char *)NULL))
      return (const char *)(void *)0;

    else
    {
      p = t;
      if(!(n == ((signed int *)NULL)))
        *n = 0;

      i = (unsigned long int)0;
      do
      {
        m = (unsigned long int)0;
        j = (unsigned long int)0;
        while(!(j >= 4ul))
        {
          const char *tmp_post_4 = s;
          s = s + 1l;
          c = (signed int)*tmp_post_4;
          if(c == 0 || c == 61)
          {
            if(l >= j + 18446744073709551615ul)
              switch(j)
              {
                case (unsigned long int)2:
                {
                  char *tmp_post_5 = t;
                  t = t + 1l;
                  *tmp_post_5 = (char)(m >> 4 & (unsigned long int)0xFF);
                  i = i + 1ul;
                  l = l - 1ul;
                  break;
                }
                case (unsigned long int)3:
                {
                  char *tmp_post_6 = t;
                  t = t + 1l;
                  *tmp_post_6 = (char)(m >> 10 & (unsigned long int)0xFF);
                  char *tmp_post_7 = t;
                  t = t + 1l;
                  *tmp_post_7 = (char)(m >> 2 & (unsigned long int)0xFF);
                  i = i + (unsigned long int)2;
                  l = l - (unsigned long int)2;
                }
              }

            if(!(n == ((signed int *)NULL)))
              *n = (signed int)i;

            if(!(l == 0ul))
              *t = (char)0;

            return p;
          }

          c = c - 43;
          if(c >= 0 && !(c >= 80))
          {
            signed int b = (signed int)soap_base64i[(signed long int)c];
            if(b >= 64)
            {
              soap->error = 4;
              return (const char *)(void *)0;
            }

            m = (m << 6) + (unsigned long int)b;
            j = j + 1ul;
          }

          else
            if(!(1 + c >= 1) || 43 + c >= 33)
            {
              soap->error = 4;
              return (const char *)(void *)0;
            }

        }
        if(!(l >= 3ul))
        {
          if(!(n == ((signed int *)NULL)))
            *n = (signed int)i;

          if(!(l == 0ul))
            *t = (char)0;

          return p;
        }

        char *tmp_post_8 = t;
        t = t + 1l;
        *tmp_post_8 = (char)(m >> 16 & (unsigned long int)0xFF);
        char *tmp_post_9 = t;
        t = t + 1l;
        *tmp_post_9 = (char)(m >> 8 & (unsigned long int)0xFF);
        char *tmp_post_10 = t;
        t = t + 1l;
        *tmp_post_10 = (char)(m & (unsigned long int)0xFF);
        i = i + (unsigned long int)3;
        l = l - (unsigned long int)3;
      }
      while((_Bool)1);
    }
  }
}

// soap_begin
// file ../../../gsoap/stdsoap2.h line 3051
void soap_begin(struct soap *soap)
{
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  if(soap == ((struct soap *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    if(!((signed int)soap->state == 1))
      tmp_if_expr_1 = (signed int)soap->state != 2 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
  }
  if(!tmp_if_expr_2)
  {
    if(soap->keep_alive == 0)
    {
      soap->buflen = (unsigned long int)0;
      soap->bufidx = (unsigned long int)0;
    }

    soap->null = (signed short int)0;
    soap->position = 0;
    soap->encoding = (signed short int)0;
    soap->mustUnderstand = (signed short int)0;
    soap->mode = 0;
    soap->ns = (signed short int)0;
    soap->part = (signed short int)9;
    soap->event = (signed short int)0;
    soap->evlev = (unsigned int)0;
    soap->count = (unsigned long int)0;
    soap->length = (unsigned long int)0;
    soap->cdata = (signed short int)0;
    soap->error = 0;
    soap->peeked = (signed short int)0;
    soap->ahead = 0;
    soap->idnum = 0;
    soap->level = (unsigned int)0;
    soap->endpoint[(signed long int)0] = (char)0;
    soap->encodingStyle = soap_padding;
    soap->dime.chunksize = (unsigned long int)0;
    soap->dime.buflen = (unsigned long int)0;
    soap_free_temp(soap);
  }

}

// soap_begin_count
// file stdsoap2.c line 7623
signed int soap_begin_count(struct soap *soap)
{
  soap_free_ns(soap);
  _Bool tmp_if_expr_4;
  if(!((0x00000080 & soap->mode) == 0))
    tmp_if_expr_4 = (_Bool)1;

  else
    tmp_if_expr_4 = (soap->omode & 0x00000080) != 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_4)
    soap->mode = soap->omode | 0x00000008 | 0x00000080;

  else
  {
    soap->mode = soap->omode;
    if(!((0x00000004 & soap->mode) == 0))
    {
      soap->mode = soap->mode | 0x00000040;
      soap->mode = soap->mode & ~0x00000003;
    }

    _Bool tmp_if_expr_3;
    if((0x00000003 & soap->mode) == 0x00000002)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      if((0x00000003 & soap->mode) == 0x00000003)
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = (soap->mode & 0x00000040) != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
        tmp_if_expr_2 = !(soap->fpreparesend != ((signed int (*)(struct soap *, const char *, unsigned long int))NULL)) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      soap->mode = soap->mode & ~0x00000008;

    else
      soap->mode = soap->mode | 0x00000008;
  }
  _Bool tmp_if_expr_5;
  if(!((0x00000200 & soap->mode) == 0))
    tmp_if_expr_5 = (soap->mode & 0x00000080) != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_5 = (_Bool)0;
  if(tmp_if_expr_5)
    soap->mode = soap->mode | 0x00000100;

  else
    if((0x00000100 & soap->mode) == 0)
      soap->mode = soap->mode & ~0x00000200;

  if(!((0x00000100 & soap->mode) == 0))
    soap_select_mime_boundary(soap);

  soap->dime.list = soap->dime.last;
  soap->count = (unsigned long int)0;
  soap->ns = (signed short int)0;
  soap->null = (signed short int)0;
  soap->position = 0;
  soap->mustUnderstand = (signed short int)0;
  soap->encoding = (signed short int)0;
  soap->part = (signed short int)0;
  soap->event = (signed short int)0;
  soap->evlev = (unsigned int)0;
  soap->idnum = 0;
  soap->body = (signed short int)1;
  soap->level = (unsigned int)0;
  soap_clr_attr(soap);
  soap_set_local_namespaces(soap);
  soap->dime.count = (unsigned long int)0;
  soap->dime.size = (unsigned long int)0;
  if(!(soap->fprepareinitsend == ((signed int (*)(struct soap *))NULL)))
  {
    if((0x00000003 & soap->mode) == 0x00000002)
      goto __CPROVER_DUMP_L19;

    soap->error=soap->fprepareinitsend(soap);
    return soap->error;
  }

  else
  {

  __CPROVER_DUMP_L19:
    ;
    return 0;
  }
}

// soap_begin_recv
// file ../../../gsoap/stdsoap2.h line 3005
signed int soap_begin_recv(struct soap *soap)
{
  signed int c;
  soap->error = 0;
  soap->recverror = 0;
  soap_free_temp(soap);
  soap_set_local_namespaces(soap);
  soap->version = (signed short int)0;
  soap_free_iht(soap);
  if((0x00000003 & soap->imode) == 0x00000003)
    soap->omode = soap->omode | 0x00000003;

  soap->imode = soap->imode & ~(0x00000003 | 0x00000100);
  soap->mode = soap->imode;
  if(soap->keep_alive == 0)
  {
    soap->buflen = (unsigned long int)0;
    soap->bufidx = (unsigned long int)0;
  }

  if((0x00000010 & soap->mode) == 0)
    soap->keep_alive = (signed short int)0;

  soap->shaky = (signed short int)0;
  soap->ahead = 0;
  soap->peeked = (signed short int)0;
  soap->level = (unsigned int)0;
  soap->part = (signed short int)0;
  soap->body = (signed short int)1;
  soap->count = (unsigned long int)0;
  soap->length = (unsigned long int)0;
  soap->cdata = (signed short int)0;
  soap->endpoint[0l] = (char)0;
  soap->action = (char *)(void *)0;
  soap->header = (struct SOAP_ENV__Header *)(void *)0;
  soap->fault = (struct SOAP_ENV__Fault *)(void *)0;
  soap->status = 0;
  soap->fform = (signed int (*)(struct soap *))(void *)0;
  soap->dom = (struct soap_dom_element *)(void *)0;
  soap->dime.chunksize = (unsigned long int)0;
  soap->dime.buflen = (unsigned long int)0;
  soap->dime.list = (struct soap_multipart *)(void *)0;
  soap->dime.first = (struct soap_multipart *)(void *)0;
  soap->dime.last = (struct soap_multipart *)(void *)0;
  soap->mime.list = (struct soap_multipart *)(void *)0;
  soap->mime.first = (struct soap_multipart *)(void *)0;
  soap->mime.last = (struct soap_multipart *)(void *)0;
  soap->mime.boundary = (char *)(void *)0;
  soap->mime.start = (const char *)(void *)0;
  _Bool tmp_if_expr_27;
  signed int return_value_soap_recv_26;
  signed int tmp_if_expr_28;
  _Bool tmp_if_expr_23;
  signed int return_value_soap_recv_22;
  signed int tmp_if_expr_24;
  _Bool tmp_if_expr_19;
  signed int return_value_soap_recv_18;
  signed int tmp_if_expr_20;
  signed int return_value_soap_recv_1;
  unsigned long int tmp_post_3;
  signed int return_value_soap_recv_5;
  unsigned long int tmp_post_7;
  _Bool tmp_if_expr_10;
  signed int return_value_soap_recv_9;
  signed int tmp_if_expr_11;
  _Bool tmp_if_expr_16;
  _Bool tmp_if_expr_14;
  signed int return_value_soap_recv_13;
  signed int tmp_if_expr_15;
  signed int return_value_soap_recv_31;
  _Bool tmp_if_expr_37;
  _Bool tmp_if_expr_35;
  signed int return_value_soap_recv_34;
  signed int tmp_if_expr_36;
  struct soap_multipart *return_value_soap_get_mime_attachment_40;
  if(!(soap->fprepareinitrecv == ((signed int (*)(struct soap *))NULL)))
  {
    soap->error=soap->fprepareinitrecv(soap);
    return soap->error;
  }

  else
  {
    c=soap_getchar(soap);
    while(1 + c >= 1 && !(c >= 33))
      c=soap_getchar(soap);
    _Bool tmp_if_expr_29;
    if(c == 45)
    {
      if(soap->bufidx >= soap->buflen)
      {
        return_value_soap_recv_26=soap_recv(soap);
        tmp_if_expr_27 = return_value_soap_recv_26 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_27 = (_Bool)0;
      if(tmp_if_expr_27)
        tmp_if_expr_28 = -1;

      else
        tmp_if_expr_28 = (signed int)(unsigned char)soap->buf[(signed long int)soap->bufidx];
      tmp_if_expr_29 = tmp_if_expr_28 == 45 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_29 = (_Bool)0;
    if(tmp_if_expr_29)
      soap->mode = soap->mode | 0x00000100;

    else
    {
      _Bool tmp_if_expr_25;
      if((0xFFFC & c) == 12)
      {
        if(soap->bufidx >= soap->buflen)
        {
          return_value_soap_recv_22=soap_recv(soap);
          tmp_if_expr_23 = return_value_soap_recv_22 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_23 = (_Bool)0;
        if(tmp_if_expr_23)
          tmp_if_expr_24 = -1;

        else
          tmp_if_expr_24 = (signed int)(unsigned char)soap->buf[(signed long int)soap->bufidx];
        tmp_if_expr_25 = (tmp_if_expr_24 & 0xFFF0) == 0x20 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_25 = (_Bool)0;
      if(tmp_if_expr_25)
        soap->mode = soap->mode | 0x00000080;

      else
      {
        _Bool tmp_if_expr_21;
        if(c == 0xEF)
        {
          if(soap->bufidx >= soap->buflen)
          {
            return_value_soap_recv_18=soap_recv(soap);
            tmp_if_expr_19 = return_value_soap_recv_18 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_19 = (_Bool)0;
          if(tmp_if_expr_19)
            tmp_if_expr_20 = -1;

          else
            tmp_if_expr_20 = (signed int)(unsigned char)soap->buf[(signed long int)soap->bufidx];
          tmp_if_expr_21 = tmp_if_expr_20 == 0xBB ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_21 = (_Bool)0;
        if(tmp_if_expr_21)
        {
          _Bool tmp_if_expr_2;
          if(soap->bufidx >= soap->buflen)
          {
            return_value_soap_recv_1=soap_recv(soap);
            tmp_if_expr_2 = return_value_soap_recv_1 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_2 = (_Bool)0;
          signed int tmp_if_expr_4;
          if(tmp_if_expr_2)
            tmp_if_expr_4 = -1;

          else
          {
            tmp_post_3 = soap->bufidx;
            soap->bufidx = soap->bufidx + 1ul;
            tmp_if_expr_4 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_3];
          }
          c = tmp_if_expr_4;
          _Bool tmp_if_expr_6;
          if(soap->bufidx >= soap->buflen)
          {
            return_value_soap_recv_5=soap_recv(soap);
            tmp_if_expr_6 = return_value_soap_recv_5 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_6 = (_Bool)0;
          signed int tmp_if_expr_8;
          if(tmp_if_expr_6)
            tmp_if_expr_8 = -1;

          else
          {
            tmp_post_7 = soap->bufidx;
            soap->bufidx = soap->bufidx + 1ul;
            tmp_if_expr_8 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_7];
          }
          c = tmp_if_expr_8;
          if(c == 0xBF)
          {
            soap->mode = soap->mode & ~0x00000020;
            c=soap_getchar(soap);
          }

          else
            c = 0x0F << 12 | 0xBB << 6 | c & 0x3F;
        }

        else
        {
          _Bool tmp_if_expr_12;
          if(c == 0xFE)
          {
            if(soap->bufidx >= soap->buflen)
            {
              return_value_soap_recv_9=soap_recv(soap);
              tmp_if_expr_10 = return_value_soap_recv_9 != 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_10 = (_Bool)0;
            if(tmp_if_expr_10)
              tmp_if_expr_11 = -1;

            else
              tmp_if_expr_11 = (signed int)(unsigned char)soap->buf[(signed long int)soap->bufidx];
            tmp_if_expr_12 = tmp_if_expr_11 == 0xFF ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_12 = (_Bool)0;
          _Bool tmp_if_expr_17;
          if(tmp_if_expr_12)
            tmp_if_expr_17 = (_Bool)1;

          else
          {
            if(c == 0xFF)
            {
              if(soap->bufidx >= soap->buflen)
              {
                return_value_soap_recv_13=soap_recv(soap);
                tmp_if_expr_14 = return_value_soap_recv_13 != 0 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_14 = (_Bool)0;
              if(tmp_if_expr_14)
                tmp_if_expr_15 = -1;

              else
                tmp_if_expr_15 = (signed int)(unsigned char)soap->buf[(signed long int)soap->bufidx];
              tmp_if_expr_16 = tmp_if_expr_15 == 0xFE ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_16 = (_Bool)0;
            tmp_if_expr_17 = tmp_if_expr_16 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_17)
          {
            soap->error = 48;
            return soap->error;
          }

        }
        while(1 + c >= 1 && !(c >= 33))
          c=soap_getchar(soap);
      }
    }
    if(c == -1)
    {
      signed int tmp_if_expr_30;
      if(!(soap->error == 0))
        tmp_if_expr_30 = soap->error;

      else
        tmp_if_expr_30 = -1;
      soap->error = tmp_if_expr_30;
      return soap->error;
    }

    soap->ahead = c;
    if(c >= 65 && !(c >= 91) || c >= 97 && !(c >= 123))
    {
      if((1472 & soap->mode) == 0)
      {
        signed int m = soap->imode;
        soap->mode = soap->mode & ~0x00000003;
        soap->error=soap->fparse(soap);
        if(!(soap->error == 0))
        {
          if(!(soap->error >= 1000))
          {
            soap->keep_alive = (signed short int)0;
            return soap->error;
          }

        }

        if(soap->error == 1000)
        {
          if(!(soap->fform == ((signed int (*)(struct soap *))NULL)))
          {
            soap->error=soap->fform(soap);
            if(soap->error == 0)
              soap->error = 1000;

          }

          return soap->error;
        }

        soap->mode = soap->imode;
        soap->imode = m;
        if((0x00000003 & soap->mode) == 0x00000003)
        {
          soap->chunkbuflen = soap->buflen;
          soap->buflen = soap->bufidx;
          soap->chunksize = (unsigned long int)0;
        }

        if(!(soap->status == 0))
        {
          if(soap->body == 0)
          {
            soap->error = soap->status;
            return soap->error;
          }

        }

        if(!(soap->fpreparerecv == ((signed int (*)(struct soap *, const char *, unsigned long int))NULL)))
        {
          if(!((0x00000003 & soap->mode) == 0x00000003))
          {
            if(!(soap->bufidx >= soap->buflen))
            {
              signed int r;
              r=soap->fpreparerecv(soap, soap->buf + (signed long int)soap->bufidx, soap->buflen - soap->bufidx);
              if(!(r == 0))
              {
                soap->error = r;
                return soap->error;
              }

            }

          }

        }

        _Bool tmp_if_expr_32;
        if(soap->bufidx >= soap->buflen)
        {
          return_value_soap_recv_31=soap_recv(soap);
          tmp_if_expr_32 = return_value_soap_recv_31 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_32 = (_Bool)0;
        signed int tmp_if_expr_33;
        if(tmp_if_expr_32)
          tmp_if_expr_33 = -1;

        else
          tmp_if_expr_33 = (signed int)(unsigned char)soap->buf[(signed long int)soap->bufidx];
        if(tmp_if_expr_33 == -1)
        {
          if(soap->status == 0)
          {
            soap->error = 14;
            return soap->error;
          }

          soap->error = soap->status;
          return soap->error;
        }

        if(!(soap->error == 0))
        {
          if(soap->error == 1001)
          {
            if(!(soap->fform == ((signed int (*)(struct soap *))NULL)))
            {
              soap->error=soap->fform(soap);
              if(soap->error == 0)
                soap->error = 1000;

            }

          }

          return soap->error;
        }

      }

    }

    if(!((0x00000100 & soap->mode) == 0))
    {
      do
      {
        c=soap_getchar(soap);
        if(c == -1)
        {
          signed int tmp_if_expr_38;
          if(!(soap->error == 0))
            tmp_if_expr_38 = soap->error;

          else
            tmp_if_expr_38 = -1;
          soap->error = tmp_if_expr_38;
          return soap->error;
        }

        if(!(c == 45))
          tmp_if_expr_37 = (_Bool)1;

        else
        {
          if(soap->bufidx >= soap->buflen)
          {
            return_value_soap_recv_34=soap_recv(soap);
            tmp_if_expr_35 = return_value_soap_recv_34 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_35 = (_Bool)0;
          if(tmp_if_expr_35)
            tmp_if_expr_36 = -1;

          else
            tmp_if_expr_36 = (signed int)(unsigned char)soap->buf[(signed long int)soap->bufidx];
          tmp_if_expr_37 = tmp_if_expr_36 != 45 ? (_Bool)1 : (_Bool)0;
        }
      }
      while(tmp_if_expr_37);
      soap->ahead = c;
      signed int return_value_soap_getmimehdr_39;
      return_value_soap_getmimehdr_39=soap_getmimehdr(soap);
      if(!(return_value_soap_getmimehdr_39 == 0))
        return soap->error;

      if(!(soap->mime.start == ((const char *)NULL)))
        while(!(soap->mime.last->id == ((const char *)NULL)))
        {
          signed int return_value_soap_match_cid_41;
          return_value_soap_match_cid_41=soap_match_cid(soap, soap->mime.start, soap->mime.last->id);
          if(return_value_soap_match_cid_41 == 0)
            break;

          return_value_soap_get_mime_attachment_40=soap_get_mime_attachment(soap, (void *)0);
          if(return_value_soap_get_mime_attachment_40 == ((struct soap_multipart *)NULL))
            break;

        }

      const char *return_value_soap_get_header_attribute_42;
      return_value_soap_get_header_attribute_42=soap_get_header_attribute(soap, soap->mime.first->type, "application/dime");
      if(!(return_value_soap_get_header_attribute_42 == ((const char *)NULL)))
        soap->mode = soap->mode | 0x00000080;

    }

    if(!((0x00000080 & soap->mode) == 0))
    {
      signed int return_value_soap_getdimehdr_43;
      return_value_soap_getdimehdr_43=soap_getdimehdr(soap);
      if(!(return_value_soap_getdimehdr_43 == 0))
        return soap->error;

      if(!((0x01 & (signed int)soap->dime.flags) == 0))
      {
        soap->dime.chunksize = soap->dime.size;
        if(soap->buflen + -soap->bufidx >= soap->dime.chunksize)
        {
          soap->dime.buflen = soap->buflen;
          soap->buflen = soap->bufidx + soap->dime.chunksize;
        }

        else
          soap->dime.chunksize = soap->dime.chunksize - (soap->buflen - soap->bufidx);
      }

      soap->count = soap->buflen - soap->bufidx;
    }

    return 0;
  }
}

// soap_begin_send
// file ../../../gsoap/stdsoap2.h line 2993
signed int soap_begin_send(struct soap *soap)
{
  soap_free_ns(soap);
  soap->error = 0;
  soap->mode = soap->omode | soap->mode & (0x00000008 | 0x00000080);
  struct soap_blist *return_value_soap_new_block_3;
  if(!((0x00000004 & soap->mode) == 0))
  {
    soap->mode = soap->mode | 0x00000040;
    soap->mode = soap->mode & ~0x00000003;
    if(!(soap->count >= 65537ul))
      goto __CPROVER_DUMP_L1;

    soap->error = 27;
    return soap->error;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if((0x00000003 & soap->mode) == 0x00000000)
    {
      if(!(soap->socket == -1))
      {
        _Bool tmp_if_expr_1;
        if(!(soap->count == 0ul))
          tmp_if_expr_1 = (_Bool)1;

        else
          tmp_if_expr_1 = (soap->mode & 0x00000008) != 0 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr_2;
        if(tmp_if_expr_1)
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = (soap->mode & 0x00000040) != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
          soap->mode = soap->mode | 0x00000001;

        else
          soap->mode = soap->mode | 0x00000002;
      }

      else
        if(!(soap->os == ((const char **)NULL)))
        {
          *soap->os = (const char *)(void *)0;
          soap->mode = soap->mode | 0x00000002;
        }

    }

    soap->mode = soap->mode & ~0x00000008;
    if((0x00000003 & soap->mode) == 0x00000002)
    {
      return_value_soap_new_block_3=soap_new_block(soap);
      if(return_value_soap_new_block_3 == ((struct soap_blist *)NULL))
        return soap->error;

    }

    if((0x00000010 & soap->mode) == 0)
      soap->keep_alive = (signed short int)0;

    _Bool tmp_if_expr_4;
    if(!((0x00000200 & soap->mode) == 0))
      tmp_if_expr_4 = (soap->mode & 0x00000080) != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
    {
      soap->mode = soap->mode | 0x00000100;
      soap->mode = soap->mode & ~0x00000080;
    }

    else
      if((0x00000100 & soap->mode) == 0)
        soap->mode = soap->mode & ~0x00000200;

    if(!((0x00000100 & soap->mode) == 0))
      soap_select_mime_boundary(soap);

    if(!((0x00000003 & soap->mode) == 0))
    {
      soap->bufidx = (unsigned long int)0;
      soap->buflen = (unsigned long int)0;
    }

    soap->chunksize = (unsigned long int)0;
    soap->ns = (signed short int)0;
    soap->null = (signed short int)0;
    soap->position = 0;
    soap->mustUnderstand = (signed short int)0;
    soap->encoding = (signed short int)0;
    soap->idnum = 0;
    soap->body = (signed short int)1;
    soap->level = (unsigned int)0;
    soap_clr_attr(soap);
    soap_set_local_namespaces(soap);
    soap->part = (signed short int)0;
    if(!(soap->fprepareinitsend == ((signed int (*)(struct soap *))NULL)))
    {
      if(!((0x00000003 & soap->mode) == 0x00000002))
        goto __CPROVER_DUMP_L19;

      soap->error=soap->fprepareinitsend(soap);
      return soap->error;
    }

    else
    {

    __CPROVER_DUMP_L19:
      ;
      return 0;
    }
  }
}

// soap_begin_serve
// file stdsoap2.c line 16443
signed int soap_begin_serve(struct soap *soap)
{
  soap_begin(soap);
  signed int return_value_soap_begin_recv_3;
  return_value_soap_begin_recv_3=soap_begin_recv(soap);
  _Bool tmp_if_expr_5;
  signed int return_value_soap_envelope_begin_in_4;
  if(!(return_value_soap_begin_recv_3 == 0))
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_soap_envelope_begin_in_4=soap_envelope_begin_in(soap);
    tmp_if_expr_5 = return_value_soap_envelope_begin_in_4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_7;
  signed int return_value_soap_recv_header_6;
  if(tmp_if_expr_5)
    tmp_if_expr_7 = (_Bool)1;

  else
  {
    return_value_soap_recv_header_6=soap_recv_header(soap);
    tmp_if_expr_7 = return_value_soap_recv_header_6 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_9;
  signed int return_value_soap_body_begin_in_8;
  if(tmp_if_expr_7)
    tmp_if_expr_9 = (_Bool)1;

  else
  {
    return_value_soap_body_begin_in_8=soap_body_begin_in(soap);
    tmp_if_expr_9 = return_value_soap_body_begin_in_8 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_9)
  {
    if(!(soap->error >= 1000))
    {
      signed int return_value_soap_send_fault_1;
      return_value_soap_send_fault_1=soap_send_fault(soap);
      return return_value_soap_send_fault_1;
    }

    signed int return_value_soap_closesock_2;
    return_value_soap_closesock_2=soap_closesock(soap);
    return return_value_soap_closesock_2;
  }

  return 0;
}

// soap_begin_shaky
// file stdsoap2.c line 8588
signed short int soap_begin_shaky(struct soap *soap)
{
  signed short int f = soap->shaky;
  soap->shaky = (signed short int)1;
  return f;
}

// soap_bind
// file ../../../gsoap/stdsoap2.h line 2909
signed int soap_bind(struct soap *soap, const char *host, signed int port, signed int backlog)
{
  struct addrinfo *addrinfo = (struct addrinfo *)(void *)0;
  struct addrinfo hints;
  struct addrinfo res;
  signed int err;
  signed int unset = 0;
  signed int len = (signed int)sizeof(char [65536l]) /*65536ul*/ ;
  signed int set = 1;
  if(!(soap->master == -1))
  {
    soap->fclosesocket(soap, soap->master);
    soap->master = (signed int)-1;
  }

  soap->socket = (signed int)-1;
  soap->errmode = 1;
  signed int return_value_tcp_init_2;
  return_value_tcp_init_2=tcp_init(soap);
  if(!(return_value_tcp_init_2 == 0))
  {
    const char *return_value_tcp_error_1;
    return_value_tcp_error_1=tcp_error(soap);
    soap_set_receiver_error(soap, return_value_tcp_error_1, "TCP init failed in soap_bind()", 28);
    return (signed int)-1;
  }

  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_family = 0;
  if(!((0x00000004 & soap->omode) == 0))
    hints.ai_socktype = 2;

  else
    hints.ai_socktype = 1;
  hints.ai_flags = 0x0001;
  soap->errmode = 2;
  const char *return_value_soap_int2s_3;
  return_value_soap_int2s_3=soap_int2s(soap, port);
  err=getaddrinfo(host, return_value_soap_int2s_3, &hints, &addrinfo);
  if(addrinfo == ((struct addrinfo *)NULL) || !(err == 0))
  {
    const char *return_value_gai_strerror_4;
    return_value_gai_strerror_4=gai_strerror(err);
    soap_set_receiver_error(soap, return_value_gai_strerror_4, "getaddrinfo failed in soap_bind()", 28);
    return (signed int)-1;
  }

  res = *addrinfo;
  signed int tmp_if_expr_6;
  void *return_value_memcpy_5;
  if(!((unsigned long int)addrinfo->ai_addrlen >= 129ul))
  {
    return_value_memcpy_5=memcpy((void *)&soap->peer.storage, (const void *)addrinfo->ai_addr, (unsigned long int)addrinfo->ai_addrlen);
    tmp_if_expr_6 = (signed int)!(return_value_memcpy_5 != NULL);
  }

  else
    tmp_if_expr_6 = 34;
  signed int return_value_setsockopt_12;
  signed int return_value_setsockopt_15;
  signed int return_value_setsockopt_24;
  signed int return_value_setsockopt_27;
  signed int return_value_setsockopt_30;
  signed int return_value_listen_36;
  if(!(tmp_if_expr_6 == 0))
  {
    soap->error = 20;
    return (signed int)-1;
  }

  else
  {
    soap->peerlen = (unsigned long int)addrinfo->ai_addrlen;
    res.ai_addr = &soap->peer.addr;
    res.ai_addrlen = (unsigned int)soap->peerlen;
    freeaddrinfo(addrinfo);
    signed int return_value_socket_7;
    return_value_socket_7=socket(res.ai_family, res.ai_socktype, res.ai_protocol);
    soap->master = (signed int)return_value_socket_7;
    soap->errmode = 0;
    if(soap->master == -1)
    {
      signed int *return_value___errno_location_8;
      return_value___errno_location_8=__errno_location();
      soap->errnum = *return_value___errno_location_8;
      const char *return_value_tcp_error_9;
      return_value_tcp_error_9=tcp_error(soap);
      soap_set_receiver_error(soap, return_value_tcp_error_9, "socket failed in soap_bind()", 28);
      return (signed int)-1;
    }

    soap->port = port;
    if(!((0x00000004 & soap->omode) == 0))
      soap->socket = soap->master;

    if(!(soap->bind_flags == 0))
    {
      return_value_setsockopt_12=setsockopt(soap->master, 1, soap->bind_flags, (const void *)(char *)&set, (unsigned int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_setsockopt_12 == 0))
      {
        signed int *return_value___errno_location_10;
        return_value___errno_location_10=__errno_location();
        soap->errnum = *return_value___errno_location_10;
        const char *return_value_tcp_error_11;
        return_value_tcp_error_11=tcp_error(soap);
        soap_set_receiver_error(soap, return_value_tcp_error_11, "setsockopt failed in soap_bind()", 28);
        return (signed int)-1;
      }

    }

    if(!(((soap->imode | soap->omode) & 0x00000010) == 0))
    {
      if(((soap->imode | soap->omode) & 0x00000004) == 0)
      {
        return_value_setsockopt_15=setsockopt(soap->master, 1, 9, (const void *)(char *)&set, (unsigned int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_setsockopt_15 == 0))
        {
          signed int *return_value___errno_location_13;
          return_value___errno_location_13=__errno_location();
          soap->errnum = *return_value___errno_location_13;
          const char *return_value_tcp_error_14;
          return_value_tcp_error_14=tcp_error(soap);
          soap_set_receiver_error(soap, return_value_tcp_error_14, "setsockopt SO_KEEPALIVE failed in soap_bind()", 28);
          return (signed int)-1;
        }

      }

    }

    signed int return_value_setsockopt_18;
    return_value_setsockopt_18=setsockopt(soap->master, 1, 7, (const void *)(char *)&len, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_setsockopt_18 == 0))
    {
      signed int *return_value___errno_location_16;
      return_value___errno_location_16=__errno_location();
      soap->errnum = *return_value___errno_location_16;
      const char *return_value_tcp_error_17;
      return_value_tcp_error_17=tcp_error(soap);
      soap_set_receiver_error(soap, return_value_tcp_error_17, "setsockopt SO_SNDBUF failed in soap_bind()", 28);
      return (signed int)-1;
    }

    signed int return_value_setsockopt_21;
    return_value_setsockopt_21=setsockopt(soap->master, 1, 8, (const void *)(char *)&len, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_setsockopt_21 == 0))
    {
      signed int *return_value___errno_location_19;
      return_value___errno_location_19=__errno_location();
      soap->errnum = *return_value___errno_location_19;
      const char *return_value_tcp_error_20;
      return_value_tcp_error_20=tcp_error(soap);
      soap_set_receiver_error(soap, return_value_tcp_error_20, "setsockopt SO_RCVBUF failed in soap_bind()", 28);
      return (signed int)-1;
    }

    if((0x00000004 & soap->omode) == 0)
    {
      return_value_setsockopt_24=setsockopt(soap->master, 6, 1, (const void *)(char *)&set, (unsigned int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_setsockopt_24 == 0))
      {
        signed int *return_value___errno_location_22;
        return_value___errno_location_22=__errno_location();
        soap->errnum = *return_value___errno_location_22;
        const char *return_value_tcp_error_23;
        return_value_tcp_error_23=tcp_error(soap);
        soap_set_receiver_error(soap, return_value_tcp_error_23, "setsockopt TCP_NODELAY failed in soap_bind()", 28);
        return (signed int)-1;
      }

    }

    if((0x00000004 & soap->omode) == 0)
    {
      return_value_setsockopt_27=setsockopt(soap->master, 6, 23, (const void *)(char *)&set, (unsigned int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_setsockopt_27 == 0))
      {
        signed int *return_value___errno_location_25;
        return_value___errno_location_25=__errno_location();
        soap->errnum = *return_value___errno_location_25;
        const char *return_value_tcp_error_26;
        return_value_tcp_error_26=tcp_error(soap);
        soap_set_receiver_error(soap, return_value_tcp_error_26, "setsockopt TCP_FASTOPEN failed in soap_bind()", 28);
        return (signed int)-1;
      }

    }

    if(res.ai_family == 10)
    {
      return_value_setsockopt_30=setsockopt(soap->master, 41, 26, (const void *)(char *)&unset, (unsigned int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_setsockopt_30 == 0))
      {
        signed int *return_value___errno_location_28;
        return_value___errno_location_28=__errno_location();
        soap->errnum = *return_value___errno_location_28;
        const char *return_value_tcp_error_29;
        return_value_tcp_error_29=tcp_error(soap);
        soap_set_receiver_error(soap, return_value_tcp_error_29, "setsockopt unset IPV6_V6ONLY failed in soap_bind()", 28);
        return (signed int)-1;
      }

    }

    soap->errmode = 0;
    signed int return_value_bind_33;
    return_value_bind_33=bind(soap->master, res.ai_addr, (unsigned int)(signed int)res.ai_addrlen);
    if(!(return_value_bind_33 == 0))
    {
      signed int *return_value___errno_location_31;
      return_value___errno_location_31=__errno_location();
      soap->errnum = *return_value___errno_location_31;
      soap_closesock(soap);
      const char *return_value_tcp_error_32;
      return_value_tcp_error_32=tcp_error(soap);
      soap_set_receiver_error(soap, return_value_tcp_error_32, "bind failed in soap_bind()", 28);
      return (signed int)-1;
    }

    if((0x00000004 & soap->omode) == 0)
    {
      return_value_listen_36=listen(soap->master, backlog);
      if(!(return_value_listen_36 == 0))
      {
        signed int *return_value___errno_location_34;
        return_value___errno_location_34=__errno_location();
        soap->errnum = *return_value___errno_location_34;
        soap_closesock(soap);
        const char *return_value_tcp_error_35;
        return_value_tcp_error_35=tcp_error(soap);
        soap_set_receiver_error(soap, return_value_tcp_error_35, "listen failed in soap_bind()", 28);
        return (signed int)-1;
      }

    }

    return soap->master;
  }
}

// soap_block_size
// file ../../../gsoap/stdsoap2.h line 3130
unsigned long int soap_block_size(struct soap *soap, struct soap_blist *b)
{
  if(b == ((struct soap_blist *)NULL))
    b = soap->blist;

  return b->head->size;
}

// soap_body_begin_in
// file stdsoap2.c line 16998
signed int soap_body_begin_in(struct soap *soap)
{
  if((signed int)soap->version == 0)
    return 0;

  else
  {
    soap->part = (signed short int)6;
    signed int return_value_soap_element_begin_in_1;
    return_value_soap_element_begin_in_1=soap_element_begin_in(soap, "SOAP-ENV:Body", 0, (const char *)(void *)0);
    if(!(return_value_soap_element_begin_in_1 == 0))
      return soap->error;

    else
    {
      if(soap->body == 0)
        soap->part = (signed short int)5;

      return 0;
    }
  }
}

// soap_body_begin_out
// file stdsoap2.c line 16962
signed int soap_body_begin_out(struct soap *soap)
{
  if((signed int)soap->version == 1)
    soap->encoding = (signed short int)1;

  signed int return_value_soap_set_attr_1;
  if(!((0x80000000 & (unsigned int)soap->mode) == 0u))
  {
    return_value_soap_set_attr_1=soap_set_attr(soap, "wsu:Id", "Body", 1);
    if(!(return_value_soap_set_attr_1 == 0))
      return soap->error;

  }

  if((signed int)soap->version == 0)
    return 0;

  else
  {
    soap->part = (signed short int)6;
    signed int return_value_soap_element_begin_out_2;
    return_value_soap_element_begin_out_2=soap_element_begin_out(soap, "SOAP-ENV:Body", 0, (const char *)(void *)0);
    return return_value_soap_element_begin_out_2;
  }
}

// soap_body_end_in
// file stdsoap2.c line 17016
signed int soap_body_end_in(struct soap *soap)
{
  if((signed int)soap->version == 0)
    return 0;

  else
    if((signed int)soap->part == 5)
    {
      soap->error = 0;
      return soap->error;
    }

    else
    {
      soap->part = (signed short int)7;
      signed int return_value_soap_element_end_in_1;
      return_value_soap_element_end_in_1=soap_element_end_in(soap, "SOAP-ENV:Body");
      return return_value_soap_element_end_in_1;
    }
}

// soap_body_end_out
// file stdsoap2.c line 16982
signed int soap_body_end_out(struct soap *soap)
{
  if((signed int)soap->version == 0)
    return 0;

  else
  {
    signed int return_value_soap_element_end_out_1;
    return_value_soap_element_end_out_1=soap_element_end_out(soap, "SOAP-ENV:Body");
    if(!(return_value_soap_element_end_out_1 == 0))
      return soap->error;

    else
    {
      soap->part = (signed short int)7;
      return 0;
    }
  }
}

// soap_byte2s
// file stdsoap2.c line 13207
const char * soap_byte2s(struct soap *soap, char n)
{
  const char *return_value_soap_long2s_1;
  return_value_soap_long2s_1=soap_long2s(soap, (signed long int)n);
  return return_value_soap_long2s_1;
}

// soap_char
// file stdsoap2.c line 1544
static signed int soap_char(struct soap *soap)
{
  char tmp[8l];
  signed int i;
  signed int c;
  char *s = tmp;
  i = 0;
  signed int return_value_soap_recv_1;
  unsigned long int tmp_post_3;
  for( ; !(i >= 7); i = i + 1)
  {
    _Bool tmp_if_expr_2;
    if(soap->bufidx >= soap->buflen)
    {
      return_value_soap_recv_1=soap_recv(soap);
      tmp_if_expr_2 = return_value_soap_recv_1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
    signed int tmp_if_expr_4;
    if(tmp_if_expr_2)
      tmp_if_expr_4 = -1;

    else
    {
      tmp_post_3 = soap->bufidx;
      soap->bufidx = soap->bufidx + 1ul;
      tmp_if_expr_4 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_3];
    }
    c = tmp_if_expr_4;
    if(c == 59 || c == -1)
      break;

    char *tmp_post_5 = s;
    s = s + 1l;
    *tmp_post_5 = (char)c;
  }
  *s = (char)0;
  signed long int return_value_strtol_6;
  if((signed int)tmp[0l] == 35)
  {
    _Bool tmp_if_expr_7;
    if((signed int)tmp[1l] == 120)
      tmp_if_expr_7 = (_Bool)1;

    else
      tmp_if_expr_7 = (signed int)tmp[(signed long int)1] == 88 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_7)
    {
      return_value_strtol_6=strtol(tmp + (signed long int)2, (char ** restrict )(void *)0, 16);
      return (signed int)return_value_strtol_6;
    }

    signed long int return_value_strtol_8;
    return_value_strtol_8=strtol(tmp + (signed long int)1, (char ** restrict )(void *)0, 10);
    return (signed int)return_value_strtol_8;
  }

  signed int return_value_strcmp_9;
  return_value_strcmp_9=strcmp(tmp, "lt");
  if(return_value_strcmp_9 == 0)
    return 60;

  else
  {
    signed int return_value_strcmp_10;
    return_value_strcmp_10=strcmp(tmp, "gt");
    if(return_value_strcmp_10 == 0)
      return 62;

    else
    {
      signed int return_value_strcmp_11;
      return_value_strcmp_11=strcmp(tmp, "amp");
      if(return_value_strcmp_11 == 0)
        return 38;

      else
      {
        signed int return_value_strcmp_12;
        return_value_strcmp_12=strcmp(tmp, "quot");
        if(return_value_strcmp_12 == 0)
          return 34;

        else
        {
          signed int return_value_strcmp_13;
          return_value_strcmp_13=strcmp(tmp, "apos");
          if(return_value_strcmp_13 == 0)
            return 39;

          else
          {
            signed long int return_value_soap_code_int_14;
            return_value_soap_code_int_14=soap_code_int(html_entity_codes, tmp, (signed long int)0x7F);
            return (signed int)return_value_soap_code_int_14;
          }
        }
      }
    }
  }
}

// soap_check_and_mark
// file stdsoap2.c line 10964
signed int soap_check_and_mark(struct soap *soap, const void *p, signed int t, char **mark)
{
  signed int return_value_soap_pointer_enter_1;
  if(!(mark == ((char **)NULL)))
  {
    struct soap_plist *pp;
    signed int return_value_soap_pointer_lookup_2;
    return_value_soap_pointer_lookup_2=soap_pointer_lookup(soap, p, t, &pp);
    if(return_value_soap_pointer_lookup_2 == 0)
    {
      return_value_soap_pointer_enter_1=soap_pointer_enter(soap, p, (void *)0, 0, t, &pp);
      if(return_value_soap_pointer_enter_1 == 0)
        return -1;

    }

    if(!((0x00000008 & soap->mode) == 0))
    {
      if((signed int)pp->mark1 >= 1)
        return -1;

      pp->mark1 = (char)1;
      *mark = &pp->mark1;
    }

    else
    {
      if((signed int)pp->mark2 >= 1)
        return -1;

      pp->mark2 = (char)1;
      *mark = &pp->mark2;
    }
  }

  return 0;
}

// soap_check_faultdetail
// file soapC.c line 156
const char * soap_check_faultdetail(struct soap *soap)
{
  soap_fault(soap);
  if((signed int)soap->version == 2)
  {
    if(soap->fault->SOAP_ENV__Detail == ((struct SOAP_ENV__Detail *)NULL))
      goto __CPROVER_DUMP_L1;

    return soap->fault->SOAP_ENV__Detail->__any;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(soap->fault->detail == ((struct SOAP_ENV__Detail *)NULL)))
      return soap->fault->detail->__any;

    else
      return (const char *)(void *)0;
  }
}

// soap_check_faultsubcode
// file soapC.c line 120
const char * soap_check_faultsubcode(struct soap *soap)
{
  soap_fault(soap);
  if((signed int)soap->version == 2)
  {
    if(!(soap->fault->SOAP_ENV__Code == ((struct SOAP_ENV__Code *)NULL)))
    {
      if(!(soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == ((struct SOAP_ENV__Code *)NULL)))
        return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;

    }

    return (const char *)(void *)0;
  }

  else
    return soap->fault->faultcode;
}

// soap_check_mime_attachments
// file stdsoap2.c line 15896
signed int soap_check_mime_attachments(struct soap *soap)
{
  struct soap_multipart *return_value_soap_get_mime_attachment_1;
  if(!((0x40000000 & soap->mode) == 0))
  {
    return_value_soap_get_mime_attachment_1=soap_get_mime_attachment(soap, (void *)0);
    return (signed int)(return_value_soap_get_mime_attachment_1 != (struct soap_multipart *)(void *)0);
  }

  return 0;
}

// soap_check_result
// file stdsoap2.c line 11083
void soap_check_result(struct soap *soap, const char *tag)
{
  (void)tag;
  if((signed int)soap->version == 2)
  {
    if(!(soap->encodingStyle == ((const char *)NULL)))
      soap_instring(soap, ":result", (char **)(void *)0, (const char *)(void *)0, 0, 2, (signed long int)-1, (signed long int)-1, (const char *)(void *)0);

  }

}

// soap_cleanup
// file stdsoap2.c line 5684
void soap_cleanup(struct soap *soap)
{
  soap_done(soap);
}

// soap_closesock
// file ../../../gsoap/stdsoap2.h line 3038
signed int soap_closesock(struct soap *soap)
{
  signed int status = soap->error;
  if(!(status == 0))
  {
    soap->mime.first = (struct soap_multipart *)(void *)0;
    soap->mime.last = (struct soap_multipart *)(void *)0;
    soap->dime.first = (struct soap_multipart *)(void *)0;
    soap->dime.last = (struct soap_multipart *)(void *)0;
  }

  if(!(soap->fdisconnect == ((signed int (*)(struct soap *))NULL)))
  {
    soap->error=soap->fdisconnect(soap);
    return soap->error;
  }

  else
  {
    _Bool tmp_if_expr_1;
    if(status == 28 || status == 30 || status == -1)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = !(soap->keep_alive != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      if(!(soap->fclose == ((signed int (*)(struct soap *))NULL)))
      {
        soap->error=soap->fclose(soap);
        if(!(soap->error == 0))
          return soap->error;

      }

      soap->keep_alive = (signed short int)0;
    }

    soap->error = status;
    return soap->error;
  }
}

// soap_clr_attr
// file stdsoap2.c line 11395
void soap_clr_attr(struct soap *soap)
{
  struct soap_attribute *tp;
  if(!((0x00010000 & soap->mode) == 0))
    for( ; !(soap->attributes == ((struct soap_attribute *)NULL)); soap->attributes = tp)
    {
      tp = soap->attributes->next;
      if(!(soap->attributes->value == ((char *)NULL)))
        free((void *)soap->attributes->value);

      free((void *)soap->attributes);
    }

  else
  {
    tp = soap->attributes;
    for( ; !(tp == ((struct soap_attribute *)NULL)); tp = tp->next)
      tp->visible = (signed short int)0;
  }
}

// soap_clr_dime
// file stdsoap2.c line 16223
void soap_clr_dime(struct soap *soap)
{
  soap->omode = soap->omode & ~0x00000080;
  soap->dime.first = (struct soap_multipart *)(void *)0;
  soap->dime.last = (struct soap_multipart *)(void *)0;
}

// soap_clr_mime
// file stdsoap2.c line 16238
void soap_clr_mime(struct soap *soap)
{
  soap->omode = soap->omode & ~0x00000100;
  soap->mime.first = (struct soap_multipart *)(void *)0;
  soap->mime.last = (struct soap_multipart *)(void *)0;
  soap->mime.boundary = (char *)(void *)0;
  soap->mime.start = (const char *)(void *)0;
}

// soap_code
// file stdsoap2.c line 1439
struct soap_code_map * soap_code(struct soap_code_map *code_map, const char *str)
{
  if(!(str == ((const char *)NULL)) && !(code_map == ((struct soap_code_map *)NULL)))
    while(!(code_map->string == ((const char *)NULL)))
    {
      signed int return_value_strcmp_1;
      return_value_strcmp_1=strcmp(str, code_map->string);
      if(return_value_strcmp_1 == 0)
        return code_map;

      code_map = code_map + 1l;
    }

  return (struct soap_code_map *)(void *)0;
}

// soap_code_bits
// file stdsoap2.c line 1490
signed long int soap_code_bits(struct soap_code_map *code_map, const char *str)
{
  signed long int bits = (signed long int)0;
  if(!(code_map == ((struct soap_code_map *)NULL)))
    while(!(str == ((const char *)NULL)))
    {
      if(*str == 0)
        break;

      struct soap_code_map *p = code_map;
      for( ; !(p->string == ((const char *)NULL)); p = p + 1l)
      {
        unsigned long int n;
        n=strlen(p->string);
        signed int return_value_strncmp_1;
        return_value_strncmp_1=strncmp(p->string, str, n);
        if(return_value_strncmp_1 == 0)
        {
          if(1 + (signed int)str[(signed long int)n] >= 1)
          {
            if(!((signed int)str[(signed long int)n] >= 33))
            {
              bits = bits | p->code;
              str = str + (signed long int)n;
              for( ; (signed int)*str >= 1; str = str + 1l)
                if((signed int)*str >= 33)
                  break;

              break;
            }

          }

        }

      }
      if(p->string == ((const char *)NULL))
        return (signed long int)0;

    }

  return bits;
}

// soap_code_int
// file stdsoap2.c line 1457
signed long int soap_code_int(struct soap_code_map *code_map, const char *str, signed long int other)
{
  if(!(code_map == ((struct soap_code_map *)NULL)))
    while(!(code_map->string == ((const char *)NULL)))
    {
      signed int return_value_soap_tag_cmp_1;
      return_value_soap_tag_cmp_1=soap_tag_cmp(str, code_map->string);
      if(return_value_soap_tag_cmp_1 == 0)
        return code_map->code;

      code_map = code_map + 1l;
    }

  return other;
}

// soap_code_list
// file stdsoap2.c line 1519
const char * soap_code_list(struct soap *soap, struct soap_code_map *code_map, signed long int code)
{
  char *t = soap->tmpbuf;
  if(!(code_map == ((struct soap_code_map *)NULL)))
    for( ; !(code_map->string == ((const char *)NULL)); code_map = code_map + 1l)
      if(!((code_map->code & code) == 0l))
      {
        const char *s = code_map->string;
        if(!(t == soap->tmpbuf))
        {
          char *tmp_post_1 = t;
          t = t + 1l;
          *tmp_post_1 = (char)32;
        }

        while(!(*s == 0))
        {
          if(t >= soap->tmpbuf + 1023l)
            break;

          char *tmp_post_2 = t;
          t = t + 1l;
          const char *tmp_post_3 = s;
          s = s + 1l;
          *tmp_post_2 = *tmp_post_3;
        }
        if(t == soap->tmpbuf + 1023l)
          break;

      }


  *t = (char)0;
  return soap->tmpbuf;
}

// soap_code_str
// file stdsoap2.c line 1475
const char * soap_code_str(struct soap_code_map *code_map, signed long int code)
{
  if(code_map == ((struct soap_code_map *)NULL))
    return (const char *)(void *)0;

  else
  {
    for( ; !(code_map->code == code); code_map = code_map + 1l)
      if(code_map->string == ((const char *)NULL))
        break;

    return code_map->string;
  }
}

// soap_connect
// file stdsoap2.c line 17114
signed int soap_connect(struct soap *soap, const char *endpoint, const char *action)
{
  signed int return_value_soap_connect_command_1;
  return_value_soap_connect_command_1=soap_connect_command(soap, 2000, endpoint, action);
  return return_value_soap_connect_command_1;
}

// soap_connect_command
// file stdsoap2.c line 17125
signed int soap_connect_command(struct soap *soap, signed int http_command, const char *endpoints, const char *action)
{
  signed int tmp_if_expr_2;
  unsigned long int return_value_strlen_4;
  if(!(endpoints == ((const char *)NULL)))
  {
    const char *s;
    s=strchr(endpoints, 32);
    if(!(s == ((const char *)NULL)))
    {
      unsigned long int l;
      l=strlen(endpoints);
      char *endpoint;
      void *return_value_malloc_1;
      return_value_malloc_1=malloc(l + (unsigned long int)1);
      endpoint = (char *)return_value_malloc_1;
      while((_Bool)1)
      {
        if(!(endpoint == ((char *)NULL)))
        {
          if(!((unsigned long int)(s - endpoints) >= 1ul + l))
          {
            strncpy(endpoint, endpoints, (unsigned long int)(s - endpoints));
            endpoint[(signed long int)(unsigned long int)(s - endpoints)] = (char)0;
            tmp_if_expr_2 = (signed int)endpoint[(signed long int)(unsigned long int)(s - endpoints)];
          }

          else
          {
            endpoint[(signed long int)0] = (char)0;
            tmp_if_expr_2 = (signed int)endpoint[(signed long int)0];
          }
          if(!(tmp_if_expr_2 == 0))
            (_Bool)1;

          else
            (_Bool)0;
        }

        else
          (_Bool)0;
        endpoint[s - endpoints] = (char)0;
        signed int return_value_soap_try_connect_command_3;
        return_value_soap_try_connect_command_3=soap_try_connect_command(soap, http_command, endpoint, action);
        if(!(return_value_soap_try_connect_command_3 == 28))
          break;

        if(*s == 0)
          break;

        soap->error = 0;
        for( ; (signed int)*s == 32; s = s + 1l)
          ;
        endpoints = s;
        s=strchr(endpoints, 32);
        if(s == ((const char *)NULL))
        {
          return_value_strlen_4=strlen(endpoints);
          s = endpoints + (signed long int)return_value_strlen_4;
        }

      }
      free((void *)endpoint);
    }

    else
      soap_try_connect_command(soap, http_command, endpoints, action);
  }

  return soap->error;
}

// soap_copy
// file ../../../gsoap/stdsoap2.h line 3043
struct soap * soap_copy(struct soap *soap)
{
  struct soap *copy;
  copy=soap_new_REQUIRE_lib_v20828(0x00000000, 0x00000000);
  struct soap *return_value_soap_copy_context_1;
  return_value_soap_copy_context_1=soap_copy_context(copy, soap);
  if(!(return_value_soap_copy_context_1 == ((struct soap *)NULL)))
    return copy;

  else
  {
    soap_free(copy);
    return (struct soap *)(void *)0;
  }
}

// soap_copy_context
// file stdsoap2.c line 9370
struct soap * soap_copy_context(struct soap *copy, struct soap *soap)
{
  _Bool tmp_if_expr_1;
  void *return_value_memcpy_3;
  if(copy == soap)
    return copy;

  else
  {
    _Bool tmp_if_expr_2;
    if(soap == ((struct soap *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      if(!((signed int)soap->state == 1))
        tmp_if_expr_1 = (signed int)soap->state != 2 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
      return (struct soap *)(void *)0;

    else
    {
      if(!(copy == ((struct soap *)NULL)))
      {
        struct soap_plugin *p = (struct soap_plugin *)(void *)0;
        if(!(copy == ((struct soap *)NULL)))
        {
          return_value_memcpy_3=memcpy((void *)copy, (const void *)soap, sizeof(struct soap) /*162088ul*/ );
          (signed int)!(return_value_memcpy_3 != NULL);
        }

        else
          34;
        copy->state = (signed short int)2;
        copy->error = 0;
        copy->userid = (const char *)(void *)0;
        copy->passwd = (const char *)(void *)0;
        copy->nlist = (struct soap_nlist *)(void *)0;
        copy->blist = (struct soap_blist *)(void *)0;
        copy->clist = (struct soap_clist *)(void *)0;
        copy->alist = (void *)0;
        copy->attributes = (struct soap_attribute *)(void *)0;
        copy->labbuf = (char *)(void *)0;
        copy->lablen = (unsigned long int)0;
        copy->labidx = (unsigned long int)0;
        soap_init_logs(copy);
        copy->namespaces = soap->local_namespaces;
        copy->local_namespaces = (struct Namespace *)(void *)0;
        soap_set_local_namespaces(copy);
        copy->namespaces = soap->namespaces;
        copy->c_locale = (void *)0;
        soap_init_iht(copy);
        soap_init_pht(copy);
        copy->header = (struct SOAP_ENV__Header *)(void *)0;
        copy->fault = (struct SOAP_ENV__Fault *)(void *)0;
        copy->action = (char *)(void *)0;
        copy->cookies = (struct soap_cookie *)(void *)0;
        copy->plugins = (struct soap_plugin *)(void *)0;
        p = soap->plugins;
        for( ; !(p == ((struct soap_plugin *)NULL)); p = p->next)
        {
          struct soap_plugin *q;
          void *return_value_malloc_4;
          return_value_malloc_4=malloc(sizeof(struct soap_plugin) /*40ul*/ );
          q = (struct soap_plugin *)return_value_malloc_4;
          if(q == ((struct soap_plugin *)NULL))
          {
            soap_end(copy);
            soap_done(copy);
            return (struct soap *)(void *)0;
          }

          *q = *p;
          if(!(p->fcopy == ((signed int (*)(struct soap *, struct soap_plugin *, struct soap_plugin *))NULL)))
          {
            copy->error=p->fcopy(copy, q, p);
            if(!(copy->error == 0))
            {
              free((void *)q);
              soap_end(copy);
              soap_done(copy);
              return (struct soap *)(void *)0;
            }

          }

          q->next = copy->plugins;
          copy->plugins = q;
        }
      }

      return copy;
    }
  }
}

// soap_copy_fault
// file stdsoap2.c line 18151
static signed int soap_copy_fault(struct soap *soap, const char *faultcode, const char *faultsubcodeQName, const char *faultstring, const char *faultdetailXML)
{
  char *r = (char *)(void *)0;
  char *s = (char *)(void *)0;
  char *t = (char *)(void *)0;
  if(!(faultsubcodeQName == ((const char *)NULL)))
    r=soap_strdup(soap, faultsubcodeQName);

  if(!(faultstring == ((const char *)NULL)))
    s=soap_strdup(soap, faultstring);

  if(!(faultdetailXML == ((const char *)NULL)))
    t=soap_strdup(soap, faultdetailXML);

  signed int return_value_soap_set_error_1;
  return_value_soap_set_error_1=soap_set_error(soap, faultcode, r, s, t, 12);
  return return_value_soap_set_error_1;
}

// soap_copy_stream
// file stdsoap2.c line 9468
void soap_copy_stream(struct soap *copy, struct soap *soap)
{
  struct soap_attribute *tp = (struct soap_attribute *)(void *)0;
  struct soap_attribute *tq;
  void *return_value_memcpy_1;
  void *return_value_memcpy_2;
  void *return_value_memcpy_3;
  void *return_value_memcpy_6;
  struct soap_nlist *return_value_soap_push_namespace_7;
  void *return_value_memcpy_8;
  void *return_value_memcpy_9;
  void *return_value_memcpy_10;
  void *return_value_memcpy_11;
  void *return_value_memcpy_14;
  void *return_value_memcpy_16;
  if(!(copy == soap))
  {
    copy->header = soap->header;
    copy->mode = soap->mode;
    copy->imode = soap->imode;
    copy->omode = soap->omode;
    copy->master = soap->master;
    copy->socket = soap->socket;
    copy->sendsk = soap->sendsk;
    copy->recvsk = soap->recvsk;
    copy->recv_timeout = soap->recv_timeout;
    copy->send_timeout = soap->send_timeout;
    copy->os = soap->os;
    copy->is = soap->is;
    copy->sendfd = soap->sendfd;
    copy->recvfd = soap->recvfd;
    copy->bufidx = soap->bufidx;
    copy->buflen = soap->buflen;
    copy->ahead = soap->ahead;
    copy->cdata = soap->cdata;
    copy->chunksize = soap->chunksize;
    copy->chunkbuflen = soap->chunkbuflen;
    copy->keep_alive = soap->keep_alive;
    copy->tcp_keep_alive = soap->tcp_keep_alive;
    copy->tcp_keep_idle = soap->tcp_keep_idle;
    copy->tcp_keep_intvl = soap->tcp_keep_intvl;
    copy->tcp_keep_cnt = soap->tcp_keep_cnt;
    copy->max_keep_alive = soap->max_keep_alive;
    copy->peer = soap->peer;
    copy->peerlen = soap->peerlen;
    copy->ip = soap->ip;
    copy->port = soap->port;
    return_value_memcpy_1=memcpy((void *)copy->host, (const void *)soap->host, sizeof(char [1024l]) /*1024ul*/ );
    (signed int)!(return_value_memcpy_1 != NULL);
    return_value_memcpy_2=memcpy((void *)copy->endpoint, (const void *)soap->endpoint, sizeof(char [1024l]) /*1024ul*/ );
    (signed int)!(return_value_memcpy_2 != NULL);
    return_value_memcpy_3=memcpy((void *)copy->buf, (const void *)soap->buf, sizeof(char [65536l]) /*65536ul*/ );
    (signed int)!(return_value_memcpy_3 != NULL);
    soap_free_ns(copy);
    soap_set_local_namespaces(copy);
    copy->version = soap->version;
    if(!(soap->nlist == ((struct soap_nlist *)NULL)))
    {
      if(!(soap->local_namespaces == ((struct Namespace *)NULL)))
      {
        struct soap_nlist *np = (struct soap_nlist *)(void *)0;
        struct soap_nlist *nq = soap->nlist;
        for( ; !(nq == ((struct soap_nlist *)NULL)); nq = nq->next)
        {
          struct soap_nlist *nr = np;
          unsigned long int soap_copy_stream__1__1__1__1__n;
          unsigned long int return_value_strlen_4;
          return_value_strlen_4=strlen(nq->id);
          soap_copy_stream__1__1__1__1__n = sizeof(struct soap_nlist) /*32ul*/  + return_value_strlen_4;
          void *return_value_malloc_5;
          return_value_malloc_5=malloc(soap_copy_stream__1__1__1__1__n);
          np = (struct soap_nlist *)return_value_malloc_5;
          if(np == ((struct soap_nlist *)NULL))
            break;

          if(!(np == ((struct soap_nlist *)NULL)))
          {
            return_value_memcpy_6=memcpy((void *)np, (const void *)nq, soap_copy_stream__1__1__1__1__n);
            (signed int)!(return_value_memcpy_6 != NULL);
          }

          else
            34;
          np->next = nr;
        }
        while(!(np == ((struct soap_nlist *)NULL)))
        {
          const char *s = np->ns;
          copy->level = np->level;
          if(s == ((const char *)NULL))
          {
            if((signed int)np->index >= 0)
            {
              s = (soap->local_namespaces + (signed long int)np->index)->out;
              if(s == ((const char *)NULL))
                s = (soap->local_namespaces + (signed long int)np->index)->ns;

            }

          }

          if(!(s == ((const char *)NULL)))
          {
            return_value_soap_push_namespace_7=soap_push_namespace(copy, np->id, s);
            if(return_value_soap_push_namespace_7 == ((struct soap_nlist *)NULL))
              break;

          }

          nq = np;
          np = np->next;
          free((void *)nq);
        }
      }

    }

    return_value_memcpy_8=memcpy((void *)copy->tag, (const void *)soap->tag, sizeof(char [1024l]) /*1024ul*/ );
    (signed int)!(return_value_memcpy_8 != NULL);
    return_value_memcpy_9=memcpy((void *)copy->id, (const void *)soap->id, sizeof(char [1024l]) /*1024ul*/ );
    (signed int)!(return_value_memcpy_9 != NULL);
    return_value_memcpy_10=memcpy((void *)copy->href, (const void *)soap->href, sizeof(char [1024l]) /*1024ul*/ );
    (signed int)!(return_value_memcpy_10 != NULL);
    return_value_memcpy_11=memcpy((void *)copy->type, (const void *)soap->type, sizeof(char [1024l]) /*1024ul*/ );
    (signed int)!(return_value_memcpy_11 != NULL);
    copy->other = soap->other;
    copy->root = soap->root;
    copy->null = soap->null;
    copy->body = soap->body;
    copy->part = soap->part;
    copy->mustUnderstand = soap->mustUnderstand;
    copy->level = soap->level;
    copy->peeked = soap->peeked;
    tq = soap->attributes;
    for( ; !(tq == ((struct soap_attribute *)NULL)); tq = tq->next)
    {
      struct soap_attribute *tr = tp;
      unsigned long int n;
      unsigned long int return_value_strlen_12;
      return_value_strlen_12=strlen(tq->name);
      n = sizeof(struct soap_attribute) /*48ul*/  + return_value_strlen_12;
      void *return_value_malloc_13;
      return_value_malloc_13=malloc(n);
      tp = (struct soap_attribute *)return_value_malloc_13;
      if(!(tp == ((struct soap_attribute *)NULL)))
      {
        return_value_memcpy_14=memcpy((void *)tp, (const void *)tq, n);
        (signed int)!(return_value_memcpy_14 != NULL);
      }

      else
        34;
      if(!(tp->size == 0ul))
      {
        void *return_value_malloc_15;
        return_value_malloc_15=malloc(tp->size);
        tp->value = (char *)return_value_malloc_15;
        if(!(tp->value == ((char *)NULL)))
        {
          _Bool tmp_if_expr_17;
          if(!(tp->value == ((char *)NULL)))
            tmp_if_expr_17 = (unsigned long int)tp->size >= (unsigned long int)tp->size ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_17 = (_Bool)0;
          if(tmp_if_expr_17)
          {
            return_value_memcpy_16=memcpy((void *)tp->value, (const void *)tq->value, tp->size);
            (signed int)!(return_value_memcpy_16 != NULL);
          }

          else
            34;
        }

      }

      tp->ns = (const char *)(void *)0;
      tp->next = tr;
    }
    copy->attributes = tp;
  }

}

// soap_count_attachments
// file stdsoap2.c line 15363
static unsigned long int soap_count_attachments(struct soap *soap)
{
  struct soap_multipart *content;
  unsigned long int count = soap->count;
  unsigned long int return_value_strlen_1;
  unsigned long int return_value_strlen_2;
  if(!((0x00000080 & soap->mode) == 0))
  {
    if((0x00000200 & soap->mode) == 0)
    {
      content = soap->dime.first;
      for( ; !(content == ((struct soap_multipart *)NULL)); content = content->next)
      {
        count = count + (unsigned long int)12 + (content->size + (unsigned long int)3 & (unsigned long int)~3);
        if(!(content->id == ((const char *)NULL)))
        {
          return_value_strlen_1=strlen(content->id);
          count = count + (return_value_strlen_1 + (unsigned long int)3 & (unsigned long int)~3);
        }

        if(!(content->type == ((const char *)NULL)))
        {
          return_value_strlen_2=strlen(content->type);
          count = count + (return_value_strlen_2 + (unsigned long int)3 & (unsigned long int)~3);
        }

        if(!(content->options == ((const char *)NULL)))
          count = count + (unsigned long int)(((signed int)(unsigned char)content->options[(signed long int)2] << 8 | (signed int)(unsigned char)content->options[(signed long int)3]) + 7 & ~3);

      }
    }

  }

  unsigned long int return_value_strlen_3;
  unsigned long int return_value_strlen_4;
  unsigned long int return_value_strlen_5;
  unsigned long int return_value_strlen_6;
  unsigned long int return_value_strlen_7;
  if(!((0x00000100 & soap->mode) == 0))
  {
    if(!(soap->mime.boundary == ((char *)NULL)))
    {
      unsigned long int n;
      n=strlen(soap->mime.boundary);
      content = soap->mime.first;
      for( ; !(content == ((struct soap_multipart *)NULL)); content = content->next)
      {
        const char *s;
        count = count + (unsigned long int)6 + n;
        if(!(content->type == ((const char *)NULL)))
        {
          return_value_strlen_3=strlen(content->type);
          count = count + (unsigned long int)16 + return_value_strlen_3;
        }

        s=soap_code_str(mime_codes, (signed long int)content->encoding);
        if(!(s == ((const char *)NULL)))
        {
          return_value_strlen_4=strlen(s);
          count = count + (unsigned long int)29 + return_value_strlen_4;
        }

        if(!(content->id == ((const char *)NULL)))
        {
          return_value_strlen_5=strlen(content->id);
          count = count + (unsigned long int)14 + return_value_strlen_5;
        }

        if(!(content->location == ((const char *)NULL)))
        {
          return_value_strlen_6=strlen(content->location);
          count = count + (unsigned long int)20 + return_value_strlen_6;
        }

        if(!(content->description == ((const char *)NULL)))
        {
          return_value_strlen_7=strlen(content->description);
          count = count + (unsigned long int)23 + return_value_strlen_7;
        }

        count = count + (unsigned long int)2 + content->size;
      }
      count = count + (unsigned long int)6 + n;
    }

  }

  return count;
}

// soap_current_namespace
// file stdsoap2.c line 3020
const char * soap_current_namespace(struct soap *soap, const char *tag)
{
  struct soap_nlist *np;
  const char *s;
  _Bool tmp_if_expr_2;
  signed int return_value_strncmp_1;
  if(tag == ((const char *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_strncmp_1=strncmp(tag, "xml", (unsigned long int)3);
    tmp_if_expr_2 = !(return_value_strncmp_1 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_strncmp_3;
  char *return_value_soap_strdup_4;
  if(tmp_if_expr_2)
    return (const char *)(void *)0;

  else
  {
    np = soap->nlist;
    s=strchr(tag, 58);
    if(s == ((const char *)NULL))
      for( ; !(np == ((struct soap_nlist *)NULL)); np = np->next)
        if(np->id[0l] == 0)
          break;


    else
    {
      for( ; !(np == ((struct soap_nlist *)NULL)); np = np->next)
      {
        return_value_strncmp_3=strncmp(np->id, tag, (unsigned long int)(s - tag));
        if(return_value_strncmp_3 == 0)
        {
          if(np->id[s - tag] == 0)
            break;

        }

      }
      if(np == ((struct soap_nlist *)NULL))
        soap->error = 9;

    }
    if(!(np == ((struct soap_nlist *)NULL)))
    {
      if((signed int)np->index >= 0)
        return (soap->namespaces + (signed long int)np->index)->ns;

      if(!(np->ns == ((const char *)NULL)))
      {
        if(!(*np->ns == 0))
        {
          return_value_soap_strdup_4=soap_strdup(soap, np->ns);
          return return_value_soap_strdup_4;
        }

      }

    }

    return (const char *)(void *)0;
  }
}

// soap_dateTime2s
// file stdsoap2.c line 14869
const char * soap_dateTime2s(struct soap *soap, signed long int n)
{
  struct tm T;
  struct tm *pT = &T;
  struct tm *return_value_gmtime_r_1;
  return_value_gmtime_r_1=gmtime_r(&n, pT);
  if(!(return_value_gmtime_r_1 == ((struct tm *)NULL)))
    strftime(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , "%Y-%m-%dT%H:%M:%SZ", pT);

  else
  {
    strncpy(soap->tmpbuf, "1969-12-31T23:59:59Z", sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
    soap->tmpbuf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
    (void)(soap->tmpbuf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
  }
  return soap->tmpbuf;
}

// soap_dealloc
// file stdsoap2.c line 8316
void soap_dealloc(struct soap *soap, void *p)
{
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  if(soap == ((struct soap *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    if(!((signed int)soap->state == 1))
      tmp_if_expr_1 = (signed int)soap->state != 2 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
  }
  if(!tmp_if_expr_2)
  {
    if(!(p == NULL))
    {
      char **soap_dealloc__1__1__q = (char **)(void *)&soap->alist;
      for( ; !(*soap_dealloc__1__1__q == ((char *)NULL)); soap_dealloc__1__1__q = *((char ***)soap_dealloc__1__1__q))
      {
        if(!(*((unsigned short int *)(*soap_dealloc__1__1__q + -2l)) == 49374))
        {
          soap->error = 21;
          goto __CPROVER_DUMP_L13;
        }

        if(p == (void *)(*soap_dealloc__1__1__q + -((signed long int)*((unsigned long int *)(*soap_dealloc__1__1__q + (signed long int)sizeof(void *) /*8l*/ )))))
        {
          *soap_dealloc__1__1__q = *(*((char ***)soap_dealloc__1__1__q));
          free((void *)p);
          goto __CPROVER_DUMP_L13;
        }

      }
      soap_delete(soap, p);
    }

    else
    {
      char *q;
      while(!(soap->alist == NULL))
      {
        q = (char *)soap->alist;
        if(!(*((unsigned short int *)(q + -2l)) == 49374))
        {
          soap->error = 21;
          goto __CPROVER_DUMP_L13;
        }

        soap->alist = *((void **)q);
        q = q - (signed long int)*((unsigned long int *)(q + (signed long int)sizeof(void *) /*8ul*/ ));
        free((void *)q);
      }
      soap->http_content = (const char *)(void *)0;
      soap->action = (char *)(void *)0;
      soap->fault = (struct SOAP_ENV__Fault *)(void *)0;
      soap->header = (struct SOAP_ENV__Header *)(void *)0;
      soap->userid = (const char *)(void *)0;
      soap->passwd = (const char *)(void *)0;
      soap->authrealm = (const char *)(void *)0;
      soap_clr_mime(soap);
    }
  }


__CPROVER_DUMP_L13:
  ;
}

// soap_decode
// file stdsoap2.c line 6270
static const char * soap_decode(char *buf, unsigned long int len, const char *val, const char *sep)
{
  const char *s;
  char *t = buf;
  unsigned long int i = len;
  s = val;
  char *return_value_strchr_1;
  for( ; !(*s == 0); s = s + 1l)
    if(!((signed int)*s == 32))
    {
      if(!((signed int)*s == 9))
      {
        return_value_strchr_1=strchr(sep, (signed int)*s);
        if(return_value_strchr_1 == ((char *)NULL))
          break;

      }

    }

  char *return_value_strchr_4;
  if(len >= 1ul)
  {
    if((signed int)*s == 34)
    {
      s = s + 1l;
      while(!(*s == 0))
      {
        if((signed int)*s == 34)
          break;

        i = i - 1ul;
        if(i == 0ul)
          break;

        char *tmp_post_2 = t;
        t = t + 1l;
        const char *tmp_post_3 = s;
        s = s + 1l;
        *tmp_post_2 = *tmp_post_3;
      }
    }

    else
      while(!(*s == 0))
      {
        if(1 + (signed int)*s >= 1)
        {
          if(!((signed int)*s >= 33))
            break;

        }

        return_value_strchr_4=strchr(sep, (signed int)*s);
        if(!(return_value_strchr_4 == ((char *)NULL)))
          break;

        i = i - 1ul;
        if(i == 0ul)
          break;

        _Bool tmp_if_expr_10;
        if((signed int)*s == 37)
          tmp_if_expr_10 = s[(signed long int)1] != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_10 = (_Bool)0;
        _Bool tmp_if_expr_11;
        if(tmp_if_expr_10)
          tmp_if_expr_11 = s[(signed long int)2] != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_11 = (_Bool)0;
        if(tmp_if_expr_11)
        {
          char *tmp_post_5 = t;
          t = t + 1l;
          signed int tmp_if_expr_6;
          if((signed int)s[1l] >= 65)
            tmp_if_expr_6 = ((signed int)s[(signed long int)1] & 0x7) + 9;

          else
            tmp_if_expr_6 = (signed int)s[(signed long int)1] - 48;
          signed int tmp_if_expr_7;
          if((signed int)s[2l] >= 65)
            tmp_if_expr_7 = ((signed int)s[(signed long int)2] & 0x7) + 9;

          else
            tmp_if_expr_7 = (signed int)s[(signed long int)2] - 48;
          *tmp_post_5 = (char)((tmp_if_expr_6 << 4) + tmp_if_expr_7);
          s = s + (signed long int)3;
        }

        else
        {
          char *tmp_post_8 = t;
          t = t + 1l;
          const char *tmp_post_9 = s;
          s = s + 1l;
          *tmp_post_8 = *tmp_post_9;
        }
      }
    buf[(signed long int)(len - (unsigned long int)1)] = (char)0;
  }

  *t = (char)0;
  char *return_value_strchr_12;
  for( ; !(*s == 0); s = s + 1l)
  {
    return_value_strchr_12=strchr(sep, (signed int)*s);
    if(!(return_value_strchr_12 == ((char *)NULL)))
      break;

  }
  return s;
}

// soap_decode_key
// file stdsoap2.c line 6242
const char * soap_decode_key(char *buf, unsigned long int len, const char *val)
{
  const char *return_value_soap_decode_1;
  return_value_soap_decode_1=soap_decode(buf, len, val, "=,;");
  return return_value_soap_decode_1;
}

// soap_decode_val
// file stdsoap2.c line 6255
const char * soap_decode_val(char *buf, unsigned long int len, const char *val)
{
  if(!((signed int)*val == 61))
  {
    *buf = (char)0;
    return val;
  }

  else
  {
    const char *return_value_soap_decode_1;
    return_value_soap_decode_1=soap_decode(buf, len, val + (signed long int)1, ",;");
    return return_value_soap_decode_1;
  }
}

// soap_default_SOAP_ENV__Code
// file soapC.c line 751
void soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
  (void)soap;
  (void)a;
  soap_default_string(soap, &a->SOAP_ENV__Value);
  a->SOAP_ENV__Subcode = (struct SOAP_ENV__Code *)(void *)0;
}

// soap_default_SOAP_ENV__Detail
// file soapC.c line 663
void soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
  (void)soap;
  (void)a;
  a->__any = (char *)(void *)0;
  a->__type = 0;
  a->fault = (void *)0;
}

// soap_default_SOAP_ENV__Fault
// file soapC.c line 422
void soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
  (void)soap;
  (void)a;
  soap_default_string(soap, &a->faultcode);
  soap_default_string(soap, &a->faultstring);
  soap_default_string(soap, &a->faultactor);
  a->detail = (struct SOAP_ENV__Detail *)(void *)0;
  a->SOAP_ENV__Code = (struct SOAP_ENV__Code *)(void *)0;
  a->SOAP_ENV__Reason = (struct SOAP_ENV__Reason *)(void *)0;
  soap_default_string(soap, &a->SOAP_ENV__Node);
  soap_default_string(soap, &a->SOAP_ENV__Role);
  a->SOAP_ENV__Detail = (struct SOAP_ENV__Detail *)(void *)0;
}

// soap_default_SOAP_ENV__Header
// file soapC.c line 841
void soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
  (void)soap;
  (void)a;
}

// soap_default_SOAP_ENV__Reason
// file soapC.c line 582
void soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
  (void)soap;
  (void)a;
  soap_default_string(soap, &a->SOAP_ENV__Text);
}

// soap_default_byte
// file soapC.c line 348
void soap_default_byte(struct soap *soap, char *a)
{
  (void)soap;
  *a = (char)0;
}

// soap_default_int
// file soapC.c line 384
void soap_default_int(struct soap *soap, signed int *a)
{
  (void)soap;
  *a = (signed int)0;
}

// soap_default_string
// file soapC.c line 1386
void soap_default_string(struct soap *soap, char **a)
{
  (void)soap;
  *a = (char *)0;
}

// soap_default_t__Routing
// file soapC.c line 1016
void soap_default_t__Routing(struct soap *soap, struct t__Routing *a)
{
  (void)soap;
  (void)a;
  soap_default_string(soap, &a->key);
  soap_default_string(soap, &a->endpoint);
  soap_default_string(soap, &a->userid);
  soap_default_string(soap, &a->passwd);
}

// soap_default_t__RoutingTable
// file soapC.c line 908
void soap_default_t__RoutingTable(struct soap *soap, struct t__RoutingTable *a)
{
  (void)soap;
  (void)a;
  a->__size = 0;
  a->__ptr = (struct t__Routing *)(void *)0;
}

// soap_default_xsd__anyAttribute
// file dom.c line 192
void soap_default_xsd__anyAttribute(struct soap *soap, struct soap_dom_attribute *node)
{
  node->next = (struct soap_dom_attribute *)(void *)0;
  node->nstr = (const char *)(void *)0;
  node->name = (const char *)(void *)0;
  node->text = (const char *)(void *)0;
  node->soap = soap;
}

// soap_default_xsd__anyType
// file dom.c line 170
void soap_default_xsd__anyType(struct soap *soap, struct soap_dom_element *node)
{
  node->next = (struct soap_dom_element *)(void *)0;
  node->prnt = (struct soap_dom_element *)(void *)0;
  node->elts = (struct soap_dom_element *)(void *)0;
  node->atts = (struct soap_dom_attribute *)(void *)0;
  node->nstr = (const char *)(void *)0;
  node->name = (const char *)(void *)0;
  node->lead = (const char *)(void *)0;
  node->text = (const char *)(void *)0;
  node->code = (const char *)(void *)0;
  node->tail = (const char *)(void *)0;
  node->node = (void *)0;
  node->type = 0;
  node->soap = soap;
}

// soap_del
// file stdsoap2.c line 7478
void soap_del(struct soap *soap)
{
  free((void *)soap);
}

// soap_del_xsd__anyAttribute
// file dom.c line 796
void soap_del_xsd__anyAttribute(struct soap_dom_attribute *a)
{
  for( ; !(a == ((struct soap_dom_attribute *)NULL)); a = a->next)
  {
    if(!(a->nstr == ((const char *)NULL)))
      free((void *)a->nstr);

    if(!(a->name == ((const char *)NULL)))
      free((void *)a->name);

    if(!(a->text == ((const char *)NULL)))
      free((void *)a->text);

  }
}

// soap_del_xsd__anyType
// file dom.c line 744
void soap_del_xsd__anyType(struct soap_dom_element *a)
{
  for( ; !(a == ((struct soap_dom_element *)NULL)); a = a->next)
  {
    if(!(a->nstr == ((const char *)NULL)))
      free((void *)a->nstr);

    if(!(a->name == ((const char *)NULL)))
      free((void *)a->name);

    if(!(a->lead == ((const char *)NULL)))
      free((void *)a->lead);

    if(!(a->text == ((const char *)NULL)))
      free((void *)a->text);

    if(!(a->code == ((const char *)NULL)))
      free((void *)a->code);

    if(!(a->tail == ((const char *)NULL)))
      free((void *)a->tail);

    soap_del_xsd__anyAttribute(a->atts);
    soap_del_xsd__anyType(a->elts);
  }
}

// soap_delegate_deletion
// file stdsoap2.c line 8435
void soap_delegate_deletion(struct soap *soap, struct soap *soap_to)
{
  struct soap_clist *cp;
  char **q = (char **)(void *)&soap->alist;
  for( ; !(*q == ((char *)NULL)); q = *((char ***)q))
    if(!(*((unsigned short int *)(*q + -2l)) == 49374))
    {
      soap->error = 21;
      goto __CPROVER_DUMP_L8;
    }

  *q = (char *)soap_to->alist;
  soap_to->alist = soap->alist;
  soap->alist = (void *)0;
  cp = soap_to->clist;
  if(!(cp == ((struct soap_clist *)NULL)))
  {
    for( ; !(cp->next == ((struct soap_clist *)NULL)); cp = cp->next)
      ;
    cp->next = soap->clist;
  }

  else
    soap_to->clist = soap->clist;
  soap->clist = (struct soap_clist *)(void *)0;

__CPROVER_DUMP_L8:
  ;
}

// soap_delete
// file stdsoap2.c line 8387
void soap_delete(struct soap *soap, void *p)
{
  struct soap_clist **cp;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  if(soap == ((struct soap *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    if(!((signed int)soap->state == 1))
      tmp_if_expr_1 = (signed int)soap->state != 2 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
  }
  if(!tmp_if_expr_2)
  {
    cp = &soap->clist;
    if(!(p == NULL))
      for( ; !(*cp == ((struct soap_clist *)NULL)); cp = &(*cp)->next)
        if(p == (*cp)->ptr)
        {
          struct soap_clist *q = *cp;
          *cp = q->next;
          signed int return_value;
          return_value=q->fdelete(q);
          free((void *)q);
        }


    else
      if(!(*cp == ((struct soap_clist *)NULL)))
      {
        struct soap_clist *soap_delete__1__2__1__q = *cp;
        *cp = soap_delete__1__2__1__q->next;
        signed int return_value_1;
        return_value_1=soap_delete__1__2__1__q->fdelete(soap_delete__1__2__1__q);
        free((void *)soap_delete__1__2__1__q);
      }

    soap->fault = (struct SOAP_ENV__Fault *)(void *)0;
    soap->header = (struct SOAP_ENV__Header *)(void *)0;
  }

}

// soap_dime_option
// file stdsoap2.c line 15440
char * soap_dime_option(struct soap *soap, unsigned short int optype, const char *option)
{
  unsigned long int n;
  char *s = (char *)(void *)0;
  if(!(option == ((const char *)NULL)))
  {
    n=strlen(option);
    void *return_value_soap_malloc_1;
    return_value_soap_malloc_1=soap_malloc(soap, n + (unsigned long int)5);
    s = (char *)return_value_soap_malloc_1;
    if(!(s == ((char *)NULL)))
    {
      s[(signed long int)0] = (char)((signed int)optype >> 8);
      s[(signed long int)1] = (char)((signed int)optype & 0xFF);
      s[(signed long int)2] = (char)(n >> 8);
      s[(signed long int)3] = (char)(n & (unsigned long int)0xFF);
      if(1ul + n >= 1ul && !(s + 4l == ((char *)NULL)))
      {
        strncpy(s + (signed long int)4, option, (n + (unsigned long int)1) - (unsigned long int)1);
        (s + (signed long int)4)[(signed long int)((n + (unsigned long int)1) - (unsigned long int)1)] = (char)0;
        if(!(s[4l + (signed long int)n] == 0))
          (_Bool)1;

        else
          (_Bool)0;
      }

      else
        (_Bool)0;
    }

  }

  return s;
}

// soap_dom_call
// file dom.c line 3135
signed int soap_dom_call(struct soap *soap, const char *endpoint, const char *action, struct soap_dom_element *in, struct soap_dom_element *out)
{
  if(!(out == ((struct soap_dom_element *)NULL)))
    soap_default_xsd__anyType(soap, out);

  if(!(in == ((struct soap_dom_element *)NULL)))
    soap_serialize_xsd__anyType(soap, in);

  soap->http_content = "text/xml; charset=utf-8";
  signed int return_value_soap_begin_count_2;
  return_value_soap_begin_count_2=soap_begin_count(soap);
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_4;
  signed int return_value_soap_out_xsd__anyType_3;
  if(!(return_value_soap_begin_count_2 == 0))
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    if(!((0x00000008 & soap->mode) == 0))
    {
      return_value_soap_out_xsd__anyType_3=soap_out_xsd__anyType(soap, (const char *)(void *)0, 0, in, (const char *)(void *)0);
      tmp_if_expr_4 = return_value_soap_out_xsd__anyType_3 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_7;
  signed int return_value_soap_end_count_6;
  if(tmp_if_expr_5)
    tmp_if_expr_7 = (_Bool)1;

  else
  {
    return_value_soap_end_count_6=soap_end_count(soap);
    tmp_if_expr_7 = return_value_soap_end_count_6 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_9;
  signed int return_value_soap_connect_command_8;
  if(tmp_if_expr_7)
    tmp_if_expr_9 = (_Bool)1;

  else
  {
    return_value_soap_connect_command_8=soap_connect_command(soap, in != ((struct soap_dom_element *)NULL) && out != ((struct soap_dom_element *)NULL) ? 2001 : (out != ((struct soap_dom_element *)NULL) ? 2002 : (in != ((struct soap_dom_element *)NULL) ? 2003 : 2004)), endpoint, action);
    tmp_if_expr_9 = return_value_soap_connect_command_8 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_11;
  signed int return_value_soap_out_xsd__anyType_10;
  if(tmp_if_expr_9)
    tmp_if_expr_11 = (_Bool)1;

  else
  {
    return_value_soap_out_xsd__anyType_10=soap_out_xsd__anyType(soap, (const char *)(void *)0, 0, in, (const char *)(void *)0);
    tmp_if_expr_11 = return_value_soap_out_xsd__anyType_10 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_13;
  signed int return_value_soap_end_send_12;
  if(tmp_if_expr_11)
    tmp_if_expr_13 = (_Bool)1;

  else
  {
    return_value_soap_end_send_12=soap_end_send(soap);
    tmp_if_expr_13 = return_value_soap_end_send_12 != 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_soap_closesock_1;
  if(tmp_if_expr_13)
  {
    return_value_soap_closesock_1=soap_closesock(soap);
    return return_value_soap_closesock_1;
  }

  if(out == ((struct soap_dom_element *)NULL))
  {
    signed int return_value_soap_begin_recv_16;
    return_value_soap_begin_recv_16=soap_begin_recv(soap);
    if(return_value_soap_begin_recv_16 == 0)
    {
      soap_get_http_body(soap, (unsigned long int *)(void *)0);
      soap_end_recv(soap);
    }

    else
    {
      _Bool tmp_if_expr_14;
      if(soap->error == 14)
        tmp_if_expr_14 = (_Bool)1;

      else
        tmp_if_expr_14 = soap->error == 200 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr_15;
      if(tmp_if_expr_14)
        tmp_if_expr_15 = (_Bool)1;

      else
        tmp_if_expr_15 = soap->error == 202 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_15)
        soap->error = 0;

    }
    signed int return_value_soap_closesock_17;
    return_value_soap_closesock_17=soap_closesock(soap);
    return return_value_soap_closesock_17;
  }

  signed int return_value_soap_begin_recv_19;
  return_value_soap_begin_recv_19=soap_begin_recv(soap);
  _Bool tmp_if_expr_21;
  struct soap_dom_element *return_value_soap_in_xsd__anyType_20;
  if(!(return_value_soap_begin_recv_19 == 0))
    tmp_if_expr_21 = (_Bool)1;

  else
  {
    return_value_soap_in_xsd__anyType_20=soap_in_xsd__anyType(soap, (const char *)(void *)0, out, (const char *)(void *)0);
    tmp_if_expr_21 = return_value_soap_in_xsd__anyType_20 == (struct soap_dom_element *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_23;
  signed int return_value_soap_end_recv_22;
  if(tmp_if_expr_21)
    tmp_if_expr_23 = (_Bool)1;

  else
  {
    return_value_soap_end_recv_22=soap_end_recv(soap);
    tmp_if_expr_23 = return_value_soap_end_recv_22 != 0 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_soap_closesock_18;
  if(tmp_if_expr_23)
  {
    return_value_soap_closesock_18=soap_closesock(soap);
    return return_value_soap_closesock_18;
  }

  signed int return_value_soap_closesock_24;
  return_value_soap_closesock_24=soap_closesock(soap);
  return return_value_soap_closesock_24;
}

// soap_dom_find
// file dom.c line 3055
struct soap_dom_element * soap_dom_find(struct soap_dom_element *begin, struct soap_dom_element *end, const char *ns, const char *patt, signed int type)
{
  signed int return_value_soap_patt_match_4;
  struct soap_dom_element *return_value_soap_dom_find_next_3;
  signed int return_value_soap_name_match_6;
  struct soap_dom_element *return_value_soap_dom_find_next_5;
  struct soap_dom_element *return_value_soap_dom_find_next_9;
  if(!(begin == ((struct soap_dom_element *)NULL)))
  {
    if(!(patt == ((const char *)NULL)))
    {
      if((signed int)*patt == 64)
      {
        struct soap_dom_attribute *return_value_soap_att_find_1;
        return_value_soap_att_find_1=soap_att_find(begin, ns, patt + (signed long int)1);
        if(!(return_value_soap_att_find_1 == ((struct soap_dom_attribute *)NULL)))
          return begin;

        struct soap_dom_element *return_value_soap_dom_find_next_2;
        return_value_soap_dom_find_next_2=soap_dom_find_next(begin, end, ns, patt, type);
        return return_value_soap_dom_find_next_2;
      }

    }

    if(ns == ((const char *)NULL) && !(patt == ((const char *)NULL)))
      ns=soap_ns_to_find(begin->soap, patt);

    if(!(patt == ((const char *)NULL)))
    {
      return_value_soap_patt_match_4=soap_patt_match(begin->name, patt);
      if(return_value_soap_patt_match_4 == 0)
      {
        return_value_soap_dom_find_next_3=soap_dom_find_next(begin, end, ns, patt, type);
        return return_value_soap_dom_find_next_3;
      }

    }

    if(!(ns == ((const char *)NULL)))
    {
      _Bool tmp_if_expr_8;
      if(!(begin->nstr == ((const char *)NULL)))
        tmp_if_expr_8 = (_Bool)1;

      else
        tmp_if_expr_8 = *ns != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_8)
      {
        _Bool tmp_if_expr_7;
        if(begin->nstr == ((const char *)NULL))
          tmp_if_expr_7 = (_Bool)1;

        else
        {
          return_value_soap_name_match_6=soap_name_match(begin->nstr, ns);
          tmp_if_expr_7 = !(return_value_soap_name_match_6 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_7)
        {
          return_value_soap_dom_find_next_5=soap_dom_find_next(begin, end, ns, patt, type);
          return return_value_soap_dom_find_next_5;
        }

      }

    }

    if(!(type == 0))
    {
      if(!(type == begin->type))
      {
        return_value_soap_dom_find_next_9=soap_dom_find_next(begin, end, ns, patt, type);
        return return_value_soap_dom_find_next_9;
      }

    }

  }

  return begin;
}

// soap_dom_find_next
// file dom.c line 3091
struct soap_dom_element * soap_dom_find_next(struct soap_dom_element *elt, struct soap_dom_element *end, const char *ns, const char *patt, signed int type)
{
  signed int return_value_soap_patt_match_2;
  signed int return_value_soap_name_match_3;
  if(!(elt == ((struct soap_dom_element *)NULL)))
  {
    struct soap_dom_element *node;
    if(ns == ((const char *)NULL) && !(patt == ((const char *)NULL)))
      ns=soap_ns_to_find(elt->soap, patt + (signed long int)((signed int)*patt == 64));

    node=soap_dom_next_element(elt, end);
    while(!(node == ((struct soap_dom_element *)NULL)))
    {
      if(!(patt == ((const char *)NULL)))
      {
        if((signed int)*patt == 64)
        {
          struct soap_dom_attribute *return_value_soap_att_find_1;
          return_value_soap_att_find_1=soap_att_find(node, ns, patt + (signed long int)1);
          if(!(return_value_soap_att_find_1 == ((struct soap_dom_attribute *)NULL)))
            return node;

          goto __CPROVER_DUMP_L14;
        }

      }

      if(!(patt == ((const char *)NULL)))
      {
        return_value_soap_patt_match_2=soap_patt_match(node->name, patt);
        if(return_value_soap_patt_match_2 == 0)
          goto __CPROVER_DUMP_L14;

      }

      if(!(ns == ((const char *)NULL)))
      {
        _Bool tmp_if_expr_5;
        if(!(node->nstr == ((const char *)NULL)))
          tmp_if_expr_5 = (_Bool)1;

        else
          tmp_if_expr_5 = *ns != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_5)
        {
          _Bool tmp_if_expr_4;
          if(node->nstr == ((const char *)NULL))
            tmp_if_expr_4 = (_Bool)1;

          else
          {
            return_value_soap_name_match_3=soap_name_match(node->nstr, ns);
            tmp_if_expr_4 = !(return_value_soap_name_match_3 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_4)
            goto __CPROVER_DUMP_L14;

        }

      }

      if(!(type == 0))
      {
        if(type == node->type)
          goto __CPROVER_DUMP_L13;

      }

      else
      {

      __CPROVER_DUMP_L13:
        ;
        return node;
      }

    __CPROVER_DUMP_L14:
      ;
      node=soap_dom_next_element(node, end);
    }
  }

  return (struct soap_dom_element *)(void *)0;
}

// soap_dom_next_attribute
// file dom.c line 3004
struct soap_dom_attribute * soap_dom_next_attribute(struct soap_dom_attribute *att)
{
  return att->next;
}

// soap_dom_next_element
// file dom.c line 3020
struct soap_dom_element * soap_dom_next_element(struct soap_dom_element *elt, struct soap_dom_element *end)
{
  struct soap_dom_element *node;
  _Bool tmp_if_expr_1;
  if(!(elt->elts == ((struct soap_dom_element *)NULL)))
    return elt->elts;

  else
    if(elt == end)
      return (struct soap_dom_element *)(void *)0;

    else
      if(!(elt->next == ((struct soap_dom_element *)NULL)))
        return elt->next;

      else
      {
        node = elt->prnt;
        do
        {
          if(!(node == ((struct soap_dom_element *)NULL)))
            tmp_if_expr_1 = !(node->next != ((struct soap_dom_element *)NULL)) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_1 = (_Bool)0;
          if(!tmp_if_expr_1)
            break;

          if(node == end)
            return (struct soap_dom_element *)(void *)0;

          node = node->prnt;
        }
        while((_Bool)1);
        if(!(node == ((struct soap_dom_element *)NULL)))
          node = node->next;

        return node;
      }
}

// soap_done
// file ../../../gsoap/stdsoap2.h line 3049
void soap_done(struct soap *soap)
{
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  if(soap == ((struct soap *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    if(!((signed int)soap->state == 1))
      tmp_if_expr_1 = (signed int)soap->state != 2 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
  }
  if(!tmp_if_expr_2)
  {
    soap_free_temp(soap);
    while(!(soap->clist == ((struct soap_clist *)NULL)))
    {
      struct soap_clist *p = soap->clist->next;
      free((void *)soap->clist);
      soap->clist = p;
    }
    if((signed int)soap->state == 1)
      soap->omode = soap->omode & ~0x00000004;

    soap->keep_alive = (signed short int)0;
    if(soap->master == soap->socket)
      soap->master = (signed int)-1;

    soap_closesock(soap);
    while(!(soap->plugins == ((struct soap_plugin *)NULL)))
    {
      struct soap_plugin *soap_done__1__2__p = soap->plugins->next;
      _Bool tmp_if_expr_3;
      if(!(soap->plugins->fcopy == ((signed int (*)(struct soap *, struct soap_plugin *, struct soap_plugin *))NULL)))
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = (signed int)soap->state == 1 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3)
        soap->plugins->fdelete(soap, soap->plugins);

      free((void *)soap->plugins);
      soap->plugins = soap_done__1__2__p;
    }
    soap->fplugin = fplugin;
    soap->fmalloc = (void * (*)(struct soap *, unsigned long int))(void *)0;
    soap->fpost = http_post;
    soap->fget = http_get;
    soap->fput = http_405;
    soap->fdel = http_405;
    soap->fopt = http_200;
    soap->fhead = http_200;
    soap->fform = (signed int (*)(struct soap *))(void *)0;
    soap->fposthdr = http_post_header;
    soap->fresponse = http_response;
    soap->fparse = http_parse;
    soap->fparsehdr = http_parse_header;
    soap->fheader = (signed int (*)(struct soap *))(void *)0;
    soap->fresolve = (signed int (*)(struct soap *, const char *, struct in_addr *))(void *)0;
    soap->faccept = tcp_accept;
    soap->fopen = tcp_connect;
    soap->fclose = tcp_disconnect;
    soap->fclosesocket = tcp_closesocket;
    soap->fshutdownsocket = tcp_shutdownsocket;
    soap->fsend = fsend;
    soap->frecv = frecv;
    soap->fpoll = soap_poll;
    soap->fsvalidate = (signed int (*)(struct soap *, const char *, const char *))(void *)0;
    soap->fwvalidate = (signed int (*)(struct soap *, const char *, const signed int *))(void *)0;
    soap->feltbegin = (signed int (*)(struct soap *, const char *))(void *)0;
    soap->feltendin = (signed int (*)(struct soap *, const char *, const char *))(void *)0;
    soap->feltbegout = (signed int (*)(struct soap *, const char *))(void *)0;
    soap->feltendout = (signed int (*)(struct soap *, const char *))(void *)0;
    soap->fprepareinitsend = (signed int (*)(struct soap *))(void *)0;
    soap->fprepareinitrecv = (signed int (*)(struct soap *))(void *)0;
    soap->fpreparesend = (signed int (*)(struct soap *, const char *, unsigned long int))(void *)0;
    soap->fpreparerecv = (signed int (*)(struct soap *, const char *, unsigned long int))(void *)0;
    soap->fpreparefinalsend = (signed int (*)(struct soap *))(void *)0;
    soap->fpreparefinalrecv = (signed int (*)(struct soap *))(void *)0;
    soap->ffiltersend = (signed int (*)(struct soap *, const char **, unsigned long int *))(void *)0;
    soap->ffilterrecv = (signed int (*)(struct soap *, char *, unsigned long int *, unsigned long int))(void *)0;
    soap->fseterror = (void (*)(struct soap *, const char **, const char **))(void *)0;
    soap->fignore = (signed int (*)(struct soap *, const char *))(void *)0;
    soap->fserveloop = (signed int (*)(struct soap *))(void *)0;
    if((signed int)soap->state == 1)
    {
      if(!(soap->master == -1))
      {
        soap->fclosesocket(soap, soap->master);
        soap->master = (signed int)-1;
      }

    }

  }

}

// soap_double2s
// file stdsoap2.c line 13530
const char * soap_double2s(struct soap *soap, double n)
{
  char *s;
  signed int return_value___isnan_1;
  return_value___isnan_1=__isnan(n);
  signed int return_value___isinf_2;
  signed int return_value___isinf_3;
  if(!(return_value___isnan_1 == 0))
    return "NaN";

  else
  {
    if(n > 0.000000)
    {
      return_value___isinf_2=__isinf(n);
      if(!(return_value___isinf_2 == 0))
        return "INF";

    }

    if(n < 0.000000)
    {
      return_value___isinf_3=__isinf(n);
      if(!(return_value___isinf_3 == 0))
        return "-INF";

    }

    snprintf(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , soap->double_format, n);
    s=strchr(soap->tmpbuf, 44);
    if(!(s == ((char *)NULL)))
      *s = (char)46;

    return soap->tmpbuf;
  }
}

// soap_dup_xsd__anyAttribute
// file dom.c line 769
struct soap_dom_attribute * soap_dup_xsd__anyAttribute(struct soap *soap, struct soap_dom_attribute *d, struct soap_dom_attribute *a)
{
  struct soap_dom_attribute *att;
  if(a == ((struct soap_dom_attribute *)NULL))
    return (struct soap_dom_attribute *)(void *)0;

  else
    if(d == ((struct soap_dom_attribute *)NULL))
    {
      d=new_attribute(soap);
      if(!(d == ((struct soap_dom_attribute *)NULL)))
        goto __CPROVER_DUMP_L2;

      return (struct soap_dom_attribute *)(void *)0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      att = d;
      while(!(a == ((struct soap_dom_attribute *)NULL)))
      {
        att->nstr=soap_strdup(soap, a->nstr);
        att->name=soap_strdup(soap, a->name);
        att->text=soap_strdup(soap, a->text);
        a = a->next;
        if(!(a == ((struct soap_dom_attribute *)NULL)))
        {
          att->next=new_attribute(soap);
          if(att->next == ((struct soap_dom_attribute *)NULL))
            break;

          att = att->next;
        }

      }
      return d;
    }
}

// soap_dup_xsd__anyType
// file dom.c line 713
struct soap_dom_element * soap_dup_xsd__anyType(struct soap *soap, struct soap_dom_element *d, struct soap_dom_element *a)
{
  struct soap_dom_element *elt = (struct soap_dom_element *)(void *)0;
  if(a == ((struct soap_dom_element *)NULL))
    return (struct soap_dom_element *)(void *)0;

  else
    if(d == ((struct soap_dom_element *)NULL))
    {
      d=new_element(soap);
      if(!(d == ((struct soap_dom_element *)NULL)))
        goto __CPROVER_DUMP_L2;

      return (struct soap_dom_element *)(void *)0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      d->next = (struct soap_dom_element *)(void *)0;
      d->nstr=soap_strdup(soap, a->nstr);
      d->name=soap_strdup(soap, a->name);
      d->lead=soap_strdup(soap, a->lead);
      d->text=soap_strdup(soap, a->text);
      d->code=soap_strdup(soap, a->code);
      d->tail=soap_strdup(soap, a->tail);
      d->node = (void *)0;
      d->type = 0;
      d->atts=soap_dup_xsd__anyAttribute(soap, (struct soap_dom_attribute *)(void *)0, a->atts);
      a = a->elts;
      for( ; !(a == ((struct soap_dom_element *)NULL)); a = a->next)
      {
        if(!(elt == ((struct soap_dom_element *)NULL)))
        {
          elt->next=soap_dup_xsd__anyType(soap, (struct soap_dom_element *)(void *)0, a);
          elt = elt->next;
        }

        else
        {
          d->elts=soap_dup_xsd__anyType(soap, (struct soap_dom_element *)(void *)0, a);
          elt = d->elts;
        }
        elt->prnt = d;
      }
      return d;
    }
}

// soap_element
// file stdsoap2.c line 10288
signed int soap_element(struct soap *soap, const char *tag, signed int id, const char *type)
{
  const char *s;
  soap->level = soap->level + 1u;
  signed int return_value_soap_send_1;
  signed int return_value_soap_send_raw_3;
  if(soap->ns == 0)
  {
    if((0x00010000 & soap->mode) == 0)
    {
      return_value_soap_send_1=soap_send(soap, soap->prolog);
      if(!(return_value_soap_send_1 == 0))
        return soap->error;

    }

  }

  else
    if(!((0x00002000 & soap->mode) == 0))
    {
      if((signed int)soap->ns == 1)
      {
        unsigned long int tmp_if_expr_2;
        if(!((unsigned long int)soap->level >= sizeof(const char [21l]) /*21ul*/ ))
          tmp_if_expr_2 = (unsigned long int)soap->level;

        else
          tmp_if_expr_2 = sizeof(const char [21l]) /*21ul*/  - (unsigned long int)1;
        return_value_soap_send_raw_3=soap_send_raw(soap, soap_indent, tmp_if_expr_2);
        if(!(return_value_soap_send_raw_3 == 0))
          return soap->error;

      }

      soap->body = (signed short int)1;
    }

  signed int return_value_soap_send_6;
  signed int return_value_strncmp_8;
  _Bool tmp_if_expr_9;
  signed int return_value_strncmp_13;
  signed int return_value_soap_send_raw_16;
  signed int return_value_soap_send_17;
  if(!((0x00008000 & soap->mode) == 0))
  {
    struct Namespace *ns = soap->local_namespaces;
    unsigned long int n = (unsigned long int)0;
    s=strchr(tag, 58);
    if(!(s == ((const char *)NULL)))
    {
      const char *tmp_post_4 = s;
      s = s + 1l;
      n = (unsigned long int)(tmp_post_4 - tag);
    }

    else
      s = tag;
    signed int return_value_soap_send_raw_5;
    return_value_soap_send_raw_5=soap_send_raw(soap, "<", (unsigned long int)1);
    _Bool tmp_if_expr_7;
    if(!(return_value_soap_send_raw_5 == 0))
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      return_value_soap_send_6=soap_send(soap, s);
      tmp_if_expr_7 = return_value_soap_send_6 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
      return soap->error;

    if(!(n == 0ul))
    {
      if(!(soap->nlist == ((struct soap_nlist *)NULL)))
      {
        return_value_strncmp_8=strncmp(soap->nlist->id, tag, n);
        if(return_value_strncmp_8 == 0)
        {
          if(soap->nlist->id[(signed long int)n] == 0)
            ns = (struct Namespace *)(void *)0;

        }

      }

      do
      {
        if(!(ns == ((struct Namespace *)NULL)))
          tmp_if_expr_9 = ns->id != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_9 = (_Bool)0;
        if(!tmp_if_expr_9)
          break;

        if(!(*ns->id == 0))
        {
          if(!(ns->ns == ((const char *)NULL)))
          {
            return_value_strncmp_13=strncmp(ns->id, tag, n);
            if(return_value_strncmp_13 == 0)
            {
              if(ns->id[(signed long int)n] == 0)
              {
                char *tmp_if_expr_10;
                if(!(ns->out == ((char *)NULL)))
                  tmp_if_expr_10 = ns->out;

                else
                  tmp_if_expr_10 = ns->ns;
                soap_push_ns(soap, ns->id, tmp_if_expr_10, (signed short int)0);
                char *tmp_if_expr_11;
                if(!(ns->out == ((char *)NULL)))
                  tmp_if_expr_11 = ns->out;

                else
                  tmp_if_expr_11 = ns->ns;
                signed int return_value_soap_attribute_12;
                return_value_soap_attribute_12=soap_attribute(soap, "xmlns", tmp_if_expr_11);
                if(!(return_value_soap_attribute_12 == 0))
                  return soap->error;

                break;
              }

            }

          }

        }

        ns = ns + 1l;
      }
      while((_Bool)1);
    }

    else
    {
      _Bool tmp_if_expr_15;
      if(soap->nlist == ((struct soap_nlist *)NULL))
        tmp_if_expr_15 = (_Bool)1;

      else
        tmp_if_expr_15 = soap->nlist->id[0l] != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_15)
      {
        soap_push_ns(soap, "", "", (signed short int)0);
        signed int return_value_soap_attribute_14;
        return_value_soap_attribute_14=soap_attribute(soap, "xmlns", "");
        if(!(return_value_soap_attribute_14 == 0))
          return soap->error;

      }

    }
  }

  else
  {
    return_value_soap_send_raw_16=soap_send_raw(soap, "<", (unsigned long int)1);
    _Bool tmp_if_expr_18;
    if(!(return_value_soap_send_raw_16 == 0))
      tmp_if_expr_18 = (_Bool)1;

    else
    {
      return_value_soap_send_17=soap_send(soap, tag);
      tmp_if_expr_18 = return_value_soap_send_17 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_18)
      return soap->error;

  }
  signed int tmp_post_20;
  if(soap->ns == 0)
  {
    struct Namespace *soap_element__1__4__ns = soap->local_namespaces;
    signed int k = -1;
    if(!(soap_element__1__4__ns == ((struct Namespace *)NULL)))
    {
      if(!((0x00008000 & soap->mode) == 0))
      {
        if(!(soap->version == 0))
          k = 4;

        else
        {
          _Bool tmp_if_expr_19;
          if((0x00080000 & soap->mode) == 0)
            tmp_if_expr_19 = (_Bool)1;

          else
            tmp_if_expr_19 = (soap->mode & 0x00040000) != 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_19)
          {
            soap_element__1__4__ns = soap_element__1__4__ns + (signed long int)2;
            k = 2;
          }

          else
            k = 0;
        }
      }

      do
      {
        tmp_post_20 = k;
        k = k - 1;
        if(tmp_post_20 == 0)
          break;

        if(soap_element__1__4__ns->id == ((const char *)NULL))
          break;

        const char *soap_element__1__4__1__2__t = soap_element__1__4__ns->out;
        if(soap_element__1__4__1__2__t == ((const char *)NULL))
          soap_element__1__4__1__2__t = soap_element__1__4__ns->ns;

        if(!(*soap_element__1__4__ns->id == 0))
        {
          if(!(soap_element__1__4__1__2__t == ((const char *)NULL)))
          {
            if(!(*soap_element__1__4__1__2__t == 0))
            {
              snprintf(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , "xmlns:%s", soap_element__1__4__ns->id);
              signed int return_value_soap_attribute_21;
              return_value_soap_attribute_21=soap_attribute(soap, soap->tmpbuf, soap_element__1__4__1__2__t);
              if(!(return_value_soap_attribute_21 == 0))
                return soap->error;

            }

          }

        }

        soap_element__1__4__ns = soap_element__1__4__ns + 1l;
      }
      while((_Bool)1);
    }

  }

  soap->ns = (signed short int)1;
  if(!((0x00010000 & soap->mode) == 0))
    soap_utilize_ns(soap, tag);

  signed int return_value_soap_attribute_23;
  if(id >= 1)
  {
    snprintf(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , "_%d", id);
    if((signed int)soap->version == 2)
    {
      signed int return_value_soap_attribute_22;
      return_value_soap_attribute_22=soap_attribute(soap, "SOAP-ENC:id", soap->tmpbuf);
      if(!(return_value_soap_attribute_22 == 0))
        return soap->error;

    }

    else
    {
      return_value_soap_attribute_23=soap_attribute(soap, "id", soap->tmpbuf);
      if(!(return_value_soap_attribute_23 == 0))
        return soap->error;

    }
  }

  signed int return_value_soap_set_attr_24;
  signed int return_value_soap_attribute_25;
  if(!(type == ((const char *)NULL)))
  {
    if(!(*type == 0))
    {
      if((0x00080000 & soap->mode) == 0)
      {
        if(!((signed int)soap->part == 3))
        {
          const char *t = type;
          if(!((0x00008000 & soap->mode) == 0))
          {
            t=strchr(type, 58);
            if(!(t == ((const char *)NULL)))
              t = t + 1l;

            else
              t = type;
          }

          else
            if(!((0x00010000 & soap->mode) == 0))
              soap_utilize_ns(soap, type);

          signed int tmp_if_expr_26;
          if(!(soap->attributes == ((struct soap_attribute *)NULL)))
          {
            return_value_soap_set_attr_24=soap_set_attr(soap, "xsi:type", t, 1);
            tmp_if_expr_26 = return_value_soap_set_attr_24;
          }

          else
          {
            return_value_soap_attribute_25=soap_attribute(soap, "xsi:type", t);
            tmp_if_expr_26 = return_value_soap_attribute_25;
          }
          if(!(tmp_if_expr_26 == 0))
            return soap->error;

        }

      }

    }

  }

  if(!(soap->null == 0))
  {
    if(soap->position >= 1)
    {
      if((signed int)soap->version == 1)
      {
        signed int i;
        snprintf(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1, "[%d", soap->positions[(signed long int)0]);
        i = 1;
        for( ; !(i >= soap->position); i = i + 1)
        {
          unsigned long int l;
          l=strlen(soap->tmpbuf);
          snprintf(soap->tmpbuf + (signed long int)l, (sizeof(char [1024l]) /*1024ul*/  - l) - (unsigned long int)1, ",%d", soap->positions[(signed long int)i]);
        }
        unsigned long int return_value_strlen_27;
        return_value_strlen_27=strlen(soap->tmpbuf);
        signed int tmp_if_expr_28;
        if(!(1ul + return_value_strlen_27 >= sizeof(char [1024l]) /*1024ul*/ ))
        {
          strncat(soap->tmpbuf, "]", (unsigned long int)1);
          soap->tmpbuf[(signed long int)((unsigned long int)sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
          tmp_if_expr_28 = (signed int)soap->tmpbuf[(signed long int)((unsigned long int)sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)];
        }

        else
        {
          soap->tmpbuf[(signed long int)0] = (char)0;
          tmp_if_expr_28 = (signed int)soap->tmpbuf[(signed long int)0];
        }
        (void)(tmp_if_expr_28 != 0 ? (_Bool)1 : (_Bool)0);
        signed int return_value_soap_attribute_29;
        return_value_soap_attribute_29=soap_attribute(soap, "SOAP-ENC:position", soap->tmpbuf);
        if(!(return_value_soap_attribute_29 == 0))
          return soap->error;

      }

    }

  }

  if(!(soap->mustUnderstand == 0))
  {
    if(!(soap->actor == ((const char *)NULL)))
    {
      if(!(*soap->actor == 0))
      {
        signed int return_value_soap_attribute_30;
        return_value_soap_attribute_30=soap_attribute(soap, (signed int)soap->version == 2 ? "SOAP-ENV:role" : "SOAP-ENV:actor", soap->actor);
        if(!(return_value_soap_attribute_30 == 0))
          return soap->error;

      }

    }

    signed int return_value_soap_attribute_31;
    return_value_soap_attribute_31=soap_attribute(soap, "SOAP-ENV:mustUnderstand", (signed int)soap->version == 2 ? "true" : "1");
    if(!(return_value_soap_attribute_31 == 0))
      return soap->error;

    soap->mustUnderstand = (signed short int)0;
  }

  signed int return_value_soap_attribute_32;
  if(!(soap->encoding == 0))
  {
    _Bool tmp_if_expr_33;
    if(!(soap->encodingStyle == ((const char *)NULL)))
      tmp_if_expr_33 = soap->local_namespaces != ((struct Namespace *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_33 = (_Bool)0;
    _Bool tmp_if_expr_34;
    if(tmp_if_expr_33)
      tmp_if_expr_34 = (soap->local_namespaces + (signed long int)0)->id != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_34 = (_Bool)0;
    _Bool tmp_if_expr_35;
    if(tmp_if_expr_34)
      tmp_if_expr_35 = (soap->local_namespaces + (signed long int)1)->id != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_35 = (_Bool)0;
    if(tmp_if_expr_35)
    {
      if(*soap->encodingStyle == 0)
      {
        if(!((soap->local_namespaces + 1l)->out == ((char *)NULL)))
          soap->encodingStyle = (soap->local_namespaces + (signed long int)1)->out;

        else
          soap->encodingStyle = (soap->local_namespaces + (signed long int)1)->ns;
      }

      if(!(soap->encodingStyle == ((const char *)NULL)))
      {
        return_value_soap_attribute_32=soap_attribute(soap, "SOAP-ENV:encodingStyle", soap->encodingStyle);
        if(!(return_value_soap_attribute_32 == 0))
          return soap->error;

      }

    }

    else
      soap->encodingStyle = (const char *)(void *)0;
    soap->encoding = (signed short int)0;
  }

  soap->null = (signed short int)0;
  soap->position = 0;
  if((signed int)soap->event == 1)
    soap->event = (signed short int)0;

  return 0;
}

// soap_element_begin_in
// file ../../../gsoap/stdsoap2.h line 3084
signed int soap_element_begin_in(struct soap *soap, const char *tag, signed int nillable, const char *type)
{
  signed int return_value_soap_peek_element_2;
  return_value_soap_peek_element_2=soap_peek_element(soap);
  signed int return_value_soap_match_tag_1;
  if(return_value_soap_peek_element_2 == 0)
  {
    if(!(soap->other == 0))
    {
      soap->error = 3;
      return soap->error;
    }

    if(!(tag == ((const char *)NULL)))
    {
      if((signed int)*tag == 45)
        return 0;

    }

    soap->error=soap_match_tag(soap, soap->tag, tag);
    if(soap->error == 0)
    {
      soap->peeked = (signed short int)0;
      if(!(type == ((const char *)NULL)))
      {
        if(!(soap->type[0l] == 0))
        {
          return_value_soap_match_tag_1=soap_match_tag(soap, soap->type, type);
          if(!(return_value_soap_match_tag_1 == 0))
          {
            soap->error = 4;
            return soap->error;
          }

        }

      }

      if(nillable == 0)
      {
        if(!(soap->null == 0))
        {
          if(!((0x00001000 & soap->mode) == 0))
          {
            soap->error = 23;
            return soap->error;
          }

        }

      }

      if(!(soap->body == 0))
        soap->level = soap->level + 1u;

      soap->error = 0;
    }

  }

  else
    if(soap->error == 6)
    {
      if(!(tag == ((const char *)NULL)))
      {
        if((signed int)*tag == 45)
          soap->error = 0;

      }

    }

  return soap->error;
}

// soap_element_begin_out
// file ../../../gsoap/stdsoap2.h line 3070
signed int soap_element_begin_out(struct soap *soap, const char *tag, signed int id, const char *type)
{
  if((signed int)*tag == 45)
    return 0;

  else
  {
    signed int return_value_soap_element_1;
    return_value_soap_element_1=soap_element(soap, tag, id, type);
    if(!(return_value_soap_element_1 == 0))
      return soap->error;

    else
    {
      signed int return_value_soap_element_start_end_out_2;
      return_value_soap_element_start_end_out_2=soap_element_start_end_out(soap, (const char *)(void *)0);
      return return_value_soap_element_start_end_out_2;
    }
  }
}

// soap_element_end_in
// file ../../../gsoap/stdsoap2.h line 3086
signed int soap_element_end_in(struct soap *soap, const char *tag)
{
  signed int c;
  char *s;
  signed int n = 0;
  signed int tmp_post_1;
  if(!(tag == ((const char *)NULL)))
  {
    if(!((signed int)*tag == 45))
      goto __CPROVER_DUMP_L1;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(soap->error == 6)
      soap->error = 0;

    if(!(soap->peeked == 0))
    {
      if(!(soap->tag[0l] == 0))
        n = n + 1;

      soap->peeked = (signed short int)0;
    }

    do
    {

    __CPROVER_DUMP_L4:
      ;
      c=soap_get(soap);
      if(!(c == -3))
      {
        if(c == -1)
        {
          signed int tmp_if_expr_2;
          if(!(soap->error == 0))
            tmp_if_expr_2 = soap->error;

          else
            tmp_if_expr_2 = -1;
          soap->error = tmp_if_expr_2;
          return soap->error;
        }

        if(c == -2)
          n = n + 1;

        else
          if(c == 47)
          {
            c=soap_get(soap);
            if(c == -4)
              n = n - 1;

            else
              soap->ahead = c;
          }

        goto __CPROVER_DUMP_L4;
      }

      tmp_post_1 = n;
      n = n - 1;
    }
    while(!(tmp_post_1 == 0));
    s = soap->tag;
    n = (signed int)sizeof(char [1024l]) /*1024ul*/ ;
    do
    {
      c=soap_get(soap);
      if(!(c >= 33))
        break;

      n = n - 1;
      if(n >= 1)
      {
        char *tmp_post_3 = s;
        s = s + 1l;
        *tmp_post_3 = (char)c;
      }

    }
    while((_Bool)1);
    *s = (char)0;
    if(c == -1)
    {
      signed int tmp_if_expr_4;
      if(!(soap->error == 0))
        tmp_if_expr_4 = soap->error;

      else
        tmp_if_expr_4 = -1;
      soap->error = tmp_if_expr_4;
      return soap->error;
    }

    while(1 + c >= 1 && !(c >= 33))
      c=soap_get(soap);
    if(!(c == -4))
    {
      soap->error = 5;
      return soap->error;
    }

    else
    {
      if(!(tag == ((const char *)NULL)))
      {
        if(!((0x00001000 & soap->mode) == 0))
        {
          soap_pop_namespace(soap);
          signed int return_value_soap_match_tag_5;
          return_value_soap_match_tag_5=soap_match_tag(soap, soap->tag, tag);
          if(!(return_value_soap_match_tag_5 == 0))
          {
            soap->error = 5;
            return soap->error;
          }

        }

      }

      soap->level = soap->level - 1u;
      return 0;
    }
  }
}

// soap_element_end_out
// file ../../../gsoap/stdsoap2.h line 3079
signed int soap_element_end_out(struct soap *soap, const char *tag)
{
  const char *s;
  signed int return_value_soap_send_4;
  if((signed int)*tag == 45)
    return 0;

  else
  {
    if(!(soap->nlist == ((struct soap_nlist *)NULL)))
      soap_pop_namespace(soap);

    if(!((0x00002000 & soap->mode) == 0))
    {
      if(soap->body == 0)
      {
        unsigned long int tmp_if_expr_1;
        if(!((unsigned long int)soap->level >= sizeof(const char [21l]) /*21ul*/ ))
          tmp_if_expr_1 = (unsigned long int)soap->level;

        else
          tmp_if_expr_1 = sizeof(const char [21l]) /*21ul*/  - (unsigned long int)1;
        signed int return_value_soap_send_raw_2;
        return_value_soap_send_raw_2=soap_send_raw(soap, soap_indent, tmp_if_expr_1);
        if(!(return_value_soap_send_raw_2 == 0))
          return soap->error;

      }

      soap->body = (signed short int)0;
    }

    if(!((0x00008000 & soap->mode) == 0))
    {
      s=strchr(tag, 58);
      if(!(s == ((const char *)NULL)))
        tag = s + (signed long int)1;

    }

    signed int return_value_soap_send_raw_3;
    return_value_soap_send_raw_3=soap_send_raw(soap, "</", (unsigned long int)2);
    _Bool tmp_if_expr_5;
    if(!(return_value_soap_send_raw_3 == 0))
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_soap_send_4=soap_send(soap, tag);
      tmp_if_expr_5 = return_value_soap_send_4 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      return soap->error;

    else
    {
      soap->level = soap->level - 1u;
      signed int return_value_soap_send_raw_6;
      return_value_soap_send_raw_6=soap_send_raw(soap, ">", (unsigned long int)1);
      return return_value_soap_send_raw_6;
    }
  }
}

// soap_element_href
// file stdsoap2.c line 10863
signed int soap_element_href(struct soap *soap, const char *tag, signed int id, const char *ref, const char *val)
{
  signed int return_value_soap_element_1;
  return_value_soap_element_1=soap_element(soap, tag, id, (const char *)(void *)0);
  _Bool tmp_if_expr_3;
  signed int return_value_soap_attribute_2;
  if(!(return_value_soap_element_1 == 0))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_soap_attribute_2=soap_attribute(soap, ref, val);
    tmp_if_expr_3 = return_value_soap_attribute_2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_5;
  signed int return_value_soap_element_start_end_out_4;
  if(tmp_if_expr_3)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_soap_element_start_end_out_4=soap_element_start_end_out(soap, tag);
    tmp_if_expr_5 = return_value_soap_element_start_end_out_4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
    return soap->error;

  else
  {
    soap->body = (signed short int)0;
    return 0;
  }
}

// soap_element_id
// file ../../../gsoap/stdsoap2.h line 3076
signed int soap_element_id(struct soap *soap, const char *tag, signed int id, const void *p, const void *a, signed int n, const char *type, signed int t, char **mark)
{
  (void)a;
  (void)n;
  signed int return_value_soap_check_and_mark_1;
  signed int return_value_soap_embed_4;
  if(p == NULL)
  {
    soap->error=soap_element_null(soap, tag, id, type);
    return -1;
  }

  else
  {
    _Bool tmp_if_expr_2;
    if(soap->encodingStyle == ((const char *)NULL))
      tmp_if_expr_2 = !((soap->omode & 0x20000000) != 0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    _Bool tmp_if_expr_3;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (soap->omode & 0x00020000) != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
    {
      return_value_soap_check_and_mark_1=soap_check_and_mark(soap, p, t, mark);
      return return_value_soap_check_and_mark_1;
    }

    if(!(mark == ((char **)NULL)))
      *mark = (char *)(void *)0;

    if(!(id >= -1))
    {
      return_value_soap_embed_4=soap_embed(soap, p, a, n, t);
      return return_value_soap_embed_4;
    }

    else
      if(!(id >= 1))
      {
        struct soap_plist *pp;
        if(!(a == NULL))
          id=soap_array_pointer_lookup(soap, p, a, n, t, &pp);

        else
          id=soap_pointer_lookup(soap, p, t, &pp);
        if(!(id == 0))
        {
          signed int return_value_soap_is_embedded_5;
          return_value_soap_is_embedded_5=soap_is_embedded(soap, pp);
          if(!(return_value_soap_is_embedded_5 == 0))
          {
            soap_element_ref(soap, tag, 0, id);
            return -1;
          }

          signed int return_value_soap_is_single_6;
          return_value_soap_is_single_6=soap_is_single(soap, pp);
          if(!(return_value_soap_is_single_6 == 0))
            return 0;

          soap_set_embedded(soap, pp);
        }

      }

    return id;
  }
}

// soap_element_nil
// file stdsoap2.c line 10907
signed int soap_element_nil(struct soap *soap, const char *tag)
{
  signed int return_value_soap_element_1;
  return_value_soap_element_1=soap_element(soap, tag, -1, (const char *)(void *)0);
  _Bool tmp_if_expr_3;
  signed int return_value_soap_attribute_2;
  if(!(return_value_soap_element_1 == 0))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_soap_attribute_2=soap_attribute(soap, "xsi:nil", "true");
    tmp_if_expr_3 = return_value_soap_attribute_2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
    return soap->error;

  else
  {
    signed int return_value_soap_element_start_end_out_4;
    return_value_soap_element_start_end_out_4=soap_element_start_end_out(soap, tag);
    return return_value_soap_element_start_end_out_4;
  }
}

// soap_element_null
// file stdsoap2.c line 10880
signed int soap_element_null(struct soap *soap, const char *tag, signed int id, const char *type)
{
  struct soap_attribute *tp = (struct soap_attribute *)(void *)0;
  tp = soap->attributes;
  for( ; !(tp == ((struct soap_attribute *)NULL)); tp = tp->next)
    if(!(tp->visible == 0))
      break;

  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_7;
  if(!(tp == ((struct soap_attribute *)NULL)))
    tmp_if_expr_8 = (_Bool)1;

  else
  {
    if((signed int)soap->version == 2)
      tmp_if_expr_7 = soap->position > 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_7 = (_Bool)0;
    tmp_if_expr_8 = tmp_if_expr_7 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_9;
  if(id >= 1 || tmp_if_expr_8)
    tmp_if_expr_9 = (_Bool)1;

  else
    tmp_if_expr_9 = (soap->mode & 0x00040000) != 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_3;
  signed int return_value_soap_attribute_2;
  signed int return_value_soap_element_start_end_out_5;
  if(tmp_if_expr_9)
  {
    signed int return_value_soap_element_1;
    return_value_soap_element_1=soap_element(soap, tag, id, type);
    _Bool tmp_if_expr_4;
    if(!(return_value_soap_element_1 == 0))
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      if(tp == ((struct soap_attribute *)NULL))
      {
        return_value_soap_attribute_2=soap_attribute(soap, "xsi:nil", "true");
        tmp_if_expr_3 = return_value_soap_attribute_2 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_3 = (_Bool)0;
      tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr_6;
    if(tmp_if_expr_4)
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_soap_element_start_end_out_5=soap_element_start_end_out(soap, tag);
      tmp_if_expr_6 = return_value_soap_element_start_end_out_5 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
      return soap->error;

    soap->body = (signed short int)0;
  }

  else
  {
    soap->null = (signed short int)1;
    soap->position = 0;
    soap->mustUnderstand = (signed short int)0;
  }
  return 0;
}

// soap_element_ref
// file stdsoap2.c line 10843
signed int soap_element_ref(struct soap *soap, const char *tag, signed int id, signed int href)
{
  const char *s = "ref";
  signed int n = 1;
  if((signed int)soap->version == 1)
  {
    s = "href";
    n = 0;
  }

  else
    if((signed int)soap->version == 2)
      s = "SOAP-ENC:ref";

  snprintf(soap->href, sizeof(char [1024l]) /*1024ul*/ , "#_%d", href);
  signed int return_value_soap_element_href_1;
  return_value_soap_element_href_1=soap_element_href(soap, tag, id, s, soap->href + (signed long int)n);
  return return_value_soap_element_href_1;
}

// soap_element_result
// file stdsoap2.c line 11064
signed int soap_element_result(struct soap *soap, const char *tag)
{
  signed int return_value_soap_attribute_2;
  signed int return_value_soap_element_start_end_out_4;
  signed int return_value_soap_string_out_6;
  signed int return_value_soap_element_end_out_8;
  if((signed int)soap->version == 2)
  {
    if(!(soap->encodingStyle == ((const char *)NULL)))
    {
      signed int return_value_soap_element_1;
      return_value_soap_element_1=soap_element(soap, "SOAP-RPC:result", 0, (const char *)(void *)0);
      _Bool tmp_if_expr_3;
      if(!(return_value_soap_element_1 == 0))
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value_soap_attribute_2=soap_attribute(soap, "xmlns:SOAP-RPC", soap_rpc);
        tmp_if_expr_3 = return_value_soap_attribute_2 != 0 ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_5;
      if(tmp_if_expr_3)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        return_value_soap_element_start_end_out_4=soap_element_start_end_out(soap, (const char *)(void *)0);
        tmp_if_expr_5 = return_value_soap_element_start_end_out_4 != 0 ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_7;
      if(tmp_if_expr_5)
        tmp_if_expr_7 = (_Bool)1;

      else
      {
        return_value_soap_string_out_6=soap_string_out(soap, tag, 0);
        tmp_if_expr_7 = return_value_soap_string_out_6 != 0 ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_9;
      if(tmp_if_expr_7)
        tmp_if_expr_9 = (_Bool)1;

      else
      {
        return_value_soap_element_end_out_8=soap_element_end_out(soap, "SOAP-RPC:result");
        tmp_if_expr_9 = return_value_soap_element_end_out_8 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_9)
        return soap->error;

    }

  }

  return 0;
}

// soap_element_start_end_out
// file stdsoap2.c line 10695
signed int soap_element_start_end_out(struct soap *soap, const char *tag)
{
  struct soap_attribute *tp;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  const char *return_value_soap_tagsearch_2;
  if(!((0x00010000 & soap->mode) == 0))
  {
    struct soap_nlist *np;
    tp = soap->attributes;
    for( ; !(tp == ((struct soap_attribute *)NULL)); tp = tp->next)
      if(!(tp->visible == 0))
      {
        if(!(tp->name[0l] == 0))
          soap_utilize_ns(soap, tp->name);

      }

    np = soap->nlist;
    for( ; !(np == ((struct soap_nlist *)NULL)); np = np->next)
    {
      _Bool tmp_if_expr_5;
      if(!(np->ns == ((const char *)NULL)))
      {
        if((signed int)np->index == 1)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          if((signed int)np->index == 0)
            tmp_if_expr_1 = (signed int)soap->event == 1 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_1 = (_Bool)0;
          if(tmp_if_expr_1)
          {
            return_value_soap_tagsearch_2=soap_tagsearch(soap->c14ninclude, np->id);
            tmp_if_expr_3 = return_value_soap_tagsearch_2 != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_3 = (_Bool)0;
          tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
        }
        tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_5 = (_Bool)0;
      if(tmp_if_expr_5)
      {
        if(!(np->id[0l] == 0))
          snprintf(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , "xmlns:%s", (const void *)np->id);

        else
        {
          strncpy(soap->tmpbuf, "xmlns", sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
          soap->tmpbuf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
          (void)(soap->tmpbuf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
        }
        soap_set_attr(soap, soap->tmpbuf, np->ns, 1);
        np->index = (signed short int)2;
      }

    }
  }

  tp = soap->attributes;
  signed int return_value_strncmp_6;
  signed int return_value_soap_send_10;
  signed int return_value_soap_send_raw_12;
  signed int return_value_soap_send_13;
  signed int return_value_soap_string_out_17;
  signed int return_value_soap_send_raw_19;
  for( ; !(tp == ((struct soap_attribute *)NULL)); tp = tp->next)
    if(!(tp->visible == 0))
    {
      const char *s;
      _Bool tmp_if_expr_15;
      if(!((0x00008000 & soap->mode) == 0))
      {
        s=strchr(tp->name, 58);
        tmp_if_expr_15 = s != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_15 = (_Bool)0;
      if(tmp_if_expr_15)
      {
        unsigned long int n = (unsigned long int)(s - tp->name);
        _Bool tmp_if_expr_7;
        if(!(soap->nlist == ((struct soap_nlist *)NULL)))
        {
          return_value_strncmp_6=strncmp(soap->nlist->id, tp->name, n);
          tmp_if_expr_7 = !(return_value_strncmp_6 != 0) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_7 = (_Bool)0;
        _Bool tmp_if_expr_8;
        if(tmp_if_expr_7)
          tmp_if_expr_8 = !(soap->nlist->id[(signed long int)n] != 0) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_8 = (_Bool)0;
        if(tmp_if_expr_8)
          s = s + 1l;

        else
          s = tp->name;
        signed int return_value_soap_send_raw_9;
        return_value_soap_send_raw_9=soap_send_raw(soap, " ", (unsigned long int)1);
        _Bool tmp_if_expr_11;
        if(!(return_value_soap_send_raw_9 == 0))
          tmp_if_expr_11 = (_Bool)1;

        else
        {
          return_value_soap_send_10=soap_send(soap, s);
          tmp_if_expr_11 = return_value_soap_send_10 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_11)
          return soap->error;

      }

      else
      {
        return_value_soap_send_raw_12=soap_send_raw(soap, " ", (unsigned long int)1);
        _Bool tmp_if_expr_14;
        if(!(return_value_soap_send_raw_12 == 0))
          tmp_if_expr_14 = (_Bool)1;

        else
        {
          return_value_soap_send_13=soap_send(soap, tp->name);
          tmp_if_expr_14 = return_value_soap_send_13 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_14)
          return soap->error;

      }
      _Bool tmp_if_expr_22;
      if((signed int)tp->visible == 2)
        tmp_if_expr_22 = tp->value != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_22 = (_Bool)0;
      if(tmp_if_expr_22)
      {
        signed int return_value_soap_send_raw_16;
        return_value_soap_send_raw_16=soap_send_raw(soap, "=\"", (unsigned long int)2);
        _Bool tmp_if_expr_18;
        if(!(return_value_soap_send_raw_16 == 0))
          tmp_if_expr_18 = (_Bool)1;

        else
        {
          return_value_soap_string_out_17=soap_string_out(soap, tp->value, (signed int)tp->flag);
          tmp_if_expr_18 = return_value_soap_string_out_17 != 0 ? (_Bool)1 : (_Bool)0;
        }
        _Bool tmp_if_expr_20;
        if(tmp_if_expr_18)
          tmp_if_expr_20 = (_Bool)1;

        else
        {
          return_value_soap_send_raw_19=soap_send_raw(soap, "\"", (unsigned long int)1);
          tmp_if_expr_20 = return_value_soap_send_raw_19 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_20)
          return soap->error;

      }

      else
        if(!((0x00001000 & soap->mode) == 0))
        {
          signed int return_value_soap_send_raw_21;
          return_value_soap_send_raw_21=soap_send_raw(soap, "=\"\"", (unsigned long int)3);
          if(!(return_value_soap_send_raw_21 == 0))
            return soap->error;

        }

      tp->visible = (signed short int)0;
    }

  signed int return_value_soap_element_end_out_24;
  if(!(tag == ((const char *)NULL)))
  {
    if(!((0x00010000 & soap->mode) == 0))
    {
      signed int return_value_soap_send_raw_23;
      return_value_soap_send_raw_23=soap_send_raw(soap, ">", (unsigned long int)1);
      _Bool tmp_if_expr_25;
      if(!(return_value_soap_send_raw_23 == 0))
        tmp_if_expr_25 = (_Bool)1;

      else
      {
        return_value_soap_element_end_out_24=soap_element_end_out(soap, tag);
        tmp_if_expr_25 = return_value_soap_element_end_out_24 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_25)
        return soap->error;

      return 0;
    }

    if(!(soap->nlist == ((struct soap_nlist *)NULL)))
      soap_pop_namespace(soap);

    soap->level = soap->level - 1u;
    soap->body = (signed short int)0;
    signed int return_value_soap_send_raw_26;
    return_value_soap_send_raw_26=soap_send_raw(soap, "/>", (unsigned long int)2);
    return return_value_soap_send_raw_26;
  }

  signed int return_value_soap_send_raw_27;
  return_value_soap_send_raw_27=soap_send_raw(soap, ">", (unsigned long int)1);
  return return_value_soap_send_raw_27;
}

// soap_elt
// file dom.c line 1242
struct soap_dom_element * soap_elt(struct soap_dom_element *elt, const char *ns, const char *tag)
{
  struct soap_dom_element *node = (struct soap_dom_element *)(void *)0;
  signed int return_value_soap_tag_match_5;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(!(elt == ((struct soap_dom_element *)NULL)))
  {
    struct soap_dom_element *last = (struct soap_dom_element *)(void *)0;
    const char *ns1 = ns;
    if(ns1 == ((const char *)NULL))
      ns1=soap_ns_to_set(elt->soap, tag);

    node = elt->elts;
    for( ; !(node == ((struct soap_dom_element *)NULL)); node = node->next)
    {
      if(!(tag == ((const char *)NULL)))
      {
        return_value_soap_tag_match_5=soap_tag_match(node->name, tag);
        if(!(return_value_soap_tag_match_5 == 0))
        {
          _Bool tmp_if_expr_4;
          if(ns1 == node->nstr)
            tmp_if_expr_4 = (_Bool)1;

          else
          {
            if(!(ns1 == ((const char *)NULL)))
              tmp_if_expr_1 = node->nstr != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_1 = (_Bool)0;
            if(tmp_if_expr_1)
            {
              return_value_strcmp_2=strcmp(node->nstr, ns1);
              tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_3 = (_Bool)0;
            tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_4)
            return node;

        }

      }

      if(node->next == ((struct soap_dom_element *)NULL))
        last = node;

    }
    node=soap_elt_new(elt->soap, ns, tag);
    if(!(node == ((struct soap_dom_element *)NULL)))
      node->prnt = elt;

    if(!(last == ((struct soap_dom_element *)NULL)))
      last->next = node;

    else
      elt->elts = node;
  }

  return node;
}

// soap_elt_bool
// file dom.c line 1526
struct soap_dom_element * soap_elt_bool(struct soap_dom_element *elt, signed long int b)
{
  if(!(elt == ((struct soap_dom_element *)NULL)))
    elt->text = b != 0l ? "true" : "false";

  return elt;
}

// soap_elt_copy
// file dom.c line 1634
struct soap_dom_element * soap_elt_copy(struct soap_dom_element *elt, struct soap_dom_element *node)
{
  elt->nstr = node->nstr;
  elt->name = node->name;
  elt->lead = node->lead;
  elt->text = node->text;
  elt->code = node->code;
  elt->tail = node->tail;
  elt->node = node->node;
  elt->type = node->type;
  soap_add_atts(elt, node->atts);
  struct soap_dom_element *return_value_soap_add_elts_1;
  return_value_soap_add_elts_1=soap_add_elts(elt, node->elts);
  return return_value_soap_add_elts_1;
}

// soap_elt_depth
// file dom.c line 1936
unsigned long int soap_elt_depth(struct soap_dom_element *elt)
{
  unsigned long int n = (unsigned long int)0;
  for( ; !(elt == ((struct soap_dom_element *)NULL)); n = n + 1ul)
    elt = elt->prnt;
  return n;
}

// soap_elt_double
// file dom.c line 1560
struct soap_dom_element * soap_elt_double(struct soap_dom_element *elt, double x)
{
  const char *return_value_soap_double2s_1;
  return_value_soap_double2s_1=soap_double2s(elt->soap, x);
  struct soap_dom_element *return_value_soap_elt_text_2;
  return_value_soap_elt_text_2=soap_elt_text(elt, return_value_soap_double2s_1);
  return return_value_soap_elt_text_2;
}

// soap_elt_find
// file dom.c line 2823
struct soap_dom_element * soap_elt_find(struct soap_dom_element *elt, const char *ns, const char *patt)
{
  struct soap_dom_element *return_value_soap_elt_find_type_1;
  return_value_soap_elt_find_type_1=soap_elt_find_type(elt, ns, patt, 0);
  return return_value_soap_elt_find_type_1;
}

// soap_elt_find_next
// file dom.c line 2840
struct soap_dom_element * soap_elt_find_next(struct soap_dom_element *elt, const char *ns, const char *patt)
{
  struct soap_dom_element *return_value_soap_elt_find_next_type_1;
  return_value_soap_elt_find_next_type_1=soap_elt_find_next_type(elt, ns, patt, 0);
  return return_value_soap_elt_find_next_type_1;
}

// soap_elt_find_next_type
// file dom.c line 2891
struct soap_dom_element * soap_elt_find_next_type(struct soap_dom_element *elt, const char *ns, const char *patt, signed int type)
{
  signed int return_value_soap_patt_match_1;
  signed int return_value_soap_name_match_2;
  if(!(elt == ((struct soap_dom_element *)NULL)))
  {
    struct soap_dom_element *node;
    if(ns == ((const char *)NULL) && !(patt == ((const char *)NULL)))
      ns=soap_ns_to_find(elt->soap, patt);

    node = elt->next;
    for( ; !(node == ((struct soap_dom_element *)NULL)); node = node->next)
    {
      if(!(patt == ((const char *)NULL)))
      {
        return_value_soap_patt_match_1=soap_patt_match(node->name, patt);
        if(return_value_soap_patt_match_1 == 0)
          goto __CPROVER_DUMP_L12;

      }

      if(!(ns == ((const char *)NULL)))
      {
        _Bool tmp_if_expr_4;
        if(!(node->nstr == ((const char *)NULL)))
          tmp_if_expr_4 = (_Bool)1;

        else
          tmp_if_expr_4 = *ns != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_4)
        {
          _Bool tmp_if_expr_3;
          if(node->nstr == ((const char *)NULL))
            tmp_if_expr_3 = (_Bool)1;

          else
          {
            return_value_soap_name_match_2=soap_name_match(node->nstr, ns);
            tmp_if_expr_3 = !(return_value_soap_name_match_2 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_3)
            goto __CPROVER_DUMP_L12;

        }

      }

      if(!(type == 0))
      {
        if(type == node->type)
          goto __CPROVER_DUMP_L11;

      }

      else
      {

      __CPROVER_DUMP_L11:
        ;
        return node;
      }

    __CPROVER_DUMP_L12:
      ;
    }
  }

  return (struct soap_dom_element *)(void *)0;
}

// soap_elt_find_type
// file dom.c line 2858
struct soap_dom_element * soap_elt_find_type(struct soap_dom_element *elt, const char *ns, const char *patt, signed int type)
{
  signed int return_value_soap_patt_match_2;
  struct soap_dom_element *return_value_soap_elt_find_next_type_1;
  signed int return_value_soap_name_match_4;
  struct soap_dom_element *return_value_soap_elt_find_next_type_3;
  struct soap_dom_element *return_value_soap_elt_find_next_type_7;
  if(!(elt == ((struct soap_dom_element *)NULL)))
  {
    elt = elt->elts;
    if(!(elt == ((struct soap_dom_element *)NULL)))
    {
      if(ns == ((const char *)NULL) && !(patt == ((const char *)NULL)))
        ns=soap_ns_to_find(elt->soap, patt);

      if(!(patt == ((const char *)NULL)))
      {
        return_value_soap_patt_match_2=soap_patt_match(elt->name, patt);
        if(return_value_soap_patt_match_2 == 0)
        {
          return_value_soap_elt_find_next_type_1=soap_elt_find_next_type(elt, ns, patt, type);
          return return_value_soap_elt_find_next_type_1;
        }

      }

      if(!(ns == ((const char *)NULL)))
      {
        _Bool tmp_if_expr_6;
        if(!(elt->nstr == ((const char *)NULL)))
          tmp_if_expr_6 = (_Bool)1;

        else
          tmp_if_expr_6 = *ns != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_6)
        {
          _Bool tmp_if_expr_5;
          if(elt->nstr == ((const char *)NULL))
            tmp_if_expr_5 = (_Bool)1;

          else
          {
            return_value_soap_name_match_4=soap_name_match(elt->nstr, ns);
            tmp_if_expr_5 = !(return_value_soap_name_match_4 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_5)
          {
            return_value_soap_elt_find_next_type_3=soap_elt_find_next_type(elt, ns, patt, type);
            return return_value_soap_elt_find_next_type_3;
          }

        }

      }

      if(!(type == 0))
      {
        if(!(type == elt->type))
        {
          return_value_soap_elt_find_next_type_7=soap_elt_find_next_type(elt, ns, patt, type);
          return return_value_soap_elt_find_next_type_7;
        }

      }

    }

  }

  return elt;
}

// soap_elt_first
// file dom.c line 2562
struct soap_dom_element * soap_elt_first(struct soap_dom_element *elt)
{
  return elt->elts;
}

// soap_elt_get
// file dom.c line 2656
struct soap_dom_element * soap_elt_get(struct soap_dom_element *elt, const char *ns, const char *tag)
{
  _Bool tmp_if_expr_6;
  signed int return_value_soap_tag_match_5;
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(!(elt == ((struct soap_dom_element *)NULL)))
  {
    struct soap_dom_element *node;
    if(ns == ((const char *)NULL))
      ns=soap_ns_to_get(elt->soap, tag);

    node = elt->elts;
    for( ; !(node == ((struct soap_dom_element *)NULL)); node = node->next)
    {
      _Bool tmp_if_expr_7;
      if(tag == node->name)
        tmp_if_expr_7 = (_Bool)1;

      else
      {
        if(!(tag == ((const char *)NULL)))
        {
          return_value_soap_tag_match_5=soap_tag_match(node->name, tag);
          tmp_if_expr_6 = return_value_soap_tag_match_5 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_6 = (_Bool)0;
        tmp_if_expr_7 = tmp_if_expr_6 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_7)
      {
        _Bool tmp_if_expr_1;
        if(node->nstr == ((const char *)NULL))
          tmp_if_expr_1 = !(*ns != 0) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        _Bool tmp_if_expr_4;
        if(tmp_if_expr_1)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          if(!(node->nstr == ((const char *)NULL)))
          {
            return_value_strcmp_2=strcmp(node->nstr, ns);
            tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_3 = (_Bool)0;
          tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
          return node;

      }

    }
  }

  return (struct soap_dom_element *)(void *)0;
}

// soap_elt_get_LONG64
// file dom.c line 1825
signed long int soap_elt_get_LONG64(struct soap_dom_element *elt)
{
  signed int return_value_soap_s2LONG64_1;
  if(!(elt == ((struct soap_dom_element *)NULL)))
  {
    signed long int n;
    if(!(elt->text == ((const char *)NULL)))
    {
      return_value_soap_s2LONG64_1=soap_s2LONG64(elt->soap, elt->text, &n);
      if(return_value_soap_s2LONG64_1 == 0)
        return n;

    }

    elt->soap->error = 0;
  }

  return (signed long int)0;
}

// soap_elt_get_double
// file dom.c line 1847
double soap_elt_get_double(struct soap_dom_element *elt)
{
  signed int return_value_soap_s2double_1;
  if(!(elt == ((struct soap_dom_element *)NULL)))
  {
    double x;
    if(!(elt->text == ((const char *)NULL)))
    {
      return_value_soap_s2double_1=soap_s2double(elt->soap, elt->text, &x);
      if(return_value_soap_s2double_1 == 0)
        return x;

    }

    elt->soap->error = 0;
  }

  return soap_double_nan.dv;
}

// soap_elt_get_int
// file dom.c line 1781
signed int soap_elt_get_int(struct soap_dom_element *elt)
{
  signed int return_value_soap_s2int_1;
  if(!(elt == ((struct soap_dom_element *)NULL)))
  {
    signed int n;
    if(!(elt->text == ((const char *)NULL)))
    {
      return_value_soap_s2int_1=soap_s2int(elt->soap, elt->text, &n);
      if(return_value_soap_s2int_1 == 0)
        return n;

    }

    elt->soap->error = 0;
  }

  return 0;
}

// soap_elt_get_long
// file dom.c line 1803
signed long int soap_elt_get_long(struct soap_dom_element *elt)
{
  signed int return_value_soap_s2long_1;
  if(!(elt == ((struct soap_dom_element *)NULL)))
  {
    signed long int n;
    if(!(elt->text == ((const char *)NULL)))
    {
      return_value_soap_s2long_1=soap_s2long(elt->soap, elt->text, &n);
      if(return_value_soap_s2long_1 == 0)
        return n;

    }

    elt->soap->error = 0;
  }

  return (signed long int)0;
}

// soap_elt_get_next
// file dom.c line 2712
struct soap_dom_element * soap_elt_get_next(struct soap_dom_element *elt)
{
  _Bool tmp_if_expr_6;
  signed int return_value_soap_tag_match_5;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(!(elt == ((struct soap_dom_element *)NULL)))
  {
    const char *ns = elt->nstr;
    const char *tag = elt->name;
    struct soap_dom_element *node = elt->next;
    for( ; !(node == ((struct soap_dom_element *)NULL)); node = node->next)
    {
      _Bool tmp_if_expr_7;
      if(tag == node->name)
        tmp_if_expr_7 = (_Bool)1;

      else
      {
        if(!(tag == ((const char *)NULL)))
        {
          return_value_soap_tag_match_5=soap_tag_match(node->name, tag);
          tmp_if_expr_6 = return_value_soap_tag_match_5 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_6 = (_Bool)0;
        tmp_if_expr_7 = tmp_if_expr_6 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_7)
      {
        _Bool tmp_if_expr_4;
        if(ns == node->nstr)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          if(!(ns == ((const char *)NULL)))
            tmp_if_expr_1 = node->nstr != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_1 = (_Bool)0;
          if(tmp_if_expr_1)
          {
            return_value_strcmp_2=strcmp(node->nstr, ns);
            tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_3 = (_Bool)0;
          tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
          return node;

      }

    }
  }

  return (struct soap_dom_element *)(void *)0;
}

// soap_elt_get_node
// file dom.c line 1885
const void * soap_elt_get_node(struct soap_dom_element *elt, signed int type)
{
  _Bool tmp_if_expr_1;
  if(elt == ((struct soap_dom_element *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = elt->type != type ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return (void *)0;

  else
    return elt->node;
}

// soap_elt_get_ns
// file dom.c line 1717
const char * soap_elt_get_ns(struct soap_dom_element *elt)
{
  if(!(elt == ((struct soap_dom_element *)NULL)))
    return elt->nstr;

  else
    return (const char *)(void *)0;
}

// soap_elt_get_nth
// file dom.c line 2738
struct soap_dom_element * soap_elt_get_nth(struct soap_dom_element *elt, unsigned long int n)
{
  unsigned long int tmp_post_1;
  do
  {
    tmp_post_1 = n;
    n = n - 1ul;
    if(!(tmp_post_1 >= 2ul))
      break;

    elt=soap_elt_get_next(elt);
  }
  while((_Bool)1);
  return elt;
}

// soap_elt_get_tag
// file dom.c line 1734
const char * soap_elt_get_tag(struct soap_dom_element *elt)
{
  if(!(elt == ((struct soap_dom_element *)NULL)))
    return elt->name;

  else
    return (const char *)(void *)0;
}

// soap_elt_get_text
// file dom.c line 1869
const char * soap_elt_get_text(struct soap_dom_element *elt)
{
  if(!(elt == ((struct soap_dom_element *)NULL)))
    return elt->text;

  else
    return (const char *)(void *)0;
}

// soap_elt_get_type
// file dom.c line 1901
signed int soap_elt_get_type(struct soap_dom_element *elt, const void **node)
{
  if(elt == ((struct soap_dom_element *)NULL))
    return 0;

  else
  {
    *node = (const void *)&elt->node;
    return elt->type;
  }
}

// soap_elt_get_w
// file dom.c line 2683
struct soap_dom_element * soap_elt_get_w(struct soap_dom_element *elt, const char *ns, const signed int *tag)
{
  _Bool tmp_if_expr_7;
  signed int return_value_soap_tag_match_6;
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(!(elt == ((struct soap_dom_element *)NULL)))
  {
    const char *name;
    name=soap_wchar2s((struct soap *)(void *)0, tag);
    struct soap_dom_element *node;
    if(ns == ((const char *)NULL))
      ns=soap_ns_to_get(elt->soap, name);

    node = elt->elts;
    for( ; !(node == ((struct soap_dom_element *)NULL)); node = node->next)
    {
      _Bool tmp_if_expr_5;
      if(name == ((const char *)NULL))
        tmp_if_expr_5 = !(node->name != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      _Bool tmp_if_expr_8;
      if(tmp_if_expr_5)
        tmp_if_expr_8 = (_Bool)1;

      else
      {
        if(!(name == ((const char *)NULL)))
        {
          return_value_soap_tag_match_6=soap_tag_match(node->name, name);
          tmp_if_expr_7 = return_value_soap_tag_match_6 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_7 = (_Bool)0;
        tmp_if_expr_8 = tmp_if_expr_7 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_8)
      {
        _Bool tmp_if_expr_1;
        if(node->nstr == ((const char *)NULL))
          tmp_if_expr_1 = !(*ns != 0) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        _Bool tmp_if_expr_4;
        if(tmp_if_expr_1)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          if(!(node->nstr == ((const char *)NULL)))
          {
            return_value_strcmp_2=strcmp(node->nstr, ns);
            tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_3 = (_Bool)0;
          tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
          break;

      }

    }
    if(!(name == ((const char *)NULL)))
      free((void *)name);

    return node;
  }

  return (struct soap_dom_element *)(void *)0;
}

// soap_elt_index
// file dom.c line 1957
unsigned long int soap_elt_index(struct soap_dom_element *elt)
{
  unsigned long int n = (unsigned long int)0;
  if(!(elt == ((struct soap_dom_element *)NULL)))
  {
    if(!(elt->prnt == ((struct soap_dom_element *)NULL)))
    {
      struct soap_dom_element *node;
      n = n + 1ul;
      node = elt->prnt->elts;
      for( ; !(node == ((struct soap_dom_element *)NULL)) && !(node == elt); node = node->next)
        n = n + 1ul;
    }

  }

  return n;
}

// soap_elt_int
// file dom.c line 1544
struct soap_dom_element * soap_elt_int(struct soap_dom_element *elt, signed long int n)
{
  const char *return_value_soap_LONG642s_1;
  return_value_soap_LONG642s_1=soap_LONG642s(elt->soap, n);
  struct soap_dom_element *return_value_soap_elt_text_2;
  return_value_soap_elt_text_2=soap_elt_text(elt, return_value_soap_LONG642s_1);
  return return_value_soap_elt_text_2;
}

// soap_elt_is_false
// file dom.c line 1766
signed int soap_elt_is_false(struct soap_dom_element *elt)
{
  _Bool tmp_if_expr_4;
  signed int return_value_strcmp_1;
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(!(elt->text == ((const char *)NULL)))
  {
    return_value_strcmp_1=strcmp(elt->text, "false");
    if(return_value_strcmp_1 == 0)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_strcmp_2=strcmp(elt->text, "0");
      tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
    }
    tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_4 = (_Bool)0;
  return (signed int)tmp_if_expr_4;
}

// soap_elt_is_true
// file dom.c line 1751
signed int soap_elt_is_true(struct soap_dom_element *elt)
{
  _Bool tmp_if_expr_4;
  signed int return_value_strcmp_1;
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(!(elt->text == ((const char *)NULL)))
  {
    return_value_strcmp_1=strcmp(elt->text, "true");
    if(return_value_strcmp_1 == 0)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_strcmp_2=strcmp(elt->text, "1");
      tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
    }
    tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_4 = (_Bool)0;
  return (signed int)tmp_if_expr_4;
}

// soap_elt_len
// file dom.c line 1980
unsigned long int soap_elt_len(struct soap_dom_element *elt)
{
  unsigned long int n = (unsigned long int)0;
  if(!(elt == ((struct soap_dom_element *)NULL)))
  {
    if(!(elt->prnt == ((struct soap_dom_element *)NULL)))
    {
      struct soap_dom_element *node;
      node=soap_elt_get(elt->prnt, elt->nstr, elt->name);
      while(!(node == ((struct soap_dom_element *)NULL)))
      {
        n = n + 1ul;
        node=soap_elt_get_next(node);
      }
    }

  }

  return n;
}

// soap_elt_match
// file dom.c line 1664
signed int soap_elt_match(struct soap_dom_element *elt, const char *ns, const char *patt)
{
  _Bool tmp_if_expr_1;
  if(elt == ((struct soap_dom_element *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(elt->name != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
  signed int return_value_soap_patt_match_2;
  signed int return_value_soap_name_match_3;
  if(tmp_if_expr_1)
    return 0;

  else
  {
    if(ns == ((const char *)NULL) && !(patt == ((const char *)NULL)))
      ns=soap_ns_to_find(elt->soap, patt);

    if(!(patt == ((const char *)NULL)))
    {
      return_value_soap_patt_match_2=soap_patt_match(elt->name, patt);
      if(return_value_soap_patt_match_2 == 0)
        return 0;

    }

    if(!(ns == ((const char *)NULL)))
    {
      _Bool tmp_if_expr_5;
      if(!(elt->nstr == ((const char *)NULL)))
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = *ns != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
      {
        _Bool tmp_if_expr_4;
        if(elt->nstr == ((const char *)NULL))
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_soap_name_match_3=soap_name_match(elt->nstr, ns);
          tmp_if_expr_4 = !(return_value_soap_name_match_3 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
          return 0;

      }

    }

    return 1;
  }
}

// soap_elt_match_w
// file dom.c line 1689
signed int soap_elt_match_w(struct soap_dom_element *elt, const char *ns, const signed int *patt)
{
  const char *s;
  signed int r = 1;
  _Bool tmp_if_expr_1;
  if(elt == ((struct soap_dom_element *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(elt->name != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
  signed int return_value_soap_patt_match_5;
  signed int return_value_soap_name_match_2;
  if(tmp_if_expr_1)
    return 0;

  else
  {
    s=soap_wchar2s((struct soap *)(void *)0, patt);
    if(ns == ((const char *)NULL) && !(s == ((const char *)NULL)))
      ns=soap_ns_to_find(elt->soap, s);

    _Bool tmp_if_expr_6;
    if(!(s == ((const char *)NULL)))
    {
      return_value_soap_patt_match_5=soap_patt_match(elt->name, s);
      tmp_if_expr_6 = !(return_value_soap_patt_match_5 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_6 = (_Bool)0;
    if(tmp_if_expr_6)
      r = 0;

    else
      if(!(ns == ((const char *)NULL)))
      {
        _Bool tmp_if_expr_4;
        if(!(elt->nstr == ((const char *)NULL)))
          tmp_if_expr_4 = (_Bool)1;

        else
          tmp_if_expr_4 = *ns != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_4)
        {
          _Bool tmp_if_expr_3;
          if(elt->nstr == ((const char *)NULL))
            tmp_if_expr_3 = (_Bool)1;

          else
          {
            return_value_soap_name_match_2=soap_name_match(elt->nstr, ns);
            tmp_if_expr_3 = !(return_value_soap_name_match_2 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_3)
            r = 0;

        }

      }

    if(!(s == ((const char *)NULL)))
      free((void *)s);

    return r;
  }
}

// soap_elt_new
// file dom.c line 1112
struct soap_dom_element * soap_elt_new(struct soap *soap, const char *ns, const char *tag)
{
  struct soap_dom_element *return_value_new_element_1;
  return_value_new_element_1=new_element(soap);
  struct soap_dom_element *return_value_soap_elt_set_2;
  return_value_soap_elt_set_2=soap_elt_set(return_value_new_element_1, ns, tag);
  return return_value_soap_elt_set_2;
}

// soap_elt_new_w
// file dom.c line 1129
struct soap_dom_element * soap_elt_new_w(struct soap *soap, const char *ns, const signed int *tag)
{
  struct soap_dom_element *return_value_new_element_1;
  return_value_new_element_1=new_element(soap);
  struct soap_dom_element *return_value_soap_elt_set_w_2;
  return_value_soap_elt_set_w_2=soap_elt_set_w(return_value_new_element_1, ns, tag);
  return return_value_soap_elt_set_w_2;
}

// soap_elt_next
// file dom.c line 2577
struct soap_dom_element * soap_elt_next(struct soap_dom_element *elt)
{
  return elt->next;
}

// soap_elt_node
// file dom.c line 1613
struct soap_dom_element * soap_elt_node(struct soap_dom_element *elt, const void *node, signed int type)
{
  if(!(elt == ((struct soap_dom_element *)NULL)))
  {
    elt->node = node;
    elt->type = type;
  }

  return elt;
}

// soap_elt_nth
// file dom.c line 2002
unsigned long int soap_elt_nth(struct soap_dom_element *elt)
{
  unsigned long int n = (unsigned long int)0;
  struct soap_dom_element *return_value_soap_elt_get_next_1;
  if(!(elt == ((struct soap_dom_element *)NULL)))
  {
    if(!(elt->prnt == ((struct soap_dom_element *)NULL)))
    {
      struct soap_dom_element *node;
      node=soap_elt_get(elt->prnt, elt->nstr, elt->name);
      while(!(node == ((struct soap_dom_element *)NULL)) && !(node == elt))
      {
        n = n + 1ul;
        node=soap_elt_get_next(node);
      }
      if(!(node == ((struct soap_dom_element *)NULL)))
      {
        _Bool tmp_if_expr_2;
        if(n >= 1ul)
          tmp_if_expr_2 = (_Bool)1;

        else
        {
          return_value_soap_elt_get_next_1=soap_elt_get_next(node);
          tmp_if_expr_2 = return_value_soap_elt_get_next_1 != ((struct soap_dom_element *)NULL) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_2)
          n = n + 1ul;

      }

    }

  }

  return n;
}

// soap_elt_parent
// file dom.c line 1919
struct soap_dom_element * soap_elt_parent(struct soap_dom_element *elt)
{
  if(elt == ((struct soap_dom_element *)NULL))
    return (struct soap_dom_element *)(void *)0;

  else
    return elt->prnt;
}

// soap_elt_set
// file dom.c line 1146
struct soap_dom_element * soap_elt_set(struct soap_dom_element *elt, const char *ns, const char *tag)
{
  if(!(elt == ((struct soap_dom_element *)NULL)))
  {
    if(!(tag == ((const char *)NULL)))
    {
      if(*tag == 0)
        tag = (const char *)(void *)0;

    }

    elt->name=soap_strdup(elt->soap, tag);
    if(ns == ((const char *)NULL))
      elt->nstr=soap_ns_to_set(elt->soap, tag);

    else
      elt->nstr=soap_strdup(elt->soap, ns);
  }

  return elt;
}

// soap_elt_set_w
// file dom.c line 1173
struct soap_dom_element * soap_elt_set_w(struct soap_dom_element *elt, const char *ns, const signed int *tag)
{
  if(!(elt == ((struct soap_dom_element *)NULL)))
  {
    if(!(tag == ((const signed int *)NULL)))
    {
      if(*tag == 0)
        tag = (const signed int *)(void *)0;

    }

    elt->name=soap_wchar2s(elt->soap, tag);
    if(ns == ((const char *)NULL))
      elt->nstr=soap_ns_to_set(elt->soap, elt->name);

    else
      elt->nstr=soap_strdup(elt->soap, ns);
  }

  return elt;
}

// soap_elt_size
// file dom.c line 2956
unsigned long int soap_elt_size(struct soap_dom_element *elt, const char *ns, const char *patt)
{
  unsigned long int return_value_soap_elt_size_type_1;
  return_value_soap_elt_size_type_1=soap_elt_size_type(elt, ns, patt, 0);
  return return_value_soap_elt_size_type_1;
}

// soap_elt_size_type
// file dom.c line 2974
unsigned long int soap_elt_size_type(struct soap_dom_element *elt, const char *ns, const char *patt, signed int type)
{
  unsigned long int n = (unsigned long int)0;
  if(!(elt == ((struct soap_dom_element *)NULL)))
  {
    elt=soap_elt_find_type(elt, ns, patt, type);
    if(!(elt == ((struct soap_dom_element *)NULL)))
    {
      n = n + 1ul;
      do
      {
        elt=soap_elt_find_next_type(elt, ns, patt, type);
        if(elt == ((struct soap_dom_element *)NULL))
          break;

        n = n + 1ul;
      }
      while((_Bool)1);
    }

  }

  return n;
}

// soap_elt_text
// file dom.c line 1576
struct soap_dom_element * soap_elt_text(struct soap_dom_element *elt, const char *text)
{
  if(!(elt == ((struct soap_dom_element *)NULL)))
    elt->text=soap_strdup(elt->soap, text);

  return elt;
}

// soap_elt_text_w
// file dom.c line 1594
struct soap_dom_element * soap_elt_text_w(struct soap_dom_element *elt, const signed int *text)
{
  if(!(elt == ((struct soap_dom_element *)NULL)))
    elt->text=soap_wchar2s(elt->soap, text);

  return elt;
}

// soap_elt_w
// file dom.c line 1282
struct soap_dom_element * soap_elt_w(struct soap_dom_element *elt, const char *ns, const signed int *tag)
{
  struct soap_dom_element *node = (struct soap_dom_element *)(void *)0;
  signed int return_value_soap_tag_match_5;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(!(elt == ((struct soap_dom_element *)NULL)))
  {
    const char *name;
    name=soap_wchar2s(elt->soap, tag);
    struct soap_dom_element *last = (struct soap_dom_element *)(void *)0;
    const char *ns1 = ns;
    if(ns1 == ((const char *)NULL))
      ns1=soap_ns_to_set(elt->soap, name);

    node = elt->elts;
    for( ; !(node == ((struct soap_dom_element *)NULL)); node = node->next)
    {
      if(!(name == ((const char *)NULL)))
      {
        return_value_soap_tag_match_5=soap_tag_match(node->name, name);
        if(!(return_value_soap_tag_match_5 == 0))
        {
          _Bool tmp_if_expr_4;
          if(ns1 == node->nstr)
            tmp_if_expr_4 = (_Bool)1;

          else
          {
            if(!(ns1 == ((const char *)NULL)))
              tmp_if_expr_1 = node->nstr != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_1 = (_Bool)0;
            if(tmp_if_expr_1)
            {
              return_value_strcmp_2=strcmp(node->nstr, ns1);
              tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_3 = (_Bool)0;
            tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_4)
            return node;

        }

      }

      if(node->next == ((struct soap_dom_element *)NULL))
        last = node;

    }
    node=soap_elt_new(elt->soap, ns, name);
    if(!(node == ((struct soap_dom_element *)NULL)))
      node->prnt = elt;

    if(!(last == ((struct soap_dom_element *)NULL)))
      last->next = node;

    else
      elt->elts = node;
  }

  return node;
}

// soap_embed
// file stdsoap2.c line 7509
signed int soap_embed(struct soap *soap, const void *p, const void *a, signed int n, signed int t)
{
  signed int id;
  struct soap_plist *pp;
  if((signed int)soap->version == 2)
    soap->encoding = (signed short int)1;

  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  if(p == NULL)
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    if(soap->encodingStyle == ((const char *)NULL))
      tmp_if_expr_1 = !((soap->omode & 0x20000000) != 0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = (soap->omode & 0x00020000) != 0 ? (_Bool)1 : (_Bool)0;
  signed int return_value_soap_is_single_5;
  if(tmp_if_expr_3)
    return 0;

  else
  {
    if(!(a == NULL))
      id=soap_array_pointer_lookup(soap, p, a, n, t, &pp);

    else
      id=soap_pointer_lookup(soap, p, t, &pp);
    if(!(id == 0))
    {
      signed int return_value_soap_is_embedded_4;
      return_value_soap_is_embedded_4=soap_is_embedded(soap, pp);
      _Bool tmp_if_expr_6;
      if(!(return_value_soap_is_embedded_4 == 0))
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        return_value_soap_is_single_5=soap_is_single(soap, pp);
        tmp_if_expr_6 = return_value_soap_is_single_5 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_6)
        return 0;

      soap_set_embedded(soap, pp);
    }

    return id;
  }
}

// soap_embedded
// file ../../../gsoap/stdsoap2.h line 2977
void soap_embedded(struct soap *soap, const void *p, signed int t)
{
  struct soap_plist *pp;
  signed int return_value_soap_pointer_lookup_1;
  return_value_soap_pointer_lookup_1=soap_pointer_lookup(soap, p, t, &pp);
  if(!(return_value_soap_pointer_lookup_1 == 0))
  {
    pp->mark1 = (char)1;
    pp->mark2 = (char)1;
  }

}

// soap_embedded_id
// file ../../../gsoap/stdsoap2.h line 2980
signed int soap_embedded_id(struct soap *soap, signed int id, const void *p, signed int t)
{
  struct soap_plist *pp = (struct soap_plist *)(void *)0;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  if(id >= 0)
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    if(soap->encodingStyle == ((const char *)NULL))
      tmp_if_expr_1 = !((soap->omode & 0x20000000) != 0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = (soap->omode & 0x00020000) != 0 ? (_Bool)1 : (_Bool)0;
  signed int return_value_soap_embed_4;
  if(tmp_if_expr_3)
    return id;

  else
  {
    if(!(id >= -1))
    {
      return_value_soap_embed_4=soap_embed(soap, p, (void *)0, 0, t);
      return return_value_soap_embed_4;
    }

    if(!(id >= 0))
    {
      id=soap_pointer_lookup(soap, p, t, &pp);
      _Bool tmp_if_expr_5;
      if((signed int)soap->version == 1)
        tmp_if_expr_5 = (signed int)soap->part != 3 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      if(tmp_if_expr_5)
      {
        if(!(id == 0))
        {
          if(!((0x00000008 & soap->mode) == 0))
            pp->mark1 = (char)2;

          else
            pp->mark2 = (char)2;
        }

        return -1;
      }

      else
        if(!(id == 0))
        {
          if(!((0x00000008 & soap->mode) == 0))
            pp->mark1 = (char)1;

          else
            pp->mark2 = (char)1;
        }

    }

    return id;
  }
}

// soap_encode_url
// file stdsoap2.c line 6653
unsigned long int soap_encode_url(const char *s, char *t, unsigned long int len)
{
  signed int c;
  unsigned long int n = len;
  const char *tmp_post_1;
  char *return_value_strchr_6;
  do
  {
    tmp_post_1 = s;
    s = s + 1l;
    c = (signed int)*tmp_post_1;
    if(c == 0)
      break;

    n = n - 1ul;
    if(!(n >= 1ul))
      break;

    _Bool tmp_if_expr_7;
    if(c >= 33 && !(c >= 128))
    {
      return_value_strchr_6=strchr("()<>@,;:\\\"/[]?={}#!_&'*+", c);
      tmp_if_expr_7 = !(return_value_strchr_6 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_7 = (_Bool)0;
    if(tmp_if_expr_7)
    {
      char *tmp_post_2 = t;
      t = t + 1l;
      *tmp_post_2 = (char)c;
    }

    else
      if(n >= 3ul)
      {
        char *tmp_post_3 = t;
        t = t + 1l;
        *tmp_post_3 = (char)37;
        char *tmp_post_4 = t;
        t = t + 1l;
        *tmp_post_4 = (char)((c >> 4) + (c > 159 ? 55 : 48));
        c = c & 0xF;
        char *tmp_post_5 = t;
        t = t + 1l;
        *tmp_post_5 = (char)(c + (c > 9 ? 55 : 48));
        n = n - (unsigned long int)2;
      }

      else
        break;
  }
  while((_Bool)1);
  *t = (char)0;
  return len - n;
}

// soap_encode_url_string
// file stdsoap2.c line 6680
const char * soap_encode_url_string(struct soap *soap, const char *s)
{
  if(!(s == ((const char *)NULL)))
  {
    unsigned long int n;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(s);
    n = (unsigned long int)3 * return_value_strlen_1 + (unsigned long int)1;
    char *t;
    void *return_value_soap_malloc_2;
    return_value_soap_malloc_2=soap_malloc(soap, n);
    t = (char *)return_value_soap_malloc_2;
    if(!(t == ((char *)NULL)))
    {
      soap_encode_url(s, t, n);
      return t;
    }

  }

  return soap_padding;
}

// soap_end
// file ../../../gsoap/stdsoap2.h line 3052
void soap_end(struct soap *soap)
{
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  if(soap == ((struct soap *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    if(!((signed int)soap->state == 1))
      tmp_if_expr_1 = (signed int)soap->state != 2 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
  }
  if(!tmp_if_expr_2)
  {
    soap_free_temp(soap);
    soap_dealloc(soap, (void *)0);
    while(!(soap->clist == ((struct soap_clist *)NULL)))
    {
      struct soap_clist *cp = soap->clist->next;
      free((void *)soap->clist);
      soap->clist = cp;
    }
    soap_closesock(soap);
  }

}

// soap_end_block
// file ../../../gsoap/stdsoap2.h line 3132
void soap_end_block(struct soap *soap, struct soap_blist *b)
{
  struct soap_bhead *p;
  struct soap_bhead *q;
  if(b == ((struct soap_blist *)NULL))
    b = soap->blist;

  if(!(b == ((struct soap_blist *)NULL)))
  {
    p = b->head;
    for( ; !(p == ((struct soap_bhead *)NULL)); p = q)
    {
      q = p->next;
      free((void *)p);
    }
    if(soap->blist == b)
      soap->blist = b->next;

    else
    {
      struct soap_blist *bp = soap->blist;
      for( ; !(bp == ((struct soap_blist *)NULL)); bp = bp->next)
        if(bp->next == b)
        {
          bp->next = b->next;
          break;
        }

    }
    free((void *)b);
  }

}

// soap_end_count
// file stdsoap2.c line 7695
signed int soap_end_count(struct soap *soap)
{
  if(!((0x00000008 & soap->mode) == 0))
  {
    if(soap->fpreparefinalsend == ((signed int (*)(struct soap *))NULL))
      goto __CPROVER_DUMP_L1;

    soap->error=soap->fpreparefinalsend(soap);
    return soap->error;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 0;
  }
}

// soap_end_recv
// file ../../../gsoap/stdsoap2.h line 3006
signed int soap_end_recv(struct soap *soap)
{
  soap->part = (signed short int)9;
  soap->wsuid = (const char *)(void *)0;
  soap->c14nexclude = (const char *)(void *)0;
  soap->c14ninclude = (const char *)(void *)0;
  soap->ffilterrecv = (signed int (*)(struct soap *, char *, unsigned long int *, unsigned long int))(void *)0;
  signed int return_value_soap_getdime_1;
  if(!((0x00000080 & soap->mode) == 0))
  {
    return_value_soap_getdime_1=soap_getdime(soap);
    if(!(return_value_soap_getdime_1 == 0))
    {
      soap->dime.first = (struct soap_multipart *)(void *)0;
      soap->dime.last = (struct soap_multipart *)(void *)0;
      return soap->error;
    }

  }

  soap->dime.list = soap->dime.first;
  soap->dime.first = (struct soap_multipart *)(void *)0;
  soap->dime.last = (struct soap_multipart *)(void *)0;
  if(!((0x00000100 & soap->mode) == 0))
  {
    if(!((0x40000000 & soap->mode) == 0))
    {
      if(soap->keep_alive == 0)
        soap->keep_alive = (signed short int)-1;

      soap_resolve(soap);
      return 0;
    }

    signed int return_value_soap_getmime_2;
    return_value_soap_getmime_2=soap_getmime(soap);
    if(!(return_value_soap_getmime_2 == 0))
      return soap->error;

  }

  soap->mime.list = soap->mime.first;
  soap->mime.first = (struct soap_multipart *)(void *)0;
  soap->mime.last = (struct soap_multipart *)(void *)0;
  soap->mime.boundary = (char *)(void *)0;
  if(!(soap->xlist == ((struct soap_xlist *)NULL)))
  {
    struct soap_multipart *content = soap->mime.list;
    for( ; !(content == ((struct soap_multipart *)NULL)); content = content->next)
      soap_resolve_attachment(soap, content);
  }

  signed int return_value_soap_recv_raw_3;
  if((0x00000003 & soap->mode) == 0x00000003)
    while(!(soap->ahead == -1))
    {
      return_value_soap_recv_raw_3=soap_recv_raw(soap);
      if(!(return_value_soap_recv_raw_3 == 0))
        break;

    }

  signed int return_value_soap_resolve_4;
  return_value_soap_resolve_4=soap_resolve(soap);
  if(!(return_value_soap_resolve_4 == 0))
    return soap->error;

  else
    if(!(soap->xlist == ((struct soap_xlist *)NULL)))
    {
      if(!((0x00000200 & soap->mode) == 0))
      {
        soap->error = 37;
        return soap->error;
      }

      soap->error = 33;
      return soap->error;
    }

    else
    {
      soap_free_ns(soap);
      if(!(soap->fpreparefinalrecv == ((signed int (*)(struct soap *))NULL)))
      {
        soap->error=soap->fpreparefinalrecv(soap);
        return soap->error;
      }

      else
        return 0;
    }
}

// soap_end_send
// file ../../../gsoap/stdsoap2.h line 2994
signed int soap_end_send(struct soap *soap)
{
  signed int err;
  if(!(soap->dime.list == ((struct soap_multipart *)NULL)))
  {
    soap->dime.last->next = soap->dime.first;
    soap->dime.first = soap->dime.list->next;
    soap->dime.list->next = (struct soap_multipart *)(void *)0;
    soap->dime.last = soap->dime.list;
  }

  err=soap_putdime(soap);
  if(err == 0)
    err=soap_putmime(soap);

  soap->mime.list = (struct soap_multipart *)(void *)0;
  soap->mime.first = (struct soap_multipart *)(void *)0;
  soap->mime.last = (struct soap_multipart *)(void *)0;
  soap->dime.list = (struct soap_multipart *)(void *)0;
  soap->dime.first = (struct soap_multipart *)(void *)0;
  soap->dime.last = (struct soap_multipart *)(void *)0;
  if(!(err == 0))
    return err;

  else
  {
    signed int return_value_soap_end_send_flush_1;
    return_value_soap_end_send_flush_1=soap_end_send_flush(soap);
    return return_value_soap_end_send_flush_1;
  }
}

// soap_end_send_flush
// file stdsoap2.c line 8936
signed int soap_end_send_flush(struct soap *soap)
{
  signed int return_value_soap_flush_3;
  if(!((0x00000003 & soap->mode) == 0))
  {
    signed int return_value_soap_flush_1;
    return_value_soap_flush_1=soap_flush(soap);
    if(!(return_value_soap_flush_1 == 0))
      return soap->error;

    if((0x00000003 & soap->mode) == 0x00000002)
    {
      if(!(soap->os == ((const char **)NULL)))
      {
        char *b;
        void *return_value_soap_push_block_2;
        return_value_soap_push_block_2=soap_push_block(soap, (struct soap_blist *)(void *)0, (unsigned long int)1);
        b = (char *)return_value_soap_push_block_2;
        if(!(b == ((char *)NULL)))
          *soap->os=soap_save_block(soap, (struct soap_blist *)(void *)0, (char *)(void *)0, 0);

      }

      else
      {
        char *p;
        if((0x00000040 & soap->mode) == 0)
        {
          soap->mode = soap->mode - 1;
          if(soap->status >= 2000)
            soap->error=soap->fpost(soap, soap->endpoint, soap->host, soap->port, soap->path, soap->action, soap->blist->size);

          else
            if(!(soap->status == 1000))
              soap->error=soap->fresponse(soap, soap->status, soap->blist->size);

          _Bool tmp_if_expr_4;
          if(!(soap->error == 0))
            tmp_if_expr_4 = (_Bool)1;

          else
          {
            return_value_soap_flush_3=soap_flush(soap);
            tmp_if_expr_4 = return_value_soap_flush_3 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_4)
            return soap->error;

          soap->mode = soap->mode + 1;
        }

        p=soap_first_block(soap, (struct soap_blist *)(void *)0);
        if(!(p == ((char *)NULL)))
        {
          unsigned long int return_value_soap_block_size_5;
          return_value_soap_block_size_5=soap_block_size(soap, (struct soap_blist *)(void *)0);
          soap->error=soap->fsend(soap, p, return_value_soap_block_size_5);
          if(!(soap->error == 0))
          {
            soap_end_block(soap, (struct soap_blist *)(void *)0);
            return soap->error;
          }

          p=soap_next_block(soap, (struct soap_blist *)(void *)0);
        }

        soap_end_block(soap, (struct soap_blist *)(void *)0);
      }
      if(!(soap->fpreparefinalsend == ((signed int (*)(struct soap *))NULL)))
      {
        soap->error=soap->fpreparefinalsend(soap);
        if(!(soap->error == 0))
          return soap->error;

      }

    }

    else
      if((0x00000003 & soap->mode) == 0x00000003)
      {
        soap->error=soap->fsend(soap, "\r\n0\r\n\r\n", (unsigned long int)7);
        if(!(soap->error == 0))
          return soap->error;

      }

  }

  soap->omode = soap->omode & (signed int)~0x80000000;
  soap->count = (unsigned long int)0;
  soap->part = (signed short int)9;
  return 0;
}

// soap_end_shaky
// file stdsoap2.c line 8603
void soap_end_shaky(struct soap *soap, signed short int f)
{
  soap->shaky = f;
}

// soap_enter
// file stdsoap2.c line 8153
struct soap_ilist * soap_enter(struct soap *soap, const char *id, signed int t, unsigned long int n)
{
  unsigned long int h;
  struct soap_ilist *ip;
  unsigned long int l;
  l=strlen(id);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct soap_ilist) /*80ul*/  + l);
  ip = (struct soap_ilist *)return_value_malloc_1;
  if(!(ip == ((struct soap_ilist *)NULL)))
  {
    ip->type = t;
    ip->size = n;
    ip->ptr = (void *)0;
    ip->spine = (void **)(void *)0;
    ip->link = (void *)0;
    ip->copy = (void *)0;
    ip->flist = (struct soap_flist *)(void *)0;
    ip->smart = (void *)0;
    ip->shaky = (signed short int)0;
    if(1ul + l >= 1ul)
    {
      strncpy((char *)ip->id, id, (l + (unsigned long int)1) - (unsigned long int)1);
      ((char *)ip->id)[(signed long int)((l + (unsigned long int)1) - (unsigned long int)1)] = (char)0;
      if(!(ip->id[(signed long int)l] == 0))
        (_Bool)1;

      else
        (_Bool)0;
    }

    else
      (_Bool)0;
    h=soap_hash(id);
    ip->next = soap->iht[(signed long int)h];
    soap->iht[(signed long int)h] = ip;
  }

  return ip;
}

// soap_envelope_begin_in
// file stdsoap2.c line 16923
signed int soap_envelope_begin_in(struct soap *soap)
{
  soap->part = (signed short int)2;
  signed int return_value_soap_element_begin_in_4;
  return_value_soap_element_begin_in_4=soap_element_begin_in(soap, "SOAP-ENV:Envelope", 0, (const char *)(void *)0);
  _Bool tmp_if_expr_1;
  if(!(return_value_soap_element_begin_in_4 == 0))
  {
    if(soap->error == 3)
    {
      signed int return_value_soap_element_begin_in_3;
      return_value_soap_element_begin_in_3=soap_element_begin_in(soap, "Envelope", 0, (const char *)(void *)0);
      if(return_value_soap_element_begin_in_3 == 0)
        soap->error = 39;

      else
      {
        _Bool tmp_if_expr_2;
        if(soap->status == 0)
          tmp_if_expr_2 = (_Bool)1;

        else
        {
          if(soap->status >= 200)
            tmp_if_expr_1 = soap->status <= 299 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_1 = (_Bool)0;
          tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_2)
          return 0;

      }
      soap->error = soap->status;
    }

    else
      if(!(soap->status == 0))
        soap->error = soap->status;

    return soap->error;
  }

  else
  {
    soap_get_version(soap);
    return 0;
  }
}

// soap_envelope_begin_out
// file stdsoap2.c line 16768
signed int soap_envelope_begin_out(struct soap *soap)
{
  unsigned long int n = (unsigned long int)0;
  if(!((0x00000100 & soap->mode) == 0))
  {
    if(!(soap->mime.boundary == ((char *)NULL)))
    {
      if(!(soap->mime.start == ((const char *)NULL)))
      {
        const char *s;
        unsigned long int return_value_strlen_1;
        return_value_strlen_1=strlen(soap->mime.boundary);
        unsigned long int return_value_strlen_2;
        return_value_strlen_2=strlen(soap->mime.start);
        if(140ul + return_value_strlen_1 + return_value_strlen_2 >= 1025ul)
        {
          soap->error = 20;
          return soap->error;
        }

        _Bool tmp_if_expr_3;
        if(!((0x00000080 & soap->mode) == 0))
          tmp_if_expr_3 = !((soap->mode & 0x00000200) != 0) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_3 = (_Bool)0;
        if(tmp_if_expr_3)
          s = "application/dime";

        else
          if((signed int)soap->version == 2)
          {
            if(!((0x00000200 & soap->mode) == 0))
              s = "application/xop+xml; charset=utf-8; type=\"application/soap+xml\"";

            else
              s = "application/soap+xml; charset=utf-8";
          }

          else
            if(!((0x00000200 & soap->mode) == 0))
              s = "application/xop+xml; charset=utf-8; type=\"text/xml\"";

            else
              s = "text/xml; charset=utf-8";
        snprintf(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , "--%s\r\nContent-Type: %s\r\nContent-Transfer-Encoding: binary\r\nContent-ID: %s\r\n\r\n", soap->mime.boundary, s, soap->mime.start);
        n=strlen(soap->tmpbuf);
        signed int return_value_soap_send_raw_4;
        return_value_soap_send_raw_4=soap_send_raw(soap, soap->tmpbuf, n);
        if(!(return_value_soap_send_raw_4 == 0))
          return soap->error;

      }

    }

  }

  if(!((0x00000008 & soap->mode) == 0))
    soap->dime.size = soap->count;

  if((0x00000008 & soap->mode) == 0)
  {
    if(!((0x00000080 & soap->mode) == 0))
    {
      signed int return_value_soap_putdimehdr_5;
      return_value_soap_putdimehdr_5=soap_putdimehdr(soap);
      if(!(return_value_soap_putdimehdr_5 == 0))
        return soap->error;

    }

  }

  if((signed int)soap->version == 0)
    return 0;

  else
  {
    soap->part = (signed short int)2;
    signed int return_value_soap_element_begin_out_6;
    return_value_soap_element_begin_out_6=soap_element_begin_out(soap, "SOAP-ENV:Envelope", 0, (const char *)(void *)0);
    return return_value_soap_element_begin_out_6;
  }
}

// soap_envelope_end_in
// file stdsoap2.c line 16948
signed int soap_envelope_end_in(struct soap *soap)
{
  if((signed int)soap->version == 0)
    return 0;

  else
  {
    soap->part = (signed short int)8;
    signed int return_value_soap_element_end_in_1;
    return_value_soap_element_end_in_1=soap_element_end_in(soap, "SOAP-ENV:Envelope");
    return return_value_soap_element_end_in_1;
  }
}

// soap_envelope_end_out
// file stdsoap2.c line 16813
signed int soap_envelope_end_out(struct soap *soap)
{
  signed int return_value_soap_send_raw_2;
  unsigned long int return_value_strlen_5;
  signed int return_value_soap_send_raw_7;
  if((signed int)soap->version == 0)
    return 0;

  else
  {
    signed int return_value_soap_element_end_out_1;
    return_value_soap_element_end_out_1=soap_element_end_out(soap, "SOAP-ENV:Envelope");
    _Bool tmp_if_expr_3;
    if(!(return_value_soap_element_end_out_1 == 0))
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_soap_send_raw_2=soap_send_raw(soap, "\r\n", (unsigned long int)2);
      tmp_if_expr_3 = return_value_soap_send_raw_2 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      return soap->error;

    else
    {
      if(!((0x00000008 & soap->mode) == 0))
      {
        if(!((0x00000080 & soap->mode) == 0))
        {
          if((0x00000200 & soap->mode) == 0)
          {
            soap->dime.size = soap->count - soap->dime.size;
            snprintf(soap->id, sizeof(char [1024l]) /*1024ul*/ , soap->dime_id_format, 0);
            soap->dime.id = soap->id;
            if(!(soap->local_namespaces == ((struct Namespace *)NULL)))
            {
              if(!(soap->local_namespaces->out == ((char *)NULL)))
                soap->dime.type = (char *)(soap->local_namespaces + (signed long int)0)->out;

              else
                soap->dime.type = (char *)(soap->local_namespaces + (signed long int)0)->ns;
            }

            soap->dime.options = (const char *)(void *)0;
            soap->dime.flags = (char)(0x04 | 0x20);
            if(soap->dime.first == ((struct soap_multipart *)NULL))
              soap->dime.flags = soap->dime.flags | (char)0x02;

            unsigned long int return_value_strlen_4;
            return_value_strlen_4=strlen(soap->dime.id);
            unsigned long int tmp_if_expr_6;
            if(!(soap->dime.type == ((const char *)NULL)))
            {
              return_value_strlen_5=strlen(soap->dime.type);
              tmp_if_expr_6 = return_value_strlen_5 + (unsigned long int)3 & (unsigned long int)~3;
            }

            else
              tmp_if_expr_6 = (unsigned long int)0;
            soap->count = soap->count + (unsigned long int)12 + (return_value_strlen_4 + (unsigned long int)3 & (unsigned long int)~3) + tmp_if_expr_6;
          }

        }

      }

      if(!((0x00000080 & soap->mode) == 0))
      {
        if((0x00000200 & soap->mode) == 0)
        {
          return_value_soap_send_raw_7=soap_send_raw(soap, soap_padding, (unsigned long int)(-((signed long int)soap->dime.size) & (signed long int)3));
          return return_value_soap_send_raw_7;
        }

      }

      soap->part = (signed short int)8;
      return 0;
    }
  }
}

// soap_fault
// file soapC.c line 63
void soap_fault(struct soap *soap)
{
  if(soap->fault == ((struct SOAP_ENV__Fault *)NULL))
  {
    void *return_value_soap_malloc_1;
    return_value_soap_malloc_1=soap_malloc(soap, sizeof(struct SOAP_ENV__Fault) /*72ul*/ );
    soap->fault = (struct SOAP_ENV__Fault *)return_value_soap_malloc_1;
    if(soap->fault == ((struct SOAP_ENV__Fault *)NULL))
      goto __CPROVER_DUMP_L4;

    soap_default_SOAP_ENV__Fault(soap, soap->fault);
  }

  if((signed int)soap->version == 2)
  {
    if(soap->fault->SOAP_ENV__Code == ((struct SOAP_ENV__Code *)NULL))
    {
      void *return_value_soap_malloc_2;
      return_value_soap_malloc_2=soap_malloc(soap, sizeof(struct SOAP_ENV__Code) /*16ul*/ );
      soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code *)return_value_soap_malloc_2;
      soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
    }

  }

  if((signed int)soap->version == 2)
  {
    if(soap->fault->SOAP_ENV__Reason == ((struct SOAP_ENV__Reason *)NULL))
    {
      void *return_value_soap_malloc_3;
      return_value_soap_malloc_3=soap_malloc(soap, sizeof(struct SOAP_ENV__Reason) /*8ul*/ );
      soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason *)return_value_soap_malloc_3;
      soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
    }

  }


__CPROVER_DUMP_L4:
  ;
}

// soap_faultcode
// file soapC.c line 99
const char ** soap_faultcode(struct soap *soap)
{
  soap_fault(soap);
  if((signed int)soap->version == 2)
  {
    if(soap->fault->SOAP_ENV__Code == ((struct SOAP_ENV__Code *)NULL))
      goto __CPROVER_DUMP_L1;

    return (const char **)(void *)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return (const char **)(void *)&soap->fault->faultcode;
  }
}

// soap_faultdetail
// file soapC.c line 139
const char ** soap_faultdetail(struct soap *soap)
{
  soap_fault(soap);
  if((signed int)soap->version == 2)
  {
    if(soap->fault->SOAP_ENV__Detail == ((struct SOAP_ENV__Detail *)NULL))
    {
      void *return_value_soap_malloc_1;
      return_value_soap_malloc_1=soap_malloc(soap, sizeof(struct SOAP_ENV__Detail) /*24ul*/ );
      soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail *)return_value_soap_malloc_1;
      soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
    }

    return (const char **)(void *)&soap->fault->SOAP_ENV__Detail->__any;
  }

  else
  {
    if(soap->fault->detail == ((struct SOAP_ENV__Detail *)NULL))
    {
      void *return_value_soap_malloc_2;
      return_value_soap_malloc_2=soap_malloc(soap, sizeof(struct SOAP_ENV__Detail) /*24ul*/ );
      soap->fault->detail = (struct SOAP_ENV__Detail *)return_value_soap_malloc_2;
      soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
    }

    return (const char **)(void *)&soap->fault->detail->__any;
  }
}

// soap_faultstring
// file soapC.c line 131
const char ** soap_faultstring(struct soap *soap)
{
  soap_fault(soap);
  if((signed int)soap->version == 2)
    return (const char **)(void *)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;

  else
    return (const char **)(void *)&soap->fault->faultstring;
}

// soap_faultsubcode
// file soapC.c line 107
const char ** soap_faultsubcode(struct soap *soap)
{
  soap_fault(soap);
  if((signed int)soap->version == 2)
  {
    if(soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == ((struct SOAP_ENV__Code *)NULL))
    {
      void *return_value_soap_malloc_1;
      return_value_soap_malloc_1=soap_malloc(soap, sizeof(struct SOAP_ENV__Code) /*16ul*/ );
      soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code *)return_value_soap_malloc_1;
      soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
    }

    return (const char **)(void *)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
  }

  else
    return (const char **)(void *)&soap->fault->faultcode;
}

// soap_first_block
// file ../../../gsoap/stdsoap2.h line 3128
char * soap_first_block(struct soap *soap, struct soap_blist *b)
{
  struct soap_bhead *p;
  struct soap_bhead *q;
  struct soap_bhead *r;
  if(b == ((struct soap_blist *)NULL))
    b = soap->blist;

  p = b->head;
  if(p == ((struct soap_bhead *)NULL))
    return (char *)(void *)0;

  else
  {
    r = (struct soap_bhead *)(void *)0;
    do
    {
      q = p->next;
      p->next = r;
      r = p;
      p = q;
    }
    while(!(p == ((struct soap_bhead *)NULL)));
    b->head = r;
    return (char *)(r + (signed long int)1);
  }
}

// soap_float2s
// file stdsoap2.c line 13362
const char * soap_float2s(struct soap *soap, float n)
{
  char *s;
  signed int return_value___isnan_1;
  return_value___isnan_1=__isnan((double)n);
  signed int return_value___isinff_2;
  signed int return_value___isinff_3;
  if(!(return_value___isnan_1 == 0))
    return "NaN";

  else
  {
    if(n > 0.000000f)
    {
      return_value___isinff_2=__isinff(n);
      if(!(return_value___isinff_2 == 0))
        return "INF";

    }

    if(n < 0.000000f)
    {
      return_value___isinff_3=__isinff(n);
      if(!(return_value___isinff_3 == 0))
        return "-INF";

    }

    snprintf(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , soap->float_format, n);
    s=strchr(soap->tmpbuf, 44);
    if(!(s == ((char *)NULL)))
      *s = (char)46;

    return soap->tmpbuf;
  }
}

// soap_flush
// file ../../../gsoap/stdsoap2.h line 2935
signed int soap_flush(struct soap *soap)
{
  unsigned long int n = soap->bufidx;
  if(!(n == 0ul))
  {
    if((0x00000003 & soap->mode) == 0x00000002)
    {
      signed int r;
      if(!(soap->fpreparesend == ((signed int (*)(struct soap *, const char *, unsigned long int))NULL)))
      {
        r=soap->fpreparesend(soap, soap->buf, n);
        if(!(r == 0))
        {
          soap->error = r;
          return soap->error;
        }

      }

    }

    soap->bufidx = (unsigned long int)0;
    signed int return_value_soap_flush_raw_1;
    return_value_soap_flush_raw_1=soap_flush_raw(soap, soap->buf, n);
    return return_value_soap_flush_raw_1;
  }

  return 0;
}

// soap_flush_raw
// file stdsoap2.c line 852
signed int soap_flush_raw(struct soap *soap, const char *s, unsigned long int n)
{
  void *return_value_memcpy_1;
  if((0x00000003 & soap->mode) == 0x00000002)
  {
    void *soap_flush_raw__1__1__t;
    soap_flush_raw__1__1__t=soap_push_block(soap, (struct soap_blist *)(void *)0, n);
    if(soap_flush_raw__1__1__t == NULL)
    {
      soap->error = 20;
      return soap->error;
    }

    if(!(soap_flush_raw__1__1__t == NULL))
    {
      return_value_memcpy_1=memcpy(soap_flush_raw__1__1__t, (const void *)s, n);
      (signed int)!(return_value_memcpy_1 != NULL);
    }

    else
      34;
    return 0;
  }

  if((0x00000003 & soap->mode) == 0x00000003)
  {
    char t[24l];
    snprintf(t, sizeof(char [24l]) /*24ul*/ , &"\r\n%lX\r\n"[(signed long int)(soap->chunksize != 0ul ? 0 : 2)], (unsigned long int)n);
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(t);
    soap->error=soap->fsend(soap, t, return_value_strlen_2);
    if(!(soap->error == 0))
      return soap->error;

    soap->chunksize = soap->chunksize + n;
  }

  soap->error=soap->fsend(soap, s, n);
  return soap->error;
}

// soap_force_closesock
// file stdsoap2.c line 5668
signed int soap_force_closesock(struct soap *soap)
{
  soap->keep_alive = (signed short int)0;
  signed int return_value_close_1;
  if(!(soap->socket == -1))
  {
    return_value_close_1=close(soap->socket);
    return return_value_close_1;
  }

  return 0;
}

// soap_free
// file ../../../gsoap/stdsoap2.h line 3042
void soap_free(struct soap *soap)
{
  soap_done(soap);
  free((void *)soap);
}

// soap_free_iht
// file stdsoap2.c line 8109
static void soap_free_iht(struct soap *soap)
{
  signed int i;
  struct soap_ilist *ip = (struct soap_ilist *)(void *)0;
  struct soap_ilist *p = (struct soap_ilist *)(void *)0;
  struct soap_flist *fp = (struct soap_flist *)(void *)0;
  struct soap_flist *fq = (struct soap_flist *)(void *)0;
  i = 0;
  for( ; !(i >= 1999); i = i + 1)
  {
    ip = soap->iht[(signed long int)i];
    for( ; !(ip == ((struct soap_ilist *)NULL)); ip = p)
    {
      fp = ip->flist;
      for( ; !(fp == ((struct soap_flist *)NULL)); fp = fq)
      {
        fq = fp->next;
        free((void *)fp);
      }
      p = ip->next;
      free((void *)ip);
    }
    soap->iht[(signed long int)i] = (struct soap_ilist *)(void *)0;
  }
}

// soap_free_ns
// file stdsoap2.c line 9226
static void soap_free_ns(struct soap *soap)
{
  struct soap_nlist *np;
  struct soap_nlist *nq;
  np = soap->nlist;
  for( ; !(np == ((struct soap_nlist *)NULL)); np = nq)
  {
    nq = np->next;
    free((void *)np);
  }
  soap->nlist = (struct soap_nlist *)(void *)0;
}

// soap_free_pht
// file stdsoap2.c line 7487
static void soap_free_pht(struct soap *soap)
{
  struct soap_pblk *pb;
  struct soap_pblk *next;
  signed int i;
  pb = soap->pblk;
  for( ; !(pb == ((struct soap_pblk *)NULL)); pb = next)
  {
    next = pb->next;
    free((void *)pb);
  }
  soap->pblk = (struct soap_pblk *)(void *)0;
  soap->pidx = (signed short int)0;
  i = 0;
  for( ; !(i >= 4096); i = i + 1)
    soap->pht[(signed long int)i] = (struct soap_plist *)(void *)0;
}

// soap_free_stream
// file stdsoap2.c line 9610
void soap_free_stream(struct soap *soap)
{
  soap->socket = (signed int)-1;
  soap->sendsk = (signed int)-1;
  soap->recvsk = (signed int)-1;
}

// soap_free_temp
// file stdsoap2.c line 9175
void soap_free_temp(struct soap *soap)
{
  struct soap_attribute *tp;
  struct soap_attribute *tq;
  struct Namespace *ns;
  soap_free_ns(soap);
  while(!(soap->blist == ((struct soap_blist *)NULL)))
    soap_end_block(soap, (struct soap_blist *)(void *)0);
  tp = soap->attributes;
  for( ; !(tp == ((struct soap_attribute *)NULL)); tp = tq)
  {
    tq = tp->next;
    if(!(tp->value == ((char *)NULL)))
      free((void *)tp->value);

    free((void *)tp);
  }
  soap->attributes = (struct soap_attribute *)(void *)0;
  if(!(soap->labbuf == ((char *)NULL)))
    free((void *)soap->labbuf);

  soap->labbuf = (char *)(void *)0;
  soap->lablen = (unsigned long int)0;
  soap->labidx = (unsigned long int)0;
  ns = soap->local_namespaces;
  if(!(ns == ((struct Namespace *)NULL)))
  {
    for( ; !(ns->id == ((const char *)NULL)); ns = ns + 1l)
      if(!(ns->out == ((char *)NULL)))
      {
        free((void *)ns->out);
        ns->out = (char *)(void *)0;
      }

    free((void *)soap->local_namespaces);
    soap->local_namespaces = (struct Namespace *)(void *)0;
  }

  while(!(soap->xlist == ((struct soap_xlist *)NULL)))
  {
    struct soap_xlist *xp = soap->xlist->next;
    free((void *)soap->xlist);
    soap->xlist = xp;
  }
  soap_free_iht(soap);
  soap_free_pht(soap);
}

// soap_get
// file stdsoap2.c line 1611
signed int soap_get(struct soap *soap)
{
  signed int c = soap->ahead;
  signed int return_value_soap_recv_1;
  unsigned long int tmp_post_3;
  if(!(c == 0))
  {
    if(!(c == -1))
      soap->ahead = 0;

  }

  else
  {
    _Bool tmp_if_expr_2;
    if(soap->bufidx >= soap->buflen)
    {
      return_value_soap_recv_1=soap_recv(soap);
      tmp_if_expr_2 = return_value_soap_recv_1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
    signed int tmp_if_expr_4;
    if(tmp_if_expr_2)
      tmp_if_expr_4 = -1;

    else
    {
      tmp_post_3 = soap->bufidx;
      soap->bufidx = soap->bufidx + 1ul;
      tmp_if_expr_4 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_3];
    }
    c = tmp_if_expr_4;
  }
  signed int return_value_soap_recv_5;
  unsigned long int tmp_post_7;
  signed int return_value_soap_recv_9;
  signed int return_value_soap_recv_12;
  unsigned long int tmp_post_14;
  signed int return_value_soap_recv_16;
  unsigned long int tmp_post_18;
  signed int return_value_soap_recv_20;
  unsigned long int tmp_post_22;
  signed int return_value_soap_recv_24;
  unsigned long int tmp_post_26;
  signed int return_value_soap_recv_28;
  unsigned long int tmp_post_30;
  signed int return_value_soap_recv_32;
  unsigned long int tmp_post_34;
  signed int return_value_soap_recv_44;
  unsigned long int tmp_post_46;
  signed int return_value_soap_recv_36;
  unsigned long int tmp_post_38;
  signed int return_value_soap_recv_40;
  unsigned long int tmp_post_42;
  signed int return_value_soap_recv_48;
  unsigned long int tmp_post_50;
  signed int return_value_soap_recv_52;
  unsigned long int tmp_post_54;
  signed int return_value_soap_char_56;
  while(!(c == -1))
  {
    if(!(soap->cdata == 0))
    {
      if(c == 93)
      {
        _Bool tmp_if_expr_6;
        if(soap->bufidx >= soap->buflen)
        {
          return_value_soap_recv_5=soap_recv(soap);
          tmp_if_expr_6 = return_value_soap_recv_5 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_6 = (_Bool)0;
        signed int tmp_if_expr_8;
        if(tmp_if_expr_6)
          tmp_if_expr_8 = -1;

        else
        {
          tmp_post_7 = soap->bufidx;
          soap->bufidx = soap->bufidx + 1ul;
          tmp_if_expr_8 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_7];
        }
        c = tmp_if_expr_8;
        if(c == 93)
        {
          _Bool tmp_if_expr_10;
          if(soap->bufidx >= soap->buflen)
          {
            return_value_soap_recv_9=soap_recv(soap);
            tmp_if_expr_10 = return_value_soap_recv_9 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_10 = (_Bool)0;
          signed int tmp_if_expr_11;
          if(tmp_if_expr_10)
            tmp_if_expr_11 = -1;

          else
            tmp_if_expr_11 = (signed int)(unsigned char)soap->buf[(signed long int)soap->bufidx];
          c = tmp_if_expr_11;
          if(c == 62)
          {
            soap->cdata = (signed short int)0;
            _Bool tmp_if_expr_13;
            if(soap->bufidx >= soap->buflen)
            {
              return_value_soap_recv_12=soap_recv(soap);
              tmp_if_expr_13 = return_value_soap_recv_12 != 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_13 = (_Bool)0;
            signed int tmp_if_expr_15;
            if(tmp_if_expr_13)
              tmp_if_expr_15 = -1;

            else
            {
              tmp_post_14 = soap->bufidx;
              soap->bufidx = soap->bufidx + 1ul;
              tmp_if_expr_15 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_14];
            }
            c = tmp_if_expr_15;
            _Bool tmp_if_expr_17;
            if(soap->bufidx >= soap->buflen)
            {
              return_value_soap_recv_16=soap_recv(soap);
              tmp_if_expr_17 = return_value_soap_recv_16 != 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_17 = (_Bool)0;
            signed int tmp_if_expr_19;
            if(tmp_if_expr_17)
              tmp_if_expr_19 = -1;

            else
            {
              tmp_post_18 = soap->bufidx;
              soap->bufidx = soap->bufidx + 1ul;
              tmp_if_expr_19 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_18];
            }
            c = tmp_if_expr_19;
          }

          else
          {
            soap->ahead = 93;
            return 93;
          }
        }

        else
        {
          soap->bufidx = soap->bufidx - 1ul;
          return 93;
        }
      }

      else
        return c;
    }

    switch(c)
    {
      case 60:
      {
        do
        {
          _Bool tmp_if_expr_21;
          if(soap->bufidx >= soap->buflen)
          {
            return_value_soap_recv_20=soap_recv(soap);
            tmp_if_expr_21 = return_value_soap_recv_20 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_21 = (_Bool)0;
          signed int tmp_if_expr_23;
          if(tmp_if_expr_21)
            tmp_if_expr_23 = -1;

          else
          {
            tmp_post_22 = soap->bufidx;
            soap->bufidx = soap->bufidx + 1ul;
            tmp_if_expr_23 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_22];
          }
          c = tmp_if_expr_23;
        }
        while(1 + c >= 1 && !(c >= 33));
        if(c == 33 || c == 37 || c == 63)
        {
          signed int k = 1;
          if(c == 33)
          {
            _Bool tmp_if_expr_25;
            if(soap->bufidx >= soap->buflen)
            {
              return_value_soap_recv_24=soap_recv(soap);
              tmp_if_expr_25 = return_value_soap_recv_24 != 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_25 = (_Bool)0;
            signed int tmp_if_expr_27;
            if(tmp_if_expr_25)
              tmp_if_expr_27 = -1;

            else
            {
              tmp_post_26 = soap->bufidx;
              soap->bufidx = soap->bufidx + 1ul;
              tmp_if_expr_27 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_26];
            }
            c = tmp_if_expr_27;
            if(c == 91)
            {
              do
              {
                _Bool tmp_if_expr_29;
                if(soap->bufidx >= soap->buflen)
                {
                  return_value_soap_recv_28=soap_recv(soap);
                  tmp_if_expr_29 = return_value_soap_recv_28 != 0 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_29 = (_Bool)0;
                signed int tmp_if_expr_31;
                if(tmp_if_expr_29)
                  tmp_if_expr_31 = -1;

                else
                {
                  tmp_post_30 = soap->bufidx;
                  soap->bufidx = soap->bufidx + 1ul;
                  tmp_if_expr_31 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_30];
                }
                c = tmp_if_expr_31;
              }
              while(!(c == 91) && !(c == -1));
              if(c == -1)
                goto __CPROVER_DUMP_L86;

              soap->cdata = (signed short int)1;
              _Bool tmp_if_expr_33;
              if(soap->bufidx >= soap->buflen)
              {
                return_value_soap_recv_32=soap_recv(soap);
                tmp_if_expr_33 = return_value_soap_recv_32 != 0 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_33 = (_Bool)0;
              signed int tmp_if_expr_35;
              if(tmp_if_expr_33)
                tmp_if_expr_35 = -1;

              else
              {
                tmp_post_34 = soap->bufidx;
                soap->bufidx = soap->bufidx + 1ul;
                tmp_if_expr_35 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_34];
              }
              c = tmp_if_expr_35;
              break;
            }

            if(c == 45)
            {
              _Bool tmp_if_expr_45;
              if(soap->bufidx >= soap->buflen)
              {
                return_value_soap_recv_44=soap_recv(soap);
                tmp_if_expr_45 = return_value_soap_recv_44 != 0 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_45 = (_Bool)0;
              signed int tmp_if_expr_47;
              if(tmp_if_expr_45)
                tmp_if_expr_47 = -1;

              else
              {
                tmp_post_46 = soap->bufidx;
                soap->bufidx = soap->bufidx + 1ul;
                tmp_if_expr_47 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_46];
              }
              c = tmp_if_expr_47;
              if(c == 45)
                do
                {
                  _Bool tmp_if_expr_37;
                  if(soap->bufidx >= soap->buflen)
                  {
                    return_value_soap_recv_36=soap_recv(soap);
                    tmp_if_expr_37 = return_value_soap_recv_36 != 0 ? (_Bool)1 : (_Bool)0;
                  }

                  else
                    tmp_if_expr_37 = (_Bool)0;
                  signed int tmp_if_expr_39;
                  if(tmp_if_expr_37)
                    tmp_if_expr_39 = -1;

                  else
                  {
                    tmp_post_38 = soap->bufidx;
                    soap->bufidx = soap->bufidx + 1ul;
                    tmp_if_expr_39 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_38];
                  }
                  c = tmp_if_expr_39;
                  if(c == 45)
                  {
                    _Bool tmp_if_expr_41;
                    if(soap->bufidx >= soap->buflen)
                    {
                      return_value_soap_recv_40=soap_recv(soap);
                      tmp_if_expr_41 = return_value_soap_recv_40 != 0 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_41 = (_Bool)0;
                    signed int tmp_if_expr_43;
                    if(tmp_if_expr_41)
                      tmp_if_expr_43 = -1;

                    else
                    {
                      tmp_post_42 = soap->bufidx;
                      soap->bufidx = soap->bufidx + 1ul;
                      tmp_if_expr_43 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_42];
                    }
                    c = tmp_if_expr_43;
                    if(c == 45)
                      break;

                  }

                }
                while(!(c == -1));

            }

          }

          else
            if(c == 63)
              c=soap_get_pi(soap);

          while(!(c == -1))
          {
            if(c == 60)
              k = k + 1;

            else
              if(c == 62)
              {
                k = k - 1;
                if(!(k >= 1))
                  break;

              }

            _Bool tmp_if_expr_49;
            if(soap->bufidx >= soap->buflen)
            {
              return_value_soap_recv_48=soap_recv(soap);
              tmp_if_expr_49 = return_value_soap_recv_48 != 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_49 = (_Bool)0;
            signed int tmp_if_expr_51;
            if(tmp_if_expr_49)
              tmp_if_expr_51 = -1;

            else
            {
              tmp_post_50 = soap->bufidx;
              soap->bufidx = soap->bufidx + 1ul;
              tmp_if_expr_51 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_50];
            }
            c = tmp_if_expr_51;
          }
          if(c == -1)
            goto __CPROVER_DUMP_L86;

          _Bool tmp_if_expr_53;
          if(soap->bufidx >= soap->buflen)
          {
            return_value_soap_recv_52=soap_recv(soap);
            tmp_if_expr_53 = return_value_soap_recv_52 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_53 = (_Bool)0;
          signed int tmp_if_expr_55;
          if(tmp_if_expr_53)
            tmp_if_expr_55 = -1;

          else
          {
            tmp_post_54 = soap->bufidx;
            soap->bufidx = soap->bufidx + 1ul;
            tmp_if_expr_55 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_54];
          }
          c = tmp_if_expr_55;
          break;
        }

        if(c == 47)
          return (signed int)-3;

        soap->bufidx = soap->bufidx - 1ul;
        return (signed int)-2;
      }
      case 62:
        return (signed int)-4;
      case 34:
        return (signed int)-5;
      case 39:
        return (signed int)-6;
      case 38:
      {
        return_value_soap_char_56=soap_char(soap);
        return (signed int)((unsigned int)return_value_soap_char_56 | 0x80000000);
      }
      default:
      {

      __CPROVER_DUMP_L86:
        ;
        goto __CPROVER_DUMP_L88;
      }
    }
  }

__CPROVER_DUMP_L88:
  ;
  return c;
}

// soap_get_PointerToSOAP_ENV__Code
// file soapC.c line 1288
struct SOAP_ENV__Code ** soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
  p=soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type);
  signed int return_value_soap_getindependent_1;
  if(!(p == ((struct SOAP_ENV__Code **)NULL)))
  {
    return_value_soap_getindependent_1=soap_getindependent(soap);
    if(!(return_value_soap_getindependent_1 == 0))
      return (struct SOAP_ENV__Code **)(void *)0;

  }

  return p;
}

// soap_get_PointerToSOAP_ENV__Detail
// file soapC.c line 1227
struct SOAP_ENV__Detail ** soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
  p=soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type);
  signed int return_value_soap_getindependent_1;
  if(!(p == ((struct SOAP_ENV__Detail **)NULL)))
  {
    return_value_soap_getindependent_1=soap_getindependent(soap);
    if(!(return_value_soap_getindependent_1 == 0))
      return (struct SOAP_ENV__Detail **)(void *)0;

  }

  return p;
}

// soap_get_PointerToSOAP_ENV__Reason
// file soapC.c line 1169
struct SOAP_ENV__Reason ** soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
  p=soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type);
  signed int return_value_soap_getindependent_1;
  if(!(p == ((struct SOAP_ENV__Reason **)NULL)))
  {
    return_value_soap_getindependent_1=soap_getindependent(soap);
    if(!(return_value_soap_getindependent_1 == 0))
      return (struct SOAP_ENV__Reason **)(void *)0;

  }

  return p;
}

// soap_get_PointerTot__Routing
// file soapC.c line 1344
struct t__Routing ** soap_get_PointerTot__Routing(struct soap *soap, struct t__Routing **p, const char *tag, const char *type)
{
  p=soap_in_PointerTot__Routing(soap, tag, p, type);
  signed int return_value_soap_getindependent_1;
  if(!(p == ((struct t__Routing **)NULL)))
  {
    return_value_soap_getindependent_1=soap_getindependent(soap);
    if(!(return_value_soap_getindependent_1 == 0))
      return (struct t__Routing **)(void *)0;

  }

  return p;
}

// soap_get_SOAP_ENV__Code
// file soapC.c line 829
struct SOAP_ENV__Code * soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
  p=soap_in_SOAP_ENV__Code(soap, tag, p, type);
  signed int return_value_soap_getindependent_1;
  if(!(p == ((struct SOAP_ENV__Code *)NULL)))
  {
    return_value_soap_getindependent_1=soap_getindependent(soap);
    if(!(return_value_soap_getindependent_1 == 0))
      return (struct SOAP_ENV__Code *)(void *)0;

  }

  return p;
}

// soap_get_SOAP_ENV__Detail
// file soapC.c line 739
struct SOAP_ENV__Detail * soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
  p=soap_in_SOAP_ENV__Detail(soap, tag, p, type);
  signed int return_value_soap_getindependent_1;
  if(!(p == ((struct SOAP_ENV__Detail *)NULL)))
  {
    return_value_soap_getindependent_1=soap_getindependent(soap);
    if(!(return_value_soap_getindependent_1 == 0))
      return (struct SOAP_ENV__Detail *)(void *)0;

  }

  return p;
}

// soap_get_SOAP_ENV__Fault
// file soapC.c line 570
struct SOAP_ENV__Fault * soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
  p=soap_in_SOAP_ENV__Fault(soap, tag, p, type);
  signed int return_value_soap_getindependent_1;
  if(!(p == ((struct SOAP_ENV__Fault *)NULL)))
  {
    return_value_soap_getindependent_1=soap_getindependent(soap);
    if(!(return_value_soap_getindependent_1 == 0))
      return (struct SOAP_ENV__Fault *)(void *)0;

  }

  return p;
}

// soap_get_SOAP_ENV__Header
// file soapC.c line 898
struct SOAP_ENV__Header * soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
  p=soap_in_SOAP_ENV__Header(soap, tag, p, type);
  signed int return_value_soap_getindependent_1;
  if(!(p == ((struct SOAP_ENV__Header *)NULL)))
  {
    return_value_soap_getindependent_1=soap_getindependent(soap);
    if(!(return_value_soap_getindependent_1 == 0))
      return (struct SOAP_ENV__Header *)(void *)0;

  }

  return p;
}

// soap_get_SOAP_ENV__Reason
// file soapC.c line 651
struct SOAP_ENV__Reason * soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
  p=soap_in_SOAP_ENV__Reason(soap, tag, p, type);
  signed int return_value_soap_getindependent_1;
  if(!(p == ((struct SOAP_ENV__Reason *)NULL)))
  {
    return_value_soap_getindependent_1=soap_getindependent(soap);
    if(!(return_value_soap_getindependent_1 == 0))
      return (struct SOAP_ENV__Reason *)(void *)0;

  }

  return p;
}

// soap_get__QName
// file soapC.c line 1378
char ** soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
  p=soap_in__QName(soap, tag, p, type);
  signed int return_value_soap_getindependent_1;
  if(!(p == ((char **)NULL)))
  {
    return_value_soap_getindependent_1=soap_getindependent(soap);
    if(!(return_value_soap_getindependent_1 == 0))
      return (char **)(void *)0;

  }

  return p;
}

// soap_get_byte
// file soapC.c line 376
char * soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
  p=soap_in_byte(soap, tag, p, type);
  signed int return_value_soap_getindependent_1;
  if(!(p == ((char *)NULL)))
  {
    return_value_soap_getindependent_1=soap_getindependent(soap);
    if(!(return_value_soap_getindependent_1 == 0))
      return (char *)(void *)0;

  }

  return p;
}

// soap_get_header_attribute
// file stdsoap2.c line 6218
const char * soap_get_header_attribute(struct soap *soap, const char *line, const char *key)
{
  const char *s = line;
  if(!(s == ((const char *)NULL)))
    while(!(*s == 0))
    {
      signed short int flag;
      s=soap_decode_key(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , s);
      signed int return_value_soap_tag_cmp_1;
      return_value_soap_tag_cmp_1=soap_tag_cmp(soap->tmpbuf, key);
      flag = (signed short int)return_value_soap_tag_cmp_1;
      s=soap_decode_val(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , s);
      if(flag == 0)
        return soap->tmpbuf;

    }

  return (const char *)(void *)0;
}

// soap_get_http_body
// file stdsoap2.c line 16851
char * soap_get_http_body(struct soap *soap, unsigned long int *len)
{
  unsigned long int l = (unsigned long int)0;
  unsigned long int n = (unsigned long int)0;
  char *s;
  if(!(len == ((unsigned long int *)NULL)))
    *len = (unsigned long int)0;

  signed int return_value_soap_recv_2;
  unsigned long int tmp_post_4;
  void *return_value_memcpy_7;
  if((0x00000400 & soap->mode) == 0)
  {
    if((0x00000003 & soap->mode) == 0x00000003)
      goto __CPROVER_DUMP_L2;

    n = soap->length;
    if(!(n == 0ul))
      goto __CPROVER_DUMP_L2;

    return (char *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    soap->labidx = (unsigned long int)0;
    do
    {
      unsigned long int i;
      unsigned long int k;
      signed int return_value_soap_append_lab_1;
      return_value_soap_append_lab_1=soap_append_lab(soap, (const char *)(void *)0, (unsigned long int)0);
      if(!(return_value_soap_append_lab_1 == 0))
        return (char *)(void *)0;

      s = soap->labbuf + (signed long int)soap->labidx;
      k = soap->lablen - soap->labidx;
      soap->labidx = soap->lablen;
      i = (unsigned long int)0;
      for( ; !(i >= k); i = i + 1ul)
      {
        signed int c;
        l = l + 1ul;
        if(n >= 1ul && !(n >= l))
          goto end;

        _Bool tmp_if_expr_3;
        if(soap->bufidx >= soap->buflen)
        {
          return_value_soap_recv_2=soap_recv(soap);
          tmp_if_expr_3 = return_value_soap_recv_2 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_3 = (_Bool)0;
        signed int tmp_if_expr_5;
        if(tmp_if_expr_3)
          tmp_if_expr_5 = -1;

        else
        {
          tmp_post_4 = soap->bufidx;
          soap->bufidx = soap->bufidx + 1ul;
          tmp_if_expr_5 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_4];
        }
        c = tmp_if_expr_5;
        if(c == -1)
          goto end;

        char *tmp_post_6 = s;
        s = s + 1l;
        *tmp_post_6 = (char)(c & 0xFF);
      }
    }
    while((_Bool)1);

  end:
    ;
    *s = (char)0;
    if(!(len == ((unsigned long int *)NULL)))
      *len = l - (unsigned long int)1;

    void *return_value_soap_malloc_8;
    return_value_soap_malloc_8=soap_malloc(soap, l);
    s = (char *)return_value_soap_malloc_8;
    if(!(s == ((char *)NULL)))
    {
      if(!(s == ((char *)NULL)))
      {
        return_value_memcpy_7=memcpy((void *)s, (const void *)soap->labbuf, l);
        (signed int)!(return_value_memcpy_7 != NULL);
      }

      else
        34;
    }

    return s;
  }
}

// soap_get_int
// file soapC.c line 412
signed int * soap_get_int(struct soap *soap, signed int *p, const char *tag, const char *type)
{
  p=soap_in_int(soap, tag, p, type);
  signed int return_value_soap_getindependent_1;
  if(!(p == ((signed int *)NULL)))
  {
    return_value_soap_getindependent_1=soap_getindependent(soap);
    if(!(return_value_soap_getindependent_1 == 0))
      return (signed int *)(void *)0;

  }

  return p;
}

// soap_get_mime_attachment
// file stdsoap2.c line 15911
struct soap_multipart * soap_get_mime_attachment(struct soap *soap, void *handle)
{
  signed int c = 0;
  unsigned long int i;
  unsigned long int m = (unsigned long int)0;
  char *s;
  char *t = (char *)(void *)0;
  struct soap_multipart *content;
  signed short int flag = (signed short int)0;
  void *return_value;
  struct soap_blist *return_value_soap_new_block_3;
  void *return_value_soap_push_block_4;
  unsigned long int return_value_strlen_8;
  char *tmp_post_10;
  signed int return_value_soap_getchar_18;
  signed int return_value_soap_end_recv_14;
  signed int return_value_soap_getchar_15;
  if((0x00000100 & soap->mode) == 0)
    return (struct soap_multipart *)(void *)0;

  else
  {
    content = soap->mime.last;
    if(content == ((struct soap_multipart *)NULL))
    {
      signed int return_value_soap_getmimehdr_1;
      return_value_soap_getmimehdr_1=soap_getmimehdr(soap);
      if(!(return_value_soap_getmimehdr_1 == 0))
        return (struct soap_multipart *)(void *)0;

      content = soap->mime.last;
    }

    else
      if(!(content == soap->mime.first))
      {
        if(!(soap->fmimewriteopen == ((void * (*)(struct soap *, void *, const char *, const char *, const char *, enum soap_mime_encoding))NULL)))
        {
          return_value=soap->fmimewriteopen(soap, (void *)handle, content->id, content->type, content->description, content->encoding);
          content->ptr = (char *)return_value;
          _Bool tmp_if_expr_2;
          if(!(content->ptr == ((char *)NULL)))
            tmp_if_expr_2 = (_Bool)1;

          else
            tmp_if_expr_2 = soap->error != 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_2)
          {
            if(content->ptr == ((char *)NULL))
              return (struct soap_multipart *)(void *)0;

          }

        }

      }

    if(content->ptr == ((char *)NULL))
    {
      return_value_soap_new_block_3=soap_new_block(soap);
      if(return_value_soap_new_block_3 == ((struct soap_blist *)NULL))
      {
        soap->error = 20;
        return (struct soap_multipart *)(void *)0;
      }

    }

    while((_Bool)1)
    {
      if(!(content->ptr == ((char *)NULL)))
        s = soap->tmpbuf;

      else
      {
        return_value_soap_push_block_4=soap_push_block(soap, (struct soap_blist *)(void *)0, sizeof(char [1024l]) /*1024ul*/ );
        s = (char *)return_value_soap_push_block_4;
        if(s == ((char *)NULL))
        {
          soap->error = 20;
          return (struct soap_multipart *)(void *)0;
        }

      }
      i = (unsigned long int)0;
      for( ; !(i >= sizeof(char [1024l]) /*1024ul*/ ); i = i + 1ul)
        if(m >= 1ul)
        {
          char *tmp_post_5 = s;
          s = s + 1l;
          char *tmp_post_6 = t;
          t = t + 1l;
          *tmp_post_5 = *tmp_post_6;
          m = m - 1ul;
        }

        else
        {
          if(flag == 0)
          {
            c=soap_getchar(soap);
            if(c == -1)
            {
              if(!(content->ptr == ((char *)NULL)))
              {
                if(!(soap->fmimewriteclose == ((void (*)(struct soap *, void *))NULL)))
                  soap->fmimewriteclose(soap, (void *)content->ptr);

              }

              signed int tmp_if_expr_7;
              if(!(soap->error == 0))
                tmp_if_expr_7 = soap->error;

              else
                tmp_if_expr_7 = -1;
              soap->error = tmp_if_expr_7;
              return (struct soap_multipart *)(void *)0;
            }

          }

          if(c == 13 || !(flag == 0))
          {
            memset((void *)soap->msgbuf, 0, sizeof(char [1024l]) /*1024ul*/ );
            strncpy(soap->msgbuf, "\n--", sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
            soap->msgbuf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
            (void)(soap->msgbuf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
            if(!(soap->mime.boundary == ((char *)NULL)))
            {
              return_value_strlen_8=strlen(soap->msgbuf);
              signed int tmp_if_expr_9;
              if(!(1020ul + return_value_strlen_8 >= sizeof(char [1024l]) /*1024ul*/ ))
              {
                strncat(soap->msgbuf, soap->mime.boundary, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)4);
                soap->msgbuf[(signed long int)((unsigned long int)sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
                tmp_if_expr_9 = (signed int)soap->msgbuf[(signed long int)((unsigned long int)sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)];
              }

              else
              {
                soap->msgbuf[(signed long int)0] = (char)0;
                tmp_if_expr_9 = (signed int)soap->msgbuf[(signed long int)0];
              }
              (void)(tmp_if_expr_9 != 0 ? (_Bool)1 : (_Bool)0);
            }

            t = soap->msgbuf;
            do
            {
              c=soap_getchar(soap);
              tmp_post_10 = t;
              t = t + 1l;
            }
            while(c == (signed int)*tmp_post_10);
            if(c == -1)
            {
              if(!(content->ptr == ((char *)NULL)))
              {
                if(!(soap->fmimewriteclose == ((void (*)(struct soap *, void *))NULL)))
                  soap->fmimewriteclose(soap, (void *)content->ptr);

              }

              signed int tmp_if_expr_11;
              if(!(soap->error == 0))
                tmp_if_expr_11 = soap->error;

              else
                tmp_if_expr_11 = -1;
              soap->error = tmp_if_expr_11;
              return (struct soap_multipart *)(void *)0;
            }

            t = t - 1l;
            if(*t == 0)
              goto end;

            *t = (char)c;
            flag = (signed short int)(c == 13);
            m = (unsigned long int)(((t - soap->msgbuf) + (signed long int)1) - (signed long int)flag);
            t = soap->msgbuf;
            c = 13;
          }

          char *tmp_post_12 = s;
          s = s + 1l;
          *tmp_post_12 = (char)c;
        }
      if(!(content->ptr == ((char *)NULL)))
      {
        if(!(soap->fmimewrite == ((signed int (*)(struct soap *, void *, const char *, unsigned long int))NULL)))
        {
          soap->error=soap->fmimewrite(soap, (void *)content->ptr, soap->tmpbuf, i);
          if(!(soap->error == 0))
            break;

        }

      }

    }

  end:
    ;
    *s = (char)0;
    if(!(content->ptr == ((char *)NULL)))
    {
      if(soap->error == 0)
      {
        if(!(soap->fmimewrite == ((signed int (*)(struct soap *, void *, const char *, unsigned long int))NULL)))
          soap->error=soap->fmimewrite(soap, (void *)content->ptr, soap->tmpbuf, i);

      }

      if(!(soap->fmimewriteclose == ((void (*)(struct soap *, void *))NULL)))
        soap->fmimewriteclose(soap, (void *)content->ptr);

      if(!(soap->error == 0))
        return (struct soap_multipart *)(void *)0;

    }

    else
    {
      unsigned long int return_value_soap_size_block_13;
      return_value_soap_size_block_13=soap_size_block(soap, (struct soap_blist *)(void *)0, i + (unsigned long int)1);
      content->size = return_value_soap_size_block_13 - (unsigned long int)1;
      content->ptr=soap_save_block(soap, (struct soap_blist *)(void *)0, (char *)(void *)0, 0);
    }
    soap_resolve_attachment(soap, content);
    _Bool tmp_if_expr_19;
    if(c == 45)
    {
      return_value_soap_getchar_18=soap_getchar(soap);
      tmp_if_expr_19 = return_value_soap_getchar_18 == 45 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_19 = (_Bool)0;
    if(tmp_if_expr_19)
    {
      soap->mode = soap->mode & ~0x00000100;
      if(!((0x40000000 & soap->mode) == 0))
      {
        return_value_soap_end_recv_14=soap_end_recv(soap);
        if(!(return_value_soap_end_recv_14 == 0))
        {
          if(!((signed int)soap->keep_alive >= 0))
            soap->keep_alive = (signed short int)0;

          soap_closesock(soap);
          return (struct soap_multipart *)(void *)0;
        }

      }

    }

    else
    {
      while(1 + c >= 1 && !(c == 13) && !(c == -1) && !(c >= 33))
        c=soap_getchar(soap);
      _Bool tmp_if_expr_16;
      if(!(c == 13))
        tmp_if_expr_16 = (_Bool)1;

      else
      {
        return_value_soap_getchar_15=soap_getchar(soap);
        tmp_if_expr_16 = return_value_soap_getchar_15 != 10 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_16)
      {
        soap->error = 36;
        return (struct soap_multipart *)(void *)0;
      }

      signed int return_value_soap_getmimehdr_17;
      return_value_soap_getmimehdr_17=soap_getmimehdr(soap);
      if(!(return_value_soap_getmimehdr_17 == 0))
        return (struct soap_multipart *)(void *)0;

    }
    return content;
  }
}

// soap_get_pi
// file stdsoap2.c line 1708
static signed int soap_get_pi(struct soap *soap)
{
  char buf[64l];
  char *s = buf;
  signed int i = (signed int)sizeof(char [64l]) /*64ul*/ ;
  signed int c;
  c=soap_getchar(soap);
  while(!(c == 63) && !(c == -1))
  {
    i = i - 1;
    if(i >= 1)
    {
      if(1 + c >= 1 && !(c >= 33))
        c = 32;

      char *tmp_post_1 = s;
      s = s + 1l;
      *tmp_post_1 = (char)c;
    }

    c=soap_getchar(soap);
  }
  *s = (char)0;
  signed int return_value_strncmp_6;
  return_value_strncmp_6=strncmp(buf, "xml ", (unsigned long int)4);
  signed int return_value_soap_tag_cmp_4;
  signed int return_value_soap_tag_cmp_2;
  if(return_value_strncmp_6 == 0)
  {
    s=strstr(buf, " encoding=");
    if(!(s == ((char *)NULL)))
    {
      if(!(s[10l] == 0))
      {
        signed int return_value_soap_tag_cmp_3;
        return_value_soap_tag_cmp_3=soap_tag_cmp(s + (signed long int)11, "iso-8859-1*");
        _Bool tmp_if_expr_5;
        if(return_value_soap_tag_cmp_3 == 0)
          tmp_if_expr_5 = (_Bool)1;

        else
        {
          return_value_soap_tag_cmp_4=soap_tag_cmp(s + (signed long int)11, "latin1*");
          tmp_if_expr_5 = !(return_value_soap_tag_cmp_4 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_5)
          soap->mode = soap->mode | 0x00000020;

        else
        {
          return_value_soap_tag_cmp_2=soap_tag_cmp(s + (signed long int)11, "utf-8*");
          if(return_value_soap_tag_cmp_2 == 0)
            soap->mode = soap->mode & ~0x00000020;

        }
      }

    }

  }

  if(!(c == -1))
    c=soap_getchar(soap);

  return c;
}

// soap_get_string
// file soapC.c line 1422
char ** soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
  p=soap_in_string(soap, tag, p, type);
  signed int return_value_soap_getindependent_1;
  if(!(p == ((char **)NULL)))
  {
    return_value_soap_getindependent_1=soap_getindependent(soap);
    if(!(return_value_soap_getindependent_1 == 0))
      return (char **)(void *)0;

  }

  return p;
}

// soap_get_t__Routing
// file soapC.c line 1113
struct t__Routing * soap_get_t__Routing(struct soap *soap, struct t__Routing *p, const char *tag, const char *type)
{
  p=soap_in_t__Routing(soap, tag, p, type);
  signed int return_value_soap_getindependent_1;
  if(!(p == ((struct t__Routing *)NULL)))
  {
    return_value_soap_getindependent_1=soap_getindependent(soap);
    if(!(return_value_soap_getindependent_1 == 0))
      return (struct t__Routing *)(void *)0;

  }

  return p;
}

// soap_get_t__RoutingTable
// file soapH.h line 202
struct t__RoutingTable * soap_get_t__RoutingTable(struct soap *soap, struct t__RoutingTable *p, const char *tag, const char *type)
{
  p=soap_in_t__RoutingTable(soap, tag, p, type);
  signed int return_value_soap_getindependent_1;
  if(!(p == ((struct t__RoutingTable *)NULL)))
  {
    return_value_soap_getindependent_1=soap_getindependent(soap);
    if(!(return_value_soap_getindependent_1 == 0))
      return (struct t__RoutingTable *)(void *)0;

  }

  return p;
}

// soap_get_version
// file stdsoap2.c line 10049
void soap_get_version(struct soap *soap)
{
  struct Namespace *p = soap->local_namespaces;
  signed int return_value_strcmp_3;
  if(!(p == ((struct Namespace *)NULL)))
  {
    const char *ns = (p + (signed long int)0)->out;
    if(ns == ((const char *)NULL))
      ns = (p + (signed long int)0)->ns;

    signed int return_value_strcmp_4;
    return_value_strcmp_4=strcmp(ns, soap_env1);
    if(return_value_strcmp_4 == 0)
    {
      soap->version = (signed short int)1;
      if(!((p + 1l)->out == ((char *)NULL)))
        free((void *)(p + (signed long int)1)->out);

      void *return_value_malloc_1;
      return_value_malloc_1=malloc(sizeof(const char [42l]) /*42ul*/ );
      (p + (signed long int)1)->out = (char *)return_value_malloc_1;
      if(!((p + 1l)->out == ((char *)NULL)))
      {
        if(!((p + 1l)->out == ((char *)NULL)))
        {
          strncpy((p + (signed long int)1)->out, soap_enc1, sizeof(const char [42l]) /*42ul*/  - (unsigned long int)1);
          (p + (signed long int)1)->out[(signed long int)(unsigned long int)(sizeof(const char [42l]) /*42ul*/  - (unsigned long int)1)] = (char)0;
          if(!((signed int)(p + 1l)->out[41l] == 0))
            (_Bool)1;

          else
            (_Bool)0;
        }

        else
          (_Bool)0;
      }

    }

    else
    {
      return_value_strcmp_3=strcmp(ns, soap_env2);
      if(return_value_strcmp_3 == 0)
      {
        soap->version = (signed short int)2;
        if(!((p + 1l)->out == ((char *)NULL)))
          free((void *)(p + (signed long int)1)->out);

        void *return_value_malloc_2;
        return_value_malloc_2=malloc(sizeof(const char [40l]) /*40ul*/ );
        (p + (signed long int)1)->out = (char *)return_value_malloc_2;
        if(!((p + 1l)->out == ((char *)NULL)))
        {
          if(!((p + 1l)->out == ((char *)NULL)))
          {
            strncpy((p + (signed long int)1)->out, soap_enc2, sizeof(const char [40l]) /*40ul*/  - (unsigned long int)1);
            (p + (signed long int)1)->out[(signed long int)(unsigned long int)(sizeof(const char [40l]) /*40ul*/  - (unsigned long int)1)] = (char)0;
            if(!((signed int)(p + 1l)->out[39l] == 0))
              (_Bool)1;

            else
              (_Bool)0;
          }

          else
            (_Bool)0;
        }

      }

    }
  }

}

// soap_getattrval
// file stdsoap2.c line 11419
static signed int soap_getattrval(struct soap *soap, char *s, unsigned long int *n, signed int d)
{
  char buf[8l];
  unsigned long int i;
  unsigned long int k = *n;
  unsigned long int m = (unsigned long int)0;
  char *t = buf;
  i = (unsigned long int)0;
  for( ; !(i >= k); i = i + 1ul)
  {
    signed int c;
    if(!(m == 0ul))
    {
      char *tmp_post_1 = s;
      s = s + 1l;
      char *tmp_post_2 = t;
      t = t + 1l;
      *tmp_post_1 = *tmp_post_2;
      m = m - 1ul;
    }

    else
    {
      if(!((0x02000000 & soap->mode) == 0))
      {
        c=soap_get(soap);
        if(!((0x80000000 & (unsigned int)c) == 0u))
        {
          if(c >= -2147483520)
          {
            if(!(c >= -6))
            {
              t = buf;
              c = c & 0x7FFFFFFF;
              if(!(c >= 0x0800))
              {
                char *tmp_post_3 = t;
                t = t + 1l;
                *tmp_post_3 = (char)(0xC0 | c >> 6 & 0x1F);
              }

              else
              {
                if(!(c >= 0x010000))
                {
                  char *tmp_post_4 = t;
                  t = t + 1l;
                  *tmp_post_4 = (char)(0xE0 | c >> 12 & 0x0F);
                }

                else
                {
                  if(!(c >= 0x200000))
                  {
                    char *tmp_post_5 = t;
                    t = t + 1l;
                    *tmp_post_5 = (char)(0xF0 | c >> 18 & 0x07);
                  }

                  else
                  {
                    if(!(c >= 0x04000000))
                    {
                      char *tmp_post_6 = t;
                      t = t + 1l;
                      *tmp_post_6 = (char)(0xF8 | c >> 24 & 0x03);
                    }

                    else
                    {
                      char *tmp_post_7 = t;
                      t = t + 1l;
                      *tmp_post_7 = (char)(0xFC | c >> 30 & 0x01);
                      char *tmp_post_8 = t;
                      t = t + 1l;
                      *tmp_post_8 = (char)(0x80 | c >> 24 & 0x3F);
                    }
                    char *tmp_post_9 = t;
                    t = t + 1l;
                    *tmp_post_9 = (char)(0x80 | c >> 18 & 0x3F);
                  }
                  char *tmp_post_10 = t;
                  t = t + 1l;
                  *tmp_post_10 = (char)(0x80 | c >> 12 & 0x3F);
                }
                char *tmp_post_11 = t;
                t = t + 1l;
                *tmp_post_11 = (char)(0x80 | c >> 6 & 0x3F);
              }
              char *tmp_post_12 = t;
              t = t + 1l;
              *tmp_post_12 = (char)(0x80 | c & 0x3F);
              m = (unsigned long int)((t - buf) - (signed long int)1);
              if(i + m >= k)
              {
                soap->ahead = (signed int)((unsigned int)c | 0x80000000);
                *n = i;
                soap->error = 20;
                return soap->error;
              }

              t = buf;
              char *tmp_post_13 = s;
              s = s + 1l;
              char *tmp_post_14 = t;
              t = t + 1l;
              *tmp_post_13 = *tmp_post_14;
              goto __CPROVER_DUMP_L30;
            }

          }

        }

      }

      else
        c=soap_getutf8(soap);
      if(!(c == -3))
      {
        if(c == -2)
          goto __CPROVER_DUMP_L16;

        if(c == -4)
          goto __CPROVER_DUMP_L17;

        if(c == -5)
          goto __CPROVER_DUMP_L19;

        if(c == -6)
          goto __CPROVER_DUMP_L21;

        if(c == 9 || c == 10 || c == 13 || c == 32 || c == 47)
          goto __CPROVER_DUMP_L23;

      }

      else
      {
        char *tmp_post_15 = s;
        s = s + 1l;
        *tmp_post_15 = (char)60;
        soap->ahead = 47;
        goto __CPROVER_DUMP_L29;

      __CPROVER_DUMP_L16:
        ;
        char *tmp_post_16 = s;
        s = s + 1l;
        *tmp_post_16 = (char)60;
        goto __CPROVER_DUMP_L29;

      __CPROVER_DUMP_L17:
        ;
        if(d == 32)
        {
          soap->ahead = c;
          *s = (char)0;
          *n = i + (unsigned long int)1;
          return 0;
        }

        char *tmp_post_17 = s;
        s = s + 1l;
        *tmp_post_17 = (char)62;
        goto __CPROVER_DUMP_L29;

      __CPROVER_DUMP_L19:
        ;
        if(c == d)
        {
          *s = (char)0;
          *n = i + (unsigned long int)1;
          return 0;
        }

        char *tmp_post_18 = s;
        s = s + 1l;
        *tmp_post_18 = (char)34;
        goto __CPROVER_DUMP_L29;

      __CPROVER_DUMP_L21:
        ;
        if(c == d)
        {
          *s = (char)0;
          *n = i + (unsigned long int)1;
          return 0;
        }

        char *tmp_post_19 = s;
        s = s + 1l;
        *tmp_post_19 = (char)39;
        goto __CPROVER_DUMP_L29;

      __CPROVER_DUMP_L23:
        ;
        if(d == 32)
        {
          soap->ahead = c;
          *s = (char)0;
          *n = i + (unsigned long int)1;
          return 0;
        }

        char *tmp_post_20 = s;
        s = s + 1l;
        *tmp_post_20 = (char)c;
        goto __CPROVER_DUMP_L29;
      }
      if(c == -1)
      {
        *s = (char)0;
        *n = i + (unsigned long int)1;
        signed int tmp_if_expr_21;
        if(!(soap->error == 0))
          tmp_if_expr_21 = soap->error;

        else
          tmp_if_expr_21 = -1;
        soap->error = tmp_if_expr_21;
        return soap->error;
      }

      char *tmp_post_22 = s;
      s = s + 1l;
      *tmp_post_22 = (char)c;
    }

  __CPROVER_DUMP_L29:
    ;

  __CPROVER_DUMP_L30:
    ;
  }
  soap->error = 20;
  return soap->error;
}

// soap_getbase64
// file stdsoap2.c line 2046
unsigned char * soap_getbase64(struct soap *soap, signed int *n, signed int malloc_flag)
{
  (void)malloc_flag;
  soap->labidx = (unsigned long int)0;
  void *return_value_memcpy_6;
  do
  {
    unsigned long int i;
    unsigned long int k;
    char *s;
    signed int return_value_soap_append_lab_1;
    return_value_soap_append_lab_1=soap_append_lab(soap, (const char *)(void *)0, (unsigned long int)2);
    if(!(return_value_soap_append_lab_1 == 0))
      return (unsigned char *)(void *)0;

    s = soap->labbuf + (signed long int)soap->labidx;
    k = soap->lablen - soap->labidx;
    soap->labidx = (unsigned long int)3 * (soap->lablen / (unsigned long int)3);
    if(k >= 3ul)
    {
      i = (unsigned long int)0;
      for( ; !(i >= k + 18446744073709551614ul); i = i + (unsigned long int)3)
      {
        unsigned long int m = (unsigned long int)0;
        signed int j = 0;
        do
        {
          signed int c;
          c=soap_get(soap);
          if(!(c >= -6))
            c = c & 0x7FFFFFFF;

          if(c == 61 || !(c >= 0))
          {
            unsigned char *p;
            unsigned long int l;
            switch(j)
            {
              case 2:
              {
                char *tmp_post_2 = s;
                s = s + 1l;
                *tmp_post_2 = (char)(m >> 4 & (unsigned long int)0xFF);
                i = i + 1ul;
                break;
              }
              case 3:
              {
                char *tmp_post_3 = s;
                s = s + 1l;
                *tmp_post_3 = (char)(m >> 10 & (unsigned long int)0xFF);
                char *tmp_post_4 = s;
                s = s + 1l;
                *tmp_post_4 = (char)(m >> 2 & (unsigned long int)0xFF);
                i = i + (unsigned long int)2;
              }
            }
            l = (soap->lablen + i) - k;
            if(!(n == ((signed int *)NULL)))
              *n = (signed int)l;

            void *return_value_soap_malloc_5;
            return_value_soap_malloc_5=soap_malloc(soap, l);
            p = (unsigned char *)return_value_soap_malloc_5;
            if(!(p == ((unsigned char *)NULL)))
            {
              if(!(p == ((unsigned char *)NULL)))
              {
                return_value_memcpy_6=memcpy((void *)p, (const void *)soap->labbuf, l);
                (signed int)!(return_value_memcpy_6 != NULL);
              }

              else
                34;
            }

            if(c >= 0)
              do
              {
                c=soap_get(soap);
                if(c == -1)
                  break;

                if(c == -2)
                  break;

                if(c == -3)
                  break;

              }
              while((_Bool)1);

            soap->ahead = c;
            return p;
          }

          c = c - 43;
          if(c >= 0 && !(c >= 80))
          {
            signed int b = (signed int)soap_base64i[(signed long int)c];
            if(b >= 64)
            {
              soap->error = 4;
              return (unsigned char *)(void *)0;
            }

            m = (m << 6) + (unsigned long int)b;
            j = j + 1;
          }

          else
            if(!(1 + c >= 1) || 43 + c >= 33)
            {
              soap->error = 4;
              return (unsigned char *)(void *)0;
            }

        }
        while(!(j >= 4));
        char *tmp_post_7 = s;
        s = s + 1l;
        *tmp_post_7 = (char)(m >> 16 & (unsigned long int)0xFF);
        char *tmp_post_8 = s;
        s = s + 1l;
        *tmp_post_8 = (char)(m >> 8 & (unsigned long int)0xFF);
        char *tmp_post_9 = s;
        s = s + 1l;
        *tmp_post_9 = (char)(m & (unsigned long int)0xFF);
      }
    }

  }
  while((_Bool)1);
}

// soap_getchar
// file stdsoap2.c line 1421
signed int soap_getchar(struct soap *soap)
{
  signed int c = soap->ahead;
  signed int return_value_soap_recv_1;
  unsigned long int tmp_post_3;
  if(!(c == 0))
  {
    if(!(c == -1))
      soap->ahead = 0;

    return c;
  }

  else
  {
    _Bool tmp_if_expr_2;
    if(soap->bufidx >= soap->buflen)
    {
      return_value_soap_recv_1=soap_recv(soap);
      tmp_if_expr_2 = return_value_soap_recv_1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
    signed int tmp_if_expr_4;
    if(tmp_if_expr_2)
      tmp_if_expr_4 = -1;

    else
    {
      tmp_post_3 = soap->bufidx;
      soap->bufidx = soap->bufidx + 1ul;
      tmp_if_expr_4 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_3];
    }
    return tmp_if_expr_4;
  }
}

// soap_getchunkchar
// file stdsoap2.c line 1094
static signed int soap_getchunkchar(struct soap *soap)
{
  if(!(soap->bufidx >= soap->buflen))
  {
    unsigned long int tmp_post_1 = soap->bufidx;
    soap->bufidx = soap->bufidx + 1ul;
    return (signed int)soap->buf[(signed long int)tmp_post_1];
  }

  soap->bufidx = (unsigned long int)0;
  soap->chunkbuflen=soap->frecv(soap, soap->buf, sizeof(char [65536l]) /*65536ul*/ );
  soap->buflen = soap->chunkbuflen;
  if(!(soap->buflen == 0ul))
  {
    unsigned long int tmp_post_2 = soap->bufidx;
    soap->bufidx = soap->bufidx + 1ul;
    return (signed int)soap->buf[(signed long int)tmp_post_2];
  }

  return -1;
}

// soap_getdime
// file stdsoap2.c line 15684
signed int soap_getdime(struct soap *soap)
{
  while(!((0x01 & (signed int)soap->dime.flags) == 0))
  {
    signed int return_value_soap_getdimehdr_1;
    return_value_soap_getdimehdr_1=soap_getdimehdr(soap);
    if(!(return_value_soap_getdimehdr_1 == 0))
      return soap->error;

    signed int return_value_soap_move_2;
    return_value_soap_move_2=soap_move(soap, soap->dime.size);
    if(!(return_value_soap_move_2 == 0))
    {
      soap->error = -1;
      return soap->error;
    }

  }
  unsigned long int return_value_soap_tell_3;
  return_value_soap_tell_3=soap_tell(soap);
  signed int return_value_soap_move_4;
  return_value_soap_move_4=soap_move(soap, (unsigned long int)((soap->dime.size + (unsigned long int)3 & (unsigned long int)~3) - return_value_soap_tell_3));
  void *return_value;
  _Bool tmp_if_expr_19;
  signed int return_value_soap_recv_11;
  unsigned long int tmp_post_13;
  if(!(return_value_soap_move_4 == 0))
  {
    soap->error = -1;
    return soap->error;
  }

  else
  {
    do
    {
      struct soap_multipart *content;
      signed int return_value_soap_getdimehdr_5;
      return_value_soap_getdimehdr_5=soap_getdimehdr(soap);
      if(!(return_value_soap_getdimehdr_5 == 0))
        break;

      _Bool tmp_if_expr_20;
      if(!(soap->fdimewriteopen == ((void * (*)(struct soap *, const char *, const char *, const char *))NULL)))
      {
        return_value=soap->fdimewriteopen(soap, soap->dime.id, soap->dime.type, soap->dime.options);
        soap->dime.ptr = (char *)return_value;
        if(!(soap->dime.ptr == ((char *)NULL)))
          tmp_if_expr_19 = (_Bool)1;

        else
          tmp_if_expr_19 = soap->error != 0 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr_20 = tmp_if_expr_19 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_20 = (_Bool)0;
      if(tmp_if_expr_20)
      {
        const char *soap_getdime__1__2__1__1__id;
        const char *soap_getdime__1__2__1__1__type;
        const char *soap_getdime__1__2__1__1__options;
        unsigned long int size;
        unsigned long int n;
        if(soap->dime.ptr == ((char *)NULL))
          return soap->error;

        soap_getdime__1__2__1__1__id = soap->dime.id;
        soap_getdime__1__2__1__1__type = soap->dime.type;
        soap_getdime__1__2__1__1__options = soap->dime.options;
        size = soap->dime.size;
        n = soap->buflen - soap->bufidx;
        if(!(size >= n))
          n = size;

        soap->error=soap->fdimewrite(soap, (void *)soap->dime.ptr, soap->buf + (signed long int)soap->bufidx, n);
        if(soap->error == 0)
        {
          size = size - n;
          if(size == 0ul)
            soap->bufidx = soap->bufidx + n;

          else
          {
            signed int return_value_soap_recv_6;
            return_value_soap_recv_6=soap_recv(soap);
            if(!(return_value_soap_recv_6 == 0))
              soap->error = -1;

          }
        }

        signed int return_value_soap_move_7;
        return_value_soap_move_7=soap_move(soap, (unsigned long int)(-((signed long int)soap->dime.size) & (signed long int)3));
        if(!(return_value_soap_move_7 == 0))
          soap->error = -1;

        else
          if(!((0x01 & (signed int)soap->dime.flags) == 0))
          {
            signed int return_value_soap_getdimehdr_8;
            return_value_soap_getdimehdr_8=soap_getdimehdr(soap);
          }


      end:
        ;
        if(!(soap->fdimewriteclose == ((void (*)(struct soap *, void *))NULL)))
          soap->fdimewriteclose(soap, (void *)soap->dime.ptr);

        soap->dime.size = (unsigned long int)0;
        soap->dime.id = soap_getdime__1__2__1__1__id;
        soap->dime.type = soap_getdime__1__2__1__1__type;
        soap->dime.options = soap_getdime__1__2__1__1__options;
      }

      else
        if(!((0x01 & (signed int)soap->dime.flags) == 0))
        {
          const char *id;
          const char *type;
          const char *soap_getdime__1__2__1__2__options;
          id = soap->dime.id;
          type = soap->dime.type;
          soap_getdime__1__2__1__2__options = soap->dime.options;
          struct soap_blist *return_value_soap_new_block_9;
          return_value_soap_new_block_9=soap_new_block(soap);
          if(return_value_soap_new_block_9 == ((struct soap_blist *)NULL))
            return 20;

          do
          {
            signed int c;
            unsigned long int i;
            char *s;
            if(soap->dime.size >= 8388609ul)
            {
              soap->error = 32;
              return soap->error;
            }

            void *return_value_soap_push_block_10;
            return_value_soap_push_block_10=soap_push_block(soap, (struct soap_blist *)(void *)0, soap->dime.size);
            s = (char *)return_value_soap_push_block_10;
            if(s == ((char *)NULL))
            {
              soap->error = 20;
              return soap->error;
            }

            i = soap->dime.size;
            for( ; i >= 1ul; i = i - 1ul)
            {
              _Bool tmp_if_expr_12;
              if(soap->bufidx >= soap->buflen)
              {
                return_value_soap_recv_11=soap_recv(soap);
                tmp_if_expr_12 = return_value_soap_recv_11 != 0 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_12 = (_Bool)0;
              signed int tmp_if_expr_14;
              if(tmp_if_expr_12)
                tmp_if_expr_14 = -1;

              else
              {
                tmp_post_13 = soap->bufidx;
                soap->bufidx = soap->bufidx + 1ul;
                tmp_if_expr_14 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_13];
              }
              c = tmp_if_expr_14;
              if(c == -1)
              {
                soap->error = -1;
                return soap->error;
              }

              char *tmp_post_15 = s;
              s = s + 1l;
              *tmp_post_15 = (char)c;
            }
            signed int return_value_soap_move_16;
            return_value_soap_move_16=soap_move(soap, (unsigned long int)(-((signed long int)soap->dime.size) & (signed long int)3));
            if(!(return_value_soap_move_16 == 0))
            {
              soap->error = -1;
              return soap->error;
            }

            if((0x01 & (signed int)soap->dime.flags) == 0)
              break;

            signed int return_value_soap_getdimehdr_17;
            return_value_soap_getdimehdr_17=soap_getdimehdr(soap);
            if(!(return_value_soap_getdimehdr_17 == 0))
              return soap->error;

          }
          while((_Bool)1);
          unsigned long int tmp_post_18 = soap->blist->size;
          soap->blist->size = soap->blist->size + 1ul;
          soap->dime.size = tmp_post_18;
          soap->dime.ptr=soap_save_block(soap, (struct soap_blist *)(void *)0, (char *)(void *)0, 0);
          if(soap->dime.ptr == ((char *)NULL))
            return soap->error;

          soap->dime.ptr[(signed long int)soap->dime.size] = (char)0;
          soap->dime.id = id;
          soap->dime.type = type;
          soap->dime.options = soap_getdime__1__2__1__2__options;
        }

        else
          soap->dime.ptr=soap_getdimefield(soap, soap->dime.size);
      content=soap_new_multipart(soap, &soap->dime.first, &soap->dime.last, soap->dime.ptr, soap->dime.size);
      if(content == ((struct soap_multipart *)NULL))
      {
        soap->error = 20;
        return soap->error;
      }

      content->id = soap->dime.id;
      content->type = soap->dime.type;
      content->options = soap->dime.options;
      if(!(soap->error == 0))
        return soap->error;

      soap_resolve_attachment(soap, content);
    }
    while((_Bool)1);
    if(!(soap->error == 35))
      return soap->error;

    else
    {
      soap->error = 0;
      return soap->error;
    }
  }
}

// soap_getdimefield
// file stdsoap2.c line 15598
static char * soap_getdimefield(struct soap *soap, unsigned long int n)
{
  signed int c;
  unsigned long int i;
  char *s;
  char *p = (char *)(void *)0;
  signed int return_value_soap_recv_3;
  unsigned long int tmp_post_5;
  if(!(n == 0ul))
  {
    void *return_value_soap_malloc_1;
    return_value_soap_malloc_1=soap_malloc(soap, n + (unsigned long int)1);
    p = (char *)return_value_soap_malloc_1;
    if(!(p == ((char *)NULL)))
    {
      s = p;
      i = n;
      for( ; i >= 1ul; i = i - 1ul)
      {
        _Bool tmp_if_expr_4;
        if(soap->bufidx >= soap->buflen)
        {
          return_value_soap_recv_3=soap_recv(soap);
          tmp_if_expr_4 = return_value_soap_recv_3 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_4 = (_Bool)0;
        signed int tmp_if_expr_6;
        if(tmp_if_expr_4)
          tmp_if_expr_6 = -1;

        else
        {
          tmp_post_5 = soap->bufidx;
          soap->bufidx = soap->bufidx + 1ul;
          tmp_if_expr_6 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_5];
        }
        c = tmp_if_expr_6;
        if(c == -1)
        {
          signed int tmp_if_expr_2;
          if(!(soap->error == 0))
            tmp_if_expr_2 = soap->error;

          else
            tmp_if_expr_2 = -1;
          soap->error = tmp_if_expr_2;
          return (char *)(void *)0;
        }

        char *tmp_post_7 = s;
        s = s + 1l;
        *tmp_post_7 = (char)c;
      }
      *s = (char)0;
      soap->error=soap_move(soap, (unsigned long int)(-((signed long int)n) & (signed long int)3));
      if(!(soap->error == 0))
        return (char *)(void *)0;

    }

    else
      soap->error = 20;
  }

  return p;
}

// soap_getdimehdr
// file stdsoap2.c line 15633
signed int soap_getdimehdr(struct soap *soap)
{
  signed int c;
  char *s;
  signed int i;
  unsigned char tmp[12l];
  unsigned long int optlen;
  unsigned long int idlen;
  unsigned long int typelen;
  if((0x00000080 & soap->mode) == 0)
  {
    soap->error = 35;
    return soap->error;
  }

  else
  {
    _Bool tmp_if_expr_4;
    if(!(soap->dime.buflen == 0ul))
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = soap->dime.chunksize != 0ul ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
    {
      unsigned long int return_value_soap_tell_2;
      return_value_soap_tell_2=soap_tell(soap);
      signed int return_value_soap_move_3;
      return_value_soap_move_3=soap_move(soap, soap->dime.size - return_value_soap_tell_2);
      if(!(return_value_soap_move_3 == 0))
      {
        signed int tmp_if_expr_1;
        if(!(soap->error == 0))
          tmp_if_expr_1 = soap->error;

        else
          tmp_if_expr_1 = -1;
        soap->error = tmp_if_expr_1;
        return soap->error;
      }

      soap->ahead=soap_getchar(soap);
      return 0;
    }

    s = (char *)tmp;
    i = 12;
    for( ; i >= 1; i = i - 1)
    {
      c=soap_getchar(soap);
      if(c == -1)
      {
        signed int tmp_if_expr_5;
        if(!(soap->error == 0))
          tmp_if_expr_5 = soap->error;

        else
          tmp_if_expr_5 = -1;
        soap->error = tmp_if_expr_5;
        return soap->error;
      }

      char *tmp_post_6 = s;
      s = s + 1l;
      *tmp_post_6 = (char)c;
    }
    if(!((0xF8 & (signed int)tmp[0l]) == 0x08))
    {
      soap->error = 34;
      return soap->error;
    }

    else
    {
      soap->dime.flags = (char)((signed int)tmp[(signed long int)0] & 0x7 | (signed int)tmp[(signed long int)1] & 0xF0);
      optlen = (unsigned long int)((signed int)tmp[(signed long int)2] << 8 | (signed int)tmp[(signed long int)3]);
      idlen = (unsigned long int)((signed int)tmp[(signed long int)4] << 8 | (signed int)tmp[(signed long int)5]);
      typelen = (unsigned long int)((signed int)tmp[(signed long int)6] << 8 | (signed int)tmp[(signed long int)7]);
      soap->dime.size = (unsigned long int)tmp[(signed long int)8] << 24 | (unsigned long int)tmp[(signed long int)9] << 16 | (unsigned long int)tmp[(signed long int)10] << 8 | (unsigned long int)tmp[(signed long int)11];
      soap->dime.options=soap_getdimefield(soap, optlen);
      if(soap->dime.options == ((const char *)NULL))
      {
        if(soap->error == 0)
          goto __CPROVER_DUMP_L14;

        return soap->error;
      }

      else
      {

      __CPROVER_DUMP_L14:
        ;
        soap->dime.id=soap_getdimefield(soap, idlen);
        if(soap->dime.id == ((const char *)NULL))
        {
          if(soap->error == 0)
            goto __CPROVER_DUMP_L15;

          return soap->error;
        }

        else
        {

        __CPROVER_DUMP_L15:
          ;
          soap->dime.type=soap_getdimefield(soap, typelen);
          if(soap->dime.type == ((const char *)NULL))
          {
            if(soap->error == 0)
              goto __CPROVER_DUMP_L16;

            return soap->error;
          }

          else
          {

          __CPROVER_DUMP_L16:
            ;
            if(!((0x02 & (signed int)soap->dime.flags) == 0))
              soap->mode = soap->mode & ~0x00000080;

            return 0;
          }
        }
      }
    }
  }
}

// soap_getelement
// file soapC.c line 184
void * soap_getelement(struct soap *soap, signed int *type)
{
  (void)type;
  signed int return_value_soap_peek_element_1;
  return_value_soap_peek_element_1=soap_peek_element(soap);
  char *return_value_soap_in_byte_3;
  signed int *return_value_soap_in_int_4;
  struct t__RoutingTable *return_value_soap_in_t__RoutingTable_5;
  struct t__Routing *return_value_soap_in_t__Routing_6;
  struct t__Routing **return_value_soap_in_PointerTot__Routing_7;
  char **s;
  char *tmp_if_expr_8;
  char **soap_getelement__1__1__2__s;
  char *tmp_if_expr_9;
  if(!(return_value_soap_peek_element_1 == 0))
    return (void *)0;

  else
  {
    _Bool tmp_if_expr_2;
    if(soap->id[0l] == 0)
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      *type=soap_lookup_type(soap, soap->id);
      tmp_if_expr_2 = !(*type != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
      *type=soap_lookup_type(soap, soap->href);

    switch(*type)
    {
      case 3:
      {
        return_value_soap_in_byte_3=soap_in_byte(soap, (const char *)(void *)0, (char *)(void *)0, "xsd:byte");
        return (void *)return_value_soap_in_byte_3;
      }
      case 1:
      {
        return_value_soap_in_int_4=soap_in_int(soap, (const char *)(void *)0, (signed int *)(void *)0, "xsd:int");
        return (void *)return_value_soap_in_int_4;
      }
      case 8:
      {
        return_value_soap_in_t__RoutingTable_5=soap_in_t__RoutingTable(soap, (const char *)(void *)0, (struct t__RoutingTable *)(void *)0, "t:RoutingTable");
        return (void *)return_value_soap_in_t__RoutingTable_5;
      }
      case 7:
      {
        return_value_soap_in_t__Routing_6=soap_in_t__Routing(soap, (const char *)(void *)0, (struct t__Routing *)(void *)0, "t:Routing");
        return (void *)return_value_soap_in_t__Routing_6;
      }
      case 9:
      {
        return_value_soap_in_PointerTot__Routing_7=soap_in_PointerTot__Routing(soap, (const char *)(void *)0, (struct t__Routing **)(void *)0, "t:Routing");
        return (void *)return_value_soap_in_PointerTot__Routing_7;
      }
      case 5:
      {
        s=soap_in__QName(soap, (const char *)(void *)0, (char **)(void *)0, "xsd:QName");
        if(!(s == ((char **)NULL)))
          tmp_if_expr_8 = *s;

        else
          tmp_if_expr_8 = (char *)(void *)0;
        return (void *)tmp_if_expr_8;
      }
      case 4:
      {
        soap_getelement__1__1__2__s=soap_in_string(soap, (const char *)(void *)0, (char **)(void *)0, "xsd:string");
        if(!(soap_getelement__1__1__2__s == ((char **)NULL)))
          tmp_if_expr_9 = *soap_getelement__1__1__2__s;

        else
          tmp_if_expr_9 = (char *)(void *)0;
        return (void *)tmp_if_expr_9;
      }
      default:
      {
        const char *t = soap->type;
        if(*t == 0)
          t = soap->tag;

        signed int return_value_soap_match_tag_11;
        return_value_soap_match_tag_11=soap_match_tag(soap, t, "xsd:byte");
        if(return_value_soap_match_tag_11 == 0)
        {
          *type = 3;
          char *return_value_soap_in_byte_10;
          return_value_soap_in_byte_10=soap_in_byte(soap, (const char *)(void *)0, (char *)(void *)0, (const char *)(void *)0);
          return (void *)return_value_soap_in_byte_10;
        }

        signed int return_value_soap_match_tag_13;
        return_value_soap_match_tag_13=soap_match_tag(soap, t, "xsd:int");
        if(return_value_soap_match_tag_13 == 0)
        {
          *type = 1;
          signed int *return_value_soap_in_int_12;
          return_value_soap_in_int_12=soap_in_int(soap, (const char *)(void *)0, (signed int *)(void *)0, (const char *)(void *)0);
          return (void *)return_value_soap_in_int_12;
        }

        signed int return_value_soap_match_tag_15;
        return_value_soap_match_tag_15=soap_match_tag(soap, t, "t:RoutingTable");
        if(return_value_soap_match_tag_15 == 0)
        {
          *type = 8;
          struct t__RoutingTable *return_value_soap_in_t__RoutingTable_14;
          return_value_soap_in_t__RoutingTable_14=soap_in_t__RoutingTable(soap, (const char *)(void *)0, (struct t__RoutingTable *)(void *)0, (const char *)(void *)0);
          return (void *)return_value_soap_in_t__RoutingTable_14;
        }

        signed int return_value_soap_match_tag_17;
        return_value_soap_match_tag_17=soap_match_tag(soap, t, "t:Routing");
        if(return_value_soap_match_tag_17 == 0)
        {
          *type = 7;
          struct t__Routing *return_value_soap_in_t__Routing_16;
          return_value_soap_in_t__Routing_16=soap_in_t__Routing(soap, (const char *)(void *)0, (struct t__Routing *)(void *)0, (const char *)(void *)0);
          return (void *)return_value_soap_in_t__Routing_16;
        }

        signed int return_value_soap_match_tag_19;
        return_value_soap_match_tag_19=soap_match_tag(soap, t, "xsd:QName");
        if(return_value_soap_match_tag_19 == 0)
        {
          char **soap_getelement__1__1__3__5__s;
          *type = 5;
          soap_getelement__1__1__3__5__s=soap_in__QName(soap, (const char *)(void *)0, (char **)(void *)0, (const char *)(void *)0);
          char *tmp_if_expr_18;
          if(!(soap_getelement__1__1__3__5__s == ((char **)NULL)))
            tmp_if_expr_18 = *soap_getelement__1__1__3__5__s;

          else
            tmp_if_expr_18 = (char *)(void *)0;
          return (void *)tmp_if_expr_18;
        }

        signed int return_value_soap_match_tag_21;
        return_value_soap_match_tag_21=soap_match_tag(soap, t, "xsd:string");
        if(return_value_soap_match_tag_21 == 0)
        {
          char **soap_getelement__1__1__3__6__s;
          *type = 4;
          soap_getelement__1__1__3__6__s=soap_in_string(soap, (const char *)(void *)0, (char **)(void *)0, (const char *)(void *)0);
          char *tmp_if_expr_20;
          if(!(soap_getelement__1__1__3__6__s == ((char **)NULL)))
            tmp_if_expr_20 = *soap_getelement__1__1__3__6__s;

          else
            tmp_if_expr_20 = (char *)(void *)0;
          return (void *)tmp_if_expr_20;
        }

        t = soap->tag;
        soap->error = 3;
        return (void *)0;
      }
    }
  }
}

// soap_getfault
// file soapC.c line 94
signed int soap_getfault(struct soap *soap)
{
  soap->fault=soap_get_SOAP_ENV__Fault(soap, (struct SOAP_ENV__Fault *)(void *)0, "SOAP-ENV:Fault", (const char *)(void *)0);
  return (signed int)(soap->fault == (struct SOAP_ENV__Fault *)(void *)0);
}

// soap_getheader
// file soapC.c line 30
signed int soap_getheader(struct soap *soap)
{
  soap->part = (signed short int)3;
  soap->header=soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, (const char *)(void *)0);
  soap->part = (signed short int)4;
  return (signed int)(soap->header == (struct SOAP_ENV__Header *)(void *)0);
}

// soap_gethex
// file stdsoap2.c line 1910
unsigned char * soap_gethex(struct soap *soap, signed int *n)
{
  soap->labidx = (unsigned long int)0;
  void *return_value_memcpy_4;
  do
  {
    char *s;
    unsigned long int i;
    unsigned long int k;
    signed int return_value_soap_append_lab_1;
    return_value_soap_append_lab_1=soap_append_lab(soap, (const char *)(void *)0, (unsigned long int)0);
    if(!(return_value_soap_append_lab_1 == 0))
      return (unsigned char *)(void *)0;

    s = soap->labbuf + (signed long int)soap->labidx;
    k = soap->lablen - soap->labidx;
    soap->labidx = soap->lablen;
    i = (unsigned long int)0;
    for( ; !(i >= k); i = i + 1ul)
    {
      char d1;
      char d2;
      signed int c;
      c=soap_get(soap);
      signed int return_value_soap_isxdigit_5;
      return_value_soap_isxdigit_5=soap_isxdigit(c);
      if(!(return_value_soap_isxdigit_5 == 0))
      {
        d1 = (char)c;
        c=soap_get(soap);
        signed int return_value_soap_isxdigit_2;
        return_value_soap_isxdigit_2=soap_isxdigit(c);
        if(!(return_value_soap_isxdigit_2 == 0))
          d2 = (char)c;

        else
        {
          soap->error = 4;
          return (unsigned char *)(void *)0;
        }
      }

      else
      {
        unsigned char *p;
        unsigned long int l = (soap->lablen + i) - k;
        soap->ahead = c;
        if(!(n == ((signed int *)NULL)))
          *n = (signed int)l;

        void *return_value_soap_malloc_3;
        return_value_soap_malloc_3=soap_malloc(soap, l);
        p = (unsigned char *)return_value_soap_malloc_3;
        if(!(p == ((unsigned char *)NULL)))
        {
          if(!(p == ((unsigned char *)NULL)))
          {
            return_value_memcpy_4=memcpy((void *)p, (const void *)soap->labbuf, l);
            (signed int)!(return_value_memcpy_4 != NULL);
          }

          else
            34;
        }

        return p;
      }
      char *tmp_post_6 = s;
      s = s + 1l;
      *tmp_post_6 = (char)((((signed int)d1 >= 65 ? ((signed int)d1 & 0x7) + 9 : (signed int)d1 - 48) << 4) + ((signed int)d2 >= 65 ? ((signed int)d2 & 0x7) + 9 : (signed int)d2 - 48));
    }
  }
  while((_Bool)1);
}

// soap_getindependent
// file soapC.c line 169
signed int soap_getindependent(struct soap *soap)
{
  signed int t;
  signed int return_value_soap_ignore_element_2;
  if((signed int)soap->version == 1)
    do
    {
      void *return_value_soap_getelement_4;
      return_value_soap_getelement_4=soap_getelement(soap, &t);
      if(return_value_soap_getelement_4 == NULL)
      {
        _Bool tmp_if_expr_1;
        if(!(soap->error == 0))
          tmp_if_expr_1 = soap->error != 3 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        _Bool tmp_if_expr_3;
        if(tmp_if_expr_1)
          tmp_if_expr_3 = (_Bool)1;

        else
        {
          return_value_soap_ignore_element_2=soap_ignore_element(soap);
          tmp_if_expr_3 = return_value_soap_ignore_element_2 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_3)
          break;

      }

    }
    while((_Bool)1);

  _Bool tmp_if_expr_5;
  if(soap->error == 6)
    tmp_if_expr_5 = (_Bool)1;

  else
    tmp_if_expr_5 = soap->error == -1 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_5)
    soap->error = 0;

  return soap->error;
}

// soap_getline
// file ../../../gsoap/stdsoap2.h line 3003
signed int soap_getline(struct soap *soap, char *buf, signed int len)
{
  char *s = buf;
  signed int i = len;
  signed int c = 0;
  signed int return_value_soap_recv_3;
  do
  {

  __CPROVER_DUMP_L1:
    ;
    i = i - 1;
    if(i >= 1)
    {
      c=soap_getchar(soap);
      if(!(c == 10) && !(c == 13))
      {
        if(c == -1)
        {
          signed int tmp_if_expr_1;
          if(!(soap->error == 0))
            tmp_if_expr_1 = soap->error;

          else
            tmp_if_expr_1 = -1;
          soap->error = tmp_if_expr_1;
          return soap->error;
        }

        char *tmp_post_2 = s;
        s = s + 1l;
        *tmp_post_2 = (char)c;
        goto __CPROVER_DUMP_L1;
      }

    }

    *s = (char)0;
    if(!(c == 10))
      c=soap_getchar(soap);

    if(c == 10)
    {
      if(1 + i == len)
        break;

      _Bool tmp_if_expr_4;
      if(soap->bufidx >= soap->buflen)
      {
        return_value_soap_recv_3=soap_recv(soap);
        tmp_if_expr_4 = return_value_soap_recv_3 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_4 = (_Bool)0;
      signed int tmp_if_expr_5;
      if(tmp_if_expr_4)
        tmp_if_expr_5 = -1;

      else
        tmp_if_expr_5 = (signed int)(unsigned char)soap->buf[(signed long int)soap->bufidx];
      c = tmp_if_expr_5;
      if(!(c == 9) && !(c == 32))
        break;

    }

    else
      if(c == -1)
      {
        signed int tmp_if_expr_6;
        if(!(soap->error == 0))
          tmp_if_expr_6 = soap->error;

        else
          tmp_if_expr_6 = -1;
        soap->error = tmp_if_expr_6;
        return soap->error;
      }

    if(!(i >= 1))
    {
      soap->error = 22;
      return soap->error;
    }

  }
  while((_Bool)1);
  return 0;
}

// soap_getmime
// file stdsoap2.c line 15868
signed int soap_getmime(struct soap *soap)
{
  struct soap_multipart *return_value_soap_get_mime_attachment_1;
  do
  {
    return_value_soap_get_mime_attachment_1=soap_get_mime_attachment(soap, (void *)0);
    if(return_value_soap_get_mime_attachment_1 == ((struct soap_multipart *)NULL))
      break;

  }
  while((_Bool)1);
  return soap->error;
}

// soap_getmimehdr
// file stdsoap2.c line 15804
signed int soap_getmimehdr(struct soap *soap)
{
  struct soap_multipart *content;
  do
  {
    signed int return_value_soap_getline_1;
    return_value_soap_getline_1=soap_getline(soap, soap->msgbuf, (signed int)sizeof(char [1024l]) /*1024ul*/ );
    if(!(return_value_soap_getline_1 == 0))
      return soap->error;

  }
  while(soap->msgbuf[0l] == 0);
  if((signed int)soap->msgbuf[0l] == 45)
  {
    if((signed int)soap->msgbuf[1l] == 45)
    {
      char *s;
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(soap->msgbuf);
      s = (soap->msgbuf + (signed long int)return_value_strlen_2) - (signed long int)1;
      for( ; 1 + (signed int)*s >= 1; s = s - 1l)
        if((signed int)*s >= 33)
          break;

      s[(signed long int)1] = (char)0;
      if(!(soap->mime.boundary == ((char *)NULL)))
      {
        signed int return_value_strcmp_3;
        return_value_strcmp_3=strcmp(soap->msgbuf + (signed long int)2, soap->mime.boundary);
        if(!(return_value_strcmp_3 == 0))
        {
          soap->error = 36;
          return soap->error;
        }

      }

      else
        soap->mime.boundary=soap_strdup(soap, soap->msgbuf + (signed long int)2);
      signed int return_value_soap_getline_4;
      return_value_soap_getline_4=soap_getline(soap, soap->msgbuf, (signed int)sizeof(char [1024l]) /*1024ul*/ );
      if(!(return_value_soap_getline_4 == 0))
        return soap->error;

    }

  }

  signed int return_value_soap_set_mime_attachment_5;
  return_value_soap_set_mime_attachment_5=soap_set_mime_attachment(soap, (char *)(void *)0, (unsigned long int)0, (enum soap_mime_encoding)SOAP_MIME_NONE, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0, (const char *)(void *)0);
  _Bool tmp_if_expr_6;
  signed int return_value_soap_tag_cmp_14;
  signed int return_value_soap_tag_cmp_12;
  const char *return_value_soap_get_header_attribute_7;
  signed int return_value_soap_tag_cmp_11;
  signed int return_value_soap_tag_cmp_10;
  signed int return_value_soap_tag_cmp_9;
  signed long int return_value_soap_code_int_8;
  if(!(return_value_soap_set_mime_attachment_5 == 0))
  {
    soap->error = 20;
    return soap->error;
  }

  else
  {
    content = soap->mime.last;
    do
    {
      char *key = soap->msgbuf;
      char *val;
      if(*key == 0)
        break;

      val=strchr(soap->msgbuf, 58);
      if(!(val == ((char *)NULL)))
      {
        *val = (char)0;
        do
        {
          val = val + 1l;
          if(!(*val == 0))
            tmp_if_expr_6 = (signed int)*val <= 32 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_6 = (_Bool)0;
        }
        while(tmp_if_expr_6);
        signed int return_value_soap_tag_cmp_15;
        return_value_soap_tag_cmp_15=soap_tag_cmp(key, "Content-ID");
        if(return_value_soap_tag_cmp_15 == 0)
          content->id=soap_strdup(soap, val);

        else
        {
          return_value_soap_tag_cmp_14=soap_tag_cmp(key, "Content-Location");
          if(return_value_soap_tag_cmp_14 == 0)
            content->location=soap_strdup(soap, val);

          else
          {
            _Bool tmp_if_expr_13;
            if(content->id == ((const char *)NULL))
            {
              return_value_soap_tag_cmp_12=soap_tag_cmp(key, "Content-Disposition");
              tmp_if_expr_13 = !(return_value_soap_tag_cmp_12 != 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_13 = (_Bool)0;
            if(tmp_if_expr_13)
            {
              return_value_soap_get_header_attribute_7=soap_get_header_attribute(soap, val, "name");
              content->id=soap_strdup(soap, return_value_soap_get_header_attribute_7);
            }

            else
            {
              return_value_soap_tag_cmp_11=soap_tag_cmp(key, "Content-Type");
              if(return_value_soap_tag_cmp_11 == 0)
                content->type=soap_strdup(soap, val);

              else
              {
                return_value_soap_tag_cmp_10=soap_tag_cmp(key, "Content-Description");
                if(return_value_soap_tag_cmp_10 == 0)
                  content->description=soap_strdup(soap, val);

                else
                {
                  return_value_soap_tag_cmp_9=soap_tag_cmp(key, "Content-Transfer-Encoding");
                  if(return_value_soap_tag_cmp_9 == 0)
                  {
                    return_value_soap_code_int_8=soap_code_int(mime_codes, val, (signed long int)SOAP_MIME_NONE);
                    content->encoding = (enum soap_mime_encoding)return_value_soap_code_int_8;
                  }

                }
              }
            }
          }
        }
      }

      signed int return_value_soap_getline_16;
      return_value_soap_getline_16=soap_getline(soap, key, (signed int)sizeof(char [1024l]) /*1024ul*/ );
      if(!(return_value_soap_getline_16 == 0))
        return soap->error;

    }
    while((_Bool)1);
    return 0;
  }
}

// soap_getoffsets
// file stdsoap2.c line 2865
signed int soap_getoffsets(const char *attr, const signed int *size, signed int *offset, signed int dim)
{
  signed int i;
  signed int j = 0;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  if(!(offset == ((signed int *)NULL)))
  {
    i = 0;
    do
    {
      if(!(attr == ((const char *)NULL)) && !(i >= dim))
        tmp_if_expr_1 = *attr != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(!tmp_if_expr_1)
        break;

      attr = attr + 1l;
      j = j * size[(signed long int)i];
      signed long int return_value_strtol_2;
      return_value_strtol_2=strtol(attr, (char ** restrict )(void *)0, 10);
      offset[(signed long int)i] = (signed int)return_value_strtol_2;
      j = j + offset[(signed long int)i];
      attr=strchr(attr, 44);
      i = i + 1;
    }
    while((_Bool)1);
  }

  else
  {
    i = 0;
    do
    {
      if(!(attr == ((const char *)NULL)) && !(i >= dim))
        tmp_if_expr_3 = *attr != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(!tmp_if_expr_3)
        break;

      attr = attr + 1l;
      j = j * size[(signed long int)i];
      signed long int return_value_strtol_4;
      return_value_strtol_4=strtol(attr, (char ** restrict )(void *)0, 10);
      j = j + (signed int)return_value_strtol_4;
      attr=strchr(attr, 44);
      i = i + 1;
    }
    while((_Bool)1);
  }
  return j;
}

// soap_getposition
// file stdsoap2.c line 2893
signed int soap_getposition(const char *attr, signed int *pos)
{
  signed int i;
  signed int n;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if(*attr == 0)
    return -1;

  else
  {
    n = 0;
    i = 1;
    do
    {
      signed int tmp_post_3 = n;
      n = n + 1;
      signed long int return_value_strtol_4;
      return_value_strtol_4=strtol(attr + (signed long int)i, (char ** restrict )(void *)0, 10);
      pos[(signed long int)tmp_post_3] = (signed int)return_value_strtol_4;
      for( ; !(attr[(signed long int)i] == 0); i = i + 1)
      {
        if((signed int)attr[(signed long int)i] == 44)
          break;

        if((signed int)attr[(signed long int)i] == 93)
          break;

      }
      if((signed int)attr[(signed long int)i] == 44)
        i = i + 1;

      if(!(n >= 16))
        tmp_if_expr_1 = attr[(signed long int)i] != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
        tmp_if_expr_2 = (signed int)attr[(signed long int)i] != 93 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
    }
    while(tmp_if_expr_2);
    return n;
  }
}

// soap_getsizes
// file stdsoap2.c line 2840
unsigned long int soap_getsizes(const char *attr, signed int *size, signed int dim)
{
  unsigned long int i;
  unsigned long int k;
  unsigned long int n;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if(*attr == 0)
    return (unsigned long int)0;

  else
  {
    i=strlen(attr);
    n = (unsigned long int)1;

  __CPROVER_DUMP_L2:
    ;
    while((_Bool)1)
    {
      if(i >= 1ul)
      {
        _Bool tmp_if_expr_3;
        if((signed int)attr[-1l + (signed long int)i] == 91)
          tmp_if_expr_3 = (_Bool)1;

        else
          tmp_if_expr_3 = (signed int)attr[(signed long int)(i - (unsigned long int)1)] == 44 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr_4;
        if(tmp_if_expr_3)
          tmp_if_expr_4 = (_Bool)1;

        else
          tmp_if_expr_4 = (signed int)attr[(signed long int)(i - (unsigned long int)1)] == 32 ? (_Bool)1 : (_Bool)0;
        if(!tmp_if_expr_4)
        {
          i = i - 1ul;
          goto __CPROVER_DUMP_L2;
        }

      }

      unsigned long int return_value_strtoul_5;
      return_value_strtoul_5=strtoul(attr + (signed long int)i, (char ** restrict )(void *)0, 10);
      k = (unsigned long int)return_value_strtoul_5;
      n = n * k;
      dim = dim - 1;
      size[(signed long int)dim] = (signed int)k;
      if(n >= 100001ul)
        return (unsigned long int)0;

      if(dim >= 1)
      {
        i = i - 1ul;
        tmp_if_expr_1 = i > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
        tmp_if_expr_2 = (signed int)attr[(signed long int)i] != 91 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(!tmp_if_expr_2)
        break;

    }
    return n;
  }
}

// soap_getutf8
// file stdsoap2.c line 1831
signed int soap_getutf8(struct soap *soap)
{
  signed int c;
  signed int c1;
  signed int c2;
  signed int c3;
  signed int c4;
  c = soap->ahead;
  if(c >= 0x80)
    soap->ahead = 0;

  else
    c=soap_get(soap);
  _Bool tmp_if_expr_1;
  if(c >= 256 || !(c >= 0x80))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (soap->mode & 0x00000020) != 0 ? (_Bool)1 : (_Bool)0;
  signed int return_value_soap_recv_2;
  unsigned long int tmp_post_4;
  signed int return_value_soap_recv_6;
  unsigned long int tmp_post_8;
  signed int return_value_soap_recv_10;
  unsigned long int tmp_post_12;
  signed int return_value_soap_recv_14;
  unsigned long int tmp_post_16;
  signed int return_value_soap_recv_18;
  unsigned long int tmp_post_20;
  if(tmp_if_expr_1)
    return c;

  else
  {
    _Bool tmp_if_expr_3;
    if(soap->bufidx >= soap->buflen)
    {
      return_value_soap_recv_2=soap_recv(soap);
      tmp_if_expr_3 = return_value_soap_recv_2 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    signed int tmp_if_expr_5;
    if(tmp_if_expr_3)
      tmp_if_expr_5 = -1;

    else
    {
      tmp_post_4 = soap->bufidx;
      soap->bufidx = soap->bufidx + 1ul;
      tmp_if_expr_5 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_4];
    }
    c1 = tmp_if_expr_5;
    if(!(c1 >= 0x80))
    {
      soap->bufidx = soap->bufidx - 1ul;
      return c;
    }

    else
    {
      c1 = c1 & 0x3F;
      if(!(c >= 0xE0))
        return (signed int)(c & 0x1F) << 6 | c1;

      else
      {
        _Bool tmp_if_expr_7;
        if(soap->bufidx >= soap->buflen)
        {
          return_value_soap_recv_6=soap_recv(soap);
          tmp_if_expr_7 = return_value_soap_recv_6 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_7 = (_Bool)0;
        signed int tmp_if_expr_9;
        if(tmp_if_expr_7)
          tmp_if_expr_9 = -1;

        else
        {
          tmp_post_8 = soap->bufidx;
          soap->bufidx = soap->bufidx + 1ul;
          tmp_if_expr_9 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_8];
        }
        c2 = (signed int)tmp_if_expr_9 & 0x3F;
        if(!(c >= 0xF0))
          return (signed int)(c & 0x0F) << 12 | c1 << 6 | c2;

        else
        {
          _Bool tmp_if_expr_11;
          if(soap->bufidx >= soap->buflen)
          {
            return_value_soap_recv_10=soap_recv(soap);
            tmp_if_expr_11 = return_value_soap_recv_10 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_11 = (_Bool)0;
          signed int tmp_if_expr_13;
          if(tmp_if_expr_11)
            tmp_if_expr_13 = -1;

          else
          {
            tmp_post_12 = soap->bufidx;
            soap->bufidx = soap->bufidx + 1ul;
            tmp_if_expr_13 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_12];
          }
          c3 = (signed int)tmp_if_expr_13 & 0x3F;
          if(!(c >= 0xF8))
            return (signed int)(c & 0x07) << 18 | c1 << 12 | c2 << 6 | c3;

          else
          {
            _Bool tmp_if_expr_15;
            if(soap->bufidx >= soap->buflen)
            {
              return_value_soap_recv_14=soap_recv(soap);
              tmp_if_expr_15 = return_value_soap_recv_14 != 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_15 = (_Bool)0;
            signed int tmp_if_expr_17;
            if(tmp_if_expr_15)
              tmp_if_expr_17 = -1;

            else
            {
              tmp_post_16 = soap->bufidx;
              soap->bufidx = soap->bufidx + 1ul;
              tmp_if_expr_17 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_16];
            }
            c4 = (signed int)tmp_if_expr_17 & 0x3F;
            if(!(c >= 0xFC))
              return (signed int)(c & 0x03) << 24 | c1 << 18 | c2 << 12 | c3 << 6 | c4;

            else
            {
              _Bool tmp_if_expr_19;
              if(soap->bufidx >= soap->buflen)
              {
                return_value_soap_recv_18=soap_recv(soap);
                tmp_if_expr_19 = return_value_soap_recv_18 != 0 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_19 = (_Bool)0;
              signed int tmp_if_expr_21;
              if(tmp_if_expr_19)
                tmp_if_expr_21 = -1;

              else
              {
                tmp_post_20 = soap->bufidx;
                soap->bufidx = soap->bufidx + 1ul;
                tmp_if_expr_21 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_20];
              }
              return (signed int)(c & 0x01) << 30 | c1 << 24 | c2 << 18 | c3 << 12 | c4 << 6 | (signed int)(tmp_if_expr_21 & 0x3F);
            }
          }
        }
      }
    }
  }
}

// soap_has_copies
// file stdsoap2.c line 2474
static signed int soap_has_copies(struct soap *soap, const char *start, const char *end)
{
  signed int i;
  struct soap_ilist *ip = (struct soap_ilist *)(void *)0;
  struct soap_flist *fp = (struct soap_flist *)(void *)0;
  const char *p;
  i = 0;
  for( ; !(i >= 1999); i = i + 1)
  {
    ip = soap->iht[(signed long int)i];
    for( ; !(ip == ((struct soap_ilist *)NULL)); ip = ip->next)
    {
      p = (const char *)ip->copy;
      for( ; !(p == ((const char *)NULL)); p = *((const char **)p))
        if(p >= start && !(p >= end))
          return -1;

      fp = ip->flist;
      for( ; !(fp == ((struct soap_flist *)NULL)); fp = fp->next)
        if(fp->type == ip->type)
        {
          if((const char *)fp->ptr >= start)
          {
            if(!((const char *)fp->ptr >= end))
              return -1;

          }

        }

    }
  }
  return 0;
}

// soap_hash
// file stdsoap2.c line 7416
unsigned long int soap_hash(const char *s)
{
  unsigned long int h = (unsigned long int)0;
  while(!(*s == 0))
  {
    const char *tmp_post_1 = s;
    s = s + 1l;
    h = (unsigned long int)65599 * h + (unsigned long int)*tmp_post_1;
  }
  return h % (unsigned long int)1999;
}

// soap_header
// file soapC.c line 55
void soap_header(struct soap *soap)
{
  if(soap->header == ((struct SOAP_ENV__Header *)NULL))
  {
    void *return_value_soap_malloc_1;
    return_value_soap_malloc_1=soap_malloc(soap, sizeof(struct SOAP_ENV__Header) /*1ul*/ );
    soap->header = (struct SOAP_ENV__Header *)return_value_soap_malloc_1;
    if(!(soap->header == ((struct SOAP_ENV__Header *)NULL)))
      soap_default_SOAP_ENV__Header(soap, soap->header);

  }

}

// soap_hex2s
// file stdsoap2.c line 17473
const char * soap_hex2s(struct soap *soap, const char *s, char *t, unsigned long int l, signed int *n)
{
  const char *p;
  _Bool tmp_if_expr_1;
  if(s == ((const char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*s != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    if(!(n == ((signed int *)NULL)))
      *n = 0;

    if(!(soap->error == 0))
      return (const char *)(void *)0;

    return soap_padding;
  }

  else
  {
    if(t == ((char *)NULL))
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(s);
      l = return_value_strlen_2 / (unsigned long int)2 + (unsigned long int)1;
      void *return_value_soap_malloc_3;
      return_value_soap_malloc_3=soap_malloc(soap, l);
      t = (char *)return_value_soap_malloc_3;
    }

    if(t == ((char *)NULL))
      return (const char *)(void *)0;

    else
    {
      p = t;
      while(!(l == 0ul))
      {
        signed int d1;
        signed int d2;
        const char *tmp_post_4 = s;
        s = s + 1l;
        d1 = (signed int)*tmp_post_4;
        if(d1 == 0)
          break;

        const char *tmp_post_5 = s;
        s = s + 1l;
        d2 = (signed int)*tmp_post_5;
        if(d2 == 0)
          break;

        char *tmp_post_6 = t;
        t = t + 1l;
        *tmp_post_6 = (char)(((d1 >= 65 ? (d1 & 0x7) + 9 : d1 - 48) << 4) + (d2 >= 65 ? (d2 & 0x7) + 9 : d2 - 48));
        l = l - 1ul;
      }
      if(!(n == ((signed int *)NULL)))
        *n = (signed int)(t - p);

      if(!(l == 0ul))
        *t = (char)0;

      return p;
    }
  }
}

// soap_id_enter
// file ../../../gsoap/stdsoap2.h line 3026
void * soap_id_enter(struct soap *soap, const char *id, void *p, signed int t, unsigned long int n, const char *type, const char *arrayType, void * (*finstantiate)(struct soap *, signed int, const char *, const char *, unsigned long int *), signed int (*fbase)(signed int, signed int))
{
  struct soap_ilist *ip;
  (void)id;
  (void)fbase;
  soap->alloced = 0;
  if(p == NULL)
  {
    if(!(finstantiate == ((void * (*)(struct soap *, signed int, const char *, const char *, unsigned long int *))NULL)))
      p=finstantiate(soap, t, type, arrayType, &n);

    else
    {
      p=soap_malloc(soap, n);
      soap->alloced = t;
    }
  }

  _Bool tmp_if_expr_1;
  if(id == ((const char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*id != 0) ? (_Bool)1 : (_Bool)0;
  signed int return_value_soap_is_shaky_2;
  _Bool tmp_if_expr_6;
  signed int return_value;
  _Bool tmp_if_expr_8;
  signed int return_value_soap_type_punned_7;
  signed int return_value_soap_is_shaky_3;
  if(tmp_if_expr_1)
    return p;

  else
  {
    ip=soap_lookup(soap, id);
    if(ip == ((struct soap_ilist *)NULL))
    {
      ip=soap_enter(soap, id, t, n);
      if(ip == ((struct soap_ilist *)NULL))
        return (void *)0;

      ip->ptr = p;
      if(soap->alloced == 0)
      {
        return_value_soap_is_shaky_2=soap_is_shaky(soap, p);
        ip->shaky = (signed short int)return_value_soap_is_shaky_2;
      }

    }

    else
      if(!(ip->ptr == NULL))
      {
        strncpy(soap->id, id, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
        soap->id[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
        (void)(soap->id[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
        soap->error = 24;
        return (void *)0;
      }

      else
      {
        _Bool tmp_if_expr_5;
        if(!(ip->type == t))
          tmp_if_expr_5 = (_Bool)1;

        else
          tmp_if_expr_5 = ip->size != n ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr_9;
        if(tmp_if_expr_5)
        {
          if(fbase == ((signed int (*)(signed int, signed int))NULL))
            tmp_if_expr_6 = (_Bool)1;

          else
          {
            return_value=fbase(t, ip->type);
            tmp_if_expr_6 = !(return_value != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_6)
            tmp_if_expr_8 = (_Bool)1;

          else
          {
            return_value_soap_type_punned_7=soap_type_punned(soap, ip);
            tmp_if_expr_8 = return_value_soap_type_punned_7 != 0 ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_9 = tmp_if_expr_8 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_9 = (_Bool)0;
        if(tmp_if_expr_9)
        {
          soap_id_nullify(soap, id);
          return (void *)0;
        }

        else
        {
          ip->type = t;
          ip->size = n;
          ip->ptr = p;
          if(soap->alloced == 0)
          {
            return_value_soap_is_shaky_3=soap_is_shaky(soap, p);
            ip->shaky = (signed short int)return_value_soap_is_shaky_3;
          }

          _Bool tmp_if_expr_4;
          if(!(soap->alloced == 0))
            tmp_if_expr_4 = (_Bool)1;

          else
            tmp_if_expr_4 = !(ip->shaky != 0) ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_4)
          {
            void **q;
            if(!(ip->spine == ((void **)NULL)))
              ip->spine[(signed long int)0] = p;

            q = (void **)ip->link;
            while(!(q == ((void **)NULL)))
            {
              void *r = *q;
              *q = p;
              q = (void **)r;
            }
            ip->link = (void *)0;
          }

        }
      }
    return ip->ptr;
  }
}

// soap_id_forward
// file ../../../gsoap/stdsoap2.h line 3023
void * soap_id_forward(struct soap *soap, const char *href, void *p, unsigned long int i, signed int t, signed int tt, unsigned long int n, unsigned int k, void (*finsert)(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **), signed int (*fbase)(signed int, signed int))
{
  struct soap_ilist *ip;
  _Bool tmp_if_expr_1;
  if(p == NULL || href == ((const char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*href != 0) ? (_Bool)1 : (_Bool)0;
  signed int return_value;
  signed int return_value_soap_type_punned_4;
  signed int return_value_1;
  if(tmp_if_expr_1)
    return p;

  else
  {
    ip=soap_lookup(soap, href);
    if(ip == ((struct soap_ilist *)NULL))
    {
      ip=soap_enter(soap, href, t, n);
      if(ip == ((struct soap_ilist *)NULL))
        return (void *)0;

    }

    else
    {
      _Bool tmp_if_expr_2;
      if(!(ip->type == t))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = ip->size != n ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
      {
        if(k == 0u)
        {
          soap_id_nullify(soap, href);
          return (void *)0;
        }

      }

    }
    if(!(finsert == ((void (*)(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **))NULL)) || !(n >= sizeof(void *) /*8ul*/ ))
    {
      struct soap_flist *fp;
      void *return_value_malloc_3;
      return_value_malloc_3=malloc(sizeof(struct soap_flist) /*48ul*/ );
      fp = (struct soap_flist *)return_value_malloc_3;
      if(fp == ((struct soap_flist *)NULL))
      {
        soap->error = 20;
        return (void *)0;
      }

      if(!(fbase == ((signed int (*)(signed int, signed int))NULL)))
      {
        return_value=fbase(t, ip->type);
        if(!(return_value == 0))
        {
          return_value_soap_type_punned_4=soap_type_punned(soap, ip);
          if(return_value_soap_type_punned_4 == 0)
          {
            ip->type = t;
            ip->size = n;
          }

        }

      }

      _Bool tmp_if_expr_6;
      if(!(ip->type == t))
        tmp_if_expr_6 = (_Bool)1;

      else
        tmp_if_expr_6 = ip->size != n ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_6)
      {
        _Bool tmp_if_expr_5;
        if(fbase == ((signed int (*)(signed int, signed int))NULL))
          tmp_if_expr_5 = (_Bool)1;

        else
        {
          return_value_1=fbase(ip->type, t);
          tmp_if_expr_5 = !(return_value_1 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_5)
        {
          soap_id_nullify(soap, href);
          return (void *)0;
        }

      }

      fp->next = ip->flist;
      fp->type = tt;
      fp->ptr = p;
      fp->level = k;
      fp->index = i;
      fp->finsert = finsert;
      ip->flist = fp;
    }

    else
    {
      *((void **)p) = ip->copy;
      ip->copy = p;
    }
    signed int return_value_soap_is_shaky_7;
    return_value_soap_is_shaky_7=soap_is_shaky(soap, p);
    ip->shaky = (signed short int)return_value_soap_is_shaky_7;
    return p;
  }
}

// soap_id_lookup
// file ../../../gsoap/stdsoap2.h line 3022
void * soap_id_lookup(struct soap *soap, const char *id, void **p, signed int t, unsigned long int n, unsigned int k, signed int (*fbase)(signed int, signed int))
{
  struct soap_ilist *ip;
  _Bool tmp_if_expr_1;
  if(p == ((void **)NULL) || id == ((const char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*id != 0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_10;
  signed int return_value_1;
  _Bool tmp_if_expr_12;
  signed int return_value_2;
  _Bool tmp_if_expr_14;
  signed int return_value_soap_type_punned_13;
  signed int return_value;
  signed int return_value_soap_type_punned_4;
  if(tmp_if_expr_1)
    return (void *)p;

  else
  {
    ip=soap_lookup(soap, id);
    if(ip == ((struct soap_ilist *)NULL))
    {
      ip=soap_enter(soap, id, t, n);
      if(ip == ((struct soap_ilist *)NULL))
        return (void *)0;

      *p = (void *)0;
      if(!(k == 0u))
      {
        signed int soap_id_lookup__1__1__1__i;
        if(k >= 5u)
          return (void *)0;

        void *return_value_soap_malloc_2;
        return_value_soap_malloc_2=soap_malloc(soap, (unsigned long int)4 * sizeof(void *) /*8ul*/ );
        ip->spine = (void **)return_value_soap_malloc_2;
        if(ip->spine == ((void **)NULL))
          return (void *)0;

        ip->spine[(signed long int)0] = (void *)0;
        soap_id_lookup__1__1__1__i = 1;
        for( ; !(soap_id_lookup__1__1__1__i >= 4); soap_id_lookup__1__1__1__i = soap_id_lookup__1__1__1__i + 1)
          ip->spine[(signed long int)soap_id_lookup__1__1__1__i] = (void *)&ip->spine[(signed long int)(soap_id_lookup__1__1__1__i - 1)];
        *p = (void *)&ip->spine[(signed long int)(k - (unsigned int)1)];
      }

      else
      {
        ip->link = (void *)p;
        signed int return_value_soap_is_shaky_3;
        return_value_soap_is_shaky_3=soap_is_shaky(soap, (void *)p);
        ip->shaky = (signed short int)return_value_soap_is_shaky_3;
      }
    }

    else
    {
      _Bool tmp_if_expr_9;
      if(!(ip->type == t))
        tmp_if_expr_9 = (_Bool)1;

      else
        tmp_if_expr_9 = ip->size != n ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr_11;
      if(tmp_if_expr_9)
      {
        if(fbase == ((signed int (*)(signed int, signed int))NULL))
          tmp_if_expr_10 = (_Bool)1;

        else
        {
          return_value_1=fbase(ip->type, t);
          tmp_if_expr_10 = !(return_value_1 != 0) ? (_Bool)1 : (_Bool)0;
        }
        tmp_if_expr_11 = tmp_if_expr_10 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_11 = (_Bool)0;
      _Bool tmp_if_expr_15;
      if(tmp_if_expr_11)
      {
        if(fbase == ((signed int (*)(signed int, signed int))NULL))
          tmp_if_expr_12 = (_Bool)1;

        else
        {
          return_value_2=fbase(t, ip->type);
          tmp_if_expr_12 = !(return_value_2 != 0) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_12)
          tmp_if_expr_14 = (_Bool)1;

        else
        {
          return_value_soap_type_punned_13=soap_type_punned(soap, ip);
          tmp_if_expr_14 = return_value_soap_type_punned_13 != 0 ? (_Bool)1 : (_Bool)0;
        }
        tmp_if_expr_15 = tmp_if_expr_14 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_15 = (_Bool)0;
      if(tmp_if_expr_15)
      {
        soap_id_nullify(soap, id);
        return (void *)0;
      }

      else
      {
        _Bool tmp_if_expr_7;
        if(k == 0u)
          tmp_if_expr_7 = ip->ptr != NULL ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_7 = (_Bool)0;
        _Bool tmp_if_expr_8;
        if(tmp_if_expr_7)
          tmp_if_expr_8 = !(ip->shaky != 0) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_8 = (_Bool)0;
        if(tmp_if_expr_8)
          *p = ip->ptr;

        else
        {
          if(!(fbase == ((signed int (*)(signed int, signed int))NULL)))
          {
            return_value=fbase(t, ip->type);
            if(!(return_value == 0))
            {
              return_value_soap_type_punned_4=soap_type_punned(soap, ip);
              if(return_value_soap_type_punned_4 == 0)
              {
                ip->type = t;
                ip->size = n;
              }

            }

          }

          *p = (void *)0;
          if(!(k == 0u))
          {
            if(ip->spine == ((void **)NULL))
            {
              signed int i;
              if(k >= 5u)
                return (void *)0;

              void *return_value_soap_malloc_5;
              return_value_soap_malloc_5=soap_malloc(soap, (unsigned long int)4 * sizeof(void *) /*8ul*/ );
              ip->spine = (void **)return_value_soap_malloc_5;
              if(ip->spine == ((void **)NULL))
                return (void *)0;

              ip->spine[(signed long int)0] = (void *)0;
              i = 1;
              for( ; !(i >= 4); i = i + 1)
                ip->spine[(signed long int)i] = (void *)&ip->spine[(signed long int)(i - 1)];
            }

            *p = (void *)&ip->spine[(signed long int)(k - (unsigned int)1)];
            if(!(ip->ptr == NULL))
            {
              if(ip->shaky == 0)
                ip->spine[(signed long int)0] = ip->ptr;

            }

          }

          else
          {
            void *q = ip->link;
            ip->link = (void *)p;
            signed int return_value_soap_is_shaky_6;
            return_value_soap_is_shaky_6=soap_is_shaky(soap, (void *)p);
            ip->shaky = (signed short int)return_value_soap_is_shaky_6;
            *p = q;
          }
        }
      }
    }
    return (void *)p;
  }
}

// soap_id_nullify
// file stdsoap2.c line 8879
signed int soap_id_nullify(struct soap *soap, const char *id)
{
  signed int i = 0;
  for( ; !(i >= 1999); i = i + 1)
  {
    struct soap_ilist *ip = soap->iht[(signed long int)i];
    for( ; !(ip == ((struct soap_ilist *)NULL)); ip = ip->next)
    {
      void *p;
      void *q;
      p = ip->link;
      for( ; !(p == NULL); p = q)
      {
        q = *((void **)p);
        *((void **)p) = (void *)0;
      }
      ip->link = (void *)0;
    }
  }
  strncpy(soap->id, id, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
  soap->id[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
  (void)(soap->id[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
  soap->error = 26;
  return soap->error;
}

// soap_id_smart
// file stdsoap2.c line 8837
void ** soap_id_smart(struct soap *soap, const char *id, signed int t, unsigned long int n)
{
  (void)soap;
  (void)id;
  (void)t;
  (void)n;
  if(!(id == ((const char *)NULL)))
  {
    if(!(*id == 0))
    {
      struct soap_ilist *ip;
      ip=soap_lookup(soap, id);
      if(ip == ((struct soap_ilist *)NULL))
      {
        ip=soap_enter(soap, id, t, n);
        if(ip == ((struct soap_ilist *)NULL))
          return (void **)(void *)0;

      }

      return &ip->smart;
    }

  }

  return (void **)(void *)0;
}

// soap_ignore_element
// file soapC.c line 257
signed int soap_ignore_element(struct soap *soap)
{
  signed int return_value_soap_peek_element_7;
  return_value_soap_peek_element_7=soap_peek_element(soap);
  signed int return_value_soap_match_tag_2;
  void *return_value_soap_getelement_5;
  signed int return_value_soap_ignore_element_4;
  if(return_value_soap_peek_element_7 == 0)
  {
    signed int t;
    if(!(soap->mustUnderstand == 0))
    {
      if(soap->other == 0)
      {
        soap->error = 8;
        return soap->error;
      }

    }

    _Bool tmp_if_expr_1;
    if(!((0x00001000 & soap->mode) == 0))
      tmp_if_expr_1 = (signed int)soap->part != 3 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    _Bool tmp_if_expr_3;
    if(tmp_if_expr_1)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_soap_match_tag_2=soap_match_tag(soap, soap->tag, "SOAP-ENV:");
      tmp_if_expr_3 = !(return_value_soap_match_tag_2 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
    {
      soap->error = 3;
      return soap->error;
    }

    _Bool tmp_if_expr_6;
    if(soap->id[0l] == 0)
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_soap_getelement_5=soap_getelement(soap, &t);
      tmp_if_expr_6 = !(return_value_soap_getelement_5 != NULL) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
    {
      soap->peeked = (signed short int)0;
      if(!(soap->fignore == ((signed int (*)(struct soap *, const char *))NULL)))
        soap->error=soap->fignore(soap, soap->tag);

      else
        soap->error = 0;
      if(soap->error == 0)
      {
        if(!(soap->body == 0))
        {
          soap->level = soap->level + 1u;
          do
          {
            return_value_soap_ignore_element_4=soap_ignore_element(soap);
            if(!(return_value_soap_ignore_element_4 == 0))
              break;

          }
          while((_Bool)1);
          if(soap->error == 6)
            soap->error=soap_element_end_in(soap, (const char *)(void *)0);

        }

      }

    }

  }

  return soap->error;
}

// soap_inLONG64
// file stdsoap2.c line 13168
signed long int * soap_inLONG64(struct soap *soap, const char *tag, signed long int *p, const char *type, signed int t)
{
  signed int return_value_soap_element_begin_in_1;
  return_value_soap_element_begin_in_1=soap_element_begin_in(soap, tag, 0, (const char *)(void *)0);
  signed int return_value_soap_match_tag_11;
  signed int return_value_soap_match_tag_10;
  signed int return_value_soap_match_tag_9;
  signed int return_value_soap_match_tag_8;
  signed int return_value_soap_match_tag_7;
  signed int return_value_soap_match_tag_6;
  signed int return_value_soap_match_tag_5;
  signed int return_value_soap_match_tag_4;
  signed int return_value_soap_match_tag_3;
  signed int return_value_soap_match_tag_2;
  void *return_value_soap_id_forward_13;
  signed int return_value_soap_element_end_in_16;
  if(!(return_value_soap_element_begin_in_1 == 0))
    return (signed long int *)(void *)0;

  else
  {
    if(!(soap->type[0l] == 0))
    {
      return_value_soap_match_tag_11=soap_match_tag(soap, soap->type, type);
      if(!(return_value_soap_match_tag_11 == 0))
      {
        return_value_soap_match_tag_10=soap_match_tag(soap, soap->type, ":integer");
        if(!(return_value_soap_match_tag_10 == 0))
        {
          return_value_soap_match_tag_9=soap_match_tag(soap, soap->type, ":positiveInteger");
          if(!(return_value_soap_match_tag_9 == 0))
          {
            return_value_soap_match_tag_8=soap_match_tag(soap, soap->type, ":negativeInteger");
            if(!(return_value_soap_match_tag_8 == 0))
            {
              return_value_soap_match_tag_7=soap_match_tag(soap, soap->type, ":nonPositiveInteger");
              if(!(return_value_soap_match_tag_7 == 0))
              {
                return_value_soap_match_tag_6=soap_match_tag(soap, soap->type, ":nonNegativeInteger");
                if(!(return_value_soap_match_tag_6 == 0))
                {
                  return_value_soap_match_tag_5=soap_match_tag(soap, soap->type, ":long");
                  if(!(return_value_soap_match_tag_5 == 0))
                  {
                    return_value_soap_match_tag_4=soap_match_tag(soap, soap->type, ":int");
                    if(!(return_value_soap_match_tag_4 == 0))
                    {
                      return_value_soap_match_tag_3=soap_match_tag(soap, soap->type, ":short");
                      if(!(return_value_soap_match_tag_3 == 0))
                      {
                        return_value_soap_match_tag_2=soap_match_tag(soap, soap->type, ":byte");
                        if(!(return_value_soap_match_tag_2 == 0))
                        {
                          soap->error = 4;
                          soap_revert(soap);
                          return (signed long int *)(void *)0;
                        }

                      }

                    }

                  }

                }

              }

            }

          }

        }

      }

    }

    void *return_value_soap_id_enter_12;
    return_value_soap_id_enter_12=soap_id_enter(soap, soap->id, (void *)p, t, sizeof(signed long int) /*8ul*/ , (const char *)(void *)0, (const char *)(void *)0, (void * (*)(struct soap *, signed int, const char *, const char *, unsigned long int *))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
    p = (signed long int *)return_value_soap_id_enter_12;
    if(!(soap->href[0l] == 0))
    {
      return_value_soap_id_forward_13=soap_id_forward(soap, soap->href, (void *)p, (unsigned long int)0, t, t, sizeof(signed long int) /*8ul*/ , (unsigned int)0, (void (*)(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
      p = (signed long int *)return_value_soap_id_forward_13;
    }

    else
      if(!(p == ((signed long int *)NULL)))
      {
        const char *return_value_soap_value_14;
        return_value_soap_value_14=soap_value(soap);
        signed int return_value_soap_s2LONG64_15;
        return_value_soap_s2LONG64_15=soap_s2LONG64(soap, return_value_soap_value_14, p);
        if(!(return_value_soap_s2LONG64_15 == 0))
          return (signed long int *)(void *)0;

      }

    if(!(soap->body == 0))
    {
      return_value_soap_element_end_in_16=soap_element_end_in(soap, tag);
      if(!(return_value_soap_element_end_in_16 == 0))
        return (signed long int *)(void *)0;

    }

    return p;
  }
}

// soap_inULONG64
// file stdsoap2.c line 14044
unsigned long int * soap_inULONG64(struct soap *soap, const char *tag, unsigned long int *p, const char *type, signed int t)
{
  signed int return_value_soap_element_begin_in_1;
  return_value_soap_element_begin_in_1=soap_element_begin_in(soap, tag, 0, (const char *)(void *)0);
  signed int return_value_soap_match_tag_8;
  signed int return_value_soap_match_tag_7;
  signed int return_value_soap_match_tag_6;
  signed int return_value_soap_match_tag_5;
  signed int return_value_soap_match_tag_4;
  signed int return_value_soap_match_tag_3;
  signed int return_value_soap_match_tag_2;
  void *return_value_soap_id_forward_10;
  signed int return_value_soap_element_end_in_13;
  if(!(return_value_soap_element_begin_in_1 == 0))
    return (unsigned long int *)(void *)0;

  else
  {
    if(!(soap->type[0l] == 0))
    {
      return_value_soap_match_tag_8=soap_match_tag(soap, soap->type, type);
      if(!(return_value_soap_match_tag_8 == 0))
      {
        return_value_soap_match_tag_7=soap_match_tag(soap, soap->type, ":positiveInteger");
        if(!(return_value_soap_match_tag_7 == 0))
        {
          return_value_soap_match_tag_6=soap_match_tag(soap, soap->type, ":nonNegativeInteger");
          if(!(return_value_soap_match_tag_6 == 0))
          {
            return_value_soap_match_tag_5=soap_match_tag(soap, soap->type, ":unsignedLong");
            if(!(return_value_soap_match_tag_5 == 0))
            {
              return_value_soap_match_tag_4=soap_match_tag(soap, soap->type, ":unsignedInt");
              if(!(return_value_soap_match_tag_4 == 0))
              {
                return_value_soap_match_tag_3=soap_match_tag(soap, soap->type, ":unsignedShort");
                if(!(return_value_soap_match_tag_3 == 0))
                {
                  return_value_soap_match_tag_2=soap_match_tag(soap, soap->type, ":unsignedByte");
                  if(!(return_value_soap_match_tag_2 == 0))
                  {
                    soap->error = 4;
                    soap_revert(soap);
                    return (unsigned long int *)(void *)0;
                  }

                }

              }

            }

          }

        }

      }

    }

    void *return_value_soap_id_enter_9;
    return_value_soap_id_enter_9=soap_id_enter(soap, soap->id, (void *)p, t, sizeof(unsigned long int) /*8ul*/ , (const char *)(void *)0, (const char *)(void *)0, (void * (*)(struct soap *, signed int, const char *, const char *, unsigned long int *))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
    p = (unsigned long int *)return_value_soap_id_enter_9;
    if(!(soap->href[0l] == 0))
    {
      return_value_soap_id_forward_10=soap_id_forward(soap, soap->href, (void *)p, (unsigned long int)0, t, t, sizeof(unsigned long int) /*8ul*/ , (unsigned int)0, (void (*)(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
      p = (unsigned long int *)return_value_soap_id_forward_10;
    }

    else
      if(!(p == ((unsigned long int *)NULL)))
      {
        const char *return_value_soap_value_11;
        return_value_soap_value_11=soap_value(soap);
        signed int return_value_soap_s2ULONG64_12;
        return_value_soap_s2ULONG64_12=soap_s2ULONG64(soap, return_value_soap_value_11, p);
        if(!(return_value_soap_s2ULONG64_12 == 0))
          return (unsigned long int *)(void *)0;

      }

    if(!(soap->body == 0))
    {
      return_value_soap_element_end_in_13=soap_element_end_in(soap, tag);
      if(!(return_value_soap_element_end_in_13 == 0))
        return (unsigned long int *)(void *)0;

    }

    return p;
  }
}

// soap_in_PointerToSOAP_ENV__Code
// file soapC.c line 1259
struct SOAP_ENV__Code ** soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
  (void)type;
  signed int return_value_soap_element_begin_in_1;
  return_value_soap_element_begin_in_1=soap_element_begin_in(soap, tag, 1, (const char *)(void *)0);
  void *return_value_soap_malloc_2;
  signed int return_value_soap_element_end_in_4;
  if(!(return_value_soap_element_begin_in_1 == 0))
    return (struct SOAP_ENV__Code **)(void *)0;

  else
  {
    if(a == ((struct SOAP_ENV__Code **)NULL))
    {
      return_value_soap_malloc_2=soap_malloc(soap, sizeof(struct SOAP_ENV__Code *) /*8ul*/ );
      a = (struct SOAP_ENV__Code **)return_value_soap_malloc_2;
      if(a == ((struct SOAP_ENV__Code **)NULL))
        return (struct SOAP_ENV__Code **)(void *)0;

    }

    *a = (struct SOAP_ENV__Code *)(void *)0;
    _Bool tmp_if_expr_5;
    if(soap->null == 0)
      tmp_if_expr_5 = (signed int)soap->href[0l] != 35 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
    {
      soap_revert(soap);
      *a=soap_in_SOAP_ENV__Code(soap, tag, *a, type);
      if(*a == ((struct SOAP_ENV__Code *)NULL))
        return (struct SOAP_ENV__Code **)(void *)0;

    }

    else
    {
      void *return_value_soap_id_lookup_3;
      return_value_soap_id_lookup_3=soap_id_lookup(soap, soap->href, (void **)a, 11, sizeof(struct SOAP_ENV__Code) /*16ul*/ , (unsigned int)0, (signed int (*)(signed int, signed int))(void *)0);
      a = (struct SOAP_ENV__Code **)return_value_soap_id_lookup_3;
      if(!(soap->body == 0))
      {
        return_value_soap_element_end_in_4=soap_element_end_in(soap, tag);
        if(!(return_value_soap_element_end_in_4 == 0))
          return (struct SOAP_ENV__Code **)(void *)0;

      }

    }
    return a;
  }
}

// soap_in_PointerToSOAP_ENV__Detail
// file soapC.c line 1198
struct SOAP_ENV__Detail ** soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
  (void)type;
  signed int return_value_soap_element_begin_in_1;
  return_value_soap_element_begin_in_1=soap_element_begin_in(soap, tag, 1, (const char *)(void *)0);
  void *return_value_soap_malloc_2;
  signed int return_value_soap_element_end_in_4;
  if(!(return_value_soap_element_begin_in_1 == 0))
    return (struct SOAP_ENV__Detail **)(void *)0;

  else
  {
    if(a == ((struct SOAP_ENV__Detail **)NULL))
    {
      return_value_soap_malloc_2=soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *) /*8ul*/ );
      a = (struct SOAP_ENV__Detail **)return_value_soap_malloc_2;
      if(a == ((struct SOAP_ENV__Detail **)NULL))
        return (struct SOAP_ENV__Detail **)(void *)0;

    }

    *a = (struct SOAP_ENV__Detail *)(void *)0;
    _Bool tmp_if_expr_5;
    if(soap->null == 0)
      tmp_if_expr_5 = (signed int)soap->href[0l] != 35 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
    {
      soap_revert(soap);
      *a=soap_in_SOAP_ENV__Detail(soap, tag, *a, type);
      if(*a == ((struct SOAP_ENV__Detail *)NULL))
        return (struct SOAP_ENV__Detail **)(void *)0;

    }

    else
    {
      void *return_value_soap_id_lookup_3;
      return_value_soap_id_lookup_3=soap_id_lookup(soap, soap->href, (void **)a, 13, sizeof(struct SOAP_ENV__Detail) /*24ul*/ , (unsigned int)0, (signed int (*)(signed int, signed int))(void *)0);
      a = (struct SOAP_ENV__Detail **)return_value_soap_id_lookup_3;
      if(!(soap->body == 0))
      {
        return_value_soap_element_end_in_4=soap_element_end_in(soap, tag);
        if(!(return_value_soap_element_end_in_4 == 0))
          return (struct SOAP_ENV__Detail **)(void *)0;

      }

    }
    return a;
  }
}

// soap_in_PointerToSOAP_ENV__Reason
// file soapC.c line 1140
struct SOAP_ENV__Reason ** soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
  (void)type;
  signed int return_value_soap_element_begin_in_1;
  return_value_soap_element_begin_in_1=soap_element_begin_in(soap, tag, 1, (const char *)(void *)0);
  void *return_value_soap_malloc_2;
  signed int return_value_soap_element_end_in_4;
  if(!(return_value_soap_element_begin_in_1 == 0))
    return (struct SOAP_ENV__Reason **)(void *)0;

  else
  {
    if(a == ((struct SOAP_ENV__Reason **)NULL))
    {
      return_value_soap_malloc_2=soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *) /*8ul*/ );
      a = (struct SOAP_ENV__Reason **)return_value_soap_malloc_2;
      if(a == ((struct SOAP_ENV__Reason **)NULL))
        return (struct SOAP_ENV__Reason **)(void *)0;

    }

    *a = (struct SOAP_ENV__Reason *)(void *)0;
    _Bool tmp_if_expr_5;
    if(soap->null == 0)
      tmp_if_expr_5 = (signed int)soap->href[0l] != 35 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
    {
      soap_revert(soap);
      *a=soap_in_SOAP_ENV__Reason(soap, tag, *a, type);
      if(*a == ((struct SOAP_ENV__Reason *)NULL))
        return (struct SOAP_ENV__Reason **)(void *)0;

    }

    else
    {
      void *return_value_soap_id_lookup_3;
      return_value_soap_id_lookup_3=soap_id_lookup(soap, soap->href, (void **)a, 16, sizeof(struct SOAP_ENV__Reason) /*8ul*/ , (unsigned int)0, (signed int (*)(signed int, signed int))(void *)0);
      a = (struct SOAP_ENV__Reason **)return_value_soap_id_lookup_3;
      if(!(soap->body == 0))
      {
        return_value_soap_element_end_in_4=soap_element_end_in(soap, tag);
        if(!(return_value_soap_element_end_in_4 == 0))
          return (struct SOAP_ENV__Reason **)(void *)0;

      }

    }
    return a;
  }
}

// soap_in_PointerTot__Routing
// file soapC.c line 1315
struct t__Routing ** soap_in_PointerTot__Routing(struct soap *soap, const char *tag, struct t__Routing **a, const char *type)
{
  (void)type;
  signed int return_value_soap_element_begin_in_1;
  return_value_soap_element_begin_in_1=soap_element_begin_in(soap, tag, 1, (const char *)(void *)0);
  void *return_value_soap_malloc_2;
  signed int return_value_soap_element_end_in_4;
  if(!(return_value_soap_element_begin_in_1 == 0))
    return (struct t__Routing **)(void *)0;

  else
  {
    if(a == ((struct t__Routing **)NULL))
    {
      return_value_soap_malloc_2=soap_malloc(soap, sizeof(struct t__Routing *) /*8ul*/ );
      a = (struct t__Routing **)return_value_soap_malloc_2;
      if(a == ((struct t__Routing **)NULL))
        return (struct t__Routing **)(void *)0;

    }

    *a = (struct t__Routing *)(void *)0;
    _Bool tmp_if_expr_5;
    if(soap->null == 0)
      tmp_if_expr_5 = (signed int)soap->href[0l] != 35 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
    {
      soap_revert(soap);
      *a=soap_in_t__Routing(soap, tag, *a, type);
      if(*a == ((struct t__Routing *)NULL))
        return (struct t__Routing **)(void *)0;

    }

    else
    {
      void *return_value_soap_id_lookup_3;
      return_value_soap_id_lookup_3=soap_id_lookup(soap, soap->href, (void **)a, 7, sizeof(struct t__Routing) /*32ul*/ , (unsigned int)0, (signed int (*)(signed int, signed int))(void *)0);
      a = (struct t__Routing **)return_value_soap_id_lookup_3;
      if(!(soap->body == 0))
      {
        return_value_soap_element_end_in_4=soap_element_end_in(soap, tag);
        if(!(return_value_soap_element_end_in_4 == 0))
          return (struct t__Routing **)(void *)0;

      }

    }
    return a;
  }
}

// soap_in_SOAP_ENV__Code
// file soapC.c line 780
struct SOAP_ENV__Code * soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
  unsigned long int soap_flag_SOAP_ENV__Value = (unsigned long int)1;
  unsigned long int soap_flag_SOAP_ENV__Subcode = (unsigned long int)1;
  signed int return_value_soap_element_begin_in_1;
  return_value_soap_element_begin_in_1=soap_element_begin_in(soap, tag, 0, type);
  char **return_value_soap_in__QName_3;
  struct SOAP_ENV__Code **return_value_soap_in_PointerToSOAP_ENV__Code_5;
  signed int return_value_soap_element_end_in_8;
  if(!(return_value_soap_element_begin_in_1 == 0))
    return (struct SOAP_ENV__Code *)(void *)0;

  else
  {
    void *return_value_soap_id_enter_2;
    return_value_soap_id_enter_2=soap_id_enter(soap, soap->id, (void *)a, 11, sizeof(struct SOAP_ENV__Code) /*16ul*/ , (const char *)(void *)0, (const char *)(void *)0, (void * (*)(struct soap *, signed int, const char *, const char *, unsigned long int *))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
    a = (struct SOAP_ENV__Code *)return_value_soap_id_enter_2;
    if(a == ((struct SOAP_ENV__Code *)NULL))
      return (struct SOAP_ENV__Code *)(void *)0;

    else
    {
      soap_default_SOAP_ENV__Code(soap, a);
      _Bool tmp_if_expr_9;
      if(!(soap->body == 0))
        tmp_if_expr_9 = !(soap->href[0l] != 0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_9 = (_Bool)0;
      if(tmp_if_expr_9)
      {
        do
        {
          soap->error = 3;
          if(!(soap_flag_SOAP_ENV__Value == 0ul))
          {
            _Bool tmp_if_expr_4;
            if(soap->error == 3)
              tmp_if_expr_4 = (_Bool)1;

            else
              tmp_if_expr_4 = soap->error == 6 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_4)
            {
              return_value_soap_in__QName_3=soap_in__QName(soap, "SOAP-ENV:Value", (char **)&a->SOAP_ENV__Value, "");
              if(!(return_value_soap_in__QName_3 == ((char **)NULL)))
              {
                soap_flag_SOAP_ENV__Value = soap_flag_SOAP_ENV__Value - 1ul;
                continue;
              }

            }

          }

          if(!(soap_flag_SOAP_ENV__Subcode == 0ul))
          {
            if(soap->error == 3)
            {
              return_value_soap_in_PointerToSOAP_ENV__Code_5=soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, "");
              if(!(return_value_soap_in_PointerToSOAP_ENV__Code_5 == ((struct SOAP_ENV__Code **)NULL)))
              {
                soap_flag_SOAP_ENV__Subcode = soap_flag_SOAP_ENV__Subcode - 1ul;
                continue;
              }

            }

          }

          if(soap->error == 3)
            soap->error=soap_ignore_element(soap);

          if(soap->error == 6)
            break;

          if(!(soap->error == 0))
            return (struct SOAP_ENV__Code *)(void *)0;

        }
        while((_Bool)1);
        signed int return_value_soap_element_end_in_6;
        return_value_soap_element_end_in_6=soap_element_end_in(soap, tag);
        if(!(return_value_soap_element_end_in_6 == 0))
          return (struct SOAP_ENV__Code *)(void *)0;

      }

      else
      {
        void *return_value_soap_id_forward_7;
        return_value_soap_id_forward_7=soap_id_forward(soap, soap->href, (void *)a, (unsigned long int)0, 11, 11, sizeof(struct SOAP_ENV__Code) /*16ul*/ , (unsigned int)0, (void (*)(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
        a = (struct SOAP_ENV__Code *)return_value_soap_id_forward_7;
        if(!(soap->body == 0))
        {
          return_value_soap_element_end_in_8=soap_element_end_in(soap, tag);
          if(!(return_value_soap_element_end_in_8 == 0))
            return (struct SOAP_ENV__Code *)(void *)0;

        }

      }
      return a;
    }
  }
}

// soap_in_SOAP_ENV__Detail
// file soapC.c line 690
struct SOAP_ENV__Detail * soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
  unsigned long int soap_flag___any = (unsigned long int)1;
  unsigned long int soap_flag_fault = (unsigned long int)1;
  signed int return_value_soap_element_begin_in_1;
  return_value_soap_element_begin_in_1=soap_element_begin_in(soap, tag, 0, type);
  char **return_value_soap_inliteral_3;
  signed int return_value_soap_element_end_in_7;
  if(!(return_value_soap_element_begin_in_1 == 0))
    return (struct SOAP_ENV__Detail *)(void *)0;

  else
  {
    void *return_value_soap_id_enter_2;
    return_value_soap_id_enter_2=soap_id_enter(soap, soap->id, (void *)a, 13, sizeof(struct SOAP_ENV__Detail) /*24ul*/ , (const char *)(void *)0, (const char *)(void *)0, (void * (*)(struct soap *, signed int, const char *, const char *, unsigned long int *))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
    a = (struct SOAP_ENV__Detail *)return_value_soap_id_enter_2;
    if(a == ((struct SOAP_ENV__Detail *)NULL))
      return (struct SOAP_ENV__Detail *)(void *)0;

    else
    {
      soap_default_SOAP_ENV__Detail(soap, a);
      _Bool tmp_if_expr_8;
      if(!(soap->body == 0))
        tmp_if_expr_8 = !(soap->href[0l] != 0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_8 = (_Bool)0;
      if(tmp_if_expr_8)
      {
        do
        {
          soap->error = 3;
          if(!(soap_flag_fault == 0ul))
          {
            if(!(soap->error == 3))
              goto __CPROVER_DUMP_L6;

            a->fault=soap_getelement(soap, &a->__type);
            if(a->fault == NULL)
              goto __CPROVER_DUMP_L6;

            soap_flag_fault = (unsigned long int)0;
          }

          else
          {

          __CPROVER_DUMP_L6:
            ;
            if(!(soap_flag___any == 0ul))
            {
              _Bool tmp_if_expr_4;
              if(soap->error == 3)
                tmp_if_expr_4 = (_Bool)1;

              else
                tmp_if_expr_4 = soap->error == 6 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_4)
              {
                return_value_soap_inliteral_3=soap_inliteral(soap, "-any", (char **)&a->__any);
                if(!(return_value_soap_inliteral_3 == ((char **)NULL)))
                {
                  soap_flag___any = soap_flag___any - 1ul;
                  continue;
                }

              }

            }

            if(soap->error == 3)
              soap->error=soap_ignore_element(soap);

            if(soap->error == 6)
              break;

            if(!(soap->error == 0))
              return (struct SOAP_ENV__Detail *)(void *)0;

          }
        }
        while((_Bool)1);
        signed int return_value_soap_element_end_in_5;
        return_value_soap_element_end_in_5=soap_element_end_in(soap, tag);
        if(!(return_value_soap_element_end_in_5 == 0))
          return (struct SOAP_ENV__Detail *)(void *)0;

      }

      else
      {
        void *return_value_soap_id_forward_6;
        return_value_soap_id_forward_6=soap_id_forward(soap, soap->href, (void *)a, (unsigned long int)0, 13, 13, sizeof(struct SOAP_ENV__Detail) /*24ul*/ , (unsigned int)0, (void (*)(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
        a = (struct SOAP_ENV__Detail *)return_value_soap_id_forward_6;
        if(!(soap->body == 0))
        {
          return_value_soap_element_end_in_7=soap_element_end_in(soap, tag);
          if(!(return_value_soap_element_end_in_7 == 0))
            return (struct SOAP_ENV__Detail *)(void *)0;

        }

      }
      return a;
    }
  }
}

// soap_in_SOAP_ENV__Fault
// file soapC.c line 479
struct SOAP_ENV__Fault * soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
  unsigned long int soap_flag_faultcode = (unsigned long int)1;
  unsigned long int soap_flag_faultstring = (unsigned long int)1;
  unsigned long int soap_flag_faultactor = (unsigned long int)1;
  unsigned long int soap_flag_detail = (unsigned long int)1;
  unsigned long int soap_flag_SOAP_ENV__Code = (unsigned long int)1;
  unsigned long int soap_flag_SOAP_ENV__Reason = (unsigned long int)1;
  unsigned long int soap_flag_SOAP_ENV__Node = (unsigned long int)1;
  unsigned long int soap_flag_SOAP_ENV__Role = (unsigned long int)1;
  unsigned long int soap_flag_SOAP_ENV__Detail = (unsigned long int)1;
  signed int return_value_soap_element_begin_in_1;
  return_value_soap_element_begin_in_1=soap_element_begin_in(soap, tag, 0, type);
  char **return_value_soap_in__QName_3;
  char **return_value_soap_in_string_5;
  char **return_value_soap_in_string_7;
  struct SOAP_ENV__Detail **return_value_soap_in_PointerToSOAP_ENV__Detail_9;
  struct SOAP_ENV__Code **return_value_soap_in_PointerToSOAP_ENV__Code_10;
  struct SOAP_ENV__Reason **return_value_soap_in_PointerToSOAP_ENV__Reason_11;
  char **return_value_soap_in_string_12;
  char **return_value_soap_in_string_14;
  struct SOAP_ENV__Detail **return_value_soap_in_PointerToSOAP_ENV__Detail_16;
  signed int return_value_soap_element_end_in_19;
  if(!(return_value_soap_element_begin_in_1 == 0))
    return (struct SOAP_ENV__Fault *)(void *)0;

  else
  {
    void *return_value_soap_id_enter_2;
    return_value_soap_id_enter_2=soap_id_enter(soap, soap->id, (void *)a, 17, sizeof(struct SOAP_ENV__Fault) /*72ul*/ , (const char *)(void *)0, (const char *)(void *)0, (void * (*)(struct soap *, signed int, const char *, const char *, unsigned long int *))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
    a = (struct SOAP_ENV__Fault *)return_value_soap_id_enter_2;
    if(a == ((struct SOAP_ENV__Fault *)NULL))
      return (struct SOAP_ENV__Fault *)(void *)0;

    else
    {
      soap_default_SOAP_ENV__Fault(soap, a);
      _Bool tmp_if_expr_20;
      if(!(soap->body == 0))
        tmp_if_expr_20 = !(soap->href[0l] != 0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_20 = (_Bool)0;
      if(tmp_if_expr_20)
      {
        do
        {
          soap->error = 3;
          if(!(soap_flag_faultcode == 0ul))
          {
            _Bool tmp_if_expr_4;
            if(soap->error == 3)
              tmp_if_expr_4 = (_Bool)1;

            else
              tmp_if_expr_4 = soap->error == 6 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_4)
            {
              return_value_soap_in__QName_3=soap_in__QName(soap, "faultcode", (char **)&a->faultcode, "");
              if(!(return_value_soap_in__QName_3 == ((char **)NULL)))
              {
                soap_flag_faultcode = soap_flag_faultcode - 1ul;
                continue;
              }

            }

          }

          if(!(soap_flag_faultstring == 0ul))
          {
            _Bool tmp_if_expr_6;
            if(soap->error == 3)
              tmp_if_expr_6 = (_Bool)1;

            else
              tmp_if_expr_6 = soap->error == 6 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_6)
            {
              return_value_soap_in_string_5=soap_in_string(soap, "faultstring", (char **)&a->faultstring, "xsd:string");
              if(!(return_value_soap_in_string_5 == ((char **)NULL)))
              {
                soap_flag_faultstring = soap_flag_faultstring - 1ul;
                continue;
              }

            }

          }

          if(!(soap_flag_faultactor == 0ul))
          {
            _Bool tmp_if_expr_8;
            if(soap->error == 3)
              tmp_if_expr_8 = (_Bool)1;

            else
              tmp_if_expr_8 = soap->error == 6 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_8)
            {
              return_value_soap_in_string_7=soap_in_string(soap, "faultactor", (char **)&a->faultactor, "xsd:string");
              if(!(return_value_soap_in_string_7 == ((char **)NULL)))
              {
                soap_flag_faultactor = soap_flag_faultactor - 1ul;
                continue;
              }

            }

          }

          if(!(soap_flag_detail == 0ul))
          {
            if(soap->error == 3)
            {
              return_value_soap_in_PointerToSOAP_ENV__Detail_9=soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, "");
              if(!(return_value_soap_in_PointerToSOAP_ENV__Detail_9 == ((struct SOAP_ENV__Detail **)NULL)))
              {
                soap_flag_detail = soap_flag_detail - 1ul;
                continue;
              }

            }

          }

          if(!(soap_flag_SOAP_ENV__Code == 0ul))
          {
            if(soap->error == 3)
            {
              return_value_soap_in_PointerToSOAP_ENV__Code_10=soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, "");
              if(!(return_value_soap_in_PointerToSOAP_ENV__Code_10 == ((struct SOAP_ENV__Code **)NULL)))
              {
                soap_flag_SOAP_ENV__Code = soap_flag_SOAP_ENV__Code - 1ul;
                continue;
              }

            }

          }

          if(!(soap_flag_SOAP_ENV__Reason == 0ul))
          {
            if(soap->error == 3)
            {
              return_value_soap_in_PointerToSOAP_ENV__Reason_11=soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, "");
              if(!(return_value_soap_in_PointerToSOAP_ENV__Reason_11 == ((struct SOAP_ENV__Reason **)NULL)))
              {
                soap_flag_SOAP_ENV__Reason = soap_flag_SOAP_ENV__Reason - 1ul;
                continue;
              }

            }

          }

          if(!(soap_flag_SOAP_ENV__Node == 0ul))
          {
            _Bool tmp_if_expr_13;
            if(soap->error == 3)
              tmp_if_expr_13 = (_Bool)1;

            else
              tmp_if_expr_13 = soap->error == 6 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_13)
            {
              return_value_soap_in_string_12=soap_in_string(soap, "SOAP-ENV:Node", (char **)&a->SOAP_ENV__Node, "xsd:string");
              if(!(return_value_soap_in_string_12 == ((char **)NULL)))
              {
                soap_flag_SOAP_ENV__Node = soap_flag_SOAP_ENV__Node - 1ul;
                continue;
              }

            }

          }

          if(!(soap_flag_SOAP_ENV__Role == 0ul))
          {
            _Bool tmp_if_expr_15;
            if(soap->error == 3)
              tmp_if_expr_15 = (_Bool)1;

            else
              tmp_if_expr_15 = soap->error == 6 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_15)
            {
              return_value_soap_in_string_14=soap_in_string(soap, "SOAP-ENV:Role", (char **)&a->SOAP_ENV__Role, "xsd:string");
              if(!(return_value_soap_in_string_14 == ((char **)NULL)))
              {
                soap_flag_SOAP_ENV__Role = soap_flag_SOAP_ENV__Role - 1ul;
                continue;
              }

            }

          }

          if(!(soap_flag_SOAP_ENV__Detail == 0ul))
          {
            if(soap->error == 3)
            {
              return_value_soap_in_PointerToSOAP_ENV__Detail_16=soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, "");
              if(!(return_value_soap_in_PointerToSOAP_ENV__Detail_16 == ((struct SOAP_ENV__Detail **)NULL)))
              {
                soap_flag_SOAP_ENV__Detail = soap_flag_SOAP_ENV__Detail - 1ul;
                continue;
              }

            }

          }

          if(soap->error == 3)
            soap->error=soap_ignore_element(soap);

          if(soap->error == 6)
            break;

          if(!(soap->error == 0))
            return (struct SOAP_ENV__Fault *)(void *)0;

        }
        while((_Bool)1);
        signed int return_value_soap_element_end_in_17;
        return_value_soap_element_end_in_17=soap_element_end_in(soap, tag);
        if(!(return_value_soap_element_end_in_17 == 0))
          return (struct SOAP_ENV__Fault *)(void *)0;

      }

      else
      {
        void *return_value_soap_id_forward_18;
        return_value_soap_id_forward_18=soap_id_forward(soap, soap->href, (void *)a, (unsigned long int)0, 17, 17, sizeof(struct SOAP_ENV__Fault) /*72ul*/ , (unsigned int)0, (void (*)(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
        a = (struct SOAP_ENV__Fault *)return_value_soap_id_forward_18;
        if(!(soap->body == 0))
        {
          return_value_soap_element_end_in_19=soap_element_end_in(soap, tag);
          if(!(return_value_soap_element_end_in_19 == 0))
            return (struct SOAP_ENV__Fault *)(void *)0;

        }

      }
      return a;
    }
  }
}

// soap_in_SOAP_ENV__Header
// file soapC.c line 861
struct SOAP_ENV__Header * soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
  signed int return_value_soap_element_begin_in_1;
  return_value_soap_element_begin_in_1=soap_element_begin_in(soap, tag, 0, type);
  signed int return_value_soap_element_end_in_5;
  if(!(return_value_soap_element_begin_in_1 == 0))
    return (struct SOAP_ENV__Header *)(void *)0;

  else
  {
    void *return_value_soap_id_enter_2;
    return_value_soap_id_enter_2=soap_id_enter(soap, soap->id, (void *)a, 10, sizeof(struct SOAP_ENV__Header) /*1ul*/ , (const char *)(void *)0, (const char *)(void *)0, (void * (*)(struct soap *, signed int, const char *, const char *, unsigned long int *))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
    a = (struct SOAP_ENV__Header *)return_value_soap_id_enter_2;
    if(a == ((struct SOAP_ENV__Header *)NULL))
      return (struct SOAP_ENV__Header *)(void *)0;

    else
    {
      soap_default_SOAP_ENV__Header(soap, a);
      _Bool tmp_if_expr_6;
      if(!(soap->body == 0))
        tmp_if_expr_6 = !(soap->href[0l] != 0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_6 = (_Bool)0;
      if(tmp_if_expr_6)
      {
        do
        {
          soap->error = 3;
          if(soap->error == 3)
            soap->error=soap_ignore_element(soap);

          if(soap->error == 6)
            break;

          if(!(soap->error == 0))
            return (struct SOAP_ENV__Header *)(void *)0;

        }
        while((_Bool)1);
        signed int return_value_soap_element_end_in_3;
        return_value_soap_element_end_in_3=soap_element_end_in(soap, tag);
        if(!(return_value_soap_element_end_in_3 == 0))
          return (struct SOAP_ENV__Header *)(void *)0;

      }

      else
      {
        void *return_value_soap_id_forward_4;
        return_value_soap_id_forward_4=soap_id_forward(soap, soap->href, (void *)a, (unsigned long int)0, 10, 10, sizeof(struct SOAP_ENV__Header) /*1ul*/ , (unsigned int)0, (void (*)(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
        a = (struct SOAP_ENV__Header *)return_value_soap_id_forward_4;
        if(!(soap->body == 0))
        {
          return_value_soap_element_end_in_5=soap_element_end_in(soap, tag);
          if(!(return_value_soap_element_end_in_5 == 0))
            return (struct SOAP_ENV__Header *)(void *)0;

        }

      }
      return a;
    }
  }
}

// soap_in_SOAP_ENV__Reason
// file soapC.c line 608
struct SOAP_ENV__Reason * soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
  unsigned long int soap_flag_SOAP_ENV__Text = (unsigned long int)1;
  signed int return_value_soap_element_begin_in_1;
  return_value_soap_element_begin_in_1=soap_element_begin_in(soap, tag, 0, type);
  char **return_value_soap_in_string_3;
  signed int return_value_soap_element_end_in_7;
  if(!(return_value_soap_element_begin_in_1 == 0))
    return (struct SOAP_ENV__Reason *)(void *)0;

  else
  {
    void *return_value_soap_id_enter_2;
    return_value_soap_id_enter_2=soap_id_enter(soap, soap->id, (void *)a, 16, sizeof(struct SOAP_ENV__Reason) /*8ul*/ , (const char *)(void *)0, (const char *)(void *)0, (void * (*)(struct soap *, signed int, const char *, const char *, unsigned long int *))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
    a = (struct SOAP_ENV__Reason *)return_value_soap_id_enter_2;
    if(a == ((struct SOAP_ENV__Reason *)NULL))
      return (struct SOAP_ENV__Reason *)(void *)0;

    else
    {
      soap_default_SOAP_ENV__Reason(soap, a);
      _Bool tmp_if_expr_8;
      if(!(soap->body == 0))
        tmp_if_expr_8 = !(soap->href[0l] != 0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_8 = (_Bool)0;
      if(tmp_if_expr_8)
      {
        do
        {
          soap->error = 3;
          if(!(soap_flag_SOAP_ENV__Text == 0ul))
          {
            _Bool tmp_if_expr_4;
            if(soap->error == 3)
              tmp_if_expr_4 = (_Bool)1;

            else
              tmp_if_expr_4 = soap->error == 6 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_4)
            {
              return_value_soap_in_string_3=soap_in_string(soap, "SOAP-ENV:Text", (char **)&a->SOAP_ENV__Text, "xsd:string");
              if(!(return_value_soap_in_string_3 == ((char **)NULL)))
              {
                soap_flag_SOAP_ENV__Text = soap_flag_SOAP_ENV__Text - 1ul;
                continue;
              }

            }

          }

          if(soap->error == 3)
            soap->error=soap_ignore_element(soap);

          if(soap->error == 6)
            break;

          if(!(soap->error == 0))
            return (struct SOAP_ENV__Reason *)(void *)0;

        }
        while((_Bool)1);
        signed int return_value_soap_element_end_in_5;
        return_value_soap_element_end_in_5=soap_element_end_in(soap, tag);
        if(!(return_value_soap_element_end_in_5 == 0))
          return (struct SOAP_ENV__Reason *)(void *)0;

      }

      else
      {
        void *return_value_soap_id_forward_6;
        return_value_soap_id_forward_6=soap_id_forward(soap, soap->href, (void *)a, (unsigned long int)0, 16, 16, sizeof(struct SOAP_ENV__Reason) /*8ul*/ , (unsigned int)0, (void (*)(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
        a = (struct SOAP_ENV__Reason *)return_value_soap_id_forward_6;
        if(!(soap->body == 0))
        {
          return_value_soap_element_end_in_7=soap_element_end_in(soap, tag);
          if(!(return_value_soap_element_end_in_7 == 0))
            return (struct SOAP_ENV__Reason *)(void *)0;

        }

      }
      return a;
    }
  }
}

// soap_in__QName
// file soapC.c line 1365
char ** soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
  a=soap_instring(soap, tag, a, type, 5, 2, (signed long int)0, (signed long int)-1, (const char *)(void *)0);
  return a;
}

// soap_in_byte
// file soapC.c line 363
char * soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
  a=soap_inbyte(soap, tag, a, type, 3);
  return a;
}

// soap_in_int
// file soapC.c line 399
signed int * soap_in_int(struct soap *soap, const char *tag, signed int *a, const char *type)
{
  a=soap_inint(soap, tag, a, type, 1);
  return a;
}

// soap_in_string
// file soapC.c line 1409
char ** soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
  a=soap_instring(soap, tag, a, type, 4, 1, (signed long int)0, (signed long int)-1, (const char *)(void *)0);
  return a;
}

// soap_in_t__Routing
// file soapC.c line 1052
struct t__Routing * soap_in_t__Routing(struct soap *soap, const char *tag, struct t__Routing *a, const char *type)
{
  unsigned long int soap_flag_key = (unsigned long int)1;
  unsigned long int soap_flag_endpoint = (unsigned long int)1;
  unsigned long int soap_flag_userid = (unsigned long int)1;
  unsigned long int soap_flag_passwd = (unsigned long int)1;
  signed int return_value_soap_element_begin_in_1;
  return_value_soap_element_begin_in_1=soap_element_begin_in(soap, tag, 0, type);
  char **return_value_soap_in_string_3;
  char **return_value_soap_in_string_5;
  char **return_value_soap_in_string_7;
  char **return_value_soap_in_string_9;
  signed int return_value_soap_element_end_in_13;
  if(!(return_value_soap_element_begin_in_1 == 0))
    return (struct t__Routing *)(void *)0;

  else
  {
    void *return_value_soap_id_enter_2;
    return_value_soap_id_enter_2=soap_id_enter(soap, soap->id, (void *)a, 7, sizeof(struct t__Routing) /*32ul*/ , (const char *)(void *)0, (const char *)(void *)0, (void * (*)(struct soap *, signed int, const char *, const char *, unsigned long int *))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
    a = (struct t__Routing *)return_value_soap_id_enter_2;
    if(a == ((struct t__Routing *)NULL))
      return (struct t__Routing *)(void *)0;

    else
    {
      soap_default_t__Routing(soap, a);
      _Bool tmp_if_expr_14;
      if(!(soap->body == 0))
        tmp_if_expr_14 = !(soap->href[0l] != 0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_14 = (_Bool)0;
      if(tmp_if_expr_14)
      {
        do
        {
          soap->error = 3;
          if(!(soap_flag_key == 0ul))
          {
            _Bool tmp_if_expr_4;
            if(soap->error == 3)
              tmp_if_expr_4 = (_Bool)1;

            else
              tmp_if_expr_4 = soap->error == 6 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_4)
            {
              return_value_soap_in_string_3=soap_in_string(soap, "key", (char **)&a->key, "xsd:string");
              if(!(return_value_soap_in_string_3 == ((char **)NULL)))
              {
                soap_flag_key = soap_flag_key - 1ul;
                continue;
              }

            }

          }

          if(!(soap_flag_endpoint == 0ul))
          {
            _Bool tmp_if_expr_6;
            if(soap->error == 3)
              tmp_if_expr_6 = (_Bool)1;

            else
              tmp_if_expr_6 = soap->error == 6 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_6)
            {
              return_value_soap_in_string_5=soap_in_string(soap, "endpoint", (char **)&a->endpoint, "xsd:string");
              if(!(return_value_soap_in_string_5 == ((char **)NULL)))
              {
                soap_flag_endpoint = soap_flag_endpoint - 1ul;
                continue;
              }

            }

          }

          if(!(soap_flag_userid == 0ul))
          {
            _Bool tmp_if_expr_8;
            if(soap->error == 3)
              tmp_if_expr_8 = (_Bool)1;

            else
              tmp_if_expr_8 = soap->error == 6 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_8)
            {
              return_value_soap_in_string_7=soap_in_string(soap, "userid", (char **)&a->userid, "xsd:string");
              if(!(return_value_soap_in_string_7 == ((char **)NULL)))
              {
                soap_flag_userid = soap_flag_userid - 1ul;
                continue;
              }

            }

          }

          if(!(soap_flag_passwd == 0ul))
          {
            _Bool tmp_if_expr_10;
            if(soap->error == 3)
              tmp_if_expr_10 = (_Bool)1;

            else
              tmp_if_expr_10 = soap->error == 6 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_10)
            {
              return_value_soap_in_string_9=soap_in_string(soap, "passwd", (char **)&a->passwd, "xsd:string");
              if(!(return_value_soap_in_string_9 == ((char **)NULL)))
              {
                soap_flag_passwd = soap_flag_passwd - 1ul;
                continue;
              }

            }

          }

          if(soap->error == 3)
            soap->error=soap_ignore_element(soap);

          if(soap->error == 6)
            break;

          if(!(soap->error == 0))
            return (struct t__Routing *)(void *)0;

        }
        while((_Bool)1);
        signed int return_value_soap_element_end_in_11;
        return_value_soap_element_end_in_11=soap_element_end_in(soap, tag);
        if(!(return_value_soap_element_end_in_11 == 0))
          return (struct t__Routing *)(void *)0;

      }

      else
      {
        void *return_value_soap_id_forward_12;
        return_value_soap_id_forward_12=soap_id_forward(soap, soap->href, (void *)a, (unsigned long int)0, 7, 7, sizeof(struct t__Routing) /*32ul*/ , (unsigned int)0, (void (*)(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
        a = (struct t__Routing *)return_value_soap_id_forward_12;
        if(!(soap->body == 0))
        {
          return_value_soap_element_end_in_13=soap_element_end_in(soap, tag);
          if(!(return_value_soap_element_end_in_13 == 0))
            return (struct t__Routing *)(void *)0;

        }

      }
      return a;
    }
  }
}

// soap_in_t__RoutingTable
// file soapC.c line 944
struct t__RoutingTable * soap_in_t__RoutingTable(struct soap *soap, const char *tag, struct t__RoutingTable *a, const char *type)
{
  struct soap_blist *soap_blist___ptr = (struct soap_blist *)(void *)0;
  signed int return_value_soap_element_begin_in_1;
  return_value_soap_element_begin_in_1=soap_element_begin_in(soap, tag, 0, type);
  signed int return_value_soap_element_begin_in_5;
  signed int return_value_soap_element_end_in_9;
  if(!(return_value_soap_element_begin_in_1 == 0))
    return (struct t__RoutingTable *)(void *)0;

  else
  {
    void *return_value_soap_id_enter_2;
    return_value_soap_id_enter_2=soap_id_enter(soap, soap->id, (void *)a, 8, sizeof(struct t__RoutingTable) /*16ul*/ , (const char *)(void *)0, (const char *)(void *)0, (void * (*)(struct soap *, signed int, const char *, const char *, unsigned long int *))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
    a = (struct t__RoutingTable *)return_value_soap_id_enter_2;
    if(a == ((struct t__RoutingTable *)NULL))
      return (struct t__RoutingTable *)(void *)0;

    else
    {
      soap_default_t__RoutingTable(soap, a);
      _Bool tmp_if_expr_10;
      if(!(soap->body == 0))
        tmp_if_expr_10 = !(soap->href[0l] != 0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_10 = (_Bool)0;
      if(tmp_if_expr_10)
      {
        do
        {
          soap->error = 3;
          if(soap->error == 3)
          {
            return_value_soap_element_begin_in_5=soap_element_begin_in(soap, "item", 1, (const char *)(void *)0);
            if(return_value_soap_element_begin_in_5 == 0)
            {
              if(a->__ptr == ((struct t__Routing *)NULL))
              {
                if(soap_blist___ptr == ((struct soap_blist *)NULL))
                  soap_blist___ptr=soap_new_block(soap);

                void *return_value_soap_push_block_3;
                return_value_soap_push_block_3=soap_push_block(soap, soap_blist___ptr, sizeof(struct t__Routing) /*32ul*/ );
                a->__ptr = (struct t__Routing *)return_value_soap_push_block_3;
                if(a->__ptr == ((struct t__Routing *)NULL))
                  return (struct t__RoutingTable *)(void *)0;

                soap_default_t__Routing(soap, a->__ptr);
              }

              soap_revert(soap);
              struct t__Routing *return_value_soap_in_t__Routing_4;
              return_value_soap_in_t__Routing_4=soap_in_t__Routing(soap, "item", a->__ptr, "t:Routing");
              if(!(return_value_soap_in_t__Routing_4 == ((struct t__Routing *)NULL)))
              {
                a->__size = a->__size + 1;
                a->__ptr = (struct t__Routing *)(void *)0;
                continue;
              }

            }

          }

          if(soap->error == 3)
            soap->error=soap_ignore_element(soap);

          if(soap->error == 6)
            break;

          if(!(soap->error == 0))
            return (struct t__RoutingTable *)(void *)0;

        }
        while((_Bool)1);
        if(!(a->__ptr == ((struct t__Routing *)NULL)))
          soap_pop_block(soap, soap_blist___ptr);

        if(!(a->__size == 0))
        {
          char *return_value_soap_save_block_6;
          return_value_soap_save_block_6=soap_save_block(soap, soap_blist___ptr, (char *)(void *)0, 1);
          a->__ptr = (struct t__Routing *)return_value_soap_save_block_6;
        }

        else
        {
          a->__ptr = (struct t__Routing *)(void *)0;
          if(!(soap_blist___ptr == ((struct soap_blist *)NULL)))
            soap_end_block(soap, soap_blist___ptr);

        }
        signed int return_value_soap_element_end_in_7;
        return_value_soap_element_end_in_7=soap_element_end_in(soap, tag);
        if(!(return_value_soap_element_end_in_7 == 0))
          return (struct t__RoutingTable *)(void *)0;

      }

      else
      {
        void *return_value_soap_id_forward_8;
        return_value_soap_id_forward_8=soap_id_forward(soap, soap->href, (void *)a, (unsigned long int)0, 8, 8, sizeof(struct t__RoutingTable) /*16ul*/ , (unsigned int)0, (void (*)(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
        a = (struct t__RoutingTable *)return_value_soap_id_forward_8;
        if(!(soap->body == 0))
        {
          return_value_soap_element_end_in_9=soap_element_end_in(soap, tag);
          if(!(return_value_soap_element_end_in_9 == 0))
            return (struct t__RoutingTable *)(void *)0;

        }

      }
      return a;
    }
  }
}

// soap_in_xsd__anyAttribute
// file dom.c line 671
struct soap_dom_attribute * soap_in_xsd__anyAttribute(struct soap *soap, const char *tag, struct soap_dom_attribute *node, const char *type)
{
  struct soap_attribute *tp;
  struct soap_dom_attribute *tmp = node;
  struct soap_dom_attribute *att = node;
  (void)tag;
  (void)type;
  tp = soap->attributes;
  for( ; !(tp == ((struct soap_attribute *)NULL)); tp = tp->next)
    if(!(tp->visible == 0))
    {
      if(att == ((struct soap_dom_attribute *)NULL))
      {
        att=new_attribute(soap);
        if(!(tmp == ((struct soap_dom_attribute *)NULL)))
          tmp->next = att;

        else
          node = att;
        tmp = att;
      }

      if(att == ((struct soap_dom_attribute *)NULL))
      {
        soap->error = 20;
        return (struct soap_dom_attribute *)(void *)0;
      }

      att->next = (struct soap_dom_attribute *)(void *)0;
      att->nstr=soap_current_namespace(soap, tp->name);
      att->name=soap_strdup(soap, tp->name);
      if((signed int)tp->visible == 2)
        att->text=soap_strdup(soap, tp->value);

      else
        att->text = (const char *)(void *)0;
      att->soap = soap;
      att = (struct soap_dom_attribute *)(void *)0;
    }

  return node;
}

// soap_in_xsd__anyType
// file dom.c line 516
struct soap_dom_element * soap_in_xsd__anyType(struct soap *soap, const char *tag, struct soap_dom_element *node, const char *type)
{
  struct soap_attribute *tp;
  struct soap_dom_attribute **att;
  signed int m = soap->mode;
  soap->mode = soap->mode | 0x02000000;
  (void)tag;
  (void)type;
  signed int return_value_soap_peek_element_3;
  return_value_soap_peek_element_3=soap_peek_element(soap);
  if(!(return_value_soap_peek_element_3 == 0))
  {
    const char *s;
    if(!(soap->error == 6))
      return (struct soap_dom_element *)(void *)0;

    char *return_value_soap_string_in_1;
    return_value_soap_string_in_1=soap_string_in(soap, 1, (signed long int)-1, (signed long int)-1, (const char *)(void *)0);
    s=soap_strtrim(soap, return_value_soap_string_in_1);
    _Bool tmp_if_expr_2;
    if(s == ((const char *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = !(*s != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      soap->mode = m;
      return (struct soap_dom_element *)(void *)0;
    }

    soap->mode = m;
    if(node == ((struct soap_dom_element *)NULL))
    {
      node=new_element(soap);
      if(node == ((struct soap_dom_element *)NULL))
      {
        soap->error = 20;
        return (struct soap_dom_element *)(void *)0;
      }

    }

    node->text = s;
    soap->error = 0;
    soap->peeked = (signed short int)0;
    return node;
  }

  if(node == ((struct soap_dom_element *)NULL))
  {
    node=new_element(soap);
    if(node == ((struct soap_dom_element *)NULL))
    {
      soap->error = 20;
      return (struct soap_dom_element *)(void *)0;
    }

  }

  else
    soap_default_xsd__anyType(soap, node);
  node->nstr=soap_current_namespace(soap, soap->tag);
  node->name=soap_strdup(soap, soap->tag);
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_6;
  signed int return_value_strcmp_5;
  if(!((0x00200000 & soap->mode) == 0))
    tmp_if_expr_8 = (_Bool)1;

  else
  {
    if((0x00100000 & soap->mode) == 0)
      tmp_if_expr_4 = soap->id[0l] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
    {
      if(type == ((const char *)NULL))
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        return_value_strcmp_5=strcmp(type, "xsd:anyType");
        tmp_if_expr_6 = return_value_strcmp_5 != 0 ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr_7 = tmp_if_expr_6 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_7 = (_Bool)0;
    tmp_if_expr_8 = tmp_if_expr_7 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_8)
  {
    soap->mode = m;
    node->node=soap_getelement(soap, &node->type);
    if(!(node->node == NULL))
    {
      if(!(node->type == 0))
        return node;

    }

    if(soap->error == 3)
      soap->error = 0;

    else
      return (struct soap_dom_element *)(void *)0;
    soap->mode = soap->mode | 0x02000000;
  }

  att = &node->atts;
  tp = soap->attributes;
  for( ; !(tp == ((struct soap_attribute *)NULL)); tp = tp->next)
    if(!(tp->visible == 0))
    {
      *att=new_attribute(soap);
      if(*att == ((struct soap_dom_attribute *)NULL))
      {
        soap->error = 20;
        return (struct soap_dom_element *)(void *)0;
      }

      (*att)->next = (struct soap_dom_attribute *)(void *)0;
      (*att)->nstr=soap_current_namespace(soap, tp->name);
      (*att)->name=soap_strdup(soap, tp->name);
      if((signed int)tp->visible == 2)
        (*att)->text=soap_strdup(soap, tp->value);

      else
        (*att)->text = (const char *)(void *)0;
      (*att)->soap = soap;
      att = &(*att)->next;
      tp->visible = (signed short int)0;
    }

  signed int return_value_soap_element_begin_in_9;
  return_value_soap_element_begin_in_9=soap_element_begin_in(soap, (const char *)(void *)0, 1, (const char *)(void *)0);
  if(!(return_value_soap_element_begin_in_9 == 0))
    return (struct soap_dom_element *)(void *)0;

  else
  {
    if(!(soap->body == 0))
    {
      struct soap_dom_element **elt;
      signed int return_value_soap_peek_element_11;
      return_value_soap_peek_element_11=soap_peek_element(soap);
      if(!(return_value_soap_peek_element_11 == 0))
      {
        if(!(soap->error == 6))
          return (struct soap_dom_element *)(void *)0;

        char *return_value_soap_string_in_10;
        return_value_soap_string_in_10=soap_string_in(soap, 1, (signed long int)-1, (signed long int)-1, (const char *)(void *)0);
        node->text=soap_strtrim(soap, return_value_soap_string_in_10);
        if(node->text == ((const char *)NULL))
          return (struct soap_dom_element *)(void *)0;

        soap->peeked = (signed short int)0;
      }

      elt = &node->elts;
      soap->mode = m;
      do
      {
        *elt=soap_in_xsd__anyType(soap, (const char *)(void *)0, (struct soap_dom_element *)(void *)0, (const char *)(void *)0);
        if(*elt == ((struct soap_dom_element *)NULL))
        {
          if(!(soap->error == 0))
          {
            if(!(soap->error == 6))
              return (struct soap_dom_element *)(void *)0;

          }

          break;
        }

        (*elt)->prnt = node;
        if(!(node->text == ((const char *)NULL)))
        {
          if(!(*node->text == 0))
          {
            struct soap_dom_element *elts;
            elts=new_element(soap);
            if(elts == ((struct soap_dom_element *)NULL))
            {
              soap->error = 20;
              return (struct soap_dom_element *)(void *)0;
            }

            elts->next = *elt;
            elts->prnt = node;
            elts->text = node->text;
            node->elts = elts;
            elt = &elts->next;
          }

          node->text = (const char *)(void *)0;
        }

        elt = &(*elt)->next;
      }
      while((_Bool)1);
      if(node->text == ((const char *)NULL))
      {
        if(node->elts == ((struct soap_dom_element *)NULL))
          node->tail = "";

      }

      signed int return_value_soap_element_end_in_12;
      return_value_soap_element_end_in_12=soap_element_end_in(soap, (const char *)(void *)0);
      if(!(return_value_soap_element_end_in_12 == 0))
        return (struct soap_dom_element *)(void *)0;

      signed int return_value_strcmp_13;
      return_value_strcmp_13=strcmp(soap->tag, node->name);
      if(!(return_value_strcmp_13 == 0))
      {
        soap->error = 5;
        return (struct soap_dom_element *)(void *)0;
      }

    }

    soap->mode = m;
    return node;
  }
}

// soap_inbyte
// file ../../../gsoap/stdsoap2.h line 3225
char * soap_inbyte(struct soap *soap, const char *tag, char *p, const char *type, signed int t)
{
  signed int return_value_soap_element_begin_in_1;
  return_value_soap_element_begin_in_1=soap_element_begin_in(soap, tag, 0, (const char *)(void *)0);
  signed int return_value_soap_match_tag_3;
  signed int return_value_soap_match_tag_2;
  void *return_value_soap_id_forward_5;
  signed int return_value_soap_element_end_in_8;
  if(!(return_value_soap_element_begin_in_1 == 0))
    return (char *)(void *)0;

  else
  {
    if(!(soap->type[0l] == 0))
    {
      return_value_soap_match_tag_3=soap_match_tag(soap, soap->type, type);
      if(!(return_value_soap_match_tag_3 == 0))
      {
        return_value_soap_match_tag_2=soap_match_tag(soap, soap->type, ":byte");
        if(!(return_value_soap_match_tag_2 == 0))
        {
          soap->error = 4;
          soap_revert(soap);
          return (char *)(void *)0;
        }

      }

    }

    void *return_value_soap_id_enter_4;
    return_value_soap_id_enter_4=soap_id_enter(soap, soap->id, (void *)p, t, sizeof(char) /*1ul*/ , (const char *)(void *)0, (const char *)(void *)0, (void * (*)(struct soap *, signed int, const char *, const char *, unsigned long int *))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
    p = (char *)return_value_soap_id_enter_4;
    if(!(soap->href[0l] == 0))
    {
      return_value_soap_id_forward_5=soap_id_forward(soap, soap->href, (void *)p, (unsigned long int)0, t, t, sizeof(char) /*1ul*/ , (unsigned int)0, (void (*)(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
      p = (char *)return_value_soap_id_forward_5;
    }

    else
      if(!(p == ((char *)NULL)))
      {
        const char *return_value_soap_value_6;
        return_value_soap_value_6=soap_value(soap);
        signed int return_value_soap_s2byte_7;
        return_value_soap_s2byte_7=soap_s2byte(soap, return_value_soap_value_6, p);
        if(!(return_value_soap_s2byte_7 == 0))
          return (char *)(void *)0;

      }

    if(!(soap->body == 0))
    {
      return_value_soap_element_end_in_8=soap_element_end_in(soap, tag);
      if(!(return_value_soap_element_end_in_8 == 0))
        return (char *)(void *)0;

    }

    return p;
  }
}

// soap_indateTime
// file stdsoap2.c line 15087
signed long int * soap_indateTime(struct soap *soap, const char *tag, signed long int *p, const char *type, signed int t)
{
  signed int return_value_soap_element_begin_in_1;
  return_value_soap_element_begin_in_1=soap_element_begin_in(soap, tag, 0, (const char *)(void *)0);
  signed int return_value_soap_match_tag_3;
  signed int return_value_soap_match_tag_2;
  void *return_value_soap_id_forward_5;
  signed int return_value_soap_element_end_in_8;
  if(!(return_value_soap_element_begin_in_1 == 0))
    return (signed long int *)(void *)0;

  else
  {
    if(!(soap->type[0l] == 0))
    {
      return_value_soap_match_tag_3=soap_match_tag(soap, soap->type, type);
      if(!(return_value_soap_match_tag_3 == 0))
      {
        return_value_soap_match_tag_2=soap_match_tag(soap, soap->type, ":dateTime");
        if(!(return_value_soap_match_tag_2 == 0))
        {
          soap->error = 4;
          soap_revert(soap);
          return (signed long int *)(void *)0;
        }

      }

    }

    void *return_value_soap_id_enter_4;
    return_value_soap_id_enter_4=soap_id_enter(soap, soap->id, (void *)p, t, sizeof(signed long int) /*8ul*/ , (const char *)(void *)0, (const char *)(void *)0, (void * (*)(struct soap *, signed int, const char *, const char *, unsigned long int *))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
    p = (signed long int *)return_value_soap_id_enter_4;
    if(!(soap->href[0l] == 0))
    {
      return_value_soap_id_forward_5=soap_id_forward(soap, soap->href, (void *)p, (unsigned long int)0, t, t, sizeof(signed long int) /*8ul*/ , (unsigned int)0, (void (*)(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
      p = (signed long int *)return_value_soap_id_forward_5;
    }

    else
      if(!(p == ((signed long int *)NULL)))
      {
        const char *return_value_soap_value_6;
        return_value_soap_value_6=soap_value(soap);
        signed int return_value_soap_s2dateTime_7;
        return_value_soap_s2dateTime_7=soap_s2dateTime(soap, return_value_soap_value_6, p);
        if(!(return_value_soap_s2dateTime_7 == 0))
          return (signed long int *)(void *)0;

      }

    if(!(soap->body == 0))
    {
      return_value_soap_element_end_in_8=soap_element_end_in(soap, tag);
      if(!(return_value_soap_element_end_in_8 == 0))
        return (signed long int *)(void *)0;

    }

    return p;
  }
}

// soap_indouble
// file stdsoap2.c line 13626
double * soap_indouble(struct soap *soap, const char *tag, double *p, const char *type, signed int t)
{
  signed int return_value_soap_element_begin_in_1;
  return_value_soap_element_begin_in_1=soap_element_begin_in(soap, tag, 0, (const char *)(void *)0);
  signed int return_value_soap_isnumeric_2;
  void *return_value_soap_id_forward_4;
  signed int return_value_soap_element_end_in_7;
  if(!(return_value_soap_element_begin_in_1 == 0))
    return (double *)(void *)0;

  else
  {
    if(!((signed int)soap->type[0l] == 0))
    {
      return_value_soap_isnumeric_2=soap_isnumeric(soap, type);
      if(!(return_value_soap_isnumeric_2 == 0))
        return (double *)(void *)0;

    }

    void *return_value_soap_id_enter_3;
    return_value_soap_id_enter_3=soap_id_enter(soap, soap->id, (void *)p, t, sizeof(double) /*8ul*/ , (const char *)(void *)0, (const char *)(void *)0, (void * (*)(struct soap *, signed int, const char *, const char *, unsigned long int *))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
    p = (double *)return_value_soap_id_enter_3;
    if(!(soap->href[0l] == 0))
    {
      return_value_soap_id_forward_4=soap_id_forward(soap, soap->href, (void *)p, (unsigned long int)0, t, t, sizeof(double) /*8ul*/ , (unsigned int)0, (void (*)(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
      p = (double *)return_value_soap_id_forward_4;
    }

    else
      if(!(p == ((double *)NULL)))
      {
        const char *return_value_soap_value_5;
        return_value_soap_value_5=soap_value(soap);
        signed int return_value_soap_s2double_6;
        return_value_soap_s2double_6=soap_s2double(soap, return_value_soap_value_5, p);
        if(!(return_value_soap_s2double_6 == 0))
          return (double *)(void *)0;

      }

    if(!(soap->body == 0))
    {
      return_value_soap_element_end_in_7=soap_element_end_in(soap, tag);
      if(!(return_value_soap_element_end_in_7 == 0))
        return (double *)(void *)0;

    }

    return p;
  }
}

// soap_infloat
// file stdsoap2.c line 13502
float * soap_infloat(struct soap *soap, const char *tag, float *p, const char *type, signed int t)
{
  signed int return_value_soap_element_begin_in_1;
  return_value_soap_element_begin_in_1=soap_element_begin_in(soap, tag, 0, (const char *)(void *)0);
  signed int return_value_soap_isnumeric_2;
  void *return_value_soap_id_forward_4;
  signed int return_value_soap_element_end_in_7;
  if(!(return_value_soap_element_begin_in_1 == 0))
    return (float *)(void *)0;

  else
  {
    if(!((signed int)soap->type[0l] == 0))
    {
      return_value_soap_isnumeric_2=soap_isnumeric(soap, type);
      if(!(return_value_soap_isnumeric_2 == 0))
        return (float *)(void *)0;

    }

    void *return_value_soap_id_enter_3;
    return_value_soap_id_enter_3=soap_id_enter(soap, soap->id, (void *)p, t, sizeof(float) /*4ul*/ , (const char *)(void *)0, (const char *)(void *)0, (void * (*)(struct soap *, signed int, const char *, const char *, unsigned long int *))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
    p = (float *)return_value_soap_id_enter_3;
    if(!(soap->href[0l] == 0))
    {
      return_value_soap_id_forward_4=soap_id_forward(soap, soap->href, (void *)p, (unsigned long int)0, t, t, sizeof(float) /*4ul*/ , (unsigned int)0, (void (*)(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
      p = (float *)return_value_soap_id_forward_4;
    }

    else
      if(!(p == ((float *)NULL)))
      {
        const char *return_value_soap_value_5;
        return_value_soap_value_5=soap_value(soap);
        signed int return_value_soap_s2float_6;
        return_value_soap_s2float_6=soap_s2float(soap, return_value_soap_value_5, p);
        if(!(return_value_soap_s2float_6 == 0))
          return (float *)(void *)0;

      }

    if(!(soap->body == 0))
    {
      return_value_soap_element_end_in_7=soap_element_end_in(soap, tag);
      if(!(return_value_soap_element_end_in_7 == 0))
        return (float *)(void *)0;

    }

    return p;
  }
}

// soap_inint
// file ../../../gsoap/stdsoap2.h line 3224
signed int * soap_inint(struct soap *soap, const char *tag, signed int *p, const char *type, signed int t)
{
  signed int return_value_soap_element_begin_in_1;
  return_value_soap_element_begin_in_1=soap_element_begin_in(soap, tag, 0, (const char *)(void *)0);
  signed int return_value_soap_match_tag_5;
  signed int return_value_soap_match_tag_4;
  signed int return_value_soap_match_tag_3;
  signed int return_value_soap_match_tag_2;
  void *return_value_soap_id_forward_7;
  signed int return_value_soap_element_end_in_10;
  if(!(return_value_soap_element_begin_in_1 == 0))
    return (signed int *)(void *)0;

  else
  {
    if(!(soap->type[0l] == 0))
    {
      return_value_soap_match_tag_5=soap_match_tag(soap, soap->type, type);
      if(!(return_value_soap_match_tag_5 == 0))
      {
        return_value_soap_match_tag_4=soap_match_tag(soap, soap->type, ":int");
        if(!(return_value_soap_match_tag_4 == 0))
        {
          return_value_soap_match_tag_3=soap_match_tag(soap, soap->type, ":short");
          if(!(return_value_soap_match_tag_3 == 0))
          {
            return_value_soap_match_tag_2=soap_match_tag(soap, soap->type, ":byte");
            if(!(return_value_soap_match_tag_2 == 0))
            {
              soap->error = 4;
              soap_revert(soap);
              return (signed int *)(void *)0;
            }

          }

        }

      }

    }

    void *return_value_soap_id_enter_6;
    return_value_soap_id_enter_6=soap_id_enter(soap, soap->id, (void *)p, t, sizeof(signed int) /*4ul*/ , (const char *)(void *)0, (const char *)(void *)0, (void * (*)(struct soap *, signed int, const char *, const char *, unsigned long int *))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
    p = (signed int *)return_value_soap_id_enter_6;
    if(!(soap->href[0l] == 0))
    {
      return_value_soap_id_forward_7=soap_id_forward(soap, soap->href, (void *)p, (unsigned long int)0, t, t, sizeof(signed int) /*4ul*/ , (unsigned int)0, (void (*)(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
      p = (signed int *)return_value_soap_id_forward_7;
    }

    else
      if(!(p == ((signed int *)NULL)))
      {
        const char *return_value_soap_value_8;
        return_value_soap_value_8=soap_value(soap);
        signed int return_value_soap_s2int_9;
        return_value_soap_s2int_9=soap_s2int(soap, return_value_soap_value_8, p);
        if(!(return_value_soap_s2int_9 == 0))
          return (signed int *)(void *)0;

      }

    if(!(soap->body == 0))
    {
      return_value_soap_element_end_in_10=soap_element_end_in(soap, tag);
      if(!(return_value_soap_element_end_in_10 == 0))
        return (signed int *)(void *)0;

    }

    return p;
  }
}

// soap_init_REQUIRE_lib_v20828
// file ../../../gsoap/stdsoap2.h line 3047
void soap_init_REQUIRE_lib_v20828(struct soap *soap, signed int imode, signed int omode)
{
  unsigned long int i;
  soap->state = (signed short int)1;
  soap_init_logs(soap);
  soap->version = (signed short int)0;
  soap->omode = imode;
  soap->imode = soap->omode;
  soap->mode = soap->imode;
  soap->imode = imode;
  soap->omode = omode;
  soap->plugins = (struct soap_plugin *)(void *)0;
  soap->user = (void *)0;
  i = (unsigned long int)0;
  for( ; !(i >= 4ul); i = i + 1ul)
    soap->data[(signed long int)i] = (void *)0;
  soap->userid = (const char *)(void *)0;
  soap->passwd = (const char *)(void *)0;
  soap->authrealm = (const char *)(void *)0;
  soap->fpost = http_post;
  soap->fget = http_get;
  soap->fput = http_405;
  soap->fdel = http_405;
  soap->fopt = http_200;
  soap->fhead = http_200;
  soap->fform = (signed int (*)(struct soap *))(void *)0;
  soap->fposthdr = http_post_header;
  soap->fresponse = http_response;
  soap->fparse = http_parse;
  soap->fparsehdr = http_parse_header;
  soap->fheader = (signed int (*)(struct soap *))(void *)0;
  soap->fconnect = (signed int (*)(struct soap *, const char *, const char *, signed int))(void *)0;
  soap->fdisconnect = (signed int (*)(struct soap *))(void *)0;
  soap->ipv6_multicast_if = (unsigned int)0;
  soap->ipv4_multicast_if = (char *)(void *)0;
  soap->ipv4_multicast_ttl = (unsigned char)0;
  soap->fresolve = (signed int (*)(struct soap *, const char *, struct in_addr *))(void *)0;
  soap->faccept = tcp_accept;
  soap->fopen = tcp_connect;
  soap->fclose = tcp_disconnect;
  soap->fclosesocket = tcp_closesocket;
  soap->fshutdownsocket = tcp_shutdownsocket;
  soap->fsend = fsend;
  soap->frecv = frecv;
  soap->fpoll = soap_poll;
  soap->fseterror = (void (*)(struct soap *, const char **, const char **))(void *)0;
  soap->fignore = (signed int (*)(struct soap *, const char *))(void *)0;
  soap->fserveloop = (signed int (*)(struct soap *))(void *)0;
  soap->fplugin = fplugin;
  soap->fmalloc = (void * (*)(struct soap *, unsigned long int))(void *)0;
  soap->fsvalidate = (signed int (*)(struct soap *, const char *, const char *))(void *)0;
  soap->fwvalidate = (signed int (*)(struct soap *, const char *, const signed int *))(void *)0;
  soap->feltbegin = (signed int (*)(struct soap *, const char *))(void *)0;
  soap->feltendin = (signed int (*)(struct soap *, const char *, const char *))(void *)0;
  soap->feltbegout = (signed int (*)(struct soap *, const char *))(void *)0;
  soap->feltendout = (signed int (*)(struct soap *, const char *))(void *)0;
  soap->fprepareinitsend = (signed int (*)(struct soap *))(void *)0;
  soap->fprepareinitrecv = (signed int (*)(struct soap *))(void *)0;
  soap->fpreparesend = (signed int (*)(struct soap *, const char *, unsigned long int))(void *)0;
  soap->fpreparerecv = (signed int (*)(struct soap *, const char *, unsigned long int))(void *)0;
  soap->fpreparefinalsend = (signed int (*)(struct soap *))(void *)0;
  soap->fpreparefinalrecv = (signed int (*)(struct soap *))(void *)0;
  soap->ffiltersend = (signed int (*)(struct soap *, const char **, unsigned long int *))(void *)0;
  soap->ffilterrecv = (signed int (*)(struct soap *, char *, unsigned long int *, unsigned long int))(void *)0;
  soap->fdimereadopen = (void * (*)(struct soap *, void *, const char *, const char *, const char *))(void *)0;
  soap->fdimewriteopen = (void * (*)(struct soap *, const char *, const char *, const char *))(void *)0;
  soap->fdimereadclose = (void (*)(struct soap *, void *))(void *)0;
  soap->fdimewriteclose = (void (*)(struct soap *, void *))(void *)0;
  soap->fdimeread = (unsigned long int (*)(struct soap *, void *, char *, unsigned long int))(void *)0;
  soap->fdimewrite = (signed int (*)(struct soap *, void *, const char *, unsigned long int))(void *)0;
  soap->fmimereadopen = (void * (*)(struct soap *, void *, const char *, const char *, const char *))(void *)0;
  soap->fmimewriteopen = (void * (*)(struct soap *, void *, const char *, const char *, const char *, enum soap_mime_encoding))(void *)0;
  soap->fmimereadclose = (void (*)(struct soap *, void *))(void *)0;
  soap->fmimewriteclose = (void (*)(struct soap *, void *))(void *)0;
  soap->fmimeread = (unsigned long int (*)(struct soap *, void *, char *, unsigned long int))(void *)0;
  soap->fmimewrite = (signed int (*)(struct soap *, void *, const char *, unsigned long int))(void *)0;
  soap->float_format = "%.9G";
  soap->double_format = "%.17lG";
  soap->long_double_format = (const char *)(void *)0;
  soap->dime_id_format = "cid:id%d";
  soap->http_version = "1.1";
  soap->proxy_http_version = "1.0";
  soap->http_content = (const char *)(void *)0;
  soap->actor = (const char *)(void *)0;
  soap->lang = "en";
  soap->keep_alive = (signed short int)0;
  soap->tcp_keep_alive = (signed short int)0;
  soap->tcp_keep_idle = (unsigned int)0;
  soap->tcp_keep_intvl = (unsigned int)0;
  soap->tcp_keep_cnt = (unsigned int)0;
  soap->max_keep_alive = (unsigned int)100;
  soap->recv_timeout = 0;
  soap->send_timeout = 0;
  soap->connect_timeout = 0;
  soap->accept_timeout = 0;
  soap->socket_flags = 0;
  soap->connect_flags = 0;
  soap->bind_flags = 0;
  soap->accept_flags = 0;
  soap->linger_time = (unsigned short int)0;
  soap->ip = (unsigned long int)0;
  soap->labbuf = (char *)(void *)0;
  soap->lablen = (unsigned long int)0;
  soap->labidx = (unsigned long int)0;
  soap->encodingStyle = (const char *)(void *)0;
  soap->namespaces = namespaces;
  soap->local_namespaces = (struct Namespace *)(void *)0;
  soap->nlist = (struct soap_nlist *)(void *)0;
  soap->blist = (struct soap_blist *)(void *)0;
  soap->clist = (struct soap_clist *)(void *)0;
  soap->alist = (void *)0;
  soap->shaky = (signed short int)0;
  soap->attributes = (struct soap_attribute *)(void *)0;
  soap->header = (struct SOAP_ENV__Header *)(void *)0;
  soap->fault = (struct SOAP_ENV__Fault *)(void *)0;
  soap->master = (signed int)-1;
  soap->socket = (signed int)-1;
  soap->sendsk = (signed int)-1;
  soap->recvsk = (signed int)-1;
  soap->os = (const char **)(void *)0;
  soap->is = (const char *)(void *)0;
  soap->dom = (struct soap_dom_element *)(void *)0;
  soap->dime.list = (struct soap_multipart *)(void *)0;
  soap->dime.first = (struct soap_multipart *)(void *)0;
  soap->dime.last = (struct soap_multipart *)(void *)0;
  soap->mime.list = (struct soap_multipart *)(void *)0;
  soap->mime.first = (struct soap_multipart *)(void *)0;
  soap->mime.last = (struct soap_multipart *)(void *)0;
  soap->mime.boundary = (char *)(void *)0;
  soap->mime.start = (const char *)(void *)0;
  soap->xlist = (struct soap_xlist *)(void *)0;
  soap->recvfd = 0;
  soap->sendfd = 1;
  soap->host[(signed long int)0] = (char)0;
  soap->path[(signed long int)0] = (char)0;
  soap->port = 0;
  soap->action = (char *)(void *)0;
  soap->proxy_host = (const char *)(void *)0;
  soap->proxy_port = 8080;
  soap->proxy_userid = (const char *)(void *)0;
  soap->proxy_passwd = (const char *)(void *)0;
  soap->prolog = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
  soap->wsuid = (const char *)(void *)0;
  soap->c14nexclude = (const char *)(void *)0;
  soap->c14ninclude = (const char *)(void *)0;
  soap->cookies = (struct soap_cookie *)(void *)0;
  soap->cookie_domain = (const char *)(void *)0;
  soap->cookie_path = (const char *)(void *)0;
  soap->cookie_max = 32;
  soap_init_iht(soap);
  soap_init_pht(soap);
  soap->c_locale = (void *)0;
  soap->buflen = (unsigned long int)0;
  soap->bufidx = (unsigned long int)0;
  soap->dime.chunksize = (unsigned long int)0;
  soap->dime.buflen = (unsigned long int)0;
  soap->null = (signed short int)0;
  soap->position = 0;
  soap->encoding = (signed short int)0;
  soap->mustUnderstand = (signed short int)0;
  soap->ns = (signed short int)0;
  soap->part = (signed short int)9;
  soap->event = (signed short int)0;
  soap->evlev = (unsigned int)0;
  soap->alloced = 0;
  soap->count = (unsigned long int)0;
  soap->length = (unsigned long int)0;
  soap->cdata = (signed short int)0;
  soap->peeked = (signed short int)0;
  soap->ahead = 0;
  soap->idnum = 0;
  soap->level = (unsigned int)0;
  soap->endpoint[(signed long int)0] = (char)0;
  soap->error = 0;
}

// soap_init_iht
// file stdsoap2.c line 8096
static void soap_init_iht(struct soap *soap)
{
  signed int i = 0;
  for( ; !(i >= 1999); i = i + 1)
    soap->iht[(signed long int)i] = (struct soap_ilist *)(void *)0;
}

// soap_init_logs
// file stdsoap2.c line 9242
static void soap_init_logs(struct soap *soap)
{
  signed int i = 0;
  for( ; !(i >= 3); i = i + 1)
  {
    soap->logfile[(signed long int)i] = (const char *)(void *)0;
    soap->fdebug[(signed long int)i] = (struct _IO_FILE *)(void *)0;
  }
}

// soap_init_pht
// file stdsoap2.c line 7428
static void soap_init_pht(struct soap *soap)
{
  signed int i;
  soap->pblk = (struct soap_pblk *)(void *)0;
  soap->pidx = (signed short int)0;
  i = 0;
  for( ; !(i >= 4096); i = i + 1)
    soap->pht[(signed long int)i] = (struct soap_plist *)(void *)0;
}

// soap_initialize
// file stdsoap2.c line 9645
void soap_initialize(struct soap *soap)
{
  soap_init_REQUIRE_lib_v20828(soap, 0x00000000, 0x00000000);
}

// soap_inliteral
// file ../../../gsoap/stdsoap2.h line 3237
char ** soap_inliteral(struct soap *soap, const char *tag, char **p)
{
  signed int return_value_soap_element_begin_in_2;
  return_value_soap_element_begin_in_2=soap_element_begin_in(soap, tag, 1, (const char *)(void *)0);
  if(!(return_value_soap_element_begin_in_2 == 0))
  {
    _Bool tmp_if_expr_1;
    if(!(soap->error == 6))
      tmp_if_expr_1 = (_Bool)1;

    else
    {
      soap->ahead=soap_get(soap);
      tmp_if_expr_1 = soap->ahead == (signed int)-3 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_1)
      return (char **)(void *)0;

    soap->error = 0;
  }

  if(p == ((char **)NULL))
  {
    void *return_value_soap_malloc_3;
    return_value_soap_malloc_3=soap_malloc(soap, sizeof(char *) /*8ul*/ );
    p = (char **)return_value_soap_malloc_3;
    if(p == ((char **)NULL))
      return (char **)(void *)0;

  }

  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_5;
  if(!(soap->body == 0))
    tmp_if_expr_6 = (_Bool)1;

  else
  {
    if(!(tag == ((const char *)NULL)))
      tmp_if_expr_5 = (signed int)*tag == 45 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    tmp_if_expr_6 = tmp_if_expr_5 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_6)
  {
    _Bool tmp_if_expr_4;
    if(!(tag == ((const char *)NULL)))
      tmp_if_expr_4 = (signed int)*tag != 45 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
      *p=soap_string_in(soap, -1, (signed long int)-1, (signed long int)-1, (const char *)(void *)0);

    else
      *p=soap_string_in(soap, 0, (signed long int)-1, (signed long int)-1, (const char *)(void *)0);
    if(*p == ((char *)NULL))
      return (char **)(void *)0;

    if(*(*p) == 0)
    {
      if(!(tag == ((const char *)NULL)))
      {
        if((signed int)*tag == 45)
        {
          soap->error = 6;
          return (char **)(void *)0;
        }

      }

    }

  }

  else
    if(!(soap->null == 0))
      *p = (char *)(void *)0;

    else
      *p=soap_strdup(soap, soap_padding);
  signed int return_value_soap_element_end_in_7;
  if(!(soap->body == 0))
  {
    return_value_soap_element_end_in_7=soap_element_end_in(soap, tag);
    if(!(return_value_soap_element_end_in_7 == 0))
      return (char **)(void *)0;

  }

  return p;
}

// soap_inlong
// file stdsoap2.c line 13075
signed long int * soap_inlong(struct soap *soap, const char *tag, signed long int *p, const char *type, signed int t)
{
  signed int return_value_soap_element_begin_in_1;
  return_value_soap_element_begin_in_1=soap_element_begin_in(soap, tag, 0, (const char *)(void *)0);
  signed int return_value_soap_match_tag_5;
  signed int return_value_soap_match_tag_4;
  signed int return_value_soap_match_tag_3;
  signed int return_value_soap_match_tag_2;
  void *return_value_soap_id_forward_7;
  signed int return_value_soap_element_end_in_10;
  if(!(return_value_soap_element_begin_in_1 == 0))
    return (signed long int *)(void *)0;

  else
  {
    if(!(soap->type[0l] == 0))
    {
      return_value_soap_match_tag_5=soap_match_tag(soap, soap->type, type);
      if(!(return_value_soap_match_tag_5 == 0))
      {
        return_value_soap_match_tag_4=soap_match_tag(soap, soap->type, ":int");
        if(!(return_value_soap_match_tag_4 == 0))
        {
          return_value_soap_match_tag_3=soap_match_tag(soap, soap->type, ":short");
          if(!(return_value_soap_match_tag_3 == 0))
          {
            return_value_soap_match_tag_2=soap_match_tag(soap, soap->type, ":byte");
            if(!(return_value_soap_match_tag_2 == 0))
            {
              soap->error = 4;
              soap_revert(soap);
              return (signed long int *)(void *)0;
            }

          }

        }

      }

    }

    void *return_value_soap_id_enter_6;
    return_value_soap_id_enter_6=soap_id_enter(soap, soap->id, (void *)p, t, sizeof(signed long int) /*8ul*/ , (const char *)(void *)0, (const char *)(void *)0, (void * (*)(struct soap *, signed int, const char *, const char *, unsigned long int *))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
    p = (signed long int *)return_value_soap_id_enter_6;
    if(!(soap->href[0l] == 0))
    {
      return_value_soap_id_forward_7=soap_id_forward(soap, soap->href, (void *)p, (unsigned long int)0, t, t, sizeof(signed long int) /*8ul*/ , (unsigned int)0, (void (*)(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
      p = (signed long int *)return_value_soap_id_forward_7;
    }

    else
      if(!(p == ((signed long int *)NULL)))
      {
        const char *return_value_soap_value_8;
        return_value_soap_value_8=soap_value(soap);
        signed int return_value_soap_s2long_9;
        return_value_soap_s2long_9=soap_s2long(soap, return_value_soap_value_8, p);
        if(!(return_value_soap_s2long_9 == 0))
          return (signed long int *)(void *)0;

      }

    if(!(soap->body == 0))
    {
      return_value_soap_element_end_in_10=soap_element_end_in(soap, tag);
      if(!(return_value_soap_element_end_in_10 == 0))
        return (signed long int *)(void *)0;

    }

    return p;
  }
}

// soap_inshort
// file stdsoap2.c line 13328
signed short int * soap_inshort(struct soap *soap, const char *tag, signed short int *p, const char *type, signed int t)
{
  signed int return_value_soap_element_begin_in_1;
  return_value_soap_element_begin_in_1=soap_element_begin_in(soap, tag, 0, (const char *)(void *)0);
  signed int return_value_soap_match_tag_4;
  signed int return_value_soap_match_tag_3;
  signed int return_value_soap_match_tag_2;
  void *return_value_soap_id_forward_6;
  signed int return_value_soap_element_end_in_9;
  if(!(return_value_soap_element_begin_in_1 == 0))
    return (signed short int *)(void *)0;

  else
  {
    if(!(soap->type[0l] == 0))
    {
      return_value_soap_match_tag_4=soap_match_tag(soap, soap->type, type);
      if(!(return_value_soap_match_tag_4 == 0))
      {
        return_value_soap_match_tag_3=soap_match_tag(soap, soap->type, ":short");
        if(!(return_value_soap_match_tag_3 == 0))
        {
          return_value_soap_match_tag_2=soap_match_tag(soap, soap->type, ":byte");
          if(!(return_value_soap_match_tag_2 == 0))
          {
            soap->error = 4;
            soap_revert(soap);
            return (signed short int *)(void *)0;
          }

        }

      }

    }

    void *return_value_soap_id_enter_5;
    return_value_soap_id_enter_5=soap_id_enter(soap, soap->id, (void *)p, t, sizeof(signed short int) /*2ul*/ , (const char *)(void *)0, (const char *)(void *)0, (void * (*)(struct soap *, signed int, const char *, const char *, unsigned long int *))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
    p = (signed short int *)return_value_soap_id_enter_5;
    if(!(soap->href[0l] == 0))
    {
      return_value_soap_id_forward_6=soap_id_forward(soap, soap->href, (void *)p, (unsigned long int)0, t, t, sizeof(signed short int) /*2ul*/ , (unsigned int)0, (void (*)(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
      p = (signed short int *)return_value_soap_id_forward_6;
    }

    else
      if(!(p == ((signed short int *)NULL)))
      {
        const char *return_value_soap_value_7;
        return_value_soap_value_7=soap_value(soap);
        signed int return_value_soap_s2short_8;
        return_value_soap_s2short_8=soap_s2short(soap, return_value_soap_value_7, p);
        if(!(return_value_soap_s2short_8 == 0))
          return (signed short int *)(void *)0;

      }

    if(!(soap->body == 0))
    {
      return_value_soap_element_end_in_9=soap_element_end_in(soap, tag);
      if(!(return_value_soap_element_end_in_9 == 0))
        return (signed short int *)(void *)0;

    }

    return p;
  }
}

// soap_instring
// file ../../../gsoap/stdsoap2.h line 3236
char ** soap_instring(struct soap *soap, const char *tag, char **p, const char *type, signed int t, signed int flag, signed long int minlen, signed long int maxlen, const char *pattern)
{
  (void)type;
  signed int return_value_soap_element_begin_in_3;
  return_value_soap_element_begin_in_3=soap_element_begin_in(soap, tag, 1, (const char *)(void *)0);
  if(!(return_value_soap_element_begin_in_3 == 0))
  {
    _Bool tmp_if_expr_1;
    if(tag == ((const char *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)*tag != 45 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr_2;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = soap->error != 6 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      return (char **)(void *)0;

    soap->error = 0;
  }

  if(p == ((char **)NULL))
  {
    void *return_value_soap_malloc_4;
    return_value_soap_malloc_4=soap_malloc(soap, sizeof(char *) /*8ul*/ );
    p = (char **)return_value_soap_malloc_4;
    if(p == ((char **)NULL))
      return (char **)(void *)0;

  }

  void *return_value_soap_id_enter_5;
  if(!(soap->null == 0))
    *p = (char *)(void *)0;

  else
    if(!(soap->body == 0))
    {
      *p=soap_string_in(soap, flag, minlen, maxlen, pattern);
      _Bool tmp_if_expr_6;
      if(*p == ((char *)NULL))
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        return_value_soap_id_enter_5=soap_id_enter(soap, soap->id, (void *)*p, t, sizeof(char *) /*8ul*/ , (const char *)(void *)0, (const char *)(void *)0, (void * (*)(struct soap *, signed int, const char *, const char *, unsigned long int *))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
        tmp_if_expr_6 = !((char *)return_value_soap_id_enter_5 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_6)
        return (char **)(void *)0;

      if(*(*p) == 0)
      {
        if(!(tag == ((const char *)NULL)))
        {
          if((signed int)*tag == 45)
          {
            soap->error = 6;
            return (char **)(void *)0;
          }

        }

      }

    }

    else
    {
      _Bool tmp_if_expr_7;
      if(!(tag == ((const char *)NULL)))
        tmp_if_expr_7 = (signed int)*tag == 45 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_7 = (_Bool)0;
      if(tmp_if_expr_7)
      {
        soap->error = 6;
        return (char **)(void *)0;
      }

      else
        if(soap->href[0l] == 0)
        {
          if(minlen >= 1l)
          {
            soap->error = 45;
            return (char **)(void *)0;
          }

          *p=soap_strdup(soap, soap_padding);
        }

    }
  void *return_value_soap_id_lookup_8;
  if(!(soap->href[0l] == 0))
  {
    return_value_soap_id_lookup_8=soap_id_lookup(soap, soap->href, (void **)p, t, sizeof(char **) /*8ul*/ , (unsigned int)0, (signed int (*)(signed int, signed int))(void *)0);
    p = (char **)return_value_soap_id_lookup_8;
  }

  signed int return_value_soap_element_end_in_9;
  if(!(soap->body == 0))
  {
    return_value_soap_element_end_in_9=soap_element_end_in(soap, tag);
    if(!(return_value_soap_element_end_in_9 == 0))
      return (char **)(void *)0;

  }

  return p;
}

// soap_int2s
// file stdsoap2.c line 12928
const char * soap_int2s(struct soap *soap, signed int n)
{
  const char *return_value_soap_long2s_1;
  return_value_soap_long2s_1=soap_long2s(soap, (signed long int)n);
  return return_value_soap_long2s_1;
}

// soap_inunsignedByte
// file stdsoap2.c line 13698
unsigned char * soap_inunsignedByte(struct soap *soap, const char *tag, unsigned char *p, const char *type, signed int t)
{
  signed int return_value_soap_element_begin_in_1;
  return_value_soap_element_begin_in_1=soap_element_begin_in(soap, tag, 0, (const char *)(void *)0);
  signed int return_value_soap_match_tag_3;
  signed int return_value_soap_match_tag_2;
  void *return_value_soap_id_forward_5;
  signed int return_value_soap_element_end_in_8;
  if(!(return_value_soap_element_begin_in_1 == 0))
    return (unsigned char *)(void *)0;

  else
  {
    if(!(soap->type[0l] == 0))
    {
      return_value_soap_match_tag_3=soap_match_tag(soap, soap->type, type);
      if(!(return_value_soap_match_tag_3 == 0))
      {
        return_value_soap_match_tag_2=soap_match_tag(soap, soap->type, ":unsignedByte");
        if(!(return_value_soap_match_tag_2 == 0))
        {
          soap->error = 4;
          soap_revert(soap);
          return (unsigned char *)(void *)0;
        }

      }

    }

    void *return_value_soap_id_enter_4;
    return_value_soap_id_enter_4=soap_id_enter(soap, soap->id, (void *)p, t, sizeof(unsigned char) /*1ul*/ , (const char *)(void *)0, (const char *)(void *)0, (void * (*)(struct soap *, signed int, const char *, const char *, unsigned long int *))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
    p = (unsigned char *)return_value_soap_id_enter_4;
    if(!(soap->href[0l] == 0))
    {
      return_value_soap_id_forward_5=soap_id_forward(soap, soap->href, (void *)p, (unsigned long int)0, t, t, sizeof(unsigned char) /*1ul*/ , (unsigned int)0, (void (*)(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
      p = (unsigned char *)return_value_soap_id_forward_5;
    }

    else
      if(!(p == ((unsigned char *)NULL)))
      {
        const char *return_value_soap_value_6;
        return_value_soap_value_6=soap_value(soap);
        signed int return_value_soap_s2unsignedByte_7;
        return_value_soap_s2unsignedByte_7=soap_s2unsignedByte(soap, return_value_soap_value_6, p);
        if(!(return_value_soap_s2unsignedByte_7 == 0))
          return (unsigned char *)(void *)0;

      }

    if(!(soap->body == 0))
    {
      return_value_soap_element_end_in_8=soap_element_end_in(soap, tag);
      if(!(return_value_soap_element_end_in_8 == 0))
        return (unsigned char *)(void *)0;

    }

    return p;
  }
}

// soap_inunsignedInt
// file stdsoap2.c line 13862
unsigned int * soap_inunsignedInt(struct soap *soap, const char *tag, unsigned int *p, const char *type, signed int t)
{
  signed int return_value_soap_element_begin_in_1;
  return_value_soap_element_begin_in_1=soap_element_begin_in(soap, tag, 0, (const char *)(void *)0);
  signed int return_value_soap_match_tag_5;
  signed int return_value_soap_match_tag_4;
  signed int return_value_soap_match_tag_3;
  signed int return_value_soap_match_tag_2;
  void *return_value_soap_id_forward_7;
  signed int return_value_soap_element_end_in_10;
  if(!(return_value_soap_element_begin_in_1 == 0))
    return (unsigned int *)(void *)0;

  else
  {
    if(!(soap->type[0l] == 0))
    {
      return_value_soap_match_tag_5=soap_match_tag(soap, soap->type, type);
      if(!(return_value_soap_match_tag_5 == 0))
      {
        return_value_soap_match_tag_4=soap_match_tag(soap, soap->type, ":unsignedInt");
        if(!(return_value_soap_match_tag_4 == 0))
        {
          return_value_soap_match_tag_3=soap_match_tag(soap, soap->type, ":unsignedShort");
          if(!(return_value_soap_match_tag_3 == 0))
          {
            return_value_soap_match_tag_2=soap_match_tag(soap, soap->type, ":unsignedByte");
            if(!(return_value_soap_match_tag_2 == 0))
            {
              soap->error = 4;
              soap_revert(soap);
              return (unsigned int *)(void *)0;
            }

          }

        }

      }

    }

    void *return_value_soap_id_enter_6;
    return_value_soap_id_enter_6=soap_id_enter(soap, soap->id, (void *)p, t, sizeof(unsigned int) /*4ul*/ , (const char *)(void *)0, (const char *)(void *)0, (void * (*)(struct soap *, signed int, const char *, const char *, unsigned long int *))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
    p = (unsigned int *)return_value_soap_id_enter_6;
    if(!(soap->href[0l] == 0))
    {
      return_value_soap_id_forward_7=soap_id_forward(soap, soap->href, (void *)p, (unsigned long int)0, t, t, sizeof(unsigned int) /*4ul*/ , (unsigned int)0, (void (*)(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
      p = (unsigned int *)return_value_soap_id_forward_7;
    }

    else
      if(!(p == ((unsigned int *)NULL)))
      {
        const char *return_value_soap_value_8;
        return_value_soap_value_8=soap_value(soap);
        signed int return_value_soap_s2unsignedInt_9;
        return_value_soap_s2unsignedInt_9=soap_s2unsignedInt(soap, return_value_soap_value_8, p);
        if(!(return_value_soap_s2unsignedInt_9 == 0))
          return (unsigned int *)(void *)0;

      }

    if(!(soap->body == 0))
    {
      return_value_soap_element_end_in_10=soap_element_end_in(soap, tag);
      if(!(return_value_soap_element_end_in_10 == 0))
        return (unsigned int *)(void *)0;

    }

    return p;
  }
}

// soap_inunsignedLong
// file stdsoap2.c line 13951
unsigned long int * soap_inunsignedLong(struct soap *soap, const char *tag, unsigned long int *p, const char *type, signed int t)
{
  signed int return_value_soap_element_begin_in_1;
  return_value_soap_element_begin_in_1=soap_element_begin_in(soap, tag, 0, (const char *)(void *)0);
  signed int return_value_soap_match_tag_5;
  signed int return_value_soap_match_tag_4;
  signed int return_value_soap_match_tag_3;
  signed int return_value_soap_match_tag_2;
  void *return_value_soap_id_forward_7;
  signed int return_value_soap_element_end_in_10;
  if(!(return_value_soap_element_begin_in_1 == 0))
    return (unsigned long int *)(void *)0;

  else
  {
    if(!(soap->type[0l] == 0))
    {
      return_value_soap_match_tag_5=soap_match_tag(soap, soap->type, type);
      if(!(return_value_soap_match_tag_5 == 0))
      {
        return_value_soap_match_tag_4=soap_match_tag(soap, soap->type, ":unsignedInt");
        if(!(return_value_soap_match_tag_4 == 0))
        {
          return_value_soap_match_tag_3=soap_match_tag(soap, soap->type, ":unsignedShort");
          if(!(return_value_soap_match_tag_3 == 0))
          {
            return_value_soap_match_tag_2=soap_match_tag(soap, soap->type, ":unsignedByte");
            if(!(return_value_soap_match_tag_2 == 0))
            {
              soap->error = 4;
              soap_revert(soap);
              return (unsigned long int *)(void *)0;
            }

          }

        }

      }

    }

    void *return_value_soap_id_enter_6;
    return_value_soap_id_enter_6=soap_id_enter(soap, soap->id, (void *)p, t, sizeof(unsigned long int) /*8ul*/ , (const char *)(void *)0, (const char *)(void *)0, (void * (*)(struct soap *, signed int, const char *, const char *, unsigned long int *))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
    p = (unsigned long int *)return_value_soap_id_enter_6;
    if(!(soap->href[0l] == 0))
    {
      return_value_soap_id_forward_7=soap_id_forward(soap, soap->href, (void *)p, (unsigned long int)0, t, t, sizeof(unsigned long int) /*8ul*/ , (unsigned int)0, (void (*)(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
      p = (unsigned long int *)return_value_soap_id_forward_7;
    }

    else
      if(!(p == ((unsigned long int *)NULL)))
      {
        const char *return_value_soap_value_8;
        return_value_soap_value_8=soap_value(soap);
        signed int return_value_soap_s2unsignedLong_9;
        return_value_soap_s2unsignedLong_9=soap_s2unsignedLong(soap, return_value_soap_value_8, p);
        if(!(return_value_soap_s2unsignedLong_9 == 0))
          return (unsigned long int *)(void *)0;

      }

    if(!(soap->body == 0))
    {
      return_value_soap_element_end_in_10=soap_element_end_in(soap, tag);
      if(!(return_value_soap_element_end_in_10 == 0))
        return (unsigned long int *)(void *)0;

    }

    return p;
  }
}

// soap_inunsignedShort
// file stdsoap2.c line 13775
unsigned short int * soap_inunsignedShort(struct soap *soap, const char *tag, unsigned short int *p, const char *type, signed int t)
{
  signed int return_value_soap_element_begin_in_1;
  return_value_soap_element_begin_in_1=soap_element_begin_in(soap, tag, 0, (const char *)(void *)0);
  signed int return_value_soap_match_tag_4;
  signed int return_value_soap_match_tag_3;
  signed int return_value_soap_match_tag_2;
  void *return_value_soap_id_forward_6;
  signed int return_value_soap_element_end_in_9;
  if(!(return_value_soap_element_begin_in_1 == 0))
    return (unsigned short int *)(void *)0;

  else
  {
    if(!(soap->type[0l] == 0))
    {
      return_value_soap_match_tag_4=soap_match_tag(soap, soap->type, type);
      if(!(return_value_soap_match_tag_4 == 0))
      {
        return_value_soap_match_tag_3=soap_match_tag(soap, soap->type, ":unsignedShort");
        if(!(return_value_soap_match_tag_3 == 0))
        {
          return_value_soap_match_tag_2=soap_match_tag(soap, soap->type, ":unsignedByte");
          if(!(return_value_soap_match_tag_2 == 0))
          {
            soap->error = 4;
            soap_revert(soap);
            return (unsigned short int *)(void *)0;
          }

        }

      }

    }

    void *return_value_soap_id_enter_5;
    return_value_soap_id_enter_5=soap_id_enter(soap, soap->id, (void *)p, t, sizeof(unsigned short int) /*2ul*/ , (const char *)(void *)0, (const char *)(void *)0, (void * (*)(struct soap *, signed int, const char *, const char *, unsigned long int *))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
    p = (unsigned short int *)return_value_soap_id_enter_5;
    if(!(soap->href[0l] == 0))
    {
      return_value_soap_id_forward_6=soap_id_forward(soap, soap->href, (void *)p, (unsigned long int)0, t, t, sizeof(unsigned short int) /*2ul*/ , (unsigned int)0, (void (*)(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
      p = (unsigned short int *)return_value_soap_id_forward_6;
    }

    else
      if(!(p == ((unsigned short int *)NULL)))
      {
        const char *return_value_soap_value_7;
        return_value_soap_value_7=soap_value(soap);
        signed int return_value_soap_s2unsignedShort_8;
        return_value_soap_s2unsignedShort_8=soap_s2unsignedShort(soap, return_value_soap_value_7, p);
        if(!(return_value_soap_s2unsignedShort_8 == 0))
          return (unsigned short int *)(void *)0;

      }

    if(!(soap->body == 0))
    {
      return_value_soap_element_end_in_9=soap_element_end_in(soap, tag);
      if(!(return_value_soap_element_end_in_9 == 0))
        return (unsigned short int *)(void *)0;

    }

    return p;
  }
}

// soap_inwliteral
// file stdsoap2.c line 15241
signed int ** soap_inwliteral(struct soap *soap, const char *tag, signed int **p)
{
  signed int return_value_soap_element_begin_in_2;
  return_value_soap_element_begin_in_2=soap_element_begin_in(soap, tag, 1, (const char *)(void *)0);
  if(!(return_value_soap_element_begin_in_2 == 0))
  {
    _Bool tmp_if_expr_1;
    if(!(soap->error == 6))
      tmp_if_expr_1 = (_Bool)1;

    else
    {
      soap->ahead=soap_get(soap);
      tmp_if_expr_1 = soap->ahead == (signed int)-3 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_1)
      return (signed int **)(void *)0;

    soap->error = 0;
  }

  if(p == ((signed int **)NULL))
  {
    void *return_value_soap_malloc_3;
    return_value_soap_malloc_3=soap_malloc(soap, sizeof(signed int *) /*8ul*/ );
    p = (signed int **)return_value_soap_malloc_3;
    if(p == ((signed int **)NULL))
      return (signed int **)(void *)0;

  }

  if(!(soap->body == 0))
  {
    _Bool tmp_if_expr_4;
    if(!(tag == ((const char *)NULL)))
      tmp_if_expr_4 = (signed int)*tag != 45 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
      *p=soap_wstring_in(soap, -1, (signed long int)-1, (signed long int)-1, (const char *)(void *)0);

    else
      *p=soap_wstring_in(soap, 0, (signed long int)-1, (signed long int)-1, (const char *)(void *)0);
    if(*p == ((signed int *)NULL))
      return (signed int **)(void *)0;

    if(*(*p) == 0)
    {
      if(!(tag == ((const char *)NULL)))
      {
        if((signed int)*tag == 45)
        {
          soap->error = 6;
          return (signed int **)(void *)0;
        }

      }

    }

  }

  else
  {
    _Bool tmp_if_expr_5;
    if(!(tag == ((const char *)NULL)))
      tmp_if_expr_5 = (signed int)*tag == 45 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
    {
      soap->error = 6;
      return (signed int **)(void *)0;
    }

    else
      if(!(soap->null == 0))
        *p = (signed int *)(void *)0;

      else
        *p=soap_wstrdup(soap, (signed int *)soap_padding);
  }
  signed int return_value_soap_element_end_in_6;
  if(!(soap->body == 0))
  {
    return_value_soap_element_end_in_6=soap_element_end_in(soap, tag);
    if(!(return_value_soap_element_end_in_6 == 0))
      return (signed int **)(void *)0;

  }

  return p;
}

// soap_inwstring
// file stdsoap2.c line 14701
signed int ** soap_inwstring(struct soap *soap, const char *tag, signed int **p, const char *type, signed int t, signed long int minlen, signed long int maxlen, const char *pattern)
{
  (void)type;
  signed int return_value_soap_element_begin_in_3;
  return_value_soap_element_begin_in_3=soap_element_begin_in(soap, tag, 1, (const char *)(void *)0);
  if(!(return_value_soap_element_begin_in_3 == 0))
  {
    _Bool tmp_if_expr_1;
    if(tag == ((const char *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)*tag != 45 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr_2;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = soap->error != 6 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      return (signed int **)(void *)0;

    soap->error = 0;
  }

  if(p == ((signed int **)NULL))
  {
    void *return_value_soap_malloc_4;
    return_value_soap_malloc_4=soap_malloc(soap, sizeof(signed int *) /*8ul*/ );
    p = (signed int **)return_value_soap_malloc_4;
    if(p == ((signed int **)NULL))
      return (signed int **)(void *)0;

  }

  void *return_value_soap_id_enter_5;
  if(!(soap->null == 0))
    *p = (signed int *)(void *)0;

  else
    if(!(soap->body == 0))
    {
      *p=soap_wstring_in(soap, 1, minlen, maxlen, pattern);
      _Bool tmp_if_expr_6;
      if(*p == ((signed int *)NULL))
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        return_value_soap_id_enter_5=soap_id_enter(soap, soap->id, (void *)*p, t, sizeof(signed int *) /*8ul*/ , (const char *)(void *)0, (const char *)(void *)0, (void * (*)(struct soap *, signed int, const char *, const char *, unsigned long int *))(void *)0, (signed int (*)(signed int, signed int))(void *)0);
        tmp_if_expr_6 = !((signed int *)return_value_soap_id_enter_5 != ((signed int *)NULL)) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_6)
        return (signed int **)(void *)0;

      if(*(*p) == 0)
      {
        if(!(tag == ((const char *)NULL)))
        {
          if((signed int)*tag == 45)
          {
            soap->error = 6;
            return (signed int **)(void *)0;
          }

        }

      }

    }

    else
    {
      _Bool tmp_if_expr_7;
      if(!(tag == ((const char *)NULL)))
        tmp_if_expr_7 = (signed int)*tag == 45 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_7 = (_Bool)0;
      if(tmp_if_expr_7)
      {
        soap->error = 6;
        return (signed int **)(void *)0;
      }

      else
        if(soap->href[0l] == 0)
        {
          if(minlen >= 1l)
          {
            soap->error = 45;
            return (signed int **)(void *)0;
          }

          *p=soap_wstrdup(soap, (signed int *)soap_padding);
        }

    }
  void *return_value_soap_id_lookup_8;
  if(!(soap->href[0l] == 0))
  {
    return_value_soap_id_lookup_8=soap_id_lookup(soap, soap->href, (void **)p, t, sizeof(signed int **) /*8ul*/ , (unsigned int)0, (signed int (*)(signed int, signed int))(void *)0);
    p = (signed int **)return_value_soap_id_lookup_8;
  }

  signed int return_value_soap_element_end_in_9;
  if(!(soap->body == 0))
  {
    return_value_soap_element_end_in_9=soap_element_end_in(soap, tag);
    if(!(return_value_soap_element_end_in_9 == 0))
      return (signed int **)(void *)0;

  }

  return p;
}

// soap_is_embedded
// file stdsoap2.c line 7960
signed int soap_is_embedded(struct soap *soap, struct soap_plist *pp)
{
  if(pp == ((struct soap_plist *)NULL))
    return 0;

  else
    if((signed int)soap->version == 1)
    {
      if(soap->encodingStyle == ((const char *)NULL))
        goto __CPROVER_DUMP_L3;

      if(!((0x20000000 & soap->mode) == 0))
        goto __CPROVER_DUMP_L3;

      if((signed int)soap->part == 3)
        goto __CPROVER_DUMP_L3;

      if(!((0x00000008 & soap->mode) == 0))
        return (signed int)((signed int)pp->mark1 != 0);

      return (signed int)((signed int)pp->mark2 != 0);
    }

    else
    {

    __CPROVER_DUMP_L3:
      ;
      if(!((0x00000008 & soap->mode) == 0))
        return (signed int)((signed int)pp->mark1 == 1);

      else
        return (signed int)((signed int)pp->mark2 == 1);
    }
}

// soap_is_shaky
// file stdsoap2.c line 8613
static signed int soap_is_shaky(struct soap *soap, void *p)
{
  (void)p;
  if(soap->blist == ((struct soap_blist *)NULL))
  {
    if(!(soap->shaky == 0))
      goto __CPROVER_DUMP_L1;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 1;
  }
}

// soap_is_single
// file stdsoap2.c line 7983
signed int soap_is_single(struct soap *soap, struct soap_plist *pp)
{
  if((signed int)soap->part == 3)
    return 1;

  else
    if(pp == ((struct soap_plist *)NULL))
      return 0;

    else
      if(!((0x00000008 & soap->mode) == 0))
        return (signed int)((signed int)pp->mark1 == 0);

      else
        return (signed int)((signed int)pp->mark2 == 0);
}

// soap_isnumeric
// file stdsoap2.c line 13470
static signed int soap_isnumeric(struct soap *soap, const char *type)
{
  signed int return_value_soap_match_tag_17;
  return_value_soap_match_tag_17=soap_match_tag(soap, soap->type, type);
  signed int return_value_soap_match_tag_16;
  signed int return_value_soap_match_tag_15;
  signed int return_value_soap_match_tag_14;
  signed int return_value_soap_match_tag_13;
  signed int return_value_soap_match_tag_12;
  signed int return_value_soap_match_tag_11;
  signed int return_value_soap_match_tag_10;
  signed int return_value_soap_match_tag_9;
  signed int return_value_soap_match_tag_8;
  signed int return_value_soap_match_tag_7;
  signed int return_value_soap_match_tag_6;
  signed int return_value_soap_match_tag_5;
  signed int return_value_soap_match_tag_4;
  signed int return_value_soap_match_tag_3;
  signed int return_value_soap_match_tag_2;
  signed int return_value_soap_match_tag_1;
  if(!(return_value_soap_match_tag_17 == 0))
  {
    return_value_soap_match_tag_16=soap_match_tag(soap, soap->type, ":float");
    if(!(return_value_soap_match_tag_16 == 0))
    {
      return_value_soap_match_tag_15=soap_match_tag(soap, soap->type, ":double");
      if(!(return_value_soap_match_tag_15 == 0))
      {
        return_value_soap_match_tag_14=soap_match_tag(soap, soap->type, ":decimal");
        if(!(return_value_soap_match_tag_14 == 0))
        {
          return_value_soap_match_tag_13=soap_match_tag(soap, soap->type, ":integer");
          if(!(return_value_soap_match_tag_13 == 0))
          {
            return_value_soap_match_tag_12=soap_match_tag(soap, soap->type, ":positiveInteger");
            if(!(return_value_soap_match_tag_12 == 0))
            {
              return_value_soap_match_tag_11=soap_match_tag(soap, soap->type, ":negativeInteger");
              if(!(return_value_soap_match_tag_11 == 0))
              {
                return_value_soap_match_tag_10=soap_match_tag(soap, soap->type, ":nonPositiveInteger");
                if(!(return_value_soap_match_tag_10 == 0))
                {
                  return_value_soap_match_tag_9=soap_match_tag(soap, soap->type, ":nonNegativeInteger");
                  if(!(return_value_soap_match_tag_9 == 0))
                  {
                    return_value_soap_match_tag_8=soap_match_tag(soap, soap->type, ":long");
                    if(!(return_value_soap_match_tag_8 == 0))
                    {
                      return_value_soap_match_tag_7=soap_match_tag(soap, soap->type, ":int");
                      if(!(return_value_soap_match_tag_7 == 0))
                      {
                        return_value_soap_match_tag_6=soap_match_tag(soap, soap->type, ":short");
                        if(!(return_value_soap_match_tag_6 == 0))
                        {
                          return_value_soap_match_tag_5=soap_match_tag(soap, soap->type, ":byte");
                          if(!(return_value_soap_match_tag_5 == 0))
                          {
                            return_value_soap_match_tag_4=soap_match_tag(soap, soap->type, ":unsignedLong");
                            if(!(return_value_soap_match_tag_4 == 0))
                            {
                              return_value_soap_match_tag_3=soap_match_tag(soap, soap->type, ":unsignedInt");
                              if(!(return_value_soap_match_tag_3 == 0))
                              {
                                return_value_soap_match_tag_2=soap_match_tag(soap, soap->type, ":unsignedShort");
                                if(!(return_value_soap_match_tag_2 == 0))
                                {
                                  return_value_soap_match_tag_1=soap_match_tag(soap, soap->type, ":unsignedByte");
                                  if(!(return_value_soap_match_tag_1 == 0))
                                  {
                                    soap->error = 4;
                                    soap_revert(soap);
                                    return -1;
                                  }

                                }

                              }

                            }

                          }

                        }

                      }

                    }

                  }

                }

              }

            }

          }

        }

      }

    }

  }

  return 0;
}

// soap_isxdigit
// file stdsoap2.c line 1112
static signed int soap_isxdigit(signed int c)
{
  return (signed int)(c >= 48 && c <= 57 || c >= 65 && c <= 70 || c >= 97 && c <= 102);
}

// soap_link
// file stdsoap2.c line 8507
struct soap_clist * soap_link(struct soap *soap, void *p, signed int t, signed int n, signed int (*fdelete)(struct soap_clist *))
{
  struct soap_clist *cp = (struct soap_clist *)(void *)0;
  if(!(p == NULL) && !(soap == ((struct soap *)NULL)) && !(n == -2))
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct soap_clist) /*32ul*/ );
    cp = (struct soap_clist *)return_value_malloc_1;
    if(cp == ((struct soap_clist *)NULL))
      soap->error = 20;

    else
    {
      cp->next = soap->clist;
      soap->alloced = t;
      cp->type = soap->alloced;
      cp->size = n;
      cp->ptr = p;
      cp->fdelete = fdelete;
      soap->clist = cp;
    }
  }

  return cp;
}

// soap_long2s
// file stdsoap2.c line 13021
const char * soap_long2s(struct soap *soap, signed long int n)
{
  snprintf(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , "%ld", n);
  return soap->tmpbuf;
}

// soap_lookup
// file stdsoap2.c line 8136
struct soap_ilist * soap_lookup(struct soap *soap, const char *id)
{
  struct soap_ilist *ip = (struct soap_ilist *)(void *)0;
  unsigned long int return_value_soap_hash_1;
  return_value_soap_hash_1=soap_hash(id);
  ip = soap->iht[(signed long int)return_value_soap_hash_1];
  signed int return_value_strcmp_2;
  for( ; !(ip == ((struct soap_ilist *)NULL)); ip = ip->next)
  {
    return_value_strcmp_2=strcmp(ip->id, id);
    if(return_value_strcmp_2 == 0)
      return ip;

  }
  return (struct soap_ilist *)(void *)0;
}

// soap_lookup_ns
// file stdsoap2.c line 10199
struct soap_nlist * soap_lookup_ns(struct soap *soap, const char *tag, unsigned long int n)
{
  struct soap_nlist *np = soap->nlist;
  signed int return_value_strncmp_1;
  for( ; !(np == ((struct soap_nlist *)NULL)); np = np->next)
  {
    return_value_strncmp_1=strncmp(np->id, tag, n);
    if(return_value_strncmp_1 == 0)
    {
      if(np->id[(signed long int)n] == 0)
        return np;

    }

  }
  return (struct soap_nlist *)(void *)0;
}

// soap_lookup_plugin
// file stdsoap2.c line 18380
void * soap_lookup_plugin(struct soap *soap, const char *id)
{
  void *return_value;
  return_value=soap->fplugin(soap, id);
  return return_value;
}

// soap_lookup_type
// file ../../../gsoap/stdsoap2.h line 3019
signed int soap_lookup_type(struct soap *soap, const char *id)
{
  struct soap_ilist *ip;
  if(!(id == ((const char *)NULL)))
  {
    if(*id == 0)
      goto __CPROVER_DUMP_L1;

    ip=soap_lookup(soap, id);
    if(ip == ((struct soap_ilist *)NULL))
      goto __CPROVER_DUMP_L1;

    return ip->type;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 0;
  }
}

// soap_malloc
// file ../../../gsoap/stdsoap2.h line 3008
void * soap_malloc(struct soap *soap, unsigned long int n)
{
  char *p;
  void *return_value_malloc_1;
  if(soap == ((struct soap *)NULL))
  {
    return_value_malloc_1=malloc(n);
    return return_value_malloc_1;
  }

  void *return_value;
  if(!(soap->fmalloc == ((void * (*)(struct soap *, unsigned long int))NULL)))
  {
    return_value=soap->fmalloc(soap, n);
    p = (char *)return_value;
  }

  else
  {
    n = n + sizeof(signed short int) /*2ul*/ ;
    n = n + ((unsigned long int)-((signed long int)n) & sizeof(void *) /*8ul*/  - (unsigned long int)1);
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(n + sizeof(void *) /*8ul*/  + sizeof(unsigned long int) /*8ul*/ );
    p = (char *)return_value_malloc_2;
    if(p == ((char *)NULL))
    {
      soap->error = 20;
      return (void *)0;
    }

    *((unsigned short int *)((p + (signed long int)n) - (signed long int)sizeof(unsigned short int) /*2ul*/ )) = (unsigned short int)0xC0DE;
    *((void **)(p + (signed long int)n)) = soap->alist;
    *((unsigned long int *)(p + (signed long int)n + (signed long int)sizeof(void *) /*8ul*/ )) = n;
    soap->alist = (void *)(p + (signed long int)n);
  }
  return (void *)p;
}

// soap_mark_cycle
// file stdsoap2.c line 11026
signed int soap_mark_cycle(struct soap *soap, struct soap_plist *pp)
{
  (void)soap;
  _Bool tmp_if_expr_1;
  if(!(pp == ((struct soap_plist *)NULL)))
    tmp_if_expr_1 = (signed int)pp->mark1 == 2 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (soap->mode & 0x00020000) != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  return (signed int)tmp_if_expr_2;
}

// soap_mark_dup
// file stdsoap2.c line 11038
void soap_mark_dup(struct soap *soap, void *a, struct soap_plist *pp)
{
  (void)soap;
  if(!(pp == ((struct soap_plist *)NULL)))
    pp->dup = a;

}

// soap_mark_lookup
// file stdsoap2.c line 10994
void * soap_mark_lookup(struct soap *soap, const void *p, signed int t, struct soap_plist **ppp, char **mark)
{
  if(soap == ((struct soap *)NULL))
    return (void *)0;

  else
  {
    _Bool tmp_if_expr_3;
    if(!(mark == ((char **)NULL)))
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = !((soap->mode & 0x00020000) != 0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
    {
      signed int return_value_soap_pointer_lookup_2;
      return_value_soap_pointer_lookup_2=soap_pointer_lookup(soap, p, t, ppp);
      if(return_value_soap_pointer_lookup_2 == 0)
      {
        signed int return_value_soap_pointer_enter_1;
        return_value_soap_pointer_enter_1=soap_pointer_enter(soap, p, (void *)0, 0, t, ppp);
        if(return_value_soap_pointer_enter_1 == 0)
          return (void *)0;

      }

      else
        if((0x00020000 & soap->mode) == 0)
          return (*ppp)->dup;

      if(!(mark == ((char **)NULL)))
      {
        if((signed int)(*ppp)->mark1 >= 1)
          (*ppp)->mark1 = (char)2;

        else
          (*ppp)->mark1 = (char)1;
        *mark = &(*ppp)->mark1;
      }

    }

    return (void *)0;
  }
}

// soap_markelement
// file soapC.c line 324
void soap_markelement(struct soap *soap, const void *ptr, signed int type)
{
  (void)soap;
  (void)ptr;
  (void)type;
  switch(type)
  {
    case 8:
    {
      soap_serialize_t__RoutingTable(soap, (struct t__RoutingTable *)ptr);
      break;
    }
    case 7:
    {
      soap_serialize_t__Routing(soap, (struct t__Routing *)ptr);
      break;
    }
    case 9:
    {
      soap_serialize_PointerTot__Routing(soap, (struct t__Routing * const *)ptr);
      break;
    }
    case 5:
    {
      soap_serialize_string(soap, (char * const *)(void *)&ptr);
      break;
    }
    case 4:
      soap_serialize_string(soap, (char * const *)(void *)&ptr);
  }
}

// soap_match_array
// file stdsoap2.c line 3152
signed int soap_match_array(struct soap *soap, const char *type)
{
  signed int return_value_soap_match_tag_3;
  signed int return_value_soap_match_tag_2;
  signed int return_value_soap_match_tag_1;
  if(!(soap->arrayType[0l] == 0))
  {
    return_value_soap_match_tag_3=soap_match_tag(soap, soap->arrayType, type);
    if(!(return_value_soap_match_tag_3 == 0))
    {
      return_value_soap_match_tag_2=soap_match_tag(soap, soap->arrayType, "xsd:anyType");
      if(!(return_value_soap_match_tag_2 == 0))
      {
        return_value_soap_match_tag_1=soap_match_tag(soap, soap->arrayType, "xsd:ur-type");
        if(!(return_value_soap_match_tag_1 == 0))
          return 3;

      }

    }

  }

  return 0;
}

// soap_match_cid
// file stdsoap2.c line 16035
signed int soap_match_cid(struct soap *soap, const char *s, const char *t)
{
  unsigned long int n;
  if(s == ((const char *)NULL))
    return 1;

  else
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(s, t);
    if(return_value_strcmp_1 == 0)
      return 0;

    else
    {
      signed int return_value_strncmp_2;
      return_value_strncmp_2=strncmp(s, "cid:", (unsigned long int)4);
      if(return_value_strncmp_2 == 0)
        s = s + (signed long int)4;

      n=strlen(t);
      if((signed int)*t == 60)
      {
        t = t + 1l;
        n = n - (unsigned long int)2;
      }

      signed int return_value_strncmp_3;
      return_value_strncmp_3=strncmp(s, t, n);
      if(return_value_strncmp_3 == 0)
      {
        if(!(s[(signed long int)n] == 0))
          goto __CPROVER_DUMP_L5;

        return 0;
      }

      else
      {

      __CPROVER_DUMP_L5:
        ;
        soap_decode(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , s, soap_padding);
        signed int return_value_strncmp_4;
        return_value_strncmp_4=strncmp(soap->tmpbuf, t, n);
        if(return_value_strncmp_4 == 0)
        {
          if(!(soap->tmpbuf[(signed long int)n] == 0))
            goto __CPROVER_DUMP_L6;

          return 0;
        }

        else
        {

        __CPROVER_DUMP_L6:
          ;
          return 1;
        }
      }
    }
  }
}

// soap_match_namespace
// file stdsoap2.c line 2992
signed int soap_match_namespace(struct soap *soap, const char *id1, const char *id2, unsigned long int n1, unsigned long int n2)
{
  struct soap_nlist *np = soap->nlist;
  const char *s;
  signed int return_value_strncmp_1;
  for( ; !(np == ((struct soap_nlist *)NULL)); np = np->next)
  {
    return_value_strncmp_1=strncmp(np->id, id1, n1);
    if(return_value_strncmp_1 == 0)
    {
      if(np->id[(signed long int)n1] == 0)
        break;

    }

  }
  _Bool tmp_if_expr_5;
  signed int return_value_strncmp_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  signed int return_value_strncmp_10;
  signed int return_value_strncmp_12;
  if(!(np == ((struct soap_nlist *)NULL)))
  {
    if((0x00004000 & soap->mode) == 0)
    {
      _Bool tmp_if_expr_7;
      if(n2 >= 1ul)
        tmp_if_expr_7 = (_Bool)1;

      else
        tmp_if_expr_7 = !(np->ns != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr_8;
      if(tmp_if_expr_7)
        tmp_if_expr_8 = (_Bool)1;

      else
        tmp_if_expr_8 = *np->ns != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_8)
      {
        _Bool tmp_if_expr_6;
        if(!((signed int)np->index >= 0))
          tmp_if_expr_6 = (_Bool)1;

        else
        {
          s = (soap->local_namespaces + (signed long int)np->index)->id;
          if(!(s == ((const char *)NULL)))
          {
            return_value_strncmp_2=strncmp(s, id2, n2);
            if(!(return_value_strncmp_2 == 0))
              tmp_if_expr_4 = (_Bool)1;

            else
            {
              if(!(s[(signed long int)n2] == 0))
                tmp_if_expr_3 = (signed int)s[(signed long int)n2] != 95 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_3 = (_Bool)0;
              tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_5 = (_Bool)0;
          tmp_if_expr_6 = tmp_if_expr_5 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_6)
          return 9;

      }

    }

    return 0;
  }

  else
  {
    if(n1 == 0ul)
    {
      _Bool tmp_if_expr_9;
      if(n2 == 0ul)
        tmp_if_expr_9 = (_Bool)1;

      else
        tmp_if_expr_9 = (soap->mode & 0x00004000) != 0 ? (_Bool)1 : (_Bool)0;
      return tmp_if_expr_9 ? 0 : 9;
    }

    _Bool tmp_if_expr_11;
    if(n1 == 3ul && n1 == n2)
    {
      return_value_strncmp_10=strncmp(id1, "xml", (unsigned long int)3);
      tmp_if_expr_11 = !(return_value_strncmp_10 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_11 = (_Bool)0;
    _Bool tmp_if_expr_13;
    if(tmp_if_expr_11)
    {
      return_value_strncmp_12=strncmp(id1, id2, (unsigned long int)3);
      tmp_if_expr_13 = !(return_value_strncmp_12 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_13 = (_Bool)0;
    _Bool tmp_if_expr_14;
    if(tmp_if_expr_13)
      tmp_if_expr_14 = (_Bool)1;

    else
      tmp_if_expr_14 = (soap->mode & 0x00004000) != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_14)
      return 0;

    else
    {
      soap->error = 5;
      return soap->error;
    }
  }
}

// soap_match_tag
// file ../../../gsoap/stdsoap2.h line 3066
signed int soap_match_tag(struct soap *soap, const char *tag1, const char *tag2)
{
  const char *s;
  const char *t;
  signed int err;
  _Bool tmp_if_expr_1;
  if(tag1 == ((const char *)NULL) || tag2 == ((const char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*tag2 != 0) ? (_Bool)1 : (_Bool)0;
  signed int return_value_strcmp_2;
  signed int return_value_soap_match_namespace_3;
  signed int return_value_strcmp_5;
  signed int return_value_strcmp_6;
  signed int return_value_strcmp_8;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_11;
  signed int return_value_soap_match_namespace_10;
  if(tmp_if_expr_1)
    return 0;

  else
  {
    s=strchr(tag1, 58);
    t=strchr(tag2, 58);
    if(!(t == ((const char *)NULL)))
    {
      if(!(s == ((const char *)NULL)))
      {
        if(!(t[1l] == 0))
        {
          return_value_strcmp_2=strcmp(s + (signed long int)1, t + (signed long int)1);
          if(!(return_value_strcmp_2 == 0))
            return 3;

        }

        if(!(t == tag2))
        {
          err=soap_match_namespace(soap, tag1, tag2, (unsigned long int)(s - tag1), (unsigned long int)(t - tag2));
          if(!(err == 0))
          {
            if(err == 9)
              return 3;

            return err;
          }

        }

      }

      else
        if(t[1l] == 0)
        {
          _Bool tmp_if_expr_4;
          if(!((0x00004000 & soap->mode) == 0))
            tmp_if_expr_4 = (_Bool)1;

          else
          {
            return_value_soap_match_namespace_3=soap_match_namespace(soap, tag1, tag2, (unsigned long int)0, (unsigned long int)(t - tag2));
            tmp_if_expr_4 = return_value_soap_match_namespace_3 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_4)
            return 3;

        }

        else
        {
          return_value_strcmp_5=strcmp(tag1, t + (signed long int)1);
          if(!(return_value_strcmp_5 == 0))
            return 3;

          else
            if(!(t == tag2))
            {
              err=soap_match_namespace(soap, tag1, tag2, (unsigned long int)0, (unsigned long int)(t - tag2));
              if(!(err == 0))
              {
                if(err == 9)
                  return 3;

                return err;
              }

            }

        }
      return 0;
    }

    if(!(s == ((const char *)NULL)))
    {
      _Bool tmp_if_expr_7;
      if((0x00004000 & soap->mode) == 0)
        tmp_if_expr_7 = (_Bool)1;

      else
      {
        return_value_strcmp_6=strcmp(s + (signed long int)1, tag2);
        tmp_if_expr_7 = return_value_strcmp_6 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_7)
        return 3;

    }

    else
    {
      return_value_strcmp_8=strcmp(tag1, tag2);
      _Bool tmp_if_expr_12;
      if(!(return_value_strcmp_8 == 0))
        tmp_if_expr_12 = (_Bool)1;

      else
      {
        if(!((0x00001000 & soap->mode) == 0))
          tmp_if_expr_9 = !((soap->mode & 0x00004000) != 0) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_9 = (_Bool)0;
        if(tmp_if_expr_9)
        {
          return_value_soap_match_namespace_10=soap_match_namespace(soap, tag1, tag2, (unsigned long int)0, (unsigned long int)0);
          tmp_if_expr_11 = return_value_soap_match_namespace_10 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_11 = (_Bool)0;
        tmp_if_expr_12 = tmp_if_expr_11 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_12)
        return 3;

    }
    return 0;
  }
}

// soap_memdup
// file stdsoap2.c line 2243
void * soap_memdup(struct soap *soap, const void *s, unsigned long int n)
{
  void *t = (void *)0;
  void *return_value_memcpy_1;
  if(!(s == NULL))
  {
    t=soap_malloc(soap, n);
    if(!(t == NULL))
    {
      if(!(t == NULL))
      {
        return_value_memcpy_1=memcpy(t, s, n);
        (signed int)!(return_value_memcpy_1 != NULL);
      }

      else
        34;
    }

  }

  return t;
}

// soap_move
// file stdsoap2.c line 1752
signed int soap_move(struct soap *soap, unsigned long int n)
{
  signed int return_value_soap_getchar_1;
  for( ; !(n == 0ul); n = n - 1ul)
  {
    return_value_soap_getchar_1=soap_getchar(soap);
    if(return_value_soap_getchar_1 == -1)
      return -1;

  }
  return 0;
}

// soap_name_match
// file dom.c line 1030
static signed int soap_name_match(const char *name, const char *patt)
{
  signed int return_value_soap_name_match_1;
  do
  {
    signed int c1 = (signed int)*name;
    signed int c2 = (signed int)*patt;
    if(c1 == 0)
      break;

    if(!(c1 == c2))
    {
      if(!(c2 == 42))
        return 0;

      patt = patt + 1l;
      c2 = (signed int)*patt;
      if(c2 == 0)
        return 1;

      do
      {
        c1 = (signed int)*name;
        if(c1 == 0)
          break;

        if(c1 == c2)
        {
          return_value_soap_name_match_1=soap_name_match(name + (signed long int)1, patt + (signed long int)1);
          if(!(return_value_soap_name_match_1 == 0))
            return 1;

        }

        name = name + 1l;
      }
      while((_Bool)1);
      break;
    }

    name = name + 1l;
    patt = patt + 1l;
  }
  while((_Bool)1);
  if((signed int)*patt == 42)
  {
    if(!(patt[1l] == 0))
      goto __CPROVER_DUMP_L10;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L10:
    ;
    return (signed int)!(*patt != 0);
  }
}

// soap_new_REQUIRE_lib_v20828
// file stdsoap2.c line 7443
struct soap * soap_new_REQUIRE_lib_v20828(signed int imode, signed int omode)
{
  struct soap *soap;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct soap) /*162088ul*/ );
  soap = (struct soap *)return_value_malloc_1;
  if(!(soap == ((struct soap *)NULL)))
    soap_init_REQUIRE_lib_v20828(soap, imode, omode);

  return soap;
}

// soap_new_block
// file ../../../gsoap/stdsoap2.h line 3124
struct soap_blist * soap_new_block(struct soap *soap)
{
  struct soap_blist *p;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct soap_blist) /*24ul*/ );
  p = (struct soap_blist *)return_value_malloc_1;
  if(p == ((struct soap_blist *)NULL))
  {
    soap->error = 20;
    return (struct soap_blist *)(void *)0;
  }

  else
  {
    p->next = soap->blist;
    p->head = (struct soap_bhead *)(void *)0;
    p->size = (unsigned long int)0;
    soap->blist = p;
    return p;
  }
}

// soap_new_multipart
// file stdsoap2.c line 16253
static struct soap_multipart * soap_new_multipart(struct soap *soap, struct soap_multipart **first, struct soap_multipart **last, char *ptr, unsigned long int size)
{
  struct soap_multipart *content;
  void *return_value_soap_malloc_1;
  return_value_soap_malloc_1=soap_malloc(soap, sizeof(struct soap_multipart) /*72ul*/ );
  content = (struct soap_multipart *)return_value_soap_malloc_1;
  if(!(content == ((struct soap_multipart *)NULL)))
  {
    content->next = (struct soap_multipart *)(void *)0;
    content->ptr = ptr;
    content->size = size;
    content->id = (const char *)(void *)0;
    content->type = (const char *)(void *)0;
    content->options = (const char *)(void *)0;
    content->encoding = (enum soap_mime_encoding)SOAP_MIME_NONE;
    content->location = (const char *)(void *)0;
    content->description = (const char *)(void *)0;
    if(*first == ((struct soap_multipart *)NULL))
      *first = content;

    if(!(*last == ((struct soap_multipart *)NULL)))
      (*last)->next = content;

    *last = content;
  }

  return content;
}

// soap_next_block
// file ../../../gsoap/stdsoap2.h line 3129
char * soap_next_block(struct soap *soap, struct soap_blist *b)
{
  struct soap_bhead *p;
  if(b == ((struct soap_blist *)NULL))
    b = soap->blist;

  p = b->head;
  if(!(p == ((struct soap_bhead *)NULL)))
  {
    b->head = p->next;
    free((void *)p);
    if(b->head == ((struct soap_bhead *)NULL))
      goto __CPROVER_DUMP_L2;

    return (char *)(b->head + (signed long int)1);
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    return (char *)(void *)0;
  }
}

// soap_next_multipart
// file stdsoap2.c line 16325
struct soap_multipart * soap_next_multipart(struct soap_multipart *content)
{
  if(!(content == ((struct soap_multipart *)NULL)))
    return content->next;

  else
    return (struct soap_multipart *)(void *)0;
}

// soap_ns_to_find
// file dom.c line 973
static const char * soap_ns_to_find(struct soap *soap, const char *tag)
{
  const char *s;
  unsigned long int n;
  struct Namespace *p;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  if(tag == ((const char *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    if((signed int)*tag == 42)
      tmp_if_expr_1 = !(tag[(signed long int)1] != 0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_3;
  signed int return_value_strncmp_5;
  if(tmp_if_expr_2)
    return (const char *)(void *)0;

  else
  {
    s=strchr(tag, 58);
    if(s == ((const char *)NULL))
      return "";

    else
      if((signed int)*tag == 42)
        return (const char *)(void *)0;

      else
      {
        n = (unsigned long int)(s - tag);
        p = soap->namespaces;
        do
        {
          if(!(p == ((struct Namespace *)NULL)))
            tmp_if_expr_3 = p->id != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_3 = (_Bool)0;
          if(!tmp_if_expr_3)
            break;

          return_value_strncmp_5=strncmp(p->id, tag, n);
          if(return_value_strncmp_5 == 0)
          {
            if(p->id[(signed long int)n] == 0)
            {
              char *tmp_if_expr_4;
              if(!(p->out == ((char *)NULL)))
                tmp_if_expr_4 = p->out;

              else
                tmp_if_expr_4 = p->ns;
              return tmp_if_expr_4;
            }

          }

          p = p + 1l;
        }
        while((_Bool)1);
        return (const char *)(void *)0;
      }
  }
}

// soap_ns_to_get
// file dom.c line 953
static const char * soap_ns_to_get(struct soap *soap, const char *tag)
{
  const char *s;
  unsigned long int n;
  struct Namespace *p;
  _Bool tmp_if_expr_1;
  signed int return_value_strncmp_3;
  if(tag == ((const char *)NULL))
    return "";

  else
  {
    s=strchr(tag, 58);
    if(s == ((const char *)NULL))
      return "";

    else
    {
      n = (unsigned long int)(s - tag);
      p = soap->namespaces;
      do
      {
        if(!(p == ((struct Namespace *)NULL)))
          tmp_if_expr_1 = p->id != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        if(!tmp_if_expr_1)
          break;

        return_value_strncmp_3=strncmp(p->id, tag, n);
        if(return_value_strncmp_3 == 0)
        {
          if(p->id[(signed long int)n] == 0)
          {
            char *tmp_if_expr_2;
            if(!(p->out == ((char *)NULL)))
              tmp_if_expr_2 = p->out;

            else
              tmp_if_expr_2 = p->ns;
            return tmp_if_expr_2;
          }

        }

        p = p + 1l;
      }
      while((_Bool)1);
      return "";
    }
  }
}

// soap_ns_to_set
// file dom.c line 933
static const char * soap_ns_to_set(struct soap *soap, const char *tag)
{
  const char *s;
  unsigned long int n;
  struct Namespace *p;
  _Bool tmp_if_expr_1;
  signed int return_value_strncmp_2;
  if(tag == ((const char *)NULL))
    return (const char *)(void *)0;

  else
  {
    s=strchr(tag, 58);
    if(s == ((const char *)NULL))
      return (const char *)(void *)0;

    else
    {
      n = (unsigned long int)(s - tag);
      p = soap->namespaces;
      do
      {
        if(!(p == ((struct Namespace *)NULL)))
          tmp_if_expr_1 = p->id != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        if(!tmp_if_expr_1)
          break;

        return_value_strncmp_2=strncmp(p->id, tag, n);
        if(return_value_strncmp_2 == 0)
        {
          if(p->id[(signed long int)n] == 0)
            return p->ns;

        }

        p = p + 1l;
      }
      while((_Bool)1);
      return (const char *)(void *)0;
    }
  }
}

// soap_nth
// file dom.c line 1358
struct soap_dom_element * soap_nth(struct soap_dom_element *elt, unsigned long int n)
{
  struct soap_dom_element *node;
  struct soap_dom_element *prev = elt;
  _Bool tmp_if_expr_6;
  signed int return_value_soap_tag_match_5;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(elt == ((struct soap_dom_element *)NULL) || !(n >= 2ul))
    return elt;

  else
  {
    node = elt->next;
    for( ; !(node == ((struct soap_dom_element *)NULL)); node = node->next)
    {
      _Bool tmp_if_expr_7;
      if(elt->name == node->name)
        tmp_if_expr_7 = (_Bool)1;

      else
      {
        if(!(elt->name == ((const char *)NULL)))
        {
          return_value_soap_tag_match_5=soap_tag_match(node->name, elt->name);
          tmp_if_expr_6 = return_value_soap_tag_match_5 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_6 = (_Bool)0;
        tmp_if_expr_7 = tmp_if_expr_6 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_7)
      {
        _Bool tmp_if_expr_4;
        if(elt->nstr == node->nstr)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          if(!(elt->nstr == ((const char *)NULL)))
            tmp_if_expr_1 = node->nstr != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_1 = (_Bool)0;
          if(tmp_if_expr_1)
          {
            return_value_strcmp_2=strcmp(node->nstr, elt->nstr);
            tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_3 = (_Bool)0;
          tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_4)
        {
          n = n - 1ul;
          if(!(n >= 2ul))
            return node;

        }

      }

      prev = node;
    }
    do
    {
      n = n - 1ul;
      if(!(n >= 1ul))
        break;

      node=new_element(elt->soap);
      node->next = prev->next;
      node->prnt = elt->prnt;
      node->nstr = elt->nstr;
      node->name = elt->name;
      prev->next = node;
      prev = node;
    }
    while((_Bool)1);
    return prev;
  }
}

// soap_nth_elt
// file dom.c line 1324
struct soap_dom_element * soap_nth_elt(struct soap_dom_element *elt, const char *ns, const char *tag, unsigned long int n)
{
  struct soap_dom_element *return_value_soap_elt_1;
  return_value_soap_elt_1=soap_elt(elt, ns, tag);
  struct soap_dom_element *return_value_soap_nth_2;
  return_value_soap_nth_2=soap_nth(return_value_soap_elt_1, n);
  return return_value_soap_nth_2;
}

// soap_nth_elt_w
// file dom.c line 1342
struct soap_dom_element * soap_nth_elt_w(struct soap_dom_element *elt, const char *ns, const signed int *tag, unsigned long int n)
{
  struct soap_dom_element *return_value_soap_elt_w_1;
  return_value_soap_elt_w_1=soap_elt_w(elt, ns, tag);
  struct soap_dom_element *return_value_soap_nth_2;
  return_value_soap_nth_2=soap_nth(return_value_soap_elt_w_1, n);
  return return_value_soap_nth_2;
}

// soap_open_logfile
// file stdsoap2.c line 9258
void soap_open_logfile(struct soap *soap, signed int i)
{
  if(!(soap->logfile[(signed long int)i] == ((const char *)NULL)))
    soap->fdebug[(signed long int)i]=fopen(soap->logfile[(signed long int)i], i < 2 ? "ab" : "a");

}

// soap_outLONG64
// file stdsoap2.c line 13122
signed int soap_outLONG64(struct soap *soap, const char *tag, signed int id, const signed long int *p, const char *type, signed int n)
{
  signed int return_value_soap_embedded_id_1;
  return_value_soap_embedded_id_1=soap_embedded_id(soap, id, (const void *)p, n);
  signed int return_value_soap_element_begin_out_2;
  return_value_soap_element_begin_out_2=soap_element_begin_out(soap, tag, return_value_soap_embedded_id_1, type);
  _Bool tmp_if_expr_5;
  const char *return_value_soap_LONG642s_3;
  signed int return_value_soap_string_out_4;
  if(!(return_value_soap_element_begin_out_2 == 0))
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_soap_LONG642s_3=soap_LONG642s(soap, *p);
    return_value_soap_string_out_4=soap_string_out(soap, return_value_soap_LONG642s_3, 0);
    tmp_if_expr_5 = return_value_soap_string_out_4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
    return soap->error;

  else
  {
    signed int return_value_soap_element_end_out_6;
    return_value_soap_element_end_out_6=soap_element_end_out(soap, tag);
    return return_value_soap_element_end_out_6;
  }
}

// soap_outULONG64
// file stdsoap2.c line 13998
signed int soap_outULONG64(struct soap *soap, const char *tag, signed int id, const unsigned long int *p, const char *type, signed int n)
{
  signed int return_value_soap_embedded_id_1;
  return_value_soap_embedded_id_1=soap_embedded_id(soap, id, (const void *)p, n);
  signed int return_value_soap_element_begin_out_2;
  return_value_soap_element_begin_out_2=soap_element_begin_out(soap, tag, return_value_soap_embedded_id_1, type);
  _Bool tmp_if_expr_5;
  const char *return_value_soap_ULONG642s_3;
  signed int return_value_soap_string_out_4;
  if(!(return_value_soap_element_begin_out_2 == 0))
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_soap_ULONG642s_3=soap_ULONG642s(soap, *p);
    return_value_soap_string_out_4=soap_string_out(soap, return_value_soap_ULONG642s_3, 0);
    tmp_if_expr_5 = return_value_soap_string_out_4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
    return soap->error;

  else
  {
    signed int return_value_soap_element_end_out_6;
    return_value_soap_element_end_out_6=soap_element_end_out(soap, tag);
    return return_value_soap_element_end_out_6;
  }
}

// soap_out_PointerToSOAP_ENV__Code
// file soapC.c line 1248
signed int soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, signed int id, struct SOAP_ENV__Code * const *a, const char *type)
{
  char *mark;
  id=soap_element_id(soap, tag, id, (const void *)*a, (void *)0, 0, type, 11, &mark);
  if(!(id >= 0))
    return soap->error;

  else
  {
    soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
    soap_unmark(soap, mark);
    return soap->error;
  }
}

// soap_out_PointerToSOAP_ENV__Detail
// file soapC.c line 1190
signed int soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, signed int id, struct SOAP_ENV__Detail * const *a, const char *type)
{
  id=soap_element_id(soap, tag, id, (const void *)*a, (void *)0, 0, type, 13, (char **)(void *)0);
  if(!(id >= 0))
    return soap->error;

  else
  {
    signed int return_value_soap_out_SOAP_ENV__Detail_1;
    return_value_soap_out_SOAP_ENV__Detail_1=soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
    return return_value_soap_out_SOAP_ENV__Detail_1;
  }
}

// soap_out_PointerToSOAP_ENV__Reason
// file soapC.c line 1132
signed int soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, signed int id, struct SOAP_ENV__Reason * const *a, const char *type)
{
  id=soap_element_id(soap, tag, id, (const void *)*a, (void *)0, 0, type, 16, (char **)(void *)0);
  if(!(id >= 0))
    return soap->error;

  else
  {
    signed int return_value_soap_out_SOAP_ENV__Reason_1;
    return_value_soap_out_SOAP_ENV__Reason_1=soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
    return return_value_soap_out_SOAP_ENV__Reason_1;
  }
}

// soap_out_PointerTot__Routing
// file soapC.c line 1307
signed int soap_out_PointerTot__Routing(struct soap *soap, const char *tag, signed int id, struct t__Routing * const *a, const char *type)
{
  id=soap_element_id(soap, tag, id, (const void *)*a, (void *)0, 0, type, 7, (char **)(void *)0);
  if(!(id >= 0))
    return soap->error;

  else
  {
    signed int return_value_soap_out_t__Routing_1;
    return_value_soap_out_t__Routing_1=soap_out_t__Routing(soap, tag, id, *a, type);
    return return_value_soap_out_t__Routing_1;
  }
}

// soap_out_SOAP_ENV__Code
// file soapC.c line 767
signed int soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, signed int id, struct SOAP_ENV__Code *a, const char *type)
{
  const char *soap_tmp_SOAP_ENV__Value;
  soap_tmp_SOAP_ENV__Value=soap_QName2s(soap, a->SOAP_ENV__Value);
  (void)soap;
  (void)tag;
  (void)id;
  (void)a;
  (void)type;
  signed int return_value_soap_embedded_id_1;
  return_value_soap_embedded_id_1=soap_embedded_id(soap, id, (const void *)a, 11);
  signed int return_value_soap_element_begin_out_2;
  return_value_soap_element_begin_out_2=soap_element_begin_out(soap, tag, return_value_soap_embedded_id_1, type);
  if(!(return_value_soap_element_begin_out_2 == 0))
    return soap->error;

  else
  {
    signed int return_value_soap_out__QName_3;
    return_value_soap_out__QName_3=soap_out__QName(soap, "SOAP-ENV:Value", -1, (char * const *)(void *)&soap_tmp_SOAP_ENV__Value, "");
    if(!(return_value_soap_out__QName_3 == 0))
      return soap->error;

    else
    {
      signed int return_value_soap_out_PointerToSOAP_ENV__Code_4;
      return_value_soap_out_PointerToSOAP_ENV__Code_4=soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, "");
      if(!(return_value_soap_out_PointerToSOAP_ENV__Code_4 == 0))
        return soap->error;

      else
      {
        signed int return_value_soap_element_end_out_5;
        return_value_soap_element_end_out_5=soap_element_end_out(soap, tag);
        return return_value_soap_element_end_out_5;
      }
    }
  }
}

// soap_out_SOAP_ENV__Detail
// file soapC.c line 679
signed int soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, signed int id, struct SOAP_ENV__Detail *a, const char *type)
{
  (void)soap;
  (void)tag;
  (void)id;
  (void)a;
  (void)type;
  signed int return_value_soap_embedded_id_1;
  return_value_soap_embedded_id_1=soap_embedded_id(soap, id, (const void *)a, 13);
  signed int return_value_soap_element_begin_out_2;
  return_value_soap_element_begin_out_2=soap_element_begin_out(soap, tag, return_value_soap_embedded_id_1, type);
  if(!(return_value_soap_element_begin_out_2 == 0))
    return soap->error;

  else
  {
    soap_outliteral(soap, "-any", (char * const *)&a->__any, (const char *)(void *)0);
    signed int return_value_soap_putelement_3;
    return_value_soap_putelement_3=soap_putelement(soap, a->fault, "fault", -1, a->__type);
    if(!(return_value_soap_putelement_3 == 0))
      return soap->error;

    else
    {
      signed int return_value_soap_element_end_out_4;
      return_value_soap_element_end_out_4=soap_element_end_out(soap, tag);
      return return_value_soap_element_end_out_4;
    }
  }
}

// soap_out_SOAP_ENV__Fault
// file soapC.c line 452
signed int soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, signed int id, struct SOAP_ENV__Fault *a, const char *type)
{
  const char *soap_tmp_faultcode;
  soap_tmp_faultcode=soap_QName2s(soap, a->faultcode);
  (void)soap;
  (void)tag;
  (void)id;
  (void)a;
  (void)type;
  signed int return_value_soap_embedded_id_1;
  return_value_soap_embedded_id_1=soap_embedded_id(soap, id, (const void *)a, 17);
  signed int return_value_soap_element_begin_out_2;
  return_value_soap_element_begin_out_2=soap_element_begin_out(soap, tag, return_value_soap_embedded_id_1, type);
  if(!(return_value_soap_element_begin_out_2 == 0))
    return soap->error;

  else
  {
    signed int return_value_soap_out__QName_3;
    return_value_soap_out__QName_3=soap_out__QName(soap, "faultcode", -1, (char * const *)(void *)&soap_tmp_faultcode, "");
    if(!(return_value_soap_out__QName_3 == 0))
      return soap->error;

    else
    {
      signed int return_value_soap_out_string_4;
      return_value_soap_out_string_4=soap_out_string(soap, "faultstring", -1, (char * const *)&a->faultstring, "");
      if(!(return_value_soap_out_string_4 == 0))
        return soap->error;

      else
      {
        signed int return_value_soap_out_string_5;
        return_value_soap_out_string_5=soap_out_string(soap, "faultactor", -1, (char * const *)&a->faultactor, "");
        if(!(return_value_soap_out_string_5 == 0))
          return soap->error;

        else
        {
          signed int return_value_soap_out_PointerToSOAP_ENV__Detail_6;
          return_value_soap_out_PointerToSOAP_ENV__Detail_6=soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, "");
          if(!(return_value_soap_out_PointerToSOAP_ENV__Detail_6 == 0))
            return soap->error;

          else
          {
            signed int return_value_soap_out_PointerToSOAP_ENV__Code_7;
            return_value_soap_out_PointerToSOAP_ENV__Code_7=soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
            if(!(return_value_soap_out_PointerToSOAP_ENV__Code_7 == 0))
              return soap->error;

            else
            {
              signed int return_value_soap_out_PointerToSOAP_ENV__Reason_8;
              return_value_soap_out_PointerToSOAP_ENV__Reason_8=soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
              if(!(return_value_soap_out_PointerToSOAP_ENV__Reason_8 == 0))
                return soap->error;

              else
              {
                signed int return_value_soap_out_string_9;
                return_value_soap_out_string_9=soap_out_string(soap, "SOAP-ENV:Node", -1, (char * const *)&a->SOAP_ENV__Node, "");
                if(!(return_value_soap_out_string_9 == 0))
                  return soap->error;

                else
                {
                  signed int return_value_soap_out_string_10;
                  return_value_soap_out_string_10=soap_out_string(soap, "SOAP-ENV:Role", -1, (char * const *)&a->SOAP_ENV__Role, "");
                  if(!(return_value_soap_out_string_10 == 0))
                    return soap->error;

                  else
                  {
                    signed int return_value_soap_out_PointerToSOAP_ENV__Detail_11;
                    return_value_soap_out_PointerToSOAP_ENV__Detail_11=soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
                    if(!(return_value_soap_out_PointerToSOAP_ENV__Detail_11 == 0))
                      return soap->error;

                    else
                    {
                      signed int return_value_soap_element_end_out_12;
                      return_value_soap_element_end_out_12=soap_element_end_out(soap, tag);
                      return return_value_soap_element_end_out_12;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// soap_out_SOAP_ENV__Header
// file soapC.c line 853
signed int soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, signed int id, struct SOAP_ENV__Header *a, const char *type)
{
  (void)soap;
  (void)tag;
  (void)id;
  (void)a;
  (void)type;
  signed int return_value_soap_embedded_id_1;
  return_value_soap_embedded_id_1=soap_embedded_id(soap, id, (const void *)a, 10);
  signed int return_value_soap_element_begin_out_2;
  return_value_soap_element_begin_out_2=soap_element_begin_out(soap, tag, return_value_soap_embedded_id_1, type);
  if(!(return_value_soap_element_begin_out_2 == 0))
    return soap->error;

  else
  {
    signed int return_value_soap_element_end_out_3;
    return_value_soap_element_end_out_3=soap_element_end_out(soap, tag);
    return return_value_soap_element_end_out_3;
  }
}

// soap_out_SOAP_ENV__Reason
// file soapC.c line 596
signed int soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, signed int id, struct SOAP_ENV__Reason *a, const char *type)
{
  (void)soap;
  (void)tag;
  (void)id;
  (void)a;
  (void)type;
  signed int return_value_soap_embedded_id_1;
  return_value_soap_embedded_id_1=soap_embedded_id(soap, id, (const void *)a, 16);
  signed int return_value_soap_element_begin_out_2;
  return_value_soap_element_begin_out_2=soap_element_begin_out(soap, tag, return_value_soap_embedded_id_1, type);
  if(!(return_value_soap_element_begin_out_2 == 0))
    return soap->error;

  else
  {
    if(!(soap->lang == ((const char *)NULL)))
      soap_set_attr(soap, "xml:lang", soap->lang, 1);

    signed int return_value_soap_out_string_3;
    return_value_soap_out_string_3=soap_out_string(soap, "SOAP-ENV:Text", -1, (char * const *)&a->SOAP_ENV__Text, "");
    if(!(return_value_soap_out_string_3 == 0))
      return soap->error;

    else
    {
      signed int return_value_soap_element_end_out_4;
      return_value_soap_element_end_out_4=soap_element_end_out(soap, tag);
      return return_value_soap_element_end_out_4;
    }
  }
}

// soap_out__QName
// file soapC.c line 1360
signed int soap_out__QName(struct soap *soap, const char *tag, signed int id, char * const *a, const char *type)
{
  signed int return_value_soap_outstring_1;
  return_value_soap_outstring_1=soap_outstring(soap, tag, id, a, type, 5);
  return return_value_soap_outstring_1;
}

// soap_out_byte
// file soapC.c line 358
signed int soap_out_byte(struct soap *soap, const char *tag, signed int id, const char *a, const char *type)
{
  signed int return_value_soap_outbyte_1;
  return_value_soap_outbyte_1=soap_outbyte(soap, tag, id, a, type, 3);
  return return_value_soap_outbyte_1;
}

// soap_out_int
// file soapC.c line 394
signed int soap_out_int(struct soap *soap, const char *tag, signed int id, const signed int *a, const char *type)
{
  signed int return_value_soap_outint_1;
  return_value_soap_outint_1=soap_outint(soap, tag, id, a, type, 1);
  return return_value_soap_outint_1;
}

// soap_out_string
// file soapC.c line 1404
signed int soap_out_string(struct soap *soap, const char *tag, signed int id, char * const *a, const char *type)
{
  signed int return_value_soap_outstring_1;
  return_value_soap_outstring_1=soap_outstring(soap, tag, id, a, type, 4);
  return return_value_soap_outstring_1;
}

// soap_out_t__Routing
// file soapC.c line 1036
signed int soap_out_t__Routing(struct soap *soap, const char *tag, signed int id, struct t__Routing *a, const char *type)
{
  (void)soap;
  (void)tag;
  (void)id;
  (void)a;
  (void)type;
  signed int return_value_soap_embedded_id_1;
  return_value_soap_embedded_id_1=soap_embedded_id(soap, id, (const void *)a, 7);
  signed int return_value_soap_element_begin_out_2;
  return_value_soap_element_begin_out_2=soap_element_begin_out(soap, tag, return_value_soap_embedded_id_1, type);
  if(!(return_value_soap_element_begin_out_2 == 0))
    return soap->error;

  else
  {
    signed int return_value_soap_out_string_3;
    return_value_soap_out_string_3=soap_out_string(soap, "key", -1, (char * const *)&a->key, "");
    if(!(return_value_soap_out_string_3 == 0))
      return soap->error;

    else
    {
      signed int return_value_soap_out_string_4;
      return_value_soap_out_string_4=soap_out_string(soap, "endpoint", -1, (char * const *)&a->endpoint, "");
      if(!(return_value_soap_out_string_4 == 0))
        return soap->error;

      else
      {
        signed int return_value_soap_out_string_5;
        return_value_soap_out_string_5=soap_out_string(soap, "userid", -1, (char * const *)&a->userid, "");
        if(!(return_value_soap_out_string_5 == 0))
          return soap->error;

        else
        {
          signed int return_value_soap_out_string_6;
          return_value_soap_out_string_6=soap_out_string(soap, "passwd", -1, (char * const *)&a->passwd, "");
          if(!(return_value_soap_out_string_6 == 0))
            return soap->error;

          else
          {
            signed int return_value_soap_element_end_out_7;
            return_value_soap_element_end_out_7=soap_element_end_out(soap, tag);
            return return_value_soap_element_end_out_7;
          }
        }
      }
    }
  }
}

// soap_out_t__RoutingTable
// file soapC.c line 930
signed int soap_out_t__RoutingTable(struct soap *soap, const char *tag, signed int id, struct t__RoutingTable *a, const char *type)
{
  (void)soap;
  (void)tag;
  (void)id;
  (void)a;
  (void)type;
  signed int return_value_soap_embedded_id_1;
  return_value_soap_embedded_id_1=soap_embedded_id(soap, id, (const void *)a, 8);
  signed int return_value_soap_element_begin_out_2;
  return_value_soap_element_begin_out_2=soap_element_begin_out(soap, tag, return_value_soap_embedded_id_1, type);
  signed int return_value_soap_out_t__Routing_3;
  if(!(return_value_soap_element_begin_out_2 == 0))
    return soap->error;

  else
  {
    if(!(a->__ptr == ((struct t__Routing *)NULL)))
    {
      signed int i = 0;
      for( ; !(i >= a->__size); i = i + 1)
      {
        return_value_soap_out_t__Routing_3=soap_out_t__Routing(soap, "item", -1, a->__ptr + (signed long int)i, "");
        if(!(return_value_soap_out_t__Routing_3 == 0))
          return soap->error;

      }
    }

    signed int return_value_soap_element_end_out_4;
    return_value_soap_element_end_out_4=soap_element_end_out(soap, tag);
    return return_value_soap_element_end_out_4;
  }
}

// soap_out_xsd__anyAttribute
// file dom.c line 456
signed int soap_out_xsd__anyAttribute(struct soap *soap, const char *tag, signed int id, struct soap_dom_attribute *node, const char *type)
{
  struct soap_dom_attribute *att;
  (void)tag;
  (void)id;
  (void)type;
  signed int return_value_strncmp_5;
  signed int return_value_strcmp_3;
  if((0x00400000 & soap->mode) == 0)
  {
    if((0x00010000 & soap->mode) == 0)
    {
      att = node;
      for( ; !(att == ((struct soap_dom_attribute *)NULL)); att = att->next)
      {
        _Bool tmp_if_expr_4;
        if(!(att->name == ((const char *)NULL)))
          tmp_if_expr_4 = att->text != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        _Bool tmp_if_expr_6;
        if(tmp_if_expr_4)
        {
          return_value_strncmp_5=strncmp(att->name, "xmlns:", (unsigned long int)6);
          tmp_if_expr_6 = !(return_value_strncmp_5 != 0) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_6 = (_Bool)0;
        if(tmp_if_expr_6)
        {
          struct soap_nlist *return_value_soap_push_namespace_1;
          return_value_soap_push_namespace_1=soap_push_namespace(soap, att->name + (signed long int)6, att->text);
          if(return_value_soap_push_namespace_1 == ((struct soap_nlist *)NULL))
            return soap->error;

        }

        else
          if(!(att->name == ((const char *)NULL)))
          {
            if(!(att->text == ((const char *)NULL)))
            {
              return_value_strcmp_3=strcmp(att->name, "xmlns");
              if(return_value_strcmp_3 == 0)
              {
                struct soap_nlist *return_value_soap_push_namespace_2;
                return_value_soap_push_namespace_2=soap_push_namespace(soap, "", att->text);
                if(return_value_soap_push_namespace_2 == ((struct soap_nlist *)NULL))
                  return soap->error;

              }

            }

          }

      }
    }

  }

  att = node;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_9;
  signed int return_value_strcmp_8;
  signed int return_value_soap_attribute_14;
  for( ; !(att == ((struct soap_dom_attribute *)NULL)); att = att->next)
    if(!(att->name == ((const char *)NULL)))
    {
      if((0x00400000 & soap->mode) == 0)
      {
        const char *p = (const char *)(void *)0;
        signed int return_value_strncmp_12;
        return_value_strncmp_12=strncmp(att->name, "xml", (unsigned long int)3);
        if(!(return_value_strncmp_12 == 0))
        {
          if(!(att->nstr == ((const char *)NULL)))
            p=soap_prefix_of(soap, att->nstr);

          if(p == ((const char *)NULL))
          {
            struct soap_nlist *np;
            unsigned long int n = (unsigned long int)0;
            p=strchr(att->name, 58);
            if(!(p == ((const char *)NULL)))
              n = (unsigned long int)(p - att->name);

            p = (const char *)(void *)0;
            np=soap_lookup_ns(soap, att->name, n);
            _Bool tmp_if_expr_11;
            if(np == ((struct soap_nlist *)NULL) && !(n == 0ul))
              tmp_if_expr_11 = (_Bool)1;

            else
            {
              if(!(att->nstr == ((const char *)NULL)))
              {
                if(np == ((struct soap_nlist *)NULL))
                  tmp_if_expr_7 = (_Bool)1;

                else
                  tmp_if_expr_7 = !(np->ns != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_7)
                  tmp_if_expr_9 = (_Bool)1;

                else
                {
                  return_value_strcmp_8=strcmp(att->nstr, np->ns);
                  tmp_if_expr_9 = return_value_strcmp_8 != 0 ? (_Bool)1 : (_Bool)0;
                }
                tmp_if_expr_10 = tmp_if_expr_9 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_10 = (_Bool)0;
              tmp_if_expr_11 = tmp_if_expr_10 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_11)
            {
              p=soap_push_prefix(soap, att->name, n, att->nstr, 1, 0);
              if(p == ((const char *)NULL))
                return soap->error;

            }

          }

        }

        signed int return_value_out_attribute_13;
        return_value_out_attribute_13=out_attribute(soap, p, att->name, att->text, 1);
        if(!(return_value_out_attribute_13 == 0))
          return soap->error;

      }

      else
      {
        return_value_soap_attribute_14=soap_attribute(soap, att->name, att->text);
        if(!(return_value_soap_attribute_14 == 0))
          return soap->error;

      }
    }

  return 0;
}

// soap_out_xsd__anyType
// file dom.c line 304
signed int soap_out_xsd__anyType(struct soap *soap, const char *tag, signed int id, struct soap_dom_element *node, const char *type)
{
  (void)id;
  (void)type;
  signed int return_value_strncmp_5;
  signed int return_value_strcmp_3;
  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_10;
  signed int return_value_strcmp_9;
  _Bool tmp_if_expr_17;
  _Bool tmp_if_expr_14;
  _Bool tmp_if_expr_16;
  signed int return_value_strcmp_15;
  signed int return_value_soap_attribute_21;
  signed int return_value_soap_element_start_end_out_22;
  signed int return_value_soap_element_start_end_out_23;
  signed int return_value_soap_string_out_24;
  signed int return_value_soap_out_xsd__anyType_25;
  signed int return_value_soap_send_26;
  signed int return_value_soap_send_27;
  if(!(node == ((struct soap_dom_element *)NULL)))
  {
    const char *prefix;
    if((0x00400000 & soap->mode) == 0)
    {
      if((0x00010000 & soap->mode) == 0)
      {
        struct soap_dom_attribute *att = node->atts;
        for( ; !(att == ((struct soap_dom_attribute *)NULL)); att = att->next)
        {
          _Bool tmp_if_expr_4;
          if(!(att->name == ((const char *)NULL)))
            tmp_if_expr_4 = att->text != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4 = (_Bool)0;
          _Bool tmp_if_expr_6;
          if(tmp_if_expr_4)
          {
            return_value_strncmp_5=strncmp(att->name, "xmlns:", (unsigned long int)6);
            tmp_if_expr_6 = !(return_value_strncmp_5 != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_6 = (_Bool)0;
          if(tmp_if_expr_6)
          {
            struct soap_nlist *return_value_soap_push_namespace_1;
            return_value_soap_push_namespace_1=soap_push_namespace(soap, att->name + (signed long int)6, att->text);
            if(return_value_soap_push_namespace_1 == ((struct soap_nlist *)NULL))
              return soap->error;

          }

          else
            if(!(att->name == ((const char *)NULL)))
            {
              if(!(att->text == ((const char *)NULL)))
              {
                return_value_strcmp_3=strcmp(att->name, "xmlns");
                if(return_value_strcmp_3 == 0)
                {
                  struct soap_nlist *return_value_soap_push_namespace_2;
                  return_value_soap_push_namespace_2=soap_push_namespace(soap, "", att->text);
                  if(return_value_soap_push_namespace_2 == ((struct soap_nlist *)NULL))
                    return soap->error;

                }

              }

            }

        }
      }

    }

    if(!(node->name == ((const char *)NULL)))
      tag = node->name;

    else
      if(tag == ((const char *)NULL))
        tag = "-";

    prefix = (const char *)(void *)0;
    if((0x00400000 & soap->mode) == 0)
    {
      struct soap_nlist *soap_out_xsd__anyType__1__1__2__np;
      unsigned long int soap_out_xsd__anyType__1__1__2__n = (unsigned long int)0;
      prefix=strchr(tag, 58);
      if(!(prefix == ((const char *)NULL)))
      {
        soap_out_xsd__anyType__1__1__2__n = (unsigned long int)(prefix - tag);
        _Bool tmp_if_expr_7;
        if(!(soap_out_xsd__anyType__1__1__2__n == 0ul))
          tmp_if_expr_7 = node->nstr != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_7 = (_Bool)0;
        if(tmp_if_expr_7)
          prefix=soap_prefix_of(soap, node->nstr);

        else
          prefix = (const char *)(void *)0;
      }

      soap_out_xsd__anyType__1__1__2__np=soap_lookup_ns(soap, tag, soap_out_xsd__anyType__1__1__2__n);
      if(prefix == ((const char *)NULL))
      {
        _Bool tmp_if_expr_12;
        if(soap_out_xsd__anyType__1__1__2__np == ((struct soap_nlist *)NULL) && !(soap_out_xsd__anyType__1__1__2__n == 0ul))
          tmp_if_expr_12 = (_Bool)1;

        else
        {
          if(!(node->nstr == ((const char *)NULL)))
          {
            if(soap_out_xsd__anyType__1__1__2__np == ((struct soap_nlist *)NULL))
              tmp_if_expr_8 = (_Bool)1;

            else
              tmp_if_expr_8 = !(soap_out_xsd__anyType__1__1__2__np->ns != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_8)
              tmp_if_expr_10 = (_Bool)1;

            else
            {
              return_value_strcmp_9=strcmp(node->nstr, soap_out_xsd__anyType__1__1__2__np->ns);
              tmp_if_expr_10 = return_value_strcmp_9 != 0 ? (_Bool)1 : (_Bool)0;
            }
            tmp_if_expr_11 = tmp_if_expr_10 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_11 = (_Bool)0;
          tmp_if_expr_12 = tmp_if_expr_11 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_12)
        {
          prefix=soap_push_prefix(soap, tag, soap_out_xsd__anyType__1__1__2__n, node->nstr, 1, 1);
          if(prefix == ((const char *)NULL))
            return soap->error;

        }

      }

      if(!(prefix == ((const char *)NULL)) && !(soap_out_xsd__anyType__1__1__2__n == 0ul))
      {
        if(!(*prefix == 0))
          tag = tag + (signed long int)(soap_out_xsd__anyType__1__1__2__n + (unsigned long int)1);

      }

    }

    if(soap->ns == 0)
      soap->ns = (signed short int)2;

    signed int return_value_out_element_13;
    return_value_out_element_13=out_element(soap, node, prefix, tag);
    if(!(return_value_out_element_13 == 0))
      return soap->error;

    _Bool tmp_if_expr_38;
    if(node->type == 0)
      tmp_if_expr_38 = (_Bool)1;

    else
      tmp_if_expr_38 = !(node->node != NULL) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_38)
    {
      struct soap_dom_attribute *soap_out_xsd__anyType__1__1__3__att;
      struct soap_dom_element *elt;
      soap_out_xsd__anyType__1__1__3__att = node->atts;
      for( ; !(soap_out_xsd__anyType__1__1__3__att == ((struct soap_dom_attribute *)NULL)); soap_out_xsd__anyType__1__1__3__att = soap_out_xsd__anyType__1__1__3__att->next)
        if(!(soap_out_xsd__anyType__1__1__3__att->name == ((const char *)NULL)))
        {
          if((0x00400000 & soap->mode) == 0)
          {
            const char *p = (const char *)(void *)0;
            signed int return_value_strncmp_19;
            return_value_strncmp_19=strncmp(soap_out_xsd__anyType__1__1__3__att->name, "xml", (unsigned long int)3);
            if(!(return_value_strncmp_19 == 0))
            {
              if(!(soap_out_xsd__anyType__1__1__3__att->nstr == ((const char *)NULL)))
                p=soap_prefix_of(soap, soap_out_xsd__anyType__1__1__3__att->nstr);

              if(p == ((const char *)NULL))
              {
                struct soap_nlist *np;
                unsigned long int n = (unsigned long int)0;
                p=strchr(soap_out_xsd__anyType__1__1__3__att->name, 58);
                if(!(p == ((const char *)NULL)))
                  n = (unsigned long int)(p - soap_out_xsd__anyType__1__1__3__att->name);

                p = (const char *)(void *)0;
                np=soap_lookup_ns(soap, soap_out_xsd__anyType__1__1__3__att->name, n);
                _Bool tmp_if_expr_18;
                if(np == ((struct soap_nlist *)NULL) && !(n == 0ul))
                  tmp_if_expr_18 = (_Bool)1;

                else
                {
                  if(!(soap_out_xsd__anyType__1__1__3__att->nstr == ((const char *)NULL)))
                  {
                    if(np == ((struct soap_nlist *)NULL))
                      tmp_if_expr_14 = (_Bool)1;

                    else
                      tmp_if_expr_14 = !(np->ns != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
                    if(tmp_if_expr_14)
                      tmp_if_expr_16 = (_Bool)1;

                    else
                    {
                      return_value_strcmp_15=strcmp(soap_out_xsd__anyType__1__1__3__att->nstr, np->ns);
                      tmp_if_expr_16 = return_value_strcmp_15 != 0 ? (_Bool)1 : (_Bool)0;
                    }
                    tmp_if_expr_17 = tmp_if_expr_16 ? (_Bool)1 : (_Bool)0;
                  }

                  else
                    tmp_if_expr_17 = (_Bool)0;
                  tmp_if_expr_18 = tmp_if_expr_17 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_18)
                {
                  p=soap_push_prefix(soap, soap_out_xsd__anyType__1__1__3__att->name, n, soap_out_xsd__anyType__1__1__3__att->nstr, 0, 0);
                  if(p == ((const char *)NULL))
                    return soap->error;

                }

              }

            }

            signed int return_value_out_attribute_20;
            return_value_out_attribute_20=out_attribute(soap, p, soap_out_xsd__anyType__1__1__3__att->name, soap_out_xsd__anyType__1__1__3__att->text, 0);
            if(!(return_value_out_attribute_20 == 0))
              return soap->error;

          }

          else
          {
            return_value_soap_attribute_21=soap_attribute(soap, soap_out_xsd__anyType__1__1__3__att->name, soap_out_xsd__anyType__1__1__3__att->text);
            if(!(return_value_soap_attribute_21 == 0))
              return soap->error;

          }
        }

      _Bool tmp_if_expr_34;
      if(node->text == ((const char *)NULL))
        tmp_if_expr_34 = !(node->code != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_34 = (_Bool)0;
      _Bool tmp_if_expr_35;
      if(tmp_if_expr_34)
        tmp_if_expr_35 = !(node->tail != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_35 = (_Bool)0;
      _Bool tmp_if_expr_36;
      if(tmp_if_expr_35)
        tmp_if_expr_36 = !(node->elts != ((struct soap_dom_element *)NULL)) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_36 = (_Bool)0;
      _Bool tmp_if_expr_37;
      if(tmp_if_expr_36)
        tmp_if_expr_37 = !((soap->mode & 0x00010000) != 0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_37 = (_Bool)0;
      if(tmp_if_expr_37)
      {
        signed int m = soap->mode;
        soap->mode = soap->mode & ~0x00002000;
        if(!((signed int)*tag == 45))
        {
          return_value_soap_element_start_end_out_22=soap_element_start_end_out(soap, tag);
          if(!(return_value_soap_element_start_end_out_22 == 0))
            return soap->error;

        }

        soap->mode = m;
      }

      else
      {
        if(!((signed int)*tag == 45))
        {
          return_value_soap_element_start_end_out_23=soap_element_start_end_out(soap, (const char *)(void *)0);
          if(!(return_value_soap_element_start_end_out_23 == 0))
            return soap->error;

        }

        if(!(node->text == ((const char *)NULL)))
        {
          return_value_soap_string_out_24=soap_string_out(soap, node->text, 0);
          if(!(return_value_soap_string_out_24 == 0))
            return soap->error;

        }

        elt = node->elts;
        for( ; !(elt == ((struct soap_dom_element *)NULL)); elt = elt->next)
        {
          return_value_soap_out_xsd__anyType_25=soap_out_xsd__anyType(soap, (const char *)(void *)0, 0, elt, (const char *)(void *)0);
          if(!(return_value_soap_out_xsd__anyType_25 == 0))
            return soap->error;

        }
        if(!(node->code == ((const char *)NULL)))
        {
          return_value_soap_send_26=soap_send(soap, node->code);
          if(!(return_value_soap_send_26 == 0))
            return soap->error;

        }

        if(!(node->tail == ((const char *)NULL)))
        {
          return_value_soap_send_27=soap_send(soap, node->tail);
          if(!(return_value_soap_send_27 == 0))
            return soap->error;

        }

        _Bool tmp_if_expr_33;
        if(prefix == ((const char *)NULL))
          tmp_if_expr_33 = (_Bool)1;

        else
          tmp_if_expr_33 = !(*prefix != 0) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_33)
        {
          signed int soap_out_xsd__anyType__1__1__3__3__2__m = soap->mode;
          if(!((0x00400000 & soap->mode) == 0))
            soap->mode = soap->mode & ~0x00002000;

          signed int return_value_soap_element_end_out_28;
          return_value_soap_element_end_out_28=soap_element_end_out(soap, tag);
          if(!(return_value_soap_element_end_out_28 == 0))
            return soap->error;

          soap->mode = soap_out_xsd__anyType__1__1__3__3__2__m;
        }

        else
        {
          char *s;
          unsigned long int l;
          unsigned long int return_value_strlen_29;
          return_value_strlen_29=strlen(prefix);
          unsigned long int return_value_strlen_30;
          return_value_strlen_30=strlen(tag);
          l = return_value_strlen_29 + return_value_strlen_30;
          if(!(1ul + l >= sizeof(char [1024l]) /*1024ul*/ ))
            s = soap->msgbuf;

          else
          {
            void *return_value_malloc_31;
            return_value_malloc_31=malloc(l + (unsigned long int)2);
            s = (char *)return_value_malloc_31;
            if(s == ((char *)NULL))
            {
              soap->error = 20;
              return soap->error;
            }

          }
          snprintf(s, l + (unsigned long int)2, "%s:%s", prefix, tag);
          signed int return_value_soap_element_end_out_32;
          return_value_soap_element_end_out_32=soap_element_end_out(soap, s);
          if(!(return_value_soap_element_end_out_32 == 0))
            return soap->error;

          if(!(s == soap->msgbuf))
            free((void *)s);

        }
      }
    }

  }

  return 0;
}

// soap_outbyte
// file ../../../gsoap/stdsoap2.h line 3249
signed int soap_outbyte(struct soap *soap, const char *tag, signed int id, const char *p, const char *type, signed int n)
{
  signed int return_value_soap_embedded_id_1;
  return_value_soap_embedded_id_1=soap_embedded_id(soap, id, (const void *)p, n);
  signed int return_value_soap_element_begin_out_2;
  return_value_soap_element_begin_out_2=soap_element_begin_out(soap, tag, return_value_soap_embedded_id_1, type);
  _Bool tmp_if_expr_5;
  const char *return_value_soap_long2s_3;
  signed int return_value_soap_string_out_4;
  if(!(return_value_soap_element_begin_out_2 == 0))
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_soap_long2s_3=soap_long2s(soap, (signed long int)*p);
    return_value_soap_string_out_4=soap_string_out(soap, return_value_soap_long2s_3, 0);
    tmp_if_expr_5 = return_value_soap_string_out_4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
    return soap->error;

  else
  {
    signed int return_value_soap_element_end_out_6;
    return_value_soap_element_end_out_6=soap_element_end_out(soap, tag);
    return return_value_soap_element_end_out_6;
  }
}

// soap_outdateTime
// file stdsoap2.c line 14960
signed int soap_outdateTime(struct soap *soap, const char *tag, signed int id, const signed long int *p, const char *type, signed int n)
{
  signed int return_value_soap_embedded_id_1;
  return_value_soap_embedded_id_1=soap_embedded_id(soap, id, (const void *)p, n);
  signed int return_value_soap_element_begin_out_2;
  return_value_soap_element_begin_out_2=soap_element_begin_out(soap, tag, return_value_soap_embedded_id_1, type);
  _Bool tmp_if_expr_5;
  const char *return_value_soap_dateTime2s_3;
  signed int return_value_soap_string_out_4;
  if(!(return_value_soap_element_begin_out_2 == 0))
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_soap_dateTime2s_3=soap_dateTime2s(soap, *p);
    return_value_soap_string_out_4=soap_string_out(soap, return_value_soap_dateTime2s_3, 0);
    tmp_if_expr_5 = return_value_soap_string_out_4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
    return soap->error;

  else
  {
    signed int return_value_soap_element_end_out_6;
    return_value_soap_element_end_out_6=soap_element_end_out(soap, tag);
    return return_value_soap_element_end_out_6;
  }
}

// soap_outdouble
// file stdsoap2.c line 13563
signed int soap_outdouble(struct soap *soap, const char *tag, signed int id, const double *p, const char *type, signed int n)
{
  signed int return_value_soap_embedded_id_1;
  return_value_soap_embedded_id_1=soap_embedded_id(soap, id, (const void *)p, n);
  signed int return_value_soap_element_begin_out_2;
  return_value_soap_element_begin_out_2=soap_element_begin_out(soap, tag, return_value_soap_embedded_id_1, type);
  _Bool tmp_if_expr_5;
  const char *return_value_soap_double2s_3;
  signed int return_value_soap_string_out_4;
  if(!(return_value_soap_element_begin_out_2 == 0))
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_soap_double2s_3=soap_double2s(soap, *p);
    return_value_soap_string_out_4=soap_string_out(soap, return_value_soap_double2s_3, 0);
    tmp_if_expr_5 = return_value_soap_string_out_4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
    return soap->error;

  else
  {
    signed int return_value_soap_element_end_out_6;
    return_value_soap_element_end_out_6=soap_element_end_out(soap, tag);
    return return_value_soap_element_end_out_6;
  }
}

// soap_outfloat
// file stdsoap2.c line 13395
signed int soap_outfloat(struct soap *soap, const char *tag, signed int id, const float *p, const char *type, signed int n)
{
  signed int return_value_soap_embedded_id_1;
  return_value_soap_embedded_id_1=soap_embedded_id(soap, id, (const void *)p, n);
  signed int return_value_soap_element_begin_out_2;
  return_value_soap_element_begin_out_2=soap_element_begin_out(soap, tag, return_value_soap_embedded_id_1, type);
  _Bool tmp_if_expr_5;
  const char *return_value_soap_float2s_3;
  signed int return_value_soap_string_out_4;
  if(!(return_value_soap_element_begin_out_2 == 0))
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_soap_float2s_3=soap_float2s(soap, *p);
    return_value_soap_string_out_4=soap_string_out(soap, return_value_soap_float2s_3, 0);
    tmp_if_expr_5 = return_value_soap_string_out_4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
    return soap->error;

  else
  {
    signed int return_value_soap_element_end_out_6;
    return_value_soap_element_end_out_6=soap_element_end_out(soap, tag);
    return return_value_soap_element_end_out_6;
  }
}

// soap_outint
// file ../../../gsoap/stdsoap2.h line 3251
signed int soap_outint(struct soap *soap, const char *tag, signed int id, const signed int *p, const char *type, signed int n)
{
  signed int return_value_soap_embedded_id_1;
  return_value_soap_embedded_id_1=soap_embedded_id(soap, id, (const void *)p, n);
  signed int return_value_soap_element_begin_out_2;
  return_value_soap_element_begin_out_2=soap_element_begin_out(soap, tag, return_value_soap_embedded_id_1, type);
  _Bool tmp_if_expr_5;
  const char *return_value_soap_long2s_3;
  signed int return_value_soap_string_out_4;
  if(!(return_value_soap_element_begin_out_2 == 0))
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_soap_long2s_3=soap_long2s(soap, (signed long int)*p);
    return_value_soap_string_out_4=soap_string_out(soap, return_value_soap_long2s_3, 0);
    tmp_if_expr_5 = return_value_soap_string_out_4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
    return soap->error;

  else
  {
    signed int return_value_soap_element_end_out_6;
    return_value_soap_element_end_out_6=soap_element_end_out(soap, tag);
    return return_value_soap_element_end_out_6;
  }
}

// soap_outliteral
// file ../../../gsoap/stdsoap2.h line 3262
signed int soap_outliteral(struct soap *soap, const char *tag, char * const *p, const char *type)
{
  signed int i;
  const char *t = (const char *)(void *)0;
  signed int return_value_strcmp_2;
  const char *tmp_if_expr_4;
  signed int return_value_soap_attribute_5;
  signed int return_value_soap_element_start_end_out_7;
  if(!(tag == ((const char *)NULL)))
  {
    if(!((signed int)*tag == 45))
    {
      _Bool tmp_if_expr_10;
      if(!(soap->local_namespaces == ((struct Namespace *)NULL)))
      {
        t=strchr(tag, 58);
        tmp_if_expr_10 = t != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_10 = (_Bool)0;
      if(tmp_if_expr_10)
      {
        unsigned long int n = (unsigned long int)(t - tag);
        if(n >= sizeof(char [1024l]) /*1024ul*/ )
          n = sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1;

        signed int tmp_if_expr_1;
        if(!(n >= sizeof(char [1024l]) /*1024ul*/ ))
        {
          strncpy(soap->tmpbuf, tag, n);
          soap->tmpbuf[(signed long int)(unsigned long int)n] = (char)0;
          tmp_if_expr_1 = (signed int)soap->tmpbuf[(signed long int)(unsigned long int)n];
        }

        else
        {
          soap->tmpbuf[(signed long int)0] = (char)0;
          tmp_if_expr_1 = (signed int)soap->tmpbuf[(signed long int)0];
        }
        (void)(tmp_if_expr_1 != 0 ? (_Bool)1 : (_Bool)0);
        i = 0;
        for( ; !((soap->local_namespaces + (signed long int)i)->id == ((const char *)NULL)); i = i + 1)
        {
          return_value_strcmp_2=strcmp(soap->tmpbuf, (soap->local_namespaces + (signed long int)i)->id);
          if(return_value_strcmp_2 == 0)
            break;

        }
        t = t + 1l;
        signed int return_value_soap_element_3;
        return_value_soap_element_3=soap_element(soap, t, 0, type);
        _Bool tmp_if_expr_6;
        if(!(return_value_soap_element_3 == 0))
          tmp_if_expr_6 = (_Bool)1;

        else
        {
          if(!((soap->local_namespaces + (signed long int)i)->ns == ((const char *)NULL)))
            tmp_if_expr_4 = (soap->local_namespaces + (signed long int)i)->ns;

          else
            tmp_if_expr_4 = soap_padding;
          return_value_soap_attribute_5=soap_attribute(soap, "xmlns", tmp_if_expr_4);
          tmp_if_expr_6 = return_value_soap_attribute_5 != 0 ? (_Bool)1 : (_Bool)0;
        }
        _Bool tmp_if_expr_8;
        if(tmp_if_expr_6)
          tmp_if_expr_8 = (_Bool)1;

        else
        {
          return_value_soap_element_start_end_out_7=soap_element_start_end_out(soap, (const char *)(void *)0);
          tmp_if_expr_8 = return_value_soap_element_start_end_out_7 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_8)
          return soap->error;

      }

      else
      {
        t = tag;
        signed int return_value_soap_element_begin_out_9;
        return_value_soap_element_begin_out_9=soap_element_begin_out(soap, t, 0, type);
        if(!(return_value_soap_element_begin_out_9 == 0))
          return soap->error;

      }
    }

  }

  if(!(p == ((char * const *)NULL)))
  {
    if(!(*p == ((char *)NULL)))
    {
      signed int return_value_soap_send_11;
      return_value_soap_send_11=soap_send(soap, *p);
      if(!(return_value_soap_send_11 == 0))
        return soap->error;

    }

  }

  signed int return_value_soap_element_end_out_12;
  if(!(t == ((const char *)NULL)))
  {
    return_value_soap_element_end_out_12=soap_element_end_out(soap, t);
    return return_value_soap_element_end_out_12;
  }

  return 0;
}

// soap_outlong
// file stdsoap2.c line 13033
signed int soap_outlong(struct soap *soap, const char *tag, signed int id, const signed long int *p, const char *type, signed int n)
{
  signed int return_value_soap_embedded_id_1;
  return_value_soap_embedded_id_1=soap_embedded_id(soap, id, (const void *)p, n);
  signed int return_value_soap_element_begin_out_2;
  return_value_soap_element_begin_out_2=soap_element_begin_out(soap, tag, return_value_soap_embedded_id_1, type);
  _Bool tmp_if_expr_5;
  const char *return_value_soap_long2s_3;
  signed int return_value_soap_string_out_4;
  if(!(return_value_soap_element_begin_out_2 == 0))
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_soap_long2s_3=soap_long2s(soap, *p);
    return_value_soap_string_out_4=soap_string_out(soap, return_value_soap_long2s_3, 0);
    tmp_if_expr_5 = return_value_soap_string_out_4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
    return soap->error;

  else
  {
    signed int return_value_soap_element_end_out_6;
    return_value_soap_element_end_out_6=soap_element_end_out(soap, tag);
    return return_value_soap_element_end_out_6;
  }
}

// soap_outshort
// file stdsoap2.c line 13295
signed int soap_outshort(struct soap *soap, const char *tag, signed int id, const signed short int *p, const char *type, signed int n)
{
  signed int return_value_soap_embedded_id_1;
  return_value_soap_embedded_id_1=soap_embedded_id(soap, id, (const void *)p, n);
  signed int return_value_soap_element_begin_out_2;
  return_value_soap_element_begin_out_2=soap_element_begin_out(soap, tag, return_value_soap_embedded_id_1, type);
  _Bool tmp_if_expr_5;
  const char *return_value_soap_long2s_3;
  signed int return_value_soap_string_out_4;
  if(!(return_value_soap_element_begin_out_2 == 0))
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_soap_long2s_3=soap_long2s(soap, (signed long int)*p);
    return_value_soap_string_out_4=soap_string_out(soap, return_value_soap_long2s_3, 0);
    tmp_if_expr_5 = return_value_soap_string_out_4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
    return soap->error;

  else
  {
    signed int return_value_soap_element_end_out_6;
    return_value_soap_element_end_out_6=soap_element_end_out(soap, tag);
    return return_value_soap_element_end_out_6;
  }
}

// soap_outstring
// file ../../../gsoap/stdsoap2.h line 3261
signed int soap_outstring(struct soap *soap, const char *tag, signed int id, char * const *p, const char *type, signed int n)
{
  id=soap_element_id(soap, tag, id, (const void *)*p, (void *)0, 0, type, n, (char **)(void *)0);
  signed int return_value_soap_element_null_1;
  signed int return_value_soap_string_out_3;
  signed int return_value_soap_element_end_out_5;
  if(!(id >= 0))
    return soap->error;

  else
  {
    if(*(*p) == 0)
    {
      if(!((0x08000000 & soap->mode) == 0))
      {
        return_value_soap_element_null_1=soap_element_null(soap, tag, id, type);
        return return_value_soap_element_null_1;
      }

    }

    signed int return_value_soap_element_begin_out_2;
    return_value_soap_element_begin_out_2=soap_element_begin_out(soap, tag, id, type);
    _Bool tmp_if_expr_4;
    if(!(return_value_soap_element_begin_out_2 == 0))
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_soap_string_out_3=soap_string_out(soap, *p, 0);
      tmp_if_expr_4 = return_value_soap_string_out_3 != 0 ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr_6;
    if(tmp_if_expr_4)
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_soap_element_end_out_5=soap_element_end_out(soap, tag);
      tmp_if_expr_6 = return_value_soap_element_end_out_5 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
      return soap->error;

    else
      return 0;
  }
}

// soap_outunsignedByte
// file stdsoap2.c line 13665
signed int soap_outunsignedByte(struct soap *soap, const char *tag, signed int id, const unsigned char *p, const char *type, signed int n)
{
  signed int return_value_soap_embedded_id_1;
  return_value_soap_embedded_id_1=soap_embedded_id(soap, id, (const void *)p, n);
  signed int return_value_soap_element_begin_out_2;
  return_value_soap_element_begin_out_2=soap_element_begin_out(soap, tag, return_value_soap_embedded_id_1, type);
  _Bool tmp_if_expr_5;
  const char *return_value_soap_unsignedLong2s_3;
  signed int return_value_soap_string_out_4;
  if(!(return_value_soap_element_begin_out_2 == 0))
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_soap_unsignedLong2s_3=soap_unsignedLong2s(soap, (unsigned long int)*p);
    return_value_soap_string_out_4=soap_string_out(soap, return_value_soap_unsignedLong2s_3, 0);
    tmp_if_expr_5 = return_value_soap_string_out_4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
    return soap->error;

  else
  {
    signed int return_value_soap_element_end_out_6;
    return_value_soap_element_end_out_6=soap_element_end_out(soap, tag);
    return return_value_soap_element_end_out_6;
  }
}

// soap_outunsignedInt
// file stdsoap2.c line 13820
signed int soap_outunsignedInt(struct soap *soap, const char *tag, signed int id, const unsigned int *p, const char *type, signed int n)
{
  signed int return_value_soap_embedded_id_1;
  return_value_soap_embedded_id_1=soap_embedded_id(soap, id, (const void *)p, n);
  signed int return_value_soap_element_begin_out_2;
  return_value_soap_element_begin_out_2=soap_element_begin_out(soap, tag, return_value_soap_embedded_id_1, type);
  _Bool tmp_if_expr_5;
  const char *return_value_soap_unsignedLong2s_3;
  signed int return_value_soap_string_out_4;
  if(!(return_value_soap_element_begin_out_2 == 0))
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_soap_unsignedLong2s_3=soap_unsignedLong2s(soap, (unsigned long int)*p);
    return_value_soap_string_out_4=soap_string_out(soap, return_value_soap_unsignedLong2s_3, 0);
    tmp_if_expr_5 = return_value_soap_string_out_4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
    return soap->error;

  else
  {
    signed int return_value_soap_element_end_out_6;
    return_value_soap_element_end_out_6=soap_element_end_out(soap, tag);
    return return_value_soap_element_end_out_6;
  }
}

// soap_outunsignedLong
// file stdsoap2.c line 13909
signed int soap_outunsignedLong(struct soap *soap, const char *tag, signed int id, const unsigned long int *p, const char *type, signed int n)
{
  signed int return_value_soap_embedded_id_1;
  return_value_soap_embedded_id_1=soap_embedded_id(soap, id, (const void *)p, n);
  signed int return_value_soap_element_begin_out_2;
  return_value_soap_element_begin_out_2=soap_element_begin_out(soap, tag, return_value_soap_embedded_id_1, type);
  _Bool tmp_if_expr_5;
  const char *return_value_soap_unsignedLong2s_3;
  signed int return_value_soap_string_out_4;
  if(!(return_value_soap_element_begin_out_2 == 0))
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_soap_unsignedLong2s_3=soap_unsignedLong2s(soap, *p);
    return_value_soap_string_out_4=soap_string_out(soap, return_value_soap_unsignedLong2s_3, 0);
    tmp_if_expr_5 = return_value_soap_string_out_4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
    return soap->error;

  else
  {
    signed int return_value_soap_element_end_out_6;
    return_value_soap_element_end_out_6=soap_element_end_out(soap, tag);
    return return_value_soap_element_end_out_6;
  }
}

// soap_outunsignedShort
// file stdsoap2.c line 13742
signed int soap_outunsignedShort(struct soap *soap, const char *tag, signed int id, const unsigned short int *p, const char *type, signed int n)
{
  signed int return_value_soap_embedded_id_1;
  return_value_soap_embedded_id_1=soap_embedded_id(soap, id, (const void *)p, n);
  signed int return_value_soap_element_begin_out_2;
  return_value_soap_element_begin_out_2=soap_element_begin_out(soap, tag, return_value_soap_embedded_id_1, type);
  _Bool tmp_if_expr_5;
  const char *return_value_soap_unsignedLong2s_3;
  signed int return_value_soap_string_out_4;
  if(!(return_value_soap_element_begin_out_2 == 0))
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_soap_unsignedLong2s_3=soap_unsignedLong2s(soap, (unsigned long int)*p);
    return_value_soap_string_out_4=soap_string_out(soap, return_value_soap_unsignedLong2s_3, 0);
    tmp_if_expr_5 = return_value_soap_string_out_4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
    return soap->error;

  else
  {
    signed int return_value_soap_element_end_out_6;
    return_value_soap_element_end_out_6=soap_element_end_out(soap, tag);
    return return_value_soap_element_end_out_6;
  }
}

// soap_outwliteral
// file stdsoap2.c line 15195
signed int soap_outwliteral(struct soap *soap, const char *tag, signed int * const *p, const char *type)
{
  signed int i;
  const char *t = (const char *)(void *)0;
  signed int return_value_strcmp_2;
  const char *tmp_if_expr_4;
  signed int return_value_soap_attribute_5;
  signed int return_value_soap_element_start_end_out_7;
  if(!(tag == ((const char *)NULL)))
  {
    if(!((signed int)*tag == 45))
    {
      _Bool tmp_if_expr_10;
      if(!(soap->local_namespaces == ((struct Namespace *)NULL)))
      {
        t=strchr(tag, 58);
        tmp_if_expr_10 = t != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_10 = (_Bool)0;
      if(tmp_if_expr_10)
      {
        unsigned long int n = (unsigned long int)(t - tag);
        if(n >= sizeof(char [1024l]) /*1024ul*/ )
          n = sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1;

        signed int tmp_if_expr_1;
        if(!(n >= sizeof(char [1024l]) /*1024ul*/ ))
        {
          strncpy(soap->tmpbuf, tag, n);
          soap->tmpbuf[(signed long int)(unsigned long int)n] = (char)0;
          tmp_if_expr_1 = (signed int)soap->tmpbuf[(signed long int)(unsigned long int)n];
        }

        else
        {
          soap->tmpbuf[(signed long int)0] = (char)0;
          tmp_if_expr_1 = (signed int)soap->tmpbuf[(signed long int)0];
        }
        (void)(tmp_if_expr_1 != 0 ? (_Bool)1 : (_Bool)0);
        i = 0;
        for( ; !((soap->local_namespaces + (signed long int)i)->id == ((const char *)NULL)); i = i + 1)
        {
          return_value_strcmp_2=strcmp(soap->tmpbuf, (soap->local_namespaces + (signed long int)i)->id);
          if(return_value_strcmp_2 == 0)
            break;

        }
        t = t + 1l;
        signed int return_value_soap_element_3;
        return_value_soap_element_3=soap_element(soap, t, 0, type);
        _Bool tmp_if_expr_6;
        if(!(return_value_soap_element_3 == 0))
          tmp_if_expr_6 = (_Bool)1;

        else
        {
          if(!((soap->local_namespaces + (signed long int)i)->ns == ((const char *)NULL)))
            tmp_if_expr_4 = (soap->local_namespaces + (signed long int)i)->ns;

          else
            tmp_if_expr_4 = soap_padding;
          return_value_soap_attribute_5=soap_attribute(soap, "xmlns", tmp_if_expr_4);
          tmp_if_expr_6 = return_value_soap_attribute_5 != 0 ? (_Bool)1 : (_Bool)0;
        }
        _Bool tmp_if_expr_8;
        if(tmp_if_expr_6)
          tmp_if_expr_8 = (_Bool)1;

        else
        {
          return_value_soap_element_start_end_out_7=soap_element_start_end_out(soap, (const char *)(void *)0);
          tmp_if_expr_8 = return_value_soap_element_start_end_out_7 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_8)
          return soap->error;

      }

      else
      {
        t = tag;
        signed int return_value_soap_element_begin_out_9;
        return_value_soap_element_begin_out_9=soap_element_begin_out(soap, t, 0, type);
        if(!(return_value_soap_element_begin_out_9 == 0))
          return soap->error;

      }
    }

  }

  const signed int *tmp_post_11;
  if(!(p == ((signed int * const *)NULL)))
  {
    signed int c;
    const signed int *s = *p;
    do
    {
      tmp_post_11 = s;
      s = s + 1l;
      c = *tmp_post_11;
      if(c == 0)
        break;

      signed int return_value_soap_pututf8_12;
      return_value_soap_pututf8_12=soap_pututf8(soap, (unsigned long int)c);
      if(!(return_value_soap_pututf8_12 == 0))
        return soap->error;

    }
    while((_Bool)1);
  }

  signed int return_value_soap_element_end_out_13;
  if(!(t == ((const char *)NULL)))
  {
    return_value_soap_element_end_out_13=soap_element_end_out(soap, t);
    return return_value_soap_element_end_out_13;
  }

  return 0;
}

// soap_outwstring
// file stdsoap2.c line 14679
signed int soap_outwstring(struct soap *soap, const char *tag, signed int id, signed int * const *p, const char *type, signed int n)
{
  id=soap_element_id(soap, tag, id, (const void *)*p, (void *)0, 0, type, n, (char **)(void *)0);
  signed int return_value_soap_element_null_1;
  signed int return_value_soap_wstring_out_3;
  signed int return_value_soap_element_end_out_5;
  if(!(id >= 0))
    return soap->error;

  else
  {
    if(*(*p) == 0)
    {
      if(!((0x08000000 & soap->mode) == 0))
      {
        return_value_soap_element_null_1=soap_element_null(soap, tag, id, type);
        return return_value_soap_element_null_1;
      }

    }

    signed int return_value_soap_element_begin_out_2;
    return_value_soap_element_begin_out_2=soap_element_begin_out(soap, tag, id, type);
    _Bool tmp_if_expr_4;
    if(!(return_value_soap_element_begin_out_2 == 0))
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_soap_wstring_out_3=soap_wstring_out(soap, *p, 0);
      tmp_if_expr_4 = return_value_soap_wstring_out_3 != 0 ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr_6;
    if(tmp_if_expr_4)
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_soap_element_end_out_5=soap_element_end_out(soap, tag);
      tmp_if_expr_6 = return_value_soap_element_end_out_5 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
      return soap->error;

    else
      return 0;
  }
}

// soap_patt_match
// file dom.c line 1014
static signed int soap_patt_match(const char *name, const char *patt)
{
  const char *s;
  if(name == ((const char *)NULL))
    return (signed int)!(*patt != 0);

  else
  {
    s=strchr(name, 58);
    if(!(s == ((const char *)NULL)))
      name = s + (signed long int)1;

    s=strchr(patt, 58);
    if(!(s == ((const char *)NULL)))
      patt = s + (signed long int)1;

    signed int return_value_soap_name_match_1;
    return_value_soap_name_match_1=soap_name_match(name, patt);
    return return_value_soap_name_match_1;
  }
}

// soap_peek_element
// file ../../../gsoap/stdsoap2.h line 3088
signed int soap_peek_element(struct soap *soap)
{
  struct soap_attribute *tp;
  struct soap_attribute *tq = (struct soap_attribute *)(void *)0;
  const char *t;
  char *s;
  signed int c;
  signed int i;
  _Bool tmp_if_expr_19;
  signed int return_value_soap_recv_18;
  signed int tmp_if_expr_20;
  signed int return_value_soap_recv_1;
  unsigned long int tmp_post_3;
  signed int return_value_soap_recv_5;
  unsigned long int tmp_post_7;
  _Bool tmp_if_expr_10;
  signed int return_value_soap_recv_9;
  signed int tmp_if_expr_11;
  _Bool tmp_if_expr_16;
  _Bool tmp_if_expr_14;
  signed int return_value_soap_recv_13;
  signed int tmp_if_expr_15;
  signed int return_value_soap_recv_23;
  unsigned long int tmp_post_25;
  signed int return_value_soap_recv_28;
  unsigned long int tmp_post_30;
  signed int return_value_soap_recv_32;
  unsigned long int tmp_post_34;
  signed int return_value_soap_recv_37;
  unsigned long int tmp_post_39;
  signed int return_value_soap_recv_44;
  unsigned long int tmp_post_46;
  signed int return_value_soap_recv_55;
  unsigned long int tmp_post_57;
  signed int return_value_soap_recv_61;
  unsigned long int tmp_post_63;
  signed int return_value_strcmp_116;
  _Bool tmp_if_expr_69;
  signed int return_value_strcmp_115;
  signed int return_value_soap_match_tag_114;
  signed int return_value_soap_match_tag_107;
  signed int return_value_soap_match_tag_108;
  signed int return_value_strcmp_110;
  _Bool tmp_if_expr_112;
  signed int return_value_strcmp_111;
  signed int return_value_soap_match_tag_106;
  signed int return_value_soap_match_tag_89;
  signed int return_value_soap_match_tag_88;
  signed int return_value_soap_match_tag_87;
  signed int return_value_strcmp_75;
  signed int return_value_strcmp_76;
  signed int return_value_soap_match_tag_82;
  signed int return_value_strcmp_83;
  _Bool tmp_if_expr_85;
  signed int return_value_strcmp_84;
  signed int return_value_soap_match_tag_81;
  signed int return_value_strcmp_79;
  signed int return_value_strcmp_78;
  signed int return_value_soap_match_tag_102;
  signed int return_value_soap_match_tag_101;
  signed int return_value_soap_match_tag_100;
  signed int return_value_soap_match_tag_95;
  signed int return_value_strcmp_96;
  _Bool tmp_if_expr_98;
  signed int return_value_strcmp_97;
  signed int return_value_soap_match_tag_94;
  signed int return_value_strcmp_92;
  signed int return_value_strcmp_91;
  signed int return_value_strcmp_104;
  if(!(soap->peeked == 0))
  {
    if(soap->tag[0l] == 0)
    {
      soap->error = 6;
      return soap->error;
    }

    return 0;
  }

  else
  {
    soap->peeked = (signed short int)1;
    soap->id[(signed long int)0] = (char)0;
    soap->href[(signed long int)0] = (char)0;
    soap->type[(signed long int)0] = (char)0;
    soap->arrayType[(signed long int)0] = (char)0;
    soap->arraySize[(signed long int)0] = (char)0;
    soap->arrayOffset[(signed long int)0] = (char)0;
    soap->other = (signed short int)0;
    soap->root = (signed short int)-1;
    soap->position = 0;
    soap->null = (signed short int)0;
    soap->mustUnderstand = (signed short int)0;
    c=soap_getchar(soap);
    _Bool tmp_if_expr_21;
    if(c == 0xEF)
    {
      if(soap->bufidx >= soap->buflen)
      {
        return_value_soap_recv_18=soap_recv(soap);
        tmp_if_expr_19 = return_value_soap_recv_18 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_19 = (_Bool)0;
      if(tmp_if_expr_19)
        tmp_if_expr_20 = -1;

      else
        tmp_if_expr_20 = (signed int)(unsigned char)soap->buf[(signed long int)soap->bufidx];
      tmp_if_expr_21 = tmp_if_expr_20 == 0xBB ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_21 = (_Bool)0;
    if(tmp_if_expr_21)
    {
      _Bool tmp_if_expr_2;
      if(soap->bufidx >= soap->buflen)
      {
        return_value_soap_recv_1=soap_recv(soap);
        tmp_if_expr_2 = return_value_soap_recv_1 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_2 = (_Bool)0;
      signed int tmp_if_expr_4;
      if(tmp_if_expr_2)
        tmp_if_expr_4 = -1;

      else
      {
        tmp_post_3 = soap->bufidx;
        soap->bufidx = soap->bufidx + 1ul;
        tmp_if_expr_4 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_3];
      }
      c = tmp_if_expr_4;
      _Bool tmp_if_expr_6;
      if(soap->bufidx >= soap->buflen)
      {
        return_value_soap_recv_5=soap_recv(soap);
        tmp_if_expr_6 = return_value_soap_recv_5 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_6 = (_Bool)0;
      signed int tmp_if_expr_8;
      if(tmp_if_expr_6)
        tmp_if_expr_8 = -1;

      else
      {
        tmp_post_7 = soap->bufidx;
        soap->bufidx = soap->bufidx + 1ul;
        tmp_if_expr_8 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_7];
      }
      c = tmp_if_expr_8;
      if(c == 0xBF)
        soap->mode = soap->mode & ~0x00000020;

      else
        soap->ahead = 0x0F << 12 | 0xBB << 6 | c & 0x3F;
    }

    else
    {
      _Bool tmp_if_expr_12;
      if(c == 0xFE)
      {
        if(soap->bufidx >= soap->buflen)
        {
          return_value_soap_recv_9=soap_recv(soap);
          tmp_if_expr_10 = return_value_soap_recv_9 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_10 = (_Bool)0;
        if(tmp_if_expr_10)
          tmp_if_expr_11 = -1;

        else
          tmp_if_expr_11 = (signed int)(unsigned char)soap->buf[(signed long int)soap->bufidx];
        tmp_if_expr_12 = tmp_if_expr_11 == 0xFF ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_12 = (_Bool)0;
      _Bool tmp_if_expr_17;
      if(tmp_if_expr_12)
        tmp_if_expr_17 = (_Bool)1;

      else
      {
        if(c == 0xFF)
        {
          if(soap->bufidx >= soap->buflen)
          {
            return_value_soap_recv_13=soap_recv(soap);
            tmp_if_expr_14 = return_value_soap_recv_13 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_14 = (_Bool)0;
          if(tmp_if_expr_14)
            tmp_if_expr_15 = -1;

          else
            tmp_if_expr_15 = (signed int)(unsigned char)soap->buf[(signed long int)soap->bufidx];
          tmp_if_expr_16 = tmp_if_expr_15 == 0xFE ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_16 = (_Bool)0;
        tmp_if_expr_17 = tmp_if_expr_16 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_17)
      {
        soap->error = 48;
        return soap->error;
      }

      else
        soap->ahead = c;
    }
    c=soap_get(soap);
    while(1 + c >= 1 && !(c >= 33))
      c=soap_get(soap);
    if(!(c == -2))
    {
      soap->tag[0l] = (char)0;
      if(c == -1)
      {
        signed int tmp_if_expr_22;
        if(!(soap->error == 0))
          tmp_if_expr_22 = soap->error;

        else
          tmp_if_expr_22 = -1;
        soap->error = tmp_if_expr_22;
        return soap->error;
      }

      soap->ahead = c;
      soap->error = 6;
      return soap->error;
    }

    else
    {
      do
      {
        _Bool tmp_if_expr_24;
        if(soap->bufidx >= soap->buflen)
        {
          return_value_soap_recv_23=soap_recv(soap);
          tmp_if_expr_24 = return_value_soap_recv_23 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_24 = (_Bool)0;
        signed int tmp_if_expr_26;
        if(tmp_if_expr_24)
          tmp_if_expr_26 = -1;

        else
        {
          tmp_post_25 = soap->bufidx;
          soap->bufidx = soap->bufidx + 1ul;
          tmp_if_expr_26 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_25];
        }
        c = tmp_if_expr_26;
      }
      while(1 + c >= 1 && !(c >= 33));
      s = soap->tag;
      i = (signed int)sizeof(char [1024l]) /*1024ul*/ ;
      while(c >= 33 && !(c == 47) && !(c == 62) && !(c == -1))
      {
        i = i - 1;
        if(i >= 1)
        {
          char *tmp_post_27 = s;
          s = s + 1l;
          *tmp_post_27 = (char)c;
        }

        _Bool tmp_if_expr_29;
        if(soap->bufidx >= soap->buflen)
        {
          return_value_soap_recv_28=soap_recv(soap);
          tmp_if_expr_29 = return_value_soap_recv_28 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_29 = (_Bool)0;
        signed int tmp_if_expr_31;
        if(tmp_if_expr_29)
          tmp_if_expr_31 = -1;

        else
        {
          tmp_post_30 = soap->bufidx;
          soap->bufidx = soap->bufidx + 1ul;
          tmp_if_expr_31 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_30];
        }
        c = tmp_if_expr_31;
      }
      *s = (char)0;
      while(1 + c >= 1 && !(c >= 33))
      {
        _Bool tmp_if_expr_33;
        if(soap->bufidx >= soap->buflen)
        {
          return_value_soap_recv_32=soap_recv(soap);
          tmp_if_expr_33 = return_value_soap_recv_32 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_33 = (_Bool)0;
        signed int tmp_if_expr_35;
        if(tmp_if_expr_33)
          tmp_if_expr_35 = -1;

        else
        {
          tmp_post_34 = soap->bufidx;
          soap->bufidx = soap->bufidx + 1ul;
          tmp_if_expr_35 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_34];
        }
        c = tmp_if_expr_35;
      }
      soap_pop_namespace(soap);
      tp = soap->attributes;
      for( ; !(tp == ((struct soap_attribute *)NULL)); tp = tp->next)
        tp->visible = (signed short int)0;
      while(!(c == 47) && !(c == 62) && !(c == -1))
      {
        s = soap->tmpbuf;
        i = (signed int)sizeof(char [1024l]) /*1024ul*/ ;
        while(c >= 33 && !(c == 47) && !(c == 61) && !(c == 62) && !(c == -1))
        {
          i = i - 1;
          if(i >= 1)
          {
            char *tmp_post_36 = s;
            s = s + 1l;
            *tmp_post_36 = (char)c;
          }

          _Bool tmp_if_expr_38;
          if(soap->bufidx >= soap->buflen)
          {
            return_value_soap_recv_37=soap_recv(soap);
            tmp_if_expr_38 = return_value_soap_recv_37 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_38 = (_Bool)0;
          signed int tmp_if_expr_40;
          if(tmp_if_expr_38)
            tmp_if_expr_40 = -1;

          else
          {
            tmp_post_39 = soap->bufidx;
            soap->bufidx = soap->bufidx + 1ul;
            tmp_if_expr_40 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_39];
          }
          c = tmp_if_expr_40;
        }
        *s = (char)0;
        if((unsigned long int)i == sizeof(char [1024l]) /*1024ul*/ )
        {
          soap->error = 5;
          return soap->error;
        }

        signed int return_value_strncmp_41;
        return_value_strncmp_41=strncmp(soap->tmpbuf, "xmlns", (unsigned long int)5);
        if(return_value_strncmp_41 == 0)
        {
          if((signed int)soap->tmpbuf[5l] == 58)
            t = soap->tmpbuf + (signed long int)6;

          else
            if(!(soap->tmpbuf[5l] == 0))
              t = (const char *)(void *)0;

            else
              t = soap_padding;
        }

        else
          t = (const char *)(void *)0;
        tq = (struct soap_attribute *)(void *)0;
        tp = soap->attributes;
        for( ; !(tp == ((struct soap_attribute *)NULL)); tp = tp->next)
        {
          signed int return_value_strcmp_42;
          return_value_strcmp_42=strcmp(tp->name, soap->tmpbuf);
          if(return_value_strcmp_42 == 0)
            break;

          tq = tp;
        }
        if(tp == ((struct soap_attribute *)NULL))
        {
          unsigned long int l;
          l=strlen(soap->tmpbuf);
          void *return_value_malloc_43;
          return_value_malloc_43=malloc(sizeof(struct soap_attribute) /*48ul*/  + l);
          tp = (struct soap_attribute *)return_value_malloc_43;
          if(tp == ((struct soap_attribute *)NULL))
          {
            soap->error = 20;
            return soap->error;
          }

          if(1ul + l >= 1ul)
          {
            strncpy((char *)tp->name, soap->tmpbuf, (l + (unsigned long int)1) - (unsigned long int)1);
            ((char *)tp->name)[(signed long int)((l + (unsigned long int)1) - (unsigned long int)1)] = (char)0;
            if(!(tp->name[(signed long int)l] == 0))
              (_Bool)1;

            else
              (_Bool)0;
          }

          else
            (_Bool)0;
          tp->value = (char *)(void *)0;
          tp->size = (unsigned long int)0;
          tp->ns = (const char *)(void *)0;
          if(!(tq == ((struct soap_attribute *)NULL)))
          {
            tq->next = tp;
            tp->next = (struct soap_attribute *)(void *)0;
          }

          else
          {
            tp->next = soap->attributes;
            soap->attributes = tp;
          }
        }

        while(1 + c >= 1 && !(c >= 33))
        {
          _Bool tmp_if_expr_45;
          if(soap->bufidx >= soap->buflen)
          {
            return_value_soap_recv_44=soap_recv(soap);
            tmp_if_expr_45 = return_value_soap_recv_44 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_45 = (_Bool)0;
          signed int tmp_if_expr_47;
          if(tmp_if_expr_45)
            tmp_if_expr_47 = -1;

          else
          {
            tmp_post_46 = soap->bufidx;
            soap->bufidx = soap->bufidx + 1ul;
            tmp_if_expr_47 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_46];
          }
          c = tmp_if_expr_47;
        }
        if(c == 61)
        {
          unsigned long int k;
          do
            c=soap_getutf8(soap);
          while(1 + c >= 1 && !(c >= 33));
          if(!(c == -6) && !(c == -5))
          {
            soap->ahead = c;
            c = 32;
          }

          k = tp->size;
          signed int return_value_soap_getattrval_54;
          return_value_soap_getattrval_54=soap_getattrval(soap, tp->value, &k, c);
          if(!(return_value_soap_getattrval_54 == 0))
          {
            if(!(soap->error == 20))
              return soap->error;

            soap->error = 0;
            signed int return_value_soap_store_lab_48;
            return_value_soap_store_lab_48=soap_store_lab(soap, tp->value, k);
            if(!(return_value_soap_store_lab_48 == 0))
              return soap->error;

            if(!(tp->value == ((char *)NULL)))
              free((void *)tp->value);

            tp->value = (char *)(void *)0;
            do
            {
              k = soap->lablen - soap->labidx;
              signed int return_value_soap_getattrval_50;
              return_value_soap_getattrval_50=soap_getattrval(soap, soap->labbuf + (signed long int)soap->labidx, &k, c);
              if(!(return_value_soap_getattrval_50 == 0))
              {
                if(!(soap->error == 20))
                  return soap->error;

                soap->error = 0;
                soap->labidx = soap->lablen;
                signed int return_value_soap_append_lab_49;
                return_value_soap_append_lab_49=soap_append_lab(soap, (const char *)(void *)0, (unsigned long int)0);
                if(!(return_value_soap_append_lab_49 == 0))
                  return soap->error;

              }

              else
                break;
            }
            while((_Bool)1);
            if(!(soap->labidx == 0ul))
              tp->size = soap->lablen;

            else
            {
              unsigned long int return_value_strlen_51;
              return_value_strlen_51=strlen(soap->labbuf);
              tp->size = return_value_strlen_51 + (unsigned long int)1;
              if(!(tp->size >= 256ul))
                tp->size = (unsigned long int)256;

            }
            void *return_value_malloc_52;
            return_value_malloc_52=malloc(tp->size);
            tp->value = (char *)return_value_malloc_52;
            if(tp->value == ((char *)NULL))
            {
              soap->error = 20;
              return soap->error;
            }

            _Bool tmp_if_expr_53;
            if(!(tp->value == ((char *)NULL)))
              tmp_if_expr_53 = (unsigned long int)tp->size > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_53 = (_Bool)0;
            if(tmp_if_expr_53)
            {
              strncpy(tp->value, soap->labbuf, tp->size - (unsigned long int)1);
              tp->value[(signed long int)(tp->size - (unsigned long int)1)] = (char)0;
              if(!(tp->value[-1l + (signed long int)tp->size] == 0))
                (_Bool)1;

              else
                (_Bool)0;
            }

            else
              (_Bool)0;
          }

          do
          {
            _Bool tmp_if_expr_56;
            if(soap->bufidx >= soap->buflen)
            {
              return_value_soap_recv_55=soap_recv(soap);
              tmp_if_expr_56 = return_value_soap_recv_55 != 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_56 = (_Bool)0;
            signed int tmp_if_expr_58;
            if(tmp_if_expr_56)
              tmp_if_expr_58 = -1;

            else
            {
              tmp_post_57 = soap->bufidx;
              soap->bufidx = soap->bufidx + 1ul;
              tmp_if_expr_58 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_57];
            }
            c = tmp_if_expr_58;
          }
          while(1 + c >= 1 && !(c >= 33));
          tp->visible = (signed short int)2;
        }

        else
          tp->visible = (signed short int)1;
        if(!(t == ((const char *)NULL)))
        {
          if(!(tp->value == ((char *)NULL)))
          {
            struct soap_nlist *return_value_soap_push_namespace_59;
            return_value_soap_push_namespace_59=soap_push_namespace(soap, t, tp->value);
            if(return_value_soap_push_namespace_59 == ((struct soap_nlist *)NULL))
              return soap->error;

          }

        }

      }
      if(c == -1)
      {
        signed int tmp_if_expr_60;
        if(!(soap->error == 0))
          tmp_if_expr_60 = soap->error;

        else
          tmp_if_expr_60 = -1;
        soap->error = tmp_if_expr_60;
        return soap->error;
      }

      soap->body = (signed short int)(c != 47);
      if(soap->body == 0)
        do
        {
          _Bool tmp_if_expr_62;
          if(soap->bufidx >= soap->buflen)
          {
            return_value_soap_recv_61=soap_recv(soap);
            tmp_if_expr_62 = return_value_soap_recv_61 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_62 = (_Bool)0;
          signed int tmp_if_expr_64;
          if(tmp_if_expr_62)
            tmp_if_expr_64 = -1;

          else
          {
            tmp_post_63 = soap->bufidx;
            soap->bufidx = soap->bufidx + 1ul;
            tmp_if_expr_64 = (signed int)(unsigned char)soap->buf[(signed long int)tmp_post_63];
          }
          c = tmp_if_expr_64;
        }
        while(1 + c >= 1 && !(c >= 33));

      tp = soap->attributes;
      for( ; !(tp == ((struct soap_attribute *)NULL)); tp = tp->next)
        if(!(tp->visible == 0))
        {
          if(!(tp->value == ((char *)NULL)))
          {
            signed int return_value_strcmp_117;
            return_value_strcmp_117=strcmp(tp->name, "id");
            if(return_value_strcmp_117 == 0)
            {
              _Bool tmp_if_expr_65;
              if((signed int)soap->version >= 1)
                tmp_if_expr_65 = !((soap->imode & 0x00020000) != 0) ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_65 = (_Bool)0;
              _Bool tmp_if_expr_66;
              if(tmp_if_expr_65)
                tmp_if_expr_66 = (_Bool)1;

              else
                tmp_if_expr_66 = (soap->mode & 0x20000000) != 0 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_66)
              {
                soap->id[0l] = (char)35;
                if(!(soap->id + 1l == ((char *)NULL)))
                {
                  strncpy(soap->id + (signed long int)1, tp->value, (sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1) - (unsigned long int)1);
                  (soap->id + (signed long int)1)[(signed long int)((sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1) - (unsigned long int)1)] = (char)0;
                  if(!(soap->id[1023l] == 0))
                    (_Bool)1;

                  else
                    (_Bool)0;
                }

                else
                  (_Bool)0;
              }

            }

            else
            {
              return_value_strcmp_116=strcmp(tp->name, "href");
              if(return_value_strcmp_116 == 0)
              {
                _Bool tmp_if_expr_67;
                if((signed int)soap->version == 1)
                  tmp_if_expr_67 = !((soap->imode & 0x00020000) != 0) ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_67 = (_Bool)0;
                _Bool tmp_if_expr_68;
                if(tmp_if_expr_67)
                  tmp_if_expr_68 = (_Bool)1;

                else
                  tmp_if_expr_68 = (soap->mode & 0x20000000) != 0 ? (_Bool)1 : (_Bool)0;
                _Bool tmp_if_expr_70;
                if(tmp_if_expr_68)
                  tmp_if_expr_70 = (_Bool)1;

                else
                {
                  if(!((640 & soap->mode) == 0))
                    tmp_if_expr_69 = (signed int)*tp->value != 35 ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr_69 = (_Bool)0;
                  tmp_if_expr_70 = tmp_if_expr_69 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_70)
                {
                  strncpy(soap->href, tp->value, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
                  soap->href[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
                  (void)(soap->href[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
                }

              }

              else
              {
                return_value_strcmp_115=strcmp(tp->name, "ref");
                if(return_value_strcmp_115 == 0)
                {
                  _Bool tmp_if_expr_71;
                  if((signed int)soap->version == 2)
                    tmp_if_expr_71 = !((soap->imode & 0x00020000) != 0) ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr_71 = (_Bool)0;
                  _Bool tmp_if_expr_72;
                  if(tmp_if_expr_71)
                    tmp_if_expr_72 = (_Bool)1;

                  else
                    tmp_if_expr_72 = (soap->mode & 0x20000000) != 0 ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr_72)
                  {
                    soap->href[0l] = (char)35;
                    if(!(soap->href + (signed long int)!((signed int)*tp->value == 35) == ((char *)NULL)))
                    {
                      strncpy(soap->href + (signed long int)((signed int)*tp->value != 35), tp->value, (sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1) - (unsigned long int)1);
                      (soap->href + (signed long int)((signed int)*tp->value != 35))[(signed long int)((sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1) - (unsigned long int)1)] = (char)0;
                      if(!(soap->href[1022l + (signed long int)!((signed int)*tp->value == 35)] == 0))
                        (_Bool)1;

                      else
                        (_Bool)0;
                    }

                    else
                      (_Bool)0;
                  }

                }

                else
                {
                  return_value_soap_match_tag_114=soap_match_tag(soap, tp->name, "xsi:type");
                  if(return_value_soap_match_tag_114 == 0)
                  {
                    strncpy(soap->type, tp->value, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
                    soap->type[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
                    (void)(soap->type[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
                  }

                  else
                  {
                    return_value_soap_match_tag_107=soap_match_tag(soap, tp->name, "xsi:null");
                    _Bool tmp_if_expr_109;
                    if(return_value_soap_match_tag_107 == 0)
                      tmp_if_expr_109 = (_Bool)1;

                    else
                    {
                      return_value_soap_match_tag_108=soap_match_tag(soap, tp->name, "xsi:nil");
                      tmp_if_expr_109 = !(return_value_soap_match_tag_108 != 0) ? (_Bool)1 : (_Bool)0;
                    }
                    _Bool tmp_if_expr_113;
                    if(tmp_if_expr_109)
                    {
                      return_value_strcmp_110=strcmp(tp->value, "1");
                      if(return_value_strcmp_110 == 0)
                        tmp_if_expr_112 = (_Bool)1;

                      else
                      {
                        return_value_strcmp_111=strcmp(tp->value, "true");
                        tmp_if_expr_112 = !(return_value_strcmp_111 != 0) ? (_Bool)1 : (_Bool)0;
                      }
                      tmp_if_expr_113 = tmp_if_expr_112 ? (_Bool)1 : (_Bool)0;
                    }

                    else
                      tmp_if_expr_113 = (_Bool)0;
                    if(tmp_if_expr_113)
                      soap->null = (signed short int)1;

                    else
                    {
                      return_value_soap_match_tag_106=soap_match_tag(soap, tp->name, "SOAP-ENV:encodingStyle");
                      if(return_value_soap_match_tag_106 == 0)
                      {
                        if(soap->encodingStyle == ((const char *)NULL))
                          soap->encodingStyle = soap_padding;

                        soap_get_version(soap);
                      }

                      else
                        if((signed int)soap->version == 1)
                        {
                          signed int return_value_soap_match_tag_90;
                          return_value_soap_match_tag_90=soap_match_tag(soap, tp->name, "SOAP-ENC:arrayType");
                          if(return_value_soap_match_tag_90 == 0)
                          {
                            s=strrchr(tp->value, 91);
                            _Bool tmp_if_expr_74;
                            if(!(s == ((char *)NULL)))
                              tmp_if_expr_74 = (unsigned long int)(s - tp->value) < sizeof(char [1024l]) /*1024ul*/  ? (_Bool)1 : (_Bool)0;

                            else
                              tmp_if_expr_74 = (_Bool)0;
                            if(tmp_if_expr_74)
                            {
                              signed int tmp_if_expr_73;
                              if(!((unsigned long int)(s - tp->value) >= sizeof(char [1024l]) /*1024ul*/ ))
                              {
                                strncpy(soap->arrayType, tp->value, (unsigned long int)(s - tp->value));
                                soap->arrayType[(signed long int)(unsigned long int)(s - tp->value)] = (char)0;
                                tmp_if_expr_73 = (signed int)soap->arrayType[(signed long int)(unsigned long int)(s - tp->value)];
                              }

                              else
                              {
                                soap->arrayType[(signed long int)0] = (char)0;
                                tmp_if_expr_73 = (signed int)soap->arrayType[(signed long int)0];
                              }
                              (void)(tmp_if_expr_73 != 0 ? (_Bool)1 : (_Bool)0);
                              strncpy(soap->arraySize, s, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
                              soap->arraySize[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
                              (void)(soap->arraySize[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
                            }

                            else
                            {
                              strncpy(soap->arrayType, tp->value, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
                              soap->arrayType[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
                              (void)(soap->arrayType[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
                            }
                          }

                          else
                          {
                            return_value_soap_match_tag_89=soap_match_tag(soap, tp->name, "SOAP-ENC:offset");
                            if(return_value_soap_match_tag_89 == 0)
                            {
                              strncpy(soap->arrayOffset, tp->value, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
                              soap->arrayOffset[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
                              (void)(soap->arrayOffset[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
                            }

                            else
                            {
                              return_value_soap_match_tag_88=soap_match_tag(soap, tp->name, "SOAP-ENC:position");
                              if(return_value_soap_match_tag_88 == 0)
                                soap->position=soap_getposition(tp->value, soap->positions);

                              else
                              {
                                return_value_soap_match_tag_87=soap_match_tag(soap, tp->name, "SOAP-ENC:root");
                                if(return_value_soap_match_tag_87 == 0)
                                {
                                  return_value_strcmp_75=strcmp(tp->value, "1");
                                  _Bool tmp_if_expr_77;
                                  if(return_value_strcmp_75 == 0)
                                    tmp_if_expr_77 = (_Bool)1;

                                  else
                                  {
                                    return_value_strcmp_76=strcmp(tp->value, "true");
                                    tmp_if_expr_77 = !(return_value_strcmp_76 != 0) ? (_Bool)1 : (_Bool)0;
                                  }
                                  soap->root = (signed short int)tmp_if_expr_77;
                                }

                                else
                                {
                                  return_value_soap_match_tag_82=soap_match_tag(soap, tp->name, "SOAP-ENV:mustUnderstand");
                                  _Bool tmp_if_expr_86;
                                  if(return_value_soap_match_tag_82 == 0)
                                  {
                                    return_value_strcmp_83=strcmp(tp->value, "1");
                                    if(return_value_strcmp_83 == 0)
                                      tmp_if_expr_85 = (_Bool)1;

                                    else
                                    {
                                      return_value_strcmp_84=strcmp(tp->value, "true");
                                      tmp_if_expr_85 = !(return_value_strcmp_84 != 0) ? (_Bool)1 : (_Bool)0;
                                    }
                                    tmp_if_expr_86 = tmp_if_expr_85 ? (_Bool)1 : (_Bool)0;
                                  }

                                  else
                                    tmp_if_expr_86 = (_Bool)0;
                                  if(tmp_if_expr_86)
                                    soap->mustUnderstand = (signed short int)1;

                                  else
                                  {
                                    return_value_soap_match_tag_81=soap_match_tag(soap, tp->name, "SOAP-ENV:actor");
                                    if(return_value_soap_match_tag_81 == 0)
                                    {
                                      _Bool tmp_if_expr_80;
                                      if(soap->actor == ((const char *)NULL))
                                        tmp_if_expr_80 = (_Bool)1;

                                      else
                                      {
                                        return_value_strcmp_79=strcmp(soap->actor, tp->value);
                                        tmp_if_expr_80 = return_value_strcmp_79 != 0 ? (_Bool)1 : (_Bool)0;
                                      }
                                      if(tmp_if_expr_80)
                                      {
                                        return_value_strcmp_78=strcmp(tp->value, "http://schemas.xmlsoap.org/soap/actor/next");
                                        if(!(return_value_strcmp_78 == 0))
                                          soap->other = (signed short int)1;

                                      }

                                    }

                                  }
                                }
                              }
                            }
                          }
                        }

                        else
                          if((signed int)soap->version == 2)
                          {
                            signed int return_value_soap_match_tag_103;
                            return_value_soap_match_tag_103=soap_match_tag(soap, tp->name, "SOAP-ENC:id");
                            if(return_value_soap_match_tag_103 == 0)
                            {
                              soap->id[0l] = (char)35;
                              if(!(soap->id + 1l == ((char *)NULL)))
                              {
                                strncpy(soap->id + (signed long int)1, tp->value, (sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1) - (unsigned long int)1);
                                (soap->id + (signed long int)1)[(signed long int)((sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1) - (unsigned long int)1)] = (char)0;
                                if(!(soap->id[1023l] == 0))
                                  (_Bool)1;

                                else
                                  (_Bool)0;
                              }

                              else
                                (_Bool)0;
                            }

                            else
                            {
                              return_value_soap_match_tag_102=soap_match_tag(soap, tp->name, "SOAP-ENC:ref");
                              if(return_value_soap_match_tag_102 == 0)
                              {
                                soap->href[0l] = (char)35;
                                if(!(soap->href + (signed long int)!((signed int)*tp->value == 35) == ((char *)NULL)))
                                {
                                  strncpy(soap->href + (signed long int)((signed int)*tp->value != 35), tp->value, (sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1) - (unsigned long int)1);
                                  (soap->href + (signed long int)((signed int)*tp->value != 35))[(signed long int)((sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1) - (unsigned long int)1)] = (char)0;
                                  if(!(soap->href[1022l + (signed long int)!((signed int)*tp->value == 35)] == 0))
                                    (_Bool)1;

                                  else
                                    (_Bool)0;
                                }

                                else
                                  (_Bool)0;
                              }

                              else
                              {
                                return_value_soap_match_tag_101=soap_match_tag(soap, tp->name, "SOAP-ENC:itemType");
                                if(return_value_soap_match_tag_101 == 0)
                                {
                                  strncpy(soap->arrayType, tp->value, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
                                  soap->arrayType[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
                                  (void)(soap->arrayType[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
                                }

                                else
                                {
                                  return_value_soap_match_tag_100=soap_match_tag(soap, tp->name, "SOAP-ENC:arraySize");
                                  if(return_value_soap_match_tag_100 == 0)
                                  {
                                    strncpy(soap->arraySize, tp->value, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
                                    soap->arraySize[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
                                    (void)(soap->arraySize[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
                                  }

                                  else
                                  {
                                    return_value_soap_match_tag_95=soap_match_tag(soap, tp->name, "SOAP-ENV:mustUnderstand");
                                    _Bool tmp_if_expr_99;
                                    if(return_value_soap_match_tag_95 == 0)
                                    {
                                      return_value_strcmp_96=strcmp(tp->value, "1");
                                      if(return_value_strcmp_96 == 0)
                                        tmp_if_expr_98 = (_Bool)1;

                                      else
                                      {
                                        return_value_strcmp_97=strcmp(tp->value, "true");
                                        tmp_if_expr_98 = !(return_value_strcmp_97 != 0) ? (_Bool)1 : (_Bool)0;
                                      }
                                      tmp_if_expr_99 = tmp_if_expr_98 ? (_Bool)1 : (_Bool)0;
                                    }

                                    else
                                      tmp_if_expr_99 = (_Bool)0;
                                    if(tmp_if_expr_99)
                                      soap->mustUnderstand = (signed short int)1;

                                    else
                                    {
                                      return_value_soap_match_tag_94=soap_match_tag(soap, tp->name, "SOAP-ENV:role");
                                      if(return_value_soap_match_tag_94 == 0)
                                      {
                                        _Bool tmp_if_expr_93;
                                        if(soap->actor == ((const char *)NULL))
                                          tmp_if_expr_93 = (_Bool)1;

                                        else
                                        {
                                          return_value_strcmp_92=strcmp(soap->actor, tp->value);
                                          tmp_if_expr_93 = return_value_strcmp_92 != 0 ? (_Bool)1 : (_Bool)0;
                                        }
                                        if(tmp_if_expr_93)
                                        {
                                          return_value_strcmp_91=strcmp(tp->value, "http://www.w3.org/2003/05/soap-envelope/role/next");
                                          if(!(return_value_strcmp_91 == 0))
                                            soap->other = (signed short int)1;

                                        }

                                      }

                                    }
                                  }
                                }
                              }
                            }
                          }

                          else
                          {
                            signed int return_value_soap_match_tag_105;
                            return_value_soap_match_tag_105=soap_match_tag(soap, tp->name, "wsdl:required");
                            if(return_value_soap_match_tag_105 == 0)
                            {
                              return_value_strcmp_104=strcmp(tp->value, "true");
                              if(return_value_strcmp_104 == 0)
                                soap->mustUnderstand = (signed short int)1;

                            }

                          }
                    }
                  }
                }
              }
            }
          }

        }

      soap->error = 0;
      return soap->error;
    }
  }
}

// soap_pointer_enter
// file stdsoap2.c line 7560
signed int soap_pointer_enter(struct soap *soap, const void *p, const void *a, signed int n, signed int type, struct soap_plist **ppp)
{
  unsigned long int h;
  struct soap_plist *pp;
  (void)n;
  _Bool tmp_if_expr_2;
  if(soap->pblk == ((struct soap_pblk *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (signed int)soap->pidx >= 32 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    struct soap_pblk *pb;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct soap_pblk) /*1544ul*/ );
    pb = (struct soap_pblk *)return_value_malloc_1;
    if(pb == ((struct soap_pblk *)NULL))
    {
      soap->error = 20;
      return 0;
    }

    pb->next = soap->pblk;
    soap->pblk = pb;
    soap->pidx = (signed short int)0;
  }

  signed short int tmp_post_3 = soap->pidx;
  soap->pidx = soap->pidx + 1;
  pp = &soap->pblk->plist[(signed long int)tmp_post_3];
  *ppp = pp;
  if(!(a == NULL))
    h = (unsigned long int)((unsigned long int)a >> 3 & (unsigned long int)(4096 - 1));

  else
    h = (unsigned long int)((unsigned long int)p >> 3 & (unsigned long int)(4096 - 1));
  pp->next = soap->pht[(signed long int)h];
  pp->type = type;
  pp->mark1 = (char)0;
  pp->mark2 = (char)0;
  pp->ptr = p;
  pp->dup = (void *)0;
  pp->array = a;
  pp->size = n;
  soap->pht[(signed long int)h] = pp;
  soap->idnum = soap->idnum + 1;
  pp->id = soap->idnum;
  return pp->id;
}

// soap_pointer_lookup
// file stdsoap2.c line 7537
signed int soap_pointer_lookup(struct soap *soap, const void *p, signed int type, struct soap_plist **ppp)
{
  struct soap_plist *pp;
  *ppp = (struct soap_plist *)(void *)0;
  if(!(p == NULL))
  {
    pp = soap->pht[(signed long int)(unsigned long int)((unsigned long int)p >> 3 & (unsigned long int)(4096 - 1))];
    for( ; !(pp == ((struct soap_plist *)NULL)); pp = pp->next)
      if(pp->ptr == p)
      {
        if(pp->type == type)
        {
          *ppp = pp;
          return pp->id;
        }

      }

  }

  return 0;
}

// soap_poll
// file stdsoap2.c line 5427
signed int soap_poll(struct soap *soap)
{
  signed int r;
  if(!(soap->socket == -1))
  {
    r=tcp_select(soap, soap->socket, 0x7, 0);
    if(r >= 1 && !((0x4 & r) == 0))
      r = -1;

  }

  else
    if(!(soap->master == -1))
      r=tcp_select(soap, soap->master, 0x2, 0);

    else
      return 0;
  signed long int return_value_recv_1;
  signed int *return_value___errno_location_4;
  if(r >= 1)
  {
    signed int t;
    if(!(soap->socket == -1))
    {
      if(!((0x2 & r) == 0))
      {
        _Bool tmp_if_expr_2;
        if((0x1 & r) == 0)
          tmp_if_expr_2 = (_Bool)1;

        else
        {
          return_value_recv_1=recv(soap->socket, (void *)(char *)&t, (unsigned long int)1, 2);
          tmp_if_expr_2 = return_value_recv_1 > (signed long int)0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_2)
          return 0;

      }

    }

  }

  else
    if(!(r >= 0))
    {
      _Bool tmp_if_expr_5;
      if(!(soap->master == -1))
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = soap->socket != (signed int)-1 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
      {
        return_value___errno_location_4=__errno_location();
        if(!(*return_value___errno_location_4 == 4))
        {
          const char *return_value_tcp_error_3;
          return_value_tcp_error_3=tcp_error(soap);
          soap_set_receiver_error(soap, return_value_tcp_error_3, "select failed in soap_poll()", 28);
          soap->error = 28;
          return soap->error;
        }

      }

    }

  return -1;
}

// soap_pop_block
// file ../../../gsoap/stdsoap2.h line 3126
void soap_pop_block(struct soap *soap, struct soap_blist *b)
{
  struct soap_bhead *p;
  if(b == ((struct soap_blist *)NULL))
    b = soap->blist;

  if(!(b->head == ((struct soap_bhead *)NULL)))
  {
    p = b->head;
    b->size = b->size - p->size;
    b->head = p->next;
    free((void *)p);
  }

}

// soap_pop_namespace
// file stdsoap2.c line 2975
void soap_pop_namespace(struct soap *soap)
{
  struct soap_nlist *np;
  struct soap_nlist *nq;
  np = soap->nlist;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(np == ((struct soap_nlist *)NULL)))
      tmp_if_expr_1 = np->level >= soap->level ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    nq = np->next;
    free((void *)np);
    np = nq;
  }
  while((_Bool)1);
  soap->nlist = np;
}

// soap_post_check_mime_attachments
// file stdsoap2.c line 15883
void soap_post_check_mime_attachments(struct soap *soap)
{
  soap->imode = soap->imode | 0x40000000;
}

// soap_prefix_of
// file dom.c line 921
static const char * soap_prefix_of(struct soap *soap, const char *ns)
{
  struct soap_nlist *np = soap->nlist;
  signed int return_value_strcmp_1;
  for( ; !(np == ((struct soap_nlist *)NULL)); np = np->next)
    if(!(np->ns == ((const char *)NULL)))
    {
      return_value_strcmp_1=strcmp(np->ns, ns);
      if(return_value_strcmp_1 == 0)
        return np->id;

    }

  return (const char *)(void *)0;
}

// soap_print_fault
// file ../../../gsoap/stdsoap2.h line 3160
void soap_print_fault(struct soap *soap, struct _IO_FILE *fd)
{
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  if(soap == ((struct soap *)NULL))
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    if(!((signed int)soap->state == 1))
      tmp_if_expr_3 = (signed int)soap->state != 2 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_4)
    fprintf(fd, "Error: soap struct state not initialized with soap_init\n");

  else
    if(!(soap->error == 0))
    {
      const char **c;
      const char *v = (const char *)(void *)0;
      const char *s;
      const char *d;
      c=soap_faultcode(soap);
      if(*c == ((const char *)NULL))
        soap_set_fault(soap);

      if((signed int)soap->version == 2)
        v=soap_check_faultsubcode(soap);

      const char **return_value_soap_faultstring_1;
      return_value_soap_faultstring_1=soap_faultstring(soap);
      s = *return_value_soap_faultstring_1;
      d=soap_check_faultdetail(soap);
      signed int tmp_if_expr_2;
      if(!(soap->version == 0))
        tmp_if_expr_2 = (signed int)soap->version;

      else
        tmp_if_expr_2 = soap->error;
      fprintf(fd, "%s%d fault %s [%s]\n\"%s\"\nDetail: %s\n", soap->version != 0 ? "SOAP 1." : "Error ", tmp_if_expr_2, *c, v != ((const char *)NULL) ? v : "no subcode", s != ((const char *)NULL) ? s : "[no reason]", d != ((const char *)NULL) ? d : "[no detail]");
    }

}

// soap_print_fault_location
// file stdsoap2.c line 18303
void soap_print_fault_location(struct soap *soap, struct _IO_FILE *fd)
{
  signed int i;
  signed int j;
  signed int c1;
  signed int c2;
  if(!(soap->error == 0))
  {
    if(!(soap->error == 1000))
    {
      if(soap->buflen >= soap->bufidx)
      {
        if(soap->buflen >= 1ul)
        {
          if(!(soap->buflen >= 65537ul))
          {
            i = (signed int)soap->bufidx - 1;
            if(!(i >= 1))
              i = 0;

            c1 = (signed int)soap->buf[(signed long int)i];
            soap->buf[(signed long int)i] = (char)0;
            if((signed int)soap->buflen >= 1024 + i)
              j = i + 1023;

            else
              j = (signed int)soap->buflen - 1;
            c2 = (signed int)soap->buf[(signed long int)j];
            soap->buf[(signed long int)j] = (char)0;
            fprintf(fd, "%s%c\n<!-- ** HERE ** -->\n", (const void *)soap->buf, c1);
            if(!(soap->bufidx >= soap->buflen))
              fprintf(fd, "%s\n", soap->buf + (signed long int)soap->bufidx);

            soap->buf[(signed long int)i] = (char)c1;
            soap->buf[(signed long int)j] = (char)c2;
          }

        }

      }

    }

  }

}

// soap_push_block
// file ../../../gsoap/stdsoap2.h line 3125
void * soap_push_block(struct soap *soap, struct soap_blist *b, unsigned long int n)
{
  struct soap_bhead *p;
  if(b == ((struct soap_blist *)NULL))
    b = soap->blist;

  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct soap_bhead) /*16ul*/  + n);
  p = (struct soap_bhead *)return_value_malloc_1;
  if(p == ((struct soap_bhead *)NULL))
  {
    soap->error = 20;
    return (void *)0;
  }

  else
  {
    p->next = b->head;
    b->head = p;
    p->size = n;
    b->size = b->size + n;
    return (void *)(p + (signed long int)1);
  }
}

// soap_push_namespace
// file stdsoap2.c line 2916
struct soap_nlist * soap_push_namespace(struct soap *soap, const char *id, const char *ns)
{
  struct soap_nlist *np;
  struct Namespace *p;
  signed short int i = (signed short int)-1;
  unsigned long int n;
  unsigned long int k;
  n=strlen(id);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(ns);
  k = return_value_strlen_1 + (unsigned long int)1;
  p = soap->local_namespaces;
  signed int return_value_strcmp_2;
  if(!(p == ((struct Namespace *)NULL)))
  {
    i = (signed short int)0;
    for( ; !(p->id == ((const char *)NULL)); i = i + 1)
    {
      if(!(p->ns == ((const char *)NULL)))
      {
        return_value_strcmp_2=strcmp(ns, p->ns);
        if(return_value_strcmp_2 == 0)
          break;

      }

      if(!(p->out == ((char *)NULL)))
      {
        signed int return_value_strcmp_3;
        return_value_strcmp_3=strcmp(ns, p->out);
        if(return_value_strcmp_3 == 0)
          break;

      }

      else
        if(!(p->in == ((const char *)NULL)))
        {
          signed int return_value_soap_tag_cmp_5;
          return_value_soap_tag_cmp_5=soap_tag_cmp(ns, p->in);
          if(return_value_soap_tag_cmp_5 == 0)
          {
            void *return_value_malloc_4;
            return_value_malloc_4=malloc(k);
            p->out = (char *)return_value_malloc_4;
            if(!(p->out == ((char *)NULL)))
            {
              if(k >= 1ul && !(p->out == ((char *)NULL)))
              {
                strncpy(p->out, ns, k - (unsigned long int)1);
                p->out[(signed long int)(k - (unsigned long int)1)] = (char)0;
                if(!(p->out[-1l + (signed long int)k] == 0))
                  (_Bool)1;

                else
                  (_Bool)0;
              }

              else
                (_Bool)0;
            }

            break;
          }

        }

      p = p + 1l;
    }
    if(p->id == ((const char *)NULL))
      i = (signed short int)-1;

  }

  if((signed int)i >= 0)
    k = (unsigned long int)0;

  void *return_value_malloc_6;
  return_value_malloc_6=malloc(sizeof(struct soap_nlist) /*32ul*/  + n + k);
  np = (struct soap_nlist *)return_value_malloc_6;
  if(np == ((struct soap_nlist *)NULL))
  {
    soap->error = 20;
    return (struct soap_nlist *)(void *)0;
  }

  else
  {
    np->next = soap->nlist;
    soap->nlist = np;
    np->level = soap->level;
    np->index = i;
    if(1ul + n >= 1ul)
    {
      strncpy((char *)np->id, id, (n + (unsigned long int)1) - (unsigned long int)1);
      ((char *)np->id)[(signed long int)((n + (unsigned long int)1) - (unsigned long int)1)] = (char)0;
      if(!(np->id[(signed long int)n] == 0))
        (_Bool)1;

      else
        (_Bool)0;
    }

    else
      (_Bool)0;
    if(!((signed int)i >= 0))
    {
      np->ns = np->id + (signed long int)n + (signed long int)1;
      if(k >= 1ul && !(np->ns == ((char *)NULL)))
      {
        strncpy((char *)np->ns, ns, k - (unsigned long int)1);
        ((char *)np->ns)[(signed long int)(k - (unsigned long int)1)] = (char)0;
        if(!(np->ns[-1l + (signed long int)k] == 0))
          (_Bool)1;

        else
          (_Bool)0;
      }

      else
        (_Bool)0;
    }

    else
      np->ns = (const char *)(void *)0;
    return np;
  }
}

// soap_push_ns
// file stdsoap2.c line 10212
static struct soap_nlist * soap_push_ns(struct soap *soap, const char *id, const char *ns, signed short int utilized)
{
  struct soap_nlist *np;
  unsigned long int n;
  unsigned long int k;
  const char *return_value_soap_tagsearch_1;
  return_value_soap_tagsearch_1=soap_tagsearch(soap->c14nexclude, id);
  signed int return_value_strcmp_2;
  if(!(return_value_soap_tagsearch_1 == ((const char *)NULL)))
    return (struct soap_nlist *)(void *)0;

  else
  {
    if(utilized == 0)
    {
      np = soap->nlist;
      for( ; !(np == ((struct soap_nlist *)NULL)); np = np->next)
      {
        signed int return_value_strcmp_4;
        return_value_strcmp_4=strcmp(np->id, id);
        if(return_value_strcmp_4 == 0)
        {
          _Bool tmp_if_expr_3;
          if(np->ns == ((const char *)NULL))
            tmp_if_expr_3 = (_Bool)1;

          else
          {
            return_value_strcmp_2=strcmp(np->ns, ns);
            tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_3)
            break;

        }

      }
      if(!(np == ((struct soap_nlist *)NULL)))
      {
        _Bool tmp_if_expr_5;
        if(!(np->level >= soap->level))
          tmp_if_expr_5 = (_Bool)1;

        else
          tmp_if_expr_5 = !(np->ns != ((const char *)NULL)) ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr_6;
        if(tmp_if_expr_5)
          tmp_if_expr_6 = (signed int)np->index == 1 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_6 = (_Bool)0;
        if(tmp_if_expr_6)
          utilized = (signed short int)1;

        else
          return (struct soap_nlist *)(void *)0;
      }

    }

    n=strlen(id);
    if(!(ns == ((const char *)NULL)))
      k=strlen(ns);

    else
      k = (unsigned long int)0;
    void *return_value_malloc_7;
    return_value_malloc_7=malloc(sizeof(struct soap_nlist) /*32ul*/  + n + k + (unsigned long int)1);
    np = (struct soap_nlist *)return_value_malloc_7;
    if(np == ((struct soap_nlist *)NULL))
    {
      soap->error = 20;
      return (struct soap_nlist *)(void *)0;
    }

    else
    {
      np->next = soap->nlist;
      soap->nlist = np;
      if(1ul + n >= 1ul)
      {
        strncpy((char *)np->id, id, (n + (unsigned long int)1) - (unsigned long int)1);
        ((char *)np->id)[(signed long int)((n + (unsigned long int)1) - (unsigned long int)1)] = (char)0;
        if(!(np->id[(signed long int)n] == 0))
          (_Bool)1;

        else
          (_Bool)0;
      }

      else
        (_Bool)0;
      if(!(ns == ((const char *)NULL)))
      {
        np->ns = np->id + (signed long int)n + (signed long int)1;
        if(1ul + k >= 1ul && !(np->ns == ((char *)NULL)))
        {
          strncpy((char *)np->ns, ns, (k + (unsigned long int)1) - (unsigned long int)1);
          ((char *)np->ns)[(signed long int)((k + (unsigned long int)1) - (unsigned long int)1)] = (char)0;
          if(!(np->ns[(signed long int)k] == 0))
            (_Bool)1;

          else
            (_Bool)0;
        }

        else
          (_Bool)0;
      }

      else
        np->ns = (const char *)(void *)0;
      np->level = soap->level;
      np->index = utilized;
      return np;
    }
  }
}

// soap_push_prefix
// file dom.c line 817
static const char * soap_push_prefix(struct soap *soap, const char *id, unsigned long int n, const char *ns, signed int isearly, signed int iselement)
{
  struct Namespace *p;
  struct Namespace *ln = soap->local_namespaces;
  struct soap_nlist *np;
  if(n == 0ul)
    id = (const char *)(void *)0;

  _Bool tmp_if_expr_1;
  signed int return_value_strncmp_2;
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_4;
  _Bool tmp_if_expr_9;
  signed int return_value_strcmp_8;
  if(ns == ((const char *)NULL))
  {
    p = ln;
    do
    {
      if(!(p == ((struct Namespace *)NULL)))
        tmp_if_expr_1 = p->id != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(!tmp_if_expr_1)
        break;

      return_value_strncmp_2=strncmp(p->id, id, n);
      if(return_value_strncmp_2 == 0)
      {
        if(p->id[(signed long int)n] == 0)
          break;

      }

      p = p + 1l;
    }
    while((_Bool)1);
    if(!(p == ((struct Namespace *)NULL)))
    {
      if(!(p->id == ((const char *)NULL)))
      {
        id = p->id;
        ns = p->out;
        if(ns == ((const char *)NULL))
          ns = p->ns;

      }

    }

    if(ns == ((const char *)NULL))
      return "";

  }

  else
    if(id == ((const char *)NULL))
    {
      if(!(iselement == 0))
        id = "";

      else
      {
        p = ln;
        do
        {
          if(!(p == ((struct Namespace *)NULL)))
            tmp_if_expr_3 = p->id != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_3 = (_Bool)0;
          if(!tmp_if_expr_3)
            break;

          if(!(p->ns == ((const char *)NULL)))
          {
            return_value_strcmp_4=strcmp(p->ns, ns);
            if(return_value_strcmp_4 == 0)
              break;

          }

          p = p + 1l;
        }
        while((_Bool)1);
        _Bool tmp_if_expr_5;
        if(!(p == ((struct Namespace *)NULL)))
          tmp_if_expr_5 = p->id != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_5 = (_Bool)0;
        if(tmp_if_expr_5)
          id = p->id;

        else
        {
          signed int i = 0;
          np = soap->nlist;
          for( ; !(np == ((struct soap_nlist *)NULL)); np = np->next)
            i = i + 1;
          snprintf(soap->tag, sizeof(char [1024l]) /*1024ul*/ , "_%d", i);
          id = soap->tag;
        }
      }
    }

    else
    {
      np = soap->nlist;
      for( ; !(np == ((struct soap_nlist *)NULL)); np = np->next)
      {
        signed int return_value_strncmp_11;
        return_value_strncmp_11=strncmp(np->id, id, n);
        if(return_value_strncmp_11 == 0)
        {
          if(np->id[(signed long int)n] == 0)
          {
            if(!(np->ns == ((const char *)NULL)))
            {
              signed int return_value_strcmp_6;
              return_value_strcmp_6=strcmp(np->ns, ns);
              if(return_value_strcmp_6 == 0)
                return "";

            }

            else
            {
              signed int return_value_strcmp_7;
              return_value_strcmp_7=strcmp((ln + (signed long int)np->index)->ns, ns);
              _Bool tmp_if_expr_10;
              if(return_value_strcmp_7 == 0)
                tmp_if_expr_10 = (_Bool)1;

              else
              {
                if(!((ln + (signed long int)np->index)->out == ((char *)NULL)))
                {
                  return_value_strcmp_8=strcmp((ln + (signed long int)np->index)->out, ns);
                  tmp_if_expr_9 = !(return_value_strcmp_8 != 0) ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_9 = (_Bool)0;
                tmp_if_expr_10 = tmp_if_expr_9 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_10)
                return "";

            }
            break;
          }

        }

      }
      signed int tmp_if_expr_12;
      if(!(n >= sizeof(char [1024l]) /*1024ul*/ ))
      {
        strncpy(soap->tag, id, n);
        soap->tag[(signed long int)(unsigned long int)n] = (char)0;
        tmp_if_expr_12 = (signed int)soap->tag[(signed long int)(unsigned long int)n];
      }

      else
      {
        soap->tag[(signed long int)0] = (char)0;
        tmp_if_expr_12 = (signed int)soap->tag[(signed long int)0];
      }
      (void)(tmp_if_expr_12 != 0 ? (_Bool)1 : (_Bool)0);
      id = soap->tag;
      soap->local_namespaces = (struct Namespace *)(void *)0;
    }
  if(!(isearly == 0))
    soap->level = soap->level + 1u;

  np=soap_push_namespace(soap, id, ns);
  soap->local_namespaces = ln;
  if(!(isearly == 0))
    soap->level = soap->level - 1u;

  if(np == ((struct soap_nlist *)NULL))
    return (const char *)(void *)0;

  else
  {
    if(np->ns == ((const char *)NULL))
    {
      np->ns = (ln + (signed long int)np->index)->out;
      if(np->ns == ((const char *)NULL))
        np->ns = (ln + (signed long int)np->index)->ns;

    }

    np->index = (signed short int)0;
    if(!(np->id[0l] == 0))
    {
      snprintf(soap->msgbuf, sizeof(char [1024l]) /*1024ul*/ , "xmlns:%s", (const void *)np->id);
      signed int return_value_out_attribute_13;
      return_value_out_attribute_13=out_attribute(soap, (const char *)(void *)0, soap->msgbuf, ns, isearly);
      if(!(return_value_out_attribute_13 == 0))
        return (const char *)(void *)0;

    }

    else
    {
      signed int return_value_out_attribute_14;
      return_value_out_attribute_14=out_attribute(soap, (const char *)(void *)0, "xmlns", ns, isearly);
      if(!(return_value_out_attribute_14 == 0))
        return (const char *)(void *)0;

    }
    return np->id;
  }
}

// soap_put_PointerToSOAP_ENV__Code
// file soapC.c line 1281
signed int soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code * const *a, const char *tag, const char *type)
{
  signed int return_value_soap_out_PointerToSOAP_ENV__Code_1;
  return_value_soap_out_PointerToSOAP_ENV__Code_1=soap_out_PointerToSOAP_ENV__Code(soap, tag != ((const char *)NULL) ? tag : "SOAP-ENV:Code", -2, a, type);
  if(!(return_value_soap_out_PointerToSOAP_ENV__Code_1 == 0))
    return soap->error;

  else
  {
    signed int return_value_soap_putindependent_2;
    return_value_soap_putindependent_2=soap_putindependent(soap);
    return return_value_soap_putindependent_2;
  }
}

// soap_put_PointerToSOAP_ENV__Detail
// file soapC.c line 1220
signed int soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail * const *a, const char *tag, const char *type)
{
  signed int return_value_soap_out_PointerToSOAP_ENV__Detail_1;
  return_value_soap_out_PointerToSOAP_ENV__Detail_1=soap_out_PointerToSOAP_ENV__Detail(soap, tag != ((const char *)NULL) ? tag : "SOAP-ENV:Detail", -2, a, type);
  if(!(return_value_soap_out_PointerToSOAP_ENV__Detail_1 == 0))
    return soap->error;

  else
  {
    signed int return_value_soap_putindependent_2;
    return_value_soap_putindependent_2=soap_putindependent(soap);
    return return_value_soap_putindependent_2;
  }
}

// soap_put_PointerToSOAP_ENV__Reason
// file soapC.c line 1162
signed int soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason * const *a, const char *tag, const char *type)
{
  signed int return_value_soap_out_PointerToSOAP_ENV__Reason_1;
  return_value_soap_out_PointerToSOAP_ENV__Reason_1=soap_out_PointerToSOAP_ENV__Reason(soap, tag != ((const char *)NULL) ? tag : "SOAP-ENV:Reason", -2, a, type);
  if(!(return_value_soap_out_PointerToSOAP_ENV__Reason_1 == 0))
    return soap->error;

  else
  {
    signed int return_value_soap_putindependent_2;
    return_value_soap_putindependent_2=soap_putindependent(soap);
    return return_value_soap_putindependent_2;
  }
}

// soap_put_PointerTot__Routing
// file soapC.c line 1337
signed int soap_put_PointerTot__Routing(struct soap *soap, struct t__Routing * const *a, const char *tag, const char *type)
{
  signed int return_value_soap_out_PointerTot__Routing_1;
  return_value_soap_out_PointerTot__Routing_1=soap_out_PointerTot__Routing(soap, tag != ((const char *)NULL) ? tag : "t:Routing", -2, a, type);
  if(!(return_value_soap_out_PointerTot__Routing_1 == 0))
    return soap->error;

  else
  {
    signed int return_value_soap_putindependent_2;
    return_value_soap_putindependent_2=soap_putindependent(soap);
    return return_value_soap_putindependent_2;
  }
}

// soap_put_SOAP_ENV__Code
// file soapC.c line 822
signed int soap_put_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
  signed int return_value_soap_out_SOAP_ENV__Code_1;
  return_value_soap_out_SOAP_ENV__Code_1=soap_out_SOAP_ENV__Code(soap, tag != ((const char *)NULL) ? tag : "SOAP-ENV:Code", -2, a, type);
  if(!(return_value_soap_out_SOAP_ENV__Code_1 == 0))
    return soap->error;

  else
  {
    signed int return_value_soap_putindependent_2;
    return_value_soap_putindependent_2=soap_putindependent(soap);
    return return_value_soap_putindependent_2;
  }
}

// soap_put_SOAP_ENV__Detail
// file soapC.c line 732
signed int soap_put_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
  signed int return_value_soap_out_SOAP_ENV__Detail_1;
  return_value_soap_out_SOAP_ENV__Detail_1=soap_out_SOAP_ENV__Detail(soap, tag != ((const char *)NULL) ? tag : "SOAP-ENV:Detail", -2, a, type);
  if(!(return_value_soap_out_SOAP_ENV__Detail_1 == 0))
    return soap->error;

  else
  {
    signed int return_value_soap_putindependent_2;
    return_value_soap_putindependent_2=soap_putindependent(soap);
    return return_value_soap_putindependent_2;
  }
}

// soap_put_SOAP_ENV__Fault
// file soapC.c line 563
signed int soap_put_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
  signed int return_value_soap_out_SOAP_ENV__Fault_1;
  return_value_soap_out_SOAP_ENV__Fault_1=soap_out_SOAP_ENV__Fault(soap, tag != ((const char *)NULL) ? tag : "SOAP-ENV:Fault", -2, a, type);
  if(!(return_value_soap_out_SOAP_ENV__Fault_1 == 0))
    return soap->error;

  else
  {
    signed int return_value_soap_putindependent_2;
    return_value_soap_putindependent_2=soap_putindependent(soap);
    return return_value_soap_putindependent_2;
  }
}

// soap_put_SOAP_ENV__Header
// file soapC.c line 891
signed int soap_put_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
  signed int return_value_soap_out_SOAP_ENV__Header_1;
  return_value_soap_out_SOAP_ENV__Header_1=soap_out_SOAP_ENV__Header(soap, tag != ((const char *)NULL) ? tag : "SOAP-ENV:Header", -2, a, type);
  if(!(return_value_soap_out_SOAP_ENV__Header_1 == 0))
    return soap->error;

  else
  {
    signed int return_value_soap_putindependent_2;
    return_value_soap_putindependent_2=soap_putindependent(soap);
    return return_value_soap_putindependent_2;
  }
}

// soap_put_SOAP_ENV__Reason
// file soapC.c line 644
signed int soap_put_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
  signed int return_value_soap_out_SOAP_ENV__Reason_1;
  return_value_soap_out_SOAP_ENV__Reason_1=soap_out_SOAP_ENV__Reason(soap, tag != ((const char *)NULL) ? tag : "SOAP-ENV:Reason", -2, a, type);
  if(!(return_value_soap_out_SOAP_ENV__Reason_1 == 0))
    return soap->error;

  else
  {
    signed int return_value_soap_putindependent_2;
    return_value_soap_putindependent_2=soap_putindependent(soap);
    return return_value_soap_putindependent_2;
  }
}

// soap_put__QName
// file soapC.c line 1371
signed int soap_put__QName(struct soap *soap, char * const *a, const char *tag, const char *type)
{
  signed int return_value_soap_out__QName_1;
  return_value_soap_out__QName_1=soap_out__QName(soap, tag != ((const char *)NULL) ? tag : "QName", -2, a, type);
  if(!(return_value_soap_out__QName_1 == 0))
    return soap->error;

  else
  {
    signed int return_value_soap_putindependent_2;
    return_value_soap_putindependent_2=soap_putindependent(soap);
    return return_value_soap_putindependent_2;
  }
}

// soap_put_byte
// file soapC.c line 369
signed int soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
  signed int return_value_soap_out_byte_1;
  return_value_soap_out_byte_1=soap_out_byte(soap, tag != ((const char *)NULL) ? tag : "byte", -2, a, type);
  if(!(return_value_soap_out_byte_1 == 0))
    return soap->error;

  else
  {
    signed int return_value_soap_putindependent_2;
    return_value_soap_putindependent_2=soap_putindependent(soap);
    return return_value_soap_putindependent_2;
  }
}

// soap_put_int
// file soapC.c line 405
signed int soap_put_int(struct soap *soap, const signed int *a, const char *tag, const char *type)
{
  signed int return_value_soap_out_int_1;
  return_value_soap_out_int_1=soap_out_int(soap, tag != ((const char *)NULL) ? tag : "int", -2, a, type);
  if(!(return_value_soap_out_int_1 == 0))
    return soap->error;

  else
  {
    signed int return_value_soap_putindependent_2;
    return_value_soap_putindependent_2=soap_putindependent(soap);
    return return_value_soap_putindependent_2;
  }
}

// soap_put_string
// file soapC.c line 1415
signed int soap_put_string(struct soap *soap, char * const *a, const char *tag, const char *type)
{
  signed int return_value_soap_out_string_1;
  return_value_soap_out_string_1=soap_out_string(soap, tag != ((const char *)NULL) ? tag : "string", -2, a, type);
  if(!(return_value_soap_out_string_1 == 0))
    return soap->error;

  else
  {
    signed int return_value_soap_putindependent_2;
    return_value_soap_putindependent_2=soap_putindependent(soap);
    return return_value_soap_putindependent_2;
  }
}

// soap_put_t__Routing
// file soapC.c line 1106
signed int soap_put_t__Routing(struct soap *soap, struct t__Routing *a, const char *tag, const char *type)
{
  signed int return_value_soap_out_t__Routing_1;
  return_value_soap_out_t__Routing_1=soap_out_t__Routing(soap, tag != ((const char *)NULL) ? tag : "t:Routing", -2, a, type);
  if(!(return_value_soap_out_t__Routing_1 == 0))
    return soap->error;

  else
  {
    signed int return_value_soap_putindependent_2;
    return_value_soap_putindependent_2=soap_putindependent(soap);
    return return_value_soap_putindependent_2;
  }
}

// soap_put_t__RoutingTable
// file soapC.c line 1001
signed int soap_put_t__RoutingTable(struct soap *soap, struct t__RoutingTable *a, const char *tag, const char *type)
{
  signed int return_value_soap_out_t__RoutingTable_1;
  return_value_soap_out_t__RoutingTable_1=soap_out_t__RoutingTable(soap, tag != ((const char *)NULL) ? tag : "t:RoutingTable", -2, a, type);
  if(!(return_value_soap_out_t__RoutingTable_1 == 0))
    return soap->error;

  else
  {
    signed int return_value_soap_putindependent_2;
    return_value_soap_putindependent_2=soap_putindependent(soap);
    return return_value_soap_putindependent_2;
  }
}

// soap_putbase64
// file stdsoap2.c line 2001
signed int soap_putbase64(struct soap *soap, const unsigned char *s, signed int n)
{
  signed int i;
  unsigned long int m;
  char d[4l];
  if(s == ((const unsigned char *)NULL))
    return 0;

  else
  {
    for( ; n >= 3; s = s + (signed long int)3)
    {
      m = (unsigned long int)s[(signed long int)0];
      m = m << 8 | (unsigned long int)s[(signed long int)1];
      m = m << 8 | (unsigned long int)s[(signed long int)2];
      i = 4;
      for( ; i >= 1; m = m >> 6)
      {
        i = i - 1;
        d[(signed long int)i] = soap_base64o[(signed long int)(m & (unsigned long int)0x3F)];
      }
      signed int return_value_soap_send_raw_1;
      return_value_soap_send_raw_1=soap_send_raw(soap, d, (unsigned long int)4);
      if(!(return_value_soap_send_raw_1 == 0))
        return soap->error;

      n = n - 3;
    }
    if(n >= 1)
    {
      m = (unsigned long int)0;
      i = 0;
      for( ; !(i >= n); i = i + 1)
      {
        const unsigned char *tmp_post_2 = s;
        s = s + 1l;
        m = m << 8 | (unsigned long int)*tmp_post_2;
      }
      for( ; !(i >= 3); i = i + 1)
        m = m << 8;
      i = i + 1;
      for( ; i >= 1; m = m >> 6)
      {
        i = i - 1;
        d[(signed long int)i] = soap_base64o[(signed long int)(m & (unsigned long int)0x3F)];
      }
      i = 3;
      for( ; !(n >= i); i = i - 1)
        d[(signed long int)i] = (char)61;
      signed int return_value_soap_send_raw_3;
      return_value_soap_send_raw_3=soap_send_raw(soap, d, (unsigned long int)4);
      if(!(return_value_soap_send_raw_3 == 0))
        return soap->error;

    }

    return 0;
  }
}

// soap_putdime
// file stdsoap2.c line 15511
signed int soap_putdime(struct soap *soap)
{
  struct soap_multipart *content;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_8;
  signed int return_value_soap_putdimefield_2;
  signed int return_value_soap_putdimefield_11;
  if((0x00000080 & soap->mode) == 0)
    return 0;

  else
  {
    content = soap->dime.first;
    for( ; !(content == ((struct soap_multipart *)NULL)); content = content->next)
    {
      void *handle;
      soap->dime.size = content->size;
      soap->dime.id = content->id;
      soap->dime.type = content->type;
      soap->dime.options = content->options;
      soap->dime.flags = (char)(0x08 | 0x10);
      _Bool tmp_if_expr_14;
      if(!(soap->fdimereadopen == ((void * (*)(struct soap *, void *, const char *, const char *, const char *))NULL)))
      {
        handle=soap->fdimereadopen(soap, (void *)content->ptr, content->id, content->type, content->options);
        if(!(handle == NULL))
          tmp_if_expr_13 = (_Bool)1;

        else
          tmp_if_expr_13 = soap->error != 0 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr_14 = tmp_if_expr_13 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_14 = (_Bool)0;
      if(tmp_if_expr_14)
      {
        unsigned long int size = content->size;
        if(handle == NULL)
          return soap->error;

        _Bool tmp_if_expr_9;
        if(size == 0ul)
        {
          if(!((0x00000040 & soap->mode) == 0))
            tmp_if_expr_7 = (_Bool)1;

          else
            tmp_if_expr_7 = (soap->mode & 0x00000003) == 0x00000003 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_7)
            tmp_if_expr_8 = (_Bool)1;

          else
            tmp_if_expr_8 = (soap->mode & 0x00000003) == 0x00000002 ? (_Bool)1 : (_Bool)0;
          tmp_if_expr_9 = tmp_if_expr_8 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_9 = (_Bool)0;
        if(tmp_if_expr_9)
        {
          unsigned long int chunksize = sizeof(char [1024l]) /*1024ul*/ ;
          size=soap->fdimeread(soap, handle, soap->tmpbuf, chunksize);
          if(!(size >= chunksize))
          {
            soap->dime.flags = soap->dime.flags & (char)~0x01;
            if(content->next == ((struct soap_multipart *)NULL))
              soap->dime.flags = soap->dime.flags | (char)0x02;

          }

          else
            soap->dime.flags = soap->dime.flags | (char)0x01;
          soap->dime.size = size;
          signed int return_value_soap_putdimehdr_1;
          return_value_soap_putdimehdr_1=soap_putdimehdr(soap);
          _Bool tmp_if_expr_3;
          if(!(return_value_soap_putdimehdr_1 == 0))
            tmp_if_expr_3 = (_Bool)1;

          else
          {
            return_value_soap_putdimefield_2=soap_putdimefield(soap, soap->tmpbuf, size);
            tmp_if_expr_3 = return_value_soap_putdimefield_2 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(!tmp_if_expr_3)
          {
            if(!(soap->dime.id == ((const char *)NULL)))
            {
              soap->dime.flags = soap->dime.flags & (char)~(0x04 | 0x10);
              soap->dime.id = (const char *)(void *)0;
              soap->dime.type = (const char *)(void *)0;
              soap->dime.options = (const char *)(void *)0;
            }

          }

        }

        else
        {
          if(content->next == ((struct soap_multipart *)NULL))
            soap->dime.flags = soap->dime.flags | (char)0x02;

          signed int return_value_soap_putdimehdr_4;
          return_value_soap_putdimehdr_4=soap_putdimehdr(soap);
          if(!(return_value_soap_putdimehdr_4 == 0))
            return soap->error;

          unsigned long int bufsize;
          if(!(size >= sizeof(char [1024l]) /*1024ul*/ ))
            bufsize = size;

          else
            bufsize = sizeof(char [1024l]) /*1024ul*/ ;
          bufsize=soap->fdimeread(soap, handle, soap->tmpbuf, bufsize);
          if(bufsize == 0ul)
          {
            signed int tmp_if_expr_5;
            if(!(soap->error == 0))
              tmp_if_expr_5 = soap->error;

            else
              tmp_if_expr_5 = -1;
            soap->error = tmp_if_expr_5;
          }

          else
          {
            signed int return_value_soap_send_raw_6;
            return_value_soap_send_raw_6=soap_send_raw(soap, soap->tmpbuf, bufsize);
            if(return_value_soap_send_raw_6 == 0)
              size = size - bufsize;

          }
          soap_send_raw(soap, soap_padding, (unsigned long int)(-((signed long int)soap->dime.size) & (signed long int)3));
        }
        if(!(soap->fdimereadclose == ((void (*)(struct soap *, void *))NULL)))
          soap->fdimereadclose(soap, handle);

      }

      else
      {
        if(content->next == ((struct soap_multipart *)NULL))
          soap->dime.flags = soap->dime.flags | (char)0x02;

        signed int return_value_soap_putdimehdr_10;
        return_value_soap_putdimehdr_10=soap_putdimehdr(soap);
        _Bool tmp_if_expr_12;
        if(!(return_value_soap_putdimehdr_10 == 0))
          tmp_if_expr_12 = (_Bool)1;

        else
        {
          return_value_soap_putdimefield_11=soap_putdimefield(soap, (char *)content->ptr, content->size);
          tmp_if_expr_12 = return_value_soap_putdimefield_11 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_12)
          return soap->error;

      }
    }
    return 0;
  }
}

// soap_putdimefield
// file stdsoap2.c line 15425
static signed int soap_putdimefield(struct soap *soap, const char *s, unsigned long int n)
{
  signed int return_value_soap_send_raw_1;
  return_value_soap_send_raw_1=soap_send_raw(soap, s, n);
  if(!(return_value_soap_send_raw_1 == 0))
    return soap->error;

  else
  {
    signed int return_value_soap_send_raw_2;
    return_value_soap_send_raw_2=soap_send_raw(soap, soap_padding, (unsigned long int)(-((signed long int)n) & (signed long int)3));
    return return_value_soap_send_raw_2;
  }
}

// soap_putdimehdr
// file stdsoap2.c line 15466
signed int soap_putdimehdr(struct soap *soap)
{
  unsigned char tmp[12l];
  unsigned long int optlen = (unsigned long int)0;
  unsigned long int idlen = (unsigned long int)0;
  unsigned long int typelen = (unsigned long int)0;
  if(!(soap->dime.options == ((const char *)NULL)))
    optlen = (unsigned long int)(((signed int)(unsigned char)soap->dime.options[(signed long int)2] << 8 | (signed int)(unsigned char)soap->dime.options[(signed long int)3]) + 4);

  if(!(soap->dime.id == ((const char *)NULL)))
  {
    idlen=strlen(soap->dime.id);
    if(idlen >= 65536ul)
      idlen = (unsigned long int)0x0000FFFF;

  }

  if(!(soap->dime.type == ((const char *)NULL)))
  {
    typelen=strlen(soap->dime.type);
    if(typelen >= 65536ul)
      typelen = (unsigned long int)0x0000FFFF;

  }

  tmp[(signed long int)0] = (unsigned char)(0x08 | (signed int)soap->dime.flags & 0x7);
  tmp[(signed long int)1] = (unsigned char)((signed int)soap->dime.flags & 0xF0);
  tmp[(signed long int)2] = (unsigned char)(char)(optlen >> 8);
  tmp[(signed long int)3] = (unsigned char)(char)(optlen & (unsigned long int)0xFF);
  tmp[(signed long int)4] = (unsigned char)(char)(idlen >> 8);
  tmp[(signed long int)5] = (unsigned char)(char)(idlen & (unsigned long int)0xFF);
  tmp[(signed long int)6] = (unsigned char)(char)(typelen >> 8);
  tmp[(signed long int)7] = (unsigned char)(char)(typelen & (unsigned long int)0xFF);
  tmp[(signed long int)8] = (unsigned char)(char)(soap->dime.size >> 24);
  tmp[(signed long int)9] = (unsigned char)(char)(soap->dime.size >> 16 & (unsigned long int)0xFF);
  tmp[(signed long int)10] = (unsigned char)(char)(soap->dime.size >> 8 & (unsigned long int)0xFF);
  tmp[(signed long int)11] = (unsigned char)(char)(soap->dime.size & (unsigned long int)0xFF);
  signed int return_value_soap_send_raw_1;
  return_value_soap_send_raw_1=soap_send_raw(soap, (char *)tmp, (unsigned long int)12);
  _Bool tmp_if_expr_3;
  signed int return_value_soap_putdimefield_2;
  if(!(return_value_soap_send_raw_1 == 0))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_soap_putdimefield_2=soap_putdimefield(soap, soap->dime.options, optlen);
    tmp_if_expr_3 = return_value_soap_putdimefield_2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_5;
  signed int return_value_soap_putdimefield_4;
  if(tmp_if_expr_3)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_soap_putdimefield_4=soap_putdimefield(soap, soap->dime.id, idlen);
    tmp_if_expr_5 = return_value_soap_putdimefield_4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_7;
  signed int return_value_soap_putdimefield_6;
  if(tmp_if_expr_5)
    tmp_if_expr_7 = (_Bool)1;

  else
  {
    return_value_soap_putdimefield_6=soap_putdimefield(soap, soap->dime.type, typelen);
    tmp_if_expr_7 = return_value_soap_putdimefield_6 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_7)
    return soap->error;

  else
    return 0;
}

// soap_putelement
// file soapC.c line 301
signed int soap_putelement(struct soap *soap, const void *ptr, const char *tag, signed int id, signed int type)
{
  (void)tag;
  signed int return_value_soap_out_byte_1;
  signed int return_value_soap_out_int_2;
  signed int return_value_soap_out_t__RoutingTable_3;
  signed int return_value_soap_out_t__Routing_4;
  signed int return_value_soap_out_PointerTot__Routing_5;
  signed int return_value_soap_out_string_6;
  signed int return_value_soap_out_string_7;
  switch(type)
  {
    case 3:
    {
      return_value_soap_out_byte_1=soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
      return return_value_soap_out_byte_1;
    }
    case 1:
    {
      return_value_soap_out_int_2=soap_out_int(soap, tag, id, (const signed int *)ptr, "xsd:int");
      return return_value_soap_out_int_2;
    }
    case 8:
    {
      return_value_soap_out_t__RoutingTable_3=soap_out_t__RoutingTable(soap, tag, id, (struct t__RoutingTable *)ptr, "t:RoutingTable");
      return return_value_soap_out_t__RoutingTable_3;
    }
    case 7:
    {
      return_value_soap_out_t__Routing_4=soap_out_t__Routing(soap, tag, id, (struct t__Routing *)ptr, "t:Routing");
      return return_value_soap_out_t__Routing_4;
    }
    case 9:
    {
      return_value_soap_out_PointerTot__Routing_5=soap_out_PointerTot__Routing(soap, tag, id, (struct t__Routing * const *)ptr, "t:Routing");
      return return_value_soap_out_PointerTot__Routing_5;
    }
    case 5:
    {
      return_value_soap_out_string_6=soap_out_string(soap, tag, id, (char * const *)(void *)&ptr, "xsd:QName");
      return return_value_soap_out_string_6;
    }
    case 4:
    {
      return_value_soap_out_string_7=soap_out_string(soap, tag, id, (char * const *)(void *)&ptr, "xsd:string");
      return return_value_soap_out_string_7;
    }
    default:
      return 0;
  }
}

// soap_putfault
// file soapC.c line 87
signed int soap_putfault(struct soap *soap)
{
  signed int return_value_soap_put_SOAP_ENV__Fault_1;
  if(!(soap->fault == ((struct SOAP_ENV__Fault *)NULL)))
  {
    return_value_soap_put_SOAP_ENV__Fault_1=soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", (const char *)(void *)0);
    return return_value_soap_put_SOAP_ENV__Fault_1;
  }

  return 0;
}

// soap_putheader
// file soapC.c line 38
signed int soap_putheader(struct soap *soap)
{
  if(!(soap->version == 0))
  {
    if(!(soap->header == ((struct SOAP_ENV__Header *)NULL)))
    {
      soap->part = (signed short int)3;
      signed int return_value_soap_out_SOAP_ENV__Header_1;
      return_value_soap_out_SOAP_ENV__Header_1=soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, (const char *)(void *)0);
      if(!(return_value_soap_out_SOAP_ENV__Header_1 == 0))
        return soap->error;

      soap->part = (signed short int)4;
    }

  }

  return 0;
}

// soap_puthex
// file stdsoap2.c line 1882
signed int soap_puthex(struct soap *soap, const unsigned char *s, signed int n)
{
  char d[2l];
  signed int i = 0;
  for( ; !(i >= n); i = i + 1)
  {
    signed int m;
    const unsigned char *tmp_post_1 = s;
    s = s + 1l;
    m = (signed int)*tmp_post_1;
    d[(signed long int)0] = (char)((m >> 4) + (m > 159 ? 55 : 48));
    m = m & 0x0F;
    d[(signed long int)1] = (char)(m + (m > 9 ? 55 : 48));
    signed int return_value_soap_send_raw_2;
    return_value_soap_send_raw_2=soap_send_raw(soap, d, (unsigned long int)2);
    if(!(return_value_soap_send_raw_2 == 0))
      return soap->error;

  }
  return 0;
}

// soap_puthttphdr
// file stdsoap2.c line 17515
signed int soap_puthttphdr(struct soap *soap, signed int status, unsigned long int count)
{
  char *return_value_strchr_5;
  char *return_value_strchr_7;
  signed int tmp_if_expr_9;
  signed int tmp_if_expr_10;
  if(!(soap->status == 2002))
  {
    if(!(soap->status == 2004))
    {
      if(!(soap->status == 2005))
      {
        const char *s = "text/xml; charset=utf-8";
        signed int err = 0;
        const char *r = (const char *)(void *)0;
        unsigned long int n;
        _Bool tmp_if_expr_2;
        if(status == 1003)
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = soap->status == 2003 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr_3;
        if(tmp_if_expr_2)
          tmp_if_expr_3 = (_Bool)1;

        else
          tmp_if_expr_3 = soap->status == 2001 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr_4;
        if(tmp_if_expr_3)
          tmp_if_expr_4 = soap->http_content != ((const char *)NULL) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        _Bool tmp_if_expr_6;
        if(tmp_if_expr_4)
        {
          return_value_strchr_5=strchr(s, 10);
          tmp_if_expr_6 = !(return_value_strchr_5 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_6 = (_Bool)0;
        _Bool tmp_if_expr_8;
        if(tmp_if_expr_6)
        {
          return_value_strchr_7=strchr(s, 13);
          tmp_if_expr_8 = !(return_value_strchr_7 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_8 = (_Bool)0;
        if(tmp_if_expr_8)
          s = soap->http_content;

        else
          if(status == 1002)
            s = "text/html; charset=utf-8";

          else
          {
            _Bool tmp_if_expr_1;
            if(!(count == 0ul))
              tmp_if_expr_1 = (_Bool)1;

            else
              tmp_if_expr_1 = (soap->omode & 0x00000003) == 0x00000003 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_1)
            {
              if((signed int)soap->version == 2)
                s = "application/soap+xml; charset=utf-8";

            }

          }
        if(!((640 & soap->mode) == 0))
        {
          if(!((0x00000200 & soap->mode) == 0))
          {
            if((signed int)soap->version == 2)
              r = "application/soap+xml";

            else
              r = "text/xml";
            s = "application/xop+xml";
          }

          else
            s = "application/dime";
        }

        _Bool tmp_if_expr_11;
        if(!((0x00000100 & soap->mode) == 0))
          tmp_if_expr_11 = soap->mime.boundary != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_11 = (_Bool)0;
        if(tmp_if_expr_11)
        {
          const char *t;
          unsigned long int l;
          n=strlen(soap->mime.boundary);
          snprintf(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , "multipart/related; charset=utf-8; boundary=\"%s\"; type=\"", soap->mime.boundary);
          t=strchr(s, 59);
          if(!(t == ((const char *)NULL)))
            n = (unsigned long int)(t - s);

          else
            n=strlen(s);
          l=strlen(soap->tmpbuf);
          if(!(n >= sizeof(char [1024l]) /*1024ul*/  + -l))
          {
            if(!(soap->tmpbuf + (signed long int)l == ((char *)NULL)))
            {
              if(!(n >= sizeof(char [1024l]) /*1024ul*/  + -l))
              {
                strncpy(soap->tmpbuf + (signed long int)l, s, n);
                (soap->tmpbuf + (signed long int)l)[(signed long int)(unsigned long int)n] = (char)0;
                tmp_if_expr_9 = (signed int)(soap->tmpbuf + (signed long int)l)[(signed long int)(unsigned long int)n];
              }

              else
              {
                (soap->tmpbuf + (signed long int)l)[(signed long int)0] = (char)0;
                tmp_if_expr_9 = (signed int)(soap->tmpbuf + (signed long int)l)[(signed long int)0];
              }
              if(!(tmp_if_expr_9 == 0))
                (_Bool)1;

              else
                (_Bool)0;
            }

            else
              (_Bool)0;
          }

          if(!(soap->mime.start == ((const char *)NULL)))
          {
            l=strlen(soap->tmpbuf);
            n=strlen(soap->mime.start);
            snprintf(soap->tmpbuf + (signed long int)l, sizeof(char [1024l]) /*1024ul*/  - l, "\"; start=\"%s", soap->mime.start);
          }

          if(!(r == ((const char *)NULL)))
          {
            l=strlen(soap->tmpbuf);
            n=strlen(r);
            snprintf(soap->tmpbuf + (signed long int)l, sizeof(char [1024l]) /*1024ul*/  - l, "\"; start-info=\"%s", r);
          }

          l=strlen(soap->tmpbuf);
          if(sizeof(char [1024l]) /*1024ul*/  + -l >= 2ul)
          {
            if(!(soap->tmpbuf + (signed long int)l == ((char *)NULL)))
            {
              if(sizeof(char [1024l]) /*1024ul*/  + -l >= 2ul)
              {
                strncpy(soap->tmpbuf + (signed long int)l, "\"", (unsigned long int)1);
                (soap->tmpbuf + (signed long int)l)[(signed long int)(unsigned long int)1] = (char)0;
                tmp_if_expr_10 = (signed int)(soap->tmpbuf + (signed long int)l)[(signed long int)(unsigned long int)1];
              }

              else
              {
                (soap->tmpbuf + (signed long int)l)[(signed long int)0] = (char)0;
                tmp_if_expr_10 = (signed int)(soap->tmpbuf + (signed long int)l)[(signed long int)0];
              }
              if(!(tmp_if_expr_10 == 0))
                (_Bool)1;

              else
                (_Bool)0;
            }

            else
              (_Bool)0;
          }

        }

        else
        {
          strncpy(soap->tmpbuf, s, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
          soap->tmpbuf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
          (void)(soap->tmpbuf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
        }
        if(status == 0)
        {
          if((signed int)soap->version == 2)
          {
            if(!(soap->action == ((char *)NULL)))
            {
              unsigned long int soap_puthttphdr__1__1__4__l;
              soap_puthttphdr__1__1__4__l=strlen(soap->tmpbuf);
              snprintf(soap->tmpbuf + (signed long int)soap_puthttphdr__1__1__4__l, sizeof(char [1024l]) /*1024ul*/  - soap_puthttphdr__1__1__4__l, "; action=\"%s\"", soap->action);
            }

          }

        }

        err=soap->fposthdr(soap, "Content-Type", soap->tmpbuf);
        if(!(err == 0))
          return err;

        if((0x00000003 & soap->omode) == 0x00000003)
          err=soap->fposthdr(soap, "Transfer-Encoding", "chunked");

        else
        {
          snprintf(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , "%lu", (unsigned long int)count);
          err=soap->fposthdr(soap, "Content-Length", soap->tmpbuf);
        }
        if(!(err == 0))
          return err;

      }

    }

  }

  signed int return_value;
  return_value=soap->fposthdr(soap, "Connection", soap->keep_alive != 0 ? "keep-alive" : "close");
  return return_value;
}

// soap_putindependent
// file soapC.c line 288
signed int soap_putindependent(struct soap *soap)
{
  signed int i;
  struct soap_plist *pp;
  signed int return_value_soap_putelement_1;
  if((signed int)soap->version == 1)
  {
    if(!(soap->encodingStyle == ((const char *)NULL)))
    {
      if((537001984 & soap->mode) == 0)
      {
        i = 0;
        for( ; !(i >= 4096); i = i + 1)
        {
          pp = soap->pht[(signed long int)i];
          for( ; !(pp == ((struct soap_plist *)NULL)); pp = pp->next)
          {
            _Bool tmp_if_expr_2;
            if((signed int)pp->mark1 == 2)
              tmp_if_expr_2 = (_Bool)1;

            else
              tmp_if_expr_2 = (signed int)pp->mark2 == 2 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_2)
            {
              return_value_soap_putelement_1=soap_putelement(soap, pp->ptr, "id", pp->id, pp->type);
              if(!(return_value_soap_putelement_1 == 0))
                return soap->error;

            }

          }
        }
      }

    }

  }

  return 0;
}

// soap_putmime
// file stdsoap2.c line 16124
signed int soap_putmime(struct soap *soap)
{
  struct soap_multipart *content;
  _Bool tmp_if_expr_1;
  if((0x00000100 & soap->mode) == 0)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(soap->mime.boundary != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_10;
  signed int return_value_soap_send_raw_8;
  if(tmp_if_expr_1)
    return 0;

  else
  {
    content = soap->mime.first;
    for( ; !(content == ((struct soap_multipart *)NULL)); content = content->next)
    {
      void *handle;
      _Bool tmp_if_expr_11;
      if(!(soap->fmimereadopen == ((void * (*)(struct soap *, void *, const char *, const char *, const char *))NULL)))
      {
        handle=soap->fmimereadopen(soap, (void *)content->ptr, content->id, content->type, content->description);
        if(!(handle == NULL))
          tmp_if_expr_10 = (_Bool)1;

        else
          tmp_if_expr_10 = soap->error != 0 ? (_Bool)1 : (_Bool)0;
        tmp_if_expr_11 = tmp_if_expr_10 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_11 = (_Bool)0;
      if(tmp_if_expr_11)
      {
        unsigned long int size = content->size;
        if(handle == NULL)
          return soap->error;

        signed int return_value_soap_putmimehdr_2;
        return_value_soap_putmimehdr_2=soap_putmimehdr(soap, content);
        if(!(return_value_soap_putmimehdr_2 == 0))
          return soap->error;

        if(size == 0ul)
        {
          _Bool tmp_if_expr_4;
          if(!((0x00000040 & soap->mode) == 0))
            tmp_if_expr_4 = (_Bool)1;

          else
            tmp_if_expr_4 = (soap->mode & 0x00000003) == 0x00000003 ? (_Bool)1 : (_Bool)0;
          _Bool tmp_if_expr_5;
          if(tmp_if_expr_4)
            tmp_if_expr_5 = (_Bool)1;

          else
            tmp_if_expr_5 = (soap->mode & 0x00000003) == 0x00000002 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_5)
          {
            size=soap->fmimeread(soap, handle, soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ );
            signed int return_value_soap_send_raw_3;
            return_value_soap_send_raw_3=soap_send_raw(soap, soap->tmpbuf, size);
          }

        }

        else
        {
          unsigned long int bufsize;
          if(!(size >= sizeof(char [1024l]) /*1024ul*/ ))
            bufsize = size;

          else
            bufsize = sizeof(char [1024l]) /*1024ul*/ ;
          bufsize=soap->fmimeread(soap, handle, soap->tmpbuf, bufsize);
          if(bufsize == 0ul)
            soap->error = -1;

          else
          {
            signed int return_value_soap_send_raw_6;
            return_value_soap_send_raw_6=soap_send_raw(soap, soap->tmpbuf, bufsize);
            if(return_value_soap_send_raw_6 == 0)
              size = size - bufsize;

          }
        }
        if(!(soap->fmimereadclose == ((void (*)(struct soap *, void *))NULL)))
          soap->fmimereadclose(soap, handle);

      }

      else
      {
        signed int return_value_soap_putmimehdr_7;
        return_value_soap_putmimehdr_7=soap_putmimehdr(soap, content);
        _Bool tmp_if_expr_9;
        if(!(return_value_soap_putmimehdr_7 == 0))
          tmp_if_expr_9 = (_Bool)1;

        else
        {
          return_value_soap_send_raw_8=soap_send_raw(soap, content->ptr, content->size);
          tmp_if_expr_9 = return_value_soap_send_raw_8 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_9)
          return soap->error;

      }
    }
    signed int return_value_soap_send3_12;
    return_value_soap_send3_12=soap_send3(soap, "\r\n--", soap->mime.boundary, "--");
    return return_value_soap_send3_12;
  }
}

// soap_putmimehdr
// file stdsoap2.c line 16096
signed int soap_putmimehdr(struct soap *soap, struct soap_multipart *content)
{
  const char *s;
  signed int return_value_soap_send3_1;
  return_value_soap_send3_1=soap_send3(soap, "\r\n--", soap->mime.boundary, "\r\n");
  signed int return_value_soap_send3_2;
  signed int return_value_soap_send3_3;
  signed int return_value_soap_send3_4;
  signed int return_value_soap_send3_5;
  signed int return_value_soap_send3_6;
  if(!(return_value_soap_send3_1 == 0))
    return soap->error;

  else
  {
    if(!(content->type == ((const char *)NULL)))
    {
      return_value_soap_send3_2=soap_send3(soap, "Content-Type: ", content->type, "\r\n");
      if(!(return_value_soap_send3_2 == 0))
        return soap->error;

    }

    s=soap_code_str(mime_codes, (signed long int)content->encoding);
    if(!(s == ((const char *)NULL)))
    {
      return_value_soap_send3_3=soap_send3(soap, "Content-Transfer-Encoding: ", s, "\r\n");
      if(!(return_value_soap_send3_3 == 0))
        return soap->error;

    }

    if(!(content->id == ((const char *)NULL)))
    {
      return_value_soap_send3_4=soap_send3(soap, "Content-ID: ", content->id, "\r\n");
      if(!(return_value_soap_send3_4 == 0))
        return soap->error;

    }

    if(!(content->location == ((const char *)NULL)))
    {
      return_value_soap_send3_5=soap_send3(soap, "Content-Location: ", content->location, "\r\n");
      if(!(return_value_soap_send3_5 == 0))
        return soap->error;

    }

    if(!(content->description == ((const char *)NULL)))
    {
      return_value_soap_send3_6=soap_send3(soap, "Content-Description: ", content->description, "\r\n");
      if(!(return_value_soap_send3_6 == 0))
        return soap->error;

    }

    signed int return_value_soap_send_raw_7;
    return_value_soap_send_raw_7=soap_send_raw(soap, "\r\n", (unsigned long int)2);
    return return_value_soap_send_raw_7;
  }
}

// soap_putoffsets
// file stdsoap2.c line 2798
char * soap_putoffsets(struct soap *soap, const signed int *offset, signed int dim)
{
  signed int i;
  soap->arrayOffset[(signed long int)0] = (char)0;
  if((signed int)soap->version == 1)
  {
    snprintf(soap->arrayOffset, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1, "[%d", offset[(signed long int)0]);
    i = 1;
    for( ; !(i >= dim); i = i + 1)
    {
      unsigned long int l;
      l=strlen(soap->arrayOffset);
      snprintf(soap->arrayOffset + (signed long int)l, (sizeof(char [1024l]) /*1024ul*/  - l) - (unsigned long int)1, ",%d", offset[(signed long int)i]);
    }
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(soap->arrayOffset);
    signed int tmp_if_expr_2;
    if(!(1ul + return_value_strlen_1 >= sizeof(char [1024l]) /*1024ul*/ ))
    {
      strncat(soap->arrayOffset, "]", (unsigned long int)1);
      soap->arrayOffset[(signed long int)((unsigned long int)sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
      tmp_if_expr_2 = (signed int)soap->arrayOffset[(signed long int)((unsigned long int)sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)];
    }

    else
    {
      soap->arrayOffset[(signed long int)0] = (char)0;
      tmp_if_expr_2 = (signed int)soap->arrayOffset[(signed long int)0];
    }
    (void)(tmp_if_expr_2 != 0 ? (_Bool)1 : (_Bool)0);
  }

  return soap->arrayOffset;
}

// soap_putsizesoffsets
// file stdsoap2.c line 2766
char * soap_putsizesoffsets(struct soap *soap, const char *type, const signed int *size, const signed int *offset, signed int dim)
{
  signed int i;
  const char *t = ",%d";
  if(type == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    if((signed int)soap->version == 2)
      t = " %d";

    if(!(offset == ((const signed int *)NULL)) && !((signed int)soap->version == 2))
    {
      snprintf(soap->type, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1, "%s[%d", type, size[(signed long int)0] + offset[(signed long int)0]);
      i = 1;
      for( ; !(i >= dim); i = i + 1)
      {
        unsigned long int l;
        l=strlen(soap->type);
        snprintf(soap->type + (signed long int)l, (sizeof(char [1024l]) /*1024ul*/  - l) - (unsigned long int)1, t, size[(signed long int)i] + offset[(signed long int)i]);
      }
    }

    else
    {
      snprintf(soap->type, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1, "%s[%d", type, size[(signed long int)0]);
      i = 1;
      for( ; !(i >= dim); i = i + 1)
      {
        unsigned long int soap_putsizesoffsets__1__2__1__1__l;
        soap_putsizesoffsets__1__2__1__1__l=strlen(soap->type);
        snprintf(soap->type + (signed long int)soap_putsizesoffsets__1__2__1__1__l, (sizeof(char [1024l]) /*1024ul*/  - soap_putsizesoffsets__1__2__1__1__l) - (unsigned long int)1, t, size[(signed long int)i]);
      }
    }
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(soap->type);
    signed int tmp_if_expr_2;
    if(!(1ul + return_value_strlen_1 >= sizeof(char [1024l]) /*1024ul*/ ))
    {
      strncat(soap->type, "]", (unsigned long int)1);
      soap->type[(signed long int)((unsigned long int)sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
      tmp_if_expr_2 = (signed int)soap->type[(signed long int)((unsigned long int)sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)];
    }

    else
    {
      soap->type[(signed long int)0] = (char)0;
      tmp_if_expr_2 = (signed int)soap->type[(signed long int)0];
    }
    (void)(tmp_if_expr_2 != 0 ? (_Bool)1 : (_Bool)0);
    return soap->type;
  }
}

// soap_pututf8
// file stdsoap2.c line 1781
signed int soap_pututf8(struct soap *soap, unsigned long int c)
{
  char tmp[24l];
  if(c >= 32ul && !(c >= 127ul))
  {
    tmp[0l] = (char)c;
    signed int return_value_soap_send_raw_1;
    return_value_soap_send_raw_1=soap_send_raw(soap, tmp, (unsigned long int)1);
    return return_value_soap_send_raw_1;
  }

  if(c >= 160ul)
  {
    char *t = tmp;
    if(!(c >= 2048ul))
    {
      char *tmp_post_2 = t;
      t = t + 1l;
      *tmp_post_2 = (char)((unsigned long int)0xC0 | c >> 6 & (unsigned long int)0x1F);
    }

    else
    {
      if(!(c >= 65536ul))
      {
        char *tmp_post_3 = t;
        t = t + 1l;
        *tmp_post_3 = (char)((unsigned long int)0xE0 | c >> 12 & (unsigned long int)0x0F);
      }

      else
      {
        if(!(c >= 2097152ul))
        {
          char *tmp_post_4 = t;
          t = t + 1l;
          *tmp_post_4 = (char)((unsigned long int)0xF0 | c >> 18 & (unsigned long int)0x07);
        }

        else
        {
          if(!(c >= 67108864ul))
          {
            char *tmp_post_5 = t;
            t = t + 1l;
            *tmp_post_5 = (char)((unsigned long int)0xF8 | c >> 24 & (unsigned long int)0x03);
          }

          else
          {
            char *tmp_post_6 = t;
            t = t + 1l;
            *tmp_post_6 = (char)((unsigned long int)0xFC | c >> 30 & (unsigned long int)0x01);
            char *tmp_post_7 = t;
            t = t + 1l;
            *tmp_post_7 = (char)((unsigned long int)0x80 | c >> 24 & (unsigned long int)0x3F);
          }
          char *tmp_post_8 = t;
          t = t + 1l;
          *tmp_post_8 = (char)((unsigned long int)0x80 | c >> 18 & (unsigned long int)0x3F);
        }
        char *tmp_post_9 = t;
        t = t + 1l;
        *tmp_post_9 = (char)((unsigned long int)0x80 | c >> 12 & (unsigned long int)0x3F);
      }
      char *tmp_post_10 = t;
      t = t + 1l;
      *tmp_post_10 = (char)((unsigned long int)0x80 | c >> 6 & (unsigned long int)0x3F);
    }
    char *tmp_post_11 = t;
    t = t + 1l;
    *tmp_post_11 = (char)((unsigned long int)0x80 | c & (unsigned long int)0x3F);
    *t = (char)0;
  }

  else
    snprintf(tmp, sizeof(char [24l]) /*24ul*/ , "&#x%lX;", c);
  signed int return_value_soap_send_12;
  return_value_soap_send_12=soap_send(soap, tmp);
  return return_value_soap_send_12;
}

// soap_receiver_fault
// file stdsoap2.c line 18191
signed int soap_receiver_fault(struct soap *soap, const char *faultstring, const char *faultdetailXML)
{
  signed int return_value_soap_receiver_fault_subcode_1;
  return_value_soap_receiver_fault_subcode_1=soap_receiver_fault_subcode(soap, (const char *)(void *)0, faultstring, faultdetailXML);
  return return_value_soap_receiver_fault_subcode_1;
}

// soap_receiver_fault_subcode
// file stdsoap2.c line 18202
signed int soap_receiver_fault_subcode(struct soap *soap, const char *faultsubcodeQName, const char *faultstring, const char *faultdetailXML)
{
  char *tmp_if_expr_1;
  if((signed int)soap->version == 2)
    tmp_if_expr_1 = "SOAP-ENV:Receiver";

  else
    tmp_if_expr_1 = (signed int)soap->version == 1 ? "SOAP-ENV:Server" : "is internal";
  signed int return_value_soap_copy_fault_2;
  return_value_soap_copy_fault_2=soap_copy_fault(soap, tmp_if_expr_1, faultsubcodeQName, faultstring, faultdetailXML);
  return return_value_soap_copy_fault_2;
}

// soap_recv
// file ../../../gsoap/stdsoap2.h line 2949
signed int soap_recv(struct soap *soap)
{
  signed int return_value_soap_recv_raw_1;
  signed int return_value_soap_recv_raw_4;
  if(!((0x00000080 & soap->mode) == 0))
  {
    if(!(soap->dime.buflen == 0ul))
    {
      char *s;
      signed int i;
      unsigned char tmp[12l];
      soap->count = soap->count + (soap->dime.buflen - soap->buflen);
      soap->buflen = soap->dime.buflen;
      i = (signed int)(-((signed long int)soap->dime.size) & (signed long int)3);
      for( ; i >= 1; i = i - 1)
      {
        soap->bufidx = soap->bufidx + 1ul;
        if(soap->bufidx >= soap->buflen)
        {
          return_value_soap_recv_raw_1=soap_recv_raw(soap);
          if(!(return_value_soap_recv_raw_1 == 0))
            return -1;

        }

      }
      s = (char *)tmp;
      i = 12;
      for( ; i >= 1; i = i - 1)
      {
        char *tmp_post_2 = s;
        s = s + 1l;
        unsigned long int tmp_post_3 = soap->bufidx;
        soap->bufidx = soap->bufidx + 1ul;
        *tmp_post_2 = soap->buf[(signed long int)tmp_post_3];
        if(soap->bufidx >= soap->buflen)
        {
          return_value_soap_recv_raw_4=soap_recv_raw(soap);
          if(!(return_value_soap_recv_raw_4 == 0))
            return -1;

        }

      }
      soap->dime.flags = (char)((signed int)tmp[(signed long int)0] & 0x7);
      soap->dime.size = (unsigned long int)tmp[(signed long int)8] << 24 | (unsigned long int)tmp[(signed long int)9] << 16 | (unsigned long int)tmp[(signed long int)10] << 8 | (unsigned long int)tmp[(signed long int)11];
      if(!((0x01 & (signed int)soap->dime.flags) == 0))
      {
        soap->dime.chunksize = soap->dime.size;
        if(soap->buflen + -soap->bufidx >= soap->dime.size)
        {
          soap->dime.buflen = soap->buflen;
          soap->buflen = soap->bufidx + soap->dime.chunksize;
        }

        else
          soap->dime.chunksize = soap->dime.chunksize - (soap->buflen - soap->bufidx);
      }

      else
      {
        soap->dime.buflen = (unsigned long int)0;
        soap->dime.chunksize = (unsigned long int)0;
      }
      soap->count = soap->buflen - soap->bufidx;
      return 0;
    }

    if(!(soap->dime.chunksize == 0ul))
    {
      signed int return_value_soap_recv_raw_5;
      return_value_soap_recv_raw_5=soap_recv_raw(soap);
      if(!(return_value_soap_recv_raw_5 == 0))
        return -1;

      if(soap->buflen + -soap->bufidx >= soap->dime.chunksize)
      {
        soap->dime.buflen = soap->buflen;
        soap->count = soap->count - ((soap->buflen - soap->bufidx) - soap->dime.chunksize);
        soap->buflen = soap->bufidx + soap->dime.chunksize;
      }

      else
        soap->dime.chunksize = soap->dime.chunksize - (soap->buflen - soap->bufidx);
      return 0;
    }

  }

  if(!(soap->ffilterrecv == ((signed int (*)(struct soap *, char *, unsigned long int *, unsigned long int))NULL)))
  {
    signed int err;
    if(!(soap->recverror == 0))
    {
      soap->buflen = (unsigned long int)0;
      soap->bufidx = soap->buflen;
    }

    else
    {
      soap->recverror=soap_recv_raw(soap);
      soap->buflen = soap->buflen - soap->bufidx;
    }
    err=soap->ffilterrecv(soap, soap->buf + (signed long int)soap->bufidx, &soap->buflen, sizeof(char [65536l]) /*65536ul*/  - soap->bufidx);
    if(!(err == 0))
    {
      soap->error = err;
      return soap->error;
    }

    if(!(soap->buflen == 0ul))
    {
      soap->buflen = soap->buflen + soap->bufidx;
      return 0;
    }

    if(!(soap->recverror == 0))
      return soap->recverror;

  }

  soap->recverror=soap_recv_raw(soap);
  return soap->recverror;
}

// soap_recv_empty_response
// file stdsoap2.c line 18005
signed int soap_recv_empty_response(struct soap *soap)
{
  signed int return_value_soap_envelope_begin_in_3;
  signed int return_value_soap_recv_header_5;
  signed int return_value_soap_body_begin_in_7;
  signed int return_value_soap_recv_fault_1;
  if((0x00000004 & soap->omode) == 0)
  {
    signed int return_value_soap_begin_recv_11;
    return_value_soap_begin_recv_11=soap_begin_recv(soap);
    if(return_value_soap_begin_recv_11 == 0)
    {
      if(!(soap->body == 0))
      {
        _Bool tmp_if_expr_2;
        if(!(soap->status == 400))
          tmp_if_expr_2 = soap->status != 500 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        _Bool tmp_if_expr_4;
        if(tmp_if_expr_2)
          tmp_if_expr_4 = (_Bool)1;

        else
        {
          return_value_soap_envelope_begin_in_3=soap_envelope_begin_in(soap);
          tmp_if_expr_4 = return_value_soap_envelope_begin_in_3 != 0 ? (_Bool)1 : (_Bool)0;
        }
        _Bool tmp_if_expr_6;
        if(tmp_if_expr_4)
          tmp_if_expr_6 = (_Bool)1;

        else
        {
          return_value_soap_recv_header_5=soap_recv_header(soap);
          tmp_if_expr_6 = return_value_soap_recv_header_5 != 0 ? (_Bool)1 : (_Bool)0;
        }
        _Bool tmp_if_expr_8;
        if(tmp_if_expr_6)
          tmp_if_expr_8 = (_Bool)1;

        else
        {
          return_value_soap_body_begin_in_7=soap_body_begin_in(soap);
          tmp_if_expr_8 = return_value_soap_body_begin_in_7 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_8)
        {
          const char *s;
          s=soap_get_http_body(soap, (unsigned long int *)(void *)0);
          soap_end_recv(soap);
          if(!(s == ((const char *)NULL)))
            soap_set_receiver_error(soap, "HTTP Error", s, soap->status);

        }

        else
        {
          return_value_soap_recv_fault_1=soap_recv_fault(soap, 1);
          return return_value_soap_recv_fault_1;
        }
      }

      else
        soap_end_recv(soap);
    }

    else
    {
      _Bool tmp_if_expr_9;
      if(soap->error == 14)
        tmp_if_expr_9 = (_Bool)1;

      else
        tmp_if_expr_9 = soap->error == 200 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr_10;
      if(tmp_if_expr_9)
        tmp_if_expr_10 = (_Bool)1;

      else
        tmp_if_expr_10 = soap->error == 202 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_10)
        soap->error = 0;

    }
  }

  signed int return_value_soap_closesock_12;
  return_value_soap_closesock_12=soap_closesock(soap);
  return return_value_soap_closesock_12;
}

// soap_recv_fault
// file stdsoap2.c line 17925
signed int soap_recv_fault(struct soap *soap, signed int check)
{
  signed int status = soap->status;
  if(check == 0)
  {
    if(!(soap->error == 6))
    {
      _Bool tmp_if_expr_1;
      if(!(soap->error == 3))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = soap->level != (unsigned int)2 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
        return soap->error;

    }

  }

  else
    if((signed int)soap->version == 0)
      return 0;

  soap->error = 0;
  signed int return_value_soap_getfault_13;
  return_value_soap_getfault_13=soap_getfault(soap);
  signed int return_value_soap_match_tag_10;
  signed int return_value_soap_match_tag_6;
  signed int return_value_soap_match_tag_7;
  signed int return_value_soap_match_tag_5;
  signed int return_value_soap_match_tag_4;
  if(!(return_value_soap_getfault_13 == 0))
  {
    if(!(check == 0))
    {
      if(soap->error == 3)
      {
        if(soap->level == 2u)
        {
          soap->error = 0;
          return soap->error;
        }

      }

    }

    const char **return_value_soap_faultcode_2;
    return_value_soap_faultcode_2=soap_faultcode(soap);
    *return_value_soap_faultcode_2 = (signed int)soap->version == 2 ? "SOAP-ENV:Sender" : "SOAP-ENV:Client";
    if(!(status == 0))
      soap->error = status;

    else
    {
      status = 14;
      soap->error = status;
    }
    soap_set_fault(soap);
  }

  else
  {
    const char *s;
    const char **return_value_soap_faultcode_3;
    return_value_soap_faultcode_3=soap_faultcode(soap);
    s = *return_value_soap_faultcode_3;
    signed int return_value_soap_match_tag_9;
    return_value_soap_match_tag_9=soap_match_tag(soap, s, "SOAP-ENV:Server");
    _Bool tmp_if_expr_11;
    if(return_value_soap_match_tag_9 == 0)
      tmp_if_expr_11 = (_Bool)1;

    else
    {
      return_value_soap_match_tag_10=soap_match_tag(soap, s, "SOAP-ENV:Receiver");
      tmp_if_expr_11 = !(return_value_soap_match_tag_10 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_11)
      status = 2;

    else
    {
      return_value_soap_match_tag_6=soap_match_tag(soap, s, "SOAP-ENV:Client");
      _Bool tmp_if_expr_8;
      if(return_value_soap_match_tag_6 == 0)
        tmp_if_expr_8 = (_Bool)1;

      else
      {
        return_value_soap_match_tag_7=soap_match_tag(soap, s, "SOAP-ENV:Sender");
        tmp_if_expr_8 = !(return_value_soap_match_tag_7 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_8)
        status = 1;

      else
      {
        return_value_soap_match_tag_5=soap_match_tag(soap, s, "SOAP-ENV:MustUnderstand");
        if(return_value_soap_match_tag_5 == 0)
          status = 8;

        else
        {
          return_value_soap_match_tag_4=soap_match_tag(soap, s, "SOAP-ENV:VersionMismatch");
          if(return_value_soap_match_tag_4 == 0)
            status = 39;

          else
            status = 12;
        }
      }
    }
    signed int return_value_soap_body_end_in_12;
    return_value_soap_body_end_in_12=soap_body_end_in(soap);
    if(return_value_soap_body_end_in_12 == 0)
      soap_envelope_end_in(soap);

  }
  soap_end_recv(soap);
  soap->error = status;
  signed int return_value_soap_closesock_14;
  return_value_soap_closesock_14=soap_closesock(soap);
  return return_value_soap_closesock_14;
}

// soap_recv_header
// file stdsoap2.c line 17032
signed int soap_recv_header(struct soap *soap)
{
  signed int return_value_soap_getheader_1;
  return_value_soap_getheader_1=soap_getheader(soap);
  if(!(return_value_soap_getheader_1 == 0))
  {
    if(soap->error == 3)
      soap->error = 0;

  }

  if(soap->error == 0)
  {
    if(!(soap->fheader == ((signed int (*)(struct soap *))NULL)))
      soap->error=soap->fheader(soap);

  }

  return soap->error;
}

// soap_recv_raw
// file ../../../gsoap/stdsoap2.h line 2948
signed int soap_recv_raw(struct soap *soap)
{
  unsigned long int ret;
  signed int r;
  signed int return_value_soap_isxdigit_2;
  signed int return_value_soap_isxdigit_3;
  _Bool tmp_if_expr_4;
  if((0x00000003 & soap->mode) == 0x00000003)
    do
    {
      signed int c;
      char *t;
      char tmp[17l];
      if(!(soap->chunksize == 0ul))
      {
        unsigned long int tmp_if_expr_1;
        if(soap->chunksize >= 65537ul)
          tmp_if_expr_1 = sizeof(char [65536l]) /*65536ul*/ ;

        else
          tmp_if_expr_1 = soap->chunksize;
        ret=soap->frecv(soap, soap->buf, tmp_if_expr_1);
        soap->buflen = ret;
        soap->bufidx = (unsigned long int)0;
        soap->chunksize = soap->chunksize - ret;
        break;
      }

      t = tmp;
      if(soap->chunkbuflen == 0ul)
      {
        ret=soap->frecv(soap, soap->buf, sizeof(char [65536l]) /*65536ul*/ );
        soap->chunkbuflen = ret;
        soap->bufidx = (unsigned long int)0;
        if(ret == 0ul)
        {
          soap->ahead = -1;
          return -1;
        }

      }

      else
        soap->bufidx = soap->buflen;
      soap->buflen = soap->chunkbuflen;
      do
      {
        c=soap_getchunkchar(soap);
        return_value_soap_isxdigit_2=soap_isxdigit((signed int)c);
        if(!(return_value_soap_isxdigit_2 == 0))
          break;

        if(c == -1)
        {
          soap->ahead = -1;
          return -1;
        }

      }
      while((_Bool)1);
      do
      {
        char *tmp_post_5 = t;
        t = t + 1l;
        *tmp_post_5 = (char)c;
        c=soap_getchunkchar(soap);
        return_value_soap_isxdigit_3=soap_isxdigit((signed int)c);
        if(!(return_value_soap_isxdigit_3 == 0))
          tmp_if_expr_4 = (unsigned long int)(t - tmp) < sizeof(char [17l]) /*17ul*/  - (unsigned long int)1 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
      }
      while(tmp_if_expr_4);
      while(!(c == 10) && !(c == -1))
        c=soap_getchunkchar(soap);
      if(c == -1)
      {
        soap->ahead = -1;
        return -1;
      }

      *t = (char)0;
      unsigned long int return_value_strtoul_6;
      return_value_strtoul_6=strtoul(tmp, &t, 16);
      soap->chunksize = (unsigned long int)return_value_strtoul_6;
      if(soap->chunksize == 0ul)
      {
        soap->chunkbuflen = (unsigned long int)0;
        soap->buflen = soap->chunkbuflen;
        soap->bufidx = soap->buflen;
        while(!(c == 10) && !(c == -1))
          c=soap_getchunkchar(soap);
        ret = (unsigned long int)0;
        soap->ahead = -1;
        break;
      }

      soap->buflen = soap->bufidx + soap->chunksize;
      if(!(soap->chunkbuflen >= soap->buflen))
      {
        soap->buflen = soap->chunkbuflen;
        soap->chunksize = soap->chunksize - (soap->buflen - soap->bufidx);
        soap->chunkbuflen = (unsigned long int)0;
      }

      else
        if(!(soap->chunkbuflen == 0ul))
          soap->chunksize = (unsigned long int)0;

      ret = soap->buflen - soap->bufidx;
      if(!(ret == 0ul))
        break;

    }
    while((_Bool)1);

  else
  {
    soap->bufidx = (unsigned long int)0;
    ret=soap->frecv(soap, soap->buf, sizeof(char [65536l]) /*65536ul*/ );
    soap->buflen = ret;
  }
  if(!(soap->fpreparerecv == ((signed int (*)(struct soap *, const char *, unsigned long int))NULL)))
  {
    r=soap->fpreparerecv(soap, soap->buf + (signed long int)soap->bufidx, ret);
    soap->error = r;
    return soap->error;
  }

  else
    if(!(ret == 0ul))
    {
      soap->count = soap->count + ret;
      return 0;
    }

    else
      return -1;
}

// soap_reference
// file ../../../gsoap/stdsoap2.h line 2978
signed int soap_reference(struct soap *soap, const void *p, signed int t)
{
  struct soap_plist *pp;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  if(p == NULL)
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    if(soap->encodingStyle == ((const char *)NULL))
      tmp_if_expr_1 = !((soap->omode & (0x00000080 | 0x00000100 | 0x00000200 | 0x20000000)) != 0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = (soap->omode & 0x00020000) != 0 ? (_Bool)1 : (_Bool)0;
  signed int return_value_soap_pointer_enter_4;
  if(tmp_if_expr_3)
    return 1;

  else
  {
    signed int return_value_soap_pointer_lookup_5;
    return_value_soap_pointer_lookup_5=soap_pointer_lookup(soap, p, t, &pp);
    if(!(return_value_soap_pointer_lookup_5 == 0))
    {
      if((signed int)pp->mark1 == 0)
      {
        pp->mark1 = (char)2;
        pp->mark2 = (char)2;
      }

    }

    else
    {
      return_value_soap_pointer_enter_4=soap_pointer_enter(soap, p, (void *)0, 0, t, &pp);
      if(return_value_soap_pointer_enter_4 == 0)
        return 1;

    }
    return (signed int)pp->mark1;
  }
}

// soap_register_plugin_arg
// file stdsoap2.c line 18339
signed int soap_register_plugin_arg(struct soap *soap, signed int (*fcreate)(struct soap *, struct soap_plugin *, void *), void *arg)
{
  struct soap_plugin *p;
  signed int r;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct soap_plugin) /*40ul*/ );
  p = (struct soap_plugin *)return_value_malloc_1;
  if(p == ((struct soap_plugin *)NULL))
  {
    soap->error = 20;
    return soap->error;
  }

  else
  {
    p->id = (const char *)(void *)0;
    p->data = (void *)0;
    p->fcopy = (signed int (*)(struct soap *, struct soap_plugin *, struct soap_plugin *))(void *)0;
    p->fdelete = (void (*)(struct soap *, struct soap_plugin *))(void *)0;
    r=fcreate(soap, p, arg);
    if(r == 0)
    {
      p->next = soap->plugins;
      soap->plugins = p;
      return 0;
    }

    else
    {
      free((void *)p);
      return r;
    }
  }
}

// soap_resolve
// file stdsoap2.c line 2501
signed int soap_resolve(struct soap *soap)
{
  signed int i;
  signed short int flag;
  const char *id;
  i = 0;
  for( ; !(i >= 1999); i = i + 1)
  {
    struct soap_ilist *ip = soap->iht[(signed long int)i];
    for( ; !(ip == ((struct soap_ilist *)NULL)); ip = ip->next)
      if(!(ip->ptr == NULL))
      {
        void **soap_resolve__1__1__1__1__1__1__q;
        struct soap_flist *soap_resolve__1__1__1__1__1__1__fp;
        struct soap_flist **fpp = &ip->flist;
        if(!(ip->spine == ((void **)NULL)))
          ip->spine[(signed long int)0] = ip->ptr;

        soap_resolve__1__1__1__1__1__1__q = (void **)ip->link;
        ip->link = (void *)0;
        while(!(soap_resolve__1__1__1__1__1__1__q == ((void **)NULL)))
        {
          void *soap_resolve__1__1__1__1__1__1__1__p = *soap_resolve__1__1__1__1__1__1__q;
          *soap_resolve__1__1__1__1__1__1__q = ip->ptr;
          soap_resolve__1__1__1__1__1__1__q = (void **)soap_resolve__1__1__1__1__1__1__1__p;
        }
        do
        {
          soap_resolve__1__1__1__1__1__1__fp = *fpp;
          if(soap_resolve__1__1__1__1__1__1__fp == ((struct soap_flist *)NULL))
            break;

          _Bool tmp_if_expr_3;
          if(soap_resolve__1__1__1__1__1__1__fp->level >= 1u)
            tmp_if_expr_3 = soap_resolve__1__1__1__1__1__1__fp->finsert != ((void (*)(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **))NULL) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_3 = (_Bool)0;
          if(tmp_if_expr_3)
          {
            _Bool tmp_if_expr_2;
            if(!(ip->spine == ((void **)NULL)))
              tmp_if_expr_2 = soap_resolve__1__1__1__1__1__1__fp->level <= (unsigned int)4 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_2 = (_Bool)0;
            if(tmp_if_expr_2)
              soap_resolve__1__1__1__1__1__1__fp->finsert(soap, ip->type, soap_resolve__1__1__1__1__1__1__fp->type, soap_resolve__1__1__1__1__1__1__fp->ptr, soap_resolve__1__1__1__1__1__1__fp->index, (const void *)&ip->spine[(signed long int)(soap_resolve__1__1__1__1__1__1__fp->level - (unsigned int)1)], &ip->smart);

            else
              if(soap_resolve__1__1__1__1__1__1__fp->level == 1u)
                soap_resolve__1__1__1__1__1__1__fp->finsert(soap, ip->type, soap_resolve__1__1__1__1__1__1__fp->type, soap_resolve__1__1__1__1__1__1__fp->ptr, soap_resolve__1__1__1__1__1__1__fp->index, (const void *)&ip->ptr, &ip->smart);

              else
                if(!(soap_resolve__1__1__1__1__1__1__fp->level >= 5u))
                {
                  signed int soap_resolve__1__1__1__1__1__1__2__1__1__i;
                  void *return_value_soap_malloc_1;
                  return_value_soap_malloc_1=soap_malloc(soap, (unsigned long int)4 * sizeof(void *) /*8ul*/ );
                  ip->spine = (void **)return_value_soap_malloc_1;
                  if(ip->spine == ((void **)NULL))
                  {
                    soap->error = 20;
                    return soap->error;
                  }

                  ip->spine[(signed long int)0] = ip->ptr;
                  soap_resolve__1__1__1__1__1__1__2__1__1__i = 1;
                  for( ; !(soap_resolve__1__1__1__1__1__1__2__1__1__i >= 4); soap_resolve__1__1__1__1__1__1__2__1__1__i = soap_resolve__1__1__1__1__1__1__2__1__1__i + 1)
                    ip->spine[(signed long int)soap_resolve__1__1__1__1__1__1__2__1__1__i] = (void *)&ip->spine[(signed long int)(soap_resolve__1__1__1__1__1__1__2__1__1__i - 1)];
                  soap_resolve__1__1__1__1__1__1__fp->finsert(soap, ip->type, soap_resolve__1__1__1__1__1__1__fp->type, soap_resolve__1__1__1__1__1__1__fp->ptr, soap_resolve__1__1__1__1__1__1__fp->index, (const void *)&ip->spine[(signed long int)(soap_resolve__1__1__1__1__1__1__fp->level - (unsigned int)1)], &ip->smart);
                }

            *fpp = soap_resolve__1__1__1__1__1__1__fp->next;
            free((void *)soap_resolve__1__1__1__1__1__1__fp);
          }

          else
            fpp = &soap_resolve__1__1__1__1__1__1__fp->next;
        }
        while((_Bool)1);
      }

      else
        if((signed int)ip->id[0l] == 35)
        {
          strncpy(soap->id, ip->id + (signed long int)1, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
          soap->id[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
          (void)(soap->id[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
          soap->error = 25;
          return soap->error;
        }

  }
  signed int return_value_soap_has_copies_8;
  void *return_value_memcpy_4;
  void *return_value_memcpy_6;
  do
  {
    flag = (signed short int)0;
    id = (const char *)(void *)0;
    i = 0;
    for( ; !(i >= 1999); i = i + 1)
    {
      struct soap_ilist *soap_resolve__1__2__1__1__ip = soap->iht[(signed long int)i];
      for( ; !(soap_resolve__1__2__1__1__ip == ((struct soap_ilist *)NULL)); soap_resolve__1__2__1__1__ip = soap_resolve__1__2__1__1__ip->next)
      {
        _Bool tmp_if_expr_10;
        if(!(soap_resolve__1__2__1__1__ip->copy == NULL))
          tmp_if_expr_10 = (_Bool)1;

        else
          tmp_if_expr_10 = soap_resolve__1__2__1__1__ip->flist != ((struct soap_flist *)NULL) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_10)
        {
          _Bool tmp_if_expr_9;
          if(!(soap_resolve__1__2__1__1__ip->ptr == NULL))
          {
            return_value_soap_has_copies_8=soap_has_copies(soap, (const char *)soap_resolve__1__2__1__1__ip->ptr, (const char *)soap_resolve__1__2__1__1__ip->ptr + (signed long int)soap_resolve__1__2__1__1__ip->size);
            tmp_if_expr_9 = !(return_value_soap_has_copies_8 != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_9 = (_Bool)0;
          if(tmp_if_expr_9)
          {
            struct soap_flist *fp;
            if(!(soap_resolve__1__2__1__1__ip->copy == NULL))
            {
              void *p;
              void **q = (void **)soap_resolve__1__2__1__1__ip->copy;
              soap_resolve__1__2__1__1__ip->copy = (void *)0;
              do
              {
                p = *q;
                _Bool tmp_if_expr_5;
                if(!(q == ((void **)NULL)))
                  tmp_if_expr_5 = (unsigned long int)soap_resolve__1__2__1__1__ip->size >= (unsigned long int)soap_resolve__1__2__1__1__ip->size ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_5 = (_Bool)0;
                if(tmp_if_expr_5)
                {
                  return_value_memcpy_4=memcpy((void *)q, (const void *)soap_resolve__1__2__1__1__ip->ptr, soap_resolve__1__2__1__1__ip->size);
                  (signed int)!(return_value_memcpy_4 != NULL);
                }

                else
                  34;
                q = (void **)p;
              }
              while(!(q == ((void **)NULL)));
              flag = (signed short int)1;
            }

            do
            {
              fp = soap_resolve__1__2__1__1__ip->flist;
              if(fp == ((struct soap_flist *)NULL))
                break;

              if(fp->level == 0u)
              {
                if(!(fp->finsert == ((void (*)(struct soap *, signed int, signed int, void *, unsigned long int, const void *, void **))NULL)))
                  fp->finsert(soap, soap_resolve__1__2__1__1__ip->type, fp->type, fp->ptr, fp->index, soap_resolve__1__2__1__1__ip->ptr, &soap_resolve__1__2__1__1__ip->smart);

                else
                {
                  _Bool tmp_if_expr_7;
                  if(!(fp->ptr == NULL))
                    tmp_if_expr_7 = (unsigned long int)soap_resolve__1__2__1__1__ip->size >= (unsigned long int)soap_resolve__1__2__1__1__ip->size ? (_Bool)1 : (_Bool)0;

                  else
                    tmp_if_expr_7 = (_Bool)0;
                  if(tmp_if_expr_7)
                  {
                    return_value_memcpy_6=memcpy((void *)fp->ptr, (const void *)soap_resolve__1__2__1__1__ip->ptr, soap_resolve__1__2__1__1__ip->size);
                    (signed int)!(return_value_memcpy_6 != NULL);
                  }

                  else
                    34;
                }
              }

              soap_resolve__1__2__1__1__ip->flist = fp->next;
              free((void *)fp);
              flag = (signed short int)1;
            }
            while((_Bool)1);
          }

          else
            id = soap_resolve__1__2__1__1__ip->id;
        }

      }
    }
  }
  while(!(flag == 0));
  if(!(id == ((const char *)NULL)))
  {
    signed int return_value_soap_id_nullify_11;
    return_value_soap_id_nullify_11=soap_id_nullify(soap, id);
    return return_value_soap_id_nullify_11;
  }

  return 0;
}

// soap_resolve_attachment
// file stdsoap2.c line 16063
static void soap_resolve_attachment(struct soap *soap, struct soap_multipart *content)
{
  if(!(content->id == ((const char *)NULL)))
  {
    struct soap_xlist **xp = &soap->xlist;
    while(!(*xp == ((struct soap_xlist *)NULL)))
    {
      struct soap_xlist *xq = *xp;
      signed int return_value_soap_match_cid_1;
      return_value_soap_match_cid_1=soap_match_cid(soap, xq->id, content->id);
      if(return_value_soap_match_cid_1 == 0)
      {
        *xp = xq->next;
        *xq->ptr = (unsigned char *)content->ptr;
        *xq->size = (signed int)content->size;
        *xq->type = (char *)content->type;
        if(!(content->options == ((const char *)NULL)))
          *xq->options = (char *)content->options;

        else
          *xq->options = (char *)content->description;
        free((void *)xq);
      }

      else
        xp = &(*xp)->next;
    }
  }

}

// soap_response
// file stdsoap2.c line 6603
signed int soap_response(struct soap *soap, signed int status)
{
  unsigned long int count;
  if((66 & soap->omode) == 0)
  {
    if(status == 1002 || status == 1003)
      soap->omode = soap->omode & ~0x00000003 | 0x00000002;

  }

  soap->status = status;
  count=soap_count_attachments(soap);
  signed int return_value_soap_begin_send_1;
  return_value_soap_begin_send_1=soap_begin_send(soap);
  if(!(return_value_soap_begin_send_1 == 0))
    return soap->error;

  else
  {
    if(!((0x00000003 & soap->mode) == 0x00000002))
    {
      if((0x00000040 & soap->mode) == 0)
      {
        signed int n = soap->mode;
        soap->mode = soap->mode & ~(0x00000003 | 0x00000400);
        if(!((0x00000003 & n) == 0x00000000))
          soap->mode = soap->mode | 0x00000001;

        soap->error=soap->fresponse(soap, status, count);
        if(!(soap->error == 0))
          return soap->error;

        if((0x00000003 & n) == 0x00000003)
        {
          signed int return_value_soap_flush_2;
          return_value_soap_flush_2=soap_flush(soap);
          if(!(return_value_soap_flush_2 == 0))
            return soap->error;

        }

        soap->mode = n;
      }

    }

    return 0;
  }
}

// soap_retry
// file stdsoap2.c line 12008
void soap_retry(struct soap *soap)
{
  soap->error = 0;
  soap_revert(soap);
}

// soap_revert
// file ../../../gsoap/stdsoap2.h line 3091
void soap_revert(struct soap *soap)
{
  if(soap->peeked == 0)
  {
    soap->peeked = (signed short int)1;
    if(!(soap->body == 0))
      soap->level = soap->level - 1u;

  }

}

// soap_s2LONG64
// file stdsoap2.c line 13136
signed int soap_s2LONG64(struct soap *soap, const char *s, signed long int *p)
{
  signed int *return_value___errno_location_3;
  if(!(s == ((const char *)NULL)))
  {
    char *r;
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 0;
    *p=strtoll(s, &r, 10);
    _Bool tmp_if_expr_2;
    if(s == r)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = *r != 0 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr_4;
    if(tmp_if_expr_2)
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value___errno_location_3=__errno_location();
      tmp_if_expr_4 = *return_value___errno_location_3 == 34 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
      soap->error = 4;

  }

  return soap->error;
}

// soap_s2QName
// file stdsoap2.c line 14136
signed int soap_s2QName(struct soap *soap, const char *s, char **t, signed long int minlen, signed long int maxlen)
{
  if(!(s == ((const char *)NULL)))
  {
    const char *r;
    r=soap_QName(soap, s, minlen, maxlen);
    if(!(r == ((const char *)NULL)))
    {
      *t=soap_strdup(soap, r);
      if(*t == ((char *)NULL))
      {
        soap->error = 20;
        return soap->error;
      }

    }

  }

  return soap->error;
}

// soap_s2ULONG64
// file stdsoap2.c line 14012
signed int soap_s2ULONG64(struct soap *soap, const char *s, unsigned long int *p)
{
  signed int *return_value___errno_location_3;
  if(!(s == ((const char *)NULL)))
  {
    char *r;
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 0;
    *p=strtoull(s, &r, 10);
    _Bool tmp_if_expr_2;
    if(s == r)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = *r != 0 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr_4;
    if(tmp_if_expr_2)
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value___errno_location_3=__errno_location();
      tmp_if_expr_4 = *return_value___errno_location_3 == 34 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
      soap->error = 4;

  }

  return soap->error;
}

// soap_s2base64
// file stdsoap2.c line 17321
char * soap_s2base64(struct soap *soap, const unsigned char *s, char *t, signed int n)
{
  signed int i;
  unsigned long int m;
  char *p;
  void *return_value_soap_malloc_1;
  if(t == ((char *)NULL))
  {
    return_value_soap_malloc_1=soap_malloc(soap, (unsigned long int)(((n + 2) / 3) * 4 + 1));
    t = (char *)return_value_soap_malloc_1;
  }

  if(t == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    p = t;
    t[(signed long int)0] = (char)0;
    if(s == ((const unsigned char *)NULL))
      return p;

    else
    {
      for( ; n >= 3; s = s + (signed long int)3)
      {
        m = (unsigned long int)s[(signed long int)0];
        m = m << 8 | (unsigned long int)s[(signed long int)1];
        m = m << 8 | (unsigned long int)s[(signed long int)2];
        i = 4;
        for( ; i >= 1; m = m >> 6)
        {
          i = i - 1;
          t[(signed long int)i] = soap_base64o[(signed long int)(m & (unsigned long int)0x3F)];
        }
        t = t + (signed long int)4;
        n = n - 3;
      }
      t[(signed long int)0] = (char)0;
      if(n >= 1)
      {
        m = (unsigned long int)0;
        i = 0;
        for( ; !(i >= n); i = i + 1)
        {
          const unsigned char *tmp_post_2 = s;
          s = s + 1l;
          m = m << 8 | (unsigned long int)*tmp_post_2;
        }
        for( ; !(i >= 3); i = i + 1)
          m = m << 8;
        i = 4;
        for( ; i >= 1; m = m >> 6)
        {
          i = i - 1;
          t[(signed long int)i] = soap_base64o[(signed long int)(m & (unsigned long int)0x3F)];
        }
        i = 3;
        for( ; !(n >= i); i = i - 1)
          t[(signed long int)i] = (char)61;
        t[(signed long int)4] = (char)0;
      }

      return p;
    }
  }
}

// soap_s2byte
// file stdsoap2.c line 13232
signed int soap_s2byte(struct soap *soap, const char *s, char *p)
{
  if(!(s == ((const char *)NULL)))
  {
    signed long int n;
    char *r;
    n=strtol(s, &r, 10);
    _Bool tmp_if_expr_1;
    if(s == r)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = *r != 0 ? (_Bool)1 : (_Bool)0;
    if(n >= 128l || !(n >= -128l) || tmp_if_expr_1)
      soap->error = 4;

    *p = (char)n;
  }

  return soap->error;
}

// soap_s2dateTime
// file stdsoap2.c line 14974
signed int soap_s2dateTime(struct soap *soap, const char *s, signed long int *p)
{
  *p = (signed long int)0;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  if(!(s == ((const char *)NULL)))
  {
    char *t;
    unsigned long int d;
    struct tm T;
    memset((void *)&T, 0, sizeof(struct tm) /*56ul*/ );
    d=strtoul(s, &t, 10);
    if((signed int)*t == 45)
    {
      T.tm_year = (signed int)d;
      unsigned long int return_value_strtoul_1;
      return_value_strtoul_1=strtoul(t + (signed long int)1, &t, 10);
      T.tm_mon = (signed int)return_value_strtoul_1;
      unsigned long int return_value_strtoul_2;
      return_value_strtoul_2=strtoul(t + (signed long int)1, &t, 10);
      T.tm_mday = (signed int)return_value_strtoul_2;
    }

    else
      if((0x00001000 & soap->mode) == 0)
      {
        T.tm_year = (signed int)(d / (unsigned long int)10000);
        T.tm_mon = (signed int)((d / (unsigned long int)100) % (unsigned long int)100);
        T.tm_mday = (signed int)(d % (unsigned long int)100);
      }

      else
      {
        soap->error = 4;
        return soap->error;
      }
    _Bool tmp_if_expr_7;
    if((signed int)*t == 84)
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      if((signed int)*t == 116)
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = (signed int)*t == 32 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
        tmp_if_expr_6 = !((soap->mode & 0x00001000) != 0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_6 = (_Bool)0;
      tmp_if_expr_7 = tmp_if_expr_6 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
    {
      d=strtoul(t + (signed long int)1, &t, 10);
      if((signed int)*t == 58)
      {
        T.tm_hour = (signed int)d;
        unsigned long int return_value_strtoul_3;
        return_value_strtoul_3=strtoul(t + (signed long int)1, &t, 10);
        T.tm_min = (signed int)return_value_strtoul_3;
        unsigned long int return_value_strtoul_4;
        return_value_strtoul_4=strtoul(t + (signed long int)1, &t, 10);
        T.tm_sec = (signed int)return_value_strtoul_4;
      }

      else
        if((0x00001000 & soap->mode) == 0)
        {
          T.tm_hour = (signed int)(d / (unsigned long int)10000);
          T.tm_min = (signed int)((d / (unsigned long int)100) % (unsigned long int)100);
          T.tm_sec = (signed int)(d % (unsigned long int)100);
        }

        else
        {
          soap->error = 4;
          return soap->error;
        }
    }

    if(T.tm_year == 1)
      T.tm_year = 70;

    else
      T.tm_year = T.tm_year - 1900;
    T.tm_mon = T.tm_mon - 1;
    if((signed int)*t == 46)
    {
      t = t + 1l;
      for( ; !(*t == 0); t = t + 1l)
      {
        _Bool tmp_if_expr_8;
        if(!((signed int)*t >= 48))
          tmp_if_expr_8 = (_Bool)1;

        else
          tmp_if_expr_8 = (signed int)*t > 57 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_8)
          break;

      }
    }

    if((signed int)*t == 32)
    {
      if((0x00001000 & soap->mode) == 0)
        t = t + 1l;

    }

    if(!(*t == 0))
    {
      _Bool tmp_if_expr_11;
      if((signed int)*t == 43)
        tmp_if_expr_11 = (_Bool)1;

      else
        tmp_if_expr_11 = (signed int)*t == 45 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_11)
      {
        signed int h;
        signed int m;
        signed long int return_value_strtol_9;
        return_value_strtol_9=strtol(t, &t, 10);
        m = (signed int)return_value_strtol_9;
        if((signed int)*t == 58)
        {
          h = m;
          signed long int return_value_strtol_10;
          return_value_strtol_10=strtol(t + (signed long int)1, &t, 10);
          m = (signed int)return_value_strtol_10;
          if(!(h >= 0))
            m = -m;

        }

        else
          if((0x00001000 & soap->mode) == 0)
          {
            h = m / 100;
            m = m % 100;
          }

          else
          {
            h = m;
            m = 0;
          }
        if(!(*t == 0))
        {
          soap->error = 4;
          return soap->error;
        }

        T.tm_min = T.tm_min - m;
        T.tm_hour = T.tm_hour - h;
        T.tm_hour = T.tm_hour + T.tm_min / 60;
        T.tm_min = T.tm_min % 60;
        if(!(T.tm_min >= 0))
        {
          T.tm_min = T.tm_min + 60;
          T.tm_hour = T.tm_hour - 1;
        }

        T.tm_mday = T.tm_mday + T.tm_hour / 24;
        T.tm_hour = T.tm_hour % 24;
        if(!(T.tm_hour >= 0))
        {
          T.tm_hour = T.tm_hour + 24;
          T.tm_mday = T.tm_mday - 1;
        }

      }

      else
        if(!((signed int)*t == 90))
        {
          soap->error = 4;
          return soap->error;
        }

      *p=soap_timegm(&T);
    }

    else
    {
      T.tm_isdst = -1;
      *p=mktime(&T);
    }
  }

  return soap->error;
}

// soap_s2double
// file stdsoap2.c line 13577
signed int soap_s2double(struct soap *soap, const char *s, double *p)
{
  float return_value___builtin_inff_1;
  signed int return_value_soap_tag_cmp_6;
  float return_value___builtin_inff_2;
  signed int return_value_soap_tag_cmp_5;
  float return_value___builtin_inff_3;
  signed int return_value_soap_tag_cmp_4;
  if(!(s == ((const char *)NULL)))
  {
    if(*s == 0)
    {
      soap->error = 4;
      return soap->error;
    }

    signed int return_value_soap_tag_cmp_7;
    return_value_soap_tag_cmp_7=soap_tag_cmp(s, "INF");
    if(return_value_soap_tag_cmp_7 == 0)
    {
      return_value___builtin_inff_1=__builtin_inff();
      *p = (double)return_value___builtin_inff_1;
    }

    else
    {
      return_value_soap_tag_cmp_6=soap_tag_cmp(s, "+INF");
      if(return_value_soap_tag_cmp_6 == 0)
      {
        return_value___builtin_inff_2=__builtin_inff();
        *p = (double)return_value___builtin_inff_2;
      }

      else
      {
        return_value_soap_tag_cmp_5=soap_tag_cmp(s, "-INF");
        if(return_value_soap_tag_cmp_5 == 0)
        {
          return_value___builtin_inff_3=__builtin_inff();
          *p = (double)-return_value___builtin_inff_3;
        }

        else
        {
          return_value_soap_tag_cmp_4=soap_tag_cmp(s, "NaN");
          if(return_value_soap_tag_cmp_4 == 0)
            *p = soap_double_nan.dv;

          else
          {
            char *r;
            *p=strtod(s, &r);
            if(!(*r == 0))
              soap->error = 4;

          }
        }
      }
    }
  }

  return soap->error;
}

// soap_s2float
// file stdsoap2.c line 13409
signed int soap_s2float(struct soap *soap, const char *s, float *p)
{
  signed int return_value_soap_tag_cmp_5;
  signed int return_value_soap_tag_cmp_4;
  float return_value___builtin_inff_1;
  signed int return_value_soap_tag_cmp_3;
  if(!(s == ((const char *)NULL)))
  {
    if(*s == 0)
    {
      soap->error = 4;
      return soap->error;
    }

    signed int return_value_soap_tag_cmp_6;
    return_value_soap_tag_cmp_6=soap_tag_cmp(s, "INF");
    if(return_value_soap_tag_cmp_6 == 0)
      *p=__builtin_inff();

    else
    {
      return_value_soap_tag_cmp_5=soap_tag_cmp(s, "+INF");
      if(return_value_soap_tag_cmp_5 == 0)
        *p=__builtin_inff();

      else
      {
        return_value_soap_tag_cmp_4=soap_tag_cmp(s, "-INF");
        if(return_value_soap_tag_cmp_4 == 0)
        {
          return_value___builtin_inff_1=__builtin_inff();
          *p = -return_value___builtin_inff_1;
        }

        else
        {
          return_value_soap_tag_cmp_3=soap_tag_cmp(s, "NaN");
          if(return_value_soap_tag_cmp_3 == 0)
            *p = soap_double_nan.fv;

          else
          {
            char *r;
            double return_value_strtod_2;
            return_value_strtod_2=strtod(s, &r);
            *p = (float)return_value_strtod_2;
            if(!(*r == 0))
              soap->error = 4;

          }
        }
      }
    }
  }

  return soap->error;
}

// soap_s2hex
// file stdsoap2.c line 17446
char * soap_s2hex(struct soap *soap, const unsigned char *s, char *t, signed int n)
{
  char *p;
  void *return_value_soap_malloc_1;
  if(t == ((char *)NULL))
  {
    return_value_soap_malloc_1=soap_malloc(soap, (unsigned long int)(2 * n + 1));
    t = (char *)return_value_soap_malloc_1;
  }

  if(t == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    p = t;
    t[(signed long int)0] = (char)0;
    if(!(s == ((const unsigned char *)NULL)))
      for( ; n >= 1; n = n - 1)
      {
        signed int m;
        const unsigned char *tmp_post_2 = s;
        s = s + 1l;
        m = (signed int)*tmp_post_2;
        char *tmp_post_3 = t;
        t = t + 1l;
        *tmp_post_3 = (char)((m >> 4) + (m > 159 ? 97 - 10 : 48));
        m = m & 0x0F;
        char *tmp_post_4 = t;
        t = t + 1l;
        *tmp_post_4 = (char)(m + (m > 9 ? 97 - 10 : 48));
      }

    char *tmp_post_5 = t;
    t = t + 1l;
    *tmp_post_5 = (char)0;
    return p;
  }
}

// soap_s2int
// file stdsoap2.c line 12953
signed int soap_s2int(struct soap *soap, const char *s, signed int *p)
{
  signed int *return_value___errno_location_3;
  if(!(s == ((const char *)NULL)))
  {
    signed long int n;
    char *r;
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 0;
    n=strtol(s, &r, 10);
    _Bool tmp_if_expr_2;
    if(s == r)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = *r != 0 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr_4;
    if(!(n == (signed long int)(signed int)n) || tmp_if_expr_2)
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value___errno_location_3=__errno_location();
      tmp_if_expr_4 = *return_value___errno_location_3 == 34 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
      soap->error = 4;

    *p = (signed int)n;
  }

  return soap->error;
}

// soap_s2long
// file stdsoap2.c line 13047
signed int soap_s2long(struct soap *soap, const char *s, signed long int *p)
{
  signed int *return_value___errno_location_3;
  if(!(s == ((const char *)NULL)))
  {
    char *r;
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 0;
    *p=strtol(s, &r, 10);
    _Bool tmp_if_expr_2;
    if(s == r)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = *r != 0 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr_4;
    if(tmp_if_expr_2)
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value___errno_location_3=__errno_location();
      tmp_if_expr_4 = *return_value___errno_location_3 == 34 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
      soap->error = 4;

  }

  return soap->error;
}

// soap_s2short
// file stdsoap2.c line 13309
signed int soap_s2short(struct soap *soap, const char *s, signed short int *p)
{
  if(!(s == ((const char *)NULL)))
  {
    signed long int n;
    char *r;
    n=strtol(s, &r, 10);
    _Bool tmp_if_expr_1;
    if(s == r)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = *r != 0 ? (_Bool)1 : (_Bool)0;
    if(n >= 32768l || !(n >= -32768l) || tmp_if_expr_1)
      soap->error = 4;

    *p = (signed short int)n;
  }

  return soap->error;
}

// soap_s2string
// file stdsoap2.c line 14078
signed int soap_s2string(struct soap *soap, const char *s, char **t, signed long int minlen, signed long int maxlen)
{
  if(!(s == ((const char *)NULL)))
  {
    const char *r;
    r=soap_string(soap, s, minlen, maxlen);
    if(!(r == ((const char *)NULL)))
    {
      *t=soap_strdup(soap, r);
      if(*t == ((char *)NULL))
      {
        soap->error = 20;
        return soap->error;
      }

    }

  }

  return soap->error;
}

// soap_s2unsignedByte
// file stdsoap2.c line 13679
signed int soap_s2unsignedByte(struct soap *soap, const char *s, unsigned char *p)
{
  if(!(s == ((const char *)NULL)))
  {
    unsigned long int n;
    char *r;
    n=strtoul(s, &r, 10);
    _Bool tmp_if_expr_1;
    if(s == r)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = *r != 0 ? (_Bool)1 : (_Bool)0;
    if(n >= 256ul || tmp_if_expr_1)
      soap->error = 4;

    *p = (unsigned char)n;
  }

  return soap->error;
}

// soap_s2unsignedInt
// file stdsoap2.c line 13834
signed int soap_s2unsignedInt(struct soap *soap, const char *s, unsigned int *p)
{
  signed int *return_value___errno_location_4;
  if(!(s == ((const char *)NULL)))
  {
    char *r;
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 0;
    unsigned long int return_value_strtoul_2;
    return_value_strtoul_2=strtoul(s, &r, 10);
    *p = (unsigned int)return_value_strtoul_2;
    _Bool tmp_if_expr_3;
    if(s == r)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = *r != 0 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr_5;
    if(tmp_if_expr_3)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value___errno_location_4=__errno_location();
      tmp_if_expr_5 = *return_value___errno_location_4 == 34 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      soap->error = 4;

  }

  return soap->error;
}

// soap_s2unsignedLong
// file stdsoap2.c line 13923
signed int soap_s2unsignedLong(struct soap *soap, const char *s, unsigned long int *p)
{
  signed int *return_value___errno_location_3;
  if(!(s == ((const char *)NULL)))
  {
    char *r;
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 0;
    *p=strtoul(s, &r, 10);
    _Bool tmp_if_expr_2;
    if(s == r)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = *r != 0 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr_4;
    if(tmp_if_expr_2)
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value___errno_location_3=__errno_location();
      tmp_if_expr_4 = *return_value___errno_location_3 == 34 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
      soap->error = 4;

  }

  return soap->error;
}

// soap_s2unsignedShort
// file stdsoap2.c line 13756
signed int soap_s2unsignedShort(struct soap *soap, const char *s, unsigned short int *p)
{
  if(!(s == ((const char *)NULL)))
  {
    unsigned long int n;
    char *r;
    n=strtoul(s, &r, 10);
    _Bool tmp_if_expr_1;
    if(s == r)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = *r != 0 ? (_Bool)1 : (_Bool)0;
    if(n >= 65536ul || tmp_if_expr_1)
      soap->error = 4;

    *p = (unsigned short int)n;
  }

  return soap->error;
}

// soap_s2wchar
// file stdsoap2.c line 14455
signed int soap_s2wchar(struct soap *soap, const char *s, signed int **t, signed long int minlen, signed long int maxlen)
{
  if(!(s == ((const char *)NULL)))
  {
    const signed int *r;
    r=soap_wstring(soap, s, minlen, maxlen);
    if(!(r == ((const signed int *)NULL)))
    {
      *t=soap_wstrdup(soap, r);
      if(*t == ((signed int *)NULL))
      {
        soap->error = 20;
        return soap->error;
      }

    }

  }

  return soap->error;
}

// soap_save_block
// file ../../../gsoap/stdsoap2.h line 3131
char * soap_save_block(struct soap *soap, struct soap_blist *b, char *p, signed int flag)
{
  unsigned long int n;
  char *q;
  char *s;
  if(b == ((struct soap_blist *)NULL))
    b = soap->blist;

  void *return_value_soap_malloc_1;
  void *return_value_memcpy_2;
  if(!(b->size == 0ul))
  {
    if(p == ((char *)NULL))
    {
      return_value_soap_malloc_1=soap_malloc(soap, b->size);
      p = (char *)return_value_soap_malloc_1;
    }

    if(!(p == ((char *)NULL)))
    {
      s = p;
      q=soap_first_block(soap, b);
      while(!(q == ((char *)NULL)))
      {
        n=soap_block_size(soap, b);
        if(!(flag == 0))
          soap_update_pointers(soap, s, q, n);

        if(!(s == ((char *)NULL)))
        {
          return_value_memcpy_2=memcpy((void *)s, (const void *)q, n);
          (signed int)!(return_value_memcpy_2 != NULL);
        }

        else
          34;
        s = s + (signed long int)n;
        q=soap_next_block(soap, b);
      }
    }

    else
      soap->error = 20;
  }

  soap_end_block(soap, b);
  if(soap->blist == ((struct soap_blist *)NULL))
  {
    _Bool tmp_if_expr_3;
    if(!(soap->version == 0))
      tmp_if_expr_3 = !((soap->imode & 0x00020000) != 0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    _Bool tmp_if_expr_4;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (soap->mode & 0x20000000) != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
    {
      signed int i;
      struct soap_ilist *ip = (struct soap_ilist *)(void *)0;
      i = 0;
      for( ; !(i >= 1999); i = i + 1)
      {
        ip = soap->iht[(signed long int)i];
        for( ; !(ip == ((struct soap_ilist *)NULL)); ip = ip->next)
          ip->shaky = (signed short int)0;
      }
    }

  }

  return p;
}

// soap_select_mime_boundary
// file stdsoap2.c line 16338
static void soap_select_mime_boundary(struct soap *soap)
{
  signed int return_value_soap_valid_mime_boundary_1;
  while((_Bool)1)
  {
    if(!(soap->mime.boundary == ((char *)NULL)))
    {
      return_value_soap_valid_mime_boundary_1=soap_valid_mime_boundary(soap);
      if(return_value_soap_valid_mime_boundary_1 == 0)
        goto __CPROVER_DUMP_L8;

    }

    char *s = soap->mime.boundary;
    unsigned long int n = (unsigned long int)0;
    if(!(s == ((char *)NULL)))
      n=strlen(s);

    if(!(n >= 16ul))
    {
      n = (unsigned long int)64;
      void *return_value_soap_malloc_2;
      return_value_soap_malloc_2=soap_malloc(soap, n + (unsigned long int)1);
      soap->mime.boundary = (char *)return_value_soap_malloc_2;
      s = soap->mime.boundary;
      if(s == ((char *)NULL))
        goto __CPROVER_DUMP_L10;

    }

    char *tmp_post_3 = s;
    s = s + 1l;
    *tmp_post_3 = (char)61;
    char *tmp_post_4 = s;
    s = s + 1l;
    *tmp_post_4 = (char)61;
    n = n - (unsigned long int)4;
    while(!(n == 0ul))
    {
      char *tmp_post_5 = s;
      s = s + 1l;
      signed long int return_value_random_6;
      return_value_random_6=random();
      *tmp_post_5 = soap_base64o[(signed long int)((signed int)return_value_random_6 & 0x3F)];
      n = n - 1ul;
    }
    char *tmp_post_7 = s;
    s = s + 1l;
    *tmp_post_7 = (char)61;
    char *tmp_post_8 = s;
    s = s + 1l;
    *tmp_post_8 = (char)61;
    *s = (char)0;
  }

__CPROVER_DUMP_L8:
  ;
  if(soap->mime.start == ((const char *)NULL))
    soap->mime.start = "<SOAP-ENV:Envelope>";


__CPROVER_DUMP_L10:
  ;
}

// soap_send
// file stdsoap2.c line 882
signed int soap_send(struct soap *soap, const char *s)
{
  unsigned long int return_value_strlen_1;
  signed int return_value_soap_send_raw_2;
  if(!(s == ((const char *)NULL)))
  {
    return_value_strlen_1=strlen(s);
    return_value_soap_send_raw_2=soap_send_raw(soap, s, return_value_strlen_1);
    return return_value_soap_send_raw_2;
  }

  return 0;
}

// soap_send2
// file stdsoap2.c line 896
signed int soap_send2(struct soap *soap, const char *s1, const char *s2)
{
  signed int return_value_soap_send_1;
  return_value_soap_send_1=soap_send(soap, s1);
  if(!(return_value_soap_send_1 == 0))
    return soap->error;

  else
  {
    signed int return_value_soap_send_2;
    return_value_soap_send_2=soap_send(soap, s2);
    return return_value_soap_send_2;
  }
}

// soap_send3
// file stdsoap2.c line 911
signed int soap_send3(struct soap *soap, const char *s1, const char *s2, const char *s3)
{
  signed int return_value_soap_send_1;
  return_value_soap_send_1=soap_send(soap, s1);
  _Bool tmp_if_expr_3;
  signed int return_value_soap_send_2;
  if(!(return_value_soap_send_1 == 0))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_soap_send_2=soap_send(soap, s2);
    tmp_if_expr_3 = return_value_soap_send_2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
    return soap->error;

  else
  {
    signed int return_value_soap_send_4;
    return_value_soap_send_4=soap_send(soap, s3);
    return return_value_soap_send_4;
  }
}

// soap_send_empty_response
// file stdsoap2.c line 17982
signed int soap_send_empty_response(struct soap *soap, signed int httpstatuscode)
{
  signed int m = soap->omode;
  if((0x00000004 & m) == 0)
  {
    soap->count = (unsigned long int)0;
    if((0x00000003 & m) == 0x00000003)
      soap->omode = m & ~0x00000003 | 0x00000001;

    soap_response(soap, httpstatuscode);
    soap_end_send(soap);
    soap->error = 1000;
    soap->omode = m;
  }

  signed int return_value_soap_closesock_1;
  return_value_soap_closesock_1=soap_closesock(soap);
  return return_value_soap_closesock_1;
}

// soap_send_fault
// file ../../../gsoap/stdsoap2.h line 3156
signed int soap_send_fault(struct soap *soap)
{
  signed int status = soap->error;
  signed int return_value_soap_closesock_1;
  if(status == 0 || status == 1000)
  {
    return_value_soap_closesock_1=soap_closesock(soap);
    return return_value_soap_closesock_1;
  }

  soap->keep_alive = (signed short int)0;
  soap_set_fault(soap);
  if(!(soap->error >= 200))
  {
    if(!(soap->error == 12))
      soap->header = (struct SOAP_ENV__Header *)(void *)0;

  }

  _Bool tmp_if_expr_35;
  _Bool tmp_if_expr_34;
  if(!(status == -1))
    tmp_if_expr_35 = (_Bool)1;

  else
  {
    if(soap->recv_timeout == 0)
      tmp_if_expr_34 = !(soap->send_timeout != 0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_34 = (_Bool)0;
    tmp_if_expr_35 = tmp_if_expr_34 ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value;
  _Bool tmp_if_expr_3;
  signed long int return_value_recv_2;
  signed int return_value_soap_putheader_8;
  signed int return_value_soap_body_begin_out_10;
  signed int return_value_soap_putfault_12;
  signed int return_value_soap_body_end_out_14;
  signed int return_value_soap_envelope_end_out_16;
  signed int return_value_soap_closesock_6;
  signed int return_value_soap_envelope_begin_out_20;
  signed int return_value_soap_putheader_22;
  signed int return_value_soap_body_begin_out_24;
  signed int return_value_soap_putfault_26;
  signed int return_value_soap_body_end_out_28;
  signed int return_value_soap_envelope_end_out_30;
  signed int return_value_soap_end_send_32;
  signed int return_value_soap_closesock_18;
  if(tmp_if_expr_35)
  {
    signed int r = 1;
    _Bool tmp_if_expr_5;
    if(!(soap->fpoll == ((signed int (*)(struct soap *))NULL)))
    {
      return_value=soap->fpoll(soap);
      tmp_if_expr_5 = return_value != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
      r = 0;

    else
      if(!(soap->socket == -1))
      {
        r=tcp_select(soap, soap->socket, 0x1 | 0x2, 0);
        if(r >= 1)
        {
          signed int t;
          _Bool tmp_if_expr_4;
          if((0x2 & r) == 0)
            tmp_if_expr_4 = (_Bool)1;

          else
          {
            if(!((0x1 & r) == 0))
            {
              return_value_recv_2=recv(soap->socket, (void *)(char *)&t, (unsigned long int)1, 2);
              tmp_if_expr_3 = return_value_recv_2 < (signed long int)0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_3 = (_Bool)0;
            tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_4)
            r = 0;

        }

      }

    if(r >= 1)
    {
      soap->error = 0;
      soap->encodingStyle = (const char *)(void *)0;
      soap_serializeheader(soap);
      soap_serializefault(soap);
      soap_begin_count(soap);
      if(!((0x00000008 & soap->mode) == 0))
      {
        signed int return_value_soap_envelope_begin_out_7;
        return_value_soap_envelope_begin_out_7=soap_envelope_begin_out(soap);
        _Bool tmp_if_expr_9;
        if(!(return_value_soap_envelope_begin_out_7 == 0))
          tmp_if_expr_9 = (_Bool)1;

        else
        {
          return_value_soap_putheader_8=soap_putheader(soap);
          tmp_if_expr_9 = return_value_soap_putheader_8 != 0 ? (_Bool)1 : (_Bool)0;
        }
        _Bool tmp_if_expr_11;
        if(tmp_if_expr_9)
          tmp_if_expr_11 = (_Bool)1;

        else
        {
          return_value_soap_body_begin_out_10=soap_body_begin_out(soap);
          tmp_if_expr_11 = return_value_soap_body_begin_out_10 != 0 ? (_Bool)1 : (_Bool)0;
        }
        _Bool tmp_if_expr_13;
        if(tmp_if_expr_11)
          tmp_if_expr_13 = (_Bool)1;

        else
        {
          return_value_soap_putfault_12=soap_putfault(soap);
          tmp_if_expr_13 = return_value_soap_putfault_12 != 0 ? (_Bool)1 : (_Bool)0;
        }
        _Bool tmp_if_expr_15;
        if(tmp_if_expr_13)
          tmp_if_expr_15 = (_Bool)1;

        else
        {
          return_value_soap_body_end_out_14=soap_body_end_out(soap);
          tmp_if_expr_15 = return_value_soap_body_end_out_14 != 0 ? (_Bool)1 : (_Bool)0;
        }
        _Bool tmp_if_expr_17;
        if(tmp_if_expr_15)
          tmp_if_expr_17 = (_Bool)1;

        else
        {
          return_value_soap_envelope_end_out_16=soap_envelope_end_out(soap);
          tmp_if_expr_17 = return_value_soap_envelope_end_out_16 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_17)
        {
          return_value_soap_closesock_6=soap_closesock(soap);
          return return_value_soap_closesock_6;
        }

      }

      soap_end_count(soap);
      signed int return_value_soap_response_19;
      return_value_soap_response_19=soap_response(soap, status);
      _Bool tmp_if_expr_21;
      if(!(return_value_soap_response_19 == 0))
        tmp_if_expr_21 = (_Bool)1;

      else
      {
        return_value_soap_envelope_begin_out_20=soap_envelope_begin_out(soap);
        tmp_if_expr_21 = return_value_soap_envelope_begin_out_20 != 0 ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_23;
      if(tmp_if_expr_21)
        tmp_if_expr_23 = (_Bool)1;

      else
      {
        return_value_soap_putheader_22=soap_putheader(soap);
        tmp_if_expr_23 = return_value_soap_putheader_22 != 0 ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_25;
      if(tmp_if_expr_23)
        tmp_if_expr_25 = (_Bool)1;

      else
      {
        return_value_soap_body_begin_out_24=soap_body_begin_out(soap);
        tmp_if_expr_25 = return_value_soap_body_begin_out_24 != 0 ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_27;
      if(tmp_if_expr_25)
        tmp_if_expr_27 = (_Bool)1;

      else
      {
        return_value_soap_putfault_26=soap_putfault(soap);
        tmp_if_expr_27 = return_value_soap_putfault_26 != 0 ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_29;
      if(tmp_if_expr_27)
        tmp_if_expr_29 = (_Bool)1;

      else
      {
        return_value_soap_body_end_out_28=soap_body_end_out(soap);
        tmp_if_expr_29 = return_value_soap_body_end_out_28 != 0 ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_31;
      if(tmp_if_expr_29)
        tmp_if_expr_31 = (_Bool)1;

      else
      {
        return_value_soap_envelope_end_out_30=soap_envelope_end_out(soap);
        tmp_if_expr_31 = return_value_soap_envelope_end_out_30 != 0 ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_33;
      if(tmp_if_expr_31)
        tmp_if_expr_33 = (_Bool)1;

      else
      {
        return_value_soap_end_send_32=soap_end_send(soap);
        tmp_if_expr_33 = return_value_soap_end_send_32 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_33)
      {
        return_value_soap_closesock_18=soap_closesock(soap);
        return return_value_soap_closesock_18;
      }

    }

  }

  soap->error = status;
  signed int return_value_soap_closesock_36;
  return_value_soap_closesock_36=soap_closesock(soap);
  return return_value_soap_closesock_36;
}

// soap_send_raw
// file ../../../gsoap/stdsoap2.h line 2947
signed int soap_send_raw(struct soap *soap, const char *s, unsigned long int n)
{
  void *return_value_memcpy_1;
  void *return_value_memcpy_3;
  signed int return_value_soap_flush_raw_5;
  if(n == 0ul)
    return 0;

  else
    if(!(soap->fpreparesend == ((signed int (*)(struct soap *, const char *, unsigned long int))NULL)))
    {
      if((0x00000003 & soap->mode) == 0x00000002)
        goto __CPROVER_DUMP_L2;

      if((0x00000008 & soap->mode) == 0)
        goto __CPROVER_DUMP_L2;

      soap->error=soap->fpreparesend(soap, s, n);
      return soap->error;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if(!(soap->ffiltersend == ((signed int (*)(struct soap *, const char **, unsigned long int *))NULL)))
      {
        soap->error=soap->ffiltersend(soap, &s, &n);
        return soap->error;
      }

      else
      {
        if(!((0x00000008 & soap->mode) == 0))
          soap->count = soap->count + n;

        else
          if(!((0x00000003 & soap->mode) == 0))
          {
            unsigned long int i = sizeof(char [65536l]) /*65536ul*/  - soap->bufidx;
            while(n >= i)
            {
              if(!(soap->buf + (signed long int)soap->bufidx == ((char *)NULL)))
              {
                return_value_memcpy_1=memcpy((void *)(soap->buf + (signed long int)soap->bufidx), (const void *)s, i);
                (signed int)!(return_value_memcpy_1 != NULL);
              }

              else
                34;
              soap->bufidx = sizeof(char [65536l]) /*65536ul*/ ;
              signed int return_value_soap_flush_2;
              return_value_soap_flush_2=soap_flush(soap);
              if(!(return_value_soap_flush_2 == 0))
                return soap->error;

              s = s + (signed long int)i;
              n = n - i;
              i = sizeof(char [65536l]) /*65536ul*/ ;
            }
            _Bool tmp_if_expr_4;
            if(!(soap->buf + (signed long int)soap->bufidx == ((char *)NULL)))
              tmp_if_expr_4 = (unsigned long int)(sizeof(char [65536l]) /*65536ul*/  - soap->bufidx) >= (unsigned long int)n ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_4 = (_Bool)0;
            if(tmp_if_expr_4)
            {
              return_value_memcpy_3=memcpy((void *)(soap->buf + (signed long int)soap->bufidx), (const void *)s, n);
              (signed int)!(return_value_memcpy_3 != NULL);
            }

            else
              34;
            soap->bufidx = soap->bufidx + n;
          }

          else
          {
            return_value_soap_flush_raw_5=soap_flush_raw(soap, s, n);
            return return_value_soap_flush_raw_5;
          }
        return 0;
      }
    }
}

// soap_sender_fault
// file stdsoap2.c line 18169
signed int soap_sender_fault(struct soap *soap, const char *faultstring, const char *faultdetailXML)
{
  signed int return_value_soap_sender_fault_subcode_1;
  return_value_soap_sender_fault_subcode_1=soap_sender_fault_subcode(soap, (const char *)(void *)0, faultstring, faultdetailXML);
  return return_value_soap_sender_fault_subcode_1;
}

// soap_sender_fault_subcode
// file stdsoap2.c line 18180
signed int soap_sender_fault_subcode(struct soap *soap, const char *faultsubcodeQName, const char *faultstring, const char *faultdetailXML)
{
  char *tmp_if_expr_1;
  if((signed int)soap->version == 2)
    tmp_if_expr_1 = "SOAP-ENV:Sender";

  else
    tmp_if_expr_1 = (signed int)soap->version == 1 ? "SOAP-ENV:Client" : "at source";
  signed int return_value_soap_copy_fault_2;
  return_value_soap_copy_fault_2=soap_copy_fault(soap, tmp_if_expr_1, faultsubcodeQName, faultstring, faultdetailXML);
  return return_value_soap_copy_fault_2;
}

// soap_serialize_PointerToSOAP_ENV__Code
// file soapC.c line 1239
void soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code * const *a)
{
  (void)soap;
  (void)a;
  signed int return_value_soap_reference_1;
  return_value_soap_reference_1=soap_reference(soap, (const void *)*a, 11);
  if(return_value_soap_reference_1 == 0)
    soap_serialize_SOAP_ENV__Code(soap, *a);

}

// soap_serialize_PointerToSOAP_ENV__Detail
// file soapC.c line 1181
void soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail * const *a)
{
  (void)soap;
  (void)a;
  signed int return_value_soap_reference_1;
  return_value_soap_reference_1=soap_reference(soap, (const void *)*a, 13);
  if(return_value_soap_reference_1 == 0)
    soap_serialize_SOAP_ENV__Detail(soap, *a);

}

// soap_serialize_PointerToSOAP_ENV__Reason
// file soapC.c line 1123
void soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason * const *a)
{
  (void)soap;
  (void)a;
  signed int return_value_soap_reference_1;
  return_value_soap_reference_1=soap_reference(soap, (const void *)*a, 16);
  if(return_value_soap_reference_1 == 0)
    soap_serialize_SOAP_ENV__Reason(soap, *a);

}

// soap_serialize_PointerTot__Routing
// file soapC.c line 1298
void soap_serialize_PointerTot__Routing(struct soap *soap, struct t__Routing * const *a)
{
  (void)soap;
  (void)a;
  signed int return_value_soap_reference_1;
  return_value_soap_reference_1=soap_reference(soap, (const void *)*a, 7);
  if(return_value_soap_reference_1 == 0)
    soap_serialize_t__Routing(soap, *a);

}

// soap_serialize_SOAP_ENV__Code
// file soapC.c line 758
void soap_serialize_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
  (void)soap;
  (void)a;
  soap_serialize__QName(soap, (char * const *)&a->SOAP_ENV__Value);
  soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

// soap_serialize_SOAP_ENV__Detail
// file soapC.c line 671
void soap_serialize_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
  (void)soap;
  (void)a;
  soap_markelement(soap, a->fault, a->__type);
}

// soap_serialize_SOAP_ENV__Fault
// file soapC.c line 436
void soap_serialize_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
  (void)soap;
  (void)a;
  soap_serialize__QName(soap, (char * const *)&a->faultcode);
  soap_serialize_string(soap, (char * const *)&a->faultstring);
  soap_serialize_string(soap, (char * const *)&a->faultactor);
  soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
  soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
  soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
  soap_serialize_string(soap, (char * const *)&a->SOAP_ENV__Node);
  soap_serialize_string(soap, (char * const *)&a->SOAP_ENV__Role);
  soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

// soap_serialize_SOAP_ENV__Header
// file soapC.c line 846
void soap_serialize_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
  (void)soap;
  (void)a;
}

// soap_serialize_SOAP_ENV__Reason
// file soapC.c line 588
void soap_serialize_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
  (void)soap;
  (void)a;
  soap_serialize_string(soap, (char * const *)&a->SOAP_ENV__Text);
}

// soap_serialize__QName
// file soapC.c line 1352
void soap_serialize__QName(struct soap *soap, char * const *a)
{
  (void)soap;
  (void)a;
  soap_reference(soap, (const void *)*a, 5);
}

// soap_serialize_string
// file soapC.c line 1396
void soap_serialize_string(struct soap *soap, char * const *a)
{
  (void)soap;
  (void)a;
  soap_reference(soap, (const void *)*a, 4);
}

// soap_serialize_t__Routing
// file soapC.c line 1025
void soap_serialize_t__Routing(struct soap *soap, struct t__Routing *a)
{
  (void)soap;
  (void)a;
  soap_serialize_string(soap, (char * const *)&a->key);
  soap_serialize_string(soap, (char * const *)&a->endpoint);
  soap_serialize_string(soap, (char * const *)&a->userid);
  soap_serialize_string(soap, (char * const *)&a->passwd);
}

// soap_serialize_t__RoutingTable
// file soapC.c line 915
void soap_serialize_t__RoutingTable(struct soap *soap, struct t__RoutingTable *a)
{
  (void)soap;
  (void)a;
  if(!(a->__ptr == ((struct t__Routing *)NULL)))
  {
    signed int i = 0;
    for( ; !(i >= a->__size); i = i + 1)
    {
      soap_embedded(soap, (const void *)(a->__ptr + (signed long int)i), 7);
      soap_serialize_t__Routing(soap, a->__ptr + (signed long int)i);
    }
  }

}

// soap_serialize_xsd__anyAttribute
// file dom.c line 152
void soap_serialize_xsd__anyAttribute(struct soap *soap, struct soap_dom_attribute *node)
{
  (void)soap;
  (void)node;
}

// soap_serialize_xsd__anyType
// file dom.c line 124
void soap_serialize_xsd__anyType(struct soap *soap, struct soap_dom_element *node)
{
  if(!(node == ((struct soap_dom_element *)NULL)))
  {
    _Bool tmp_if_expr_1;
    if(!(node->type == 0))
      tmp_if_expr_1 = node->node != NULL ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      soap_markelement(soap, node->node, node->type);

    else
    {
      struct soap_dom_element *elt = node->elts;
      for( ; !(elt == ((struct soap_dom_element *)NULL)); elt = elt->next)
        soap_serialize_xsd__anyType(soap, elt);
    }
  }

}

// soap_serializefault
// file soapC.c line 81
void soap_serializefault(struct soap *soap)
{
  if(!(soap->fault == ((struct SOAP_ENV__Fault *)NULL)))
    soap_serialize_SOAP_ENV__Fault(soap, soap->fault);

}

// soap_serializeheader
// file soapC.c line 49
void soap_serializeheader(struct soap *soap)
{
  if(!(soap->version == 0))
  {
    if(!(soap->header == ((struct SOAP_ENV__Header *)NULL)))
      soap_serialize_SOAP_ENV__Header(soap, soap->header);

  }

}

// soap_set_attr
// file ../../../gsoap/stdsoap2.h line 3302
signed int soap_set_attr(struct soap *soap, const char *name, const char *value, signed int flag)
{
  struct soap_attribute *tp;
  struct soap_attribute *soap_set_attr__1__tq;
  signed int return_value_strncmp_3;
  signed int return_value_strcmp_4;
  signed int return_value_strncmp_8;
  signed int return_value_strcmp_6;
  signed int return_value_strncmp_9;
  _Bool tmp_if_expr_12;
  signed int return_value_strcmp_11;
  unsigned long int return_value_strlen_16;
  signed int return_value_strcmp_23;
  signed int return_value_strcmp_25;
  _Bool tmp_if_expr_27;
  signed int return_value_strcmp_26;
  _Bool tmp_if_expr_29;
  signed int return_value_strcmp_28;
  if((signed int)*name == 45)
    return 0;

  else
  {
    soap_set_attr__1__tq = (struct soap_attribute *)(void *)0;
    tp = soap->attributes;
    for( ; !(tp == ((struct soap_attribute *)NULL)); tp = tp->next)
    {
      signed int return_value_strcmp_1;
      return_value_strcmp_1=strcmp(tp->name, name);
      if(return_value_strcmp_1 == 0)
        break;

      soap_set_attr__1__tq = tp;
    }
    if(tp == ((struct soap_attribute *)NULL))
    {
      unsigned long int l;
      l=strlen(name);
      void *return_value_malloc_2;
      return_value_malloc_2=malloc(sizeof(struct soap_attribute) /*48ul*/  + l);
      tp = (struct soap_attribute *)return_value_malloc_2;
      if(tp == ((struct soap_attribute *)NULL))
      {
        soap->error = 20;
        return soap->error;
      }

      tp->ns = (const char *)(void *)0;
      if(!((0x00010000 & soap->mode) == 0))
      {
        struct soap_attribute **tpp = &soap->attributes;
        const char *s;
        s=strchr(name, 58);
        signed int return_value_strncmp_15;
        return_value_strncmp_15=strncmp(name, "xmlns", (unsigned long int)5);
        if(return_value_strncmp_15 == 0)
          for( ; !(*tpp == ((struct soap_attribute *)NULL)); tpp = &(*tpp)->next)
          {
            return_value_strncmp_3=strncmp((*tpp)->name, "xmlns", (unsigned long int)5);
            _Bool tmp_if_expr_5;
            if(!(return_value_strncmp_3 == 0))
              tmp_if_expr_5 = (_Bool)1;

            else
            {
              return_value_strcmp_4=strcmp((*tpp)->name + (signed long int)5, name + (signed long int)5);
              tmp_if_expr_5 = return_value_strcmp_4 > 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_5)
              break;

          }

        else
          if(s == ((const char *)NULL))
            for( ; !(*tpp == ((struct soap_attribute *)NULL)); tpp = &(*tpp)->next)
            {
              return_value_strncmp_8=strncmp((*tpp)->name, "xmlns", (unsigned long int)5);
              if(!(return_value_strncmp_8 == 0))
              {
                _Bool tmp_if_expr_7;
                if(!((*tpp)->ns == ((const char *)NULL)))
                  tmp_if_expr_7 = (_Bool)1;

                else
                {
                  return_value_strcmp_6=strcmp((*tpp)->name, name);
                  tmp_if_expr_7 = return_value_strcmp_6 > 0 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_7)
                  break;

              }

            }

          else
          {
            struct soap_nlist *np;
            np=soap_lookup_ns(soap, name, (unsigned long int)(s - name));
            if(!(np == ((struct soap_nlist *)NULL)))
              tp->ns = np->ns;

            else
            {
              struct soap_attribute *tq = soap->attributes;
              for( ; !(tq == ((struct soap_attribute *)NULL)); tq = tq->next)
              {
                signed int return_value_strncmp_10;
                return_value_strncmp_10=strncmp(tq->name, "xmlns:", (unsigned long int)6);
                if(return_value_strncmp_10 == 0)
                {
                  return_value_strncmp_9=strncmp(tq->name + (signed long int)6, name, (unsigned long int)(s - name));
                  if(return_value_strncmp_9 == 0)
                  {
                    if(tq->name[(6l + s) - name] == 0)
                    {
                      tp->ns = tq->ns;
                      break;
                    }

                  }

                }

              }
            }
            for( ; !(*tpp == ((struct soap_attribute *)NULL)); tpp = &(*tpp)->next)
            {
              signed int k;
              signed int return_value_strncmp_14;
              return_value_strncmp_14=strncmp((*tpp)->name, "xmlns", (unsigned long int)5);
              if(!(return_value_strncmp_14 == 0))
              {
                if(!((*tpp)->ns == ((const char *)NULL)))
                {
                  if(!(tp->ns == ((const char *)NULL)))
                  {
                    k=strcmp((*tpp)->ns, tp->ns);
                    _Bool tmp_if_expr_13;
                    if(k >= 1)
                      tmp_if_expr_13 = (_Bool)1;

                    else
                    {
                      if(k == 0)
                      {
                        return_value_strcmp_11=strcmp((*tpp)->name, name);
                        tmp_if_expr_12 = return_value_strcmp_11 > 0 ? (_Bool)1 : (_Bool)0;
                      }

                      else
                        tmp_if_expr_12 = (_Bool)0;
                      tmp_if_expr_13 = tmp_if_expr_12 ? (_Bool)1 : (_Bool)0;
                    }
                    if(tmp_if_expr_13)
                      break;

                  }

                }

              }

            }
          }
        tp->next = *tpp;
        *tpp = tp;
      }

      else
        if(!(soap_set_attr__1__tq == ((struct soap_attribute *)NULL)))
        {
          soap_set_attr__1__tq->next = tp;
          tp->next = (struct soap_attribute *)(void *)0;
        }

        else
        {
          tp->next = soap->attributes;
          soap->attributes = tp;
        }
      if(1ul + l >= 1ul)
      {
        strncpy((char *)tp->name, name, (l + (unsigned long int)1) - (unsigned long int)1);
        ((char *)tp->name)[(signed long int)((l + (unsigned long int)1) - (unsigned long int)1)] = (char)0;
        if(!(tp->name[(signed long int)l] == 0))
          (_Bool)1;

        else
          (_Bool)0;
      }

      else
        (_Bool)0;
      tp->value = (char *)(void *)0;
    }

    else
      if(!(tp->visible == 0))
        return 0;

      else
        if(!(value == ((const char *)NULL)))
        {
          if(!(tp->value == ((char *)NULL)))
          {
            return_value_strlen_16=strlen(value);
            if(return_value_strlen_16 >= tp->size)
            {
              free((void *)tp->value);
              tp->value = (char *)(void *)0;
              tp->ns = (const char *)(void *)0;
            }

          }

        }

    if(!(value == ((const char *)NULL)))
    {
      if(tp->value == ((char *)NULL))
      {
        unsigned long int return_value_strlen_17;
        return_value_strlen_17=strlen(value);
        tp->size = return_value_strlen_17 + (unsigned long int)1;
        void *return_value_malloc_18;
        return_value_malloc_18=malloc(tp->size);
        tp->value = (char *)return_value_malloc_18;
        if(tp->value == ((char *)NULL))
        {
          soap->error = 20;
          return soap->error;
        }

      }

      _Bool tmp_if_expr_19;
      if(!(tp->value == ((char *)NULL)))
        tmp_if_expr_19 = (unsigned long int)tp->size > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_19 = (_Bool)0;
      if(tmp_if_expr_19)
      {
        strncpy(tp->value, value, tp->size - (unsigned long int)1);
        tp->value[(signed long int)(tp->size - (unsigned long int)1)] = (char)0;
        if(!(tp->value[-1l + (signed long int)tp->size] == 0))
          (_Bool)1;

        else
          (_Bool)0;
      }

      else
        (_Bool)0;
      signed int return_value_strncmp_20;
      return_value_strncmp_20=strncmp(tp->name, "xmlns:", (unsigned long int)6);
      if(return_value_strncmp_20 == 0)
        tp->ns = tp->value;

      tp->visible = (signed short int)2;
      tp->flag = (signed short int)flag;
      signed int return_value_strcmp_21;
      return_value_strcmp_21=strcmp(name, "wsu:Id");
      if(return_value_strcmp_21 == 0)
      {
        soap->event = (signed short int)1;
        strncpy(soap->id, value, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
        soap->id[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
        (void)(soap->id[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
      }

      if(!((0x00010000 & soap->mode) == 0))
      {
        const char *soap_set_attr__1__5__3__s;
        soap_set_attr__1__5__3__s=strchr(name, 58);
        if(!(soap_set_attr__1__5__3__s == ((const char *)NULL)))
        {
          struct soap_nlist *soap_set_attr__1__5__3__1__np;
          soap_set_attr__1__5__3__1__np=soap_lookup_ns(soap, name, (unsigned long int)(soap_set_attr__1__5__3__s - name));
          if(!(soap_set_attr__1__5__3__1__np == ((struct soap_nlist *)NULL)))
          {
            if(!(soap_set_attr__1__5__3__1__np->ns == ((const char *)NULL)))
            {
              if(!(soap->local_namespaces == ((struct Namespace *)NULL)))
              {
                signed int return_value_strcmp_22;
                return_value_strcmp_22=strcmp(soap_set_attr__1__5__3__s + (signed long int)1, "type");
                _Bool tmp_if_expr_24;
                if(return_value_strcmp_22 == 0)
                {
                  return_value_strcmp_23=strcmp(soap_set_attr__1__5__3__1__np->ns, (soap->local_namespaces + (signed long int)2)->ns);
                  tmp_if_expr_24 = !(return_value_strcmp_23 != 0) ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_24 = (_Bool)0;
                _Bool tmp_if_expr_30;
                if(tmp_if_expr_24)
                  tmp_if_expr_30 = (_Bool)1;

                else
                {
                  return_value_strcmp_25=strcmp(soap_set_attr__1__5__3__s + (signed long int)1, "arrayType");
                  if(return_value_strcmp_25 == 0)
                    tmp_if_expr_27 = (_Bool)1;

                  else
                  {
                    return_value_strcmp_26=strcmp(soap_set_attr__1__5__3__s + (signed long int)1, "itemType");
                    tmp_if_expr_27 = !(return_value_strcmp_26 != 0) ? (_Bool)1 : (_Bool)0;
                  }
                  if(tmp_if_expr_27)
                  {
                    return_value_strcmp_28=strcmp(soap_set_attr__1__5__3__1__np->ns, (soap->local_namespaces + (signed long int)1)->ns);
                    tmp_if_expr_29 = !(return_value_strcmp_28 != 0) ? (_Bool)1 : (_Bool)0;
                  }

                  else
                    tmp_if_expr_29 = (_Bool)0;
                  tmp_if_expr_30 = tmp_if_expr_29 ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr_30)
                  soap_utilize_ns(soap, value);

              }

            }

          }

        }

      }

    }

    else
      tp->visible = (signed short int)1;
    return 0;
  }
}

// soap_set_dime
// file stdsoap2.c line 16191
void soap_set_dime(struct soap *soap)
{
  soap->omode = soap->omode | 0x00000080;
  soap->dime.first = (struct soap_multipart *)(void *)0;
  soap->dime.last = (struct soap_multipart *)(void *)0;
}

// soap_set_dime_attachment
// file stdsoap2.c line 16285
signed int soap_set_dime_attachment(struct soap *soap, char *ptr, unsigned long int size, const char *type, const char *id, unsigned short int optype, const char *option)
{
  struct soap_multipart *content;
  content=soap_new_multipart(soap, &soap->dime.first, &soap->dime.last, ptr, size);
  if(content == ((struct soap_multipart *)NULL))
    return 20;

  else
  {
    content->id=soap_strdup(soap, id);
    content->type=soap_strdup(soap, type);
    content->options=soap_dime_option(soap, optype, option);
    return 0;
  }
}

// soap_set_embedded
// file stdsoap2.c line 8002
void soap_set_embedded(struct soap *soap, struct soap_plist *pp)
{
  if(!(pp == ((struct soap_plist *)NULL)))
  {
    if(!((0x00000008 & soap->mode) == 0))
      pp->mark1 = (char)1;

    else
      pp->mark2 = (char)1;
  }

}

// soap_set_endpoint
// file ../../../gsoap/stdsoap2.h line 2933
void soap_set_endpoint(struct soap *soap, const char *endpoint)
{
  const char *s;
  unsigned long int i;
  unsigned long int n;
  soap->endpoint[(signed long int)0] = (char)0;
  soap->host[(signed long int)0] = (char)0;
  soap->path[(signed long int)0] = (char)47;
  soap->path[(signed long int)1] = (char)0;
  soap->port = 80;
  _Bool tmp_if_expr_1;
  if(endpoint == ((const char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*endpoint != 0) ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr_1)
  {
    strncpy(soap->endpoint, endpoint, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
    soap->endpoint[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
    (void)(soap->endpoint[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
    s=strchr(endpoint, 58);
    _Bool tmp_if_expr_2;
    if(!(s == ((const char *)NULL)))
      tmp_if_expr_2 = (signed int)s[(signed long int)1] == 47 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    _Bool tmp_if_expr_3;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (signed int)s[(signed long int)2] == 47 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
      s = s + (signed long int)3;

    else
      s = endpoint;
    n=strlen(s);
    if(n >= sizeof(char [1024l]) /*1024ul*/ )
      n = sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1;

    if((signed int)*s == 91)
    {
      s = s + 1l;
      i = (unsigned long int)0;
      for( ; !(i >= n); i = i + 1ul)
      {
        if((signed int)s[(signed long int)i] == 93)
        {
          s = s + 1l;
          n = n - 1ul;
          break;
        }

        soap->host[(signed long int)i] = s[(signed long int)i];
      }
    }

    else
    {
      i = (unsigned long int)0;
      for( ; !(i >= n); i = i + 1ul)
      {
        soap->host[(signed long int)i] = s[(signed long int)i];
        _Bool tmp_if_expr_4;
        if((signed int)s[(signed long int)i] == 47)
          tmp_if_expr_4 = (_Bool)1;

        else
          tmp_if_expr_4 = (signed int)s[(signed long int)i] == 58 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_4)
          break;

      }
    }
    soap->host[(signed long int)i] = (char)0;
    if((signed int)s[(signed long int)i] == 58)
    {
      signed long int return_value_strtol_5;
      return_value_strtol_5=strtol(s + (signed long int)i + (signed long int)1, (char ** restrict )(void *)0, 10);
      soap->port = (signed int)return_value_strtol_5;
      i = i + 1ul;
      for( ; !(i >= n); i = i + 1ul)
        if((signed int)s[(signed long int)i] == 47)
          break;

    }

    if(!(i >= n))
    {
      if(!(s[(signed long int)i] == 0))
      {
        strncpy(soap->path, s + (signed long int)i, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
        soap->path[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
        (void)(soap->path[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
      }

    }

  }

}

// soap_set_error
// file stdsoap2.c line 18111
static signed int soap_set_error(struct soap *soap, const char *faultcode, const char *faultsubcodeQName, const char *faultstring, const char *faultdetailXML, signed int soaperror)
{
  const char **return_value_soap_faultcode_1;
  return_value_soap_faultcode_1=soap_faultcode(soap);
  *return_value_soap_faultcode_1 = faultcode;
  const char **return_value_soap_faultsubcode_2;
  if(!(faultsubcodeQName == ((const char *)NULL)))
  {
    return_value_soap_faultsubcode_2=soap_faultsubcode(soap);
    *return_value_soap_faultsubcode_2 = faultsubcodeQName;
  }

  const char **return_value_soap_faultstring_3;
  return_value_soap_faultstring_3=soap_faultstring(soap);
  *return_value_soap_faultstring_3 = faultstring;
  if(!(faultdetailXML == ((const char *)NULL)))
  {
    if(!(*faultdetailXML == 0))
    {
      const char **s;
      s=soap_faultdetail(soap);
      if(!(s == ((const char **)NULL)))
        *s = faultdetailXML;

    }

  }

  soap->error = soaperror;
  return soap->error;
}

// soap_set_fault
// file stdsoap2.c line 17628
void soap_set_fault(struct soap *soap)
{
  const char **c;
  c=soap_faultcode(soap);
  const char **s;
  s=soap_faultstring(soap);
  if(!(soap->fseterror == ((void (*)(struct soap *, const char **, const char **))NULL)))
    soap->fseterror(soap, c, s);

  if(*c == ((const char *)NULL))
  {
    if((signed int)soap->version == 2)
      *c = "SOAP-ENV:Sender";

    else
      if((signed int)soap->version == 1)
        *c = "SOAP-ENV:Client";

      else
        *c = "at source";
  }

  const char **return_value_soap_faultsubcode_3;
  const char **return_value_soap_faultsubcode_4;
  unsigned long int return_value_strlen_11;
  unsigned long int return_value_strlen_7;
  unsigned long int return_value_strlen_5;
  void *return_value_memmove_6;
  void *return_value_memcpy_9;
  void *return_value_memcpy_10;
  if(*s == ((const char *)NULL))
  {
    if(!(soap->error == 1))
    {
      if(soap->error == 2)
        goto __CPROVER_DUMP_L7;

      if(soap->error == 3)
        goto __CPROVER_DUMP_L8;

      if(soap->error == 4)
        goto __CPROVER_DUMP_L9;

      if(soap->error == 5)
        goto __CPROVER_DUMP_L12;

      if(soap->error == 6)
        goto __CPROVER_DUMP_L13;

      if(soap->error == 8)
        goto __CPROVER_DUMP_L22;

      if(soap->error == 39)
        goto __CPROVER_DUMP_L23;

      if(soap->error == 41)
        goto __CPROVER_DUMP_L24;

      if(soap->error == 9)
        goto __CPROVER_DUMP_L25;

      if(soap->error == 10)
        goto __CPROVER_DUMP_L26;

      if(soap->error == 11)
        goto __CPROVER_DUMP_L27;

      if(soap->error == 13)
        goto __CPROVER_DUMP_L28;

      if(soap->error == 14)
        goto __CPROVER_DUMP_L29;

      if(soap->error == 15)
        goto __CPROVER_DUMP_L30;

      if(soap->error == 16)
        goto __CPROVER_DUMP_L31;

      if(soap->error == 19)
        goto __CPROVER_DUMP_L32;

      if(soap->error == 20)
        goto __CPROVER_DUMP_L33;

      if(soap->error == 21)
        goto __CPROVER_DUMP_L34;

      if(soap->error == 22)
        goto __CPROVER_DUMP_L35;

      if(soap->error == 7)
        goto __CPROVER_DUMP_L36;

      if(soap->error == 23)
        goto __CPROVER_DUMP_L37;

      if(soap->error == 24)
        goto __CPROVER_DUMP_L38;

      if(soap->error == 25)
        goto __CPROVER_DUMP_L40;

      if(soap->error == 26)
        goto __CPROVER_DUMP_L42;

      if(soap->error == 12)
        goto __CPROVER_DUMP_L43;

      if(soap->error == 27)
        goto __CPROVER_DUMP_L44;

      if(soap->error == 28)
        goto __CPROVER_DUMP_L45;

      if(soap->error == 29)
        goto __CPROVER_DUMP_L46;

      if(soap->error == 49)
        goto __CPROVER_DUMP_L47;

      if(soap->error == 30)
        goto __CPROVER_DUMP_L48;

      if(soap->error == 40)
        goto __CPROVER_DUMP_L49;

      if(soap->error == 32)
        goto __CPROVER_DUMP_L50;

      if(soap->error == 33)
        goto __CPROVER_DUMP_L51;

      if(soap->error == 34)
        goto __CPROVER_DUMP_L52;

      if(soap->error == 35)
        goto __CPROVER_DUMP_L53;

      if(soap->error == 36)
        goto __CPROVER_DUMP_L54;

      if(soap->error == 37)
        goto __CPROVER_DUMP_L55;

      if(soap->error == 38)
        goto __CPROVER_DUMP_L56;

      if(soap->error == 31)
        goto __CPROVER_DUMP_L57;

      if(soap->error == 42)
        goto __CPROVER_DUMP_L58;

      if(soap->error == 43)
        goto __CPROVER_DUMP_L59;

      if(soap->error == 44)
        goto __CPROVER_DUMP_L60;

      if(soap->error == 45)
        goto __CPROVER_DUMP_L61;

      if(soap->error == 47)
        goto __CPROVER_DUMP_L62;

      if(soap->error == 48)
        goto __CPROVER_DUMP_L63;

      if(soap->error == 1000)
        goto __CPROVER_DUMP_L64;

      if(soap->error == -1)
        goto __CPROVER_DUMP_L65;

    }

    else
    {
      *s = "Client fault";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L7:
      ;
      *s = "Server fault";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L8:
      ;
      *s=soap_set_validation_fault(soap, "tag name or namespace mismatch", (const char *)(void *)0);
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L9:
      ;
      if(!(soap->type[0l] == 0))
        *s=soap_set_validation_fault(soap, "type mismatch ", soap->type);

      else
        *s=soap_set_validation_fault(soap, "invalid value", (const char *)(void *)0);
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L12:
      ;
      *s=soap_set_validation_fault(soap, "syntax error", (const char *)(void *)0);
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L13:
      ;
      _Bool tmp_if_expr_2;
      if((signed int)soap->version == 0)
        tmp_if_expr_2 = soap->level == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        *s=soap_set_validation_fault(soap, "missing root element", (const char *)(void *)0);

      else
      {
        _Bool tmp_if_expr_1;
        if(!((signed int)soap->version == 0))
          tmp_if_expr_1 = soap->level < (unsigned int)3 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        if(tmp_if_expr_1)
          *s=soap_set_validation_fault(soap, "missing SOAP message", (const char *)(void *)0);

        else
          *s=soap_set_validation_fault(soap, "missing element", (const char *)(void *)0);
      }
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L22:
      ;
      *c = "SOAP-ENV:MustUnderstand";
      snprintf(soap->msgbuf, sizeof(char [1024l]) /*1024ul*/ , "The data in element '%s' must be understood but cannot be processed", (const void *)soap->tag);
      *s = soap->msgbuf;
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L23:
      ;
      *c = "SOAP-ENV:VersionMismatch";
      *s = "Invalid SOAP message or SOAP version mismatch";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L24:
      ;
      *c = "SOAP-ENV:DataEncodingUnknown";
      *s = "Unsupported SOAP data encoding";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L25:
      ;
      *s=soap_set_validation_fault(soap, "namespace error", (const char *)(void *)0);
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L26:
      ;
      *s = "User data access error";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L27:
      ;
      *s = "A fatal error has occurred";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L28:
      ;
      snprintf(soap->msgbuf, sizeof(char [1024l]) /*1024ul*/ , "Method '%s' not implemented: method name or namespace not recognized", (const void *)soap->tag);
      *s = soap->msgbuf;
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L29:
      ;
      *s = "Data required for operation";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L30:
      ;
      *s = "HTTP GET method not implemented";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L31:
      ;
      *s = "HTTP PUT method not implemented";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L32:
      ;
      *s = "HTTP method not implemented";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L33:
      ;
      *s = "Out of memory";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L34:
      ;
      *s = "Memory overflow or memory corruption error";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L35:
      ;
      *s = "Header line too long";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L36:
      ;
      *s = "Array index out of bounds";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L37:
      ;
      *s=soap_set_validation_fault(soap, "nil not allowed", (const char *)(void *)0);
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L38:
      ;
      *s=soap_set_validation_fault(soap, "multiple elements (use the SOAP_XML_TREE flag) with duplicate id ", soap->id);
      if((signed int)soap->version == 2)
      {
        return_value_soap_faultsubcode_3=soap_faultsubcode(soap);
        *return_value_soap_faultsubcode_3 = "SOAP-ENC:DuplicateID";
      }

      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L40:
      ;
      *s=soap_set_validation_fault(soap, "missing id for ref ", soap->id);
      if((signed int)soap->version == 2)
      {
        return_value_soap_faultsubcode_4=soap_faultsubcode(soap);
        *return_value_soap_faultsubcode_4 = "SOAP-ENC:MissingID";
      }

      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L42:
      ;
      *s=soap_set_validation_fault(soap, "incompatible object type id-ref ", soap->id);
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L43:
      ;
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L44:
      ;
      *s = "Message too large for UDP packet";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L45:
      ;
      *s=tcp_error(soap);
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L46:
      ;
      *s = "An HTTP processing error occurred";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L47:
      ;
      *s = "An HTTP NTLM authentication error occurred";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L48:
      ;
      *s = "OpenSSL not installed: recompile with -DWITH_OPENSSL";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L49:
      ;
      *s = "Plugin registry error";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L50:
      ;
      *s = "DIME format error or max DIME size exceeds SOAP_MAXDIMESIZE";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L51:
      ;
      *s = "DIME href to missing attachment";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L52:
      ;
      *s = "DIME version/transmission error";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L53:
      ;
      *s = "End of DIME error";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L54:
      ;
      *s = "MIME format error";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L55:
      ;
      *s = "MIME href to missing attachment";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L56:
      ;
      *s = "End of MIME error";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L57:
      ;
      *s = "Zlib/gzip not installed for (de)compression: recompile with -DWITH_GZIP";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L58:
      ;
      *s=soap_set_validation_fault(soap, "missing required attribute", (const char *)(void *)0);
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L59:
      ;
      *s=soap_set_validation_fault(soap, "prohibited attribute present", (const char *)(void *)0);
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L60:
      ;
      *s=soap_set_validation_fault(soap, "occurrence violation", (const char *)(void *)0);
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L61:
      ;
      *s=soap_set_validation_fault(soap, "value range or content length violation", (const char *)(void *)0);
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L62:
      ;
      *s = "Maximum number of open connections was reached (no define HAVE_POLL): increase FD_SETSIZE";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L63:
      ;
      *s = "UTF content encoding error";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L64:
      ;
      *s = "Stopped: no response sent or received (informative)";
      goto __CPROVER_DUMP_L81;

    __CPROVER_DUMP_L65:
      ;
      *s=soap_strerror(soap);
      return_value_strlen_11=strlen(soap->msgbuf);
      if(!(25ul + return_value_strlen_11 >= sizeof(char [1024l]) /*1024ul*/ ))
      {
        _Bool tmp_if_expr_8;
        if(!(soap->msgbuf + 25l == ((char *)NULL)))
        {
          return_value_strlen_7=strlen(soap->msgbuf);
          tmp_if_expr_8 = (unsigned long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)25) >= (unsigned long int)(return_value_strlen_7 + (unsigned long int)1) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_8 = (_Bool)0;
        if(tmp_if_expr_8)
        {
          return_value_strlen_5=strlen(soap->msgbuf);
          return_value_memmove_6=memmove((void *)(soap->msgbuf + (signed long int)25), (const void *)soap->msgbuf, return_value_strlen_5 + (unsigned long int)1);
          (signed int)!(return_value_memmove_6 != NULL);
        }

        else
          34;
        if(!(soap->is == ((const char *)NULL)))
        {
          return_value_memcpy_9=memcpy((void *)soap->msgbuf, (const void *)"End at NUL buffer input: ", (unsigned long int)25);
          (signed int)!(return_value_memcpy_9 != NULL);
        }

        else
        {
          return_value_memcpy_10=memcpy((void *)soap->msgbuf, (const void *)"End of file or no input: ", (unsigned long int)25);
          (signed int)!(return_value_memcpy_10 != NULL);
        }
      }

      goto __CPROVER_DUMP_L81;
    }
    _Bool tmp_if_expr_12;
    if(soap->error >= 200)
      tmp_if_expr_12 = soap->error < 600 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_12 = (_Bool)0;
    if(tmp_if_expr_12)
    {
      const char *t;
      t=http_error(soap, soap->error);
      snprintf(soap->msgbuf, sizeof(char [1024l]) /*1024ul*/ , "Error %d: HTTP %d %s", soap->error, soap->error, t);
      *s = soap->msgbuf;
    }

    else
    {
      snprintf(soap->msgbuf, sizeof(char [1024l]) /*1024ul*/ , "Error %d", soap->error);
      *s = soap->msgbuf;
    }
  }


__CPROVER_DUMP_L81:
  ;
}

// soap_set_local_namespaces
// file stdsoap2.c line 10136
void soap_set_local_namespaces(struct soap *soap)
{
  void *return_value_memcpy_2;
  signed int return_value_strcmp_3;
  if(!(soap->namespaces == ((struct Namespace *)NULL)))
  {
    if(soap->local_namespaces == ((struct Namespace *)NULL))
    {
      struct Namespace *ns1;
      struct Namespace *ns2;
      unsigned long int n = (unsigned long int)1;
      ns1 = soap->namespaces;
      for( ; !(ns1->id == ((const char *)NULL)); ns1 = ns1 + 1l)
        n = n + 1ul;
      n = n * sizeof(struct Namespace) /*32ul*/ ;
      void *return_value_malloc_1;
      return_value_malloc_1=malloc(n);
      ns2 = (struct Namespace *)return_value_malloc_1;
      if(!(ns2 == ((struct Namespace *)NULL)))
      {
        if(!(ns2 == ((struct Namespace *)NULL)))
        {
          return_value_memcpy_2=memcpy((void *)ns2, (const void *)soap->namespaces, n);
          (signed int)!(return_value_memcpy_2 != NULL);
        }

        else
          34;
        if(!(ns2->ns == ((const char *)NULL)))
        {
          signed int return_value_strcmp_4;
          return_value_strcmp_4=strcmp((ns2 + (signed long int)0)->ns, soap_env1);
          if(return_value_strcmp_4 == 0)
            soap->version = (signed short int)1;

          else
          {
            return_value_strcmp_3=strcmp((ns2 + (signed long int)0)->ns, soap_env2);
            if(return_value_strcmp_3 == 0)
              soap->version = (signed short int)2;

          }
        }

        soap->local_namespaces = ns2;
        for( ; !(ns2->id == ((const char *)NULL)); ns2 = ns2 + 1l)
          ns2->out = (char *)(void *)0;
      }

    }

  }

}

// soap_set_mime
// file stdsoap2.c line 16206
void soap_set_mime(struct soap *soap, const char *boundary, const char *start)
{
  soap->omode = soap->omode | 0x00000100;
  soap->mime.first = (struct soap_multipart *)(void *)0;
  soap->mime.last = (struct soap_multipart *)(void *)0;
  soap->mime.boundary=soap_strdup(soap, boundary);
  soap->mime.start=soap_strdup(soap, start);
}

// soap_set_mime_attachment
// file stdsoap2.c line 16304
signed int soap_set_mime_attachment(struct soap *soap, char *ptr, unsigned long int size, enum soap_mime_encoding encoding, const char *type, const char *id, const char *location, const char *description)
{
  struct soap_multipart *content;
  content=soap_new_multipart(soap, &soap->mime.first, &soap->mime.last, ptr, size);
  if(content == ((struct soap_multipart *)NULL))
    return 20;

  else
  {
    content->id=soap_strdup(soap, id);
    content->type=soap_strdup(soap, type);
    content->encoding = encoding;
    content->location=soap_strdup(soap, location);
    content->description=soap_strdup(soap, description);
    return 0;
  }
}

// soap_set_namespaces
// file stdsoap2.c line 10079
signed int soap_set_namespaces(struct soap *soap, struct Namespace *p)
{
  struct Namespace *ns = soap->local_namespaces;
  struct soap_nlist *np;
  struct soap_nlist *nq;
  struct soap_nlist *nr;
  unsigned int level = soap->level;
  soap->namespaces = p;
  soap->local_namespaces = (struct Namespace *)(void *)0;
  soap_set_local_namespaces(soap);
  np = soap->nlist;
  soap->nlist = (struct soap_nlist *)(void *)0;
  if(!(np == ((struct soap_nlist *)NULL)))
  {
    nq = np->next;
    np->next = (struct soap_nlist *)(void *)0;
    for( ; !(nq == ((struct soap_nlist *)NULL)); nq = nr)
    {
      nr = nq->next;
      nq->next = np;
      np = nq;
    }
  }

  struct soap_nlist *return_value_soap_push_namespace_1;
  while(!(np == ((struct soap_nlist *)NULL)))
  {
    const char *s;
    soap->level = np->level;
    s = np->ns;
    if(s == ((const char *)NULL))
    {
      if((signed int)np->index >= 0)
      {
        if(!(ns == ((struct Namespace *)NULL)))
        {
          s = (ns + (signed long int)np->index)->out;
          if(s == ((const char *)NULL))
            s = (ns + (signed long int)np->index)->ns;

        }

      }

    }

    if(!(s == ((const char *)NULL)))
    {
      return_value_soap_push_namespace_1=soap_push_namespace(soap, np->id, s);
      if(return_value_soap_push_namespace_1 == ((struct soap_nlist *)NULL))
        return soap->error;

    }

    nq = np;
    np = np->next;
    free((void *)nq);
  }
  if(!(ns == ((struct Namespace *)NULL)))
  {
    signed int i = 0;
    for( ; !((ns + (signed long int)i)->id == ((const char *)NULL)); i = i + 1)
      if(!((ns + (signed long int)i)->out == ((char *)NULL)))
      {
        free((void *)(ns + (signed long int)i)->out);
        (ns + (signed long int)i)->out = (char *)(void *)0;
      }

    free((void *)ns);
  }

  soap->level = level;
  return 0;
}

// soap_set_receiver_error
// file stdsoap2.c line 18142
signed int soap_set_receiver_error(struct soap *soap, const char *faultstring, const char *faultdetailXML, signed int soaperror)
{
  char *tmp_if_expr_1;
  if((signed int)soap->version == 2)
    tmp_if_expr_1 = "SOAP-ENV:Receiver";

  else
    tmp_if_expr_1 = (signed int)soap->version == 1 ? "SOAP-ENV:Server" : "is internal";
  signed int return_value_soap_set_error_2;
  return_value_soap_set_error_2=soap_set_error(soap, tmp_if_expr_1, (const char *)(void *)0, faultstring, faultdetailXML, soaperror);
  return return_value_soap_set_error_2;
}

// soap_set_recv_logfile
// file stdsoap2.c line 9315
void soap_set_recv_logfile(struct soap *soap, const char *logfile)
{
  (void)soap;
  (void)logfile;
}

// soap_set_sender_error
// file stdsoap2.c line 18131
signed int soap_set_sender_error(struct soap *soap, const char *faultstring, const char *faultdetailXML, signed int soaperror)
{
  char *tmp_if_expr_1;
  if((signed int)soap->version == 2)
    tmp_if_expr_1 = "SOAP-ENV:Sender";

  else
    tmp_if_expr_1 = (signed int)soap->version == 1 ? "SOAP-ENV:Client" : "at source";
  signed int return_value_soap_set_error_2;
  return_value_soap_set_error_2=soap_set_error(soap, tmp_if_expr_1, (const char *)(void *)0, faultstring, faultdetailXML, soaperror);
  return return_value_soap_set_error_2;
}

// soap_set_sent_logfile
// file stdsoap2.c line 9328
void soap_set_sent_logfile(struct soap *soap, const char *logfile)
{
  (void)soap;
  (void)logfile;
}

// soap_set_test_logfile
// file stdsoap2.c line 9341
void soap_set_test_logfile(struct soap *soap, const char *logfile)
{
  (void)soap;
  (void)logfile;
}

// soap_set_validation_fault
// file stdsoap2.c line 17611
static const char * soap_set_validation_fault(struct soap *soap, const char *s, const char *t)
{
  if(t == ((const char *)NULL))
    t = soap_padding;

  if(!(soap->tag[0l] == 0))
    snprintf(soap->msgbuf, sizeof(char [1024l]) /*1024ul*/ , "Validation constraint violation: %s%s in element '%s'", s, t, (const void *)soap->tag);

  else
    snprintf(soap->msgbuf, sizeof(char [1024l]) /*1024ul*/ , "Validation constraint violation: %s%s", s, t);
  return soap->msgbuf;
}

// soap_set_version
// file stdsoap2.c line 10023
void soap_set_version(struct soap *soap, signed short int version)
{
  soap_set_local_namespaces(soap);
  if(!(soap->version == version))
  {
    if(!(soap->local_namespaces == ((struct Namespace *)NULL)))
    {
      if(!(soap->local_namespaces->id == ((const char *)NULL)))
      {
        if(!((soap->local_namespaces + 1l)->id == ((const char *)NULL)))
        {
          if((signed int)version == 1)
          {
            (soap->local_namespaces + (signed long int)0)->ns = soap_env1;
            (soap->local_namespaces + (signed long int)1)->ns = soap_enc1;
          }

          else
            if((signed int)version == 2)
            {
              (soap->local_namespaces + (signed long int)0)->ns = soap_env2;
              (soap->local_namespaces + (signed long int)1)->ns = soap_enc2;
            }

          soap->version = version;
        }

      }

    }

  }

  if((signed int)version == 0)
    soap->encodingStyle = soap_padding;

  else
    soap->encodingStyle = (const char *)(void *)0;
}

// soap_short2s
// file stdsoap2.c line 13284
const char * soap_short2s(struct soap *soap, signed short int n)
{
  const char *return_value_soap_long2s_1;
  return_value_soap_long2s_1=soap_long2s(soap, (signed long int)n);
  return return_value_soap_long2s_1;
}

// soap_size
// file stdsoap2.c line 2819
unsigned long int soap_size(const signed int *size, signed int dim)
{
  signed int i;
  unsigned long int n = (unsigned long int)0;
  if(!(*size >= 1))
    return (unsigned long int)0;

  else
  {
    n = (unsigned long int)size[(signed long int)0];
    i = 1;
    for( ; !(i >= dim); i = i + 1)
    {
      if(!(size[(signed long int)i] >= 1))
        return (unsigned long int)0;

      n = n * (unsigned long int)size[(signed long int)i];
    }
    return (unsigned long int)n;
  }
}

// soap_size_block
// file stdsoap2.c line 2612
unsigned long int soap_size_block(struct soap *soap, struct soap_blist *b, unsigned long int n)
{
  if(b == ((struct soap_blist *)NULL))
    b = soap->blist;

  if(!(b->head == ((struct soap_bhead *)NULL)))
  {
    b->size = b->size - (b->head->size - n);
    b->head->size = n;
  }

  return b->size;
}

// soap_sprint_fault
// file stdsoap2.c line 18276
char * soap_sprint_fault(struct soap *soap, char *buf, unsigned long int len)
{
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  if(soap == ((struct soap *)NULL))
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    if(!((signed int)soap->state == 1))
      tmp_if_expr_3 = (signed int)soap->state != 2 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_4)
  {
    if(len >= 1ul && !(buf == ((char *)NULL)))
    {
      strncpy(buf, "Error: soap struct not initialized with soap_init", len - (unsigned long int)1);
      buf[(signed long int)(len - (unsigned long int)1)] = (char)0;
      if(!(buf[-1l + (signed long int)len] == 0))
        (_Bool)1;

      else
        (_Bool)0;
    }

    else
      (_Bool)0;
  }

  else
    if(!(soap->error == 0))
    {
      const char **c;
      const char *v = (const char *)(void *)0;
      const char *s;
      const char *d;
      c=soap_faultcode(soap);
      if(*c == ((const char *)NULL))
        soap_set_fault(soap);

      if((signed int)soap->version == 2)
        v=soap_check_faultsubcode(soap);

      const char **return_value_soap_faultstring_1;
      return_value_soap_faultstring_1=soap_faultstring(soap);
      s = *return_value_soap_faultstring_1;
      d=soap_check_faultdetail(soap);
      signed int tmp_if_expr_2;
      if(!(soap->version == 0))
        tmp_if_expr_2 = (signed int)soap->version;

      else
        tmp_if_expr_2 = soap->error;
      snprintf(buf, len, "%s%d fault %s [%s]\n\"%s\"\nDetail: %s\n", soap->version != 0 ? "SOAP 1." : "Error ", tmp_if_expr_2, *c, v != ((const char *)NULL) ? v : "no subcode", s != ((const char *)NULL) ? s : "[no reason]", d != ((const char *)NULL) ? d : "[no detail]");
    }

  return buf;
}

// soap_store_lab
// file stdsoap2.c line 11538
signed int soap_store_lab(struct soap *soap, const char *s, unsigned long int n)
{
  soap->labidx = (unsigned long int)0;
  signed int return_value_soap_append_lab_1;
  return_value_soap_append_lab_1=soap_append_lab(soap, s, n);
  return return_value_soap_append_lab_1;
}

// soap_strdup
// file stdsoap2.c line 2257
char * soap_strdup(struct soap *soap, const char *s)
{
  char *t = (char *)(void *)0;
  void *return_value_memcpy_2;
  if(!(s == ((const char *)NULL)))
  {
    unsigned long int l;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(s);
    l = return_value_strlen_1 + (unsigned long int)1;
    void *return_value_soap_malloc_3;
    return_value_soap_malloc_3=soap_malloc(soap, l);
    t = (char *)return_value_soap_malloc_3;
    if(!(t == ((char *)NULL)))
    {
      if(!(t == ((char *)NULL)))
      {
        return_value_memcpy_2=memcpy((void *)t, (const void *)s, l);
        (signed int)!(return_value_memcpy_2 != NULL);
      }

      else
        34;
    }

  }

  return t;
}

// soap_strerror
// file stdsoap2.c line 18042
static const char * soap_strerror(struct soap *soap)
{
  signed int err = soap->errnum;
  soap->msgbuf[0l] = (char)0;
  if(!(err == 0))
    __xpg_strerror_r(err, soap->msgbuf, sizeof(char [1024l]) /*1024ul*/ );

  else
  {
    signed int rt = soap->recv_timeout;
    signed int st = soap->send_timeout;
    signed int ru = 32;
    signed int su = 32;
    strncpy(soap->msgbuf, "message transfer interrupted", sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
    soap->msgbuf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
    (void)(soap->msgbuf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
    if(!(rt == 0) || !(st == 0))
    {
      if(!(soap->msgbuf + 28l == ((char *)NULL)))
      {
        strncpy(soap->msgbuf + (signed long int)28, " or timed out", (sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)28) - (unsigned long int)1);
        (soap->msgbuf + (signed long int)28)[(signed long int)((sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)28) - (unsigned long int)1)] = (char)0;
        if(!(soap->msgbuf[1023l] == 0))
          (_Bool)1;

        else
          (_Bool)0;
      }

      else
        (_Bool)0;
    }

    if(!(rt >= 0))
    {
      rt = -rt;
      ru = 117;
    }

    if(!(st >= 0))
    {
      st = -st;
      su = 117;
    }

    if(!(rt == 0))
    {
      unsigned long int soap_strerror__1__2__3__l;
      soap_strerror__1__2__3__l=strlen(soap->msgbuf);
      snprintf(soap->msgbuf + (signed long int)soap_strerror__1__2__3__l, sizeof(char [1024l]) /*1024ul*/  - soap_strerror__1__2__3__l, " (%d%cs recv delay)", rt, ru);
    }

    if(!(st == 0))
    {
      unsigned long int l;
      l=strlen(soap->msgbuf);
      snprintf(soap->msgbuf + (signed long int)l, sizeof(char [1024l]) /*1024ul*/  - l, " (%d%cs send delay)", st, su);
    }

  }
  return soap->msgbuf;
}

// soap_string
// file stdsoap2.c line 14112
static const char * soap_string(struct soap *soap, const char *s, signed long int minlen, signed long int maxlen)
{
  unsigned long int return_value_soap_utf8len_1;
  unsigned long int return_value_strlen_2;
  if(!(s == ((const char *)NULL)))
  {
    if(maxlen >= 0l || minlen >= 1l)
    {
      signed long int l;
      if(!((0x02000000 & soap->mode) == 0))
      {
        return_value_soap_utf8len_1=soap_utf8len(s);
        l = (signed long int)return_value_soap_utf8len_1;
      }

      else
      {
        return_value_strlen_2=strlen(s);
        l = (signed long int)return_value_strlen_2;
      }
      if(!(l >= minlen) || !(maxlen >= l))
      {
        soap->error = 45;
        return (const char *)(void *)0;
      }

    }

  }

  return s;
}

// soap_string_in
// file stdsoap2.c line 12129
char * soap_string_in(struct soap *soap, signed int flag, signed long int minlen, signed long int maxlen, const char *pattern)
{
  char *s;
  char *t = (char *)(void *)0;
  unsigned long int i;
  signed long int soap_string_in__1__l = (signed long int)0;
  signed int n = 0;
  signed int f = 0;
  signed int m = 0;
  signed int c;
  char buf[16l];
  signed int tmp_if_expr_3;
  signed int tmp_if_expr_6;
  if(!(flag >= 1))
  {
    if(!(soap->peeked == 0))
    {
      if(!(soap->tag[0l] == 0))
      {
        struct soap_attribute *tp;
        t = soap->tmpbuf;
        *t = (char)60;
        if(!(t + 1l == ((char *)NULL)))
        {
          strncpy(t + (signed long int)1, soap->tag, (sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1) - (unsigned long int)1);
          (t + (signed long int)1)[(signed long int)((sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1) - (unsigned long int)1)] = (char)0;
          if(!(t[1023l] == 0))
            (_Bool)1;

          else
            (_Bool)0;
        }

        else
          (_Bool)0;
        unsigned long int return_value_strlen_1;
        return_value_strlen_1=strlen(t);
        t = t + (signed long int)return_value_strlen_1;
        tp = soap->attributes;
        for( ; !(tp == ((struct soap_attribute *)NULL)); tp = tp->next)
          if(!(tp->visible == 0))
          {
            unsigned long int l;
            l=strlen(tp->name);
            if(t + (signed long int)l + 1l >= soap->tmpbuf + (signed long int)sizeof(char [1024l]) /*1024l*/ )
              break;

            char *tmp_post_2 = t;
            t = t + 1l;
            *tmp_post_2 = (char)32;
            if(!(t == ((char *)NULL)))
            {
              if(!(l >= sizeof(char [1024l]) /*1024ul*/  + -((unsigned long int)(t - soap->tmpbuf))))
              {
                strncpy(t, tp->name, l);
                t[(signed long int)(unsigned long int)l] = (char)0;
                tmp_if_expr_3 = (signed int)t[(signed long int)(unsigned long int)l];
              }

              else
              {
                t[(signed long int)0] = (char)0;
                tmp_if_expr_3 = (signed int)t[(signed long int)0];
              }
              if(!(tmp_if_expr_3 == 0))
                (_Bool)1;

              else
                (_Bool)0;
            }

            else
              (_Bool)0;
            t = t + (signed long int)l;
            if(!(tp->value == ((char *)NULL)))
            {
              l=strlen(tp->value);
              if(t + (signed long int)l + 3l >= soap->tmpbuf + (signed long int)sizeof(char [1024l]) /*1024l*/ )
                break;

              char *tmp_post_4 = t;
              t = t + 1l;
              *tmp_post_4 = (char)61;
              char *tmp_post_5 = t;
              t = t + 1l;
              *tmp_post_5 = (char)34;
              if(!(t == ((char *)NULL)))
              {
                if(!(l >= sizeof(char [1024l]) /*1024ul*/  + -((unsigned long int)(t - soap->tmpbuf))))
                {
                  strncpy(t, tp->value, l);
                  t[(signed long int)(unsigned long int)l] = (char)0;
                  tmp_if_expr_6 = (signed int)t[(signed long int)(unsigned long int)l];
                }

                else
                {
                  t[(signed long int)0] = (char)0;
                  tmp_if_expr_6 = (signed int)t[(signed long int)0];
                }
                if(!(tmp_if_expr_6 == 0))
                  (_Bool)1;

                else
                  (_Bool)0;
              }

              else
                (_Bool)0;
              t = t + (signed long int)l;
              char *tmp_post_7 = t;
              t = t + 1l;
              *tmp_post_7 = (char)34;
            }

          }

        if(soap->body == 0)
        {
          char *tmp_post_8 = t;
          t = t + 1l;
          *tmp_post_8 = (char)47;
        }

        char *tmp_post_9 = t;
        t = t + 1l;
        *tmp_post_9 = (char)62;
        *t = (char)0;
        t = soap->tmpbuf;
        unsigned long int return_value_strlen_10;
        return_value_strlen_10=strlen(soap->tmpbuf);
        m = (signed int)return_value_strlen_10;
        if(!(soap->body == 0))
          n = 1;

        f = 1;
        soap->peeked = (signed short int)0;
      }

    }

  }

  unsigned long int return_value___ctype_get_mb_cur_max_48;
  if(!(flag >= 1))
  {
    signed int state = 0;
    soap->labidx = (unsigned long int)0;
    do
    {
      unsigned long int k;
      signed int return_value_soap_append_lab_11;
      return_value_soap_append_lab_11=soap_append_lab(soap, (const char *)(void *)0, (unsigned long int)0);
      if(!(return_value_soap_append_lab_11 == 0))
        return (char *)(void *)0;

      s = soap->labbuf + (signed long int)soap->labidx;
      k = soap->lablen - soap->labidx;
      soap->labidx = soap->lablen;
      i = (unsigned long int)0;
      for( ; !(i >= k); i = i + 1ul)
      {
        if(m >= 1)
        {
          char *tmp_post_12 = s;
          s = s + 1l;
          char *tmp_post_13 = t;
          t = t + 1l;
          *tmp_post_12 = *tmp_post_13;
          m = m - 1;
        }

        else
        {
          c=soap_getchar(soap);
          if(c == -1)
            goto end;

          if(!(state == 1) && (c >= 0x80 || !(c >= -6)))
          {
            if((0x00000020 & soap->mode) == 0)
            {
              if((0x7FFFFFFF & c) >= 0x80)
              {
                soap->ahead = c;
                c=soap_getutf8(soap);
              }

              if((0x7FFFFFFF & c) >= 0x80)
              {
                _Bool tmp_if_expr_26;
                if(!(flag >= 1))
                  tmp_if_expr_26 = (_Bool)1;

                else
                  tmp_if_expr_26 = (soap->mode & 0x02000000) != 0 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_26)
                {
                  c = c & 0x7FFFFFFF;
                  t = buf;
                  if(!(c >= 0x0800))
                  {
                    char *tmp_post_14 = t;
                    t = t + 1l;
                    *tmp_post_14 = (char)(0xC0 | c >> 6 & 0x1F);
                  }

                  else
                  {
                    if(!(c >= 0x010000))
                    {
                      char *tmp_post_15 = t;
                      t = t + 1l;
                      *tmp_post_15 = (char)(0xE0 | c >> 12 & 0x0F);
                    }

                    else
                    {
                      if(!(c >= 0x200000))
                      {
                        char *tmp_post_16 = t;
                        t = t + 1l;
                        *tmp_post_16 = (char)(0xF0 | c >> 18 & 0x07);
                      }

                      else
                      {
                        if(!(c >= 0x04000000))
                        {
                          char *tmp_post_17 = t;
                          t = t + 1l;
                          *tmp_post_17 = (char)(0xF8 | c >> 24 & 0x03);
                        }

                        else
                        {
                          char *tmp_post_18 = t;
                          t = t + 1l;
                          *tmp_post_18 = (char)(0xFC | c >> 30 & 0x01);
                          char *tmp_post_19 = t;
                          t = t + 1l;
                          *tmp_post_19 = (char)(0x80 | c >> 24 & 0x3F);
                        }
                        char *tmp_post_20 = t;
                        t = t + 1l;
                        *tmp_post_20 = (char)(0x80 | c >> 18 & 0x3F);
                      }
                      char *tmp_post_21 = t;
                      t = t + 1l;
                      *tmp_post_21 = (char)(0x80 | c >> 12 & 0x3F);
                    }
                    char *tmp_post_22 = t;
                    t = t + 1l;
                    *tmp_post_22 = (char)(0x80 | c >> 6 & 0x3F);
                  }
                  char *tmp_post_23 = t;
                  t = t + 1l;
                  *tmp_post_23 = (char)(0x80 | c & 0x3F);
                  m = (signed int)(t - buf) - 1;
                  t = buf;
                  char *tmp_post_24 = s;
                  s = s + 1l;
                  char *tmp_post_25 = t;
                  t = t + 1l;
                  *tmp_post_24 = *tmp_post_25;
                  goto __CPROVER_DUMP_L94;
                }

              }

            }

          }

          switch(state)
          {
            case 1:
            {
              if(c == 93)
                state = 4;

              char *tmp_post_27 = s;
              s = s + 1l;
              *tmp_post_27 = (char)c;
              break;
            }
            case 2:
            {
              if(c == 45)
                state = 6;

              char *tmp_post_28 = s;
              s = s + 1l;
              *tmp_post_28 = (char)c;
              break;
            }
            case 3:
            {
              if(c == 63)
                state = 8;

              char *tmp_post_29 = s;
              s = s + 1l;
              *tmp_post_29 = (char)c;
              break;
            }
            case 4:
            {
              if(c == 93)
                state = 5;

              else
                state = 1;
              char *tmp_post_30 = s;
              s = s + 1l;
              *tmp_post_30 = (char)c;
              break;
            }
            case 5:
            {
              if(c == 62)
                state = 0;

              else
                if(!(c == 93))
                  state = 1;

              char *tmp_post_31 = s;
              s = s + 1l;
              *tmp_post_31 = (char)c;
              break;
            }
            case 6:
            {
              if(c == 45)
                state = 7;

              else
                state = 2;
              char *tmp_post_32 = s;
              s = s + 1l;
              *tmp_post_32 = (char)c;
              break;
            }
            case 7:
            {
              if(c == 62)
                state = 0;

              else
                if(!(c == 45))
                  state = 2;

              char *tmp_post_33 = s;
              s = s + 1l;
              *tmp_post_33 = (char)c;
              break;
            }
            case 8:
            {
              if(c == 62)
                state = 0;

              else
                if(!(c == 63))
                  state = 3;

              char *tmp_post_34 = s;
              s = s + 1l;
              *tmp_post_34 = (char)c;
              break;
            }
            default:
            {
              if(!(c == -3))
              {
                if(c == -2)
                  goto __CPROVER_DUMP_L66;

                if(c == -4)
                  goto __CPROVER_DUMP_L67;

                if(c == -5)
                  goto __CPROVER_DUMP_L68;

                if(c == -6)
                  goto __CPROVER_DUMP_L69;

                if(c == 47)
                  goto __CPROVER_DUMP_L70;

                if(c == 60)
                  goto __CPROVER_DUMP_L73;

                if(c == 62)
                  goto __CPROVER_DUMP_L85;

                if(c == 34)
                  goto __CPROVER_DUMP_L86;

              }

              else
              {
                if(n == 0)
                  goto end;

                n = n - 1;
                char *tmp_post_35 = s;
                s = s + 1l;
                *tmp_post_35 = (char)60;
                t = (char *)"/";
                m = 1;
                goto __CPROVER_DUMP_L93;

              __CPROVER_DUMP_L66:
                ;
                if(f == 0 && flag >= 0 || n == 0 && !(f == 0))
                  goto end;

                n = n + 1;
                char *tmp_post_36 = s;
                s = s + 1l;
                *tmp_post_36 = (char)60;
                goto __CPROVER_DUMP_L93;

              __CPROVER_DUMP_L67:
                ;
                char *tmp_post_37 = s;
                s = s + 1l;
                *tmp_post_37 = (char)62;
                goto __CPROVER_DUMP_L93;

              __CPROVER_DUMP_L68:
                ;
                char *tmp_post_38 = s;
                s = s + 1l;
                *tmp_post_38 = (char)34;
                goto __CPROVER_DUMP_L93;

              __CPROVER_DUMP_L69:
                ;
                char *tmp_post_39 = s;
                s = s + 1l;
                *tmp_post_39 = (char)39;
                goto __CPROVER_DUMP_L93;

              __CPROVER_DUMP_L70:
                ;
                if(n >= 1)
                {
                  c=soap_getchar(soap);
                  if(c == 62)
                    n = n - 1;

                  soap->ahead = c;
                }

                char *tmp_post_40 = s;
                s = s + 1l;
                *tmp_post_40 = (char)47;
                goto __CPROVER_DUMP_L93;

              __CPROVER_DUMP_L73:
                ;
                c=soap_getchar(soap);
                if(c == 47)
                {
                  if(n == 0)
                  {
                    c = (signed int)-3;
                    goto end;
                  }

                  n = n - 1;
                }

                else
                  if(c == 33)
                  {
                    c=soap_getchar(soap);
                    if(c == 91)
                    {
                      do
                        c=soap_getchar(soap);
                      while(!(c == 91) && !(c == -1));
                      if(c == -1)
                        goto end;

                      t = (char *)"![CDATA[";
                      m = 8;
                      state = 1;
                    }

                    else
                      if(c == 45)
                      {
                        c=soap_getchar(soap);
                        if(c == 45)
                          state = 2;

                        t = (char *)"!-";
                        m = 2;
                        soap->ahead = c;
                      }

                      else
                      {
                        t = (char *)"!";
                        m = 1;
                        soap->ahead = c;
                      }
                    char *tmp_post_41 = s;
                    s = s + 1l;
                    *tmp_post_41 = (char)60;
                    goto __CPROVER_DUMP_L93;
                  }

                  else
                    if(c == 63)
                      state = 3;

                    else
                      if(n == 0 && !(f == 0))
                      {
                        soap->bufidx = soap->bufidx - 1ul;
                        c = 60;
                        goto end;
                      }

                      else
                        n = n + 1;
                soap->ahead = c;
                char *tmp_post_42 = s;
                s = s + 1l;
                *tmp_post_42 = (char)60;
                goto __CPROVER_DUMP_L93;

              __CPROVER_DUMP_L85:
                ;
                char *tmp_post_43 = s;
                s = s + 1l;
                *tmp_post_43 = (char)62;
                goto __CPROVER_DUMP_L93;

              __CPROVER_DUMP_L86:
                ;
                char *tmp_post_44 = s;
                s = s + 1l;
                *tmp_post_44 = (char)34;
                goto __CPROVER_DUMP_L93;
              }
              if(!((0x04000000 & soap->mode) == 0))
              {
                m=wctomb(buf, (signed int)(c & 0x7FFFFFFF));
                _Bool tmp_if_expr_49;
                if(m >= 1)
                {
                  return_value___ctype_get_mb_cur_max_48=__ctype_get_mb_cur_max();
                  tmp_if_expr_49 = m <= (signed int)return_value___ctype_get_mb_cur_max_48 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr_49 = (_Bool)0;
                if(tmp_if_expr_49)
                {
                  t = buf;
                  char *tmp_post_45 = s;
                  s = s + 1l;
                  char *tmp_post_46 = t;
                  t = t + 1l;
                  *tmp_post_45 = *tmp_post_46;
                  m = m - 1;
                }

                else
                {
                  char *tmp_post_47 = s;
                  s = s + 1l;
                  *tmp_post_47 = (char)0x7F;
                  m = 0;
                }
              }

              else
              {
                char *tmp_post_50 = s;
                s = s + 1l;
                *tmp_post_50 = (char)(c & 0xFF);
              }

            __CPROVER_DUMP_L93:
              ;
              soap_string_in__1__l = soap_string_in__1__l + 1l;
              if(maxlen >= 0l && !(maxlen >= soap_string_in__1__l))
              {
                soap->error = 45;
                return (char *)(void *)0;
              }

            }
          }
        }

      __CPROVER_DUMP_L94:
        ;
      }
    }
    while((_Bool)1);
  }

  soap->labidx = (unsigned long int)0;
  unsigned long int return_value___ctype_get_mb_cur_max_85;
  do
  {
    unsigned long int soap_string_in__1__3__1__k;
    signed int return_value_soap_append_lab_51;
    return_value_soap_append_lab_51=soap_append_lab(soap, (const char *)(void *)0, (unsigned long int)0);
    if(!(return_value_soap_append_lab_51 == 0))
      return (char *)(void *)0;

    s = soap->labbuf + (signed long int)soap->labidx;
    soap_string_in__1__3__1__k = soap->lablen - soap->labidx;
    soap->labidx = soap->lablen;
    i = (unsigned long int)0;
    for( ; !(i >= soap_string_in__1__3__1__k); i = i + 1ul)
      if(m >= 1)
      {
        char *tmp_post_52 = s;
        s = s + 1l;
        char *tmp_post_53 = t;
        t = t + 1l;
        *tmp_post_52 = *tmp_post_53;
        m = m - 1;
      }

      else
      {
        c=soap_getutf8(soap);
        if(!((0x02000000 & soap->mode) == 0))
        {
          if(!(c >= 0x80) && (!(c >= -2147483520) || c >= -6))
            goto __CPROVER_DUMP_L110;

          c = c & 0x7FFFFFFF;
          t = buf;
          if(!(c >= 0x0800))
          {
            char *tmp_post_54 = t;
            t = t + 1l;
            *tmp_post_54 = (char)(0xC0 | c >> 6 & 0x1F);
          }

          else
          {
            if(!(c >= 0x010000))
            {
              char *tmp_post_55 = t;
              t = t + 1l;
              *tmp_post_55 = (char)(0xE0 | c >> 12 & 0x0F);
            }

            else
            {
              if(!(c >= 0x200000))
              {
                char *tmp_post_56 = t;
                t = t + 1l;
                *tmp_post_56 = (char)(0xF0 | c >> 18 & 0x07);
              }

              else
              {
                if(!(c >= 0x04000000))
                {
                  char *tmp_post_57 = t;
                  t = t + 1l;
                  *tmp_post_57 = (char)(0xF8 | c >> 24 & 0x03);
                }

                else
                {
                  char *tmp_post_58 = t;
                  t = t + 1l;
                  *tmp_post_58 = (char)(0xFC | c >> 30 & 0x01);
                  char *tmp_post_59 = t;
                  t = t + 1l;
                  *tmp_post_59 = (char)(0x80 | c >> 24 & 0x3F);
                }
                char *tmp_post_60 = t;
                t = t + 1l;
                *tmp_post_60 = (char)(0x80 | c >> 18 & 0x3F);
              }
              char *tmp_post_61 = t;
              t = t + 1l;
              *tmp_post_61 = (char)(0x80 | c >> 12 & 0x3F);
            }
            char *tmp_post_62 = t;
            t = t + 1l;
            *tmp_post_62 = (char)(0x80 | c >> 6 & 0x3F);
          }
          char *tmp_post_63 = t;
          t = t + 1l;
          *tmp_post_63 = (char)(0x80 | c & 0x3F);
          m = (signed int)(t - buf) - 1;
          t = buf;
          char *tmp_post_64 = s;
          s = s + 1l;
          char *tmp_post_65 = t;
          t = t + 1l;
          *tmp_post_64 = *tmp_post_65;
          soap_string_in__1__l = soap_string_in__1__l + 1l;
          if(maxlen >= 0l && !(maxlen >= soap_string_in__1__l))
          {
            soap->error = 45;
            return (char *)(void *)0;
          }

        }

        else
        {

        __CPROVER_DUMP_L110:
          ;
          if(!(c == -3))
          {
            if(c == -2)
              goto __CPROVER_DUMP_L112;

            if(c == -4)
              goto __CPROVER_DUMP_L113;

            if(c == -5)
              goto __CPROVER_DUMP_L114;

            if(c == -6)
              goto __CPROVER_DUMP_L115;

            if(c == 47)
              goto __CPROVER_DUMP_L116;

            if(c == -2147483588)
              goto __CPROVER_DUMP_L121;

            if(c == -2147483586)
              goto __CPROVER_DUMP_L124;

            if(c == -2147483610)
              goto __CPROVER_DUMP_L127;

            if(c == -2147483614)
              goto __CPROVER_DUMP_L130;

            if(c == -2147483609)
              goto __CPROVER_DUMP_L133;

          }

          else
          {
            if(n == 0)
              goto end;

            n = n - 1;
            char *tmp_post_66 = s;
            s = s + 1l;
            *tmp_post_66 = (char)60;
            t = (char *)"/";
            m = 1;
            goto __CPROVER_DUMP_L142;

          __CPROVER_DUMP_L112:
            ;
            if(f == 0 && flag >= 0 || n == 0 && !(f == 0))
              goto end;

            n = n + 1;
            char *tmp_post_67 = s;
            s = s + 1l;
            *tmp_post_67 = (char)60;
            goto __CPROVER_DUMP_L142;

          __CPROVER_DUMP_L113:
            ;
            char *tmp_post_68 = s;
            s = s + 1l;
            *tmp_post_68 = (char)62;
            goto __CPROVER_DUMP_L142;

          __CPROVER_DUMP_L114:
            ;
            char *tmp_post_69 = s;
            s = s + 1l;
            *tmp_post_69 = (char)34;
            goto __CPROVER_DUMP_L142;

          __CPROVER_DUMP_L115:
            ;
            char *tmp_post_70 = s;
            s = s + 1l;
            *tmp_post_70 = (char)39;
            goto __CPROVER_DUMP_L142;

          __CPROVER_DUMP_L116:
            ;
            if(n >= 1)
            {
              if(flag >= 1)
              {
                c=soap_get(soap);
                if(c == -4)
                  n = n - 1;

              }

              else
              {
                c=soap_getchar(soap);
                if(c == 62)
                  n = n - 1;

              }
              soap->ahead = c;
            }

            char *tmp_post_71 = s;
            s = s + 1l;
            *tmp_post_71 = (char)47;
            goto __CPROVER_DUMP_L142;

          __CPROVER_DUMP_L121:
            ;
            if(flag >= 1)
            {
              char *tmp_post_72 = s;
              s = s + 1l;
              *tmp_post_72 = (char)60;
            }

            else
            {
              char *tmp_post_73 = s;
              s = s + 1l;
              *tmp_post_73 = (char)38;
              t = (char *)"lt;";
              m = 3;
            }
            goto __CPROVER_DUMP_L142;

          __CPROVER_DUMP_L124:
            ;
            if(flag >= 1)
            {
              char *tmp_post_74 = s;
              s = s + 1l;
              *tmp_post_74 = (char)62;
            }

            else
            {
              char *tmp_post_75 = s;
              s = s + 1l;
              *tmp_post_75 = (char)38;
              t = (char *)"gt;";
              m = 3;
            }
            goto __CPROVER_DUMP_L142;

          __CPROVER_DUMP_L127:
            ;
            if(flag >= 1)
            {
              char *tmp_post_76 = s;
              s = s + 1l;
              *tmp_post_76 = (char)38;
            }

            else
            {
              char *tmp_post_77 = s;
              s = s + 1l;
              *tmp_post_77 = (char)38;
              t = (char *)"amp;";
              m = 4;
            }
            goto __CPROVER_DUMP_L142;

          __CPROVER_DUMP_L130:
            ;
            if(flag >= 1)
            {
              char *tmp_post_78 = s;
              s = s + 1l;
              *tmp_post_78 = (char)34;
            }

            else
            {
              char *tmp_post_79 = s;
              s = s + 1l;
              *tmp_post_79 = (char)38;
              t = (char *)"quot;";
              m = 5;
            }
            goto __CPROVER_DUMP_L142;

          __CPROVER_DUMP_L133:
            ;
            if(flag >= 1)
            {
              char *tmp_post_80 = s;
              s = s + 1l;
              *tmp_post_80 = (char)39;
            }

            else
            {
              char *tmp_post_81 = s;
              s = s + 1l;
              *tmp_post_81 = (char)38;
              t = (char *)"apos;";
              m = 5;
            }
            goto __CPROVER_DUMP_L142;
          }
          if(c == -1)
            goto end;

          if(!((0x04000000 & soap->mode) == 0))
          {
            m=wctomb(buf, (signed int)(c & 0x7FFFFFFF));
            _Bool tmp_if_expr_86;
            if(m >= 1)
            {
              return_value___ctype_get_mb_cur_max_85=__ctype_get_mb_cur_max();
              tmp_if_expr_86 = m <= (signed int)return_value___ctype_get_mb_cur_max_85 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_86 = (_Bool)0;
            if(tmp_if_expr_86)
            {
              t = buf;
              char *tmp_post_82 = s;
              s = s + 1l;
              char *tmp_post_83 = t;
              t = t + 1l;
              *tmp_post_82 = *tmp_post_83;
              m = m - 1;
            }

            else
            {
              char *tmp_post_84 = s;
              s = s + 1l;
              *tmp_post_84 = (char)0x7F;
              m = 0;
            }
          }

          else
          {
            char *tmp_post_87 = s;
            s = s + 1l;
            *tmp_post_87 = (char)(c & 0xFF);
          }

        __CPROVER_DUMP_L142:
          ;
          soap_string_in__1__l = soap_string_in__1__l + 1l;
          if(maxlen >= 0l && !(maxlen >= soap_string_in__1__l))
          {
            soap->error = 45;
            return (char *)(void *)0;
          }

        }
      }
  }
  while((_Bool)1);

end:
  ;
  soap->ahead = c;
  *s = (char)0;
  t=soap_strdup(soap, soap->labbuf);
  signed int return_value_soap_s2QName_88;
  if(!(soap_string_in__1__l >= minlen))
  {
    soap->error = 45;
    return (char *)(void *)0;
  }

  else
    if(!(pattern == ((const char *)NULL)))
    {
      if(soap->fsvalidate == ((signed int (*)(struct soap *, const char *, const char *))NULL))
        goto __CPROVER_DUMP_L147;

      soap->error=soap->fsvalidate(soap, pattern, s);
      return (char *)(void *)0;
    }

    else
    {

    __CPROVER_DUMP_L147:
      ;
      if(flag == 2)
      {
        return_value_soap_s2QName_88=soap_s2QName(soap, t, &t, minlen, maxlen);
        if(!(return_value_soap_s2QName_88 == 0))
          return (char *)(void *)0;

      }

      return t;
    }
}

// soap_string_out
// file stdsoap2.c line 12036
signed int soap_string_out(struct soap *soap, const char *s, signed int flag)
{
  const char *t;
  signed int c;
  signed int mask = (signed int)0xFFFFFF80UL;
  _Bool tmp_if_expr_1;
  if(flag == 2)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (soap->mode & 0x02000000) != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    mask = 0;

  t = s;
  const char *tmp_post_2;
  signed int return_value_soap_send_raw_4;
  signed int return_value_soap_send_raw_7;
  signed int return_value_soap_send_raw_10;
  signed int return_value_soap_send_raw_11;
  signed int return_value_soap_send_raw_13;
  signed int return_value_soap_send_raw_14;
  signed int return_value_soap_send_raw_17;
  signed int return_value_soap_send_raw_20;
  signed int return_value_soap_send_raw_22;
  signed int return_value_soap_send_raw_23;
  signed int return_value_soap_pututf8_27;
  signed int return_value_soap_pututf8_30;
  do
  {
    tmp_post_2 = t;
    t = t + 1l;
    c = (signed int)*tmp_post_2;
    if(c == 0)
      break;

    switch(c)
    {
      case 0x09:
      {
        if(!(flag == 0))
        {
          signed int return_value_soap_send_raw_3;
          return_value_soap_send_raw_3=soap_send_raw(soap, s, (unsigned long int)((t - s) - (signed long int)1));
          _Bool tmp_if_expr_5;
          if(!(return_value_soap_send_raw_3 == 0))
            tmp_if_expr_5 = (_Bool)1;

          else
          {
            return_value_soap_send_raw_4=soap_send_raw(soap, "&#x9;", (unsigned long int)5);
            tmp_if_expr_5 = return_value_soap_send_raw_4 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_5)
            return soap->error;

          s = t;
        }

        break;
      }
      case 0x0A:
      {
        _Bool tmp_if_expr_9;
        if(!(flag == 0))
          tmp_if_expr_9 = (_Bool)1;

        else
          tmp_if_expr_9 = !((soap->mode & 0x00010000) != 0) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_9)
        {
          signed int return_value_soap_send_raw_6;
          return_value_soap_send_raw_6=soap_send_raw(soap, s, (unsigned long int)((t - s) - (signed long int)1));
          _Bool tmp_if_expr_8;
          if(!(return_value_soap_send_raw_6 == 0))
            tmp_if_expr_8 = (_Bool)1;

          else
          {
            return_value_soap_send_raw_7=soap_send_raw(soap, "&#xA;", (unsigned long int)5);
            tmp_if_expr_8 = return_value_soap_send_raw_7 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_8)
            return soap->error;

          s = t;
        }

        break;
      }
      case 38:
      {
        return_value_soap_send_raw_10=soap_send_raw(soap, s, (unsigned long int)((t - s) - (signed long int)1));
        _Bool tmp_if_expr_12;
        if(!(return_value_soap_send_raw_10 == 0))
          tmp_if_expr_12 = (_Bool)1;

        else
        {
          return_value_soap_send_raw_11=soap_send_raw(soap, "&amp;", (unsigned long int)5);
          tmp_if_expr_12 = return_value_soap_send_raw_11 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_12)
          return soap->error;

        s = t;
        break;
      }
      case 60:
      {
        return_value_soap_send_raw_13=soap_send_raw(soap, s, (unsigned long int)((t - s) - (signed long int)1));
        _Bool tmp_if_expr_15;
        if(!(return_value_soap_send_raw_13 == 0))
          tmp_if_expr_15 = (_Bool)1;

        else
        {
          return_value_soap_send_raw_14=soap_send_raw(soap, "&lt;", (unsigned long int)4);
          tmp_if_expr_15 = return_value_soap_send_raw_14 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_15)
          return soap->error;

        s = t;
        break;
      }
      case 62:
      {
        if(flag == 0)
        {
          signed int return_value_soap_send_raw_16;
          return_value_soap_send_raw_16=soap_send_raw(soap, s, (unsigned long int)((t - s) - (signed long int)1));
          _Bool tmp_if_expr_18;
          if(!(return_value_soap_send_raw_16 == 0))
            tmp_if_expr_18 = (_Bool)1;

          else
          {
            return_value_soap_send_raw_17=soap_send_raw(soap, "&gt;", (unsigned long int)4);
            tmp_if_expr_18 = return_value_soap_send_raw_17 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_18)
            return soap->error;

          s = t;
        }

        break;
      }
      case 34:
      {
        if(!(flag == 0))
        {
          signed int return_value_soap_send_raw_19;
          return_value_soap_send_raw_19=soap_send_raw(soap, s, (unsigned long int)((t - s) - (signed long int)1));
          _Bool tmp_if_expr_21;
          if(!(return_value_soap_send_raw_19 == 0))
            tmp_if_expr_21 = (_Bool)1;

          else
          {
            return_value_soap_send_raw_20=soap_send_raw(soap, "&quot;", (unsigned long int)6);
            tmp_if_expr_21 = return_value_soap_send_raw_20 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_21)
            return soap->error;

          s = t;
        }

        break;
      }
      case 0x7F:
      {
        return_value_soap_send_raw_22=soap_send_raw(soap, s, (unsigned long int)((t - s) - (signed long int)1));
        _Bool tmp_if_expr_24;
        if(!(return_value_soap_send_raw_22 == 0))
          tmp_if_expr_24 = (_Bool)1;

        else
        {
          return_value_soap_send_raw_23=soap_send_raw(soap, "&#x7F;", (unsigned long int)6);
          tmp_if_expr_24 = return_value_soap_send_raw_23 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_24)
          return soap->error;

        s = t;
        break;
      }
      default:
      {
        if(!((0x04000000 & soap->mode) == 0))
        {
          signed int wc;
          signed int m;
          unsigned long int return_value___ctype_get_mb_cur_max_25;
          return_value___ctype_get_mb_cur_max_25=__ctype_get_mb_cur_max();
          m=mbtowc(&wc, t - (signed long int)1, return_value___ctype_get_mb_cur_max_25);
          if(m >= 1 && (!(m == 1) || !(wc == c) || c >= 0x80))
          {
            signed int return_value_soap_send_raw_26;
            return_value_soap_send_raw_26=soap_send_raw(soap, s, (unsigned long int)((t - s) - (signed long int)1));
            _Bool tmp_if_expr_28;
            if(!(return_value_soap_send_raw_26 == 0))
              tmp_if_expr_28 = (_Bool)1;

            else
            {
              return_value_soap_pututf8_27=soap_pututf8(soap, (unsigned long int)wc);
              tmp_if_expr_28 = return_value_soap_pututf8_27 != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_28)
              return soap->error;

            t = t + (signed long int)(m - 1);
            s = t;
            break;
          }

        }

        if((0xFFFFFFE0UL & (unsigned long int)c) == 0ul || !((c & mask) == 0))
        {
          signed int return_value_soap_send_raw_29;
          return_value_soap_send_raw_29=soap_send_raw(soap, s, (unsigned long int)((t - s) - (signed long int)1));
          _Bool tmp_if_expr_31;
          if(!(return_value_soap_send_raw_29 == 0))
            tmp_if_expr_31 = (_Bool)1;

          else
          {
            return_value_soap_pututf8_30=soap_pututf8(soap, (unsigned long int)(unsigned char)c);
            tmp_if_expr_31 = return_value_soap_pututf8_30 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_31)
            return soap->error;

          s = t;
        }

      }
    }
  }
  while((_Bool)1);
  signed int return_value_soap_send_raw_32;
  return_value_soap_send_raw_32=soap_send_raw(soap, s, (unsigned long int)((t - s) - (signed long int)1));
  return return_value_soap_send_raw_32;
}

// soap_strtrim
// file stdsoap2.c line 2294
char * soap_strtrim(struct soap *soap, char *s)
{
  (void)soap;
  if(!(s == ((char *)NULL)))
  {
    char *t;
    for( ; (_Bool)1; s = s + 1l)
      if((signed int)*s >= 9)
      {
        if((signed int)*s >= 14)
          goto __CPROVER_DUMP_L2;

      }

      else
      {

      __CPROVER_DUMP_L2:
        ;
        if(!((signed int)*s == 32))
          goto __CPROVER_DUMP_L4;

      }

  __CPROVER_DUMP_L4:
    ;
    t = s;
    for( ; !(*t == 0); t = t + 1l)
      ;
    do
    {
      t = t - 1l;
      if(s >= t)
        break;

      if((signed int)*t >= 9)
      {
        if((signed int)*t >= 14)
          goto __CPROVER_DUMP_L7;

      }

      else
      {

      __CPROVER_DUMP_L7:
        ;
        if(!((signed int)*t == 32))
          break;

      }
    }
    while((_Bool)1);
    t[(signed long int)1] = (char)0;
  }

  return s;
}

// soap_tag_cmp
// file ../../../gsoap/stdsoap2.h line 2938
signed int soap_tag_cmp(const char *s, const char *t)
{
  signed int return_value_soap_tag_cmp_1;
  do
  {
    signed int c1 = (signed int)*s;
    signed int c2 = (signed int)*t;
    if(c1 == 0 || c1 == 34)
      break;

    if(!(c2 == 45))
    {
      if(!(c1 == c2))
      {
        if(c1 >= 65 && !(c1 >= 91))
          c1 = c1 + (97 - 65);

        if(c2 >= 65 && !(c2 >= 91))
          c2 = c2 + (97 - 65);

      }

      if(!(c1 == c2))
      {
        if(!(c2 == 42))
          return 1;

        t = t + 1l;
        c2 = (signed int)*t;
        if(c2 == 0)
          return 0;

        if(c2 >= 65 && !(c2 >= 91))
          c2 = c2 + (97 - 65);

        do
        {
          c1 = (signed int)*s;
          if(c1 == 0 || c1 == 34)
            break;

          if(c1 >= 65 && !(c1 >= 91))
            c1 = c1 + (97 - 65);

          if(c1 == c2)
          {
            return_value_soap_tag_cmp_1=soap_tag_cmp(s + (signed long int)1, t + (signed long int)1);
            if(return_value_soap_tag_cmp_1 == 0)
              return 0;

          }

          s = s + 1l;
        }
        while((_Bool)1);
        break;
      }

    }

    s = s + 1l;
    t = t + 1l;
  }
  while((_Bool)1);
  if((signed int)*t == 42)
  {
    if(!(t[1l] == 0))
      goto __CPROVER_DUMP_L14;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L14:
    ;
    return (signed int)*t;
  }
}

// soap_tag_match
// file dom.c line 998
static signed int soap_tag_match(const char *name, const char *tag)
{
  const char *s;
  if(name == ((const char *)NULL))
    return (signed int)!(*tag != 0);

  else
  {
    s=strchr(name, 58);
    if(!(s == ((const char *)NULL)))
      name = s + (signed long int)1;

    s=strchr(tag, 58);
    if(!(s == ((const char *)NULL)))
      tag = s + (signed long int)1;

    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(name, tag);
    return (signed int)!(return_value_strcmp_1 != 0);
  }
}

// soap_tagsearch
// file stdsoap2.c line 10168
const char * soap_tagsearch(const char *big, const char *little)
{
  _Bool tmp_if_expr_1;
  if(!(big == ((const char *)NULL)) && !(little == ((const char *)NULL)))
  {
    unsigned long int n;
    n=strlen(little);
    const char *s = big;
    while(!(s == ((const char *)NULL)))
    {
      const char *t = s;
      unsigned long int i = (unsigned long int)0;
      for( ; !(i >= n); t = t + 1l)
      {
        if(!(*t == little[(signed long int)i]))
          break;

        i = i + 1ul;
      }
      _Bool tmp_if_expr_3;
      if((signed int)*t == 0)
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = (signed int)*t == 32 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3)
      {
        _Bool tmp_if_expr_2;
        if(i == n)
          tmp_if_expr_2 = (_Bool)1;

        else
        {
          if(!(i == 0ul))
            tmp_if_expr_1 = (signed int)little[(signed long int)(i - (unsigned long int)1)] == 58 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_1 = (_Bool)0;
          tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_2)
          return s;

      }

      s=strchr(t, 32);
      if(!(s == ((const char *)NULL)))
        s = s + 1l;

    }
  }

  return (const char *)(void *)0;
}

// soap_tell
// file stdsoap2.c line 1769
unsigned long int soap_tell(struct soap *soap)
{
  return ((soap->count - soap->buflen) + soap->bufidx) - (unsigned long int)(soap->ahead != 0);
}

// soap_timegm
// file stdsoap2.c line 14831
signed long int soap_timegm(struct tm *T)
{
  signed long int return_value_timegm_1;
  return_value_timegm_1=timegm(T);
  return return_value_timegm_1;
}

// soap_traverse_xsd__anyAttribute
// file dom.c line 160
void soap_traverse_xsd__anyAttribute(struct soap *soap, struct soap_dom_attribute *node, const char *s, void (*p)(struct soap *, void *, signed int, const char *, const char *), void (*q)(struct soap *, void *, signed int, const char *, const char *))
{
  (void)soap;
  (void)node;
  (void)s;
  (void)p;
  (void)q;
}

// soap_traverse_xsd__anyType
// file dom.c line 142
void soap_traverse_xsd__anyType(struct soap *soap, struct soap_dom_element *node, const char *s, void (*p)(struct soap *, void *, signed int, const char *, const char *), void (*q)(struct soap *, void *, signed int, const char *, const char *))
{
  (void)soap;
  (void)node;
  (void)s;
  (void)p;
  (void)q;
}

// soap_try_connect_command
// file stdsoap2.c line 17160
static signed int soap_try_connect_command(struct soap *soap, signed int http_command, const char *endpoint, const char *action)
{
  char host[(signed long int)sizeof(char [1024l]) /*1024l*/ ];
  signed int port;
  unsigned long int count;
  soap->error = 0;
  strncpy(host, soap->host, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1);
  host[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
  (void)(host[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] != 0 ? (_Bool)1 : (_Bool)0);
  port = soap->port;
  soap->status = http_command;
  soap_set_endpoint(soap, endpoint);
  soap->action=soap_strdup(soap, action);
  signed int return_value_strcmp_4;
  signed int return_value;
  if(!(soap->fconnect == ((signed int (*)(struct soap *, const char *, const char *, signed int))NULL)))
  {
    soap->error=soap->fconnect(soap, endpoint, soap->host, soap->port);
    if(!(soap->error == 0))
      return soap->error;

  }

  else
    if(!(soap->fopen == ((signed int (*)(struct soap *, const char *, const char *, signed int))NULL)))
    {
      if(!(soap->host[0l] == 0))
      {
        _Bool tmp_if_expr_3;
        if(soap->keep_alive == 0)
          tmp_if_expr_3 = (_Bool)1;

        else
          tmp_if_expr_3 = !(soap->socket != (signed int)-1) ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr_5;
        if(tmp_if_expr_3)
          tmp_if_expr_5 = (_Bool)1;

        else
        {
          return_value_strcmp_4=strcmp(soap->host, host);
          tmp_if_expr_5 = return_value_strcmp_4 != 0 ? (_Bool)1 : (_Bool)0;
        }
        _Bool tmp_if_expr_6;
        if(tmp_if_expr_5)
          tmp_if_expr_6 = (_Bool)1;

        else
          tmp_if_expr_6 = soap->port != port ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr_7;
        if(tmp_if_expr_6)
          tmp_if_expr_7 = (_Bool)1;

        else
          tmp_if_expr_7 = !(soap->fpoll != ((signed int (*)(struct soap *))NULL)) ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr_8;
        if(tmp_if_expr_7)
          tmp_if_expr_8 = (_Bool)1;

        else
        {
          return_value=soap->fpoll(soap);
          tmp_if_expr_8 = return_value != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_8)
        {
          soap->error = 0;
          signed int return_value_strncmp_1;
          return_value_strncmp_1=strncmp(endpoint, "soap.udp:", (unsigned long int)9);
          if(return_value_strncmp_1 == 0)
            soap->omode = soap->omode | 0x00000004;

          else
          {
            soap->keep_alive = (signed short int)0;
            soap->omode = soap->omode & ~0x00000004;
          }
          soap_closesock(soap);
          _Bool tmp_if_expr_2;
          if(soap->keep_alive == 0)
            tmp_if_expr_2 = (_Bool)1;

          else
            tmp_if_expr_2 = !(soap->socket != (signed int)-1) ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_2)
          {
            soap->socket=soap->fopen(soap, endpoint, soap->host, soap->port);
            if(!(soap->error == 0))
              return soap->error;

            soap->keep_alive = (signed short int)((soap->omode & 0x00000010) != 0);
          }

        }

      }

    }

  count=soap_count_attachments(soap);
  signed int return_value_soap_begin_send_9;
  return_value_soap_begin_send_9=soap_begin_send(soap);
  signed int return_value_soap_end_send_flush_11;
  if(!(return_value_soap_begin_send_9 == 0))
    return soap->error;

  else
  {
    if(http_command == 2002)
    {
      soap->mode = soap->mode & ~0x00000003;
      soap->mode = soap->mode | 0x00000001;
    }

    if(!((0x00000003 & soap->mode) == 0x00000002))
    {
      if((0x00000040 & soap->mode) == 0)
      {
        if(!(endpoint == ((const char *)NULL)))
        {
          unsigned int k = (unsigned int)soap->mode;
          soap->mode = soap->mode & ~(0x00000003 | 0x00000400);
          if(!((3u & k) == 0u))
            soap->mode = soap->mode | 0x00000001;

          soap->error=soap->fpost(soap, endpoint, soap->host, soap->port, soap->path, action, count);
          if(!(soap->error == 0))
            return soap->error;

          if((3u & k) == 3u)
          {
            signed int return_value_soap_flush_10;
            return_value_soap_flush_10=soap_flush(soap);
            if(!(return_value_soap_flush_10 == 0))
              return soap->error;

          }

          soap->mode = (signed int)k;
        }

      }

    }

    if(http_command == 2002 || http_command == 2004)
    {
      return_value_soap_end_send_flush_11=soap_end_send_flush(soap);
      return return_value_soap_end_send_flush_11;
    }

    return 0;
  }
}

// soap_type_punned
// file stdsoap2.c line 8859
static signed int soap_type_punned(struct soap *soap, struct soap_ilist *ip)
{
  struct soap_flist *fp;
  (void)soap;
  _Bool tmp_if_expr_1;
  if(!(ip->ptr == NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = ip->copy != NULL ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return 1;

  else
  {
    fp = ip->flist;
    for( ; !(fp == ((struct soap_flist *)NULL)); fp = fp->next)
      if(fp->level == 0u)
        return 1;

    return 0;
  }
}

// soap_unlink
// file stdsoap2.c line 8531
signed int soap_unlink(struct soap *soap, const void *p)
{
  char **q;
  struct soap_clist **cp;
  if(!(p == NULL) && !(soap == ((struct soap *)NULL)))
  {
    q = (char **)(void *)&soap->alist;
    for( ; !(*q == ((char *)NULL)); q = *((char ***)q))
      if(p == (void *)(*q + -((signed long int)*((unsigned long int *)(*q + (signed long int)sizeof(void *) /*8l*/ )))))
      {
        *q = *(*((char ***)q));
        return 0;
      }

    cp = &soap->clist;
    for( ; !(*cp == ((struct soap_clist *)NULL)); cp = &(*cp)->next)
      if(p == (*cp)->ptr)
      {
        q = (char **)*cp;
        *cp = (*cp)->next;
        free((void *)q);
        return 0;
      }

  }

  return -1;
}

// soap_unmark
// file ../../../gsoap/stdsoap2.h line 2989
void soap_unmark(struct soap *soap, char *mark)
{
  (void)soap;
  if(!(mark == ((char *)NULL)))
    *mark = (char)0;

}

// soap_unsignedByte2s
// file stdsoap2.c line 13654
const char * soap_unsignedByte2s(struct soap *soap, unsigned char n)
{
  const char *return_value_soap_unsignedLong2s_1;
  return_value_soap_unsignedLong2s_1=soap_unsignedLong2s(soap, (unsigned long int)n);
  return return_value_soap_unsignedLong2s_1;
}

// soap_unsignedInt2s
// file stdsoap2.c line 13809
const char * soap_unsignedInt2s(struct soap *soap, unsigned int n)
{
  const char *return_value_soap_unsignedLong2s_1;
  return_value_soap_unsignedLong2s_1=soap_unsignedLong2s(soap, (unsigned long int)n);
  return return_value_soap_unsignedLong2s_1;
}

// soap_unsignedLong2s
// file stdsoap2.c line 13897
const char * soap_unsignedLong2s(struct soap *soap, unsigned long int n)
{
  snprintf(soap->tmpbuf, sizeof(char [1024l]) /*1024ul*/ , "%lu", n);
  return soap->tmpbuf;
}

// soap_unsignedShort2s
// file stdsoap2.c line 13731
const char * soap_unsignedShort2s(struct soap *soap, unsigned short int n)
{
  const char *return_value_soap_unsignedLong2s_1;
  return_value_soap_unsignedLong2s_1=soap_unsignedLong2s(soap, (unsigned long int)n);
  return return_value_soap_unsignedLong2s_1;
}

// soap_update_pointers
// file stdsoap2.c line 2404
void soap_update_pointers(struct soap *soap, const char *dst, const char *src, unsigned long int len)
{
  const void *start = (const void *)src;
  const void *end = (const void *)(src + (signed long int)len);
  struct soap_xlist *xp;
  _Bool tmp_if_expr_1;
  if(!(soap->version == 0))
    tmp_if_expr_1 = !((soap->imode & 0x00020000) != 0) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = (soap->mode & 0x20000000) != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    signed int i = 0;
    for( ; !(i >= 1999); i = i + 1)
    {
      struct soap_ilist *ip = soap->iht[(signed long int)i];
      for( ; !(ip == ((struct soap_ilist *)NULL)); ip = ip->next)
      {
        struct soap_flist *fp;
        void *p;
        void **q;
        if(!(ip->shaky == 0))
        {
          if(!(ip->ptr == NULL))
          {
            if(ip->ptr >= start)
            {
              if(!(ip->ptr >= end))
                ip->ptr = (void *)((const char *)ip->ptr + (dst - src));

            }

          }

          q = &ip->link;
          for( ; !(q == ((void **)NULL)); q = (void **)p)
          {
            p = *q;
            if(p >= start && !(p == NULL) && !(p >= end))
              *q = (void *)((const char *)p + (dst - src));

          }
          q = &ip->copy;
          for( ; !(q == ((void **)NULL)); q = (void **)p)
          {
            p = *q;
            if(p >= start && !(p == NULL) && !(p >= end))
              *q = (void *)((const char *)p + (dst - src));

          }
          fp = ip->flist;
          for( ; !(fp == ((struct soap_flist *)NULL)); fp = fp->next)
            if(fp->ptr >= start)
            {
              if(!(fp->ptr >= end))
                fp->ptr = (void *)((const char *)fp->ptr + (dst - src));

            }

          if(!(ip->smart == NULL))
          {
            if(ip->smart >= start)
            {
              if(!(ip->smart >= end))
                ip->smart = (void *)((const char *)ip->smart + (dst - src));

            }

          }

        }

      }
    }
  }

  xp = soap->xlist;
  for( ; !(xp == ((struct soap_xlist *)NULL)); xp = xp->next)
    if(!(xp->ptr == ((unsigned char **)NULL)))
    {
      if((void *)xp->ptr >= start)
      {
        if(!((void *)xp->ptr >= end))
        {
          xp->ptr = (unsigned char **)((char *)xp->ptr + (dst - src));
          xp->size = (signed int *)((char *)xp->size + (dst - src));
          xp->type = (char **)((char *)xp->type + (dst - src));
          xp->options = (char **)((char *)xp->options + (dst - src));
        }

      }

    }

}

// soap_url
// file stdsoap2.c line 6639
const char * soap_url(struct soap *soap, const char *s, const char *t)
{
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  if(t == ((const char *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    if(!((signed int)*t == 47))
      tmp_if_expr_1 = (signed int)*t != 63 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
    return s;

  else
  {
    snprintf(soap->msgbuf, sizeof(char [1024l]) /*1024ul*/ , "%s%s", s, t);
    return soap->msgbuf;
  }
}

// soap_utf8len
// file stdsoap2.c line 1867
unsigned long int soap_utf8len(const char *s)
{
  unsigned long int l = (unsigned long int)0;
  while(!(*s == 0))
  {
    const char *tmp_post_1 = s;
    s = s + 1l;
    if(!((0xC0 & (signed int)*tmp_post_1) == 0x80))
      l = l + 1ul;

  }
  return l;
}

// soap_utilize_ns
// file stdsoap2.c line 10259
static void soap_utilize_ns(struct soap *soap, const char *tag)
{
  struct soap_nlist *np;
  unsigned long int n = (unsigned long int)0;
  const char *t;
  t=strchr(tag, 58);
  if(!(t == ((const char *)NULL)))
    n = (unsigned long int)(t - tag);

  np=soap_lookup_ns(soap, tag, n);
  signed int return_value_strncmp_2;
  if(!(np == ((struct soap_nlist *)NULL)))
  {
    if(!((signed int)np->index >= 1))
    {
      if(np->level == soap->level)
        np->index = (signed short int)1;

      else
        soap_push_ns(soap, np->id, np->ns, (signed short int)1);
    }

  }

  else
    if(!(n == 0ul))
    {
      return_value_strncmp_2=strncmp(tag, "xml", (unsigned long int)3);
      if(!(return_value_strncmp_2 == 0))
      {
        signed int tmp_if_expr_1;
        if(!(n >= sizeof(char [1024l]) /*1024ul*/ ))
        {
          strncpy(soap->tmpbuf, tag, n);
          soap->tmpbuf[(signed long int)(unsigned long int)n] = (char)0;
          tmp_if_expr_1 = (signed int)soap->tmpbuf[(signed long int)(unsigned long int)n];
        }

        else
        {
          soap->tmpbuf[(signed long int)0] = (char)0;
          tmp_if_expr_1 = (signed int)soap->tmpbuf[(signed long int)0];
        }
        (void)(tmp_if_expr_1 != 0 ? (_Bool)1 : (_Bool)0);
        soap_push_ns(soap, soap->tmpbuf, (const char *)(void *)0, (signed short int)1);
      }

    }

}

// soap_valid_mime_boundary
// file stdsoap2.c line 16372
static signed int soap_valid_mime_boundary(struct soap *soap)
{
  struct soap_multipart *content;
  unsigned long int k;
  if(!(soap->fmimeread == ((unsigned long int (*)(struct soap *, void *, char *, unsigned long int))NULL)))
    return 0;

  else
  {
    k=strlen(soap->mime.boundary);
    content = soap->mime.first;
    for( ; !(content == ((struct soap_multipart *)NULL)); content = content->next)
      if(!(content->ptr == ((char *)NULL)))
      {
        if(content->size >= k)
        {
          const char *p = (const char *)content->ptr;
          unsigned long int i = (unsigned long int)0;
          for( ; !(i >= content->size + -k); p = p + 1l)
          {
            signed int return_value_strncmp_1;
            return_value_strncmp_1=strncmp(p, soap->mime.boundary, k);
            if(return_value_strncmp_1 == 0)
              return -1;

            i = i + 1ul;
          }
        }

      }

    return 0;
  }
}

// soap_value
// file stdsoap2.c line 15284
const char * soap_value(struct soap *soap)
{
  unsigned long int i;
  signed int c = 0;
  char *s = soap->tmpbuf;
  if(soap->body == 0)
    return soap_padding;

  else
  {
    do
      c=soap_get(soap);
    while(1 + c >= 1 && !(c >= 33));
    i = (unsigned long int)0;
    for( ; !(i >= 1023ul); i = i + 1ul)
    {
      if(c == -3 || c == -2 || c == -1)
        break;

      char *tmp_post_1 = s;
      s = s + 1l;
      *tmp_post_1 = (char)c;
      c=soap_get(soap);
    }
    s = s - 1l;
    for( ; i >= 1ul; s = s - 1l)
    {
      _Bool tmp_if_expr_2;
      if(1 + (signed int)*s >= 1)
        tmp_if_expr_2 = (signed int)*s <= 32 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(!tmp_if_expr_2)
        break;

      i = i - 1ul;
    }
    s[(signed long int)1] = (char)0;
    soap->tmpbuf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
    if(c == -3 || c == -2 || c == -1)
      soap->ahead = c;

    else
    {
      soap->error = 45;
      return (const char *)(void *)0;
    }
    return soap->tmpbuf;
  }
}

// soap_wchar2s
// file stdsoap2.c line 14555
const char * soap_wchar2s(struct soap *soap, const signed int *s)
{
  signed int c;
  char *r;
  char *t;
  const signed int *q = s;
  unsigned long int n = (unsigned long int)0;
  const signed int *tmp_post_1;
  const signed int *tmp_post_3;
  if(s == ((const signed int *)NULL))
    return (const char *)(void *)0;

  else
  {
    do
    {
      tmp_post_1 = q;
      q = q + 1l;
      c = *tmp_post_1;
      if(c == 0)
        break;

      if(c >= 1 && !(c >= 0x80))
        n = n + 1ul;

      else
        n = n + (unsigned long int)6;
    }
    while((_Bool)1);
    void *return_value_soap_malloc_2;
    return_value_soap_malloc_2=soap_malloc(soap, n + (unsigned long int)1);
    t = (char *)return_value_soap_malloc_2;
    r = t;
    if(!(r == ((char *)NULL)))
    {
      do
      {
        tmp_post_3 = s;
        s = s + 1l;
        c = *tmp_post_3;
        if(c == 0)
          break;

        if(c >= 1 && !(c >= 0x80))
        {
          char *tmp_post_4 = t;
          t = t + 1l;
          *tmp_post_4 = (char)c;
        }

        else
        {
          if(!(c >= 0x0800))
          {
            char *tmp_post_5 = t;
            t = t + 1l;
            *tmp_post_5 = (char)(0xC0 | c >> 6 & 0x1F);
          }

          else
          {
            if(!(c >= 0x010000))
            {
              char *tmp_post_6 = t;
              t = t + 1l;
              *tmp_post_6 = (char)(0xE0 | c >> 12 & 0x0F);
            }

            else
            {
              if(!(c >= 0x200000))
              {
                char *tmp_post_7 = t;
                t = t + 1l;
                *tmp_post_7 = (char)(0xF0 | c >> 18 & 0x07);
              }

              else
              {
                if(!(c >= 0x04000000))
                {
                  char *tmp_post_8 = t;
                  t = t + 1l;
                  *tmp_post_8 = (char)(0xF8 | c >> 24 & 0x03);
                }

                else
                {
                  char *tmp_post_9 = t;
                  t = t + 1l;
                  *tmp_post_9 = (char)(0xFC | c >> 30 & 0x01);
                  char *tmp_post_10 = t;
                  t = t + 1l;
                  *tmp_post_10 = (char)(0x80 | c >> 24 & 0x3F);
                }
                char *tmp_post_11 = t;
                t = t + 1l;
                *tmp_post_11 = (char)(0x80 | c >> 18 & 0x3F);
              }
              char *tmp_post_12 = t;
              t = t + 1l;
              *tmp_post_12 = (char)(0x80 | c >> 12 & 0x3F);
            }
            char *tmp_post_13 = t;
            t = t + 1l;
            *tmp_post_13 = (char)(0x80 | c >> 6 & 0x3F);
          }
          char *tmp_post_14 = t;
          t = t + 1l;
          *tmp_post_14 = (char)(0x80 | c & 0x3F);
        }
      }
      while((_Bool)1);
      *t = (char)0;
    }

    return r;
  }
}

// soap_wstrdup
// file stdsoap2.c line 2274
signed int * soap_wstrdup(struct soap *soap, const signed int *s)
{
  signed int *t = (signed int *)(void *)0;
  void *return_value_memcpy_1;
  if(!(s == ((const signed int *)NULL)))
  {
    unsigned long int n = (unsigned long int)0;
    for( ; !(s[(signed long int)n] == 0); n = n + 1ul)
      ;
    n = sizeof(signed int) /*4ul*/  * (n + (unsigned long int)1);
    void *return_value_soap_malloc_2;
    return_value_soap_malloc_2=soap_malloc(soap, n);
    t = (signed int *)return_value_soap_malloc_2;
    if(!(t == ((signed int *)NULL)))
    {
      if(!(t == ((signed int *)NULL)))
      {
        return_value_memcpy_1=memcpy((void *)t, (const void *)s, n);
        (signed int)!(return_value_memcpy_1 != NULL);
      }

      else
        34;
    }

  }

  return t;
}

// soap_wstring
// file stdsoap2.c line 14489
static const signed int * soap_wstring(struct soap *soap, const char *s, signed long int minlen, signed long int maxlen)
{
  if(!(s == ((const char *)NULL)))
  {
    signed long int l;
    signed int wc;
    soap->labidx = (unsigned long int)0;
    if(!((0x00000020 & soap->mode) == 0))
    {
      signed int *r;
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(s);
      signed int return_value_soap_append_lab_2;
      return_value_soap_append_lab_2=soap_append_lab(soap, (const char *)(void *)0, sizeof(signed int) /*4ul*/  * (return_value_strlen_1 + (unsigned long int)1));
      if(!(return_value_soap_append_lab_2 == 0))
        return (const signed int *)(void *)0;

      r = (signed int *)soap->labbuf;
      while(!(*s == 0))
      {
        signed int *tmp_post_3 = r;
        r = r + 1l;
        const char *tmp_post_4 = s;
        s = s + 1l;
        *tmp_post_3 = (signed int)*tmp_post_4;
      }
    }

    else
      while(!(*s == 0))
      {
        signed int c;
        signed int c1;
        signed int c2;
        signed int c3;
        signed int c4;
        const char *tmp_post_5 = s;
        s = s + 1l;
        c = (signed int)(unsigned char)*tmp_post_5;
        if(!(c >= 0x80))
          wc = (signed int)c;

        else
        {
          const char *tmp_post_6 = s;
          s = s + 1l;
          c1 = (signed int)*tmp_post_6 & 0x3F;
          if(!(c >= 0xE0))
            wc = (signed int)((signed int)(c & 0x1F) << 6 | c1);

          else
          {
            const char *tmp_post_7 = s;
            s = s + 1l;
            c2 = (signed int)*tmp_post_7 & 0x3F;
            if(!(c >= 0xF0))
              wc = (signed int)((signed int)(c & 0x0F) << 12 | c1 << 6 | c2);

            else
            {
              const char *tmp_post_8 = s;
              s = s + 1l;
              c3 = (signed int)*tmp_post_8 & 0x3F;
              if(!(c >= 0xF8))
                wc = (signed int)((signed int)(c & 0x07) << 18 | c1 << 12 | c2 << 6 | c3);

              else
              {
                const char *tmp_post_9 = s;
                s = s + 1l;
                c4 = (signed int)*tmp_post_9 & 0x3F;
                if(!(c >= 0xFC))
                  wc = (signed int)((signed int)(c & 0x03) << 24 | c1 << 18 | c2 << 12 | c3 << 6 | c4);

                else
                {
                  const char *tmp_post_10 = s;
                  s = s + 1l;
                  wc = (signed int)((signed int)(c & 0x01) << 30 | c1 << 24 | c2 << 18 | c3 << 12 | c4 << 6 | (signed int)((signed int)*tmp_post_10 & 0x3F));
                }
              }
            }
          }
        }
        signed int return_value_soap_append_lab_11;
        return_value_soap_append_lab_11=soap_append_lab(soap, (const char *)&wc, sizeof(signed int) /*4ul*/ );
        if(!(return_value_soap_append_lab_11 == 0))
          return (const signed int *)(void *)0;

      }
    l = (signed long int)(soap->labidx / sizeof(signed int) /*4ul*/ );
    wc = 0;
    signed int return_value_soap_append_lab_12;
    return_value_soap_append_lab_12=soap_append_lab(soap, (const char *)&wc, sizeof(signed int) /*4ul*/ );
    if(!(return_value_soap_append_lab_12 == 0))
      return (const signed int *)(void *)0;

    if(maxlen >= 0l && !(maxlen >= l) || !(l >= minlen))
    {
      soap->error = 45;
      return (const signed int *)(void *)0;
    }

    return (signed int *)soap->labbuf;
  }

  return (const signed int *)(void *)0;
}

// soap_wstring_in
// file stdsoap2.c line 12762
signed int * soap_wstring_in(struct soap *soap, signed int flag, signed long int minlen, signed long int maxlen, const char *pattern)
{
  signed int *s;
  signed int i;
  signed int n = 0;
  signed int f = 0;
  signed long int soap_wstring_in__1__l = (signed long int)0;
  signed int c;
  char *t = (char *)(void *)0;
  signed int tmp_if_expr_3;
  signed int tmp_if_expr_6;
  if(!(flag >= 1))
  {
    if(!(soap->peeked == 0))
    {
      if(!(soap->tag[0l] == 0))
      {
        struct soap_attribute *tp;
        t = soap->tmpbuf;
        *t = (char)60;
        if(!(t + 1l == ((char *)NULL)))
        {
          strncpy(t + (signed long int)1, soap->tag, (sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1) - (unsigned long int)1);
          (t + (signed long int)1)[(signed long int)((sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1) - (unsigned long int)1)] = (char)0;
          if(!(t[1023l] == 0))
            (_Bool)1;

          else
            (_Bool)0;
        }

        else
          (_Bool)0;
        unsigned long int return_value_strlen_1;
        return_value_strlen_1=strlen(t);
        t = t + (signed long int)return_value_strlen_1;
        tp = soap->attributes;
        for( ; !(tp == ((struct soap_attribute *)NULL)); tp = tp->next)
          if(!(tp->visible == 0))
          {
            unsigned long int l;
            l=strlen(tp->name);
            if(t + (signed long int)l + 1l >= soap->tmpbuf + (signed long int)sizeof(char [1024l]) /*1024l*/ )
              break;

            char *tmp_post_2 = t;
            t = t + 1l;
            *tmp_post_2 = (char)32;
            if(!(t == ((char *)NULL)))
            {
              if(!(l >= sizeof(char [1024l]) /*1024ul*/  + -((unsigned long int)(t - soap->tmpbuf))))
              {
                strncpy(t, tp->name, l);
                t[(signed long int)(unsigned long int)l] = (char)0;
                tmp_if_expr_3 = (signed int)t[(signed long int)(unsigned long int)l];
              }

              else
              {
                t[(signed long int)0] = (char)0;
                tmp_if_expr_3 = (signed int)t[(signed long int)0];
              }
              if(!(tmp_if_expr_3 == 0))
                (_Bool)1;

              else
                (_Bool)0;
            }

            else
              (_Bool)0;
            t = t + (signed long int)l;
            if(!(tp->value == ((char *)NULL)))
            {
              l=strlen(tp->value);
              if(t + (signed long int)l + 3l >= soap->tmpbuf + (signed long int)sizeof(char [1024l]) /*1024l*/ )
                break;

              char *tmp_post_4 = t;
              t = t + 1l;
              *tmp_post_4 = (char)61;
              char *tmp_post_5 = t;
              t = t + 1l;
              *tmp_post_5 = (char)34;
              if(!(t == ((char *)NULL)))
              {
                if(!(l >= sizeof(char [1024l]) /*1024ul*/  + -((unsigned long int)(t - soap->tmpbuf))))
                {
                  strncpy(t, tp->value, l);
                  t[(signed long int)(unsigned long int)l] = (char)0;
                  tmp_if_expr_6 = (signed int)t[(signed long int)(unsigned long int)l];
                }

                else
                {
                  t[(signed long int)0] = (char)0;
                  tmp_if_expr_6 = (signed int)t[(signed long int)0];
                }
                if(!(tmp_if_expr_6 == 0))
                  (_Bool)1;

                else
                  (_Bool)0;
              }

              else
                (_Bool)0;
              t = t + (signed long int)l;
              char *tmp_post_7 = t;
              t = t + 1l;
              *tmp_post_7 = (char)34;
            }

          }

        if(soap->body == 0)
        {
          char *tmp_post_8 = t;
          t = t + 1l;
          *tmp_post_8 = (char)47;
        }

        char *tmp_post_9 = t;
        t = t + 1l;
        *tmp_post_9 = (char)62;
        *t = (char)0;
        t = soap->tmpbuf;
        if(!(soap->body == 0))
          n = 1;

        f = 1;
        soap->peeked = (signed short int)0;
      }

    }

  }

  struct soap_blist *return_value_soap_new_block_10;
  return_value_soap_new_block_10=soap_new_block(soap);
  if(return_value_soap_new_block_10 == ((struct soap_blist *)NULL))
    return (signed int *)(void *)0;

  else
  {
    do
    {
      void *return_value_soap_push_block_11;
      return_value_soap_push_block_11=soap_push_block(soap, (struct soap_blist *)(void *)0, sizeof(signed int) /*4ul*/  * (unsigned long int)256);
      s = (signed int *)return_value_soap_push_block_11;
      if(s == ((signed int *)NULL))
        return (signed int *)(void *)0;

      i = 0;
      for( ; !(i >= 256); i = i + 1)
        if(!(t == ((char *)NULL)))
        {
          signed int *tmp_post_12 = s;
          s = s + 1l;
          char *tmp_post_13 = t;
          t = t + 1l;
          *tmp_post_12 = (signed int)*tmp_post_13;
          if(*t == 0)
            t = (char *)(void *)0;

        }

        else
        {
          c=soap_getutf8(soap);
          if(!(c == -3))
          {
            if(c == -2)
              goto __CPROVER_DUMP_L33;

            if(c == -4)
              goto __CPROVER_DUMP_L34;

            if(c == -5)
              goto __CPROVER_DUMP_L35;

            if(c == -6)
              goto __CPROVER_DUMP_L36;

            if(c == 47)
              goto __CPROVER_DUMP_L37;

            if(c == 60)
              goto __CPROVER_DUMP_L40;

            if(c == 62)
              goto __CPROVER_DUMP_L43;

            if(c == 34)
              goto __CPROVER_DUMP_L46;

          }

          else
          {
            if(n == 0)
              goto end;

            n = n - 1;
            signed int *tmp_post_14 = s;
            s = s + 1l;
            *tmp_post_14 = 60;
            soap->ahead = 47;
            goto __CPROVER_DUMP_L51;

          __CPROVER_DUMP_L33:
            ;
            if(f == 0 && flag >= 0 || n == 0 && !(f == 0))
              goto end;

            n = n + 1;
            signed int *tmp_post_15 = s;
            s = s + 1l;
            *tmp_post_15 = 60;
            goto __CPROVER_DUMP_L51;

          __CPROVER_DUMP_L34:
            ;
            signed int *tmp_post_16 = s;
            s = s + 1l;
            *tmp_post_16 = 62;
            goto __CPROVER_DUMP_L51;

          __CPROVER_DUMP_L35:
            ;
            signed int *tmp_post_17 = s;
            s = s + 1l;
            *tmp_post_17 = 34;
            goto __CPROVER_DUMP_L51;

          __CPROVER_DUMP_L36:
            ;
            signed int *tmp_post_18 = s;
            s = s + 1l;
            *tmp_post_18 = 39;
            goto __CPROVER_DUMP_L51;

          __CPROVER_DUMP_L37:
            ;
            if(n >= 1)
            {
              c=soap_getutf8(soap);
              if(c == -4)
                n = n - 1;

              soap->ahead = c;
            }

            signed int *tmp_post_19 = s;
            s = s + 1l;
            *tmp_post_19 = 47;
            goto __CPROVER_DUMP_L51;

          __CPROVER_DUMP_L40:
            ;
            if(flag >= 1)
            {
              signed int *tmp_post_20 = s;
              s = s + 1l;
              *tmp_post_20 = (signed int)60;
            }

            else
            {
              signed int *tmp_post_21 = s;
              s = s + 1l;
              *tmp_post_21 = (signed int)38;
              t = (char *)"lt;";
            }
            goto __CPROVER_DUMP_L51;

          __CPROVER_DUMP_L43:
            ;
            if(flag >= 1)
            {
              signed int *tmp_post_22 = s;
              s = s + 1l;
              *tmp_post_22 = (signed int)62;
            }

            else
            {
              signed int *tmp_post_23 = s;
              s = s + 1l;
              *tmp_post_23 = (signed int)38;
              t = (char *)"gt;";
            }
            goto __CPROVER_DUMP_L51;

          __CPROVER_DUMP_L46:
            ;
            if(flag >= 1)
            {
              signed int *tmp_post_24 = s;
              s = s + 1l;
              *tmp_post_24 = (signed int)34;
            }

            else
            {
              signed int *tmp_post_25 = s;
              s = s + 1l;
              *tmp_post_25 = (signed int)38;
              t = (char *)"quot;";
            }
            goto __CPROVER_DUMP_L51;
          }
          if(c == -1)
            goto end;

          signed int *tmp_post_26 = s;
          s = s + 1l;
          *tmp_post_26 = (signed int)c & 0x7FFFFFFF;

        __CPROVER_DUMP_L51:
          ;
          soap_wstring_in__1__l = soap_wstring_in__1__l + 1l;
          if(maxlen >= 0l && !(maxlen >= soap_wstring_in__1__l))
          {
            soap->error = 45;
            return (signed int *)(void *)0;
          }

        }
    }
    while((_Bool)1);

  end:
    ;
    soap->ahead = c;
    *s = 0;
    soap_size_block(soap, (struct soap_blist *)(void *)0, sizeof(signed int) /*4ul*/  * (unsigned long int)(i + 1));
    if(!(soap_wstring_in__1__l >= minlen))
    {
      soap->error = 45;
      return (signed int *)(void *)0;
    }

    else
    {
      char *return_value_soap_save_block_27;
      return_value_soap_save_block_27=soap_save_block(soap, (struct soap_blist *)(void *)0, (char *)(void *)0, 0);
      s = (signed int *)return_value_soap_save_block_27;
      if(!(pattern == ((const char *)NULL)))
      {
        if(soap->fwvalidate == ((signed int (*)(struct soap *, const char *, const signed int *))NULL))
          goto __CPROVER_DUMP_L56;

        soap->error=soap->fwvalidate(soap, pattern, s);
        return (signed int *)(void *)0;
      }

      else
      {

      __CPROVER_DUMP_L56:
        ;
        return s;
      }
    }
  }
}

// soap_wstring_out
// file stdsoap2.c line 12681
signed int soap_wstring_out(struct soap *soap, const signed int *s, signed int flag)
{
  const char *t;
  char tmp;
  signed int c;
  const signed int *tmp_post_1;
  do
  {
    tmp_post_1 = s;
    s = s + 1l;
    c = *tmp_post_1;
    if(c == 0)
      break;

    switch(c)
    {
      case 0x09:
      {
        if(!(flag == 0))
          t = "&#x9;";

        else
          t = "\t";
        break;
      }
      case 0x0A:
      {
        _Bool tmp_if_expr_2;
        if(!(flag == 0))
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = !((soap->mode & 0x00010000) != 0) ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
          t = "&#xA;";

        else
          t = "\n";
        break;
      }
      case 0x0D:
      {
        t = "&#xD;";
        break;
      }
      case 38:
      {
        t = "&amp;";
        break;
      }
      case 60:
      {
        t = "&lt;";
        break;
      }
      case 62:
      {
        if(!(flag == 0))
          t = ">";

        else
          t = "&gt;";
        break;
      }
      case 34:
      {
        if(!(flag == 0))
          t = "&quot;";

        else
          t = "\"";
        break;
      }
      default:
      {
        if(c >= 0x20 && !(c >= 0x80))
        {
          tmp = (char)c;
          signed int return_value_soap_send_raw_3;
          return_value_soap_send_raw_3=soap_send_raw(soap, &tmp, (unsigned long int)1);
          if(!(return_value_soap_send_raw_3 == 0))
            return soap->error;

        }

        else
        {
          signed int return_value_soap_pututf8_5;
          return_value_soap_pututf8_5=soap_pututf8(soap, (unsigned long int)c);
          if(!(return_value_soap_pututf8_5 == 0))
            return soap->error;

        }
        goto __CPROVER_DUMP_L29;
      }
    }
    signed int return_value_soap_send_6;
    return_value_soap_send_6=soap_send(soap, t);
    if(!(return_value_soap_send_6 == 0))
      return soap->error;


  __CPROVER_DUMP_L29:
    ;
  }
  while((_Bool)1);
  return 0;
}

// soap_wstrtrim
// file stdsoap2.c line 2317
signed int * soap_wstrtrim(struct soap *soap, signed int *s)
{
  (void)soap;
  if(!(s == ((signed int *)NULL)))
  {
    signed int *t;
    for( ; (_Bool)1; s = s + 1l)
      if(*s >= 9)
      {
        if(*s >= 14)
          goto __CPROVER_DUMP_L2;

      }

      else
      {

      __CPROVER_DUMP_L2:
        ;
        if(!(*s == 32))
          goto __CPROVER_DUMP_L4;

      }

  __CPROVER_DUMP_L4:
    ;
    t = s;
    for( ; !(*t == 0); t = t + 1l)
      ;
    do
    {
      t = t - 1l;
      if(s >= t)
        break;

      if(*t >= 9)
      {
        if(*t >= 14)
          goto __CPROVER_DUMP_L7;

      }

      else
      {

      __CPROVER_DUMP_L7:
        ;
        if(!(*t == 32))
          break;

      }
    }
    while((_Bool)1);
    t[(signed long int)1] = 0;
  }

  return s;
}

// soap_xop_forward
// file stdsoap2.c line 2188
signed int soap_xop_forward(struct soap *soap, unsigned char **ptr, signed int *size, char **id, char **type, char **options)
{
  signed short int body = soap->body;
  signed int return_value_soap_peek_element_6;
  return_value_soap_peek_element_6=soap_peek_element(soap);
  _Bool tmp_if_expr_3;
  signed int return_value_soap_element_end_in_2;
  if(return_value_soap_peek_element_6 == 0)
  {
    signed int return_value_soap_element_begin_in_5;
    return_value_soap_element_begin_in_5=soap_element_begin_in(soap, "xop:Include", 0, (const char *)(void *)0);
    if(return_value_soap_element_begin_in_5 == 0)
    {
      signed int return_value_soap_attachment_forward_1;
      return_value_soap_attachment_forward_1=soap_attachment_forward(soap, ptr, size, id, type, options);
      _Bool tmp_if_expr_4;
      if(!(return_value_soap_attachment_forward_1 == 0))
        tmp_if_expr_4 = (_Bool)1;

      else
      {
        if(!(soap->body == 0))
        {
          return_value_soap_element_end_in_2=soap_element_end_in(soap, "xop:Include");
          tmp_if_expr_3 = return_value_soap_element_end_in_2 != 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_3 = (_Bool)0;
        tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_4)
        return soap->error;

    }

  }

  soap->body = body;
  return 0;
}

// tcp_accept
// file stdsoap2.c line 5087
static signed int tcp_accept(struct soap *soap, signed int s, struct sockaddr *a, signed int *n)
{
  signed int sk;
  (void)soap;
  sk=accept(s, a, (unsigned int *)n);
  return sk;
}

// tcp_closesocket
// file stdsoap2.c line 5209
static signed int tcp_closesocket(struct soap *soap, signed int sk)
{
  (void)soap;
  signed int return_value_close_1;
  return_value_close_1=close(sk);
  return return_value_close_1;
}

// tcp_connect
// file stdsoap2.c line 4191
static signed int tcp_connect(struct soap *soap, const char *endpoint, const char *host, signed int port)
{
  struct addrinfo hints;
  struct addrinfo *res;
  struct addrinfo *ressave;
  signed int sk;
  signed int err = 0;
  signed int len = (signed int)sizeof(char [65536l]) /*65536ul*/ ;
  signed int set = 1;
  signed int retries;
  if(!(soap->socket == -1))
    soap->fclosesocket(soap, soap->socket);

  soap->socket = (signed int)-1;
  signed int return_value_tcp_init_2;
  return_value_tcp_init_2=tcp_init(soap);
  if(!(return_value_tcp_init_2 == 0))
  {
    soap->errnum = 0;
    const char *return_value_tcp_error_1;
    return_value_tcp_error_1=tcp_error(soap);
    soap_set_receiver_error(soap, return_value_tcp_error_1, "TCP init failed in tcp_connect()", 28);
    return (signed int)-1;
  }

  soap->errmode = 0;
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_family = 0;
  if(!((0x00000004 & soap->omode) == 0))
    hints.ai_socktype = 2;

  else
    hints.ai_socktype = 1;
  soap->errmode = 2;
  const char *return_value_soap_int2s_3;
  const char *return_value_soap_int2s_4;
  if(!(soap->proxy_host == ((const char *)NULL)))
  {
    return_value_soap_int2s_3=soap_int2s(soap, soap->proxy_port);
    err=getaddrinfo(soap->proxy_host, return_value_soap_int2s_3, &hints, &res);
  }

  else
  {
    return_value_soap_int2s_4=soap_int2s(soap, port);
    err=getaddrinfo(host, return_value_soap_int2s_4, &hints, &res);
  }
  if(res == ((struct addrinfo *)NULL) || !(err == 0))
  {
    const char *return_value_gai_strerror_5;
    return_value_gai_strerror_5=gai_strerror(err);
    soap_set_receiver_error(soap, return_value_gai_strerror_5, "getaddrinfo failed in tcp_connect()", 28);
    return (signed int)-1;
  }

  ressave = res;
  do
  {

  again:
    ;
    sk=socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    soap->error = 0;
    soap->errmode = 0;
    if(!(sk == -1))
      goto __CPROVER_DUMP_L10;

    if(res->ai_next == ((struct addrinfo *)NULL))
      break;

    res = res->ai_next;
  }
  while((_Bool)1);
  signed int *return_value___errno_location_6;
  return_value___errno_location_6=__errno_location();
  soap->errnum = *return_value___errno_location_6;
  const char *return_value_tcp_error_7;
  return_value_tcp_error_7=tcp_error(soap);
  soap_set_receiver_error(soap, return_value_tcp_error_7, "socket failed in tcp_connect()", 28);
  freeaddrinfo(ressave);
  return (signed int)-1;

__CPROVER_DUMP_L10:
  ;
  if(!((13 & soap->connect_flags) == 0))
  {
    struct linger linger;
    memset((void *)&linger, 0, sizeof(struct linger) /*8ul*/ );
    linger.l_onoff = 1;
    linger.l_linger = (signed int)soap->linger_time;
    signed int return_value_setsockopt_10;
    return_value_setsockopt_10=setsockopt(sk, 1, 13, (const void *)(char *)&linger, (unsigned int)sizeof(struct linger) /*8ul*/ );
    if(!(return_value_setsockopt_10 == 0))
    {
      signed int *return_value___errno_location_8;
      return_value___errno_location_8=__errno_location();
      soap->errnum = *return_value___errno_location_8;
      const char *return_value_tcp_error_9;
      return_value_tcp_error_9=tcp_error(soap);
      soap_set_receiver_error(soap, return_value_tcp_error_9, "setsockopt SO_LINGER failed in tcp_connect()", 28);
      soap->fclosesocket(soap, sk);
      freeaddrinfo(ressave);
      return (signed int)-1;
    }

  }

  signed int return_value_setsockopt_13;
  if(!((-14 & soap->connect_flags) == 0))
  {
    return_value_setsockopt_13=setsockopt(sk, 1, soap->connect_flags & ~13, (const void *)(char *)&set, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_setsockopt_13 == 0))
    {
      signed int *return_value___errno_location_11;
      return_value___errno_location_11=__errno_location();
      soap->errnum = *return_value___errno_location_11;
      const char *return_value_tcp_error_12;
      return_value_tcp_error_12=tcp_error(soap);
      soap_set_receiver_error(soap, return_value_tcp_error_12, "setsockopt failed in tcp_connect()", 28);
      soap->fclosesocket(soap, sk);
      freeaddrinfo(ressave);
      return (signed int)-1;
    }

  }

  _Bool tmp_if_expr_17;
  if(!(soap->keep_alive == 0))
    tmp_if_expr_17 = (_Bool)1;

  else
    tmp_if_expr_17 = soap->tcp_keep_alive != 0 ? (_Bool)1 : (_Bool)0;
  signed int return_value_setsockopt_16;
  if(tmp_if_expr_17)
  {
    return_value_setsockopt_16=setsockopt(sk, 1, 9, (const void *)(char *)&set, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_setsockopt_16 == 0))
    {
      signed int *return_value___errno_location_14;
      return_value___errno_location_14=__errno_location();
      soap->errnum = *return_value___errno_location_14;
      const char *return_value_tcp_error_15;
      return_value_tcp_error_15=tcp_error(soap);
      soap_set_receiver_error(soap, return_value_tcp_error_15, "setsockopt SO_KEEPALIVE failed in tcp_connect()", 28);
      soap->fclosesocket(soap, sk);
      freeaddrinfo(ressave);
      return (signed int)-1;
    }

  }

  signed int return_value_setsockopt_20;
  return_value_setsockopt_20=setsockopt(sk, 1, 7, (const void *)(char *)&len, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_setsockopt_20 == 0))
  {
    signed int *return_value___errno_location_18;
    return_value___errno_location_18=__errno_location();
    soap->errnum = *return_value___errno_location_18;
    const char *return_value_tcp_error_19;
    return_value_tcp_error_19=tcp_error(soap);
    soap_set_receiver_error(soap, return_value_tcp_error_19, "setsockopt SO_SNDBUF failed in tcp_connect()", 28);
    soap->fclosesocket(soap, sk);
    freeaddrinfo(ressave);
    return (signed int)-1;
  }

  signed int return_value_setsockopt_23;
  return_value_setsockopt_23=setsockopt(sk, 1, 8, (const void *)(char *)&len, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_setsockopt_23 == 0))
  {
    signed int *return_value___errno_location_21;
    return_value___errno_location_21=__errno_location();
    soap->errnum = *return_value___errno_location_21;
    const char *return_value_tcp_error_22;
    return_value_tcp_error_22=tcp_error(soap);
    soap_set_receiver_error(soap, return_value_tcp_error_22, "setsockopt SO_RCVBUF failed in tcp_connect()", 28);
    soap->fclosesocket(soap, sk);
    freeaddrinfo(ressave);
    return (signed int)-1;
  }

  signed int return_value_setsockopt_26;
  if(!(soap->tcp_keep_idle == 0u))
  {
    return_value_setsockopt_26=setsockopt((signed int)sk, 6, 4, (const void *)(char *)&soap->tcp_keep_idle, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_setsockopt_26 == 0))
    {
      signed int *return_value___errno_location_24;
      return_value___errno_location_24=__errno_location();
      soap->errnum = *return_value___errno_location_24;
      const char *return_value_tcp_error_25;
      return_value_tcp_error_25=tcp_error(soap);
      soap_set_receiver_error(soap, return_value_tcp_error_25, "setsockopt TCP_KEEPIDLE failed in tcp_connect()", 28);
      soap->fclosesocket(soap, (signed int)sk);
      freeaddrinfo(ressave);
      return (signed int)-1;
    }

  }

  signed int return_value_setsockopt_29;
  if(!(soap->tcp_keep_intvl == 0u))
  {
    return_value_setsockopt_29=setsockopt((signed int)sk, 6, 5, (const void *)(char *)&soap->tcp_keep_intvl, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_setsockopt_29 == 0))
    {
      signed int *return_value___errno_location_27;
      return_value___errno_location_27=__errno_location();
      soap->errnum = *return_value___errno_location_27;
      const char *return_value_tcp_error_28;
      return_value_tcp_error_28=tcp_error(soap);
      soap_set_receiver_error(soap, return_value_tcp_error_28, "setsockopt TCP_KEEPINTVL failed in tcp_connect()", 28);
      soap->fclosesocket(soap, (signed int)sk);
      freeaddrinfo(ressave);
      return (signed int)-1;
    }

  }

  signed int return_value_setsockopt_32;
  if(!(soap->tcp_keep_cnt == 0u))
  {
    return_value_setsockopt_32=setsockopt((signed int)sk, 6, 6, (const void *)(char *)&soap->tcp_keep_cnt, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_setsockopt_32 == 0))
    {
      signed int *return_value___errno_location_30;
      return_value___errno_location_30=__errno_location();
      soap->errnum = *return_value___errno_location_30;
      const char *return_value_tcp_error_31;
      return_value_tcp_error_31=tcp_error(soap);
      soap_set_receiver_error(soap, return_value_tcp_error_31, "setsockopt TCP_KEEPCNT failed in tcp_connect()", 28);
      soap->fclosesocket(soap, (signed int)sk);
      freeaddrinfo(ressave);
      return (signed int)-1;
    }

  }

  signed int return_value_setsockopt_35;
  if((0x00000004 & soap->omode) == 0)
  {
    return_value_setsockopt_35=setsockopt(sk, 6, 1, (const void *)(char *)&set, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_setsockopt_35 == 0))
    {
      signed int *return_value___errno_location_33;
      return_value___errno_location_33=__errno_location();
      soap->errnum = *return_value___errno_location_33;
      const char *return_value_tcp_error_34;
      return_value_tcp_error_34=tcp_error(soap);
      soap_set_receiver_error(soap, return_value_tcp_error_34, "setsockopt TCP_NODELAY failed in tcp_connect()", 28);
      soap->fclosesocket(soap, sk);
      freeaddrinfo(ressave);
      return (signed int)-1;
    }

  }

  if(!((0x00000004 & soap->omode) == 0))
  {
    if(!(soap->ipv6_multicast_if == 0u))
    {
      struct sockaddr_in6 *in6addr = (struct sockaddr_in6 *)res->ai_addr;
      in6addr->sin6_scope_id = soap->ipv6_multicast_if;
    }

  }

  if(!((0x00000004 & soap->omode) == 0))
  {
    if(!(soap->ipv4_multicast_ttl == 0))
    {
      unsigned char ttl = soap->ipv4_multicast_ttl;
      signed int return_value_setsockopt_38;
      return_value_setsockopt_38=setsockopt(sk, 0, 33, (const void *)(char *)&ttl, (unsigned int)sizeof(unsigned char) /*1ul*/ );
      if(!(return_value_setsockopt_38 == 0))
      {
        signed int *return_value___errno_location_36;
        return_value___errno_location_36=__errno_location();
        soap->errnum = *return_value___errno_location_36;
        const char *return_value_tcp_error_37;
        return_value_tcp_error_37=tcp_error(soap);
        soap_set_receiver_error(soap, return_value_tcp_error_37, "setsockopt IP_MULTICAST_TTL failed in tcp_connect()", 28);
        soap->fclosesocket(soap, sk);
        return (signed int)-1;
      }

    }

    if(!((0x00000004 & soap->omode) == 0))
    {
      if(!(soap->ipv4_multicast_if == ((char *)NULL)))
      {
        if(soap->ipv6_multicast_if == 0u)
        {
          signed int return_value_setsockopt_41;
          return_value_setsockopt_41=setsockopt(sk, 0, 32, (const void *)(char *)soap->ipv4_multicast_if, (unsigned int)sizeof(struct in_addr) /*4ul*/ );
          if(!(return_value_setsockopt_41 == 0))
          {
            signed int *return_value___errno_location_39;
            return_value___errno_location_39=__errno_location();
            soap->errnum = *return_value___errno_location_39;
            const char *return_value_tcp_error_40;
            return_value_tcp_error_40=tcp_error(soap);
            soap_set_receiver_error(soap, return_value_tcp_error_40, "setsockopt IP_MULTICAST_IF failed in tcp_connect()", 28);
            soap->fclosesocket(soap, sk);
            return (signed int)-1;
          }

        }

      }

    }

  }

  void *return_value_memcpy_42;
  if(!((0x00000004 & soap->omode) == 0))
  {
    signed int tmp_if_expr_43;
    if(!((unsigned long int)res->ai_addrlen >= 129ul))
    {
      return_value_memcpy_42=memcpy((void *)&soap->peer.storage, (const void *)res->ai_addr, (unsigned long int)res->ai_addrlen);
      tmp_if_expr_43 = (signed int)!(return_value_memcpy_42 != NULL);
    }

    else
      tmp_if_expr_43 = 34;
    if(!(tmp_if_expr_43 == 0))
    {
      soap->error = 20;
      soap->fclosesocket(soap, sk);
      sk = (signed int)-1;
    }

    soap->peerlen = (unsigned long int)res->ai_addrlen;
    freeaddrinfo(ressave);
    return sk;
  }

  signed int return_value_fcntl_44;
  signed int return_value_fcntl_45;
  if(!(soap->connect_timeout == 0))
  {
    return_value_fcntl_44=fcntl(sk, 3);
    fcntl(sk, 4, return_value_fcntl_44 | 04000);
  }

  else
  {
    return_value_fcntl_45=fcntl(sk, 3);
    fcntl(sk, 4, return_value_fcntl_45 & ~04000);
  }
  retries = 10;
  signed int *return_value___errno_location_51;
  do
  {
    signed int return_value_connect_54;
    return_value_connect_54=connect(sk, res->ai_addr, (unsigned int)(signed int)res->ai_addrlen);
    if(!(return_value_connect_54 == 0))
    {
      signed int *return_value___errno_location_46;
      return_value___errno_location_46=__errno_location();
      err = *return_value___errno_location_46;
      if(err == 111)
      {
        if(!(res->ai_next == ((struct addrinfo *)NULL)))
        {
          soap->fclosesocket(soap, sk);
          res = res->ai_next;
        }

      }

      if(err == 98)
      {
        soap->fclosesocket(soap, sk);
        signed int tmp_post_47 = retries;
        retries = retries - 1;
      }

      else
        if(!(soap->connect_timeout == 0))
        {
          if(err == 11 || err == 115)
          {
            unsigned int k;
            do
            {
              signed int r;
              r=tcp_select(soap, sk, 0x2, soap->connect_timeout);
              if(r >= 1)
                break;

              if(r == 0)
              {
                soap_set_receiver_error(soap, "Timeout", "connect failed in tcp_connect()", 28);
                soap->fclosesocket(soap, sk);
                if(!(res->ai_next == ((struct addrinfo *)NULL)))
                  res = res->ai_next;

                freeaddrinfo(ressave);
                return (signed int)-1;
              }

              signed int *return_value___errno_location_48;
              return_value___errno_location_48=__errno_location();
              soap->errnum = *return_value___errno_location_48;
              r = soap->errnum;
              if(!(r == 4))
              {
                const char *return_value_tcp_error_49;
                return_value_tcp_error_49=tcp_error(soap);
                soap_set_receiver_error(soap, return_value_tcp_error_49, "connect failed in tcp_connect()", 28);
                soap->fclosesocket(soap, sk);
                if(!(res->ai_next == ((struct addrinfo *)NULL)))
                  res = res->ai_next;

                freeaddrinfo(ressave);
                return (signed int)-1;
              }

            }
            while((_Bool)1);
            k = (unsigned int)sizeof(signed int) /*4ul*/ ;
            signed int return_value_getsockopt_50;
            return_value_getsockopt_50=getsockopt(sk, 1, 4, (void *)(char *)&soap->errnum, &k);
            if(return_value_getsockopt_50 == 0)
            {
              if(soap->errnum == 0)
                break;

            }

            if(soap->errnum == 0)
            {
              return_value___errno_location_51=__errno_location();
              soap->errnum = *return_value___errno_location_51;
            }

            const char *return_value_tcp_error_52;
            return_value_tcp_error_52=tcp_error(soap);
            soap_set_receiver_error(soap, return_value_tcp_error_52, "connect failed in tcp_connect()", 28);
            soap->fclosesocket(soap, sk);
            if(!(res->ai_next == ((struct addrinfo *)NULL)))
              res = res->ai_next;

            freeaddrinfo(ressave);
            return (signed int)-1;
          }

        }

      if(!(res->ai_next == ((struct addrinfo *)NULL)))
      {
        res = res->ai_next;
        soap->fclosesocket(soap, sk);
      }

      if(!(err == 0) && !(err == 4))
      {
        soap->errnum = err;
        const char *return_value_tcp_error_53;
        return_value_tcp_error_53=tcp_error(soap);
        soap_set_receiver_error(soap, return_value_tcp_error_53, "connect failed in tcp_connect()", 28);
        soap->fclosesocket(soap, sk);
        freeaddrinfo(ressave);
        return (signed int)-1;
      }

    }

    else
      break;
  }
  while((_Bool)1);
  soap->peerlen = (unsigned long int)0;
  freeaddrinfo(ressave);
  soap->socket = sk;
  soap->imode = soap->imode & ~0x00000800;
  soap->omode = soap->omode & ~0x00000800;
  signed int return_value_soap_tag_cmp_55;
  if(!(endpoint == ((const char *)NULL)))
  {
    return_value_soap_tag_cmp_55=soap_tag_cmp(endpoint, "https:*");
    if(return_value_soap_tag_cmp_55 == 0)
    {
      soap->fclosesocket(soap, sk);
      soap->error = 30;
      return (signed int)-1;
    }

  }

  _Bool tmp_if_expr_58;
  if(!(soap->recv_timeout == 0))
    tmp_if_expr_58 = (_Bool)1;

  else
    tmp_if_expr_58 = soap->send_timeout != 0 ? (_Bool)1 : (_Bool)0;
  signed int return_value_fcntl_56;
  signed int return_value_fcntl_57;
  if(tmp_if_expr_58)
  {
    return_value_fcntl_56=fcntl(sk, 3);
    fcntl(sk, 4, return_value_fcntl_56 | 04000);
  }

  else
  {
    return_value_fcntl_57=fcntl(sk, 3);
    fcntl(sk, 4, return_value_fcntl_57 & ~04000);
  }
  return sk;
}

// tcp_disconnect
// file stdsoap2.c line 5110
static signed int tcp_disconnect(struct soap *soap)
{
  if(!(soap->socket == -1))
  {
    if((0x00000004 & soap->omode) == 0)
    {
      soap->fshutdownsocket(soap, soap->socket, 2);
      soap->fclosesocket(soap, soap->socket);
      soap->socket = (signed int)-1;
    }

  }

  return 0;
}

// tcp_error
// file stdsoap2.c line 4088
static const char * tcp_error(struct soap *soap)
{
  const char *msg = (const char *)(void *)0;
  switch(soap->errmode)
  {
    case 0:
    {
      msg=soap_strerror(soap);
      break;
    }
    case 1:
    {
      msg = "WSAStartup failed";
      break;
    }
    case 2:
    {
      msg=soap_code_str(h_error_codes, (signed long int)soap->errnum);
      if(msg == ((const char *)NULL))
      {
        snprintf(soap->msgbuf, sizeof(char [1024l]) /*1024ul*/ , "TCP/UDP IP error %d", soap->errnum);
        msg = soap->msgbuf;
      }

    }
  }
  return msg;
}

// tcp_init
// file stdsoap2.c line 4066
static signed int tcp_init(struct soap *soap)
{
  soap->errmode = 1;
  return 0;
}

// tcp_select
// file stdsoap2.c line 4976
static signed int tcp_select(struct soap *soap, signed int sk, signed int flags, signed int timeout)
{
  signed int r;
  struct timeval tv;
  struct anonymous_3 fd[3l];
  struct anonymous_3 *rfd;
  struct anonymous_3 *sfd;
  struct anonymous_3 *efd;
  signed int retries = 0;
  signed int eintr = 10;
  soap->errnum = 0;
  signed int *return_value___errno_location_2;
  signed int tmp_post_4;
  if(sk >= 1024)
  {
    struct pollfd pollfd;
    pollfd.fd = (signed int)sk;
    pollfd.events = (signed short int)0;
    if(!((0x1 & flags) == 0))
      pollfd.events = pollfd.events | (signed short int)0x001;

    if(!((0x2 & flags) == 0))
      pollfd.events = pollfd.events | (signed short int)0x004;

    if(!((0x4 & flags) == 0))
      pollfd.events = pollfd.events | (signed short int)0x008;

    if(!(timeout >= 1))
      timeout = timeout / -1000;

    else
    {
      retries = timeout - 1;
      timeout = 1000;
    }
    do
    {
      r=poll(&pollfd, (unsigned long int)1, timeout);
      _Bool tmp_if_expr_3;
      if(!(r >= 0))
      {
        return_value___errno_location_2=__errno_location();
        soap->errnum = *return_value___errno_location_2;
        tmp_if_expr_3 = soap->errnum == 4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_3 = (_Bool)0;
      _Bool tmp_if_expr_5;
      if(tmp_if_expr_3)
      {
        tmp_post_4 = eintr;
        eintr = eintr - 1;
        tmp_if_expr_5 = tmp_post_4 > 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_5 = (_Bool)0;
      if(tmp_if_expr_5)
        r = 0;

      else
      {
        signed int tmp_post_1 = retries;
        retries = retries - 1;
        if(!(tmp_post_1 >= 1))
          break;

      }
    }
    while(r == 0);
    if(r >= 1)
    {
      r = 0;
      if(!((0x1 & flags) == 0) && !((0x001 & (signed int)pollfd.revents) == 0))
        r = r | 0x1;

      if(!((0x2 & flags) == 0) && !((0x004 & (signed int)pollfd.revents) == 0))
        r = r | 0x2;

      if(!((0x4 & flags) == 0) && !((0x008 & (signed int)pollfd.revents) == 0))
        r = r | 0x4;

    }

    else
      if(r == 0)
        soap->errnum = 0;

    return r;
  }

  if(timeout >= 1)
    retries = timeout - 1;

  signed int *return_value___errno_location_7;
  signed int tmp_post_9;
  do
  {
    efd = (struct anonymous_3 *)(void *)0;
    sfd = efd;
    rfd = sfd;
    if(!((0x1 & flags) == 0))
    {
      rfd = &fd[(signed long int)0];
      do
      {
        signed int tcp_select__1__2__1__1____d0;
        signed int tcp_select__1__2__1__1____d1;
        asm("cld; rep; stosq" : "=c"(tcp_select__1__2__1__1____d0), "=D"(tcp_select__1__2__1__1____d1) : "a"(0), "0"(sizeof(struct anonymous_3) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&rfd->__fds_bits[(signed long int)0]) : "memory");
      }
      while((_Bool)0);
      rfd->__fds_bits[(signed long int)(sk / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = rfd->__fds_bits[(signed long int)(sk / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << sk % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    }

    if(!((0x2 & flags) == 0))
    {
      sfd = &fd[(signed long int)1];
      do
      {
        signed int tcp_select__1__2__2__1____d0;
        signed int __d1;
        asm("cld; rep; stosq" : "=c"(tcp_select__1__2__2__1____d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_3) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&sfd->__fds_bits[(signed long int)0]) : "memory");
      }
      while((_Bool)0);
      sfd->__fds_bits[(signed long int)(sk / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = sfd->__fds_bits[(signed long int)(sk / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << sk % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    }

    if(!((0x4 & flags) == 0))
    {
      efd = &fd[(signed long int)2];
      do
      {
        signed int __d0;
        signed int tcp_select__1__2__3__1____d1;
        asm("cld; rep; stosq" : "=c"(__d0), "=D"(tcp_select__1__2__3__1____d1) : "a"(0), "0"(sizeof(struct anonymous_3) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&efd->__fds_bits[(signed long int)0]) : "memory");
      }
      while((_Bool)0);
      efd->__fds_bits[(signed long int)(sk / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = efd->__fds_bits[(signed long int)(sk / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << sk % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    }

    if(!(timeout >= 1))
    {
      tv.tv_sec = (signed long int)(-timeout / 1000000);
      tv.tv_usec = (signed long int)(-timeout % 1000000);
    }

    else
    {
      tv.tv_sec = (signed long int)1;
      tv.tv_usec = (signed long int)0;
    }
    r=select((signed int)sk + 1, rfd, sfd, efd, &tv);
    _Bool tmp_if_expr_8;
    if(!(r >= 0))
    {
      return_value___errno_location_7=__errno_location();
      soap->errnum = *return_value___errno_location_7;
      tmp_if_expr_8 = soap->errnum == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_8 = (_Bool)0;
    _Bool tmp_if_expr_10;
    if(tmp_if_expr_8)
    {
      tmp_post_9 = eintr;
      eintr = eintr - 1;
      tmp_if_expr_10 = tmp_post_9 > 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_10 = (_Bool)0;
    if(tmp_if_expr_10)
      r = 0;

    else
    {
      signed int tmp_post_6 = retries;
      retries = retries - 1;
      if(!(tmp_post_6 >= 1))
        break;

    }
  }
  while(r == 0);
  if(r >= 1)
  {
    r = 0;
    if(!((0x1 & flags) == 0))
    {
      if(!((rfd->__fds_bits[(signed long int)(sk / 8)] & (signed long int)(1UL << sk % 8)) == 0l))
        r = r | 0x1;

    }

    if(!((0x2 & flags) == 0))
    {
      if(!((sfd->__fds_bits[(signed long int)(sk / 8)] & (signed long int)(1UL << sk % 8)) == 0l))
        r = r | 0x2;

    }

    if(!((0x4 & flags) == 0))
    {
      if(!((efd->__fds_bits[(signed long int)(sk / 8)] & (signed long int)(1UL << sk % 8)) == 0l))
        r = r | 0x4;

    }

  }

  else
    if(r == 0)
      soap->errnum = 0;

  return r;
}

// tcp_shutdownsocket
// file stdsoap2.c line 5222
static signed int tcp_shutdownsocket(struct soap *soap, signed int sk, signed int how)
{
  (void)soap;
  signed int return_value_shutdown_1;
  return_value_shutdown_1=shutdown(sk, how);
  return return_value_shutdown_1;
}

