// tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_4;

// tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_2;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_5;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_1;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_0;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_7;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_9;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_3;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V_'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_11;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_6;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_10;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_8;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-cmsghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 242
struct cmsghdr;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-fd_store
// file ulockmgr_server.c line 35
struct fd_store;

// tag-flock
// file /usr/include/x86_64-linux-gnu/bits/fcntl.h line 35
struct flock;

// tag-iovec
// file /usr/include/x86_64-linux-gnu/bits/uio.h line 43
struct iovec;

// tag-message
// file ulockmgr_server.c line 25
struct message;

// tag-msghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 224
struct msghdr;

// tag-owner
// file ulockmgr_server.c line 42
struct owner;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-req_data
// file ulockmgr_server.c line 47
struct req_data;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// closefrom
// file ulockmgr_server.c line 127
static signed int closefrom(signed int minfd);
// dirfd
// file /usr/include/dirent.h line 223
extern signed int dirfd(struct __dirstream *);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// open
// file /usr/include/fcntl.h line 149
extern signed int open(const char *, signed int, ...);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// process_message
// file ulockmgr_server.c line 179
static void process_message(struct owner *o, struct message *msg, signed int cfd, signed int fd);
// process_owner
// file ulockmgr_server.c line 294
static void process_owner(signed int cfd);
// process_request
// file ulockmgr_server.c line 155
static void * process_request(void *d_);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_kill
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 35
extern signed int pthread_kill(unsigned long int, signed int);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_8 *, const union anonymous_10 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_8 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_8 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// readdir
// file /usr/include/dirent.h line 165
extern struct dirent * readdir(struct __dirstream *);
// receive_message
// file ulockmgr_server.c line 56
static signed int receive_message(signed int sock, void *buf, unsigned long int buflen, signed int *fdp, signed int *numfds);
// recvmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 202
extern signed long int recvmsg(signed int, struct msghdr *, signed int);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// send_reply
// file ulockmgr_server.c line 145
static void send_reply(signed int cfd, struct message *msg);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous *);
// sigprocmask
// file /usr/include/signal.h line 248
extern signed int sigprocmask(signed int, const struct anonymous *, struct anonymous *);
// sigusr1_handler
// file ulockmgr_server.c line 288
static void sigusr1_handler(signed int sig);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);

struct anonymous_4
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_2
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_5
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_1
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_0
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_9
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_3
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_6
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_5 _kill;
  // _timer
  struct anonymous_9 _timer;
  // _rt
  struct anonymous_0 _rt;
  // _sigchld
  struct anonymous_1 _sigchld;
  // _sigfault
  struct anonymous_2 _sigfault;
  // _sigpoll
  struct anonymous_3 _sigpoll;
  // _sigsys
  struct anonymous_4 _sigsys;
};

struct anonymous_7
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_6 _sifields;
};

union anonymous_11
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_7 *, void *);
};

union anonymous_10
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_8
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct cmsghdr
{
  // cmsg_len
  unsigned long int cmsg_len;
  // cmsg_level
  signed int cmsg_level;
  // cmsg_type
  signed int cmsg_type;
  // __cmsg_data
  unsigned char __cmsg_data[0l];
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct fd_store
{
  // next
  struct fd_store *next;
  // fd
  signed int fd;
  // origfd
  signed int origfd;
  // inuse
  signed int inuse;
};

struct flock
{
  // l_type
  signed short int l_type;
  // l_whence
  signed short int l_whence;
  // l_start
  signed long int l_start;
  // l_len
  signed long int l_len;
  // l_pid
  signed int l_pid;
};

struct iovec
{
  // iov_base
  void *iov_base;
  // iov_len
  unsigned long int iov_len;
};

struct message
{
  // intr
  unsigned int intr : 1;
  // nofd
  unsigned int nofd : 1;
  // thr
  unsigned long int thr;
  // cmd
  signed int cmd;
  // fd
  signed int fd;
  // lock
  struct flock lock;
  // error
  signed int error;
};

struct msghdr
{
  // msg_name
  void *msg_name;
  // msg_namelen
  unsigned int msg_namelen;
  // msg_iov
  struct iovec *msg_iov;
  // msg_iovlen
  unsigned long int msg_iovlen;
  // msg_control
  void *msg_control;
  // msg_controllen
  unsigned long int msg_controllen;
  // msg_flags
  signed int msg_flags;
};

struct owner
{
  // fds
  struct fd_store *fds;
  // lock
  union anonymous_8 lock;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct req_data
{
  // o
  struct owner *o;
  // cfd
  signed int cfd;
  // f
  struct fd_store *f;
  // msg
  struct message msg;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_11 __sigaction_handler;
  // sa_mask
  struct anonymous sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};


// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;

// closefrom
// file ulockmgr_server.c line 127
static signed int closefrom(signed int minfd)
{
  struct __dirstream *dir;
  dir=opendir("/proc/self/fd");
  if(!(dir == ((struct __dirstream *)NULL)))
  {
    signed int dfd;
    dfd=dirfd(dir);
    struct dirent *ent;
    do
    {
      ent=readdir(dir);
      if(ent == ((struct dirent *)NULL))
        break;

      char *end;
      signed int fd;
      signed long int return_value_strtol_1;
      return_value_strtol_1=strtol(ent->d_name, &end, 10);
      fd = (signed int)return_value_strtol_1;
      if(!(ent->d_name[0l] == 0))
      {
        if(*end == 0)
        {
          if(fd >= minfd)
          {
            if(!(fd == dfd))
              close(fd);

          }

        }

      }

    }
    while((_Bool)1);
    closedir(dir);
  }

  return 0;
}

// main
// file ulockmgr_server.c line 341
signed int main(signed int argc, char **argv)
{
  signed int nullfd;
  char *end;
  signed int cfd;
  struct anonymous empty;
  _Bool tmp_if_expr_1;
  if(!(argc == 2))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(argv[(signed long int)1][(signed long int)0] != 0) ? (_Bool)1 : (_Bool)0;
  signed long int return_value_strtol_2;
  signed int return_value_fork_3;
  signed int return_value_setsid_4;
  signed int return_value_dup2_5;
  if(!tmp_if_expr_1)
  {
    return_value_strtol_2=strtol(argv[(signed long int)1], &end, 10);
    cfd = (signed int)return_value_strtol_2;
    if(!(*end == 0))
      goto out_inval;

    return_value_fork_3=fork();
    if(!(return_value_fork_3 == -1))
    {
      if(return_value_fork_3 == 0)
        goto __CPROVER_DUMP_L4;

    }

    else
    {
      perror("ulockmgr_server: fork");
      exit(1);

    __CPROVER_DUMP_L4:
      ;
      goto __CPROVER_DUMP_L6;
    }
    _exit(0);

  __CPROVER_DUMP_L6:
    ;
    return_value_setsid_4=setsid();
    if(return_value_setsid_4 == -1)
    {
      perror("ulockmgr_server: setsid");
      exit(1);
    }

    chdir("/");
    sigemptyset(&empty);
    sigprocmask(2, &empty, (struct anonymous *)(void *)0);
    return_value_dup2_5=dup2(cfd, 4);
    if(return_value_dup2_5 == -1)
    {
      perror("ulockmgr_server: dup2");
      exit(1);
    }

    cfd = 4;
    nullfd=open("/dev/null", 02);
    if(nullfd >= 0)
    {
      dup2(nullfd, 0);
      dup2(nullfd, 1);
    }

    close(3);
    closefrom(5);
    while((_Bool)1)
    {
      char c;
      signed int sock;
      signed int pid;
      signed int numfds = 1;
      signed int res;
      res=receive_message(cfd, (void *)&c, sizeof(char) /*1ul*/ , &sock, &numfds);
      if(res == 0)
        break;

      if(res == -1)
        exit(1);

      /* assertion numfds == 1 */
      assert(numfds == 1);
      pid=fork();
      if(pid == -1)
      {
        perror("ulockmgr_server: fork");
        close(sock);
      }

      else
      {
        if(pid == 0)
        {
          close(cfd);
          pid=fork();
          if(pid == -1)
          {
            perror("ulockmgr_server: fork");
            _exit(1);
          }

          if(pid == 0)
            process_owner(sock);

          _exit(0);
        }

        waitpid(pid, (signed int *)(void *)0, 0);
        close(sock);
      }
    }
    return 0;
  }

  else
  {

  out_inval:
    ;
    fprintf(stderr, "%s should be started by libulockmgr\n", argv[(signed long int)0]);
    return 1;
  }
}

// process_message
// file ulockmgr_server.c line 179
static void process_message(struct owner *o, struct message *msg, signed int cfd, signed int fd)
{
  struct fd_store *f = (struct fd_store *)(void *)0;
  struct fd_store *newf = (struct fd_store *)(void *)0;
  struct fd_store **fp;
  struct req_data *d;
  unsigned long int tid;
  signed int res;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  signed int tmp_if_expr_4;
  signed int *return_value___errno_location_3;
  if(msg->cmd == 6)
  {
    if(!((signed int)msg->lock.l_type == 2))
      goto __CPROVER_DUMP_L8;

    if(!(msg->lock.l_start == 0l))
      goto __CPROVER_DUMP_L8;

    if(!(msg->lock.l_len == 0l))
      goto __CPROVER_DUMP_L8;

    fp = &o->fds;
    while(!(*fp == ((struct fd_store *)NULL)))
    {
      f = *fp;
      if(f->origfd == msg->fd)
        tmp_if_expr_1 = !(f->inuse != 0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
      {
        close(f->fd);
        *fp = f->next;
        free((void *)f);
      }

      else
        fp = &f->next;
    }
    if(msg->nofd == 0u)
      close(fd);

    msg->error = 0;
    send_reply(cfd, msg);
    close(cfd);
  }

  else
  {

  __CPROVER_DUMP_L8:
    ;
    if(!(msg->nofd == 0u))
    {
      fp = &o->fds;
      for( ; !(*fp == ((struct fd_store *)NULL)); fp = &(*fp)->next)
      {
        f = *fp;
        if(f->origfd == msg->fd)
          break;

      }
      if(*fp == ((struct fd_store *)NULL))
      {
        fprintf(stderr, "ulockmgr_server: fd %i not found\n", msg->fd);
        msg->error = 5;
        send_reply(cfd, msg);
        close(cfd);
        goto __CPROVER_DUMP_L26;
      }

    }

    else
    {
      void *return_value_malloc_2;
      return_value_malloc_2=malloc(sizeof(struct fd_store) /*24ul*/ );
      f = (struct fd_store *)return_value_malloc_2;
      newf = f;
      if(f == ((struct fd_store *)NULL))
      {
        msg->error = 37;
        send_reply(cfd, msg);
        close(cfd);
        goto __CPROVER_DUMP_L26;
      }

      f->fd = fd;
      f->origfd = msg->fd;
      f->inuse = 0;
    }
    if(msg->cmd == 5)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = msg->cmd == 6 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
      tmp_if_expr_6 = (_Bool)1;

    else
      tmp_if_expr_6 = (signed int)msg->lock.l_type == 2 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_6)
    {
      res=fcntl(f->fd, msg->cmd, &msg->lock);
      if(res == -1)
      {
        return_value___errno_location_3=__errno_location();
        tmp_if_expr_4 = *return_value___errno_location_3;
      }

      else
        tmp_if_expr_4 = 0;
      msg->error = tmp_if_expr_4;
      send_reply(cfd, msg);
      close(cfd);
      if(!(newf == ((struct fd_store *)NULL)))
      {
        newf->next = o->fds;
        o->fds = newf;
      }

      goto __CPROVER_DUMP_L26;
    }

    void *return_value_malloc_7;
    return_value_malloc_7=malloc(sizeof(struct req_data) /*88ul*/ );
    d = (struct req_data *)return_value_malloc_7;
    if(d == ((struct req_data *)NULL))
    {
      msg->error = 37;
      send_reply(cfd, msg);
      close(cfd);
      free((void *)newf);
    }

    else
    {
      f->inuse = f->inuse + 1;
      d->o = o;
      d->cfd = cfd;
      d->f = f;
      d->msg = *msg;
      res=pthread_create(&tid, (const union pthread_attr_t *)(void *)0, process_request, (void *)d);
      if(!(res == 0))
      {
        msg->error = 37;
        send_reply(cfd, msg);
        close(cfd);
        free((void *)d);
        f->inuse = f->inuse - 1;
        free((void *)newf);
      }

      else
      {
        if(!(newf == ((struct fd_store *)NULL)))
        {
          newf->next = o->fds;
          o->fds = newf;
        }

        pthread_detach(tid);
      }
    }
  }

__CPROVER_DUMP_L26:
  ;
}

// process_owner
// file ulockmgr_server.c line 294
static void process_owner(signed int cfd)
{
  struct owner o;
  struct sigaction sa;
  memset((void *)&sa, 0, sizeof(struct sigaction) /*152ul*/ );
  sa.__sigaction_handler.sa_handler = sigusr1_handler;
  sigemptyset(&sa.sa_mask);
  signed int return_value_sigaction_1;
  return_value_sigaction_1=sigaction(10, &sa, (struct sigaction *)(void *)0);
  if(return_value_sigaction_1 == -1)
  {
    perror("ulockmgr_server: cannot set sigusr1 signal handler");
    exit(1);
  }

  memset((void *)&o, 0, sizeof(struct owner) /*48ul*/ );
  pthread_mutex_init(&o.lock, (const union anonymous_10 *)(void *)0);
  while((_Bool)1)
  {
    struct message msg;
    signed int rfds[2l];
    signed int res;
    signed int numfds = 2;
    res=receive_message(cfd, (void *)&msg, sizeof(struct message) /*64ul*/ , rfds, &numfds);
    if(res == 0)
      break;

    if(res == -1)
      exit(1);

    if(!(msg.intr == 0u))
    {
      if(!(numfds == 0))
        fprintf(stderr, "ulockmgr_server: too many fds for intr\n");

      pthread_kill(msg.thr, 10);
    }

    else
    {
      if(!(numfds == 2))
        continue;

      pthread_mutex_lock(&o.lock);
      process_message(&o, &msg, rfds[(signed long int)0], rfds[(signed long int)1]);
      pthread_mutex_unlock(&o.lock);
    }
  }
  if(!(o.fds == ((struct fd_store *)NULL)))
    fprintf(stderr, "ulockmgr_server: open file descriptors on exit\n");

}

// process_request
// file ulockmgr_server.c line 155
static void * process_request(void *d_)
{
  struct req_data *d = (struct req_data *)d_;
  signed int res;
  /* assertion d->msg.cmd == 7 */
  assert(d->msg.cmd == 7);
  res=fcntl(d->f->fd, 6, &d->msg.lock);
  signed int *return_value___errno_location_1;
  if(res == -1)
  {
    return_value___errno_location_1=__errno_location();
    if(*return_value___errno_location_1 == 11)
    {
      d->msg.error = 11;
      d->msg.thr=pthread_self();
      send_reply(d->cfd, &d->msg);
      res=fcntl(d->f->fd, 7, &d->msg.lock);
    }

  }

  signed int tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  if(res == -1)
  {
    return_value___errno_location_2=__errno_location();
    tmp_if_expr_3 = *return_value___errno_location_2;
  }

  else
    tmp_if_expr_3 = 0;
  d->msg.error = tmp_if_expr_3;
  pthread_mutex_lock(&d->o->lock);
  d->f->inuse = d->f->inuse - 1;
  pthread_mutex_unlock(&d->o->lock);
  send_reply(d->cfd, &d->msg);
  close(d->cfd);
  free((void *)d);
  return (void *)0;
}

// receive_message
// file ulockmgr_server.c line 56
static signed int receive_message(signed int sock, void *buf, unsigned long int buflen, signed int *fdp, signed int *numfds)
{
  struct msghdr msg;
  struct iovec iov;
  unsigned long int ccmsg[3l];
  struct cmsghdr *cmsg;
  signed int res;
  signed int i;
  /* assertion *numfds <= 2 */
  assert(*numfds <= 2);
  iov.iov_base = buf;
  iov.iov_len = buflen;
  memset((void *)&msg, 0, sizeof(struct msghdr) /*56ul*/ );
  memset((void *)ccmsg, -1, sizeof(unsigned long int [3l]) /*24ul*/ );
  msg.msg_iov = &iov;
  msg.msg_iovlen = (unsigned long int)1;
  msg.msg_control = (void *)ccmsg;
  msg.msg_controllen = sizeof(unsigned long int [3l]) /*24ul*/ ;
  signed long int return_value_recvmsg_1;
  return_value_recvmsg_1=recvmsg(sock, &msg, 256);
  res = (signed int)return_value_recvmsg_1;
  if(res == 0)
  {
    signed long int return_value_recvmsg_2;
    return_value_recvmsg_2=recvmsg(sock, &msg, 256);
    res = (signed int)return_value_recvmsg_2;
    if(res == 0)
      return 0;

  }

  struct cmsghdr *tmp_if_expr_3;
  if(res == -1)
  {
    perror("ulockmgr_server: recvmsg");
    return -1;
  }

  else
    if(!((unsigned long int)res == buflen))
    {
      fprintf(stderr, "ulockmgr_server: short message received\n");
      return -1;
    }

    else
    {
      if(msg.msg_controllen >= sizeof(struct cmsghdr) /*16ul*/ )
        tmp_if_expr_3 = (struct cmsghdr *)(&msg)->msg_control;

      else
        tmp_if_expr_3 = (struct cmsghdr *)0;
      cmsg = tmp_if_expr_3;
      if(!(cmsg == ((struct cmsghdr *)NULL)))
      {
        if((signed int)(cmsg->cmsg_type == 0) == 1)
        {
          fprintf(stderr, "ulockmgr_server: unknown control message %d\n", cmsg->cmsg_type);
          return -1;
        }

        memcpy((void *)fdp, (const void *)cmsg->__cmsg_data, sizeof(signed int) /*4ul*/  * (unsigned long int)*numfds);
        if(!((8 & msg.msg_flags) == 0))
        {
          fprintf(stderr, "ulockmgr_server: control message truncated\n");
          i = 0;
          for( ; !(i >= *numfds); i = i + 1)
            close(fdp[(signed long int)i]);
          *numfds = 0;
        }

      }

      else
      {
        if(!((8 & msg.msg_flags) == 0))
        {
          fprintf(stderr, "ulockmgr_server: control message truncated(*)\n");
          cmsg = (struct cmsghdr *)ccmsg;
          memcpy((void *)fdp, (const void *)cmsg->__cmsg_data, sizeof(signed int) /*4ul*/  * (unsigned long int)*numfds);
          i = 0;
          for( ; !(i >= *numfds); i = i + 1)
            close(fdp[(signed long int)i]);
        }

        *numfds = 0;
      }
      return res;
    }
}

// send_reply
// file ulockmgr_server.c line 145
static void send_reply(signed int cfd, struct message *msg)
{
  signed int res;
  signed long int return_value_send_1;
  return_value_send_1=send(cfd, (const void *)msg, sizeof(struct message) /*64ul*/ , 16384);
  res = (signed int)return_value_send_1;
  if(res == -1)
    perror("ulockmgr_server: sending reply");

}

// sigusr1_handler
// file ulockmgr_server.c line 288
static void sigusr1_handler(signed int sig)
{
  (void)sig;
}

