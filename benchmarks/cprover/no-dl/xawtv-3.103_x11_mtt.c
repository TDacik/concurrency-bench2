// #anon_enum$JCS_UNKNOWN=0$JCS_GRAYSCALE=1$JCS_RGB=2$JCS_YCbCr=3$JCS_CMYK=4$JCS_YCCK=5$JCS_EXT_RGB=6$JCS_EXT_RGBX=7$JCS_EXT_BGR=8$JCS_EXT_BGRX=9$JCS_EXT_XBGR=10$JCS_EXT_XRGB=11$JCS_EXT_RGBA=12$JCS_EXT_BGRA=13$JCS_EXT_ABGR=14$JCS_EXT_ARGB=15$JCS_RGB565=16
// file /usr/include/jpeglib.h line 215
enum anonymous$5 { JCS_UNKNOWN=0, JCS_GRAYSCALE=1, JCS_RGB=2, JCS_YCbCr=3, JCS_CMYK=4, JCS_YCCK=5, JCS_EXT_RGB=6, JCS_EXT_RGBX=7, JCS_EXT_BGR=8, JCS_EXT_BGRX=9, JCS_EXT_XBGR=10, JCS_EXT_XRGB=11, JCS_EXT_RGBA=12, JCS_EXT_BGRA=13, JCS_EXT_ABGR=14, JCS_EXT_ARGB=15, JCS_RGB565=16 };

// #anon_enum$JDCT_ISLOW=0$JDCT_IFAST=1$JDCT_FLOAT=2
// file /usr/include/jpeglib.h line 244
enum anonymous$10 { JDCT_ISLOW=0, JDCT_IFAST=1, JDCT_FLOAT=2 };

// #anon_enum$VBI_AUDIO_MODE_NONE=0$VBI_AUDIO_MODE_MONO=1$VBI_AUDIO_MODE_STEREO=2$VBI_AUDIO_MODE_STEREO_SURROUND=3$VBI_AUDIO_MODE_SIMULATED_STEREO=4$VBI_AUDIO_MODE_VIDEO_DESCRIPTIONS=5$VBI_AUDIO_MODE_NON_PROGRAM_AUDIO=6$VBI_AUDIO_MODE_SPECIAL_EFFECTS=7$VBI_AUDIO_MODE_DATA_SERVICE=8$VBI_AUDIO_MODE_UNKNOWN=9
// file /usr/include/libzvbi.h line 534
enum anonymous$29 { VBI_AUDIO_MODE_NONE=0, VBI_AUDIO_MODE_MONO=1, VBI_AUDIO_MODE_STEREO=2, VBI_AUDIO_MODE_STEREO_SURROUND=3, VBI_AUDIO_MODE_SIMULATED_STEREO=4, VBI_AUDIO_MODE_VIDEO_DESCRIPTIONS=5, VBI_AUDIO_MODE_NON_PROGRAM_AUDIO=6, VBI_AUDIO_MODE_SPECIAL_EFFECTS=7, VBI_AUDIO_MODE_DATA_SERVICE=8, VBI_AUDIO_MODE_UNKNOWN=9 };

// #anon_enum$VBI_BLACK=0$VBI_RED=1$VBI_GREEN=2$VBI_YELLOW=3$VBI_BLUE=4$VBI_MAGENTA=5$VBI_CYAN=6$VBI_WHITE=7
// file /usr/include/libzvbi.h line 761
enum anonymous$102 { VBI_BLACK=0, VBI_RED=1, VBI_GREEN=2, VBI_YELLOW=3, VBI_BLUE=4, VBI_MAGENTA=5, VBI_CYAN=6, VBI_WHITE=7 };

// #anon_enum$VBI_CNI_TYPE_NONE=0$VBI_CNI_TYPE_UNKNOWN=0$VBI_CNI_TYPE_VPS=1$VBI_CNI_TYPE_8301=2$VBI_CNI_TYPE_8302=3$VBI_CNI_TYPE_PDC_A=4$VBI_CNI_TYPE_PDC_B=5
// file /usr/include/libzvbi.h line 254
enum anonymous$79 { VBI_CNI_TYPE_NONE=0, VBI_CNI_TYPE_UNKNOWN=0, VBI_CNI_TYPE_VPS=1, VBI_CNI_TYPE_8301=2, VBI_CNI_TYPE_8302=3, VBI_CNI_TYPE_PDC_A=4, VBI_CNI_TYPE_PDC_B=5 };

// #anon_enum$VBI_DST_UNKNOWN=0$VBI_DST_INCLUDED=1$VBI_DST_INACTIVE=2$VBI_DST_ACTIVE=3
// file /usr/include/libzvbi.h line 676
enum anonymous$85 { VBI_DST_UNKNOWN=0, VBI_DST_INCLUDED=1, VBI_DST_INACTIVE=2, VBI_DST_ACTIVE=3 };

// #anon_enum$VBI_LINK_NONE=0$VBI_LINK_MESSAGE=1$VBI_LINK_PAGE=2$VBI_LINK_SUBPAGE=3$VBI_LINK_HTTP=4$VBI_LINK_FTP=5$VBI_LINK_EMAIL=6$VBI_LINK_LID=7$VBI_LINK_TELEWEB=8
// file /usr/include/libzvbi.h line 445
enum anonymous$17 { VBI_LINK_NONE=0, VBI_LINK_MESSAGE=1, VBI_LINK_PAGE=2, VBI_LINK_SUBPAGE=3, VBI_LINK_HTTP=4, VBI_LINK_FTP=5, VBI_LINK_EMAIL=6, VBI_LINK_LID=7, VBI_LINK_TELEWEB=8 };

// #anon_enum$VBI_PCS_AUDIO_UNKNOWN=0$VBI_PCS_AUDIO_MONO=1$VBI_PCS_AUDIO_STEREO=2$VBI_PCS_AUDIO_BILINGUAL=3
// file /usr/include/libzvbi.h line 370
enum anonymous$83 { VBI_PCS_AUDIO_UNKNOWN=0, VBI_PCS_AUDIO_MONO=1, VBI_PCS_AUDIO_STEREO=2, VBI_PCS_AUDIO_BILINGUAL=3 };

// #anon_enum$VBI_PID_CHANNEL_LCI_0=0$VBI_PID_CHANNEL_LCI_1=1$VBI_PID_CHANNEL_LCI_2=2$VBI_PID_CHANNEL_LCI_3=3$VBI_PID_CHANNEL_VPS=4$VBI_PID_CHANNEL_PDC_DESCRIPTOR=5$VBI_PID_CHANNEL_XDS_CURRENT=6$VBI_PID_CHANNEL_XDS_FUTURE=7$VBI_MAX_PID_CHANNELS=8
// file /usr/include/libzvbi.h line 346
enum anonymous$82 { VBI_PID_CHANNEL_LCI_0=0, VBI_PID_CHANNEL_LCI_1=1, VBI_PID_CHANNEL_LCI_2=2, VBI_PID_CHANNEL_LCI_3=3, VBI_PID_CHANNEL_VPS=4, VBI_PID_CHANNEL_PDC_DESCRIPTOR=5, VBI_PID_CHANNEL_XDS_CURRENT=6, VBI_PID_CHANNEL_XDS_FUTURE=7, VBI_MAX_PID_CHANNELS=8 };

// #anon_enum$VBI_PIXFMT_YUV420=1$VBI_PIXFMT_YUYV=2$VBI_PIXFMT_YVYU=3$VBI_PIXFMT_UYVY=4$VBI_PIXFMT_VYUY=5$VBI_PIXFMT_PAL8=6$VBI_PIXFMT_RGBA32_LE=32$VBI_PIXFMT_RGBA32_BE=33$VBI_PIXFMT_BGRA32_LE=34$VBI_PIXFMT_BGRA32_BE=35$VBI_PIXFMT_ABGR32_BE=32$VBI_PIXFMT_ABGR32_LE=33$VBI_PIXFMT_ARGB32_BE=34$VBI_PIXFMT_ARGB32_LE=35$VBI_PIXFMT_RGB24=36$VBI_PIXFMT_BGR24=37$VBI_PIXFMT_RGB16_LE=38$VBI_PIXFMT_RGB16_BE=39$VBI_PIXFMT_BGR16_LE=40$VBI_PIXFMT_BGR16_BE=41$VBI_PIXFMT_RGBA15_LE=42$VBI_PIXFMT_RGBA15_BE=43$VBI_PIXFMT_BGRA15_LE=44$VBI_PIXFMT_BGRA15_BE=45$VBI_PIXFMT_ARGB15_LE=46$VBI_PIXFMT_ARGB15_BE=47$VBI_PIXFMT_ABGR15_LE=48$VBI_PIXFMT_ABGR15_BE=49
// file /usr/include/libzvbi.h line 1069
enum anonymous$13 { VBI_PIXFMT_YUV420=1, VBI_PIXFMT_YUYV=2, VBI_PIXFMT_YVYU=3, VBI_PIXFMT_UYVY=4, VBI_PIXFMT_VYUY=5, VBI_PIXFMT_PAL8=6, VBI_PIXFMT_RGBA32_LE=32, VBI_PIXFMT_RGBA32_BE=33, VBI_PIXFMT_BGRA32_LE=34, VBI_PIXFMT_BGRA32_BE=35, VBI_PIXFMT_ABGR32_BE=32, VBI_PIXFMT_ABGR32_LE=33, VBI_PIXFMT_ARGB32_BE=34, VBI_PIXFMT_ARGB32_LE=35, VBI_PIXFMT_RGB24=36, VBI_PIXFMT_BGR24=37, VBI_PIXFMT_RGB16_LE=38, VBI_PIXFMT_RGB16_BE=39, VBI_PIXFMT_BGR16_LE=40, VBI_PIXFMT_BGR16_BE=41, VBI_PIXFMT_RGBA15_LE=42, VBI_PIXFMT_RGBA15_BE=43, VBI_PIXFMT_BGRA15_LE=44, VBI_PIXFMT_BGRA15_BE=45, VBI_PIXFMT_ARGB15_LE=46, VBI_PIXFMT_ARGB15_BE=47, VBI_PIXFMT_ABGR15_LE=48, VBI_PIXFMT_ABGR15_BE=49 };

// #anon_enum$VBI_PROG_CLASSF_NONE=0$VBI_PROG_CLASSF_EIA_608=1$VBI_PROG_CLASSF_ETS_300231=2
// file /usr/include/libzvbi.h line 524
enum anonymous$25 { VBI_PROG_CLASSF_NONE=0, VBI_PROG_CLASSF_EIA_608=1, VBI_PROG_CLASSF_ETS_300231=2 };

// #anon_enum$VBI_RATING_AUTH_NONE=0$VBI_RATING_AUTH_MPAA=1$VBI_RATING_AUTH_TV_US=2$VBI_RATING_AUTH_TV_CA_EN=3$VBI_RATING_AUTH_TV_CA_FR=4
// file /usr/include/libzvbi.h line 508
enum anonymous$26 { VBI_RATING_AUTH_NONE=0, VBI_RATING_AUTH_MPAA=1, VBI_RATING_AUTH_TV_US=2, VBI_RATING_AUTH_TV_CA_EN=3, VBI_RATING_AUTH_TV_CA_FR=4 };

// #anon_enum$VBI_SUBT_NONE=0$VBI_SUBT_ACTIVE=1$VBI_SUBT_MATTE=2$VBI_SUBT_UNKNOWN=3
// file /usr/include/libzvbi.h line 487
enum anonymous$33 { VBI_SUBT_NONE=0, VBI_SUBT_ACTIVE=1, VBI_SUBT_MATTE=2, VBI_SUBT_UNKNOWN=3 };

// #anon_enum$VBI_TRANSPARENT_SPACE=0$VBI_TRANSPARENT_FULL=1$VBI_SEMI_TRANSPARENT=2$VBI_OPAQUE=3
// file /usr/include/libzvbi.h line 775
enum anonymous$103 { VBI_TRANSPARENT_SPACE=0, VBI_TRANSPARENT_FULL=1, VBI_SEMI_TRANSPARENT=2, VBI_OPAQUE=3 };

// #anon_enum$VBI_WEBLINK_UNKNOWN=0$VBI_WEBLINK_PROGRAM_RELATED=1$VBI_WEBLINK_NETWORK_RELATED=2$VBI_WEBLINK_STATION_RELATED=3$VBI_WEBLINK_SPONSOR_MESSAGE=4$VBI_WEBLINK_OPERATOR=5
// file /usr/include/libzvbi.h line 459
enum anonymous$18 { VBI_WEBLINK_UNKNOWN=0, VBI_WEBLINK_PROGRAM_RELATED=1, VBI_WEBLINK_NETWORK_RELATED=2, VBI_WEBLINK_STATION_RELATED=3, VBI_WEBLINK_SPONSOR_MESSAGE=4, VBI_WEBLINK_OPERATOR=5 };

// #anon_enum$VBI_WST_LEVEL_1=0$VBI_WST_LEVEL_1p5=1$VBI_WST_LEVEL_2p5=2$VBI_WST_LEVEL_3p5=3
// file /usr/include/libzvbi.h line 2017
enum anonymous { VBI_WST_LEVEL_1=0, VBI_WST_LEVEL_1p5=1, VBI_WST_LEVEL_2p5=2, VBI_WST_LEVEL_3p5=3 };

// #anon_enum$XmCHARSET_TEXT=0$XmMULTIBYTE_TEXT=1$XmWIDECHAR_TEXT=2$XmNO_TEXT=3
// file /usr/include/Xm/Xm.h line 215
enum anonymous$3 { XmCHARSET_TEXT=0, XmMULTIBYTE_TEXT=1, XmWIDECHAR_TEXT=2, XmNO_TEXT=3 };

// #anon_enum$XmOUTPUT_ALL=0$XmOUTPUT_BETWEEN=1$XmOUTPUT_BEGINNING=2$XmOUTPUT_END=3$XmOUTPUT_BOTH=4
// file /usr/include/Xm/Xm.h line 220
enum anonymous$4 { XmOUTPUT_ALL=0, XmOUTPUT_BETWEEN=1, XmOUTPUT_BEGINNING=2, XmOUTPUT_END=3, XmOUTPUT_BOTH=4 };

// #anon_enum$XrmoptionNoArg=0$XrmoptionIsArg=1$XrmoptionStickyArg=2$XrmoptionSepArg=3$XrmoptionResArg=4$XrmoptionSkipArg=5$XrmoptionSkipLine=6$XrmoptionSkipNArgs=7
// file /usr/include/X11/Xresource.h line 326
enum anonymous$20 { XrmoptionNoArg=0, XrmoptionIsArg=1, XrmoptionStickyArg=2, XrmoptionSepArg=3, XrmoptionResArg=4, XrmoptionSkipArg=5, XrmoptionSkipLine=6, XrmoptionSkipNArgs=7 };

// tag-#anon#ST[*{S8}$S8$'name'|*{S8}$S8$'value'|U64'pixel']
// file /usr/include/X11/xpm.h line 100
struct anonymous$87;

// tag-#anon#ST[*{S8}$S8$'name'|S64'value']
// file /usr/include/X11/Intrinsic.h line 316
struct anonymous$1;

// tag-#anon#ST[*{S8}$S8$'name'|U32'nlines'|U32'$pad0'|*{*{S8}$S8$}$*{S8}$S8$$'lines']
// file /usr/include/X11/xpm.h line 106
struct anonymous$88;

// tag-#anon#ST[*{S8}$S8$'option'|*{S8}$S8$'specifier'|SYM##anon_enum$XrmoptionNoArg=0$XrmoptionIsArg=1$XrmoptionStickyArg=2$XrmoptionSepArg=3$XrmoptionResArg=4$XrmoptionSkipArg=5$XrmoptionSkipLine=6$XrmoptionSkipNArgs=7#'argKind'|U32'$pad0'|*{S8}$S8$'value']
// file /usr/include/X11/Xresource.h line 338
struct anonymous$21;

// tag-#anon#ST[*{S8}$S8$'string'|*{S8}$S8$'symbolic'|*{S8}$S8$'m_color'|*{S8}$S8$'g4_color'|*{S8}$S8$'g_color'|*{S8}$S8$'c_color']
// file /usr/include/X11/xpm.h line 112
struct anonymous$89;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'$pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'|U64'visualid'|S32'class'|U32'$pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'|U64'visualid'|S32'class'|U32'$pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#$'visuals']#}$SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'|U64'visualid'|S32'class'|U32'$pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'|U64'visualid'|S32'class'|U32'$pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#$'visuals']#$'depths'|S32'root_depth'|U32'$pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'|U64'visualid'|S32'class'|U32'$pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'|U64'visualid'|S32'class'|U32'$pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#$'root_visual'|*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']
// file /usr/include/X11/Xlib.h line 257
struct anonymous$96;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'|U64'fid'|U32'direction'|U32'min_char_or_byte2'|U32'max_char_or_byte2'|U32'min_byte1'|U32'max_byte1'|S32'all_chars_exist'|U32'default_char'|S32'n_properties'|*{SYM#tag-#anon#ST[U64'name'|U64'card32']#}$SYM#tag-#anon#ST[U64'name'|U64'card32']#$'properties'|SYM#tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']#'min_bounds'|SYM#tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']#'max_bounds'|*{SYM#tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']#}$SYM#tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']#$'per_char'|S32'ascent'|S32'descent']
// file /usr/include/X11/Xlib.h line 1035
struct anonymous$100;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'|U64'visualid'|S32'class'|U32'$pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']
// file /usr/include/X11/Xlib.h line 227
struct anonymous$90;

// tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous$37;

// tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$32;

// tag-#anon#ST[ARR16{S64}$S64$'__fds_bits']
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$12;

// tag-#anon#ST[ARR16{S64}$S64$'fds_bits']
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$94;

// tag-#anon#ST[ARR16{U64}$U64$'__val']
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$16;

// tag-#anon#ST[ARR17{U8}$U8$'bits'|ARR256{U8}$U8$'huffval'|U24'$pad0'|S32'sent_table']
// file /usr/include/jpeglib.h line 101
struct anonymous$8;

// tag-#anon#ST[ARR64{U16}$U16$'quantval'|S32'sent_table']
// file /usr/include/jpeglib.h line 84
struct anonymous$7;

// tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']
// file /usr/include/X11/Xlib.h line 1017
struct anonymous$99;

// tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}$V$'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$81;

// tag-#anon#ST[S32'component_id'|S32'component_index'|S32'h_samp_factor'|S32'v_samp_factor'|S32'quant_tbl_no'|S32'dc_tbl_no'|S32'ac_tbl_no'|U32'width_in_blocks'|U32'height_in_blocks'|S32'DCT_scaled_size'|U32'downsampled_width'|U32'downsampled_height'|S32'component_needed'|S32'MCU_width'|S32'MCU_height'|S32'MCU_blocks'|S32'MCU_sample_width'|S32'last_col_width'|S32'last_row_height'|U32'$pad0'|*{SYM#tag-#anon#ST[ARR64{U16}$U16$'quantval'|S32'sent_table']#}$SYM#tag-#anon#ST[ARR64{U16}$U16$'quantval'|S32'sent_table']#$'quant_table'|*{V}$V$'dct_table']
// file /usr/include/jpeglib.h line 117
struct anonymous$6;

// tag-#anon#ST[S32'comps_in_scan'|ARR4{S32}$S32$'component_index'|S32'Ss'|S32'Se'|S32'Ah'|S32'Al']
// file /usr/include/jpeglib.h line 190
struct anonymous$9;

// tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'|U64'visualid'|S32'class'|U32'$pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'|U64'visualid'|S32'class'|U32'$pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#$'visuals']
// file /usr/include/X11/Xlib.h line 243
struct anonymous$95;

// tag-#anon#ST[S32'first_line'|S32'last_line'|F64'ratio'|S32'film_mode'|SYM##anon_enum$VBI_SUBT_NONE=0$VBI_SUBT_ACTIVE=1$VBI_SUBT_MATTE=2$VBI_SUBT_UNKNOWN=3#'open_subtitles']
// file /usr/include/libzvbi.h line 494
struct anonymous$34;

// tag-#anon#ST[S32'function'|U32'$pad0'|U64'plane_mask'|U64'foreground'|U64'background'|S32'line_width'|S32'line_style'|S32'cap_style'|S32'join_style'|S32'fill_style'|S32'fill_rule'|S32'arc_mode'|U32'$pad1'|U64'tile'|U64'stipple'|S32'ts_x_origin'|S32'ts_y_origin'|U64'font'|S32'subwindow_mode'|S32'graphics_exposures'|S32'clip_x_origin'|S32'clip_y_origin'|U64'clip_mask'|S32'dash_offset'|S8'dashes'|U24'$pad2']
// file /usr/include/X11/Xlib.h line 181
struct anonymous$107;

// tag-#anon#ST[S32'pgno']
// file /usr/include/libzvbi.h line 724
struct anonymous$44;

// tag-#anon#ST[S32'pgno'|S32'subno']
// file /usr/include/libzvbi.h line 832
struct anonymous$104;

// tag-#anon#ST[S32'pgno'|S32'subno'|*{U8}$U8$'raw_header'|S32'pn_offset'|BF{U32}$U32$'roll_header'|BF{U32}$U32$'header_update'|BF{U32}$U32$'clock_update'|BF{U5}$U5$'$bit_field_pad0'|U24'$pad0']
// file /usr/include/libzvbi.h line 715
struct anonymous$43;

// tag-#anon#ST[S32'reason'|U32'$pad0'|*{SYM#tag-_XEvent#}$SYM#tag-_XEvent#$'event'|*{SYM#tag-__XmStringRec#}$SYM#tag-__XmStringRec#$'value'|S32'length'|U32'$pad1'|*{SYM#tag-__XmStringRec#}$SYM#tag-__XmStringRec#$'mask'|S32'mask_length'|U32'$pad2'|*{SYM#tag-__XmStringRec#}$SYM#tag-__XmStringRec#$'dir'|S32'dir_length'|U32'$pad3'|*{SYM#tag-__XmStringRec#}$SYM#tag-__XmStringRec#$'pattern'|S32'pattern_length'|U32'$pad4']
// file /usr/include/Xm/Xm.h line 774
struct anonymous$0;

// tag-#anon#ST[S32'reason'|U32'$pad0'|*{SYM#tag-_XEvent#}$SYM#tag-_XEvent#$'event'|U64'selection'|U64'target'|*{V}$V$'source_data'|*{V}$V$'location_data'|S32'flags'|U32'$pad1'|*{V}$V$'parm'|S32'parm_format'|U32'$pad2'|U64'parm_length'|U64'parm_type'|S32'status'|U32'$pad3'|*{V}$V$'value'|U64'type'|S32'format'|U32'$pad4'|U64'length']
// file /usr/include/Xm/Transfer.h line 65
struct anonymous$2;

// tag-#anon#ST[S32'reason'|U32'$pad0'|*{SYM#tag-_XEvent#}$SYM#tag-_XEvent#$'event'|U64'window']
// file /usr/include/Xm/Xm.h line 698
struct anonymous$109;

// tag-#anon#ST[S32'si_pid'|U32'si_uid']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$23;

// tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$31;

// tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$28;

// tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'$pad0'|SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$24;

// tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$27;

// tag-#anon#ST[S32'type'|U32'$pad0'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'resourceid'|U64'serial'|U8'error_code'|U8'request_code'|U8'minor_code'|U40'$pad1']
// file /usr/include/X11/Xlib.h line 924
struct anonymous$74;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|S32'extension'|S32'evtype']
// file /usr/include/X11/Xlib.h line 948
struct anonymous$75;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|S32'extension'|S32'evtype'|U32'cookie'|U32'$pad2'|*{V}$V$'data']
// file /usr/include/X11/Xlib.h line 958
struct anonymous$76;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'drawable'|S32'major_code'|S32'minor_code']
// file /usr/include/X11/Xlib.h line 686
struct anonymous$52;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'drawable'|S32'x'|S32'y'|S32'width'|S32'height'|S32'count'|S32'major_code'|S32'minor_code'|U32'$pad2']
// file /usr/include/X11/Xlib.h line 673
struct anonymous$51;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'event'|U64'window']
// file /usr/include/X11/Xlib.h line 718
struct anonymous$55;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'event'|U64'window'|S32'from_configure'|U32'$pad2']
// file /usr/include/X11/Xlib.h line 727
struct anonymous$56;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'event'|U64'window'|S32'override_redirect'|U32'$pad2']
// file /usr/include/X11/Xlib.h line 737
struct anonymous$58;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'event'|U64'window'|S32'place'|U32'$pad2']
// file /usr/include/X11/Xlib.h line 816
struct anonymous$65;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'event'|U64'window'|S32'x'|S32'y']
// file /usr/include/X11/Xlib.h line 782
struct anonymous$62;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'event'|U64'window'|S32'x'|S32'y'|S32'width'|S32'height'|S32'border_width'|U32'$pad2'|U64'above'|S32'override_redirect'|U32'$pad3']
// file /usr/include/X11/Xlib.h line 768
struct anonymous$61;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'event'|U64'window'|U64'parent'|S32'x'|S32'y'|S32'override_redirect'|U32'$pad2']
// file /usr/include/X11/Xlib.h line 756
struct anonymous$60;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'owner'|U64'requestor'|U64'selection'|U64'target'|U64'property'|U64'time']
// file /usr/include/X11/Xlib.h line 857
struct anonymous$69;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'parent'|U64'window']
// file /usr/include/X11/Xlib.h line 747
struct anonymous$59;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'parent'|U64'window'|S32'place'|U32'$pad2']
// file /usr/include/X11/Xlib.h line 826
struct anonymous$66;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'parent'|U64'window'|S32'x'|S32'y'|S32'width'|S32'height'|S32'border_width'|S32'override_redirect']
// file /usr/include/X11/Xlib.h line 705
struct anonymous$54;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'parent'|U64'window'|S32'x'|S32'y'|S32'width'|S32'height'|S32'border_width'|U32'$pad2'|U64'above'|S32'detail'|U32'$pad3'|U64'value_mask']
// file /usr/include/X11/Xlib.h line 801
struct anonymous$64;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'requestor'|U64'selection'|U64'target'|U64'property'|U64'time']
// file /usr/include/X11/Xlib.h line 870
struct anonymous$70;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'window']
// file /usr/include/X11/Xlib.h line 934
struct anonymous$57;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'window'|ARR32{S8}$S8$'key_vector']
// file /usr/include/X11/Xlib.h line 653
struct anonymous$49;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'window'|S32'mode'|S32'detail']
// file /usr/include/X11/Xlib.h line 634
struct anonymous$48;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'window'|S32'request'|S32'first_keycode'|S32'count'|U32'$pad2']
// file /usr/include/X11/Xlib.h line 912
struct anonymous$73;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'window'|S32'state'|U32'$pad2']
// file /usr/include/X11/Xlib.h line 696
struct anonymous$53;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'window'|S32'width'|S32'height']
// file /usr/include/X11/Xlib.h line 792
struct anonymous$63;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'window'|S32'x'|S32'y'|S32'width'|S32'height'|S32'count'|U32'$pad2']
// file /usr/include/X11/Xlib.h line 662
struct anonymous$50;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'window'|U64'atom'|U64'time'|S32'state'|U32'$pad2']
// file /usr/include/X11/Xlib.h line 836
struct anonymous$67;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'window'|U64'colormap'|S32'new'|S32'state']
// file /usr/include/X11/Xlib.h line 882
struct anonymous$71;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'window'|U64'message_type'|S32'format'|U32'$pad2'|SYM#tag-#anon#UN[ARR20{S8}$S8$'b'|ARR10{S16}$S16$'s'|ARR5{S64}$S64$'l']#'data']
// file /usr/include/X11/Xlib.h line 897
struct anonymous$72;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'window'|U64'root'|U64'subwindow'|U64'time'|S32'x'|S32'y'|S32'x_root'|S32'y_root'|S32'mode'|S32'detail'|S32'same_screen'|S32'focus'|U32'state'|U32'$pad2']
// file /usr/include/X11/Xlib.h line 610
struct anonymous$42;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'window'|U64'root'|U64'subwindow'|U64'time'|S32'x'|S32'y'|S32'x_root'|S32'y_root'|U32'state'|S8'is_hint'|U24'$pad2'|S32'same_screen'|U32'$pad3']
// file /usr/include/X11/Xlib.h line 593
struct anonymous$41;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'window'|U64'root'|U64'subwindow'|U64'time'|S32'x'|S32'y'|S32'x_root'|S32'y_root'|U32'state'|U32'button'|S32'same_screen'|U32'$pad2']
// file /usr/include/X11/Xlib.h line 575
struct anonymous$40;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'window'|U64'root'|U64'subwindow'|U64'time'|S32'x'|S32'y'|S32'x_root'|S32'y_root'|U32'state'|U32'keycode'|S32'same_screen'|U32'$pad2']
// file /usr/include/X11/Xlib.h line 557
struct anonymous$39;

// tag-#anon#ST[S32'type'|U32'$pad0'|U64'serial'|S32'send_event'|U32'$pad1'|*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'|U64'window'|U64'selection'|U64'time']
// file /usr/include/X11/Xlib.h line 847
struct anonymous$68;

// tag-#anon#ST[S32'y0'|S32'y1'|S32'roll']
// file /usr/include/libzvbi.h line 819
struct anonymous$101;

// tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous$35;

// tag-#anon#ST[S64'time'|S32'seconds_east'|S32'seconds_east_valid'|SYM##anon_enum$VBI_DST_UNKNOWN=0$VBI_DST_INCLUDED=1$VBI_DST_INACTIVE=2$VBI_DST_ACTIVE=3#'dst_state'|U32'$pad0']
// file /usr/include/libzvbi.h line 688
struct anonymous$46;

// tag-#anon#ST[S64'ts']
// file ./libng/grab-ng.h line 183
struct anonymous$84;

// tag-#anon#ST[S64'ts'|S32'seq'|S32'twice']
// file ./libng/grab-ng.h line 142
struct anonymous$78;

// tag-#anon#ST[SYM##anon_enum$VBI_AUDIO_MODE_NONE=0$VBI_AUDIO_MODE_MONO=1$VBI_AUDIO_MODE_STEREO=2$VBI_AUDIO_MODE_STEREO_SURROUND=3$VBI_AUDIO_MODE_SIMULATED_STEREO=4$VBI_AUDIO_MODE_VIDEO_DESCRIPTIONS=5$VBI_AUDIO_MODE_NON_PROGRAM_AUDIO=6$VBI_AUDIO_MODE_SPECIAL_EFFECTS=7$VBI_AUDIO_MODE_DATA_SERVICE=8$VBI_AUDIO_MODE_UNKNOWN=9#'mode'|U32'$pad0'|*{U8}$U8$'language']
// file /usr/include/libzvbi.h line 616
struct anonymous$30;

// tag-#anon#ST[SYM##anon_enum$VBI_PID_CHANNEL_LCI_0=0$VBI_PID_CHANNEL_LCI_1=1$VBI_PID_CHANNEL_LCI_2=2$VBI_PID_CHANNEL_LCI_3=3$VBI_PID_CHANNEL_VPS=4$VBI_PID_CHANNEL_PDC_DESCRIPTOR=5$VBI_PID_CHANNEL_XDS_CURRENT=6$VBI_PID_CHANNEL_XDS_FUTURE=7$VBI_MAX_PID_CHANNELS=8#'channel'|SYM##anon_enum$VBI_CNI_TYPE_NONE=0$VBI_CNI_TYPE_UNKNOWN=0$VBI_CNI_TYPE_VPS=1$VBI_CNI_TYPE_8301=2$VBI_CNI_TYPE_8302=3$VBI_CNI_TYPE_PDC_A=4$VBI_CNI_TYPE_PDC_B=5#'cni_type'|U32'cni'|U32'pil'|S32'luf'|S32'mi'|S32'prf'|SYM##anon_enum$VBI_PCS_AUDIO_UNKNOWN=0$VBI_PCS_AUDIO_MONO=1$VBI_PCS_AUDIO_STEREO=2$VBI_PCS_AUDIO_BILINGUAL=3#'pcs_audio'|U32'pty'|S32'tape_delayed'|ARR2{*{V}$V$}$*{V}$V$$'_reserved2'|ARR4{S32}$S32$'_reserved3']
// file /usr/include/libzvbi.h line 384
struct anonymous$47;

// tag-#anon#ST[U16'red'|U16'green'|U16'blue'|U16'alpha']
// file /usr/include/X11/extensions/Xrender.h line 83
struct anonymous$97;

// tag-#anon#ST[U32'id'|U32'line'|ARR56{U8}$U8$'data']
// file /usr/include/libzvbi.h line 1048
struct anonymous$15;

// tag-#anon#ST[U32'nuid'|ARR64{S8}$S8$'name'|ARR40{S8}$S8$'call'|S32'tape_delay'|S32'cni_vps'|S32'cni_8301'|S32'cni_8302'|S32'reserved'|S32'cycle']
// file /usr/include/libzvbi.h line 420
struct anonymous$45;

// tag-#anon#ST[U64'name'|U64'card32']
// file /usr/include/X11/Xlib.h line 1030
struct anonymous$98;

// tag-#anon#ST[U64'pixel'|U16'red'|U16'green'|U16'blue'|S8'flags'|S8'pad']
// file /usr/include/X11/Xlib.h line 410
struct anonymous$91;

// tag-#anon#ST[U64'valuemask'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'|U64'visualid'|S32'class'|U32'$pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'|U64'visualid'|S32'class'|U32'$pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#$'visual'|U64'colormap'|U32'depth'|U32'width'|U32'height'|U32'x_hotspot'|U32'y_hotspot'|U32'cpp'|*{U64}$U64$'pixels'|U32'npixels'|U32'$pad0'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|*{S8}$S8$'value'|U64'pixel']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|*{S8}$S8$'value'|U64'pixel']#$'colorsymbols'|U32'numsymbols'|U32'$pad1'|*{S8}$S8$'rgb_fname'|U32'nextensions'|U32'$pad2'|*{SYM#tag-#anon#ST[*{S8}$S8$'name'|U32'nlines'|U32'$pad0'|*{*{S8}$S8$}$*{S8}$S8$$'lines']#}$SYM#tag-#anon#ST[*{S8}$S8$'name'|U32'nlines'|U32'$pad0'|*{*{S8}$S8$}$*{S8}$S8$$'lines']#$'extensions'|U32'ncolors'|U32'$pad3'|*{SYM#tag-#anon#ST[*{S8}$S8$'string'|*{S8}$S8$'symbolic'|*{S8}$S8$'m_color'|*{S8}$S8$'g4_color'|*{S8}$S8$'g_color'|*{S8}$S8$'c_color']#}$SYM#tag-#anon#ST[*{S8}$S8$'string'|*{S8}$S8$'symbolic'|*{S8}$S8$'m_color'|*{S8}$S8$'g4_color'|*{S8}$S8$'g_color'|*{S8}$S8$'c_color']#$'colorTable'|*{S8}$S8$'hints_cmt'|*{S8}$S8$'colors_cmt'|*{S8}$S8$'pixels_cmt'|U32'mask_pixel'|S32'exactColors'|U32'closeness'|U32'red_closeness'|U32'green_closeness'|U32'blue_closeness'|S32'color_key'|U32'$pad4'|*{U64}$U64$'alloc_pixels'|S32'nalloc_pixels'|S32'alloc_close_colors'|S32'bitmap_format'|U32'$pad5'|*{S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$|U64|*{S8}$S8$|*{SYM#tag-#anon#ST[U64'pixel'|U16'red'|U16'green'|U16'blue'|S8'flags'|S8'pad']#}$SYM#tag-#anon#ST[U64'pixel'|U16'red'|U16'green'|U16'blue'|S8'flags'|S8'pad']#$|*{V}$V$)->S32}$S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$|U64|*{S8}$S8$|*{SYM#tag-#anon#ST[U64'pixel'|U16'red'|U16'green'|U16'blue'|S8'flags'|S8'pad']#}$SYM#tag-#anon#ST[U64'pixel'|U16'red'|U16'green'|U16'blue'|S8'flags'|S8'pad']#$|*{V}$V$)->S32$'alloc_color'|*{S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$|U64|*{U64}$U64$|S32|*{V}$V$)->S32}$S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$|U64|*{U64}$U64$|S32|*{V}$V$)->S32$'free_colors'|*{V}$V$'color_closure']
// file /usr/include/X11/xpm.h line 157
struct anonymous$92;

// tag-#anon#ST[U8'byte1'|U8'byte2']
// file /usr/include/X11/Xlib.h line 1064
struct anonymous$105;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'|*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'$pad0'|SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#}$SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'$pad0'|SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'$pad0'|SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#}$SYM#tag-#anon#ST[S32'si_signo'|S32'si_errno'|S32'si_code'|U32'$pad0'|SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']#'_sifields']#$|*{V}$V$)->V$'sa_sigaction']
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous$22;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'|ARR8{U16}$U16$'__u6_addr16'|ARR4{U32}$U32$'__u6_addr32']
// file /usr/include/netinet/in.h line 211
union anonymous$93;

// tag-#anon#UN[ARR20{S8}$S8$'b'|ARR10{S16}$S16$'s'|ARR5{S64}$S64$'l']
// file /usr/include/X11/Xlib.h line 905
union anonymous$77;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid']#'_kill'|SYM#tag-#anon#ST[S32'si_tid'|S32'si_overrun'|SYM#tag-sigval#'si_sigval']#'_timer'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|SYM#tag-sigval#'si_sigval']#'_rt'|SYM#tag-#anon#ST[S32'si_pid'|U32'si_uid'|S32'si_status'|U32'$pad0'|S64'si_utime'|S64'si_stime']#'_sigchld'|SYM#tag-#anon#ST[*{V}$V$'si_addr'|S16'si_addr_lsb'|U48'$pad0']#'_sigfault'|SYM#tag-#anon#ST[S64'si_band'|S32'si_fd'|U32'$pad0']#'_sigpoll'|SYM#tag-#anon#ST[*{V}$V$'_call_addr'|S32'_syscall'|U32'_arch']#'_sigsys']
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$38;

// tag-#anon#UN[ARR4{S8}$S8$'__size'|S32'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$86;

// tag-#anon#UN[ARR8{S32}$S32$'i'|ARR80{S8}$S8$'s']
// file /usr/include/jpeglib.h line 736
union anonymous$11;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}$V$'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']#'__data'|ARR48{S8}$S8$'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$80;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'pgno'|S32'subno'|*{U8}$U8$'raw_header'|S32'pn_offset'|BF{U32}$U32$'roll_header'|BF{U32}$U32$'header_update'|BF{U32}$U32$'clock_update'|BF{U5}$U5$'$bit_field_pad0'|U24'$pad0']#'ttx_page'|SYM#tag-#anon#ST[S32'pgno']#'caption'|SYM#tag-#anon#ST[U32'nuid'|ARR64{S8}$S8$'name'|ARR40{S8}$S8$'call'|S32'tape_delay'|S32'cni_vps'|S32'cni_8301'|S32'cni_8302'|S32'reserved'|S32'cycle']#'network'|*{SYM#tag-vbi_link#}$SYM#tag-vbi_link#$'trigger'|SYM#tag-#anon#ST[S32'first_line'|S32'last_line'|F64'ratio'|S32'film_mode'|SYM##anon_enum$VBI_SUBT_NONE=0$VBI_SUBT_ACTIVE=1$VBI_SUBT_MATTE=2$VBI_SUBT_UNKNOWN=3#'open_subtitles']#'aspect'|*{SYM#tag-vbi_program_info#}$SYM#tag-vbi_program_info#$'prog_info'|*{SYM#tag-#anon#ST[S64'time'|S32'seconds_east'|S32'seconds_east_valid'|SYM##anon_enum$VBI_DST_UNKNOWN=0$VBI_DST_INCLUDED=1$VBI_DST_INACTIVE=2$VBI_DST_ACTIVE=3#'dst_state'|U32'$pad0']#}$SYM#tag-#anon#ST[S64'time'|S32'seconds_east'|S32'seconds_east_valid'|SYM##anon_enum$VBI_DST_UNKNOWN=0$VBI_DST_INCLUDED=1$VBI_DST_INACTIVE=2$VBI_DST_ACTIVE=3#'dst_state'|U32'$pad0']#$'local_time'|*{SYM#tag-#anon#ST[SYM##anon_enum$VBI_PID_CHANNEL_LCI_0=0$VBI_PID_CHANNEL_LCI_1=1$VBI_PID_CHANNEL_LCI_2=2$VBI_PID_CHANNEL_LCI_3=3$VBI_PID_CHANNEL_VPS=4$VBI_PID_CHANNEL_PDC_DESCRIPTOR=5$VBI_PID_CHANNEL_XDS_CURRENT=6$VBI_PID_CHANNEL_XDS_FUTURE=7$VBI_MAX_PID_CHANNELS=8#'channel'|SYM##anon_enum$VBI_CNI_TYPE_NONE=0$VBI_CNI_TYPE_UNKNOWN=0$VBI_CNI_TYPE_VPS=1$VBI_CNI_TYPE_8301=2$VBI_CNI_TYPE_8302=3$VBI_CNI_TYPE_PDC_A=4$VBI_CNI_TYPE_PDC_B=5#'cni_type'|U32'cni'|U32'pil'|S32'luf'|S32'mi'|S32'prf'|SYM##anon_enum$VBI_PCS_AUDIO_UNKNOWN=0$VBI_PCS_AUDIO_MONO=1$VBI_PCS_AUDIO_STEREO=2$VBI_PCS_AUDIO_BILINGUAL=3#'pcs_audio'|U32'pty'|S32'tape_delayed'|ARR2{*{V}$V$}$*{V}$V$$'_reserved2'|ARR4{S32}$S32$'_reserved3']#}$SYM#tag-#anon#ST[SYM##anon_enum$VBI_PID_CHANNEL_LCI_0=0$VBI_PID_CHANNEL_LCI_1=1$VBI_PID_CHANNEL_LCI_2=2$VBI_PID_CHANNEL_LCI_3=3$VBI_PID_CHANNEL_VPS=4$VBI_PID_CHANNEL_PDC_DESCRIPTOR=5$VBI_PID_CHANNEL_XDS_CURRENT=6$VBI_PID_CHANNEL_XDS_FUTURE=7$VBI_MAX_PID_CHANNELS=8#'channel'|SYM##anon_enum$VBI_CNI_TYPE_NONE=0$VBI_CNI_TYPE_UNKNOWN=0$VBI_CNI_TYPE_VPS=1$VBI_CNI_TYPE_8301=2$VBI_CNI_TYPE_8302=3$VBI_CNI_TYPE_PDC_A=4$VBI_CNI_TYPE_PDC_B=5#'cni_type'|U32'cni'|U32'pil'|S32'luf'|S32'mi'|S32'prf'|SYM##anon_enum$VBI_PCS_AUDIO_UNKNOWN=0$VBI_PCS_AUDIO_MONO=1$VBI_PCS_AUDIO_STEREO=2$VBI_PCS_AUDIO_BILINGUAL=3#'pcs_audio'|U32'pty'|S32'tape_delayed'|ARR2{*{V}$V$}$*{V}$V$$'_reserved2'|ARR4{S32}$S32$'_reserved3']#$'prog_id'|*{SYM#tag-_vbi_event_cc608_page#}$SYM#tag-_vbi_event_cc608_page#$'_cc608'|*{SYM#tag-_vbi_event_cc608_stream#}$SYM#tag-_vbi_event_cc608_stream#$'_cc608_stream'|U1088'$pad']
// file /usr/include/libzvbi.h line 714
union anonymous$19;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}$S8$'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$14;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'|r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__']
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$106;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'|r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__']$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$36;

// tag-ARGS
// file x11/mtt.c line 61
struct ARGS;

// tag-CFG_ENTRIES
// file common/parseconfig.c line 11
struct CFG_ENTRIES;

// tag-CFG_SECTIONS
// file common/parseconfig.c line 18
struct CFG_SECTIONS;

// tag-CHANLIST
// file common/frequencies.h line 82
struct CHANLIST;

// tag-CHANLISTS
// file common/frequencies.h line 87
struct CHANLISTS;

// tag-CHANNEL
// file ./common/channel.h line 11
struct CHANNEL;

// tag-CHUNKHDR
// file libng/writefile.c line 201
struct CHUNKHDR;

// tag-COMMANDS
// file common/commands.c line 109
struct COMMANDS;

// tag-DEVS
// file console/fbtools.c line 56
struct DEVS;

// tag-FIFO
// file common/capture.h line 6
struct FIFO;

// tag-LAUNCH
// file common/channel.h line 82
struct LAUNCH;

// tag-OVERLAY_CLIP
// file ./libng/grab-ng.h line 122
struct OVERLAY_CLIP;

// tag-STRTAB
// file ./libng/grab-ng.h line 117
struct STRTAB;

// tag-WAVEHDR
// file libng/writefile.c line 207
struct WAVEHDR;

// tag-WEBCAM
// file common/webcam.c line 22
struct WEBCAM;

// tag-_FcCharSet
// file /usr/include/fontconfig/fontconfig.h line 212
struct _FcCharSet;

// tag-_FcConfig
// file /usr/include/fontconfig/fontconfig.h line 288
struct _FcConfig;

// tag-_FcFontSet
// file /usr/include/fontconfig/fontconfig.h line 248
struct _FcFontSet;

// tag-_FcObjectSet
// file /usr/include/fontconfig/fontconfig.h line 254
struct _FcObjectSet;

// tag-_FcPattern
// file /usr/include/fontconfig/fontconfig.h line 230
struct _FcPattern;

// tag-_FcResult
// file /usr/include/fontconfig/fontconfig.h line 225
enum _FcResult { FcResultMatch=0, FcResultNoMatch=1, FcResultTypeMismatch=2, FcResultNoId=3, FcResultOutOfMemory=4 };

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_WidgetClassRec
// file /usr/include/X11/Intrinsic.h line 109
struct _WidgetClassRec;

// tag-_WidgetRec
// file /usr/include/X11/Intrinsic.h line 107
struct _WidgetRec;

// tag-_XDisplay
// file /usr/include/X11/Xlib.h line 255
struct _XDisplay;

// tag-_XEvent
// file /usr/include/X11/Xlib.h line 973
union _XEvent;

// tag-_XExtData
// file /usr/include/X11/Xlib.h line 148
struct _XExtData;

// tag-_XGC
// file /usr/include/X11/Xlib.h line 214
struct _XGC;

// tag-_XImage
// file /usr/include/X11/Xlib.h line 360
struct _XImage;

// tag-_XftColor
// file /usr/include/X11/Xft/Xft.h line 75
struct _XftColor;

// tag-_XftDraw
// file /usr/include/X11/Xft/Xft.h line 73
struct _XftDraw;

// tag-_XftFont
// file /usr/include/X11/Xft/Xft.h line 64
struct _XftFont;

// tag-_XtActionsRec
// file /usr/include/X11/Intrinsic.h line 111
struct _XtActionsRec;

// tag-_XtAppStruct
// file /usr/include/X11/Intrinsic.h line 114
struct _XtAppStruct;

// tag-_XtResource
// file /usr/include/X11/Intrinsic.h line 354
struct _XtResource;

// tag-__XmParseMappingRec
// file /usr/include/Xm/Xm.h line 251
struct __XmParseMappingRec;

// tag-__XmStringRec
// file /usr/include/Xm/Xm.h line 181
union __XmStringRec;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__jmp_buf_tag
// file /usr/include/setjmp.h line 34
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_vbi_event_cc608_page
// file /usr/include/libzvbi.h line 703
struct _vbi_event_cc608_page;

// tag-_vbi_event_cc608_stream
// file /usr/include/libzvbi.h line 704
struct _vbi_event_cc608_stream;

// tag-_vbi_raw_decoder_job
// file /usr/include/libzvbi.h line 1160
struct _vbi_raw_decoder_job;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-bus_type
// file common/get_media_devices.h line 63
enum bus_type { MEDIA_BUS_UNKNOWN=0, MEDIA_BUS_VIRTUAL=1, MEDIA_BUS_PCI=2, MEDIA_BUS_USB=3 };

// tag-device_type
// file ./common/get_media_devices.h line 32
enum device_type { UNKNOWN=65535, NONE=65534, MEDIA_V4L_VIDEO=0, MEDIA_V4L_VBI=1, MEDIA_V4L_RADIO=2, MEDIA_V4L_SUBDEV=3, MEDIA_DVB_VIDEO=100, MEDIA_DVB_AUDIO=101, MEDIA_DVB_SEC=102, MEDIA_DVB_FRONTEND=103, MEDIA_DVB_DEMUX=104, MEDIA_DVB_DVR=105, MEDIA_DVB_CA=106, MEDIA_DVB_NET=107, MEDIA_DVB_OSD=108, MEDIA_SND_CARD=200, MEDIA_SND_CAP=201, MEDIA_SND_OUT=202, MEDIA_SND_CONTROL=203, MEDIA_SND_HW=204, MEDIA_SND_TIMER=205, MEDIA_SND_SEQ=206 };

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-event_entry
// file common/event.h line 3
struct event_entry;

// tag-fb_bitfield
// file /usr/include/linux/fb.h line 185
struct fb_bitfield;

// tag-fb_cmap
// file /usr/include/linux/fb.h line 278
struct fb_cmap;

// tag-fb_con2fbmap
// file /usr/include/linux/fb.h line 287
struct fb_con2fbmap;

// tag-fb_fix_screeninfo
// file /usr/include/linux/fb.h line 154
struct fb_fix_screeninfo;

// tag-fb_var_screeninfo
// file /usr/include/linux/fb.h line 238
struct fb_var_screeninfo;

// tag-files_handle
// file libng/writefile.c line 280
struct files_handle;

// tag-funcs
// file /usr/include/X11/Xlib.h line 376
struct funcs;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-jpeg_c_coef_controller
// file /usr/include/jpeglib.h line 457
struct jpeg_c_coef_controller;

// tag-jpeg_c_main_controller
// file /usr/include/jpeglib.h line 455
struct jpeg_c_main_controller;

// tag-jpeg_c_prep_controller
// file /usr/include/jpeglib.h line 456
struct jpeg_c_prep_controller;

// tag-jpeg_color_converter
// file /usr/include/jpeglib.h line 459
struct jpeg_color_converter;

// tag-jpeg_common_struct
// file /usr/include/jpeglib.h line 280
struct jpeg_common_struct;

// tag-jpeg_comp_master
// file /usr/include/jpeglib.h line 454
struct jpeg_comp_master;

// tag-jpeg_compress_struct
// file /usr/include/jpeglib.h line 289
struct jpeg_compress_struct;

// tag-jpeg_destination_mgr
// file /usr/include/jpeglib.h line 299
struct jpeg_destination_mgr;

// tag-jpeg_downsampler
// file /usr/include/jpeglib.h line 460
struct jpeg_downsampler;

// tag-jpeg_entropy_encoder
// file /usr/include/jpeglib.h line 462
struct jpeg_entropy_encoder;

// tag-jpeg_error_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_error_mgr;

// tag-jpeg_forward_dct
// file /usr/include/jpeglib.h line 461
struct jpeg_forward_dct;

// tag-jpeg_marker_writer
// file /usr/include/jpeglib.h line 458
struct jpeg_marker_writer;

// tag-jpeg_memory_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_memory_mgr;

// tag-jpeg_progress_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_progress_mgr;

// tag-jvirt_barray_control
// file /usr/include/jpeglib.h line 828
struct jvirt_barray_control;

// tag-jvirt_sarray_control
// file /usr/include/jpeglib.h line 827
struct jvirt_sarray_control;

// tag-list_head
// file ./libng/list.h line 15
struct list_head;

// tag-media_device_entry
// file common/get_media_devices.c line 43
struct media_device_entry;

// tag-media_devices
// file common/get_media_devices.c line 60
struct media_devices;

// tag-movie_handle
// file common/capture.h line 27
struct movie_handle;

// tag-ng_attribute
// file ./libng/grab-ng.h line 243
struct ng_attribute;

// tag-ng_audio_buf
// file ./libng/grab-ng.h line 177
struct ng_audio_buf;

// tag-ng_audio_conv
// file libng/grab-ng.h line 387
struct ng_audio_conv;

// tag-ng_audio_fmt
// file ./libng/grab-ng.h line 172
struct ng_audio_fmt;

// tag-ng_convert_handle
// file ./libng/grab-ng.h line 364
struct ng_convert_handle;

// tag-ng_convthread_handle
// file common/capture.c line 122
struct ng_convthread_handle;

// tag-ng_device_config
// file ./libng/devices.h line 2
struct ng_device_config;

// tag-ng_devinfo
// file libng/grab-ng.h line 275
struct ng_devinfo;

// tag-ng_dsp_driver
// file ./libng/grab-ng.h line 321
struct ng_dsp_driver;

// tag-ng_filter
// file ./libng/grab-ng.h line 402
struct ng_filter;

// tag-ng_format_list
// file ./libng/grab-ng.h line 194
struct ng_format_list;

// tag-ng_mix_driver
// file libng/grab-ng.h line 335
struct ng_mix_driver;

// tag-ng_reader
// file libng/grab-ng.h line 220
struct ng_reader;

// tag-ng_vid_driver
// file ./libng/grab-ng.h line 284
struct ng_vid_driver;

// tag-ng_video_buf
// file ./libng/grab-ng.h line 136
struct ng_video_buf;

// tag-ng_video_conv
// file ./libng/grab-ng.h line 350
struct ng_video_conv;

// tag-ng_video_fmt
// file ./libng/grab-ng.h line 129
struct ng_video_fmt;

// tag-ng_writer
// file ./libng/grab-ng.h line 203
struct ng_writer;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-raw_handle
// file libng/writefile.c line 392
struct raw_handle;

// tag-raw_priv
// file libng/writefile.c line 388
struct raw_priv;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-termios
// file /usr/include/x86_64-linux-gnu/bits/termios.h line 28
struct termios;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-vbi_bit_slicer
// file /usr/include/libzvbi.h line 1108
struct vbi_bit_slicer;

// tag-vbi_capture
// file /usr/include/libzvbi.h line 1574
struct vbi_capture;

// tag-vbi_char
// file /usr/include/libzvbi.h line 788
struct vbi_char;

// tag-vbi_decoder
// file /usr/include/libzvbi.h line 39
struct vbi_decoder;

// tag-vbi_event
// file /usr/include/libzvbi.h line 712
struct vbi_event;

// tag-vbi_font
// file x11/vbi-x11.h line 13
struct vbi_font;

// tag-vbi_font_descr
// file /usr/include/libzvbi.h line 805
struct vbi_font_descr;

// tag-vbi_link
// file /usr/include/libzvbi.h line 468
struct vbi_link;

// tag-vbi_page
// file /usr/include/libzvbi.h line 807
struct vbi_page;

// tag-vbi_program_info
// file /usr/include/libzvbi.h line 548
struct vbi_program_info;

// tag-vbi_raw_decoder
// file /usr/include/libzvbi.h line 1139
struct vbi_raw_decoder;

// tag-vbi_rect
// file ./common/vbi-data.h line 21
struct vbi_rect;

// tag-vbi_selection
// file x11/vbi-gui.c line 53
struct vbi_selection;

// tag-vbi_state
// file ./common/vbi-data.h line 9
struct vbi_state;

// tag-vbi_tty
// file console/vbi-tty.c line 80
struct vbi_tty;

// tag-vbi_txt_colors
// file ./common/vbi-data.h line 25
enum vbi_txt_colors { VBI_NOCOLOR=0, VBI_ANSICOLOR=1 };

// tag-vbi_window
// file x11/vbi-x11.h line 19
struct vbi_window;

// tag-vt_mode
// file /usr/include/linux/vt.h line 19
struct vt_mode;

// tag-vt_stat
// file /usr/include/linux/vt.h line 32
struct vt_stat;

// tag-winsize
// file /usr/include/x86_64-linux-gnu/bits/ioctl-types.h line 27
struct winsize;

#include <assert.h>
#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// FcFontList
// file /usr/include/fontconfig/fontconfig.h line 664
struct _FcFontSet * FcFontList(struct _FcConfig *, struct _FcPattern *, struct _FcObjectSet *);
// FcNameParse
// file /usr/include/fontconfig/fontconfig.h line 778
struct _FcPattern * FcNameParse(const unsigned char *);
// FcNameUnparse
// file /usr/include/fontconfig/fontconfig.h line 781
unsigned char * FcNameUnparse(struct _FcPattern *);
// FcObjectSetBuild
// file /usr/include/fontconfig/fontconfig.h line 654
struct _FcObjectSet * FcObjectSetBuild(const char *, ...);
// FcPatternDestroy
// file /usr/include/fontconfig/fontconfig.h line 806
void FcPatternDestroy(struct _FcPattern *);
// XAllocNamedColor
// file /usr/include/X11/Xlib.h line 1988
extern signed int XAllocNamedColor(struct _XDisplay *, unsigned long int, const char *, struct anonymous$91 *, struct anonymous$91 *);
// XChangeGC
// file /usr/include/X11/Xlib.h line 2038
extern signed int XChangeGC(struct _XDisplay *, struct _XGC *, unsigned long int, struct anonymous$107 *);
// XClearWindow
// file /usr/include/X11/Xlib.h line 2155
extern signed int XClearWindow(struct _XDisplay *, unsigned long int);
// XCreateGC
// file /usr/include/X11/Xlib.h line 1584
extern struct _XGC * XCreateGC(struct _XDisplay *, unsigned long int, unsigned long int, struct anonymous$107 *);
// XCreatePixmap
// file /usr/include/X11/Xlib.h line 1597
extern unsigned long int XCreatePixmap(struct _XDisplay *, unsigned long int, unsigned int, unsigned int, unsigned int);
// XDrawString16
// file /usr/include/X11/Xlib.h line 2414
extern signed int XDrawString16(struct _XDisplay *, unsigned long int, struct _XGC *, signed int, signed int, const struct anonymous$105 *, signed int);
// XFillRectangle
// file /usr/include/X11/Xlib.h line 2489
extern signed int XFillRectangle(struct _XDisplay *, unsigned long int, struct _XGC *, signed int, signed int, unsigned int, unsigned int);
// XFree
// file /usr/include/X11/Xlib.h line 2516
extern signed int XFree(void *);
// XFreeFont
// file /usr/include/X11/Xlib.h line 2542
extern signed int XFreeFont(struct _XDisplay *, struct anonymous$100 *);
// XFreeGC
// file /usr/include/X11/Xlib.h line 2561
extern signed int XFreeGC(struct _XDisplay *, struct _XGC *);
// XFreePixmap
// file /usr/include/X11/Xlib.h line 2570
extern signed int XFreePixmap(struct _XDisplay *, unsigned long int);
// XGetAtomName
// file /usr/include/X11/Xlib.h line 1500
extern char * XGetAtomName(struct _XDisplay *, unsigned long int);
// XInternAtom
// file /usr/include/X11/Xlib.h line 1536
extern unsigned long int XInternAtom(struct _XDisplay *, const char *, signed int);
// XKeycodeToKeysym
// file /usr/include/X11/Xlib.h line 1687
extern unsigned long int XKeycodeToKeysym(struct _XDisplay *, unsigned char, signed int);
// XLoadQueryFont
// file /usr/include/X11/Xlib.h line 1394
extern struct anonymous$100 * XLoadQueryFont(struct _XDisplay *, const char *);
// XScreenNumberOfScreen
// file /usr/include/X11/Xlib.h line 1839
extern signed int XScreenNumberOfScreen(struct anonymous$96 *);
// XftColorAllocName
// file /usr/include/X11/Xft/Xft.h line 111
signed int XftColorAllocName(struct _XDisplay *, const struct anonymous$90 *, unsigned long int, const char *, struct _XftColor *);
// XftDrawCreate
// file /usr/include/X11/Xft/Xft.h line 143
struct _XftDraw * XftDrawCreate(struct _XDisplay *, unsigned long int, struct anonymous$90 *, unsigned long int);
// XftDrawDestroy
// file /usr/include/X11/Xft/Xft.h line 174
void XftDrawDestroy(struct _XftDraw *);
// XftDrawString32
// file /usr/include/X11/Xft/Xft.h line 210
void XftDrawString32(struct _XftDraw *, const struct _XftColor *, struct _XftFont *, signed int, signed int, const unsigned int *, signed int);
// XftFontClose
// file /usr/include/X11/Xft/Xft.h line 381
void XftFontClose(struct _XDisplay *, struct _XftFont *);
// XftFontMatch
// file /usr/include/X11/Xft/Xft.h line 335
struct _FcPattern * XftFontMatch(struct _XDisplay *, signed int, const struct _FcPattern *, enum _FcResult *);
// XftFontOpenPattern
// file /usr/include/X11/Xft/Xft.h line 375
struct _XftFont * XftFontOpenPattern(struct _XDisplay *, struct _FcPattern *);
// XmAddProtocolCallback
// file /usr/include/Xm/Protocols.h line 93
extern void XmAddProtocolCallback(struct _WidgetRec *, unsigned long int, unsigned long int, void (*)(struct _WidgetRec *, void *, void *), void *);
// XmCreateFileSelectionDialog
// file /usr/include/Xm/FileSB.h line 79
extern struct _WidgetRec * XmCreateFileSelectionDialog(struct _WidgetRec *, char *, struct anonymous$1 *, unsigned int);
// XmCreateMenuBar
// file /usr/include/Xm/RowColumn.h line 77
extern struct _WidgetRec * XmCreateMenuBar(struct _WidgetRec *, char *, struct anonymous$1 *, unsigned int);
// XmCreateOptionMenu
// file /usr/include/Xm/RowColumn.h line 68
extern struct _WidgetRec * XmCreateOptionMenu(struct _WidgetRec *, char *, struct anonymous$1 *, unsigned int);
// XmCreatePulldownMenu
// file /usr/include/Xm/RowColumn.h line 87
extern struct _WidgetRec * XmCreatePulldownMenu(struct _WidgetRec *, char *, struct anonymous$1 *, unsigned int);
// XmFileSelectionBoxGetChild
// file /usr/include/Xm/FileSB.h line 64
extern struct _WidgetRec * XmFileSelectionBoxGetChild(struct _WidgetRec *, unsigned char);
// XmInstallImage
// file /usr/include/Xm/Xm.h line 1395
extern char XmInstallImage(struct _XImage *, char *);
// XmStringFree
// file /usr/include/Xm/Xm.h line 1816
extern void XmStringFree(union __XmStringRec *);
// XmStringGenerate
// file /usr/include/Xm/Xm.h line 1947
extern union __XmStringRec * XmStringGenerate(void *, char *, enum anonymous$3, char *);
// XmStringUnparse
// file /usr/include/Xm/Xm.h line 1908
extern void * XmStringUnparse(union __XmStringRec *, char *, enum anonymous$3, enum anonymous$3, struct __XmParseMappingRec **, unsigned int, enum anonymous$4);
// XmeClipboardSource
// file /usr/include/Xm/TransferP.h line 42
extern char XmeClipboardSource(struct _WidgetRec *, unsigned char, unsigned long int);
// XmeDragSource
// file /usr/include/Xm/TransferP.h line 43
extern struct _WidgetRec * XmeDragSource(struct _WidgetRec *, void *, union _XEvent *, struct anonymous$1 *, unsigned int);
// XmePrimarySource
// file /usr/include/Xm/TransferP.h line 38
extern char XmePrimarySource(struct _WidgetRec *, unsigned long int);
// XpmCreateImageFromData
// file /usr/include/X11/xpm.h line 319
extern signed int XpmCreateImageFromData(struct _XDisplay *, char **, struct _XImage **, struct _XImage **, struct anonymous$92 *);
// XtAddCallback
// file /usr/include/X11/Intrinsic.h line 1235
extern void XtAddCallback(struct _WidgetRec *, const char *, void (*)(struct _WidgetRec *, void *, void *), void *);
// XtAddEventHandler
// file /usr/include/X11/Intrinsic.h line 827
extern void XtAddEventHandler(struct _WidgetRec *, unsigned long int, char, void (*)(struct _WidgetRec *, void *, union _XEvent *, char *), void *);
// XtAppAddActions
// file /usr/include/X11/Intrinsic.h line 718
extern void XtAppAddActions(struct _XtAppStruct *, struct _XtActionsRec *, unsigned int);
// XtAppAddInput
// file /usr/include/X11/Intrinsic.h line 996
extern unsigned long int XtAppAddInput(struct _XtAppStruct *, signed int, void *, void (*)(void *, signed int *, unsigned long int *), void *);
// XtAppMainLoop
// file /usr/include/X11/Intrinsic.h line 940
extern void XtAppMainLoop(struct _XtAppStruct *);
// XtAppSetFallbackResources
// file /usr/include/X11/Intrinsic.h line 1515
extern void XtAppSetFallbackResources(struct _XtAppStruct *, char **);
// XtCreateApplicationContext
// file /usr/include/X11/Intrinsic.h line 1511
extern struct _XtAppStruct * XtCreateApplicationContext(void);
// XtDestroyWidget
// file /usr/include/X11/Intrinsic.h line 1112
extern void XtDestroyWidget(struct _WidgetRec *);
// XtDisplay
// file /usr/include/X11/Intrinsic.h line 1184
extern struct _XDisplay * XtDisplay(struct _WidgetRec *);
// XtGetApplicationResources
// file /usr/include/X11/Intrinsic.h line 1548
extern void XtGetApplicationResources(struct _WidgetRec *, void *, struct _XtResource *, unsigned int, struct anonymous$1 *, unsigned int);
// XtLastTimestampProcessed
// file /usr/include/X11/Intrinsic.h line 962
extern unsigned long int XtLastTimestampProcessed(struct _XDisplay *);
// XtMalloc
// file /usr/include/X11/Intrinsic.h line 1830
extern char * XtMalloc(unsigned int);
// XtManageChild
// file /usr/include/X11/Composite.h line 64
extern void XtManageChild(struct _WidgetRec *);
// XtName
// file /usr/include/X11/Intrinsic.h line 1208
extern char * XtName(struct _WidgetRec *);
// XtOpenDisplay
// file /usr/include/X11/Intrinsic.h line 1500
extern struct _XDisplay * XtOpenDisplay(struct _XtAppStruct *, const char *, const char *, const char *, struct anonymous$21 *, unsigned int, signed int *, char **);
// XtRealizeWidget
// file /usr/include/X11/Intrinsic.h line 1104
extern void XtRealizeWidget(struct _WidgetRec *);
// XtScreen
// file /usr/include/X11/Intrinsic.h line 1192
extern struct anonymous$96 * XtScreen(struct _WidgetRec *);
// XtSetLanguageProc
// file /usr/include/X11/Intrinsic.h line 1426
extern char * (*XtSetLanguageProc(struct _XtAppStruct *, char * (*)(struct _XDisplay *, char *, void *), void *))(struct _XDisplay *, char *, void *);
// XtToolkitInitialize
// file /usr/include/X11/Intrinsic.h line 1422
extern void XtToolkitInitialize(void);
// XtUnmanageChild
// file /usr/include/X11/Composite.h line 73
extern void XtUnmanageChild(struct _WidgetRec *);
// XtVaAppCreateShell
// file /usr/include/X11/Intrinsic.h line 1408
extern struct _WidgetRec * XtVaAppCreateShell(const char *, const char *, struct _WidgetClassRec *, struct _XDisplay *, ...);
// XtVaCreateManagedWidget
// file /usr/include/X11/Intrinsic.h line 1385
extern struct _WidgetRec * XtVaCreateManagedWidget(const char *, struct _WidgetClassRec *, struct _WidgetRec *, ...);
// XtVaGetValues
// file /usr/include/X11/Intrinsic.h line 1603
extern void XtVaGetValues(struct _WidgetRec *, ...);
// XtVaSetValues
// file /usr/include/X11/Intrinsic.h line 1592
extern void XtVaSetValues(struct _WidgetRec *, ...);
// XtWindow
// file /usr/include/X11/Intrinsic.h line 1200
extern unsigned long int XtWindow(struct _WidgetRec *);
// _XEditResCheckMessages
// file /usr/include/X11/Xmu/Editres.h line 31
void _XEditResCheckMessages(struct _WidgetRec *, void *, union _XEvent *, char *);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __list_add
// file ./libng/list.h line 34
static inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next);
// __list_add$link1
// file libng/list.h line 34
static inline void __list_add$link1(struct list_head *new$link1, struct list_head *prev$link1, struct list_head *next$link1);
// __list_del
// file ./libng/list.h line 77
static inline void __list_del(struct list_head *prev, struct list_head *next);
// __sigsetjmp
// file /usr/include/setjmp.h line 59
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// abs
// file /usr/include/stdlib.h line 774
extern signed int abs(signed int);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// add_attrs
// file common/commands.c line 168
void add_attrs(struct ng_attribute *new);
// add_channel
// file common/channel.c line 186
struct CHANNEL * add_channel(char *name);
// add_dvb_class
// file common/get_media_devices.c line 275
static signed int add_dvb_class(struct media_device_entry *md);
// add_pixmap
// file x11/icons.c line 22
static void add_pixmap(struct _XDisplay *dpy, unsigned long int bg, char *imgname, char *maskname, char **data);
// add_snd_class
// file common/get_media_devices.c line 232
static signed int add_snd_class(struct media_device_entry *md);
// add_v4l_class
// file common/get_media_devices.c line 218
static signed int add_v4l_class(struct media_device_entry *md);
// alphasort
// file /usr/include/dirent.h line 329
extern signed int alphasort(struct dirent **, struct dirent **);
// atof
// file /usr/include/stdlib.h line 144
extern double atof(const char *);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// atol
// file /usr/include/stdlib.h line 150
extern signed long int atol(const char *);
// attr_handler
// file common/commands.c line 833
static signed int attr_handler(char *name, signed int argc, char **argv);
// attr_init
// file common/commands.c line 473
void attr_init(void);
// attr_notify$object
//
void attr_notify$object(struct ng_attribute *, signed int);
// audio_init
// file common/commands.c line 502
void audio_init(void);
// audio_off
// file common/commands.c line 519
void audio_off(void);
// audio_on
// file common/commands.c line 514
void audio_on(void);
// bgr24_to_bgr32
// file libng/color_packed.c line 39
static void bgr24_to_bgr32(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// bgr24_to_lut2
// file libng/color_lut.c line 43
static void bgr24_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// bgr24_to_lut4
// file libng/color_lut.c line 109
static void bgr24_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// bgr24_to_rgb32
// file libng/color_packed.c line 54
static void bgr24_to_rgb32(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// bgr32_to_lut2
// file libng/color_lut.c line 69
static void bgr32_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// bgr32_to_lut4
// file libng/color_lut.c line 135
static void bgr32_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// byteswap_short
// file libng/color_packed.c line 102
static void byteswap_short(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// calc_frequencies
// file common/channel.c line 299
void calc_frequencies(void);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// capture_get_hook$object
//
void capture_get_hook$object(void);
// capture_handler
// file common/commands.c line 778
static signed int capture_handler(char *name, signed int argc, char **argv);
// capture_rel_hook$object
//
void capture_rel_hook$object(void);
// cc_sim
// file common/vbi-sim.c line 22
static inline double cc_sim(double t, double F, unsigned char b1, unsigned char b2);
// cf2freq
// file common/channel.c line 159
signed int cf2freq(char *name, signed int fine);
// cfg_find_section
// file common/parseconfig.c line 61
static struct CFG_ENTRIES * cfg_find_section(struct CFG_SECTIONS *c, char *name);
// cfg_get_float
// file common/parseconfig.c line 245
float cfg_get_float(char *sec, char *ent);
// cfg_get_int
// file common/parseconfig.h line 8
signed int cfg_get_int(char *sec, char *ent);
// cfg_get_signed_int
// file common/parseconfig.h line 9
signed int cfg_get_signed_int(char *sec, char *ent);
// cfg_get_str
// file common/parseconfig.h line 7
char * cfg_get_str(char *sec, char *ent);
// cfg_init_entries
// file common/parseconfig.c line 46
static struct CFG_ENTRIES * cfg_init_entries(void);
// cfg_init_sections
// file common/parseconfig.c line 33
static struct CFG_SECTIONS * cfg_init_sections(void);
// cfg_list_entries
// file common/parseconfig.h line 6
char ** cfg_list_entries(char *name);
// cfg_list_sections
// file common/parseconfig.h line 5
char ** cfg_list_sections(void);
// cfg_parse_file
// file common/parseconfig.h line 1
signed int cfg_parse_file(char *filename);
// cfg_parse_option
// file common/parseconfig.c line 153
void cfg_parse_option(char *section, char *tag, char *value);
// cfg_parse_options
// file common/parseconfig.h line 3
void cfg_parse_options(signed int *argc, char **argv);
// cfg_set_entry
// file common/parseconfig.c line 85
static void cfg_set_entry(struct CFG_ENTRIES *e, char *name, char *value);
// channel_switch_hook$object
//
void channel_switch_hook$object(void);
// chown
// file /usr/include/unistd.h line 473
extern signed int chown(const char *, unsigned int, unsigned int);
// clip_drop
// file libng/grab-ng.c line 841
static void clip_drop(struct OVERLAY_CLIP *oc, signed int n, signed int *count);
// clip_dump
// file libng/grab-ng.c line 829
static void clip_dump(char *state, struct OVERLAY_CLIP *oc, signed int count);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, union anonymous$36, unsigned int);
// dattr_handler
// file common/commands.c line 980
static signed int dattr_handler(char *name, signed int argc, char **argv);
// debug_action
// file x11/mtt.c line 119
static void debug_action(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params);
// del_channel
// file common/channel.c line 287
void del_channel(signed int i);
// dev_init
// file console/fbtools.c line 74
static void dev_init(void);
// discover_media_devices
// file ./common/get_media_devices.h line 81
void * discover_media_devices(void);
// display_media_devices
// file common/get_media_devices.c line 418
void display_media_devices(void *opaque);
// display_message$object
//
void display_message$object(char *);
// dlerror
// file /usr/include/dlfcn.h line 82
extern char * dlerror(void);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// do_command
// file common/commands.c line 240
signed int do_command(signed int argc, char **argv);
// do_va_cmd
// file ./common/commands.h line 77
signed int do_va_cmd(signed int argc, ...);
// do_write_jpeg
// file libng/writefile.c line 87
static signed int do_write_jpeg(struct _IO_FILE *fp, struct ng_video_buf *buf, signed int quality, signed int gray);
// dup
// file /usr/include/unistd.h line 531
extern signed int dup(signed int);
// event_dispatch
// file common/event.c line 112
signed int event_dispatch(char *event);
// event_readconfig
// file common/event.h line 20
void event_readconfig(void);
// event_register
// file common/event.c line 54
signed int event_register(char *event, char *action);
// event_register_list
// file common/event.c line 71
signed int event_register_list(struct event_entry *entry);
// event_writeconfig
// file common/event.h line 21
void event_writeconfig(struct _IO_FILE *fp);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// exit_handler
// file common/commands.c line 1189
static signed int exit_handler(char *name, signed int argc, char **argv);
// exit_hook$object
//
void exit_hook$object(void);
// export_charset_cb
// file x11/vbi-gui.c line 573
static void export_charset_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// export_do_save_cb
// file x11/vbi-gui.c line 539
static void export_do_save_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// export_save_cb
// file x11/vbi-gui.c line 580
static void export_save_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// fb_activate_current
// file console/fbtools.c line 304
static signed int fb_activate_current(signed int tty);
// fb_catch_exit_signal
// file console/fbtools.c line 493
static void fb_catch_exit_signal(signed int signal);
// fb_catch_exit_signals
// file console/fbtools.h line 17
void fb_catch_exit_signals(void);
// fb_cleanup
// file console/fbtools.h line 16
void fb_cleanup(void);
// fb_clear
// file console/vbi-tty.c line 73
static void fb_clear(void);
// fb_init
// file console/fbtools.h line 15
signed int fb_init(char *device, char *mode, signed int vt);
// fb_memset
// file console/fbtools.h line 18
void fb_memset(void *addr, signed int c, unsigned long int len);
// fb_setmode
// file console/fbtools.c line 173
static signed int fb_setmode(char *name);
// fb_setvt
// file console/fbtools.c line 251
static void fb_setvt(signed int vtno);
// fb_switch_acquire
// file console/fbtools.c line 118
void fb_switch_acquire(void);
// fb_switch_init
// file console/fbtools.h line 21
signed int fb_switch_init(void);
// fb_switch_release
// file console/fbtools.c line 109
void fb_switch_release(void);
// fb_switch_signal
// file console/fbtools.c line 92
static void fb_switch_signal(signed int signal);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fget_associated_device
// file common/get_media_devices.c line 501
const char * fget_associated_device(void *opaque, const char *last_seek, const enum device_type desired_type, const signed int fd_seek_device, const enum device_type seek_type);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fifo_get
// file common/capture.c line 81
void * fifo_get(struct FIFO *fifo);
// fifo_init
// file common/capture.c line 31
void fifo_init(struct FIFO *fifo, char *name, signed int slots, signed int writers);
// fifo_put
// file common/capture.c line 45
signed int fifo_put(struct FIFO *fifo, void *data);
// files_audio
// file libng/writefile.c line 364
static signed int files_audio(void *handle, struct ng_audio_buf *buf);
// files_close
// file libng/writefile.c line 374
static signed int files_close(void *handle);
// files_open
// file libng/writefile.c line 298
static void * files_open(char *filesname, char *audioname, struct ng_video_fmt *video, const void *priv_video, signed int fps, struct ng_audio_fmt *audio, const void *priv_audio);
// files_video
// file libng/writefile.c line 330
static signed int files_video(void *handle, struct ng_video_buf *buf);
// flushit
// file common/capture.c line 106
static void * flushit(void *arg);
// fnmatch
// file /usr/include/fnmatch.h line 56
extern signed int fnmatch(const char *, const char *, signed int);
// fntcmp
// file x11/vbi-gui.c line 994
static signed int fntcmp(const void *a, const void *b);
// fopen
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_media_devices
// file ./common/get_media_devices.h line 92
void free_media_devices(void *opaque);
// freq_init
// file ./common/frequencies.h line 105
void freq_init(void);
// freq_newtab
// file common/frequencies.h line 106
void freq_newtab(signed int n);
// freq_readlist
// file common/frequencies.c line 78
static signed int freq_readlist(struct CHANLIST **list, signed int n, char *name);
// freqtab_notify$object
//
void freqtab_notify$object(void);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 219
extern signed int fstat(signed int, struct stat *);
// ftruncate
// file /usr/include/unistd.h line 1019
extern signed int ftruncate(signed int, signed long int);
// fullscreen_handler
// file common/commands.c line 1158
static signed int fullscreen_handler(char *name, signed int argc, char **argv);
// fullscreen_hook$object
//
void fullscreen_hook$object(void);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// get_associated_device
// file ./common/get_media_devices.h line 124
const char * get_associated_device(void *opaque, const char *last_seek, const enum device_type desired_type, const char *seek_device, const enum device_type seek_type);
// get_bus
// file common/get_media_devices.c line 96
static enum bus_type get_bus(char *device);
// get_class
// file common/get_media_devices.c line 121
static signed int get_class(char *class, struct media_device_entry **md, unsigned int *md_size, signed int (*fill)(struct media_device_entry *));
// get_class::fill$object
//
signed int fill$object(struct media_device_entry *);
// get_freq
// file common/channel.c line 152
signed int get_freq(signed int i);
// get_not_associated_device
// file common/get_media_devices.c line 561
const char * get_not_associated_device(void *opaque, const char *last_seek, const enum device_type desired_type, const enum device_type not_desired_type);
// get_uevent_info
// file common/get_media_devices.c line 69
static void get_uevent_info(struct media_device_entry *md_ptr, char *dname);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getgid
// file /usr/include/unistd.h line 681
extern unsigned int getgid(void);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getpagesize
// file /usr/include/unistd.h line 978
extern signed int getpagesize(void);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// gnu_dev_major
// file /usr/include/x86_64-linux-gnu/sys/sysmacros.h line 27
extern unsigned int gnu_dev_major(unsigned long long int);
// gnu_dev_minor
// file /usr/include/x86_64-linux-gnu/sys/sysmacros.h line 30
extern unsigned int gnu_dev_minor(unsigned long long int);
// gray_to_lut2
// file libng/color_lut.c line 82
static void gray_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// gray_to_lut4
// file libng/color_lut.c line 148
static void gray_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// iconv
// file /usr/include/iconv.h line 42
extern unsigned long int iconv(void *, char ** restrict , unsigned long int *, char ** restrict , unsigned long int *);
// iconv_open
// file /usr/include/iconv.h line 37
extern void * iconv_open(const char *, const char *);
// init_atoms
// file x11/atoms.h line 2
void init_atoms(struct _XDisplay *dpy);
// init_channel
// file common/channel.c line 318
static void init_channel(char *name, struct CHANNEL *c);
// init_overlay
// file common/commands.c line 202
void init_overlay(void);
// init_sim
// file common/vbi-sim.c line 429
static struct vbi_raw_decoder * init_sim(signed int scanning, unsigned int services);
// int_to_str
// file common/channel.c line 752
const char * int_to_str(signed int n, struct STRTAB *tab);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// jpeg_CreateCompress
// file /usr/include/jpeglib.h line 904
extern void jpeg_CreateCompress(struct jpeg_compress_struct *, signed int, unsigned long int);
// jpeg_destroy_compress
// file /usr/include/jpeglib.h line 909
extern void jpeg_destroy_compress(struct jpeg_compress_struct *);
// jpeg_finish_compress
// file /usr/include/jpeglib.h line 954
extern void jpeg_finish_compress(struct jpeg_compress_struct *);
// jpeg_set_defaults
// file /usr/include/jpeglib.h line 926
extern void jpeg_set_defaults(struct jpeg_compress_struct *);
// jpeg_set_quality
// file /usr/include/jpeglib.h line 931
extern void jpeg_set_quality(struct jpeg_compress_struct *, signed int, signed int);
// jpeg_start_compress
// file /usr/include/jpeglib.h line 949
extern void jpeg_start_compress(struct jpeg_compress_struct *, signed int);
// jpeg_std_error
// file /usr/include/jpeglib.h line 889
extern struct jpeg_error_mgr * jpeg_std_error(struct jpeg_error_mgr *);
// jpeg_stdio_dest
// file /usr/include/jpeglib.h line 914
extern void jpeg_stdio_dest(struct jpeg_compress_struct *, struct _IO_FILE *);
// jpeg_write_scanlines
// file /usr/include/jpeglib.h line 951
extern unsigned int jpeg_write_scanlines(struct jpeg_compress_struct *, unsigned char **, unsigned int);
// keypad_handler
// file common/commands.c line 1484
static signed int keypad_handler(char *name, signed int argc, char **argv);
// keypad_timeout
// file common/commands.c line 1527
void keypad_timeout(void);
// link
// file /usr/include/unistd.h line 790
extern signed int link(const char *, const char *);
// list_add_tail
// file ./libng/list.h line 65
static inline void list_add_tail(struct list_head *new, struct list_head *head);
// list_add_tail$link1
// file libng/list.h line 65
static inline void list_add_tail$link1(struct list_head *new$link1, struct list_head *head$link1);
// list_del
// file ./libng/list.h line 89
static inline void list_del(struct list_head *entry);
// list_handler
// file common/commands.c line 943
static signed int list_handler(char *name, signed int argc, char **argv);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// lookup_channel
// file common/channel.c line 102
signed int lookup_channel(char *channel);
// lseek
// file /usr/include/unistd.h line 337
extern signed long int lseek(signed int, signed long int, signed int);
// lstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 266
extern signed int lstat(const char *, struct stat *);
// main_tty
// file x11/mtt.c line 154
static signed int main_tty(signed int argc, char **argv);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// media_device_type
// file common/get_media_devices.c line 364
const char * media_device_type(enum device_type type);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 61
extern void * mmap(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// movie_grab_put_video
// file common/capture.c line 606
signed int movie_grab_put_video(struct movie_handle *h, struct ng_video_buf **ret);
// movie_handler
// file common/commands.c line 1149
static signed int movie_handler(char *name, signed int argc, char **argv);
// movie_hook$object
//
void movie_hook$object(signed int, char **);
// movie_print_timestamps
// file common/capture.c line 583
static void movie_print_timestamps(struct movie_handle *h);
// movie_writer_init
// file common/capture.c line 398
struct movie_handle * movie_writer_init(char *moviename, char *audioname, struct ng_writer *writer, struct ng_video_fmt *video, const void *priv_video, signed int fps, struct ng_audio_fmt *audio, const void *priv_audio, char *dsp, signed int slots, signed int threads);
// movie_writer_start
// file common/capture.c line 498
signed int movie_writer_start(struct movie_handle *h);
// movie_writer_stop
// file common/capture.c line 518
signed int movie_writer_stop(struct movie_handle *h);
// msg_handler
// file common/commands.c line 1166
static signed int msg_handler(char *name, signed int argc, char **argv);
// mute_notify$object
//
void mute_notify$object(signed int);
// ng_aconv_register
// file libng/grab-ng.c line 409
signed int ng_aconv_register(signed int magic, char *plugname, struct ng_audio_conv *list, signed int count);
// ng_attr_byid
// file ./libng/grab-ng.h line 257
struct ng_attribute * ng_attr_byid(struct ng_attribute *attrs, signed int id);
// ng_attr_byname
// file ./libng/grab-ng.h line 258
struct ng_attribute * ng_attr_byname(struct ng_attribute *attrs, char *name);
// ng_attr_getint
// file ./libng/grab-ng.h line 260
signed int ng_attr_getint(struct ng_attribute *attr, char *value);
// ng_attr_getstr
// file ./libng/grab-ng.h line 259
const char * ng_attr_getstr(struct ng_attribute *attr, signed int value);
// ng_attr_int2percent
// file ./libng/grab-ng.h line 262
signed int ng_attr_int2percent(struct ng_attribute *attr, signed int value);
// ng_attr_listchoices
// file ./libng/grab-ng.h line 261
void ng_attr_listchoices(struct ng_attribute *attr);
// ng_attr_parse_int
// file ./libng/grab-ng.h line 264
signed int ng_attr_parse_int(struct ng_attribute *attr, char *str);
// ng_attr_percent2int
// file libng/grab-ng.c line 297
signed int ng_attr_percent2int(struct ng_attribute *attr, signed int percent);
// ng_check_clipping
// file libng/grab-ng.c line 847
void ng_check_clipping(signed int width, signed int height, signed int xadjust, signed int yadjust, struct OVERLAY_CLIP *oc, signed int *count);
// ng_check_magic
// file libng/grab-ng.c line 381
static signed int ng_check_magic(signed int magic, char *plugname, char *type);
// ng_color_packed_init
// file libng/grab-ng.h line 479
void ng_color_packed_init(void);
// ng_color_yuv2rgb_init
// file libng/grab-ng.h line 480
void ng_color_yuv2rgb_init(void);
// ng_conv_find_from
// file libng/grab-ng.c line 504
struct ng_video_conv * ng_conv_find_from(unsigned int in, signed int *i);
// ng_conv_find_match
// file libng/grab-ng.c line 531
struct ng_video_conv * ng_conv_find_match(unsigned int in, unsigned int out);
// ng_conv_find_to
// file ./libng/grab-ng.h line 445
struct ng_video_conv * ng_conv_find_to(unsigned int out, signed int *i);
// ng_conv_nop_fini
// file libng/color_common.c line 56
void ng_conv_nop_fini(void *handle);
// ng_conv_nop_init
// file libng/color_common.c line 49
void * ng_conv_nop_init(struct ng_video_fmt *out, void *priv);
// ng_conv_register
// file libng/grab-ng.c line 396
signed int ng_conv_register(signed int magic, char *plugname, struct ng_video_conv *list, signed int count);
// ng_convert_alloc
// file ./libng/grab-ng.h line 373
struct ng_convert_handle * ng_convert_alloc(struct ng_video_conv *conv, struct ng_video_fmt *i, struct ng_video_fmt *o);
// ng_convert_copyframe
// file libng/convert.c line 69
static void ng_convert_copyframe(struct ng_video_buf *dest, struct ng_video_buf *src);
// ng_convert_fini
// file ./libng/grab-ng.h line 380
void ng_convert_fini(struct ng_convert_handle *h);
// ng_convert_frame
// file ./libng/grab-ng.h line 377
struct ng_video_buf * ng_convert_frame(struct ng_convert_handle *h, struct ng_video_buf *dest, struct ng_video_buf *buf);
// ng_convert_init
// file ./libng/grab-ng.h line 376
void ng_convert_init(struct ng_convert_handle *h);
// ng_convert_single
// file ./libng/grab-ng.h line 381
struct ng_video_buf * ng_convert_single(struct ng_convert_handle *h, struct ng_video_buf *in);
// ng_convert_thread
// file common/capture.c line 132
void * ng_convert_thread(void *arg);
// ng_device_init
// file libng/devices.h line 14
void ng_device_init(void);
// ng_dsp_driver_register
// file libng/grab-ng.c line 458
signed int ng_dsp_driver_register(signed int magic, char *plugname, struct ng_dsp_driver *driver);
// ng_dsp_open
// file ./libng/grab-ng.h line 452
struct ng_dsp_driver * ng_dsp_open(char *device, struct ng_audio_fmt *fmt, signed int record, void **handle);
// ng_filter_register
// file libng/grab-ng.c line 422
signed int ng_filter_register(signed int magic, char *plugname, struct ng_filter *filter);
// ng_filter_single
// file ./libng/grab-ng.h line 461
struct ng_video_buf * ng_filter_single(struct ng_filter *filter, struct ng_video_buf *in);
// ng_find_reader
// file libng/grab-ng.c line 763
struct ng_reader * ng_find_reader(char *filename);
// ng_free_video_buf
// file libng/grab-ng.c line 154
static void ng_free_video_buf(struct ng_video_buf *buf);
// ng_get_timestamp
// file ./libng/grab-ng.h line 458
signed long int ng_get_timestamp(void);
// ng_grabber_findconv
// file common/capture.c line 199
struct ng_video_conv * ng_grabber_findconv(struct ng_video_fmt *fmt, signed int fix_ratio);
// ng_grabber_get_image
// file common/capture.h line 24
struct ng_video_buf * ng_grabber_get_image(struct ng_video_fmt *fmt);
// ng_grabber_grab_image
// file common/capture.c line 226
struct ng_video_buf * ng_grabber_grab_image(signed int single);
// ng_grabber_setformat
// file common/capture.c line 163
signed int ng_grabber_setformat(struct ng_video_fmt *fmt, signed int fix_ratio);
// ng_init
// file libng/grab-ng.c line 975
void ng_init(void);
// ng_init_video_buf
// file libng/grab-ng.c line 122
void ng_init_video_buf(struct ng_video_buf *buf);
// ng_lut_init
// file libng/color_lut.c line 241
void ng_lut_init(unsigned long int red_mask, unsigned long int green_mask, unsigned long int blue_mask, unsigned int fmtid, signed int swap);
// ng_malloc_audio_buf
// file libng/grab-ng.c line 184
struct ng_audio_buf * ng_malloc_audio_buf(struct ng_audio_fmt *fmt, signed int size);
// ng_malloc_video_buf
// file libng/grab-ng.c line 161
struct ng_video_buf * ng_malloc_video_buf(struct ng_video_fmt *fmt, signed int size);
// ng_mix_driver_register
// file libng/grab-ng.c line 467
signed int ng_mix_driver_register(signed int magic, char *plugname, struct ng_mix_driver *driver);
// ng_mix_init
// file libng/grab-ng.c line 738
struct ng_attribute * ng_mix_init(char *device, char *channel);
// ng_packed_frame
// file libng/color_common.c line 22
void ng_packed_frame(void *handle, struct ng_video_buf *out, struct ng_video_buf *in);
// ng_packed_frame::1::func$object
//
signed int func$object(unsigned char *, unsigned char *, signed int);
// ng_packed_init
// file libng/color_common.c line 16
void * ng_packed_init(struct ng_video_fmt *out, void *priv);
// ng_plugins
// file libng/grab-ng.c line 940
static signed int ng_plugins(char *dirname);
// ng_plugins::1::initcall$object
//
void initcall$object(void);
// ng_ratio_fixup
// file ./libng/grab-ng.h line 268
void ng_ratio_fixup(signed int *width, signed int *height, signed int *xoff, signed int *yoff);
// ng_ratio_fixup2
// file libng/grab-ng.c line 349
void ng_ratio_fixup2(signed int *width, signed int *height, signed int *xoff, signed int *yoff, signed int ratio_x, signed int ratio_y, signed int up);
// ng_reader_register
// file libng/grab-ng.c line 440
signed int ng_reader_register(signed int magic, char *plugname, struct ng_reader *reader);
// ng_release_video_buf
// file ./libng/grab-ng.h line 162
void ng_release_video_buf(struct ng_video_buf *buf);
// ng_rgb24_to_lut2
// file libng/color_lut.c line 30
void ng_rgb24_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// ng_rgb24_to_lut4
// file libng/color_lut.c line 96
void ng_rgb24_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// ng_tofday_to_timestamp
// file libng/grab-ng.c line 793
signed long int ng_tofday_to_timestamp(struct timeval *tv);
// ng_vid_driver_register
// file libng/grab-ng.c line 449
signed int ng_vid_driver_register(signed int magic, char *plugname, struct ng_vid_driver *driver);
// ng_vid_open
// file libng/grab-ng.c line 616
struct ng_vid_driver * ng_vid_open(char **device, char *driver, struct ng_video_fmt *screen, void *base, void **handle);
// ng_vid_open_auto
// file libng/grab-ng.c line 547
static void * ng_vid_open_auto(struct ng_vid_driver *drv, char *devpath, signed int allow_grabber);
// ng_waiton_video_buf
// file libng/grab-ng.c line 146
void ng_waiton_video_buf(struct ng_video_buf *buf);
// ng_wakeup_video_buf
// file libng/grab-ng.c line 141
void ng_wakeup_video_buf(struct ng_video_buf *buf);
// ng_writefile_init
// file libng/grab-ng.h line 481
void ng_writefile_init(void);
// ng_writer_register
// file libng/grab-ng.c line 431
signed int ng_writer_register(signed int magic, char *plugname, struct ng_writer *writer);
// ng_yuv420p_to_lut2
// file libng/grab-ng.h line 489
void ng_yuv420p_to_lut2(void *h, struct ng_video_buf *out, struct ng_video_buf *in);
// ng_yuv420p_to_lut4
// file libng/grab-ng.h line 491
void ng_yuv420p_to_lut4(void *h, struct ng_video_buf *out, struct ng_video_buf *in);
// ng_yuv422_to_lut2
// file libng/grab-ng.h line 487
void ng_yuv422_to_lut2(unsigned char * restrict dest, unsigned char * restrict s, signed int p);
// ng_yuv422_to_lut4
// file libng/grab-ng.h line 488
void ng_yuv422_to_lut4(unsigned char * restrict dest, unsigned char * restrict s, signed int p);
// ng_yuv422p_to_lut2
// file libng/grab-ng.h line 493
void ng_yuv422p_to_lut2(void *h, struct ng_video_buf *out, struct ng_video_buf *in);
// ng_yuv422p_to_lut4
// file libng/grab-ng.h line 495
void ng_yuv422p_to_lut4(void *h, struct ng_video_buf *out, struct ng_video_buf *in);
// nl_langinfo
// file /usr/include/langinfo.h line 583
extern char * nl_langinfo(signed int);
// odd
// file common/vbi-sim.c line 194
static inline signed int odd(signed int c);
// open
// file /usr/include/fcntl.h line 149
extern signed int open(const char *, signed int, ...);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// oss_levels
// file common/sound.c line 13
void oss_levels(struct ng_audio_buf *buf, signed int *left, signed int *right);
// parse_action
// file common/event.c line 21
static void parse_action(struct event_entry *entry);
// parse_config
// file ./common/channel.h line 77
void parse_config(signed int parse_channels);
// patch_up
// file libng/writefile.c line 36
signed int patch_up(char *name);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// print_choices
// file common/commands.c line 753
static void print_choices(char *name, char *value, struct STRTAB *tab);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous$80 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$80 *, const union anonymous$86 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$80 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$80 *, union anonymous$14 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$14 *, const union anonymous$86 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$14 *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_trylock(union anonymous$14 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$14 *);
// pthread_setcancelstate
// file /usr/include/pthread.h line 508
extern signed int pthread_setcancelstate(signed int, signed int *);
// pthread_setcanceltype
// file /usr/include/pthread.h line 512
extern signed int pthread_setcanceltype(signed int, signed int *);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// raw_audio
// file libng/writefile.c line 519
static signed int raw_audio(void *handle, struct ng_audio_buf *buf);
// raw_close
// file libng/writefile.c line 529
static signed int raw_close(void *handle);
// raw_open
// file libng/writefile.c line 408
static void * raw_open(char *videoname, char *audioname, struct ng_video_fmt *video, const void *priv_video, signed int fps, struct ng_audio_fmt *audio, const void *priv_audio);
// raw_video
// file libng/writefile.c line 497
static signed int raw_video(void *handle, struct ng_video_buf *buf);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_config
// file ./common/channel.h line 76
void read_config(char *conffile, signed int *argc, char **argv);
// read_sim
// file common/vbi-sim.c line 301
static void read_sim(unsigned char *raw_data, struct anonymous$15 *sliced_data, signed int *lines, double *timestamp);
// readdir
// file /usr/include/dirent.h line 165
extern struct dirent * readdir(struct __dirstream *);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// realpath
// file /usr/include/stdlib.h line 733
extern char * realpath(const char *, char *);
// rec_status$object
//
void rec_status$object(char *);
// record_audio_thread
// file common/capture.c line 371
static void * record_audio_thread(void *arg);
// redblue_swap
// file libng/color_packed.c line 25
static void redblue_swap(unsigned char *dest, unsigned char *src, signed int p);
// rgb15_be_gray
// file libng/color_packed.c line 137
static void rgb15_be_gray(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// rgb15_native_gray
// file libng/color_packed.c line 119
static void rgb15_native_gray(unsigned char * restrict dest, unsigned char *s, signed int p);
// rgb32_to_bgr24
// file libng/color_packed.c line 85
static void rgb32_to_bgr24(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// rgb32_to_lut2
// file libng/color_lut.c line 56
static void rgb32_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// rgb32_to_lut4
// file libng/color_lut.c line 122
static void rgb32_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// rgb32_to_rgb24
// file libng/color_packed.c line 70
static void rgb32_to_rgb24(unsigned char * restrict dest, unsigned char * restrict src, signed int p);
// save_config
// file common/channel.c line 559
void save_config(void);
// scandir
// file /usr/include/dirent.h line 262
extern signed int scandir(const char *, struct dirent *** restrict , signed int (*)(struct dirent *), signed int (*)(struct dirent **, struct dirent **));
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$12 *, struct anonymous$12 *, struct anonymous$12 *, struct timeval *);
// selection_clip_cb
// file x11/vbi-gui.c line 857
static void selection_clip_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// selection_convert_cb
// file x11/vbi-gui.c line 689
static void selection_convert_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// selection_dnd_done
// file x11/vbi-gui.c line 869
static void selection_dnd_done(struct _WidgetRec *widget, void *clientdata, void *call_data);
// selection_dnd_start
// file x11/vbi-gui.c line 879
static void selection_dnd_start(struct vbi_window *vw, union _XEvent *event);
// selection_find
// file x11/vbi-gui.c line 626
static struct vbi_selection * selection_find(struct vbi_window *vw, unsigned long int selection);
// selection_fini
// file x11/vbi-gui.c line 640
static void selection_fini(struct vbi_window *vw, unsigned long int selection);
// selection_init
// file x11/vbi-gui.c line 655
static void selection_init(struct vbi_window *vw, unsigned long int selection);
// selection_pri
// file x11/vbi-gui.c line 847
static void selection_pri(struct vbi_window *vw);
// selection_unique_atom
// file x11/vbi-gui.c line 673
static unsigned long int selection_unique_atom(struct vbi_window *vw);
// set_attr
// file common/commands.c line 331
static void set_attr(struct ng_attribute *attr, signed int val);
// set_capture
// file common/commands.c line 304
static void set_capture(signed int capture, signed int tmp_switch);
// set_capture_hook$object
//
void set_capture_hook$object(signed int, signed int, signed int);
// set_defaults
// file common/commands.c line 525
void set_defaults(void);
// set_freqtab
// file common/commands.c line 364
static void set_freqtab(signed int j);
// set_msg_bool
// file common/commands.c line 418
static void set_msg_bool(const char *name, signed int val);
// set_msg_int
// file common/commands.c line 406
static void set_msg_int(struct ng_attribute *attr, signed int val);
// set_msg_str
// file common/commands.c line 429
static void set_msg_str(const char *name, const char *val);
// set_mute
// file common/commands.c line 351
static void set_mute(signed int val);
// set_title
// file common/commands.c line 381
static void set_title(void);
// set_volume
// file common/commands.c line 342
static void set_volume(signed int val);
// setchannel_handler
// file common/commands.c line 667
static signed int setchannel_handler(char *name, signed int argc, char **argv);
// setfreqtab_handler
// file common/commands.c line 763
static signed int setfreqtab_handler(char *name, signed int argc, char **argv);
// setfreqtab_notify$object
//
void setfreqtab_notify$object(void);
// setlocale
// file /usr/include/locale.h line 124
extern char * setlocale(signed int, const char *);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setstation_handler
// file common/commands.c line 567
static signed int setstation_handler(char *name, signed int argc, char **argv);
// setstation_notify$object
//
void setstation_notify$object(void);
// shape
// file common/vbi-sim.c line 10
static inline double shape(double ph);
// show_handler
// file common/commands.c line 909
static signed int show_handler(char *name, signed int argc, char **argv);
// showtime_handler
// file common/commands.c line 1174
static signed int showtime_handler(char *name, signed int argc, char **argv);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous$16 *);
// siglongjmp
// file /usr/include/setjmp.h line 102
extern void siglongjmp(struct __jmp_buf_tag *, signed int);
// sin
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 65
extern double sin(double);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snap_filename
// file ./libng/writefile.h line 2
char * snap_filename(char *base, char *channel, char *ext);
// snap_handler
// file common/commands.c line 1006
static signed int snap_handler(char *hname, signed int argc, char **argv);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sort_media_device_entry
// file common/get_media_devices.c line 299
static signed int sort_media_device_entry(const void *a, const void *b);
// split_cmdline
// file common/commands.c line 272
char ** split_cmdline(char *line, signed int *count);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 216
extern signed int stat(const char *, struct stat *);
// str_to_int
// file common/channel.c line 739
signed int str_to_int(char *str, struct STRTAB *tab);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcasestr
// file /usr/include/string.h line 372
extern char * strcasestr(const char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strfamily
// file common/commands.c line 1198
static char * strfamily(signed int family);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// sync
// file /usr/include/unistd.h line 972
extern void sync(void);
// system
// file /usr/include/stdlib.h line 716
extern signed int system(const char *);
// tcgetattr
// file /usr/include/termios.h line 66
extern signed int tcgetattr(signed int, struct termios *);
// tcp_connect
// file common/commands.c line 1209
static signed int tcp_connect(struct addrinfo *ai, char *host, char *serv);
// tcp_readbuf
// file common/commands.c line 1256
static signed int tcp_readbuf(signed int sock, signed int timeout, char *dest, char dlen);
// tcsetattr
// file /usr/include/termios.h line 70
extern signed int tcsetattr(signed int, signed int, struct termios *);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// ttx_next
// file common/vbi-sim.c line 209
static unsigned char * ttx_next(void);
// ttx_sim
// file common/vbi-sim.c line 147
static inline double ttx_sim(double t, double F, const unsigned char *text);
// tty_clear
// file console/vbi-tty.c line 57
static void tty_clear(void);
// tty_goto
// file console/vbi-tty.c line 62
static void tty_goto(signed int x, signed int y);
// tty_raw
// file console/vbi-tty.c line 33
static void tty_raw(void);
// tty_restore
// file console/vbi-tty.c line 48
static void tty_restore(void);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// update_int
// file common/commands.c line 441
static signed int update_int(struct ng_attribute *attr, signed int old, char *new);
// update_title$object
//
void update_title$object(char *);
// usage
// file x11/mtt.c line 131
static void usage(void);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// vbi_calc_page
// file ./common/vbi-data.h line 38
signed int vbi_calc_page(signed int pagenr, signed int offset);
// vbi_calc_subpage
// file ./common/vbi-data.h line 39
signed int vbi_calc_subpage(struct vbi_decoder *dec, signed int pgno, signed int subno, signed int offset);
// vbi_capture_delete
// file /usr/include/libzvbi.h line 1655
extern void vbi_capture_delete(struct vbi_capture *);
// vbi_capture_fd
// file /usr/include/libzvbi.h line 1648
extern signed int vbi_capture_fd(struct vbi_capture *);
// vbi_capture_parameters
// file /usr/include/libzvbi.h line 1647
extern struct vbi_raw_decoder * vbi_capture_parameters(struct vbi_capture *);
// vbi_capture_read
// file /usr/include/libzvbi.h line 1638
extern signed int vbi_capture_read(struct vbi_capture *, void *, struct anonymous$15 *, signed int *, double *, struct timeval *);
// vbi_capture_v4l2_new
// file /usr/include/libzvbi.h line 1582
extern struct vbi_capture * vbi_capture_v4l2_new(const char *, signed int, unsigned int *, signed int, char **, signed int);
// vbi_capture_v4l_new
// file /usr/include/libzvbi.h line 1592
extern struct vbi_capture * vbi_capture_v4l_new(const char *, signed int, unsigned int *, signed int, char **, signed int);
// vbi_check_rectangle
// file x11/vbi-gui.c line 109
static void vbi_check_rectangle(struct vbi_rect *rect);
// vbi_close
// file common/vbi-data.c line 138
void vbi_close(struct vbi_state *vbi);
// vbi_close_cb
// file x11/vbi-gui.c line 290
static void vbi_close_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// vbi_create_widgets
// file x11/vbi-gui.h line 1
void vbi_create_widgets(struct _WidgetRec *shell, struct vbi_state *vbi);
// vbi_data
// file x11/mtt.c line 148
static void vbi_data(void *data, signed int *fd, unsigned long int *iproc);
// vbi_decode
// file /usr/include/libzvbi.h line 2145
extern void vbi_decode(struct vbi_decoder *, struct anonymous$15 *, signed int, double);
// vbi_decoder_delete
// file /usr/include/libzvbi.h line 2144
extern void vbi_decoder_delete(struct vbi_decoder *);
// vbi_decoder_new
// file /usr/include/libzvbi.h line 2143
extern struct vbi_decoder * vbi_decoder_new(void);
// vbi_destroy_cb
// file x11/vbi-gui.c line 276
static void vbi_destroy_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// vbi_draw_vt_page_region
// file /usr/include/libzvbi.h line 1867
extern void vbi_draw_vt_page_region(struct vbi_page *, enum anonymous$13, void *, signed int, signed int, signed int, signed int, signed int, signed int, signed int);
// vbi_dump_event
// file ./common/vbi-data.h line 36
void vbi_dump_event(struct vbi_event *ev, void *user);
// vbi_event_handler_add
// file /usr/include/libzvbi.h line 742
extern signed int vbi_event_handler_add(struct vbi_decoder *, signed int, void (*)(struct vbi_event *, void *), void *);
// vbi_event_handler_register
// file /usr/include/libzvbi.h line 747
extern signed int vbi_event_handler_register(struct vbi_decoder *, signed int, void (*)(struct vbi_event *, void *), void *);
// vbi_event_handler_unregister
// file /usr/include/libzvbi.h line 750
extern void vbi_event_handler_unregister(struct vbi_decoder *, void (*)(struct vbi_event *, void *), void *);
// vbi_export_pixmap
// file x11/vbi-x11.c line 256
unsigned long int vbi_export_pixmap(struct vbi_window *vw, struct vbi_page *pg, struct vbi_rect *rect);
// vbi_export_txt
// file ./common/vbi-data.h line 40
signed int vbi_export_txt(char *dest, char *charset, signed int size, struct vbi_page *pg, struct vbi_rect *rect, enum vbi_txt_colors color);
// vbi_expose_cb
// file x11/vbi-gui.c line 265
static void vbi_expose_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// vbi_fetch_vt_page
// file /usr/include/libzvbi.h line 2028
extern signed int vbi_fetch_vt_page(struct vbi_decoder *, struct vbi_page *, signed int, signed int, enum anonymous, signed int, signed int);
// vbi_find_subtitle
// file common/vbi-data.c line 348
void vbi_find_subtitle(struct vbi_page *pg, struct vbi_rect *rect);
// vbi_findpage
// file x11/vbi-gui.c line 346
static signed int vbi_findpage(struct vbi_page *pg, signed int px, signed int py);
// vbi_fix_head
// file x11/vbi-gui.c line 70
static void vbi_fix_head(struct vbi_window *vw, struct vbi_char *ch);
// vbi_fix_head$link1
// file console/vbi-tty.c line 88
static void vbi_fix_head$link1(struct vbi_tty *tty, struct vbi_char *ch$link1);
// vbi_font_cb
// file x11/vbi-gui.c line 309
static void vbi_font_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// vbi_goto_cb
// file x11/vbi-gui.c line 319
static void vbi_goto_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// vbi_hasdata
// file ./common/vbi-data.h line 34
signed int vbi_hasdata(struct vbi_state *vbi);
// vbi_is_gfx
// file /usr/include/libzvbi.h line 855
static inline signed int vbi_is_gfx(unsigned int unicode);
// vbi_kbd_eh
// file x11/vbi-gui.c line 391
static void vbi_kbd_eh(struct _WidgetRec *widget, void *clientdata, union _XEvent *event, char *cont);
// vbi_mark_rectangle
// file x11/vbi-gui.c line 130
static void vbi_mark_rectangle(struct vbi_window *vw);
// vbi_mouse_eh
// file x11/vbi-gui.c line 472
static void vbi_mouse_eh(struct _WidgetRec *widget, void *clientdata, union _XEvent *event, char *cont);
// vbi_new_cb
// file x11/vbi-gui.c line 297
static void vbi_new_cb(struct _WidgetRec *widget, void *clientdata, void *call_data);
// vbi_newdata
// file x11/vbi-gui.c line 178
static void vbi_newdata(struct vbi_event *ev, void *user);
// vbi_newdata$link1
// file console/vbi-tty.c line 187
static void vbi_newdata$link1(struct vbi_event *ev$link1, void *user$link1);
// vbi_open
// file ./common/vbi-data.h line 33
struct vbi_state * vbi_open(char *dev, signed int debug, signed int sim);
// vbi_raw_decode
// file /usr/include/libzvbi.h line 1181
extern signed int vbi_raw_decode(struct vbi_raw_decoder *, unsigned char *, struct anonymous$15 *);
// vbi_raw_decoder_add_services
// file /usr/include/libzvbi.h line 1170
extern unsigned int vbi_raw_decoder_add_services(struct vbi_raw_decoder *, unsigned int, signed int);
// vbi_raw_decoder_init
// file /usr/include/libzvbi.h line 1167
extern void vbi_raw_decoder_init(struct vbi_raw_decoder *);
// vbi_render_free_font
// file x11/vbi-x11.c line 77
void vbi_render_free_font(struct _WidgetRec *shell, struct vbi_window *vw);
// vbi_render_head
// file x11/vbi-gui.c line 166
static void vbi_render_head(struct vbi_window *vw, signed int pgno, signed int subno);
// vbi_render_head$link1
// file console/vbi-tty.c line 155
static void vbi_render_head$link1(struct vbi_tty *tty, signed int pgno$link1, signed int subno$link1);
// vbi_render_init
// file x11/vbi-x11.c line 142
struct vbi_window * vbi_render_init(struct _WidgetRec *shell, struct _WidgetRec *tt, struct vbi_state *vbi);
// vbi_render_line
// file x11/vbi-x11.c line 176
void vbi_render_line(struct vbi_window *vw, unsigned long int d, struct vbi_char *ch, signed int y, signed int top, signed int left, signed int right);
// vbi_render_page
// file x11/vbi-gui.c line 150
static void vbi_render_page(struct vbi_window *vw);
// vbi_render_page$link1
// file console/vbi-tty.c line 127
static void vbi_render_page$link1(struct vbi_tty *tty);
// vbi_render_set_font
// file x11/vbi-x11.c line 95
void vbi_render_set_font(struct _WidgetRec *shell, struct vbi_window *vw, char *label);
// vbi_render_try_font
// file x11/vbi-x11.c line 59
static signed int vbi_render_try_font(struct _WidgetRec *shell, struct vbi_window *vw, struct vbi_font *fnt);
// vbi_setpage
// file x11/vbi-gui.c line 251
static void vbi_setpage(struct vbi_window *vw, signed int pgno, signed int subno);
// vbi_setpage$link1
// file console/vbi-tty.c line 207
static void vbi_setpage$link1(struct vbi_tty *tty, signed int pgno$link1, signed int subno$link1);
// vbi_station_cb
// file x11/vbi-gui.c line 895
static void vbi_station_cb(struct _WidgetRec *widget, void *client, void *call);
// vbi_station_menu
// file x11/vbi-gui.c line 930
static void vbi_station_menu(struct _WidgetRec *menubar, struct vbi_state *vbi);
// vbi_subpage_menu
// file x11/vbi-gui.c line 208
static void vbi_subpage_menu(struct vbi_window *vw);
// vbi_teletext_set_default_region
// file /usr/include/libzvbi.h line 2025
extern void vbi_teletext_set_default_region(struct vbi_decoder *, signed int);
// vbi_tty
// file ./console/vbi-tty.h line 1
extern void vbi_tty(char *device, signed int debug, signed int sim);
// vbi_xft_font_menu
// file x11/vbi-gui.c line 1002
static void vbi_xft_font_menu(struct _WidgetRec *menu, struct vbi_window *vw);
// vdr_handler
// file common/commands.c line 1293
static signed int vdr_handler(char *name, signed int argc, char **argv);
// volume_handler
// file common/commands.c line 796
static signed int volume_handler(char *name, signed int argc, char **argv);
// volume_notify$object
//
void volume_notify$object(void);
// vtx_subtitle$object
//
void vtx_subtitle$object(struct vbi_page *, struct vbi_rect *);
// wav_init_header
// file libng/writefile.c line 233
static void wav_init_header(struct WAVEHDR *fileheader, struct ng_audio_fmt *audio);
// wav_start_write
// file libng/writefile.c line 261
static void wav_start_write(signed int fd, struct WAVEHDR *fileheader, struct ng_audio_fmt *audio);
// wav_stop_write
// file libng/writefile.c line 268
static void wav_stop_write(signed int fd, struct WAVEHDR *fileheader, signed int wav_size);
// webcam_exit
// file common/webcam.c line 118
void webcam_exit(void);
// webcam_handler
// file common/commands.c line 1115
static signed int webcam_handler(char *hname, signed int argc, char **argv);
// webcam_init
// file common/webcam.c line 108
void webcam_init(void);
// webcam_put
// file common/webcam.c line 128
signed int webcam_put(char *filename, struct ng_video_buf *buf);
// webcam_writer
// file common/webcam.c line 30
static void * webcam_writer(void *arg);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_jpeg
// file ./libng/writefile.h line 4
signed int write_jpeg(char *filename, struct ng_video_buf *buf, signed int quality, signed int gray);
// write_pgm
// file libng/writefile.c line 161
signed int write_pgm(char *filename, struct ng_video_buf *buf);
// write_ppm
// file ./libng/writefile.h line 6
signed int write_ppm(char *filename, struct ng_video_buf *buf);
// writer_audio_thread
// file common/capture.c line 295
static void * writer_audio_thread(void *arg);
// writer_video_thread
// file common/capture.c line 321
static void * writer_video_thread(void *arg);
// wss525_sim
// file common/vbi-sim.c line 112
static inline double wss525_sim(double t, double F, unsigned int bits);
// wss625_sim
// file common/vbi-sim.c line 66
static inline double wss625_sim(double t, double F, unsigned int bits);
// x11_icons_init
// file x11/icons.h line 1
void x11_icons_init(struct _XDisplay *dpy, unsigned long int bg);
// yuv420p_to_rgb24
// file libng/color_yuv2rgb.c line 170
static void yuv420p_to_rgb24(void *h, struct ng_video_buf *out, struct ng_video_buf *in);
// yuv422_to_gray
// file libng/color_yuv2rgb.c line 64
static void yuv422_to_gray(unsigned char * restrict dest, unsigned char * restrict s, signed int p);
// yuv422_to_rgb24
// file libng/color_yuv2rgb.c line 78
static void yuv422_to_rgb24(unsigned char * restrict dest, unsigned char * restrict s, signed int p);
// yuv422p_to_rgb24
// file libng/color_yuv2rgb.c line 206
static void yuv422p_to_rgb24(void *h, struct ng_video_buf *out, struct ng_video_buf *in);
// yuv42xp_to_gray
// file libng/color_yuv2rgb.c line 149
static void yuv42xp_to_gray(void *h, struct ng_video_buf *out, struct ng_video_buf *in);

struct anonymous$87
{
  // name
  char *name;
  // value
  char *value;
  // pixel
  unsigned long int pixel;
};

struct anonymous$1
{
  // name
  char *name;
  // value
  signed long int value;
};

struct anonymous$88
{
  // name
  char *name;
  // nlines
  unsigned int nlines;
  // lines
  char **lines;
};

struct anonymous$21
{
  // option
  char *option;
  // specifier
  char *specifier;
  // argKind
  enum anonymous$20 argKind;
  // value
  char *value;
};

struct anonymous$89
{
  // string
  char *string;
  // symbolic
  char *symbolic;
  // m_color
  char *m_color;
  // g4_color
  char *g4_color;
  // g_color
  char *g_color;
  // c_color
  char *c_color;
};

struct anonymous$96
{
  // ext_data
  struct _XExtData *ext_data;
  // display
  struct _XDisplay *display;
  // root
  unsigned long int root;
  // width
  signed int width;
  // height
  signed int height;
  // mwidth
  signed int mwidth;
  // mheight
  signed int mheight;
  // ndepths
  signed int ndepths;
  // depths
  struct anonymous$95 *depths;
  // root_depth
  signed int root_depth;
  // root_visual
  struct anonymous$90 *root_visual;
  // default_gc
  struct _XGC *default_gc;
  // cmap
  unsigned long int cmap;
  // white_pixel
  unsigned long int white_pixel;
  // black_pixel
  unsigned long int black_pixel;
  // max_maps
  signed int max_maps;
  // min_maps
  signed int min_maps;
  // backing_store
  signed int backing_store;
  // save_unders
  signed int save_unders;
  // root_input_mask
  signed long int root_input_mask;
};

struct anonymous$99
{
  // lbearing
  signed short int lbearing;
  // rbearing
  signed short int rbearing;
  // width
  signed short int width;
  // ascent
  signed short int ascent;
  // descent
  signed short int descent;
  // attributes
  unsigned short int attributes;
};

struct anonymous$100
{
  // ext_data
  struct _XExtData *ext_data;
  // fid
  unsigned long int fid;
  // direction
  unsigned int direction;
  // min_char_or_byte2
  unsigned int min_char_or_byte2;
  // max_char_or_byte2
  unsigned int max_char_or_byte2;
  // min_byte1
  unsigned int min_byte1;
  // max_byte1
  unsigned int max_byte1;
  // all_chars_exist
  signed int all_chars_exist;
  // default_char
  unsigned int default_char;
  // n_properties
  signed int n_properties;
  // properties
  struct anonymous$98 *properties;
  // min_bounds
  struct anonymous$99 min_bounds;
  // max_bounds
  struct anonymous$99 max_bounds;
  // per_char
  struct anonymous$99 *per_char;
  // ascent
  signed int ascent;
  // descent
  signed int descent;
};

struct anonymous$90
{
  // ext_data
  struct _XExtData *ext_data;
  // visualid
  unsigned long int visualid;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // bits_per_rgb
  signed int bits_per_rgb;
  // map_entries
  signed int map_entries;
};

struct anonymous$37
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$32
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous$12
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous$94
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous$16
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$8
{
  // bits
  unsigned char bits[17l];
  // huffval
  unsigned char huffval[256l];
  // sent_table
  signed int sent_table;
};

struct anonymous$7
{
  // quantval
  unsigned short int quantval[64l];
  // sent_table
  signed int sent_table;
};

struct anonymous$81
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$6
{
  // component_id
  signed int component_id;
  // component_index
  signed int component_index;
  // h_samp_factor
  signed int h_samp_factor;
  // v_samp_factor
  signed int v_samp_factor;
  // quant_tbl_no
  signed int quant_tbl_no;
  // dc_tbl_no
  signed int dc_tbl_no;
  // ac_tbl_no
  signed int ac_tbl_no;
  // width_in_blocks
  unsigned int width_in_blocks;
  // height_in_blocks
  unsigned int height_in_blocks;
  // DCT_scaled_size
  signed int DCT_scaled_size;
  // downsampled_width
  unsigned int downsampled_width;
  // downsampled_height
  unsigned int downsampled_height;
  // component_needed
  signed int component_needed;
  // MCU_width
  signed int MCU_width;
  // MCU_height
  signed int MCU_height;
  // MCU_blocks
  signed int MCU_blocks;
  // MCU_sample_width
  signed int MCU_sample_width;
  // last_col_width
  signed int last_col_width;
  // last_row_height
  signed int last_row_height;
  // quant_table
  struct anonymous$7 *quant_table;
  // dct_table
  void *dct_table;
};

struct anonymous$9
{
  // comps_in_scan
  signed int comps_in_scan;
  // component_index
  signed int component_index[4l];
  // Ss
  signed int Ss;
  // Se
  signed int Se;
  // Ah
  signed int Ah;
  // Al
  signed int Al;
};

struct anonymous$95
{
  // depth
  signed int depth;
  // nvisuals
  signed int nvisuals;
  // visuals
  struct anonymous$90 *visuals;
};

struct anonymous$34
{
  // first_line
  signed int first_line;
  // last_line
  signed int last_line;
  // ratio
  double ratio;
  // film_mode
  signed int film_mode;
  // open_subtitles
  enum anonymous$33 open_subtitles;
};

struct anonymous$107
{
  // function
  signed int function;
  // plane_mask
  unsigned long int plane_mask;
  // foreground
  unsigned long int foreground;
  // background
  unsigned long int background;
  // line_width
  signed int line_width;
  // line_style
  signed int line_style;
  // cap_style
  signed int cap_style;
  // join_style
  signed int join_style;
  // fill_style
  signed int fill_style;
  // fill_rule
  signed int fill_rule;
  // arc_mode
  signed int arc_mode;
  // tile
  unsigned long int tile;
  // stipple
  unsigned long int stipple;
  // ts_x_origin
  signed int ts_x_origin;
  // ts_y_origin
  signed int ts_y_origin;
  // font
  unsigned long int font;
  // subwindow_mode
  signed int subwindow_mode;
  // graphics_exposures
  signed int graphics_exposures;
  // clip_x_origin
  signed int clip_x_origin;
  // clip_y_origin
  signed int clip_y_origin;
  // clip_mask
  unsigned long int clip_mask;
  // dash_offset
  signed int dash_offset;
  // dashes
  char dashes;
};

struct anonymous$44
{
  // pgno
  signed int pgno;
};

struct anonymous$104
{
  // pgno
  signed int pgno;
  // subno
  signed int subno;
};

struct anonymous$43
{
  // pgno
  signed int pgno;
  // subno
  signed int subno;
  // raw_header
  unsigned char *raw_header;
  // pn_offset
  signed int pn_offset;
  // roll_header
  unsigned int roll_header : 1;
  // header_update
  unsigned int header_update : 1;
  // clock_update
  unsigned int clock_update : 1;
};

struct anonymous$0
{
  // reason
  signed int reason;
  // event
  union _XEvent *event;
  // value
  union __XmStringRec *value;
  // length
  signed int length;
  // mask
  union __XmStringRec *mask;
  // mask_length
  signed int mask_length;
  // dir
  union __XmStringRec *dir;
  // dir_length
  signed int dir_length;
  // pattern
  union __XmStringRec *pattern;
  // pattern_length
  signed int pattern_length;
};

struct anonymous$2
{
  // reason
  signed int reason;
  // event
  union _XEvent *event;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // source_data
  void *source_data;
  // location_data
  void *location_data;
  // flags
  signed int flags;
  // parm
  void *parm;
  // parm_format
  signed int parm_format;
  // parm_length
  unsigned long int parm_length;
  // parm_type
  unsigned long int parm_type;
  // status
  signed int status;
  // value
  void *value;
  // type
  unsigned long int type;
  // format
  signed int format;
  // length
  unsigned long int length;
};

struct anonymous$109
{
  // reason
  signed int reason;
  // event
  union _XEvent *event;
  // window
  unsigned long int window;
};

struct anonymous$23
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$31
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$28
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$27
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$35
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$38
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$23 _kill;
  // _timer
  struct anonymous$27 _timer;
  // _rt
  struct anonymous$28 _rt;
  // _sigchld
  struct anonymous$31 _sigchld;
  // _sigfault
  struct anonymous$32 _sigfault;
  // _sigpoll
  struct anonymous$35 _sigpoll;
  // _sigsys
  struct anonymous$37 _sigsys;
};

struct anonymous$24
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$38 _sifields;
};

struct anonymous$74
{
  // type
  signed int type;
  // display
  struct _XDisplay *display;
  // resourceid
  unsigned long int resourceid;
  // serial
  unsigned long int serial;
  // error_code
  unsigned char error_code;
  // request_code
  unsigned char request_code;
  // minor_code
  unsigned char minor_code;
};

struct anonymous$75
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
};

struct anonymous$76
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
  // cookie
  unsigned int cookie;
  // data
  void *data;
};

struct anonymous$52
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous$51
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous$55
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
};

struct anonymous$56
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // from_configure
  signed int from_configure;
};

struct anonymous$58
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$65
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous$62
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
};

struct anonymous$61
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$60
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // parent
  unsigned long int parent;
  // x
  signed int x;
  // y
  signed int y;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$69
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // owner
  unsigned long int owner;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous$59
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
};

struct anonymous$66
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous$54
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$64
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // detail
  signed int detail;
  // value_mask
  unsigned long int value_mask;
};

struct anonymous$70
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous$57
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
};

struct anonymous$49
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // key_vector
  char key_vector[32l];
};

struct anonymous$48
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // mode
  signed int mode;
  // detail
  signed int detail;
};

struct anonymous$73
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // request
  signed int request;
  // first_keycode
  signed int first_keycode;
  // count
  signed int count;
};

struct anonymous$53
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // state
  signed int state;
};

struct anonymous$63
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // width
  signed int width;
  // height
  signed int height;
};

struct anonymous$50
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
};

struct anonymous$67
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // atom
  unsigned long int atom;
  // time
  unsigned long int time;
  // state
  signed int state;
};

struct anonymous$71
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // colormap
  unsigned long int colormap;
  // new
  signed int new;
  // state
  signed int state;
};

union anonymous$77
{
  // b
  char b[20l];
  // s
  signed short int s[10l];
  // l
  signed long int l[5l];
};

struct anonymous$72
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // message_type
  unsigned long int message_type;
  // format
  signed int format;
  // data
  union anonymous$77 data;
};

struct anonymous$42
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // mode
  signed int mode;
  // detail
  signed int detail;
  // same_screen
  signed int same_screen;
  // focus
  signed int focus;
  // state
  unsigned int state;
};

struct anonymous$41
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // is_hint
  char is_hint;
  // same_screen
  signed int same_screen;
};

struct anonymous$40
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // same_screen
  signed int same_screen;
};

struct anonymous$39
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // keycode
  unsigned int keycode;
  // same_screen
  signed int same_screen;
};

struct anonymous$68
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // selection
  unsigned long int selection;
  // time
  unsigned long int time;
};

struct anonymous$101
{
  // y0
  signed int y0;
  // y1
  signed int y1;
  // roll
  signed int roll;
};

struct anonymous$46
{
  // time
  signed long int time;
  // seconds_east
  signed int seconds_east;
  // seconds_east_valid
  signed int seconds_east_valid;
  // dst_state
  enum anonymous$85 dst_state;
};

struct anonymous$84
{
  // ts
  signed long int ts;
};

struct anonymous$78
{
  // ts
  signed long int ts;
  // seq
  signed int seq;
  // twice
  signed int twice;
};

struct anonymous$30
{
  // mode
  enum anonymous$29 mode;
  // language
  unsigned char *language;
};

struct anonymous$47
{
  // channel
  enum anonymous$82 channel;
  // cni_type
  enum anonymous$79 cni_type;
  // cni
  unsigned int cni;
  // pil
  unsigned int pil;
  // luf
  signed int luf;
  // mi
  signed int mi;
  // prf
  signed int prf;
  // pcs_audio
  enum anonymous$83 pcs_audio;
  // pty
  unsigned int pty;
  // tape_delayed
  signed int tape_delayed;
  // _reserved2
  void *_reserved2[2l];
  // _reserved3
  signed int _reserved3[4l];
};

struct anonymous$97
{
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
  // alpha
  unsigned short int alpha;
};

struct anonymous$15
{
  // id
  unsigned int id;
  // line
  unsigned int line;
  // data
  unsigned char data[56l];
};

struct anonymous$45
{
  // nuid
  unsigned int nuid;
  // name
  signed char name[64l];
  // call
  signed char call[40l];
  // tape_delay
  signed int tape_delay;
  // cni_vps
  signed int cni_vps;
  // cni_8301
  signed int cni_8301;
  // cni_8302
  signed int cni_8302;
  // reserved
  signed int reserved;
  // cycle
  signed int cycle;
};

struct anonymous$98
{
  // name
  unsigned long int name;
  // card32
  unsigned long int card32;
};

struct anonymous$91
{
  // pixel
  unsigned long int pixel;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
  // flags
  char flags;
  // pad
  char pad;
};

struct anonymous$92
{
  // valuemask
  unsigned long int valuemask;
  // visual
  struct anonymous$90 *visual;
  // colormap
  unsigned long int colormap;
  // depth
  unsigned int depth;
  // width
  unsigned int width;
  // height
  unsigned int height;
  // x_hotspot
  unsigned int x_hotspot;
  // y_hotspot
  unsigned int y_hotspot;
  // cpp
  unsigned int cpp;
  // pixels
  unsigned long int *pixels;
  // npixels
  unsigned int npixels;
  // colorsymbols
  struct anonymous$87 *colorsymbols;
  // numsymbols
  unsigned int numsymbols;
  // rgb_fname
  char *rgb_fname;
  // nextensions
  unsigned int nextensions;
  // extensions
  struct anonymous$88 *extensions;
  // ncolors
  unsigned int ncolors;
  // colorTable
  struct anonymous$89 *colorTable;
  // hints_cmt
  char *hints_cmt;
  // colors_cmt
  char *colors_cmt;
  // pixels_cmt
  char *pixels_cmt;
  // mask_pixel
  unsigned int mask_pixel;
  // exactColors
  signed int exactColors;
  // closeness
  unsigned int closeness;
  // red_closeness
  unsigned int red_closeness;
  // green_closeness
  unsigned int green_closeness;
  // blue_closeness
  unsigned int blue_closeness;
  // color_key
  signed int color_key;
  // alloc_pixels
  unsigned long int *alloc_pixels;
  // nalloc_pixels
  signed int nalloc_pixels;
  // alloc_close_colors
  signed int alloc_close_colors;
  // bitmap_format
  signed int bitmap_format;
  // alloc_color
  signed int (*alloc_color)(struct _XDisplay *, unsigned long int, char *, struct anonymous$91 *, void *);
  // free_colors
  signed int (*free_colors)(struct _XDisplay *, unsigned long int, unsigned long int *, signed int, void *);
  // color_closure
  void *color_closure;
};

struct anonymous$105
{
  // byte1
  unsigned char byte1;
  // byte2
  unsigned char byte2;
};

union anonymous$22
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$24 *, void *);
};

union anonymous$93
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$86
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$11
{
  // i
  signed int i[8l];
  // s
  char s[80l];
};

union anonymous$80
{
  // __data
  struct anonymous$81 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

union anonymous$19
{
  // ttx_page
  struct anonymous$43 ttx_page;
  // caption
  struct anonymous$44 caption;
  // network
  struct anonymous$45 network;
  // trigger
  struct vbi_link *trigger;
  // aspect
  struct anonymous$34 aspect;
  // prog_info
  struct vbi_program_info *prog_info;
  // local_time
  struct anonymous$46 *local_time;
  // prog_id
  struct anonymous$47 *prog_id;
  // _cc608
  struct _vbi_event_cc608_page *_cc608;
  // _cc608_stream
  struct _vbi_event_cc608_stream *_cc608_stream;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$14
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous$106
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous$36
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct ARGS
{
  // device
  char *device;
  // help
  signed int help;
  // tty
  signed int tty;
  // debug
  signed int debug;
  // sim
  signed int sim;
};

struct CFG_ENTRIES
{
  // ent_count
  signed int ent_count;
  // ent_names
  char **ent_names;
  // ent_values
  char **ent_values;
  // ent_seen
  signed int **ent_seen;
};

struct CFG_SECTIONS
{
  // sec_count
  signed int sec_count;
  // sec_names
  char **sec_names;
  // sec_entries
  struct CFG_ENTRIES **sec_entries;
};

struct CHANLIST
{
  // name
  char *name;
  // freq
  unsigned int freq;
};

struct CHANLISTS
{
  // name
  char *name;
  // filename
  char *filename;
  // list
  struct CHANLIST *list;
  // count
  signed int count;
};

struct CHANNEL
{
  // name
  char *name;
  // key
  char *key;
  // group
  char *group;
  // midi
  signed int midi;
  // cname
  char *cname;
  // channel
  signed int channel;
  // fine
  signed int fine;
  // freq
  signed int freq;
  // audio
  signed int audio;
  // capture
  signed int capture;
  // input
  signed int input;
  // norm
  signed int norm;
  // color
  signed int color;
  // bright
  signed int bright;
  // hue
  signed int hue;
  // contrast
  signed int contrast;
  // pixmap
  unsigned long int pixmap;
  // button
  struct _WidgetRec *button;
};

struct CHUNKHDR
{
  // ckid
  unsigned int ckid;
  // dwSize
  unsigned int dwSize;
};

struct COMMANDS
{
  // name
  char *name;
  // min_args
  signed int min_args;
  // handler
  signed int (*handler)(char *, signed int, char **);
};

struct DEVS
{
  // fb0
  char *fb0;
  // fbnr
  char *fbnr;
  // ttynr
  char *ttynr;
};

struct FIFO
{
  // name
  char *name;
  // data
  unsigned char *data[64l];
  // slots
  signed int slots;
  // read
  signed int read;
  // write
  signed int write;
  // eof
  signed int eof;
  // max
  signed int max;
  // writers
  signed int writers;
  // lock
  union anonymous$14 lock;
  // hasdata
  union anonymous$80 hasdata;
};

struct LAUNCH
{
  // name
  char *name;
  // key
  char *key;
  // cmdline
  char *cmdline;
};

struct OVERLAY_CLIP
{
  // x1
  signed int x1;
  // x2
  signed int x2;
  // y1
  signed int y1;
  // y2
  signed int y2;
};

struct STRTAB
{
  // nr
  signed long int nr;
  // str
  const char *str;
};

struct WAVEHDR
{
  // chkRiff
  struct CHUNKHDR chkRiff;
  // fccWave
  unsigned int fccWave;
  // chkFmt
  struct CHUNKHDR chkFmt;
  // wFormatTag
  unsigned short int wFormatTag;
  // nChannels
  unsigned short int nChannels;
  // nSamplesPerSec
  unsigned int nSamplesPerSec;
  // nAvgBytesPerSec
  unsigned int nAvgBytesPerSec;
  // nBlockAlign
  unsigned short int nBlockAlign;
  // wBitsPerSample
  unsigned short int wBitsPerSample;
  // chkData
  struct CHUNKHDR chkData;
};

struct WEBCAM
{
  // lock
  union anonymous$14 lock;
  // wait
  union anonymous$80 wait;
  // filename
  char *filename;
  // buf
  struct ng_video_buf *buf;
};

struct _FcFontSet
{
  // nfont
  signed int nfont;
  // sfont
  signed int sfont;
  // fonts
  struct _FcPattern **fonts;
};

struct _FcObjectSet
{
  // nobject
  signed int nobject;
  // sobject
  signed int sobject;
  // objects
  const char **objects;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

union _XEvent
{
  // type
  signed int type;
  // xany
  struct anonymous$57 xany;
  // xkey
  struct anonymous$39 xkey;
  // xbutton
  struct anonymous$40 xbutton;
  // xmotion
  struct anonymous$41 xmotion;
  // xcrossing
  struct anonymous$42 xcrossing;
  // xfocus
  struct anonymous$48 xfocus;
  // xexpose
  struct anonymous$50 xexpose;
  // xgraphicsexpose
  struct anonymous$51 xgraphicsexpose;
  // xnoexpose
  struct anonymous$52 xnoexpose;
  // xvisibility
  struct anonymous$53 xvisibility;
  // xcreatewindow
  struct anonymous$54 xcreatewindow;
  // xdestroywindow
  struct anonymous$55 xdestroywindow;
  // xunmap
  struct anonymous$56 xunmap;
  // xmap
  struct anonymous$58 xmap;
  // xmaprequest
  struct anonymous$59 xmaprequest;
  // xreparent
  struct anonymous$60 xreparent;
  // xconfigure
  struct anonymous$61 xconfigure;
  // xgravity
  struct anonymous$62 xgravity;
  // xresizerequest
  struct anonymous$63 xresizerequest;
  // xconfigurerequest
  struct anonymous$64 xconfigurerequest;
  // xcirculate
  struct anonymous$65 xcirculate;
  // xcirculaterequest
  struct anonymous$66 xcirculaterequest;
  // xproperty
  struct anonymous$67 xproperty;
  // xselectionclear
  struct anonymous$68 xselectionclear;
  // xselectionrequest
  struct anonymous$69 xselectionrequest;
  // xselection
  struct anonymous$70 xselection;
  // xcolormap
  struct anonymous$71 xcolormap;
  // xclient
  struct anonymous$72 xclient;
  // xmapping
  struct anonymous$73 xmapping;
  // xerror
  struct anonymous$74 xerror;
  // xkeymap
  struct anonymous$49 xkeymap;
  // xgeneric
  struct anonymous$75 xgeneric;
  // xcookie
  struct anonymous$76 xcookie;
  // pad
  signed long int pad[24l];
};

struct _XExtData
{
  // number
  signed int number;
  // next
  struct _XExtData *next;
  // free_private
  signed int (*free_private)(struct _XExtData *);
  // private_data
  char *private_data;
};

struct funcs
{
  // create_image
  struct _XImage * (*create_image)(struct _XDisplay *, struct anonymous$90 *, unsigned int, signed int, signed int, char *, unsigned int, unsigned int, signed int, signed int);
  // destroy_image
  signed int (*destroy_image)(struct _XImage *);
  // get_pixel
  unsigned long int (*get_pixel)(struct _XImage *, signed int, signed int);
  // put_pixel
  signed int (*put_pixel)(struct _XImage *, signed int, signed int, unsigned long int);
  // sub_image
  struct _XImage * (*sub_image)(struct _XImage *, signed int, signed int, unsigned int, unsigned int);
  // add_pixel
  signed int (*add_pixel)(struct _XImage *, signed long int);
};

struct _XImage
{
  // width
  signed int width;
  // height
  signed int height;
  // xoffset
  signed int xoffset;
  // format
  signed int format;
  // data
  char *data;
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // bitmap_pad
  signed int bitmap_pad;
  // depth
  signed int depth;
  // bytes_per_line
  signed int bytes_per_line;
  // bits_per_pixel
  signed int bits_per_pixel;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // obdata
  char *obdata;
  // f
  struct funcs f;
};

struct _XftColor
{
  // pixel
  unsigned long int pixel;
  // color
  struct anonymous$97 color;
};

struct _XftFont
{
  // ascent
  signed int ascent;
  // descent
  signed int descent;
  // height
  signed int height;
  // max_advance_width
  signed int max_advance_width;
  // charset
  struct _FcCharSet *charset;
  // pattern
  struct _FcPattern *pattern;
};

struct _XtActionsRec
{
  // string
  char *string;
  // proc
  void (*proc)(struct _WidgetRec *, union _XEvent *, char **, unsigned int *);
};

struct _XtResource
{
  // resource_name
  char *resource_name;
  // resource_class
  char *resource_class;
  // resource_type
  char *resource_type;
  // resource_size
  unsigned int resource_size;
  // resource_offset
  unsigned int resource_offset;
  // default_type
  char *default_type;
  // default_addr
  void *default_addr;
};

struct __jmp_buf_tag
{
  // __jmpbuf
  signed long int __jmpbuf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
  // __saved_mask
  struct anonymous$16 __saved_mask;
};

struct vbi_bit_slicer
{
  // func
  signed int (*func)(struct vbi_bit_slicer *, unsigned char *, unsigned char *);
  // cri
  unsigned int cri;
  // cri_mask
  unsigned int cri_mask;
  // thresh
  signed int thresh;
  // cri_bytes
  signed int cri_bytes;
  // cri_rate
  signed int cri_rate;
  // oversampling_rate
  signed int oversampling_rate;
  // phase_shift
  signed int phase_shift;
  // step
  signed int step;
  // frc
  unsigned int frc;
  // frc_bits
  signed int frc_bits;
  // payload
  signed int payload;
  // endian
  signed int endian;
  // skip
  signed int skip;
};

struct _vbi_raw_decoder_job
{
  // id
  unsigned int id;
  // offset
  signed int offset;
  // slicer
  struct vbi_bit_slicer slicer;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct event_entry
{
  // event
  char event[128l];
  // action
  char action[128l];
  // argbuf
  char argbuf[128l];
  // argc
  signed int argc;
  // argv
  char *argv[16l];
  // next
  struct event_entry *next;
};

struct fb_bitfield
{
  // offset
  unsigned int offset;
  // length
  unsigned int length;
  // msb_right
  unsigned int msb_right;
};

struct fb_cmap
{
  // start
  unsigned int start;
  // len
  unsigned int len;
  // red
  unsigned short int *red;
  // green
  unsigned short int *green;
  // blue
  unsigned short int *blue;
  // transp
  unsigned short int *transp;
};

struct fb_con2fbmap
{
  // console
  unsigned int console;
  // framebuffer
  unsigned int framebuffer;
};

struct fb_fix_screeninfo
{
  // id
  char id[16l];
  // smem_start
  unsigned long int smem_start;
  // smem_len
  unsigned int smem_len;
  // type
  unsigned int type;
  // type_aux
  unsigned int type_aux;
  // visual
  unsigned int visual;
  // xpanstep
  unsigned short int xpanstep;
  // ypanstep
  unsigned short int ypanstep;
  // ywrapstep
  unsigned short int ywrapstep;
  // line_length
  unsigned int line_length;
  // mmio_start
  unsigned long int mmio_start;
  // mmio_len
  unsigned int mmio_len;
  // accel
  unsigned int accel;
  // capabilities
  unsigned short int capabilities;
  // reserved
  unsigned short int reserved[2l];
};

struct fb_var_screeninfo
{
  // xres
  unsigned int xres;
  // yres
  unsigned int yres;
  // xres_virtual
  unsigned int xres_virtual;
  // yres_virtual
  unsigned int yres_virtual;
  // xoffset
  unsigned int xoffset;
  // yoffset
  unsigned int yoffset;
  // bits_per_pixel
  unsigned int bits_per_pixel;
  // grayscale
  unsigned int grayscale;
  // red
  struct fb_bitfield red;
  // green
  struct fb_bitfield green;
  // blue
  struct fb_bitfield blue;
  // transp
  struct fb_bitfield transp;
  // nonstd
  unsigned int nonstd;
  // activate
  unsigned int activate;
  // height
  unsigned int height;
  // width
  unsigned int width;
  // accel_flags
  unsigned int accel_flags;
  // pixclock
  unsigned int pixclock;
  // left_margin
  unsigned int left_margin;
  // right_margin
  unsigned int right_margin;
  // upper_margin
  unsigned int upper_margin;
  // lower_margin
  unsigned int lower_margin;
  // hsync_len
  unsigned int hsync_len;
  // vsync_len
  unsigned int vsync_len;
  // sync
  unsigned int sync;
  // vmode
  unsigned int vmode;
  // rotate
  unsigned int rotate;
  // colorspace
  unsigned int colorspace;
  // reserved
  unsigned int reserved[4l];
};

struct ng_video_fmt
{
  // fmtid
  unsigned int fmtid;
  // width
  unsigned int width;
  // height
  unsigned int height;
  // bytesperline
  unsigned int bytesperline;
};

struct ng_audio_fmt
{
  // fmtid
  unsigned int fmtid;
  // rate
  unsigned int rate;
};

struct files_handle
{
  // file
  char file[4096l];
  // video
  struct ng_video_fmt video;
  // audio
  struct ng_audio_fmt audio;
  // wav_fd
  signed int wav_fd;
  // wav_header
  struct WAVEHDR wav_header;
  // wav_size
  signed int wav_size;
  // gotcha
  signed int gotcha;
};

struct in6_addr
{
  // __in6_u
  union anonymous$93 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct jpeg_common_struct
{
  // err
  struct jpeg_error_mgr *err;
  // mem
  struct jpeg_memory_mgr *mem;
  // progress
  struct jpeg_progress_mgr *progress;
  // client_data
  void *client_data;
  // is_decompressor
  signed int is_decompressor;
  // global_state
  signed int global_state;
};

struct jpeg_compress_struct
{
  // err
  struct jpeg_error_mgr *err;
  // mem
  struct jpeg_memory_mgr *mem;
  // progress
  struct jpeg_progress_mgr *progress;
  // client_data
  void *client_data;
  // is_decompressor
  signed int is_decompressor;
  // global_state
  signed int global_state;
  // dest
  struct jpeg_destination_mgr *dest;
  // image_width
  unsigned int image_width;
  // image_height
  unsigned int image_height;
  // input_components
  signed int input_components;
  // in_color_space
  enum anonymous$5 in_color_space;
  // input_gamma
  double input_gamma;
  // data_precision
  signed int data_precision;
  // num_components
  signed int num_components;
  // jpeg_color_space
  enum anonymous$5 jpeg_color_space;
  // comp_info
  struct anonymous$6 *comp_info;
  // quant_tbl_ptrs
  struct anonymous$7 *quant_tbl_ptrs[4l];
  // dc_huff_tbl_ptrs
  struct anonymous$8 *dc_huff_tbl_ptrs[4l];
  // ac_huff_tbl_ptrs
  struct anonymous$8 *ac_huff_tbl_ptrs[4l];
  // arith_dc_L
  unsigned char arith_dc_L[16l];
  // arith_dc_U
  unsigned char arith_dc_U[16l];
  // arith_ac_K
  unsigned char arith_ac_K[16l];
  // num_scans
  signed int num_scans;
  // scan_info
  const struct anonymous$9 *scan_info;
  // raw_data_in
  signed int raw_data_in;
  // arith_code
  signed int arith_code;
  // optimize_coding
  signed int optimize_coding;
  // CCIR601_sampling
  signed int CCIR601_sampling;
  // smoothing_factor
  signed int smoothing_factor;
  // dct_method
  enum anonymous$10 dct_method;
  // restart_interval
  unsigned int restart_interval;
  // restart_in_rows
  signed int restart_in_rows;
  // write_JFIF_header
  signed int write_JFIF_header;
  // JFIF_major_version
  unsigned char JFIF_major_version;
  // JFIF_minor_version
  unsigned char JFIF_minor_version;
  // density_unit
  unsigned char density_unit;
  // X_density
  unsigned short int X_density;
  // Y_density
  unsigned short int Y_density;
  // write_Adobe_marker
  signed int write_Adobe_marker;
  // next_scanline
  unsigned int next_scanline;
  // progressive_mode
  signed int progressive_mode;
  // max_h_samp_factor
  signed int max_h_samp_factor;
  // max_v_samp_factor
  signed int max_v_samp_factor;
  // total_iMCU_rows
  unsigned int total_iMCU_rows;
  // comps_in_scan
  signed int comps_in_scan;
  // cur_comp_info
  struct anonymous$6 *cur_comp_info[4l];
  // MCUs_per_row
  unsigned int MCUs_per_row;
  // MCU_rows_in_scan
  unsigned int MCU_rows_in_scan;
  // blocks_in_MCU
  signed int blocks_in_MCU;
  // MCU_membership
  signed int MCU_membership[10l];
  // Ss
  signed int Ss;
  // Se
  signed int Se;
  // Ah
  signed int Ah;
  // Al
  signed int Al;
  // master
  struct jpeg_comp_master *master;
  // main
  struct jpeg_c_main_controller *main;
  // prep
  struct jpeg_c_prep_controller *prep;
  // coef
  struct jpeg_c_coef_controller *coef;
  // marker
  struct jpeg_marker_writer *marker;
  // cconvert
  struct jpeg_color_converter *cconvert;
  // downsample
  struct jpeg_downsampler *downsample;
  // fdct
  struct jpeg_forward_dct *fdct;
  // entropy
  struct jpeg_entropy_encoder *entropy;
  // script_space
  struct anonymous$9 *script_space;
  // script_space_size
  signed int script_space_size;
};

struct jpeg_destination_mgr
{
  // next_output_byte
  unsigned char *next_output_byte;
  // free_in_buffer
  unsigned long int free_in_buffer;
  // init_destination
  void (*init_destination)(struct jpeg_compress_struct *);
  // empty_output_buffer
  signed int (*empty_output_buffer)(struct jpeg_compress_struct *);
  // term_destination
  void (*term_destination)(struct jpeg_compress_struct *);
};

struct jpeg_error_mgr
{
  // error_exit
  void (*error_exit)(struct jpeg_common_struct *);
  // emit_message
  void (*emit_message)(struct jpeg_common_struct *, signed int);
  // output_message
  void (*output_message)(struct jpeg_common_struct *);
  // format_message
  void (*format_message)(struct jpeg_common_struct *, char *);
  // reset_error_mgr
  void (*reset_error_mgr)(struct jpeg_common_struct *);
  // msg_code
  signed int msg_code;
  // msg_parm
  union anonymous$11 msg_parm;
  // trace_level
  signed int trace_level;
  // num_warnings
  signed long int num_warnings;
  // jpeg_message_table
  const char * const *jpeg_message_table;
  // last_jpeg_message
  signed int last_jpeg_message;
  // addon_message_table
  const char * const *addon_message_table;
  // first_addon_message
  signed int first_addon_message;
  // last_addon_message
  signed int last_addon_message;
};

struct jpeg_memory_mgr
{
  // alloc_small
  void * (*alloc_small)(struct jpeg_common_struct *, signed int, unsigned long int);
  // alloc_large
  void * (*alloc_large)(struct jpeg_common_struct *, signed int, unsigned long int);
  // alloc_sarray
  unsigned char ** (*alloc_sarray)(struct jpeg_common_struct *, signed int, unsigned int, unsigned int);
  // alloc_barray
  signed short int (**(*alloc_barray)(struct jpeg_common_struct *, signed int, unsigned int, unsigned int))[64l];
  // request_virt_sarray
  struct jvirt_sarray_control * (*request_virt_sarray)(struct jpeg_common_struct *, signed int, signed int, unsigned int, unsigned int, unsigned int);
  // request_virt_barray
  struct jvirt_barray_control * (*request_virt_barray)(struct jpeg_common_struct *, signed int, signed int, unsigned int, unsigned int, unsigned int);
  // realize_virt_arrays
  void (*realize_virt_arrays)(struct jpeg_common_struct *);
  // access_virt_sarray
  unsigned char ** (*access_virt_sarray)(struct jpeg_common_struct *, struct jvirt_sarray_control *, unsigned int, unsigned int, signed int);
  // access_virt_barray
  signed short int (**(*access_virt_barray)(struct jpeg_common_struct *, struct jvirt_barray_control *, unsigned int, unsigned int, signed int))[64l];
  // free_pool
  void (*free_pool)(struct jpeg_common_struct *, signed int);
  // self_destruct
  void (*self_destruct)(struct jpeg_common_struct *);
  // max_memory_to_use
  signed long int max_memory_to_use;
  // max_alloc_chunk
  signed long int max_alloc_chunk;
};

struct jpeg_progress_mgr
{
  // progress_monitor
  void (*progress_monitor)(struct jpeg_common_struct *);
  // pass_counter
  signed long int pass_counter;
  // pass_limit
  signed long int pass_limit;
  // completed_passes
  signed int completed_passes;
  // total_passes
  signed int total_passes;
};

struct list_head
{
  // next
  struct list_head *next;
  // prev
  struct list_head *prev;
};

struct media_device_entry
{
  // device
  char *device;
  // node
  char *node;
  // type
  enum device_type type;
  // bus
  enum bus_type bus;
  // major
  unsigned int major;
  // minor
  unsigned int minor;
};

struct media_devices
{
  // md_entry
  struct media_device_entry *md_entry;
  // md_size
  unsigned int md_size;
};

struct ng_convthread_handle
{
  // c
  struct ng_convert_handle *c;
  // in
  struct FIFO *in;
  // out
  struct FIFO *out;
};

struct movie_handle
{
  // lock
  union anonymous$14 lock;
  // writer
  struct ng_writer *writer;
  // handle
  void *handle;
  // tflush
  unsigned long int tflush;
  // start
  unsigned long int start;
  // rts
  unsigned long int rts;
  // stopby
  unsigned long int stopby;
  // slots
  signed int slots;
  // vfmt
  struct ng_video_fmt vfmt;
  // fps
  signed int fps;
  // frames
  signed int frames;
  // seq
  signed int seq;
  // vfifo
  struct FIFO vfifo;
  // tvideo
  unsigned long int tvideo;
  // vts
  unsigned long int vts;
  // cfifo
  struct FIFO cfifo;
  // cthreads
  signed int cthreads;
  // hconv
  struct ng_convthread_handle *hconv[4l];
  // tconv
  unsigned long int tconv[4l];
  // dsp
  struct ng_dsp_driver *dsp;
  // hdsp
  void *hdsp;
  // afmt
  struct ng_audio_fmt afmt;
  // bytes_per_sec
  unsigned long int bytes_per_sec;
  // bytes
  unsigned long int bytes;
  // afifo
  struct FIFO afifo;
  // taudio
  unsigned long int taudio;
  // raudio
  unsigned long int raudio;
  // ats
  unsigned long int ats;
  // rdrift
  unsigned long int rdrift;
  // vdrift
  unsigned long int vdrift;
};

struct ng_attribute
{
  // id
  signed int id;
  // name
  const char *name;
  // type
  signed int type;
  // defval
  signed int defval;
  // choices
  struct STRTAB *choices;
  // min
  signed int min;
  // max
  signed int max;
  // points
  signed int points;
  // priv
  const void *priv;
  // handle
  void *handle;
  // read
  signed int (*read)(struct ng_attribute *);
  // write
  void (*write)(struct ng_attribute *, signed int);
};

struct ng_audio_buf
{
  // fmt
  struct ng_audio_fmt fmt;
  // size
  signed int size;
  // written
  signed int written;
  // data
  char *data;
  // info
  struct anonymous$84 info;
};

struct ng_audio_conv
{
  // fmtid_in
  unsigned int fmtid_in;
  // fmtid_out
  unsigned int fmtid_out;
  // init
  void * (*init)(void *);
  // frame
  struct ng_audio_buf * (*frame)(void *, struct ng_audio_buf *);
  // fini
  void (*fini)(void *);
  // priv
  void *priv;
  // list
  struct list_head list;
};

struct ng_convert_handle
{
  // ifmt
  struct ng_video_fmt ifmt;
  // ofmt
  struct ng_video_fmt ofmt;
  // isize
  signed int isize;
  // osize
  signed int osize;
  // conv
  struct ng_video_conv *conv;
  // chandle
  void *chandle;
};

struct ng_device_config
{
  // video
  char *video;
  // driver
  char *driver;
  // radio
  char *radio;
  // vbi
  char *vbi;
  // dsp
  char *dsp;
  // mixer
  char *mixer;
  // video_scan
  char *video_scan[32l];
  // mixer_scan
  char *mixer_scan[32l];
};

struct ng_devinfo
{
  // device
  char device[32l];
  // name
  char name[64l];
  // flags
  signed int flags;
};

struct ng_dsp_driver
{
  // name
  const char *name;
  // open
  void * (*open)(char *, struct ng_audio_fmt *, signed int);
  // close
  void (*close)(void *);
  // fd
  signed int (*fd)(void *);
  // startrec
  signed int (*startrec)(void *);
  // read
  struct ng_audio_buf * (*read)(void *, signed long int);
  // write
  struct ng_audio_buf * (*write)(void *, struct ng_audio_buf *);
  // latency
  signed long int (*latency)(void *);
  // list
  struct list_head list;
};

struct ng_filter
{
  // name
  char *name;
  // fmts
  signed int fmts;
  // attrs
  struct ng_attribute *attrs;
  // init
  void * (*init)(struct ng_video_fmt *);
  // frame
  struct ng_video_buf * (*frame)(void *, struct ng_video_buf *);
  // fini
  void (*fini)(void *);
  // list
  struct list_head list;
};

struct ng_format_list
{
  // name
  char *name;
  // desc
  char *desc;
  // ext
  char *ext;
  // fmtid
  unsigned int fmtid;
  // priv
  void *priv;
};

struct ng_mix_driver
{
  // name
  const char *name;
  // probe
  struct ng_devinfo * (*probe)(void);
  // channels
  struct ng_devinfo * (*channels)(char *);
  // open
  void * (*open)(char *);
  // volctl
  struct ng_attribute * (*volctl)(void *, char *);
  // close
  void (*close)(void *);
  // list
  struct list_head list;
};

struct ng_reader
{
  // name
  const char *name;
  // desc
  const char *desc;
  // magic
  char *magic[4l];
  // moff
  signed int moff[4l];
  // mlen
  signed int mlen[4l];
  // rd_open
  void * (*rd_open)(char *);
  // rd_vfmt
  struct ng_video_fmt * (*rd_vfmt)(void *, signed int *, signed int);
  // rd_afmt
  struct ng_audio_fmt * (*rd_afmt)(void *);
  // rd_vdata
  struct ng_video_buf * (*rd_vdata)(void *, unsigned int);
  // rd_adata
  struct ng_audio_buf * (*rd_adata)(void *);
  // frame_time
  signed long int (*frame_time)(void *);
  // rd_close
  signed int (*rd_close)(void *);
  // list
  struct list_head list;
};

struct ng_vid_driver
{
  // name
  const char *name;
  // open
  void * (*open)(char *, signed int);
  // close
  signed int (*close)(void *);
  // get_devname
  char * (*get_devname)(void *);
  // capabilities
  signed int (*capabilities)(void *);
  // list_attrs
  struct ng_attribute * (*list_attrs)(void *);
  // get_min_size
  void (*get_min_size)(void *, signed int *, signed int *);
  // setupfb
  signed int (*setupfb)(void *, struct ng_video_fmt *, void *);
  // overlay
  signed int (*overlay)(void *, struct ng_video_fmt *, signed int, signed int, struct OVERLAY_CLIP *, signed int, signed int);
  // setformat
  signed int (*setformat)(void *, struct ng_video_fmt *);
  // startvideo
  signed int (*startvideo)(void *, signed int, unsigned int);
  // stopvideo
  void (*stopvideo)(void *);
  // nextframe
  struct ng_video_buf * (*nextframe)(void *);
  // getimage
  struct ng_video_buf * (*getimage)(void *);
  // getfreq
  unsigned long int (*getfreq)(void *);
  // setfreq
  void (*setfreq)(void *, unsigned long int);
  // is_tuned
  signed int (*is_tuned)(void *);
  // list
  struct list_head list;
};

struct ng_video_buf
{
  // fmt
  struct ng_video_fmt fmt;
  // size
  unsigned long int size;
  // data
  unsigned char *data;
  // info
  struct anonymous$78 info;
  // lock
  union anonymous$14 lock;
  // cond
  union anonymous$80 cond;
  // refcount
  signed int refcount;
  // release
  void (*release)(struct ng_video_buf *);
  // priv
  void *priv;
};

struct ng_video_conv
{
  // fmtid_in
  unsigned int fmtid_in;
  // fmtid_out
  unsigned int fmtid_out;
  // init
  void * (*init)(struct ng_video_fmt *, void *);
  // frame
  void (*frame)(void *, struct ng_video_buf *, struct ng_video_buf *);
  // fini
  void (*fini)(void *);
  // priv
  void *priv;
  // list
  struct list_head list;
};

struct ng_writer
{
  // name
  const char *name;
  // desc
  const char *desc;
  // video
  struct ng_format_list *video;
  // audio
  struct ng_format_list *audio;
  // combined
  const signed int combined;
  // wr_open
  void * (*wr_open)(char *, char *, struct ng_video_fmt *, const void *, signed int, struct ng_audio_fmt *, const void *);
  // wr_video
  signed int (*wr_video)(void *, struct ng_video_buf *);
  // wr_audio
  signed int (*wr_audio)(void *, struct ng_audio_buf *);
  // wr_close
  signed int (*wr_close)(void *);
  // list
  struct list_head list;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct raw_handle
{
  // video
  struct ng_video_fmt video;
  // audio
  struct ng_audio_fmt audio;
  // vpriv
  struct raw_priv *vpriv;
  // fd
  signed int fd;
  // wav_fd
  signed int wav_fd;
  // wav_header
  struct WAVEHDR wav_header;
  // wav_size
  signed int wav_size;
};

struct raw_priv
{
  // yuv4mpeg
  signed int yuv4mpeg;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous$22 __sigaction_handler;
  // sa_mask
  struct anonymous$16 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct termios
{
  // c_iflag
  unsigned int c_iflag;
  // c_oflag
  unsigned int c_oflag;
  // c_cflag
  unsigned int c_cflag;
  // c_lflag
  unsigned int c_lflag;
  // c_line
  unsigned char c_line;
  // c_cc
  unsigned char c_cc[32l];
  // c_ispeed
  unsigned int c_ispeed;
  // c_ospeed
  unsigned int c_ospeed;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct vbi_char
{
  // underline
  unsigned int underline : 1;
  // bold
  unsigned int bold : 1;
  // italic
  unsigned int italic : 1;
  // flash
  unsigned int flash : 1;
  // conceal
  unsigned int conceal : 1;
  // proportional
  unsigned int proportional : 1;
  // link
  unsigned int link : 1;
  // reserved
  unsigned int reserved : 1;
  // size
  unsigned int size : 8;
  // opacity
  unsigned int opacity : 8;
  // foreground
  unsigned int foreground : 8;
  // background
  unsigned int background : 8;
  // drcs_clut_offs
  unsigned int drcs_clut_offs : 8;
  // unicode
  unsigned int unicode : 16;
};

struct vbi_event
{
  // type
  signed int type;
  // ev
  union anonymous$19 ev;
};

struct vbi_font
{
  // label
  char *label;
  // xlfd1
  char *xlfd1;
  // xlfd2
  char *xlfd2;
};

struct vbi_link
{
  // type
  enum anonymous$17 type;
  // eacem
  signed int eacem;
  // name
  signed char name[80l];
  // url
  signed char url[256l];
  // script
  signed char script[256l];
  // nuid
  unsigned int nuid;
  // pgno
  signed int pgno;
  // subno
  signed int subno;
  // expires
  double expires;
  // itv_type
  enum anonymous$18 itv_type;
  // priority
  signed int priority;
  // autoload
  signed int autoload;
};

struct vbi_page
{
  // vbi
  struct vbi_decoder *vbi;
  // nuid
  unsigned int nuid;
  // pgno
  signed int pgno;
  // subno
  signed int subno;
  // rows
  signed int rows;
  // columns
  signed int columns;
  // text
  struct vbi_char text[1056l];
  // dirty
  struct anonymous$101 dirty;
  // screen_color
  enum anonymous$102 screen_color;
  // screen_opacity
  enum anonymous$103 screen_opacity;
  // color_map
  unsigned int color_map[40l];
  // drcs_clut
  unsigned char *drcs_clut;
  // drcs
  unsigned char *drcs[32l];
  // nav_link
  struct anonymous$104 nav_link[6l];
  // nav_index
  char nav_index[64l];
  // font
  struct vbi_font_descr *font[2l];
  // double_height_lower
  unsigned int double_height_lower;
  // page_opacity
  enum anonymous$103 page_opacity[2l];
  // boxed_opacity
  enum anonymous$103 boxed_opacity[2l];
};

struct vbi_program_info
{
  // future
  unsigned int future : 1;
  // month
  signed char month;
  // day
  signed char day;
  // hour
  signed char hour;
  // min
  signed char min;
  // tape_delayed
  signed char tape_delayed;
  // length_hour
  signed char length_hour;
  // length_min
  signed char length_min;
  // elapsed_hour
  signed char elapsed_hour;
  // elapsed_min
  signed char elapsed_min;
  // elapsed_sec
  signed char elapsed_sec;
  // title
  signed char title[64l];
  // type_classf
  enum anonymous$25 type_classf;
  // type_id
  signed int type_id[33l];
  // rating_auth
  enum anonymous$26 rating_auth;
  // rating_id
  signed int rating_id;
  // rating_dlsv
  signed int rating_dlsv;
  // audio
  struct anonymous$30 audio[2l];
  // caption_services
  signed int caption_services;
  // caption_language
  unsigned char *caption_language[8l];
  // cgms_a
  signed int cgms_a;
  // aspect
  struct anonymous$34 aspect;
  // description
  signed char description[8l][33l];
};

struct vbi_raw_decoder
{
  // scanning
  signed int scanning;
  // sampling_format
  enum anonymous$13 sampling_format;
  // sampling_rate
  signed int sampling_rate;
  // bytes_per_line
  signed int bytes_per_line;
  // offset
  signed int offset;
  // start
  signed int start[2l];
  // count
  signed int count[2l];
  // interlaced
  signed int interlaced;
  // synchronous
  signed int synchronous;
  // mutex
  union anonymous$14 mutex;
  // services
  unsigned int services;
  // num_jobs
  signed int num_jobs;
  // pattern
  signed char *pattern;
  // jobs
  struct _vbi_raw_decoder_job jobs[8l];
};

struct vbi_rect
{
  // x1
  signed int x1;
  // x2
  signed int x2;
  // y1
  signed int y1;
  // y2
  signed int y2;
};

struct vbi_selection
{
  // list
  struct list_head list;
  // atom
  unsigned long int atom;
  // pg
  struct vbi_page pg;
  // rect
  struct vbi_rect rect;
  // pix
  unsigned long int pix;
};

struct vbi_state
{
  // dec
  struct vbi_decoder *dec;
  // cap
  struct vbi_capture *cap;
  // par
  struct vbi_raw_decoder *par;
  // sliced
  struct anonymous$15 *sliced;
  // raw
  unsigned char *raw;
  // err
  char *err;
  // lines
  signed int lines;
  // fd
  signed int fd;
  // sim
  signed int sim;
  // debug
  signed int debug;
  // ts
  double ts;
  // tv
  struct timeval tv;
};

struct vbi_tty
{
  // vbi
  struct vbi_state *vbi;
  // pg
  struct vbi_page pg;
  // pgno
  signed int pgno;
  // subno
  signed int subno;
  // newpage
  signed int newpage;
};

struct vbi_window
{
  // shell
  struct _WidgetRec *shell;
  // tt
  struct _WidgetRec *tt;
  // subbtn
  struct _WidgetRec *subbtn;
  // submenu
  struct _WidgetRec *submenu;
  // savebox
  struct _WidgetRec *savebox;
  // cmap
  unsigned long int cmap;
  // gc
  struct _XGC *gc;
  // font1
  struct anonymous$100 *font1;
  // font2
  struct anonymous$100 *font2;
  // w
  signed int w;
  // a
  signed int a;
  // d
  signed int d;
  // h
  signed int h;
  // colors
  unsigned long int colors[8l];
  // xft_font
  struct _XftFont *xft_font;
  // xft_color
  struct _XftColor xft_color[8l];
  // vbi
  struct vbi_state *vbi;
  // pg
  struct vbi_page pg;
  // pgno
  signed int pgno;
  // subno
  signed int subno;
  // charset
  char *charset;
  // newpage
  signed int newpage;
  // down
  unsigned long int down;
  // s
  struct vbi_rect s;
  // selections
  struct list_head selections;
};

struct vt_mode
{
  // mode
  char mode;
  // waitv
  char waitv;
  // relsig
  signed short int relsig;
  // acqsig
  signed short int acqsig;
  // frsig
  signed short int frsig;
};

struct vt_stat
{
  // v_active
  unsigned short int v_active;
  // v_signal
  unsigned short int v_signal;
  // v_state
  unsigned short int v_state;
};

struct winsize
{
  // ws_row
  unsigned short int ws_row;
  // ws_col
  unsigned short int ws_col;
  // ws_xpixel
  unsigned short int ws_xpixel;
  // ws_ypixel
  unsigned short int ws_ypixel;
};


// MIME_IMAGE_JPEG
// file x11/atoms.c line 46
unsigned long int MIME_IMAGE_JPEG;
// MIME_IMAGE_PPM
// file x11/atoms.c line 45
unsigned long int MIME_IMAGE_PPM;
// MIME_TEXT_ISO8859_1
// file x11/atoms.c line 42
unsigned long int MIME_TEXT_ISO8859_1;
// MIME_TEXT_URI_LIST
// file x11/atoms.c line 48
unsigned long int MIME_TEXT_URI_LIST;
// MIME_TEXT_UTF_8
// file x11/atoms.c line 43
unsigned long int MIME_TEXT_UTF_8;
// WM_DELETE_WINDOW
// file x11/atoms.c line 7
unsigned long int WM_DELETE_WINDOW;
// WM_PROTOCOLS
// file x11/atoms.c line 6
unsigned long int WM_PROTOCOLS;
// XA_BACKGROUND
// file x11/atoms.c line 39
unsigned long int XA_BACKGROUND;
// XA_CLIPBOARD
// file x11/atoms.c line 34
unsigned long int XA_CLIPBOARD;
// XA_DEACTIVATE
// file x11/atoms.c line 22
unsigned long int XA_DEACTIVATE;
// XA_DONE
// file x11/atoms.c line 33
unsigned long int XA_DONE;
// XA_FILE
// file x11/atoms.c line 37
unsigned long int XA_FILE;
// XA_FILE_NAME
// file x11/atoms.c line 36
unsigned long int XA_FILE_NAME;
// XA_FOREGROUND
// file x11/atoms.c line 40
unsigned long int XA_FOREGROUND;
// XA_PIXEL
// file x11/atoms.c line 38
unsigned long int XA_PIXEL;
// XA_TARGETS
// file x11/atoms.c line 32
unsigned long int XA_TARGETS;
// XA_UTF8_STRING
// file x11/atoms.c line 35
unsigned long int XA_UTF8_STRING;
// XV_COLORKEY
// file x11/atoms.c line 55
unsigned long int XV_COLORKEY;
// XV_ENCODING
// file x11/atoms.c line 53
unsigned long int XV_ENCODING;
// XV_FREQ
// file x11/atoms.c line 54
unsigned long int XV_FREQ;
// XV_MUTE
// file x11/atoms.c line 52
unsigned long int XV_MUTE;
// XtShellStrings
// file /usr/include/X11/Shell.h line 189
extern const char XtShellStrings[];
// XtStrings
// file /usr/include/X11/StringDefs.h line 316
extern const char XtStrings[];
// _MOTIF_CLIPBOARD_TARGETS
// file x11/atoms.c line 25
unsigned long int _MOTIF_CLIPBOARD_TARGETS;
// _MOTIF_DEFERRED_CLIPBOARD_TARGETS
// file x11/atoms.c line 26
unsigned long int _MOTIF_DEFERRED_CLIPBOARD_TARGETS;
// _MOTIF_DROP
// file x11/atoms.c line 28
unsigned long int _MOTIF_DROP;
// _MOTIF_EXPORT_TARGETS
// file x11/atoms.c line 29
unsigned long int _MOTIF_EXPORT_TARGETS;
// _MOTIF_LOSE_SELECTION
// file x11/atoms.c line 30
unsigned long int _MOTIF_LOSE_SELECTION;
// _MOTIF_SNAPSHOT
// file x11/atoms.c line 27
unsigned long int _MOTIF_SNAPSHOT;
// _NETSCAPE_URL
// file x11/atoms.c line 49
unsigned long int _NETSCAPE_URL;
// _NET_SUPPORTED
// file x11/atoms.c line 9
unsigned long int _NET_SUPPORTED;
// _NET_WM_STATE
// file x11/atoms.c line 10
unsigned long int _NET_WM_STATE;
// _NET_WM_STATE_ABOVE
// file x11/atoms.c line 12
unsigned long int _NET_WM_STATE_ABOVE;
// _NET_WM_STATE_FULLSCREEN
// file x11/atoms.c line 13
unsigned long int _NET_WM_STATE_FULLSCREEN;
// _NET_WM_STATE_STAYS_ON_TOP
// file x11/atoms.c line 11
unsigned long int _NET_WM_STATE_STAYS_ON_TOP;
// _WIN_LAYER
// file x11/atoms.c line 16
unsigned long int _WIN_LAYER;
// _WIN_PROTOCOLS
// file x11/atoms.c line 15
unsigned long int _WIN_PROTOCOLS;
// _WIN_SUPPORTING_WM_CHECK
// file x11/atoms.c line 14
unsigned long int _WIN_SUPPORTING_WM_CHECK;
// _XAWTV_REMOTE
// file x11/atoms.c line 20
unsigned long int _XAWTV_REMOTE;
// _XAWTV_STATION
// file x11/atoms.c line 19
unsigned long int _XAWTV_STATION;
// _XmStrings
// file /usr/include/Xm/XmStrDefs.h line 1375
extern char _XmStrings[];
// actionTable
// file x11/mtt.c line 125
static struct _XtActionsRec actionTable[1l];
// actionTable
// file x11/mtt.c line 125
static struct _XtActionsRec actionTable[1l] = { { .string="debug", .proc=debug_action } };
// alloc_count
// file common/channel.c line 66
signed int alloc_count = 0;
// app_context
// file x11/mtt.c line 51
struct _XtAppStruct *app_context;
// app_shell
// file x11/mtt.c line 52
struct _WidgetRec *app_shell;
// applicationShellWidgetClass
// file /usr/include/X11/Shell.h line 557
extern struct _WidgetClassRec *applicationShellWidgetClass;
// args
// file x11/mtt.c line 67
struct ARGS args;
// args_count
// file x11/mtt.c line 100
const signed int args_count = (const signed int)(unsigned int)(sizeof(struct _XtResource [5l]) /*240ul*/  / sizeof(struct _XtResource) /*48ul*/ );
// args_desc
// file x11/mtt.c line 69
struct _XtResource args_desc[5l];
// args_desc
// file x11/mtt.c line 69
struct _XtResource args_desc[5l] = { { .resource_name="device", .resource_class=(char *)&XtStrings[(signed long int)1416], .resource_type=(char *)&XtStrings[(signed long int)1797],
    .resource_size=(unsigned int)sizeof(char *) /*8ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->device - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"/dev/vbi0" },
    { .resource_name="help", .resource_class=(char *)&XtStrings[(signed long int)1497], .resource_type=(char *)&XtStrings[(signed long int)1718],
    .resource_size=(unsigned int)sizeof(signed int) /*4ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->help - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"0" },
    { .resource_name="tty", .resource_class=(char *)&XtStrings[(signed long int)1497], .resource_type=(char *)&XtStrings[(signed long int)1718],
    .resource_size=(unsigned int)sizeof(signed int) /*4ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->tty - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"0" },
    { .resource_name="debug", .resource_class=(char *)&XtStrings[(signed long int)1497], .resource_type=(char *)&XtStrings[(signed long int)1718],
    .resource_size=(unsigned int)sizeof(signed int) /*4ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->debug - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"0" },
    { .resource_name="sim", .resource_class=(char *)&XtStrings[(signed long int)1497], .resource_type=(char *)&XtStrings[(signed long int)1718],
    .resource_size=(unsigned int)sizeof(signed int) /*4ul*/ ,
    .resource_offset=(unsigned int)((char *)&((struct ARGS *)(void *)0)->sim - (char *)(void *)0),
    .default_type=(char *)&XtStrings[(signed long int)1797],
    .default_addr=(void *)"0" } };
// attr_notify
// file common/commands.c line 46
void (*attr_notify)(struct ng_attribute *, signed int);
// attrs
// file common/commands.c line 79
struct ng_attribute *attrs = (struct ng_attribute *)(void *)0;
// booltab
// file common/channel.c line 728
struct STRTAB booltab[7l] = { { .nr=(signed long int)0, .str="no" }, { .nr=(signed long int)0, .str="false" },
    { .nr=(signed long int)0, .str="off" }, { .nr=(signed long int)1, .str="yes" }, { .nr=(signed long int)1, .str="true" },
    { .nr=(signed long int)1, .str="on" }, { .nr=(signed long int)-1, .str=(const char *)(void *)0 } };
// c
// file common/parseconfig.c line 26
static struct CFG_SECTIONS *c;
// captab
// file common/channel.c line 170
struct STRTAB captab[11l] = { { .nr=(signed long int)9, .str="on" }, { .nr=(signed long int)9, .str="yes" }, { .nr=(signed long int)9, .str="true" },
    { .nr=(signed long int)0, .str="off" }, { .nr=(signed long int)0, .str="no" }, { .nr=(signed long int)0, .str="false" },
    { .nr=(signed long int)1, .str="over" },
    { .nr=(signed long int)1, .str="overlay" },
    { .nr=(signed long int)2, .str="grab" },
    { .nr=(signed long int)2, .str="grabdisplay" },
    { .nr=(signed long int)-1, .str=(const char *)(void *)0 } };
// caption_i
// file common/vbi-sim.c line 184
static unsigned int caption_i = (unsigned int)0;
// caption_text
// file common/vbi-sim.c line 185
static const unsigned char caption_text[34l] = { (const unsigned char)0x14, (const unsigned char)0x25, (const unsigned char)0x14, (const unsigned char)0x25, (const unsigned char)76, (const unsigned char)73, (const unsigned char)66, (const unsigned char)90, (const unsigned char)86, (const unsigned char)66, (const unsigned char)73, (const unsigned char)32, (const unsigned char)67, (const unsigned char)65, (const unsigned char)80, (const unsigned char)84, (const unsigned char)73, (const unsigned char)79, (const unsigned char)78, (const unsigned char)32, (const unsigned char)83, (const unsigned char)73, (const unsigned char)77, (const unsigned char)85, (const unsigned char)76, (const unsigned char)65, (const unsigned char)84, (const unsigned char)73, (const unsigned char)79, (const unsigned char)78, (const unsigned char)0x14, (const unsigned char)0x2D, (const unsigned char)0x14, (const unsigned char)0x2D };
// capture_get_hook
// file common/commands.c line 62
void (*capture_get_hook)(void);
// capture_rel_hook
// file common/commands.c line 63
void (*capture_rel_hook)(void);
// chanlist_names
// file common/frequencies.c line 17
struct STRTAB *chanlist_names;
// chanlists
// file common/frequencies.c line 16
struct CHANLISTS *chanlists;
// channel_switch_hook
// file common/commands.c line 54
void (*channel_switch_hook)(void);
// channels
// file common/channel.c line 64
struct CHANNEL **channels = (struct CHANNEL **)(void *)0;
// chantab
// file common/frequencies.c line 15
signed int chantab = -1;
// commands
// file common/commands.c line 113
static struct COMMANDS commands[29l];
// commands
// file common/commands.c line 113
static struct COMMANDS commands[29l] = { { .name="setstation", .min_args=0, .handler=setstation_handler },
    { .name="setchannel", .min_args=0, .handler=setchannel_handler },
    { .name="setfreq", .min_args=1, .handler=setchannel_handler },
    { .name="setfreqtab", .min_args=1, .handler=setfreqtab_handler },
    { .name="capture", .min_args=1, .handler=capture_handler },
    { .name="setnorm", .min_args=1, .handler=attr_handler },
    { .name="setinput", .min_args=1, .handler=attr_handler },
    { .name="setattr", .min_args=1, .handler=attr_handler },
    { .name="color", .min_args=0, .handler=attr_handler },
    { .name="hue", .min_args=0, .handler=attr_handler },
    { .name="bright", .min_args=0, .handler=attr_handler },
    { .name="contrast", .min_args=0, .handler=attr_handler },
    { .name="show", .min_args=0, .handler=show_handler },
    { .name="list", .min_args=0, .handler=list_handler },
    { .name="volume", .min_args=0, .handler=volume_handler },
    { .name="attr", .min_args=0, .handler=dattr_handler },
    { .name="snap", .min_args=0, .handler=snap_handler },
    { .name="webcam", .min_args=1, .handler=webcam_handler },
    { .name="movie", .min_args=1, .handler=movie_handler },
    { .name="fullscreen", .min_args=0, .handler=fullscreen_handler },
    { .name="msg", .min_args=1, .handler=msg_handler },
    { .name="message", .min_args=0, .handler=msg_handler },
    { .name="exit", .min_args=0, .handler=exit_handler },
    { .name="quit", .min_args=0, .handler=exit_handler },
    { .name="bye", .min_args=0, .handler=exit_handler },
    { .name="keypad", .min_args=1, .handler=keypad_handler },
    { .name="showtime", .min_args=0, .handler=showtime_handler },
    { .name="vdr", .min_args=1, .handler=vdr_handler },
    { .name=(char *)(void *)0, .min_args=0, .handler=(signed int (*)(char *, signed int, char **))(void *)0 } };
// conv_list
// file libng/color_packed.c line 174
static struct ng_video_conv conv_list[12l];
// conv_list
// file libng/color_packed.c line 174
static struct ng_video_conv conv_list[12l] = { { .fmtid_in=(unsigned int)5, .fmtid_out=(unsigned int)2, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)rgb15_be_gray, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)3, .fmtid_out=(unsigned int)2, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)rgb15_native_gray, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)3, .fmtid_out=(unsigned int)5, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)byteswap_short, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)5, .fmtid_out=(unsigned int)3, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)byteswap_short, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)4, .fmtid_out=(unsigned int)6, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)byteswap_short, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)6, .fmtid_out=(unsigned int)4, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)byteswap_short, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)7, .fmtid_out=(unsigned int)9, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)redblue_swap, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)9, .fmtid_out=(unsigned int)7, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)redblue_swap, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)10, .fmtid_out=(unsigned int)9, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)rgb32_to_rgb24, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)10, .fmtid_out=(unsigned int)7, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)rgb32_to_bgr24, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)7, .fmtid_out=(unsigned int)8, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)bgr24_to_bgr32, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)7, .fmtid_out=(unsigned int)10, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)bgr24_to_rgb32, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } } };
// conv_list$link1
// file libng/color_yuv2rgb.c line 384
static struct ng_video_conv conv_list$link1[6l];
// conv_list$link1
// file libng/color_yuv2rgb.c line 384
static struct ng_video_conv conv_list$link1[6l] = { { .fmtid_in=(unsigned int)13, .fmtid_out=(unsigned int)9, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)yuv422_to_rgb24, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)13, .fmtid_out=(unsigned int)2, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)yuv422_to_gray, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)14, .fmtid_out=(unsigned int)9, .init=ng_conv_nop_init,
    .frame=yuv422p_to_rgb24, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)15, .fmtid_out=(unsigned int)9, .init=ng_conv_nop_init,
    .frame=yuv420p_to_rgb24, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)14, .fmtid_out=(unsigned int)2, .init=ng_conv_nop_init,
    .frame=yuv42xp_to_gray, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)15, .fmtid_out=(unsigned int)2, .init=ng_conv_nop_init,
    .frame=yuv42xp_to_gray, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } } };
// count
// file common/channel.c line 65
signed int count = 0;
// cur_attrs
// file common/commands.c line 72
signed int cur_attrs[256l];
// cur_capture
// file common/channel.c line 72
signed int cur_capture = 0;
// cur_channel
// file common/channel.c line 68
signed int cur_channel = -1;
// cur_dattr
// file common/commands.c line 154
static signed int cur_dattr = 0;
// cur_filter
// file common/channel.c line 70
struct ng_filter *cur_filter;
// cur_fine
// file common/channel.c line 68
signed int cur_fine = 0;
// cur_freq
// file common/channel.c line 69
signed int cur_freq;
// cur_movie
// file common/commands.c line 72
signed int cur_movie;
// cur_sender
// file common/channel.c line 68
signed int cur_sender = -1;
// cur_tv_height
// file common/commands.c line 71
unsigned int cur_tv_height;
// cur_tv_width
// file common/commands.c line 71
unsigned int cur_tv_width;
// dattr
// file common/commands.c line 155
static signed int dattr[5l] = { 3, 7, 9, 6, 8 };
// debug
// file x11/mtt.c line 54
signed int debug;
// defaults
// file common/channel.c line 52
struct CHANNEL defaults = { .name="defaults", .key=((char *)NULL), .group="main",
    .midi=0, .cname=((char *)NULL), .channel=-1,
    .fine=0, .freq=0, .audio=-1, .capture=9,
    .input=0, .norm=0, .color=-1, .bright=-1,
    .hue=-1, .contrast=-1, .pixmap=0ul, .button=((struct _WidgetRec *)NULL) };
// devices
// file console/fbtools.c line 72
struct DEVS *devices;
// devs_default
// file console/fbtools.c line 62
struct DEVS devs_default = { .fb0="/dev/fb0", .fbnr="/dev/fb%d", .ttynr="/dev/tty%d" };
// devs_devfs
// file console/fbtools.c line 67
struct DEVS devs_devfs = { .fb0="/dev/fb/0", .fbnr="/dev/fb/%d", .ttynr="/dev/vc/%d" };
// display_message
// file common/commands.c line 36
void (*display_message)(char *);
// do_overlay
// file common/commands.c line 67
signed int do_overlay;
// dpy
// file x11/mtt.c line 53
struct _XDisplay *dpy;
// drv
// file common/commands.c line 75
struct ng_vid_driver *drv;
// event_builtin_list
// file common/event.c line 17
static struct event_entry *event_builtin_list;
// event_conf_list
// file common/event.c line 16
static struct event_entry *event_conf_list;
// exit_hook
// file common/commands.c line 61
void (*exit_hook)(void);
// exit_xpm
// file x11/xpm/exit.xpm line 2
static char *exit_xpm[20l] = { "16 16 3 1", " \tc gray77", ".\tc #000000000000", "X\tc #861782078617", "                ", "                ", "       ..       ", "       ..X      ", "    .  ..X .    ", "   ..X ..X ..   ", "  ..X  ..X  ..  ", "  ..X  ..X  ..X ", "  ..X  ..X  ..X ", "  ..X   XX  ..X ", "  ..X       ..X ", "   ..      ..XX ", "    ........XX  ", "     ......XX   ", "      XXXXXX    ", "                " };
// f_drv
// file common/commands.c line 77
signed int f_drv;
// fallback_ressources
// file x11/mtt.c line 56
static char *fallback_ressources[78l] = { "mtt.title:\t\t\t\tteletext test utility",
    "mtt.deleteResponse:\t\t\tDO_NOTHING", "", "*renderTable:", "*renderTable.fontType: FONT_IS_FONTSET",
    "*renderTable.fontName:  -misc-fixed-bold-r-normal--13-*-*-*-*-*-iso10646-1,  -misc-fixed-bold-r-normal--13-*-*-*-*-*-iso8859-*  -*-*-*-*--13-*-*-*-*-*-*-*,*",
    "", "mtt.form.*.leftAttachment:\t\tATTACH_FORM",
    "mtt.form.*.rightAttachment:\t\tATTACH_FORM",
    "mtt.form.tool.topAttachment:\t\tATTACH_WIDGET",
    "mtt.form.tool.topWidget:\t\tbar", "mtt.form.tt.topAttachment:\t\tATTACH_WIDGET",
    "mtt.form.tt.topWidget:\t\t\ttool", "mtt.form.tt.bottomAttachment:\t\tATTACH_FORM",
    "mtt.form.tt.background:\t\t\tblack", "mtt.form.tt.foreground:\t\t\twhite", "", "mtt*bar.file.labelString:\t\tFile", "mtt*bar.file.mnemonic:\t\t\tF", "mtt*bar.edit.labelString:\t\tEdit", "mtt*bar.edit.mnemonic:\t\t\tE", "mtt*bar.go.labelString:\t\t\tGo to", "mtt*bar.go.mnemonic:\t\t\tG", "mtt*bar.subpage.labelString:\t\tSubpage",
    "mtt*bar.subpage.mnemonic:\t\tS", "mtt*bar.station.labelString:\t\tStations",
    "mtt*bar.station.mnemonic:\t\tt", "mtt*bar.font.labelString:\t\tFonts", "mtt*bar.font.mnemonic:\t\t\to", "", "mtt*tool.orientation:\t\t\tHORIZONTAL",
    "mtt*tool.?.shadowThickness:\t\t1", "mtt*tool.?.labelType:\t\t\tPIXMAP", "mtt*tool.XmSeparator.orientation:\tVERTICAL",
    "mtt*tool.XmSeparator.width:\t\t12", "mtt*tool.XmSeparator.margin:\t\t3", "mtt*tool.100.labelPixmap:\t\thome", "mtt*tool.prev.labelPixmap:\t\tprev", "mtt*tool.next.labelPixmap:\t\tnext", "mtt*tool.exit.labelPixmap:\t\texit", "", "mtt*bar*new.labelString:\t\tNew window",
    "mtt*bar*new.mnemonic:\t\t\tN", "mtt*bar*new.acceleratorText:\t\tN", "mtt*bar*new.accelerator:\t\t<Key>N", "mtt*bar*save.labelString:\t\tSave as ...",
    "mtt*bar*save.mnemonic:\t\t\tS", "mtt*bar*save.acceleratorText:\t\tS", "mtt*bar*save.accelerator:\t\t<Key>S", "mtt*bar*quit.labelString:\t\tClose", "mtt*bar*quit.mnemonic:\t\t\tC", "mtt*bar*quit.acceleratorText:\t\tQ", "mtt*bar*quit.accelerator:\t\t<Key>Q", "", "mtt*bar*copy.labelString:\t\tCopy", "mtt*bar*copy.mnemonic:\t\t\tC", "mtt*bar*copy.acceleratorText:\t\tCtrl+C",
    "mtt*bar*copy.accelerator:\t\tCtrl<Key>C",
    "", "mtt*bar*100.labelString:\t\tIndex", "mtt*bar*100.mnemonic:\t\t\tI", "mtt*bar*100.acceleratorText:\t\tI", "mtt*bar*100.accelerator:\t\t<Key>I", "mtt*bar*prev.labelString:\t\tPrevious page",
    "mtt*bar*prev.mnemonic:\t\t\tP", "mtt*bar*prev.acceleratorText:\t\tPgUp",
    "mtt*bar*prev.accelerator:\t\t<Key>Page_Up",
    "mtt*bar*next.labelString:\t\tNext page",
    "mtt*bar*next.mnemonic:\t\t\tN", "mtt*bar*next.acceleratorText:\t\tPgDown",
    "mtt*bar*next.accelerator:\t\t<Key>Page_Down",
    "", "mtt*bar*s00.labelString:\t\tcycle subpages",
    "", "mtt.save_popup.title:\t\t\tSave File", "mtt.save_popup*format.labelString:\tCharacter set:",
    "", (char *)(void *)0 };
// fb
// file console/fbtools.c line 38
static signed int fb;
// fb_fatal_cleanup
// file console/fbtools.c line 490
static struct __jmp_buf_tag fb_fatal_cleanup[1l];
// fb_fix
// file console/fbtools.c line 29
struct fb_fix_screeninfo fb_fix;
// fb_fmt
// file console/vbi-tty.c line 70
static signed int fb_fmt = VBI_PIXFMT_RGBA32_LE;
// fb_mem
// file console/fbtools.c line 31
unsigned char *fb_mem;
// fb_mem_offset
// file console/fbtools.c line 32
signed int fb_mem_offset = 0;
// fb_ovar
// file console/fbtools.c line 49
static struct fb_var_screeninfo fb_ovar;
// fb_switch_state
// file console/fbtools.c line 33
signed int fb_switch_state = 0;
// fb_var
// file console/fbtools.c line 30
struct fb_var_screeninfo fb_var;
// files_vformats
// file libng/writefile.c line 546
static struct ng_format_list files_vformats[4l] = { { .name="ppm", .desc=((char *)NULL), .ext="ppm", .fmtid=(unsigned int)9,
    .priv=NULL },
    { .name="pgm", .desc=((char *)NULL), .ext="pgm", .fmtid=(unsigned int)2,
    .priv=NULL },
    { .name="jpeg", .desc=((char *)NULL), .ext="jpeg", .fmtid=(unsigned int)17,
    .priv=NULL },
    { .name=((char *)NULL), .desc=((char *)NULL), .ext=((char *)NULL),
    .fmtid=0u, .priv=NULL } };
// files_writer
// file libng/writefile.c line 624
struct ng_writer files_writer;
// wav_aformats
// file libng/writefile.c line 606
static struct ng_format_list wav_aformats[4l] = { { .name="mono8", .desc=((char *)NULL), .ext="wav", .fmtid=(unsigned int)1,
    .priv=NULL },
    { .name="mono16", .desc=((char *)NULL), .ext="wav", .fmtid=(unsigned int)3,
    .priv=NULL },
    { .name="stereo", .desc=((char *)NULL), .ext="wav", .fmtid=(unsigned int)4,
    .priv=NULL },
    { .name=((char *)NULL), .desc=((char *)NULL), .ext=((char *)NULL),
    .fmtid=0u, .priv=NULL } };
// files_writer
// file libng/writefile.c line 624
struct ng_writer files_writer = { .name="files", .desc="multiple image files", .video=files_vformats,
    .audio=wav_aformats, .combined=0,
    .wr_open=files_open, .wr_video=files_video, .wr_audio=files_audio,
    .wr_close=files_close, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } };
// freqtab_notify
// file common/commands.c line 49
void (*freqtab_notify)(void);
// fs_height
// file common/channel.c line 80
signed int fs_height;
// fs_width
// file common/channel.c line 80
signed int fs_width;
// fs_xoff
// file common/channel.c line 80
signed int fs_xoff;
// fs_yoff
// file common/channel.c line 80
signed int fs_yoff;
// fullscreen_hook
// file common/commands.c line 60
void (*fullscreen_hook)(void);
// h_drv
// file common/commands.c line 76
void *h_drv;
// have_config
// file common/channel.c line 73
signed int have_config;
// have_fb
// file console/vbi-tty.c line 69
static signed int have_fb = 0;
// have_shmem
// file common/commands.c line 69
signed int have_shmem;
// home_xpm
// file x11/xpm/home.xpm line 2
static char *home_xpm[20l] = { "16 16 3 1", " \tc #C71BC71BC71B", ".\tc #000000000000", "X\tc #861782078617", "                ", "       .        ", "   .. ...       ", "   ....X..      ", "   ...XX ..     ", "   ..XX   ..    ", "  ..XX     ..   ", " ...X      ...  ", "  X.X ...  .XXX ", "   .X . .X .X   ", "   .X . .X .X   ", "   .X . .X .X   ", "   .X . .X .X   ", "   .........X   ", "    XXXXXXXXX   ", "                " };
// kd_mode
// file console/fbtools.c line 46
static signed int kd_mode;
// keypad_ntsc
// file common/channel.c line 74
signed int keypad_ntsc = 0;
// keypad_partial
// file common/channel.c line 75
signed int keypad_partial = 1;
// keypad_state
// file common/commands.c line 164
static signed int keypad_state = -1;
// last_sender
// file common/channel.c line 68
signed int last_sender = -1;
// launch
// file common/channel.c line 97
struct LAUNCH *launch = (struct LAUNCH *)(void *)0;
// lut2_list
// file libng/color_lut.c line 161
static struct ng_video_conv lut2_list[8l];
// lut2_list
// file libng/color_lut.c line 161
static struct ng_video_conv lut2_list[8l] = { { .fmtid_in=(unsigned int)9, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)ng_rgb24_to_lut2, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)7, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)bgr24_to_lut2, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)10, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)rgb32_to_lut2, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)8, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)bgr32_to_lut2, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)2, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)gray_to_lut2, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)13, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)ng_yuv422_to_lut2, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)14, .fmtid_out=0u, .init=ng_conv_nop_init,
    .frame=ng_yuv422p_to_lut2, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)15, .fmtid_out=0u, .init=ng_conv_nop_init,
    .frame=ng_yuv420p_to_lut2, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } } };
// lut4_list
// file libng/color_lut.c line 199
static struct ng_video_conv lut4_list[8l];
// lut4_list
// file libng/color_lut.c line 199
static struct ng_video_conv lut4_list[8l] = { { .fmtid_in=(unsigned int)9, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)ng_rgb24_to_lut4, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)7, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)bgr24_to_lut4, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)10, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)rgb32_to_lut4, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)8, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)bgr32_to_lut4, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)2, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)gray_to_lut4, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)13, .fmtid_out=0u, .init=ng_packed_init,
    .frame=ng_packed_frame, .fini=ng_conv_nop_fini,
    .priv=(void *)ng_yuv422_to_lut4, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)14, .fmtid_out=0u, .init=ng_conv_nop_init,
    .frame=ng_yuv422p_to_lut4, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } },
    { .fmtid_in=(unsigned int)15, .fmtid_out=0u, .init=ng_conv_nop_init,
    .frame=ng_yuv420p_to_lut4, .fini=ng_conv_nop_fini,
    .priv=NULL, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } } };
// midi
// file common/channel.c line 95
char *midi = (char *)(void *)0;
// mixer
// file common/channel.c line 93
static char *mixer = (char *)(void *)0;
// mixerctl
// file common/channel.c line 94
char mixerctl[16l];
// mixerdev
// file common/channel.c line 94
char mixerdev[32l];
// mov_audio
// file common/channel.c line 86
char *mov_audio = (char *)(void *)0;
// mov_driver
// file common/channel.c line 83
char *mov_driver = (char *)(void *)0;
// mov_fps
// file common/channel.c line 85
char *mov_fps = (char *)(void *)0;
// mov_rate
// file common/channel.c line 87
char *mov_rate = (char *)(void *)0;
// mov_video
// file common/channel.c line 84
char *mov_video = (char *)(void *)0;
// movie_hook
// file common/commands.c line 64
void (*movie_hook)(signed int, char **);
// movie_xpm
// file x11/xpm/movie.xpm line 2
static char *movie_xpm[20l] = { "16 16 3 1", " \tc gray77", ".\tc #000000000000", "X\tc #861782078617", "                ", "                ", "............... ", ". . . . . . . .X", "...............X", " X.XXXXXXX.XXXXX", "  .X      .X    ", "  .X      .X    ", "  .X      .X    ", "  .X      .X    ", "............... ", " . . . . . . . X", "...............X", " XXXXXXXXXXXXXXX", "                ", "                " };
// mute_notify
// file common/commands.c line 47
void (*mute_notify)(signed int);
// mute_xpm
// file x11/xpm/mute.xpm line 2
static char *mute_xpm[20l] = { "16 16 3 1", " \tc gray77", ".\tc #000000000000", "X\tc #861782078617", "                ", "         .      ", "        ..X     ", "       . .X     ", "      .  .X .   ", " .....   .X .X  ", " .       .X  .X ", " .       .X  .X ", " .       .X  .X ", " .....   .X .XX ", "  XXXX.  .X .X  ", "       . .X  X  ", "        ..X     ", "         .X     ", "          X     ", "                " };
// nconv
// file libng/color_packed.c line 255
static const signed int nconv = (const signed int)(sizeof(struct ng_video_conv [12l]) /*672ul*/  / sizeof(struct ng_video_conv) /*56ul*/ );
// nconv$link1
// file libng/color_yuv2rgb.c line 421
static const signed int nconv$link1 = (const signed int)(sizeof(struct ng_video_conv [6l]) /*336ul*/  / sizeof(struct ng_video_conv) /*56ul*/ );
// nconv2
// file libng/color_lut.c line 237
static const unsigned int nconv2 = (const unsigned int)(sizeof(struct ng_video_conv [8l]) /*448ul*/  / sizeof(struct ng_video_conv) /*56ul*/ );
// nconv4
// file libng/color_lut.c line 238
static const unsigned int nconv4 = (const unsigned int)(sizeof(struct ng_video_conv [8l]) /*448ul*/  / sizeof(struct ng_video_conv) /*56ul*/ );
// next_xpm
// file x11/xpm/next.xpm line 2
static char *next_xpm[20l] = { "16 16 3 1", " \tc gray77", ".\tc #000000000000", "X\tc #868682828686", "                ", "                ", "        .       ", "        ..      ", "        ...     ", "        ....    ", "  ...........   ", "  ............  ", "  ...........XX ", "   XXXXX....XX  ", "        ...XX   ", "        ..XX    ", "        .XX     ", "         X      ", "                ", "                " };
// ng_aconv
// file libng/grab-ng.c line 373
struct list_head ng_aconv;
// ng_aconv
// file libng/grab-ng.c line 373
struct list_head ng_aconv = { .next=&ng_aconv, .prev=&ng_aconv };
// ng_afmt_to_bits
// file libng/grab-ng.c line 91
const unsigned int ng_afmt_to_bits[8l] = { (const unsigned int)0, (const unsigned int)8, (const unsigned int)8, (const unsigned int)16, (const unsigned int)16, (const unsigned int)16, (const unsigned int)16, (const unsigned int)0 };
// ng_afmt_to_channels
// file libng/grab-ng.c line 88
const unsigned int ng_afmt_to_channels[8l] = { (const unsigned int)0, (const unsigned int)1, (const unsigned int)2, (const unsigned int)1, (const unsigned int)2, (const unsigned int)1, (const unsigned int)2, (const unsigned int)0 };
// ng_afmt_to_desc
// file libng/grab-ng.c line 94
const char *ng_afmt_to_desc[8l] = { "none", "8bit mono", "8bit stereo", "16bit mono (LE)", "16bit stereo (LE)", "16bit mono (BE)", "16bit stereo (BE)", "mp3 compressed audio" };
// ng_attr_to_desc
// file libng/grab-ng.c line 107
const char *ng_attr_to_desc[10l] = { "none", "norm", "input", "volume", "mute", "audio mode", "color", "bright", "hue", "contrast" };
// ng_chromakey
// file libng/grab-ng.c line 33
signed int ng_chromakey = 0x00ff00ff;
// ng_clip
// file libng/color_yuv2rgb.c line 52
static unsigned int ng_clip[896l];
// ng_conv
// file libng/grab-ng.c line 372
struct list_head ng_conv;
// ng_conv
// file libng/grab-ng.c line 372
struct list_head ng_conv = { .next=&ng_conv, .prev=&ng_conv };
// ng_debug
// file libng/grab-ng.c line 32
signed int ng_debug = 0;
// ng_dev
// file libng/devices.c line 37
struct ng_device_config ng_dev = { .video="/dev/video0", .driver="libv4l", .radio="/dev/radio0",
    .vbi="/dev/vbi0", .dsp="/dev/dsp",
    .mixer="/dev/mixer", .video_scan={ "/dev/video0", "/dev/video1", "/dev/video2", "/dev/video3", (char *)(void *)0, ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) },
    .mixer_scan={ "/dev/mixer", "/dev/mixer1", "/dev/mixer2", "/dev/mixer3", (char *)(void *)0, ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) } };
// ng_dev_devfs
// file libng/devices.c line 60
struct ng_device_config ng_dev_devfs = { .video="/dev/v4l/video0", .driver="libv4l", .radio="/dev/v4l/radio0",
    .vbi="/dev/v4l/vbi0", .dsp="/dev/sound/dsp",
    .mixer="/dev/sound/mixer", .video_scan={ "/dev/v4l/video0", "/dev/v4l/video1", "/dev/v4l/video2", "/dev/v4l/video3", (char *)(void *)0, ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) },
    .mixer_scan={ "/dev/sound/mixer", "/dev/sound/mixer1", "/dev/sound/mixer2", "/dev/sound/mixer3", (char *)(void *)0, ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) } };
// ng_dsp_drivers
// file libng/grab-ng.c line 378
struct list_head ng_dsp_drivers;
// ng_dsp_drivers
// file libng/grab-ng.c line 378
struct list_head ng_dsp_drivers = { .next=&ng_dsp_drivers, .prev=&ng_dsp_drivers };
// ng_filters
// file libng/grab-ng.c line 374
struct list_head ng_filters;
// ng_filters
// file libng/grab-ng.c line 374
struct list_head ng_filters = { .next=&ng_filters, .prev=&ng_filters };
// ng_jpeg_quality
// file libng/grab-ng.c line 34
signed int ng_jpeg_quality = 75;
// ng_lut_blue
// file libng/grab-ng.h line 486
unsigned long int ng_lut_blue[256l];
// ng_lut_green
// file libng/grab-ng.h line 485
unsigned long int ng_lut_green[256l];
// ng_lut_red
// file libng/grab-ng.h line 484
unsigned long int ng_lut_red[256l];
// ng_mix_drivers
// file libng/grab-ng.c line 379
struct list_head ng_mix_drivers;
// ng_mix_drivers
// file libng/grab-ng.c line 379
struct list_head ng_mix_drivers = { .next=&ng_mix_drivers, .prev=&ng_mix_drivers };
// ng_ratio_x
// file libng/grab-ng.c line 35
signed int ng_ratio_x = 4;
// ng_ratio_y
// file libng/grab-ng.c line 36
signed int ng_ratio_y = 3;
// ng_readers
// file libng/grab-ng.c line 376
struct list_head ng_readers;
// ng_readers
// file libng/grab-ng.c line 376
struct list_head ng_readers = { .next=&ng_readers, .prev=&ng_readers };
// ng_v4l_conf
// file libng/grab-ng.c line 38
char ng_v4l_conf[256l] = { 'v', '4', 'l', '-', 'c', 'o', 'n', 'f', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// ng_vfmt_to_depth
// file libng/grab-ng.c line 42
const unsigned int ng_vfmt_to_depth[19l] = { (const unsigned int)0, (const unsigned int)8, (const unsigned int)8, (const unsigned int)16, (const unsigned int)16, (const unsigned int)16, (const unsigned int)16, (const unsigned int)24, (const unsigned int)32, (const unsigned int)24, (const unsigned int)32, (const unsigned int)16, (const unsigned int)32, (const unsigned int)16, (const unsigned int)16, (const unsigned int)12, (const unsigned int)0, (const unsigned int)0, (const unsigned int)16 };
// ng_vfmt_to_desc
// file libng/grab-ng.c line 64
const char *ng_vfmt_to_desc[19l] = { "none", "8 bit PseudoColor (dithering)", "8 bit StaticGray", "15 bit TrueColor (LE)", "16 bit TrueColor (LE)", "15 bit TrueColor (BE)", "16 bit TrueColor (BE)", "24 bit TrueColor (LE: bgr)", "32 bit TrueColor (LE: bgr-)", "24 bit TrueColor (BE: rgb)", "32 bit TrueColor (BE: -rgb)", "16 bit TrueColor (lut)", "32 bit TrueColor (lut)", "16 bit YUV 4:2:2 (packed, YUYV)", "16 bit YUV 4:2:2 (planar)", "12 bit YUV 4:2:0 (planar)", "MJPEG (AVI)", "JPEG (JFIF)", "16 bit YUV 4:2:2 (packed, UYVY)" };
// ng_vid_drivers
// file libng/grab-ng.c line 377
struct list_head ng_vid_drivers;
// ng_vid_drivers
// file libng/grab-ng.c line 377
struct list_head ng_vid_drivers = { .next=&ng_vid_drivers, .prev=&ng_vid_drivers };
// ng_writers
// file libng/grab-ng.c line 375
struct list_head ng_writers;
// ng_writers
// file libng/grab-ng.c line 375
struct list_head ng_writers = { .next=&ng_writers, .prev=&ng_writers };
// ng_yuv_blue
// file libng/color_yuv2rgb.c line 49
static unsigned int ng_yuv_blue[256l];
// ng_yuv_g1
// file libng/color_yuv2rgb.c line 50
static unsigned int ng_yuv_g1[256l];
// ng_yuv_g2
// file libng/color_yuv2rgb.c line 51
static unsigned int ng_yuv_g2[256l];
// ng_yuv_gray
// file libng/color_yuv2rgb.c line 47
static unsigned int ng_yuv_gray[256l];
// ng_yuv_red
// file libng/color_yuv2rgb.c line 48
static unsigned int ng_yuv_red[256l];
// nlaunch
// file common/channel.c line 98
signed int nlaunch = 0;
// oblue
// file console/fbtools.c line 50
static unsigned short int oblue[256l];
// ocmap
// file console/fbtools.c line 51
static struct fb_cmap ocmap;
// ogreen
// file console/fbtools.c line 50
static unsigned short int ogreen[256l];
// ored
// file console/fbtools.c line 50
static unsigned short int ored[256l];
// ocmap
// file console/fbtools.c line 51
static struct fb_cmap ocmap = { .start=(unsigned int)0, .len=(unsigned int)256, .red=ored,
    .green=ogreen, .blue=oblue, .transp=((unsigned short int *)NULL) };
// opt_count
// file x11/mtt.c line 114
const signed int opt_count = (const signed int)(sizeof(struct anonymous$21 [8l]) /*256ul*/  / sizeof(struct anonymous$21) /*32ul*/ );
// opt_desc
// file x11/mtt.c line 102
struct anonymous$21 opt_desc[8l] = { { .option="-c", .specifier="device", .argKind=(enum anonymous$20)XrmoptionSepArg, .value=(char *)(void *)0 },
    { .option="-device", .specifier="device", .argKind=(enum anonymous$20)XrmoptionSepArg,
    .value=(char *)(void *)0 },
    { .option="-tty", .specifier="tty", .argKind=(enum anonymous$20)XrmoptionNoArg, .value="1" },
    { .option="-sim", .specifier="sim", .argKind=(enum anonymous$20)XrmoptionNoArg, .value="1" },
    { .option="-debug", .specifier="debug", .argKind=(enum anonymous$20)XrmoptionNoArg, .value="1" },
    { .option="-h", .specifier="help", .argKind=(enum anonymous$20)XrmoptionNoArg, .value="1" },
    { .option="-help", .specifier="help", .argKind=(enum anonymous$20)XrmoptionNoArg, .value="1" },
    { .option="--help", .specifier="help", .argKind=(enum anonymous$20)XrmoptionNoArg, .value="1" } };
// orig_vt_no
// file console/fbtools.c line 43
static signed int orig_vt_no = 0;
// osd_x
// file common/channel.c line 78
signed int osd_x = 30;
// osd_y
// file common/channel.c line 79
signed int osd_y = 20;
// pix_cols
// file common/channel.c line 81
signed int pix_cols = 1;
// pix_height
// file common/channel.c line 81
signed int pix_height = 96;
// pix_width
// file common/channel.c line 81
signed int pix_width = 128;
// prev_xpm
// file x11/xpm/prev.xpm line 2
static char *prev_xpm[20l] = { "16 16 3 1", " \tc gray77", ".\tc #000000000000", "X\tc #868682828686", "                ", "                ", "      .         ", "     ..X        ", "    ...X        ", "   ....X        ", "  ...........   ", " ............X  ", "  ...........X  ", "   ....XXXXXXX  ", "    ...X        ", "     ..X        ", "      .X        ", "       X        ", "                ", "                " };
// raw_vformats
// file libng/writefile.c line 572
static struct ng_format_list raw_vformats[7l];
// yuv4mpeg
// file libng/writefile.c line 564
static struct raw_priv yuv4mpeg = { .yuv4mpeg=1 };
// yuv4mpeg2
// file libng/writefile.c line 568
static struct raw_priv yuv4mpeg2 = { .yuv4mpeg=2 };
// raw_vformats
// file libng/writefile.c line 572
static struct ng_format_list raw_vformats[7l] = { { .name="rgb", .desc=((char *)NULL), .ext="raw", .fmtid=(unsigned int)9,
    .priv=NULL },
    { .name="gray", .desc=((char *)NULL), .ext="raw", .fmtid=(unsigned int)2,
    .priv=NULL },
    { .name="422", .desc=((char *)NULL), .ext="raw", .fmtid=(unsigned int)13,
    .priv=NULL },
    { .name="422p", .desc=((char *)NULL), .ext="raw", .fmtid=(unsigned int)14,
    .priv=NULL },
    { .name="4mpeg", .desc="yuv4mpeg (mpeg2enc >= 1.6)", .ext="yuv",
    .fmtid=(unsigned int)15, .priv=(void *)&yuv4mpeg2 },
    { .name="4mpeg-o", .desc="yuv4mpeg (old mpeg2enc)", .ext="yuv",
    .fmtid=(unsigned int)15, .priv=(void *)&yuv4mpeg },
    { .name=((char *)NULL), .desc=((char *)NULL), .ext=((char *)NULL),
    .fmtid=0u, .priv=NULL } };
// raw_writer
// file libng/writefile.c line 635
struct ng_writer raw_writer;
// raw_writer
// file libng/writefile.c line 635
struct ng_writer raw_writer = { .name="raw", .desc="single file, raw video data", .video=raw_vformats,
    .audio=wav_aformats, .combined=0,
    .wr_open=raw_open, .wr_video=raw_video, .wr_audio=raw_audio,
    .wr_close=raw_close, .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) } };
// rec_status
// file common/commands.c line 37
void (*rec_status)(char *);
// saved_attributes
// file console/vbi-tty.c line 30
struct termios saved_attributes;
// saved_fl
// file console/vbi-tty.c line 31
signed int saved_fl;
// set_capture_hook
// file common/commands.c line 57
void (*set_capture_hook)(signed int, signed int, signed int);
// setfreqtab_notify
// file common/commands.c line 50
void (*setfreqtab_notify)(void);
// setstation_notify
// file common/commands.c line 51
void (*setstation_notify)(void);
// sim
// file common/vbi-sim.c line 6
static struct vbi_raw_decoder sim;
// sim_time
// file common/vbi-sim.c line 7
static double sim_time;
// snap_xpm
// file x11/xpm/snap.xpm line 2
static char *snap_xpm[20l] = { "16 16 3 1", " \tc gray77", ".\tc #000000000000", "o\tc #861782078617", "                ", "                ", "                ", " .............  ", ".  .   ....   . ", ".  .  .    .  .o", ".... .  ..  . .o", ".    . .  . . .o", ".    . .  . . .o", ".    .  ..  . .o", ".     .    .  .o", ".      ....   .o", " .............oo", "  ooooooooooooo ", "                ", "                " };
// snapbase
// file common/commands.c line 68
char *snapbase = "snap";
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// switch_last
// file console/vbi-tty.c line 71
static signed int switch_last;
// sys_siglist
// file /usr/include/signal.h line 304
extern const char * const sys_siglist[65l];
// term
// file console/fbtools.c line 48
static struct termios term;
// tt_debug
// file x11/vbi-gui.c line 50
static signed int tt_debug = 1;
// tt_windows
// file x11/vbi-gui.c line 51
static signed int tt_windows = 0;
// tty
// file console/fbtools.c line 38
static signed int tty;
// tv_xpm
// file x11/xpm/tv.xpm line 2
static char *tv_xpm[42l] = { "32 32 9 1", " \tc none", ".\tc #000000000000", "X\tc #861782078617", "o\tc #FFFF82070000", "O\tc #FFFFFFFF0000", "+\tc #0000FFFF0000", "@\tc #0000FFFFFFFF", "#\tc #FFFF00000000", "$\tc #00000000FFFF", "                                ", "                                ", "                                ", "      ..             ..         ", "      ..X            ..X        ", "       X.           .XXX        ", "         .         .X           ", "          .       .X            ", "           .     .X             ", "            .   .X              ", "             . .X               ", "    ......................      ", "    ......................X     ", "    ......ooOOO+++@@......XX    ", "    ...##oooOOO+++@@@$$...XX    ", "    ..###oooOOO+++@@@$$$..XX    ", "    ..###oooOOO+++@@@$$$..XX    ", "    ..###oooOOO+++@@@$$$..XX    ", "    ..###oooOOO+++@@@$$$..XX    ", "    ..###oooOOO+++@@@$$$..XX    ", "    ..###oooOOO+++@@@$$$$.XX    ", "    ..###oooOOO+++@@@$$$..XX    ", "    ...##oooOOO+++@@@$$...XX    ", "    ......ooOOO+++@@......XX    ", "    ......................XX    ", "    ......................XX    ", "     XXXXXXXXXXXXXXXXXXXXXXX    ", "      XXXXXXXXXXXXXXXXXXXXXX    ", "                                ", "                                ", "                                ", "                                " };
// tweb
// file common/webcam.c line 105
static unsigned long int tweb;
// update_title
// file common/commands.c line 35
void (*update_title)(char *);
// use_osd
// file common/channel.c line 77
signed int use_osd = 1;
// use_wm_fullscreen
// file common/channel.c line 76
signed int use_wm_fullscreen = 1;
// vbi_colors
// file common/vbi-data.c line 22
char *vbi_colors[8l] = { "black", "red", "green", "yellow", "blue", "magenta", "cyan", "white" };
// vbi_fonts
// file x11/vbi-x11.c line 36
struct vbi_font vbi_fonts[5l] = { { .label="Teletext 20", .xlfd1="-*-teletext-medium-r-normal--20-*-*-*-*-*-iso10646-1", .xlfd2="-*-teletext-medium-r-normal--40-*-*-*-*-*-iso10646-1" },
    { .label="Teletext 10", .xlfd1="-*-teletext-medium-r-normal--10-*-*-*-*-*-iso10646-1", .xlfd2="-*-teletext-medium-r-normal--20-*-*-*-*-*-iso10646-1" },
    { .label="Fixed 18", .xlfd1="-*-fixed-medium-r-normal--18-*-*-*-*-*-iso10646-1", .xlfd2=((char *)NULL) },
    { .label="Fixed 13", .xlfd1="-misc-fixed-medium-r-semicondensed--13-*-*-*-*-*-iso10646-1", .xlfd2=((char *)NULL) },
    { .label=((char *)NULL), .xlfd1=((char *)NULL), .xlfd2=((char *)NULL) } };
// vbi_fullrect
// file common/vbi-data.c line 24
struct vbi_rect vbi_fullrect = { .x1=0, .x2=41, .y1=0, .y2=25 };
// vdr_sock
// file common/commands.c line 1290
static signed int vdr_sock = -1;
// volume_notify
// file common/commands.c line 48
void (*volume_notify)(void);
// vt_mode
// file console/fbtools.c line 44
static struct vt_mode vt_mode;
// vt_omode
// file console/fbtools.c line 47
static struct vt_mode vt_omode;
// vtx_subtitle
// file common/commands.c line 42
void (*vtx_subtitle)(struct vbi_page *, struct vbi_rect *);
// web
// file common/webcam.c line 104
static struct WEBCAM *web;
// webcam
// file common/webcam.c line 20
char *webcam;
// xmCascadeButtonWidgetClass
// file /usr/include/Xm/CascadeB.h line 40
extern struct _WidgetClassRec *xmCascadeButtonWidgetClass;
// xmDrawingAreaWidgetClass
// file /usr/include/Xm/DrawingA.h line 40
extern struct _WidgetClassRec *xmDrawingAreaWidgetClass;
// xmFormWidgetClass
// file /usr/include/Xm/Form.h line 43
extern struct _WidgetClassRec *xmFormWidgetClass;
// xmPushButtonWidgetClass
// file /usr/include/Xm/PushB.h line 56
extern struct _WidgetClassRec *xmPushButtonWidgetClass;
// xmRowColumnWidgetClass
// file /usr/include/Xm/RowColumn.h line 38
extern struct _WidgetClassRec *xmRowColumnWidgetClass;
// xmSeparatorWidgetClass
// file /usr/include/Xm/Separator.h line 43
extern struct _WidgetClassRec *xmSeparatorWidgetClass;

// __list_add
// file ./libng/list.h line 34
static inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next)
{
  next->prev = new;
  new->next = next;
  new->prev = prev;
  prev->next = new;
}

// __list_add$link1
// file libng/list.h line 34
static inline void __list_add$link1(struct list_head *new$link1, struct list_head *prev$link1, struct list_head *next$link1)
{
  next$link1->prev = new$link1;
  new$link1->next = next$link1;
  new$link1->prev = prev$link1;
  prev$link1->next = new$link1;
}

// __list_del
// file ./libng/list.h line 77
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
  next->prev = prev;
  prev->next = next;
}

// add_attrs
// file common/commands.c line 168
void add_attrs(struct ng_attribute *new)
{
  struct ng_attribute *all;
  signed int nold;
  signed int nnew;
  if(!(attrs == ((struct ng_attribute *)NULL)))
  {
    nold = 0;
    for( ; !((attrs + (signed long int)nold)->name == ((const char *)NULL)); nold = nold + 1)
      ;
  }

  else
    nold = 0;
  nnew = 0;
  for( ; !((new + (signed long int)nnew)->name == ((const char *)NULL)); nnew = nnew + 1)
    ;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct ng_attribute) /*80ul*/  * (unsigned long int)(nold + nnew + 1));
  all = (struct ng_attribute *)return_value_malloc$1;
  memset((void *)all, 0, sizeof(struct ng_attribute) /*80ul*/  * (unsigned long int)(nold + nnew + 1));
  memcpy((void *)all, (const void *)new, sizeof(struct ng_attribute) /*80ul*/  * (unsigned long int)nnew);
  if(!(attrs == ((struct ng_attribute *)NULL)))
  {
    memcpy((void *)(all + (signed long int)nnew), (const void *)attrs, sizeof(struct ng_attribute) /*80ul*/  * (unsigned long int)nold);
    free((void *)attrs);
  }

  attrs = all;
}

// add_channel
// file common/channel.c line 186
struct CHANNEL * add_channel(char *name)
{
  struct CHANNEL *channel;
  void *return_value_malloc$1;
  void *return_value_realloc$2;
  if(alloc_count == count)
  {
    alloc_count = alloc_count + 16;
    if(alloc_count == 16)
    {
      return_value_malloc$1=malloc(sizeof(struct CHANNEL *) /*8ul*/  * (unsigned long int)alloc_count);
      channels = (struct CHANNEL **)return_value_malloc$1;
    }

    else
    {
      return_value_realloc$2=realloc((void *)channels, sizeof(struct CHANNEL *) /*8ul*/  * (unsigned long int)alloc_count);
      channels = (struct CHANNEL **)return_value_realloc$2;
    }
  }

  signed int tmp_post$3 = count;
  count = count + 1;
  void *return_value_malloc$4;
  return_value_malloc$4=malloc(sizeof(struct CHANNEL) /*104ul*/ );
  channels[(signed long int)tmp_post$3] = (struct CHANNEL *)return_value_malloc$4;
  channel = channels[(signed long int)tmp_post$3];
  memcpy((void *)channel, (const void *)&defaults, sizeof(struct CHANNEL) /*104ul*/ );
  channel->name=strdup(name);
  return channel;
}

// add_dvb_class
// file common/get_media_devices.c line 275
static signed int add_dvb_class(struct media_device_entry *md)
{
  char *return_value_strstr$1;
  return_value_strstr$1=strstr(md->node, "video");
  if(!(return_value_strstr$1 == ((char *)NULL)))
    md->type = (enum device_type)MEDIA_DVB_VIDEO;

  char *return_value_strstr$2;
  return_value_strstr$2=strstr(md->node, "audio");
  if(!(return_value_strstr$2 == ((char *)NULL)))
    md->type = (enum device_type)MEDIA_DVB_AUDIO;

  char *return_value_strstr$3;
  return_value_strstr$3=strstr(md->node, "sec");
  if(!(return_value_strstr$3 == ((char *)NULL)))
    md->type = (enum device_type)MEDIA_DVB_SEC;

  char *return_value_strstr$9;
  return_value_strstr$9=strstr(md->node, "frontend");
  char *return_value_strstr$8;
  char *return_value_strstr$7;
  char *return_value_strstr$6;
  char *return_value_strstr$5;
  char *return_value_strstr$4;
  if(!(return_value_strstr$9 == ((char *)NULL)))
    md->type = (enum device_type)MEDIA_DVB_FRONTEND;

  else
  {
    return_value_strstr$8=strstr(md->node, "demux");
    if(!(return_value_strstr$8 == ((char *)NULL)))
      md->type = (enum device_type)MEDIA_DVB_DEMUX;

    else
    {
      return_value_strstr$7=strstr(md->node, "dvr");
      if(!(return_value_strstr$7 == ((char *)NULL)))
        md->type = (enum device_type)MEDIA_DVB_DVR;

      else
      {
        return_value_strstr$6=strstr(md->node, "net");
        if(!(return_value_strstr$6 == ((char *)NULL)))
          md->type = (enum device_type)MEDIA_DVB_NET;

        else
        {
          return_value_strstr$5=strstr(md->node, "ca");
          if(!(return_value_strstr$5 == ((char *)NULL)))
            md->type = (enum device_type)MEDIA_DVB_CA;

          else
          {
            return_value_strstr$4=strstr(md->node, "osd");
            if(!(return_value_strstr$4 == ((char *)NULL)))
              md->type = (enum device_type)MEDIA_DVB_OSD;

          }
        }
      }
    }
  }
  return 0;
}

// add_pixmap
// file x11/icons.c line 22
static void add_pixmap(struct _XDisplay *dpy, unsigned long int bg, char *imgname, char *maskname, char **data)
{
  struct _XImage *image;
  struct _XImage *add_pixmap$$1$$shape;
  struct anonymous$92 attr;
  unsigned int x;
  unsigned int y;
  memset((void *)&attr, 0, sizeof(struct anonymous$92) /*224ul*/ );
  XpmCreateImageFromData(dpy, data, &image, &add_pixmap$$1$$shape, &attr);
  unsigned long int return_value;
  if(!(maskname == ((char *)NULL)))
  {
    XmInstallImage(image, imgname);
    if(!(add_pixmap$$1$$shape == ((struct _XImage *)NULL)))
      XmInstallImage(add_pixmap$$1$$shape, maskname);

  }

  else
  {
    if(!(add_pixmap$$1$$shape == ((struct _XImage *)NULL)))
    {
      y = (unsigned int)0;
      for( ; !(y >= attr.height); y = y + 1u)
      {
        x = (unsigned int)0;
        if(!(x >= attr.width))
        {
          return_value=add_pixmap$$1$$shape->f.get_pixel(add_pixmap$$1$$shape, (signed int)x, (signed int)y);
          if(return_value == 0ul)
            image->f.put_pixel(image, (signed int)x, (signed int)y, bg);

          x = x + 1u;
        }

      }
    }

    XmInstallImage(image, imgname);
  }
}

// add_snd_class
// file common/get_media_devices.c line 232
static signed int add_snd_class(struct media_device_entry *md)
{
  unsigned int add_snd_class$$1$$c = (unsigned int)65535;
  unsigned int d = (unsigned int)65535;
  char node[64l];
  char *return_value_strstr$2;
  return_value_strstr$2=strstr(md->node, "timer");
  char *return_value_strstr$1;
  if(!(return_value_strstr$2 == ((char *)NULL)))
  {
    md->type = (enum device_type)MEDIA_SND_TIMER;
    return 0;
  }

  else
  {
    return_value_strstr$1=strstr(md->node, "seq");
    if(!(return_value_strstr$1 == ((char *)NULL)))
    {
      md->type = (enum device_type)MEDIA_SND_SEQ;
      return 0;
    }

  }
  char *return_value_strstr$8;
  return_value_strstr$8=strstr(md->node, "card");
  char *return_value_strstr$7;
  char *return_value_strstr$6;
  char *return_value_strstr$5;
  unsigned long int return_value_strlen$3;
  if(!(return_value_strstr$8 == ((char *)NULL)))
  {
    sscanf(md->node, "card%u", &add_snd_class$$1$$c);
    md->type = (enum device_type)MEDIA_SND_CARD;
  }

  else
  {
    return_value_strstr$7=strstr(md->node, "hw");
    if(!(return_value_strstr$7 == ((char *)NULL)))
    {
      sscanf(md->node, "hwC%uD%u", &add_snd_class$$1$$c, &d);
      md->type = (enum device_type)MEDIA_SND_HW;
    }

    else
    {
      return_value_strstr$6=strstr(md->node, "control");
      if(!(return_value_strstr$6 == ((char *)NULL)))
      {
        sscanf(md->node, "controlC%u", &add_snd_class$$1$$c);
        md->type = (enum device_type)MEDIA_SND_CONTROL;
      }

      else
      {
        return_value_strstr$5=strstr(md->node, "pcm");
        if(!(return_value_strstr$5 == ((char *)NULL)))
        {
          sscanf(md->node, "pcmC%uD%u", &add_snd_class$$1$$c, &d);
          unsigned long int return_value_strlen$4;
          return_value_strlen$4=strlen(md->node);
          if((signed int)md->node[-1l + (signed long int)return_value_strlen$4] == 112)
            md->type = (enum device_type)MEDIA_SND_OUT;

          else
          {
            return_value_strlen$3=strlen(md->node);
            if((signed int)md->node[-1l + (signed long int)return_value_strlen$3] == 99)
              md->type = (enum device_type)MEDIA_SND_CAP;

          }
        }

      }
    }
  }
  if(add_snd_class$$1$$c == 65535u)
    return 0;

  else
  {
    if(d == 65535u)
      snprintf(node, sizeof(char [64l]) /*64ul*/ , "hw:%u", add_snd_class$$1$$c);

    else
      snprintf(node, sizeof(char [64l]) /*64ul*/ , "hw:%u,%u", add_snd_class$$1$$c, d);
    free((void *)md->node);
    md->node=strdup(node);
    return 0;
  }
}

// add_v4l_class
// file common/get_media_devices.c line 218
static signed int add_v4l_class(struct media_device_entry *md)
{
  char *return_value_strstr$4;
  return_value_strstr$4=strstr(md->node, "video");
  char *return_value_strstr$3;
  char *return_value_strstr$2;
  char *return_value_strstr$1;
  if(!(return_value_strstr$4 == ((char *)NULL)))
    md->type = (enum device_type)MEDIA_V4L_VIDEO;

  else
  {
    return_value_strstr$3=strstr(md->node, "vbi");
    if(!(return_value_strstr$3 == ((char *)NULL)))
      md->type = (enum device_type)MEDIA_V4L_VBI;

    else
    {
      return_value_strstr$2=strstr(md->node, "radio");
      if(!(return_value_strstr$2 == ((char *)NULL)))
        md->type = (enum device_type)MEDIA_V4L_RADIO;

      else
      {
        return_value_strstr$1=strstr(md->node, "v4l-subdev");
        if(!(return_value_strstr$1 == ((char *)NULL)))
          md->type = (enum device_type)MEDIA_V4L_SUBDEV;

      }
    }
  }
  return 0;
}

// attr_handler
// file common/commands.c line 833
static signed int attr_handler(char *name, signed int argc, char **argv)
{
  struct ng_attribute *attr;
  signed int val;
  signed int arg = 0;
  signed int return_value_strcasecmp$4;
  return_value_strcasecmp$4=strcasecmp(name, "setnorm");
  signed int return_value_strcasecmp$3;
  signed int return_value_strcasecmp$2;
  if(return_value_strcasecmp$4 == 0)
    attr=ng_attr_byname(attrs, "norm");

  else
  {
    return_value_strcasecmp$3=strcasecmp(name, "setinput");
    if(return_value_strcasecmp$3 == 0)
      attr=ng_attr_byname(attrs, "input");

    else
    {
      return_value_strcasecmp$2=strcasecmp(name, "setattr");
      if(return_value_strcasecmp$2 == 0 && argc >= 1)
      {
        signed int tmp_post$1 = arg;
        arg = arg + 1;
        attr=ng_attr_byname(attrs, argv[(signed long int)tmp_post$1]);
      }

      else
        attr=ng_attr_byname(attrs, name);
    }
  }
  if(attr == ((struct ng_attribute *)NULL))
  {
    char *tmp_if_expr$5;
    if(arg >= 1)
      tmp_if_expr$5 = argv[(signed long int)0];

    else
      tmp_if_expr$5 = name;
    fprintf(stderr, "cmd: %s: attribute not found\nvalid choices are:", tmp_if_expr$5);
    attr = attrs;
    for( ; !(attr->name == ((const char *)NULL)); attr = attr + 1l)
      fprintf(stderr, "%s \"%s\"", attr != attrs ? "," : "", attr->name);
    fprintf(stderr, "\n");
    return -1;
  }

  else
  {
    if(cur_movie == 0 && !(capture_get_hook == ((void (*)(void))NULL)))
      capture_get_hook();

    switch(attr->type)
    {
      case 2:
      {
        if(!(arg >= argc))
        {
          signed int return_value_strcasecmp$6;
          return_value_strcasecmp$6=strcasecmp("next", argv[(signed long int)arg]);
          if(return_value_strcasecmp$6 == 0)
          {
            val = cur_attrs[(signed long int)attr->id];
            val = val + 1;
            if((attr->choices + (signed long int)val)->str == ((const char *)NULL))
              val = 0;

          }

          else
            val=ng_attr_getint(attr, argv[(signed long int)arg]);
          if(val == -1)
          {
            fprintf(stderr, "invalid value for %s: %s\n", attr->name, argv[(signed long int)arg]);
            ng_attr_listchoices(attr);
          }

          else
          {
            set_attr(attr, val);
            set_msg_str(attr->name, (attr->choices + (signed long int)val)->str);
          }
        }

        break;
      }
      case 1:
      {
        if(!(arg >= argc))
        {
          cur_attrs[(signed long int)attr->id]=attr->read(attr);
          val=update_int(attr, cur_attrs[(signed long int)attr->id], argv[(signed long int)arg]);
          set_attr(attr, val);
        }

        set_msg_int(attr, cur_attrs[(signed long int)attr->id]);
        break;
      }
      case 3:
      {
        if(!(arg >= argc))
        {
          val=str_to_int(argv[(signed long int)arg], booltab);
          if(val == -1)
          {
            signed int return_value_strcasecmp$7;
            return_value_strcasecmp$7=strcasecmp(argv[(signed long int)arg], "toggle");
            if(return_value_strcasecmp$7 == 0)
              val = (signed int)!(cur_attrs[(signed long int)attr->id] != 0);

          }

          set_attr(attr, val);
        }

        set_msg_bool(attr->name, cur_attrs[(signed long int)attr->id]);
      }
    }
    if(cur_movie == 0 && !(capture_rel_hook == ((void (*)(void))NULL)))
      capture_rel_hook();

    return 0;
  }
}

// attr_init
// file common/commands.c line 473
void attr_init(void)
{
  struct ng_attribute *attr;
  signed int val;
  attr = attrs;
  _Bool tmp_if_expr$1;
  do
  {
    if(!(attr == ((struct ng_attribute *)NULL)))
      tmp_if_expr$1 = attr->name != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    _Bool tmp_if_expr$2;
    if(attr->id == 3)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = attr->id == 4 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$2)
    {
      val=attr->read(attr);
      if(!(attr_notify == ((void (*)(struct ng_attribute *, signed int))NULL)))
        attr_notify(attr, val);

      cur_attrs[(signed long int)attr->id] = val;
    }

    attr = attr + 1l;
  }
  while((_Bool)1);
  struct ng_attribute *return_value_ng_attr_byid$3;
  if(defaults.color == -1)
  {
    return_value_ng_attr_byid$3=ng_attr_byid(attrs, 6);
    if(!(return_value_ng_attr_byid$3 == ((struct ng_attribute *)NULL)))
      defaults.color = cur_attrs[(signed long int)6];

  }

  struct ng_attribute *return_value_ng_attr_byid$4;
  if(defaults.bright == -1)
  {
    return_value_ng_attr_byid$4=ng_attr_byid(attrs, 7);
    if(!(return_value_ng_attr_byid$4 == ((struct ng_attribute *)NULL)))
      defaults.bright = cur_attrs[(signed long int)7];

  }

  struct ng_attribute *return_value_ng_attr_byid$5;
  if(defaults.hue == -1)
  {
    return_value_ng_attr_byid$5=ng_attr_byid(attrs, 8);
    if(!(return_value_ng_attr_byid$5 == ((struct ng_attribute *)NULL)))
      defaults.hue = cur_attrs[(signed long int)8];

  }

  struct ng_attribute *return_value_ng_attr_byid$6;
  if(defaults.contrast == -1)
  {
    return_value_ng_attr_byid$6=ng_attr_byid(attrs, 9);
    if(!(return_value_ng_attr_byid$6 == ((struct ng_attribute *)NULL)))
      defaults.contrast = cur_attrs[(signed long int)9];

  }

}

// audio_init
// file common/commands.c line 502
void audio_init(void)
{
  struct ng_attribute *attr;
  attr=ng_attr_byid(attrs, 3);
  if(!(attr == ((struct ng_attribute *)NULL)))
    cur_attrs[(signed long int)3]=attr->read(attr);

  attr=ng_attr_byid(attrs, 4);
  if(!(attr == ((struct ng_attribute *)NULL)))
    cur_attrs[(signed long int)4]=attr->read(attr);

  if(!(volume_notify == ((void (*)(void))NULL)))
    volume_notify();

}

// audio_off
// file common/commands.c line 519
void audio_off(void)
{
  set_mute(1);
}

// audio_on
// file common/commands.c line 514
void audio_on(void)
{
  set_mute(0);
}

// bgr24_to_bgr32
// file libng/color_packed.c line 39
static void bgr24_to_bgr32(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned char * restrict s = src;
  unsigned char * restrict d = dest;
  signed int tmp_post$1;
  do
  {
    tmp_post$1 = p;
    p = p - 1;
    if(tmp_post$1 == 0)
      break;

    unsigned char * restrict tmp_post$2 = d;
    d = d + 1l;
    unsigned char * restrict tmp_post$3 = s;
    s = s + 1l;
    *tmp_post$2 = *tmp_post$3;
    unsigned char * restrict tmp_post$4 = d;
    d = d + 1l;
    unsigned char * restrict tmp_post$5 = s;
    s = s + 1l;
    *tmp_post$4 = *tmp_post$5;
    unsigned char * restrict tmp_post$6 = d;
    d = d + 1l;
    unsigned char * restrict tmp_post$7 = s;
    s = s + 1l;
    *tmp_post$6 = *tmp_post$7;
    unsigned char * restrict tmp_post$8 = d;
    d = d + 1l;
    *tmp_post$8 = (unsigned char)0;
  }
  while((_Bool)1);
}

// bgr24_to_lut2
// file libng/color_lut.c line 43
static void bgr24_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned short int * restrict d = (unsigned short int *)dest;
  signed int tmp_post$1;
  do
  {
    tmp_post$1 = p;
    p = p - 1;
    if(!(tmp_post$1 >= 1))
      break;

    unsigned short int * restrict tmp_post$2 = d;
    d = d + 1l;
    *tmp_post$2 = (unsigned short int)(ng_lut_red[(signed long int)src[(signed long int)2]] | ng_lut_green[(signed long int)src[(signed long int)1]] | ng_lut_blue[(signed long int)src[(signed long int)0]]);
    src = src + (signed long int)3;
  }
  while((_Bool)1);
}

// bgr24_to_lut4
// file libng/color_lut.c line 109
static void bgr24_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned int * restrict d = (unsigned int *)dest;
  signed int tmp_post$1;
  do
  {
    tmp_post$1 = p;
    p = p - 1;
    if(!(tmp_post$1 >= 1))
      break;

    unsigned int * restrict tmp_post$2 = d;
    d = d + 1l;
    *tmp_post$2 = (unsigned int)(ng_lut_red[(signed long int)src[(signed long int)2]] | ng_lut_green[(signed long int)src[(signed long int)1]] | ng_lut_blue[(signed long int)src[(signed long int)0]]);
    src = src + (signed long int)3;
  }
  while((_Bool)1);
}

// bgr24_to_rgb32
// file libng/color_packed.c line 54
static void bgr24_to_rgb32(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned char * restrict s = src;
  unsigned char * restrict d = dest;
  signed int tmp_post$1;
  do
  {
    tmp_post$1 = p;
    p = p - 1;
    if(tmp_post$1 == 0)
      break;

    unsigned char * restrict tmp_post$2 = d;
    d = d + 1l;
    *tmp_post$2 = (unsigned char)0;
    unsigned char * restrict tmp_post$3 = d;
    d = d + 1l;
    *tmp_post$3 = s[(signed long int)2];
    unsigned char * restrict tmp_post$4 = d;
    d = d + 1l;
    *tmp_post$4 = s[(signed long int)1];
    unsigned char * restrict tmp_post$5 = d;
    d = d + 1l;
    *tmp_post$5 = s[(signed long int)0];
    s = s + (signed long int)3;
  }
  while((_Bool)1);
}

// bgr32_to_lut2
// file libng/color_lut.c line 69
static void bgr32_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned short int * restrict d = (unsigned short int *)dest;
  signed int tmp_post$1;
  do
  {
    tmp_post$1 = p;
    p = p - 1;
    if(!(tmp_post$1 >= 1))
      break;

    unsigned short int * restrict tmp_post$2 = d;
    d = d + 1l;
    *tmp_post$2 = (unsigned short int)(ng_lut_red[(signed long int)src[(signed long int)2]] | ng_lut_green[(signed long int)src[(signed long int)1]] | ng_lut_blue[(signed long int)src[(signed long int)0]]);
    src = src + (signed long int)4;
  }
  while((_Bool)1);
}

// bgr32_to_lut4
// file libng/color_lut.c line 135
static void bgr32_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned int * restrict d = (unsigned int *)dest;
  signed int tmp_post$1;
  do
  {
    tmp_post$1 = p;
    p = p - 1;
    if(!(tmp_post$1 >= 1))
      break;

    unsigned int * restrict tmp_post$2 = d;
    d = d + 1l;
    *tmp_post$2 = (unsigned int)(ng_lut_red[(signed long int)src[(signed long int)2]] | ng_lut_green[(signed long int)src[(signed long int)1]] | ng_lut_blue[(signed long int)src[(signed long int)0]]);
    src = src + (signed long int)4;
  }
  while((_Bool)1);
}

// byteswap_short
// file libng/color_packed.c line 102
static void byteswap_short(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned char * restrict s = src;
  unsigned char * restrict d = dest;
  do
  {
    p = p - 1;
    if(p == 0)
      break;

    unsigned char * restrict tmp_post$1 = d;
    d = d + 1l;
    *tmp_post$1 = s[(signed long int)1];
    unsigned char * restrict tmp_post$2 = d;
    d = d + 1l;
    *tmp_post$2 = s[(signed long int)0];
    s = s + (signed long int)2;
  }
  while((_Bool)1);
}

// calc_frequencies
// file common/channel.c line 299
void calc_frequencies(void)
{
  signed int i = 0;
  signed int return_value_get_freq$1;
  for( ; !(i >= count); i = i + 1)
    if(!(channels[(signed long int)i]->cname == ((char *)NULL)))
    {
      channels[(signed long int)i]->channel=lookup_channel(channels[(signed long int)i]->cname);
      if(channels[(signed long int)i]->channel == -1)
        channels[(signed long int)i]->freq = -1;

      else
      {
        return_value_get_freq$1=get_freq(channels[(signed long int)i]->channel);
        channels[(signed long int)i]->freq = return_value_get_freq$1 + channels[(signed long int)i]->fine;
      }
    }

}

// capture_handler
// file common/commands.c line 778
static signed int capture_handler(char *name, signed int argc, char **argv)
{
  signed int i;
  signed int temp = 0;
  signed int return_value_strcasecmp$1;
  return_value_strcasecmp$1=strcasecmp(argv[(signed long int)0], "toggle");
  if(return_value_strcasecmp$1 == 0)
    i = cur_capture == 0 ? 9 : 0;

  else
    i=str_to_int(argv[(signed long int)0], captab);
  signed int return_value_strcasecmp$2;
  if(argc == 2)
  {
    return_value_strcasecmp$2=strcasecmp(argv[(signed long int)1], "temp");
    if(return_value_strcasecmp$2 == 0)
      temp = 1;

  }

  if(!(i == -1))
    set_capture(i, temp);

  return 0;
}

// cc_sim
// file common/vbi-sim.c line 22
static inline double cc_sim(double t, double F, unsigned char b1, unsigned char b2)
{
  signed int bits = ((signed int)b2 << 10) + ((signed int)b1 << 2) + 2;
  double t1 = 10.5e-6 - .25 / F;
  double t2 = t1 + (double)7 / F;
  double t3 = t2 + 1.5 / F;
  double t4 = t3 + (double)18 / F;
  double ph;
  if(t < t1)
    return 0.0;

  else
    if(t < t2)
    {
      t = t - t2;
      ph = 3.14159265358979323846 * (double)2 * t * F - 3.14159265358979323846 * .5;
      double return_value_sin$1;
      return_value_sin$1=sin(ph);
      return return_value_sin$1 / (double)2 + .5;
    }

    else
      if(t < t3)
        return 0.0;

      else
        if(t < t4)
        {
          signed int i;
          signed int n;
          t = t - t3;
          i = (signed int)(t * F - .0);
          n = bits >> i & 3;
          if(n == 0)
            return 0.0;

          else
            if(n == 3)
              return 1.0;

          if(!(((i ^ n) & 1) == 0))
            ph = (3.14159265358979323846 * (double)2 * (t - (double)1 / F) * F) / (double)4;

          else
            ph = (3.14159265358979323846 * (double)2 * (t - (double)0 / F) * F) / (double)4;
          double return_value_shape$2;
          return_value_shape$2=shape(ph);
          return return_value_shape$2;
        }

        else
          return 0.0;
}

// cf2freq
// file common/channel.c line 159
signed int cf2freq(char *name, signed int fine)
{
  signed int i;
  i=lookup_channel(name);
  if(i == -1)
    return -1;

  else
  {
    signed int return_value_get_freq$1;
    return_value_get_freq$1=get_freq(i);
    return return_value_get_freq$1 + fine;
  }
}

// cfg_find_section
// file common/parseconfig.c line 61
static struct CFG_ENTRIES * cfg_find_section(struct CFG_SECTIONS *c, char *name)
{
  struct CFG_ENTRIES *e;
  signed int i = 0;
  signed int return_value_strcasecmp$1;
  for( ; !(i >= c->sec_count); i = i + 1)
  {
    return_value_strcasecmp$1=strcasecmp(c->sec_names[(signed long int)i], name);
    if(return_value_strcasecmp$1 == 0)
      return c->sec_entries[(signed long int)i];

  }
  if(c->sec_count % 16 == 16)
  {
    void *return_value_realloc$2;
    return_value_realloc$2=realloc((void *)c->sec_names, (unsigned long int)(c->sec_count + 2 + 16) * sizeof(char *) /*8ul*/ );
    c->sec_names = (char **)return_value_realloc$2;
    void *return_value_realloc$3;
    return_value_realloc$3=realloc((void *)c->sec_entries, (unsigned long int)(c->sec_count + 2 + 16) * sizeof(struct CFG_ENTRIES *) /*8ul*/ );
    c->sec_entries = (struct CFG_ENTRIES **)return_value_realloc$3;
  }

  e=cfg_init_entries();
  c->sec_names[(signed long int)c->sec_count]=strdup(name);
  c->sec_entries[(signed long int)c->sec_count] = e;
  c->sec_count = c->sec_count + 1;
  c->sec_names[(signed long int)c->sec_count] = (char *)(void *)0;
  c->sec_entries[(signed long int)c->sec_count] = (struct CFG_ENTRIES *)(void *)0;
  return e;
}

// cfg_get_float
// file common/parseconfig.c line 245
float cfg_get_float(char *sec, char *ent)
{
  char *val;
  val=cfg_get_str(sec, ent);
  if(val == ((char *)NULL))
    return (float)-1;

  else
  {
    double return_value_atof$1;
    return_value_atof$1=atof(val);
    return (float)return_value_atof$1;
  }
}

// cfg_get_int
// file common/parseconfig.h line 8
signed int cfg_get_int(char *sec, char *ent)
{
  char *val;
  val=cfg_get_str(sec, ent);
  if(val == ((char *)NULL))
    return -1;

  else
  {
    signed int return_value_atoi$1;
    return_value_atoi$1=atoi(val);
    return return_value_atoi$1;
  }
}

// cfg_get_signed_int
// file common/parseconfig.h line 9
signed int cfg_get_signed_int(char *sec, char *ent)
{
  char *val;
  val=cfg_get_str(sec, ent);
  if(val == ((char *)NULL))
    return 0;

  else
  {
    signed int return_value_atoi$1;
    return_value_atoi$1=atoi(val);
    return return_value_atoi$1;
  }
}

// cfg_get_str
// file common/parseconfig.h line 7
char * cfg_get_str(char *sec, char *ent)
{
  struct CFG_ENTRIES *e = (struct CFG_ENTRIES *)(void *)0;
  char *v = (char *)(void *)0;
  signed int i = 0;
  signed int return_value_strcasecmp$1;
  for( ; !(i >= c->sec_count); i = i + 1)
  {
    return_value_strcasecmp$1=strcasecmp(c->sec_names[(signed long int)i], sec);
    if(return_value_strcasecmp$1 == 0)
      e = c->sec_entries[(signed long int)i];

  }
  signed int return_value_strcasecmp$2;
  if(e == ((struct CFG_ENTRIES *)NULL))
    return (char *)(void *)0;

  else
  {
    i = 0;
    for( ; !(i >= e->ent_count); i = i + 1)
    {
      return_value_strcasecmp$2=strcasecmp(e->ent_names[(signed long int)i], ent);
      if(return_value_strcasecmp$2 == 0)
      {
        v = e->ent_values[(signed long int)i];
        e->ent_seen[(signed long int)i] = e->ent_seen[(signed long int)i] + 1l;
      }

    }
    return v;
  }
}

// cfg_init_entries
// file common/parseconfig.c line 46
static struct CFG_ENTRIES * cfg_init_entries(void)
{
  struct CFG_ENTRIES *e;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct CFG_ENTRIES) /*32ul*/ );
  e = (struct CFG_ENTRIES *)return_value_malloc$1;
  memset((void *)e, 0, sizeof(struct CFG_ENTRIES) /*32ul*/ );
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)16 * sizeof(char *) /*8ul*/ );
  e->ent_names = (char **)return_value_malloc$2;
  e->ent_names[(signed long int)0] = (char *)(void *)0;
  void *return_value_malloc$3;
  return_value_malloc$3=malloc((unsigned long int)16 * sizeof(char *) /*8ul*/ );
  e->ent_values = (char **)return_value_malloc$3;
  e->ent_values[(signed long int)0] = (char *)(void *)0;
  void *return_value_malloc$4;
  return_value_malloc$4=malloc((unsigned long int)16 * sizeof(signed int *) /*8ul*/ );
  e->ent_seen = (signed int **)return_value_malloc$4;
  e->ent_seen[(signed long int)0] = ((signed int *)NULL);
  return e;
}

// cfg_init_sections
// file common/parseconfig.c line 33
static struct CFG_SECTIONS * cfg_init_sections(void)
{
  struct CFG_SECTIONS *cfg_init_sections$$1$$c;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct CFG_SECTIONS) /*24ul*/ );
  cfg_init_sections$$1$$c = (struct CFG_SECTIONS *)return_value_malloc$1;
  memset((void *)cfg_init_sections$$1$$c, 0, sizeof(struct CFG_SECTIONS) /*24ul*/ );
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)16 * sizeof(char *) /*8ul*/ );
  cfg_init_sections$$1$$c->sec_names = (char **)return_value_malloc$2;
  cfg_init_sections$$1$$c->sec_names[(signed long int)0] = (char *)(void *)0;
  void *return_value_malloc$3;
  return_value_malloc$3=malloc((unsigned long int)16 * sizeof(struct CFG_ENTRIES *) /*8ul*/ );
  cfg_init_sections$$1$$c->sec_entries = (struct CFG_ENTRIES **)return_value_malloc$3;
  cfg_init_sections$$1$$c->sec_entries[(signed long int)0] = (struct CFG_ENTRIES *)(void *)0;
  return cfg_init_sections$$1$$c;
}

// cfg_list_entries
// file common/parseconfig.h line 6
char ** cfg_list_entries(char *name)
{
  signed int i;
  signed int return_value_strcasecmp$1;
  if(c == ((struct CFG_SECTIONS *)NULL))
    return (char **)(void *)0;

  else
  {
    i = 0;
    for( ; !(i >= c->sec_count); i = i + 1)
    {
      return_value_strcasecmp$1=strcasecmp(c->sec_names[(signed long int)i], name);
      if(return_value_strcasecmp$1 == 0)
        return c->sec_entries[(signed long int)i]->ent_names;

    }
    return (char **)(void *)0;
  }
}

// cfg_list_sections
// file common/parseconfig.h line 5
char ** cfg_list_sections(void)
{
  return c->sec_names;
}

// cfg_parse_file
// file common/parseconfig.h line 1
signed int cfg_parse_file(char *filename)
{
  struct CFG_ENTRIES *e = (struct CFG_ENTRIES *)(void *)0;
  char line[256l];
  char tag[64l];
  char value[192l];
  struct _IO_FILE *fp;
  signed int nr;
  if(c == ((struct CFG_SECTIONS *)NULL))
    c=cfg_init_sections();

  fp=fopen(filename, "r");
  char *return_value_fgets$1;
  signed int return_value_sscanf$6;
  if(fp == ((struct _IO_FILE *)NULL))
    return -1;

  else
  {
    nr = 0;
    do
    {
      return_value_fgets$1=fgets(line, 255, fp);
      if(return_value_fgets$1 == ((char *)NULL))
        break;

      nr = nr + 1;
      _Bool tmp_if_expr$2;
      if((signed int)line[0l] == 10)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)line[(signed long int)0] == 35 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$3;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)line[(signed long int)0] == 37 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$3)
      {
        signed int return_value_sscanf$7;
        return_value_sscanf$7=sscanf(line, "[%99[^]]]", (const void *)value);
        if(return_value_sscanf$7 == 1)
          e=cfg_find_section(c, value);

        else
        {
          return_value_sscanf$6=sscanf(line, " %63[^= ] = %191[^\n]", (const void *)tag, (const void *)value);
          if(return_value_sscanf$6 == 2)
          {
            if(e == ((struct CFG_ENTRIES *)NULL))
              fprintf(stderr, "%s:%d: error: no section\n", filename, nr);

            else
            {
              char *cfg_parse_file$$1$$1$$2$$2$$c;
              unsigned long int return_value_strlen$4;
              return_value_strlen$4=strlen(value);
              cfg_parse_file$$1$$1$$2$$2$$c = (value + (signed long int)return_value_strlen$4) - (signed long int)1;
              while(!(value >= cfg_parse_file$$1$$1$$2$$2$$c))
              {
                if(!((signed int)*cfg_parse_file$$1$$1$$2$$2$$c == 32))
                {
                  if(!((signed int)*cfg_parse_file$$1$$1$$2$$2$$c == 9))
                    break;

                }

                char *tmp_post$5 = cfg_parse_file$$1$$1$$2$$2$$c;
                cfg_parse_file$$1$$1$$2$$2$$c = cfg_parse_file$$1$$1$$2$$2$$c - 1l;
                *tmp_post$5 = (char)0;
              }
              cfg_set_entry(e, tag, value);
            }
          }

          else
            fprintf(stderr, "%s:%d: syntax error\n", filename, nr);
        }
      }

    }
    while((_Bool)1);
    fclose(fp);
    return 0;
  }
}

// cfg_parse_option
// file common/parseconfig.c line 153
void cfg_parse_option(char *section, char *tag, char *value)
{
  struct CFG_ENTRIES *e = (struct CFG_ENTRIES *)(void *)0;
  if(c == ((struct CFG_SECTIONS *)NULL))
    c=cfg_init_sections();

  e=cfg_find_section(c, section);
  cfg_set_entry(e, tag, value);
}

// cfg_parse_options
// file common/parseconfig.h line 3
void cfg_parse_options(signed int *argc, char **argv)
{
  char section[64l];
  char tag[64l];
  signed int i;
  signed int j;
  i = 1;
  while(!(1 + i >= *argc))
  {
    signed int return_value_sscanf$1;
    return_value_sscanf$1=sscanf(argv[(signed long int)i], "-%63[^:]:%63s", (const void *)section, (const void *)tag);
    if(return_value_sscanf$1 == 2)
    {
      cfg_parse_option(section, tag, argv[(signed long int)(i + 1)]);
      j = i;
      for( ; !(j >= *argc + -1); j = j + 1)
        argv[(signed long int)j] = argv[(signed long int)(j + 2)];
      *argc = *argc - 2;
    }

    else
      i = i + 1;
  }
}

// cfg_set_entry
// file common/parseconfig.c line 85
static void cfg_set_entry(struct CFG_ENTRIES *e, char *name, char *value)
{
  signed int i = 0;
  signed int return_value_strcasecmp$1;
  for( ; !(i >= e->ent_count); i = i + 1)
  {
    return_value_strcasecmp$1=strcasecmp(e->ent_names[(signed long int)i], name);
    if(return_value_strcasecmp$1 == 0)
      break;

  }
  if(i == e->ent_count)
  {
    if(e->ent_count % 16 == 16)
    {
      void *return_value_realloc$2;
      return_value_realloc$2=realloc((void *)e->ent_names, (unsigned long int)(e->ent_count + 2 + 16) * sizeof(char *) /*8ul*/ );
      e->ent_names = (char **)return_value_realloc$2;
      void *return_value_realloc$3;
      return_value_realloc$3=realloc((void *)e->ent_values, (unsigned long int)(e->ent_count + 2 + 16) * sizeof(char *) /*8ul*/ );
      e->ent_values = (char **)return_value_realloc$3;
      void *return_value_realloc$4;
      return_value_realloc$4=realloc((void *)e->ent_seen, (unsigned long int)(e->ent_count + 2 + 16) * sizeof(signed int *) /*8ul*/ );
      e->ent_seen = (signed int **)return_value_realloc$4;
    }

    e->ent_count = e->ent_count + 1;
    e->ent_names[(signed long int)e->ent_count] = (char *)(void *)0;
    e->ent_values[(signed long int)e->ent_count] = (char *)(void *)0;
    e->ent_seen[(signed long int)e->ent_count] = ((signed int *)NULL);
  }

  e->ent_names[(signed long int)i]=strdup(name);
  e->ent_values[(signed long int)i]=strdup(value);
}

// clip_drop
// file libng/grab-ng.c line 841
static void clip_drop(struct OVERLAY_CLIP *oc, signed int n, signed int *count)
{
  *count = *count - 1;
  memmove((void *)(oc + (signed long int)n), (const void *)(oc + (signed long int)n + (signed long int)1), sizeof(struct OVERLAY_CLIP) /*16ul*/  * (unsigned long int)(*count - n));
}

// clip_dump
// file libng/grab-ng.c line 829
static void clip_dump(char *state, struct OVERLAY_CLIP *oc, signed int count)
{
  signed int i;
  fprintf(stderr, "clip: %s - %d clips\n", state, count);
  i = 0;
  for( ; !(i >= count); i = i + 1)
    fprintf(stderr, "clip:   %d: %dx%d+%d+%d\n", i, (oc + (signed long int)i)->x2 - (oc + (signed long int)i)->x1, (oc + (signed long int)i)->y2 - (oc + (signed long int)i)->y1, (oc + (signed long int)i)->x1, (oc + (signed long int)i)->y1);
}

// dattr_handler
// file common/commands.c line 980
static signed int dattr_handler(char *name, signed int argc, char **argv)
{
  struct ng_attribute *attr = (struct ng_attribute *)(void *)0;
  unsigned int i;
  signed int return_value_strcasecmp$1;
  if(argc >= 1)
  {
    return_value_strcasecmp$1=strcasecmp(argv[(signed long int)0], "next");
    if(return_value_strcasecmp$1 == 0)
    {
      i = (unsigned int)0;
      for( ; !((unsigned long int)i >= 2ul); i = i + 1u)
      {
        cur_dattr = cur_dattr + 1;
        cur_dattr = cur_dattr % (signed int)(sizeof(signed int [5l]) /*20ul*/  / sizeof(char *) /*8ul*/ );
        attr=ng_attr_byid(attrs, dattr[(signed long int)cur_dattr]);
        if(!(attr == ((struct ng_attribute *)NULL)))
          break;

      }
      if(attr == ((struct ng_attribute *)NULL))
        return 0;

      argc = 0;
    }

  }

  if(attr == ((struct ng_attribute *)NULL))
    attr=ng_attr_byid(attrs, dattr[(signed long int)cur_dattr]);

  if(attr == ((struct ng_attribute *)NULL))
    return 0;

  else
  {
    signed int return_value_attr_handler$2;
    return_value_attr_handler$2=attr_handler((char *)attr->name, argc, argv);
    return return_value_attr_handler$2;
  }
}

// debug_action
// file x11/mtt.c line 119
static void debug_action(struct _WidgetRec *widget, union _XEvent *event, char **params, unsigned int *num_params)
{
  fprintf(stderr, "debug_action: called\n");
}

// del_channel
// file common/channel.c line 287
void del_channel(signed int i)
{
  free((void *)channels[(signed long int)i]->name);
  if(!(channels[(signed long int)i]->key == ((char *)NULL)))
    free((void *)channels[(signed long int)i]->key);

  free((void *)channels[(signed long int)i]);
  count = count - 1;
  if(!(i >= count))
    memmove((void *)(channels + (signed long int)i), (const void *)(channels + (signed long int)i + (signed long int)1), (unsigned long int)(count - i) * sizeof(struct CHANNEL *) /*8ul*/ );

}

// dev_init
// file console/fbtools.c line 74
static void dev_init(void)
{
  struct stat dummy;
  if(devices == ((struct DEVS *)NULL))
  {
    signed int return_value_stat$1;
    return_value_stat$1=stat("/dev/.devfsd", &dummy);
    if(return_value_stat$1 == 0)
      devices = &devs_devfs;

    else
      devices = &devs_default;
  }

}

// discover_media_devices
// file ./common/get_media_devices.h line 81
void * discover_media_devices(void)
{
  struct media_devices *md = (struct media_devices *)(void *)0;
  struct media_device_entry *md_entry = (struct media_device_entry *)(void *)0;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct media_devices) /*16ul*/ );
  md = (struct media_devices *)return_value_calloc$1;
  signed int return_value_get_class$3;
  signed int return_value_get_class$4;
  if(md == ((struct media_devices *)NULL))
    return (void *)0;

  else
  {
    md->md_size = (unsigned int)0;
    signed int return_value_get_class$2;
    return_value_get_class$2=get_class("video4linux", &md_entry, &md->md_size, add_v4l_class);
    if(return_value_get_class$2 == 0)
    {
      return_value_get_class$3=get_class("sound", &md_entry, &md->md_size, add_snd_class);
      if(!(return_value_get_class$3 == 0))
        goto error;

      return_value_get_class$4=get_class("dvb", &md_entry, &md->md_size, add_dvb_class);
      if(!(return_value_get_class$4 == 0))
        goto error;

      if(md_entry == ((struct media_device_entry *)NULL))
        goto error;

      qsort((void *)md_entry, (unsigned long int)md->md_size, sizeof(struct media_device_entry) /*32ul*/ , sort_media_device_entry);
      md->md_entry = md_entry;
      return (void *)md;
    }

    else
    {

    error:
      ;
      free_media_devices((void *)md);
      return (void *)0;
    }
  }
}

// display_media_devices
// file common/get_media_devices.c line 418
void display_media_devices(void *opaque)
{
  struct media_devices *md = (struct media_devices *)opaque;
  struct media_device_entry *md_ptr = md->md_entry;
  signed int i;
  char *prev = "";
  i = 0;
  for( ; !((unsigned int)i >= md->md_size); i = i + 1)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(prev, md_ptr->device);
    if(!(return_value_strcmp$1 == 0))
    {
      printf("\nDevice %s:\n\t", md_ptr->device);
      prev = md_ptr->device;
    }

    const char *return_value_media_device_type$2;
    return_value_media_device_type$2=media_device_type(md_ptr->type);
    printf("%s(%s, dev %i:%i) ", md_ptr->node, return_value_media_device_type$2, md_ptr->major, md_ptr->minor);
    md_ptr = md_ptr + 1l;
  }
  printf("\n");
}

// do_command
// file common/commands.c line 240
signed int do_command(signed int argc, char **argv)
{
  signed int i;
  signed int return_value_strcasecmp$1;
  if(argc == 0)
  {
    fprintf(stderr, "do_command: no argument\n");
    return -1;
  }

  else
  {
    if(!(debug == 0))
    {
      fprintf(stderr, "cmd:");
      i = 0;
      for( ; !(i >= argc); i = i + 1)
        fprintf(stderr, " \"%s\"", argv[(signed long int)i]);
      fprintf(stderr, "\n");
    }

    i = 0;
    for( ; !(commands[(signed long int)i].name == ((char *)NULL)); i = i + 1)
    {
      return_value_strcasecmp$1=strcasecmp(commands[(signed long int)i].name, argv[(signed long int)0]);
      if(return_value_strcasecmp$1 == 0)
        break;

    }
    if(commands[(signed long int)i].name == ((char *)NULL))
    {
      fprintf(stderr, "no handler for %s\n", argv[(signed long int)0]);
      return -1;
    }

    else
      if(!(argc + -1 >= commands[(signed long int)i].min_args))
      {
        fprintf(stderr, "no enough args for %s\n", argv[(signed long int)0]);
        return -1;
      }

      else
      {
        signed int return_value;
        return_value=commands[(signed long int)i].handler(argv[(signed long int)0], argc - 1, argv + (signed long int)1);
        return return_value;
      }
  }
}

// do_va_cmd
// file ./common/commands.h line 77
signed int do_va_cmd(signed int argc, ...)
{
  __builtin_va_list ap;
  signed int i;
  char *argv[32l];
  va_start(ap, argc);
  i = 0;
  for( ; !(i >= argc); i = i + 1)
    argv[(signed long int)i]=va_arg(ap, __typeof__(argv[(signed long int)i]));
  argv[(signed long int)i] = (char *)(void *)0;
  va_end(ap);
  signed int return_value_do_command$1;
  return_value_do_command$1=do_command(argc, argv);
  return return_value_do_command$1;
}

// do_write_jpeg
// file libng/writefile.c line 87
static signed int do_write_jpeg(struct _IO_FILE *fp, struct ng_video_buf *buf, signed int quality, signed int gray)
{
  struct jpeg_compress_struct cinfo;
  struct jpeg_error_mgr jerr;
  unsigned int i;
  unsigned char *line;
  signed int line_length;
  cinfo.err=jpeg_std_error(&jerr);
  jpeg_CreateCompress(&cinfo, 62, (unsigned long int)sizeof(struct jpeg_compress_struct) /*520ul*/ );
  jpeg_stdio_dest(&cinfo, fp);
  cinfo.image_width = buf->fmt.width;
  cinfo.image_height = buf->fmt.height;
  cinfo.input_components = gray != 0 ? 1 : 3;
  cinfo.in_color_space = (enum anonymous$5)(gray != 0 ? JCS_GRAYSCALE : JCS_RGB);
  jpeg_set_defaults(&cinfo);
  jpeg_set_quality(&cinfo, quality, 1);
  jpeg_start_compress(&cinfo, 1);
  unsigned int tmp_if_expr$1;
  if(!(gray == 0))
    tmp_if_expr$1 = buf->fmt.width;

  else
    tmp_if_expr$1 = buf->fmt.width * (unsigned int)3;
  line_length = (signed int)tmp_if_expr$1;
  i = (unsigned int)0;
  line = buf->data;
  for( ; !(i >= buf->fmt.height); line = line + (signed long int)line_length)
  {
    jpeg_write_scanlines(&cinfo, &line, (unsigned int)1);
    i = i + 1u;
  }
  jpeg_finish_compress(&cinfo);
  jpeg_destroy_compress(&cinfo);
  fclose(fp);
  return 0;
}

// event_dispatch
// file common/event.c line 112
signed int event_dispatch(char *event)
{
  struct event_entry *entry = (struct event_entry *)(void *)0;
  char *name;
  char *arg;
  char *h;
  char *argv[16l];
  signed int argc;
  h=strchr(event, 40);
  if(!(h == ((char *)NULL)))
  {
    name = event;
    arg = h + (signed long int)1;
    *h = (char)0;
    h=strchr(arg, 41);
    if(!(h == ((char *)NULL)))
      *h = (char)0;

    if(!(debug == 0))
      fprintf(stderr, "ev: dispatch name=%s arg=%s\n", name, arg);

  }

  else
  {
    name = event;
    arg = (char *)(void *)0;
    if(!(debug == 0))
      fprintf(stderr, "ev: dispatch name=%s\n", name);

  }
  signed int return_value_strcasecmp$1;
  if(entry == ((struct event_entry *)NULL))
  {
    entry = event_conf_list;
    for( ; !(entry == ((struct event_entry *)NULL)); entry = entry->next)
    {
      return_value_strcasecmp$1=strcasecmp(name, entry->event);
      if(return_value_strcasecmp$1 == 0)
        break;

    }
  }

  signed int return_value_strcasecmp$2;
  if(entry == ((struct event_entry *)NULL))
  {
    entry = event_builtin_list;
    for( ; !(entry == ((struct event_entry *)NULL)); entry = entry->next)
    {
      return_value_strcasecmp$2=strcasecmp(name, entry->event);
      if(return_value_strcasecmp$2 == 0)
        break;

    }
  }

  if(entry == ((struct event_entry *)NULL))
  {
    if(!(debug == 0))
      fprintf(stderr, "ev: 404: %s\n", name);

    return 0;
  }

  else
  {
    memcpy((void *)argv, (const void *)entry->argv, sizeof(char *[16l]) /*128ul*/ );
    argc = entry->argc;
    if(!(arg == ((char *)NULL)))
    {
      signed int tmp_post$3 = argc;
      argc = argc + 1;
      argv[(signed long int)tmp_post$3] = arg;
    }

    do_command(argc, argv);
    return 0;
  }
}

// event_readconfig
// file common/event.h line 20
void event_readconfig(void)
{
  char **list;
  char *val;
  list=cfg_list_entries("eventmap");
  if(!(list == ((char **)NULL)))
    for( ; !(*list == ((char *)NULL)); list = list + 1l)
    {
      val=cfg_get_str("eventmap", *list);
      if(!(val == ((char *)NULL)))
        event_register(*list, val);

    }

}

// event_register
// file common/event.c line 54
signed int event_register(char *event, char *action)
{
  struct event_entry *entry;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct event_entry) /*528ul*/ );
  entry = (struct event_entry *)return_value_malloc$1;
  memset((void *)entry, 0, sizeof(struct event_entry) /*528ul*/ );
  strncpy(entry->event, event, (unsigned long int)127);
  strncpy(entry->action, action, (unsigned long int)127);
  entry->next = event_conf_list;
  event_conf_list = entry;
  parse_action(entry);
  if(!(debug == 0))
    fprintf(stderr, "ev: reg conf \"%s\" => \"%s\"\n", (const void *)entry->event, (const void *)entry->action);

  return 0;
}

// event_register_list
// file common/event.c line 71
signed int event_register_list(struct event_entry *entry)
{
  _Bool tmp_if_expr$1;
  do
  {
    if(!(entry == ((struct event_entry *)NULL)))
      tmp_if_expr$1 = 0 != (signed int)entry->event[(signed long int)0] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    entry->next = event_builtin_list;
    event_builtin_list = entry;
    parse_action(entry);
    if(!(debug == 0))
      fprintf(stderr, "ev: reg built-in \"%s\" => \"%s\"\n", (const void *)entry->event, (const void *)entry->action);

    entry = entry + 1l;
  }
  while((_Bool)1);
  return 0;
}

// event_writeconfig
// file common/event.h line 21
void event_writeconfig(struct _IO_FILE *fp)
{
  struct event_entry *entry;
  if(!(event_conf_list == ((struct event_entry *)NULL)))
  {
    fprintf(fp, "[eventmap]\n");
    entry = event_conf_list;
    for( ; !(entry == ((struct event_entry *)NULL)); entry = entry->next)
      fprintf(fp, "%s = %s\n", (const void *)entry->event, (const void *)entry->action);
    fprintf(fp, "\n");
  }

}

// exit_handler
// file common/commands.c line 1189
static signed int exit_handler(char *name, signed int argc, char **argv)
{
  if(!(exit_hook == ((void (*)(void))NULL)))
    exit_hook();

  return 0;
}

// export_charset_cb
// file x11/vbi-gui.c line 573
static void export_charset_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  struct vbi_window *vw = (struct vbi_window *)clientdata;
  vw->charset=XtName(widget);
}

// export_do_save_cb
// file x11/vbi-gui.c line 539
static void export_do_save_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  struct anonymous$0 *cb = (struct anonymous$0 *)call_data;
  struct vbi_window *vw = (struct vbi_window *)clientdata;
  char *filename;
  char *data;
  signed int len;
  signed int fh;
  if(cb->reason == 31)
  {
    void *return_value_XmStringUnparse$1;
    return_value_XmStringUnparse$1=XmStringUnparse(cb->value, (char *)(void *)0, (enum anonymous$3)XmMULTIBYTE_TEXT, (enum anonymous$3)XmMULTIBYTE_TEXT, (struct __XmParseMappingRec **)(void *)0, (unsigned int)0, (enum anonymous$4)0);
    filename = (char *)return_value_XmStringUnparse$1;
    void *return_value_malloc$2;
    return_value_malloc$2=malloc((unsigned long int)(25 * 41 * 8));
    data = (char *)return_value_malloc$2;
    static struct vbi_rect rect = { .x1=0, .x2=41, .y1=0, .y2=25 };
    len=vbi_export_txt(data, vw->charset, 25 * 41 * 8, &vw->pg, &rect, (enum vbi_txt_colors)VBI_NOCOLOR);
    fh=open(filename, 01 | 0100, 0666);
    if(fh == -1)
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      char *return_value_strerror$4;
      return_value_strerror$4=strerror(*return_value___errno_location$3);
      fprintf(stderr, "open %s: %s\n", filename, return_value_strerror$4);
    }

    else
    {
      ftruncate(fh, (signed long int)0);
      write(fh, (const void *)data, (unsigned long int)len);
      close(fh);
    }
    free((void *)data);
  }

  XtUnmanageChild(widget);
}

// export_save_cb
// file x11/vbi-gui.c line 580
static void export_save_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  struct vbi_window *vw = (struct vbi_window *)clientdata;
  struct _WidgetRec *help;
  struct _WidgetRec *text;
  struct _WidgetRec *menu;
  struct _WidgetRec *option;
  struct _WidgetRec *push;
  struct anonymous$1 export_save_cb$$1$$args[2l];
  if(vw->savebox == ((struct _WidgetRec *)NULL))
  {
    vw->savebox=XmCreateFileSelectionDialog(vw->shell, "save", (struct anonymous$1 *)(void *)0, (unsigned int)0);
    help=XmFileSelectionBoxGetChild(vw->savebox, (unsigned char)7);
    text=XmFileSelectionBoxGetChild(vw->savebox, (unsigned char)13);
    XtUnmanageChild(help);
    menu=XmCreatePulldownMenu(vw->savebox, "formatM", (struct anonymous$1 *)(void *)0, (unsigned int)0);
    export_save_cb$$1$$args[(signed long int)0].name = (char *)&_XmStrings[(signed long int)9963];
    export_save_cb$$1$$args[(signed long int)0].value = (signed long int)menu;
    option=XmCreateOptionMenu(vw->savebox, "format", export_save_cb$$1$$args, (unsigned int)1);
    XtManageChild(option);
    vw->charset=nl_langinfo(14);
    push=XtVaCreateManagedWidget(vw->charset, xmPushButtonWidgetClass, menu, (void *)0);
    XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], export_charset_cb, (void *)vw);
    signed int return_value_strcasecmp$1;
    return_value_strcasecmp$1=strcasecmp(vw->charset, "UTF-8");
    if(!(return_value_strcasecmp$1 == 0))
    {
      push=XtVaCreateManagedWidget("UTF-8", xmPushButtonWidgetClass, menu, (void *)0);
      XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], export_charset_cb, (void *)vw);
    }

    signed int return_value_strcasecmp$2;
    return_value_strcasecmp$2=strcasecmp(vw->charset, "ISO-8859-1");
    if(!(return_value_strcasecmp$2 == 0))
    {
      push=XtVaCreateManagedWidget("ISO-8859-1", xmPushButtonWidgetClass, menu, (void *)0);
      XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], export_charset_cb, (void *)vw);
    }

    signed int return_value_strcasecmp$3;
    return_value_strcasecmp$3=strcasecmp(vw->charset, "US-ASCII");
    if(!(return_value_strcasecmp$3 == 0))
    {
      push=XtVaCreateManagedWidget("US-ASCII", xmPushButtonWidgetClass, menu, (void *)0);
      XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], export_charset_cb, (void *)vw);
    }

    XtAddCallback(vw->savebox, (char *)&_XmStrings[(signed long int)8560], export_do_save_cb, (void *)vw);
    XtAddCallback(vw->savebox, (char *)&_XmStrings[(signed long int)5319], export_do_save_cb, (void *)vw);
  }

  XtManageChild(vw->savebox);
}

// fb_activate_current
// file console/fbtools.c line 304
static signed int fb_activate_current(signed int tty)
{
  struct vt_stat vts;
  signed int return_value_ioctl$1;
  return_value_ioctl$1=ioctl(tty, (unsigned long int)0x5603, &vts);
  if(return_value_ioctl$1 == -1)
  {
    perror("ioctl VT_GETSTATE");
    return -1;
  }

  else
  {
    signed int return_value_ioctl$2;
    return_value_ioctl$2=ioctl(tty, (unsigned long int)0x5606, vts.v_active);
    if(return_value_ioctl$2 == -1)
    {
      perror("ioctl VT_ACTIVATE");
      return -1;
    }

    else
    {
      signed int return_value_ioctl$3;
      return_value_ioctl$3=ioctl(tty, (unsigned long int)0x5607, vts.v_active);
      if(return_value_ioctl$3 == -1)
      {
        perror("ioctl VT_WAITACTIVE");
        return -1;
      }

      else
        return 0;
    }
  }
}

// fb_catch_exit_signal
// file console/fbtools.c line 493
static void fb_catch_exit_signal(signed int signal)
{
  siglongjmp(fb_fatal_cleanup, signal);
}

// fb_catch_exit_signals
// file console/fbtools.h line 17
void fb_catch_exit_signals(void)
{
  struct sigaction act;
  struct sigaction old;
  signed int termsig;
  memset((void *)&act, 0, sizeof(struct sigaction) /*152ul*/ );
  act.__sigaction_handler.sa_handler = fb_catch_exit_signal;
  sigemptyset(&act.sa_mask);
  sigaction(2, &act, &old);
  sigaction(3, &act, &old);
  sigaction(15, &act, &old);
  sigaction(6, &act, &old);
  sigaction(20, &act, &old);
  sigaction(7, &act, &old);
  sigaction(4, &act, &old);
  sigaction(11, &act, &old);
  termsig=__sigsetjmp(fb_fatal_cleanup, 0);
  if(!(termsig == 0))
  {
    fb_cleanup();
    fprintf(stderr, "Oops: %s\n", sys_siglist[(signed long int)termsig]);
    exit(42);
  }

}

// fb_cleanup
// file console/fbtools.h line 16
void fb_cleanup(void)
{
  signed int return_value_ioctl$1;
  return_value_ioctl$1=ioctl(fb, (unsigned long int)0x4601, &fb_ovar);
  if(return_value_ioctl$1 == -1)
    perror("ioctl FBIOPUT_VSCREENINFO");

  signed int return_value_ioctl$2;
  return_value_ioctl$2=ioctl(fb, (unsigned long int)0x4602, &fb_fix);
  if(return_value_ioctl$2 == -1)
    perror("ioctl FBIOGET_FSCREENINFO");

  if(fb_fix.visual == 4u || fb_ovar.bits_per_pixel == 8u)
  {
    signed int return_value_ioctl$3;
    return_value_ioctl$3=ioctl(fb, (unsigned long int)0x4605, &ocmap);
    if(return_value_ioctl$3 == -1)
      perror("ioctl FBIOPUTCMAP");

  }

  close(fb);
  signed int return_value_ioctl$4;
  return_value_ioctl$4=ioctl(tty, (unsigned long int)0x4B3A, kd_mode);
  if(return_value_ioctl$4 == -1)
    perror("ioctl KDSETMODE");

  signed int return_value_ioctl$5;
  return_value_ioctl$5=ioctl(tty, (unsigned long int)0x5602, &vt_omode);
  if(return_value_ioctl$5 == -1)
    perror("ioctl VT_SETMODE");

  signed int return_value_ioctl$6;
  if(!(orig_vt_no == 0))
  {
    return_value_ioctl$6=ioctl(tty, (unsigned long int)0x5606, orig_vt_no);
    if(return_value_ioctl$6 == -1)
      perror("ioctl VT_ACTIVATE");

  }

  signed int return_value_ioctl$7;
  if(!(orig_vt_no == 0))
  {
    return_value_ioctl$7=ioctl(tty, (unsigned long int)0x5607, orig_vt_no);
    if(return_value_ioctl$7 == -1)
      perror("ioctl VT_WAITACTIVE");

  }

  tcsetattr(tty, 0, &term);
  close(tty);
}

// fb_clear
// file console/vbi-tty.c line 73
static void fb_clear(void)
{
  fb_memset((void *)(fb_mem + (signed long int)fb_mem_offset), 0, (unsigned long int)fb_fix.smem_len);
}

// fb_init
// file console/fbtools.h line 15
signed int fb_init(char *device, char *mode, signed int vt)
{
  char fbdev[16l];
  struct vt_stat vts;
  dev_init();
  tty = 0;
  if(!(vt == 0))
    fb_setvt(vt);

  signed int return_value_ioctl$3;
  return_value_ioctl$3=ioctl(tty, (unsigned long int)0x5603, &vts);
  if(return_value_ioctl$3 == -1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    fprintf(stderr, "ioctl VT_GETSTATE: %s (not a linux console?)\n", return_value_strerror$2);
    exit(1);
  }

  if(device == ((char *)NULL))
  {
    device=getenv("FRAMEBUFFER");
    if(device == ((char *)NULL))
    {
      struct fb_con2fbmap c2m;
      fb=open(devices->fb0, 01, 0);
      if(fb == -1)
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        char *return_value_strerror$5;
        return_value_strerror$5=strerror(*return_value___errno_location$4);
        fprintf(stderr, "open %s: %s\n", devices->fb0, return_value_strerror$5);
        exit(1);
      }

      c2m.console = (unsigned int)vts.v_active;
      signed int return_value_ioctl$6;
      return_value_ioctl$6=ioctl(fb, (unsigned long int)0x460F, &c2m);
      if(return_value_ioctl$6 == -1)
      {
        perror("ioctl FBIOGET_CON2FBMAP");
        exit(1);
      }

      close(fb);
      fprintf(stderr, "map: vt%02d => fb%d\n", c2m.console, c2m.framebuffer);
      sprintf(fbdev, devices->fbnr, c2m.framebuffer);
      device = fbdev;
    }

  }

  fb=open(device, 02);
  if(fb == -1)
  {
    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    char *return_value_strerror$8;
    return_value_strerror$8=strerror(*return_value___errno_location$7);
    fprintf(stderr, "open %s: %s\n", device, return_value_strerror$8);
    exit(1);
  }

  signed int return_value_ioctl$9;
  return_value_ioctl$9=ioctl(fb, (unsigned long int)0x4600, &fb_ovar);
  if(return_value_ioctl$9 == -1)
  {
    perror("ioctl FBIOGET_VSCREENINFO");
    exit(1);
  }

  signed int return_value_ioctl$10;
  return_value_ioctl$10=ioctl(fb, (unsigned long int)0x4602, &fb_fix);
  if(return_value_ioctl$10 == -1)
  {
    perror("ioctl FBIOGET_FSCREENINFO");
    exit(1);
  }

  if(fb_fix.visual == 4u || fb_ovar.bits_per_pixel == 8u)
  {
    signed int return_value_ioctl$11;
    return_value_ioctl$11=ioctl(fb, (unsigned long int)0x4604, &ocmap);
    if(return_value_ioctl$11 == -1)
    {
      perror("ioctl FBIOGETCMAP");
      exit(1);
    }

  }

  signed int return_value_ioctl$12;
  return_value_ioctl$12=ioctl(tty, (unsigned long int)0x4B3B, &kd_mode);
  if(return_value_ioctl$12 == -1)
  {
    perror("ioctl KDGETMODE");
    exit(1);
  }

  signed int return_value_ioctl$13;
  return_value_ioctl$13=ioctl(tty, (unsigned long int)0x5601, &vt_omode);
  if(return_value_ioctl$13 == -1)
  {
    perror("ioctl VT_GETMODE");
    exit(1);
  }

  tcgetattr(tty, &term);
  fb_setmode(mode);
  signed int return_value_ioctl$14;
  return_value_ioctl$14=ioctl(fb, (unsigned long int)0x4602, &fb_fix);
  if(return_value_ioctl$14 == -1)
  {
    perror("ioctl FBIOGET_FSCREENINFO");
    exit(1);
  }

  signed int return_value_getpagesize$15;
  void *return_value_mmap$16;
  signed int return_value_ioctl$18;
  if(!(fb_fix.type == 0u))
    fprintf(stderr, "can handle only packed pixel frame buffers\n");

  else
  {
    return_value_getpagesize$15=getpagesize();
    fb_mem_offset = (signed int)((unsigned long int)fb_fix.smem_start & (unsigned long int)(return_value_getpagesize$15 - 1));
    return_value_mmap$16=mmap((void *)0, (unsigned long int)(fb_fix.smem_len + (unsigned int)fb_mem_offset), 0x1 | 0x2, 0x01, fb, (signed long int)0);
    fb_mem = (unsigned char *)return_value_mmap$16;
    if((signed long int)fb_mem == -1l)
      perror("mmap");

    else
    {
      if(!(fb_var.xoffset == 0u) || !(fb_var.yoffset == 0u))
      {
        fb_var.xoffset = (unsigned int)0;
        fb_var.yoffset = (unsigned int)0;
        signed int return_value_ioctl$17;
        return_value_ioctl$17=ioctl(fb, (unsigned long int)0x4606, &fb_var);
        if(return_value_ioctl$17 == -1)
        {
          perror("ioctl FBIOPAN_DISPLAY");
          goto err;
        }

      }

      return_value_ioctl$18=ioctl(tty, (unsigned long int)0x4B3A, 0x01);
      if(return_value_ioctl$18 == -1)
        perror("ioctl KDSETMODE");

      else
      {
        fb_activate_current(tty);
        fb_memset((void *)(fb_mem + (signed long int)fb_mem_offset), 0, (unsigned long int)fb_fix.smem_len);
        return fb;
      }
    }
  }

err:
  ;
  fb_cleanup();
  exit(1);
}

// fb_memset
// file console/fbtools.h line 18
void fb_memset(void *addr, signed int c, unsigned long int len)
{
  unsigned int i;
  unsigned int *p;
  i = (unsigned int)((c & 0xff) << 8);
  i = i | i << 16;
  len = len >> 2;
  p = (unsigned int *)addr;
  unsigned long int tmp_post$1;
  do
  {
    tmp_post$1 = len;
    len = len - 1ul;
    if(tmp_post$1 == 0ul)
      break;

    *p = i;
    p = p + 1l;
  }
  while((_Bool)1);
}

// fb_setmode
// file console/fbtools.c line 173
static signed int fb_setmode(char *name)
{
  struct _IO_FILE *fp;
  char line[80l];
  char label[32l];
  char value[16l];
  signed int geometry = 0;
  signed int timings = 0;
  signed int err = -1;
  signed int return_value_ioctl$1;
  return_value_ioctl$1=ioctl(fb, (unsigned long int)0x4600, &fb_var);
  if(return_value_ioctl$1 == -1)
  {
    perror("ioctl FBIOGET_VSCREENINFO");
    exit(1);
  }

  char *return_value_fgets$2;
  signed int return_value_strcmp$21;
  char *return_value_fgets$3;
  char *return_value_strstr$4;
  signed int return_value_strcasecmp$7;
  signed int return_value_strcasecmp$9;
  signed int return_value_strcasecmp$11;
  signed int return_value_strcasecmp$13;
  signed int return_value_strcasecmp$15;
  signed int return_value_strcasecmp$17;
  if(name == ((char *)NULL))
    return -1;

  else
  {
    fp=fopen("/etc/fb.modes", "r");
    if(fp == ((struct _IO_FILE *)NULL))
      return -1;

    else
    {
      do
      {
        return_value_fgets$2=fgets(line, 79, fp);
        if(return_value_fgets$2 == ((char *)NULL))
          break;

        signed int return_value_sscanf$22;
        return_value_sscanf$22=sscanf(line, "mode \"%31[^\"]\"", (const void *)label);
        if(return_value_sscanf$22 == 1)
        {
          return_value_strcmp$21=strcmp(label, name);
          if(return_value_strcmp$21 == 0)
          {
            fb_var.sync = (unsigned int)0;
            fb_var.vmode = (unsigned int)0;
            do
            {
              return_value_fgets$3=fgets(line, 79, fp);
              if(return_value_fgets$3 == ((char *)NULL))
                break;

              return_value_strstr$4=strstr(line, "endmode");
              if(!(return_value_strstr$4 == ((char *)NULL)))
                break;

              signed int return_value_sscanf$5;
              return_value_sscanf$5=sscanf(line, " geometry %d %d %d %d %d", &fb_var.xres, &fb_var.yres, &fb_var.xres_virtual, &fb_var.yres_virtual, &fb_var.bits_per_pixel);
              if(return_value_sscanf$5 == 5)
                geometry = 1;

              signed int return_value_sscanf$6;
              return_value_sscanf$6=sscanf(line, " timings %d %d %d %d %d %d %d", &fb_var.pixclock, &fb_var.left_margin, &fb_var.right_margin, &fb_var.upper_margin, &fb_var.lower_margin, &fb_var.hsync_len, &fb_var.vsync_len);
              if(return_value_sscanf$6 == 7)
                timings = 1;

              signed int return_value_sscanf$8;
              return_value_sscanf$8=sscanf(line, " hsync %15s", (const void *)value);
              if(return_value_sscanf$8 == 1)
              {
                return_value_strcasecmp$7=strcasecmp(value, "high");
                if(return_value_strcasecmp$7 == 0)
                  fb_var.sync = fb_var.sync | (unsigned int)1;

              }

              signed int return_value_sscanf$10;
              return_value_sscanf$10=sscanf(line, " vsync %15s", (const void *)value);
              if(return_value_sscanf$10 == 1)
              {
                return_value_strcasecmp$9=strcasecmp(value, "high");
                if(return_value_strcasecmp$9 == 0)
                  fb_var.sync = fb_var.sync | (unsigned int)2;

              }

              signed int return_value_sscanf$12;
              return_value_sscanf$12=sscanf(line, " csync %15s", (const void *)value);
              if(return_value_sscanf$12 == 1)
              {
                return_value_strcasecmp$11=strcasecmp(value, "high");
                if(return_value_strcasecmp$11 == 0)
                  fb_var.sync = fb_var.sync | (unsigned int)8;

              }

              signed int return_value_sscanf$14;
              return_value_sscanf$14=sscanf(line, " extsync %15s", (const void *)value);
              if(return_value_sscanf$14 == 1)
              {
                return_value_strcasecmp$13=strcasecmp(value, "true");
                if(return_value_strcasecmp$13 == 0)
                  fb_var.sync = fb_var.sync | (unsigned int)4;

              }

              signed int return_value_sscanf$16;
              return_value_sscanf$16=sscanf(line, " laced %15s", (const void *)value);
              if(return_value_sscanf$16 == 1)
              {
                return_value_strcasecmp$15=strcasecmp(value, "true");
                if(return_value_strcasecmp$15 == 0)
                  fb_var.vmode = fb_var.vmode | (unsigned int)1;

              }

              signed int return_value_sscanf$18;
              return_value_sscanf$18=sscanf(line, " double %15s", (const void *)value);
              if(return_value_sscanf$18 == 1)
              {
                return_value_strcasecmp$17=strcasecmp(value, "true");
                if(return_value_strcasecmp$17 == 0)
                  fb_var.vmode = fb_var.vmode | (unsigned int)2;

              }

            }
            while((_Bool)1);
            if(geometry == 0 || timings == 0)
              goto out;

            fb_var.xoffset = (unsigned int)0;
            fb_var.yoffset = (unsigned int)0;
            signed int return_value_ioctl$19;
            return_value_ioctl$19=ioctl(fb, (unsigned long int)0x4601, &fb_var);
            if(return_value_ioctl$19 == -1)
              perror("ioctl FBIOPUT_VSCREENINFO");

            signed int return_value_ioctl$20;
            return_value_ioctl$20=ioctl(fb, (unsigned long int)0x4600, &fb_var);
            if(return_value_ioctl$20 == -1)
            {
              perror("ioctl FBIOGET_VSCREENINFO");
              exit(1);
            }

            err = 0;
            goto out;
          }

        }

      }
      while((_Bool)1);

    out:
      ;
      fclose(fp);
      return err;
    }
  }
}

// fb_setvt
// file console/fbtools.c line 251
static void fb_setvt(signed int vtno)
{
  struct vt_stat vts;
  char vtname[12l];
  if(!(vtno >= 0))
  {
    signed int return_value_ioctl$1;
    return_value_ioctl$1=ioctl(tty, (unsigned long int)0x5600, &vtno);
    if(return_value_ioctl$1 == -1 || vtno == -1)
    {
      perror("ioctl VT_OPENQRY");
      exit(1);
    }

  }

  vtno = vtno & 0xff;
  sprintf(vtname, devices->ttynr, vtno);
  unsigned int return_value_getuid$2;
  return_value_getuid$2=getuid();
  unsigned int return_value_getgid$3;
  return_value_getgid$3=getgid();
  chown(vtname, return_value_getuid$2, return_value_getgid$3);
  signed int return_value_access$6;
  return_value_access$6=access(vtname, 4 | 2);
  if(return_value_access$6 == -1)
  {
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    char *return_value_strerror$5;
    return_value_strerror$5=strerror(*return_value___errno_location$4);
    fprintf(stderr, "access %s: %s\n", (const void *)vtname, return_value_strerror$5);
    exit(1);
  }

  signed int return_value_fork$7;
  return_value_fork$7=fork();
  if(!(return_value_fork$7 == 0))
  {
    if(return_value_fork$7 == -1)
      goto __CPROVER_DUMP_L5;

  }

  else
  {
    goto __CPROVER_DUMP_L7;

  __CPROVER_DUMP_L5:
    ;
    perror("fork");
    exit(1);
  }
  exit(0);

__CPROVER_DUMP_L7:
  ;
  close(tty);
  close(0);
  close(1);
  close(2);
  setsid();
  open(vtname, 02);
  dup(0);
  dup(0);
  signed int return_value_ioctl$8;
  return_value_ioctl$8=ioctl(tty, (unsigned long int)0x5603, &vts);
  if(return_value_ioctl$8 == -1)
  {
    perror("ioctl VT_GETSTATE");
    exit(1);
  }

  orig_vt_no = (signed int)vts.v_active;
  signed int return_value_ioctl$9;
  return_value_ioctl$9=ioctl(tty, (unsigned long int)0x5606, vtno);
  if(return_value_ioctl$9 == -1)
  {
    perror("ioctl VT_ACTIVATE");
    exit(1);
  }

  signed int return_value_ioctl$10;
  return_value_ioctl$10=ioctl(tty, (unsigned long int)0x5607, vtno);
  if(return_value_ioctl$10 == -1)
  {
    perror("ioctl VT_WAITACTIVE");
    exit(1);
  }

}

// fb_switch_acquire
// file console/fbtools.c line 118
void fb_switch_acquire(void)
{
  ioctl(tty, (unsigned long int)0x5605, 0x02);
  fb_switch_state = 0;
  if(!(debug == 0))
    write(2, (const void *)"vt: acquire\n", (unsigned long int)12);

}

// fb_switch_init
// file console/fbtools.h line 21
signed int fb_switch_init(void)
{
  struct sigaction act;
  struct sigaction old;
  memset((void *)&act, 0, sizeof(struct sigaction) /*152ul*/ );
  act.__sigaction_handler.sa_handler = fb_switch_signal;
  sigemptyset(&act.sa_mask);
  sigaction(10, &act, &old);
  sigaction(12, &act, &old);
  signed int return_value_ioctl$1;
  return_value_ioctl$1=ioctl(tty, (unsigned long int)0x5601, &vt_mode);
  if(return_value_ioctl$1 == -1)
  {
    perror("ioctl VT_GETMODE");
    exit(1);
  }

  vt_mode.mode = (char)0x01;
  vt_mode.waitv = (char)0;
  vt_mode.relsig = (signed short int)10;
  vt_mode.acqsig = (signed short int)12;
  signed int return_value_ioctl$2;
  return_value_ioctl$2=ioctl(tty, (unsigned long int)0x5602, &vt_mode);
  if(return_value_ioctl$2 == -1)
  {
    perror("ioctl VT_SETMODE");
    exit(1);
  }

  return 0;
}

// fb_switch_release
// file console/fbtools.c line 109
void fb_switch_release(void)
{
  ioctl(tty, (unsigned long int)0x5605, 1);
  fb_switch_state = 2;
  if(!(debug == 0))
    write(2, (const void *)"vt: release\n", (unsigned long int)12);

}

// fb_switch_signal
// file console/fbtools.c line 92
static void fb_switch_signal(signed int signal)
{
  if(signal == 10)
  {
    fb_switch_state = 1;
    if(!(debug == 0))
      write(2, (const void *)"vt: SIGUSR1\n", (unsigned long int)12);

  }

  if(signal == 12)
  {
    fb_switch_state = 3;
    if(!(debug == 0))
      write(2, (const void *)"vt: SIGUSR2\n", (unsigned long int)12);

  }

}

// fget_associated_device
// file common/get_media_devices.c line 501
const char * fget_associated_device(void *opaque, const char *last_seek, const enum device_type desired_type, const signed int fd_seek_device, const enum device_type seek_type)
{
  struct media_devices *md = (struct media_devices *)opaque;
  struct media_device_entry *md_ptr = md->md_entry;
  struct stat f_status;
  unsigned int dev_major;
  unsigned int dev_minor;
  signed int i;
  signed int found = 0;
  char *prev;
  signed int return_value_fstat$1;
  return_value_fstat$1=fstat(fd_seek_device, &f_status);
  _Bool tmp_if_expr$3;
  signed int return_value_strcmp$2;
  if(!(return_value_fstat$1 == 0))
  {
    perror("Can't get file status");
    return (const char *)(void *)0;
  }

  else
    if(!((61440u & f_status.st_mode) == 8192u))
    {
      fprintf(stderr, "File descriptor is not a char device\n");
      return (const char *)(void *)0;
    }

    else
    {
      dev_major=gnu_dev_major(f_status.st_rdev);
      dev_minor=gnu_dev_minor(f_status.st_rdev);
      i = 0;
      for( ; !((unsigned int)i >= md->md_size); md_ptr = md_ptr + 1l)
      {
        if(!(last_seek == ((const char *)NULL)))
        {
          if(!(md_ptr->type == seek_type))
            goto __CPROVER_DUMP_L4;

          if(!(md_ptr->major == dev_major))
            goto __CPROVER_DUMP_L4;

          if(!(md_ptr->minor == dev_minor))
            goto __CPROVER_DUMP_L4;

          found = 1;
        }

        else
        {

        __CPROVER_DUMP_L4:
          ;
          if(!(found == 0) || last_seek == ((const char *)NULL))
          {
            if(md_ptr->type == seek_type)
            {
              if(md_ptr->major == dev_major)
              {
                if(md_ptr->minor == dev_minor)
                  break;

              }

            }

          }

        }
        i = i + 1;
      }
      if((unsigned int)i == md->md_size)
        return (const char *)(void *)0;

      else
      {
        i = i + 1;
        prev = md_ptr->device;
        md_ptr = md_ptr + 1l;
        do
        {
          if(!((unsigned int)i >= md->md_size))
          {
            return_value_strcmp$2=strcmp(prev, md_ptr->device);
            tmp_if_expr$3 = !(return_value_strcmp$2 != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$3 = (_Bool)0;
          if(!tmp_if_expr$3)
            break;

          if(!(last_seek == ((const char *)NULL)))
          {
            if(!(md_ptr->type == seek_type))
              goto __CPROVER_DUMP_L11;

            if(!(md_ptr->major == dev_major))
              goto __CPROVER_DUMP_L11;

            if(!(md_ptr->minor == dev_minor))
              goto __CPROVER_DUMP_L11;

            found = 1;
          }

          else
          {

          __CPROVER_DUMP_L11:
            ;
            if(!(found == 0) || last_seek == ((const char *)NULL))
            {
              if(md_ptr->type == desired_type)
                return md_ptr->node;

            }

          }
          i = i + 1;
          md_ptr = md_ptr + 1l;
        }
        while((_Bool)1);
        return (const char *)(void *)0;
      }
    }
}

// fifo_get
// file common/capture.c line 81
void * fifo_get(struct FIFO *fifo)
{
  void *data;
  pthread_mutex_lock(&fifo->lock);
  while(fifo->write == fifo->read)
  {
    if(fifo->writers == fifo->eof)
      break;

    pthread_cond_wait(&fifo->hasdata, &fifo->lock);
  }
  signed int return_value_getpid$1;
  if(fifo->write == fifo->read)
  {
    pthread_cond_signal(&fifo->hasdata);
    pthread_mutex_unlock(&fifo->lock);
    return (void *)0;
  }

  else
  {
    if(debug >= 2)
    {
      return_value_getpid$1=getpid();
      fprintf(stderr, "get %s %d=%p [pid=%d]\n", fifo->name, fifo->read, fifo->data[(signed long int)fifo->read], return_value_getpid$1);
    }

    data = (void *)fifo->data[(signed long int)fifo->read];
    fifo->read = fifo->read + 1;
    if(fifo->read >= fifo->slots)
      fifo->read = 0;

    pthread_mutex_unlock(&fifo->lock);
    return data;
  }
}

// fifo_init
// file common/capture.c line 31
void fifo_init(struct FIFO *fifo, char *name, signed int slots, signed int writers)
{
  pthread_mutex_init(&fifo->lock, (const union anonymous$86 *)(void *)0);
  pthread_cond_init(&fifo->hasdata, (const union anonymous$86 *)(void *)0);
  fifo->name = name;
  fifo->slots = slots;
  fifo->writers = writers;
  fifo->read = 0;
  fifo->write = 0;
  fifo->eof = 0;
  fifo->max = 0;
}

// fifo_put
// file common/capture.c line 45
signed int fifo_put(struct FIFO *fifo, void *data)
{
  signed int full;
  pthread_mutex_lock(&fifo->lock);
  signed int return_value_getpid$1;
  if(data == NULL)
  {
    fifo->eof = fifo->eof + 1;
    if(!(debug == 0))
      fprintf(stderr, "fifo %s: EOF %d/%d\n", fifo->name, fifo->eof, fifo->writers);

    if(fifo->writers == fifo->eof)
      pthread_cond_broadcast(&fifo->hasdata);

    pthread_mutex_unlock(&fifo->lock);
    return 0;
  }

  else
    if((1 + fifo->write) % fifo->slots == fifo->read)
    {
      pthread_mutex_unlock(&fifo->lock);
      fprintf(stderr, "fifo %s is full\n", fifo->name);
      return -1;
    }

    else
    {
      if(debug >= 2)
      {
        return_value_getpid$1=getpid();
        fprintf(stderr, "put %s %d=%p [pid=%d]\n", fifo->name, fifo->write, data, return_value_getpid$1);
      }

      fifo->data[(signed long int)fifo->write] = (unsigned char *)data;
      fifo->write = fifo->write + 1;
      full = ((fifo->write + fifo->slots) - fifo->read) % fifo->slots;
      if(!(fifo->max >= full))
        fifo->max = full;

      if(fifo->write >= fifo->slots)
        fifo->write = 0;

      pthread_cond_signal(&fifo->hasdata);
      pthread_mutex_unlock(&fifo->lock);
      return 0;
    }
}

// files_audio
// file libng/writefile.c line 364
static signed int files_audio(void *handle, struct ng_audio_buf *buf)
{
  struct files_handle *h = (struct files_handle *)handle;
  signed long int return_value_write$1;
  return_value_write$1=write(h->wav_fd, (const void *)buf->data, (unsigned long int)buf->size);
  if(!((signed long int)buf->size == return_value_write$1))
    return -1;

  else
  {
    h->wav_size = h->wav_size + buf->size;
    return 0;
  }
}

// files_close
// file libng/writefile.c line 374
static signed int files_close(void *handle)
{
  struct files_handle *h = (struct files_handle *)handle;
  if(!(h->audio.fmtid == 0u))
  {
    wav_stop_write(h->wav_fd, &h->wav_header, h->wav_size);
    close(h->wav_fd);
  }

  free((void *)h);
  return 0;
}

// files_open
// file libng/writefile.c line 298
static void * files_open(char *filesname, char *audioname, struct ng_video_fmt *video, const void *priv_video, signed int fps, struct ng_audio_fmt *audio, const void *priv_audio)
{
  struct files_handle *h;
  if(!(video->fmtid == 0u))
  {
    if(!(filesname == ((char *)NULL)))
      goto __CPROVER_DUMP_L1;

    return (void *)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct files_handle) /*4176ul*/ );
    h = (struct files_handle *)return_value_malloc$1;
    if(h == ((struct files_handle *)NULL))
      return (void *)0;

    else
    {
      memset((void *)h, 0, sizeof(struct files_handle) /*4176ul*/ );
      h->video = *video;
      h->audio = *audio;
      if(!(filesname == ((char *)NULL)))
        strcpy(h->file, filesname);

      if(!(h->audio.fmtid == 0u))
      {
        h->wav_fd=open(audioname, 0100 | 02 | 01000, 0666);
        if(h->wav_fd == -1)
        {
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          char *return_value_strerror$3;
          return_value_strerror$3=strerror(*return_value___errno_location$2);
          fprintf(stderr, "open %s: %s\n", audioname, return_value_strerror$3);
          free((void *)h);
          return (void *)0;
        }

        wav_start_write(h->wav_fd, &h->wav_header, &h->audio);
      }

      return (void *)h;
    }
  }
}

// files_video
// file libng/writefile.c line 330
static signed int files_video(void *handle, struct ng_video_buf *buf)
{
  struct files_handle *h = (struct files_handle *)handle;
  signed int rc = -1;
  struct _IO_FILE *fp;
  if(!(h->gotcha == 0))
  {
    fprintf(stderr, "Oops: can't count up file names any more\n");
    return -1;
  }

  else
  {
    switch(h->video.fmtid)
    {
      case (unsigned int)9:
      {
        rc=write_ppm(h->file, buf);
        break;
      }
      case (unsigned int)2:
      {
        rc=write_pgm(h->file, buf);
        break;
      }
      case (unsigned int)17:
      {
        fp=fopen(h->file, "w");
        if(fp == ((struct _IO_FILE *)NULL))
        {
          signed int *return_value___errno_location$1;
          return_value___errno_location$1=__errno_location();
          char *return_value_strerror$2;
          return_value_strerror$2=strerror(*return_value___errno_location$1);
          fprintf(stderr, "grab: can't open %s: %s\n", (const void *)h->file, return_value_strerror$2);
          rc = -1;
        }

        else
        {
          fwrite((const void *)buf->data, buf->size, (unsigned long int)1, fp);
          fclose(fp);
          rc = 0;
        }
      }
    }
    signed int return_value_patch_up$3;
    return_value_patch_up$3=patch_up(h->file);
    if(!(return_value_patch_up$3 == 1))
      h->gotcha = 1;

    return rc;
  }
}

// flushit
// file common/capture.c line 106
static void * flushit(void *arg)
{
  signed int old;
  pthread_setcancelstate(0, &old);
  pthread_setcanceltype(1, &old);
  do
  {
    sleep((unsigned int)1);
    sync();
  }
  while((_Bool)1);
  return (void *)0;
}

// fntcmp
// file x11/vbi-gui.c line 994
static signed int fntcmp(const void *a, const void *b)
{
  const char * const *aa = (const char * const *)a;
  const char * const *bb = (const char * const *)b;
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(*aa, *bb);
  return return_value_strcmp$1;
}

// free_media_devices
// file ./common/get_media_devices.h line 92
void free_media_devices(void *opaque)
{
  struct media_devices *md = (struct media_devices *)opaque;
  struct media_device_entry *md_ptr = md->md_entry;
  signed int i = 0;
  for( ; !((unsigned int)i >= md->md_size); i = i + 1)
  {
    free((void *)md_ptr->node);
    free((void *)md_ptr->device);
    md_ptr = md_ptr + 1l;
  }
  free((void *)md->md_entry);
  free((void *)md);
}

// freq_init
// file ./common/frequencies.h line 105
void freq_init(void)
{
  char line[256l];
  char value[256l];
  struct _IO_FILE *fp;
  signed int nr;
  signed int i;
  signed int j;
  fp=fopen("/usr/share/xawtv/Index.map", "r");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    perror("open /usr/share/xawtv/Index.map");
    exit(1);
  }

  if(!(debug == 0))
    fprintf(stderr, "freq: reading /usr/share/xawtv/Index.map\n");

  nr = 0;
  i = 0;
  char *return_value_fgets$1;
  do
  {
    return_value_fgets$1=fgets(line, 255, fp);
    if(return_value_fgets$1 == ((char *)NULL))
      break;

    nr = nr + 1;
    _Bool tmp_if_expr$2;
    if((signed int)line[0l] == 10)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)line[(signed long int)0] == 35 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr$3;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (signed int)line[(signed long int)0] == 37 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$3)
    {
      signed int return_value_sscanf$5;
      return_value_sscanf$5=sscanf(line, "[%255[^]]]", (const void *)value);
      if(return_value_sscanf$5 == 1)
      {
        void *return_value_realloc$4;
        return_value_realloc$4=realloc((void *)chanlists, (unsigned long int)(i + 2) * sizeof(struct CHANLISTS) /*32ul*/ );
        chanlists = (struct CHANLISTS *)return_value_realloc$4;
        memset((void *)(chanlists + (signed long int)i), 0, (unsigned long int)2 * sizeof(struct CHANLISTS) /*32ul*/ );
        (chanlists + (signed long int)i)->name=strdup(value);
        i = i + 1;
        continue;
      }

      if(chanlists == ((struct CHANLISTS *)NULL))
        fprintf(stderr, "%s:%d: error: no section\n", (const void *)"/usr/share/xawtv/Index.map", nr);

      else
      {
        signed int return_value_sscanf$6;
        return_value_sscanf$6=sscanf(line, " file = %255[^\n]", (const void *)value);
        if(return_value_sscanf$6 == 1)
          (chanlists + (signed long int)(i - 1))->filename=strdup(value);

        else
          fprintf(stderr, "%s:%d: syntax error\n", (const void *)"/usr/share/xawtv/Index.map", nr);
      }
    }

  }
  while((_Bool)1);
  fclose(fp);
  void *return_value_malloc$7;
  return_value_malloc$7=malloc((unsigned long int)(i + 1) * sizeof(struct STRTAB) /*16ul*/ );
  chanlist_names = (struct STRTAB *)return_value_malloc$7;
  j = 0;
  for( ; !(j >= i); j = j + 1)
  {
    (chanlist_names + (signed long int)j)->nr = (signed long int)j;
    (chanlist_names + (signed long int)j)->str = (chanlists + (signed long int)j)->name;
  }
  (chanlist_names + (signed long int)j)->nr = (signed long int)-1;
  (chanlist_names + (signed long int)j)->str = (const char *)(void *)0;
}

// freq_newtab
// file common/frequencies.h line 106
void freq_newtab(signed int n)
{
  if(!(debug == 0))
    fprintf(stderr, "freq: newtab %d\n", n);

  if((chanlists + (signed long int)n)->list == ((struct CHANLIST *)NULL))
    (chanlists + (signed long int)n)->count=freq_readlist(&(chanlists + (signed long int)n)->list, 0, (chanlists + (signed long int)n)->filename);

  chantab = n;
}

// freq_readlist
// file common/frequencies.c line 78
static signed int freq_readlist(struct CHANLIST **list, signed int n, char *name)
{
  char line[256l];
  char value[256l];
  char filename[256l];
  struct _IO_FILE *fp;
  signed int nr;
  sprintf(filename, "%s/%s", (const void *)"/usr/share/xawtv", name);
  fp=fopen(filename, "r");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    fprintf(stderr, "open %s: %s\n", (const void *)filename, return_value_strerror$2);
    exit(1);
  }

  if(!(debug == 0))
    fprintf(stderr, "freq: reading %s\n", (const void *)filename);

  nr = 0;
  char *return_value_fgets$3;
  do
  {
    return_value_fgets$3=fgets(line, 255, fp);
    if(return_value_fgets$3 == ((char *)NULL))
      break;

    nr = nr + 1;
    signed int return_value_sscanf$4;
    return_value_sscanf$4=sscanf(line, "# include \"%[^\"]\"", (const void *)value);
    if(return_value_sscanf$4 == 1)
      n=freq_readlist(list, n, value);

    else
    {
      _Bool tmp_if_expr$5;
      if((signed int)line[0l] == 10)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)line[(signed long int)0] == 35 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$6;
      if(tmp_if_expr$5)
        tmp_if_expr$6 = (_Bool)1;

      else
        tmp_if_expr$6 = (signed int)line[(signed long int)0] == 37 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$6)
      {
        signed int return_value_sscanf$8;
        return_value_sscanf$8=sscanf(line, "[%255[^]]]", (const void *)value);
        if(return_value_sscanf$8 == 1)
        {
          if(n % 16 == 0)
          {
            void *return_value_realloc$7;
            return_value_realloc$7=realloc((void *)*list, (unsigned long int)(n + 16) * sizeof(struct CHANLIST) /*16ul*/ );
            *list = (struct CHANLIST *)return_value_realloc$7;
            memset((void *)(*list + (signed long int)n), 0, (unsigned long int)16 * sizeof(struct CHANLIST) /*16ul*/ );
          }

          (*list + (signed long int)n)->name=strdup(value);
          n = n + 1;
        }

        else
          if(n == 0)
            fprintf(stderr, "%s:%d: error: no section\n", (const void *)filename, nr);

          else
          {
            signed int return_value_sscanf$10;
            return_value_sscanf$10=sscanf(line, " freq = %255[^\n]", (const void *)value);
            if(return_value_sscanf$10 == 1)
            {
              signed int return_value_atoi$9;
              return_value_atoi$9=atoi(value);
              (*list + (signed long int)(n - 1))->freq = (unsigned int)return_value_atoi$9;
              continue;
            }

            fprintf(stderr, "%s:%d: syntax error\n", (const void *)filename, nr);
          }
      }

    }
  }
  while((_Bool)1);
  fclose(fp);
  return n;
}

// fullscreen_handler
// file common/commands.c line 1158
static signed int fullscreen_handler(char *name, signed int argc, char **argv)
{
  if(!(fullscreen_hook == ((void (*)(void))NULL)))
    fullscreen_hook();

  return 0;
}

// get_associated_device
// file ./common/get_media_devices.h line 124
const char * get_associated_device(void *opaque, const char *last_seek, const enum device_type desired_type, const char *seek_device, const enum device_type seek_type)
{
  struct media_devices *md = (struct media_devices *)opaque;
  struct media_device_entry *md_ptr = md->md_entry;
  signed int i;
  signed int found = 0;
  char *prev;
  char *p;
  _Bool tmp_if_expr$7;
  if(!((signed int)seek_type == NONE))
    tmp_if_expr$7 = seek_device[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$7 = (_Bool)0;
  signed int return_value_strcmp$1;
  signed int return_value_strcmp$2;
  _Bool tmp_if_expr$4;
  signed int return_value_strcmp$3;
  signed int return_value_strcmp$5;
  signed int return_value_strcmp$6;
  if(tmp_if_expr$7)
  {
    p=strrchr(seek_device, 47);
    if(!(p == ((char *)NULL)))
      seek_device = p + (signed long int)1;

    i = 0;
    for( ; !((unsigned int)i >= md->md_size); md_ptr = md_ptr + 1l)
    {
      if(!(last_seek == ((const char *)NULL)))
      {
        if(md_ptr->type == seek_type)
        {
          return_value_strcmp$1=strcmp(md_ptr->node, last_seek);
          if(return_value_strcmp$1 == 0)
          {
            found = 1;
            goto __CPROVER_DUMP_L10;
          }

        }

      }

      if(!(found == 0) || last_seek == ((const char *)NULL))
      {
        if(md_ptr->type == seek_type)
        {
          return_value_strcmp$2=strcmp(seek_device, md_ptr->node);
          if(return_value_strcmp$2 == 0)
            break;

        }

      }


    __CPROVER_DUMP_L10:
      ;
      i = i + 1;
    }
    if((unsigned int)i == md->md_size)
      return (const char *)(void *)0;

    i = i + 1;
    prev = md_ptr->device;
    md_ptr = md_ptr + 1l;
    do
    {
      if(!((unsigned int)i >= md->md_size))
      {
        return_value_strcmp$3=strcmp(prev, md_ptr->device);
        tmp_if_expr$4 = !(return_value_strcmp$3 != 0) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$4 = (_Bool)0;
      if(!tmp_if_expr$4)
        break;

      if(!(last_seek == ((const char *)NULL)))
      {
        if(md_ptr->type == seek_type)
        {
          return_value_strcmp$5=strcmp(md_ptr->node, last_seek);
          if(return_value_strcmp$5 == 0)
          {
            found = 1;
            goto __CPROVER_DUMP_L20;
          }

        }

      }

      if(!(found == 0) || last_seek == ((const char *)NULL))
      {
        if(md_ptr->type == desired_type)
          return md_ptr->node;

      }


    __CPROVER_DUMP_L20:
      ;
      i = i + 1;
      md_ptr = md_ptr + 1l;
    }
    while((_Bool)1);
  }

  else
  {
    i = 0;
    for( ; !((unsigned int)i >= md->md_size); md_ptr = md_ptr + 1l)
    {
      if(!(last_seek == ((const char *)NULL)))
      {
        return_value_strcmp$6=strcmp(md_ptr->node, last_seek);
        if(return_value_strcmp$6 == 0)
        {
          found = 1;
          goto __CPROVER_DUMP_L28;
        }

      }

      if(!(found == 0) || last_seek == ((const char *)NULL))
      {
        if(md_ptr->type == desired_type)
          return md_ptr->node;

      }


    __CPROVER_DUMP_L28:
      ;
      i = i + 1;
    }
  }
  return (const char *)(void *)0;
}

// get_bus
// file common/get_media_devices.c line 96
static enum bus_type get_bus(char *device)
{
  char file[4096l];
  char s[1024l];
  struct _IO_FILE *f;
  signed int return_value_strcmp$1;
  return_value_strcmp$1=strcmp(device, "/sys/devices/virtual");
  if(return_value_strcmp$1 == 0)
    return (enum bus_type)MEDIA_BUS_VIRTUAL;

  else
  {
    snprintf(file, (unsigned long int)4096, "%s/modalias", device);
    f=fopen(file, "r");
    if(f == ((struct _IO_FILE *)NULL))
      return (enum bus_type)MEDIA_BUS_UNKNOWN;

    else
    {
      char *return_value_fgets$2;
      return_value_fgets$2=fgets(s, (signed int)sizeof(char [1024l]) /*1024ul*/ , f);
      if(return_value_fgets$2 == ((char *)NULL))
        return (enum bus_type)MEDIA_BUS_UNKNOWN;

      else
      {
        fclose(f);
        signed int return_value_strncmp$3;
        return_value_strncmp$3=strncmp(s, "pci", (unsigned long int)3);
        if(return_value_strncmp$3 == 0)
          return (enum bus_type)MEDIA_BUS_PCI;

        else
        {
          signed int return_value_strncmp$4;
          return_value_strncmp$4=strncmp(s, "usb", (unsigned long int)3);
          if(return_value_strncmp$4 == 0)
            return (enum bus_type)MEDIA_BUS_USB;

          else
            return (enum bus_type)MEDIA_BUS_UNKNOWN;
        }
      }
    }
  }
}

// get_class
// file common/get_media_devices.c line 121
static signed int get_class(char *class, struct media_device_entry **md, unsigned int *md_size, signed int (*fill)(struct media_device_entry *))
{
  struct __dirstream *dir;
  struct dirent *entry;
  char dname[4096l];
  char fname[4096l];
  char get_class$$1$$link[4096l];
  char virt_dev[60l];
  signed int err = -2;
  struct media_device_entry *md_ptr = (struct media_device_entry *)(void *)0;
  char *p;
  char *device;
  enum bus_type bus;
  snprintf(dname, (unsigned long int)4096, "/sys/class/%s", class);
  dir=opendir(dname);
  char *return_value_strchr$1;
  if(dir == ((struct __dirstream *)NULL))
    return 0;

  else
  {
    entry=readdir(dir);
    while(!(entry == ((struct dirent *)NULL)))
    {
      if(!((signed int)entry->d_name[0l] == 46))
      {
        snprintf(fname, (unsigned long int)4096, "%s/%s", (const void *)dname, (const void *)entry->d_name);
        char *return_value_realpath$4;
        return_value_realpath$4=realpath(fname, get_class$$1$$link);
        if(!(return_value_realpath$4 == ((char *)NULL)))
        {
          device = get_class$$1$$link;
          p=strstr(device, class);
          if(p == ((char *)NULL))
            goto __CPROVER_DUMP_L9;

          *(p - (signed long int)1) = (char)0;
          bus=get_bus(device);
          device = device + (signed long int)13;
          switch((signed int)bus)
          {
            case MEDIA_BUS_PCI:
            {
              p=strrchr(device, 46);
              if(p == ((char *)NULL))
                goto __CPROVER_DUMP_L9;

              *p = (char)0;
              break;
            }
            case MEDIA_BUS_USB:
            {
              p=strrchr(device, 47);
              if(p == ((char *)NULL))
                goto __CPROVER_DUMP_L9;

              return_value_strchr$1=strchr(p, 58);
              if(return_value_strchr$1 == ((char *)NULL))
                break;

              *p = (char)0;
              break;
            }
            case MEDIA_BUS_VIRTUAL:
            {
              static signed int virtual = 0;
              signed int tmp_post$2 = virtual;
              virtual = virtual + 1;
              sprintf(virt_dev, "virtual%d", tmp_post$2);
              device = virt_dev;
              break;
            }
            case MEDIA_BUS_UNKNOWN:
              ;
          }
          void *return_value_realloc$3;
          return_value_realloc$3=realloc((void *)*md, (unsigned long int)(*md_size + (unsigned int)1) * sizeof(struct media_device_entry) /*32ul*/ );
          *md = (struct media_device_entry *)return_value_realloc$3;
          if(*md == ((struct media_device_entry *)NULL))
            goto error;

          md_ptr = *md + (signed long int)*md_size;
          *md_size = *md_size + 1u;
          memset((void *)md_ptr, 0, sizeof(struct media_device_entry) /*32ul*/ );
          md_ptr->type = (enum device_type)UNKNOWN;
          md_ptr->device=strdup(device);
          md_ptr->node=strdup(entry->d_name);
          get_uevent_info(md_ptr, dname);
          fill(md_ptr);
        }

      }


    __CPROVER_DUMP_L9:
      ;
      entry=readdir(dir);
    }
    err = 0;

  error:
    ;
    closedir(dir);
    return err;
  }
}

// get_freq
// file common/channel.c line 152
signed int get_freq(signed int i)
{
  _Bool tmp_if_expr$2;
  signed int tmp_if_expr$1;
  if(!(i >= 0))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    if(!(chantab == -1))
      tmp_if_expr$1 = (chanlists + (signed long int)chantab)->count;

    else
      tmp_if_expr$1 = 0;
    tmp_if_expr$2 = i >= tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
    return -1;

  else
  {
    struct CHANLIST *tmp_if_expr$3;
    if(!(chantab == -1))
      tmp_if_expr$3 = (chanlists + (signed long int)chantab)->list;

    else
      tmp_if_expr$3 = (struct CHANLIST *)(void *)0;
    return (signed int)(((tmp_if_expr$3 + (signed long int)i)->freq * (unsigned int)16) / (unsigned int)1000);
  }
}

// get_not_associated_device
// file common/get_media_devices.c line 561
const char * get_not_associated_device(void *opaque, const char *last_seek, const enum device_type desired_type, const enum device_type not_desired_type)
{
  struct media_devices *md = (struct media_devices *)opaque;
  struct media_device_entry *md_ptr = md->md_entry;
  signed int i;
  signed int skip = 0;
  signed int found = 0;
  char *prev = "";
  char *result = (char *)(void *)0;
  i = 0;
  signed int return_value_strcmp$1;
  for( ; !((unsigned int)i >= md->md_size); md_ptr = md_ptr + 1l)
  {
    if(!(last_seek == ((const char *)NULL)))
    {
      return_value_strcmp$1=strcmp(md_ptr->node, last_seek);
      if(return_value_strcmp$1 == 0)
      {
        found = 1;
        goto __CPROVER_DUMP_L9;
      }

    }

    if(!(found == 0) || last_seek == ((const char *)NULL))
    {
      signed int return_value_strcmp$2;
      return_value_strcmp$2=strcmp(prev, md_ptr->device);
      if(!(return_value_strcmp$2 == 0))
      {
        if(skip == 0 && !(result == ((char *)NULL)))
          break;

        prev = md_ptr->device;
        skip = 0;
        result = (char *)(void *)0;
      }

      if(md_ptr->type == not_desired_type)
        skip = 1;

      else
        if(result == ((char *)NULL) && skip == 0)
        {
          if(md_ptr->type == desired_type)
            result = md_ptr->node;

        }

    }


  __CPROVER_DUMP_L9:
    ;
    i = i + 1;
  }
  if(!(skip == 0))
    result = (char *)(void *)0;

  return result;
}

// get_uevent_info
// file common/get_media_devices.c line 69
static void get_uevent_info(struct media_device_entry *md_ptr, char *dname)
{
  struct _IO_FILE *fd;
  char file[4096l];
  char *name;
  char *p;
  char s[1024l];
  snprintf(file, (unsigned long int)4096, "%s/%s/uevent", dname, md_ptr->node);
  fd=fopen(file, "r");
  char *return_value_fgets$1;
  signed long int return_value_atol$2;
  signed int return_value_strcmp$4;
  signed long int return_value_atol$3;
  if(!(fd == ((struct _IO_FILE *)NULL)))
  {
    do
    {
      return_value_fgets$1=fgets(s, (signed int)sizeof(char [1024l]) /*1024ul*/ , fd);
      if(return_value_fgets$1 == ((char *)NULL))
        break;

      p=strtok(s, "=");
      if(!(p == ((char *)NULL)))
      {
        name = p;
        p=strtok((char *)(void *)0, "\n");
        if(!(p == ((char *)NULL)))
        {
          signed int return_value_strcmp$5;
          return_value_strcmp$5=strcmp(name, "MAJOR");
          if(return_value_strcmp$5 == 0)
          {
            return_value_atol$2=atol(p);
            md_ptr->major = (unsigned int)return_value_atol$2;
          }

          else
          {
            return_value_strcmp$4=strcmp(name, "MINOR");
            if(return_value_strcmp$4 == 0)
            {
              return_value_atol$3=atol(p);
              md_ptr->minor = (unsigned int)return_value_atol$3;
            }

          }
        }

      }

    }
    while((_Bool)1);
    fclose(fd);
  }

}

// gray_to_lut2
// file libng/color_lut.c line 82
static void gray_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned short int * restrict d = (unsigned short int *)dest;
  signed int tmp_post$1;
  do
  {
    tmp_post$1 = p;
    p = p - 1;
    if(!(tmp_post$1 >= 1))
      break;

    unsigned short int * restrict tmp_post$2 = d;
    d = d + 1l;
    *tmp_post$2 = (unsigned short int)(ng_lut_red[(signed long int)*src] | ng_lut_green[(signed long int)*src] | ng_lut_blue[(signed long int)*src]);
    src = src + 1l;
  }
  while((_Bool)1);
}

// gray_to_lut4
// file libng/color_lut.c line 148
static void gray_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned int * restrict d = (unsigned int *)dest;
  signed int tmp_post$1;
  do
  {
    tmp_post$1 = p;
    p = p - 1;
    if(!(tmp_post$1 >= 1))
      break;

    unsigned int * restrict tmp_post$2 = d;
    d = d + 1l;
    *tmp_post$2 = (unsigned int)(ng_lut_red[(signed long int)*src] | ng_lut_green[(signed long int)*src] | ng_lut_blue[(signed long int)*src]);
    src = src + 1l;
  }
  while((_Bool)1);
}

// init_atoms
// file x11/atoms.h line 2
void init_atoms(struct _XDisplay *dpy)
{
  WM_PROTOCOLS=XInternAtom(dpy, "WM_PROTOCOLS", 0);
  WM_DELETE_WINDOW=XInternAtom(dpy, "WM_DELETE_WINDOW", 0);
  _NET_SUPPORTED=XInternAtom(dpy, "_NET_SUPPORTED", 0);
  _NET_WM_STATE=XInternAtom(dpy, "_NET_WM_STATE", 0);
  _NET_WM_STATE_STAYS_ON_TOP=XInternAtom(dpy, "_NET_WM_STATE_STAYS_ON_TOP", 0);
  _NET_WM_STATE_ABOVE=XInternAtom(dpy, "_NET_WM_STATE_ABOVE", 0);
  _NET_WM_STATE_FULLSCREEN=XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", 0);
  _WIN_SUPPORTING_WM_CHECK=XInternAtom(dpy, "_WIN_SUPPORTING_WM_CHECK", 0);
  _WIN_PROTOCOLS=XInternAtom(dpy, "_WIN_PROTOCOLS", 0);
  _WIN_LAYER=XInternAtom(dpy, "_WIN_LAYER", 0);
  _NETSCAPE_URL=XInternAtom(dpy, "_NETSCAPE_URL", 0);
  _XAWTV_STATION=XInternAtom(dpy, "_XAWTV_STATION", 0);
  _XAWTV_REMOTE=XInternAtom(dpy, "_XAWTV_REMOTE", 0);
  XV_MUTE=XInternAtom(dpy, "XV_MUTE", 0);
  XV_ENCODING=XInternAtom(dpy, "XV_ENCODING", 0);
  XV_FREQ=XInternAtom(dpy, "XV_FREQ", 0);
  XV_COLORKEY=XInternAtom(dpy, "XV_COLORKEY", 0);
  _MOTIF_CLIPBOARD_TARGETS=XInternAtom(dpy, "_MOTIF_CLIPBOARD_TARGETS", 0);
  _MOTIF_DEFERRED_CLIPBOARD_TARGETS=XInternAtom(dpy, "_MOTIF_DEFERRED_CLIPBOARD_TARGETS", 0);
  _MOTIF_SNAPSHOT=XInternAtom(dpy, "_MOTIF_SNAPSHOT", 0);
  _MOTIF_DROP=XInternAtom(dpy, "_MOTIF_DROP", 0);
  _MOTIF_EXPORT_TARGETS=XInternAtom(dpy, "_MOTIF_EXPORT_TARGETS", 0);
  _MOTIF_LOSE_SELECTION=XInternAtom(dpy, "_MOTIF_LOSE_SELECTION", 0);
  XA_DEACTIVATE=XInternAtom(dpy, "DEACTIVATE", 0);
  XA_TARGETS=XInternAtom(dpy, "TARGETS", 0);
  XA_DONE=XInternAtom(dpy, "DONE", 0);
  XA_CLIPBOARD=XInternAtom(dpy, "CLIPBOARD", 0);
  XA_UTF8_STRING=XInternAtom(dpy, "UTF8_STRING", 0);
  XA_FILE_NAME=XInternAtom(dpy, "FILE_NAME", 0);
  XA_FILE=XInternAtom(dpy, "FILE", 0);
  XA_BACKGROUND=XInternAtom(dpy, "BACKGROUND", 0);
  XA_FOREGROUND=XInternAtom(dpy, "FOREGROUND", 0);
  XA_PIXEL=XInternAtom(dpy, "PIXEL", 0);
  MIME_TEXT_ISO8859_1=XInternAtom(dpy, "text/plain;charset=ISO-8859-1", 0);
  MIME_TEXT_UTF_8=XInternAtom(dpy, "text/plain;charset=UTF-8", 0);
  MIME_IMAGE_PPM=XInternAtom(dpy, "image/ppm", 0);
  MIME_IMAGE_JPEG=XInternAtom(dpy, "image/jpeg", 0);
  MIME_TEXT_URI_LIST=XInternAtom(dpy, "text/uri-list", 0);
}

// init_channel
// file common/channel.c line 318
static void init_channel(char *name, struct CHANNEL *c)
{
  struct ng_attribute *attr;
  char *val;
  signed int n;
  signed int i;
  val=cfg_get_str(name, "capture");
  if(!(val == ((char *)NULL)))
  {
    i=str_to_int(val, captab);
    if(!(i == -1))
      c->capture = i;

    else
      fprintf(stderr, "config: invalid value for capture: %s\n", val);
  }

  attr=ng_attr_byid(attrs, 2);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "input");
    _Bool tmp_if_expr$1;
    if(!(val == ((char *)NULL)))
      tmp_if_expr$1 = (_Bool)1;

    else
    {
      val=cfg_get_str(name, "source");
      tmp_if_expr$1 = (char *)(void *)0 != val ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$1)
    {
      i=ng_attr_getint(attr, val);
      if(!(i == -1))
        c->input = i;

      else
      {
        fprintf(stderr, "config: invalid value for input: %s\n", val);
        ng_attr_listchoices(attr);
      }
    }

  }

  attr=ng_attr_byid(attrs, 1);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "norm");
    if(!(val == ((char *)NULL)))
    {
      i=ng_attr_getint(attr, val);
      if(!(i == -1))
        c->norm = i;

      else
      {
        fprintf(stderr, "config: invalid value for norm: %s\n", val);
        ng_attr_listchoices(attr);
      }
    }

  }

  attr=ng_attr_byid(attrs, 5);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "audio");
    if(!(val == ((char *)NULL)))
    {
      i=ng_attr_getint(attr, val);
      if(!(i == -1))
        c->audio = i;

      else
      {
        fprintf(stderr, "config: invalid value for audio: %s\n", val);
        ng_attr_listchoices(attr);
      }
    }

  }

  val=cfg_get_str(name, "channel");
  if(!(val == ((char *)NULL)))
    c->cname=strdup(val);

  val=cfg_get_str(name, "freq");
  double return_value_atof$2;
  if(!(val == ((char *)NULL)))
  {
    return_value_atof$2=atof(val);
    c->freq = (signed int)(return_value_atof$2 * (double)16);
  }

  n=cfg_get_signed_int(name, "fine");
  if(!(n == 0))
    c->fine = n;

  val=cfg_get_str(name, "key");
  if(!(val == ((char *)NULL)))
    c->key=strdup(val);

  val=cfg_get_str(name, "group");
  if(!(val == ((char *)NULL)))
    c->group=strdup(val);

  val=cfg_get_str(name, "midi");
  if(!(val == ((char *)NULL)))
    c->midi=atoi(val);

  attr=ng_attr_byid(attrs, 6);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "color");
    if(!(val == ((char *)NULL)))
      c->color=ng_attr_parse_int(attr, val);

  }

  attr=ng_attr_byid(attrs, 7);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "bright");
    if(!(val == ((char *)NULL)))
      c->bright=ng_attr_parse_int(attr, val);

  }

  attr=ng_attr_byid(attrs, 8);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "hue");
    if(!(val == ((char *)NULL)))
      c->hue=ng_attr_parse_int(attr, val);

  }

  attr=ng_attr_byid(attrs, 9);
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    val=cfg_get_str(name, "contrast");
    if(!(val == ((char *)NULL)))
      c->contrast=ng_attr_parse_int(attr, val);

  }

}

// init_overlay
// file common/commands.c line 202
void init_overlay(void)
{
  const char *tmp_if_expr$1;
  if(!(chantab == -1))
    tmp_if_expr$1 = (chanlist_names + (signed long int)chantab)->str;

  else
    tmp_if_expr$1 = "europe-west";
  do_va_cmd(2, (const void *)"setfreqtab", tmp_if_expr$1);
  cur_capture = -1;
  switch(defaults.capture)
  {
    case 9:

    case 1:
    {
      do_va_cmd(2, (const void *)"capture", (const void *)"overlay");
      break;
    }
    case 2:
    {
      do_va_cmd(2, (const void *)"capture", (const void *)"grabdisplay");
      break;
    }
    default:
      do_va_cmd(2, (const void *)"capture", (const void *)"off");
  }
}

// init_sim
// file common/vbi-sim.c line 429
static struct vbi_raw_decoder * init_sim(signed int scanning, unsigned int services)
{
  vbi_raw_decoder_init(&sim);
  sim.scanning = scanning;
  sim.sampling_format = (enum anonymous$13)VBI_PIXFMT_YUV420;
  sim.sampling_rate = 2 * 13500000;
  sim.bytes_per_line = 1440;
  sim.offset = (signed int)(9.7e-6 * (double)sim.sampling_rate);
  sim.interlaced = 0;
  sim.synchronous = 1;
  if(scanning == 525)
  {
    sim.start[(signed long int)0] = 10;
    sim.count[(signed long int)0] = (21 - 10) + 1;
    sim.start[(signed long int)1] = 272;
    sim.count[(signed long int)1] = (285 - 272) + 1;
  }

  else
    if(scanning == 625)
    {
      sim.start[(signed long int)0] = 6;
      sim.count[(signed long int)0] = (23 - 6) + 1;
      sim.start[(signed long int)1] = 318;
      sim.count[(signed long int)1] = (335 - 318) + 1;
    }

    else
      /* assertion !"invalid scanning value" */
      assert(!((_Bool)"invalid scanning value"));
  sim_time = 0.0;
  vbi_raw_decoder_add_services(&sim, services, 0);
  return &sim;
}

// int_to_str
// file common/channel.c line 752
const char * int_to_str(signed int n, struct STRTAB *tab)
{
  signed int i = 0;
  for( ; !((tab + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
    if((tab + (signed long int)i)->nr == (signed long int)n)
      return (tab + (signed long int)i)->str;

  return (const char *)(void *)0;
}

// keypad_handler
// file common/commands.c line 1484
static signed int keypad_handler(char *name, signed int argc, char **argv)
{
  signed int n;
  signed int return_value_atoi$1;
  return_value_atoi$1=atoi(argv[(signed long int)0]);
  n = return_value_atoi$1 % 10;
  char msg[8l];
  char ch[8l];
  if(!(debug == 0))
    fprintf(stderr, "keypad: key %d\n", n);

  if(keypad_state == -1)
  {
    if((keypad_ntsc == 0 ? count >= n : !(n >= 100)) && n >= 1 && !(keypad_partial == 0) || keypad_partial == 0 && (keypad_ntsc == 0 ? count >= n : !(n >= 100)) && n >= 1 && !(keypad_ntsc == 0 ? count >= 10 * n : !(10 * n >= 100)))
    {
      if(!(keypad_ntsc == 0))
      {
        sprintf(ch, "%d", n);
        do_va_cmd(2, (const void *)"setchannel", (const void *)ch, (void *)0);
      }

      else
        do_va_cmd(2, (const void *)"setstation", channels[(signed long int)(n - 1)]->name, (void *)0);
    }

    if((keypad_ntsc == 0 ? count >= 10 * n : !(10 * n >= 100)) && n >= 0)
    {
      if(!(debug == 0))
        fprintf(stderr, "keypad: hang: %d\n", n);

      keypad_state = n;
      if(!(display_message == ((void (*)(char *))NULL)))
      {
        sprintf(msg, "%d_", n);
        display_message(msg);
      }

    }

  }

  else
  {
    if((keypad_ntsc == 0 ? count : 99) >= 10 * keypad_state + n)
      n = n + keypad_state * 10;

    keypad_state = -1;
    if(!(debug == 0))
      fprintf(stderr, "keypad: ok: %d\n", n);

    if((keypad_ntsc == 0 ? count >= n : !(n >= 100)) && n >= 1)
    {
      if(!(keypad_ntsc == 0))
      {
        sprintf(ch, "%d", n);
        do_va_cmd(2, (const void *)"setchannel", (const void *)ch, (void *)0);
      }

      else
        do_va_cmd(2, (const void *)"setstation", channels[(signed long int)(n - 1)]->name, (void *)0);
    }

  }
  return 0;
}

// keypad_timeout
// file common/commands.c line 1527
void keypad_timeout(void)
{
  if(!(debug == 0))
    fprintf(stderr, "keypad: timeout\n");

  if(keypad_state == 1 + cur_sender)
    set_title();

  keypad_state = -1;
}

// list_add_tail
// file ./libng/list.h line 65
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
  __list_add(new, head->prev, head);
}

// list_add_tail$link1
// file libng/list.h line 65
static inline void list_add_tail$link1(struct list_head *new$link1, struct list_head *head$link1)
{
  __list_add$link1(new$link1, head$link1->prev, head$link1);
}

// list_del
// file ./libng/list.h line 89
static inline void list_del(struct list_head *entry)
{
  __list_del(entry->prev, entry->next);
}

// list_handler
// file common/commands.c line 943
static signed int list_handler(char *name, signed int argc, char **argv)
{
  struct ng_attribute *attr;
  signed int val;
  signed int i;
  printf("%-10.10s | type   | %-7.7s | %-7.7s | %s\n", (const void *)"attribute", (const void *)"current", (const void *)"default", (const void *)"comment");
  printf("-----------+--------+---------+---------+-------------------------------------\n");
  attr = attrs;
  const char *return_value_ng_attr_getstr$1;
  const char *return_value_ng_attr_getstr$2;
  for( ; !(attr->name == ((const char *)NULL)); attr = attr + 1l)
  {
    val = cur_attrs[(signed long int)attr->id];
    switch(attr->type)
    {
      case 2:
      {
        return_value_ng_attr_getstr$1=ng_attr_getstr(attr, val);
        return_value_ng_attr_getstr$2=ng_attr_getstr(attr, attr->defval);
        printf("%-10.10s | choice | %-7.7s | %-7.7s |", attr->name, return_value_ng_attr_getstr$1, return_value_ng_attr_getstr$2);
        i = 0;
        for( ; !((attr->choices + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
          printf(" %s", (attr->choices + (signed long int)i)->str);
        printf("\n");
        break;
      }
      case 1:
      {
        printf("%-10.10s | int    | %7d | %7d | range is %d => %d\n", attr->name, val, attr->defval, attr->min, attr->max);
        break;
      }
      case 3:
        printf("%-10.10s | bool   | %-7.7s | %-7.7s |\n", attr->name, val != 0 ? "on" : "off", attr->defval != 0 ? "on" : "off");
    }
  }
  return 0;
}

// lookup_channel
// file common/channel.c line 102
signed int lookup_channel(char *channel)
{
  signed int i;
  signed int tmp_if_expr$1;
  signed int return_value_strcasecmp$3;
  if(channel == ((char *)NULL))
    return -1;

  else
  {
    i = 0;
    do
    {
      if(!(chantab == -1))
        tmp_if_expr$1 = (chanlists + (signed long int)chantab)->count;

      else
        tmp_if_expr$1 = 0;
      if(i >= tmp_if_expr$1)
        break;

      struct CHANLIST *tmp_if_expr$2;
      if(!(chantab == -1))
        tmp_if_expr$2 = (chanlists + (signed long int)chantab)->list;

      else
        tmp_if_expr$2 = (struct CHANLIST *)(void *)0;
      return_value_strcasecmp$3=strcasecmp((tmp_if_expr$2 + (signed long int)i)->name, channel);
      if(return_value_strcasecmp$3 == 0)
        break;

      i = i + 1;
    }
    while((_Bool)1);
    signed int tmp_if_expr$4;
    if(!(chantab == -1))
      tmp_if_expr$4 = (chanlists + (signed long int)chantab)->count;

    else
      tmp_if_expr$4 = 0;
    if(i == tmp_if_expr$4)
      return -1;

    else
      return i;
  }
}

// main
// file x11/mtt.c line 197
signed int main(signed int argc, char **argv)
{
  struct vbi_state *vbi;
  char **av;
  signed int ac = argc;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(char *) /*8ul*/  * (unsigned long int)(argc + 1));
  av = (char **)return_value_malloc$1;
  memcpy((void *)av, (const void *)argv, sizeof(char *) /*8ul*/  * (unsigned long int)(argc + 1));
  XtSetLanguageProc((struct _XtAppStruct *)(void *)0, (char * (*)(struct _XDisplay *, char *, void *))(void *)0, (void *)0);
  XtToolkitInitialize();
  app_context=XtCreateApplicationContext();
  XtAppSetFallbackResources(app_context, fallback_ressources);
  dpy=XtOpenDisplay(app_context, (const char *)(void *)0, (const char *)(void *)0, "mtt", opt_desc, (unsigned int)opt_count, &argc, argv);
  if(dpy == ((struct _XDisplay *)NULL))
    main_tty(ac, av);

  app_shell=XtVaAppCreateShell((const char *)(void *)0, "mtt", applicationShellWidgetClass, dpy, (void *)0);
  XtAppAddActions(app_context, actionTable, (unsigned int)(sizeof(struct _XtActionsRec [1l]) /*16ul*/  / sizeof(struct _XtActionsRec) /*16ul*/ ));
  x11_icons_init(dpy, (unsigned long int)0);
  init_atoms(dpy);
  XtGetApplicationResources(app_shell, (void *)&args, args_desc, (unsigned int)args_count, (struct anonymous$1 *)(void *)0, (unsigned int)0);
  if(!(args.help == 0))
  {
    usage();
    exit(1);
  }

  if(!(args.tty == 0))
    main_tty(ac, av);

  freq_init();
  read_config((char *)(void *)0, &argc, argv);
  parse_config(1);
  const char *tmp_if_expr$2;
  if(!(chantab == -1))
    tmp_if_expr$2 = (chanlist_names + (signed long int)chantab)->str;

  else
    tmp_if_expr$2 = "europe-west";
  do_va_cmd(2, (const void *)"setfreqtab", tmp_if_expr$2);
  vbi=vbi_open(args.device, args.debug, args.sim);
  if(vbi == ((struct vbi_state *)NULL))
    exit(1);

  if(!(args.debug == 0))
    vbi_event_handler_add(vbi->dec, ~0, vbi_dump_event, (void *)vbi);

  XtAppAddInput(app_context, vbi->fd, (void *)(1L << 0), vbi_data, (void *)vbi);
  vbi_create_widgets(app_shell, vbi);
  XtRealizeWidget(app_shell);
  XtAppMainLoop(app_context);
  return 0;
}

// main_tty
// file x11/mtt.c line 154
static signed int main_tty(signed int argc, char **argv)
{
  char *dev = "/dev/vbi0";
  signed int main_tty$$1$$debug = 0;
  signed int main_tty$$1$$sim = 0;
  argc = argc - 1;
  argv = argv + 1l;
  signed int return_value_strcmp$10;
  signed int return_value_strcmp$8;
  signed int return_value_strcmp$7;
  signed int return_value_strcmp$6;
  signed int return_value_strcmp$1;
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$4;
  while(!(argc == 0))
  {
    signed int return_value_strcmp$9;
    return_value_strcmp$9=strcmp(argv[(signed long int)0], "-c");
    _Bool tmp_if_expr$11;
    if(return_value_strcmp$9 == 0)
      tmp_if_expr$11 = (_Bool)1;

    else
    {
      return_value_strcmp$10=strcmp(argv[(signed long int)0], "-device");
      tmp_if_expr$11 = 0 == return_value_strcmp$10 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$11)
    {
      dev = argv[(signed long int)1];
      argc = argc - 2;
      argv = argv + (signed long int)2;
    }

    else
    {
      return_value_strcmp$8=strcmp(argv[(signed long int)0], "-tty");
      if(return_value_strcmp$8 == 0)
      {
        argc = argc - 1;
        argv = argv + (signed long int)1;
      }

      else
      {
        return_value_strcmp$7=strcmp(argv[(signed long int)0], "-debug");
        if(return_value_strcmp$7 == 0)
        {
          main_tty$$1$$debug = 1;
          argc = argc - 1;
          argv = argv + (signed long int)1;
        }

        else
        {
          return_value_strcmp$6=strcmp(argv[(signed long int)0], "-sim");
          if(return_value_strcmp$6 == 0)
          {
            main_tty$$1$$sim = 1;
            argc = argc - 1;
            argv = argv + (signed long int)1;
          }

          else
          {
            return_value_strcmp$1=strcmp(argv[(signed long int)0], "-h");
            _Bool tmp_if_expr$3;
            if(return_value_strcmp$1 == 0)
            {
              return_value_strcmp$2=strcmp(argv[(signed long int)0], "-help");
              tmp_if_expr$3 = 0 == return_value_strcmp$2 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$3 = (_Bool)0;
            _Bool tmp_if_expr$5;
            if(tmp_if_expr$3)
            {
              return_value_strcmp$4=strcmp(argv[(signed long int)0], "--help");
              tmp_if_expr$5 = 0 == return_value_strcmp$4 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$5 = (_Bool)0;
            if(tmp_if_expr$5)
            {
              usage();
              exit(0);
            }

            else
              break;
          }
        }
      }
    }
  }
  vbi_tty(dev, main_tty$$1$$debug, main_tty$$1$$sim);
  exit(0);
}

// media_device_type
// file common/get_media_devices.c line 364
const char * media_device_type(enum device_type type)
{
  switch((signed int)type)
  {
    case MEDIA_V4L_VIDEO:
      return "video";
    case MEDIA_V4L_VBI:
      return "vbi";
    case MEDIA_V4L_RADIO:
      return "radio";
    case MEDIA_V4L_SUBDEV:
      return "v4l subdevice";
    case MEDIA_DVB_VIDEO:
      return "dvb video";
    case MEDIA_DVB_AUDIO:
      return "dvb audio";
    case MEDIA_DVB_SEC:
      return "dvb sec";
    case MEDIA_DVB_FRONTEND:
      return "dvb frontend";
    case MEDIA_DVB_DEMUX:
      return "dvb demux";
    case MEDIA_DVB_DVR:
      return "dvb dvr";
    case MEDIA_DVB_NET:
      return "dvb net";
    case MEDIA_DVB_CA:
      return "dvb conditional access";
    case MEDIA_DVB_OSD:
      return "dvb OSD";
    case MEDIA_SND_CARD:
      return "sound card";
    case MEDIA_SND_CAP:
      return "pcm capture";
    case MEDIA_SND_OUT:
      return "pcm output";
    case MEDIA_SND_CONTROL:
      return "mixer";
    case MEDIA_SND_HW:
      return "sound hardware";
    case MEDIA_SND_TIMER:
      return "sound timer";
    case MEDIA_SND_SEQ:
      return "sound sequencer";
    default:
      return "unknown";
  }
}

// movie_grab_put_video
// file common/capture.c line 606
signed int movie_grab_put_video(struct movie_handle *h, struct ng_video_buf **ret)
{
  struct ng_video_buf *buf;
  signed int expected;
  signed int rc;
  if(debug >= 2)
    fprintf(stderr, "grab_put_video\n");

  buf=ng_grabber_grab_image(0);
  if(buf == ((struct ng_video_buf *)NULL))
  {
    if(!(debug == 0))
      fprintf(stderr, "grab_put_video: grab image failed\n");

    return -1;
  }

  else
  {
    expected = (signed int)((((unsigned long int)buf->info.ts - h->vdrift) * (unsigned long int)h->fps) / (unsigned long int)1000000000000ULL);
    if(!(expected >= h->frames + -1))
    {
      if(debug >= 2)
        fprintf(stderr, "rate: ignoring frame [%d %d]\n", expected, h->frames);

      ng_release_video_buf(buf);
      return 0;
    }

    else
    {
      if(!(1 + h->frames >= expected))
      {
        fprintf(stderr, "rate: queueing frame twice (%d)\n", expected - h->frames);
        buf->info.twice = buf->info.twice + 1;
        h->frames = h->frames + 1;
      }

      h->frames = h->frames + 1;
      h->vts = (unsigned long int)buf->info.ts;
      buf->info.seq = h->seq;
      if(!(ret == ((struct ng_video_buf **)NULL)))
      {
        buf->refcount = buf->refcount + 1;
        *ret = buf;
      }

      if(!(h->cthreads == 0))
        rc=fifo_put(&h->cfifo, (void *)buf);

      else
        rc=fifo_put(&h->vfifo, (void *)buf);
      if(!(rc == 0))
      {
        ng_release_video_buf(buf);
        return h->frames;
      }

      else
      {
        h->seq = h->seq + 1;
        movie_print_timestamps(h);
        return h->frames;
      }
    }
  }
}

// movie_handler
// file common/commands.c line 1149
static signed int movie_handler(char *name, signed int argc, char **argv)
{
  if(movie_hook == ((void (*)(signed int, char **))NULL))
    return 0;

  else
  {
    movie_hook(argc, argv);
    return 0;
  }
}

// movie_print_timestamps
// file common/capture.c line 583
static void movie_print_timestamps(struct movie_handle *h)
{
  char line[128l];
  if(!(rec_status == ((void (*)(char *))NULL)))
  {
    signed int return_value_abs$1;
    return_value_abs$1=abs((signed int)h->rdrift);
    signed int return_value_abs$2;
    return_value_abs$2=abs((signed int)h->rdrift);
    signed int return_value_abs$3;
    return_value_abs$3=abs((signed int)h->vdrift);
    signed int return_value_abs$4;
    return_value_abs$4=abs((signed int)h->vdrift);
    sprintf(line, "rec %d:%02d.%02d  -  a/r: %c%d.%02ds [%d], a/v: %c%d.%02ds [%d]", (signed int)((h->rts / (unsigned long int)1000000000) / (unsigned long int)60), (signed int)((h->rts / (unsigned long int)1000000000) % (unsigned long int)60), (signed int)((h->rts % (unsigned long int)1000000000) / (unsigned long int)10000000), h->rdrift > (unsigned long int)0 ? 43 : 45, (signed int)(return_value_abs$1 / 1000000000), (signed int)((return_value_abs$2 % 1000000000) / 10000000), (signed int)((h->rdrift * (unsigned long int)h->fps) / (unsigned long int)1000000000000ULL), h->vdrift > (unsigned long int)0 ? 43 : 45, (signed int)(return_value_abs$3 / 1000000000), (signed int)((return_value_abs$4 % 1000000000) / 10000000), (signed int)((h->vdrift * (unsigned long int)h->fps) / (unsigned long int)1000000000000ULL));
    rec_status(line);
  }

}

// movie_writer_init
// file common/capture.c line 398
struct movie_handle * movie_writer_init(char *moviename, char *audioname, struct ng_writer *writer, struct ng_video_fmt *video, const void *priv_video, signed int fps, struct ng_audio_fmt *audio, const void *priv_audio, char *dsp, signed int slots, signed int threads)
{
  struct movie_handle *h;
  struct ng_video_conv *conv;
  void *dummy;
  signed int i;
  if(!(debug == 0))
    fprintf(stderr, "movie_init_writer start\n");

  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct movie_handle) /*2184ul*/ );
  h = (struct movie_handle *)return_value_malloc$1;
  if(h == ((struct movie_handle *)NULL))
    return (struct movie_handle *)(void *)0;

  else
  {
    memset((void *)h, 0, sizeof(struct movie_handle) /*2184ul*/ );
    pthread_mutex_init(&h->lock, (const union anonymous$86 *)(void *)0);
    h->writer = writer;
    h->slots = slots;
    if(!(audio->fmtid == 0u))
    {
      h->dsp=ng_dsp_open(dsp, audio, 1, &h->hdsp);
      if(h->dsp == ((struct ng_dsp_driver *)NULL))
      {
        free((void *)h);
        return (struct movie_handle *)(void *)0;
      }

      fifo_init(&h->afifo, "audio", slots, 1);
      pthread_create(&h->taudio, (const union pthread_attr_t *)(void *)0, writer_audio_thread, (void *)h);
      h->bytes_per_sec = (unsigned long int)((ng_afmt_to_bits[(signed long int)audio->fmtid] * ng_afmt_to_channels[(signed long int)audio->fmtid] * audio->rate) / (unsigned int)8);
      h->afmt = *audio;
    }

    if(!(video->fmtid == 0u))
    {
      signed int return_value_ng_grabber_setformat$3;
      return_value_ng_grabber_setformat$3=ng_grabber_setformat(video, 1);
      if(return_value_ng_grabber_setformat$3 == 0)
      {
        fifo_init(&h->vfifo, "video", slots, 1);
        pthread_create(&h->tvideo, (const union pthread_attr_t *)(void *)0, writer_video_thread, (void *)h);
      }

      else
      {
        struct ng_video_fmt gfmt = *video;
        conv=ng_grabber_findconv(&gfmt, 1);
        if(conv == ((struct ng_video_conv *)NULL))
        {
          if(!(h->afmt.fmtid == 0u))
            h->dsp->close(h->hdsp);

          free((void *)h);
          return (struct movie_handle *)(void *)0;
        }

        h->cthreads = threads;
        if(!(h->cthreads >= 1))
          h->cthreads = 1;

        if(h->cthreads >= 5)
          h->cthreads = 4;

        fifo_init(&h->vfifo, "video", slots, h->cthreads);
        fifo_init(&h->cfifo, "conv", slots, 1);
        pthread_create(&h->tvideo, (const union pthread_attr_t *)(void *)0, writer_video_thread, (void *)h);
        i = 0;
        for( ; !(i >= h->cthreads); i = i + 1)
        {
          void *return_value_malloc$2;
          return_value_malloc$2=malloc(sizeof(struct ng_convthread_handle) /*24ul*/ );
          h->hconv[(signed long int)i] = (struct ng_convthread_handle *)return_value_malloc$2;
          memset((void *)h->hconv[(signed long int)i], 0, sizeof(struct ng_convthread_handle) /*24ul*/ );
          h->hconv[(signed long int)i]->c=ng_convert_alloc(conv, &gfmt, video);
          h->hconv[(signed long int)i]->in = &h->cfifo;
          h->hconv[(signed long int)i]->out = &h->vfifo;
          pthread_create(&h->tconv[(signed long int)i], (const union pthread_attr_t *)(void *)0, ng_convert_thread, (void *)h->hconv[(signed long int)i]);
        }
      }
      h->vfmt = *video;
      h->fps = fps;
    }

    h->handle=writer->wr_open(moviename, audioname, video, priv_video, fps, audio, priv_audio);
    if(!(debug == 0))
      fprintf(stderr, "movie_init_writer end (h=%p)\n", h->handle);

    if(!(h->handle == NULL))
      return h;

    else
    {
      if(!(h->afmt.fmtid == 0u))
      {
        pthread_cancel(h->taudio);
        pthread_join(h->taudio, &dummy);
        h->dsp->close(h->hdsp);
      }

      if(!(h->vfmt.fmtid == 0u))
      {
        pthread_cancel(h->tvideo);
        pthread_join(h->tvideo, &dummy);
      }

      i = 0;
      if(!(i >= h->cthreads))
      {
        pthread_cancel(h->tconv[(signed long int)i]);
        pthread_join(h->tconv[(signed long int)i], &dummy);
        i = i + 1;
      }

      free((void *)h);
      return (struct movie_handle *)(void *)0;
    }
  }
}

// movie_writer_start
// file common/capture.c line 498
signed int movie_writer_start(struct movie_handle *h)
{
  signed int rc = 0;
  if(!(debug == 0))
    fprintf(stderr, "movie_writer_start\n");

  signed long int return_value_ng_get_timestamp$1;
  return_value_ng_get_timestamp$1=ng_get_timestamp();
  h->start = (unsigned long int)return_value_ng_get_timestamp$1;
  signed int return_value;
  if(!(h->afmt.fmtid == 0u))
  {
    return_value=h->dsp->startrec(h->hdsp);
    if(!(return_value == 0))
      rc = -1;

  }

  signed int return_value_1;
  if(!(h->vfmt.fmtid == 0u))
  {
    return_value_1=drv->startvideo(h_drv, h->fps, (unsigned int)h->slots);
    if(!(return_value_1 == 0))
      rc = -1;

  }

  if(!(h->afmt.fmtid == 0u))
    pthread_create(&h->raudio, (const union pthread_attr_t *)(void *)0, record_audio_thread, (void *)h);

  pthread_create(&h->tflush, (const union pthread_attr_t *)(void *)0, flushit, (void *)0);
  return rc;
}

// movie_writer_stop
// file common/capture.c line 518
signed int movie_writer_stop(struct movie_handle *h)
{
  char line[128l];
  unsigned long int stopby;
  signed int frames;
  signed int i;
  void *dummy;
  if(!(debug == 0))
    fprintf(stderr, "movie_writer_stop\n");

  _Bool tmp_if_expr$1;
  if(!(h->vfmt.fmtid == 0u))
    tmp_if_expr$1 = h->afmt.fmtid != (unsigned int)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
  {
    frames = 0;
    for( ; !(frames >= 16); frames = frames + 1)
    {
      stopby = ((unsigned long int)(h->frames + frames) * (unsigned long int)1000000000000ULL) / (unsigned long int)h->fps;
      if(!(h->ats >= stopby))
        break;

    }
    frames = frames + 1;
    h->stopby = ((unsigned long int)(h->frames + frames) * (unsigned long int)1000000000000ULL) / (unsigned long int)h->fps;
    for( ; !(frames == 0); frames = frames - 1)
      movie_grab_put_video(h, (struct ng_video_buf **)(void *)0);
  }

  else
    if(!(h->afmt.fmtid == 0u))
      h->stopby = h->ats;

  if(!(h->cthreads == 0))
    fifo_put(&h->cfifo, (void *)0);

  else
    fifo_put(&h->vfifo, (void *)0);
  if(!(h->afmt.fmtid == 0u))
  {
    pthread_join(h->raudio, &dummy);
    pthread_join(h->taudio, &dummy);
  }

  if(!(h->vfmt.fmtid == 0u))
    pthread_join(h->tvideo, &dummy);

  i = 0;
  for( ; !(i >= h->cthreads); i = i + 1)
    pthread_join(h->tconv[(signed long int)i], &dummy);
  pthread_cancel(h->tflush);
  pthread_join(h->tflush, &dummy);
  h->writer->wr_close(h->handle);
  if(!(h->afmt.fmtid == 0u))
    h->dsp->close(h->hdsp);

  if(!(h->vfmt.fmtid == 0u))
    drv->stopvideo(h_drv);

  sprintf(line, "fifo max fill: audio %d/%d, video %d/%d, convert %d/%d", h->afifo.max, h->afifo.slots, h->vfifo.max, h->vfifo.slots, h->cfifo.max, h->cfifo.slots);
  rec_status(line);
  free((void *)h);
  return 0;
}

// msg_handler
// file common/commands.c line 1166
static signed int msg_handler(char *name, signed int argc, char **argv)
{
  if(!(display_message == ((void (*)(char *))NULL)))
    display_message(argv[(signed long int)0]);

  return 0;
}

// ng_aconv_register
// file libng/grab-ng.c line 409
signed int ng_aconv_register(signed int magic, char *plugname, struct ng_audio_conv *list, signed int count)
{
  signed int n;
  signed int return_value_ng_check_magic$1;
  return_value_ng_check_magic$1=ng_check_magic(magic, plugname, "audio converters");
  if(!(return_value_ng_check_magic$1 == 0))
    return -1;

  else
  {
    n = 0;
    for( ; !(n >= count); n = n + 1)
      list_add_tail$link1(&(list + (signed long int)n)->list, &ng_aconv);
    return 0;
  }
}

// ng_attr_byid
// file ./libng/grab-ng.h line 257
struct ng_attribute * ng_attr_byid(struct ng_attribute *attrs, signed int id)
{
  if(attrs == ((struct ng_attribute *)NULL))
    return (struct ng_attribute *)(void *)0;

  else
    for( ; (_Bool)1; attrs = attrs + 1l)
    {
      if(attrs->name == ((const char *)NULL))
        return (struct ng_attribute *)(void *)0;

      if(attrs->id == id)
        return attrs;

    }
}

// ng_attr_byname
// file ./libng/grab-ng.h line 258
struct ng_attribute * ng_attr_byname(struct ng_attribute *attrs, char *name)
{
  if(attrs == ((struct ng_attribute *)NULL))
    return (struct ng_attribute *)(void *)0;

  else
    while((_Bool)1)
    {
      if(attrs->name == ((const char *)NULL))
        return (struct ng_attribute *)(void *)0;

      signed int return_value_strcasecmp$1;
      return_value_strcasecmp$1=strcasecmp(attrs->name, name);
      if(return_value_strcasecmp$1 == 0)
        return attrs;

      attrs = attrs + 1l;
    }
}

// ng_attr_getint
// file ./libng/grab-ng.h line 260
signed int ng_attr_getint(struct ng_attribute *attr, char *value)
{
  signed int i;
  signed int val;
  if(attr == ((struct ng_attribute *)NULL))
    return -1;

  else
    if(!(attr->type == 2))
      return -1;

    else
    {
      i = 0;
      for( ; !((attr->choices + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
      {
        signed int return_value_strcasecmp$1;
        return_value_strcasecmp$1=strcasecmp((attr->choices + (signed long int)i)->str, value);
        if(return_value_strcasecmp$1 == 0)
          return (signed int)(attr->choices + (signed long int)i)->nr;

      }
      const unsigned short int **return_value___ctype_b_loc$2;
      return_value___ctype_b_loc$2=__ctype_b_loc();
      if(!((2048 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)*value]) == 0))
      {
        val=atoi(value);
        i = 0;
        for( ; !((attr->choices + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
          if((signed long int)val == (attr->choices + (signed long int)i)->nr)
            return (signed int)(attr->choices + (signed long int)i)->nr;

      }

      return -1;
    }
}

// ng_attr_getstr
// file ./libng/grab-ng.h line 259
const char * ng_attr_getstr(struct ng_attribute *attr, signed int value)
{
  signed int i;
  if(attr == ((struct ng_attribute *)NULL))
    return (const char *)(void *)0;

  else
    if(!(attr->type == 2))
      return (const char *)(void *)0;

    else
    {
      i = 0;
      for( ; !((attr->choices + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
        if((attr->choices + (signed long int)i)->nr == (signed long int)value)
          return (attr->choices + (signed long int)i)->str;

      return (const char *)(void *)0;
    }
}

// ng_attr_int2percent
// file ./libng/grab-ng.h line 262
signed int ng_attr_int2percent(struct ng_attribute *attr, signed int value)
{
  signed int range;
  signed int percent;
  range = attr->max - attr->min;
  percent = ((value - attr->min) * 100) / range;
  if(!(percent >= 0))
    percent = 0;

  if(percent >= 101)
    percent = 100;

  return percent;
}

// ng_attr_listchoices
// file ./libng/grab-ng.h line 261
void ng_attr_listchoices(struct ng_attribute *attr)
{
  signed int i;
  fprintf(stderr, "valid choices for \"%s\": ", attr->name);
  i = 0;
  for( ; !((attr->choices + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
    fprintf(stderr, "%s\"%s\"", i != 0 ? ", " : "", (attr->choices + (signed long int)i)->str);
  fprintf(stderr, "\n");
}

// ng_attr_parse_int
// file ./libng/grab-ng.h line 264
signed int ng_attr_parse_int(struct ng_attribute *attr, char *str)
{
  signed int value;
  signed int n;
  signed int return_value_sscanf$1;
  return_value_sscanf$1=sscanf(str, "%d%n", &value, &n);
  if(return_value_sscanf$1 == 0)
    return attr->defval;

  else
  {
    if((signed int)str[(signed long int)n] == 37)
      value=ng_attr_percent2int(attr, value);

    if(!(value >= attr->min))
      value = attr->min;

    if(!(attr->max >= value))
      value = attr->max;

    return value;
  }
}

// ng_attr_percent2int
// file libng/grab-ng.c line 297
signed int ng_attr_percent2int(struct ng_attribute *attr, signed int percent)
{
  signed int range;
  signed int value;
  range = attr->max - attr->min;
  value = (percent * range) / 100 + attr->min;
  if(!(value >= attr->min))
    value = attr->min;

  if(!(attr->max >= value))
    value = attr->max;

  return value;
}

// ng_check_clipping
// file libng/grab-ng.c line 847
void ng_check_clipping(signed int width, signed int height, signed int xadjust, signed int yadjust, struct OVERLAY_CLIP *oc, signed int *count)
{
  signed int i;
  signed int j;
  if(ng_debug >= 2)
  {
    fprintf(stderr, "clip: win=%dx%d xa=%d ya=%d\n", width, height, xadjust, yadjust);
    clip_dump("init", oc, *count);
  }

  i = 0;
  for( ; !(i >= *count); i = i + 1)
  {
    (oc + (signed long int)i)->x1 = (oc + (signed long int)i)->x1 + xadjust;
    (oc + (signed long int)i)->x2 = (oc + (signed long int)i)->x2 + xadjust;
    (oc + (signed long int)i)->y1 = (oc + (signed long int)i)->y1 + yadjust;
    (oc + (signed long int)i)->y2 = (oc + (signed long int)i)->y2 + yadjust;
  }
  if(ng_debug >= 2)
    clip_dump("fixup adjust", oc, *count);

  i = 0;
  for( ; !(i >= *count); i = i + 1)
  {
    if(!((oc + (signed long int)i)->x1 >= 0))
      (oc + (signed long int)i)->x1 = 0;

    if(!((oc + (signed long int)i)->x2 >= 0))
      (oc + (signed long int)i)->x2 = 0;

    if(!(width >= (oc + (signed long int)i)->x1))
      (oc + (signed long int)i)->x1 = width;

    if(!(width >= (oc + (signed long int)i)->x2))
      (oc + (signed long int)i)->x2 = width;

    if(!((oc + (signed long int)i)->y1 >= 0))
      (oc + (signed long int)i)->y1 = 0;

    if(!((oc + (signed long int)i)->y2 >= 0))
      (oc + (signed long int)i)->y2 = 0;

    if(!(height >= (oc + (signed long int)i)->y1))
      (oc + (signed long int)i)->y1 = height;

    if(!(height >= (oc + (signed long int)i)->y2))
      (oc + (signed long int)i)->y2 = height;

  }
  if(ng_debug >= 2)
    clip_dump("fixup range", oc, *count);

  i = 0;
  while(!(i >= *count))
  {
    _Bool tmp_if_expr$1;
    if((oc + (signed long int)i)->x1 == (oc + (signed long int)i)->x2)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = (oc + (signed long int)i)->y1 == (oc + (signed long int)i)->y2 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      clip_drop(oc, i, count);

    else
      i = i + 1;
  }
  if(ng_debug >= 2)
    clip_dump("zerosize done", oc, *count);

  do
  {

  restart_merge:
    ;
    j = *count - 1;

  __CPROVER_DUMP_L23:
    ;
    if(!(j >= 0))
      goto __CPROVER_DUMP_L34;

    i = 0;

  __CPROVER_DUMP_L24:
    ;
    if(i >= *count)
      goto __CPROVER_DUMP_L33;

    if(i == j)
      break;

    if((oc + (signed long int)i)->x1 == (oc + (signed long int)j)->x1)
    {
      if((oc + (signed long int)i)->x2 == (oc + (signed long int)j)->x2)
      {
        if((oc + (signed long int)j)->y1 >= (oc + (signed long int)i)->y1)
        {
          if((oc + (signed long int)i)->y2 >= (oc + (signed long int)j)->y1)
          {
            if(ng_debug >= 2)
              fprintf(stderr, "clip: merge y %d,%d\n", i, j);

            if(!((oc + (signed long int)i)->y2 >= (oc + (signed long int)j)->y2))
              (oc + (signed long int)i)->y2 = (oc + (signed long int)j)->y2;

            clip_drop(oc, j, count);
            if(ng_debug >= 2)
              clip_dump("merge y done", oc, *count);

            goto restart_merge;
          }

        }

      }

    }

    if(!((oc + (signed long int)i)->y1 == (oc + (signed long int)j)->y1))
      break;

    if(!((oc + (signed long int)i)->y2 == (oc + (signed long int)j)->y2))
      break;

    if(!((oc + (signed long int)j)->x1 >= (oc + (signed long int)i)->x1))
      break;

    if(!((oc + (signed long int)i)->x2 >= (oc + (signed long int)j)->x1))
      break;

    if(ng_debug >= 2)
      fprintf(stderr, "clip: merge x %d,%d\n", i, j);

    if(!((oc + (signed long int)i)->x2 >= (oc + (signed long int)j)->x2))
      (oc + (signed long int)i)->x2 = (oc + (signed long int)j)->x2;

    clip_drop(oc, j, count);
    if(ng_debug >= 2)
      clip_dump("merge x done", oc, *count);

  }
  while((_Bool)1);
  i = i + 1;
  goto __CPROVER_DUMP_L24;

__CPROVER_DUMP_L33:
  ;
  j = j - 1;
  goto __CPROVER_DUMP_L23;

__CPROVER_DUMP_L34:
  ;
  if(!(ng_debug == 0))
    clip_dump("final", oc, *count);

}

// ng_check_magic
// file libng/grab-ng.c line 381
static signed int ng_check_magic(signed int magic, char *plugname, char *type)
{
  if(!(magic == 0x20030129))
  {
    fprintf(stderr, "ERROR: plugin magic mismatch [xawtv=%d,%s=%d]\n", 0x20030129, plugname, magic);
    return -1;
  }

  else
    return 0;
}

// ng_color_packed_init
// file libng/grab-ng.h line 479
void ng_color_packed_init(void)
{
  ng_conv_register(0x20030129, "built-in", conv_list, nconv);
}

// ng_color_yuv2rgb_init
// file libng/grab-ng.h line 480
void ng_color_yuv2rgb_init(void)
{
  signed int i = 0;
  for( ; !(i >= 256); i = i + 1)
  {
    ng_yuv_gray[(signed long int)i] = (unsigned int)(i * 256 >> 8);
    ng_yuv_red[(signed long int)i] = (unsigned int)(-128 * 512 + i * 512 >> 8);
    ng_yuv_blue[(signed long int)i] = (unsigned int)(-128 * 512 + i * 512 >> 8);
    ng_yuv_g1[(signed long int)i] = (unsigned int)(-(-128 * 512) / 2 + i * (-512 / 2) >> 8);
    ng_yuv_g2[(signed long int)i] = (unsigned int)(-(-128 * 512) / 6 + i * (-512 / 6) >> 8);
  }
  i = 0;
  for( ; !(i >= 320); i = i + 1)
    ng_clip[(signed long int)i] = (unsigned int)0;
  for( ; !(i >= 256); i = i + 1)
    ng_clip[(signed long int)i] = (unsigned int)(i - 320);
  for( ; !(i >= 256); i = i + 1)
    ng_clip[(signed long int)i] = (unsigned int)255;
  ng_conv_register(0x20030129, "built-in", conv_list$link1, nconv$link1);
}

// ng_conv_find_from
// file libng/grab-ng.c line 504
struct ng_video_conv * ng_conv_find_from(unsigned int in, signed int *i)
{
  struct list_head *item;
  struct ng_video_conv *ret;
  signed int j = 0;
  item = (&ng_conv)->next;
  for( ; !(item == &ng_conv); item = item->next)
    if(!(j >= *i))
      j = j + 1;

    else
    {
      ret = (struct ng_video_conv *)((char *)item - (signed long int)(unsigned long int)&((struct ng_video_conv *)0)->list);
      if(ret->fmtid_in == in)
      {
        *i = *i + 1;
        return ret;
      }

    }
  return (struct ng_video_conv *)(void *)0;
}

// ng_conv_find_match
// file libng/grab-ng.c line 531
struct ng_video_conv * ng_conv_find_match(unsigned int in, unsigned int out)
{
  struct list_head *item;
  struct ng_video_conv *ret = (struct ng_video_conv *)(void *)0;
  item = (&ng_conv)->next;
  for( ; !(item == &ng_conv); item = item->next)
  {
    ret = (struct ng_video_conv *)((char *)item - (signed long int)(unsigned long int)&((struct ng_video_conv *)0)->list);
    if(ret->fmtid_in == in)
    {
      if(ret->fmtid_out == out)
        return ret;

    }

  }
  return (struct ng_video_conv *)(void *)0;
}

// ng_conv_find_to
// file ./libng/grab-ng.h line 445
struct ng_video_conv * ng_conv_find_to(unsigned int out, signed int *i)
{
  struct list_head *item;
  struct ng_video_conv *ret;
  signed int j = 0;
  item = (&ng_conv)->next;
  for( ; !(item == &ng_conv); item = item->next)
    if(!(j >= *i))
      j = j + 1;

    else
    {
      ret = (struct ng_video_conv *)((char *)item - (signed long int)(unsigned long int)&((struct ng_video_conv *)0)->list);
      if(ret->fmtid_out == out)
      {
        *i = *i + 1;
        return ret;
      }

      *i = *i + 1;
      j = j + 1;
    }
  return (struct ng_video_conv *)(void *)0;
}

// ng_conv_nop_fini
// file libng/color_common.c line 56
void ng_conv_nop_fini(void *handle)
{
  ;
}

// ng_conv_nop_init
// file libng/color_common.c line 49
void * ng_conv_nop_init(struct ng_video_fmt *out, void *priv)
{
  return (void *)0;
}

// ng_conv_register
// file libng/grab-ng.c line 396
signed int ng_conv_register(signed int magic, char *plugname, struct ng_video_conv *list, signed int count)
{
  signed int n;
  signed int return_value_ng_check_magic$1;
  return_value_ng_check_magic$1=ng_check_magic(magic, plugname, "video converters");
  if(!(return_value_ng_check_magic$1 == 0))
    return -1;

  else
  {
    n = 0;
    for( ; !(n >= count); n = n + 1)
      list_add_tail$link1(&(list + (signed long int)n)->list, &ng_conv);
    return 0;
  }
}

// ng_convert_alloc
// file ./libng/grab-ng.h line 373
struct ng_convert_handle * ng_convert_alloc(struct ng_video_conv *conv, struct ng_video_fmt *i, struct ng_video_fmt *o)
{
  struct ng_convert_handle *h;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct ng_convert_handle) /*56ul*/ );
  h = (struct ng_convert_handle *)return_value_malloc$1;
  if(h == ((struct ng_convert_handle *)NULL))
    return ((struct ng_convert_handle *)NULL);

  else
  {
    memset((void *)h, 0, sizeof(struct ng_convert_handle) /*56ul*/ );
    o->width = i->width;
    o->height = i->height;
    if(o->bytesperline == 0u)
      o->bytesperline = (o->width * ng_vfmt_to_depth[(signed long int)o->fmtid]) / (unsigned int)8;

    h->ifmt = *i;
    h->ofmt = *o;
    if(!(conv == ((struct ng_video_conv *)NULL)))
      h->conv = conv;

    return h;
  }
}

// ng_convert_copyframe
// file libng/convert.c line 69
static void ng_convert_copyframe(struct ng_video_buf *dest, struct ng_video_buf *src)
{
  unsigned int i;
  unsigned int sw;
  unsigned int dw;
  unsigned char *sp;
  unsigned char *dp;
  dw = (dest->fmt.width * ng_vfmt_to_depth[(signed long int)dest->fmt.fmtid]) / (unsigned int)8;
  sw = (src->fmt.width * ng_vfmt_to_depth[(signed long int)src->fmt.fmtid]) / (unsigned int)8;
  _Bool tmp_if_expr$1;
  if(src->fmt.bytesperline == sw)
    tmp_if_expr$1 = dest->fmt.bytesperline == dw ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    memcpy((void *)dest->data, (const void *)src->data, (unsigned long int)(src->fmt.bytesperline * src->fmt.height));

  else
  {
    dp = dest->data;
    sp = src->data;
    i = (unsigned int)0;
    for( ; !(i >= src->fmt.height); i = i + 1u)
    {
      memcpy((void *)dp, (const void *)sp, (unsigned long int)dw);
      dp = dp + (signed long int)dest->fmt.bytesperline;
      sp = sp + (signed long int)src->fmt.bytesperline;
    }
  }
}

// ng_convert_fini
// file ./libng/grab-ng.h line 380
void ng_convert_fini(struct ng_convert_handle *h)
{
  if(!(h->conv == ((struct ng_video_conv *)NULL)))
    h->conv->fini(h->chandle);

  free((void *)h);
}

// ng_convert_frame
// file ./libng/grab-ng.h line 377
struct ng_video_buf * ng_convert_frame(struct ng_convert_handle *h, struct ng_video_buf *dest, struct ng_video_buf *buf)
{
  if(buf == ((struct ng_video_buf *)NULL))
    return (struct ng_video_buf *)(void *)0;

  else
  {
    if(dest == ((struct ng_video_buf *)NULL))
    {
      if(!(h->conv == ((struct ng_video_conv *)NULL)))
        dest=ng_malloc_video_buf(&h->ofmt, h->osize);

    }

    if(!(dest == ((struct ng_video_buf *)NULL)))
    {
      dest->fmt = h->ofmt;
      dest->size = (unsigned long int)h->osize;
      if(!(h->conv == ((struct ng_video_conv *)NULL)))
        h->conv->frame(h->chandle, dest, buf);

      else
        ng_convert_copyframe(dest, buf);
      dest->info = buf->info;
      ng_release_video_buf(buf);
      buf = dest;
    }

    return buf;
  }
}

// ng_convert_init
// file ./libng/grab-ng.h line 376
void ng_convert_init(struct ng_convert_handle *h)
{
  if(h->ifmt.bytesperline == 0u)
    h->ifmt.bytesperline = (h->ifmt.width * ng_vfmt_to_depth[(signed long int)h->ifmt.fmtid]) / (unsigned int)8;

  if(h->ofmt.bytesperline == 0u)
    h->ofmt.bytesperline = (h->ofmt.width * ng_vfmt_to_depth[(signed long int)h->ofmt.fmtid]) / (unsigned int)8;

  h->isize = (signed int)(h->ifmt.height * h->ifmt.bytesperline);
  if(h->isize == 0)
    h->isize = (signed int)(h->ifmt.width * h->ifmt.height * (unsigned int)3);

  h->osize = (signed int)(h->ofmt.height * h->ofmt.bytesperline);
  if(h->osize == 0)
    h->osize = (signed int)(h->ofmt.width * h->ofmt.height * (unsigned int)3);

  if(!(h->conv == ((struct ng_video_conv *)NULL)))
    h->chandle=h->conv->init(&h->ofmt, h->conv->priv);

  if(!(ng_debug == 0))
  {
    fprintf(stderr, "convert-in : %dx%d %s (size=%d)\n", h->ifmt.width, h->ifmt.height, ng_vfmt_to_desc[(signed long int)h->ifmt.fmtid], h->isize);
    fprintf(stderr, "convert-out: %dx%d %s (size=%d)\n", h->ofmt.width, h->ofmt.height, ng_vfmt_to_desc[(signed long int)h->ofmt.fmtid], h->osize);
  }

}

// ng_convert_single
// file ./libng/grab-ng.h line 381
struct ng_video_buf * ng_convert_single(struct ng_convert_handle *h, struct ng_video_buf *in)
{
  struct ng_video_buf *out;
  ng_convert_init(h);
  out=ng_convert_frame(h, (struct ng_video_buf *)(void *)0, in);
  ng_convert_fini(h);
  return out;
}

// ng_convert_thread
// file common/capture.c line 132
void * ng_convert_thread(void *arg)
{
  struct ng_convthread_handle *h = (struct ng_convthread_handle *)arg;
  struct ng_video_buf *in;
  struct ng_video_buf *out;
  signed int return_value_getpid$1;
  if(!(debug == 0))
  {
    return_value_getpid$1=getpid();
    fprintf(stderr, "convert_thread start [pid=%d]\n", return_value_getpid$1);
  }

  ng_convert_init(h->c);
  signed int return_value_webcam_put$3;
  do
  {
    void *return_value_fifo_get$2;
    return_value_fifo_get$2=fifo_get(h->in);
    in = (struct ng_video_buf *)return_value_fifo_get$2;
    if(in == ((struct ng_video_buf *)NULL))
      break;

    out=ng_convert_frame(h->c, (struct ng_video_buf *)(void *)0, in);
    if(!(webcam == ((char *)NULL)))
    {
      return_value_webcam_put$3=webcam_put(webcam, out);
      if(return_value_webcam_put$3 == 0)
      {
        free((void *)webcam);
        webcam = (char *)(void *)0;
      }

    }

    fifo_put(h->out, (void *)out);
  }
  while((_Bool)1);
  fifo_put(h->out, (void *)0);
  ng_convert_fini(h->c);
  signed int return_value_getpid$4;
  if(!(debug == 0))
  {
    return_value_getpid$4=getpid();
    fprintf(stderr, "convert_thread done [pid=%d]\n", return_value_getpid$4);
  }

  return (void *)0;
}

// ng_device_init
// file libng/devices.h line 14
void ng_device_init(void)
{
  struct stat st;
  signed int return_value_lstat$1;
  return_value_lstat$1=lstat("/dev/.devfsd", &st);
  if(!(return_value_lstat$1 == -1))
  {
    if((61440u & st.st_mode) == 8192u)
      ng_dev = ng_dev_devfs;

  }

}

// ng_dsp_driver_register
// file libng/grab-ng.c line 458
signed int ng_dsp_driver_register(signed int magic, char *plugname, struct ng_dsp_driver *driver)
{
  signed int return_value_ng_check_magic$1;
  return_value_ng_check_magic$1=ng_check_magic(magic, plugname, "dsp drv");
  if(!(return_value_ng_check_magic$1 == 0))
    return -1;

  else
  {
    list_add_tail$link1(&driver->list, &ng_dsp_drivers);
    return 0;
  }
}

// ng_dsp_open
// file ./libng/grab-ng.h line 452
struct ng_dsp_driver * ng_dsp_open(char *device, struct ng_audio_fmt *fmt, signed int record, void **handle)
{
  struct list_head *item;
  struct ng_dsp_driver *ng_dsp_open$$1$$drv;
  item = (&ng_dsp_drivers)->next;
  for( ; !(item == &ng_dsp_drivers); item = item->next)
  {
    ng_dsp_open$$1$$drv = (struct ng_dsp_driver *)((char *)item - (signed long int)(unsigned long int)&((struct ng_dsp_driver *)0)->list);
    if(!(ng_dsp_open$$1$$drv->name == ((const char *)NULL)))
    {
      if(!(record == 0))
      {
        if(ng_dsp_open$$1$$drv->read == ((struct ng_audio_buf * (*)(void *, signed long int))NULL))
          goto __CPROVER_DUMP_L5;

      }

      if(record == 0)
      {
        if(ng_dsp_open$$1$$drv->write == ((struct ng_audio_buf * (*)(void *, struct ng_audio_buf *))NULL))
          goto __CPROVER_DUMP_L5;

      }

      if(!(ng_debug == 0))
        fprintf(stderr, "dsp-open: trying: %s... \n", ng_dsp_open$$1$$drv->name);

      *handle=ng_dsp_open$$1$$drv->open(device, fmt, record);
      if(!(*handle == NULL))
        break;

      if(!(ng_debug == 0))
        fprintf(stderr, "dsp-open: failed: %s\n", ng_dsp_open$$1$$drv->name);

    }


  __CPROVER_DUMP_L5:
    ;
  }
  if(item == &ng_dsp_drivers)
    return (struct ng_dsp_driver *)(void *)0;

  else
  {
    if(!(ng_debug == 0))
      fprintf(stderr, "dsp-open: ok: %s\n", ng_dsp_open$$1$$drv->name);

    return ng_dsp_open$$1$$drv;
  }
}

// ng_filter_register
// file libng/grab-ng.c line 422
signed int ng_filter_register(signed int magic, char *plugname, struct ng_filter *filter)
{
  signed int return_value_ng_check_magic$1;
  return_value_ng_check_magic$1=ng_check_magic(magic, plugname, "filter");
  if(!(return_value_ng_check_magic$1 == 0))
    return -1;

  else
  {
    list_add_tail$link1(&filter->list, &ng_filters);
    return 0;
  }
}

// ng_filter_single
// file ./libng/grab-ng.h line 461
struct ng_video_buf * ng_filter_single(struct ng_filter *filter, struct ng_video_buf *in)
{
  struct ng_video_buf *out = in;
  void *handle;
  if(!(filter == ((struct ng_filter *)NULL)))
  {
    if(!((filter->fmts & 1 << in->fmt.fmtid) == 0))
    {
      handle=filter->init(&in->fmt);
      out=filter->frame(handle, in);
      filter->fini(handle);
    }

  }

  return out;
}

// ng_find_reader
// file libng/grab-ng.c line 763
struct ng_reader * ng_find_reader(char *filename)
{
  struct list_head *item;
  struct ng_reader *reader;
  char blk[512l];
  struct _IO_FILE *fp;
  signed int m;
  fp=fopen(filename, "r");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    fprintf(stderr, "open %s: %s\n", filename, return_value_strerror$2);
    return (struct ng_reader *)(void *)0;
  }

  memset((void *)blk, 0, sizeof(char [512l]) /*512ul*/ );
  fread((void *)blk, (unsigned long int)1, sizeof(char [512l]) /*512ul*/ , fp);
  fclose(fp);
  item = (&ng_readers)->next;
  _Bool tmp_if_expr$3;
  for( ; !(item == &ng_readers); item = item->next)
  {
    reader = (struct ng_reader *)((char *)item - (signed long int)(unsigned long int)&((struct ng_reader *)0)->list);
    m = 0;
    do
    {
      if(!(m >= 4))
        tmp_if_expr$3 = reader->mlen[(signed long int)m] > 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      if(!tmp_if_expr$3)
        break;

      signed int return_value_memcmp$4;
      return_value_memcmp$4=memcmp((const void *)(blk + (signed long int)reader->moff[(signed long int)m]), (const void *)reader->magic[(signed long int)m], (unsigned long int)reader->mlen[(signed long int)m]);
      if(return_value_memcmp$4 == 0)
        return reader;

      m = m + 1;
    }
    while((_Bool)1);
  }
  if(!(ng_debug == 0))
    fprintf(stderr, "%s: no reader found\n", filename);

  return (struct ng_reader *)(void *)0;
}

// ng_free_video_buf
// file libng/grab-ng.c line 154
static void ng_free_video_buf(struct ng_video_buf *buf)
{
  free((void *)buf->data);
  free((void *)buf);
}

// ng_get_timestamp
// file ./libng/grab-ng.h line 458
signed long int ng_get_timestamp(void)
{
  struct timeval tv;
  gettimeofday(&tv, (struct timezone *)(void *)0);
  signed long int return_value_ng_tofday_to_timestamp$1;
  return_value_ng_tofday_to_timestamp$1=ng_tofday_to_timestamp(&tv);
  return return_value_ng_tofday_to_timestamp$1;
}

// ng_grabber_findconv
// file common/capture.c line 199
struct ng_video_conv * ng_grabber_findconv(struct ng_video_fmt *fmt, signed int fix_ratio)
{
  struct ng_video_fmt gfmt;
  struct ng_video_conv *conv;
  signed int i = 0;
  do
  {
    conv=ng_conv_find_to(fmt->fmtid, &i);
    if(conv == ((struct ng_video_conv *)NULL))
      break;

    gfmt = *fmt;
    gfmt.fmtid = conv->fmtid_in;
    signed int return_value_ng_grabber_setformat$1;
    return_value_ng_grabber_setformat$1=ng_grabber_setformat(&gfmt, fix_ratio);
    if(return_value_ng_grabber_setformat$1 == 0)
      goto found;

  }
  while((_Bool)1);
  fprintf(stderr, "no way to get: %dx%d %s\n", fmt->width, fmt->height, ng_vfmt_to_desc[(signed long int)fmt->fmtid]);
  return (struct ng_video_conv *)(void *)0;

found:
  ;
  *fmt = gfmt;
  return conv;
}

// ng_grabber_get_image
// file common/capture.h line 24
struct ng_video_buf * ng_grabber_get_image(struct ng_video_fmt *fmt)
{
  struct ng_video_fmt gfmt;
  struct ng_video_conv *conv;
  struct ng_convert_handle *ch;
  struct ng_video_buf *buf;
  signed int return_value_ng_grabber_setformat$2;
  return_value_ng_grabber_setformat$2=ng_grabber_setformat(fmt, 1);
  struct ng_video_buf *return_value_ng_grabber_grab_image$1;
  if(return_value_ng_grabber_setformat$2 == 0)
  {
    return_value_ng_grabber_grab_image$1=ng_grabber_grab_image(1);
    return return_value_ng_grabber_grab_image$1;
  }

  gfmt = *fmt;
  conv=ng_grabber_findconv(&gfmt, 1);
  if(conv == ((struct ng_video_conv *)NULL))
    return (struct ng_video_buf *)(void *)0;

  else
  {
    ch=ng_convert_alloc(conv, &gfmt, fmt);
    buf=ng_grabber_grab_image(1);
    if(buf == ((struct ng_video_buf *)NULL))
      return (struct ng_video_buf *)(void *)0;

    else
    {
      buf=ng_convert_single(ch, buf);
      return buf;
    }
  }
}

// ng_grabber_grab_image
// file common/capture.c line 226
struct ng_video_buf * ng_grabber_grab_image(signed int single)
{
  struct ng_video_buf *tmp_if_expr$1;
  struct ng_video_buf *return_value;
  struct ng_video_buf *return_value_1;
  if(!(single == 0))
  {
    return_value=drv->getimage(h_drv);
    tmp_if_expr$1 = return_value;
  }

  else
  {
    return_value_1=drv->nextframe(h_drv);
    tmp_if_expr$1 = return_value_1;
  }
  return tmp_if_expr$1;
}

// ng_grabber_setformat
// file common/capture.c line 163
signed int ng_grabber_setformat(struct ng_video_fmt *fmt, signed int fix_ratio)
{
  struct ng_video_fmt gfmt;
  signed int rc;
  if((2 & f_drv) == 0)
    return -1;

  else
  {
    gfmt = *fmt;
    rc=drv->setformat(h_drv, &gfmt);
    if(!(debug == 0))
      fprintf(stderr, "setformat: %s (%dx%d): %s\n", ng_vfmt_to_desc[(signed long int)gfmt.fmtid], gfmt.width, gfmt.height, 0 == rc ? "ok" : "failed");

    if(!(rc == 0))
      return -1;

    else
    {
      if(!(fix_ratio == 0))
      {
        ng_ratio_fixup((signed int *)&gfmt.width, (signed int *)&gfmt.height, (signed int *)(void *)0, (signed int *)(void *)0);
        gfmt.bytesperline = (unsigned int)0;
        signed int return_value;
        return_value=drv->setformat(h_drv, &gfmt);
        if(!(return_value == 0))
        {
          fprintf(stderr, "Oops: ratio size renegotiation failed\n");
          exit(1);
        }

      }

      *fmt = gfmt;
      return 0;
    }
  }
}

// ng_init
// file libng/grab-ng.c line 975
void ng_init(void)
{
  signed int ng_init$$1$$count = 0;
  static signed int once = 0;
  signed int tmp_post$1 = once;
  once = once + 1;
  if(!(tmp_post$1 == 0))
  {
    fprintf(stderr, "panic: ng_init called twice\n");
    exit(1);
  }

  ng_device_init();
  ng_color_packed_init();
  ng_color_yuv2rgb_init();
  ng_writefile_init();
  signed int return_value_ng_plugins$2;
  return_value_ng_plugins$2=ng_plugins("/usr/lib/x86_64-linux-gnu/xawtv");
  ng_init$$1$$count = ng_init$$1$$count + return_value_ng_plugins$2;
  if(ng_init$$1$$count == 0)
  {
    signed int return_value_ng_plugins$3;
    return_value_ng_plugins$3=ng_plugins("../libng/plugins");
    ng_init$$1$$count = ng_init$$1$$count + return_value_ng_plugins$3;
    signed int return_value_ng_plugins$4;
    return_value_ng_plugins$4=ng_plugins("../libng/contrib-plugins");
    ng_init$$1$$count = ng_init$$1$$count + return_value_ng_plugins$4;
  }

  if(ng_init$$1$$count == 0)
    fprintf(stderr, "WARNING: no plugins found [%s]\n", (const void *)"/usr/lib/x86_64-linux-gnu/xawtv");

}

// ng_init_video_buf
// file libng/grab-ng.c line 122
void ng_init_video_buf(struct ng_video_buf *buf)
{
  memset((void *)buf, 0, sizeof(struct ng_video_buf) /*160ul*/ );
  pthread_mutex_init(&buf->lock, (const union anonymous$86 *)(void *)0);
  pthread_cond_init(&buf->cond, (const union anonymous$86 *)(void *)0);
}

// ng_lut_init
// file libng/color_lut.c line 241
void ng_lut_init(unsigned long int red_mask, unsigned long int green_mask, unsigned long int blue_mask, unsigned int fmtid, signed int swap)
{
  signed int rgb_red_bits = 0;
  signed int rgb_red_shift = 0;
  signed int rgb_green_bits = 0;
  signed int rgb_green_shift = 0;
  signed int rgb_blue_bits = 0;
  signed int rgb_blue_shift = 0;
  unsigned int i;
  unsigned int mask;
  static signed int once = 0;
  signed int tmp_post$1 = once;
  once = once + 1;
  if(!(tmp_post$1 == 0))
  {
    fprintf(stderr, "panic: ng_lut_init called twice\n");
    exit(1);
  }

  i = (unsigned int)0;
  for( ; !(i >= 32u); i = i + 1u)
  {
    mask = (unsigned int)(1 << i);
    if(!((red_mask & (unsigned long int)mask) == 0ul))
      rgb_red_bits = rgb_red_bits + 1;

    else
      if(rgb_red_bits == 0)
        rgb_red_shift = rgb_red_shift + 1;

    if(!((green_mask & (unsigned long int)mask) == 0ul))
      rgb_green_bits = rgb_green_bits + 1;

    else
      if(rgb_green_bits == 0)
        rgb_green_shift = rgb_green_shift + 1;

    if(!((blue_mask & (unsigned long int)mask) == 0ul))
      rgb_blue_bits = rgb_blue_bits + 1;

    else
      if(rgb_blue_bits == 0)
        rgb_blue_shift = rgb_blue_shift + 1;

  }
  if(rgb_red_bits >= 9)
  {
    i = (unsigned int)0;
    for( ; !(i >= 256u); i = i + 1u)
      ng_lut_red[(signed long int)i] = (unsigned long int)(i << (rgb_red_bits + rgb_red_shift) - 8);
  }

  else
  {
    i = (unsigned int)0;
    for( ; !(i >= 256u); i = i + 1u)
      ng_lut_red[(signed long int)i] = (unsigned long int)((i >> 8 - rgb_red_bits) << rgb_red_shift);
  }
  if(rgb_green_bits >= 9)
  {
    i = (unsigned int)0;
    for( ; !(i >= 256u); i = i + 1u)
      ng_lut_green[(signed long int)i] = (unsigned long int)(i << (rgb_green_bits + rgb_green_shift) - 8);
  }

  else
  {
    i = (unsigned int)0;
    for( ; !(i >= 256u); i = i + 1u)
      ng_lut_green[(signed long int)i] = (unsigned long int)((i >> 8 - rgb_green_bits) << rgb_green_shift);
  }
  if(rgb_blue_bits >= 9)
  {
    i = (unsigned int)0;
    for( ; !(i >= 256u); i = i + 1u)
      ng_lut_blue[(signed long int)i] = (unsigned long int)(i << (rgb_blue_bits + rgb_blue_shift) - 8);
  }

  else
  {
    i = (unsigned int)0;
    for( ; !(i >= 256u); i = i + 1u)
      ng_lut_blue[(signed long int)i] = (unsigned long int)((i >> 8 - rgb_blue_bits) << rgb_blue_shift);
  }
  switch(ng_vfmt_to_depth[(signed long int)fmtid])
  {
    case (const unsigned int)16:
    {
      if(!(swap == 0))
      {
        i = (unsigned int)0;
        for( ; !(i >= 256u); i = i + 1u)
        {
          ng_lut_red[(signed long int)i] = ng_lut_red[(signed long int)i] >> 8 & (unsigned long int)0x00ff | ng_lut_red[(signed long int)i] << 8 & (unsigned long int)0xff00;
          ng_lut_green[(signed long int)i] = ng_lut_green[(signed long int)i] >> 8 & (unsigned long int)0x00ff | ng_lut_green[(signed long int)i] << 8 & (unsigned long int)0xff00;
          ng_lut_blue[(signed long int)i] = ng_lut_blue[(signed long int)i] >> 8 & (unsigned long int)0x00ff | ng_lut_blue[(signed long int)i] << 8 & (unsigned long int)0xff00;
        }
      }

      i = (unsigned int)0;
      for( ; !(i >= nconv2); i = i + 1u)
        lut2_list[(signed long int)i].fmtid_out = fmtid;
      ng_conv_register(0x20030129, "built-in", lut2_list, (signed int)nconv2);
      break;
    }
    case (const unsigned int)32:
    {
      if(!(swap == 0))
      {
        i = (unsigned int)0;
        for( ; !(i >= 256u); i = i + 1u)
        {
          ng_lut_red[(signed long int)i] = ng_lut_red[(signed long int)i] >> 24 & (unsigned long int)0x000000ff | ng_lut_red[(signed long int)i] >> 8 & (unsigned long int)0x0000ff00 | ng_lut_red[(signed long int)i] << 8 & (unsigned long int)0x00ff0000 | ng_lut_red[(signed long int)i] << 24 & (unsigned long int)0xff000000;
          ng_lut_green[(signed long int)i] = ng_lut_green[(signed long int)i] >> 24 & (unsigned long int)0x000000ff | ng_lut_green[(signed long int)i] >> 8 & (unsigned long int)0x0000ff00 | ng_lut_green[(signed long int)i] << 8 & (unsigned long int)0x00ff0000 | ng_lut_green[(signed long int)i] << 24 & (unsigned long int)0xff000000;
          ng_lut_blue[(signed long int)i] = ng_lut_blue[(signed long int)i] >> 24 & (unsigned long int)0x000000ff | ng_lut_blue[(signed long int)i] >> 8 & (unsigned long int)0x0000ff00 | ng_lut_blue[(signed long int)i] << 8 & (unsigned long int)0x00ff0000 | ng_lut_blue[(signed long int)i] << 24 & (unsigned long int)0xff000000;
        }
      }

      i = (unsigned int)0;
      for( ; !(i >= nconv4); i = i + 1u)
        lut4_list[(signed long int)i].fmtid_out = fmtid;
      ng_conv_register(0x20030129, "built-in", lut4_list, (signed int)nconv4);
    }
  }
}

// ng_malloc_audio_buf
// file libng/grab-ng.c line 184
struct ng_audio_buf * ng_malloc_audio_buf(struct ng_audio_fmt *fmt, signed int size)
{
  struct ng_audio_buf *buf;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct ng_audio_buf) /*32ul*/  + (unsigned long int)size);
  buf = (struct ng_audio_buf *)return_value_malloc$1;
  memset((void *)buf, 0, sizeof(struct ng_audio_buf) /*32ul*/ );
  buf->fmt = *fmt;
  buf->size = size;
  buf->data = (char *)buf + (signed long int)sizeof(struct ng_audio_buf) /*32ul*/ ;
  return buf;
}

// ng_malloc_video_buf
// file libng/grab-ng.c line 161
struct ng_video_buf * ng_malloc_video_buf(struct ng_video_fmt *fmt, signed int size)
{
  struct ng_video_buf *buf;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct ng_video_buf) /*160ul*/ );
  buf = (struct ng_video_buf *)return_value_malloc$1;
  if(buf == ((struct ng_video_buf *)NULL))
    return (struct ng_video_buf *)(void *)0;

  else
  {
    ng_init_video_buf(buf);
    buf->fmt = *fmt;
    buf->size = (unsigned long int)size;
    void *return_value_malloc$2;
    return_value_malloc$2=malloc((unsigned long int)size);
    buf->data = (unsigned char *)return_value_malloc$2;
    if(buf->data == ((unsigned char *)NULL))
    {
      free((void *)buf);
      return (struct ng_video_buf *)(void *)0;
    }

    else
    {
      buf->refcount = 1;
      buf->release = ng_free_video_buf;
      return buf;
    }
  }
}

// ng_mix_driver_register
// file libng/grab-ng.c line 467
signed int ng_mix_driver_register(signed int magic, char *plugname, struct ng_mix_driver *driver)
{
  signed int return_value_ng_check_magic$1;
  return_value_ng_check_magic$1=ng_check_magic(magic, plugname, "mixer drv");
  if(!(return_value_ng_check_magic$1 == 0))
    return -1;

  else
  {
    list_add_tail$link1(&driver->list, &ng_mix_drivers);
    return 0;
  }
}

// ng_mix_init
// file libng/grab-ng.c line 738
struct ng_attribute * ng_mix_init(char *device, char *channel)
{
  struct list_head *item;
  struct ng_mix_driver *ng_mix_init$$1$$drv = (struct ng_mix_driver *)(void *)0;
  struct ng_attribute *ng_mix_init$$1$$attrs = (struct ng_attribute *)(void *)0;
  void *handle;
  item = (&ng_mix_drivers)->next;
  if(!(item == &ng_mix_drivers))
  {
    ng_mix_init$$1$$drv = (struct ng_mix_driver *)((char *)item - (signed long int)(unsigned long int)&((struct ng_mix_driver *)0)->list);
    if(!(ng_debug == 0))
      fprintf(stderr, "mix-init: trying: %s... \n", ng_mix_init$$1$$drv->name);

    handle=ng_mix_init$$1$$drv->open(device);
    if(!(handle == NULL))
    {
      ng_mix_init$$1$$attrs=ng_mix_init$$1$$drv->volctl(handle, channel);
      ng_mix_init$$1$$drv->close(handle);
    }

    if(!(ng_debug == 0))
      fprintf(stderr, "mix-init: failed: %s\n", ng_mix_init$$1$$drv->name);

    item = item->next;
  }

  if(!(ng_mix_init$$1$$attrs == ((struct ng_attribute *)NULL)) && !(ng_debug == 0))
    fprintf(stderr, "mix-init: ok: %s\n", ng_mix_init$$1$$drv->name);

  return ng_mix_init$$1$$attrs;
}

// ng_packed_frame
// file libng/color_common.c line 22
void ng_packed_frame(void *handle, struct ng_video_buf *out, struct ng_video_buf *in)
{
  signed int (*func)(unsigned char *, unsigned char *, signed int) = (signed int (*)(unsigned char *, unsigned char *, signed int))handle;
  unsigned char *sp;
  unsigned char *dp;
  unsigned int i;
  unsigned int sw;
  unsigned int dw = out->fmt.width * ng_vfmt_to_depth[(signed long int)out->fmt.fmtid] >> 3;
  sw = in->fmt.width * ng_vfmt_to_depth[(signed long int)in->fmt.fmtid] >> 3;
  _Bool tmp_if_expr$1;
  if(in->fmt.bytesperline == sw)
    tmp_if_expr$1 = out->fmt.bytesperline == dw ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  if(tmp_if_expr$1)
    func(out->data, in->data, (signed int)(in->fmt.width * in->fmt.height));

  else
  {
    dp = out->data;
    sp = in->data;
    i = (unsigned int)0;
    if(!(i >= in->fmt.height))
    {
      func(dp, sp, (signed int)in->fmt.width);
      dp = dp + (signed long int)out->fmt.bytesperline;
      sp = sp + (signed long int)in->fmt.bytesperline;
      i = i + 1u;
    }

  }
}

// ng_packed_init
// file libng/color_common.c line 16
void * ng_packed_init(struct ng_video_fmt *out, void *priv)
{
  return priv;
}

// ng_plugins
// file libng/grab-ng.c line 940
static signed int ng_plugins(char *dirname)
{
  struct dirent **list;
  char filename[1024l];
  void *plugin;
  void (*initcall)(void);
  signed int i;
  signed int n = 0;
  signed int l = 0;
  n=scandir(dirname, &list, (signed int (*)(struct dirent *))(void *)0, alphasort);
  if(!(n >= 1))
    return 0;

  else
  {
    i = 0;
    for( ; !(i >= n); i = i + 1)
    {
      signed int return_value_fnmatch$1;
      return_value_fnmatch$1=fnmatch("*.so", list[(signed long int)i]->d_name, 0);
      if(return_value_fnmatch$1 == 0)
      {
        sprintf(filename, "%s/%s", dirname, (const void *)list[(signed long int)i]->d_name);
        plugin=dlopen(filename, 0x00002);
        if(plugin == NULL)
        {
          char *return_value_dlerror$2;
          return_value_dlerror$2=dlerror();
          fprintf(stderr, "dlopen: %s\n", return_value_dlerror$2);
          goto __CPROVER_DUMP_L6;
        }

        void *return_value_dlsym$5;
        return_value_dlsym$5=dlsym(plugin, "ng_plugin_init");
        initcall = (void (*)(void))return_value_dlsym$5;
        if(initcall == ((void (*)(void))NULL))
        {
          void *return_value_dlsym$4;
          return_value_dlsym$4=dlsym(plugin, "_ng_plugin_init");
          initcall = (void (*)(void))return_value_dlsym$4;
          if(initcall == ((void (*)(void))NULL))
          {
            char *return_value_dlerror$3;
            return_value_dlerror$3=dlerror();
            fprintf(stderr, "dlsym[%s]: %s\n", (const void *)filename, return_value_dlerror$3);
            goto __CPROVER_DUMP_L6;
          }

        }

        initcall();
        l = l - 1;
      }


    __CPROVER_DUMP_L6:
      ;
    }
    i = 0;
    for( ; !(i >= n); i = i + 1)
      free((void *)list[(signed long int)i]);
    free((void *)list);
    return l;
  }
}

// ng_ratio_fixup
// file ./libng/grab-ng.h line 268
void ng_ratio_fixup(signed int *width, signed int *height, signed int *xoff, signed int *yoff)
{
  signed int h = *height;
  signed int w = *width;
  if(!(ng_ratio_x == 0) && !(ng_ratio_y == 0))
  {
    if(!(w * ng_ratio_y >= h * ng_ratio_x))
    {
      *height = (*width * ng_ratio_y) / ng_ratio_x;
      if(!(yoff == ((signed int *)NULL)))
        *yoff = *yoff + (h - *height) / 2;

    }

    else
      if(!(h * ng_ratio_x >= w * ng_ratio_y))
      {
        *width = (*height * ng_ratio_x) / ng_ratio_y;
        if(!(yoff == ((signed int *)NULL)))
          *xoff = *xoff + (w - *width) / 2;

      }

  }

}

// ng_ratio_fixup2
// file libng/grab-ng.c line 349
void ng_ratio_fixup2(signed int *width, signed int *height, signed int *xoff, signed int *yoff, signed int ratio_x, signed int ratio_y, signed int up)
{
  signed int h = *height;
  signed int w = *width;
  if(!(ratio_x == 0) && !(ratio_y == 0))
  {
    if(up == 0 && !(w * ratio_y >= h * ratio_x) || !(up == 0) && !(h * ratio_x >= w * ratio_y))
    {
      *height = (*width * ratio_y) / ratio_x;
      if(!(yoff == ((signed int *)NULL)))
        *yoff = *yoff + (h - *height) / 2;

    }

    else
      if(up == 0 && !(h * ratio_x >= w * ratio_y) || !(up == 0) && !(w * ratio_y >= h * ratio_x))
      {
        *width = (*height * ratio_x) / ratio_y;
        if(!(yoff == ((signed int *)NULL)))
          *xoff = *xoff + (w - *width) / 2;

      }

  }

}

// ng_reader_register
// file libng/grab-ng.c line 440
signed int ng_reader_register(signed int magic, char *plugname, struct ng_reader *reader)
{
  signed int return_value_ng_check_magic$1;
  return_value_ng_check_magic$1=ng_check_magic(magic, plugname, "reader");
  if(!(return_value_ng_check_magic$1 == 0))
    return -1;

  else
  {
    list_add_tail$link1(&reader->list, &ng_readers);
    return 0;
  }
}

// ng_release_video_buf
// file ./libng/grab-ng.h line 162
void ng_release_video_buf(struct ng_video_buf *buf)
{
  signed int release;
  pthread_mutex_lock(&buf->lock);
  buf->refcount = buf->refcount - 1;
  release = (signed int)(buf->refcount == 0);
  pthread_mutex_unlock(&buf->lock);
  if(!(release == 0))
  {
    if(!(buf->release == ((void (*)(struct ng_video_buf *))NULL)))
      buf->release(buf);

  }

}

// ng_rgb24_to_lut2
// file libng/color_lut.c line 30
void ng_rgb24_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned short int * restrict d = (unsigned short int *)dest;
  signed int tmp_post$1;
  do
  {
    tmp_post$1 = p;
    p = p - 1;
    if(!(tmp_post$1 >= 1))
      break;

    unsigned short int * restrict tmp_post$2 = d;
    d = d + 1l;
    *tmp_post$2 = (unsigned short int)(ng_lut_red[(signed long int)src[(signed long int)0]] | ng_lut_green[(signed long int)src[(signed long int)1]] | ng_lut_blue[(signed long int)src[(signed long int)2]]);
    src = src + (signed long int)3;
  }
  while((_Bool)1);
}

// ng_rgb24_to_lut4
// file libng/color_lut.c line 96
void ng_rgb24_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned int * restrict d = (unsigned int *)dest;
  signed int tmp_post$1;
  do
  {
    tmp_post$1 = p;
    p = p - 1;
    if(!(tmp_post$1 >= 1))
      break;

    unsigned int * restrict tmp_post$2 = d;
    d = d + 1l;
    *tmp_post$2 = (unsigned int)(ng_lut_red[(signed long int)src[(signed long int)0]] | ng_lut_green[(signed long int)src[(signed long int)1]] | ng_lut_blue[(signed long int)src[(signed long int)2]]);
    src = src + (signed long int)3;
  }
  while((_Bool)1);
}

// ng_tofday_to_timestamp
// file libng/grab-ng.c line 793
signed long int ng_tofday_to_timestamp(struct timeval *tv)
{
  signed long long int ts = tv->tv_sec;
  ts = ts * (signed long long int)1000000;
  ts = ts + tv->tv_usec;
  ts = ts * (signed long long int)1000;
  return ts;
}

// ng_vid_driver_register
// file libng/grab-ng.c line 449
signed int ng_vid_driver_register(signed int magic, char *plugname, struct ng_vid_driver *driver)
{
  signed int return_value_ng_check_magic$1;
  return_value_ng_check_magic$1=ng_check_magic(magic, plugname, "video drv");
  if(!(return_value_ng_check_magic$1 == 0))
    return -1;

  else
  {
    list_add_tail$link1(&driver->list, &ng_vid_drivers);
    return 0;
  }
}

// ng_vid_open
// file libng/grab-ng.c line 616
struct ng_vid_driver * ng_vid_open(char **device, char *driver, struct ng_video_fmt *screen, void *base, void **handle)
{
  struct list_head *item;
  struct ng_vid_driver *ng_vid_open$$1$$drv;
  signed int return_value_strcmp$5;
  signed int return_value;
  if(driver == ((char *)NULL))
  {
    fprintf(stderr, "Video4linux driver is not specified\n");
    return (struct ng_vid_driver *)(void *)0;
  }

  else
  {
    item = (&ng_vid_drivers)->next;
    for( ; !(item == &ng_vid_drivers); item = item->next)
    {
      ng_vid_open$$1$$drv = (struct ng_vid_driver *)((char *)item - (signed long int)(unsigned long int)&((struct ng_vid_driver *)0)->list);
      signed int return_value_strcasecmp$1;
      return_value_strcasecmp$1=strcasecmp(driver, ng_vid_open$$1$$drv->name);
      if(return_value_strcasecmp$1 == 0)
        break;

    }
    if(item == &ng_vid_drivers)
    {
      signed int return_value_strcasecmp$2;
      return_value_strcasecmp$2=strcasecmp(driver, "help");
      if(!(return_value_strcasecmp$2 == 0))
        fprintf(stderr, "Cannot find %s video driver\n", driver);

      fprintf(stderr, "Available drivers:");
      item = (&ng_vid_drivers)->next;
      for( ; !(item == &ng_vid_drivers); item = item->next)
      {
        ng_vid_open$$1$$drv = (struct ng_vid_driver *)((char *)item - (signed long int)(unsigned long int)&((struct ng_vid_driver *)0)->list);
        fprintf(stderr, " %s", ng_vid_open$$1$$drv->name);
      }
      fprintf(stderr, "\n");
      return (struct ng_vid_driver *)(void *)0;
    }

    signed int return_value_strcmp$4;
    return_value_strcmp$4=strcmp(*device, "auto");
    _Bool tmp_if_expr$6;
    if(return_value_strcmp$4 == 0)
      tmp_if_expr$6 = (_Bool)1;

    else
    {
      return_value_strcmp$5=strcmp(*device, "auto_tv");
      tmp_if_expr$6 = !(return_value_strcmp$5 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$6)
    {
      char devpath[4096l];
      signed int return_value_strcmp$3;
      return_value_strcmp$3=strcmp(*device, "auto_tv");
      *handle=ng_vid_open_auto(ng_vid_open$$1$$drv, devpath, !(return_value_strcmp$3 != 0) ? 0 : 1);
      if(*handle == NULL)
      {
        fprintf(stderr, "vid-open: could not find a suitable videodev\n");
        return (struct ng_vid_driver *)(void *)0;
      }

      *device=strdup(devpath);
    }

    else
    {
      if(!(ng_debug == 0))
        fprintf(stderr, "vid-open: trying: %s... \n", ng_vid_open$$1$$drv->name);

      *handle=ng_vid_open$$1$$drv->open(*device, 0);
      if(*handle == NULL)
      {
        fprintf(stderr, "vid-open: failed: %s\n", ng_vid_open$$1$$drv->name);
        return (struct ng_vid_driver *)(void *)0;
      }

      if(!(ng_debug == 0))
        fprintf(stderr, "vid-open: ok: %s\n", ng_vid_open$$1$$drv->name);

    }
    if(!(screen == ((struct ng_video_fmt *)NULL)))
    {
      return_value=ng_vid_open$$1$$drv->capabilities(*handle);
      if(!((1 & return_value) == 0))
      {
        signed int l;
        unsigned long int return_value_strlen$7;
        return_value_strlen$7=strlen(ng_v4l_conf);
        l = (signed int)return_value_strlen$7;
        snprintf(ng_v4l_conf + (signed long int)l, sizeof(char [256l]) /*256ul*/  - (unsigned long int)l, " -c %s", *device);
        if(!(ng_debug == 0))
          fprintf(stderr, "vid-open: closing dev to run v4lconf\n");

        ng_vid_open$$1$$drv->close(*handle);
        signed int return_value_system$8;
        return_value_system$8=system(ng_v4l_conf);
        if(return_value_system$8 == -1)
          fprintf(stderr, "could'nt start v4l-conf\n");

        fprintf(stderr, "v4l-conf had some trouble, trying to continue anyway\n");
        if(!(ng_debug == 0))
          fprintf(stderr, "vid-open: re-opening dev after v4lconf\n");

        *handle=ng_vid_open$$1$$drv->open(*device, 0);
        if(*handle == NULL)
        {
          fprintf(stderr, "vid-open: failed: %s\n", ng_vid_open$$1$$drv->name);
          return (struct ng_vid_driver *)(void *)0;
        }

        if(!(ng_debug == 0))
          fprintf(stderr, "vid-open: re-open ok\n");

        ng_vid_open$$1$$drv->setupfb(*handle, screen, base);
      }

    }

    return ng_vid_open$$1$$drv;
  }
}

// ng_vid_open_auto
// file libng/grab-ng.c line 547
static void * ng_vid_open_auto(struct ng_vid_driver *drv, char *devpath, signed int allow_grabber)
{
  void *md;
  void *handle = (void *)0;
  const char *device = (const char *)(void *)0;
  const char *scan_type = "an analog TV";
  *devpath = (char)0;
  md=discover_media_devices();
  if(!(md == NULL))
  {
    device=get_associated_device(md, device, (const enum device_type)MEDIA_V4L_VIDEO, (const char *)(void *)0, (const enum device_type)NONE);
    if(!(device == ((const char *)NULL)))
    {
      snprintf(devpath, (unsigned long int)4096, "/dev/%s", device);
      if(!(ng_debug == 0))
        fprintf(stderr, "vid-open-auto: trying: %s... \n", devpath);

      handle=drv->open(devpath, 2 | 4);
      if(!(handle == NULL))
        fprintf(stderr, "vid-open-auto: using analog TV device %s\n", devpath);

    }

    if(handle == NULL)
    {
      if(allow_grabber == 0)
        goto error;

      scan_type = "a capture";
      device = (const char *)(void *)0;
      device=get_associated_device(md, device, (const enum device_type)MEDIA_V4L_VIDEO, (const char *)(void *)0, (const enum device_type)NONE);
      if(!(device == ((const char *)NULL)))
      {
        snprintf(devpath, (unsigned long int)4096, "/dev/%s", device);
        if(!(ng_debug == 0))
          fprintf(stderr, "vid-open-auto: trying: %s... \n", devpath);

        handle=drv->open(devpath, 2);
        if(!(handle == NULL))
          fprintf(stderr, "vid-open-auto: using grabber/webcam device %s\n", devpath);

      }

    }

    free_media_devices(md);
  }


error:
  ;
  if(handle == NULL)
  {
    fprintf(stderr, "vid-open-auto: failed to open %s device", scan_type);
    if(!(*devpath == 0))
      fprintf(stderr, " at %s\n", devpath);

    else
      fprintf(stderr, "\n");
    return (void *)0;
  }

  else
  {
    if(!(handle == NULL) && !(ng_debug == 0))
      fprintf(stderr, "vid-open-auto: success, using: %s\n", devpath);

    return handle;
  }
}

// ng_waiton_video_buf
// file libng/grab-ng.c line 146
void ng_waiton_video_buf(struct ng_video_buf *buf)
{
  pthread_mutex_lock(&buf->lock);
  while(!(buf->refcount == 0))
    pthread_cond_wait(&buf->cond, &buf->lock);
  pthread_mutex_unlock(&buf->lock);
}

// ng_wakeup_video_buf
// file libng/grab-ng.c line 141
void ng_wakeup_video_buf(struct ng_video_buf *buf)
{
  pthread_cond_signal(&buf->cond);
}

// ng_writefile_init
// file libng/grab-ng.h line 481
void ng_writefile_init(void)
{
  ng_writer_register(0x20030129, "built-in", &files_writer);
  ng_writer_register(0x20030129, "built-in", &raw_writer);
}

// ng_writer_register
// file libng/grab-ng.c line 431
signed int ng_writer_register(signed int magic, char *plugname, struct ng_writer *writer)
{
  signed int return_value_ng_check_magic$1;
  return_value_ng_check_magic$1=ng_check_magic(magic, plugname, "writer");
  if(!(return_value_ng_check_magic$1 == 0))
    return -1;

  else
  {
    list_add_tail$link1(&writer->list, &ng_writers);
    return 0;
  }
}

// ng_yuv420p_to_lut2
// file libng/grab-ng.h line 489
void ng_yuv420p_to_lut2(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict u;
  unsigned char * restrict v;
  unsigned char *us;
  unsigned char *vs;
  unsigned char *dp;
  unsigned short int * restrict d;
  unsigned int i;
  unsigned int j;
  signed int gray;
  dp = out->data;
  y = in->data;
  u = y + (signed long int)(in->fmt.width * in->fmt.height);
  v = u + (signed long int)((in->fmt.width * in->fmt.height) / (unsigned int)4);
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = (unsigned short int *)dp;
    us = u;
    vs = v;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + (unsigned int)2)
    {
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned short int * restrict tmp_post$1 = d;
      d = d + 1l;
      *tmp_post$1 = (unsigned short int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned short int * restrict tmp_post$2 = d;
      d = d + 1l;
      *tmp_post$2 = (unsigned short int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      u = u + 1l;
      v = v + 1l;
    }
    if(i % 2u == 0u)
    {
      u = us;
      v = vs;
    }

    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

// ng_yuv420p_to_lut4
// file libng/grab-ng.h line 491
void ng_yuv420p_to_lut4(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict u;
  unsigned char * restrict v;
  unsigned char *us;
  unsigned char *vs;
  unsigned char *dp;
  unsigned int * restrict d;
  unsigned int i;
  unsigned int j;
  signed int gray;
  dp = out->data;
  y = in->data;
  u = y + (signed long int)(in->fmt.width * in->fmt.height);
  v = u + (signed long int)((in->fmt.width * in->fmt.height) / (unsigned int)4);
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = (unsigned int *)dp;
    us = u;
    vs = v;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + (unsigned int)2)
    {
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned int * restrict tmp_post$1 = d;
      d = d + 1l;
      *tmp_post$1 = (unsigned int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned int * restrict tmp_post$2 = d;
      d = d + 1l;
      *tmp_post$2 = (unsigned int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      u = u + 1l;
      v = v + 1l;
    }
    if(i % 2u == 0u)
    {
      u = us;
      v = vs;
    }

    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

// ng_yuv422_to_lut2
// file libng/grab-ng.h line 487
void ng_yuv422_to_lut2(unsigned char * restrict dest, unsigned char * restrict s, signed int p)
{
  unsigned short int * restrict d = (unsigned short int *)dest;
  signed int gray;
  for( ; !(p == 0); p = p - 2)
  {
    gray = (signed int)ng_yuv_gray[(signed long int)s[(signed long int)0]];
    unsigned short int * restrict tmp_post$1 = d;
    d = d + 1l;
    *tmp_post$1 = (unsigned short int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)s[(signed long int)3]])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)s[(signed long int)3]] + ng_yuv_g2[(signed long int)s[(signed long int)1]])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)s[(signed long int)1]])]]);
    gray = (signed int)ng_yuv_gray[(signed long int)s[(signed long int)2]];
    unsigned short int * restrict tmp_post$2 = d;
    d = d + 1l;
    *tmp_post$2 = (unsigned short int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)s[(signed long int)3]])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)s[(signed long int)3]] + ng_yuv_g2[(signed long int)s[(signed long int)1]])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)s[(signed long int)1]])]]);
    s = s + (signed long int)4;
  }
}

// ng_yuv422_to_lut4
// file libng/grab-ng.h line 488
void ng_yuv422_to_lut4(unsigned char * restrict dest, unsigned char * restrict s, signed int p)
{
  unsigned int * restrict d = (unsigned int *)dest;
  signed int gray;
  for( ; !(p == 0); p = p - 2)
  {
    gray = (signed int)ng_yuv_gray[(signed long int)s[(signed long int)0]];
    unsigned int * restrict tmp_post$1 = d;
    d = d + 1l;
    *tmp_post$1 = (unsigned int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)s[(signed long int)3]])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)s[(signed long int)3]] + ng_yuv_g2[(signed long int)s[(signed long int)1]])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)s[(signed long int)1]])]]);
    gray = (signed int)ng_yuv_gray[(signed long int)s[(signed long int)2]];
    unsigned int * restrict tmp_post$2 = d;
    d = d + 1l;
    *tmp_post$2 = (unsigned int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)s[(signed long int)3]])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)s[(signed long int)3]] + ng_yuv_g2[(signed long int)s[(signed long int)1]])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)s[(signed long int)1]])]]);
    s = s + (signed long int)4;
  }
}

// ng_yuv422p_to_lut2
// file libng/grab-ng.h line 493
void ng_yuv422p_to_lut2(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict u;
  unsigned char * restrict v;
  unsigned char *dp;
  unsigned short int * restrict d;
  unsigned int i;
  unsigned int j;
  signed int gray;
  dp = out->data;
  y = in->data;
  u = y + (signed long int)(in->fmt.width * in->fmt.height);
  v = u + (signed long int)((in->fmt.width * in->fmt.height) / (unsigned int)2);
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = (unsigned short int *)dp;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + (unsigned int)2)
    {
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned short int * restrict tmp_post$1 = d;
      d = d + 1l;
      *tmp_post$1 = (unsigned short int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned short int * restrict tmp_post$2 = d;
      d = d + 1l;
      *tmp_post$2 = (unsigned short int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      u = u + 1l;
      v = v + 1l;
    }
    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

// ng_yuv422p_to_lut4
// file libng/grab-ng.h line 495
void ng_yuv422p_to_lut4(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict u;
  unsigned char * restrict v;
  unsigned char *dp;
  unsigned int * restrict d;
  unsigned int i;
  unsigned int j;
  signed int gray;
  dp = out->data;
  y = in->data;
  u = y + (signed long int)(in->fmt.width * in->fmt.height);
  v = u + (signed long int)((in->fmt.width * in->fmt.height) / (unsigned int)2);
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = (unsigned int *)dp;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + (unsigned int)2)
    {
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned int * restrict tmp_post$1 = d;
      d = d + 1l;
      *tmp_post$1 = (unsigned int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned int * restrict tmp_post$2 = d;
      d = d + 1l;
      *tmp_post$2 = (unsigned int)(ng_lut_red[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])]] | ng_lut_green[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])]] | ng_lut_blue[(signed long int)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])]]);
      y = y + 1l;
      u = u + 1l;
      v = v + 1l;
    }
    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

// odd
// file common/vbi-sim.c line 194
static inline signed int odd(signed int c)
{
  signed int n = c ^ c >> 4;
  n = n ^ n >> 2;
  n = n ^ n >> 1;
  if((1 & n) == 0)
    c = c | 0x80;

  return c;
}

// oss_levels
// file common/sound.c line 13
void oss_levels(struct ng_audio_buf *buf, signed int *left, signed int *right)
{
  signed int lmax;
  signed int rmax;
  signed int i;
  signed int level;
  signed char *s = (signed char *)buf->data;
  unsigned char *u = (unsigned char *)buf->data;
  lmax = 0;
  rmax = 0;
  switch(buf->fmt.fmtid)
  {
    case (unsigned int)1:
    {
      i = 0;
      while(!(i >= buf->size))
      {
        signed int tmp_post$1 = i;
        i = i + 1;
        level=abs((signed int)u[(signed long int)tmp_post$1] - 128);
        if(!(lmax >= level))
        {
          lmax = level;
          rmax = level;
        }

      }
      goto __CPROVER_DUMP_L18;
    }
    case (unsigned int)2:
    {
      i = 0;
      while(!(i >= buf->size))
      {
        signed int tmp_post$2 = i;
        i = i + 1;
        level=abs((signed int)u[(signed long int)tmp_post$2] - 128);
        if(!(lmax >= level))
          lmax = level;

        signed int tmp_post$3 = i;
        i = i + 1;
        level=abs((signed int)u[(signed long int)tmp_post$3] - 128);
        if(!(rmax >= level))
          rmax = level;

      }
      goto __CPROVER_DUMP_L18;
    }
    case (unsigned int)5:

    case (unsigned int)3:
    {
      i = (unsigned int)5 == buf->fmt.fmtid ? 0 : 1;
      while(!(i >= buf->size))
      {
        level=abs((signed int)s[(signed long int)i]);
        i = i + 2;
        if(!(lmax >= level))
        {
          lmax = level;
          rmax = level;
        }

      }
      goto __CPROVER_DUMP_L18;
    }
    case (unsigned int)4:

    case (unsigned int)6:
    {
      i = (unsigned int)6 == buf->fmt.fmtid ? 0 : 1;
      while(!(i >= buf->size))
      {
        level=abs((signed int)s[(signed long int)i]);
        i = i + 2;
        if(!(lmax >= level))
          lmax = level;

        level=abs((signed int)s[(signed long int)i]);
        i = i + 2;
        if(!(rmax >= level))
          rmax = level;

      }
    }
    default:
    {

    __CPROVER_DUMP_L18:
      ;
      *left = lmax;
      *right = rmax;
    }
  }
}

// parse_action
// file common/event.c line 21
static void parse_action(struct event_entry *entry)
{
  char *token;
  char *h;
  strcpy(entry->argbuf, entry->action);
  h = entry->argbuf;

__CPROVER_DUMP_L1:
  ;
  while((_Bool)1)
  {
    if(!((signed int)*h == 32))
    {
      if((signed int)*h == 9)
        goto __CPROVER_DUMP_L2;

    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      h = h + 1l;
      goto __CPROVER_DUMP_L1;
    }
    if((signed int)*h == 0)
      break;

    if((signed int)*h == 34)
    {
      h = h + 1l;
      token = h;
      for( ; !((signed int)*h == 0); h = h + 1l)
        if((signed int)*h == 34)
          break;

    }

    else
    {
      token = h;
      for( ; !((signed int)*h == 0); h = h + 1l)
      {
        if((signed int)*h == 32)
          break;

        if((signed int)*h == 9)
          break;

      }
    }
    if(!((signed int)*h == 0))
    {
      *h = (char)0;
      h = h + 1l;
    }

    signed int tmp_post$1 = entry->argc;
    entry->argc = entry->argc + 1;
    entry->argv[(signed long int)tmp_post$1] = token;
  }
}

// parse_config
// file ./common/channel.h line 77
void parse_config(signed int parse_channels)
{
  char key[16l];
  char cmdline[128l];
  char **list;
  char *val;
  list=cfg_list_entries("launch");
  signed int return_value_sscanf$2;
  if(!(list == ((char **)NULL)))
    for( ; !(*list == ((char *)NULL)); list = list + 1l)
    {
      val=cfg_get_str("launch", *list);
      _Bool tmp_if_expr$3;
      if(!(val == ((char *)NULL)))
      {
        return_value_sscanf$2=sscanf(val, "%15[^,], %127[^\n]", (const void *)key, (const void *)cmdline);
        tmp_if_expr$3 = 2 == return_value_sscanf$2 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$3 = (_Bool)0;
      if(tmp_if_expr$3)
      {
        void *return_value_realloc$1;
        return_value_realloc$1=realloc((void *)launch, sizeof(struct LAUNCH) /*24ul*/  * (unsigned long int)(nlaunch + 1));
        launch = (struct LAUNCH *)return_value_realloc$1;
        (launch + (signed long int)nlaunch)->name=strdup(*list);
        (launch + (signed long int)nlaunch)->key=strdup(key);
        (launch + (signed long int)nlaunch)->cmdline=strdup(cmdline);
        nlaunch = nlaunch + 1;
      }

      else
        fprintf(stderr, "invalid value in section [launch]: %s\n", val);
    }

  event_readconfig();
  if(!(parse_channels == 0))
  {
    init_channel("defaults", &defaults);
    list=cfg_list_sections();
    for( ; !(*list == ((char *)NULL)); list = list + 1l)
    {
      signed int return_value_strcmp$4;
      return_value_strcmp$4=strcmp(*list, "defaults");
      if(!(return_value_strcmp$4 == 0))
      {
        signed int return_value_strcmp$5;
        return_value_strcmp$5=strcmp(*list, "global");
        if(!(return_value_strcmp$5 == 0))
        {
          signed int return_value_strcmp$6;
          return_value_strcmp$6=strcmp(*list, "launch");
          if(!(return_value_strcmp$6 == 0))
          {
            signed int return_value_strcmp$7;
            return_value_strcmp$7=strcmp(*list, "eventmap");
            if(!(return_value_strcmp$7 == 0))
            {
              struct CHANNEL *return_value_add_channel$8;
              return_value_add_channel$8=add_channel(*list);
              init_channel(*list, return_value_add_channel$8);
            }

          }

        }

      }

    }
    defaults.channel=lookup_channel(defaults.cname);
    signed int return_value_get_freq$9;
    return_value_get_freq$9=get_freq(defaults.channel);
    defaults.freq = return_value_get_freq$9 + defaults.fine;
    calc_frequencies();
  }

}

// patch_up
// file libng/writefile.c line 36
signed int patch_up(char *name)
{
  char *ptr;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(name);
  ptr = name + (signed long int)return_value_strlen$1;
  const unsigned short int **return_value___ctype_b_loc$2;
  for( ; ptr >= name; ptr = ptr - 1l)
  {
    return_value___ctype_b_loc$2=__ctype_b_loc();
    if(!((2048 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)*ptr]) == 0))
      break;

  }
  if(!(ptr >= name))
    return 0;

  else
  {
    while((signed int)*ptr == 57)
    {
      if(!(ptr >= name))
        break;

      char *tmp_post$3 = ptr;
      ptr = ptr - 1l;
      *tmp_post$3 = (char)48;
    }
    if(!(ptr >= name))
      return 0;

    else
    {
      const unsigned short int **return_value___ctype_b_loc$4;
      return_value___ctype_b_loc$4=__ctype_b_loc();
      if(!((2048 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)*ptr]) == 0))
      {
        *ptr = *ptr + 1;
        return 1;
      }

      else
        return 0;
    }
  }
}

// print_choices
// file common/commands.c line 753
static void print_choices(char *name, char *value, struct STRTAB *tab)
{
  signed int i;
  fprintf(stderr, "unknown %s: '%s' (available: ", name, value);
  i = 0;
  for( ; !((tab + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
    fprintf(stderr, "%s'%s'", 0 == i ? "" : ", ", (tab + (signed long int)i)->str);
  fprintf(stderr, ")\n");
}

// raw_audio
// file libng/writefile.c line 519
static signed int raw_audio(void *handle, struct ng_audio_buf *buf)
{
  struct raw_handle *h = (struct raw_handle *)handle;
  signed long int return_value_write$1;
  return_value_write$1=write(h->wav_fd, (const void *)buf->data, (unsigned long int)buf->size);
  if(!((signed long int)buf->size == return_value_write$1))
    return -1;

  else
  {
    h->wav_size = h->wav_size + buf->size;
    return 0;
  }
}

// raw_close
// file libng/writefile.c line 529
static signed int raw_close(void *handle)
{
  struct raw_handle *h = (struct raw_handle *)handle;
  if(!(h->audio.fmtid == 0u))
  {
    wav_stop_write(h->wav_fd, &h->wav_header, h->wav_size);
    close(h->wav_fd);
  }

  if(!(h->video.fmtid == 0u))
  {
    if(!(h->fd == 1))
      close(h->fd);

  }

  free((void *)h);
  return 0;
}

// raw_open
// file libng/writefile.c line 408
static void * raw_open(char *videoname, char *audioname, struct ng_video_fmt *video, const void *priv_video, signed int fps, struct ng_audio_fmt *audio, const void *priv_audio)
{
  struct raw_handle *h;
  signed int frame_rate_code = 0;
  signed int frame_rate_mul = fps;
  signed int frame_rate_div = 1000;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct raw_handle) /*88ul*/ );
  h = (struct raw_handle *)return_value_malloc$1;
  if(h == ((struct raw_handle *)NULL))
    return (void *)0;

  else
  {
    memset((void *)h, 0, sizeof(struct raw_handle) /*88ul*/ );
    h->video = *video;
    h->audio = *audio;
    h->vpriv = (struct raw_priv *)priv_video;
    if(!(h->audio.fmtid == 0u))
    {
      h->wav_fd=open(audioname, 0100 | 02 | 01000, 0666);
      if(h->wav_fd == -1)
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        char *return_value_strerror$3;
        return_value_strerror$3=strerror(*return_value___errno_location$2);
        fprintf(stderr, "open %s: %s\n", audioname, return_value_strerror$3);
        free((void *)h);
        return (void *)0;
      }

      wav_start_write(h->wav_fd, &h->wav_header, &h->audio);
    }

    if(!(h->video.fmtid == 0u))
    {
      if(!(h->vpriv == ((struct raw_priv *)NULL)))
      {
        if(!(h->vpriv->yuv4mpeg == 0))
          switch(fps)
          {
            case 23976:
            {
              frame_rate_code = 1;
              frame_rate_mul = 24000;
              frame_rate_div = 1001;
              break;
            }
            case 29970:
            {
              frame_rate_code = 4;
              frame_rate_mul = 30000;
              frame_rate_div = 1001;
              break;
            }
            case 59940:
            {
              frame_rate_code = 7;
              frame_rate_mul = 60000;
              frame_rate_div = 1001;
              break;
            }
            case 24000:
            {
              frame_rate_code = 2;
              break;
            }
            case 25000:
            {
              frame_rate_code = 3;
              break;
            }
            case 30000:
            {
              frame_rate_code = 5;
              break;
            }
            case 50000:
            {
              frame_rate_code = 6;
              break;
            }
            case 60000:
            {
              frame_rate_code = 8;
              break;
            }
            default:
            {
              fprintf(stderr, "illegal frame rate\n");
              free((void *)h);
              return (void *)0;
            }
          }

      }

      if(!(videoname == ((char *)NULL)))
      {
        h->fd=open(videoname, 0100 | 02 | 01000, 0666);
        if(h->fd == -1)
        {
          signed int *return_value___errno_location$4;
          return_value___errno_location$4=__errno_location();
          char *return_value_strerror$5;
          return_value_strerror$5=strerror(*return_value___errno_location$4);
          fprintf(stderr, "open %s: %s\n", videoname, return_value_strerror$5);
          if(!(h->wav_fd == 0))
            close(h->wav_fd);

          free((void *)h);
          return (void *)0;
        }

      }

      else
        h->fd = 1;
      if(!(h->vpriv == ((struct raw_priv *)NULL)))
      {
        if(!(h->vpriv->yuv4mpeg == 0))
        {
          char header[64l];
          switch(h->vpriv->yuv4mpeg)
          {
            case 1:
            {
              sprintf(header, "YUV4MPEG %d %d %d\n", h->video.width, h->video.height, frame_rate_code);
              break;
            }
            case 2:
              sprintf(header, "YUV4MPEG2 W%d H%d F%d:%d\n", h->video.width, h->video.height, frame_rate_mul, frame_rate_div);
          }
          unsigned long int return_value_strlen$6;
          return_value_strlen$6=strlen(header);
          write(h->fd, (const void *)header, return_value_strlen$6);
        }

      }

    }

    return (void *)h;
  }
}

// raw_video
// file libng/writefile.c line 497
static signed int raw_video(void *handle, struct ng_video_buf *buf)
{
  struct raw_handle *h = (struct raw_handle *)handle;
  signed long int return_value_write$1;
  signed long int return_value_write$2;
  if(!(h->vpriv == ((struct raw_priv *)NULL)))
  {
    if(!(h->vpriv->yuv4mpeg == 0))
      switch(h->vpriv->yuv4mpeg)
      {
        case 1:
        {
          return_value_write$1=write(h->fd, (const void *)"FRAME\n", (unsigned long int)6);
          if(!(return_value_write$1 == 6l))
            return -1;

          break;
        }
        case 2:
        {
          return_value_write$2=write(h->fd, (const void *)"FRAME \n", (unsigned long int)7);
          if(!(return_value_write$2 == 7l))
            return -1;

        }
      }

  }

  signed long int return_value_write$3;
  return_value_write$3=write(h->fd, (const void *)buf->data, buf->size);
  if(!(buf->size == (unsigned long int)return_value_write$3))
    return -1;

  else
    return 0;
}

// read_config
// file ./common/channel.h line 76
void read_config(char *conffile, signed int *argc, char **argv)
{
  struct list_head *item;
  char filename[100l];
  char *val;
  signed int i;
  if(!(conffile == ((char *)NULL)))
  {
    signed int return_value_cfg_parse_file$1;
    return_value_cfg_parse_file$1=cfg_parse_file(conffile);
    if(return_value_cfg_parse_file$1 == 0)
      have_config = 1;

  }

  else
  {
    char *return_value_getenv$2;
    return_value_getenv$2=getenv("HOME");
    sprintf(filename, "%.*s/%s", (signed int)sizeof(char [100l]) /*100ul*/  - 8, return_value_getenv$2, (const void *)".xawtv");
    signed int return_value_cfg_parse_file$3;
    return_value_cfg_parse_file$3=cfg_parse_file("/etc/X11/xawtvrc");
    if(return_value_cfg_parse_file$3 == 0)
      have_config = 1;

    signed int return_value_cfg_parse_file$4;
    return_value_cfg_parse_file$4=cfg_parse_file(filename);
    if(return_value_cfg_parse_file$4 == 0)
      have_config = 1;

  }
  if(!(argc == ((signed int *)NULL)))
    cfg_parse_options(argc, argv);

  val=cfg_get_str("global", "mixer");
  if(!(val == ((char *)NULL)))
  {
    mixer=strdup(val);
    signed int return_value_sscanf$5;
    return_value_sscanf$5=sscanf(mixer, "%31[^:]:%15s", (const void *)mixerdev, (const void *)mixerctl);
    if(!(return_value_sscanf$5 == 2))
    {
      strcpy(mixerdev, ng_dev.mixer);
      strncpy(mixerctl, val, (unsigned long int)15);
      mixerctl[(signed long int)15] = (char)0;
    }

  }

  val=cfg_get_str("global", "midi");
  if(!(val == ((char *)NULL)))
    midi=strdup(val);

  val=cfg_get_str("global", "freqtab");
  signed int return_value_strcasecmp$6;
  if(!(val == ((char *)NULL)))
  {
    i = 0;
    for( ; !((chanlists + (signed long int)i)->name == ((char *)NULL)); i = i + 1)
    {
      return_value_strcasecmp$6=strcasecmp(val, (chanlists + (signed long int)i)->name);
      if(return_value_strcasecmp$6 == 0)
        break;

    }
    if(!((chanlists + (signed long int)i)->name == ((char *)NULL)))
      freq_newtab(i);

    else
      fprintf(stderr, "invalid value for freqtab: %s\n", val);
  }

  val=cfg_get_str("global", "fullscreen");
  if(!(val == ((char *)NULL)))
  {
    signed int return_value_sscanf$7;
    return_value_sscanf$7=sscanf(val, "%d x %d", &fs_width, &fs_height);
    if(!(return_value_sscanf$7 == 2))
    {
      fprintf(stderr, "invalid value for fullscreen: %s\n", val);
      fs_height = 0;
      fs_width = fs_height;
    }

  }

  val=cfg_get_str("global", "pixsize");
  if(!(val == ((char *)NULL)))
  {
    signed int return_value_sscanf$8;
    return_value_sscanf$8=sscanf(val, "%d x %d", &pix_width, &pix_height);
    if(!(return_value_sscanf$8 == 2))
    {
      fprintf(stderr, "invalid value for pixsize: %s\n", val);
      pix_width = 128;
      pix_height = 96;
    }

  }

  i=cfg_get_int("global", "pixcols");
  if(!(i == -1))
    pix_cols = i;

  val=cfg_get_str("global", "wm-off-by");
  if(!(val == ((char *)NULL)))
  {
    signed int return_value_sscanf$9;
    return_value_sscanf$9=sscanf(val, "%d %d", &fs_xoff, &fs_yoff);
    if(!(return_value_sscanf$9 == 2))
    {
      fprintf(stderr, "invalid value for wm-off-by: %s\n", val);
      fs_yoff = 0;
      fs_xoff = fs_yoff;
    }

  }

  val=cfg_get_str("global", "ratio");
  if(!(val == ((char *)NULL)))
  {
    signed int return_value_sscanf$10;
    return_value_sscanf$10=sscanf(val, "%d:%d", &ng_ratio_x, &ng_ratio_y);
    if(!(return_value_sscanf$10 == 2))
    {
      fprintf(stderr, "invalid value for ratio: %s\n", val);
      ng_ratio_y = 0;
      ng_ratio_x = ng_ratio_y;
    }

  }

  i=cfg_get_int("global", "jpeg-quality");
  if(!(i == -1))
    ng_jpeg_quality = i;

  val=cfg_get_str("global", "keypad-ntsc");
  if(!(val == ((char *)NULL)))
  {
    i=str_to_int(val, booltab);
    if(!(i == -1))
      keypad_ntsc = i;

  }

  val=cfg_get_str("global", "keypad-partial");
  if(!(val == ((char *)NULL)))
  {
    i=str_to_int(val, booltab);
    if(!(i == -1))
      keypad_partial = i;

  }

  val=cfg_get_str("global", "osd");
  if(!(val == ((char *)NULL)))
  {
    i=str_to_int(val, booltab);
    if(!(i == -1))
      use_osd = i;

  }

  val=cfg_get_str("global", "osd-position");
  signed int return_value_sscanf$11;
  if(!(val == ((char *)NULL)))
  {
    return_value_sscanf$11=sscanf(val, "%d , %d", &osd_x, &osd_y);
    if(!(return_value_sscanf$11 == 2))
      fprintf(stderr, "invalid values for osd-position: %s\n", val);

  }

  val=cfg_get_str("global", "use-wm-fullscreen");
  if(!(val == ((char *)NULL)))
  {
    i=str_to_int(val, booltab);
    if(!(i == -1))
      use_wm_fullscreen = i;

  }

  val=cfg_get_str("global", "mov-driver");
  if(!(val == ((char *)NULL)))
    mov_driver = val;

  val=cfg_get_str("global", "mov-video");
  if(!(val == ((char *)NULL)))
    mov_video = val;

  val=cfg_get_str("global", "mov-fps");
  if(!(val == ((char *)NULL)))
    mov_fps = val;

  val=cfg_get_str("global", "mov-audio");
  if(!(val == ((char *)NULL)))
    mov_audio = val;

  val=cfg_get_str("global", "mov-rate");
  if(!(val == ((char *)NULL)))
    mov_rate = val;

  val=cfg_get_str("global", "filter");
  if(!(val == ((char *)NULL)))
  {
    item = (&ng_filters)->next;
    for( ; !(item == &ng_filters); item = item->next)
    {
      struct ng_filter *f = (struct ng_filter *)((char *)item - (signed long int)(unsigned long int)&((struct ng_filter *)0)->list);
      signed int return_value_strcasecmp$12;
      return_value_strcasecmp$12=strcasecmp(f->name, val);
      if(return_value_strcasecmp$12 == 0)
        cur_filter = f;

    }
  }

}

// read_sim
// file common/vbi-sim.c line 301
static void read_sim(unsigned char *raw_data, struct anonymous$15 *sliced_data, signed int *lines, double *timestamp)
{
  unsigned char *buf;
  double start;
  double inc;
  signed int i;
  memset((void *)raw_data, 0, (unsigned long int)((sim.count[(signed long int)0] + sim.count[(signed long int)1]) * sim.bytes_per_line));
  *timestamp = sim_time;
  if(sim.scanning == 525)
    sim_time = sim_time + (double)1001 / 30000.0;

  else
    sim_time = sim_time + (double)1 / 25.0;
  start = (double)sim.offset / (double)sim.sampling_rate;
  inc = (double)1 / (double)sim.sampling_rate;
  signed int return_value_odd$1;
  signed int return_value_odd$2;
  double return_value_cc_sim$3;
  double return_value_wss525_sim$4;
  signed int return_value_odd$5;
  signed int return_value_odd$6;
  double return_value_cc_sim$7;
  double return_value_wss625_sim$8;
  if(sim.scanning == 525)
  {
    buf = raw_data + (signed long int)((21 - sim.start[(signed long int)0]) * sim.bytes_per_line);
    i = 0;
    for( ; !(i >= sim.bytes_per_line); i = i + 1)
    {
      return_value_odd$1=odd((signed int)caption_text[(signed long int)caption_i]);
      return_value_odd$2=odd((signed int)caption_text[(signed long int)(caption_i + (unsigned int)1)]);
      return_value_cc_sim$3=cc_sim(start + (double)i * inc, (double)(15734 * 32), (unsigned char)return_value_odd$1, (unsigned char)return_value_odd$2);
      buf[(signed long int)i] = (unsigned char)(return_value_cc_sim$3 * (double)110 + (double)60);
    }
    caption_i = caption_i + (unsigned int)2;
    if((unsigned long int)caption_i >= 35ul)
      caption_i = (unsigned int)0;

    const signed int poly = (1 << 6) + (1 << 1) + 1;
    signed int b0 = 1;
    signed int b1 = 1;
    signed int bits = (b0 << 13) + (b1 << 12);
    signed int crc;
    signed int j;
    crc = ((1 << 6) - 1 << 14 + 6) + (bits << 6);
    j = (14 + 6) - 1;
    for( ; j >= 0; j = j - 1)
      if(!((64 << j & crc) == 0))
        crc = crc ^ poly << j;

    bits = bits << 6;
    bits = bits | crc;
    buf = raw_data + (signed long int)((20 - sim.start[(signed long int)0]) * sim.bytes_per_line);
    i = 0;
    for( ; !(i >= sim.bytes_per_line); i = i + 1)
    {
      return_value_wss525_sim$4=wss525_sim(start + (double)i * inc, (double)447443, (unsigned int)bits);
      buf[(signed long int)i] = (unsigned char)(return_value_wss525_sim$4 * (double)110 + (double)60);
    }
  }

  else
  {
    buf = raw_data + (signed long int)((22 - sim.start[(signed long int)0]) * sim.bytes_per_line);
    i = 0;
    for( ; !(i >= sim.bytes_per_line); i = i + 1)
    {
      return_value_odd$5=odd((signed int)caption_text[(signed long int)caption_i]);
      return_value_odd$6=odd((signed int)caption_text[(signed long int)(caption_i + (unsigned int)1)]);
      return_value_cc_sim$7=cc_sim(start + (double)i * inc, (double)(15625 * 32), (unsigned char)return_value_odd$5, (unsigned char)return_value_odd$6);
      buf[(signed long int)i] = (unsigned char)(return_value_cc_sim$7 * (double)110 + (double)60);
    }
    caption_i = caption_i + (unsigned int)2;
    if((unsigned long int)caption_i >= 35ul)
      caption_i = (unsigned int)0;

    signed int g0 = 1;
    signed int g1 = 2;
    signed int g2 = 3;
    signed int g3 = 4;
    signed int read_sim$$1$$2$$2$$bits = (g3 << 11) + (g2 << 8) + (g1 << 4) + g0;
    buf = raw_data + (signed long int)((23 - sim.start[(signed long int)0]) * sim.bytes_per_line);
    i = 0;
    for( ; !(i >= sim.bytes_per_line); i = i + 1)
    {
      return_value_wss625_sim$8=wss625_sim(start + (double)i * inc, (double)(15625 * 320), (unsigned int)read_sim$$1$$2$$2$$bits);
      buf[(signed long int)i] = (unsigned char)(return_value_wss625_sim$8 * (double)110 + (double)60);
    }
    signed int line;
    signed int read_sim$$1$$2$$3$$count;
    unsigned char *text;
    buf = raw_data;
    line = sim.start[(signed long int)0];
    read_sim$$1$$2$$3$$count = sim.count[(signed long int)0];
    for( ; read_sim$$1$$2$$3$$count >= 1; buf = buf + (signed long int)sim.bytes_per_line)
    {
      if(line >= 7 && !(line >= 16) || line >= 19 && !(line >= 22))
      {
        text=ttx_next();
        i = 0;
        for( ; !(i >= sim.bytes_per_line); i = i + 1)
        {
          double return_value_ttx_sim$9;
          return_value_ttx_sim$9=ttx_sim(start + (double)i * inc, (double)(15625 * 444), text);
          buf[(signed long int)i] = (unsigned char)(return_value_ttx_sim$9 * (double)110 + (double)60);
        }
      }

      line = line + 1;
      read_sim$$1$$2$$3$$count = read_sim$$1$$2$$3$$count - 1;
    }
    line = sim.start[(signed long int)1];
    read_sim$$1$$2$$3$$count = sim.count[(signed long int)1];
    for( ; read_sim$$1$$2$$3$$count >= 1; buf = buf + (signed long int)sim.bytes_per_line)
    {
      if(line >= 320 && !(line >= 329) || line >= 332 && !(line >= 336))
      {
        text=ttx_next();
        i = 0;
        for( ; !(i >= sim.bytes_per_line); i = i + 1)
        {
          double return_value_ttx_sim$10;
          return_value_ttx_sim$10=ttx_sim(start + (double)i * inc, (double)(15625 * 444), text);
          buf[(signed long int)i] = (unsigned char)(return_value_ttx_sim$10 * (double)110 + (double)60);
        }
      }

      line = line + 1;
      read_sim$$1$$2$$3$$count = read_sim$$1$$2$$3$$count - 1;
    }
  }
  *lines=vbi_raw_decode(&sim, raw_data, sliced_data);
}

// record_audio_thread
// file common/capture.c line 371
static void * record_audio_thread(void *arg)
{
  struct movie_handle *h = (struct movie_handle *)arg;
  struct ng_audio_buf *buf;
  signed int return_value_getpid$1;
  if(!(debug == 0))
  {
    return_value_getpid$1=getpid();
    fprintf(stderr, "record_audio_thread start [pid=%d]\n", return_value_getpid$1);
  }

  buf=h->dsp->read(h->hdsp, (signed long int)h->stopby);
  if(!(buf == ((struct ng_audio_buf *)NULL)))
  {
    if(!(buf->size == 0))
    {
      h->ats = (unsigned long int)buf->info.ts;
      signed long int return_value_ng_get_timestamp$2;
      return_value_ng_get_timestamp$2=ng_get_timestamp();
      h->rts = (unsigned long int)return_value_ng_get_timestamp$2 - h->start;
      h->rdrift = h->rts - h->ats;
      h->vdrift = h->vts - h->ats;
      signed int return_value_fifo_put$3;
      return_value_fifo_put$3=fifo_put(&h->afifo, (void *)buf);
      if(!(return_value_fifo_put$3 == 0))
        free((void *)buf);

    }

  }

  fifo_put(&h->afifo, (void *)0);
  if(!(debug == 0))
    fprintf(stderr, "record_audio_thread done\n");

  return (void *)0;
}

// redblue_swap
// file libng/color_packed.c line 25
static void redblue_swap(unsigned char *dest, unsigned char *src, signed int p)
{
  unsigned char *s = src;
  unsigned char *d = dest;
  signed int tmp_post$1;
  do
  {
    tmp_post$1 = p;
    p = p - 1;
    if(tmp_post$1 == 0)
      break;

    unsigned char *tmp_post$2 = d;
    d = d + 1l;
    *tmp_post$2 = s[(signed long int)2];
    unsigned char *tmp_post$3 = d;
    d = d + 1l;
    *tmp_post$3 = s[(signed long int)1];
    unsigned char *tmp_post$4 = d;
    d = d + 1l;
    *tmp_post$4 = s[(signed long int)0];
    s = s + (signed long int)3;
  }
  while((_Bool)1);
}

// rgb15_be_gray
// file libng/color_packed.c line 137
static void rgb15_be_gray(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  signed int r;
  signed int g;
  signed int b;
  unsigned char * restrict d = dest;
  signed int tmp_post$1;
  do
  {
    tmp_post$1 = p;
    p = p - 1;
    if(tmp_post$1 == 0)
      break;

    r = ((signed int)src[(signed long int)0] & 0x7c) >> 2;
    g = ((signed int)src[(signed long int)0] & 0x03) << 3 | ((signed int)src[(signed long int)1] & 0xe0) >> 5;
    b = (signed int)src[(signed long int)1] & 0x1f;
    unsigned char * restrict tmp_post$2 = d;
    d = d + 1l;
    *tmp_post$2 = (unsigned char)((3 * r + 6 * g + b) / 10 << 3);
    src = src + (signed long int)2;
  }
  while((_Bool)1);
}

// rgb15_native_gray
// file libng/color_packed.c line 119
static void rgb15_native_gray(unsigned char * restrict dest, unsigned char *s, signed int p)
{
  signed int r;
  signed int g;
  signed int b;
  unsigned short int * restrict src = (unsigned short int *)s;
  signed int tmp_post$1;
  do
  {
    tmp_post$1 = p;
    p = p - 1;
    if(tmp_post$1 == 0)
      break;

    r = ((signed int)src[(signed long int)0] & 0x7c00) >> 10;
    g = ((signed int)src[(signed long int)0] & 0x03e0) >> 5;
    b = (signed int)src[(signed long int)0] & 0x001f;
    unsigned char * restrict tmp_post$2 = dest;
    dest = dest + 1l;
    *tmp_post$2 = (unsigned char)((3 * r + 6 * g + b) / 10 << 3);
    src = src + 1l;
  }
  while((_Bool)1);
}

// rgb32_to_bgr24
// file libng/color_packed.c line 85
static void rgb32_to_bgr24(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned char * restrict s = src;
  unsigned char * restrict d = dest;
  signed int tmp_post$1;
  do
  {
    tmp_post$1 = p;
    p = p - 1;
    if(tmp_post$1 == 0)
      break;

    s = s + 1l;
    unsigned char * restrict tmp_post$2 = s;
    s = s + 1l;
    d[(signed long int)2] = *tmp_post$2;
    unsigned char * restrict tmp_post$3 = s;
    s = s + 1l;
    d[(signed long int)1] = *tmp_post$3;
    unsigned char * restrict tmp_post$4 = s;
    s = s + 1l;
    d[(signed long int)0] = *tmp_post$4;
    d = d + (signed long int)3;
  }
  while((_Bool)1);
}

// rgb32_to_lut2
// file libng/color_lut.c line 56
static void rgb32_to_lut2(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned short int * restrict d = (unsigned short int *)dest;
  signed int tmp_post$1;
  do
  {
    tmp_post$1 = p;
    p = p - 1;
    if(!(tmp_post$1 >= 1))
      break;

    unsigned short int * restrict tmp_post$2 = d;
    d = d + 1l;
    *tmp_post$2 = (unsigned short int)(ng_lut_red[(signed long int)src[(signed long int)1]] | ng_lut_green[(signed long int)src[(signed long int)2]] | ng_lut_blue[(signed long int)src[(signed long int)3]]);
    src = src + (signed long int)4;
  }
  while((_Bool)1);
}

// rgb32_to_lut4
// file libng/color_lut.c line 122
static void rgb32_to_lut4(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned int * restrict d = (unsigned int *)dest;
  signed int tmp_post$1;
  do
  {
    tmp_post$1 = p;
    p = p - 1;
    if(!(tmp_post$1 >= 1))
      break;

    unsigned int * restrict tmp_post$2 = d;
    d = d + 1l;
    *tmp_post$2 = (unsigned int)(ng_lut_red[(signed long int)src[(signed long int)1]] | ng_lut_green[(signed long int)src[(signed long int)2]] | ng_lut_blue[(signed long int)src[(signed long int)3]]);
    src = src + (signed long int)4;
  }
  while((_Bool)1);
}

// rgb32_to_rgb24
// file libng/color_packed.c line 70
static void rgb32_to_rgb24(unsigned char * restrict dest, unsigned char * restrict src, signed int p)
{
  unsigned char * restrict s = src;
  unsigned char * restrict d = dest;
  signed int tmp_post$1;
  do
  {
    tmp_post$1 = p;
    p = p - 1;
    if(tmp_post$1 == 0)
      break;

    s = s + 1l;
    unsigned char * restrict tmp_post$2 = d;
    d = d + 1l;
    unsigned char * restrict tmp_post$3 = s;
    s = s + 1l;
    *tmp_post$2 = *tmp_post$3;
    unsigned char * restrict tmp_post$4 = d;
    d = d + 1l;
    unsigned char * restrict tmp_post$5 = s;
    s = s + 1l;
    *tmp_post$4 = *tmp_post$5;
    unsigned char * restrict tmp_post$6 = d;
    d = d + 1l;
    unsigned char * restrict tmp_post$7 = s;
    s = s + 1l;
    *tmp_post$6 = *tmp_post$7;
  }
  while((_Bool)1);
}

// save_config
// file common/channel.c line 559
void save_config(void)
{
  struct ng_attribute *attr;
  char filename1[100l];
  char filename2[100l];
  struct _IO_FILE *fp;
  signed int i;
  char *return_value_getenv$1;
  return_value_getenv$1=getenv("HOME");
  sprintf(filename1, "%s/%s", return_value_getenv$1, (const void *)".xawtv");
  char *return_value_getenv$2;
  return_value_getenv$2=getenv("HOME");
  sprintf(filename2, "%s/%s", return_value_getenv$2, (const void *)".xawtv~");
  unlink(filename2);
  signed int return_value_link$3;
  return_value_link$3=link(filename1, filename2);
  if(return_value_link$3 == 0)
    unlink(filename1);

  fp=fopen(filename1, "w");
  signed int return_value_ng_attr_int2percent$13;
  signed int return_value_ng_attr_int2percent$14;
  signed int return_value_ng_attr_int2percent$15;
  signed int return_value_ng_attr_int2percent$16;
  struct ng_attribute *return_value_ng_attr_byid$18;
  const char *return_value_ng_attr_getstr$19;
  struct ng_attribute *return_value_ng_attr_byid$20;
  const char *return_value_ng_attr_getstr$21;
  const char *return_value_int_to_str$23;
  signed int return_value_ng_attr_int2percent$24;
  signed int return_value_ng_attr_int2percent$25;
  signed int return_value_ng_attr_int2percent$26;
  signed int return_value_ng_attr_int2percent$27;
  if(fp == ((struct _IO_FILE *)NULL))
    fprintf(stderr, "can't open config file %s\n", (const void *)filename1);

  else
  {
    fprintf(fp, "[global]\n");
    if(!(fs_height == 0) && !(fs_width == 0))
      fprintf(fp, "fullscreen = %d x %d\n", fs_width, fs_height);

    if(!(fs_xoff == 0) || !(fs_yoff == 0))
      fprintf(fp, "wm-off-by = %+d%+d\n", fs_xoff, fs_yoff);

    if(!(ng_ratio_x == 0) || !(ng_ratio_y == 0))
      fprintf(fp, "ratio = %d:%d\n", ng_ratio_x, ng_ratio_y);

    fprintf(fp, "freqtab = %s\n", (chanlists + (signed long int)chantab)->name);
    fprintf(fp, "pixsize = %d x %d\n", pix_width, pix_height);
    fprintf(fp, "pixcols = %d\n", pix_cols);
    fprintf(fp, "jpeg-quality = %d\n", ng_jpeg_quality);
    const char *return_value_int_to_str$4;
    return_value_int_to_str$4=int_to_str(keypad_ntsc, booltab);
    fprintf(fp, "keypad-ntsc = %s\n", return_value_int_to_str$4);
    const char *return_value_int_to_str$5;
    return_value_int_to_str$5=int_to_str(keypad_partial, booltab);
    fprintf(fp, "keypad-partial = %s\n", return_value_int_to_str$5);
    const char *return_value_int_to_str$6;
    return_value_int_to_str$6=int_to_str(use_osd, booltab);
    fprintf(fp, "osd = %s\n", return_value_int_to_str$6);
    fprintf(fp, "osd-position = %d , %d\n", osd_x, osd_y);
    const char *return_value_int_to_str$7;
    return_value_int_to_str$7=int_to_str(use_wm_fullscreen, booltab);
    fprintf(fp, "use-wm-fullscreen = %s\n", return_value_int_to_str$7);
    if(!(mixer == ((char *)NULL)))
      fprintf(fp, "mixer = %s\n", mixer);

    if(!(midi == ((char *)NULL)))
      fprintf(fp, "midi = %s\n", midi);

    if(!(mov_driver == ((char *)NULL)))
      fprintf(fp, "mov-driver = %s\n", mov_driver);

    if(!(mov_video == ((char *)NULL)))
      fprintf(fp, "mov-video = %s\n", mov_video);

    if(!(mov_fps == ((char *)NULL)))
      fprintf(fp, "mov-fps = %s\n", mov_fps);

    if(!(mov_audio == ((char *)NULL)))
      fprintf(fp, "mov-audio = %s\n", mov_audio);

    if(!(mov_rate == ((char *)NULL)))
      fprintf(fp, "mov-rate = %s\n", mov_rate);

    fprintf(fp, "\n");
    if(nlaunch >= 1)
    {
      fprintf(fp, "[launch]\n");
      i = 0;
      for( ; !(i >= nlaunch); i = i + 1)
        fprintf(fp, "%s = %s, %s\n", (launch + (signed long int)i)->name, (launch + (signed long int)i)->key, (launch + (signed long int)i)->cmdline);
      fprintf(fp, "\n");
    }

    event_writeconfig(fp);
    fprintf(fp, "# [Station name]\n");
    fprintf(fp, "# capture = overlay | grabdisplay | on | off\n");
    fprintf(fp, "# input = Television | Composite1 | S-Video | ...\n");
    fprintf(fp, "# norm = PAL | NTSC | SECAM | ... \n");
    fprintf(fp, "# channel = #\n");
    fprintf(fp, "# fine = # (-128..+127)\n");
    fprintf(fp, "# key = keysym | modifier+keysym\n");
    fprintf(fp, "# color = #\n");
    fprintf(fp, "# bright = #\n");
    fprintf(fp, "# hue = #\n");
    fprintf(fp, "# contrast = #\n");
    fprintf(fp, "\n");
    fprintf(fp, "[defaults]\n");
    fprintf(fp, "group = %s\n", defaults.group);
    struct ng_attribute *return_value_ng_attr_byid$8;
    return_value_ng_attr_byid$8=ng_attr_byid(attrs, 1);
    const char *return_value_ng_attr_getstr$9;
    return_value_ng_attr_getstr$9=ng_attr_getstr(return_value_ng_attr_byid$8, cur_attrs[(signed long int)1]);
    fprintf(fp, "norm = %s\n", return_value_ng_attr_getstr$9);
    struct ng_attribute *return_value_ng_attr_byid$10;
    return_value_ng_attr_byid$10=ng_attr_byid(attrs, 2);
    const char *return_value_ng_attr_getstr$11;
    return_value_ng_attr_getstr$11=ng_attr_getstr(return_value_ng_attr_byid$10, cur_attrs[(signed long int)2]);
    fprintf(fp, "input = %s\n", return_value_ng_attr_getstr$11);
    const char *return_value_int_to_str$12;
    return_value_int_to_str$12=int_to_str(cur_capture, captab);
    fprintf(fp, "capture = %s\n", return_value_int_to_str$12);
    attr=ng_attr_byid(attrs, 6);
    if(!(attr == ((struct ng_attribute *)NULL)))
    {
      if(!(attr->defval == cur_attrs[6l]))
      {
        return_value_ng_attr_int2percent$13=ng_attr_int2percent(attr, cur_attrs[(signed long int)6]);
        fprintf(fp, "color = %d%%\n", return_value_ng_attr_int2percent$13);
      }

    }

    attr=ng_attr_byid(attrs, 7);
    if(!(attr == ((struct ng_attribute *)NULL)))
    {
      if(!(attr->defval == cur_attrs[7l]))
      {
        return_value_ng_attr_int2percent$14=ng_attr_int2percent(attr, cur_attrs[(signed long int)7]);
        fprintf(fp, "bright = %d%%\n", return_value_ng_attr_int2percent$14);
      }

    }

    attr=ng_attr_byid(attrs, 8);
    if(!(attr == ((struct ng_attribute *)NULL)))
    {
      if(!(attr->defval == cur_attrs[8l]))
      {
        return_value_ng_attr_int2percent$15=ng_attr_int2percent(attr, cur_attrs[(signed long int)8]);
        fprintf(fp, "hue = %d%%\n", return_value_ng_attr_int2percent$15);
      }

    }

    attr=ng_attr_byid(attrs, 9);
    if(!(attr == ((struct ng_attribute *)NULL)))
    {
      if(!(attr->defval == cur_attrs[9l]))
      {
        return_value_ng_attr_int2percent$16=ng_attr_int2percent(attr, cur_attrs[(signed long int)9]);
        fprintf(fp, "contrast = %d%%\n", return_value_ng_attr_int2percent$16);
      }

    }

    fprintf(fp, "\n");
    i = 0;
    for( ; !(i >= count); i = i + 1)
    {
      fprintf(fp, "[%s]\n", channels[(signed long int)i]->name);
      if(!(channels[(signed long int)i]->cname == ((char *)NULL)))
      {
        struct CHANLIST *tmp_if_expr$17;
        if(!(chantab == -1))
          tmp_if_expr$17 = (chanlists + (signed long int)chantab)->list;

        else
          tmp_if_expr$17 = (struct CHANLIST *)(void *)0;
        fprintf(fp, "channel = %s\n", (tmp_if_expr$17 + (signed long int)channels[(signed long int)i]->channel)->name);
        if(!(channels[(signed long int)i]->fine == 0))
          fprintf(fp, "fine = %+d\n", channels[(signed long int)i]->fine);

      }

      else
        fprintf(fp, "freq = %.2f\n", (float)channels[(signed long int)i]->freq / (float)16);
      if(!(channels[(signed long int)i]->norm == cur_attrs[1l]))
      {
        return_value_ng_attr_byid$18=ng_attr_byid(attrs, 1);
        return_value_ng_attr_getstr$19=ng_attr_getstr(return_value_ng_attr_byid$18, channels[(signed long int)i]->norm);
        fprintf(fp, "norm = %s\n", return_value_ng_attr_getstr$19);
      }

      if(!(channels[(signed long int)i]->input == cur_attrs[2l]))
      {
        return_value_ng_attr_byid$20=ng_attr_byid(attrs, 2);
        return_value_ng_attr_getstr$21=ng_attr_getstr(return_value_ng_attr_byid$20, channels[(signed long int)i]->input);
        fprintf(fp, "input = %s\n", return_value_ng_attr_getstr$21);
      }

      if(!(channels[(signed long int)i]->key == ((char *)NULL)))
        fprintf(fp, "key = %s\n", channels[(signed long int)i]->key);

      signed int return_value_strcmp$22;
      return_value_strcmp$22=strcmp(channels[(signed long int)i]->group, defaults.group);
      if(!(return_value_strcmp$22 == 0))
        fprintf(fp, "group = %s\n", channels[(signed long int)i]->group);

      if(!(channels[(signed long int)i]->midi == 0))
        fprintf(fp, "midi = %d\n", channels[(signed long int)i]->midi);

      if(!(channels[(signed long int)i]->capture == cur_capture))
      {
        return_value_int_to_str$23=int_to_str(channels[(signed long int)i]->capture, captab);
        fprintf(fp, "capture = %s\n", return_value_int_to_str$23);
      }

      attr=ng_attr_byid(attrs, 6);
      if(!(attr == ((struct ng_attribute *)NULL)))
      {
        if(!(cur_attrs[6l] == channels[(signed long int)i]->color))
        {
          return_value_ng_attr_int2percent$24=ng_attr_int2percent(attr, channels[(signed long int)i]->color);
          fprintf(fp, "color = %d%%\n", return_value_ng_attr_int2percent$24);
        }

      }

      attr=ng_attr_byid(attrs, 7);
      if(!(attr == ((struct ng_attribute *)NULL)))
      {
        if(!(cur_attrs[7l] == channels[(signed long int)i]->bright))
        {
          return_value_ng_attr_int2percent$25=ng_attr_int2percent(attr, channels[(signed long int)i]->bright);
          fprintf(fp, "bright = %d%%\n", return_value_ng_attr_int2percent$25);
        }

      }

      attr=ng_attr_byid(attrs, 8);
      if(!(attr == ((struct ng_attribute *)NULL)))
      {
        if(!(cur_attrs[8l] == channels[(signed long int)i]->hue))
        {
          return_value_ng_attr_int2percent$26=ng_attr_int2percent(attr, channels[(signed long int)i]->hue);
          fprintf(fp, "hue = %d%%\n", return_value_ng_attr_int2percent$26);
        }

      }

      attr=ng_attr_byid(attrs, 9);
      if(!(attr == ((struct ng_attribute *)NULL)))
      {
        if(!(cur_attrs[9l] == channels[(signed long int)i]->contrast))
        {
          return_value_ng_attr_int2percent$27=ng_attr_int2percent(attr, channels[(signed long int)i]->contrast);
          fprintf(fp, "contrast = %d%%\n", return_value_ng_attr_int2percent$27);
        }

      }

      fprintf(fp, "\n");
    }
    fclose(fp);
  }
}

// selection_clip_cb
// file x11/vbi-gui.c line 857
static void selection_clip_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  struct vbi_window *vw = (struct vbi_window *)clientdata;
  if(!(tt_debug == 0))
    fprintf(stderr, "tt: clipboard [copy]\n");

  struct _XDisplay *return_value_XtDisplay$1;
  return_value_XtDisplay$1=XtDisplay(vw->tt);
  unsigned long int return_value_XtLastTimestampProcessed$2;
  return_value_XtLastTimestampProcessed$2=XtLastTimestampProcessed(return_value_XtDisplay$1);
  XmeClipboardSource(vw->tt, (unsigned char)2, return_value_XtLastTimestampProcessed$2);
}

// selection_convert_cb
// file x11/vbi-gui.c line 689
static void selection_convert_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  struct anonymous$2 *ccs = (struct anonymous$2 *)call_data;
  struct vbi_window *vw = (struct vbi_window *)clientdata;
  struct vbi_selection *sel;
  struct _XDisplay *selection_convert_cb$$1$$dpy;
  selection_convert_cb$$1$$dpy=XtDisplay(widget);
  unsigned long int *ldata;
  unsigned char *cdata;
  unsigned long int *targs;
  signed int n;
  char *return_value_XGetAtomName$1;
  char *return_value_XGetAtomName$3;
  char *return_value_XGetAtomName$5;
  if(!(tt_debug == 0))
  {
    char *y;
    char *tmp_if_expr$2;
    if(ccs->type == 0ul)
      tmp_if_expr$2 = (char *)(void *)0;

    else
    {
      return_value_XGetAtomName$1=XGetAtomName(selection_convert_cb$$1$$dpy, ccs->type);
      tmp_if_expr$2 = return_value_XGetAtomName$1;
    }
    y = tmp_if_expr$2;
    char *t;
    char *tmp_if_expr$4;
    if(ccs->target == 0ul)
      tmp_if_expr$4 = (char *)(void *)0;

    else
    {
      return_value_XGetAtomName$3=XGetAtomName(selection_convert_cb$$1$$dpy, ccs->target);
      tmp_if_expr$4 = return_value_XGetAtomName$3;
    }
    t = tmp_if_expr$4;
    char *s;
    char *tmp_if_expr$6;
    if(ccs->selection == 0ul)
      tmp_if_expr$6 = (char *)(void *)0;

    else
    {
      return_value_XGetAtomName$5=XGetAtomName(selection_convert_cb$$1$$dpy, ccs->selection);
      tmp_if_expr$6 = return_value_XGetAtomName$5;
    }
    s = tmp_if_expr$6;
    fprintf(stderr, "tt: target=%s type=%s selection=%s\n", t, y, s);
    if(!(y == ((char *)NULL)))
      XFree((void *)y);

    if(!(t == ((char *)NULL)))
      XFree((void *)t);

    if(!(s == ((char *)NULL)))
      XFree((void *)s);

  }

  _Bool tmp_if_expr$19;
  if(ccs->target == XA_TARGETS)
    tmp_if_expr$19 = (_Bool)1;

  else
    tmp_if_expr$19 = ccs->target == _MOTIF_CLIPBOARD_TARGETS ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$20;
  if(tmp_if_expr$19)
    tmp_if_expr$20 = (_Bool)1;

  else
    tmp_if_expr$20 = ccs->target == _MOTIF_DEFERRED_CLIPBOARD_TARGETS ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$21;
  if(tmp_if_expr$20)
    tmp_if_expr$21 = (_Bool)1;

  else
    tmp_if_expr$21 = ccs->target == _MOTIF_EXPORT_TARGETS ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$21)
  {
    n = 0;
    char *return_value_XtMalloc$7;
    return_value_XtMalloc$7=XtMalloc((unsigned int)(sizeof(unsigned long int) /*8ul*/  * (unsigned long int)32));
    targs = (unsigned long int *)return_value_XtMalloc$7;
    if(!(ccs->target == _MOTIF_CLIPBOARD_TARGETS))
    {
      signed int tmp_post$8 = n;
      n = n + 1;
      targs[(signed long int)tmp_post$8] = XA_TARGETS;
      signed int tmp_post$9 = n;
      n = n + 1;
      targs[(signed long int)tmp_post$9] = (unsigned long int)20;
      signed int tmp_post$10 = n;
      n = n + 1;
      targs[(signed long int)tmp_post$10] = (unsigned long int)7;
      signed int tmp_post$11 = n;
      n = n + 1;
      targs[(signed long int)tmp_post$11] = XA_FOREGROUND;
      signed int tmp_post$12 = n;
      n = n + 1;
      targs[(signed long int)tmp_post$12] = XA_BACKGROUND;
      signed int tmp_post$13 = n;
      n = n + 1;
      targs[(signed long int)tmp_post$13] = MIME_TEXT_UTF_8;
      signed int tmp_post$14 = n;
      n = n + 1;
      targs[(signed long int)tmp_post$14] = XA_UTF8_STRING;
      signed int tmp_post$15 = n;
      n = n + 1;
      targs[(signed long int)tmp_post$15] = MIME_TEXT_ISO8859_1;
      signed int tmp_post$16 = n;
      n = n + 1;
      targs[(signed long int)tmp_post$16] = (unsigned long int)31;
    }

    if(ccs->target == _MOTIF_EXPORT_TARGETS)
      selection_init(vw, ccs->selection);

    ccs->value = (void *)targs;
    ccs->length = (unsigned long int)n;
    ccs->type = (unsigned long int)4;
    ccs->format = 32;
    ccs->status = 4;
    goto __CPROVER_DUMP_L46;
  }

  else
    if(ccs->target == _MOTIF_SNAPSHOT)
    {
      n = 0;
      char *return_value_XtMalloc$17;
      return_value_XtMalloc$17=XtMalloc((unsigned int)sizeof(unsigned long int) /*8ul*/ );
      targs = (unsigned long int *)return_value_XtMalloc$17;
      signed int tmp_post$18 = n;
      n = n + 1;
      targs[(signed long int)tmp_post$18]=selection_unique_atom(vw);
      selection_init(vw, targs[(signed long int)0]);
      ccs->value = (void *)targs;
      ccs->length = (unsigned long int)n;
      ccs->type = (unsigned long int)4;
      ccs->format = 32;
      ccs->status = 4;
      goto __CPROVER_DUMP_L46;
    }

  sel=selection_find(vw, ccs->selection);
  if(sel == ((struct vbi_selection *)NULL))
  {
    fprintf(stderr, "tt: oops: selection data not found\n");
    ccs->status = 3;
  }

  else
  {
    _Bool tmp_if_expr$22;
    if(ccs->target == _MOTIF_LOSE_SELECTION)
      tmp_if_expr$22 = (_Bool)1;

    else
      tmp_if_expr$22 = ccs->target == XA_DONE ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$22)
    {
      selection_fini(vw, ccs->selection);
      if(ccs->selection == 1ul)
      {
        vw->s.x2 = 0;
        vw->s.x1 = vw->s.x2;
        vw->s.y2 = 0;
        vw->s.y1 = vw->s.y2;
        vbi_render_page(vw);
      }

      ccs->value = (void *)0;
      ccs->length = (unsigned long int)0;
      ccs->type = (unsigned long int)19;
      ccs->format = 32;
      ccs->status = 4;
    }

    else
    {
      _Bool tmp_if_expr$36;
      if(ccs->target == 31ul)
        tmp_if_expr$36 = (_Bool)1;

      else
        tmp_if_expr$36 = ccs->target == MIME_TEXT_ISO8859_1 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$36)
      {
        char *return_value_XtMalloc$23;
        return_value_XtMalloc$23=XtMalloc((unsigned int)(25 * 41 * 8));
        cdata = (unsigned char *)return_value_XtMalloc$23;
        n=vbi_export_txt((char *)cdata, "ISO8859-1", 25 * 41 * 8, &sel->pg, &sel->rect, (enum vbi_txt_colors)VBI_NOCOLOR);
        ccs->value = (void *)cdata;
        ccs->length = (unsigned long int)n;
        ccs->type = (unsigned long int)31;
        ccs->format = 8;
        ccs->status = 4;
      }

      else
      {
        _Bool tmp_if_expr$35;
        if(ccs->target == XA_UTF8_STRING)
          tmp_if_expr$35 = (_Bool)1;

        else
          tmp_if_expr$35 = ccs->target == MIME_TEXT_UTF_8 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$35)
        {
          char *return_value_XtMalloc$24;
          return_value_XtMalloc$24=XtMalloc((unsigned int)(25 * 41 * 8));
          cdata = (unsigned char *)return_value_XtMalloc$24;
          n=vbi_export_txt((char *)cdata, "UTF-8", 25 * 41 * 8, &sel->pg, &sel->rect, (enum vbi_txt_colors)VBI_NOCOLOR);
          ccs->value = (void *)cdata;
          ccs->length = (unsigned long int)n;
          ccs->type = (unsigned long int)31;
          ccs->format = 8;
          ccs->status = 4;
        }

        else
        {
          _Bool tmp_if_expr$33;
          if(ccs->target == XA_BACKGROUND)
            tmp_if_expr$33 = (_Bool)1;

          else
            tmp_if_expr$33 = ccs->target == XA_FOREGROUND ? (_Bool)1 : (_Bool)0;
          _Bool tmp_if_expr$34;
          if(tmp_if_expr$33)
            tmp_if_expr$34 = (_Bool)1;

          else
            tmp_if_expr$34 = ccs->target == (unsigned long int)7 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$34)
          {
            n = 0;
            char *return_value_XtMalloc$25;
            return_value_XtMalloc$25=XtMalloc((unsigned int)(sizeof(unsigned long int) /*8ul*/  * (unsigned long int)8));
            ldata = (unsigned long int *)return_value_XtMalloc$25;
            if(ccs->target == XA_BACKGROUND)
            {
              signed int tmp_post$26 = n;
              n = n + 1;
              struct anonymous$96 *return_value_XtScreen$27;
              return_value_XtScreen$27=XtScreen(widget);
              ldata[(signed long int)tmp_post$26] = return_value_XtScreen$27->white_pixel;
              ccs->type = XA_PIXEL;
            }

            if(ccs->target == XA_FOREGROUND)
            {
              signed int tmp_post$28 = n;
              n = n + 1;
              struct anonymous$96 *return_value_XtScreen$29;
              return_value_XtScreen$29=XtScreen(widget);
              ldata[(signed long int)tmp_post$28] = return_value_XtScreen$29->black_pixel;
              ccs->type = XA_PIXEL;
            }

            if(ccs->target == 7ul)
            {
              signed int tmp_post$30 = n;
              n = n + 1;
              struct anonymous$96 *return_value_XtScreen$31;
              return_value_XtScreen$31=XtScreen(widget);
              ldata[(signed long int)tmp_post$30] = return_value_XtScreen$31->cmap;
              ccs->type = (unsigned long int)7;
            }

            ccs->value = (void *)ldata;
            ccs->length = (unsigned long int)n;
            ccs->format = 32;
            ccs->status = 4;
          }

          else
            if(ccs->target == 20ul)
            {
              if(sel->pix == 0ul)
                sel->pix=vbi_export_pixmap(vw, &sel->pg, &sel->rect);

              if(!(tt_debug == 0))
                fprintf(stderr, "tt: pixmap id is 0x%lx\n", sel->pix);

              char *return_value_XtMalloc$32;
              return_value_XtMalloc$32=XtMalloc((unsigned int)sizeof(unsigned long int) /*8ul*/ );
              ldata = (unsigned long int *)return_value_XtMalloc$32;
              ldata[(signed long int)0] = sel->pix;
              ccs->value = (void *)ldata;
              ccs->length = (unsigned long int)1;
              ccs->type = (unsigned long int)17;
              ccs->format = 32;
              ccs->status = 4;
            }

            else
            {
              fprintf(stderr, "tt: oops: target not found\n");
              ccs->status = 3;
            }
        }
      }
    }
  }

__CPROVER_DUMP_L46:
  ;
}

// selection_dnd_done
// file x11/vbi-gui.c line 869
static void selection_dnd_done(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  struct vbi_window *vw = (struct vbi_window *)clientdata;
  if(!(tt_debug == 0))
    fprintf(stderr, "tt: dnd done\n");

  selection_fini(vw, _MOTIF_DROP);
}

// selection_dnd_start
// file x11/vbi-gui.c line 879
static void selection_dnd_start(struct vbi_window *vw, union _XEvent *event)
{
  struct _WidgetRec *drag;
  struct anonymous$1 selection_dnd_start$$1$$args[4l];
  unsigned int n = (unsigned int)0;
  if(!(tt_debug == 0))
    fprintf(stderr, "tt: dnd start\n");

  n = (unsigned int)0;
  selection_dnd_start$$1$$args[(signed long int)n].name = (char *)&_XmStrings[(signed long int)6334];
  selection_dnd_start$$1$$args[(signed long int)n].value = (signed long int)(1L << 1);
  n = n + 1u;
  drag=XmeDragSource(vw->tt, (void *)0, event, selection_dnd_start$$1$$args, n);
  XtAddCallback(drag, (char *)&_XmStrings[(signed long int)6251], selection_dnd_done, (void *)vw);
}

// selection_find
// file x11/vbi-gui.c line 626
static struct vbi_selection * selection_find(struct vbi_window *vw, unsigned long int selection)
{
  struct list_head *item;
  struct vbi_selection *sel;
  item = (&vw->selections)->next;
  for( ; !(item == &vw->selections); item = item->next)
  {
    sel = (struct vbi_selection *)((char *)item - (signed long int)(unsigned long int)&((struct vbi_selection *)0)->list);
    if(sel->atom == selection)
      return sel;

  }
  return (struct vbi_selection *)(void *)0;
}

// selection_fini
// file x11/vbi-gui.c line 640
static void selection_fini(struct vbi_window *vw, unsigned long int selection)
{
  struct vbi_selection *sel;
  sel=selection_find(vw, selection);
  struct _XDisplay *return_value_XtDisplay$1;
  if(!(sel == ((struct vbi_selection *)NULL)))
  {
    if(!(sel->pix == 0ul))
    {
      return_value_XtDisplay$1=XtDisplay(vw->tt);
      XFreePixmap(return_value_XtDisplay$1, sel->pix);
    }

    list_del(&sel->list);
    free((void *)sel);
  }

}

// selection_init
// file x11/vbi-gui.c line 655
static void selection_init(struct vbi_window *vw, unsigned long int selection)
{
  struct vbi_selection *sel;
  selection_fini(vw, selection);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct vbi_selection) /*9120ul*/ );
  sel = (struct vbi_selection *)return_value_malloc$1;
  memset((void *)sel, 0, sizeof(struct vbi_selection) /*9120ul*/ );
  list_add_tail(&sel->list, &vw->selections);
  sel->atom = selection;
  sel->pg = vw->pg;
  sel->rect = vw->s;
  vbi_check_rectangle(&sel->rect);
  if(sel->rect.x2 == 0)
  {
    if(sel->rect.y2 == 0)
    {
      sel->rect.x2 = 41;
      sel->rect.y2 = 25;
    }

  }

}

// selection_pri
// file x11/vbi-gui.c line 847
static void selection_pri(struct vbi_window *vw)
{
  if(!(tt_debug == 0))
    fprintf(stderr, "tt: primary\n");

  selection_init(vw, (unsigned long int)1);
  struct _XDisplay *return_value_XtDisplay$1;
  return_value_XtDisplay$1=XtDisplay(vw->tt);
  unsigned long int return_value_XtLastTimestampProcessed$2;
  return_value_XtLastTimestampProcessed$2=XtLastTimestampProcessed(return_value_XtDisplay$1);
  XmePrimarySource(vw->tt, return_value_XtLastTimestampProcessed$2);
}

// selection_unique_atom
// file x11/vbi-gui.c line 673
static unsigned long int selection_unique_atom(struct vbi_window *vw)
{
  char id_name[32l];
  unsigned long int id;
  signed int i = 0;
  do
  {
    unsigned long int return_value_XtWindow$1;
    return_value_XtWindow$1=XtWindow(vw->tt);
    sprintf(id_name, "_VBI_DATA_%lX_%d", return_value_XtWindow$1, i);
    struct _XDisplay *return_value_XtDisplay$2;
    return_value_XtDisplay$2=XtDisplay(vw->tt);
    id=XInternAtom(return_value_XtDisplay$2, id_name, 0);
    struct vbi_selection *return_value_selection_find$3;
    return_value_selection_find$3=selection_find(vw, id);
    if(return_value_selection_find$3 == ((struct vbi_selection *)NULL))
      break;

    i = i + 1;
  }
  while((_Bool)1);
  return id;
}

// set_attr
// file common/commands.c line 331
static void set_attr(struct ng_attribute *attr, signed int val)
{
  if(!(attr == ((struct ng_attribute *)NULL)))
  {
    attr->write(attr, val);
    cur_attrs[(signed long int)attr->id] = val;
    if(!(attr_notify == ((void (*)(struct ng_attribute *, signed int))NULL)))
      attr_notify(attr, val);

  }

}

// set_capture
// file common/commands.c line 304
static void set_capture(signed int capture, signed int tmp_switch)
{
  if(!(set_capture_hook == ((void (*)(signed int, signed int, signed int))NULL)))
  {
    static signed int last_on = 1;
    if(capture == 9)
      capture = last_on;

    if(capture == 1)
    {
      if((1 & f_drv) == 0)
        capture = 2;

      if(do_overlay == 0)
        capture = 2;

    }

    if(!(cur_capture == capture))
    {
      set_capture_hook(cur_capture, capture, tmp_switch);
      cur_capture = capture;
    }

    if(!(cur_capture == 0))
      last_on = cur_capture;

  }

}

// set_defaults
// file common/commands.c line 525
void set_defaults(void)
{
  struct ng_attribute *attr;
  attr=ng_attr_byid(attrs, 6);
  if(!(attr == ((struct ng_attribute *)NULL)))
    set_attr(attr, defaults.color);

  attr=ng_attr_byid(attrs, 7);
  if(!(attr == ((struct ng_attribute *)NULL)))
    set_attr(attr, defaults.bright);

  attr=ng_attr_byid(attrs, 8);
  if(!(attr == ((struct ng_attribute *)NULL)))
    set_attr(attr, defaults.hue);

  attr=ng_attr_byid(attrs, 9);
  if(!(attr == ((struct ng_attribute *)NULL)))
    set_attr(attr, defaults.contrast);

  attr=ng_attr_byid(attrs, 2);
  if(!(attr == ((struct ng_attribute *)NULL)))
    set_attr(attr, defaults.input);

  attr=ng_attr_byid(attrs, 1);
  if(!(attr == ((struct ng_attribute *)NULL)))
    set_attr(attr, defaults.norm);

  set_capture(defaults.capture, 0);
  cur_channel = defaults.channel;
  cur_fine = defaults.fine;
  cur_freq = defaults.freq;
  if(!((4 & f_drv) == 0))
    drv->setfreq(h_drv, (unsigned long int)defaults.freq);

}

// set_freqtab
// file common/commands.c line 364
static void set_freqtab(signed int j)
{
  if(!((4 & f_drv) == 0))
  {
    freq_newtab(j);
    cur_channel = -1;
    calc_frequencies();
    if(!(freqtab_notify == ((void (*)(void))NULL)))
      freqtab_notify();

  }

}

// set_msg_bool
// file common/commands.c line 418
static void set_msg_bool(const char *name, signed int val)
{
  if(!(display_message == ((void (*)(char *))NULL)))
  {
    static char title[256l];
    sprintf(title, "%s: %s", name, val != 0 ? "on" : "off");
    display_message(title);
  }

}

// set_msg_int
// file common/commands.c line 406
static void set_msg_int(struct ng_attribute *attr, signed int val)
{
  if(!(display_message == ((void (*)(char *))NULL)))
  {
    signed int return_value_ng_attr_int2percent$1;
    return_value_ng_attr_int2percent$1=ng_attr_int2percent(attr, val);
    static char title[256l];
    sprintf(title, "%s: %d%%", attr->name, return_value_ng_attr_int2percent$1);
    display_message(title);
  }

}

// set_msg_str
// file common/commands.c line 429
static void set_msg_str(const char *name, const char *val)
{
  if(!(display_message == ((void (*)(char *))NULL)))
  {
    static char title[256l];
    sprintf(title, "%s: %s", name, val);
    display_message(title);
  }

}

// set_mute
// file common/commands.c line 351
static void set_mute(signed int val)
{
  struct ng_attribute *attr;
  cur_attrs[(signed long int)4] = val;
  attr=ng_attr_byid(attrs, 4);
  if(!(attr == ((struct ng_attribute *)NULL)))
    attr->write(attr, val);

  if(!(mute_notify == ((void (*)(signed int))NULL)))
    mute_notify(val);

}

// set_title
// file common/commands.c line 381
static void set_title(void)
{
  const char *norm;
  keypad_state = -1;
  unsigned long int return_value_strlen$2;
  if(!(update_title == ((void (*)(char *))NULL)))
  {
    static char title[256l];
    if(!(cur_sender == -1))
      sprintf(title, "%s", channels[(signed long int)cur_sender]->name);

    else
      if(!(cur_channel == -1))
      {
        struct CHANLIST *tmp_if_expr$1;
        if(!(chantab == -1))
          tmp_if_expr$1 = (chanlists + (signed long int)chantab)->list;

        else
          tmp_if_expr$1 = (struct CHANLIST *)(void *)0;
        sprintf(title, "channel %s", (tmp_if_expr$1 + (signed long int)cur_channel)->name);
        if(!(cur_fine == 0))
        {
          return_value_strlen$2=strlen(title);
          sprintf(title + (signed long int)return_value_strlen$2, " (%d)", cur_fine);
        }

        struct ng_attribute *return_value_ng_attr_byid$3;
        return_value_ng_attr_byid$3=ng_attr_byid(attrs, 1);
        norm=ng_attr_getstr(return_value_ng_attr_byid$3, cur_attrs[(signed long int)1]);
        unsigned long int return_value_strlen$4;
        return_value_strlen$4=strlen(title);
        sprintf(title + (signed long int)return_value_strlen$4, " (%s/%s)", norm != ((const char *)NULL) ? norm : "???", (chanlists + (signed long int)chantab)->name);
      }

      else
        sprintf(title, "%.3f MHz", (double)cur_freq / 16.0);
    update_title(title);
  }

}

// set_volume
// file common/commands.c line 342
static void set_volume(signed int val)
{
  struct ng_attribute *attr;
  cur_attrs[(signed long int)3] = val;
  attr=ng_attr_byid(attrs, 3);
  if(!(attr == ((struct ng_attribute *)NULL)))
    attr->write(attr, val);

}

// setchannel_handler
// file common/commands.c line 667
static signed int setchannel_handler(char *name, signed int argc, char **argv)
{
  signed int i;
  signed int setchannel_handler$$1$$c;
  signed int orig_mute;
  signed int return_value_strcasecmp$7;
  signed int return_value_strcasecmp$6;
  signed int return_value_strcasecmp$5;
  signed int return_value_get_freq$11;
  if((4 & f_drv) == 0)
    return 0;

  else
    if(argc == 0)
    {
      set_title();
      return 0;
    }

    else
      if(!(cur_movie == 0))
      {
        if(!(display_message == ((void (*)(char *))NULL)))
          display_message("grabber busy");

        return -1;
      }

      else
      {
        signed int return_value_strcasecmp$12;
        return_value_strcasecmp$12=strcasecmp("setfreq", name);
        if(return_value_strcasecmp$12 == 0)
        {
          double return_value_atof$1;
          return_value_atof$1=atof(argv[(signed long int)0]);
          cur_freq = (signed int)(unsigned long int)(return_value_atof$1 * (double)16);
          cur_sender = -1;
          cur_channel = -1;
          cur_fine = 0;
        }

        else
        {
          signed int return_value_strcasecmp$8;
          return_value_strcasecmp$8=strcasecmp(argv[(signed long int)0], "next");
          if(return_value_strcasecmp$8 == 0)
          {
            signed int tmp_if_expr$2;
            if(!(chantab == -1))
              tmp_if_expr$2 = (chanlists + (signed long int)chantab)->count;

            else
              tmp_if_expr$2 = 0;
            cur_channel = (cur_channel + 1) % tmp_if_expr$2;
            cur_fine = defaults.fine;
          }

          else
          {
            return_value_strcasecmp$7=strcasecmp(argv[(signed long int)0], "prev");
            if(return_value_strcasecmp$7 == 0)
            {
              signed int tmp_if_expr$3;
              if(!(chantab == -1))
                tmp_if_expr$3 = (chanlists + (signed long int)chantab)->count;

              else
                tmp_if_expr$3 = 0;
              signed int tmp_if_expr$4;
              if(!(chantab == -1))
                tmp_if_expr$4 = (chanlists + (signed long int)chantab)->count;

              else
                tmp_if_expr$4 = 0;
              cur_channel = ((cur_channel + tmp_if_expr$3) - 1) % tmp_if_expr$4;
              cur_fine = defaults.fine;
            }

            else
            {
              return_value_strcasecmp$6=strcasecmp(argv[(signed long int)0], "fine_up");
              if(return_value_strcasecmp$6 == 0)
                cur_fine = cur_fine + 1;

              else
              {
                return_value_strcasecmp$5=strcasecmp(argv[(signed long int)0], "fine_down");
                if(return_value_strcasecmp$5 == 0)
                  cur_fine = cur_fine - 1;

                else
                {
                  setchannel_handler$$1$$c=lookup_channel(argv[(signed long int)0]);
                  if(!(setchannel_handler$$1$$c == -1))
                  {
                    cur_channel = setchannel_handler$$1$$c;
                    cur_fine = defaults.fine;
                  }

                }
              }
            }
          }
          signed int return_value_strncmp$10;
          return_value_strncmp$10=strncmp(argv[(signed long int)0], "fine", (unsigned long int)4);
          if(!(return_value_strncmp$10 == 0))
          {
            i = 0;
            for( ; !(i >= count); i = i + 1)
              if(cur_channel == channels[(signed long int)i]->channel)
              {
                char *setchannel_handler$$1$$4$$6$$1$$1$$1$$argv[2l];
                setchannel_handler$$1$$4$$6$$1$$1$$1$$argv[(signed long int)0] = channels[(signed long int)i]->name;
                setchannel_handler$$1$$4$$6$$1$$1$$1$$argv[(signed long int)1] = (char *)(void *)0;
                signed int return_value_setstation_handler$9;
                return_value_setstation_handler$9=setstation_handler("", argc, setchannel_handler$$1$$4$$6$$1$$1$$1$$argv);
                return return_value_setstation_handler$9;
              }

          }

          cur_sender = -1;
          if(!(cur_channel == -1))
          {
            return_value_get_freq$11=get_freq(cur_channel);
            cur_freq = return_value_get_freq$11 + cur_fine;
          }

          else
          {
            cur_freq = cur_freq + cur_fine;
            cur_fine = 0;
          }
        }
        if(!(channel_switch_hook == ((void (*)(void))NULL)))
          channel_switch_hook();

        set_capture(0, 1);
        orig_mute = cur_attrs[(signed long int)4];
        if(orig_mute == 0)
          set_mute(1);

        if(!((4 & f_drv) == 0))
          drv->setfreq(h_drv, (unsigned long int)cur_freq);

        set_capture(defaults.capture, 0);
        set_title();
        if(!(setstation_notify == ((void (*)(void))NULL)))
          setstation_notify();

        if(orig_mute == 0)
        {
          usleep((unsigned int)20000);
          set_mute(0);
        }

        return 0;
      }
}

// setfreqtab_handler
// file common/commands.c line 763
static signed int setfreqtab_handler(char *name, signed int argc, char **argv)
{
  signed int i;
  if((4 & f_drv) == 0)
    return 0;

  else
  {
    i=str_to_int(argv[(signed long int)0], chanlist_names);
    if(!(i == -1))
      set_freqtab(i);

    else
      print_choices("freqtab", argv[(signed long int)0], chanlist_names);
    return 0;
  }
}

// setstation_handler
// file common/commands.c line 567
static signed int setstation_handler(char *name, signed int argc, char **argv)
{
  struct ng_attribute *attr;
  signed int i;
  signed int orig_mute;
  signed int return_value_strcasecmp$8;
  signed int return_value_strcasecmp$6;
  signed int return_value_strcasecmp$4;
  signed int return_value_strcasecmp$1;
  char *return_value_strcasestr$2;
  const unsigned short int **return_value___ctype_b_loc$3;
  if((4 & f_drv) == 0)
    return 0;

  else
    if(argc == 0)
    {
      set_title();
      return 0;
    }

    else
      if(!(cur_movie == 0))
      {
        if(!(display_message == ((void (*)(char *))NULL)))
          display_message("grabber busy");

        return -1;
      }

      else
      {
        _Bool tmp_if_expr$9;
        if(!(count == 0))
        {
          return_value_strcasecmp$8=strcasecmp(argv[(signed long int)0], "next");
          tmp_if_expr$9 = 0 == return_value_strcasecmp$8 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$9 = (_Bool)0;
        if(tmp_if_expr$9)
          i = (cur_sender + 1) % count;

        else
        {
          _Bool tmp_if_expr$7;
          if(!(count == 0))
          {
            return_value_strcasecmp$6=strcasecmp(argv[(signed long int)0], "prev");
            tmp_if_expr$7 = 0 == return_value_strcasecmp$6 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$7 = (_Bool)0;
          if(tmp_if_expr$7)
            i = ((cur_sender + count) - 1) % count;

          else
          {
            _Bool tmp_if_expr$5;
            if(!(count == 0))
            {
              return_value_strcasecmp$4=strcasecmp(argv[(signed long int)0], "back");
              tmp_if_expr$5 = 0 == return_value_strcasecmp$4 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$5 = (_Bool)0;
            if(tmp_if_expr$5)
            {
              if(last_sender == -1)
                return -1;

              i = last_sender;
            }

            else
            {
              i = 0;
              for( ; !(i >= count); i = i + 1)
              {
                return_value_strcasecmp$1=strcasecmp(channels[(signed long int)i]->name, argv[(signed long int)0]);
                if(return_value_strcasecmp$1 == 0)
                  break;

              }
              if(i == count)
              {
                i = 0;
                for( ; !(i >= count); i = i + 1)
                {
                  return_value_strcasestr$2=strcasestr(channels[(signed long int)i]->name, argv[(signed long int)0]);
                  if(!(return_value_strcasestr$2 == ((char *)NULL)))
                    break;

                }
              }

              if(i == count)
              {
                return_value___ctype_b_loc$3=__ctype_b_loc();
                if(!((2048 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*(*argv)]) == 0))
                  i=atoi(argv[(signed long int)0]);

              }

              if(i == count)
              {
                fprintf(stderr, "station \"%s\" not found\n", argv[(signed long int)0]);
                return -1;
              }

            }
          }
        }
        if(i >= count || !(i >= 0))
          return -1;

        else
        {
          if(!(channel_switch_hook == ((void (*)(void))NULL)))
            channel_switch_hook();

          set_capture(0, 1);
          orig_mute = cur_attrs[(signed long int)4];
          if(orig_mute == 0)
            set_mute(1);

          last_sender = cur_sender;
          cur_sender = i;
          attr=ng_attr_byid(attrs, 6);
          if(!(attr == ((struct ng_attribute *)NULL)))
            set_attr(attr, channels[(signed long int)i]->color);

          attr=ng_attr_byid(attrs, 7);
          if(!(attr == ((struct ng_attribute *)NULL)))
            set_attr(attr, channels[(signed long int)i]->bright);

          attr=ng_attr_byid(attrs, 8);
          if(!(attr == ((struct ng_attribute *)NULL)))
            set_attr(attr, channels[(signed long int)i]->hue);

          attr=ng_attr_byid(attrs, 9);
          if(!(attr == ((struct ng_attribute *)NULL)))
            set_attr(attr, channels[(signed long int)i]->contrast);

          if(!(cur_attrs[2l] == channels[(signed long int)i]->input))
          {
            attr=ng_attr_byid(attrs, 2);
            if(!(attr == ((struct ng_attribute *)NULL)))
              set_attr(attr, channels[(signed long int)i]->input);

          }

          if(!(cur_attrs[1l] == channels[(signed long int)i]->norm))
          {
            attr=ng_attr_byid(attrs, 1);
            if(!(attr == ((struct ng_attribute *)NULL)))
              set_attr(attr, channels[(signed long int)i]->norm);

          }

          cur_channel = channels[(signed long int)i]->channel;
          cur_fine = channels[(signed long int)i]->fine;
          cur_freq = channels[(signed long int)i]->freq;
          if(!((4 & f_drv) == 0))
            drv->setfreq(h_drv, (unsigned long int)channels[(signed long int)i]->freq);

          set_capture(channels[(signed long int)i]->capture, 0);
          set_title();
          if(!(setstation_notify == ((void (*)(void))NULL)))
            setstation_notify();

          if(orig_mute == 0)
          {
            usleep((unsigned int)20000);
            set_mute(0);
          }

          return 0;
        }
      }
}

// shape
// file common/vbi-sim.c line 10
static inline double shape(double ph)
{
  double x;
  x=sin(ph);
  return x * x;
}

// show_handler
// file common/commands.c line 909
static signed int show_handler(char *name, signed int argc, char **argv)
{
  struct ng_attribute *attr;
  char *n[2l] = { (char *)(void *)0, (char *)(void *)0 };
  signed int val;
  const char *return_value_ng_attr_getstr$1;
  if(argc == 0)
  {
    attr = attrs;
    for( ; !(attr->name == ((const char *)NULL)); attr = attr + 1l)
    {
      n[(signed long int)0] = (char *)attr->name;
      show_handler("show", 1, n);
    }
    return 0;
  }

  else
  {
    attr=ng_attr_byname(attrs, argv[(signed long int)0]);
    if(attr == ((struct ng_attribute *)NULL))
    {
      fprintf(stderr, "fixme: 404 %s\n", argv[(signed long int)0]);
      return 0;
    }

    else
    {
      val = cur_attrs[(signed long int)attr->id];
      switch(attr->type)
      {
        case 2:
        {
          return_value_ng_attr_getstr$1=ng_attr_getstr(attr, val);
          printf("%s: %s\n", attr->name, return_value_ng_attr_getstr$1);
          break;
        }
        case 1:
        {
          printf("%s: %d\n", attr->name, val);
          break;
        }
        case 3:
          printf("%s: %s\n", attr->name, val != 0 ? "on" : "off");
      }
      return 0;
    }
  }
}

// showtime_handler
// file common/commands.c line 1174
static signed int showtime_handler(char *name, signed int argc, char **argv)
{
  char timestr[6l];
  struct tm *times;
  signed long int timet;
  timet=time((signed long int *)(void *)0);
  times=localtime(&timet);
  strftime(timestr, (unsigned long int)6, "%k:%M", times);
  if(!(display_message == ((void (*)(char *))NULL)))
    display_message(timestr);

  return 0;
}

// snap_filename
// file ./libng/writefile.h line 2
char * snap_filename(char *base, char *channel, char *ext)
{
  signed long int now;
  struct tm *tm;
  char timestamp[32l];
  time(&now);
  tm=localtime(&now);
  static signed int snap_filename$$1$$count = 0;
  static signed long int last = (signed long int)0;
  if(!(last == now))
    snap_filename$$1$$count = 0;

  last = now;
  snap_filename$$1$$count = snap_filename$$1$$count + 1;
  static char *filename = (char *)(void *)0;
  if(!(filename == ((char *)NULL)))
    free((void *)filename);

  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(base);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(channel);
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(ext);
  void *return_value_malloc$4;
  return_value_malloc$4=malloc(return_value_strlen$1 + return_value_strlen$2 + return_value_strlen$3 + (unsigned long int)32);
  filename = (char *)return_value_malloc$4;
  strftime(timestamp, (unsigned long int)31, "%Y%m%d-%H%M%S", tm);
  sprintf(filename, "%s-%s-%s-%d.%s", base, channel, (const void *)timestamp, snap_filename$$1$$count, ext);
  return filename;
}

// snap_handler
// file common/commands.c line 1006
static signed int snap_handler(char *hname, signed int argc, char **argv)
{
  char message[512l];
  char *tmpfilename = (char *)(void *)0;
  char *filename = (char *)(void *)0;
  char *name;
  signed int jpeg = 0;
  signed int ret = 0;
  struct ng_video_fmt fmt;
  struct ng_video_buf *buf = (struct ng_video_buf *)(void *)0;
  signed int return_value_strcasecmp$4;
  signed int return_value_sscanf$3;
  unsigned long int return_value_strlen$7;
  void *return_value_malloc$8;
  signed int return_value_link$17;
  if((2 & f_drv) == 0)
  {
    fprintf(stderr, "grabbing: not supported [try -noxv switch?]\n");
    return -1;
  }

  else
    if(!(cur_movie == 0))
    {
      if(!(display_message == ((void (*)(char *))NULL)))
        display_message("grabber busy");

      return -1;
    }

    else
    {
      if(!(capture_get_hook == ((void (*)(void))NULL)))
        capture_get_hook();

      if(argc >= 1)
      {
        signed int return_value_strcasecmp$1;
        return_value_strcasecmp$1=strcasecmp(argv[(signed long int)0], "jpeg");
        if(return_value_strcasecmp$1 == 0)
          jpeg = 1;

        signed int return_value_strcasecmp$2;
        return_value_strcasecmp$2=strcasecmp(argv[(signed long int)0], "ppm");
        if(return_value_strcasecmp$2 == 0)
          jpeg = 0;

      }

      memset((void *)&fmt, 0, sizeof(struct ng_video_fmt) /*16ul*/ );
      fmt.fmtid = (unsigned int)9;
      fmt.width = (unsigned int)2048;
      fmt.height = (unsigned int)1572;
      if(argc >= 2)
      {
        signed int return_value_strcasecmp$5;
        return_value_strcasecmp$5=strcasecmp(argv[(signed long int)1], "full");
        if(!(return_value_strcasecmp$5 == 0))
        {
          return_value_strcasecmp$4=strcasecmp(argv[(signed long int)1], "win");
          if(return_value_strcasecmp$4 == 0)
          {
            fmt.width = cur_tv_width;
            fmt.height = cur_tv_height;
          }

          else
          {
            return_value_sscanf$3=sscanf(argv[(signed long int)1], "%dx%d", &fmt.width, &fmt.height);
            if(!(return_value_sscanf$3 == 2))
              return -1;

          }
        }

      }

      if(argc >= 3)
        filename = argv[(signed long int)2];

      buf=ng_grabber_get_image(&fmt);
      if(buf == ((struct ng_video_buf *)NULL))
      {
        if(!(display_message == ((void (*)(char *))NULL)))
          display_message("grabbing failed");

        ret = -1;
      }

      else
      {
        buf=ng_filter_single(cur_filter, buf);
        if(filename == ((char *)NULL))
        {
          if(!(cur_sender == -1))
            name = channels[(signed long int)cur_sender]->name;

          else
            if(!(cur_channel == -1))
            {
              struct CHANLIST *tmp_if_expr$6;
              if(!(chantab == -1))
                tmp_if_expr$6 = (chanlists + (signed long int)chantab)->list;

              else
                tmp_if_expr$6 = (struct CHANLIST *)(void *)0;
              name = (tmp_if_expr$6 + (signed long int)cur_channel)->name;
            }

            else
              name = "unknown";
          filename=snap_filename(snapbase, name, jpeg != 0 ? "jpeg" : "ppm");
        }

        return_value_strlen$7=strlen(filename);
        return_value_malloc$8=malloc(return_value_strlen$7 + (unsigned long int)8);
        tmpfilename = (char *)return_value_malloc$8;
        sprintf(tmpfilename, "%s.$$$", filename);
        if(!(jpeg == 0))
        {
          signed int return_value_write_jpeg$11;
          return_value_write_jpeg$11=write_jpeg(tmpfilename, buf, ng_jpeg_quality, 0);
          if(return_value_write_jpeg$11 == -1)
          {
            signed int *return_value___errno_location$9;
            return_value___errno_location$9=__errno_location();
            char *return_value_strerror$10;
            return_value_strerror$10=strerror(*return_value___errno_location$9);
            sprintf(message, "open %s: %s\n", tmpfilename, return_value_strerror$10);
          }

          else
            sprintf(message, "saved jpeg: %s", filename);
        }

        else
        {
          signed int return_value_write_ppm$14;
          return_value_write_ppm$14=write_ppm(tmpfilename, buf);
          if(return_value_write_ppm$14 == -1)
          {
            signed int *return_value___errno_location$12;
            return_value___errno_location$12=__errno_location();
            char *return_value_strerror$13;
            return_value_strerror$13=strerror(*return_value___errno_location$12);
            sprintf(message, "open %s: %s\n", tmpfilename, return_value_strerror$13);
          }

          else
            sprintf(message, "saved ppm: %s", filename);
        }
        unlink(filename);
        return_value_link$17=link(tmpfilename, filename);
        if(return_value_link$17 == -1)
        {
          signed int *return_value___errno_location$15;
          return_value___errno_location$15=__errno_location();
          char *return_value_strerror$16;
          return_value_strerror$16=strerror(*return_value___errno_location$15);
          fprintf(stderr, "link(%s,%s): %s\n", tmpfilename, filename, return_value_strerror$16);
          goto done;
        }

        unlink(tmpfilename);
        if(!(display_message == ((void (*)(char *))NULL)))
          display_message(message);

      }

    done:
      ;
      if(!(tmpfilename == ((char *)NULL)))
        free((void *)tmpfilename);

      if(!(buf == ((struct ng_video_buf *)NULL)))
        ng_release_video_buf(buf);

      if(!(capture_rel_hook == ((void (*)(void))NULL)))
        capture_rel_hook();

      return ret;
    }
}

// sort_media_device_entry
// file common/get_media_devices.c line 299
static signed int sort_media_device_entry(const void *a, const void *b)
{
  struct media_device_entry *md_a = (struct media_device_entry *)a;
  struct media_device_entry *md_b = (struct media_device_entry *)b;
  signed int cmp;
  cmp=strcmp(md_a->device, md_b->device);
  if(!(cmp == 0))
    return cmp;

  else
  {
    cmp = (signed int)md_a->type - (signed int)md_b->type;
    if(!(cmp == 0))
      return cmp;

    else
    {
      signed int return_value_strcmp$1;
      return_value_strcmp$1=strcmp(md_a->node, md_b->node);
      return return_value_strcmp$1;
    }
  }
}

// split_cmdline
// file common/commands.c line 272
char ** split_cmdline(char *line, signed int *count)
{
  signed int argc;
  signed int i;
  static char cmdline[1024l];
  strcpy(cmdline, line);
  argc = 0;
  i = 0;
  static char *argv[32l];
  while(!(argc >= 31))
  {
    signed int tmp_post$1 = argc;
    argc = argc + 1;
    argv[(signed long int)tmp_post$1] = cmdline + (signed long int)i;
    for( ; !((signed int)cmdline[(signed long int)i] == 32); i = i + 1)
    {
      if((signed int)cmdline[(signed long int)i] == 9)
        break;

      if((signed int)cmdline[(signed long int)i] == 0)
        break;

    }
    if((signed int)cmdline[(signed long int)i] == 0)
      break;

    signed int tmp_post$2 = i;
    i = i + 1;
    cmdline[(signed long int)tmp_post$2] = (char)0;
    for( ; (_Bool)1; i = i + 1)
      if(!((signed int)cmdline[(signed long int)i] == 32))
      {
        if(!((signed int)cmdline[(signed long int)i] == 9))
          goto __CPROVER_DUMP_L6;

      }


  __CPROVER_DUMP_L6:
    ;
    if((signed int)cmdline[(signed long int)i] == 0)
      break;

  }
  argv[(signed long int)argc] = (char *)(void *)0;
  *count = argc;
  return argv;
}

// str_to_int
// file common/channel.c line 739
signed int str_to_int(char *str, struct STRTAB *tab)
{
  signed int i;
  signed int return_value_atoi$1;
  if((signed int)*str >= 48)
  {
    if(!((signed int)*str >= 58))
    {
      return_value_atoi$1=atoi(str);
      return return_value_atoi$1;
    }

  }

  i = 0;
  signed int return_value_strcasecmp$2;
  for( ; !((tab + (signed long int)i)->str == ((const char *)NULL)); i = i + 1)
  {
    return_value_strcasecmp$2=strcasecmp(str, (tab + (signed long int)i)->str);
    if(return_value_strcasecmp$2 == 0)
      return (signed int)(tab + (signed long int)i)->nr;

  }
  return -1;
}

// strfamily
// file common/commands.c line 1198
static char * strfamily(signed int family)
{
  switch(family)
  {
    case 10:
      return "ipv6";
    case 2:
      return "ipv4";
    case 1:
      return "unix";
    default:
      return "????";
  }
}

// tcp_connect
// file common/commands.c line 1209
static signed int tcp_connect(struct addrinfo *ai, char *host, char *serv)
{
  struct addrinfo *res;
  struct addrinfo *e;
  char uhost[47l];
  char userv[33l];
  signed int sock;
  signed int rc;
  signed int opt = 1;
  ai->ai_flags = 0x0002;
  if(!(debug == 0))
    fprintf(stderr, "tcp: lookup %s:%s ... ", host, serv);

  rc=getaddrinfo(host, serv, ai, &res);
  if(!(rc == 0))
  {
    const char *return_value_gai_strerror$1;
    return_value_gai_strerror$1=gai_strerror(rc);
    fprintf(stderr, "tcp: getaddrinfo (%s:%s): %s\n", host, serv, return_value_gai_strerror$1);
    return -1;
  }

  if(!(debug == 0))
    fprintf(stderr, "ok\n");

  e = res;
  char *return_value_strfamily$3;
  for( ; !(e == ((struct addrinfo *)NULL)); e = e->ai_next)
  {
    signed int return_value_getnameinfo$2;
    return_value_getnameinfo$2=getnameinfo((struct sockaddr *)e->ai_addr, e->ai_addrlen, uhost, (unsigned int)46, userv, (unsigned int)32, 1 | 2);
    if(!(return_value_getnameinfo$2 == 0))
      fprintf(stderr, "tcp: getnameinfo (peer): oops\n");

    else
    {
      if(!(debug == 0))
      {
        return_value_strfamily$3=strfamily(e->ai_family);
        fprintf(stderr, "tcp: trying %s (%s:%s) ... ", return_value_strfamily$3, (const void *)uhost, (const void *)userv);
      }

      sock=socket(e->ai_family, e->ai_socktype, e->ai_protocol);
      if(sock == -1)
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        char *return_value_strerror$5;
        return_value_strerror$5=strerror(*return_value___errno_location$4);
        fprintf(stderr, "tcp: socket: %s\n", return_value_strerror$5);
        goto __CPROVER_DUMP_L10;
      }

      setsockopt(sock, 1, 2, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
      signed int return_value_connect$8;
      return_value_connect$8=connect(sock, e->ai_addr, e->ai_addrlen);
      if(return_value_connect$8 == -1)
      {
        signed int *return_value___errno_location$6;
        return_value___errno_location$6=__errno_location();
        char *return_value_strerror$7;
        return_value_strerror$7=strerror(*return_value___errno_location$6);
        fprintf(stderr, "tcp: connect: %s\n", return_value_strerror$7);
        close(sock);
        goto __CPROVER_DUMP_L10;
      }

      if(!(debug == 0))
        fprintf(stderr, "ok\n");

      fcntl(sock, 4, 04000);
      fcntl(sock, 2, 1);
      return sock;
    }

  __CPROVER_DUMP_L10:
    ;
  }
  return -1;
}

// tcp_readbuf
// file common/commands.c line 1256
static signed int tcp_readbuf(signed int sock, signed int timeout, char *dest, char dlen)
{
  struct timeval tv;
  struct anonymous$94 set;
  signed int rc;
  signed int *return_value___errno_location$1;
  do
  {

  again:
    ;
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$94) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&set)->fds_bits[(signed long int)0]) : "memory");
    (&set)->fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&set)->fds_bits[(signed long int)(sock / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << sock % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    tv.tv_sec = (signed long int)timeout;
    tv.tv_usec = (signed long int)0;
    rc=select(sock + 1, &set, (struct anonymous$94 *)(void *)0, (struct anonymous$94 *)(void *)0, &tv);
    if(!(rc == -1))
      goto __CPROVER_DUMP_L2;

    return_value___errno_location$1=__errno_location();
  }
  while(*return_value___errno_location$1 == 4);

__CPROVER_DUMP_L2:
  ;
  if(rc == -1)
  {
    if(!(debug == 0))
      perror("tcp: select");

    return -1;
  }

  else
    if(rc == 0)
    {
      if(!(debug == 0))
        fprintf(stderr, "tcp: select timeout\n");

      return -1;
    }

    else
    {
      signed long int return_value_read$2;
      return_value_read$2=read(sock, (void *)dest, (unsigned long int)((signed int)dlen - 1));
      rc = (signed int)return_value_read$2;
      if(rc == -1)
      {
        if(!(debug == 0))
          perror("tcp: read");

        return -1;
      }

      else
      {
        dest[(signed long int)rc] = (char)0;
        return rc;
      }
    }
}

// ttx_next
// file common/vbi-sim.c line 209
static unsigned char * ttx_next(void)
{
  signed int i;
  static unsigned char buf[45l];
  buf[(signed long int)0] = (unsigned char)0x55;
  buf[(signed long int)1] = (unsigned char)0x55;
  buf[(signed long int)2] = (unsigned char)0x27;
  signed int return_value_odd$1;
  signed int return_value_odd$2;
  signed int return_value_odd$3;
  static unsigned char s5[10l][42l] = { { (unsigned char)0x02, (unsigned char)0x2f, (unsigned char)0x97, (unsigned char)0x20, (unsigned char)0x37, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0xb5, (unsigned char)0x20 },
    { (unsigned char)0xc7, (unsigned char)0x2f, (unsigned char)0x97, (unsigned char)0x0d, (unsigned char)0xb5, (unsigned char)0x04, (unsigned char)0x20, (unsigned char)0x9d, (unsigned char)0x83, (unsigned char)0x8c, (unsigned char)0x08, (unsigned char)0x2a, (unsigned char)0x2a, (unsigned char)0x2a, (unsigned char)0x89, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x0d, (unsigned char)0x54, (unsigned char)0x45, (unsigned char)0xd3, (unsigned char)0x54, (unsigned char)0x20, (unsigned char)0xd0, (unsigned char)0xc1, (unsigned char)0xc7, (unsigned char)0x45, (unsigned char)0x8c, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x08, (unsigned char)0x2a, (unsigned char)0x2a, (unsigned char)0x2a, (unsigned char)0x89, (unsigned char)0x0d, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x1c, (unsigned char)0x97, (unsigned char)0xb5, (unsigned char)0x20 },
    { (unsigned char)0x02, (unsigned char)0xd0, (unsigned char)0x97, (unsigned char)0x20, (unsigned char)0xb5, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0xea, (unsigned char)0x20 },
    { (unsigned char)0xc7, (unsigned char)0xd0, (unsigned char)0x97, (unsigned char)0x20, (unsigned char)0xb5, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0xb5, (unsigned char)0x20 },
    { (unsigned char)0x02, (unsigned char)0xc7, (unsigned char)0x97, (unsigned char)0x20, (unsigned char)0xb5, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x15, (unsigned char)0x1a, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x2c, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x97, (unsigned char)0x19, (unsigned char)0xb5, (unsigned char)0x20 },
    { (unsigned char)0xc7, (unsigned char)0xc7, (unsigned char)0x97, (unsigned char)0x20, (unsigned char)0xb5, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0xb5, (unsigned char)0x20 },
    { (unsigned char)0x02, (unsigned char)0x8c, (unsigned char)0x97, (unsigned char)0x9e, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x13, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x16, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x92, (unsigned char)0x7f, (unsigned char)0x92, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x15, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x15, (unsigned char)0x7f, (unsigned char)0x91, (unsigned char)0x91, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x91, (unsigned char)0x94, (unsigned char)0x7f, (unsigned char)0x94, (unsigned char)0x7f, (unsigned char)0x94, (unsigned char)0x97, (unsigned char)0xb5, (unsigned char)0x20 },
    { (unsigned char)0xc7, (unsigned char)0x8c, (unsigned char)0x97, (unsigned char)0x9e, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x13, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x16, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x92, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x15, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x91, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x94, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x97, (unsigned char)0xb5, (unsigned char)0x20 },
    { (unsigned char)0x02, (unsigned char)0x9b, (unsigned char)0x97, (unsigned char)0x9e, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x13, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x16, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x92, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x15, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x91, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x94, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x7f, (unsigned char)0x97, (unsigned char)0xb5, (unsigned char)0x20 },
    { (unsigned char)0xc7, (unsigned char)0x9b, (unsigned char)0x97, (unsigned char)0x20, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0x23, (unsigned char)0xa1, (unsigned char)0x20 } };
  static signed int row = 0;
  if(row == 0)
  {
    static signed int page = 0;
    static unsigned char s1[2l][10l] = { { (unsigned char)0x02, (unsigned char)0x15, (unsigned char)0x15, (unsigned char)0x15, (unsigned char)0x15, (unsigned char)0x15, (unsigned char)0x15, (unsigned char)0x15, (unsigned char)0x15, (unsigned char)0x15 },
    { (unsigned char)0x02, (unsigned char)0x15, (unsigned char)0x02, (unsigned char)0x15, (unsigned char)0x15, (unsigned char)0x15, (unsigned char)0x15, (unsigned char)0x15, (unsigned char)0x15, (unsigned char)0x15 } };
    memcpy((void *)(buf + (signed long int)3), (const void *)s1[(signed long int)page], (unsigned long int)10);
    page = page ^ 1;
    i = 0;
    for( ; !(i >= 32); i = i + 1)
    {
      static unsigned char s2[32l] = { '1', '0', '0', 2, 'L', 'I', 'B', 'Z', 'V', 'B', 'I', 7, ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '0', '0', ':', '0', '0', ':', '0', '0' };
      return_value_odd$1=odd((signed int)s2[(signed long int)i]);
      buf[(signed long int)(13 + i)] = (unsigned char)return_value_odd$1;
    }
  }

  else
    if(row == 1)
    {
      buf[(signed long int)3] = (unsigned char)0x02;
      buf[(signed long int)4] = (unsigned char)0x02;
      i = 0;
      for( ; !(i >= 40); i = i + 1)
      {
        static unsigned char s3[40l] = { ' ', ' ', 'L', 'I', 'B', 'Z', 'V', 'B', 'I', ' ', 'T', 'E', 'L', 'E', 'T', 'E', 'X', 'T', ' ', 'S', 'I', 'M', 'U', 'L', 'A', 'T', 'I', 'O', 'N', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
        return_value_odd$2=odd((signed int)s3[(signed long int)i]);
        buf[(signed long int)(5 + i)] = (unsigned char)return_value_odd$2;
      }
    }

    else
      if(row == 2)
      {
        buf[(signed long int)3] = (unsigned char)0x02;
        buf[(signed long int)4] = (unsigned char)0x49;
        i = 0;
        for( ; !(i >= 40); i = i + 1)
        {
          static unsigned char s4[40l] = { ' ', ' ', 'P', 'a', 'g', 'e', ' ', '1', '0', '0', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
          return_value_odd$3=odd((signed int)s4[(signed long int)i]);
          buf[(signed long int)(5 + i)] = (unsigned char)return_value_odd$3;
        }
      }

      else
        memcpy((void *)(buf + (signed long int)3), (const void *)s5[(signed long int)(row - 3)], (unsigned long int)42);
  row = row + 1;
  if(row >= 13)
    row = 0;

  return buf;
}

// ttx_sim
// file common/vbi-sim.c line 147
static inline double ttx_sim(double t, double F, const unsigned char *text)
{
  double t1 = 10.3e-6 - .5 / F;
  double t2 = t1 + (double)(45 * 8 + 1) / F;
  double ph;
  if(t < t1)
    return 0.0;

  else
    if(t < t2)
    {
      signed int i;
      signed int j;
      signed int n;
      t = t - t1;
      i = (signed int)(t * F);
      j = i >> 3;
      i = i & 7;
      if(j == 0)
        n = (signed int)text[(signed long int)0] * 2 >> i & 3;

      else
        n = ((signed int)text[(signed long int)(j - 1)] >> 7) + (signed int)text[(signed long int)j] * 2 >> i & 3;
      if(n == 0)
        return 0.0;

      else
        if(n == 3)
          return 1.0;

        else
          if(!(((i ^ n) & 1) == 0))
          {
            ph = (3.14159265358979323846 * (double)2 * (t - (double)1 / F) * F) / (double)4;
            double return_value_shape$1;
            return_value_shape$1=shape(ph);
            return return_value_shape$1;
          }

          else
          {
            ph = (3.14159265358979323846 * (double)2 * (t - (double)0 / F) * F) / (double)4;
            double return_value_shape$2;
            return_value_shape$2=shape(ph);
            return return_value_shape$2;
          }
    }

    else
      return 0.0;
}

// tty_clear
// file console/vbi-tty.c line 57
static void tty_clear(void)
{
  fprintf(stderr, "\033[H\033[2J");
}

// tty_goto
// file console/vbi-tty.c line 62
static void tty_goto(signed int x, signed int y)
{
  fprintf(stderr, "\033[%d;%dH", y, x);
}

// tty_raw
// file console/vbi-tty.c line 33
static void tty_raw(void)
{
  struct termios tattr;
  fcntl(0, 3, &saved_fl);
  tcgetattr(0, &saved_attributes);
  fcntl(0, 4, 04000);
  memcpy((void *)&tattr, (const void *)&saved_attributes, sizeof(struct termios) /*60ul*/ );
  tattr.c_lflag = tattr.c_lflag & (unsigned int)~(0000002 | 0000010);
  tattr.c_cc[(signed long int)6] = (unsigned char)1;
  tattr.c_cc[(signed long int)5] = (unsigned char)0;
  tcsetattr(0, 2, &tattr);
}

// tty_restore
// file console/vbi-tty.c line 48
static void tty_restore(void)
{
  fcntl(0, 4, saved_fl);
  tcsetattr(0, 0, &saved_attributes);
}

// update_int
// file common/commands.c line 441
static signed int update_int(struct ng_attribute *attr, signed int old, char *new)
{
  signed int value = old;
  signed int step = ((attr->max - attr->min) * 3) / 100;
  if(step == 0)
    step = 1;

  signed int return_value_strcasecmp$9;
  return_value_strcasecmp$9=strcasecmp(new, "inc");
  signed int return_value_strcasecmp$8;
  signed int return_value_strncasecmp$7;
  signed int return_value_ng_attr_parse_int$1;
  signed int return_value_strncasecmp$6;
  signed int return_value_ng_attr_parse_int$2;
  const unsigned short int **return_value___ctype_b_loc$3;
  if(return_value_strcasecmp$9 == 0)
    value = value + step;

  else
  {
    return_value_strcasecmp$8=strcasecmp(new, "dec");
    if(return_value_strcasecmp$8 == 0)
      value = value - step;

    else
    {
      return_value_strncasecmp$7=strncasecmp(new, "+=", (unsigned long int)2);
      if(return_value_strncasecmp$7 == 0)
      {
        return_value_ng_attr_parse_int$1=ng_attr_parse_int(attr, new + (signed long int)2);
        value = value + return_value_ng_attr_parse_int$1;
      }

      else
      {
        return_value_strncasecmp$6=strncasecmp(new, "-=", (unsigned long int)2);
        if(return_value_strncasecmp$6 == 0)
        {
          return_value_ng_attr_parse_int$2=ng_attr_parse_int(attr, new + (signed long int)2);
          value = value - return_value_ng_attr_parse_int$2;
        }

        else
        {
          return_value___ctype_b_loc$3=__ctype_b_loc();
          _Bool tmp_if_expr$4;
          if(!((2048 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*new]) == 0))
            tmp_if_expr$4 = (_Bool)1;

          else
            tmp_if_expr$4 = 43 == (signed int)new[(signed long int)0] ? (_Bool)1 : (_Bool)0;
          _Bool tmp_if_expr$5;
          if(tmp_if_expr$4)
            tmp_if_expr$5 = (_Bool)1;

          else
            tmp_if_expr$5 = 45 == (signed int)new[(signed long int)0] ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$5)
            value=ng_attr_parse_int(attr, new);

          else
            fprintf(stderr, "update_int: can't parse %s\n", new);
        }
      }
    }
  }
  if(!(value >= attr->min))
    value = attr->min;

  if(!(attr->max >= value))
    value = attr->max;

  return value;
}

// usage
// file x11/mtt.c line 131
static void usage(void)
{
  fprintf(stderr, "\nmtt -- teletext application\n\nusage: mtt [ options ]\noptions:\n  -help         print this text\n  -debug        enable debug messages\n  -device <dev> use vbi device <dev> instead of /dev/vbi0\n  -tty          use terminal mode\n\n--\nGerd Knorr <kraxel@bytesex.org>\n");
}

// vbi_calc_page
// file ./common/vbi-data.h line 38
signed int vbi_calc_page(signed int pagenr, signed int offset)
{
  signed int result = pagenr + offset;
  if(!(offset >= 0))
  {
    for( ; (0x0f & result) >= 10; result = result - 0x01)
      ;
    for( ; (0xf0 & result) >= 145; result = result - 0x10)
      ;
    if(!(result >= 0x100))
      result = 0x100;

  }

  if(offset >= 1)
  {
    for( ; (0x0f & result) >= 10; result = result + 0x01)
      ;
    for( ; (0xf0 & result) >= 145; result = result + 0x10)
      ;
    if(result >= 2202)
      result = 0x899;

  }

  return result;
}

// vbi_calc_subpage
// file ./common/vbi-data.h line 39
signed int vbi_calc_subpage(struct vbi_decoder *dec, signed int pgno, signed int subno, signed int offset)
{
  struct vbi_page pg;
  signed int newno = subno + offset;
  while(!(newno == subno))
  {
    signed int return_value_vbi_fetch_vt_page$1;
    return_value_vbi_fetch_vt_page$1=vbi_fetch_vt_page(dec, &pg, pgno, newno, (enum anonymous)VBI_WST_LEVEL_1, 0, 0);
    if(!(return_value_vbi_fetch_vt_page$1 == 0))
      break;

    if(!(offset >= 0))
    {
      newno = newno - 1;
      if(!(newno >= 0))
        newno = newno + 64;

      for( ; (0x0f & newno) >= 10; newno = newno - 0x01)
        ;
    }

    if(offset >= 1)
    {
      newno = newno + 1;
      for( ; (0x0f & newno) >= 10; newno = newno + 0x01)
        ;
      if(newno >= 64)
        newno = 0;

    }

  }
  return newno;
}

// vbi_check_rectangle
// file x11/vbi-gui.c line 109
static void vbi_check_rectangle(struct vbi_rect *rect)
{
  signed int h;
  if(!(rect->x2 >= rect->x1))
  {
    h = rect->x1;
    rect->x1 = rect->x2;
    rect->x2 = h;
  }

  if(!(rect->y2 >= rect->y1))
  {
    h = rect->y1;
    rect->y1 = rect->y2;
    rect->y2 = h;
  }

  if(!(rect->x1 >= 0))
    rect->x1 = 0;

  if(!(rect->x2 >= 0))
    rect->x2 = 0;

  if(!(rect->y1 >= 0))
    rect->y1 = 0;

  if(!(rect->y2 >= 0))
    rect->y2 = 0;

  if(rect->x1 >= 42)
    rect->x1 = 41;

  if(rect->x2 >= 42)
    rect->x2 = 41;

  if(rect->y1 >= 26)
    rect->y1 = 25;

  if(rect->y2 >= 26)
    rect->y2 = 25;

}

// vbi_close
// file common/vbi-data.c line 138
void vbi_close(struct vbi_state *vbi)
{
  if(!(vbi == ((struct vbi_state *)NULL)))
  {
    if(!(vbi->sliced == ((struct anonymous$15 *)NULL)))
      free((void *)vbi->sliced);

    if(!(vbi->raw == ((unsigned char *)NULL)))
      free((void *)vbi->raw);

    if(!(vbi->cap == ((struct vbi_capture *)NULL)))
      vbi_capture_delete(vbi->cap);

    if(!(vbi->dec == ((struct vbi_decoder *)NULL)))
      vbi_decoder_delete(vbi->dec);

    free((void *)vbi);
  }

}

// vbi_close_cb
// file x11/vbi-gui.c line 290
static void vbi_close_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  struct vbi_window *vw = (struct vbi_window *)clientdata;
  XtDestroyWidget(vw->shell);
}

// vbi_create_widgets
// file x11/vbi-gui.h line 1
void vbi_create_widgets(struct _WidgetRec *shell, struct vbi_state *vbi)
{
  struct _WidgetRec *form;
  struct _WidgetRec *menubar;
  struct _WidgetRec *tool;
  struct _WidgetRec *menu;
  struct _WidgetRec *push;
  struct _WidgetRec *tt;
  struct vbi_window *vw;
  signed int i;
  XtVaSetValues(shell, (char *)&XtShellStrings[(signed long int)280], 1, (void *)0);
  form=XtVaCreateManagedWidget("form", xmFormWidgetClass, shell, (void *)0);
  menubar=XmCreateMenuBar(form, "bar", (struct anonymous$1 *)(void *)0, (unsigned int)0);
  XtManageChild(menubar);
  tool=XtVaCreateManagedWidget("tool", xmRowColumnWidgetClass, form, (void *)0);
  tt=XtVaCreateManagedWidget("tt", xmDrawingAreaWidgetClass, form, (void *)0);
  vw=vbi_render_init(shell, tt, vbi);
  XtVaSetValues(tt, (char *)&XtStrings[(signed long int)872], vw->w * 41, (char *)&XtStrings[(signed long int)234], vw->h * 25, (void *)0);
  XtAddEventHandler(tt, (unsigned long int)(1L << 0), (char)0, vbi_kbd_eh, (void *)vw);
  XtAddEventHandler(tt, (unsigned long int)(1L << 2 | 1L << 3 | 1L << 8), (char)0, vbi_mouse_eh, (void *)vw);
  XtAddCallback(tt, (char *)&_XmStrings[(signed long int)6711], vbi_expose_cb, (void *)vw);
  XtAddCallback(tt, (char *)&XtStrings[(signed long int)169], vbi_destroy_cb, (void *)vw);
  XtAddCallback(tt, (char *)&_XmStrings[(signed long int)12699], selection_convert_cb, (void *)vw);
  vbi_event_handler_register(vw->vbi->dec, ~0, vbi_newdata, (void *)vw);
  menu=XmCreatePulldownMenu(menubar, "fileM", (struct anonymous$1 *)(void *)0, (unsigned int)0);
  XtVaCreateManagedWidget("file", xmCascadeButtonWidgetClass, menubar, (char *)&_XmStrings[(signed long int)9963], menu, (void *)0);
  push=XtVaCreateManagedWidget("new", xmPushButtonWidgetClass, menu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], vbi_new_cb, (void *)vw);
  push=XtVaCreateManagedWidget("save", xmPushButtonWidgetClass, menu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], export_save_cb, (void *)vw);
  XtVaCreateManagedWidget("sep", xmSeparatorWidgetClass, menu, (void *)0);
  push=XtVaCreateManagedWidget("quit", xmPushButtonWidgetClass, menu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], vbi_close_cb, (void *)vw);
  menu=XmCreatePulldownMenu(menubar, "editM", (struct anonymous$1 *)(void *)0, (unsigned int)0);
  XtVaCreateManagedWidget("edit", xmCascadeButtonWidgetClass, menubar, (char *)&_XmStrings[(signed long int)9963], menu, (void *)0);
  push=XtVaCreateManagedWidget("copy", xmPushButtonWidgetClass, menu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], selection_clip_cb, (void *)vw);
  menu=XmCreatePulldownMenu(menubar, "goM", (struct anonymous$1 *)(void *)0, (unsigned int)0);
  XtVaCreateManagedWidget("go", xmCascadeButtonWidgetClass, menubar, (char *)&_XmStrings[(signed long int)9963], menu, (void *)0);
  push=XtVaCreateManagedWidget("100", xmPushButtonWidgetClass, menu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], vbi_goto_cb, (void *)vw);
  push=XtVaCreateManagedWidget("prev", xmPushButtonWidgetClass, menu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], vbi_goto_cb, (void *)vw);
  push=XtVaCreateManagedWidget("next", xmPushButtonWidgetClass, menu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], vbi_goto_cb, (void *)vw);
  vw->submenu=XmCreatePulldownMenu(menubar, "subpageM", (struct anonymous$1 *)(void *)0, (unsigned int)0);
  vw->subbtn=XtVaCreateManagedWidget("subpage", xmCascadeButtonWidgetClass, menubar, (char *)&_XmStrings[(signed long int)9963], vw->submenu, (void *)0);
  vbi_station_menu(menubar, vbi);
  menu=XmCreatePulldownMenu(menubar, "fontM", (struct anonymous$1 *)(void *)0, (unsigned int)0);
  XtVaCreateManagedWidget("font", xmCascadeButtonWidgetClass, menubar, (char *)&_XmStrings[(signed long int)9963], menu, (void *)0);
  i = 0;
  for( ; !(vbi_fonts[(signed long int)i].label == ((char *)NULL)); i = i + 1)
  {
    push=XtVaCreateManagedWidget(vbi_fonts[(signed long int)i].label, xmPushButtonWidgetClass, menu, (void *)0);
    XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], vbi_font_cb, (void *)vw);
  }
  vbi_xft_font_menu(menu, vw);
  push=XtVaCreateManagedWidget("100", xmPushButtonWidgetClass, tool, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], vbi_goto_cb, (void *)vw);
  XtAddEventHandler(push, (unsigned long int)(1L << 0), (char)0, vbi_kbd_eh, (void *)vw);
  push=XtVaCreateManagedWidget("prev", xmPushButtonWidgetClass, tool, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], vbi_goto_cb, (void *)vw);
  XtAddEventHandler(push, (unsigned long int)(1L << 0), (char)0, vbi_kbd_eh, (void *)vw);
  push=XtVaCreateManagedWidget("next", xmPushButtonWidgetClass, tool, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], vbi_goto_cb, (void *)vw);
  XtAddEventHandler(push, (unsigned long int)(1L << 0), (char)0, vbi_kbd_eh, (void *)vw);
  XtVaCreateManagedWidget("sep", xmSeparatorWidgetClass, tool, (void *)0);
  push=XtVaCreateManagedWidget("exit", xmPushButtonWidgetClass, tool, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], vbi_close_cb, (void *)vw);
  XtAddEventHandler(push, (unsigned long int)(1L << 0), (char)0, vbi_kbd_eh, (void *)vw);
  XtAddEventHandler(shell, (unsigned long int)0, (char)1, (void (*)(struct _WidgetRec *, void *, union _XEvent *, char *))_XEditResCheckMessages, (void *)0);
  struct _XDisplay *return_value_XtDisplay$1;
  return_value_XtDisplay$1=XtDisplay(shell);
  unsigned long int return_value_XInternAtom$2;
  return_value_XInternAtom$2=XInternAtom(return_value_XtDisplay$1, "WM_PROTOCOLS", 0);
  XmAddProtocolCallback(shell, return_value_XInternAtom$2, WM_DELETE_WINDOW, vbi_close_cb, (void *)vw);
  vbi_setpage(vw, 0x100, 0x3F7F);
  tt_windows = tt_windows + 1;
}

// vbi_data
// file x11/mtt.c line 148
static void vbi_data(void *data, signed int *fd, unsigned long int *iproc)
{
  struct vbi_state *vbi = (struct vbi_state *)data;
  vbi_hasdata(vbi);
}

// vbi_destroy_cb
// file x11/vbi-gui.c line 276
static void vbi_destroy_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  struct vbi_window *vw = (struct vbi_window *)clientdata;
  vbi_event_handler_unregister(vw->vbi->dec, vbi_newdata, (void *)vw);
  vbi_render_free_font(widget, vw);
  struct _XDisplay *return_value_XtDisplay$1;
  return_value_XtDisplay$1=XtDisplay(widget);
  XFreeGC(return_value_XtDisplay$1, vw->gc);
  free((void *)vw);
  tt_windows = tt_windows - 1;
  if(tt_windows == 0)
    exit(0);

}

// vbi_dump_event
// file ./common/vbi-data.h line 36
void vbi_dump_event(struct vbi_event *ev, void *user)
{
  switch(ev->type)
  {
    case 0x0002:
    {
      fprintf(stderr, "vbi ev: ttx page %03x.%02x \r", ev->ev.ttx_page.pgno, ev->ev.ttx_page.subno);
      break;
    }
    case 0x0001:
    {
      fprintf(stderr, "vbi ev: close \n");
      break;
    }
    case 0x0004:
    {
      fprintf(stderr, "vbi ev: caption \n");
      break;
    }
    case 0x0008:
    {
      fprintf(stderr, "vbi ev: network id=%d name=\"%s\" call=\"%s\"\n", ev->ev.network.nuid, (const void *)ev->ev.network.name, (const void *)ev->ev.network.call);
      break;
    }
    case 0x0010:
    {
      switch((signed int)ev->ev.trigger->type)
      {
        case VBI_LINK_NONE:
        {
          fprintf(stderr, "vbi ev: trigger none \n");
          break;
        }
        case VBI_LINK_MESSAGE:
        {
          fprintf(stderr, "vbi ev: trigger message \n");
          break;
        }
        case VBI_LINK_PAGE:
        {
          fprintf(stderr, "vbi ev: trigger page [%03x.%02x]\n", ev->ev.trigger->pgno, ev->ev.trigger->subno);
          break;
        }
        case VBI_LINK_SUBPAGE:
        {
          fprintf(stderr, "vbi ev: trigger subpage \n");
          break;
        }
        case VBI_LINK_HTTP:
        {
          fprintf(stderr, "vbi ev: trigger http [%s]\n", (const void *)ev->ev.trigger->url);
          break;
        }
        case VBI_LINK_FTP:
        {
          fprintf(stderr, "vbi ev: trigger ftp \n");
          break;
        }
        case VBI_LINK_EMAIL:
        {
          fprintf(stderr, "vbi ev: trigger email \n");
          break;
        }
        case VBI_LINK_LID:
        {
          fprintf(stderr, "vbi ev: trigger lid \n");
          break;
        }
        case VBI_LINK_TELEWEB:
          fprintf(stderr, "vbi ev: trigger teleweb \n");
      }
      break;
    }
    case 0x0040:
    {
      fprintf(stderr, "vbi ev: aspect \n");
      break;
    }
    case 0x0080:
    {
      fprintf(stderr, "vbi ev: prog info \n");
      break;
    }
    default:
      fprintf(stderr, "vbi ev: UNKNOWN[0x%x] \n", ev->type);
  }
}

// vbi_export_pixmap
// file x11/vbi-x11.c line 256
unsigned long int vbi_export_pixmap(struct vbi_window *vw, struct vbi_page *pg, struct vbi_rect *rect)
{
  unsigned long int pix;
  struct vbi_char *ch;
  signed int y;
  struct _XDisplay *return_value_XtDisplay$1;
  return_value_XtDisplay$1=XtDisplay(vw->tt);
  unsigned long int return_value_XtWindow$2;
  return_value_XtWindow$2=XtWindow(vw->tt);
  struct anonymous$96 *return_value_XtScreen$3;
  return_value_XtScreen$3=XtScreen(vw->tt);
  pix=XCreatePixmap(return_value_XtDisplay$1, return_value_XtWindow$2, (unsigned int)(vw->w * (rect->x2 - rect->x1)), (unsigned int)(vw->h * (rect->y2 - rect->y1)), (unsigned int)return_value_XtScreen$3->root_depth);
  y = rect->y1;
  for( ; !(y >= rect->y2); y = y + 1)
  {
    ch = vw->pg.text + (signed long int)(41 * y);
    vbi_render_line(vw, pix, ch, y, rect->y1, rect->x1, rect->x2);
  }
  return pix;
}

// vbi_export_txt
// file ./common/vbi-data.h line 40
signed int vbi_export_txt(char *dest, char *charset, signed int size, struct vbi_page *pg, struct vbi_rect *rect, enum vbi_txt_colors color)
{
  signed int x;
  signed int y;
  signed int rc;
  unsigned long int olen;
  unsigned long int ilen;
  signed int fg;
  signed int bg;
  signed int len = 0;
  char *ibuf;
  char *obuf;
  struct vbi_char *ch;
  signed int wch;
  void *ic;
  ic=iconv_open(charset, "WCHAR_T");
  unsigned long int return_value_iconv$2;
  signed int *return_value___errno_location$4;
  signed int return_value_vbi_is_gfx$3;
  if(ic == NULL)
    return -1;

  else
  {
    obuf = dest;
    olen = (unsigned long int)size;
    y = rect->y1;
    for( ; !(y >= rect->y2); y = y + 1)
    {
      ch = pg->text + (signed long int)(41 * y);
      fg = -1;
      bg = -1;
      x = rect->x1;
      for( ; rect->x2 >= x; x = x + 1)
      {
        if(!(x >= rect->x2))
        {
          wch = (signed int)(ch + (signed long int)x)->unicode;
          if((signed int)(ch + (signed long int)x)->size >= 4)
            wch = 32;

          if(!((ch + (signed long int)x)->conceal == 0u))
            wch = 32;

        }

        else
          wch = 10;
        _Bool tmp_if_expr$1;
        if(!(fg == (signed int)(ch + (signed long int)x)->foreground))
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = bg != (signed int)(ch + (signed long int)x)->background ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$1)
        {
          fg = (signed int)(ch + (signed long int)x)->foreground;
          bg = (signed int)(ch + (signed long int)x)->background;
          switch((signed int)color)
          {
            case VBI_ANSICOLOR:
            {
              len=sprintf(obuf, "\033[%d;%dm", 30 + (fg & 7), 40 + (bg & 7));
              break;
            }
            case VBI_NOCOLOR:
              len = 0;
          }
          olen = olen - (unsigned long int)len;
          obuf = obuf + (signed long int)len;
        }

        ibuf = (char *)&wch;
        ilen = sizeof(signed int) /*4ul*/ ;
        do
        {

        retry:
          ;
          return_value_iconv$2=iconv(ic, &ibuf, &ilen, &obuf, &olen);
          rc = (signed int)return_value_iconv$2;
          if(!(rc == -1))
            goto __CPROVER_DUMP_L18;

          return_value___errno_location$4=__errno_location();
          if(!(*return_value___errno_location$4 == 84))
            break;

          if(wch == 63)
            break;

          return_value_vbi_is_gfx$3=vbi_is_gfx((unsigned int)wch);
          if(!(return_value_vbi_is_gfx$3 == 0))
            wch = 35;

          else
            wch = 63;
        }
        while((_Bool)1);

      __CPROVER_DUMP_L18:
        ;
        if(rc == -1)
          goto done;

      }
      switch((signed int)color)
      {
        case VBI_ANSICOLOR:
        {
          len=sprintf(obuf, "\033[0m");
          break;
        }
        case VBI_NOCOLOR:
          len = 0;
      }
      olen = olen - (unsigned long int)len;
      obuf = obuf + (signed long int)len;
    }

  done:
    ;
    return (signed int)(obuf - dest);
  }
}

// vbi_expose_cb
// file x11/vbi-gui.c line 265
static void vbi_expose_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  struct anonymous$109 *cd = (struct anonymous$109 *)call_data;
  struct vbi_window *vw = (struct vbi_window *)clientdata;
  if(!(cd->event->xexpose.count >= 1))
    vbi_render_page(vw);

}

// vbi_find_subtitle
// file common/vbi-data.c line 348
void vbi_find_subtitle(struct vbi_page *pg, struct vbi_rect *rect)
{
  signed int x;
  signed int y;
  signed int showline;
  struct vbi_char *ch;
  *rect = vbi_fullrect;
  y = 1;
  for( ; !(y >= 25); y = y + 1)
  {
    showline = 0;
    ch = pg->text + (signed long int)(41 * y);
    x = 0;
    for( ; !(x >= 41); x = x + 1)
      if(!((signed int)(ch + (signed long int)x)->unicode == 32))
        showline = 1;

    if(!(showline == 0))
      break;

  }
  rect->y1 = y;
  y = 25;
  for( ; y >= rect->y1; y = y - 1)
  {
    showline = 0;
    ch = pg->text + (signed long int)(41 * y);
    x = 0;
    for( ; !(x >= 41); x = x + 1)
      if(!((signed int)(ch + (signed long int)x)->unicode == 32))
        showline = 1;

    if(!(showline == 0))
      break;

  }
  rect->y2 = y + 1;
}

// vbi_findpage
// file x11/vbi-gui.c line 346
static signed int vbi_findpage(struct vbi_page *pg, signed int px, signed int py)
{
  signed int newpage = 0;
  signed int x;
  if(py == 24)
  {
    signed int i = ((signed int)pg->text[(signed long int)(py * 41 + px)].foreground & 7) - 1;
    if(i >= 6)
      i = 0;

    newpage = pg->nav_link[(signed long int)i].pgno;
  }

  else
    if(!(px >= 41) && !(py >= 24))
    {
      _Bool tmp_if_expr$1;
      if((signed int)pg->text[(signed long int)(41 * py + px)].unicode >= 48)
        tmp_if_expr$1 = (signed int)pg->text[(signed long int)(py * 41 + px)].unicode <= 57 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$1 = (_Bool)0;
      if(tmp_if_expr$1)
      {
        x = px;
        newpage = 0;
        for( ; (signed int)pg->text[(signed long int)(41 * py + x)].unicode >= 48; x = x - 1)
        {
          if((signed int)pg->text[(signed long int)(41 * py + x)].unicode >= 58)
            break;

          if(!(x >= 1))
            break;

        }
        x = x + 1;
        for( ; (signed int)pg->text[(signed long int)(41 * py + x)].unicode >= 48; x = x + 1)
        {
          if((signed int)pg->text[(signed long int)(41 * py + x)].unicode >= 58)
            break;

          if(x >= 40)
            break;

          newpage = (newpage * 16 + (signed int)pg->text[(signed long int)(py * 41 + x)].unicode) - 48;
        }
      }

      else
        if((signed int)pg->text[(signed long int)(41 * py + px)].unicode == 62)
          newpage=vbi_calc_page(pg->pgno, +1);

        else
          if((signed int)pg->text[(signed long int)(41 * py + px)].unicode == 60)
            newpage=vbi_calc_page(pg->pgno, -1);

    }

  if(newpage >= 0x999 || !(newpage >= 0x100))
    return 0;

  else
    return newpage;
}

// vbi_fix_head
// file x11/vbi-gui.c line 70
static void vbi_fix_head(struct vbi_window *vw, struct vbi_char *ch)
{
  signed int showno;
  signed int showsub;
  signed int red;
  signed int i;
  showno = vw->pg.pgno;
  showsub = vw->pg.subno;
  red = 0;
  if(showno == 0)
  {
    showno = vw->pgno;
    showsub = 0;
    red = 1;
  }

  if(!(vw->newpage == 0))
  {
    showno = vw->newpage;
    showsub = 0;
    red = 1;
  }

  i = 1;
  for( ; !(i >= 7); i = i + 1)
    (ch + (signed long int)i)->unicode = (unsigned int)32;
  if(showno >= 0x100)
    (ch + (signed long int)1)->unicode = (unsigned int)(48 + (showno >> 8 & 0xf));

  if(showno >= 0x10)
    (ch + (signed long int)2)->unicode = (unsigned int)(48 + (showno >> 4 & 0xf));

  if(showno >= 0x1)
    (ch + (signed long int)3)->unicode = (unsigned int)(48 + (showno >> 0 & 0xf));

  if(!(showsub == 0))
  {
    (ch + (signed long int)4)->unicode = (unsigned int)47;
    (ch + (signed long int)5)->unicode = (unsigned int)(48 + (showsub >> 4 & 0xf));
    (ch + (signed long int)6)->unicode = (unsigned int)(48 + (showsub >> 0 & 0xf));
  }

  if(!(red == 0))
  {
    (ch + (signed long int)1)->foreground = (unsigned int)VBI_RED;
    (ch + (signed long int)2)->foreground = (unsigned int)VBI_RED;
    (ch + (signed long int)3)->foreground = (unsigned int)VBI_RED;
  }

}

// vbi_fix_head$link1
// file console/vbi-tty.c line 88
static void vbi_fix_head$link1(struct vbi_tty *tty, struct vbi_char *ch$link1)
{
  signed int showno$link1;
  signed int showsub$link1;
  signed int red$link1;
  signed int i$link1;
  showno$link1 = tty->pg.pgno;
  showsub$link1 = tty->pg.subno;
  red$link1 = 0;
  if(showno$link1 == 0)
  {
    showno$link1 = tty->pgno;
    showsub$link1 = 0;
    red$link1 = 1;
  }

  if(!(tty->newpage == 0))
  {
    showno$link1 = tty->newpage;
    showsub$link1 = 0;
    red$link1 = 1;
  }

  i$link1 = 1;
  for( ; !(i$link1 >= 7); i$link1 = i$link1 + 1)
    (ch$link1 + (signed long int)i$link1)->unicode = (unsigned int)32;
  if(showno$link1 >= 0x100)
    (ch$link1 + (signed long int)1)->unicode = (unsigned int)(48 + (showno$link1 >> 8 & 0xf));

  if(showno$link1 >= 0x10)
    (ch$link1 + (signed long int)2)->unicode = (unsigned int)(48 + (showno$link1 >> 4 & 0xf));

  if(showno$link1 >= 0x1)
    (ch$link1 + (signed long int)3)->unicode = (unsigned int)(48 + (showno$link1 >> 0 & 0xf));

  if(!(showsub$link1 == 0))
  {
    (ch$link1 + (signed long int)4)->unicode = (unsigned int)47;
    (ch$link1 + (signed long int)5)->unicode = (unsigned int)(48 + (showsub$link1 >> 4 & 0xf));
    (ch$link1 + (signed long int)6)->unicode = (unsigned int)(48 + (showsub$link1 >> 0 & 0xf));
  }

  if(!(red$link1 == 0))
  {
    (ch$link1 + (signed long int)1)->foreground = (unsigned int)VBI_RED;
    (ch$link1 + (signed long int)2)->foreground = (unsigned int)VBI_RED;
    (ch$link1 + (signed long int)3)->foreground = (unsigned int)VBI_RED;
  }

}

// vbi_font_cb
// file x11/vbi-gui.c line 309
static void vbi_font_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  struct vbi_window *vw = (struct vbi_window *)clientdata;
  char *name;
  name=XtName(widget);
  vbi_render_set_font(widget, vw, name);
  XtVaSetValues(vw->tt, (char *)&XtStrings[(signed long int)872], vw->w * 41, (char *)&XtStrings[(signed long int)234], vw->h * 25, (void *)0);
  struct _XDisplay *return_value_XtDisplay$1;
  return_value_XtDisplay$1=XtDisplay(vw->tt);
  unsigned long int return_value_XtWindow$2;
  return_value_XtWindow$2=XtWindow(vw->tt);
  XClearWindow(return_value_XtDisplay$1, return_value_XtWindow$2);
}

// vbi_goto_cb
// file x11/vbi-gui.c line 319
static void vbi_goto_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  struct vbi_window *vw = (struct vbi_window *)clientdata;
  signed int pgno;
  signed int subno;
  char *name;
  pgno = vw->pg.pgno;
  subno = vw->pg.subno;
  name=XtName(widget);
  signed int return_value_strcmp$3;
  return_value_strcmp$3=strcmp(name, "prev");
  signed int return_value_strcmp$2;
  signed int return_value_sscanf$1;
  if(return_value_strcmp$3 == 0)
  {
    pgno=vbi_calc_page(vw->pgno, -1);
    subno = 0x3F7F;
  }

  else
  {
    return_value_strcmp$2=strcmp(name, "next");
    if(return_value_strcmp$2 == 0)
    {
      pgno=vbi_calc_page(vw->pgno, +1);
      subno = 0x3F7F;
    }

    else
    {
      return_value_sscanf$1=sscanf(name, "s%x", &subno);
      if(!(return_value_sscanf$1 == 1))
      {
        sscanf(name, "%x", &pgno);
        subno = 0x3F7F;
      }

    }
  }
  if(subno == 0)
    subno = 0x3F7F;

  vbi_setpage(vw, pgno, subno);
}

// vbi_hasdata
// file ./common/vbi-data.h line 34
signed int vbi_hasdata(struct vbi_state *vbi)
{
  char buf[1l];
  signed int rc;
  if(!(vbi->sim == 0))
  {
    read(vbi->fd, (void *)buf, (unsigned long int)1);
    read_sim(vbi->raw, vbi->sliced, &vbi->lines, &vbi->ts);
    rc = 1;
  }

  else
    rc=vbi_capture_read(vbi->cap, (void *)vbi->raw, vbi->sliced, &vbi->lines, &vbi->ts, &vbi->tv);
  vbi_decode(vbi->dec, vbi->sliced, vbi->lines, vbi->ts);
  return rc;
}

// vbi_is_gfx
// file /usr/include/libzvbi.h line 855
static inline signed int vbi_is_gfx(unsigned int unicode)
{
  return (signed int)(unicode >= (unsigned int)0xEE00 && unicode <= (unsigned int)0xEFFF);
}

// vbi_kbd_eh
// file x11/vbi-gui.c line 391
static void vbi_kbd_eh(struct _WidgetRec *widget, void *clientdata, union _XEvent *event, char *cont)
{
  struct vbi_window *vw = (struct vbi_window *)clientdata;
  unsigned long int sym;
  signed int digit;
  signed int subno;
  signed int return_value_vbi_calc_page$2;
  signed int return_value_vbi_calc_page$3;
  if(event->type == 2)
  {
    struct _XDisplay *return_value_XtDisplay$1;
    return_value_XtDisplay$1=XtDisplay(widget);
    sym=XKeycodeToKeysym(return_value_XtDisplay$1, (unsigned char)event->xkey.keycode, 0);
    digit = -1;
    switch(sym)
    {
      case (unsigned long int)0x0030:

      case (unsigned long int)0xff9e:
      {
        digit = 0;
        break;
      }
      case (unsigned long int)0x0031:

      case (unsigned long int)0xff9c:
      {
        digit = 1;
        break;
      }
      case (unsigned long int)0x0032:

      case (unsigned long int)0xff99:
      {
        digit = 2;
        break;
      }
      case (unsigned long int)0x0033:

      case (unsigned long int)0xff9b:
      {
        digit = 3;
        break;
      }
      case (unsigned long int)0x0034:

      case (unsigned long int)0xff96:
      {
        digit = 4;
        break;
      }
      case (unsigned long int)0x0035:

      case (unsigned long int)0xff9d:
      {
        digit = 5;
        break;
      }
      case (unsigned long int)0x0036:

      case (unsigned long int)0xff98:
      {
        digit = 6;
        break;
      }
      case (unsigned long int)0x0037:

      case (unsigned long int)0xff95:
      {
        digit = 7;
        break;
      }
      case (unsigned long int)0x0038:

      case (unsigned long int)0xff97:
      {
        digit = 8;
        break;
      }
      case (unsigned long int)0x0039:

      case (unsigned long int)0xff9a:
      {
        digit = 9;
        break;
      }
      case (unsigned long int)0x0020:

      case (unsigned long int)0x006c:
      {
        return_value_vbi_calc_page$2=vbi_calc_page(vw->pgno, +1);
        vbi_setpage(vw, return_value_vbi_calc_page$2, 0x3F7F);
        break;
      }
      case (unsigned long int)0xff08:

      case (unsigned long int)0x0068:
      {
        return_value_vbi_calc_page$3=vbi_calc_page(vw->pgno, -1);
        vbi_setpage(vw, return_value_vbi_calc_page$3, 0x3F7F);
        break;
      }
      case (unsigned long int)0x006b:
      {
        signed int tmp_if_expr$4;
        if(!(vw->subno == 0x3F7F))
          tmp_if_expr$4 = vw->subno;

        else
          tmp_if_expr$4 = vw->pg.subno;
        subno = tmp_if_expr$4;
        subno=vbi_calc_subpage(vw->vbi->dec, vw->pgno, subno, +1);
        vbi_setpage(vw, vw->pgno, subno);
        break;
      }
      case (unsigned long int)0x006a:
      {
        signed int tmp_if_expr$5;
        if(!(vw->subno == 0x3F7F))
          tmp_if_expr$5 = vw->subno;

        else
          tmp_if_expr$5 = vw->pg.subno;
        subno = tmp_if_expr$5;
        subno=vbi_calc_subpage(vw->vbi->dec, vw->pgno, subno, -1);
        vbi_setpage(vw, vw->pgno, subno);
      }
    }
    if(!(digit == -1))
    {
      vw->newpage = vw->newpage * 16;
      vw->newpage = vw->newpage + digit;
      if(vw->newpage >= 0x100)
        vbi_setpage(vw, vw->newpage, 0x3F7F);

    }

    goto __CPROVER_DUMP_L22;
  }


__CPROVER_DUMP_L22:
  ;
}

// vbi_mark_rectangle
// file x11/vbi-gui.c line 130
static void vbi_mark_rectangle(struct vbi_window *vw)
{
  struct vbi_rect rect;
  struct anonymous$107 values;
  signed int x;
  signed int y;
  signed int w;
  signed int h;
  rect = vw->s;
  vbi_check_rectangle(&rect);
  x = vw->w * rect.x1;
  w = vw->w * (rect.x2 - rect.x1);
  y = vw->h * rect.y1;
  h = vw->h * (rect.y2 - rect.y1);
  values.function = 0x6;
  values.foreground = (unsigned long int)~0;
  struct _XDisplay *return_value_XtDisplay$1;
  return_value_XtDisplay$1=XtDisplay(vw->tt);
  XChangeGC(return_value_XtDisplay$1, vw->gc, (unsigned long int)(1L << 0 | 1L << 2), &values);
  struct _XDisplay *return_value_XtDisplay$2;
  return_value_XtDisplay$2=XtDisplay(vw->tt);
  unsigned long int return_value_XtWindow$3;
  return_value_XtWindow$3=XtWindow(vw->tt);
  XFillRectangle(return_value_XtDisplay$2, return_value_XtWindow$3, vw->gc, x, y, (unsigned int)w, (unsigned int)h);
}

// vbi_mouse_eh
// file x11/vbi-gui.c line 472
static void vbi_mouse_eh(struct _WidgetRec *widget, void *clientdata, union _XEvent *event, char *cont)
{
  struct vbi_window *vw = (struct vbi_window *)clientdata;
  signed int px;
  signed int py;
  signed int newpage;
  signed int return_value_abs$1;
  signed int return_value_abs$2;
  switch(event->type)
  {
    case 4:
    {
      switch(event->xbutton.button)
      {
        case (unsigned int)1:
        {
          px = event->xbutton.x / vw->w;
          py = event->xbutton.y / vw->h;
          vw->s.x2 = px;
          vw->s.x1 = vw->s.x2;
          vw->s.y2 = py;
          vw->s.y1 = vw->s.y2;
          vw->down = event->xbutton.time;
          break;
        }
        case (unsigned int)2:
          selection_dnd_start(vw, event);
      }
      break;
    }
    case 6:
    {
      if(!((256u & event->xmotion.state) == 0u))
      {
        vw->s.x2 = event->xbutton.x / vw->w + 1;
        vw->s.y2 = event->xbutton.y / vw->h + 1;
        vbi_render_page(vw);
      }

      break;
    }
    case 5:
    {
      if(!(event->xbutton.button == 1u))
      {
        if(event->xbutton.button == 4u)
          goto __CPROVER_DUMP_L17;

        if(event->xbutton.button == 5u)
          goto __CPROVER_DUMP_L18;

        break;
      }

      px = event->xbutton.x / vw->w;
      py = event->xbutton.y / vw->h;
      return_value_abs$1=abs(vw->s.x1 - px);
      _Bool tmp_if_expr$3;
      if(!(return_value_abs$1 >= 2))
      {
        return_value_abs$2=abs(vw->s.y1 - py);
        tmp_if_expr$3 = return_value_abs$2 < 2 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$3 = (_Bool)0;
      _Bool tmp_if_expr$4;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = event->xbutton.time - vw->down < (unsigned long int)500 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
      {
        vw->s.x2 = 0;
        vw->s.x1 = vw->s.x2;
        vw->s.y2 = 0;
        vw->s.y1 = vw->s.y2;
        newpage=vbi_findpage(&vw->pg, px, py);
        if(!(newpage == 0))
          vbi_setpage(vw, newpage, 0x3F7F);

        else
          vbi_render_page(vw);
      }

      else
      {
        vw->s.x2 = px + 1;
        vw->s.y2 = py + 1;
        vbi_render_page(vw);
        selection_pri(vw);
      }
      break;

    __CPROVER_DUMP_L17:
      ;
      newpage=vbi_calc_page(vw->pgno, -1);
      vbi_setpage(vw, newpage, 0x3F7F);
      break;

    __CPROVER_DUMP_L18:
      ;
      newpage=vbi_calc_page(vw->pgno, +1);
      vbi_setpage(vw, newpage, 0x3F7F);
    }
  }
}

// vbi_new_cb
// file x11/vbi-gui.c line 297
static void vbi_new_cb(struct _WidgetRec *widget, void *clientdata, void *call_data)
{
  struct vbi_window *vw = (struct vbi_window *)clientdata;
  struct _WidgetRec *shell;
  struct _XDisplay *return_value_XtDisplay$1;
  return_value_XtDisplay$1=XtDisplay(widget);
  shell=XtVaAppCreateShell("mtt", "mtt", applicationShellWidgetClass, return_value_XtDisplay$1, (void *)0);
  vbi_create_widgets(shell, vw->vbi);
  XtRealizeWidget(shell);
}

// vbi_newdata
// file x11/vbi-gui.c line 178
static void vbi_newdata(struct vbi_event *ev, void *user)
{
  struct vbi_window *vw = (struct vbi_window *)user;
  switch(ev->type)
  {
    case 0x0002:
    {
      if(vw->pgno == ev->ev.ttx_page.pgno)
      {
        _Bool tmp_if_expr$1;
        if(vw->subno == ev->ev.ttx_page.subno)
          tmp_if_expr$1 = (_Bool)1;

        else
          tmp_if_expr$1 = vw->subno == 0x3F7F ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$1)
        {
          vbi_fetch_vt_page(vw->vbi->dec, &vw->pg, vw->pgno, vw->subno, (enum anonymous)VBI_WST_LEVEL_1p5, 25, 1);
          vbi_render_page(vw);
        }

        vbi_subpage_menu(vw);
      }

      else
        vbi_render_head(vw, ev->ev.ttx_page.pgno, ev->ev.ttx_page.subno);
      break;
    }
    case 0x0008:
      XtVaSetValues(vw->shell, (char *)&XtShellStrings[(signed long int)356], (const void *)ev->ev.network.name, (void *)0);
  }
}

// vbi_newdata$link1
// file console/vbi-tty.c line 187
static void vbi_newdata$link1(struct vbi_event *ev$link1, void *user$link1)
{
  struct vbi_tty *vbi_newdata$$1$$tty = (struct vbi_tty *)user$link1;
  _Bool tmp_if_expr$1$link1;
  if(ev$link1->type == 0x0002)
  {
    _Bool tmp_if_expr$2;
    if(vbi_newdata$$1$$tty->pgno == ev$link1->ev.ttx_page.pgno)
    {
      if(vbi_newdata$$1$$tty->subno == ev$link1->ev.ttx_page.subno)
        tmp_if_expr$1$link1 = (_Bool)1;

      else
        tmp_if_expr$1$link1 = vbi_newdata$$1$$tty->subno == 0x3F7F ? (_Bool)1 : (_Bool)0;
      tmp_if_expr$2 = tmp_if_expr$1$link1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      vbi_render_page$link1(vbi_newdata$$1$$tty);

    else
      vbi_render_head$link1(vbi_newdata$$1$$tty, ev$link1->ev.ttx_page.pgno, ev$link1->ev.ttx_page.subno);
  }

}

// vbi_open
// file ./common/vbi-data.h line 33
struct vbi_state * vbi_open(char *dev, signed int debug, signed int sim)
{
  struct vbi_state *vbi;
  signed int services = 0x40000000 | 0x20000000 | 0x00000001 | 0x00000002 | 0x00000020 | 0x00000040 | 0x00000008 | 0x00000010 | 0x00000004 | 0x00000400 | 0x00000800;
  signed int p[2l];
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct vbi_state) /*88ul*/ );
  vbi = (struct vbi_state *)return_value_malloc$1;
  unsigned long int return_value_strtoul$2;
  void *return_value_malloc$5;
  void *return_value_malloc$6;
  if(!(vbi == ((struct vbi_state *)NULL)))
  {
    memset((void *)vbi, 0, sizeof(struct vbi_state) /*88ul*/ );
    vbi->debug = debug;
    vbi->sim = sim;
    vbi->dec=vbi_decoder_new();
    if(vbi->dec == ((struct vbi_decoder *)NULL))
      goto oops;

    {
      char *env;
      env=getenv("ALEVTD_REGION");
      unsigned int region;
      if(!(env == ((char *)NULL)))
      {
        return_value_strtoul$2=strtoul(env, (char ** restrict )(void *)0, 0);
        region = (unsigned int)return_value_strtoul$2;
        if(!(region == 0u))
          vbi_teletext_set_default_region(vbi->dec, (signed int)region);

      }

    }
    if(!(vbi->sim == 0))
    {
      vbi->par=init_sim(625, (unsigned int)services);
      pipe(p);
      signed int return_value_fork$3;
      return_value_fork$3=fork();
      if(!(return_value_fork$3 == -1))
      {
        if(return_value_fork$3 == 0)
          goto __CPROVER_DUMP_L5;

      }

      else
      {
        perror("fork");
        exit(1);

      __CPROVER_DUMP_L5:
        ;
        close(p[(signed long int)0]);
        do
        {
          signed long int return_value_write$4;
          return_value_write$4=write(p[(signed long int)1], (const void *)"x", (unsigned long int)1);
          if(!(return_value_write$4 == 1l))
            exit(0);

          usleep((unsigned int)(100 * 1000));
        }
        while((_Bool)1);
      }
      vbi->fd = p[(signed long int)0];
      close(p[(signed long int)1]);
    }

    else
    {
      vbi->cap=vbi_capture_v4l2_new(dev, 16, (unsigned int *)&services, -1, &vbi->err, debug);
      if(vbi->cap == ((struct vbi_capture *)NULL))
      {
        vbi->cap=vbi_capture_v4l_new(dev, 16, (unsigned int *)&services, -1, &vbi->err, debug);
        if(vbi->cap == ((struct vbi_capture *)NULL))
          goto oops;

      }

      vbi->par=vbi_capture_parameters(vbi->cap);
      vbi->fd=vbi_capture_fd(vbi->cap);
    }
    vbi->lines = vbi->par->count[(signed long int)0] + vbi->par->count[(signed long int)1];
    return_value_malloc$5=malloc((unsigned long int)(vbi->lines * vbi->par->bytes_per_line));
    vbi->raw = (unsigned char *)return_value_malloc$5;
    if(vbi->raw == ((unsigned char *)NULL))
      goto oops;

    return_value_malloc$6=malloc((unsigned long int)vbi->lines * sizeof(struct anonymous$15) /*64ul*/ );
    vbi->sliced = (struct anonymous$15 *)return_value_malloc$6;
    if(vbi->sliced == ((struct anonymous$15 *)NULL))
      goto oops;

    vbi->tv.tv_sec = (signed long int)1;
    vbi->tv.tv_usec = (signed long int)0;
    return vbi;
  }

  else
  {

  oops:
    ;
    if(!(vbi == ((struct vbi_state *)NULL)))
    {
      if(!(vbi->sliced == ((struct anonymous$15 *)NULL)))
        free((void *)vbi->sliced);

      if(!(vbi->raw == ((unsigned char *)NULL)))
        free((void *)vbi->raw);

      if(!(vbi->cap == ((struct vbi_capture *)NULL)))
        vbi_capture_delete(vbi->cap);

      if(!(vbi->dec == ((struct vbi_decoder *)NULL)))
        vbi_decoder_delete(vbi->dec);

      free((void *)vbi);
    }

    fprintf(stderr, "vbi: open failed [%s]\n", dev);
    return (struct vbi_state *)(void *)0;
  }
}

// vbi_render_free_font
// file x11/vbi-x11.c line 77
void vbi_render_free_font(struct _WidgetRec *shell, struct vbi_window *vw)
{
  if(!(vw->xft_font == ((struct _XftFont *)NULL)))
  {
    struct _XDisplay *return_value_XtDisplay$1;
    return_value_XtDisplay$1=XtDisplay(shell);
    XftFontClose(return_value_XtDisplay$1, vw->xft_font);
    vw->xft_font = (struct _XftFont *)(void *)0;
  }

  if(!(vw->font1 == ((struct anonymous$100 *)NULL)))
  {
    struct _XDisplay *return_value_XtDisplay$2;
    return_value_XtDisplay$2=XtDisplay(shell);
    XFreeFont(return_value_XtDisplay$2, vw->font1);
    vw->font1 = (struct anonymous$100 *)(void *)0;
  }

  if(!(vw->font2 == ((struct anonymous$100 *)NULL)))
  {
    struct _XDisplay *return_value_XtDisplay$3;
    return_value_XtDisplay$3=XtDisplay(shell);
    XFreeFont(return_value_XtDisplay$3, vw->font2);
    vw->font2 = (struct anonymous$100 *)(void *)0;
  }

}

// vbi_render_head
// file x11/vbi-gui.c line 166
static void vbi_render_head(struct vbi_window *vw, signed int pgno, signed int subno)
{
  struct vbi_page pg;
  memset((void *)&pg, 0, sizeof(struct vbi_page) /*9072ul*/ );
  vbi_fetch_vt_page(vw->vbi->dec, &pg, pgno, subno, (enum anonymous)VBI_WST_LEVEL_1p5, 1, 0);
  vbi_fix_head(vw, pg.text);
  unsigned long int return_value_XtWindow$1;
  return_value_XtWindow$1=XtWindow(vw->tt);
  vbi_render_line(vw, return_value_XtWindow$1, pg.text, 0, 0, 0, 41);
}

// vbi_render_head$link1
// file console/vbi-tty.c line 155
static void vbi_render_head$link1(struct vbi_tty *tty, signed int pgno$link1, signed int subno$link1)
{
  struct vbi_page pg$link1;
  char *data;
  signed int len;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)(41 * 24));
  data = (char *)return_value_malloc$1;
  memset((void *)&pg$link1, 0, sizeof(struct vbi_page) /*9072ul*/ );
  vbi_fetch_vt_page(tty->vbi->dec, &pg$link1, pgno$link1, subno$link1, (enum anonymous)VBI_WST_LEVEL_1p5, 1, 1);
  vbi_fix_head$link1(tty, pg$link1.text);
  if(!(have_fb == 0))
    vbi_draw_vt_page_region(&pg$link1, (enum anonymous$13)fb_fmt, (void *)(fb_mem + (signed long int)fb_mem_offset), (signed int)fb_fix.line_length, 0, 0, pg$link1.columns, 1, 0, 1);

  else
  {
    char *return_value_nl_langinfo$2;
    return_value_nl_langinfo$2=nl_langinfo(14);
    static struct vbi_rect head = { .x1=0, .x2=41, .y1=0, .y2=1 };
    len=vbi_export_txt(data, return_value_nl_langinfo$2, 41 * 8, &pg$link1, &head, (enum vbi_txt_colors)VBI_ANSICOLOR);
    tty_goto(0, 0);
    fwrite((const void *)data, (unsigned long int)len, (unsigned long int)1, stderr);
    tty_goto(42, 0);
    free((void *)data);
  }
}

// vbi_render_init
// file x11/vbi-x11.c line 142
struct vbi_window * vbi_render_init(struct _WidgetRec *shell, struct _WidgetRec *tt, struct vbi_state *vbi)
{
  struct vbi_window *vw;
  struct anonymous$91 color;
  struct anonymous$91 dummy;
  signed int i;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct vbi_window) /*9432ul*/ );
  vw = (struct vbi_window *)return_value_malloc$1;
  memset((void *)vw, 0, sizeof(struct vbi_window) /*9432ul*/ );
  vw->shell = shell;
  vw->tt = tt;
  vw->vbi = vbi;
  struct _XDisplay *return_value_XtDisplay$2;
  return_value_XtDisplay$2=XtDisplay(shell);
  struct anonymous$96 *return_value_XtScreen$3;
  return_value_XtScreen$3=XtScreen(shell);
  vw->gc=XCreateGC(return_value_XtDisplay$2, return_value_XtScreen$3->root, (unsigned long int)0, (struct anonymous$107 *)(void *)0);
  XtVaGetValues(tt, (char *)&XtStrings[(signed long int)154], &vw->cmap, (void *)0);
  i = 0;
  for( ; !(i >= 8); i = i + 1)
  {
    struct _XDisplay *return_value_XtDisplay$4;
    return_value_XtDisplay$4=XtDisplay(shell);
    struct anonymous$96 *return_value_XtScreen$5;
    return_value_XtScreen$5=XtScreen(shell);
    XftColorAllocName(return_value_XtDisplay$4, return_value_XtScreen$5->root_visual, vw->cmap, vbi_colors[(signed long int)i], &vw->xft_color[(signed long int)i]);
    struct _XDisplay *return_value_XtDisplay$6;
    return_value_XtDisplay$6=XtDisplay(shell);
    XAllocNamedColor(return_value_XtDisplay$6, vw->cmap, vbi_colors[(signed long int)i], &color, &dummy);
    vw->colors[(signed long int)i] = color.pixel;
  }
  vbi_render_set_font(shell, vw, (char *)(void *)0);
  do
  {
    (&vw->selections)->next = &vw->selections;
    (&vw->selections)->prev = &vw->selections;
  }
  while((_Bool)0);
  return vw;
}

// vbi_render_line
// file x11/vbi-x11.c line 176
void vbi_render_line(struct vbi_window *vw, unsigned long int d, struct vbi_char *ch, signed int y, signed int top, signed int left, signed int right)
{
  struct anonymous$107 values;
  struct anonymous$105 line[42l];
  signed int x1;
  signed int x2;
  signed int i;
  signed int code;
  signed int sy;
  unsigned int wline[42l];
  struct _XftDraw *xft_draw = (struct _XftDraw *)(void *)0;
  x1 = left;
  struct _XDisplay *return_value_XtDisplay$8;
  struct anonymous$96 *return_value_XtScreen$9;
  for( ; !(x1 >= right); x1 = x2)
  {
    x2 = x1;
    for( ; !(x2 >= right); x2 = x2 + 1)
    {
      if(!((ch + (signed long int)x1)->foreground == (ch + (signed long int)x2)->foreground))
        break;

      if(!((ch + (signed long int)x1)->background == (ch + (signed long int)x2)->background))
        break;

      if(!((ch + (signed long int)x1)->size == (ch + (signed long int)x2)->size))
        break;

    }
    sy = 1;
    if(!(vw->font2 == ((struct anonymous$100 *)NULL)))
    {
      _Bool tmp_if_expr$1;
      if((signed int)(ch + (signed long int)x1)->size == 2)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)(ch + (signed long int)x1)->size == 3 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        sy = 2;

      _Bool tmp_if_expr$2;
      if((signed int)(ch + (signed long int)x1)->size == 6)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)(ch + (signed long int)x1)->size == 7 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        goto __CPROVER_DUMP_L25;

    }

    i = x1;
    for( ; !(i >= x2); i = i + 1)
    {
      code = (signed int)(ch + (signed long int)i)->unicode;
      if(!((ch + (signed long int)i)->conceal == 0u))
        code = 32;

      _Bool tmp_if_expr$3;
      if((signed int)(ch + (signed long int)i)->size == 4)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)(ch + (signed long int)i)->size == 5 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$4;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)(ch + (signed long int)i)->size == 6 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr$5;
      if(tmp_if_expr$4)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)(ch + (signed long int)i)->size == 7 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
        code = 32;

      line[(signed long int)(i - x1)].byte1 = (unsigned char)(code >> 8 & 0xff);
      line[(signed long int)(i - x1)].byte2 = (unsigned char)(code & 0xff);
      wline[(signed long int)(i - x1)] = (unsigned int)code;
    }
    values.function = 0x3;
    values.foreground = vw->colors[(signed long int)((signed int)(ch + (signed long int)x1)->background & 7)];
    struct _XDisplay *return_value_XtDisplay$6;
    return_value_XtDisplay$6=XtDisplay(vw->tt);
    XChangeGC(return_value_XtDisplay$6, vw->gc, (unsigned long int)(1L << 2 | 1L << 0), &values);
    struct _XDisplay *return_value_XtDisplay$7;
    return_value_XtDisplay$7=XtDisplay(vw->tt);
    XFillRectangle(return_value_XtDisplay$7, d, vw->gc, (x1 - left) * vw->w, (y - top) * vw->h, (unsigned int)(vw->w * (x2 - x1)), (unsigned int)(vw->h * sy));
    if(!(vw->xft_font == ((struct _XftFont *)NULL)))
    {
      if(xft_draw == ((struct _XftDraw *)NULL))
      {
        return_value_XtDisplay$8=XtDisplay(vw->tt);
        return_value_XtScreen$9=XtScreen(vw->tt);
        xft_draw=XftDrawCreate(return_value_XtDisplay$8, d, return_value_XtScreen$9->root_visual, vw->cmap);
      }

      XftDrawString32(xft_draw, &vw->xft_color[(signed long int)((signed int)(ch + (signed long int)x1)->foreground & 7)], vw->xft_font, (x1 - left) * vw->w, vw->a + (((y - top) + sy) - 1) * vw->h, wline, x2 - x1);
    }

    else
    {
      values.foreground = vw->colors[(signed long int)((signed int)(ch + (signed long int)x1)->foreground & 7)];
      unsigned long int tmp_if_expr$10;
      if(sy == 1)
        tmp_if_expr$10 = vw->font1->fid;

      else
        tmp_if_expr$10 = vw->font2->fid;
      values.font = tmp_if_expr$10;
      struct _XDisplay *return_value_XtDisplay$11;
      return_value_XtDisplay$11=XtDisplay(vw->tt);
      XChangeGC(return_value_XtDisplay$11, vw->gc, (unsigned long int)(1L << 2 | 1L << 14), &values);
      struct _XDisplay *return_value_XtDisplay$12;
      return_value_XtDisplay$12=XtDisplay(vw->tt);
      XDrawString16(return_value_XtDisplay$12, d, vw->gc, (x1 - left) * vw->w, vw->a + (((y - top) + sy) - 1) * vw->h, line, x2 - x1);
    }

  __CPROVER_DUMP_L25:
    ;
  }
  if(!(xft_draw == ((struct _XftDraw *)NULL)))
    XftDrawDestroy(xft_draw);

}

// vbi_render_page
// file x11/vbi-gui.c line 150
static void vbi_render_page(struct vbi_window *vw)
{
  struct vbi_char *ch;
  signed int y;
  vbi_fix_head(vw, vw->pg.text);
  y = 0;
  for( ; !(y >= 25); y = y + 1)
  {
    ch = vw->pg.text + (signed long int)(41 * y);
    unsigned long int return_value_XtWindow$1;
    return_value_XtWindow$1=XtWindow(vw->tt);
    vbi_render_line(vw, return_value_XtWindow$1, ch, y, 0, 0, 41);
  }
  _Bool tmp_if_expr$3;
  if(!(vw->s.x1 == 0))
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = vw->s.x2 != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$3)
  {
    _Bool tmp_if_expr$2;
    if(!(vw->s.y1 == 0))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = vw->s.y2 != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      vbi_mark_rectangle(vw);

  }

}

// vbi_render_page$link1
// file console/vbi-tty.c line 127
static void vbi_render_page$link1(struct vbi_tty *tty)
{
  char *data;
  signed int len;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)(25 * 41 * 24));
  data = (char *)return_value_malloc$1;
  vbi_fetch_vt_page(tty->vbi->dec, &tty->pg, tty->pgno, tty->subno, (enum anonymous)VBI_WST_LEVEL_1p5, 25, 1);
  vbi_fix_head$link1(tty, tty->pg.text);
  if(!(have_fb == 0))
    vbi_draw_vt_page_region(&tty->pg, (enum anonymous$13)fb_fmt, (void *)(fb_mem + (signed long int)fb_mem_offset), (signed int)fb_fix.line_length, 0, 0, tty->pg.columns, tty->pg.rows, 0, 1);

  else
  {
    char *return_value_nl_langinfo$2;
    return_value_nl_langinfo$2=nl_langinfo(14);
    len=vbi_export_txt(data, return_value_nl_langinfo$2, 25 * 41 * 8, &tty->pg, &vbi_fullrect, (enum vbi_txt_colors)VBI_ANSICOLOR);
    tty_goto(0, 0);
    fwrite((const void *)data, (unsigned long int)len, (unsigned long int)1, stderr);
    tty_goto(42, 0);
    free((void *)data);
  }
}

// vbi_render_set_font
// file x11/vbi-x11.c line 95
void vbi_render_set_font(struct _WidgetRec *shell, struct vbi_window *vw, char *label)
{
  struct _FcPattern *pattern;
  enum _FcResult rc;
  signed int i;
  vbi_render_free_font(shell, vw);
  if(!(label == ((char *)NULL)))
  {
    i = 0;
    for( ; !(vbi_fonts[(signed long int)i].label == ((char *)NULL)); i = i + 1)
    {
      signed int return_value_strcasecmp$1;
      return_value_strcasecmp$1=strcasecmp(label, vbi_fonts[(signed long int)i].label);
      if(return_value_strcasecmp$1 == 0)
      {
        signed int return_value_vbi_render_try_font$2;
        return_value_vbi_render_try_font$2=vbi_render_try_font(shell, vw, &vbi_fonts[(signed long int)i]);
        if(return_value_vbi_render_try_font$2 == 0)
          goto __CPROVER_DUMP_L10;

      }

    }
    pattern=FcNameParse((const unsigned char *)label);
    struct _XDisplay *return_value_XtDisplay$3;
    return_value_XtDisplay$3=XtDisplay(shell);
    struct anonymous$96 *return_value_XtScreen$4;
    return_value_XtScreen$4=XtScreen(shell);
    signed int return_value_XScreenNumberOfScreen$5;
    return_value_XScreenNumberOfScreen$5=XScreenNumberOfScreen(return_value_XtScreen$4);
    pattern=XftFontMatch(return_value_XtDisplay$3, return_value_XScreenNumberOfScreen$5, pattern, &rc);
    struct _XDisplay *return_value_XtDisplay$6;
    return_value_XtDisplay$6=XtDisplay(shell);
    vw->xft_font=XftFontOpenPattern(return_value_XtDisplay$6, pattern);
    if(!(vw->xft_font == ((struct _XftFont *)NULL)))
    {
      vw->a = vw->xft_font->ascent;
      vw->d = vw->xft_font->descent;
      vw->w = vw->xft_font->max_advance_width;
      vw->h = vw->xft_font->height;
      goto __CPROVER_DUMP_L10;
    }

  }

  i = 0;
  for( ; !(vbi_fonts[(signed long int)i].label == ((char *)NULL)); i = i + 1)
  {
    signed int return_value_vbi_render_try_font$7;
    return_value_vbi_render_try_font$7=vbi_render_try_font(shell, vw, &vbi_fonts[(signed long int)i]);
    if(return_value_vbi_render_try_font$7 == 0)
      goto __CPROVER_DUMP_L10;

  }
  fprintf(stderr, "Oops: can't load any font\n");
  exit(1);

__CPROVER_DUMP_L10:
  ;
}

// vbi_render_try_font
// file x11/vbi-x11.c line 59
static signed int vbi_render_try_font(struct _WidgetRec *shell, struct vbi_window *vw, struct vbi_font *fnt)
{
  struct _XDisplay *return_value_XtDisplay$2;
  if(vw->xft_font == ((struct _XftFont *)NULL))
  {
    if(!(fnt->xlfd1 == ((char *)NULL)))
    {
      struct _XDisplay *return_value_XtDisplay$1;
      return_value_XtDisplay$1=XtDisplay(shell);
      vw->font1=XLoadQueryFont(return_value_XtDisplay$1, fnt->xlfd1);
      if(!(fnt->xlfd2 == ((char *)NULL)))
      {
        return_value_XtDisplay$2=XtDisplay(shell);
        vw->font2=XLoadQueryFont(return_value_XtDisplay$2, fnt->xlfd2);
      }

      if(!(vw->font1 == ((struct anonymous$100 *)NULL)))
      {
        vw->a = (signed int)vw->font1->max_bounds.ascent;
        vw->d = (signed int)vw->font1->max_bounds.descent;
        vw->w = (signed int)vw->font1->max_bounds.width;
        vw->h = vw->a + vw->d;
        return 0;
      }

    }

  }

  return 1;
}

// vbi_setpage
// file x11/vbi-gui.c line 251
static void vbi_setpage(struct vbi_window *vw, signed int pgno, signed int subno)
{
  vw->pgno = pgno;
  vw->subno = subno;
  vw->newpage = 0;
  memset((void *)&vw->pg, 0, sizeof(struct vbi_page) /*9072ul*/ );
  vbi_fetch_vt_page(vw->vbi->dec, &vw->pg, vw->pgno, vw->subno, (enum anonymous)VBI_WST_LEVEL_1p5, 25, 1);
  unsigned long int return_value_XtWindow$1;
  return_value_XtWindow$1=XtWindow(vw->tt);
  if(!(return_value_XtWindow$1 == 0ul))
    vbi_render_page(vw);

  vbi_subpage_menu(vw);
}

// vbi_setpage$link1
// file console/vbi-tty.c line 207
static void vbi_setpage$link1(struct vbi_tty *tty, signed int pgno$link1, signed int subno$link1)
{
  tty->pgno = pgno$link1;
  tty->subno = subno$link1;
  tty->newpage = 0;
  memset((void *)&tty->pg, 0, sizeof(struct vbi_page) /*9072ul*/ );
  vbi_fetch_vt_page(tty->vbi->dec, &tty->pg, tty->pgno, tty->subno, (enum anonymous)VBI_WST_LEVEL_1p5, 25, 1);
  vbi_render_page$link1(tty);
}

// vbi_station_cb
// file x11/vbi-gui.c line 895
static void vbi_station_cb(struct _WidgetRec *widget, void *client, void *call)
{
  struct vbi_state *vbi = (struct vbi_state *)client;
  char *name;
  name=XtName(widget);
  signed int i = 0;
  signed int return_value_strcmp$1;
  for( ; !(i >= count); i = i + 1)
  {
    return_value_strcmp$1=strcmp(channels[(signed long int)i]->name, name);
    if(return_value_strcmp$1 == 0)
      break;

  }
  if(!(i == count))
  {
    /* vbi_station_cb::1::tag-v4l2_frequency */
struct v4l2_frequency
{
  // tuner
  unsigned int tuner;
  // type
  unsigned int type;
  // frequency
  unsigned int frequency;
  // reserved
  unsigned int reserved[8l];
};

/* */
    ;
    struct v4l2_frequency frequency;
    memset((void *)&frequency, 0, sizeof(struct v4l2_frequency) /*44ul*/ );
    frequency.type = (unsigned int)2;
    frequency.frequency = (unsigned int)channels[(signed long int)i]->freq;
    signed int return_value_ioctl$2;
    return_value_ioctl$2=ioctl(vbi->fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(86 << 0 + 8) | (unsigned int)(57 << 0)) | sizeof(struct v4l2_frequency) /*44ul*/  << 0 + 8 + 8, &frequency);
    if(return_value_ioctl$2 == -1)
      perror("ioctl VIDIOCSFREQ");

  }

}

// vbi_station_menu
// file x11/vbi-gui.c line 930
static void vbi_station_menu(struct _WidgetRec *menubar, struct vbi_state *vbi)
{
  /* tag-#anon#lST[l*{S8}$S8$'name'|*{SYM#tag-_WidgetRec#}$SYM#tag-_WidgetRec#$'menu'] */
struct anonymous$108
{
  // name
  char *name;
  // menu
  struct _WidgetRec *menu;
};

/* */
  ;
  struct anonymous$108 *sub = (struct anonymous$108 *)(void *)0;
  signed int subs = 0;
  struct _WidgetRec *m;
  struct _WidgetRec *menu;
  struct _WidgetRec *push;
  union __XmStringRec *label;
  signed int i;
  signed int j;
  signed int return_value_strcmp$1;
  if(!(count == 0))
  {
    menu=XmCreatePulldownMenu(menubar, "stationM", (struct anonymous$1 *)(void *)0, (unsigned int)0);
    XtVaCreateManagedWidget("station", xmCascadeButtonWidgetClass, menubar, (char *)&_XmStrings[(signed long int)9963], menu, (void *)0);
    i = 0;
    for( ; !(i >= count); i = i + 1)
    {
      m = menu;
      signed int return_value_strcmp$3;
      return_value_strcmp$3=strcmp(channels[(signed long int)i]->group, "main");
      if(!(return_value_strcmp$3 == 0))
      {
        j = 0;
        for( ; !(j >= subs); j = j + 1)
        {
          return_value_strcmp$1=strcmp(channels[(signed long int)i]->group, (sub + (signed long int)j)->name);
          if(return_value_strcmp$1 == 0)
            break;

        }
        if(j == subs)
        {
          subs = subs + 1;
          void *return_value_realloc$2;
          return_value_realloc$2=realloc((void *)sub, (unsigned long int)subs * sizeof(struct anonymous$108) /*16ul*/ );
          sub = (struct anonymous$108 *)return_value_realloc$2;
          (sub + (signed long int)j)->name = channels[(signed long int)i]->group;
          (sub + (signed long int)j)->menu=XmCreatePulldownMenu(menu, channels[(signed long int)i]->group, (struct anonymous$1 *)(void *)0, (unsigned int)0);
          XtVaCreateManagedWidget(channels[(signed long int)i]->group, xmCascadeButtonWidgetClass, menu, (char *)&_XmStrings[(signed long int)9963], (sub + (signed long int)j)->menu, (void *)0);
        }

        m = (sub + (signed long int)j)->menu;
      }

      label=XmStringGenerate((void *)channels[(signed long int)i]->name, (char *)(void *)0, (enum anonymous$3)XmMULTIBYTE_TEXT, (char *)(void *)0);
      push=XtVaCreateManagedWidget(channels[(signed long int)i]->name, xmPushButtonWidgetClass, m, (char *)&_XmStrings[(signed long int)7535], label, (void *)0);
      XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], vbi_station_cb, (void *)vbi);
      XmStringFree(label);
    }
  }

}

// vbi_subpage_menu
// file x11/vbi-gui.c line 208
static void vbi_subpage_menu(struct vbi_window *vw)
{
  struct _WidgetRec **children;
  struct _WidgetRec **list;
  unsigned int nchildren;
  struct _WidgetRec *push;
  struct vbi_page pg;
  char page[8l];
  unsigned int i;
  XtVaGetValues(vw->submenu, (char *)&XtStrings[(signed long int)145], &children, (char *)&XtStrings[(signed long int)493], &nchildren, (void *)0);
  if(!(nchildren == 0u))
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(struct _WidgetRec **) /*8ul*/  * (unsigned long int)nchildren);
    list = (struct _WidgetRec **)return_value_malloc$1;
    memcpy((void *)list, (const void *)children, sizeof(struct _WidgetRec **) /*8ul*/  * (unsigned long int)nchildren);
    i = (unsigned int)0;
    for( ; !(i >= nchildren); i = i + 1u)
      XtDestroyWidget(list[(signed long int)i]);
    free((void *)list);
  }

  push=XtVaCreateManagedWidget("s00", xmPushButtonWidgetClass, vw->submenu, (void *)0);
  XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], vbi_goto_cb, (void *)vw);
  XtVaCreateManagedWidget("sep", xmSeparatorWidgetClass, vw->submenu, (void *)0);
  _Bool tmp_if_expr$3;
  if(!(vw->pg.pgno == 0))
    tmp_if_expr$3 = vw->pg.subno != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$3 = (_Bool)0;
  if(tmp_if_expr$3)
  {
    XtVaSetValues(vw->subbtn, (char *)&XtStrings[(signed long int)711], 1, (void *)0);
    i = (unsigned int)0;
    for( ; !(i >= 64u); i = i + 1u)
    {
      signed int return_value_vbi_fetch_vt_page$2;
      return_value_vbi_fetch_vt_page$2=vbi_fetch_vt_page(vw->vbi->dec, &pg, vw->pg.pgno, (signed int)i, (enum anonymous)VBI_WST_LEVEL_1, 0, 0);
      if(!(return_value_vbi_fetch_vt_page$2 == 0))
      {
        sprintf(page, "s%02x", i);
        push=XtVaCreateManagedWidget(page, xmPushButtonWidgetClass, vw->submenu, (void *)0);
        XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], vbi_goto_cb, (void *)vw);
      }

    }
  }

  else
    XtVaSetValues(vw->subbtn, (char *)&XtStrings[(signed long int)711], 0, (void *)0);
}

// vbi_tty
// file ./console/vbi-tty.h line 1
extern void vbi_tty(char *device, signed int debug, signed int sim)
{
  struct vbi_state *vbi;
  struct vbi_tty *vbi_tty$$1$$tty;
  struct anonymous$12 set;
  struct winsize win;
  struct timeval tv;
  char key[11l];
  signed int rc;
  signed int subno;
  signed int last;
  setlocale(6, "");
  vbi=vbi_open(device, debug, sim);
  if(vbi == ((struct vbi_state *)NULL))
    exit(1);

  {
    signed int return_value_ioctl$1;
    return_value_ioctl$1=ioctl(0, (unsigned long int)0x5413, &win);
    if(!(return_value_ioctl$1 == -1))
    {
      if(!((signed int)win.ws_row >= 26))
      {
        fprintf(stderr, "Terminal too small (need 26 rows, have %d)\n", win.ws_row);
        exit(1);
      }

    }

  }
  tty_raw();
  if(!(have_fb == 0))
    fb_clear();

  else
    tty_clear();
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(struct vbi_tty) /*9096ul*/ );
  vbi_tty$$1$$tty = (struct vbi_tty *)return_value_malloc$2;
  memset((void *)vbi_tty$$1$$tty, 0, sizeof(struct vbi_tty) /*9096ul*/ );
  vbi_tty$$1$$tty->vbi = vbi;
  vbi_event_handler_add(vbi->dec, ~0, vbi_newdata$link1, (void *)vbi_tty$$1$$tty);
  vbi_setpage$link1(vbi_tty$$1$$tty, 0x100, 0x3F7F);
  last = 0;
  signed int return_value_vbi_calc_page$4;
  signed int return_value_vbi_calc_page$5;
  while(last == 0)
  {
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$12) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&set)->__fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&set)->__fds_bits[(signed long int)(0 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&set)->__fds_bits[(signed long int)(0 / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << 0 % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    (&set)->__fds_bits[(signed long int)(vbi->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&set)->__fds_bits[(signed long int)(vbi->fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << vbi->fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    tv.tv_sec = (signed long int)1;
    tv.tv_usec = (signed long int)0;
    rc=select(vbi->fd + 1, &set, (struct anonymous$12 *)(void *)0, (struct anonymous$12 *)(void *)0, &tv);
    if(rc == -1)
    {
      tty_restore();
      if(!(have_fb == 0))
        fb_cleanup();

      perror("select");
      exit(1);
    }

    if(rc == 0)
    {
      if(!(have_fb == 0))
        fb_cleanup();

      tty_restore();
      fprintf(stderr, "oops: timeout\n");
      exit(1);
    }

    if(!((1l & set.__fds_bits[0l]) == 0l))
    {
      signed long int return_value_read$3;
      return_value_read$3=read(0, (void *)key, (unsigned long int)10);
      rc = (signed int)return_value_read$3;
      key[(signed long int)rc] = (char)0;
      if(rc == 1)
      {
        if(!((signed int)key[0l] == 81) && !((signed int)key[0l] == 113))
        {
          if((signed int)key[0l] == 12)
            goto __CPROVER_DUMP_L14;

          if((signed int)key[0l] == 73 || (signed int)key[0l] == 105)
            goto __CPROVER_DUMP_L17;

          if((signed int)key[0l] == 32 || (signed int)key[0l] == 76 || (signed int)key[0l] == 108)
            goto __CPROVER_DUMP_L18;

          if((signed int)key[0l] == 72 || (signed int)key[0l] == 104 || (signed int)key[0l] == 127)
            goto __CPROVER_DUMP_L19;

          if((signed int)key[0l] == 75 || (signed int)key[0l] == 107)
            goto __CPROVER_DUMP_L20;

          if((signed int)key[0l] == 74 || (signed int)key[0l] == 106)
            goto __CPROVER_DUMP_L23;

        }

        else
        {
          last = 1;
          goto __CPROVER_DUMP_L28;

        __CPROVER_DUMP_L14:
          ;
          if(!(have_fb == 0))
            fb_clear();

          else
            tty_clear();
          vbi_render_page$link1(vbi_tty$$1$$tty);
          goto __CPROVER_DUMP_L28;

        __CPROVER_DUMP_L17:
          ;
          vbi_setpage$link1(vbi_tty$$1$$tty, 0x100, 0x3F7F);
          goto __CPROVER_DUMP_L28;

        __CPROVER_DUMP_L18:
          ;
          return_value_vbi_calc_page$4=vbi_calc_page(vbi_tty$$1$$tty->pgno, +1);
          vbi_setpage$link1(vbi_tty$$1$$tty, return_value_vbi_calc_page$4, 0x3F7F);
          goto __CPROVER_DUMP_L28;

        __CPROVER_DUMP_L19:
          ;
          return_value_vbi_calc_page$5=vbi_calc_page(vbi_tty$$1$$tty->pgno, -1);
          vbi_setpage$link1(vbi_tty$$1$$tty, return_value_vbi_calc_page$5, 0x3F7F);
          goto __CPROVER_DUMP_L28;

        __CPROVER_DUMP_L20:
          ;
          signed int tmp_if_expr$6;
          if(!(vbi_tty$$1$$tty->subno == 0x3F7F))
            tmp_if_expr$6 = vbi_tty$$1$$tty->subno;

          else
            tmp_if_expr$6 = vbi_tty$$1$$tty->pg.subno;
          subno = tmp_if_expr$6;
          subno=vbi_calc_subpage(vbi_tty$$1$$tty->vbi->dec, vbi_tty$$1$$tty->pgno, subno, +1);
          vbi_setpage$link1(vbi_tty$$1$$tty, vbi_tty$$1$$tty->pgno, subno);
          goto __CPROVER_DUMP_L28;

        __CPROVER_DUMP_L23:
          ;
          signed int tmp_if_expr$7;
          if(!(vbi_tty$$1$$tty->subno == 0x3F7F))
            tmp_if_expr$7 = vbi_tty$$1$$tty->subno;

          else
            tmp_if_expr$7 = vbi_tty$$1$$tty->pg.subno;
          subno = tmp_if_expr$7;
          subno=vbi_calc_subpage(vbi_tty$$1$$tty->vbi->dec, vbi_tty$$1$$tty->pgno, subno, -1);
          vbi_setpage$link1(vbi_tty$$1$$tty, vbi_tty$$1$$tty->pgno, subno);
          goto __CPROVER_DUMP_L28;
        }
        if((signed int)key[0l] >= 48)
        {
          if(!((signed int)key[0l] >= 58))
          {
            vbi_tty$$1$$tty->newpage = vbi_tty$$1$$tty->newpage * 16;
            vbi_tty$$1$$tty->newpage = vbi_tty$$1$$tty->newpage + ((signed int)key[(signed long int)0] - 48);
            if(vbi_tty$$1$$tty->newpage >= 0x100)
              vbi_setpage$link1(vbi_tty$$1$$tty, vbi_tty$$1$$tty->newpage, 0x3F7F);

          }

        }

      }

    }


  __CPROVER_DUMP_L28:
    ;
    if(!((set.__fds_bits[(signed long int)(vbi->fd / 8)] & (signed long int)(1UL << vbi->fd % 8)) == 0l))
      vbi_hasdata(vbi);

  }
  if(!(have_fb == 0))
    fb_cleanup();

  tty_goto(0, 0);
  tty_restore();
}

// vbi_xft_font_menu
// file x11/vbi-gui.c line 1002
static void vbi_xft_font_menu(struct _WidgetRec *menu, struct vbi_window *vw)
{
  struct _FcPattern *pattern;
  struct _FcObjectSet *oset;
  struct _FcFontSet *fset;
  struct _WidgetRec *push;
  union __XmStringRec *label;
  char **fonts;
  char *h;
  signed int i;
  pattern=FcNameParse((const unsigned char *)":style=Regular:spacing=100:slant=0:weight=100");
  oset=FcObjectSetBuild("family", (const void *)"style", (const void *)"spacing", (const void *)"slant", (const void *)"weight", (void *)0);
  fset=FcFontList((struct _FcConfig *)(void *)0, pattern, oset);
  FcPatternDestroy(pattern);
  unsigned char *return_value_FcNameUnparse$2;
  if(!(fset == ((struct _FcFontSet *)NULL)))
  {
    XtVaCreateManagedWidget("sep", xmSeparatorWidgetClass, menu, (void *)0);
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(char *) /*8ul*/  * (unsigned long int)fset->nfont);
    fonts = (char **)return_value_malloc$1;
    i = 0;
    for( ; !(i >= fset->nfont); i = i + 1)
    {
      return_value_FcNameUnparse$2=FcNameUnparse(fset->fonts[(signed long int)i]);
      fonts[(signed long int)i] = (char *)return_value_FcNameUnparse$2;
    }
    qsort((void *)fonts, (unsigned long int)fset->nfont, sizeof(char *) /*8ul*/ , fntcmp);
    i = 0;
    for( ; !(i >= fset->nfont); i = i + 1)
    {
      push=XtVaCreateManagedWidget(fonts[(signed long int)i], xmPushButtonWidgetClass, menu, (void *)0);
      h=strchr(fonts[(signed long int)i], 58);
      if(!(h == ((char *)NULL)))
        *h = (char)0;

      label=XmStringGenerate((void *)fonts[(signed long int)i], (char *)(void *)0, (enum anonymous$3)XmMULTIBYTE_TEXT, (char *)(void *)0);
      XtVaSetValues(push, (char *)&_XmStrings[(signed long int)7535], label, (void *)0);
      XmStringFree(label);
      XtAddCallback(push, (char *)&_XmStrings[(signed long int)4700], vbi_font_cb, (void *)vw);
    }
    i = 0;
    for( ; !(i >= fset->nfont); i = i + 1)
      free((void *)fonts[(signed long int)i]);
    free((void *)fonts);
  }

}

// vdr_handler
// file common/commands.c line 1293
static signed int vdr_handler(char *name, signed int argc, char **argv)
{
  char line[80l];
  struct addrinfo ask;
  signed int i;
  signed int rc;
  unsigned int l;
  unsigned int len;

reconnect:
  ;
  signed long int return_value_write$4;
  signed int *return_value___errno_location$3;
  for( ; (_Bool)1; vdr_sock = -1)
  {
    if(vdr_sock == -1)
    {
      memset((void *)&ask, 0, sizeof(struct addrinfo) /*48ul*/ );
      ask.ai_family = 0;
      ask.ai_socktype = 1;
      vdr_sock=tcp_connect(&ask, "localhost", "2001");
      if(vdr_sock == -1)
        return -1;

      if(!(debug == 0))
        fprintf(stderr, "vdr: connected\n");

      signed int return_value_tcp_readbuf$1;
      return_value_tcp_readbuf$1=tcp_readbuf(vdr_sock, 3, line, (char)sizeof(char [80l]) /*80ul*/ );
      if(return_value_tcp_readbuf$1 == -1)
        goto oops;

      if(!(debug == 0))
        fprintf(stderr, "vdr: << %s", (const void *)line);

    }

    line[(signed long int)0] = (char)0;
    i = 0;
    len = (unsigned int)0;
    for( ; !(i >= argc); i = i + 1)
    {
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(argv[(signed long int)i]);
      l = (unsigned int)return_value_strlen$2;
      if((unsigned long int)(4u + l + len) >= 81ul)
        break;

      if(!(len == 0u))
      {
        strcpy(line + (signed long int)len, " ");
        len = len + 1u;
      }

      strcpy(line + (signed long int)len, argv[(signed long int)i]);
      len = len + l;
    }
    strcpy(line + (signed long int)len, "\r\n");
    len = len + (unsigned int)2;
    return_value_write$4=write(vdr_sock, (const void *)line, (unsigned long int)len);
    rc = (signed int)return_value_write$4;
    if(len == (unsigned int)rc)
      goto __CPROVER_DUMP_L14;

    if(!(rc == -1))
      goto __CPROVER_DUMP_L12;

    return_value___errno_location$3=__errno_location();
    if(!(*return_value___errno_location$3 == 32))
      break;

    if(!(debug == 0))
      fprintf(stderr, "tcp: write: broken pipe, trying reconnect\n");

    close(vdr_sock);
  }

__CPROVER_DUMP_L12:
  ;
  if(!(debug == 0))
    perror("tcp: write");

  goto oops;

__CPROVER_DUMP_L14:
  ;
  if(!(debug == 0))
    fprintf(stderr, "vdr: >> %s", (const void *)line);

  signed int return_value_tcp_readbuf$5;
  return_value_tcp_readbuf$5=tcp_readbuf(vdr_sock, 3, line, (char)sizeof(char [80l]) /*80ul*/ );
  if(!(return_value_tcp_readbuf$5 == -1))
  {
    if(!(debug == 0))
      fprintf(stderr, "vdr: << %s", (const void *)line);

    return 0;
  }

  else
  {

  oops:
    ;
    close(vdr_sock);
    vdr_sock = -1;
    return -1;
  }
}

// volume_handler
// file common/commands.c line 796
static signed int volume_handler(char *name, signed int argc, char **argv)
{
  struct ng_attribute *vol;
  vol=ng_attr_byid(attrs, 3);
  signed int return_value_strcasecmp$3;
  if(!(argc == 0))
  {
    return_value_strcasecmp$3=strcasecmp(argv[(signed long int)0], "mute");
    if(return_value_strcasecmp$3 == 0)
    {
      if(argc >= 2)
      {
        signed int return_value_str_to_int$1;
        return_value_str_to_int$1=str_to_int(argv[(signed long int)1], booltab);
        switch(return_value_str_to_int$1)
        {
          case 0:
          {
            set_mute(0);
            break;
          }
          case 1:
          {
            set_mute(1);
            break;
          }
          default:
            set_mute((signed int)!(cur_attrs[(signed long int)4] != 0));
        }
      }

      else
        set_mute((signed int)!(cur_attrs[(signed long int)4] != 0));
    }

    else
      if(!(vol == ((struct ng_attribute *)NULL)))
      {
        signed int return_value;
        return_value=vol->read(vol);
        signed int return_value_update_int$2;
        return_value_update_int$2=update_int(vol, return_value, argv[(signed long int)0]);
        set_volume(return_value_update_int$2);
      }

    if(!(volume_notify == ((void (*)(void))NULL)))
      volume_notify();

  }


display:
  ;
  if(!(cur_attrs[4l] == 0))
    set_msg_str("volume", "muted");

  else
    if(!(vol == ((struct ng_attribute *)NULL)))
      set_msg_int(vol, cur_attrs[(signed long int)3]);

    else
      set_msg_str("volume", "unmuted");
  return 0;
}

// wav_init_header
// file libng/writefile.c line 233
static void wav_init_header(struct WAVEHDR *fileheader, struct ng_audio_fmt *audio)
{
  signed int nBitsPerSample = (signed int)ng_afmt_to_bits[(signed long int)audio->fmtid];
  signed int wav_init_header$$1$$channels = (signed int)ng_afmt_to_channels[(signed long int)audio->fmtid];
  signed int rate = (signed int)audio->rate;
  unsigned long int nBlockAlign = (unsigned long int)(wav_init_header$$1$$channels * ((nBitsPerSample + 7) / 8));
  unsigned long int nAvgBytesPerSec = nBlockAlign * (unsigned long int)rate;
  unsigned long int temp = ((unsigned long int)0 + sizeof(struct WAVEHDR) /*44ul*/ ) - sizeof(struct CHUNKHDR) /*8ul*/ ;
  fileheader->chkRiff.ckid = (unsigned int)(unsigned char)82 | (unsigned int)(unsigned char)73 << 8 | (unsigned int)(unsigned char)70 << 16 | (unsigned int)(unsigned char)70 << 24;
  fileheader->fccWave = (unsigned int)(unsigned char)87 | (unsigned int)(unsigned char)65 << 8 | (unsigned int)(unsigned char)86 << 16 | (unsigned int)(unsigned char)69 << 24;
  fileheader->chkFmt.ckid = (unsigned int)(unsigned char)102 | (unsigned int)(unsigned char)109 << 8 | (unsigned int)(unsigned char)116 << 16 | (unsigned int)(unsigned char)32 << 24;
  fileheader->chkFmt.dwSize = (unsigned int)16;
  fileheader->wFormatTag = (unsigned short int)1;
  fileheader->nChannels = (unsigned short int)wav_init_header$$1$$channels;
  fileheader->nSamplesPerSec = (unsigned int)rate;
  fileheader->nAvgBytesPerSec = (unsigned int)nAvgBytesPerSec;
  fileheader->nBlockAlign = (unsigned short int)nBlockAlign;
  fileheader->wBitsPerSample = (unsigned short int)nBitsPerSample;
  fileheader->chkData.ckid = (unsigned int)(unsigned char)100 | (unsigned int)(unsigned char)97 << 8 | (unsigned int)(unsigned char)116 << 16 | (unsigned int)(unsigned char)97 << 24;
  fileheader->chkRiff.dwSize = (unsigned int)temp;
  fileheader->chkData.dwSize = (unsigned int)0;
}

// wav_start_write
// file libng/writefile.c line 261
static void wav_start_write(signed int fd, struct WAVEHDR *fileheader, struct ng_audio_fmt *audio)
{
  wav_init_header(fileheader, audio);
  write(fd, (const void *)fileheader, sizeof(struct WAVEHDR) /*44ul*/ );
}

// wav_stop_write
// file libng/writefile.c line 268
static void wav_stop_write(signed int fd, struct WAVEHDR *fileheader, signed int wav_size)
{
  unsigned long int temp = ((unsigned long int)wav_size + sizeof(struct WAVEHDR) /*44ul*/ ) - sizeof(struct CHUNKHDR) /*8ul*/ ;
  fileheader->chkRiff.dwSize = (unsigned int)temp;
  fileheader->chkData.dwSize = (unsigned int)wav_size;
  lseek(fd, (signed long int)0, 0);
  write(fd, (const void *)fileheader, sizeof(struct WAVEHDR) /*44ul*/ );
}

// webcam_exit
// file common/webcam.c line 118
void webcam_exit(void)
{
  if(!(web == ((struct WEBCAM *)NULL)))
  {
    pthread_cancel(tweb);
    free((void *)web);
    web = (struct WEBCAM *)(void *)0;
  }

}

// webcam_handler
// file common/commands.c line 1115
static signed int webcam_handler(char *hname, signed int argc, char **argv)
{
  struct ng_video_fmt fmt;
  struct ng_video_buf *buf;
  if(!(webcam == ((char *)NULL)))
    free((void *)webcam);

  webcam=strdup(argv[(signed long int)0]);
  if(!(cur_movie == 0))
    return 0;

  else
    if(cur_capture == 2)
      return 0;

    else
    {
      if(!(capture_get_hook == ((void (*)(void))NULL)))
        capture_get_hook();

      memset((void *)&fmt, 0, sizeof(struct ng_video_fmt) /*16ul*/ );
      fmt.fmtid = (unsigned int)9;
      fmt.width = cur_tv_width;
      fmt.height = cur_tv_height;
      buf=ng_grabber_get_image(&fmt);
      if(!(buf == ((struct ng_video_buf *)NULL)))
        ng_release_video_buf(buf);

      if(!(capture_rel_hook == ((void (*)(void))NULL)))
        capture_rel_hook();

      return 0;
    }
}

// webcam_init
// file common/webcam.c line 108
void webcam_init(void)
{
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct WEBCAM) /*104ul*/ );
  web = (struct WEBCAM *)return_value_malloc$1;
  memset((void *)web, 0, sizeof(struct WEBCAM) /*104ul*/ );
  pthread_mutex_init(&web->lock, (const union anonymous$86 *)(void *)0);
  pthread_create(&tweb, (const union pthread_attr_t *)(void *)0, webcam_writer, (void *)web);
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// webcam_put
// file common/webcam.c line 128
signed int webcam_put(char *filename, struct ng_video_buf *buf)
{
  signed int ret = 0;
  if(web == ((struct WEBCAM *)NULL))
    webcam_init();

  signed int return_value_pthread_mutex_trylock$1;
  return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&web->lock);
  if(return_value_pthread_mutex_trylock$1 == -1)
  {
    if(!(debug == 0))
      fprintf(stderr, "webcam_put: locked\n");

    return -1;
  }

  else
  {
    if(!(web->buf == ((struct ng_video_buf *)NULL)))
    {
      if(!(debug == 0))
        fprintf(stderr, "webcam_put: still has data\n");

      ret = -1;
    }

    else
    {
      web->filename=strdup(filename);
      web->buf = buf;
      buf->refcount = buf->refcount + 1;
      if(!(debug == 0))
        fprintf(stderr, "webcam_put: ok\n");

      pthread_cond_signal(&web->wait);
    }

  done:
    ;
    pthread_mutex_unlock(&web->lock);
    return ret;
  }
}

// webcam_writer
// file common/webcam.c line 30
static void * webcam_writer(void *arg)
{
  struct WEBCAM *webcam_writer$$1$$web = (struct WEBCAM *)arg;
  signed int rename;
  signed int fd;
  signed int old;
  char tmpfilename[512l];
  struct ng_video_fmt *fmt;
  if(!(debug == 0))
    fprintf(stderr, "webcam_writer start\n");

  pthread_setcancelstate(0, &old);
  pthread_setcanceltype(1, &old);
  pthread_mutex_lock(&webcam_writer$$1$$web->lock);

__CPROVER_DUMP_L2:
  ;
  for( ; (_Bool)1; webcam_writer$$1$$web->buf = (struct ng_video_buf *)(void *)0)
  {
    if(webcam_writer$$1$$web->buf == ((struct ng_video_buf *)NULL))
    {
      if(!(debug == 0))
        fprintf(stderr, "webcam_writer: waiting for data\n");

      pthread_cond_wait(&webcam_writer$$1$$web->wait, &webcam_writer$$1$$web->lock);
      goto __CPROVER_DUMP_L2;
    }

    fmt = &webcam_writer$$1$$web->buf->fmt;
    if(!(debug == 0))
      fprintf(stderr, "webcam_writer: %d %dx%d \n", fmt->fmtid, fmt->width, fmt->height);

    rename = 1;
    sprintf(tmpfilename, "%s.$$$", webcam_writer$$1$$web->filename);
    switch(fmt->fmtid)
    {
      case (unsigned int)16:

      case (unsigned int)17:
      {
        fd=open(tmpfilename, 0100 | 01, 0666);
        if(fd == -1)
        {
          signed int *return_value___errno_location$1;
          return_value___errno_location$1=__errno_location();
          char *return_value_strerror$2;
          return_value_strerror$2=strerror(*return_value___errno_location$1);
          fprintf(stderr, "open(%s): %s\n", (const void *)tmpfilename, return_value_strerror$2);
          goto done;
        }

        write(fd, (const void *)webcam_writer$$1$$web->buf->data, webcam_writer$$1$$web->buf->size);
        close(fd);
        break;
      }
      case (unsigned int)9:
      {
        write_jpeg(tmpfilename, webcam_writer$$1$$web->buf, ng_jpeg_quality, 0);
        break;
      }
      default:
      {
        fprintf(stderr, "webcam_writer: can't deal with format=%d\n", fmt->fmtid);
        rename = 0;
      }
    }
    if(!(rename == 0))
    {
      unlink(webcam_writer$$1$$web->filename);
      signed int return_value_link$5;
      return_value_link$5=link(tmpfilename, webcam_writer$$1$$web->filename);
      if(return_value_link$5 == -1)
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        char *return_value_strerror$4;
        return_value_strerror$4=strerror(*return_value___errno_location$3);
        fprintf(stderr, "link(%s,%s): %s\n", (const void *)tmpfilename, webcam_writer$$1$$web->filename, return_value_strerror$4);
        break;
      }

      unlink(tmpfilename);
    }

    free((void *)webcam_writer$$1$$web->filename);
    ng_release_video_buf(webcam_writer$$1$$web->buf);
  }

done:
  ;
  pthread_mutex_unlock(&webcam_writer$$1$$web->lock);
  if(!(debug == 0))
    fprintf(stderr, "webcam_writer done\n");

  return (void *)0;
}

// write_jpeg
// file ./libng/writefile.h line 4
signed int write_jpeg(char *filename, struct ng_video_buf *buf, signed int quality, signed int gray)
{
  struct _IO_FILE *fp;
  fp=fopen(filename, "w");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    fprintf(stderr, "grab: can't open %s: %s\n", filename, return_value_strerror$2);
    return -1;
  }

  signed int return_value_do_write_jpeg$3;
  return_value_do_write_jpeg$3=do_write_jpeg(fp, buf, quality, gray);
  return return_value_do_write_jpeg$3;
}

// write_pgm
// file libng/writefile.c line 161
signed int write_pgm(char *filename, struct ng_video_buf *buf)
{
  struct _IO_FILE *fp;
  fp=fopen(filename, "w");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    fprintf(stderr, "grab: can't open %s: %s\n", filename, return_value_strerror$2);
    return -1;
  }

  fprintf(fp, "P5\n%d %d\n255\n", buf->fmt.width, buf->fmt.height);
  fwrite((const void *)buf->data, (unsigned long int)buf->fmt.height, (unsigned long int)buf->fmt.width, fp);
  fclose(fp);
  return 0;
}

// write_ppm
// file ./libng/writefile.h line 6
signed int write_ppm(char *filename, struct ng_video_buf *buf)
{
  struct _IO_FILE *fp;
  fp=fopen(filename, "w");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    fprintf(stderr, "grab: can't open %s: %s\n", filename, return_value_strerror$2);
    return -1;
  }

  fprintf(fp, "P6\n%d %d\n255\n", buf->fmt.width, buf->fmt.height);
  fwrite((const void *)buf->data, (unsigned long int)buf->fmt.height, (unsigned long int)((unsigned int)3 * buf->fmt.width), fp);
  fclose(fp);
  return 0;
}

// writer_audio_thread
// file common/capture.c line 295
static void * writer_audio_thread(void *arg)
{
  struct movie_handle *h = (struct movie_handle *)arg;
  struct ng_audio_buf *buf;
  signed int return_value_getpid$1;
  if(!(debug == 0))
  {
    return_value_getpid$1=getpid();
    fprintf(stderr, "writer_audio_thread start [pid=%d]\n", return_value_getpid$1);
  }

  void *return_value_fifo_get$2;
  return_value_fifo_get$2=fifo_get(&h->afifo);
  buf = (struct ng_audio_buf *)return_value_fifo_get$2;
  if(!(buf == ((struct ng_audio_buf *)NULL)))
  {
    pthread_mutex_lock(&h->lock);
    h->writer->wr_audio(h->handle, buf);
    pthread_mutex_unlock(&h->lock);
    free((void *)buf);
  }

  if(!(debug == 0))
    fprintf(stderr, "writer_audio_thread done\n");

  return (void *)0;
}

// writer_video_thread
// file common/capture.c line 321
static void * writer_video_thread(void *arg)
{
  struct movie_handle *h = (struct movie_handle *)arg;
  struct ng_video_buf *buf;
  struct ng_video_buf *reorder[32l];
  signed int seq;
  signed int slot;
  signed int return_value_getpid$1;
  if(!(debug == 0))
  {
    return_value_getpid$1=getpid();
    fprintf(stderr, "writer_video_thread start [pid=%d]\n", return_value_getpid$1);
  }

  seq = 0;
  memset((void *)&reorder, 0, sizeof(struct ng_video_buf *[32l]) /*256ul*/ );
  do
  {
    void *return_value_fifo_get$2;
    return_value_fifo_get$2=fifo_get(&h->vfifo);
    buf = (struct ng_video_buf *)return_value_fifo_get$2;
    if(buf == ((struct ng_video_buf *)NULL))
      break;

    slot = buf->info.seq % 32;
    if(debug >= 2)
      fprintf(stderr, "video write: get seq=%d [%d]\n", buf->info.seq, slot);

    if(!(reorder[(signed long int)slot] == ((struct ng_video_buf *)NULL)))
    {
      fprintf(stderr, "panic: reorder buffer full\n");
      exit(1);
    }

    reorder[(signed long int)slot] = buf;
    slot = seq % 32;
    if(!(reorder[(signed long int)slot] == ((struct ng_video_buf *)NULL)))
    {
      buf = reorder[(signed long int)slot];
      reorder[(signed long int)slot] = (struct ng_video_buf *)(void *)0;
      if(debug >= 2)
        fprintf(stderr, "video write: put seq=%d [%d/%d]\n", buf->info.seq, slot, seq);

      seq = seq + 1;
      pthread_mutex_lock(&h->lock);
      h->writer->wr_video(h->handle, buf);
      if(!(buf->info.twice == 0))
        h->writer->wr_video(h->handle, buf);

      pthread_mutex_unlock(&h->lock);
      ng_release_video_buf(buf);
    }

  }
  while((_Bool)1);
  if(!(debug == 0))
    fprintf(stderr, "writer_video_thread done\n");

  return (void *)0;
}

// wss525_sim
// file common/vbi-sim.c line 112
static inline double wss525_sim(double t, double F, unsigned int bits)
{
  double t1 = 11.2e-6 - .5 / F;
  double t4 = t1 + (double)(2 + 14 + 6 + 1) / F;
  double ph;
  signed int i;
  signed int n;
  bits = bits * (unsigned int)2 + (unsigned int)(2 << 21);
  if(t < t1)
    return 0.0;

  else
    if(t < t4)
    {
      t = t - t1;
      i = (signed int)(t * F - .0);
      n = (signed int)(bits >> 22 - i & (unsigned int)3);
      if(n == 0)
        return 0.0;

      else
        if(n == 3)
          return 1.0;

      if(!(((i ^ n) & 1) == 0))
        ph = (3.14159265358979323846 * (double)2 * (t - (double)0 / F) * F) / (double)4;

      else
        ph = (3.14159265358979323846 * (double)2 * (t - (double)1 / F) * F) / (double)4;
      double return_value_shape$1;
      return_value_shape$1=shape(ph);
      return return_value_shape$1;
    }

    else
      return 0.0;
}

// wss625_sim
// file common/vbi-sim.c line 66
static inline double wss625_sim(double t, double F, unsigned int bits)
{
  double t1 = 11.0e-6 - .5 / F;
  double t4 = t1 + (double)(29 + 24 + 84) / F;
  double ph;
  signed int i;
  signed int j;
  signed int n;
  static char frame[56l] = { 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 'x', 0 };
  frame[(signed long int)(1 + 29 + 24)] = (char)(bits & (unsigned int)1);
  if(t < t1)
    return 0.0;

  else
    if(t < t4)
    {
      t = t - t1;
      i = (signed int)(t * F - .0);
      if(!(i >= 24))
        n = (signed int)frame[(signed long int)i] + 2 * (signed int)frame[(signed long int)(i + 1)];

      else
      {
        j = (i - 29) - 24;
        static signed int twobit[4l] = { 0xE38, 0xE07, 0x1F8, 0x1C7 };
        n = twobit[(signed long int)(bits >> j / 6 & (unsigned int)3)];
        n = n >> j % 6 & 3;
      }
      if(n == 0)
        return 0.0;

      else
        if(n == 3)
          return 1.0;

      if(!(((i ^ n) & 1) == 0))
        ph = (3.14159265358979323846 * (double)2 * (t - (double)1 / F) * F) / (double)4;

      else
        ph = (3.14159265358979323846 * (double)2 * (t - (double)0 / F) * F) / (double)4;
      double return_value_shape$1;
      return_value_shape$1=shape(ph);
      return return_value_shape$1;
    }

    else
      return 0.0;
}

// x11_icons_init
// file x11/icons.h line 1
void x11_icons_init(struct _XDisplay *dpy, unsigned long int bg)
{
  add_pixmap(dpy, bg, "home", (char *)(void *)0, home_xpm);
  add_pixmap(dpy, bg, "prev", (char *)(void *)0, prev_xpm);
  add_pixmap(dpy, bg, "next", (char *)(void *)0, next_xpm);
  add_pixmap(dpy, bg, "movie", (char *)(void *)0, movie_xpm);
  add_pixmap(dpy, bg, "snap", (char *)(void *)0, snap_xpm);
  add_pixmap(dpy, bg, "mute", (char *)(void *)0, mute_xpm);
  add_pixmap(dpy, bg, "exit", (char *)(void *)0, exit_xpm);
  add_pixmap(dpy, bg, "TVimg", "TVmask", tv_xpm);
}

// yuv420p_to_rgb24
// file libng/color_yuv2rgb.c line 170
static void yuv420p_to_rgb24(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict u;
  unsigned char * restrict v;
  unsigned char * restrict d;
  unsigned char *us;
  unsigned char *vs;
  unsigned char *dp;
  unsigned int i;
  unsigned int j;
  signed int gray;
  dp = out->data;
  y = in->data;
  u = y + (signed long int)(in->fmt.width * in->fmt.height);
  v = u + (signed long int)((in->fmt.width * in->fmt.height) / (unsigned int)4);
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = dp;
    us = u;
    vs = v;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + (unsigned int)2)
    {
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned char * restrict tmp_post$1 = d;
      d = d + 1l;
      *tmp_post$1 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])];
      unsigned char * restrict tmp_post$2 = d;
      d = d + 1l;
      *tmp_post$2 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])];
      unsigned char * restrict tmp_post$3 = d;
      d = d + 1l;
      *tmp_post$3 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])];
      y = y + 1l;
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned char * restrict tmp_post$4 = d;
      d = d + 1l;
      *tmp_post$4 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])];
      unsigned char * restrict tmp_post$5 = d;
      d = d + 1l;
      *tmp_post$5 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])];
      unsigned char * restrict tmp_post$6 = d;
      d = d + 1l;
      *tmp_post$6 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])];
      y = y + 1l;
      u = u + 1l;
      v = v + 1l;
    }
    if(i % 2u == 0u)
    {
      u = us;
      v = vs;
    }

    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

// yuv422_to_gray
// file libng/color_yuv2rgb.c line 64
static void yuv422_to_gray(unsigned char * restrict dest, unsigned char * restrict s, signed int p)
{
  unsigned char * restrict d = dest;
  for( ; !(p == 0); s = s + (signed long int)2)
  {
    d[(signed long int)0] = (unsigned char)ng_yuv_gray[(signed long int)s[(signed long int)0]];
    p = p - 1;
    d = d + 1l;
  }
}

// yuv422_to_rgb24
// file libng/color_yuv2rgb.c line 78
static void yuv422_to_rgb24(unsigned char * restrict dest, unsigned char * restrict s, signed int p)
{
  unsigned char * restrict d = dest;
  signed int gray;
  for( ; !(p == 0); p = p - 2)
  {
    gray = (signed int)ng_yuv_gray[(signed long int)s[(signed long int)0]];
    d[(signed long int)0] = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)s[(signed long int)3]])];
    d[(signed long int)1] = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)s[(signed long int)3]] + ng_yuv_g2[(signed long int)s[(signed long int)1]])];
    d[(signed long int)2] = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)s[(signed long int)1]])];
    gray = (signed int)ng_yuv_gray[(signed long int)s[(signed long int)2]];
    d[(signed long int)3] = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)s[(signed long int)3]])];
    d[(signed long int)4] = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)s[(signed long int)3]] + ng_yuv_g2[(signed long int)s[(signed long int)1]])];
    d[(signed long int)5] = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)s[(signed long int)1]])];
    d = d + (signed long int)6;
    s = s + (signed long int)4;
  }
}

// yuv422p_to_rgb24
// file libng/color_yuv2rgb.c line 206
static void yuv422p_to_rgb24(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict u;
  unsigned char * restrict v;
  unsigned char * restrict d;
  unsigned char *dp;
  unsigned int i;
  unsigned int j;
  signed int gray;
  dp = out->data;
  y = in->data;
  u = y + (signed long int)(in->fmt.width * in->fmt.height);
  v = u + (signed long int)((in->fmt.width * in->fmt.height) / (unsigned int)2);
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = dp;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + (unsigned int)2)
    {
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned char * restrict tmp_post$1 = d;
      d = d + 1l;
      *tmp_post$1 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])];
      unsigned char * restrict tmp_post$2 = d;
      d = d + 1l;
      *tmp_post$2 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])];
      unsigned char * restrict tmp_post$3 = d;
      d = d + 1l;
      *tmp_post$3 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])];
      y = y + 1l;
      gray = (signed int)ng_yuv_gray[(signed long int)*y];
      unsigned char * restrict tmp_post$4 = d;
      d = d + 1l;
      *tmp_post$4 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_red[(signed long int)*v])];
      unsigned char * restrict tmp_post$5 = d;
      d = d + 1l;
      *tmp_post$5 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_g1[(signed long int)*v] + ng_yuv_g2[(signed long int)*u])];
      unsigned char * restrict tmp_post$6 = d;
      d = d + 1l;
      *tmp_post$6 = (unsigned char)ng_clip[(signed long int)((unsigned int)(320 + gray) + ng_yuv_blue[(signed long int)*u])];
      y = y + 1l;
      u = u + 1l;
      v = v + 1l;
    }
    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

// yuv42xp_to_gray
// file libng/color_yuv2rgb.c line 149
static void yuv42xp_to_gray(void *h, struct ng_video_buf *out, struct ng_video_buf *in)
{
  unsigned char * restrict y;
  unsigned char * restrict d;
  unsigned char *dp;
  unsigned int i;
  unsigned int j;
  dp = out->data;
  y = in->data;
  i = (unsigned int)0;
  for( ; !(i >= in->fmt.height); i = i + 1u)
  {
    d = dp;
    j = (unsigned int)0;
    for( ; !(j >= in->fmt.width); j = j + 1u)
    {
      *d = (unsigned char)ng_yuv_gray[(signed long int)*y];
      d = d + 1l;
      y = y + 1l;
    }
    dp = dp + (signed long int)out->fmt.bytesperline;
  }
}

