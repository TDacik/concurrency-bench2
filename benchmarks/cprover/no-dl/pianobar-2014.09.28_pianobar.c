// #anon_enum$AVLINK_UNINIT=0$AVLINK_STARTINIT=1$AVLINK_INIT=2
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 760
enum anonymous$37 { AVLINK_UNINIT=0, AVLINK_STARTINIT=1, AVLINK_INIT=2 };

// #anon_enum$AV_CLASS_CATEGORY_NA=0$AV_CLASS_CATEGORY_INPUT=1$AV_CLASS_CATEGORY_OUTPUT=2$AV_CLASS_CATEGORY_MUXER=3$AV_CLASS_CATEGORY_DEMUXER=4$AV_CLASS_CATEGORY_ENCODER=5$AV_CLASS_CATEGORY_DECODER=6$AV_CLASS_CATEGORY_FILTER=7$AV_CLASS_CATEGORY_BITSTREAM_FILTER=8$AV_CLASS_CATEGORY_SWSCALER=9$AV_CLASS_CATEGORY_SWRESAMPLER=10$AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT=40$AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT=41$AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT=42$AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT=43$AV_CLASS_CATEGORY_DEVICE_OUTPUT=44$AV_CLASS_CATEGORY_DEVICE_INPUT=45$AV_CLASS_CATEGORY_NB=46
// file /usr/include/x86_64-linux-gnu/libavutil/log.h line 29
enum anonymous$32 { AV_CLASS_CATEGORY_NA=0, AV_CLASS_CATEGORY_INPUT=1, AV_CLASS_CATEGORY_OUTPUT=2, AV_CLASS_CATEGORY_MUXER=3, AV_CLASS_CATEGORY_DEMUXER=4, AV_CLASS_CATEGORY_ENCODER=5, AV_CLASS_CATEGORY_DECODER=6, AV_CLASS_CATEGORY_FILTER=7, AV_CLASS_CATEGORY_BITSTREAM_FILTER=8, AV_CLASS_CATEGORY_SWSCALER=9, AV_CLASS_CATEGORY_SWRESAMPLER=10, AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT=40, AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT=41, AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT=42, AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT=43, AV_CLASS_CATEGORY_DEVICE_OUTPUT=44, AV_CLASS_CATEGORY_DEVICE_INPUT=45, AV_CLASS_CATEGORY_NB=46 };

// #anon_enum$BAR_DC_UNDEFINED=0$BAR_DC_GLOBAL=1$BAR_DC_STATION=2$BAR_DC_SONG=4
// file src/ui_dispatch.h line 28
enum anonymous$28 { BAR_DC_UNDEFINED=0, BAR_DC_GLOBAL=1, BAR_DC_STATION=2, BAR_DC_SONG=4 };

// #anon_enum$BAR_KS_HELP=0$BAR_KS_LOVE=1$BAR_KS_BAN=2$BAR_KS_ADDMUSIC=3$BAR_KS_CREATESTATION=4$BAR_KS_DELETESTATION=5$BAR_KS_EXPLAIN=6$BAR_KS_GENRESTATION=7$BAR_KS_HISTORY=8$BAR_KS_INFO=9$BAR_KS_ADDSHARED=10$BAR_KS_SKIP=11$BAR_KS_PLAYPAUSE=12$BAR_KS_QUIT=13$BAR_KS_RENAMESTATION=14$BAR_KS_SELECTSTATION=15$BAR_KS_TIRED=16$BAR_KS_UPCOMING=17$BAR_KS_SELECTQUICKMIX=18$BAR_KS_DEBUG=19$BAR_KS_BOOKMARK=20$BAR_KS_VOLDOWN=21$BAR_KS_VOLUP=22$BAR_KS_MANAGESTATION=23$BAR_KS_PLAYPAUSE2=24$BAR_KS_CREATESTATIONFROMSONG=25$BAR_KS_PLAY=26$BAR_KS_PAUSE=27$BAR_KS_VOLRESET=28$BAR_KS_COUNT=29
// file src/settings.h line 33
enum anonymous$36 { BAR_KS_HELP=0, BAR_KS_LOVE=1, BAR_KS_BAN=2, BAR_KS_ADDMUSIC=3, BAR_KS_CREATESTATION=4, BAR_KS_DELETESTATION=5, BAR_KS_EXPLAIN=6, BAR_KS_GENRESTATION=7, BAR_KS_HISTORY=8, BAR_KS_INFO=9, BAR_KS_ADDSHARED=10, BAR_KS_SKIP=11, BAR_KS_PLAYPAUSE=12, BAR_KS_QUIT=13, BAR_KS_RENAMESTATION=14, BAR_KS_SELECTSTATION=15, BAR_KS_TIRED=16, BAR_KS_UPCOMING=17, BAR_KS_SELECTQUICKMIX=18, BAR_KS_DEBUG=19, BAR_KS_BOOKMARK=20, BAR_KS_VOLDOWN=21, BAR_KS_VOLUP=22, BAR_KS_MANAGESTATION=23, BAR_KS_PLAYPAUSE2=24, BAR_KS_CREATESTATIONFROMSONG=25, BAR_KS_PLAY=26, BAR_KS_PAUSE=27, BAR_KS_VOLRESET=28, BAR_KS_COUNT=29 };

// #anon_enum$BAR_RL_DEFAULT=0$BAR_RL_FULLRETURN=1$BAR_RL_NOECHO=2
// file src/ui_readline.h line 30
enum anonymous$45 { BAR_RL_DEFAULT=0, BAR_RL_FULLRETURN=1, BAR_RL_NOECHO=2 };

// #anon_enum$BAR_SORT_NAME_AZ=0$BAR_SORT_NAME_ZA=1$BAR_SORT_QUICKMIX_01_NAME_AZ=2$BAR_SORT_QUICKMIX_01_NAME_ZA=3$BAR_SORT_QUICKMIX_10_NAME_AZ=4$BAR_SORT_QUICKMIX_10_NAME_ZA=5$BAR_SORT_COUNT=6
// file src/settings.h line 69
enum anonymous$38 { BAR_SORT_NAME_AZ=0, BAR_SORT_NAME_ZA=1, BAR_SORT_QUICKMIX_01_NAME_AZ=2, BAR_SORT_QUICKMIX_01_NAME_ZA=3, BAR_SORT_QUICKMIX_10_NAME_AZ=4, BAR_SORT_QUICKMIX_10_NAME_ZA=5, BAR_SORT_COUNT=6 };

// #anon_enum$CHUNKSIZE=0$DATA=1
// file src/libwaitress/waitress.h line 114
enum anonymous$46 { CHUNKSIZE=0, DATA=1 };

// #anon_enum$GNUTLS_CRD_CERTIFICATE=1$GNUTLS_CRD_ANON=2$GNUTLS_CRD_SRP=3$GNUTLS_CRD_PSK=4$GNUTLS_CRD_IA=5
// file /usr/include/gnutls/gnutls.h line 201
enum anonymous$19 { GNUTLS_CRD_CERTIFICATE=1, GNUTLS_CRD_ANON=2, GNUTLS_CRD_SRP=3, GNUTLS_CRD_PSK=4, GNUTLS_CRD_IA=5 };

// #anon_enum$GNUTLS_CRT_UNKNOWN=0$GNUTLS_CRT_X509=1$GNUTLS_CRT_OPENPGP=2$GNUTLS_CRT_RAW=3
// file /usr/include/gnutls/gnutls.h line 569
enum anonymous$10 { GNUTLS_CRT_UNKNOWN=0, GNUTLS_CRT_X509=1, GNUTLS_CRT_OPENPGP=2, GNUTLS_CRT_RAW=3 };

// #anon_enum$GNUTLS_DIG_UNKNOWN=0$GNUTLS_DIG_NULL=1$GNUTLS_DIG_MD5=2$GNUTLS_DIG_SHA1=3$GNUTLS_DIG_RMD160=4$GNUTLS_DIG_MD2=5$GNUTLS_DIG_SHA256=6$GNUTLS_DIG_SHA384=7$GNUTLS_DIG_SHA512=8$GNUTLS_DIG_SHA224=9
// file /usr/include/gnutls/gnutls.h line 264
enum anonymous$21 { GNUTLS_DIG_UNKNOWN=0, GNUTLS_DIG_NULL=1, GNUTLS_DIG_MD5=2, GNUTLS_DIG_SHA1=3, GNUTLS_DIG_RMD160=4, GNUTLS_DIG_MD2=5, GNUTLS_DIG_SHA256=6, GNUTLS_DIG_SHA384=7, GNUTLS_DIG_SHA512=8, GNUTLS_DIG_SHA224=9 };

// #anon_enum$GNUTLS_NAME_DNS=1
// file /usr/include/gnutls/gnutls.h line 998
enum anonymous$25 { GNUTLS_NAME_DNS=1 };

// #anon_enum$GNUTLS_SHUT_RDWR=0$GNUTLS_SHUT_WR=1
// file /usr/include/gnutls/gnutls.h line 525
enum anonymous$23 { GNUTLS_SHUT_RDWR=0, GNUTLS_SHUT_WR=1 };

// #anon_enum$GNUTLS_X509_FMT_DER=0$GNUTLS_X509_FMT_PEM=1
// file /usr/include/gnutls/gnutls.h line 583
enum anonymous$20 { GNUTLS_X509_FMT_DER=0, GNUTLS_X509_FMT_PEM=1 };

// #anon_enum$MSG_NONE=0$MSG_INFO=1$MSG_PLAYING=2$MSG_TIME=3$MSG_ERR=4$MSG_QUESTION=5$MSG_LIST=6$MSG_COUNT=7
// file src/ui_types.h line 27
enum anonymous$34 { MSG_NONE=0, MSG_INFO=1, MSG_PLAYING=2, MSG_TIME=3, MSG_ERR=4, MSG_QUESTION=5, MSG_LIST=6, MSG_COUNT=7 };

// #anon_enum$PIANO_AF_UNKNOWN=0$PIANO_AF_AACPLUS=1$PIANO_AF_MP3=2
// file src/libpiano/piano.h line 71
enum anonymous$30 { PIANO_AF_UNKNOWN=0, PIANO_AF_AACPLUS=1, PIANO_AF_MP3=2 };

// #anon_enum$PIANO_AQ_UNKNOWN=0$PIANO_AQ_LOW=1$PIANO_AQ_MEDIUM=2$PIANO_AQ_HIGH=3
// file src/libpiano/piano.h line 77
enum anonymous$1 { PIANO_AQ_UNKNOWN=0, PIANO_AQ_LOW=1, PIANO_AQ_MEDIUM=2, PIANO_AQ_HIGH=3 };

// #anon_enum$PIANO_MUSICTYPE_INVALID=0$PIANO_MUSICTYPE_SONG=1$PIANO_MUSICTYPE_ARTIST=2
// file src/libpiano/piano.h line 220
enum anonymous$43 { PIANO_MUSICTYPE_INVALID=0, PIANO_MUSICTYPE_SONG=1, PIANO_MUSICTYPE_ARTIST=2 };

// #anon_enum$PIANO_RATE_NONE=0$PIANO_RATE_LOVE=1$PIANO_RATE_BAN=2
// file src/libpiano/piano.h line 64
enum anonymous$29 { PIANO_RATE_NONE=0, PIANO_RATE_LOVE=1, PIANO_RATE_BAN=2 };

// #anon_enum$PIANO_REQUEST_LOGIN=1$PIANO_REQUEST_GET_STATIONS=2$PIANO_REQUEST_GET_PLAYLIST=3$PIANO_REQUEST_RATE_SONG=4$PIANO_REQUEST_ADD_FEEDBACK=5$PIANO_REQUEST_RENAME_STATION=7$PIANO_REQUEST_DELETE_STATION=8$PIANO_REQUEST_SEARCH=9$PIANO_REQUEST_CREATE_STATION=10$PIANO_REQUEST_ADD_SEED=11$PIANO_REQUEST_ADD_TIRED_SONG=12$PIANO_REQUEST_SET_QUICKMIX=13$PIANO_REQUEST_GET_GENRE_STATIONS=14$PIANO_REQUEST_TRANSFORM_STATION=15$PIANO_REQUEST_EXPLAIN=16$PIANO_REQUEST_BOOKMARK_SONG=18$PIANO_REQUEST_BOOKMARK_ARTIST=19$PIANO_REQUEST_GET_STATION_INFO=20$PIANO_REQUEST_DELETE_FEEDBACK=21$PIANO_REQUEST_DELETE_SEED=22
// file src/libpiano/piano.h line 151
enum anonymous$2 { PIANO_REQUEST_LOGIN=1, PIANO_REQUEST_GET_STATIONS=2, PIANO_REQUEST_GET_PLAYLIST=3, PIANO_REQUEST_RATE_SONG=4, PIANO_REQUEST_ADD_FEEDBACK=5, PIANO_REQUEST_RENAME_STATION=7, PIANO_REQUEST_DELETE_STATION=8, PIANO_REQUEST_SEARCH=9, PIANO_REQUEST_CREATE_STATION=10, PIANO_REQUEST_ADD_SEED=11, PIANO_REQUEST_ADD_TIRED_SONG=12, PIANO_REQUEST_SET_QUICKMIX=13, PIANO_REQUEST_GET_GENRE_STATIONS=14, PIANO_REQUEST_TRANSFORM_STATION=15, PIANO_REQUEST_EXPLAIN=16, PIANO_REQUEST_BOOKMARK_SONG=18, PIANO_REQUEST_BOOKMARK_ARTIST=19, PIANO_REQUEST_GET_STATION_INFO=20, PIANO_REQUEST_DELETE_FEEDBACK=21, PIANO_REQUEST_DELETE_SEED=22 };

// #anon_enum$PIANO_RET_ERR=0$PIANO_RET_OK=1$PIANO_RET_INVALID_RESPONSE=2$PIANO_RET_CONTINUE_REQUEST=3$PIANO_RET_OUT_OF_MEMORY=4$PIANO_RET_INVALID_LOGIN=5$PIANO_RET_QUALITY_UNAVAILABLE=6$PIANO_RET_GCRY_ERR=7$PIANO_RET_P_INTERNAL=1024$PIANO_RET_P_API_VERSION_NOT_SUPPORTED=1035$PIANO_RET_P_BIRTH_YEAR_INVALID=2049$PIANO_RET_P_BIRTH_YEAR_TOO_YOUNG=2050$PIANO_RET_P_CALL_NOT_ALLOWED=2032$PIANO_RET_P_CERTIFICATE_REQUIRED=1031$PIANO_RET_P_COMPLIMENTARY_PERIOD_ALREADY_IN_USE=2031$PIANO_RET_P_DAILY_TRIAL_LIMIT_REACHED=2059$PIANO_RET_P_DEVICE_ALREADY_ASSOCIATED_TO_ACCOUNT=2038$PIANO_RET_P_DEVICE_DISABLED=2058$PIANO_RET_P_DEVICE_MODEL_INVALID=2047$PIANO_RET_P_DEVICE_NOT_FOUND=2033$PIANO_RET_P_EXPLICIT_PIN_INCORRECT=2042$PIANO_RET_P_EXPLICIT_PIN_MALFORMED=2044$PIANO_RET_P_INSUFFICIENT_CONNECTIVITY=1037$PIANO_RET_P_INVALID_AUTH_TOKEN=2025$PIANO_RET_P_INVALID_COUNTRY_CODE=2051$PIANO_RET_P_INVALID_GENDER=2051$PIANO_RET_P_INVALID_PARTNER_LOGIN=2026$PIANO_RET_P_INVALID_PASSWORD=2036$PIANO_RET_P_INVALID_SPONSOR=2060$PIANO_RET_P_INVALID_USERNAME=2035$PIANO_RET_P_LICENSING_RESTRICTIONS=1036$PIANO_RET_P_MAINTENANCE_MODE=1025$PIANO_RET_P_MAX_STATIONS_REACHED=2029$PIANO_RET_P_PARAMETER_MISSING=1033$PIANO_RET_P_PARAMETER_TYPE_MISMATCH=1032$PIANO_RET_P_PARAMETER_VALUE_INVALID=1034$PIANO_RET_P_PARTNER_NOT_AUTHORIZED=2034$PIANO_RET_P_READ_ONLY_MODE=2024$PIANO_RET_P_SECURE_PROTOCOL_REQUIRED=1030$PIANO_RET_P_STATION_DOES_NOT_EXIST=2030$PIANO_RET_P_UPGRADE_DEVICE_MODEL_INVALID=2039$PIANO_RET_P_URL_PARAM_MISSING_AUTH_TOKEN=1027$PIANO_RET_P_URL_PARAM_MISSING_METHOD=1026$PIANO_RET_P_URL_PARAM_MISSING_PARTNER_ID=1028$PIANO_RET_P_URL_PARAM_MISSING_USER_ID=1029$PIANO_RET_P_USERNAME_ALREADY_EXISTS=2037$PIANO_RET_P_USER_ALREADY_USED_TRIAL=2061$PIANO_RET_P_LISTENER_NOT_AUTHORIZED=2027$PIANO_RET_P_USER_NOT_AUTHORIZED=2028$PIANO_RET_P_ZIP_CODE_INVALID=2048$PIANO_RET_P_RATE_LIMIT=2063
// file src/libpiano/piano.h line 250
enum anonymous$4 { PIANO_RET_ERR=0, PIANO_RET_OK=1, PIANO_RET_INVALID_RESPONSE=2, PIANO_RET_CONTINUE_REQUEST=3, PIANO_RET_OUT_OF_MEMORY=4, PIANO_RET_INVALID_LOGIN=5, PIANO_RET_QUALITY_UNAVAILABLE=6, PIANO_RET_GCRY_ERR=7, PIANO_RET_P_INTERNAL=1024, PIANO_RET_P_API_VERSION_NOT_SUPPORTED=1035, PIANO_RET_P_BIRTH_YEAR_INVALID=2049, PIANO_RET_P_BIRTH_YEAR_TOO_YOUNG=2050, PIANO_RET_P_CALL_NOT_ALLOWED=2032, PIANO_RET_P_CERTIFICATE_REQUIRED=1031, PIANO_RET_P_COMPLIMENTARY_PERIOD_ALREADY_IN_USE=2031, PIANO_RET_P_DAILY_TRIAL_LIMIT_REACHED=2059, PIANO_RET_P_DEVICE_ALREADY_ASSOCIATED_TO_ACCOUNT=2038, PIANO_RET_P_DEVICE_DISABLED=2058, PIANO_RET_P_DEVICE_MODEL_INVALID=2047, PIANO_RET_P_DEVICE_NOT_FOUND=2033, PIANO_RET_P_EXPLICIT_PIN_INCORRECT=2042, PIANO_RET_P_EXPLICIT_PIN_MALFORMED=2044, PIANO_RET_P_INSUFFICIENT_CONNECTIVITY=1037, PIANO_RET_P_INVALID_AUTH_TOKEN=2025, PIANO_RET_P_INVALID_COUNTRY_CODE=2051, PIANO_RET_P_INVALID_GENDER=2051, PIANO_RET_P_INVALID_PARTNER_LOGIN=2026, PIANO_RET_P_INVALID_PASSWORD=2036, PIANO_RET_P_INVALID_SPONSOR=2060, PIANO_RET_P_INVALID_USERNAME=2035, PIANO_RET_P_LICENSING_RESTRICTIONS=1036, PIANO_RET_P_MAINTENANCE_MODE=1025, PIANO_RET_P_MAX_STATIONS_REACHED=2029, PIANO_RET_P_PARAMETER_MISSING=1033, PIANO_RET_P_PARAMETER_TYPE_MISMATCH=1032, PIANO_RET_P_PARAMETER_VALUE_INVALID=1034, PIANO_RET_P_PARTNER_NOT_AUTHORIZED=2034, PIANO_RET_P_READ_ONLY_MODE=2024, PIANO_RET_P_SECURE_PROTOCOL_REQUIRED=1030, PIANO_RET_P_STATION_DOES_NOT_EXIST=2030, PIANO_RET_P_UPGRADE_DEVICE_MODEL_INVALID=2039, PIANO_RET_P_URL_PARAM_MISSING_AUTH_TOKEN=1027, PIANO_RET_P_URL_PARAM_MISSING_METHOD=1026, PIANO_RET_P_URL_PARAM_MISSING_PARTNER_ID=1028, PIANO_RET_P_URL_PARAM_MISSING_USER_ID=1029, PIANO_RET_P_USERNAME_ALREADY_EXISTS=2037, PIANO_RET_P_USER_ALREADY_USED_TRIAL=2061, PIANO_RET_P_LISTENER_NOT_AUTHORIZED=2027, PIANO_RET_P_USER_NOT_AUTHORIZED=2028, PIANO_RET_P_ZIP_CODE_INVALID=2048, PIANO_RET_P_RATE_LIMIT=2063 };

// #anon_enum$PLAYER_DEAD=0$PLAYER_STARTING=1$PLAYER_PLAYING=2$PLAYER_FINISHED=3
// file src/player.h line 51
enum anonymous$41 { PLAYER_DEAD=0, PLAYER_STARTING=1, PLAYER_PLAYING=2, PLAYER_FINISHED=3 };

// #anon_enum$WAITRESS_CB_RET_ERR=0$WAITRESS_CB_RET_OK=1
// file src/libwaitress/waitress.h line 39
enum anonymous$8 { WAITRESS_CB_RET_ERR=0, WAITRESS_CB_RET_OK=1 };

// #anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3
// file src/libwaitress/waitress.h line 44
enum anonymous$12 { WAITRESS_HANDLER_CONTINUE=0, WAITRESS_HANDLER_DONE=1, WAITRESS_HANDLER_ERR=2, WAITRESS_HANDLER_ABORTED=3 };

// #anon_enum$WAITRESS_METHOD_GET=0$WAITRESS_METHOD_POST=1
// file src/libwaitress/waitress.h line 34
enum anonymous$22 { WAITRESS_METHOD_GET=0, WAITRESS_METHOD_POST=1 };

// #anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18
// file src/libwaitress/waitress.h line 62
enum anonymous$5 { WAITRESS_RET_ERR=0, WAITRESS_RET_OK=1, WAITRESS_RET_CB_ABORT=2, WAITRESS_RET_STATUS_UNKNOWN=3, WAITRESS_RET_NOTFOUND=4, WAITRESS_RET_FORBIDDEN=5, WAITRESS_RET_BAD_REQUEST=6, WAITRESS_RET_CONNECT_REFUSED=7, WAITRESS_RET_SOCK_ERR=8, WAITRESS_RET_GETADDR_ERR=9, WAITRESS_RET_TIMEOUT=10, WAITRESS_RET_READ_ERR=11, WAITRESS_RET_CONNECTION_CLOSED=12, WAITRESS_RET_TLS_WRITE_ERR=13, WAITRESS_RET_TLS_READ_ERR=14, WAITRESS_RET_PARTIAL_FILE=15, WAITRESS_RET_DECODING_ERR=16, WAITRESS_RET_TLS_HANDSHAKE_ERR=17, WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18 };

// tag-#anon#ST[*{S8}$S8$'data'||U64'pos'|]
// file src/libwaitress/waitress.c line 52
struct anonymous$9;

// tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]
// file src/settings.h line 81
struct anonymous$39;

// tag-#anon#ST[*{S8}$S8$'searchStr'||SYM#tag-PianoSearchResult#'searchResult'|]
// file src/libpiano/piano.h line 213
struct anonymous$55;

// tag-#anon#ST[*{S8}$S8$'stationId'||*{S8}$S8$'trackToken'||EN#anon_enum$PIANO_RATE_NONE=0$PIANO_RATE_LOVE=1$PIANO_RATE_BAN=2#{U32}$U32$'rating'||U32'$pad0'|]
// file src/libpiano/piano.h line 202
struct anonymous$56;

// tag-#anon#ST[*{S8}$S8$'token'||EN#anon_enum$PIANO_MUSICTYPE_INVALID=0$PIANO_MUSICTYPE_SONG=1$PIANO_MUSICTYPE_ARTIST=2#{U32}$U32$'type'||U32'$pad0'|]
// file src/libpiano/piano.h line 218
struct anonymous$44;

// tag-#anon#ST[*{S8}$S8$'url'||B'tls'||U56'$pad0'||*{cS8}$cS8$'user'||*{cS8}$cS8$'password'||*{cS8}$cS8$'host'||*{cS8}$cS8$'port'||*{cS8}$cS8$'tlsPort'||*{cS8}$cS8$'path'|]
// file src/libwaitress/waitress.h line 51
struct anonymous$16;

// tag-#anon#ST[*{S8}$S8$'user'||*{S8}$S8$'password'||U8'step'||U56'$pad0'|]
// file src/libpiano/piano.h line 185
struct anonymous$13;

// tag-#anon#ST[*{SYM#tag-PianoSong#}$SYM#tag-PianoSong#$'song'||*{S8}$S8$'retExplain'|]
// file src/libpiano/piano.h line 232
struct anonymous$42;

// tag-#anon#ST[*{SYM#tag-PianoSong#}$SYM#tag-PianoSong#$'song'||*{SYM#tag-PianoArtist#}$SYM#tag-PianoArtist#$'artist'||*{SYM#tag-PianoStation#}$SYM#tag-PianoStation#$'station'|]
// file src/libpiano/piano.h line 242
struct anonymous$52;

// tag-#anon#ST[*{SYM#tag-PianoSong#}$SYM#tag-PianoSong#$'song'||EN#anon_enum$PIANO_RATE_NONE=0$PIANO_RATE_LOVE=1$PIANO_RATE_BAN=2#{U32}$U32$'rating'||U32'$pad0'|]
// file src/libpiano/piano.h line 197
struct anonymous$48;

// tag-#anon#ST[*{SYM#tag-PianoSong#}$SYM#tag-PianoSong#$'songSeeds'||*{SYM#tag-PianoArtist#}$SYM#tag-PianoArtist#$'artistSeeds'||*{SYM#tag-PianoStation#}$SYM#tag-PianoStation#$'stationSeeds'||*{SYM#tag-PianoSong#}$SYM#tag-PianoSong#$'feedback'|]
// file src/libpiano/piano.h line 144
struct anonymous$50;

// tag-#anon#ST[*{SYM#tag-PianoStation#}$SYM#tag-PianoStation#$'station'||*{S8}$S8$'musicId'|]
// file src/libpiano/piano.h line 227
struct anonymous$54;

// tag-#anon#ST[*{SYM#tag-PianoStation#}$SYM#tag-PianoStation#$'station'||*{S8}$S8$'newName'|]
// file src/libpiano/piano.h line 208
struct anonymous$49;

// tag-#anon#ST[*{SYM#tag-PianoStation#}$SYM#tag-PianoStation#$'station'||EN#anon_enum$PIANO_AQ_UNKNOWN=0$PIANO_AQ_LOW=1$PIANO_AQ_MEDIUM=2$PIANO_AQ_HIGH=3#{U32}$U32$'quality'||U32'$pad0'||*{SYM#tag-PianoSong#}$SYM#tag-PianoSong#$'retPlaylist'|]
// file src/libpiano/piano.h line 191
struct anonymous$14;

// tag-#anon#ST[*{SYM#tag-PianoStation#}$SYM#tag-PianoStation#$'station'||SYM#tag-#anon#ST[*{SYM#tag-PianoSong#}$SYM#tag-PianoSong#$'songSeeds'||*{SYM#tag-PianoArtist#}$SYM#tag-PianoArtist#$'artistSeeds'||*{SYM#tag-PianoStation#}$SYM#tag-PianoStation#$'stationSeeds'||*{SYM#tag-PianoSong#}$SYM#tag-PianoSong#$'feedback'|]#'info'|]
// file src/libpiano/piano.h line 237
struct anonymous$51;

// tag-#anon#ST[*{U8}$U8$'data'||U32'size'||U32'$pad0'|]
// file /usr/include/gnutls/gnutls.h line 766
struct anonymous$11;

// tag-#anon#ST[ARR16{S64}$S64$'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$47;

// tag-#anon#ST[B'autoselect'||U24'$pad0'||U32'history'||U32'maxPlayerErrors'||S32'volume'||EN#anon_enum$BAR_SORT_NAME_AZ=0$BAR_SORT_NAME_ZA=1$BAR_SORT_QUICKMIX_01_NAME_AZ=2$BAR_SORT_QUICKMIX_01_NAME_ZA=3$BAR_SORT_QUICKMIX_10_NAME_AZ=4$BAR_SORT_QUICKMIX_10_NAME_ZA=5$BAR_SORT_COUNT=6#{U32}$U32$'sortOrder'||EN#anon_enum$PIANO_AQ_UNKNOWN=0$PIANO_AQ_LOW=1$PIANO_AQ_MEDIUM=2$PIANO_AQ_HIGH=3#{U32}$U32$'audioQuality'||*{S8}$S8$'username'||*{S8}$S8$'password'||*{S8}$S8$'passwordCmd'||*{S8}$S8$'controlProxy'||*{S8}$S8$'proxy'||*{S8}$S8$'autostartStation'||*{S8}$S8$'eventCmd'||*{S8}$S8$'loveIcon'||*{S8}$S8$'banIcon'||*{S8}$S8$'atIcon'||*{S8}$S8$'npSongFormat'||*{S8}$S8$'npStationFormat'||*{S8}$S8$'listSongFormat'||*{S8}$S8$'fifo'||*{S8}$S8$'rpcHost'||*{S8}$S8$'rpcTlsPort'||*{S8}$S8$'partnerUser'||*{S8}$S8$'partnerPassword'||*{S8}$S8$'device'||*{S8}$S8$'inkey'||*{S8}$S8$'outkey'||ARR20{S8}$S8$'tlsFingerprint'||ARR29{S8}$S8$'keys'||U56'$pad1'||ARR7{SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#$'msgFormat'|]
// file src/settings.h line 86
struct anonymous$33;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 140
struct anonymous$17;

// tag-#anon#ST[S32'sockfd'||EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$'readWriteRet'||U64'contentLength'||U64'contentReceived'||U64'chunkSize'||B'contentLengthKnown'||U24'$pad0'||EN#anon_enum$CHUNKSIZE=0$DATA=1#{U32}$U32$'chunkedState'||*{S8}$S8$'buf'||*{EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64)->EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$}$EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64)->EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$$'dataHandler'||*{EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64|*{U64}$U64$)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$}$EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64|*{U64}$U64$)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$$'read'||*{EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{cS8}$cS8$|cU64)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$}$EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{cS8}$cS8$|cU64)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$$'write'||*{SYM#tag-gnutls_session_int#}$SYM#tag-gnutls_session_int#$'tlsSession'|]
// file src/libwaitress/waitress.h line 106
struct anonymous$15;

// tag-#anon#ST[S32'timeout'||EN#anon_enum$WAITRESS_METHOD_GET=0$WAITRESS_METHOD_POST=1#{U32}$U32$'method'||*{cS8}$cS8$'extraHeaders'||*{cS8}$cS8$'postData'||*{V}$V$'data'||*{EN#anon_enum$WAITRESS_CB_RET_ERR=0$WAITRESS_CB_RET_OK=1#{U32}$U32$(*{V}$V$|U64|*{V}$V$)->EN#anon_enum$WAITRESS_CB_RET_ERR=0$WAITRESS_CB_RET_OK=1#{U32}$U32$}$EN#anon_enum$WAITRESS_CB_RET_ERR=0$WAITRESS_CB_RET_OK=1#{U32}$U32$(*{V}$V$|U64|*{V}$V$)->EN#anon_enum$WAITRESS_CB_RET_ERR=0$WAITRESS_CB_RET_OK=1#{U32}$U32$$'callback'||*{cS8}$cS8$'tlsFingerprint'||SYM#tag-#anon#ST[*{S8}$S8$'url'||B'tls'||U56'$pad0'||*{cS8}$cS8$'user'||*{cS8}$cS8$'password'||*{cS8}$cS8$'host'||*{cS8}$cS8$'port'||*{cS8}$cS8$'tlsPort'||*{cS8}$cS8$'path'|]#'url'||SYM#tag-#anon#ST[*{S8}$S8$'url'||B'tls'||U56'$pad0'||*{cS8}$cS8$'user'||*{cS8}$cS8$'password'||*{cS8}$cS8$'host'||*{cS8}$cS8$'port'||*{cS8}$cS8$'tlsPort'||*{cS8}$cS8$'path'|]#'proxy'||*{SYM#tag-gnutls_certificate_credentials_st#}$SYM#tag-gnutls_certificate_credentials_st#$'tlsCred'||SYM#tag-#anon#ST[S32'sockfd'||EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$'readWriteRet'||U64'contentLength'||U64'contentReceived'||U64'chunkSize'||B'contentLengthKnown'||U24'$pad0'||EN#anon_enum$CHUNKSIZE=0$DATA=1#{U32}$U32$'chunkedState'||*{S8}$S8$'buf'||*{EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64)->EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$}$EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64)->EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$$'dataHandler'||*{EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64|*{U64}$U64$)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$}$EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64|*{U64}$U64$)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$$'read'||*{EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{cS8}$cS8$|cU64)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$}$EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{cS8}$cS8$|cU64)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$$'write'||*{SYM#tag-gnutls_session_int#}$SYM#tag-gnutls_session_int#$'tlsSession'|]#'request'|]
// file src/libwaitress/waitress.h line 89
struct anonymous$7;

// tag-#anon#ST[S64'last_dts'||S64'duration_gcd'||S32'duration_count'||U32'$pad0'||S64'rfps_duration_sum'||*{ARR2{ARR373{F64}$F64$}$ARR373{F64}$F64$$}$ARR2{ARR373{F64}$F64$}$ARR373{F64}$F64$$$'duration_error'||S64'codec_info_duration'||S64'codec_info_duration_fields'||S32'found_decoder'||U32'$pad1'||S64'last_duration'||S64'fps_first_dts'||S32'fps_first_dts_idx'||U32'$pad2'||S64'fps_last_dts'||S32'fps_last_dts_idx'||U32'$pad3'|]
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 972
struct anonymous$6;

// tag-#anon#ST[S8'defaultKey'||U24'$pad0'||EN#anon_enum$BAR_DC_UNDEFINED=0$BAR_DC_GLOBAL=1$BAR_DC_STATION=2$BAR_DC_SONG=4#{U32}$U32$'context'||*{V(*{SYM#tag-#anon#ST[SYM#tag-PianoHandle#'ph'||SYM#tag-#anon#ST[S32'timeout'||EN#anon_enum$WAITRESS_METHOD_GET=0$WAITRESS_METHOD_POST=1#{U32}$U32$'method'||*{cS8}$cS8$'extraHeaders'||*{cS8}$cS8$'postData'||*{V}$V$'data'||*{EN#anon_enum$WAITRESS_CB_RET_ERR=0$WAITRESS_CB_RET_OK=1#{U32}$U32$(*{V}$V$|U64|*{V}$V$)->EN#anon_enum$WAITRESS_CB_RET_ERR=0$WAITRESS_CB_RET_OK=1#{U32}$U32$}$EN#anon_enum$WAITRESS_CB_RET_ERR=0$WAITRESS_CB_RET_OK=1#{U32}$U32$(*{V}$V$|U64|*{V}$V$)->EN#anon_enum$WAITRESS_CB_RET_ERR=0$WAITRESS_CB_RET_OK=1#{U32}$U32$$'callback'||*{cS8}$cS8$'tlsFingerprint'||SYM#tag-#anon#ST[*{S8}$S8$'url'||B'tls'||U56'$pad0'||*{cS8}$cS8$'user'||*{cS8}$cS8$'password'||*{cS8}$cS8$'host'||*{cS8}$cS8$'port'||*{cS8}$cS8$'tlsPort'||*{cS8}$cS8$'path'|]#'url'||SYM#tag-#anon#ST[*{S8}$S8$'url'||B'tls'||U56'$pad0'||*{cS8}$cS8$'user'||*{cS8}$cS8$'password'||*{cS8}$cS8$'host'||*{cS8}$cS8$'port'||*{cS8}$cS8$'tlsPort'||*{cS8}$cS8$'path'|]#'proxy'||*{SYM#tag-gnutls_certificate_credentials_st#}$SYM#tag-gnutls_certificate_credentials_st#$'tlsCred'||SYM#tag-#anon#ST[S32'sockfd'||EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$'readWriteRet'||U64'contentLength'||U64'contentReceived'||U64'chunkSize'||B'contentLengthKnown'||U24'$pad0'||EN#anon_enum$CHUNKSIZE=0$DATA=1#{U32}$U32$'chunkedState'||*{S8}$S8$'buf'||*{EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64)->EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$}$EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64)->EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$$'dataHandler'||*{EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64|*{U64}$U64$)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$}$EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64|*{U64}$U64$)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$$'read'||*{EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{cS8}$cS8$|cU64)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$}$EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{cS8}$cS8$|cU64)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$$'write'||*{SYM#tag-gnutls_session_int#}$SYM#tag-gnutls_session_int#$'tlsSession'|]#'request'|]#'waith'||SYM#tag-#anon#ST[vB'doQuit'||vB'doPause'||U48'$pad0'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'pauseMutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'pauseCond'||EN#anon_enum$PLAYER_DEAD=0$PLAYER_STARTING=1$PLAYER_PLAYING=2$PLAYER_FINISHED=3#{U32}$U32$'mode'||U32'$pad1'||*{SYM#tag-AVFilterContext#}$SYM#tag-AVFilterContext#$'fvolume'||*{SYM#tag-AVFilterGraph#}$SYM#tag-AVFilterGraph#$'fgraph'||*{SYM#tag-AVFormatContext#}$SYM#tag-AVFormatContext#$'fctx'||*{SYM#tag-AVStream#}$SYM#tag-AVStream#$'st'||*{SYM#tag-AVFilterContext#}$SYM#tag-AVFilterContext#$'fbufsink'||*{SYM#tag-AVFilterContext#}$SYM#tag-AVFilterContext#$'fabuf'||S32'streamIdx'||U32'$pad2'||S64'lastTimestamp'||*{SYM#tag-ao_device#}$SYM#tag-ao_device#$'aoDev'||vF64'volume'||F64'gain'||*{S8}$S8$'url'||*{cSYM#tag-#anon#ST[B'autoselect'||U24'$pad0'||U32'history'||U32'maxPlayerErrors'||S32'volume'||EN#anon_enum$BAR_SORT_NAME_AZ=0$BAR_SORT_NAME_ZA=1$BAR_SORT_QUICKMIX_01_NAME_AZ=2$BAR_SORT_QUICKMIX_01_NAME_ZA=3$BAR_SORT_QUICKMIX_10_NAME_AZ=4$BAR_SORT_QUICKMIX_10_NAME_ZA=5$BAR_SORT_COUNT=6#{U32}$U32$'sortOrder'||EN#anon_enum$PIANO_AQ_UNKNOWN=0$PIANO_AQ_LOW=1$PIANO_AQ_MEDIUM=2$PIANO_AQ_HIGH=3#{U32}$U32$'audioQuality'||*{S8}$S8$'username'||*{S8}$S8$'password'||*{S8}$S8$'passwordCmd'||*{S8}$S8$'controlProxy'||*{S8}$S8$'proxy'||*{S8}$S8$'autostartStation'||*{S8}$S8$'eventCmd'||*{S8}$S8$'loveIcon'||*{S8}$S8$'banIcon'||*{S8}$S8$'atIcon'||*{S8}$S8$'npSongFormat'||*{S8}$S8$'npStationFormat'||*{S8}$S8$'listSongFormat'||*{S8}$S8$'fifo'||*{S8}$S8$'rpcHost'||*{S8}$S8$'rpcTlsPort'||*{S8}$S8$'partnerUser'||*{S8}$S8$'partnerPassword'||*{S8}$S8$'device'||*{S8}$S8$'inkey'||*{S8}$S8$'outkey'||ARR20{S8}$S8$'tlsFingerprint'||ARR29{S8}$S8$'keys'||U56'$pad1'||ARR7{SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#$'msgFormat'|]#}$cSYM#tag-#anon#ST[B'autoselect'||U24'$pad0'||U32'history'||U32'maxPlayerErrors'||S32'volume'||EN#anon_enum$BAR_SORT_NAME_AZ=0$BAR_SORT_NAME_ZA=1$BAR_SORT_QUICKMIX_01_NAME_AZ=2$BAR_SORT_QUICKMIX_01_NAME_ZA=3$BAR_SORT_QUICKMIX_10_NAME_AZ=4$BAR_SORT_QUICKMIX_10_NAME_ZA=5$BAR_SORT_COUNT=6#{U32}$U32$'sortOrder'||EN#anon_enum$PIANO_AQ_UNKNOWN=0$PIANO_AQ_LOW=1$PIANO_AQ_MEDIUM=2$PIANO_AQ_HIGH=3#{U32}$U32$'audioQuality'||*{S8}$S8$'username'||*{S8}$S8$'password'||*{S8}$S8$'passwordCmd'||*{S8}$S8$'controlProxy'||*{S8}$S8$'proxy'||*{S8}$S8$'autostartStation'||*{S8}$S8$'eventCmd'||*{S8}$S8$'loveIcon'||*{S8}$S8$'banIcon'||*{S8}$S8$'atIcon'||*{S8}$S8$'npSongFormat'||*{S8}$S8$'npStationFormat'||*{S8}$S8$'listSongFormat'||*{S8}$S8$'fifo'||*{S8}$S8$'rpcHost'||*{S8}$S8$'rpcTlsPort'||*{S8}$S8$'partnerUser'||*{S8}$S8$'partnerPassword'||*{S8}$S8$'device'||*{S8}$S8$'inkey'||*{S8}$S8$'outkey'||ARR20{S8}$S8$'tlsFingerprint'||ARR29{S8}$S8$'keys'||U56'$pad1'||ARR7{SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#$'msgFormat'|]#$'settings'||vU32'songDuration'||vU32'songPlayed'|]#'player'||SYM#tag-#anon#ST[B'autoselect'||U24'$pad0'||U32'history'||U32'maxPlayerErrors'||S32'volume'||EN#anon_enum$BAR_SORT_NAME_AZ=0$BAR_SORT_NAME_ZA=1$BAR_SORT_QUICKMIX_01_NAME_AZ=2$BAR_SORT_QUICKMIX_01_NAME_ZA=3$BAR_SORT_QUICKMIX_10_NAME_AZ=4$BAR_SORT_QUICKMIX_10_NAME_ZA=5$BAR_SORT_COUNT=6#{U32}$U32$'sortOrder'||EN#anon_enum$PIANO_AQ_UNKNOWN=0$PIANO_AQ_LOW=1$PIANO_AQ_MEDIUM=2$PIANO_AQ_HIGH=3#{U32}$U32$'audioQuality'||*{S8}$S8$'username'||*{S8}$S8$'password'||*{S8}$S8$'passwordCmd'||*{S8}$S8$'controlProxy'||*{S8}$S8$'proxy'||*{S8}$S8$'autostartStation'||*{S8}$S8$'eventCmd'||*{S8}$S8$'loveIcon'||*{S8}$S8$'banIcon'||*{S8}$S8$'atIcon'||*{S8}$S8$'npSongFormat'||*{S8}$S8$'npStationFormat'||*{S8}$S8$'listSongFormat'||*{S8}$S8$'fifo'||*{S8}$S8$'rpcHost'||*{S8}$S8$'rpcTlsPort'||*{S8}$S8$'partnerUser'||*{S8}$S8$'partnerPassword'||*{S8}$S8$'device'||*{S8}$S8$'inkey'||*{S8}$S8$'outkey'||ARR20{S8}$S8$'tlsFingerprint'||ARR29{S8}$S8$'keys'||U56'$pad1'||ARR7{SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#$'msgFormat'|]#'settings'||*{SYM#tag-PianoSong#}$SYM#tag-PianoSong#$'playlist'||*{SYM#tag-PianoSong#}$SYM#tag-PianoSong#$'songHistory'||*{SYM#tag-PianoStation#}$SYM#tag-PianoStation#$'curStation'||S8'doQuit'||U56'$pad0'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR16{S64}$S64$'__fds_bits'|]#'set'||S32'maxfd'||ARR2{S32}$S32$'fds'||U32'$pad0'|]#'input'||U32'playerErrors'||U32'$pad1'|]#}$SYM#tag-#anon#ST[SYM#tag-PianoHandle#'ph'||SYM#tag-#anon#ST[S32'timeout'||EN#anon_enum$WAITRESS_METHOD_GET=0$WAITRESS_METHOD_POST=1#{U32}$U32$'method'||*{cS8}$cS8$'extraHeaders'||*{cS8}$cS8$'postData'||*{V}$V$'data'||*{EN#anon_enum$WAITRESS_CB_RET_ERR=0$WAITRESS_CB_RET_OK=1#{U32}$U32$(*{V}$V$|U64|*{V}$V$)->EN#anon_enum$WAITRESS_CB_RET_ERR=0$WAITRESS_CB_RET_OK=1#{U32}$U32$}$EN#anon_enum$WAITRESS_CB_RET_ERR=0$WAITRESS_CB_RET_OK=1#{U32}$U32$(*{V}$V$|U64|*{V}$V$)->EN#anon_enum$WAITRESS_CB_RET_ERR=0$WAITRESS_CB_RET_OK=1#{U32}$U32$$'callback'||*{cS8}$cS8$'tlsFingerprint'||SYM#tag-#anon#ST[*{S8}$S8$'url'||B'tls'||U56'$pad0'||*{cS8}$cS8$'user'||*{cS8}$cS8$'password'||*{cS8}$cS8$'host'||*{cS8}$cS8$'port'||*{cS8}$cS8$'tlsPort'||*{cS8}$cS8$'path'|]#'url'||SYM#tag-#anon#ST[*{S8}$S8$'url'||B'tls'||U56'$pad0'||*{cS8}$cS8$'user'||*{cS8}$cS8$'password'||*{cS8}$cS8$'host'||*{cS8}$cS8$'port'||*{cS8}$cS8$'tlsPort'||*{cS8}$cS8$'path'|]#'proxy'||*{SYM#tag-gnutls_certificate_credentials_st#}$SYM#tag-gnutls_certificate_credentials_st#$'tlsCred'||SYM#tag-#anon#ST[S32'sockfd'||EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$'readWriteRet'||U64'contentLength'||U64'contentReceived'||U64'chunkSize'||B'contentLengthKnown'||U24'$pad0'||EN#anon_enum$CHUNKSIZE=0$DATA=1#{U32}$U32$'chunkedState'||*{S8}$S8$'buf'||*{EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64)->EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$}$EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64)->EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$$'dataHandler'||*{EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64|*{U64}$U64$)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$}$EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64|*{U64}$U64$)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$$'read'||*{EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{cS8}$cS8$|cU64)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$}$EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{cS8}$cS8$|cU64)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$$'write'||*{SYM#tag-gnutls_session_int#}$SYM#tag-gnutls_session_int#$'tlsSession'|]#'request'|]#'waith'||SYM#tag-#anon#ST[vB'doQuit'||vB'doPause'||U48'$pad0'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'pauseMutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'pauseCond'||EN#anon_enum$PLAYER_DEAD=0$PLAYER_STARTING=1$PLAYER_PLAYING=2$PLAYER_FINISHED=3#{U32}$U32$'mode'||U32'$pad1'||*{SYM#tag-AVFilterContext#}$SYM#tag-AVFilterContext#$'fvolume'||*{SYM#tag-AVFilterGraph#}$SYM#tag-AVFilterGraph#$'fgraph'||*{SYM#tag-AVFormatContext#}$SYM#tag-AVFormatContext#$'fctx'||*{SYM#tag-AVStream#}$SYM#tag-AVStream#$'st'||*{SYM#tag-AVFilterContext#}$SYM#tag-AVFilterContext#$'fbufsink'||*{SYM#tag-AVFilterContext#}$SYM#tag-AVFilterContext#$'fabuf'||S32'streamIdx'||U32'$pad2'||S64'lastTimestamp'||*{SYM#tag-ao_device#}$SYM#tag-ao_device#$'aoDev'||vF64'volume'||F64'gain'||*{S8}$S8$'url'||*{cSYM#tag-#anon#ST[B'autoselect'||U24'$pad0'||U32'history'||U32'maxPlayerErrors'||S32'volume'||EN#anon_enum$BAR_SORT_NAME_AZ=0$BAR_SORT_NAME_ZA=1$BAR_SORT_QUICKMIX_01_NAME_AZ=2$BAR_SORT_QUICKMIX_01_NAME_ZA=3$BAR_SORT_QUICKMIX_10_NAME_AZ=4$BAR_SORT_QUICKMIX_10_NAME_ZA=5$BAR_SORT_COUNT=6#{U32}$U32$'sortOrder'||EN#anon_enum$PIANO_AQ_UNKNOWN=0$PIANO_AQ_LOW=1$PIANO_AQ_MEDIUM=2$PIANO_AQ_HIGH=3#{U32}$U32$'audioQuality'||*{S8}$S8$'username'||*{S8}$S8$'password'||*{S8}$S8$'passwordCmd'||*{S8}$S8$'controlProxy'||*{S8}$S8$'proxy'||*{S8}$S8$'autostartStation'||*{S8}$S8$'eventCmd'||*{S8}$S8$'loveIcon'||*{S8}$S8$'banIcon'||*{S8}$S8$'atIcon'||*{S8}$S8$'npSongFormat'||*{S8}$S8$'npStationFormat'||*{S8}$S8$'listSongFormat'||*{S8}$S8$'fifo'||*{S8}$S8$'rpcHost'||*{S8}$S8$'rpcTlsPort'||*{S8}$S8$'partnerUser'||*{S8}$S8$'partnerPassword'||*{S8}$S8$'device'||*{S8}$S8$'inkey'||*{S8}$S8$'outkey'||ARR20{S8}$S8$'tlsFingerprint'||ARR29{S8}$S8$'keys'||U56'$pad1'||ARR7{SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#$'msgFormat'|]#}$cSYM#tag-#anon#ST[B'autoselect'||U24'$pad0'||U32'history'||U32'maxPlayerErrors'||S32'volume'||EN#anon_enum$BAR_SORT_NAME_AZ=0$BAR_SORT_NAME_ZA=1$BAR_SORT_QUICKMIX_01_NAME_AZ=2$BAR_SORT_QUICKMIX_01_NAME_ZA=3$BAR_SORT_QUICKMIX_10_NAME_AZ=4$BAR_SORT_QUICKMIX_10_NAME_ZA=5$BAR_SORT_COUNT=6#{U32}$U32$'sortOrder'||EN#anon_enum$PIANO_AQ_UNKNOWN=0$PIANO_AQ_LOW=1$PIANO_AQ_MEDIUM=2$PIANO_AQ_HIGH=3#{U32}$U32$'audioQuality'||*{S8}$S8$'username'||*{S8}$S8$'password'||*{S8}$S8$'passwordCmd'||*{S8}$S8$'controlProxy'||*{S8}$S8$'proxy'||*{S8}$S8$'autostartStation'||*{S8}$S8$'eventCmd'||*{S8}$S8$'loveIcon'||*{S8}$S8$'banIcon'||*{S8}$S8$'atIcon'||*{S8}$S8$'npSongFormat'||*{S8}$S8$'npStationFormat'||*{S8}$S8$'listSongFormat'||*{S8}$S8$'fifo'||*{S8}$S8$'rpcHost'||*{S8}$S8$'rpcTlsPort'||*{S8}$S8$'partnerUser'||*{S8}$S8$'partnerPassword'||*{S8}$S8$'device'||*{S8}$S8$'inkey'||*{S8}$S8$'outkey'||ARR20{S8}$S8$'tlsFingerprint'||ARR29{S8}$S8$'keys'||U56'$pad1'||ARR7{SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#$'msgFormat'|]#$'settings'||vU32'songDuration'||vU32'songPlayed'|]#'player'||SYM#tag-#anon#ST[B'autoselect'||U24'$pad0'||U32'history'||U32'maxPlayerErrors'||S32'volume'||EN#anon_enum$BAR_SORT_NAME_AZ=0$BAR_SORT_NAME_ZA=1$BAR_SORT_QUICKMIX_01_NAME_AZ=2$BAR_SORT_QUICKMIX_01_NAME_ZA=3$BAR_SORT_QUICKMIX_10_NAME_AZ=4$BAR_SORT_QUICKMIX_10_NAME_ZA=5$BAR_SORT_COUNT=6#{U32}$U32$'sortOrder'||EN#anon_enum$PIANO_AQ_UNKNOWN=0$PIANO_AQ_LOW=1$PIANO_AQ_MEDIUM=2$PIANO_AQ_HIGH=3#{U32}$U32$'audioQuality'||*{S8}$S8$'username'||*{S8}$S8$'password'||*{S8}$S8$'passwordCmd'||*{S8}$S8$'controlProxy'||*{S8}$S8$'proxy'||*{S8}$S8$'autostartStation'||*{S8}$S8$'eventCmd'||*{S8}$S8$'loveIcon'||*{S8}$S8$'banIcon'||*{S8}$S8$'atIcon'||*{S8}$S8$'npSongFormat'||*{S8}$S8$'npStationFormat'||*{S8}$S8$'listSongFormat'||*{S8}$S8$'fifo'||*{S8}$S8$'rpcHost'||*{S8}$S8$'rpcTlsPort'||*{S8}$S8$'partnerUser'||*{S8}$S8$'partnerPassword'||*{S8}$S8$'device'||*{S8}$S8$'inkey'||*{S8}$S8$'outkey'||ARR20{S8}$S8$'tlsFingerprint'||ARR29{S8}$S8$'keys'||U56'$pad1'||ARR7{SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#$'msgFormat'|]#'settings'||*{SYM#tag-PianoSong#}$SYM#tag-PianoSong#$'playlist'||*{SYM#tag-PianoSong#}$SYM#tag-PianoSong#$'songHistory'||*{SYM#tag-PianoStation#}$SYM#tag-PianoStation#$'curStation'||S8'doQuit'||U56'$pad0'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR16{S64}$S64$'__fds_bits'|]#'set'||S32'maxfd'||ARR2{S32}$S32$'fds'||U32'$pad0'|]#'input'||U32'playerErrors'||U32'$pad1'|]#$|*{SYM#tag-PianoStation#}$SYM#tag-PianoStation#$|*{SYM#tag-PianoSong#}$SYM#tag-PianoSong#$|EN#anon_enum$BAR_DC_UNDEFINED=0$BAR_DC_GLOBAL=1$BAR_DC_STATION=2$BAR_DC_SONG=4#{U32}$U32$)->V}$V(*{SYM#tag-#anon#ST[SYM#tag-PianoHandle#'ph'||SYM#tag-#anon#ST[S32'timeout'||EN#anon_enum$WAITRESS_METHOD_GET=0$WAITRESS_METHOD_POST=1#{U32}$U32$'method'||*{cS8}$cS8$'extraHeaders'||*{cS8}$cS8$'postData'||*{V}$V$'data'||*{EN#anon_enum$WAITRESS_CB_RET_ERR=0$WAITRESS_CB_RET_OK=1#{U32}$U32$(*{V}$V$|U64|*{V}$V$)->EN#anon_enum$WAITRESS_CB_RET_ERR=0$WAITRESS_CB_RET_OK=1#{U32}$U32$}$EN#anon_enum$WAITRESS_CB_RET_ERR=0$WAITRESS_CB_RET_OK=1#{U32}$U32$(*{V}$V$|U64|*{V}$V$)->EN#anon_enum$WAITRESS_CB_RET_ERR=0$WAITRESS_CB_RET_OK=1#{U32}$U32$$'callback'||*{cS8}$cS8$'tlsFingerprint'||SYM#tag-#anon#ST[*{S8}$S8$'url'||B'tls'||U56'$pad0'||*{cS8}$cS8$'user'||*{cS8}$cS8$'password'||*{cS8}$cS8$'host'||*{cS8}$cS8$'port'||*{cS8}$cS8$'tlsPort'||*{cS8}$cS8$'path'|]#'url'||SYM#tag-#anon#ST[*{S8}$S8$'url'||B'tls'||U56'$pad0'||*{cS8}$cS8$'user'||*{cS8}$cS8$'password'||*{cS8}$cS8$'host'||*{cS8}$cS8$'port'||*{cS8}$cS8$'tlsPort'||*{cS8}$cS8$'path'|]#'proxy'||*{SYM#tag-gnutls_certificate_credentials_st#}$SYM#tag-gnutls_certificate_credentials_st#$'tlsCred'||SYM#tag-#anon#ST[S32'sockfd'||EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$'readWriteRet'||U64'contentLength'||U64'contentReceived'||U64'chunkSize'||B'contentLengthKnown'||U24'$pad0'||EN#anon_enum$CHUNKSIZE=0$DATA=1#{U32}$U32$'chunkedState'||*{S8}$S8$'buf'||*{EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64)->EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$}$EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64)->EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$$'dataHandler'||*{EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64|*{U64}$U64$)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$}$EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64|*{U64}$U64$)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$$'read'||*{EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{cS8}$cS8$|cU64)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$}$EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{cS8}$cS8$|cU64)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$$'write'||*{SYM#tag-gnutls_session_int#}$SYM#tag-gnutls_session_int#$'tlsSession'|]#'request'|]#'waith'||SYM#tag-#anon#ST[vB'doQuit'||vB'doPause'||U48'$pad0'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'pauseMutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'pauseCond'||EN#anon_enum$PLAYER_DEAD=0$PLAYER_STARTING=1$PLAYER_PLAYING=2$PLAYER_FINISHED=3#{U32}$U32$'mode'||U32'$pad1'||*{SYM#tag-AVFilterContext#}$SYM#tag-AVFilterContext#$'fvolume'||*{SYM#tag-AVFilterGraph#}$SYM#tag-AVFilterGraph#$'fgraph'||*{SYM#tag-AVFormatContext#}$SYM#tag-AVFormatContext#$'fctx'||*{SYM#tag-AVStream#}$SYM#tag-AVStream#$'st'||*{SYM#tag-AVFilterContext#}$SYM#tag-AVFilterContext#$'fbufsink'||*{SYM#tag-AVFilterContext#}$SYM#tag-AVFilterContext#$'fabuf'||S32'streamIdx'||U32'$pad2'||S64'lastTimestamp'||*{SYM#tag-ao_device#}$SYM#tag-ao_device#$'aoDev'||vF64'volume'||F64'gain'||*{S8}$S8$'url'||*{cSYM#tag-#anon#ST[B'autoselect'||U24'$pad0'||U32'history'||U32'maxPlayerErrors'||S32'volume'||EN#anon_enum$BAR_SORT_NAME_AZ=0$BAR_SORT_NAME_ZA=1$BAR_SORT_QUICKMIX_01_NAME_AZ=2$BAR_SORT_QUICKMIX_01_NAME_ZA=3$BAR_SORT_QUICKMIX_10_NAME_AZ=4$BAR_SORT_QUICKMIX_10_NAME_ZA=5$BAR_SORT_COUNT=6#{U32}$U32$'sortOrder'||EN#anon_enum$PIANO_AQ_UNKNOWN=0$PIANO_AQ_LOW=1$PIANO_AQ_MEDIUM=2$PIANO_AQ_HIGH=3#{U32}$U32$'audioQuality'||*{S8}$S8$'username'||*{S8}$S8$'password'||*{S8}$S8$'passwordCmd'||*{S8}$S8$'controlProxy'||*{S8}$S8$'proxy'||*{S8}$S8$'autostartStation'||*{S8}$S8$'eventCmd'||*{S8}$S8$'loveIcon'||*{S8}$S8$'banIcon'||*{S8}$S8$'atIcon'||*{S8}$S8$'npSongFormat'||*{S8}$S8$'npStationFormat'||*{S8}$S8$'listSongFormat'||*{S8}$S8$'fifo'||*{S8}$S8$'rpcHost'||*{S8}$S8$'rpcTlsPort'||*{S8}$S8$'partnerUser'||*{S8}$S8$'partnerPassword'||*{S8}$S8$'device'||*{S8}$S8$'inkey'||*{S8}$S8$'outkey'||ARR20{S8}$S8$'tlsFingerprint'||ARR29{S8}$S8$'keys'||U56'$pad1'||ARR7{SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#$'msgFormat'|]#}$cSYM#tag-#anon#ST[B'autoselect'||U24'$pad0'||U32'history'||U32'maxPlayerErrors'||S32'volume'||EN#anon_enum$BAR_SORT_NAME_AZ=0$BAR_SORT_NAME_ZA=1$BAR_SORT_QUICKMIX_01_NAME_AZ=2$BAR_SORT_QUICKMIX_01_NAME_ZA=3$BAR_SORT_QUICKMIX_10_NAME_AZ=4$BAR_SORT_QUICKMIX_10_NAME_ZA=5$BAR_SORT_COUNT=6#{U32}$U32$'sortOrder'||EN#anon_enum$PIANO_AQ_UNKNOWN=0$PIANO_AQ_LOW=1$PIANO_AQ_MEDIUM=2$PIANO_AQ_HIGH=3#{U32}$U32$'audioQuality'||*{S8}$S8$'username'||*{S8}$S8$'password'||*{S8}$S8$'passwordCmd'||*{S8}$S8$'controlProxy'||*{S8}$S8$'proxy'||*{S8}$S8$'autostartStation'||*{S8}$S8$'eventCmd'||*{S8}$S8$'loveIcon'||*{S8}$S8$'banIcon'||*{S8}$S8$'atIcon'||*{S8}$S8$'npSongFormat'||*{S8}$S8$'npStationFormat'||*{S8}$S8$'listSongFormat'||*{S8}$S8$'fifo'||*{S8}$S8$'rpcHost'||*{S8}$S8$'rpcTlsPort'||*{S8}$S8$'partnerUser'||*{S8}$S8$'partnerPassword'||*{S8}$S8$'device'||*{S8}$S8$'inkey'||*{S8}$S8$'outkey'||ARR20{S8}$S8$'tlsFingerprint'||ARR29{S8}$S8$'keys'||U56'$pad1'||ARR7{SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#$'msgFormat'|]#$'settings'||vU32'songDuration'||vU32'songPlayed'|]#'player'||SYM#tag-#anon#ST[B'autoselect'||U24'$pad0'||U32'history'||U32'maxPlayerErrors'||S32'volume'||EN#anon_enum$BAR_SORT_NAME_AZ=0$BAR_SORT_NAME_ZA=1$BAR_SORT_QUICKMIX_01_NAME_AZ=2$BAR_SORT_QUICKMIX_01_NAME_ZA=3$BAR_SORT_QUICKMIX_10_NAME_AZ=4$BAR_SORT_QUICKMIX_10_NAME_ZA=5$BAR_SORT_COUNT=6#{U32}$U32$'sortOrder'||EN#anon_enum$PIANO_AQ_UNKNOWN=0$PIANO_AQ_LOW=1$PIANO_AQ_MEDIUM=2$PIANO_AQ_HIGH=3#{U32}$U32$'audioQuality'||*{S8}$S8$'username'||*{S8}$S8$'password'||*{S8}$S8$'passwordCmd'||*{S8}$S8$'controlProxy'||*{S8}$S8$'proxy'||*{S8}$S8$'autostartStation'||*{S8}$S8$'eventCmd'||*{S8}$S8$'loveIcon'||*{S8}$S8$'banIcon'||*{S8}$S8$'atIcon'||*{S8}$S8$'npSongFormat'||*{S8}$S8$'npStationFormat'||*{S8}$S8$'listSongFormat'||*{S8}$S8$'fifo'||*{S8}$S8$'rpcHost'||*{S8}$S8$'rpcTlsPort'||*{S8}$S8$'partnerUser'||*{S8}$S8$'partnerPassword'||*{S8}$S8$'device'||*{S8}$S8$'inkey'||*{S8}$S8$'outkey'||ARR20{S8}$S8$'tlsFingerprint'||ARR29{S8}$S8$'keys'||U56'$pad1'||ARR7{SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#$'msgFormat'|]#'settings'||*{SYM#tag-PianoSong#}$SYM#tag-PianoSong#$'playlist'||*{SYM#tag-PianoSong#}$SYM#tag-PianoSong#$'songHistory'||*{SYM#tag-PianoStation#}$SYM#tag-PianoStation#$'curStation'||S8'doQuit'||U56'$pad0'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR16{S64}$S64$'__fds_bits'|]#'set'||S32'maxfd'||ARR2{S32}$S32$'fds'||U32'$pad0'|]#'input'||U32'playerErrors'||U32'$pad1'|]#}$SYM#tag-#anon#ST[SYM#tag-PianoHandle#'ph'||SYM#tag-#anon#ST[S32'timeout'||EN#anon_enum$WAITRESS_METHOD_GET=0$WAITRESS_METHOD_POST=1#{U32}$U32$'method'||*{cS8}$cS8$'extraHeaders'||*{cS8}$cS8$'postData'||*{V}$V$'data'||*{EN#anon_enum$WAITRESS_CB_RET_ERR=0$WAITRESS_CB_RET_OK=1#{U32}$U32$(*{V}$V$|U64|*{V}$V$)->EN#anon_enum$WAITRESS_CB_RET_ERR=0$WAITRESS_CB_RET_OK=1#{U32}$U32$}$EN#anon_enum$WAITRESS_CB_RET_ERR=0$WAITRESS_CB_RET_OK=1#{U32}$U32$(*{V}$V$|U64|*{V}$V$)->EN#anon_enum$WAITRESS_CB_RET_ERR=0$WAITRESS_CB_RET_OK=1#{U32}$U32$$'callback'||*{cS8}$cS8$'tlsFingerprint'||SYM#tag-#anon#ST[*{S8}$S8$'url'||B'tls'||U56'$pad0'||*{cS8}$cS8$'user'||*{cS8}$cS8$'password'||*{cS8}$cS8$'host'||*{cS8}$cS8$'port'||*{cS8}$cS8$'tlsPort'||*{cS8}$cS8$'path'|]#'url'||SYM#tag-#anon#ST[*{S8}$S8$'url'||B'tls'||U56'$pad0'||*{cS8}$cS8$'user'||*{cS8}$cS8$'password'||*{cS8}$cS8$'host'||*{cS8}$cS8$'port'||*{cS8}$cS8$'tlsPort'||*{cS8}$cS8$'path'|]#'proxy'||*{SYM#tag-gnutls_certificate_credentials_st#}$SYM#tag-gnutls_certificate_credentials_st#$'tlsCred'||SYM#tag-#anon#ST[S32'sockfd'||EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$'readWriteRet'||U64'contentLength'||U64'contentReceived'||U64'chunkSize'||B'contentLengthKnown'||U24'$pad0'||EN#anon_enum$CHUNKSIZE=0$DATA=1#{U32}$U32$'chunkedState'||*{S8}$S8$'buf'||*{EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64)->EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$}$EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64)->EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$$'dataHandler'||*{EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64|*{U64}$U64$)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$}$EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64|*{U64}$U64$)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$$'read'||*{EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{cS8}$cS8$|cU64)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$}$EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{cS8}$cS8$|cU64)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$$'write'||*{SYM#tag-gnutls_session_int#}$SYM#tag-gnutls_session_int#$'tlsSession'|]#'request'|]#'waith'||SYM#tag-#anon#ST[vB'doQuit'||vB'doPause'||U48'$pad0'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'pauseMutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'pauseCond'||EN#anon_enum$PLAYER_DEAD=0$PLAYER_STARTING=1$PLAYER_PLAYING=2$PLAYER_FINISHED=3#{U32}$U32$'mode'||U32'$pad1'||*{SYM#tag-AVFilterContext#}$SYM#tag-AVFilterContext#$'fvolume'||*{SYM#tag-AVFilterGraph#}$SYM#tag-AVFilterGraph#$'fgraph'||*{SYM#tag-AVFormatContext#}$SYM#tag-AVFormatContext#$'fctx'||*{SYM#tag-AVStream#}$SYM#tag-AVStream#$'st'||*{SYM#tag-AVFilterContext#}$SYM#tag-AVFilterContext#$'fbufsink'||*{SYM#tag-AVFilterContext#}$SYM#tag-AVFilterContext#$'fabuf'||S32'streamIdx'||U32'$pad2'||S64'lastTimestamp'||*{SYM#tag-ao_device#}$SYM#tag-ao_device#$'aoDev'||vF64'volume'||F64'gain'||*{S8}$S8$'url'||*{cSYM#tag-#anon#ST[B'autoselect'||U24'$pad0'||U32'history'||U32'maxPlayerErrors'||S32'volume'||EN#anon_enum$BAR_SORT_NAME_AZ=0$BAR_SORT_NAME_ZA=1$BAR_SORT_QUICKMIX_01_NAME_AZ=2$BAR_SORT_QUICKMIX_01_NAME_ZA=3$BAR_SORT_QUICKMIX_10_NAME_AZ=4$BAR_SORT_QUICKMIX_10_NAME_ZA=5$BAR_SORT_COUNT=6#{U32}$U32$'sortOrder'||EN#anon_enum$PIANO_AQ_UNKNOWN=0$PIANO_AQ_LOW=1$PIANO_AQ_MEDIUM=2$PIANO_AQ_HIGH=3#{U32}$U32$'audioQuality'||*{S8}$S8$'username'||*{S8}$S8$'password'||*{S8}$S8$'passwordCmd'||*{S8}$S8$'controlProxy'||*{S8}$S8$'proxy'||*{S8}$S8$'autostartStation'||*{S8}$S8$'eventCmd'||*{S8}$S8$'loveIcon'||*{S8}$S8$'banIcon'||*{S8}$S8$'atIcon'||*{S8}$S8$'npSongFormat'||*{S8}$S8$'npStationFormat'||*{S8}$S8$'listSongFormat'||*{S8}$S8$'fifo'||*{S8}$S8$'rpcHost'||*{S8}$S8$'rpcTlsPort'||*{S8}$S8$'partnerUser'||*{S8}$S8$'partnerPassword'||*{S8}$S8$'device'||*{S8}$S8$'inkey'||*{S8}$S8$'outkey'||ARR20{S8}$S8$'tlsFingerprint'||ARR29{S8}$S8$'keys'||U56'$pad1'||ARR7{SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#$'msgFormat'|]#}$cSYM#tag-#anon#ST[B'autoselect'||U24'$pad0'||U32'history'||U32'maxPlayerErrors'||S32'volume'||EN#anon_enum$BAR_SORT_NAME_AZ=0$BAR_SORT_NAME_ZA=1$BAR_SORT_QUICKMIX_01_NAME_AZ=2$BAR_SORT_QUICKMIX_01_NAME_ZA=3$BAR_SORT_QUICKMIX_10_NAME_AZ=4$BAR_SORT_QUICKMIX_10_NAME_ZA=5$BAR_SORT_COUNT=6#{U32}$U32$'sortOrder'||EN#anon_enum$PIANO_AQ_UNKNOWN=0$PIANO_AQ_LOW=1$PIANO_AQ_MEDIUM=2$PIANO_AQ_HIGH=3#{U32}$U32$'audioQuality'||*{S8}$S8$'username'||*{S8}$S8$'password'||*{S8}$S8$'passwordCmd'||*{S8}$S8$'controlProxy'||*{S8}$S8$'proxy'||*{S8}$S8$'autostartStation'||*{S8}$S8$'eventCmd'||*{S8}$S8$'loveIcon'||*{S8}$S8$'banIcon'||*{S8}$S8$'atIcon'||*{S8}$S8$'npSongFormat'||*{S8}$S8$'npStationFormat'||*{S8}$S8$'listSongFormat'||*{S8}$S8$'fifo'||*{S8}$S8$'rpcHost'||*{S8}$S8$'rpcTlsPort'||*{S8}$S8$'partnerUser'||*{S8}$S8$'partnerPassword'||*{S8}$S8$'device'||*{S8}$S8$'inkey'||*{S8}$S8$'outkey'||ARR20{S8}$S8$'tlsFingerprint'||ARR29{S8}$S8$'keys'||U56'$pad1'||ARR7{SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#$'msgFormat'|]#$'settings'||vU32'songDuration'||vU32'songPlayed'|]#'player'||SYM#tag-#anon#ST[B'autoselect'||U24'$pad0'||U32'history'||U32'maxPlayerErrors'||S32'volume'||EN#anon_enum$BAR_SORT_NAME_AZ=0$BAR_SORT_NAME_ZA=1$BAR_SORT_QUICKMIX_01_NAME_AZ=2$BAR_SORT_QUICKMIX_01_NAME_ZA=3$BAR_SORT_QUICKMIX_10_NAME_AZ=4$BAR_SORT_QUICKMIX_10_NAME_ZA=5$BAR_SORT_COUNT=6#{U32}$U32$'sortOrder'||EN#anon_enum$PIANO_AQ_UNKNOWN=0$PIANO_AQ_LOW=1$PIANO_AQ_MEDIUM=2$PIANO_AQ_HIGH=3#{U32}$U32$'audioQuality'||*{S8}$S8$'username'||*{S8}$S8$'password'||*{S8}$S8$'passwordCmd'||*{S8}$S8$'controlProxy'||*{S8}$S8$'proxy'||*{S8}$S8$'autostartStation'||*{S8}$S8$'eventCmd'||*{S8}$S8$'loveIcon'||*{S8}$S8$'banIcon'||*{S8}$S8$'atIcon'||*{S8}$S8$'npSongFormat'||*{S8}$S8$'npStationFormat'||*{S8}$S8$'listSongFormat'||*{S8}$S8$'fifo'||*{S8}$S8$'rpcHost'||*{S8}$S8$'rpcTlsPort'||*{S8}$S8$'partnerUser'||*{S8}$S8$'partnerPassword'||*{S8}$S8$'device'||*{S8}$S8$'inkey'||*{S8}$S8$'outkey'||ARR20{S8}$S8$'tlsFingerprint'||ARR29{S8}$S8$'keys'||U56'$pad1'||ARR7{SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#$'msgFormat'|]#'settings'||*{SYM#tag-PianoSong#}$SYM#tag-PianoSong#$'playlist'||*{SYM#tag-PianoSong#}$SYM#tag-PianoSong#$'songHistory'||*{SYM#tag-PianoStation#}$SYM#tag-PianoStation#$'curStation'||S8'doQuit'||U56'$pad0'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR16{S64}$S64$'__fds_bits'|]#'set'||S32'maxfd'||ARR2{S32}$S32$'fds'||U32'$pad0'|]#'input'||U32'playerErrors'||U32'$pad1'|]#$|*{SYM#tag-PianoStation#}$SYM#tag-PianoStation#$|*{SYM#tag-PianoSong#}$SYM#tag-PianoSong#$|EN#anon_enum$BAR_DC_UNDEFINED=0$BAR_DC_GLOBAL=1$BAR_DC_STATION=2$BAR_DC_SONG=4#{U32}$U32$)->V$'function'||c*{cS8}$cS8$'helpText'||c*{cS8}$cS8$'configKey'|]
// file src/ui_dispatch.h line 41
struct anonymous$31;

// tag-#anon#ST[SYM#tag-#anon#ST[ARR16{S64}$S64$'__fds_bits'|]#'set'||S32'maxfd'||ARR2{S32}$S32$'fds'||U32'$pad0'|]
// file src/ui_readline.h line 36
struct anonymous$40;

// tag-#anon#ST[SYM#tag-PianoHandle#'ph'||SYM#tag-#anon#ST[S32'timeout'||EN#anon_enum$WAITRESS_METHOD_GET=0$WAITRESS_METHOD_POST=1#{U32}$U32$'method'||*{cS8}$cS8$'extraHeaders'||*{cS8}$cS8$'postData'||*{V}$V$'data'||*{EN#anon_enum$WAITRESS_CB_RET_ERR=0$WAITRESS_CB_RET_OK=1#{U32}$U32$(*{V}$V$|U64|*{V}$V$)->EN#anon_enum$WAITRESS_CB_RET_ERR=0$WAITRESS_CB_RET_OK=1#{U32}$U32$}$EN#anon_enum$WAITRESS_CB_RET_ERR=0$WAITRESS_CB_RET_OK=1#{U32}$U32$(*{V}$V$|U64|*{V}$V$)->EN#anon_enum$WAITRESS_CB_RET_ERR=0$WAITRESS_CB_RET_OK=1#{U32}$U32$$'callback'||*{cS8}$cS8$'tlsFingerprint'||SYM#tag-#anon#ST[*{S8}$S8$'url'||B'tls'||U56'$pad0'||*{cS8}$cS8$'user'||*{cS8}$cS8$'password'||*{cS8}$cS8$'host'||*{cS8}$cS8$'port'||*{cS8}$cS8$'tlsPort'||*{cS8}$cS8$'path'|]#'url'||SYM#tag-#anon#ST[*{S8}$S8$'url'||B'tls'||U56'$pad0'||*{cS8}$cS8$'user'||*{cS8}$cS8$'password'||*{cS8}$cS8$'host'||*{cS8}$cS8$'port'||*{cS8}$cS8$'tlsPort'||*{cS8}$cS8$'path'|]#'proxy'||*{SYM#tag-gnutls_certificate_credentials_st#}$SYM#tag-gnutls_certificate_credentials_st#$'tlsCred'||SYM#tag-#anon#ST[S32'sockfd'||EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$'readWriteRet'||U64'contentLength'||U64'contentReceived'||U64'chunkSize'||B'contentLengthKnown'||U24'$pad0'||EN#anon_enum$CHUNKSIZE=0$DATA=1#{U32}$U32$'chunkedState'||*{S8}$S8$'buf'||*{EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64)->EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$}$EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64)->EN#anon_enum$WAITRESS_HANDLER_CONTINUE=0$WAITRESS_HANDLER_DONE=1$WAITRESS_HANDLER_ERR=2$WAITRESS_HANDLER_ABORTED=3#{U32}$U32$$'dataHandler'||*{EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64|*{U64}$U64$)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$}$EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{S8}$S8$|cU64|*{U64}$U64$)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$$'read'||*{EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{cS8}$cS8$|cU64)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$}$EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$(*{V}$V$|*{cS8}$cS8$|cU64)->EN#anon_enum$WAITRESS_RET_ERR=0$WAITRESS_RET_OK=1$WAITRESS_RET_CB_ABORT=2$WAITRESS_RET_STATUS_UNKNOWN=3$WAITRESS_RET_NOTFOUND=4$WAITRESS_RET_FORBIDDEN=5$WAITRESS_RET_BAD_REQUEST=6$WAITRESS_RET_CONNECT_REFUSED=7$WAITRESS_RET_SOCK_ERR=8$WAITRESS_RET_GETADDR_ERR=9$WAITRESS_RET_TIMEOUT=10$WAITRESS_RET_READ_ERR=11$WAITRESS_RET_CONNECTION_CLOSED=12$WAITRESS_RET_TLS_WRITE_ERR=13$WAITRESS_RET_TLS_READ_ERR=14$WAITRESS_RET_PARTIAL_FILE=15$WAITRESS_RET_DECODING_ERR=16$WAITRESS_RET_TLS_HANDSHAKE_ERR=17$WAITRESS_RET_TLS_FINGERPRINT_MISMATCH=18#{U32}$U32$$'write'||*{SYM#tag-gnutls_session_int#}$SYM#tag-gnutls_session_int#$'tlsSession'|]#'request'|]#'waith'||SYM#tag-#anon#ST[vB'doQuit'||vB'doPause'||U48'$pad0'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'pauseMutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'pauseCond'||EN#anon_enum$PLAYER_DEAD=0$PLAYER_STARTING=1$PLAYER_PLAYING=2$PLAYER_FINISHED=3#{U32}$U32$'mode'||U32'$pad1'||*{SYM#tag-AVFilterContext#}$SYM#tag-AVFilterContext#$'fvolume'||*{SYM#tag-AVFilterGraph#}$SYM#tag-AVFilterGraph#$'fgraph'||*{SYM#tag-AVFormatContext#}$SYM#tag-AVFormatContext#$'fctx'||*{SYM#tag-AVStream#}$SYM#tag-AVStream#$'st'||*{SYM#tag-AVFilterContext#}$SYM#tag-AVFilterContext#$'fbufsink'||*{SYM#tag-AVFilterContext#}$SYM#tag-AVFilterContext#$'fabuf'||S32'streamIdx'||U32'$pad2'||S64'lastTimestamp'||*{SYM#tag-ao_device#}$SYM#tag-ao_device#$'aoDev'||vF64'volume'||F64'gain'||*{S8}$S8$'url'||*{cSYM#tag-#anon#ST[B'autoselect'||U24'$pad0'||U32'history'||U32'maxPlayerErrors'||S32'volume'||EN#anon_enum$BAR_SORT_NAME_AZ=0$BAR_SORT_NAME_ZA=1$BAR_SORT_QUICKMIX_01_NAME_AZ=2$BAR_SORT_QUICKMIX_01_NAME_ZA=3$BAR_SORT_QUICKMIX_10_NAME_AZ=4$BAR_SORT_QUICKMIX_10_NAME_ZA=5$BAR_SORT_COUNT=6#{U32}$U32$'sortOrder'||EN#anon_enum$PIANO_AQ_UNKNOWN=0$PIANO_AQ_LOW=1$PIANO_AQ_MEDIUM=2$PIANO_AQ_HIGH=3#{U32}$U32$'audioQuality'||*{S8}$S8$'username'||*{S8}$S8$'password'||*{S8}$S8$'passwordCmd'||*{S8}$S8$'controlProxy'||*{S8}$S8$'proxy'||*{S8}$S8$'autostartStation'||*{S8}$S8$'eventCmd'||*{S8}$S8$'loveIcon'||*{S8}$S8$'banIcon'||*{S8}$S8$'atIcon'||*{S8}$S8$'npSongFormat'||*{S8}$S8$'npStationFormat'||*{S8}$S8$'listSongFormat'||*{S8}$S8$'fifo'||*{S8}$S8$'rpcHost'||*{S8}$S8$'rpcTlsPort'||*{S8}$S8$'partnerUser'||*{S8}$S8$'partnerPassword'||*{S8}$S8$'device'||*{S8}$S8$'inkey'||*{S8}$S8$'outkey'||ARR20{S8}$S8$'tlsFingerprint'||ARR29{S8}$S8$'keys'||U56'$pad1'||ARR7{SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#$'msgFormat'|]#}$cSYM#tag-#anon#ST[B'autoselect'||U24'$pad0'||U32'history'||U32'maxPlayerErrors'||S32'volume'||EN#anon_enum$BAR_SORT_NAME_AZ=0$BAR_SORT_NAME_ZA=1$BAR_SORT_QUICKMIX_01_NAME_AZ=2$BAR_SORT_QUICKMIX_01_NAME_ZA=3$BAR_SORT_QUICKMIX_10_NAME_AZ=4$BAR_SORT_QUICKMIX_10_NAME_ZA=5$BAR_SORT_COUNT=6#{U32}$U32$'sortOrder'||EN#anon_enum$PIANO_AQ_UNKNOWN=0$PIANO_AQ_LOW=1$PIANO_AQ_MEDIUM=2$PIANO_AQ_HIGH=3#{U32}$U32$'audioQuality'||*{S8}$S8$'username'||*{S8}$S8$'password'||*{S8}$S8$'passwordCmd'||*{S8}$S8$'controlProxy'||*{S8}$S8$'proxy'||*{S8}$S8$'autostartStation'||*{S8}$S8$'eventCmd'||*{S8}$S8$'loveIcon'||*{S8}$S8$'banIcon'||*{S8}$S8$'atIcon'||*{S8}$S8$'npSongFormat'||*{S8}$S8$'npStationFormat'||*{S8}$S8$'listSongFormat'||*{S8}$S8$'fifo'||*{S8}$S8$'rpcHost'||*{S8}$S8$'rpcTlsPort'||*{S8}$S8$'partnerUser'||*{S8}$S8$'partnerPassword'||*{S8}$S8$'device'||*{S8}$S8$'inkey'||*{S8}$S8$'outkey'||ARR20{S8}$S8$'tlsFingerprint'||ARR29{S8}$S8$'keys'||U56'$pad1'||ARR7{SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#$'msgFormat'|]#$'settings'||vU32'songDuration'||vU32'songPlayed'|]#'player'||SYM#tag-#anon#ST[B'autoselect'||U24'$pad0'||U32'history'||U32'maxPlayerErrors'||S32'volume'||EN#anon_enum$BAR_SORT_NAME_AZ=0$BAR_SORT_NAME_ZA=1$BAR_SORT_QUICKMIX_01_NAME_AZ=2$BAR_SORT_QUICKMIX_01_NAME_ZA=3$BAR_SORT_QUICKMIX_10_NAME_AZ=4$BAR_SORT_QUICKMIX_10_NAME_ZA=5$BAR_SORT_COUNT=6#{U32}$U32$'sortOrder'||EN#anon_enum$PIANO_AQ_UNKNOWN=0$PIANO_AQ_LOW=1$PIANO_AQ_MEDIUM=2$PIANO_AQ_HIGH=3#{U32}$U32$'audioQuality'||*{S8}$S8$'username'||*{S8}$S8$'password'||*{S8}$S8$'passwordCmd'||*{S8}$S8$'controlProxy'||*{S8}$S8$'proxy'||*{S8}$S8$'autostartStation'||*{S8}$S8$'eventCmd'||*{S8}$S8$'loveIcon'||*{S8}$S8$'banIcon'||*{S8}$S8$'atIcon'||*{S8}$S8$'npSongFormat'||*{S8}$S8$'npStationFormat'||*{S8}$S8$'listSongFormat'||*{S8}$S8$'fifo'||*{S8}$S8$'rpcHost'||*{S8}$S8$'rpcTlsPort'||*{S8}$S8$'partnerUser'||*{S8}$S8$'partnerPassword'||*{S8}$S8$'device'||*{S8}$S8$'inkey'||*{S8}$S8$'outkey'||ARR20{S8}$S8$'tlsFingerprint'||ARR29{S8}$S8$'keys'||U56'$pad1'||ARR7{SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#$'msgFormat'|]#'settings'||*{SYM#tag-PianoSong#}$SYM#tag-PianoSong#$'playlist'||*{SYM#tag-PianoSong#}$SYM#tag-PianoSong#$'songHistory'||*{SYM#tag-PianoStation#}$SYM#tag-PianoStation#$'curStation'||S8'doQuit'||U56'$pad0'||SYM#tag-#anon#ST[SYM#tag-#anon#ST[ARR16{S64}$S64$'__fds_bits'|]#'set'||S32'maxfd'||ARR2{S32}$S32$'fds'||U32'$pad0'|]#'input'||U32'playerErrors'||U32'$pad1'|]
// file src/main.h line 34
struct anonymous$35;

// tag-#anon#ST[vB'doQuit'||vB'doPause'||U48'$pad0'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'pauseMutex'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]#'pauseCond'||EN#anon_enum$PLAYER_DEAD=0$PLAYER_STARTING=1$PLAYER_PLAYING=2$PLAYER_FINISHED=3#{U32}$U32$'mode'||U32'$pad1'||*{SYM#tag-AVFilterContext#}$SYM#tag-AVFilterContext#$'fvolume'||*{SYM#tag-AVFilterGraph#}$SYM#tag-AVFilterGraph#$'fgraph'||*{SYM#tag-AVFormatContext#}$SYM#tag-AVFormatContext#$'fctx'||*{SYM#tag-AVStream#}$SYM#tag-AVStream#$'st'||*{SYM#tag-AVFilterContext#}$SYM#tag-AVFilterContext#$'fbufsink'||*{SYM#tag-AVFilterContext#}$SYM#tag-AVFilterContext#$'fabuf'||S32'streamIdx'||U32'$pad2'||S64'lastTimestamp'||*{SYM#tag-ao_device#}$SYM#tag-ao_device#$'aoDev'||vF64'volume'||F64'gain'||*{S8}$S8$'url'||*{cSYM#tag-#anon#ST[B'autoselect'||U24'$pad0'||U32'history'||U32'maxPlayerErrors'||S32'volume'||EN#anon_enum$BAR_SORT_NAME_AZ=0$BAR_SORT_NAME_ZA=1$BAR_SORT_QUICKMIX_01_NAME_AZ=2$BAR_SORT_QUICKMIX_01_NAME_ZA=3$BAR_SORT_QUICKMIX_10_NAME_AZ=4$BAR_SORT_QUICKMIX_10_NAME_ZA=5$BAR_SORT_COUNT=6#{U32}$U32$'sortOrder'||EN#anon_enum$PIANO_AQ_UNKNOWN=0$PIANO_AQ_LOW=1$PIANO_AQ_MEDIUM=2$PIANO_AQ_HIGH=3#{U32}$U32$'audioQuality'||*{S8}$S8$'username'||*{S8}$S8$'password'||*{S8}$S8$'passwordCmd'||*{S8}$S8$'controlProxy'||*{S8}$S8$'proxy'||*{S8}$S8$'autostartStation'||*{S8}$S8$'eventCmd'||*{S8}$S8$'loveIcon'||*{S8}$S8$'banIcon'||*{S8}$S8$'atIcon'||*{S8}$S8$'npSongFormat'||*{S8}$S8$'npStationFormat'||*{S8}$S8$'listSongFormat'||*{S8}$S8$'fifo'||*{S8}$S8$'rpcHost'||*{S8}$S8$'rpcTlsPort'||*{S8}$S8$'partnerUser'||*{S8}$S8$'partnerPassword'||*{S8}$S8$'device'||*{S8}$S8$'inkey'||*{S8}$S8$'outkey'||ARR20{S8}$S8$'tlsFingerprint'||ARR29{S8}$S8$'keys'||U56'$pad1'||ARR7{SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#$'msgFormat'|]#}$cSYM#tag-#anon#ST[B'autoselect'||U24'$pad0'||U32'history'||U32'maxPlayerErrors'||S32'volume'||EN#anon_enum$BAR_SORT_NAME_AZ=0$BAR_SORT_NAME_ZA=1$BAR_SORT_QUICKMIX_01_NAME_AZ=2$BAR_SORT_QUICKMIX_01_NAME_ZA=3$BAR_SORT_QUICKMIX_10_NAME_AZ=4$BAR_SORT_QUICKMIX_10_NAME_ZA=5$BAR_SORT_COUNT=6#{U32}$U32$'sortOrder'||EN#anon_enum$PIANO_AQ_UNKNOWN=0$PIANO_AQ_LOW=1$PIANO_AQ_MEDIUM=2$PIANO_AQ_HIGH=3#{U32}$U32$'audioQuality'||*{S8}$S8$'username'||*{S8}$S8$'password'||*{S8}$S8$'passwordCmd'||*{S8}$S8$'controlProxy'||*{S8}$S8$'proxy'||*{S8}$S8$'autostartStation'||*{S8}$S8$'eventCmd'||*{S8}$S8$'loveIcon'||*{S8}$S8$'banIcon'||*{S8}$S8$'atIcon'||*{S8}$S8$'npSongFormat'||*{S8}$S8$'npStationFormat'||*{S8}$S8$'listSongFormat'||*{S8}$S8$'fifo'||*{S8}$S8$'rpcHost'||*{S8}$S8$'rpcTlsPort'||*{S8}$S8$'partnerUser'||*{S8}$S8$'partnerPassword'||*{S8}$S8$'device'||*{S8}$S8$'inkey'||*{S8}$S8$'outkey'||ARR20{S8}$S8$'tlsFingerprint'||ARR29{S8}$S8$'keys'||U56'$pad1'||ARR7{SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'prefix'||*{S8}$S8$'postfix'|]#$'msgFormat'|]#$'settings'||vU32'songDuration'||vU32'songPlayed'|]
// file src/player.h line 44
struct anonymous$3;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 129
union anonymous$0;

// tag-#anon#UN[S64'i64'||F64'dbl'||*{cS8}$cS8$'str'||SYM#tag-AVRational#'q'|]
// file /usr/include/x86_64-linux-gnu/libavutil/opt.h line 274
union anonymous$24;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 138
union anonymous$18;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous;

// tag-AVAudioServiceType
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 692
enum AVAudioServiceType { AV_AUDIO_SERVICE_TYPE_MAIN=0, AV_AUDIO_SERVICE_TYPE_EFFECTS=1, AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED=2, AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED=3, AV_AUDIO_SERVICE_TYPE_DIALOGUE=4, AV_AUDIO_SERVICE_TYPE_COMMENTARY=5, AV_AUDIO_SERVICE_TYPE_EMERGENCY=6, AV_AUDIO_SERVICE_TYPE_VOICE_OVER=7, AV_AUDIO_SERVICE_TYPE_KARAOKE=8, AV_AUDIO_SERVICE_TYPE_NB=9 };

// tag-AVBuffer
// file /usr/include/x86_64-linux-gnu/libavutil/buffer.h line 73
struct AVBuffer;

// tag-AVBufferRef
// file /usr/include/x86_64-linux-gnu/libavutil/buffer.h line 81
struct AVBufferRef;

// tag-AVChapter
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1227
struct AVChapter;

// tag-AVChromaLocation
// file /usr/include/x86_64-linux-gnu/libavutil/pixfmt.h line 559
enum AVChromaLocation { AVCHROMA_LOC_UNSPECIFIED=0, AVCHROMA_LOC_LEFT=1, AVCHROMA_LOC_CENTER=2, AVCHROMA_LOC_TOPLEFT=3, AVCHROMA_LOC_TOP=4, AVCHROMA_LOC_BOTTOMLEFT=5, AVCHROMA_LOC_BOTTOM=6, AVCHROMA_LOC_NB=7 };

// tag-AVClass
// file /usr/include/x86_64-linux-gnu/libavutil/log.h line 67
struct AVClass;

// tag-AVCodec
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 1511
struct AVCodec;

// tag-AVCodecContext
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 408
struct AVCodecContext;

// tag-AVCodecDefault
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3465
struct AVCodecDefault;

// tag-AVCodecDescriptor
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 566
struct AVCodecDescriptor;

// tag-AVCodecID
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 102
enum AVCodecID { AV_CODEC_ID_NONE=0, AV_CODEC_ID_MPEG1VIDEO=1, AV_CODEC_ID_MPEG2VIDEO=2, AV_CODEC_ID_MPEG2VIDEO_XVMC=3, AV_CODEC_ID_H261=4, AV_CODEC_ID_H263=5, AV_CODEC_ID_RV10=6, AV_CODEC_ID_RV20=7, AV_CODEC_ID_MJPEG=8, AV_CODEC_ID_MJPEGB=9, AV_CODEC_ID_LJPEG=10, AV_CODEC_ID_SP5X=11, AV_CODEC_ID_JPEGLS=12, AV_CODEC_ID_MPEG4=13, AV_CODEC_ID_RAWVIDEO=14, AV_CODEC_ID_MSMPEG4V1=15, AV_CODEC_ID_MSMPEG4V2=16, AV_CODEC_ID_MSMPEG4V3=17, AV_CODEC_ID_WMV1=18, AV_CODEC_ID_WMV2=19, AV_CODEC_ID_H263P=20, AV_CODEC_ID_H263I=21, AV_CODEC_ID_FLV1=22, AV_CODEC_ID_SVQ1=23, AV_CODEC_ID_SVQ3=24, AV_CODEC_ID_DVVIDEO=25, AV_CODEC_ID_HUFFYUV=26, AV_CODEC_ID_CYUV=27, AV_CODEC_ID_H264=28, AV_CODEC_ID_INDEO3=29, AV_CODEC_ID_VP3=30, AV_CODEC_ID_THEORA=31, AV_CODEC_ID_ASV1=32, AV_CODEC_ID_ASV2=33, AV_CODEC_ID_FFV1=34, AV_CODEC_ID_4XM=35, AV_CODEC_ID_VCR1=36, AV_CODEC_ID_CLJR=37, AV_CODEC_ID_MDEC=38, AV_CODEC_ID_ROQ=39, AV_CODEC_ID_INTERPLAY_VIDEO=40, AV_CODEC_ID_XAN_WC3=41, AV_CODEC_ID_XAN_WC4=42, AV_CODEC_ID_RPZA=43, AV_CODEC_ID_CINEPAK=44, AV_CODEC_ID_WS_VQA=45, AV_CODEC_ID_MSRLE=46, AV_CODEC_ID_MSVIDEO1=47, AV_CODEC_ID_IDCIN=48, AV_CODEC_ID_8BPS=49, AV_CODEC_ID_SMC=50, AV_CODEC_ID_FLIC=51, AV_CODEC_ID_TRUEMOTION1=52, AV_CODEC_ID_VMDVIDEO=53, AV_CODEC_ID_MSZH=54, AV_CODEC_ID_ZLIB=55, AV_CODEC_ID_QTRLE=56, AV_CODEC_ID_TSCC=57, AV_CODEC_ID_ULTI=58, AV_CODEC_ID_QDRAW=59, AV_CODEC_ID_VIXL=60, AV_CODEC_ID_QPEG=61, AV_CODEC_ID_PNG=62, AV_CODEC_ID_PPM=63, AV_CODEC_ID_PBM=64, AV_CODEC_ID_PGM=65, AV_CODEC_ID_PGMYUV=66, AV_CODEC_ID_PAM=67, AV_CODEC_ID_FFVHUFF=68, AV_CODEC_ID_RV30=69, AV_CODEC_ID_RV40=70, AV_CODEC_ID_VC1=71, AV_CODEC_ID_WMV3=72, AV_CODEC_ID_LOCO=73, AV_CODEC_ID_WNV1=74, AV_CODEC_ID_AASC=75, AV_CODEC_ID_INDEO2=76, AV_CODEC_ID_FRAPS=77, AV_CODEC_ID_TRUEMOTION2=78, AV_CODEC_ID_BMP=79, AV_CODEC_ID_CSCD=80, AV_CODEC_ID_MMVIDEO=81, AV_CODEC_ID_ZMBV=82, AV_CODEC_ID_AVS=83, AV_CODEC_ID_SMACKVIDEO=84, AV_CODEC_ID_NUV=85, AV_CODEC_ID_KMVC=86, AV_CODEC_ID_FLASHSV=87, AV_CODEC_ID_CAVS=88, AV_CODEC_ID_JPEG2000=89, AV_CODEC_ID_VMNC=90, AV_CODEC_ID_VP5=91, AV_CODEC_ID_VP6=92, AV_CODEC_ID_VP6F=93, AV_CODEC_ID_TARGA=94, AV_CODEC_ID_DSICINVIDEO=95, AV_CODEC_ID_TIERTEXSEQVIDEO=96, AV_CODEC_ID_TIFF=97, AV_CODEC_ID_GIF=98, AV_CODEC_ID_DXA=99, AV_CODEC_ID_DNXHD=100, AV_CODEC_ID_THP=101, AV_CODEC_ID_SGI=102, AV_CODEC_ID_C93=103, AV_CODEC_ID_BETHSOFTVID=104, AV_CODEC_ID_PTX=105, AV_CODEC_ID_TXD=106, AV_CODEC_ID_VP6A=107, AV_CODEC_ID_AMV=108, AV_CODEC_ID_VB=109, AV_CODEC_ID_PCX=110, AV_CODEC_ID_SUNRAST=111, AV_CODEC_ID_INDEO4=112, AV_CODEC_ID_INDEO5=113, AV_CODEC_ID_MIMIC=114, AV_CODEC_ID_RL2=115, AV_CODEC_ID_ESCAPE124=116, AV_CODEC_ID_DIRAC=117, AV_CODEC_ID_BFI=118, AV_CODEC_ID_CMV=119, AV_CODEC_ID_MOTIONPIXELS=120, AV_CODEC_ID_TGV=121, AV_CODEC_ID_TGQ=122, AV_CODEC_ID_TQI=123, AV_CODEC_ID_AURA=124, AV_CODEC_ID_AURA2=125, AV_CODEC_ID_V210X=126, AV_CODEC_ID_TMV=127, AV_CODEC_ID_V210=128, AV_CODEC_ID_DPX=129, AV_CODEC_ID_MAD=130, AV_CODEC_ID_FRWU=131, AV_CODEC_ID_FLASHSV2=132, AV_CODEC_ID_CDGRAPHICS=133, AV_CODEC_ID_R210=134, AV_CODEC_ID_ANM=135, AV_CODEC_ID_BINKVIDEO=136, AV_CODEC_ID_IFF_ILBM=137, AV_CODEC_ID_IFF_BYTERUN1=138, AV_CODEC_ID_KGV1=139, AV_CODEC_ID_YOP=140, AV_CODEC_ID_VP8=141, AV_CODEC_ID_PICTOR=142, AV_CODEC_ID_ANSI=143, AV_CODEC_ID_A64_MULTI=144, AV_CODEC_ID_A64_MULTI5=145, AV_CODEC_ID_R10K=146, AV_CODEC_ID_MXPEG=147, AV_CODEC_ID_LAGARITH=148, AV_CODEC_ID_PRORES=149, AV_CODEC_ID_JV=150, AV_CODEC_ID_DFA=151, AV_CODEC_ID_WMV3IMAGE=152, AV_CODEC_ID_VC1IMAGE=153, AV_CODEC_ID_UTVIDEO=154, AV_CODEC_ID_BMV_VIDEO=155, AV_CODEC_ID_VBLE=156, AV_CODEC_ID_DXTORY=157, AV_CODEC_ID_V410=158, AV_CODEC_ID_XWD=159, AV_CODEC_ID_CDXL=160, AV_CODEC_ID_XBM=161, AV_CODEC_ID_ZEROCODEC=162, AV_CODEC_ID_MSS1=163, AV_CODEC_ID_MSA1=164, AV_CODEC_ID_TSCC2=165, AV_CODEC_ID_MTS2=166, AV_CODEC_ID_CLLC=167, AV_CODEC_ID_MSS2=168, AV_CODEC_ID_VP9=169, AV_CODEC_ID_AIC=170, AV_CODEC_ID_ESCAPE130_DEPRECATED=171, AV_CODEC_ID_G2M_DEPRECATED=172, AV_CODEC_ID_WEBP_DEPRECATED=173, AV_CODEC_ID_HNM4_VIDEO=174, AV_CODEC_ID_HEVC_DEPRECATED=175, AV_CODEC_ID_FIC=176, AV_CODEC_ID_ALIAS_PIX=177, AV_CODEC_ID_BRENDER_PIX_DEPRECATED=178, AV_CODEC_ID_PAF_VIDEO_DEPRECATED=179, AV_CODEC_ID_EXR_DEPRECATED=180, AV_CODEC_ID_VP7_DEPRECATED=181, AV_CODEC_ID_SANM_DEPRECATED=182, AV_CODEC_ID_SGIRLE_DEPRECATED=183, AV_CODEC_ID_MVC1_DEPRECATED=184, AV_CODEC_ID_MVC2_DEPRECATED=185, AV_CODEC_ID_HQX=186, AV_CODEC_ID_TDSC=187, AV_CODEC_ID_HQ_HQA=188, AV_CODEC_ID_HAP=189, AV_CODEC_ID_DDS=190, AV_CODEC_ID_BRENDER_PIX=1112557912, AV_CODEC_ID_Y41P=1496592720, AV_CODEC_ID_ESCAPE130=1160852272, AV_CODEC_ID_EXR=809850962, AV_CODEC_ID_AVRP=1096176208, AV_CODEC_ID_012V=808530518, AV_CODEC_ID_G2M=4665933, AV_CODEC_ID_AVUI=1096176969, AV_CODEC_ID_AYUV=1096373590, AV_CODEC_ID_TARGA_Y216=1412575542, AV_CODEC_ID_V308=1446195256, AV_CODEC_ID_V408=1446260792, AV_CODEC_ID_YUV4=1498764852, AV_CODEC_ID_SANM=1396788813, AV_CODEC_ID_PAF_VIDEO=1346455126, AV_CODEC_ID_AVRN=1096176238, AV_CODEC_ID_CPIA=1129335105, AV_CODEC_ID_XFACE=1480999235, AV_CODEC_ID_SGIRLE=1397180754, AV_CODEC_ID_MVC1=1297498929, AV_CODEC_ID_MVC2=1297498930, AV_CODEC_ID_SNOW=1397641047, AV_CODEC_ID_WEBP=1464156752, AV_CODEC_ID_SMVJPEG=1397577290, AV_CODEC_ID_HEVC=1211250229, AV_CODEC_ID_VP7=1448097584, AV_CODEC_ID_APNG=1095781959, AV_CODEC_ID_FIRST_AUDIO=65536, AV_CODEC_ID_PCM_S16LE=65536, AV_CODEC_ID_PCM_S16BE=65537, AV_CODEC_ID_PCM_U16LE=65538, AV_CODEC_ID_PCM_U16BE=65539, AV_CODEC_ID_PCM_S8=65540, AV_CODEC_ID_PCM_U8=65541, AV_CODEC_ID_PCM_MULAW=65542, AV_CODEC_ID_PCM_ALAW=65543, AV_CODEC_ID_PCM_S32LE=65544, AV_CODEC_ID_PCM_S32BE=65545, AV_CODEC_ID_PCM_U32LE=65546, AV_CODEC_ID_PCM_U32BE=65547, AV_CODEC_ID_PCM_S24LE=65548, AV_CODEC_ID_PCM_S24BE=65549, AV_CODEC_ID_PCM_U24LE=65550, AV_CODEC_ID_PCM_U24BE=65551, AV_CODEC_ID_PCM_S24DAUD=65552, AV_CODEC_ID_PCM_ZORK=65553, AV_CODEC_ID_PCM_S16LE_PLANAR=65554, AV_CODEC_ID_PCM_DVD=65555, AV_CODEC_ID_PCM_F32BE=65556, AV_CODEC_ID_PCM_F32LE=65557, AV_CODEC_ID_PCM_F64BE=65558, AV_CODEC_ID_PCM_F64LE=65559, AV_CODEC_ID_PCM_BLURAY=65560, AV_CODEC_ID_PCM_LXF=65561, AV_CODEC_ID_S302M=65562, AV_CODEC_ID_PCM_S8_PLANAR=65563, AV_CODEC_ID_PCM_S24LE_PLANAR_DEPRECATED=65564, AV_CODEC_ID_PCM_S32LE_PLANAR_DEPRECATED=65565, AV_CODEC_ID_PCM_S16BE_PLANAR_DEPRECATED=65566, AV_CODEC_ID_PCM_S24LE_PLANAR=407917392, AV_CODEC_ID_PCM_S32LE_PLANAR=542135120, AV_CODEC_ID_PCM_S16BE_PLANAR=1347637264, AV_CODEC_ID_ADPCM_IMA_QT=69632, AV_CODEC_ID_ADPCM_IMA_WAV=69633, AV_CODEC_ID_ADPCM_IMA_DK3=69634, AV_CODEC_ID_ADPCM_IMA_DK4=69635, AV_CODEC_ID_ADPCM_IMA_WS=69636, AV_CODEC_ID_ADPCM_IMA_SMJPEG=69637, AV_CODEC_ID_ADPCM_MS=69638, AV_CODEC_ID_ADPCM_4XM=69639, AV_CODEC_ID_ADPCM_XA=69640, AV_CODEC_ID_ADPCM_ADX=69641, AV_CODEC_ID_ADPCM_EA=69642, AV_CODEC_ID_ADPCM_G726=69643, AV_CODEC_ID_ADPCM_CT=69644, AV_CODEC_ID_ADPCM_SWF=69645, AV_CODEC_ID_ADPCM_YAMAHA=69646, AV_CODEC_ID_ADPCM_SBPRO_4=69647, AV_CODEC_ID_ADPCM_SBPRO_3=69648, AV_CODEC_ID_ADPCM_SBPRO_2=69649, AV_CODEC_ID_ADPCM_THP=69650, AV_CODEC_ID_ADPCM_IMA_AMV=69651, AV_CODEC_ID_ADPCM_EA_R1=69652, AV_CODEC_ID_ADPCM_EA_R3=69653, AV_CODEC_ID_ADPCM_EA_R2=69654, AV_CODEC_ID_ADPCM_IMA_EA_SEAD=69655, AV_CODEC_ID_ADPCM_IMA_EA_EACS=69656, AV_CODEC_ID_ADPCM_EA_XAS=69657, AV_CODEC_ID_ADPCM_EA_MAXIS_XA=69658, AV_CODEC_ID_ADPCM_IMA_ISS=69659, AV_CODEC_ID_ADPCM_G722=69660, AV_CODEC_ID_ADPCM_IMA_APC=69661, AV_CODEC_ID_ADPCM_VIMA_DEPRECATED=69662, AV_CODEC_ID_ADPCM_VIMA=1447644481, AV_CODEC_ID_VIMA=1447644481, AV_CODEC_ID_ADPCM_AFC=1095123744, AV_CODEC_ID_ADPCM_IMA_OKI=1330333984, AV_CODEC_ID_ADPCM_DTK=1146374944, AV_CODEC_ID_ADPCM_IMA_RAD=1380008992, AV_CODEC_ID_ADPCM_G726LE=909260615, AV_CODEC_ID_ADPCM_THP_LE=1414025292, AV_CODEC_ID_AMR_NB=73728, AV_CODEC_ID_AMR_WB=73729, AV_CODEC_ID_RA_144=77824, AV_CODEC_ID_RA_288=77825, AV_CODEC_ID_ROQ_DPCM=81920, AV_CODEC_ID_INTERPLAY_DPCM=81921, AV_CODEC_ID_XAN_DPCM=81922, AV_CODEC_ID_SOL_DPCM=81923, AV_CODEC_ID_MP2=86016, AV_CODEC_ID_MP3=86017, AV_CODEC_ID_AAC=86018, AV_CODEC_ID_AC3=86019, AV_CODEC_ID_DTS=86020, AV_CODEC_ID_VORBIS=86021, AV_CODEC_ID_DVAUDIO=86022, AV_CODEC_ID_WMAV1=86023, AV_CODEC_ID_WMAV2=86024, AV_CODEC_ID_MACE3=86025, AV_CODEC_ID_MACE6=86026, AV_CODEC_ID_VMDAUDIO=86027, AV_CODEC_ID_FLAC=86028, AV_CODEC_ID_MP3ADU=86029, AV_CODEC_ID_MP3ON4=86030, AV_CODEC_ID_SHORTEN=86031, AV_CODEC_ID_ALAC=86032, AV_CODEC_ID_WESTWOOD_SND1=86033, AV_CODEC_ID_GSM=86034, AV_CODEC_ID_QDM2=86035, AV_CODEC_ID_COOK=86036, AV_CODEC_ID_TRUESPEECH=86037, AV_CODEC_ID_TTA=86038, AV_CODEC_ID_SMACKAUDIO=86039, AV_CODEC_ID_QCELP=86040, AV_CODEC_ID_WAVPACK=86041, AV_CODEC_ID_DSICINAUDIO=86042, AV_CODEC_ID_IMC=86043, AV_CODEC_ID_MUSEPACK7=86044, AV_CODEC_ID_MLP=86045, AV_CODEC_ID_GSM_MS=86046, AV_CODEC_ID_ATRAC3=86047, AV_CODEC_ID_VOXWARE=86048, AV_CODEC_ID_APE=86049, AV_CODEC_ID_NELLYMOSER=86050, AV_CODEC_ID_MUSEPACK8=86051, AV_CODEC_ID_SPEEX=86052, AV_CODEC_ID_WMAVOICE=86053, AV_CODEC_ID_WMAPRO=86054, AV_CODEC_ID_WMALOSSLESS=86055, AV_CODEC_ID_ATRAC3P=86056, AV_CODEC_ID_EAC3=86057, AV_CODEC_ID_SIPR=86058, AV_CODEC_ID_MP1=86059, AV_CODEC_ID_TWINVQ=86060, AV_CODEC_ID_TRUEHD=86061, AV_CODEC_ID_MP4ALS=86062, AV_CODEC_ID_ATRAC1=86063, AV_CODEC_ID_BINKAUDIO_RDFT=86064, AV_CODEC_ID_BINKAUDIO_DCT=86065, AV_CODEC_ID_AAC_LATM=86066, AV_CODEC_ID_QDMC=86067, AV_CODEC_ID_CELT=86068, AV_CODEC_ID_G723_1=86069, AV_CODEC_ID_G729=86070, AV_CODEC_ID_8SVX_EXP=86071, AV_CODEC_ID_8SVX_FIB=86072, AV_CODEC_ID_BMV_AUDIO=86073, AV_CODEC_ID_RALF=86074, AV_CODEC_ID_IAC=86075, AV_CODEC_ID_ILBC=86076, AV_CODEC_ID_OPUS_DEPRECATED=86077, AV_CODEC_ID_COMFORT_NOISE=86078, AV_CODEC_ID_TAK_DEPRECATED=86079, AV_CODEC_ID_METASOUND=86080, AV_CODEC_ID_PAF_AUDIO_DEPRECATED=86081, AV_CODEC_ID_ON2AVC=86082, AV_CODEC_ID_DSS_SP=86083, AV_CODEC_ID_FFWAVESYNTH=1179014995, AV_CODEC_ID_SONIC=1397706307, AV_CODEC_ID_SONIC_LS=1397706316, AV_CODEC_ID_PAF_AUDIO=1346455105, AV_CODEC_ID_OPUS=1330664787, AV_CODEC_ID_TAK=1950507339, AV_CODEC_ID_EVRC=1936029283, AV_CODEC_ID_SMV=1936944502, AV_CODEC_ID_DSD_LSBF=1146307660, AV_CODEC_ID_DSD_MSBF=1146307661, AV_CODEC_ID_DSD_LSBF_PLANAR=1146307633, AV_CODEC_ID_DSD_MSBF_PLANAR=1146307640, AV_CODEC_ID_4GV=1932814198, AV_CODEC_ID_FIRST_SUBTITLE=94208, AV_CODEC_ID_DVD_SUBTITLE=94208, AV_CODEC_ID_DVB_SUBTITLE=94209, AV_CODEC_ID_TEXT=94210, AV_CODEC_ID_XSUB=94211, AV_CODEC_ID_SSA=94212, AV_CODEC_ID_MOV_TEXT=94213, AV_CODEC_ID_HDMV_PGS_SUBTITLE=94214, AV_CODEC_ID_DVB_TELETEXT=94215, AV_CODEC_ID_SRT=94216, AV_CODEC_ID_MICRODVD=1833195076, AV_CODEC_ID_EIA_608=1664495672, AV_CODEC_ID_JACOSUB=1246975298, AV_CODEC_ID_SAMI=1396788553, AV_CODEC_ID_REALTEXT=1381259348, AV_CODEC_ID_STL=1399870540, AV_CODEC_ID_SUBVIEWER1=1398953521, AV_CODEC_ID_SUBVIEWER=1400201814, AV_CODEC_ID_SUBRIP=1397909872, AV_CODEC_ID_WEBVTT=1465275476, AV_CODEC_ID_MPL2=1297108018, AV_CODEC_ID_VPLAYER=1448111218, AV_CODEC_ID_PJS=1349012051, AV_CODEC_ID_ASS=1095979808, AV_CODEC_ID_HDMV_TEXT_SUBTITLE=1111774296, AV_CODEC_ID_FIRST_UNKNOWN=98304, AV_CODEC_ID_TTF=98304, AV_CODEC_ID_BINTEXT=1112823892, AV_CODEC_ID_XBIN=1480739150, AV_CODEC_ID_IDF=4801606, AV_CODEC_ID_OTF=5198918, AV_CODEC_ID_SMPTE_KLV=1263294017, AV_CODEC_ID_DVD_NAV=1145979222, AV_CODEC_ID_TIMED_ID3=1414087731, AV_CODEC_ID_BIN_DATA=1145132097, AV_CODEC_ID_PROBE=102400, AV_CODEC_ID_MPEG2TS=131072, AV_CODEC_ID_MPEG4SYSTEMS=131073, AV_CODEC_ID_FFMETADATA=135168, CODEC_ID_NONE=0, CODEC_ID_MPEG1VIDEO=1, CODEC_ID_MPEG2VIDEO=2, CODEC_ID_MPEG2VIDEO_XVMC=3, CODEC_ID_H261=4, CODEC_ID_H263=5, CODEC_ID_RV10=6, CODEC_ID_RV20=7, CODEC_ID_MJPEG=8, CODEC_ID_MJPEGB=9, CODEC_ID_LJPEG=10, CODEC_ID_SP5X=11, CODEC_ID_JPEGLS=12, CODEC_ID_MPEG4=13, CODEC_ID_RAWVIDEO=14, CODEC_ID_MSMPEG4V1=15, CODEC_ID_MSMPEG4V2=16, CODEC_ID_MSMPEG4V3=17, CODEC_ID_WMV1=18, CODEC_ID_WMV2=19, CODEC_ID_H263P=20, CODEC_ID_H263I=21, CODEC_ID_FLV1=22, CODEC_ID_SVQ1=23, CODEC_ID_SVQ3=24, CODEC_ID_DVVIDEO=25, CODEC_ID_HUFFYUV=26, CODEC_ID_CYUV=27, CODEC_ID_H264=28, CODEC_ID_INDEO3=29, CODEC_ID_VP3=30, CODEC_ID_THEORA=31, CODEC_ID_ASV1=32, CODEC_ID_ASV2=33, CODEC_ID_FFV1=34, CODEC_ID_4XM=35, CODEC_ID_VCR1=36, CODEC_ID_CLJR=37, CODEC_ID_MDEC=38, CODEC_ID_ROQ=39, CODEC_ID_INTERPLAY_VIDEO=40, CODEC_ID_XAN_WC3=41, CODEC_ID_XAN_WC4=42, CODEC_ID_RPZA=43, CODEC_ID_CINEPAK=44, CODEC_ID_WS_VQA=45, CODEC_ID_MSRLE=46, CODEC_ID_MSVIDEO1=47, CODEC_ID_IDCIN=48, CODEC_ID_8BPS=49, CODEC_ID_SMC=50, CODEC_ID_FLIC=51, CODEC_ID_TRUEMOTION1=52, CODEC_ID_VMDVIDEO=53, CODEC_ID_MSZH=54, CODEC_ID_ZLIB=55, CODEC_ID_QTRLE=56, CODEC_ID_TSCC=57, CODEC_ID_ULTI=58, CODEC_ID_QDRAW=59, CODEC_ID_VIXL=60, CODEC_ID_QPEG=61, CODEC_ID_PNG=62, CODEC_ID_PPM=63, CODEC_ID_PBM=64, CODEC_ID_PGM=65, CODEC_ID_PGMYUV=66, CODEC_ID_PAM=67, CODEC_ID_FFVHUFF=68, CODEC_ID_RV30=69, CODEC_ID_RV40=70, CODEC_ID_VC1=71, CODEC_ID_WMV3=72, CODEC_ID_LOCO=73, CODEC_ID_WNV1=74, CODEC_ID_AASC=75, CODEC_ID_INDEO2=76, CODEC_ID_FRAPS=77, CODEC_ID_TRUEMOTION2=78, CODEC_ID_BMP=79, CODEC_ID_CSCD=80, CODEC_ID_MMVIDEO=81, CODEC_ID_ZMBV=82, CODEC_ID_AVS=83, CODEC_ID_SMACKVIDEO=84, CODEC_ID_NUV=85, CODEC_ID_KMVC=86, CODEC_ID_FLASHSV=87, CODEC_ID_CAVS=88, CODEC_ID_JPEG2000=89, CODEC_ID_VMNC=90, CODEC_ID_VP5=91, CODEC_ID_VP6=92, CODEC_ID_VP6F=93, CODEC_ID_TARGA=94, CODEC_ID_DSICINVIDEO=95, CODEC_ID_TIERTEXSEQVIDEO=96, CODEC_ID_TIFF=97, CODEC_ID_GIF=98, CODEC_ID_DXA=99, CODEC_ID_DNXHD=100, CODEC_ID_THP=101, CODEC_ID_SGI=102, CODEC_ID_C93=103, CODEC_ID_BETHSOFTVID=104, CODEC_ID_PTX=105, CODEC_ID_TXD=106, CODEC_ID_VP6A=107, CODEC_ID_AMV=108, CODEC_ID_VB=109, CODEC_ID_PCX=110, CODEC_ID_SUNRAST=111, CODEC_ID_INDEO4=112, CODEC_ID_INDEO5=113, CODEC_ID_MIMIC=114, CODEC_ID_RL2=115, CODEC_ID_ESCAPE124=116, CODEC_ID_DIRAC=117, CODEC_ID_BFI=118, CODEC_ID_CMV=119, CODEC_ID_MOTIONPIXELS=120, CODEC_ID_TGV=121, CODEC_ID_TGQ=122, CODEC_ID_TQI=123, CODEC_ID_AURA=124, CODEC_ID_AURA2=125, CODEC_ID_V210X=126, CODEC_ID_TMV=127, CODEC_ID_V210=128, CODEC_ID_DPX=129, CODEC_ID_MAD=130, CODEC_ID_FRWU=131, CODEC_ID_FLASHSV2=132, CODEC_ID_CDGRAPHICS=133, CODEC_ID_R210=134, CODEC_ID_ANM=135, CODEC_ID_BINKVIDEO=136, CODEC_ID_IFF_ILBM=137, CODEC_ID_IFF_BYTERUN1=138, CODEC_ID_KGV1=139, CODEC_ID_YOP=140, CODEC_ID_VP8=141, CODEC_ID_PICTOR=142, CODEC_ID_ANSI=143, CODEC_ID_A64_MULTI=144, CODEC_ID_A64_MULTI5=145, CODEC_ID_R10K=146, CODEC_ID_MXPEG=147, CODEC_ID_LAGARITH=148, CODEC_ID_PRORES=149, CODEC_ID_JV=150, CODEC_ID_DFA=151, CODEC_ID_WMV3IMAGE=152, CODEC_ID_VC1IMAGE=153, CODEC_ID_UTVIDEO=154, CODEC_ID_BMV_VIDEO=155, CODEC_ID_VBLE=156, CODEC_ID_DXTORY=157, CODEC_ID_V410=158, CODEC_ID_XWD=159, CODEC_ID_CDXL=160, CODEC_ID_XBM=161, CODEC_ID_ZEROCODEC=162, CODEC_ID_MSS1=163, CODEC_ID_MSA1=164, CODEC_ID_TSCC2=165, CODEC_ID_MTS2=166, CODEC_ID_CLLC=167, CODEC_ID_Y41P=1496592720, CODEC_ID_ESCAPE130=1160852272, CODEC_ID_EXR=809850962, CODEC_ID_AVRP=1096176208, CODEC_ID_G2M=4665933, CODEC_ID_AVUI=1096176969, CODEC_ID_AYUV=1096373590, CODEC_ID_V308=1446195256, CODEC_ID_V408=1446260792, CODEC_ID_YUV4=1498764852, CODEC_ID_SANM=1396788813, CODEC_ID_PAF_VIDEO=1346455126, CODEC_ID_SNOW=1397641047, CODEC_ID_FIRST_AUDIO=65536, CODEC_ID_PCM_S16LE=65536, CODEC_ID_PCM_S16BE=65537, CODEC_ID_PCM_U16LE=65538, CODEC_ID_PCM_U16BE=65539, CODEC_ID_PCM_S8=65540, CODEC_ID_PCM_U8=65541, CODEC_ID_PCM_MULAW=65542, CODEC_ID_PCM_ALAW=65543, CODEC_ID_PCM_S32LE=65544, CODEC_ID_PCM_S32BE=65545, CODEC_ID_PCM_U32LE=65546, CODEC_ID_PCM_U32BE=65547, CODEC_ID_PCM_S24LE=65548, CODEC_ID_PCM_S24BE=65549, CODEC_ID_PCM_U24LE=65550, CODEC_ID_PCM_U24BE=65551, CODEC_ID_PCM_S24DAUD=65552, CODEC_ID_PCM_ZORK=65553, CODEC_ID_PCM_S16LE_PLANAR=65554, CODEC_ID_PCM_DVD=65555, CODEC_ID_PCM_F32BE=65556, CODEC_ID_PCM_F32LE=65557, CODEC_ID_PCM_F64BE=65558, CODEC_ID_PCM_F64LE=65559, CODEC_ID_PCM_BLURAY=65560, CODEC_ID_PCM_LXF=65561, CODEC_ID_S302M=65562, CODEC_ID_PCM_S8_PLANAR=65563, CODEC_ID_ADPCM_IMA_QT=69632, CODEC_ID_ADPCM_IMA_WAV=69633, CODEC_ID_ADPCM_IMA_DK3=69634, CODEC_ID_ADPCM_IMA_DK4=69635, CODEC_ID_ADPCM_IMA_WS=69636, CODEC_ID_ADPCM_IMA_SMJPEG=69637, CODEC_ID_ADPCM_MS=69638, CODEC_ID_ADPCM_4XM=69639, CODEC_ID_ADPCM_XA=69640, CODEC_ID_ADPCM_ADX=69641, CODEC_ID_ADPCM_EA=69642, CODEC_ID_ADPCM_G726=69643, CODEC_ID_ADPCM_CT=69644, CODEC_ID_ADPCM_SWF=69645, CODEC_ID_ADPCM_YAMAHA=69646, CODEC_ID_ADPCM_SBPRO_4=69647, CODEC_ID_ADPCM_SBPRO_3=69648, CODEC_ID_ADPCM_SBPRO_2=69649, CODEC_ID_ADPCM_THP=69650, CODEC_ID_ADPCM_IMA_AMV=69651, CODEC_ID_ADPCM_EA_R1=69652, CODEC_ID_ADPCM_EA_R3=69653, CODEC_ID_ADPCM_EA_R2=69654, CODEC_ID_ADPCM_IMA_EA_SEAD=69655, CODEC_ID_ADPCM_IMA_EA_EACS=69656, CODEC_ID_ADPCM_EA_XAS=69657, CODEC_ID_ADPCM_EA_MAXIS_XA=69658, CODEC_ID_ADPCM_IMA_ISS=69659, CODEC_ID_ADPCM_G722=69660, CODEC_ID_ADPCM_IMA_APC=69661, CODEC_ID_VIMA=1447644481, CODEC_ID_AMR_NB=73728, CODEC_ID_AMR_WB=73729, CODEC_ID_RA_144=77824, CODEC_ID_RA_288=77825, CODEC_ID_ROQ_DPCM=81920, CODEC_ID_INTERPLAY_DPCM=81921, CODEC_ID_XAN_DPCM=81922, CODEC_ID_SOL_DPCM=81923, CODEC_ID_MP2=86016, CODEC_ID_MP3=86017, CODEC_ID_AAC=86018, CODEC_ID_AC3=86019, CODEC_ID_DTS=86020, CODEC_ID_VORBIS=86021, CODEC_ID_DVAUDIO=86022, CODEC_ID_WMAV1=86023, CODEC_ID_WMAV2=86024, CODEC_ID_MACE3=86025, CODEC_ID_MACE6=86026, CODEC_ID_VMDAUDIO=86027, CODEC_ID_FLAC=86028, CODEC_ID_MP3ADU=86029, CODEC_ID_MP3ON4=86030, CODEC_ID_SHORTEN=86031, CODEC_ID_ALAC=86032, CODEC_ID_WESTWOOD_SND1=86033, CODEC_ID_GSM=86034, CODEC_ID_QDM2=86035, CODEC_ID_COOK=86036, CODEC_ID_TRUESPEECH=86037, CODEC_ID_TTA=86038, CODEC_ID_SMACKAUDIO=86039, CODEC_ID_QCELP=86040, CODEC_ID_WAVPACK=86041, CODEC_ID_DSICINAUDIO=86042, CODEC_ID_IMC=86043, CODEC_ID_MUSEPACK7=86044, CODEC_ID_MLP=86045, CODEC_ID_GSM_MS=86046, CODEC_ID_ATRAC3=86047, CODEC_ID_VOXWARE=86048, CODEC_ID_APE=86049, CODEC_ID_NELLYMOSER=86050, CODEC_ID_MUSEPACK8=86051, CODEC_ID_SPEEX=86052, CODEC_ID_WMAVOICE=86053, CODEC_ID_WMAPRO=86054, CODEC_ID_WMALOSSLESS=86055, CODEC_ID_ATRAC3P=86056, CODEC_ID_EAC3=86057, CODEC_ID_SIPR=86058, CODEC_ID_MP1=86059, CODEC_ID_TWINVQ=86060, CODEC_ID_TRUEHD=86061, CODEC_ID_MP4ALS=86062, CODEC_ID_ATRAC1=86063, CODEC_ID_BINKAUDIO_RDFT=86064, CODEC_ID_BINKAUDIO_DCT=86065, CODEC_ID_AAC_LATM=86066, CODEC_ID_QDMC=86067, CODEC_ID_CELT=86068, CODEC_ID_G723_1=86069, CODEC_ID_G729=86070, CODEC_ID_8SVX_EXP=86071, CODEC_ID_8SVX_FIB=86072, CODEC_ID_BMV_AUDIO=86073, CODEC_ID_RALF=86074, CODEC_ID_IAC=86075, CODEC_ID_ILBC=86076, CODEC_ID_FFWAVESYNTH=1179014995, CODEC_ID_SONIC=1397706307, CODEC_ID_SONIC_LS=1397706316, CODEC_ID_PAF_AUDIO=1346455105, CODEC_ID_OPUS=1330664787, CODEC_ID_FIRST_SUBTITLE=94208, CODEC_ID_DVD_SUBTITLE=94208, CODEC_ID_DVB_SUBTITLE=94209, CODEC_ID_TEXT=94210, CODEC_ID_XSUB=94211, CODEC_ID_SSA=94212, CODEC_ID_MOV_TEXT=94213, CODEC_ID_HDMV_PGS_SUBTITLE=94214, CODEC_ID_DVB_TELETEXT=94215, CODEC_ID_SRT=94216, CODEC_ID_MICRODVD=1833195076, CODEC_ID_EIA_608=1664495672, CODEC_ID_JACOSUB=1246975298, CODEC_ID_SAMI=1396788553, CODEC_ID_REALTEXT=1381259348, CODEC_ID_SUBVIEWER=1400201814, CODEC_ID_FIRST_UNKNOWN=98304, CODEC_ID_TTF=98304, CODEC_ID_BINTEXT=1112823892, CODEC_ID_XBIN=1480739150, CODEC_ID_IDF=4801606, CODEC_ID_OTF=5198918, CODEC_ID_PROBE=102400, CODEC_ID_MPEG2TS=131072, CODEC_ID_MPEG4SYSTEMS=131073, CODEC_ID_FFMETADATA=135168 };

// tag-AVCodecInternal
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 1482
struct AVCodecInternal;

// tag-AVCodecParser
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4541
struct AVCodecParser;

// tag-AVCodecParserContext
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4539
struct AVCodecParserContext;

// tag-AVCodecTag
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 443
struct AVCodecTag;

// tag-AVColorPrimaries
// file /usr/include/x86_64-linux-gnu/libavutil/pixfmt.h line 476
enum AVColorPrimaries { AVCOL_PRI_RESERVED0=0, AVCOL_PRI_BT709=1, AVCOL_PRI_UNSPECIFIED=2, AVCOL_PRI_RESERVED=3, AVCOL_PRI_BT470M=4, AVCOL_PRI_BT470BG=5, AVCOL_PRI_SMPTE170M=6, AVCOL_PRI_SMPTE240M=7, AVCOL_PRI_FILM=8, AVCOL_PRI_BT2020=9, AVCOL_PRI_NB=10 };

// tag-AVColorRange
// file /usr/include/x86_64-linux-gnu/libavutil/pixfmt.h line 537
enum AVColorRange { AVCOL_RANGE_UNSPECIFIED=0, AVCOL_RANGE_MPEG=1, AVCOL_RANGE_JPEG=2, AVCOL_RANGE_NB=3 };

// tag-AVColorSpace
// file /usr/include/x86_64-linux-gnu/libavutil/pixfmt.h line 517
enum AVColorSpace { AVCOL_SPC_RGB=0, AVCOL_SPC_BT709=1, AVCOL_SPC_UNSPECIFIED=2, AVCOL_SPC_RESERVED=3, AVCOL_SPC_FCC=4, AVCOL_SPC_BT470BG=5, AVCOL_SPC_SMPTE170M=6, AVCOL_SPC_SMPTE240M=7, AVCOL_SPC_YCOCG=8, AVCOL_SPC_BT2020_NCL=9, AVCOL_SPC_BT2020_CL=10, AVCOL_SPC_NB=11 };

// tag-AVColorTransferCharacteristic
// file /usr/include/x86_64-linux-gnu/libavutil/pixfmt.h line 494
enum AVColorTransferCharacteristic { AVCOL_TRC_RESERVED0=0, AVCOL_TRC_BT709=1, AVCOL_TRC_UNSPECIFIED=2, AVCOL_TRC_RESERVED=3, AVCOL_TRC_GAMMA22=4, AVCOL_TRC_GAMMA28=5, AVCOL_TRC_SMPTE170M=6, AVCOL_TRC_SMPTE240M=7, AVCOL_TRC_LINEAR=8, AVCOL_TRC_LOG=9, AVCOL_TRC_LOG_SQRT=10, AVCOL_TRC_IEC61966_2_4=11, AVCOL_TRC_BT1361_ECG=12, AVCOL_TRC_IEC61966_2_1=13, AVCOL_TRC_BT2020_10=14, AVCOL_TRC_BT2020_12=15, AVCOL_TRC_NB=16 };

// tag-AVDeviceCapabilitiesQuery
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 316
struct AVDeviceCapabilitiesQuery;

// tag-AVDeviceInfoList
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 315
struct AVDeviceInfoList;

// tag-AVDictionary
// file /usr/include/x86_64-linux-gnu/libavutil/dict.h line 87
struct AVDictionary;

// tag-AVDiscard
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 680
enum AVDiscard { AVDISCARD_NONE=-16, AVDISCARD_DEFAULT=0, AVDISCARD_NONREF=8, AVDISCARD_BIDIR=16, AVDISCARD_NONINTRA=24, AVDISCARD_NONKEY=32, AVDISCARD_ALL=48 };

// tag-AVDurationEstimationMethod
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1248
enum AVDurationEstimationMethod { AVFMT_DURATION_FROM_PTS=0, AVFMT_DURATION_FROM_STREAM=1, AVFMT_DURATION_FROM_BITRATE=2 };

// tag-AVFieldOrder
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 1484
enum AVFieldOrder { AV_FIELD_UNKNOWN=0, AV_FIELD_PROGRESSIVE=1, AV_FIELD_TT=2, AV_FIELD_BB=3, AV_FIELD_TB=4, AV_FIELD_BT=5 };

// tag-AVFilter
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 470
struct AVFilter;

// tag-AVFilterBuffer
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 75
struct AVFilterBuffer;

// tag-AVFilterBufferRef
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 158
struct AVFilterBufferRef;

// tag-AVFilterBufferRefAudioProps
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 125
struct AVFilterBufferRefAudioProps;

// tag-AVFilterBufferRefVideoProps
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 137
struct AVFilterBufferRefVideoProps;

// tag-AVFilterChannelLayouts
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 747
struct AVFilterChannelLayouts;

// tag-AVFilterCommand
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 681
struct AVFilterCommand;

// tag-AVFilterContext
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 64
struct AVFilterContext;

// tag-AVFilterFormats
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 67
struct AVFilterFormats;

// tag-AVFilterGraph
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 656
struct AVFilterGraph;

// tag-AVFilterGraphInternal
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 1140
struct AVFilterGraphInternal;

// tag-AVFilterInternal
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 630
struct AVFilterInternal;

// tag-AVFilterLink
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 65
struct AVFilterLink;

// tag-AVFilterPad
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 66
struct AVFilterPad;

// tag-AVFilterPool
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 767
struct AVFilterPool;

// tag-AVFormatContext
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 313
struct AVFormatContext;

// tag-AVFormatInternal
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1254
struct AVFormatInternal;

// tag-AVFrac
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 435
struct AVFrac;

// tag-AVFrame
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 171
struct AVFrame;

// tag-AVFrameSideData
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 134
struct AVFrameSideData;

// tag-AVFrameSideDataType
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 48
enum AVFrameSideDataType { AV_FRAME_DATA_PANSCAN=0, AV_FRAME_DATA_A53_CC=1, AV_FRAME_DATA_STEREO3D=2, AV_FRAME_DATA_MATRIXENCODING=3, AV_FRAME_DATA_DOWNMIX_INFO=4, AV_FRAME_DATA_REPLAYGAIN=5, AV_FRAME_DATA_DISPLAYMATRIX=6, AV_FRAME_DATA_AFD=7, AV_FRAME_DATA_MOTION_VECTORS=8, AV_FRAME_DATA_SKIP_SAMPLES=9, AV_FRAME_DATA_AUDIO_SERVICE_TYPE=10 };

// tag-AVHWAccel
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 2922
struct AVHWAccel;

// tag-AVIOContext
// file /usr/include/x86_64-linux-gnu/libavformat/avio.h line 111
struct AVIOContext;

// tag-AVIOInterruptCB
// file /usr/include/x86_64-linux-gnu/libavformat/avio.h line 50
struct AVIOInterruptCB;

// tag-AVIndexEntry
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 775
struct AVIndexEntry;

// tag-AVInputFormat
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 615
struct AVInputFormat;

// tag-AVMediaType
// file /usr/include/x86_64-linux-gnu/libavutil/avutil.h line 191
enum AVMediaType { AVMEDIA_TYPE_UNKNOWN=-1, AVMEDIA_TYPE_VIDEO=0, AVMEDIA_TYPE_AUDIO=1, AVMEDIA_TYPE_DATA=2, AVMEDIA_TYPE_SUBTITLE=3, AVMEDIA_TYPE_ATTACHMENT=4, AVMEDIA_TYPE_NB=5 };

// tag-AVOption
// file /usr/include/x86_64-linux-gnu/libavutil/log.h line 85
struct AVOption;

// tag-AVOptionRange
// file /usr/include/x86_64-linux-gnu/libavutil/opt.h line 316
struct AVOptionRange;

// tag-AVOptionRanges
// file /usr/include/x86_64-linux-gnu/libavutil/log.h line 60
struct AVOptionRanges;

// tag-AVOptionType
// file /usr/include/x86_64-linux-gnu/libavutil/opt.h line 221
enum AVOptionType { AV_OPT_TYPE_FLAGS=0, AV_OPT_TYPE_INT=1, AV_OPT_TYPE_INT64=2, AV_OPT_TYPE_DOUBLE=3, AV_OPT_TYPE_FLOAT=4, AV_OPT_TYPE_STRING=5, AV_OPT_TYPE_RATIONAL=6, AV_OPT_TYPE_BINARY=7, AV_OPT_TYPE_DICT=8, AV_OPT_TYPE_CONST=128, AV_OPT_TYPE_IMAGE_SIZE=1397316165, AV_OPT_TYPE_PIXEL_FMT=1346784596, AV_OPT_TYPE_SAMPLE_FMT=1397116244, AV_OPT_TYPE_VIDEO_RATE=1448231252, AV_OPT_TYPE_DURATION=1146442272, AV_OPT_TYPE_COLOR=1129270354, AV_OPT_TYPE_CHANNEL_LAYOUT=1128811585, FF_OPT_TYPE_FLAGS=0, FF_OPT_TYPE_INT=1, FF_OPT_TYPE_INT64=2, FF_OPT_TYPE_DOUBLE=3, FF_OPT_TYPE_FLOAT=4, FF_OPT_TYPE_STRING=5, FF_OPT_TYPE_RATIONAL=6, FF_OPT_TYPE_BINARY=7, FF_OPT_TYPE_CONST=128 };

// tag-AVOutputFormat
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 504
struct AVOutputFormat;

// tag-AVPacket
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 1400
struct AVPacket;

// tag-AVPacketList
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1032
struct AVPacketList;

// tag-AVPacketSideData
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 1372
struct AVPacketSideData;

// tag-AVPacketSideDataType
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 1224
enum AVPacketSideDataType { AV_PKT_DATA_PALETTE=0, AV_PKT_DATA_NEW_EXTRADATA=1, AV_PKT_DATA_PARAM_CHANGE=2, AV_PKT_DATA_H263_MB_INFO=3, AV_PKT_DATA_REPLAYGAIN=4, AV_PKT_DATA_DISPLAYMATRIX=5, AV_PKT_DATA_STEREO3D=6, AV_PKT_DATA_AUDIO_SERVICE_TYPE=7, AV_PKT_DATA_QUALITY_STATS=8, AV_PKT_DATA_SKIP_SAMPLES=70, AV_PKT_DATA_JP_DUALMONO=71, AV_PKT_DATA_STRINGS_METADATA=72, AV_PKT_DATA_SUBTITLE_POSITION=73, AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL=74, AV_PKT_DATA_WEBVTT_IDENTIFIER=75, AV_PKT_DATA_WEBVTT_SETTINGS=76, AV_PKT_DATA_METADATA_UPDATE=77 };

// tag-AVPanScan
// file /usr/include/x86_64-linux-gnu/libavutil/frame.h line 387
struct AVPanScan;

// tag-AVPicture
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3744
struct AVPicture;

// tag-AVPictureStructure
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4532
enum AVPictureStructure { AV_PICTURE_STRUCTURE_UNKNOWN=0, AV_PICTURE_STRUCTURE_TOP_FIELD=1, AV_PICTURE_STRUCTURE_BOTTOM_FIELD=2, AV_PICTURE_STRUCTURE_FRAME=3 };

// tag-AVPictureType
// file /usr/include/x86_64-linux-gnu/libavutil/avutil.h line 264
enum AVPictureType { AV_PICTURE_TYPE_NONE=0, AV_PICTURE_TYPE_I=1, AV_PICTURE_TYPE_P=2, AV_PICTURE_TYPE_B=3, AV_PICTURE_TYPE_S=4, AV_PICTURE_TYPE_SI=5, AV_PICTURE_TYPE_SP=6, AV_PICTURE_TYPE_BI=7 };

// tag-AVPixelFormat
// file /usr/include/x86_64-linux-gnu/libavutil/pixfmt.h line 61
enum AVPixelFormat { AV_PIX_FMT_NONE=-1, AV_PIX_FMT_YUV420P=0, AV_PIX_FMT_YUYV422=1, AV_PIX_FMT_RGB24=2, AV_PIX_FMT_BGR24=3, AV_PIX_FMT_YUV422P=4, AV_PIX_FMT_YUV444P=5, AV_PIX_FMT_YUV410P=6, AV_PIX_FMT_YUV411P=7, AV_PIX_FMT_GRAY8=8, AV_PIX_FMT_MONOWHITE=9, AV_PIX_FMT_MONOBLACK=10, AV_PIX_FMT_PAL8=11, AV_PIX_FMT_YUVJ420P=12, AV_PIX_FMT_YUVJ422P=13, AV_PIX_FMT_YUVJ444P=14, AV_PIX_FMT_XVMC_MPEG2_MC=15, AV_PIX_FMT_XVMC_MPEG2_IDCT=16, AV_PIX_FMT_UYVY422=17, AV_PIX_FMT_UYYVYY411=18, AV_PIX_FMT_BGR8=19, AV_PIX_FMT_BGR4=20, AV_PIX_FMT_BGR4_BYTE=21, AV_PIX_FMT_RGB8=22, AV_PIX_FMT_RGB4=23, AV_PIX_FMT_RGB4_BYTE=24, AV_PIX_FMT_NV12=25, AV_PIX_FMT_NV21=26, AV_PIX_FMT_ARGB=27, AV_PIX_FMT_RGBA=28, AV_PIX_FMT_ABGR=29, AV_PIX_FMT_BGRA=30, AV_PIX_FMT_GRAY16BE=31, AV_PIX_FMT_GRAY16LE=32, AV_PIX_FMT_YUV440P=33, AV_PIX_FMT_YUVJ440P=34, AV_PIX_FMT_YUVA420P=35, AV_PIX_FMT_VDPAU_H264=36, AV_PIX_FMT_VDPAU_MPEG1=37, AV_PIX_FMT_VDPAU_MPEG2=38, AV_PIX_FMT_VDPAU_WMV3=39, AV_PIX_FMT_VDPAU_VC1=40, AV_PIX_FMT_RGB48BE=41, AV_PIX_FMT_RGB48LE=42, AV_PIX_FMT_RGB565BE=43, AV_PIX_FMT_RGB565LE=44, AV_PIX_FMT_RGB555BE=45, AV_PIX_FMT_RGB555LE=46, AV_PIX_FMT_BGR565BE=47, AV_PIX_FMT_BGR565LE=48, AV_PIX_FMT_BGR555BE=49, AV_PIX_FMT_BGR555LE=50, AV_PIX_FMT_VAAPI_MOCO=51, AV_PIX_FMT_VAAPI_IDCT=52, AV_PIX_FMT_VAAPI_VLD=53, AV_PIX_FMT_VAAPI=53, AV_PIX_FMT_YUV420P16LE=54, AV_PIX_FMT_YUV420P16BE=55, AV_PIX_FMT_YUV422P16LE=56, AV_PIX_FMT_YUV422P16BE=57, AV_PIX_FMT_YUV444P16LE=58, AV_PIX_FMT_YUV444P16BE=59, AV_PIX_FMT_VDPAU_MPEG4=60, AV_PIX_FMT_DXVA2_VLD=61, AV_PIX_FMT_RGB444LE=62, AV_PIX_FMT_RGB444BE=63, AV_PIX_FMT_BGR444LE=64, AV_PIX_FMT_BGR444BE=65, AV_PIX_FMT_YA8=66, AV_PIX_FMT_Y400A=66, AV_PIX_FMT_GRAY8A=66, AV_PIX_FMT_BGR48BE=67, AV_PIX_FMT_BGR48LE=68, AV_PIX_FMT_YUV420P9BE=69, AV_PIX_FMT_YUV420P9LE=70, AV_PIX_FMT_YUV420P10BE=71, AV_PIX_FMT_YUV420P10LE=72, AV_PIX_FMT_YUV422P10BE=73, AV_PIX_FMT_YUV422P10LE=74, AV_PIX_FMT_YUV444P9BE=75, AV_PIX_FMT_YUV444P9LE=76, AV_PIX_FMT_YUV444P10BE=77, AV_PIX_FMT_YUV444P10LE=78, AV_PIX_FMT_YUV422P9BE=79, AV_PIX_FMT_YUV422P9LE=80, AV_PIX_FMT_VDA_VLD=81, AV_PIX_FMT_GBRP=82, AV_PIX_FMT_GBRP9BE=83, AV_PIX_FMT_GBRP9LE=84, AV_PIX_FMT_GBRP10BE=85, AV_PIX_FMT_GBRP10LE=86, AV_PIX_FMT_GBRP16BE=87, AV_PIX_FMT_GBRP16LE=88, AV_PIX_FMT_YUVA422P_LIBAV=89, AV_PIX_FMT_YUVA444P_LIBAV=90, AV_PIX_FMT_YUVA420P9BE=91, AV_PIX_FMT_YUVA420P9LE=92, AV_PIX_FMT_YUVA422P9BE=93, AV_PIX_FMT_YUVA422P9LE=94, AV_PIX_FMT_YUVA444P9BE=95, AV_PIX_FMT_YUVA444P9LE=96, AV_PIX_FMT_YUVA420P10BE=97, AV_PIX_FMT_YUVA420P10LE=98, AV_PIX_FMT_YUVA422P10BE=99, AV_PIX_FMT_YUVA422P10LE=100, AV_PIX_FMT_YUVA444P10BE=101, AV_PIX_FMT_YUVA444P10LE=102, AV_PIX_FMT_YUVA420P16BE=103, AV_PIX_FMT_YUVA420P16LE=104, AV_PIX_FMT_YUVA422P16BE=105, AV_PIX_FMT_YUVA422P16LE=106, AV_PIX_FMT_YUVA444P16BE=107, AV_PIX_FMT_YUVA444P16LE=108, AV_PIX_FMT_VDPAU=109, AV_PIX_FMT_XYZ12LE=110, AV_PIX_FMT_XYZ12BE=111, AV_PIX_FMT_NV16=112, AV_PIX_FMT_NV20LE=113, AV_PIX_FMT_NV20BE=114, AV_PIX_FMT_RGBA64BE_LIBAV=115, AV_PIX_FMT_RGBA64LE_LIBAV=116, AV_PIX_FMT_BGRA64BE_LIBAV=117, AV_PIX_FMT_BGRA64LE_LIBAV=118, AV_PIX_FMT_YVYU422=119, AV_PIX_FMT_VDA=120, AV_PIX_FMT_YA16BE=121, AV_PIX_FMT_YA16LE=122, AV_PIX_FMT_GBRAP_LIBAV=123, AV_PIX_FMT_GBRAP16BE_LIBAV=124, AV_PIX_FMT_GBRAP16LE_LIBAV=125, AV_PIX_FMT_QSV=126, AV_PIX_FMT_MMAL=127, AV_PIX_FMT_D3D11VA_VLD=128, AV_PIX_FMT_RGBA64BE=291, AV_PIX_FMT_RGBA64LE=292, AV_PIX_FMT_BGRA64BE=293, AV_PIX_FMT_BGRA64LE=294, AV_PIX_FMT_0RGB=295, AV_PIX_FMT_RGB0=296, AV_PIX_FMT_0BGR=297, AV_PIX_FMT_BGR0=298, AV_PIX_FMT_YUVA444P=299, AV_PIX_FMT_YUVA422P=300, AV_PIX_FMT_YUV420P12BE=301, AV_PIX_FMT_YUV420P12LE=302, AV_PIX_FMT_YUV420P14BE=303, AV_PIX_FMT_YUV420P14LE=304, AV_PIX_FMT_YUV422P12BE=305, AV_PIX_FMT_YUV422P12LE=306, AV_PIX_FMT_YUV422P14BE=307, AV_PIX_FMT_YUV422P14LE=308, AV_PIX_FMT_YUV444P12BE=309, AV_PIX_FMT_YUV444P12LE=310, AV_PIX_FMT_YUV444P14BE=311, AV_PIX_FMT_YUV444P14LE=312, AV_PIX_FMT_GBRP12BE=313, AV_PIX_FMT_GBRP12LE=314, AV_PIX_FMT_GBRP14BE=315, AV_PIX_FMT_GBRP14LE=316, AV_PIX_FMT_GBRAP=317, AV_PIX_FMT_GBRAP16BE=318, AV_PIX_FMT_GBRAP16LE=319, AV_PIX_FMT_YUVJ411P=320, AV_PIX_FMT_BAYER_BGGR8=321, AV_PIX_FMT_BAYER_RGGB8=322, AV_PIX_FMT_BAYER_GBRG8=323, AV_PIX_FMT_BAYER_GRBG8=324, AV_PIX_FMT_BAYER_BGGR16LE=325, AV_PIX_FMT_BAYER_BGGR16BE=326, AV_PIX_FMT_BAYER_RGGB16LE=327, AV_PIX_FMT_BAYER_RGGB16BE=328, AV_PIX_FMT_BAYER_GBRG16LE=329, AV_PIX_FMT_BAYER_GBRG16BE=330, AV_PIX_FMT_BAYER_GRBG16LE=331, AV_PIX_FMT_BAYER_GRBG16BE=332, AV_PIX_FMT_YUV440P10LE=333, AV_PIX_FMT_YUV440P10BE=334, AV_PIX_FMT_YUV440P12LE=335, AV_PIX_FMT_YUV440P12BE=336, AV_PIX_FMT_AYUV64LE=337, AV_PIX_FMT_AYUV64BE=338, AV_PIX_FMT_VIDEOTOOLBOX=339, AV_PIX_FMT_NB=340, PIX_FMT_NONE=-1, PIX_FMT_YUV420P=0, PIX_FMT_YUYV422=1, PIX_FMT_RGB24=2, PIX_FMT_BGR24=3, PIX_FMT_YUV422P=4, PIX_FMT_YUV444P=5, PIX_FMT_YUV410P=6, PIX_FMT_YUV411P=7, PIX_FMT_GRAY8=8, PIX_FMT_MONOWHITE=9, PIX_FMT_MONOBLACK=10, PIX_FMT_PAL8=11, PIX_FMT_YUVJ420P=12, PIX_FMT_YUVJ422P=13, PIX_FMT_YUVJ444P=14, PIX_FMT_XVMC_MPEG2_MC=15, PIX_FMT_XVMC_MPEG2_IDCT=16, PIX_FMT_UYVY422=17, PIX_FMT_UYYVYY411=18, PIX_FMT_BGR8=19, PIX_FMT_BGR4=20, PIX_FMT_BGR4_BYTE=21, PIX_FMT_RGB8=22, PIX_FMT_RGB4=23, PIX_FMT_RGB4_BYTE=24, PIX_FMT_NV12=25, PIX_FMT_NV21=26, PIX_FMT_ARGB=27, PIX_FMT_RGBA=28, PIX_FMT_ABGR=29, PIX_FMT_BGRA=30, PIX_FMT_GRAY16BE=31, PIX_FMT_GRAY16LE=32, PIX_FMT_YUV440P=33, PIX_FMT_YUVJ440P=34, PIX_FMT_YUVA420P=35, PIX_FMT_VDPAU_H264=36, PIX_FMT_VDPAU_MPEG1=37, PIX_FMT_VDPAU_MPEG2=38, PIX_FMT_VDPAU_WMV3=39, PIX_FMT_VDPAU_VC1=40, PIX_FMT_RGB48BE=41, PIX_FMT_RGB48LE=42, PIX_FMT_RGB565BE=43, PIX_FMT_RGB565LE=44, PIX_FMT_RGB555BE=45, PIX_FMT_RGB555LE=46, PIX_FMT_BGR565BE=47, PIX_FMT_BGR565LE=48, PIX_FMT_BGR555BE=49, PIX_FMT_BGR555LE=50, PIX_FMT_VAAPI_MOCO=51, PIX_FMT_VAAPI_IDCT=52, PIX_FMT_VAAPI_VLD=53, PIX_FMT_YUV420P16LE=54, PIX_FMT_YUV420P16BE=55, PIX_FMT_YUV422P16LE=56, PIX_FMT_YUV422P16BE=57, PIX_FMT_YUV444P16LE=58, PIX_FMT_YUV444P16BE=59, PIX_FMT_VDPAU_MPEG4=60, PIX_FMT_DXVA2_VLD=61, PIX_FMT_RGB444LE=62, PIX_FMT_RGB444BE=63, PIX_FMT_BGR444LE=64, PIX_FMT_BGR444BE=65, PIX_FMT_GRAY8A=66, PIX_FMT_BGR48BE=67, PIX_FMT_BGR48LE=68, PIX_FMT_YUV420P9BE=69, PIX_FMT_YUV420P9LE=70, PIX_FMT_YUV420P10BE=71, PIX_FMT_YUV420P10LE=72, PIX_FMT_YUV422P10BE=73, PIX_FMT_YUV422P10LE=74, PIX_FMT_YUV444P9BE=75, PIX_FMT_YUV444P9LE=76, PIX_FMT_YUV444P10BE=77, PIX_FMT_YUV444P10LE=78, PIX_FMT_YUV422P9BE=79, PIX_FMT_YUV422P9LE=80, PIX_FMT_VDA_VLD=81, PIX_FMT_GBRP=82, PIX_FMT_GBRP9BE=83, PIX_FMT_GBRP9LE=84, PIX_FMT_GBRP10BE=85, PIX_FMT_GBRP10LE=86, PIX_FMT_GBRP16BE=87, PIX_FMT_GBRP16LE=88, PIX_FMT_RGBA64BE=291, PIX_FMT_RGBA64LE=292, PIX_FMT_BGRA64BE=293, PIX_FMT_BGRA64LE=294, PIX_FMT_0RGB=295, PIX_FMT_RGB0=296, PIX_FMT_0BGR=297, PIX_FMT_BGR0=298, PIX_FMT_YUVA444P=299, PIX_FMT_YUVA422P=300, PIX_FMT_YUV420P12BE=301, PIX_FMT_YUV420P12LE=302, PIX_FMT_YUV420P14BE=303, PIX_FMT_YUV420P14LE=304, PIX_FMT_YUV422P12BE=305, PIX_FMT_YUV422P12LE=306, PIX_FMT_YUV422P14BE=307, PIX_FMT_YUV422P14LE=308, PIX_FMT_YUV444P12BE=309, PIX_FMT_YUV444P12LE=310, PIX_FMT_YUV444P14BE=311, PIX_FMT_YUV444P14LE=312, PIX_FMT_GBRP12BE=313, PIX_FMT_GBRP12LE=314, PIX_FMT_GBRP14BE=315, PIX_FMT_GBRP14LE=316, PIX_FMT_NB=317 };

// tag-AVProbeData
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 448
struct AVProbeData;

// tag-AVProfile
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3460
struct AVProfile;

// tag-AVProgram
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1198
struct AVProgram;

// tag-AVRational
// file /usr/include/x86_64-linux-gnu/libavutil/rational.h line 43
struct AVRational;

// tag-AVSampleFormat
// file /usr/include/x86_64-linux-gnu/libavutil/samplefmt.h line 59
enum AVSampleFormat { AV_SAMPLE_FMT_NONE=-1, AV_SAMPLE_FMT_U8=0, AV_SAMPLE_FMT_S16=1, AV_SAMPLE_FMT_S32=2, AV_SAMPLE_FMT_FLT=3, AV_SAMPLE_FMT_DBL=4, AV_SAMPLE_FMT_U8P=5, AV_SAMPLE_FMT_S16P=6, AV_SAMPLE_FMT_S32P=7, AV_SAMPLE_FMT_FLTP=8, AV_SAMPLE_FMT_DBLP=9, AV_SAMPLE_FMT_NB=10 };

// tag-AVStream
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 834
struct AVStream;

// tag-AVStreamParseType
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 764
enum AVStreamParseType { AVSTREAM_PARSE_NONE=0, AVSTREAM_PARSE_FULL=1, AVSTREAM_PARSE_HEADERS=2, AVSTREAM_PARSE_TIMESTAMPS=3, AVSTREAM_PARSE_FULL_ONCE=4, AVSTREAM_PARSE_FULL_RAW=1463898624 };

// tag-AVSubtitle
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3467
struct AVSubtitle;

// tag-AVSubtitleRect
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3773
struct AVSubtitleRect;

// tag-AVSubtitleType
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3753
enum AVSubtitleType { SUBTITLE_NONE=0, SUBTITLE_BITMAP=1, SUBTITLE_TEXT=2, SUBTITLE_ASS=3 };

// tag-FFFrac
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1174
struct FFFrac;

// tag-MpegEncContext
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3571
struct MpegEncContext;

// tag-PianoArtist
// file src/libpiano/piano.h line 104
struct PianoArtist;

// tag-PianoGenre
// file src/libpiano/piano.h line 112
struct PianoGenre;

// tag-PianoGenreCategory
// file src/libpiano/piano.h line 118
struct PianoGenreCategory;

// tag-PianoHandle
// file src/libpiano/piano.h line 130
struct PianoHandle;

// tag-PianoListHead
// file src/libpiano/piano.h line 45
struct PianoListHead;

// tag-PianoPartner
// file src/libpiano/piano.h line 124
struct PianoPartner;

// tag-PianoRequest
// file src/libpiano/piano.h line 175
struct PianoRequest;

// tag-PianoSearchResult
// file src/libpiano/piano.h line 139
struct PianoSearchResult;

// tag-PianoSong
// file src/libpiano/piano.h line 84
struct PianoSong;

// tag-PianoStation
// file src/libpiano/piano.h line 54
struct PianoStation;

// tag-PianoUserInfo
// file src/libpiano/piano.h line 49
struct PianoUserInfo;

// tag-RcOverride
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 708
struct RcOverride;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-ao_device
// file /usr/include/ao/ao.h line 77
struct ao_device;

// tag-ao_option
// file /usr/include/ao/ao.h line 87
struct ao_option;

// tag-ao_sample_format
// file /usr/include/ao/ao.h line 79
struct ao_sample_format;

// tag-gcry_cipher_handle
// file /usr/include/gcrypt.h line 842
struct gcry_cipher_handle;

// tag-gcry_ctl_cmds
// file /usr/include/gcrypt.h line 263
enum gcry_ctl_cmds { GCRYCTL_CFB_SYNC=3, GCRYCTL_RESET=4, GCRYCTL_FINALIZE=5, GCRYCTL_GET_KEYLEN=6, GCRYCTL_GET_BLKLEN=7, GCRYCTL_TEST_ALGO=8, GCRYCTL_IS_SECURE=9, GCRYCTL_GET_ASNOID=10, GCRYCTL_ENABLE_ALGO=11, GCRYCTL_DISABLE_ALGO=12, GCRYCTL_DUMP_RANDOM_STATS=13, GCRYCTL_DUMP_SECMEM_STATS=14, GCRYCTL_GET_ALGO_NPKEY=15, GCRYCTL_GET_ALGO_NSKEY=16, GCRYCTL_GET_ALGO_NSIGN=17, GCRYCTL_GET_ALGO_NENCR=18, GCRYCTL_SET_VERBOSITY=19, GCRYCTL_SET_DEBUG_FLAGS=20, GCRYCTL_CLEAR_DEBUG_FLAGS=21, GCRYCTL_USE_SECURE_RNDPOOL=22, GCRYCTL_DUMP_MEMORY_STATS=23, GCRYCTL_INIT_SECMEM=24, GCRYCTL_TERM_SECMEM=25, GCRYCTL_DISABLE_SECMEM_WARN=27, GCRYCTL_SUSPEND_SECMEM_WARN=28, GCRYCTL_RESUME_SECMEM_WARN=29, GCRYCTL_DROP_PRIVS=30, GCRYCTL_ENABLE_M_GUARD=31, GCRYCTL_START_DUMP=32, GCRYCTL_STOP_DUMP=33, GCRYCTL_GET_ALGO_USAGE=34, GCRYCTL_IS_ALGO_ENABLED=35, GCRYCTL_DISABLE_INTERNAL_LOCKING=36, GCRYCTL_DISABLE_SECMEM=37, GCRYCTL_INITIALIZATION_FINISHED=38, GCRYCTL_INITIALIZATION_FINISHED_P=39, GCRYCTL_ANY_INITIALIZATION_P=40, GCRYCTL_SET_CBC_CTS=41, GCRYCTL_SET_CBC_MAC=42, GCRYCTL_ENABLE_QUICK_RANDOM=44, GCRYCTL_SET_RANDOM_SEED_FILE=45, GCRYCTL_UPDATE_RANDOM_SEED_FILE=46, GCRYCTL_SET_THREAD_CBS=47, GCRYCTL_FAST_POLL=48, GCRYCTL_SET_RANDOM_DAEMON_SOCKET=49, GCRYCTL_USE_RANDOM_DAEMON=50, GCRYCTL_FAKED_RANDOM_P=51, GCRYCTL_SET_RNDEGD_SOCKET=52, GCRYCTL_PRINT_CONFIG=53, GCRYCTL_OPERATIONAL_P=54, GCRYCTL_FIPS_MODE_P=55, GCRYCTL_FORCE_FIPS_MODE=56, GCRYCTL_SELFTEST=57, GCRYCTL_DISABLE_HWF=63, GCRYCTL_SET_ENFORCED_FIPS_FLAG=64, GCRYCTL_SET_PREFERRED_RNG_TYPE=65, GCRYCTL_GET_CURRENT_RNG_TYPE=66, GCRYCTL_DISABLE_LOCKED_SECMEM=67, GCRYCTL_DISABLE_PRIV_DROP=68, GCRYCTL_SET_CCM_LENGTHS=69, GCRYCTL_CLOSE_RANDOM_DEVICE=70, GCRYCTL_INACTIVATE_FIPS_FLAG=71, GCRYCTL_REACTIVATE_FIPS_FLAG=72 };

// tag-gnutls_certificate_credentials_st
// file /usr/include/gnutls/gnutls.h line 1288
struct gnutls_certificate_credentials_st;

// tag-gnutls_session_int
// file /usr/include/gnutls/gnutls.h line 750
struct gnutls_session_int;

// tag-gnutls_x509_crt_int
// file /usr/include/gnutls/gnutls.h line 1276
struct gnutls_x509_crt_int;

// tag-json_object
// file /usr/include/json-c/json_object.h line 71
struct json_object;

// tag-json_type
// file /usr/include/json-c/json_object.h line 100
enum json_type { json_type_null=0, json_type_boolean=1, json_type_double=2, json_type_int=3, json_type_object=4, json_type_array=5, json_type_string=6 };

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pollfd
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 39
struct pollfd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-termios
// file /usr/include/x86_64-linux-gnu/bits/termios.h line 28
struct termios;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// BarGetXdgConfigDir
// file src/settings.c line 69
static char * BarGetXdgConfigDir(const char * const filename);
// BarMainGetInitialStation
// file src/main.c line 203
static void BarMainGetInitialStation(struct anonymous$35 *app);
// BarMainGetLoginCredentials
// file src/main.c line 107
static _Bool BarMainGetLoginCredentials(struct anonymous$33 *settings, struct anonymous$40 *input);
// BarMainGetPlaylist
// file src/main.c line 236
static void BarMainGetPlaylist(struct anonymous$35 *app);
// BarMainGetStations
// file src/main.c line 189
static _Bool BarMainGetStations(struct anonymous$35 *app);
// BarMainHandleUserInput
// file src/main.c line 225
static void BarMainHandleUserInput(struct anonymous$35 *app);
// BarMainLoadProxy
// file src/main.c line 66
static void BarMainLoadProxy(const struct anonymous$33 *settings, struct anonymous$7 *waith);
// BarMainLoginUser
// file src/main.c line 88
static _Bool BarMainLoginUser(struct anonymous$35 *app);
// BarMainLoop
// file src/main.c line 354
static void BarMainLoop(struct anonymous$35 *app);
// BarMainPlayerCleanup
// file src/main.c line 304
static void BarMainPlayerCleanup(struct anonymous$35 *app, unsigned long int *playerThread);
// BarMainPrintTime
// file src/main.c line 334
static void BarMainPrintTime(struct anonymous$35 *app);
// BarMainStartPlayback
// file src/main.c line 261
static void BarMainStartPlayback(struct anonymous$35 *app, unsigned long int *playerThread);
// BarPianoHttpRequest
// file src/ui.c line 138
static enum anonymous$5 BarPianoHttpRequest(struct anonymous$7 *waith, struct PianoRequest *req);
// BarPlayerDestroy
// file src/player.h line 88
void BarPlayerDestroy();
// BarPlayerInit
// file src/player.h line 87
void BarPlayerInit();
// BarPlayerSetVolume
// file src/player.c line 86
void BarPlayerSetVolume(struct anonymous$3 * const player);
// BarPlayerThread
// file src/player.h line 85
void * BarPlayerThread(void *data);
// BarReadline
// file src/ui_readline.h line 42
unsigned long int BarReadline(char *buf, const unsigned long int bufSize, const char *mask, struct anonymous$40 *input, const enum anonymous$45 flags, signed int timeout);
// BarReadlineInt
// file src/ui_readline.h line 46
unsigned long int BarReadlineInt(signed int *ret, struct anonymous$40 *input);
// BarReadlinePrevUtf8
// file src/ui_readline.c line 34
static unsigned long int BarReadlinePrevUtf8(char *ptr);
// BarReadlineStr
// file src/ui_readline.h line 44
unsigned long int BarReadlineStr(char *buf, const unsigned long int bufSize, struct anonymous$40 *input, const enum anonymous$45 flags);
// BarReadlineYesNo
// file src/ui_readline.h line 47
_Bool BarReadlineYesNo(_Bool def, struct anonymous$40 *input);
// BarSettingsDestroy
// file src/settings.h line 114
void BarSettingsDestroy(struct anonymous$33 *settings);
// BarSettingsExpandTilde
// file src/settings.c line 88
char * BarSettingsExpandTilde(const char * const path, const char * const home);
// BarSettingsGetHome
// file src/settings.c line 50
static char * BarSettingsGetHome();
// BarSettingsInit
// file src/settings.h line 113
void BarSettingsInit(struct anonymous$33 *settings);
// BarSettingsRead
// file src/settings.h line 115
void BarSettingsRead(struct anonymous$33 *settings);
// BarSettingsWrite
// file src/settings.h line 116
void BarSettingsWrite(struct PianoStation *station, struct anonymous$33 *settings);
// BarSortedStations
// file src/ui.c line 294
static struct PianoStation ** BarSortedStations(struct PianoStation *unsortedStations, unsigned long int *retStationCount, enum anonymous$38 order);
// BarStationCmpQuickmix01NameAZ
// file src/ui.c line 268
static signed int BarStationCmpQuickmix01NameAZ(const void *a, const void *b);
// BarStationCmpQuickmix01NameZA
// file src/ui.c line 274
static signed int BarStationCmpQuickmix01NameZA(const void *a, const void *b);
// BarStationCmpQuickmix10NameAZ
// file src/ui.c line 280
static signed int BarStationCmpQuickmix10NameAZ(const void *a, const void *b);
// BarStationCmpQuickmix10NameZA
// file src/ui.c line 286
static signed int BarStationCmpQuickmix10NameZA(const void *a, const void *b);
// BarStationNameAZCmp
// file src/ui.c line 246
static inline signed int BarStationNameAZCmp(const void *a, const void *b);
// BarStationNameZACmp
// file src/ui.c line 254
static signed int BarStationNameZACmp(const void *a, const void *b);
// BarStationQuickmix01Cmp
// file src/ui.c line 238
static inline signed int BarStationQuickmix01Cmp(const void *a, const void *b);
// BarStationQuickmixNameCmp
// file src/ui.c line 260
static inline signed int BarStationQuickmixNameCmp(const void *a, const void *b, const void *c, const void *d);
// BarStrCaseStr
// file src/ui.c line 68
static const char * BarStrCaseStr(const char *haystack, const char *needle);
// BarTermHandleCont
// file src/terminal.c line 38
static void BarTermHandleCont(signed int sig);
// BarTermInit
// file src/terminal.h line 27
void BarTermInit();
// BarTermRestore
// file src/terminal.h line 28
void BarTermRestore();
// BarTransformIfShared
// file src/ui_act.c line 64
static signed int BarTransformIfShared(struct anonymous$35 *app, struct PianoStation *station);
// BarUiActAddMusic
// file src/ui_act.h line 37
void BarUiActAddMusic(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActAddSharedStation
// file src/ui_act.h line 41
void BarUiActAddSharedStation(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActBanSong
// file src/ui_act.h line 38
void BarUiActBanSong(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActBookmark
// file src/ui_act.h line 59
void BarUiActBookmark(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActCreateStation
// file src/ui_act.h line 39
void BarUiActCreateStation(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActCreateStationFromSong
// file src/ui_act.h line 40
void BarUiActCreateStationFromSong(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActDebug
// file src/ui_act.h line 57
void BarUiActDebug(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActDeleteStation
// file src/ui_act.h line 42
void BarUiActDeleteStation(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActExplain
// file src/ui_act.h line 43
void BarUiActExplain(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActHelp
// file src/ui_act.h line 36
void BarUiActHelp(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActHistory
// file src/ui_act.h line 58
void BarUiActHistory(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActLoveSong
// file src/ui_act.h line 46
void BarUiActLoveSong(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActManageStation
// file src/ui_act.h line 62
void BarUiActManageStation(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActPause
// file src/ui_act.h line 49
void BarUiActPause(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActPlay
// file src/ui_act.h line 48
void BarUiActPlay(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActPrintUpcoming
// file src/ui_act.h line 54
void BarUiActPrintUpcoming(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActQuickmixCallback
// file src/ui_act.c line 512
static void BarUiActQuickmixCallback(struct anonymous$35 *app, char *buf);
// BarUiActQuit
// file src/ui_act.h line 56
void BarUiActQuit(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActRenameStation
// file src/ui_act.h line 51
void BarUiActRenameStation(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActSelectQuickMix
// file src/ui_act.h line 55
void BarUiActSelectQuickMix(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActSelectStation
// file src/ui_act.h line 52
void BarUiActSelectStation(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActSkipSong
// file src/ui_act.h line 47
void BarUiActSkipSong(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActSongInfo
// file src/ui_act.h line 45
void BarUiActSongInfo(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActStationFromGenre
// file src/ui_act.h line 44
void BarUiActStationFromGenre(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActTempBanSong
// file src/ui_act.h line 53
void BarUiActTempBanSong(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActTogglePause
// file src/ui_act.h line 50
void BarUiActTogglePause(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActVolDown
// file src/ui_act.h line 60
void BarUiActVolDown(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActVolReset
// file src/ui_act.h line 63
void BarUiActVolReset(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiActVolUp
// file src/ui_act.h line 61
void BarUiActVolUp(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context);
// BarUiAppendNewline
// file src/ui.c line 598
static void BarUiAppendNewline(char *s, unsigned long int maxlen);
// BarUiCustomFormat
// file src/ui.c line 544
static void BarUiCustomFormat(char *dest, unsigned long int destSize, const char *format, const char *formatChars, const char **formatVals);
// BarUiDispatch
// file src/ui_dispatch.h line 112
enum anonymous$36 BarUiDispatch(struct anonymous$35 *app, const char key, struct PianoStation *selStation, struct PianoSong *selSong, const _Bool verbose, enum anonymous$28 context);
// BarUiDoSkipSong
// file src/ui_act.c line 49
static inline void BarUiDoSkipSong(struct anonymous$3 * const player);
// BarUiHistoryPrepend
// file src/ui.h line 56
void BarUiHistoryPrepend(struct anonymous$35 *app, struct PianoSong *song);
// BarUiListSongs
// file src/ui.h line 50
unsigned long int BarUiListSongs(const struct anonymous$33 *settings, const struct PianoSong *song, const char *filter);
// BarUiMsg
// file src/ui.h line 40
void BarUiMsg(const struct anonymous$33 *settings, const enum anonymous$34 type, const char *format, ...);
// BarUiPianoCall
// file src/ui.h line 54
signed int BarUiPianoCall(struct anonymous$35 * const app, enum anonymous$2 type, void *data, enum anonymous$4 *pRet, enum anonymous$5 *wRet);
// BarUiPrintSong
// file src/ui.h line 48
void BarUiPrintSong(const struct anonymous$33 *settings, const struct PianoSong *song, const struct PianoStation *station);
// BarUiPrintStation
// file src/ui.h line 47
void BarUiPrintStation(const struct anonymous$33 *settings, struct PianoStation *station);
// BarUiSelectArtist
// file src/ui.h line 45
struct PianoArtist * BarUiSelectArtist(struct anonymous$35 *app, struct PianoArtist *startArtist);
// BarUiSelectMusicId
// file src/ui.h line 46
char * BarUiSelectMusicId(struct anonymous$35 *app, struct PianoStation *station, const char *msg);
// BarUiSelectSong
// file src/ui.h line 43
struct PianoSong * BarUiSelectSong(const struct anonymous$33 *settings, struct PianoSong *startSong, struct anonymous$40 *input);
// BarUiSelectStation
// file src/ui.h line 41
struct PianoStation * BarUiSelectStation(struct anonymous$35 *app, struct PianoStation *stations, const char *prompt, void (*callback)(struct anonymous$35 *, char *), _Bool autoselect);
// BarUiSelectStation::callback$object
//
void callback$object(struct anonymous$35 *, char *);
// BarUiStartEventCmd
// file src/ui.h line 51
void BarUiStartEventCmd(const struct anonymous$33 *settings, const char *type, const struct PianoStation *curStation, const struct PianoSong *curSong, const struct anonymous$3 * const player, struct PianoStation *stations, enum anonymous$4 pRet, enum anonymous$5 wRet);
// PianoDecryptString
// file src/libpiano/crypt.c line 39
char * PianoDecryptString(struct gcry_cipher_handle *h, const char * const input, unsigned long int * const retSize);
// PianoDestroy
// file src/libpiano/piano.h line 333
void PianoDestroy(struct PianoHandle *ph);
// PianoDestroyArtists
// file src/libpiano/piano.c line 74
static void PianoDestroyArtists(struct PianoArtist *artists);
// PianoDestroyGenres
// file src/libpiano/piano.c line 158
static void PianoDestroyGenres(struct PianoGenre *genres);
// PianoDestroyPartner
// file src/libpiano/piano.c line 180
static void PianoDestroyPartner(struct PianoPartner *partner);
// PianoDestroyPlaylist
// file src/libpiano/piano.h line 334
void PianoDestroyPlaylist(struct PianoSong *playlist);
// PianoDestroyRequest
// file src/libpiano/piano.h line 342
void PianoDestroyRequest(struct PianoRequest *req);
// PianoDestroySearchResult
// file src/libpiano/piano.h line 335
void PianoDestroySearchResult(struct PianoSearchResult *searchResult);
// PianoDestroyStation
// file src/libpiano/piano.c line 100
void PianoDestroyStation(struct PianoStation *station);
// PianoDestroyStationInfo
// file src/libpiano/piano.h line 336
void PianoDestroyStationInfo(struct anonymous$50 *info);
// PianoDestroyStations
// file src/libpiano/piano.c line 110
static void PianoDestroyStations(struct PianoStation *stations);
// PianoDestroyUserInfo
// file src/libpiano/piano.c line 173
void PianoDestroyUserInfo(struct PianoUserInfo *user);
// PianoEncryptString
// file src/libpiano/crypt.c line 73
char * PianoEncryptString(struct gcry_cipher_handle *h, const char *s);
// PianoErrorToStr
// file src/libpiano/piano.h line 347
const char * PianoErrorToStr(enum anonymous$4 ret);
// PianoFindStationById
// file src/libpiano/piano.h line 345
struct PianoStation * PianoFindStationById(struct PianoStation * const stations, const char * const searchStation);
// PianoInit
// file src/libpiano/piano.h line 330
enum anonymous$4 PianoInit(struct PianoHandle *ph, const char *partnerUser, const char *partnerPassword, const char *device, const char *inkey, const char *outkey);
// PianoJsonParseStation
// file src/libpiano/response.c line 43
static void PianoJsonParseStation(struct json_object *j, struct PianoStation *s);
// PianoJsonStrdup
// file src/libpiano/response.c line 39
static char * PianoJsonStrdup(struct json_object *j, const char *key);
// PianoListAppend
// file src/libpiano/piano.h line 312
void * PianoListAppend(struct PianoListHead * const l, struct PianoListHead * const e);
// PianoListCount
// file src/libpiano/piano.h line 310
unsigned long int PianoListCount(const struct PianoListHead * const l);
// PianoListDelete
// file src/libpiano/piano.h line 316
void * PianoListDelete(struct PianoListHead * const l, struct PianoListHead * const e);
// PianoListGet
// file src/libpiano/piano.h line 325
void * PianoListGet(struct PianoListHead * const l, const unsigned long int n);
// PianoListPrepend
// file src/libpiano/piano.h line 321
void * PianoListPrepend(struct PianoListHead * const l, struct PianoListHead * const e);
// PianoRequest
// file src/libpiano/piano.h line 339
enum anonymous$4 PianoRequest(struct PianoHandle *ph, struct PianoRequest *req, enum anonymous$2 type);
// PianoResponse
// file src/libpiano/piano.h line 341
enum anonymous$4 PianoResponse(struct PianoHandle *ph, struct PianoRequest *req);
// PianoStrpcat
// file src/libpiano/response.c line 57
static void PianoStrpcat(char * restrict dest, const char * restrict src, unsigned long int len);
// WaitressBase64Encode
// file src/libwaitress/waitress.c line 127
static char * WaitressBase64Encode(const char *in);
// WaitressConnect
// file src/libwaitress/waitress.c line 772
static enum anonymous$5 WaitressConnect(struct anonymous$7 *waith);
// WaitressDefaultPort
// file src/libwaitress/waitress.c line 577
static const char * WaitressDefaultPort(const struct anonymous$16 * const url);
// WaitressErrorToStr
// file src/libwaitress/waitress.h line 133
const char * WaitressErrorToStr(enum anonymous$5 wRet);
// WaitressFetchBuf
// file src/libwaitress/waitress.h line 131
enum anonymous$5 WaitressFetchBuf(struct anonymous$7 *waith, char **retBuffer);
// WaitressFetchBufCb
// file src/libwaitress/waitress.c line 375
static enum anonymous$8 WaitressFetchBufCb(void *recvData, unsigned long int recvDataSize, void *extraData);
// WaitressFetchCall
// file src/libwaitress/waitress.c line 1099
enum anonymous$5 WaitressFetchCall(struct anonymous$7 *waith);
// WaitressFormatAuthorization
// file src/libwaitress/waitress.c line 552
static _Bool WaitressFormatAuthorization(struct anonymous$7 *waith, struct anonymous$16 *url, const char *prefix, char *writeBuf, const unsigned long int writeBufSize);
// WaitressFree
// file src/libwaitress/waitress.h line 127
void WaitressFree(struct anonymous$7 *waith);
// WaitressGetline
// file src/libwaitress/waitress.c line 591
static char * WaitressGetline(char * const str);
// WaitressGnutlsRead
// file src/libwaitress/waitress.c line 534
static enum anonymous$5 WaitressGnutlsRead(void *data, char *buf, const unsigned long int size, unsigned long int *retSize);
// WaitressGnutlsWrite
// file src/libwaitress/waitress.c line 481
static enum anonymous$5 WaitressGnutlsWrite(void *data, const char *buf, const unsigned long int size);
// WaitressHandleChunked
// file src/libwaitress/waitress.c line 633
static enum anonymous$12 WaitressHandleChunked(void *data, char *buf, const unsigned long int size);
// WaitressHandleHeader
// file src/libwaitress/waitress.c line 698
static void WaitressHandleHeader(struct anonymous$7 *waith, const char * const key, const char * const value);
// WaitressHandleIdentity
// file src/libwaitress/waitress.c line 616
static enum anonymous$12 WaitressHandleIdentity(void *data, char *buf, const unsigned long int size);
// WaitressInit
// file src/libwaitress/waitress.h line 126
void WaitressInit(struct anonymous$7 *waith);
// WaitressOrdinaryRead
// file src/libwaitress/waitress.c line 522
static enum anonymous$5 WaitressOrdinaryRead(void *data, char *buf, const unsigned long int size, unsigned long int *retSize);
// WaitressOrdinaryWrite
// file src/libwaitress/waitress.c line 473
static enum anonymous$5 WaitressOrdinaryWrite(void *data, const char *buf, const unsigned long int size);
// WaitressParseStatusline
// file src/libwaitress/waitress.c line 716
static signed int WaitressParseStatusline(const char * const line);
// WaitressPollLoop
// file src/libwaitress/waitress.c line 427
static signed int WaitressPollLoop(signed int fd, signed short int events, signed int timeout);
// WaitressPollRead
// file src/libwaitress/waitress.c line 497
static signed long int WaitressPollRead(void *data, void *buf, unsigned long int count);
// WaitressPollWrite
// file src/libwaitress/waitress.c line 447
static signed long int WaitressPollWrite(void *data, const void *buf, unsigned long int count);
// WaitressProxyEnabled
// file src/libwaitress/waitress.c line 89
static _Bool WaitressProxyEnabled(const struct anonymous$7 *waith);
// WaitressReceiveHeaders
// file src/libwaitress/waitress.c line 961
static enum anonymous$5 WaitressReceiveHeaders(struct anonymous$7 *waith, unsigned long int *retRemaining);
// WaitressReceiveResponse
// file src/libwaitress/waitress.c line 1051
static enum anonymous$5 WaitressReceiveResponse(struct anonymous$7 *waith);
// WaitressSendRequest
// file src/libwaitress/waitress.c line 893
static enum anonymous$5 WaitressSendRequest(struct anonymous$7 *waith);
// WaitressSetProxy
// file src/libwaitress/waitress.h line 128
_Bool WaitressSetProxy(struct anonymous$7 *waith, const char *url);
// WaitressSetUrl
// file src/libwaitress/waitress.c line 357
_Bool WaitressSetUrl(struct anonymous$7 *waith, const char *url);
// WaitressSplitUrl
// file src/libwaitress/waitress.c line 233
static _Bool WaitressSplitUrl(const char *inurl, struct anonymous$16 *retUrl);
// WaitressTlsVerify
// file src/libwaitress/waitress.c line 729
static enum anonymous$5 WaitressTlsVerify(const struct anonymous$7 *waith);
// WaitressUrlEncode
// file src/libwaitress/waitress.h line 129
char * WaitressUrlEncode(const char *in);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// ao_close
// file /usr/include/ao/ao.h line 122
signed int ao_close(struct ao_device *);
// ao_default_driver_id
// file /usr/include/ao/ao.h line 126
signed int ao_default_driver_id(void);
// ao_initialize
// file /usr/include/ao/ao.h line 100
void ao_initialize(void);
// ao_open_live
// file /usr/include/ao/ao.h line 110
struct ao_device * ao_open_live(signed int, struct ao_sample_format *, struct ao_option *);
// ao_play
// file /usr/include/ao/ao.h line 119
signed int ao_play(struct ao_device *, char *, unsigned int);
// ao_shutdown
// file /usr/include/ao/ao.h line 101
void ao_shutdown(void);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// atol
// file /usr/include/stdlib.h line 150
extern signed long int atol(const char *);
// av_buffersink_read
// file /usr/include/x86_64-linux-gnu/libavfilter/buffersink.h line 70
signed int av_buffersink_read(struct AVFilterContext *, struct AVFilterBufferRef **);
// av_buffersrc_write_frame
// file /usr/include/x86_64-linux-gnu/libavfilter/buffersrc.h line 118
signed int av_buffersrc_write_frame(struct AVFilterContext *, const struct AVFrame *);
// av_dict_set
// file /usr/include/x86_64-linux-gnu/libavutil/dict.h line 128
signed int av_dict_set(struct AVDictionary **, const char *, const char *, signed int);
// av_find_best_stream
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2149
signed int av_find_best_stream(struct AVFormatContext *, enum AVMediaType, signed int, signed int, struct AVCodec **, signed int);
// av_free_packet
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4108
void av_free_packet(struct AVPacket *);
// av_get_bytes_per_sample
// file /usr/include/x86_64-linux-gnu/libavutil/samplefmt.h line 139
signed int av_get_bytes_per_sample(enum AVSampleFormat);
// av_get_channel_layout_nb_channels
// file /usr/include/x86_64-linux-gnu/libavutil/channel_layout.h line 167
signed int av_get_channel_layout_nb_channels(unsigned long int);
// av_get_sample_fmt_name
// file /usr/include/x86_64-linux-gnu/libavutil/samplefmt.h line 80
const char * av_get_sample_fmt_name(enum AVSampleFormat);
// av_init_packet
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4040
void av_init_packet(struct AVPacket *);
// av_q2d
// file /usr/include/x86_64-linux-gnu/libavutil/rational.h line 80
static inline double av_q2d(struct AVRational a);
// av_read_frame
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2180
signed int av_read_frame(struct AVFormatContext *, struct AVPacket *);
// av_read_pause
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2257
signed int av_read_pause(struct AVFormatContext *);
// av_read_play
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2250
signed int av_read_play(struct AVFormatContext *);
// av_register_all
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1884
void av_register_all(void);
// av_seek_frame
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2195
signed int av_seek_frame(struct AVFormatContext *, signed int, signed long int, signed int);
// av_strerror
// file /usr/include/x86_64-linux-gnu/libavutil/error.h line 97
signed int av_strerror(signed int, char *, unsigned long int);
// avcodec_alloc_frame
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3927
struct AVFrame * avcodec_alloc_frame(void);
// avcodec_close
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4005
signed int avcodec_close(struct AVCodecContext *);
// avcodec_decode_audio4
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4446
signed int avcodec_decode_audio4(struct AVCodecContext *, struct AVFrame *, signed int *, const struct AVPacket *);
// avcodec_find_decoder
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 4256
struct AVCodec * avcodec_find_decoder(enum AVCodecID);
// avcodec_free_frame
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3952
void avcodec_free_frame(struct AVFrame **);
// avcodec_open2
// file /usr/include/x86_64-linux-gnu/libavcodec/avcodec.h line 3994
signed int avcodec_open2(struct AVCodecContext *, const struct AVCodec *, struct AVDictionary **);
// avfilter_copy_buf_props
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 1130
signed int avfilter_copy_buf_props(struct AVFrame *, const struct AVFilterBufferRef *);
// avfilter_get_by_name
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 1007
struct AVFilter * avfilter_get_by_name(const char *);
// avfilter_graph_alloc
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 1255
struct AVFilterGraph * avfilter_graph_alloc(void);
// avfilter_graph_config
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 1338
signed int avfilter_graph_config(struct AVFilterGraph *, void *);
// avfilter_graph_create_filter
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 1312
signed int avfilter_graph_create_filter(struct AVFilterContext **, const struct AVFilter *, const char *, const char *, void *, struct AVFilterGraph *);
// avfilter_graph_free
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 1344
void avfilter_graph_free(struct AVFilterGraph **);
// avfilter_graph_send_command
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 1487
signed int avfilter_graph_send_command(struct AVFilterGraph *, const char *, const char *, const char *, char *, signed int, signed int);
// avfilter_link
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 878
signed int avfilter_link(struct AVFilterContext *, unsigned int, struct AVFilterContext *, unsigned int);
// avfilter_register_all
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 977
void avfilter_register_all(void);
// avfilter_uninit
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 982
void avfilter_uninit(void);
// avfilter_unref_bufferp
// file /usr/include/x86_64-linux-gnu/libavfilter/avfilter.h line 236
void avfilter_unref_bufferp(struct AVFilterBufferRef **);
// avformat_close_input
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2263
void avformat_close_input(struct AVFormatContext **);
// avformat_find_stream_info
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2111
signed int avformat_find_stream_info(struct AVFormatContext *, struct AVDictionary **);
// avformat_network_deinit
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1902
signed int avformat_network_deinit(void);
// avformat_network_init
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 1897
signed int avformat_network_init(void);
// avformat_open_input
// file /usr/include/x86_64-linux-gnu/libavformat/avformat.h line 2085
signed int avformat_open_input(struct AVFormatContext **, const char *, struct AVInputFormat *, struct AVDictionary **);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// execl
// file /usr/include/unistd.h line 573
extern signed int execl(const char *, const char *, ...);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// finish
// file src/player.c line 391
static void finish(struct anonymous$3 * const player);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// fscanf
// file /usr/include/stdio.h line 425
extern signed int fscanf(struct _IO_FILE *, const char *, ...);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 214
extern signed int fstat(signed int, struct stat *);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// gcry_check_version
// file /usr/include/gcrypt.h line 258
const char * gcry_check_version(const char *);
// gcry_cipher_close
// file /usr/include/gcrypt.h line 928
void gcry_cipher_close(struct gcry_cipher_handle *);
// gcry_cipher_decrypt
// file /usr/include/gcrypt.h line 965
unsigned int gcry_cipher_decrypt(struct gcry_cipher_handle *, void *, unsigned long int, const void *, unsigned long int);
// gcry_cipher_encrypt
// file /usr/include/gcrypt.h line 960
unsigned int gcry_cipher_encrypt(struct gcry_cipher_handle *, void *, unsigned long int, const void *, unsigned long int);
// gcry_cipher_open
// file /usr/include/gcrypt.h line 924
unsigned int gcry_cipher_open(struct gcry_cipher_handle **, signed int, signed int, unsigned int);
// gcry_cipher_setkey
// file /usr/include/gcrypt.h line 970
unsigned int gcry_cipher_setkey(struct gcry_cipher_handle *, const void *, unsigned long int);
// gcry_control
// file /usr/include/gcrypt.h line 334
unsigned int gcry_control(enum gcry_ctl_cmds, ...);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getpwuid
// file /usr/include/pwd.h line 110
extern struct passwd * getpwuid(unsigned int);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// gnutls_bye
// file /usr/include/gnutls/gnutls.h line 791
signed int gnutls_bye(struct gnutls_session_int *, enum anonymous$23);
// gnutls_certificate_allocate_credentials
// file /usr/include/gnutls/gnutls.h line 1326
signed int gnutls_certificate_allocate_credentials(struct gnutls_certificate_credentials_st **);
// gnutls_certificate_free_credentials
// file /usr/include/gnutls/gnutls.h line 1324
void gnutls_certificate_free_credentials(struct gnutls_certificate_credentials_st *);
// gnutls_certificate_get_peers
// file /usr/include/gnutls/gnutls.h line 1918
const struct anonymous$11 * gnutls_certificate_get_peers(struct gnutls_session_int *, unsigned int *);
// gnutls_certificate_type_get
// file /usr/include/gnutls/gnutls.h line 828
enum anonymous$10 gnutls_certificate_type_get(struct gnutls_session_int *);
// gnutls_credentials_set
// file /usr/include/gnutls/gnutls.h line 1256
signed int gnutls_credentials_set(struct gnutls_session_int *, enum anonymous$19, void *);
// gnutls_deinit
// file /usr/include/gnutls/gnutls.h line 788
void gnutls_deinit(struct gnutls_session_int *);
// gnutls_global_deinit
// file /usr/include/gnutls/gnutls.h line 1458
void gnutls_global_deinit(void);
// gnutls_global_init
// file /usr/include/gnutls/gnutls.h line 1457
signed int gnutls_global_init(void);
// gnutls_handshake
// file /usr/include/gnutls/gnutls.h line 793
signed int gnutls_handshake(struct gnutls_session_int *);
// gnutls_init
// file /usr/include/gnutls/gnutls.h line 787
signed int gnutls_init(struct gnutls_session_int **, unsigned int);
// gnutls_record_recv
// file /usr/include/gnutls/gnutls.h line 940
signed long int gnutls_record_recv(struct gnutls_session_int *, void *, unsigned long int);
// gnutls_record_send
// file /usr/include/gnutls/gnutls.h line 935
signed long int gnutls_record_send(struct gnutls_session_int *, const void *, unsigned long int);
// gnutls_server_name_set
// file /usr/include/gnutls/gnutls.h line 1002
signed int gnutls_server_name_set(struct gnutls_session_int *, enum anonymous$25, const void *, unsigned long int);
// gnutls_set_default_priority
// file /usr/include/gnutls/gnutls.h line 1133
signed int gnutls_set_default_priority(struct gnutls_session_int *);
// gnutls_transport_set_ptr
// file /usr/include/gnutls/gnutls.h line 1561
void gnutls_transport_set_ptr(struct gnutls_session_int *, void *);
// gnutls_transport_set_pull_function
// file /usr/include/gnutls/gnutls.h line 1576
void gnutls_transport_set_pull_function(struct gnutls_session_int *, signed long int (*)(void *, void *, unsigned long int));
// gnutls_transport_set_push_function
// file /usr/include/gnutls/gnutls.h line 1574
void gnutls_transport_set_push_function(struct gnutls_session_int *, signed long int (*)(void *, const void *, unsigned long int));
// gnutls_x509_crt_deinit
// file /usr/include/gnutls/x509.h line 124
void gnutls_x509_crt_deinit(struct gnutls_x509_crt_int *);
// gnutls_x509_crt_get_fingerprint
// file /usr/include/gnutls/x509.h line 899
signed int gnutls_x509_crt_get_fingerprint(struct gnutls_x509_crt_int *, enum anonymous$21, void *, unsigned long int *);
// gnutls_x509_crt_import
// file /usr/include/gnutls/x509.h line 125
signed int gnutls_x509_crt_import(struct gnutls_x509_crt_int *, const struct anonymous$11 *, enum anonymous$20);
// gnutls_x509_crt_init
// file /usr/include/gnutls/x509.h line 123
signed int gnutls_x509_crt_init(struct gnutls_x509_crt_int **);
// isnumeric
// file src/ui.c line 53
static _Bool isnumeric(const char *s);
// json_object_array_add
// file /usr/include/json-c/json_object.h line 395
extern signed int json_object_array_add(struct json_object *, struct json_object *);
// json_object_array_get_idx
// file /usr/include/json-c/json_object.h line 421
extern struct json_object * json_object_array_get_idx(struct json_object *, signed int);
// json_object_array_length
// file /usr/include/json-c/json_object.h line 374
extern signed int json_object_array_length(struct json_object *);
// json_object_get_boolean
// file /usr/include/json-c/json_object.h line 443
extern signed int json_object_get_boolean(struct json_object *);
// json_object_get_double
// file /usr/include/json-c/json_object.h line 527
extern double json_object_get_double(struct json_object *);
// json_object_get_int
// file /usr/include/json-c/json_object.h line 478
extern signed int json_object_get_int(struct json_object *);
// json_object_get_string
// file /usr/include/json-c/json_object.h line 554
extern const char * json_object_get_string(struct json_object *);
// json_object_is_type
// file /usr/include/json-c/json_object.h line 143
extern signed int json_object_is_type(struct json_object *, enum json_type);
// json_object_new_array
// file /usr/include/json-c/json_object.h line 362
extern struct json_object * json_object_new_array(void);
// json_object_new_boolean
// file /usr/include/json-c/json_object.h line 430
extern struct json_object * json_object_new_boolean(signed int);
// json_object_new_int
// file /usr/include/json-c/json_object.h line 454
extern struct json_object * json_object_new_int(signed int);
// json_object_new_object
// file /usr/include/json-c/json_object.h line 222
extern struct json_object * json_object_new_object(void);
// json_object_new_string
// file /usr/include/json-c/json_object.h line 539
extern struct json_object * json_object_new_string(const char *);
// json_object_object_add
// file /usr/include/json-c/json_object.h line 251
extern void json_object_object_add(struct json_object *, const char *, struct json_object *);
// json_object_object_get
// file /usr/include/json-c/json_object.h line 271
extern struct json_object * json_object_object_get(struct json_object *, const char *);
// json_object_put
// file /usr/include/json-c/json_object.h line 129
signed int json_object_put(struct json_object *);
// json_object_to_json_string
// file /usr/include/json-c/json_object.h line 167
extern const char * json_object_to_json_string(struct json_object *);
// json_tokener_parse
// file /usr/include/json-c/json_tokener.h line 132
extern struct json_object * json_tokener_parse(const char *);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// openDevice
// file src/player.c line 271
static _Bool openDevice(struct anonymous$3 * const player);
// openFilter
// file src/player.c line 207
static _Bool openFilter(struct anonymous$3 * const player);
// openStream
// file src/player.c line 133
static _Bool openStream(struct anonymous$3 * const player);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// play
// file src/player.c line 293
static signed int play(struct anonymous$3 * const player);
// poll
// file /usr/include/x86_64-linux-gnu/sys/poll.h line 57
extern signed int poll(struct pollfd *, unsigned long int, signed int);
// printError
// file src/player.c line 59
static void printError(const struct anonymous$33 * const settings, const char * const msg, signed int ret);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 992
extern signed int pthread_cond_broadcast(union anonymous$18 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 984
extern signed int pthread_cond_destroy(union anonymous$18 *);
// pthread_cond_init
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_init(union anonymous$18 *, const union anonymous$0 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 1000
extern signed int pthread_cond_wait(union anonymous$18 *, union anonymous *);
// pthread_create
// file /usr/include/pthread.h line 244
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 261
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 765
extern signed int pthread_mutex_destroy(union anonymous *);
// pthread_mutex_init
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_init(union anonymous *, const union anonymous$0 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 773
extern signed int pthread_mutex_lock(union anonymous *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 784
extern signed int pthread_mutex_unlock(union anonymous *);
// putchar
// file /usr/include/stdio.h line 580
extern signed int putchar(signed int);
// puts
// file /usr/include/stdio.h line 695
extern signed int puts(const char *);
// qsort
// file /usr/include/stdlib.h line 765
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$47 *, struct anonymous$47 *, struct anonymous$47 *, struct timeval *);
// setenv
// file /usr/include/stdlib.h line 584
extern signed int setenv(const char *, const char *, signed int);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// strcasecmp
// file /usr/include/string.h line 534
extern signed int strcasecmp(const char *, const char *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 236
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 176
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 413
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 399
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strstr
// file /usr/include/string.h line 342
extern char * strstr(const char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// tcgetattr
// file /usr/include/termios.h line 66
extern signed int tcgetattr(signed int, struct termios *);
// tcsetattr
// file /usr/include/termios.h line 70
extern signed int tcsetattr(signed int, signed int, struct termios *);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// vprintf
// file /usr/include/stdio.h line 377
extern signed int vprintf(const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous$9
{
  // data
  char *data;
  // pos
  unsigned long int pos;
};

struct anonymous$39
{
  // prefix
  char *prefix;
  // postfix
  char *postfix;
};

struct PianoSearchResult
{
  // songs
  struct PianoSong *songs;
  // artists
  struct PianoArtist *artists;
};

struct anonymous$55
{
  // searchStr
  char *searchStr;
  // searchResult
  struct PianoSearchResult searchResult;
};

struct anonymous$56
{
  // stationId
  char *stationId;
  // trackToken
  char *trackToken;
  // rating
  enum anonymous$29 rating;
};

struct anonymous$44
{
  // token
  char *token;
  // type
  enum anonymous$43 type;
};

struct anonymous$16
{
  // url
  char *url;
  // tls
  _Bool tls;
  // user
  const char *user;
  // password
  const char *password;
  // host
  const char *host;
  // port
  const char *port;
  // tlsPort
  const char *tlsPort;
  // path
  const char *path;
};

struct anonymous$13
{
  // user
  char *user;
  // password
  char *password;
  // step
  unsigned char step;
};

struct anonymous$42
{
  // song
  struct PianoSong *song;
  // retExplain
  char *retExplain;
};

struct anonymous$52
{
  // song
  struct PianoSong *song;
  // artist
  struct PianoArtist *artist;
  // station
  struct PianoStation *station;
};

struct anonymous$48
{
  // song
  struct PianoSong *song;
  // rating
  enum anonymous$29 rating;
};

struct anonymous$50
{
  // songSeeds
  struct PianoSong *songSeeds;
  // artistSeeds
  struct PianoArtist *artistSeeds;
  // stationSeeds
  struct PianoStation *stationSeeds;
  // feedback
  struct PianoSong *feedback;
};

struct anonymous$54
{
  // station
  struct PianoStation *station;
  // musicId
  char *musicId;
};

struct anonymous$49
{
  // station
  struct PianoStation *station;
  // newName
  char *newName;
};

struct anonymous$14
{
  // station
  struct PianoStation *station;
  // quality
  enum anonymous$1 quality;
  // retPlaylist
  struct PianoSong *retPlaylist;
};

struct anonymous$51
{
  // station
  struct PianoStation *station;
  // info
  struct anonymous$50 info;
};

struct anonymous$11
{
  // data
  unsigned char *data;
  // size
  unsigned int size;
};

struct anonymous$47
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous$33
{
  // autoselect
  _Bool autoselect;
  // history
  unsigned int history;
  // maxPlayerErrors
  unsigned int maxPlayerErrors;
  // volume
  signed int volume;
  // sortOrder
  enum anonymous$38 sortOrder;
  // audioQuality
  enum anonymous$1 audioQuality;
  // username
  char *username;
  // password
  char *password;
  // passwordCmd
  char *passwordCmd;
  // controlProxy
  char *controlProxy;
  // proxy
  char *proxy;
  // autostartStation
  char *autostartStation;
  // eventCmd
  char *eventCmd;
  // loveIcon
  char *loveIcon;
  // banIcon
  char *banIcon;
  // atIcon
  char *atIcon;
  // npSongFormat
  char *npSongFormat;
  // npStationFormat
  char *npStationFormat;
  // listSongFormat
  char *listSongFormat;
  // fifo
  char *fifo;
  // rpcHost
  char *rpcHost;
  // rpcTlsPort
  char *rpcTlsPort;
  // partnerUser
  char *partnerUser;
  // partnerPassword
  char *partnerPassword;
  // device
  char *device;
  // inkey
  char *inkey;
  // outkey
  char *outkey;
  // tlsFingerprint
  char tlsFingerprint[20l];
  // keys
  char keys[29l];
  // msgFormat
  struct anonymous$39 msgFormat[7l];
};

struct anonymous$17
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$15
{
  // sockfd
  signed int sockfd;
  // readWriteRet
  enum anonymous$5 readWriteRet;
  // contentLength
  unsigned long int contentLength;
  // contentReceived
  unsigned long int contentReceived;
  // chunkSize
  unsigned long int chunkSize;
  // contentLengthKnown
  _Bool contentLengthKnown;
  // chunkedState
  enum anonymous$46 chunkedState;
  // buf
  char *buf;
  // dataHandler
  enum anonymous$12 (*dataHandler)(void *, char *, const unsigned long int);
  // read
  enum anonymous$5 (*read)(void *, char *, const unsigned long int, unsigned long int *);
  // write
  enum anonymous$5 (*write)(void *, const char *, const unsigned long int);
  // tlsSession
  struct gnutls_session_int *tlsSession;
};

struct anonymous$7
{
  // timeout
  signed int timeout;
  // method
  enum anonymous$22 method;
  // extraHeaders
  const char *extraHeaders;
  // postData
  const char *postData;
  // data
  void *data;
  // callback
  enum anonymous$8 (*callback)(void *, unsigned long int, void *);
  // tlsFingerprint
  const char *tlsFingerprint;
  // url
  struct anonymous$16 url;
  // proxy
  struct anonymous$16 proxy;
  // tlsCred
  struct gnutls_certificate_credentials_st *tlsCred;
  // request
  struct anonymous$15 request;
};

struct anonymous$6
{
  // last_dts
  signed long int last_dts;
  // duration_gcd
  signed long int duration_gcd;
  // duration_count
  signed int duration_count;
  // rfps_duration_sum
  signed long int rfps_duration_sum;
  // duration_error
  double (*duration_error)[2l][373l];
  // codec_info_duration
  signed long int codec_info_duration;
  // codec_info_duration_fields
  signed long int codec_info_duration_fields;
  // found_decoder
  signed int found_decoder;
  // last_duration
  signed long int last_duration;
  // fps_first_dts
  signed long int fps_first_dts;
  // fps_first_dts_idx
  signed int fps_first_dts_idx;
  // fps_last_dts
  signed long int fps_last_dts;
  // fps_last_dts_idx
  signed int fps_last_dts_idx;
};

struct anonymous$31
{
  // defaultKey
  char defaultKey;
  // context
  enum anonymous$28 context;
  // function
  void (*function)(struct anonymous$35 *, struct PianoStation *, struct PianoSong *, enum anonymous$28);
  // helpText
  const char * const helpText;
  // configKey
  const char * const configKey;
};

struct anonymous$40
{
  // set
  struct anonymous$47 set;
  // maxfd
  signed int maxfd;
  // fds
  signed int fds[2l];
};

struct PianoUserInfo
{
  // listenerId
  char *listenerId;
  // authToken
  char *authToken;
};

struct PianoPartner
{
  // in
  struct gcry_cipher_handle *in;
  // out
  struct gcry_cipher_handle *out;
  // authToken
  char *authToken;
  // device
  char *device;
  // user
  char *user;
  // password
  char *password;
  // id
  unsigned int id;
};

struct PianoHandle
{
  // user
  struct PianoUserInfo user;
  // stations
  struct PianoStation *stations;
  // genreStations
  struct PianoGenreCategory *genreStations;
  // partner
  struct PianoPartner partner;
  // timeOffset
  signed int timeOffset;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous$18
{
  // __data
  struct anonymous$17 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct anonymous$3
{
  // doQuit
  volatile _Bool doQuit;
  // doPause
  volatile _Bool doPause;
  // pauseMutex
  union anonymous pauseMutex;
  // pauseCond
  union anonymous$18 pauseCond;
  // mode
  enum anonymous$41 mode;
  // fvolume
  struct AVFilterContext *fvolume;
  // fgraph
  struct AVFilterGraph *fgraph;
  // fctx
  struct AVFormatContext *fctx;
  // st
  struct AVStream *st;
  // fbufsink
  struct AVFilterContext *fbufsink;
  // fabuf
  struct AVFilterContext *fabuf;
  // streamIdx
  signed int streamIdx;
  // lastTimestamp
  signed long int lastTimestamp;
  // aoDev
  struct ao_device *aoDev;
  // volume
  volatile double volume;
  // gain
  double gain;
  // url
  char *url;
  // settings
  const struct anonymous$33 *settings;
  // songDuration
  volatile unsigned int songDuration;
  // songPlayed
  volatile unsigned int songPlayed;
};

struct anonymous$35
{
  // ph
  struct PianoHandle ph;
  // waith
  struct anonymous$7 waith;
  // player
  struct anonymous$3 player;
  // settings
  struct anonymous$33 settings;
  // playlist
  struct PianoSong *playlist;
  // songHistory
  struct PianoSong *songHistory;
  // curStation
  struct PianoStation *curStation;
  // doQuit
  char doQuit;
  // input
  struct anonymous$40 input;
  // playerErrors
  unsigned int playerErrors;
};

union anonymous$0
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct AVRational
{
  // num
  signed int num;
  // den
  signed int den;
};

union anonymous$24
{
  // i64
  signed long int i64;
  // dbl
  double dbl;
  // str
  const char *str;
  // q
  struct AVRational q;
};

struct AVBufferRef
{
  // buffer
  struct AVBuffer *buffer;
  // data
  unsigned char *data;
  // size
  signed int size;
};

struct AVChapter
{
  // id
  signed int id;
  // time_base
  struct AVRational time_base;
  // start
  signed long int start;
  // end
  signed long int end;
  // metadata
  struct AVDictionary *metadata;
};

struct AVClass
{
  // class_name
  const char *class_name;
  // item_name
  const char * (*item_name)(void *);
  // option
  struct AVOption *option;
  // version
  signed int version;
  // log_level_offset_offset
  signed int log_level_offset_offset;
  // parent_log_context_offset
  signed int parent_log_context_offset;
  // child_next
  void * (*child_next)(void *, void *);
  // child_class_next
  struct AVClass * (*child_class_next)(struct AVClass *);
  // category
  enum anonymous$32 category;
  // get_category
  enum anonymous$32 (*get_category)(void *);
  // query_ranges
  signed int (*query_ranges)(struct AVOptionRanges **, void *, const char *, signed int);
};

struct AVCodec
{
  // name
  const char *name;
  // long_name
  const char *long_name;
  // type
  enum AVMediaType type;
  // id
  enum AVCodecID id;
  // capabilities
  signed int capabilities;
  // supported_framerates
  const struct AVRational *supported_framerates;
  // pix_fmts
  const enum AVPixelFormat *pix_fmts;
  // supported_samplerates
  const signed int *supported_samplerates;
  // sample_fmts
  const enum AVSampleFormat *sample_fmts;
  // channel_layouts
  const unsigned long int *channel_layouts;
  // max_lowres
  unsigned char max_lowres;
  // priv_class
  const struct AVClass *priv_class;
  // profiles
  const struct AVProfile *profiles;
  // priv_data_size
  signed int priv_data_size;
  // next
  struct AVCodec *next;
  // init_thread_copy
  signed int (*init_thread_copy)(struct AVCodecContext *);
  // update_thread_context
  signed int (*update_thread_context)(struct AVCodecContext *, const struct AVCodecContext *);
  // defaults
  const struct AVCodecDefault *defaults;
  // init_static_data
  void (*init_static_data)(struct AVCodec *);
  // init
  signed int (*init)(struct AVCodecContext *);
  // encode_sub
  signed int (*encode_sub)(struct AVCodecContext *, unsigned char *, signed int, struct AVSubtitle *);
  // encode2
  signed int (*encode2)(struct AVCodecContext *, struct AVPacket *, const struct AVFrame *, signed int *);
  // decode
  signed int (*decode)(struct AVCodecContext *, void *, signed int *, struct AVPacket *);
  // close
  signed int (*close)(struct AVCodecContext *);
  // flush
  void (*flush)(struct AVCodecContext *);
  // caps_internal
  signed int caps_internal;
};

struct AVCodecContext
{
  // av_class
  const struct AVClass *av_class;
  // log_level_offset
  signed int log_level_offset;
  // codec_type
  enum AVMediaType codec_type;
  // codec
  struct AVCodec *codec;
  // codec_name
  char codec_name[32l];
  // codec_id
  enum AVCodecID codec_id;
  // codec_tag
  unsigned int codec_tag;
  // stream_codec_tag
  unsigned int stream_codec_tag;
  // priv_data
  void *priv_data;
  // internal
  struct AVCodecInternal *internal;
  // opaque
  void *opaque;
  // bit_rate
  signed int bit_rate;
  // bit_rate_tolerance
  signed int bit_rate_tolerance;
  // global_quality
  signed int global_quality;
  // compression_level
  signed int compression_level;
  // flags
  signed int flags;
  // flags2
  signed int flags2;
  // extradata
  unsigned char *extradata;
  // extradata_size
  signed int extradata_size;
  // time_base
  struct AVRational time_base;
  // ticks_per_frame
  signed int ticks_per_frame;
  // delay
  signed int delay;
  // width
  signed int width;
  // height
  signed int height;
  // coded_width
  signed int coded_width;
  // coded_height
  signed int coded_height;
  // gop_size
  signed int gop_size;
  // pix_fmt
  enum AVPixelFormat pix_fmt;
  // me_method
  signed int me_method;
  // draw_horiz_band
  void (*draw_horiz_band)(struct AVCodecContext *, const struct AVFrame *, signed int *, signed int, signed int, signed int);
  // get_format
  enum AVPixelFormat (*get_format)(struct AVCodecContext *, const enum AVPixelFormat *);
  // max_b_frames
  signed int max_b_frames;
  // b_quant_factor
  float b_quant_factor;
  // rc_strategy
  signed int rc_strategy;
  // b_frame_strategy
  signed int b_frame_strategy;
  // b_quant_offset
  float b_quant_offset;
  // has_b_frames
  signed int has_b_frames;
  // mpeg_quant
  signed int mpeg_quant;
  // i_quant_factor
  float i_quant_factor;
  // i_quant_offset
  float i_quant_offset;
  // lumi_masking
  float lumi_masking;
  // temporal_cplx_masking
  float temporal_cplx_masking;
  // spatial_cplx_masking
  float spatial_cplx_masking;
  // p_masking
  float p_masking;
  // dark_masking
  float dark_masking;
  // slice_count
  signed int slice_count;
  // prediction_method
  signed int prediction_method;
  // slice_offset
  signed int *slice_offset;
  // sample_aspect_ratio
  struct AVRational sample_aspect_ratio;
  // me_cmp
  signed int me_cmp;
  // me_sub_cmp
  signed int me_sub_cmp;
  // mb_cmp
  signed int mb_cmp;
  // ildct_cmp
  signed int ildct_cmp;
  // dia_size
  signed int dia_size;
  // last_predictor_count
  signed int last_predictor_count;
  // pre_me
  signed int pre_me;
  // me_pre_cmp
  signed int me_pre_cmp;
  // pre_dia_size
  signed int pre_dia_size;
  // me_subpel_quality
  signed int me_subpel_quality;
  // dtg_active_format
  signed int dtg_active_format;
  // me_range
  signed int me_range;
  // intra_quant_bias
  signed int intra_quant_bias;
  // inter_quant_bias
  signed int inter_quant_bias;
  // slice_flags
  signed int slice_flags;
  // xvmc_acceleration
  signed int xvmc_acceleration;
  // mb_decision
  signed int mb_decision;
  // intra_matrix
  unsigned short int *intra_matrix;
  // inter_matrix
  unsigned short int *inter_matrix;
  // scenechange_threshold
  signed int scenechange_threshold;
  // noise_reduction
  signed int noise_reduction;
  // me_threshold
  signed int me_threshold;
  // mb_threshold
  signed int mb_threshold;
  // intra_dc_precision
  signed int intra_dc_precision;
  // skip_top
  signed int skip_top;
  // skip_bottom
  signed int skip_bottom;
  // border_masking
  float border_masking;
  // mb_lmin
  signed int mb_lmin;
  // mb_lmax
  signed int mb_lmax;
  // me_penalty_compensation
  signed int me_penalty_compensation;
  // bidir_refine
  signed int bidir_refine;
  // brd_scale
  signed int brd_scale;
  // keyint_min
  signed int keyint_min;
  // refs
  signed int refs;
  // chromaoffset
  signed int chromaoffset;
  // scenechange_factor
  signed int scenechange_factor;
  // mv0_threshold
  signed int mv0_threshold;
  // b_sensitivity
  signed int b_sensitivity;
  // color_primaries
  enum AVColorPrimaries color_primaries;
  // color_trc
  enum AVColorTransferCharacteristic color_trc;
  // colorspace
  enum AVColorSpace colorspace;
  // color_range
  enum AVColorRange color_range;
  // chroma_sample_location
  enum AVChromaLocation chroma_sample_location;
  // slices
  signed int slices;
  // field_order
  enum AVFieldOrder field_order;
  // sample_rate
  signed int sample_rate;
  // channels
  signed int channels;
  // sample_fmt
  enum AVSampleFormat sample_fmt;
  // frame_size
  signed int frame_size;
  // frame_number
  signed int frame_number;
  // block_align
  signed int block_align;
  // cutoff
  signed int cutoff;
  // request_channels
  signed int request_channels;
  // channel_layout
  unsigned long int channel_layout;
  // request_channel_layout
  unsigned long int request_channel_layout;
  // audio_service_type
  enum AVAudioServiceType audio_service_type;
  // request_sample_fmt
  enum AVSampleFormat request_sample_fmt;
  // get_buffer
  signed int (*get_buffer)(struct AVCodecContext *, struct AVFrame *);
  // release_buffer
  void (*release_buffer)(struct AVCodecContext *, struct AVFrame *);
  // reget_buffer
  signed int (*reget_buffer)(struct AVCodecContext *, struct AVFrame *);
  // get_buffer2
  signed int (*get_buffer2)(struct AVCodecContext *, struct AVFrame *, signed int);
  // refcounted_frames
  signed int refcounted_frames;
  // qcompress
  float qcompress;
  // qblur
  float qblur;
  // qmin
  signed int qmin;
  // qmax
  signed int qmax;
  // max_qdiff
  signed int max_qdiff;
  // rc_qsquish
  float rc_qsquish;
  // rc_qmod_amp
  float rc_qmod_amp;
  // rc_qmod_freq
  signed int rc_qmod_freq;
  // rc_buffer_size
  signed int rc_buffer_size;
  // rc_override_count
  signed int rc_override_count;
  // rc_override
  struct RcOverride *rc_override;
  // rc_eq
  const char *rc_eq;
  // rc_max_rate
  signed int rc_max_rate;
  // rc_min_rate
  signed int rc_min_rate;
  // rc_buffer_aggressivity
  float rc_buffer_aggressivity;
  // rc_initial_cplx
  float rc_initial_cplx;
  // rc_max_available_vbv_use
  float rc_max_available_vbv_use;
  // rc_min_vbv_overflow_use
  float rc_min_vbv_overflow_use;
  // rc_initial_buffer_occupancy
  signed int rc_initial_buffer_occupancy;
  // coder_type
  signed int coder_type;
  // context_model
  signed int context_model;
  // lmin
  signed int lmin;
  // lmax
  signed int lmax;
  // frame_skip_threshold
  signed int frame_skip_threshold;
  // frame_skip_factor
  signed int frame_skip_factor;
  // frame_skip_exp
  signed int frame_skip_exp;
  // frame_skip_cmp
  signed int frame_skip_cmp;
  // trellis
  signed int trellis;
  // min_prediction_order
  signed int min_prediction_order;
  // max_prediction_order
  signed int max_prediction_order;
  // timecode_frame_start
  signed long int timecode_frame_start;
  // rtp_callback
  void (*rtp_callback)(struct AVCodecContext *, void *, signed int, signed int);
  // rtp_payload_size
  signed int rtp_payload_size;
  // mv_bits
  signed int mv_bits;
  // header_bits
  signed int header_bits;
  // i_tex_bits
  signed int i_tex_bits;
  // p_tex_bits
  signed int p_tex_bits;
  // i_count
  signed int i_count;
  // p_count
  signed int p_count;
  // skip_count
  signed int skip_count;
  // misc_bits
  signed int misc_bits;
  // frame_bits
  signed int frame_bits;
  // stats_out
  char *stats_out;
  // stats_in
  char *stats_in;
  // workaround_bugs
  signed int workaround_bugs;
  // strict_std_compliance
  signed int strict_std_compliance;
  // error_concealment
  signed int error_concealment;
  // debug
  signed int debug;
  // debug_mv
  signed int debug_mv;
  // err_recognition
  signed int err_recognition;
  // reordered_opaque
  signed long int reordered_opaque;
  // hwaccel
  struct AVHWAccel *hwaccel;
  // hwaccel_context
  void *hwaccel_context;
  // error
  unsigned long int error[8l];
  // dct_algo
  signed int dct_algo;
  // idct_algo
  signed int idct_algo;
  // bits_per_coded_sample
  signed int bits_per_coded_sample;
  // bits_per_raw_sample
  signed int bits_per_raw_sample;
  // lowres
  signed int lowres;
  // coded_frame
  struct AVFrame *coded_frame;
  // thread_count
  signed int thread_count;
  // thread_type
  signed int thread_type;
  // active_thread_type
  signed int active_thread_type;
  // thread_safe_callbacks
  signed int thread_safe_callbacks;
  // execute
  signed int (*execute)(struct AVCodecContext *, signed int (*)(struct AVCodecContext *, void *), void *, signed int *, signed int, signed int);
  // execute2
  signed int (*execute2)(struct AVCodecContext *, signed int (*)(struct AVCodecContext *, void *, signed int, signed int), void *, signed int *, signed int);
  // thread_opaque
  void *thread_opaque;
  // nsse_weight
  signed int nsse_weight;
  // profile
  signed int profile;
  // level
  signed int level;
  // skip_loop_filter
  enum AVDiscard skip_loop_filter;
  // skip_idct
  enum AVDiscard skip_idct;
  // skip_frame
  enum AVDiscard skip_frame;
  // subtitle_header
  unsigned char *subtitle_header;
  // subtitle_header_size
  signed int subtitle_header_size;
  // error_rate
  signed int error_rate;
  // pkt
  struct AVPacket *pkt;
  // vbv_delay
  unsigned long int vbv_delay;
  // side_data_only_packets
  signed int side_data_only_packets;
  // initial_padding
  signed int initial_padding;
  // framerate
  struct AVRational framerate;
  // sw_pix_fmt
  enum AVPixelFormat sw_pix_fmt;
  // pkt_timebase
  struct AVRational pkt_timebase;
  // codec_descriptor
  const struct AVCodecDescriptor *codec_descriptor;
  // pts_correction_num_faulty_pts
  signed long int pts_correction_num_faulty_pts;
  // pts_correction_num_faulty_dts
  signed long int pts_correction_num_faulty_dts;
  // pts_correction_last_pts
  signed long int pts_correction_last_pts;
  // pts_correction_last_dts
  signed long int pts_correction_last_dts;
  // sub_charenc
  char *sub_charenc;
  // sub_charenc_mode
  signed int sub_charenc_mode;
  // skip_alpha
  signed int skip_alpha;
  // seek_preroll
  signed int seek_preroll;
  // chroma_intra_matrix
  unsigned short int *chroma_intra_matrix;
  // dump_separator
  unsigned char *dump_separator;
  // codec_whitelist
  char *codec_whitelist;
  // properties
  unsigned int properties;
};

struct AVCodecDescriptor
{
  // id
  enum AVCodecID id;
  // type
  enum AVMediaType type;
  // name
  const char *name;
  // long_name
  const char *long_name;
  // props
  signed int props;
  // mime_types
  const char * const *mime_types;
};

struct AVCodecParser
{
  // codec_ids
  signed int codec_ids[5l];
  // priv_data_size
  signed int priv_data_size;
  // parser_init
  signed int (*parser_init)(struct AVCodecParserContext *);
  // parser_parse
  signed int (*parser_parse)(struct AVCodecParserContext *, struct AVCodecContext *, const unsigned char **, signed int *, const unsigned char *, signed int);
  // parser_close
  void (*parser_close)(struct AVCodecParserContext *);
  // split
  signed int (*split)(struct AVCodecContext *, const unsigned char *, signed int);
  // next
  struct AVCodecParser *next;
};

struct AVCodecParserContext
{
  // priv_data
  void *priv_data;
  // parser
  struct AVCodecParser *parser;
  // frame_offset
  signed long int frame_offset;
  // cur_offset
  signed long int cur_offset;
  // next_frame_offset
  signed long int next_frame_offset;
  // pict_type
  signed int pict_type;
  // repeat_pict
  signed int repeat_pict;
  // pts
  signed long int pts;
  // dts
  signed long int dts;
  // last_pts
  signed long int last_pts;
  // last_dts
  signed long int last_dts;
  // fetch_timestamp
  signed int fetch_timestamp;
  // cur_frame_start_index
  signed int cur_frame_start_index;
  // cur_frame_offset
  signed long int cur_frame_offset[4l];
  // cur_frame_pts
  signed long int cur_frame_pts[4l];
  // cur_frame_dts
  signed long int cur_frame_dts[4l];
  // flags
  signed int flags;
  // offset
  signed long int offset;
  // cur_frame_end
  signed long int cur_frame_end[4l];
  // key_frame
  signed int key_frame;
  // convergence_duration
  signed long int convergence_duration;
  // dts_sync_point
  signed int dts_sync_point;
  // dts_ref_dts_delta
  signed int dts_ref_dts_delta;
  // pts_dts_delta
  signed int pts_dts_delta;
  // cur_frame_pos
  signed long int cur_frame_pos[4l];
  // pos
  signed long int pos;
  // last_pos
  signed long int last_pos;
  // duration
  signed int duration;
  // field_order
  enum AVFieldOrder field_order;
  // picture_structure
  enum AVPictureStructure picture_structure;
  // output_picture_number
  signed int output_picture_number;
  // width
  signed int width;
  // height
  signed int height;
  // coded_width
  signed int coded_width;
  // coded_height
  signed int coded_height;
  // format
  signed int format;
};

struct AVFilter
{
  // name
  const char *name;
  // description
  const char *description;
  // inputs
  const struct AVFilterPad *inputs;
  // outputs
  const struct AVFilterPad *outputs;
  // priv_class
  const struct AVClass *priv_class;
  // flags
  signed int flags;
  // init
  signed int (*init)(struct AVFilterContext *);
  // init_dict
  signed int (*init_dict)(struct AVFilterContext *, struct AVDictionary **);
  // uninit
  void (*uninit)(struct AVFilterContext *);
  // query_formats
  signed int (*query_formats)(struct AVFilterContext *);
  // priv_size
  signed int priv_size;
  // next
  struct AVFilter *next;
  // process_command
  signed int (*process_command)(struct AVFilterContext *, const char *, const char *, char *, signed int, signed int);
  // init_opaque
  signed int (*init_opaque)(struct AVFilterContext *, void *);
};

struct AVFilterBuffer
{
  // data
  unsigned char *data[8l];
  // extended_data
  unsigned char **extended_data;
  // linesize
  signed int linesize[8l];
  // priv
  void *priv;
  // free
  void (*free)(struct AVFilterBuffer *);
  // format
  signed int format;
  // w
  signed int w;
  // h
  signed int h;
  // refcount
  unsigned int refcount;
};

struct AVFilterBufferRef
{
  // buf
  struct AVFilterBuffer *buf;
  // data
  unsigned char *data[8l];
  // extended_data
  unsigned char **extended_data;
  // linesize
  signed int linesize[8l];
  // video
  struct AVFilterBufferRefVideoProps *video;
  // audio
  struct AVFilterBufferRefAudioProps *audio;
  // pts
  signed long int pts;
  // pos
  signed long int pos;
  // format
  signed int format;
  // perms
  signed int perms;
  // type
  enum AVMediaType type;
  // metadata
  struct AVDictionary *metadata;
};

struct AVFilterBufferRefAudioProps
{
  // channel_layout
  unsigned long int channel_layout;
  // nb_samples
  signed int nb_samples;
  // sample_rate
  signed int sample_rate;
  // channels
  signed int channels;
};

struct AVFilterBufferRefVideoProps
{
  // w
  signed int w;
  // h
  signed int h;
  // sample_aspect_ratio
  struct AVRational sample_aspect_ratio;
  // interlaced
  signed int interlaced;
  // top_field_first
  signed int top_field_first;
  // pict_type
  enum AVPictureType pict_type;
  // key_frame
  signed int key_frame;
  // qp_table_linesize
  signed int qp_table_linesize;
  // qp_table_size
  signed int qp_table_size;
  // qp_table
  signed char *qp_table;
};

struct AVFilterContext
{
  // av_class
  const struct AVClass *av_class;
  // filter
  const struct AVFilter *filter;
  // name
  char *name;
  // input_pads
  struct AVFilterPad *input_pads;
  // inputs
  struct AVFilterLink **inputs;
  // input_count
  unsigned int input_count;
  // nb_inputs
  unsigned int nb_inputs;
  // output_pads
  struct AVFilterPad *output_pads;
  // outputs
  struct AVFilterLink **outputs;
  // output_count
  unsigned int output_count;
  // nb_outputs
  unsigned int nb_outputs;
  // priv
  void *priv;
  // graph
  struct AVFilterGraph *graph;
  // thread_type
  signed int thread_type;
  // internal
  struct AVFilterInternal *internal;
  // command_queue
  struct AVFilterCommand *command_queue;
  // enable_str
  char *enable_str;
  // enable
  void *enable;
  // var_values
  double *var_values;
  // is_disabled
  signed int is_disabled;
};

struct AVFilterGraph
{
  // av_class
  const struct AVClass *av_class;
  // filter_count_unused
  unsigned int filter_count_unused;
  // filters
  struct AVFilterContext **filters;
  // scale_sws_opts
  char *scale_sws_opts;
  // resample_lavr_opts
  char *resample_lavr_opts;
  // nb_filters
  unsigned int nb_filters;
  // thread_type
  signed int thread_type;
  // nb_threads
  signed int nb_threads;
  // internal
  struct AVFilterGraphInternal *internal;
  // opaque
  void *opaque;
  // execute
  signed int (*execute)(struct AVFilterContext *, signed int (*)(struct AVFilterContext *, void *, signed int, signed int), void *, signed int *, signed int);
  // aresample_swr_opts
  char *aresample_swr_opts;
  // sink_links
  struct AVFilterLink **sink_links;
  // sink_links_count
  signed int sink_links_count;
  // disable_auto_convert
  unsigned int disable_auto_convert;
};

struct AVFilterLink
{
  // src
  struct AVFilterContext *src;
  // srcpad
  struct AVFilterPad *srcpad;
  // dst
  struct AVFilterContext *dst;
  // dstpad
  struct AVFilterPad *dstpad;
  // type
  enum AVMediaType type;
  // w
  signed int w;
  // h
  signed int h;
  // sample_aspect_ratio
  struct AVRational sample_aspect_ratio;
  // channel_layout
  unsigned long int channel_layout;
  // sample_rate
  signed int sample_rate;
  // format
  signed int format;
  // time_base
  struct AVRational time_base;
  // in_formats
  struct AVFilterFormats *in_formats;
  // out_formats
  struct AVFilterFormats *out_formats;
  // in_samplerates
  struct AVFilterFormats *in_samplerates;
  // out_samplerates
  struct AVFilterFormats *out_samplerates;
  // in_channel_layouts
  struct AVFilterChannelLayouts *in_channel_layouts;
  // out_channel_layouts
  struct AVFilterChannelLayouts *out_channel_layouts;
  // request_samples
  signed int request_samples;
  // init_state
  enum anonymous$37 init_state;
  // pool
  struct AVFilterPool *pool;
  // graph
  struct AVFilterGraph *graph;
  // current_pts
  signed long int current_pts;
  // age_index
  signed int age_index;
  // frame_rate
  struct AVRational frame_rate;
  // partial_buf
  struct AVFrame *partial_buf;
  // partial_buf_size
  signed int partial_buf_size;
  // min_samples
  signed int min_samples;
  // max_samples
  signed int max_samples;
  // cur_buf_copy
  struct AVFilterBufferRef *cur_buf_copy;
  // closed
  signed int closed;
  // channels
  signed int channels;
  // frame_requested
  unsigned int frame_requested;
  // flags
  unsigned int flags;
  // frame_count
  signed long int frame_count;
};

struct AVFilterPad
{
  // name
  const char *name;
  // type
  enum AVMediaType type;
  // min_perms
  signed int min_perms;
  // rej_perms
  signed int rej_perms;
  // start_frame
  signed int (*start_frame)(struct AVFilterLink *, struct AVFilterBufferRef *);
  // get_video_buffer
  struct AVFrame * (*get_video_buffer)(struct AVFilterLink *, signed int, signed int);
  // get_audio_buffer
  struct AVFrame * (*get_audio_buffer)(struct AVFilterLink *, signed int);
  // end_frame
  signed int (*end_frame)(struct AVFilterLink *);
  // draw_slice
  signed int (*draw_slice)(struct AVFilterLink *, signed int, signed int, signed int);
  // filter_frame
  signed int (*filter_frame)(struct AVFilterLink *, struct AVFrame *);
  // poll_frame
  signed int (*poll_frame)(struct AVFilterLink *);
  // request_frame
  signed int (*request_frame)(struct AVFilterLink *);
  // config_props
  signed int (*config_props)(struct AVFilterLink *);
  // needs_fifo
  signed int needs_fifo;
  // needs_writable
  signed int needs_writable;
};

struct AVIOInterruptCB
{
  // callback
  signed int (*callback)(void *);
  // opaque
  void *opaque;
};

struct AVFormatContext
{
  // av_class
  const struct AVClass *av_class;
  // iformat
  struct AVInputFormat *iformat;
  // oformat
  struct AVOutputFormat *oformat;
  // priv_data
  void *priv_data;
  // pb
  struct AVIOContext *pb;
  // ctx_flags
  signed int ctx_flags;
  // nb_streams
  unsigned int nb_streams;
  // streams
  struct AVStream **streams;
  // filename
  char filename[1024l];
  // start_time
  signed long int start_time;
  // duration
  signed long int duration;
  // bit_rate
  signed int bit_rate;
  // packet_size
  unsigned int packet_size;
  // max_delay
  signed int max_delay;
  // flags
  signed int flags;
  // probesize
  unsigned int probesize;
  // max_analyze_duration
  signed int max_analyze_duration;
  // key
  const unsigned char *key;
  // keylen
  signed int keylen;
  // nb_programs
  unsigned int nb_programs;
  // programs
  struct AVProgram **programs;
  // video_codec_id
  enum AVCodecID video_codec_id;
  // audio_codec_id
  enum AVCodecID audio_codec_id;
  // subtitle_codec_id
  enum AVCodecID subtitle_codec_id;
  // max_index_size
  unsigned int max_index_size;
  // max_picture_buffer
  unsigned int max_picture_buffer;
  // nb_chapters
  unsigned int nb_chapters;
  // chapters
  struct AVChapter **chapters;
  // metadata
  struct AVDictionary *metadata;
  // start_time_realtime
  signed long int start_time_realtime;
  // fps_probe_size
  signed int fps_probe_size;
  // error_recognition
  signed int error_recognition;
  // interrupt_callback
  struct AVIOInterruptCB interrupt_callback;
  // debug
  signed int debug;
  // max_interleave_delta
  signed long int max_interleave_delta;
  // strict_std_compliance
  signed int strict_std_compliance;
  // event_flags
  signed int event_flags;
  // max_ts_probe
  signed int max_ts_probe;
  // avoid_negative_ts
  signed int avoid_negative_ts;
  // ts_id
  signed int ts_id;
  // audio_preload
  signed int audio_preload;
  // max_chunk_duration
  signed int max_chunk_duration;
  // max_chunk_size
  signed int max_chunk_size;
  // use_wallclock_as_timestamps
  signed int use_wallclock_as_timestamps;
  // avio_flags
  signed int avio_flags;
  // duration_estimation_method
  enum AVDurationEstimationMethod duration_estimation_method;
  // skip_initial_bytes
  signed long int skip_initial_bytes;
  // correct_ts_overflow
  unsigned int correct_ts_overflow;
  // seek2any
  signed int seek2any;
  // flush_packets
  signed int flush_packets;
  // probe_score
  signed int probe_score;
  // format_probesize
  signed int format_probesize;
  // codec_whitelist
  char *codec_whitelist;
  // format_whitelist
  char *format_whitelist;
  // internal
  struct AVFormatInternal *internal;
  // io_repositioned
  signed int io_repositioned;
  // video_codec
  struct AVCodec *video_codec;
  // audio_codec
  struct AVCodec *audio_codec;
  // subtitle_codec
  struct AVCodec *subtitle_codec;
  // data_codec
  struct AVCodec *data_codec;
  // metadata_header_padding
  signed int metadata_header_padding;
  // opaque
  void *opaque;
  // control_message_cb
  signed int (*control_message_cb)(struct AVFormatContext *, signed int, void *, unsigned long int);
  // output_ts_offset
  signed long int output_ts_offset;
  // max_analyze_duration2
  signed long int max_analyze_duration2;
  // probesize2
  signed long int probesize2;
  // dump_separator
  unsigned char *dump_separator;
  // data_codec_id
  enum AVCodecID data_codec_id;
  // open_cb
  signed int (*open_cb)(struct AVFormatContext *, struct AVIOContext **, const char *, signed int, const struct AVIOInterruptCB *, struct AVDictionary **);
};

struct AVFrac
{
  // val
  signed long int val;
  // num
  signed long int num;
  // den
  signed long int den;
};

struct AVFrame
{
  // data
  unsigned char *data[8l];
  // linesize
  signed int linesize[8l];
  // extended_data
  unsigned char **extended_data;
  // width
  signed int width;
  // height
  signed int height;
  // nb_samples
  signed int nb_samples;
  // format
  signed int format;
  // key_frame
  signed int key_frame;
  // pict_type
  enum AVPictureType pict_type;
  // base
  unsigned char *base[8l];
  // sample_aspect_ratio
  struct AVRational sample_aspect_ratio;
  // pts
  signed long int pts;
  // pkt_pts
  signed long int pkt_pts;
  // pkt_dts
  signed long int pkt_dts;
  // coded_picture_number
  signed int coded_picture_number;
  // display_picture_number
  signed int display_picture_number;
  // quality
  signed int quality;
  // reference
  signed int reference;
  // qscale_table
  signed char *qscale_table;
  // qstride
  signed int qstride;
  // qscale_type
  signed int qscale_type;
  // mbskip_table
  unsigned char *mbskip_table;
  // motion_val
  signed short int (*motion_val[2l])[2l];
  // mb_type
  unsigned int *mb_type;
  // dct_coeff
  signed short int *dct_coeff;
  // ref_index
  signed char *ref_index[2l];
  // opaque
  void *opaque;
  // error
  unsigned long int error[8l];
  // type
  signed int type;
  // repeat_pict
  signed int repeat_pict;
  // interlaced_frame
  signed int interlaced_frame;
  // top_field_first
  signed int top_field_first;
  // palette_has_changed
  signed int palette_has_changed;
  // buffer_hints
  signed int buffer_hints;
  // pan_scan
  struct AVPanScan *pan_scan;
  // reordered_opaque
  signed long int reordered_opaque;
  // hwaccel_picture_private
  void *hwaccel_picture_private;
  // owner
  struct AVCodecContext *owner;
  // thread_opaque
  void *thread_opaque;
  // motion_subsample_log2
  unsigned char motion_subsample_log2;
  // sample_rate
  signed int sample_rate;
  // channel_layout
  unsigned long int channel_layout;
  // buf
  struct AVBufferRef *buf[8l];
  // extended_buf
  struct AVBufferRef **extended_buf;
  // nb_extended_buf
  signed int nb_extended_buf;
  // side_data
  struct AVFrameSideData **side_data;
  // nb_side_data
  signed int nb_side_data;
  // flags
  signed int flags;
  // color_range
  enum AVColorRange color_range;
  // color_primaries
  enum AVColorPrimaries color_primaries;
  // color_trc
  enum AVColorTransferCharacteristic color_trc;
  // colorspace
  enum AVColorSpace colorspace;
  // chroma_location
  enum AVChromaLocation chroma_location;
  // best_effort_timestamp
  signed long int best_effort_timestamp;
  // pkt_pos
  signed long int pkt_pos;
  // pkt_duration
  signed long int pkt_duration;
  // metadata
  struct AVDictionary *metadata;
  // decode_error_flags
  signed int decode_error_flags;
  // channels
  signed int channels;
  // pkt_size
  signed int pkt_size;
  // qp_table_buf
  struct AVBufferRef *qp_table_buf;
};

struct AVFrameSideData
{
  // type
  enum AVFrameSideDataType type;
  // data
  unsigned char *data;
  // size
  signed int size;
  // metadata
  struct AVDictionary *metadata;
  // buf
  struct AVBufferRef *buf;
};

struct AVHWAccel
{
  // name
  const char *name;
  // type
  enum AVMediaType type;
  // id
  enum AVCodecID id;
  // pix_fmt
  enum AVPixelFormat pix_fmt;
  // capabilities
  signed int capabilities;
  // next
  struct AVHWAccel *next;
  // alloc_frame
  signed int (*alloc_frame)(struct AVCodecContext *, struct AVFrame *);
  // start_frame
  signed int (*start_frame)(struct AVCodecContext *, const unsigned char *, unsigned int);
  // decode_slice
  signed int (*decode_slice)(struct AVCodecContext *, const unsigned char *, unsigned int);
  // end_frame
  signed int (*end_frame)(struct AVCodecContext *);
  // frame_priv_data_size
  signed int frame_priv_data_size;
  // decode_mb
  void (*decode_mb)(struct MpegEncContext *);
  // init
  signed int (*init)(struct AVCodecContext *);
  // uninit
  signed int (*uninit)(struct AVCodecContext *);
  // priv_data_size
  signed int priv_data_size;
};

struct AVIOContext
{
  // av_class
  const struct AVClass *av_class;
  // buffer
  unsigned char *buffer;
  // buffer_size
  signed int buffer_size;
  // buf_ptr
  unsigned char *buf_ptr;
  // buf_end
  unsigned char *buf_end;
  // opaque
  void *opaque;
  // read_packet
  signed int (*read_packet)(void *, unsigned char *, signed int);
  // write_packet
  signed int (*write_packet)(void *, unsigned char *, signed int);
  // seek
  signed long int (*seek)(void *, signed long int, signed int);
  // pos
  signed long int pos;
  // must_flush
  signed int must_flush;
  // eof_reached
  signed int eof_reached;
  // write_flag
  signed int write_flag;
  // max_packet_size
  signed int max_packet_size;
  // checksum
  unsigned long int checksum;
  // checksum_ptr
  unsigned char *checksum_ptr;
  // update_checksum
  unsigned long int (*update_checksum)(unsigned long int, const unsigned char *, unsigned int);
  // error
  signed int error;
  // read_pause
  signed int (*read_pause)(void *, signed int);
  // read_seek
  signed long int (*read_seek)(void *, signed int, signed long int, signed int);
  // seekable
  signed int seekable;
  // maxsize
  signed long int maxsize;
  // direct
  signed int direct;
  // bytes_read
  signed long int bytes_read;
  // seek_count
  signed int seek_count;
  // writeout_count
  signed int writeout_count;
  // orig_buffer_size
  signed int orig_buffer_size;
  // short_seek_threshold
  signed int short_seek_threshold;
};

struct AVIndexEntry
{
  // pos
  signed long int pos;
  // timestamp
  signed long int timestamp;
  // flags
  signed int flags : 2;
  // size
  signed int size : 30;
  // min_distance
  signed int min_distance;
};

struct AVInputFormat
{
  // name
  const char *name;
  // long_name
  const char *long_name;
  // flags
  signed int flags;
  // extensions
  const char *extensions;
  // codec_tag
  struct AVCodecTag * const *codec_tag;
  // priv_class
  const struct AVClass *priv_class;
  // mime_type
  const char *mime_type;
  // next
  struct AVInputFormat *next;
  // raw_codec_id
  signed int raw_codec_id;
  // priv_data_size
  signed int priv_data_size;
  // read_probe
  signed int (*read_probe)(struct AVProbeData *);
  // read_header
  signed int (*read_header)(struct AVFormatContext *);
  // read_packet
  signed int (*read_packet)(struct AVFormatContext *, struct AVPacket *);
  // read_close
  signed int (*read_close)(struct AVFormatContext *);
  // read_seek
  signed int (*read_seek)(struct AVFormatContext *, signed int, signed long int, signed int);
  // read_timestamp
  signed long int (*read_timestamp)(struct AVFormatContext *, signed int, signed long int *, signed long int);
  // read_play
  signed int (*read_play)(struct AVFormatContext *);
  // read_pause
  signed int (*read_pause)(struct AVFormatContext *);
  // read_seek2
  signed int (*read_seek2)(struct AVFormatContext *, signed int, signed long int, signed long int, signed long int, signed int);
  // get_device_list
  signed int (*get_device_list)(struct AVFormatContext *, struct AVDeviceInfoList *);
  // create_device_capabilities
  signed int (*create_device_capabilities)(struct AVFormatContext *, struct AVDeviceCapabilitiesQuery *);
  // free_device_capabilities
  signed int (*free_device_capabilities)(struct AVFormatContext *, struct AVDeviceCapabilitiesQuery *);
};

struct AVOption
{
  // name
  const char *name;
  // help
  const char *help;
  // offset
  signed int offset;
  // type
  enum AVOptionType type;
  // default_val
  union anonymous$24 default_val;
  // min
  double min;
  // max
  double max;
  // flags
  signed int flags;
  // unit
  const char *unit;
};

struct AVOptionRange
{
  // str
  const char *str;
  // value_min
  double value_min;
  // value_max
  double value_max;
  // component_min
  double component_min;
  // component_max
  double component_max;
  // is_range
  signed int is_range;
};

struct AVOptionRanges
{
  // range
  struct AVOptionRange **range;
  // nb_ranges
  signed int nb_ranges;
  // nb_components
  signed int nb_components;
};

struct AVOutputFormat
{
  // name
  const char *name;
  // long_name
  const char *long_name;
  // mime_type
  const char *mime_type;
  // extensions
  const char *extensions;
  // audio_codec
  enum AVCodecID audio_codec;
  // video_codec
  enum AVCodecID video_codec;
  // subtitle_codec
  enum AVCodecID subtitle_codec;
  // flags
  signed int flags;
  // codec_tag
  struct AVCodecTag * const *codec_tag;
  // priv_class
  const struct AVClass *priv_class;
  // next
  struct AVOutputFormat *next;
  // priv_data_size
  signed int priv_data_size;
  // write_header
  signed int (*write_header)(struct AVFormatContext *);
  // write_packet
  signed int (*write_packet)(struct AVFormatContext *, struct AVPacket *);
  // write_trailer
  signed int (*write_trailer)(struct AVFormatContext *);
  // interleave_packet
  signed int (*interleave_packet)(struct AVFormatContext *, struct AVPacket *, struct AVPacket *, signed int);
  // query_codec
  signed int (*query_codec)(enum AVCodecID, signed int);
  // get_output_timestamp
  void (*get_output_timestamp)(struct AVFormatContext *, signed int, signed long int *, signed long int *);
  // control_message
  signed int (*control_message)(struct AVFormatContext *, signed int, void *, unsigned long int);
  // write_uncoded_frame
  signed int (*write_uncoded_frame)(struct AVFormatContext *, signed int, struct AVFrame **, unsigned int);
  // get_device_list
  signed int (*get_device_list)(struct AVFormatContext *, struct AVDeviceInfoList *);
  // create_device_capabilities
  signed int (*create_device_capabilities)(struct AVFormatContext *, struct AVDeviceCapabilitiesQuery *);
  // free_device_capabilities
  signed int (*free_device_capabilities)(struct AVFormatContext *, struct AVDeviceCapabilitiesQuery *);
  // data_codec
  enum AVCodecID data_codec;
};

struct AVPacket
{
  // buf
  struct AVBufferRef *buf;
  // pts
  signed long int pts;
  // dts
  signed long int dts;
  // data
  unsigned char *data;
  // size
  signed int size;
  // stream_index
  signed int stream_index;
  // flags
  signed int flags;
  // side_data
  struct AVPacketSideData *side_data;
  // side_data_elems
  signed int side_data_elems;
  // duration
  signed int duration;
  // destruct
  void (*destruct)(struct AVPacket *);
  // priv
  void *priv;
  // pos
  signed long int pos;
  // convergence_duration
  signed long int convergence_duration;
};

struct AVPacketList
{
  // pkt
  struct AVPacket pkt;
  // next
  struct AVPacketList *next;
};

struct AVPacketSideData
{
  // data
  unsigned char *data;
  // size
  signed int size;
  // type
  enum AVPacketSideDataType type;
};

struct AVPanScan
{
  // id
  signed int id;
  // width
  signed int width;
  // height
  signed int height;
  // position
  signed short int position[3l][2l];
};

struct AVPicture
{
  // data
  unsigned char *data[8l];
  // linesize
  signed int linesize[8l];
};

struct AVProbeData
{
  // filename
  const char *filename;
  // buf
  unsigned char *buf;
  // buf_size
  signed int buf_size;
  // mime_type
  const char *mime_type;
};

struct AVProfile
{
  // profile
  signed int profile;
  // name
  const char *name;
};

struct AVProgram
{
  // id
  signed int id;
  // flags
  signed int flags;
  // discard
  enum AVDiscard discard;
  // stream_index
  unsigned int *stream_index;
  // nb_stream_indexes
  unsigned int nb_stream_indexes;
  // metadata
  struct AVDictionary *metadata;
  // program_num
  signed int program_num;
  // pmt_pid
  signed int pmt_pid;
  // pcr_pid
  signed int pcr_pid;
  // start_time
  signed long int start_time;
  // end_time
  signed long int end_time;
  // pts_wrap_reference
  signed long int pts_wrap_reference;
  // pts_wrap_behavior
  signed int pts_wrap_behavior;
};

struct AVStream
{
  // index
  signed int index;
  // id
  signed int id;
  // codec
  struct AVCodecContext *codec;
  // priv_data
  void *priv_data;
  // pts
  struct AVFrac pts;
  // time_base
  struct AVRational time_base;
  // start_time
  signed long int start_time;
  // duration
  signed long int duration;
  // nb_frames
  signed long int nb_frames;
  // disposition
  signed int disposition;
  // discard
  enum AVDiscard discard;
  // sample_aspect_ratio
  struct AVRational sample_aspect_ratio;
  // metadata
  struct AVDictionary *metadata;
  // avg_frame_rate
  struct AVRational avg_frame_rate;
  // attached_pic
  struct AVPacket attached_pic;
  // side_data
  struct AVPacketSideData *side_data;
  // nb_side_data
  signed int nb_side_data;
  // event_flags
  signed int event_flags;
  // info
  struct anonymous$6 *info;
  // pts_wrap_bits
  signed int pts_wrap_bits;
  // first_dts
  signed long int first_dts;
  // cur_dts
  signed long int cur_dts;
  // last_IP_pts
  signed long int last_IP_pts;
  // last_IP_duration
  signed int last_IP_duration;
  // probe_packets
  signed int probe_packets;
  // codec_info_nb_frames
  signed int codec_info_nb_frames;
  // need_parsing
  enum AVStreamParseType need_parsing;
  // parser
  struct AVCodecParserContext *parser;
  // last_in_packet_buffer
  struct AVPacketList *last_in_packet_buffer;
  // probe_data
  struct AVProbeData probe_data;
  // pts_buffer
  signed long int pts_buffer[17l];
  // index_entries
  struct AVIndexEntry *index_entries;
  // nb_index_entries
  signed int nb_index_entries;
  // index_entries_allocated_size
  unsigned int index_entries_allocated_size;
  // r_frame_rate
  struct AVRational r_frame_rate;
  // stream_identifier
  signed int stream_identifier;
  // interleaver_chunk_size
  signed long int interleaver_chunk_size;
  // interleaver_chunk_duration
  signed long int interleaver_chunk_duration;
  // request_probe
  signed int request_probe;
  // skip_to_keyframe
  signed int skip_to_keyframe;
  // skip_samples
  signed int skip_samples;
  // start_skip_samples
  signed long int start_skip_samples;
  // first_discard_sample
  signed long int first_discard_sample;
  // last_discard_sample
  signed long int last_discard_sample;
  // nb_decoded_frames
  signed int nb_decoded_frames;
  // mux_ts_offset
  signed long int mux_ts_offset;
  // pts_wrap_reference
  signed long int pts_wrap_reference;
  // pts_wrap_behavior
  signed int pts_wrap_behavior;
  // update_initial_durations_done
  signed int update_initial_durations_done;
  // pts_reorder_error
  signed long int pts_reorder_error[17l];
  // pts_reorder_error_count
  unsigned char pts_reorder_error_count[17l];
  // last_dts_for_order_check
  signed long int last_dts_for_order_check;
  // dts_ordered
  unsigned char dts_ordered;
  // dts_misordered
  unsigned char dts_misordered;
  // inject_global_side_data
  signed int inject_global_side_data;
  // recommended_encoder_configuration
  char *recommended_encoder_configuration;
  // display_aspect_ratio
  struct AVRational display_aspect_ratio;
  // priv_pts
  struct FFFrac *priv_pts;
};

struct AVSubtitle
{
  // format
  unsigned short int format;
  // start_display_time
  unsigned int start_display_time;
  // end_display_time
  unsigned int end_display_time;
  // num_rects
  unsigned int num_rects;
  // rects
  struct AVSubtitleRect **rects;
  // pts
  signed long int pts;
};

struct AVSubtitleRect
{
  // x
  signed int x;
  // y
  signed int y;
  // w
  signed int w;
  // h
  signed int h;
  // nb_colors
  signed int nb_colors;
  // pict
  struct AVPicture pict;
  // type
  enum AVSubtitleType type;
  // text
  char *text;
  // ass
  char *ass;
  // flags
  signed int flags;
};

struct PianoListHead
{
  // next
  struct PianoListHead *next;
};

struct PianoArtist
{
  // head
  struct PianoListHead head;
  // name
  char *name;
  // musicId
  char *musicId;
  // seedId
  char *seedId;
  // score
  signed int score;
};

struct PianoGenre
{
  // head
  struct PianoListHead head;
  // name
  char *name;
  // musicId
  char *musicId;
};

struct PianoGenreCategory
{
  // head
  struct PianoListHead head;
  // name
  char *name;
  // genres
  struct PianoGenre *genres;
};

struct PianoRequest
{
  // type
  enum anonymous$2 type;
  // secure
  _Bool secure;
  // data
  void *data;
  // urlPath
  char urlPath[1024l];
  // postData
  char *postData;
  // responseData
  char *responseData;
};

struct PianoSong
{
  // head
  struct PianoListHead head;
  // artist
  char *artist;
  // stationId
  char *stationId;
  // album
  char *album;
  // audioUrl
  char *audioUrl;
  // coverArt
  char *coverArt;
  // musicId
  char *musicId;
  // title
  char *title;
  // seedId
  char *seedId;
  // feedbackId
  char *feedbackId;
  // detailUrl
  char *detailUrl;
  // trackToken
  char *trackToken;
  // fileGain
  float fileGain;
  // length
  unsigned int length;
  // rating
  enum anonymous$29 rating;
  // audioFormat
  enum anonymous$30 audioFormat;
};

struct PianoStation
{
  // head
  struct PianoListHead head;
  // isCreator
  char isCreator;
  // isQuickMix
  char isQuickMix;
  // useQuickMix
  char useQuickMix;
  // name
  char *name;
  // id
  char *id;
  // seedId
  char *seedId;
};

struct RcOverride
{
  // start_frame
  signed int start_frame;
  // end_frame
  signed int end_frame;
  // qscale
  signed int qscale;
  // quality_factor
  float quality_factor;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct ao_option
{
  // key
  char *key;
  // value
  char *value;
  // next
  struct ao_option *next;
};

struct ao_sample_format
{
  // bits
  signed int bits;
  // rate
  signed int rate;
  // channels
  signed int channels;
  // byte_format
  signed int byte_format;
  // matrix
  char *matrix;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

struct pollfd
{
  // fd
  signed int fd;
  // events
  signed short int events;
  // revents
  signed short int revents;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct termios
{
  // c_iflag
  unsigned int c_iflag;
  // c_oflag
  unsigned int c_oflag;
  // c_cflag
  unsigned int c_cflag;
  // c_lflag
  unsigned int c_lflag;
  // c_line
  unsigned char c_line;
  // c_cc
  unsigned char c_cc[32l];
  // c_ispeed
  unsigned int c_ispeed;
  // c_ospeed
  unsigned int c_ospeed;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};


// avformat
// file src/player.c line 57
const enum AVSampleFormat avformat = (const enum AVSampleFormat)1;
// dispatchActions
// file src/ui_dispatch.h line 52
static const struct anonymous$31 dispatchActions[29l];
// dispatchActions
// file src/ui_dispatch.h line 52
static const struct anonymous$31 dispatchActions[29l] = { { .defaultKey=(char)63, .context=(enum anonymous$28)BAR_DC_UNDEFINED, .function=BarUiActHelp,
    .helpText=(const char *)(void *)0, .configKey="act_help" },
    { .defaultKey=(char)43, .context=(enum anonymous$28)BAR_DC_SONG, .function=BarUiActLoveSong,
    .helpText="love song", .configKey="act_songlove" },
    { .defaultKey=(char)45, .context=(enum anonymous$28)BAR_DC_SONG, .function=BarUiActBanSong,
    .helpText="ban song", .configKey="act_songban" },
    { .defaultKey=(char)97, .context=(enum anonymous$28)BAR_DC_STATION, .function=BarUiActAddMusic,
    .helpText="add music to station", .configKey="act_stationaddmusic" },
    { .defaultKey=(char)99, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActCreateStation,
    .helpText="create new station", .configKey="act_stationcreate" },
    { .defaultKey=(char)100, .context=(enum anonymous$28)BAR_DC_STATION, .function=BarUiActDeleteStation,
    .helpText="delete station", .configKey="act_stationdelete" },
    { .defaultKey=(char)101, .context=(enum anonymous$28)BAR_DC_SONG, .function=BarUiActExplain,
    .helpText="explain why this song is played", .configKey="act_songexplain" },
    { .defaultKey=(char)103, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActStationFromGenre,
    .helpText="add genre station", .configKey="act_stationaddbygenre" },
    { .defaultKey=(char)104, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActHistory,
    .helpText="song history", .configKey="act_history" },
    { .defaultKey=(char)105, .context=(enum anonymous$28)(BAR_DC_GLOBAL | BAR_DC_STATION | BAR_DC_SONG), .function=BarUiActSongInfo,
    .helpText="print information about song/station", .configKey="act_songinfo" },
    { .defaultKey=(char)106, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActAddSharedStation,
    .helpText="add shared station", .configKey="act_addshared" },
    { .defaultKey=(char)110, .context=(enum anonymous$28)(BAR_DC_GLOBAL | BAR_DC_STATION), .function=BarUiActSkipSong,
    .helpText="next song", .configKey="act_songnext" },
    { .defaultKey=(char)112, .context=(enum anonymous$28)(BAR_DC_GLOBAL | BAR_DC_STATION), .function=BarUiActTogglePause,
    .helpText="pause/resume playback", .configKey="act_songpausetoggle" },
    { .defaultKey=(char)113, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActQuit,
    .helpText="quit", .configKey="act_quit" },
    { .defaultKey=(char)114, .context=(enum anonymous$28)BAR_DC_STATION, .function=BarUiActRenameStation,
    .helpText="rename station", .configKey="act_stationrename" },
    { .defaultKey=(char)115, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActSelectStation,
    .helpText="change station", .configKey="act_stationchange" },
    { .defaultKey=(char)116, .context=(enum anonymous$28)BAR_DC_SONG, .function=BarUiActTempBanSong,
    .helpText="tired (ban song for 1 month)", .configKey="act_songtired" },
    { .defaultKey=(char)117, .context=(enum anonymous$28)(BAR_DC_GLOBAL | BAR_DC_STATION), .function=BarUiActPrintUpcoming,
    .helpText="upcoming songs", .configKey="act_upcoming" },
    { .defaultKey=(char)120, .context=(enum anonymous$28)BAR_DC_STATION, .function=BarUiActSelectQuickMix,
    .helpText="select quickmix stations", .configKey="act_stationselectquickmix" },
    { .defaultKey=(char)36, .context=(enum anonymous$28)BAR_DC_SONG, .function=BarUiActDebug,
    .helpText=(const char *)(void *)0, .configKey="act_debug" },
    { .defaultKey=(char)98, .context=(enum anonymous$28)BAR_DC_SONG, .function=BarUiActBookmark,
    .helpText="bookmark song/artist", .configKey="act_bookmark" },
    { .defaultKey=(char)40, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActVolDown,
    .helpText="decrease volume", .configKey="act_voldown" },
    { .defaultKey=(char)41, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActVolUp,
    .helpText="increase volume", .configKey="act_volup" },
    { .defaultKey=(char)61, .context=(enum anonymous$28)BAR_DC_STATION, .function=BarUiActManageStation,
    .helpText="delete seeds/feedback", .configKey="act_managestation" },
    { .defaultKey=(char)32, .context=(enum anonymous$28)(BAR_DC_GLOBAL | BAR_DC_STATION), .function=BarUiActTogglePause,
    .helpText=(const char *)(void *)0, .configKey="act_songpausetoggle2" },
    { .defaultKey=(char)118, .context=(enum anonymous$28)BAR_DC_SONG, .function=BarUiActCreateStationFromSong,
    .helpText="create new station from song or artist",
    .configKey="act_stationcreatefromsong" },
    { .defaultKey=(char)80, .context=(enum anonymous$28)(BAR_DC_GLOBAL | BAR_DC_STATION), .function=BarUiActPlay,
    .helpText="resume playback", .configKey="act_songplay" },
    { .defaultKey=(char)83, .context=(enum anonymous$28)(BAR_DC_GLOBAL | BAR_DC_STATION), .function=BarUiActPause,
    .helpText="pause playback", .configKey="act_songpause" },
    { .defaultKey=(char)94, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActVolReset,
    .helpText="reset volume", .configKey="act_volreset" } };
// dispatchActions$link1
// file src/ui_dispatch.h line 52
static const struct anonymous$31 dispatchActions$link1[29l];
// dispatchActions$link1
// file src/ui_dispatch.h line 52
static const struct anonymous$31 dispatchActions$link1[29l] = { { .defaultKey=(char)63, .context=(enum anonymous$28)BAR_DC_UNDEFINED, .function=BarUiActHelp,
    .helpText=(const char *)(void *)0, .configKey="act_help" },
    { .defaultKey=(char)43, .context=(enum anonymous$28)BAR_DC_SONG, .function=BarUiActLoveSong,
    .helpText="love song", .configKey="act_songlove" },
    { .defaultKey=(char)45, .context=(enum anonymous$28)BAR_DC_SONG, .function=BarUiActBanSong,
    .helpText="ban song", .configKey="act_songban" },
    { .defaultKey=(char)97, .context=(enum anonymous$28)BAR_DC_STATION, .function=BarUiActAddMusic,
    .helpText="add music to station", .configKey="act_stationaddmusic" },
    { .defaultKey=(char)99, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActCreateStation,
    .helpText="create new station", .configKey="act_stationcreate" },
    { .defaultKey=(char)100, .context=(enum anonymous$28)BAR_DC_STATION, .function=BarUiActDeleteStation,
    .helpText="delete station", .configKey="act_stationdelete" },
    { .defaultKey=(char)101, .context=(enum anonymous$28)BAR_DC_SONG, .function=BarUiActExplain,
    .helpText="explain why this song is played", .configKey="act_songexplain" },
    { .defaultKey=(char)103, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActStationFromGenre,
    .helpText="add genre station", .configKey="act_stationaddbygenre" },
    { .defaultKey=(char)104, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActHistory,
    .helpText="song history", .configKey="act_history" },
    { .defaultKey=(char)105, .context=(enum anonymous$28)(BAR_DC_GLOBAL | BAR_DC_STATION | BAR_DC_SONG), .function=BarUiActSongInfo,
    .helpText="print information about song/station", .configKey="act_songinfo" },
    { .defaultKey=(char)106, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActAddSharedStation,
    .helpText="add shared station", .configKey="act_addshared" },
    { .defaultKey=(char)110, .context=(enum anonymous$28)(BAR_DC_GLOBAL | BAR_DC_STATION), .function=BarUiActSkipSong,
    .helpText="next song", .configKey="act_songnext" },
    { .defaultKey=(char)112, .context=(enum anonymous$28)(BAR_DC_GLOBAL | BAR_DC_STATION), .function=BarUiActTogglePause,
    .helpText="pause/resume playback", .configKey="act_songpausetoggle" },
    { .defaultKey=(char)113, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActQuit,
    .helpText="quit", .configKey="act_quit" },
    { .defaultKey=(char)114, .context=(enum anonymous$28)BAR_DC_STATION, .function=BarUiActRenameStation,
    .helpText="rename station", .configKey="act_stationrename" },
    { .defaultKey=(char)115, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActSelectStation,
    .helpText="change station", .configKey="act_stationchange" },
    { .defaultKey=(char)116, .context=(enum anonymous$28)BAR_DC_SONG, .function=BarUiActTempBanSong,
    .helpText="tired (ban song for 1 month)", .configKey="act_songtired" },
    { .defaultKey=(char)117, .context=(enum anonymous$28)(BAR_DC_GLOBAL | BAR_DC_STATION), .function=BarUiActPrintUpcoming,
    .helpText="upcoming songs", .configKey="act_upcoming" },
    { .defaultKey=(char)120, .context=(enum anonymous$28)BAR_DC_STATION, .function=BarUiActSelectQuickMix,
    .helpText="select quickmix stations", .configKey="act_stationselectquickmix" },
    { .defaultKey=(char)36, .context=(enum anonymous$28)BAR_DC_SONG, .function=BarUiActDebug,
    .helpText=(const char *)(void *)0, .configKey="act_debug" },
    { .defaultKey=(char)98, .context=(enum anonymous$28)BAR_DC_SONG, .function=BarUiActBookmark,
    .helpText="bookmark song/artist", .configKey="act_bookmark" },
    { .defaultKey=(char)40, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActVolDown,
    .helpText="decrease volume", .configKey="act_voldown" },
    { .defaultKey=(char)41, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActVolUp,
    .helpText="increase volume", .configKey="act_volup" },
    { .defaultKey=(char)61, .context=(enum anonymous$28)BAR_DC_STATION, .function=BarUiActManageStation,
    .helpText="delete seeds/feedback", .configKey="act_managestation" },
    { .defaultKey=(char)32, .context=(enum anonymous$28)(BAR_DC_GLOBAL | BAR_DC_STATION), .function=BarUiActTogglePause,
    .helpText=(const char *)(void *)0, .configKey="act_songpausetoggle2" },
    { .defaultKey=(char)118, .context=(enum anonymous$28)BAR_DC_SONG, .function=BarUiActCreateStationFromSong,
    .helpText="create new station from song or artist",
    .configKey="act_stationcreatefromsong" },
    { .defaultKey=(char)80, .context=(enum anonymous$28)(BAR_DC_GLOBAL | BAR_DC_STATION), .function=BarUiActPlay,
    .helpText="resume playback", .configKey="act_songplay" },
    { .defaultKey=(char)83, .context=(enum anonymous$28)(BAR_DC_GLOBAL | BAR_DC_STATION), .function=BarUiActPause,
    .helpText="pause playback", .configKey="act_songpause" },
    { .defaultKey=(char)94, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActVolReset,
    .helpText="reset volume", .configKey="act_volreset" } };
// dispatchActions$link2
// file src/ui_dispatch.h line 52
static const struct anonymous$31 dispatchActions$link2[29l];
// dispatchActions$link2
// file src/ui_dispatch.h line 52
static const struct anonymous$31 dispatchActions$link2[29l] = { { .defaultKey=(char)63, .context=(enum anonymous$28)BAR_DC_UNDEFINED, .function=BarUiActHelp,
    .helpText=(const char *)(void *)0, .configKey="act_help" },
    { .defaultKey=(char)43, .context=(enum anonymous$28)BAR_DC_SONG, .function=BarUiActLoveSong,
    .helpText="love song", .configKey="act_songlove" },
    { .defaultKey=(char)45, .context=(enum anonymous$28)BAR_DC_SONG, .function=BarUiActBanSong,
    .helpText="ban song", .configKey="act_songban" },
    { .defaultKey=(char)97, .context=(enum anonymous$28)BAR_DC_STATION, .function=BarUiActAddMusic,
    .helpText="add music to station", .configKey="act_stationaddmusic" },
    { .defaultKey=(char)99, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActCreateStation,
    .helpText="create new station", .configKey="act_stationcreate" },
    { .defaultKey=(char)100, .context=(enum anonymous$28)BAR_DC_STATION, .function=BarUiActDeleteStation,
    .helpText="delete station", .configKey="act_stationdelete" },
    { .defaultKey=(char)101, .context=(enum anonymous$28)BAR_DC_SONG, .function=BarUiActExplain,
    .helpText="explain why this song is played", .configKey="act_songexplain" },
    { .defaultKey=(char)103, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActStationFromGenre,
    .helpText="add genre station", .configKey="act_stationaddbygenre" },
    { .defaultKey=(char)104, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActHistory,
    .helpText="song history", .configKey="act_history" },
    { .defaultKey=(char)105, .context=(enum anonymous$28)(BAR_DC_GLOBAL | BAR_DC_STATION | BAR_DC_SONG), .function=BarUiActSongInfo,
    .helpText="print information about song/station", .configKey="act_songinfo" },
    { .defaultKey=(char)106, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActAddSharedStation,
    .helpText="add shared station", .configKey="act_addshared" },
    { .defaultKey=(char)110, .context=(enum anonymous$28)(BAR_DC_GLOBAL | BAR_DC_STATION), .function=BarUiActSkipSong,
    .helpText="next song", .configKey="act_songnext" },
    { .defaultKey=(char)112, .context=(enum anonymous$28)(BAR_DC_GLOBAL | BAR_DC_STATION), .function=BarUiActTogglePause,
    .helpText="pause/resume playback", .configKey="act_songpausetoggle" },
    { .defaultKey=(char)113, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActQuit,
    .helpText="quit", .configKey="act_quit" },
    { .defaultKey=(char)114, .context=(enum anonymous$28)BAR_DC_STATION, .function=BarUiActRenameStation,
    .helpText="rename station", .configKey="act_stationrename" },
    { .defaultKey=(char)115, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActSelectStation,
    .helpText="change station", .configKey="act_stationchange" },
    { .defaultKey=(char)116, .context=(enum anonymous$28)BAR_DC_SONG, .function=BarUiActTempBanSong,
    .helpText="tired (ban song for 1 month)", .configKey="act_songtired" },
    { .defaultKey=(char)117, .context=(enum anonymous$28)(BAR_DC_GLOBAL | BAR_DC_STATION), .function=BarUiActPrintUpcoming,
    .helpText="upcoming songs", .configKey="act_upcoming" },
    { .defaultKey=(char)120, .context=(enum anonymous$28)BAR_DC_STATION, .function=BarUiActSelectQuickMix,
    .helpText="select quickmix stations", .configKey="act_stationselectquickmix" },
    { .defaultKey=(char)36, .context=(enum anonymous$28)BAR_DC_SONG, .function=BarUiActDebug,
    .helpText=(const char *)(void *)0, .configKey="act_debug" },
    { .defaultKey=(char)98, .context=(enum anonymous$28)BAR_DC_SONG, .function=BarUiActBookmark,
    .helpText="bookmark song/artist", .configKey="act_bookmark" },
    { .defaultKey=(char)40, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActVolDown,
    .helpText="decrease volume", .configKey="act_voldown" },
    { .defaultKey=(char)41, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActVolUp,
    .helpText="increase volume", .configKey="act_volup" },
    { .defaultKey=(char)61, .context=(enum anonymous$28)BAR_DC_STATION, .function=BarUiActManageStation,
    .helpText="delete seeds/feedback", .configKey="act_managestation" },
    { .defaultKey=(char)32, .context=(enum anonymous$28)(BAR_DC_GLOBAL | BAR_DC_STATION), .function=BarUiActTogglePause,
    .helpText=(const char *)(void *)0, .configKey="act_songpausetoggle2" },
    { .defaultKey=(char)118, .context=(enum anonymous$28)BAR_DC_SONG, .function=BarUiActCreateStationFromSong,
    .helpText="create new station from song or artist",
    .configKey="act_stationcreatefromsong" },
    { .defaultKey=(char)80, .context=(enum anonymous$28)(BAR_DC_GLOBAL | BAR_DC_STATION), .function=BarUiActPlay,
    .helpText="resume playback", .configKey="act_songplay" },
    { .defaultKey=(char)83, .context=(enum anonymous$28)(BAR_DC_GLOBAL | BAR_DC_STATION), .function=BarUiActPause,
    .helpText="pause playback", .configKey="act_songpause" },
    { .defaultKey=(char)94, .context=(enum anonymous$28)BAR_DC_GLOBAL, .function=BarUiActVolReset,
    .helpText="reset volume", .configKey="act_volreset" } };
// restore
// file src/terminal.c line 34
static struct termios restore;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;

// BarGetXdgConfigDir
// file src/settings.c line 69
static char * BarGetXdgConfigDir(const char * const filename)
{
  /* assertion filename != ((void *)0) */
  assert(filename != (const char *)(void *)0);
  char *xdgConfigDir;
  xdgConfigDir=getenv("XDG_CONFIG_HOME");
  unsigned long int return_value_strlen$4;
  if(!(xdgConfigDir == ((char *)NULL)))
  {
    return_value_strlen$4=strlen(xdgConfigDir);
    if(return_value_strlen$4 >= 1ul)
    {
      unsigned long int len;
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(xdgConfigDir);
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(filename);
      len = return_value_strlen$1 + (unsigned long int)1 + return_value_strlen$2 + (unsigned long int)1;
      char *concat;
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(len * sizeof(char) /*1ul*/ );
      concat = (char *)return_value_malloc$3;
      snprintf(concat, len, "%s/%s", xdgConfigDir, filename);
      return concat;
    }

  }

  return (char *)(void *)0;
}

// BarMainGetInitialStation
// file src/main.c line 203
static void BarMainGetInitialStation(struct anonymous$35 *app)
{
  if(!(app->settings.autostartStation == ((char *)NULL)))
  {
    app->curStation=PianoFindStationById(app->ph.stations, app->settings.autostartStation);
    if(app->curStation == ((struct PianoStation *)NULL))
      BarUiMsg(&app->settings, (const enum anonymous$34)MSG_ERR, "Error: Autostart station not found.\n");

  }

  if(app->curStation == ((struct PianoStation *)NULL))
    app->curStation=BarUiSelectStation(app, app->ph.stations, "Select station: ", (void (*)(struct anonymous$35 *, char *))(void *)0, app->settings.autoselect);

  if(!(app->curStation == ((struct PianoStation *)NULL)))
    BarUiPrintStation(&app->settings, app->curStation);

}

// BarMainGetLoginCredentials
// file src/main.c line 107
static _Bool BarMainGetLoginCredentials(struct anonymous$33 *settings, struct anonymous$40 *input)
{
  _Bool usernameFromConfig = (_Bool)1;
  if(settings->username == ((char *)NULL))
  {
    char nameBuf[100l];
    BarUiMsg(settings, (const enum anonymous$34)MSG_QUESTION, "Email: ");
    BarReadlineStr(nameBuf, sizeof(char [100l]) /*100ul*/ , input, (const enum anonymous$45)BAR_RL_DEFAULT);
    settings->username=strdup(nameBuf);
    usernameFromConfig = (_Bool)0;
  }

  if(settings->password == ((char *)NULL))
  {
    char passBuf[100l];
    if(!(usernameFromConfig == (_Bool)0))
      BarUiMsg(settings, (const enum anonymous$34)MSG_QUESTION, "Email: %s\n", settings->username);

    if(settings->passwordCmd == ((char *)NULL))
    {
      BarUiMsg(settings, (const enum anonymous$34)MSG_QUESTION, "Password: ");
      BarReadlineStr(passBuf, sizeof(char [100l]) /*100ul*/ , input, (const enum anonymous$45)BAR_RL_NOECHO);
      puts("");
      settings->password=strdup(passBuf);
    }

    else
    {
      signed int chld;
      signed int pipeFd[2l];
      BarUiMsg(settings, (const enum anonymous$34)MSG_INFO, "Requesting password from external helper... ");
      signed int return_value_pipe$3;
      return_value_pipe$3=pipe(pipeFd);
      if(return_value_pipe$3 == -1)
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        char *return_value_strerror$2;
        return_value_strerror$2=strerror(*return_value___errno_location$1);
        BarUiMsg(settings, (const enum anonymous$34)MSG_NONE, "Error: %s\n", return_value_strerror$2);
        return (_Bool)0;
      }

      chld=fork();
      if(chld == 0)
      {
        close(pipeFd[(signed long int)0]);
        signed int return_value_fileno$4;
        return_value_fileno$4=fileno(stdout);
        dup2(pipeFd[(signed long int)1], return_value_fileno$4);
        execl("/bin/sh", "/bin/sh", (const void *)"-c", settings->passwordCmd, (char *)(void *)0);
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        char *return_value_strerror$6;
        return_value_strerror$6=strerror(*return_value___errno_location$5);
        BarUiMsg(settings, (const enum anonymous$34)MSG_NONE, "Error: %s\n", return_value_strerror$6);
        close(pipeFd[(signed long int)1]);
        exit(1);
      }

      else
        if(chld == -1)
        {
          signed int *return_value___errno_location$7;
          return_value___errno_location$7=__errno_location();
          char *return_value_strerror$8;
          return_value_strerror$8=strerror(*return_value___errno_location$7);
          BarUiMsg(settings, (const enum anonymous$34)MSG_NONE, "Error: %s\n", return_value_strerror$8);
          return (_Bool)0;
        }

        else
        {
          signed int status;
          close(pipeFd[(signed long int)1]);
          memset((void *)passBuf, 0, sizeof(char [100l]) /*100ul*/ );
          read(pipeFd[(signed long int)0], (void *)passBuf, sizeof(char [100l]) /*100ul*/  - (unsigned long int)1);
          close(pipeFd[(signed long int)0]);
          signed long int len;
          unsigned long int return_value_strlen$9;
          return_value_strlen$9=strlen(passBuf);
          len = (signed long int)(return_value_strlen$9 - (unsigned long int)1);
          for( ; len >= 0l; len = len - 1l)
          {
            if(!((signed int)passBuf[len] == 10))
              break;

            passBuf[len] = (char)0;
          }
          waitpid(chld, &status, 0);
          if((0xff00 & status) >> 8 == 0)
          {
            settings->password=strdup(passBuf);
            BarUiMsg(settings, (const enum anonymous$34)MSG_NONE, "Ok.\n");
          }

          else
          {
            /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous$53
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
            ;
            BarUiMsg(settings, (const enum anonymous$34)MSG_NONE, "Error: Exit status %i.\n", (((union anonymous$53){ .__in=status }).__i & 0xff00) >> 8);
            return (_Bool)0;
          }
        }
    }
  }

  return (_Bool)1;
}

// BarMainGetPlaylist
// file src/main.c line 236
static void BarMainGetPlaylist(struct anonymous$35 *app)
{
  enum anonymous$4 pRet;
  enum anonymous$5 wRet;
  struct anonymous$14 reqData;
  reqData.station = app->curStation;
  reqData.quality = app->settings.audioQuality;
  BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Receiving new playlist... ");
  signed int return_value_BarUiPianoCall$1;
  return_value_BarUiPianoCall$1=BarUiPianoCall(app, (enum anonymous$2)PIANO_REQUEST_GET_PLAYLIST, (void *)&reqData, &pRet, &wRet);
  if(return_value_BarUiPianoCall$1 == 0)
    app->curStation = (struct PianoStation *)(void *)0;

  else
  {
    app->playlist = reqData.retPlaylist;
    if(app->playlist == ((struct PianoSong *)NULL))
    {
      BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "No tracks left.\n");
      app->curStation = (struct PianoStation *)(void *)0;
    }

  }
  BarUiStartEventCmd(&app->settings, "stationfetchplaylist", app->curStation, app->playlist, &app->player, app->ph.stations, pRet, wRet);
}

// BarMainGetStations
// file src/main.c line 189
static _Bool BarMainGetStations(struct anonymous$35 *app)
{
  enum anonymous$4 pRet;
  enum anonymous$5 wRet;
  _Bool ret;
  BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Get stations... ");
  signed int return_value_BarUiPianoCall$1;
  return_value_BarUiPianoCall$1=BarUiPianoCall(app, (enum anonymous$2)PIANO_REQUEST_GET_STATIONS, (void *)0, &pRet, &wRet);
  ret = (_Bool)return_value_BarUiPianoCall$1;
  BarUiStartEventCmd(&app->settings, "usergetstations", (const struct PianoStation *)(void *)0, (const struct PianoSong *)(void *)0, &app->player, app->ph.stations, pRet, wRet);
  return ret;
}

// BarMainHandleUserInput
// file src/main.c line 225
static void BarMainHandleUserInput(struct anonymous$35 *app)
{
  char buf[2l];
  unsigned long int return_value_BarReadline$1;
  return_value_BarReadline$1=BarReadline(buf, sizeof(char [2l]) /*2ul*/ , (const char *)(void *)0, &app->input, (const enum anonymous$45)(BAR_RL_FULLRETURN | BAR_RL_NOECHO), 1);
  if(return_value_BarReadline$1 >= 1ul)
    BarUiDispatch(app, buf[(signed long int)0], app->curStation, app->playlist, (const _Bool)1, (enum anonymous$28)BAR_DC_GLOBAL);

}

// BarMainLoadProxy
// file src/main.c line 66
static void BarMainLoadProxy(const struct anonymous$33 *settings, struct anonymous$7 *waith)
{
  unsigned long int return_value_strlen$3;
  if(!(settings->controlProxy == ((char *)NULL)))
  {
    _Bool return_value_WaitressSetProxy$1;
    return_value_WaitressSetProxy$1=WaitressSetProxy(waith, settings->controlProxy);
    if(return_value_WaitressSetProxy$1 == (_Bool)0)
      BarUiMsg(settings, (const enum anonymous$34)MSG_ERR, "Control proxy (%s) is invalid!\n", settings->controlProxy);

  }

  else
    if(!(settings->proxy == ((char *)NULL)))
    {
      return_value_strlen$3=strlen(settings->proxy);
      if(return_value_strlen$3 >= 1ul)
      {
        _Bool return_value_WaitressSetProxy$2;
        return_value_WaitressSetProxy$2=WaitressSetProxy(waith, settings->proxy);
        if(return_value_WaitressSetProxy$2 == (_Bool)0)
          BarUiMsg(settings, (const enum anonymous$34)MSG_ERR, "Proxy (%s) is invalid!\n", settings->proxy);

      }

    }

}

// BarMainLoginUser
// file src/main.c line 88
static _Bool BarMainLoginUser(struct anonymous$35 *app)
{
  enum anonymous$4 pRet;
  enum anonymous$5 wRet;
  struct anonymous$13 reqData;
  _Bool ret;
  reqData.user = app->settings.username;
  reqData.password = app->settings.password;
  reqData.step = (unsigned char)0;
  BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Login... ");
  signed int return_value_BarUiPianoCall$1;
  return_value_BarUiPianoCall$1=BarUiPianoCall(app, (enum anonymous$2)PIANO_REQUEST_LOGIN, (void *)&reqData, &pRet, &wRet);
  ret = (_Bool)return_value_BarUiPianoCall$1;
  BarUiStartEventCmd(&app->settings, "userlogin", (const struct PianoStation *)(void *)0, (const struct PianoSong *)(void *)0, &app->player, (struct PianoStation *)(void *)0, pRet, wRet);
  return ret;
}

// BarMainLoop
// file src/main.c line 354
static void BarMainLoop(struct anonymous$35 *app)
{
  unsigned long int playerThread;
  _Bool return_value_BarMainGetLoginCredentials$1;
  return_value_BarMainGetLoginCredentials$1=BarMainGetLoginCredentials(&app->settings, &app->input);
  if(!(return_value_BarMainGetLoginCredentials$1 == (_Bool)0))
  {
    BarMainLoadProxy(&app->settings, &app->waith);
    _Bool return_value_BarMainLoginUser$2;
    return_value_BarMainLoginUser$2=BarMainLoginUser(app);
    if(!(return_value_BarMainLoginUser$2 == (_Bool)0))
    {
      _Bool return_value_BarMainGetStations$3;
      return_value_BarMainGetStations$3=BarMainGetStations(app);
      if(!(return_value_BarMainGetStations$3 == (_Bool)0))
      {
        BarMainGetInitialStation(app);
        memset((void *)&app->player, 0, sizeof(struct anonymous$3) /*216ul*/ );
        while(app->doQuit == 0)
        {
          if((signed int)app->player.mode == PLAYER_FINISHED)
            BarMainPlayerCleanup(app, &playerThread);

          if((signed int)app->player.mode == PLAYER_DEAD)
          {
            if(!(app->curStation == ((struct PianoStation *)NULL)))
            {
              if(!(app->playlist == ((struct PianoSong *)NULL)))
              {
                struct PianoSong *histsong = app->playlist;
                app->playlist = (struct PianoSong *)(void *)app->playlist->head.next;
                histsong->head.next = (struct PianoListHead *)(void *)0;
                BarUiHistoryPrepend(app, histsong);
              }

              if(app->playlist == ((struct PianoSong *)NULL))
                BarMainGetPlaylist(app);

              if(!(app->playlist == ((struct PianoSong *)NULL)))
                BarMainStartPlayback(app, &playerThread);

            }

          }

          BarMainHandleUserInput(app);
          if((signed int)app->player.mode == PLAYER_PLAYING)
            BarMainPrintTime(app);

        }
        if(!((signed int)app->player.mode == PLAYER_DEAD))
          pthread_join(playerThread, (void **)(void *)0);

      }

    }

  }

}

// BarMainPlayerCleanup
// file src/main.c line 304
static void BarMainPlayerCleanup(struct anonymous$35 *app, unsigned long int *playerThread)
{
  void *threadRet;
  BarUiStartEventCmd(&app->settings, "songfinish", app->curStation, app->playlist, &app->player, app->ph.stations, (enum anonymous$4)PIANO_RET_OK, (enum anonymous$5)WAITRESS_RET_OK);
  pthread_join(*playerThread, &threadRet);
  pthread_cond_destroy(&app->player.pauseCond);
  pthread_mutex_destroy(&app->player.pauseMutex);
  if(threadRet == NULL)
    app->playerErrors = (unsigned int)0;

  else
    if(threadRet == (void *)2)
    {
      app->playerErrors = app->playerErrors + 1u;
      if(app->playerErrors >= app->settings.maxPlayerErrors)
        app->curStation = (struct PianoStation *)(void *)0;

    }

    else
      app->curStation = (struct PianoStation *)(void *)0;
  memset((void *)&app->player, 0, sizeof(struct anonymous$3) /*216ul*/ );
}

// BarMainPrintTime
// file src/main.c line 334
static void BarMainPrintTime(struct anonymous$35 *app)
{
  unsigned int songRemaining;
  char sign;
  if(app->player.songDuration >= app->player.songPlayed)
  {
    songRemaining = app->player.songDuration - app->player.songPlayed;
    sign = (char)45;
  }

  else
  {
    songRemaining = app->player.songPlayed - app->player.songDuration;
    sign = (char)43;
  }
  BarUiMsg(&app->settings, (const enum anonymous$34)MSG_TIME, "%c%02u:%02u/%02u:%02u\r", sign, songRemaining / (unsigned int)60, songRemaining % (unsigned int)60, app->player.songDuration / (unsigned int)60, app->player.songDuration % (unsigned int)60);
}

// BarMainStartPlayback
// file src/main.c line 261
static void BarMainStartPlayback(struct anonymous$35 *app, unsigned long int *playerThread)
{
  /* assertion app != ((void *)0) */
  assert(app != (struct anonymous$35 *)(void *)0);
  /* assertion playerThread != ((void *)0) */
  assert(playerThread != (unsigned long int *)(void *)0);
  const struct PianoSong * const curSong = app->playlist;
  /* assertion curSong != ((void *)0) */
  assert(curSong != (const struct PianoSong *)(void *)0);
  struct PianoStation *tmp_if_expr$2;
  struct PianoStation *return_value_PianoFindStationById$1;
  if(!(app->curStation->isQuickMix == 0))
  {
    return_value_PianoFindStationById$1=PianoFindStationById(app->ph.stations, curSong->stationId);
    tmp_if_expr$2 = return_value_PianoFindStationById$1;
  }

  else
    tmp_if_expr$2 = (struct PianoStation *)(void *)0;
  BarUiPrintSong(&app->settings, curSong, tmp_if_expr$2);
  _Bool tmp_if_expr$5;
  unsigned long int return_value_strlen$3;
  signed int return_value_strncmp$4;
  if(curSong->audioUrl == ((char *)NULL))
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    static const char httpPrefix[8l] = { 'h', 't', 't', 'p', ':', '/', '/', 0 };
    return_value_strlen$3=strlen(httpPrefix);
    return_value_strncmp$4=strncmp(curSong->audioUrl, httpPrefix, return_value_strlen$3);
    tmp_if_expr$5 = return_value_strncmp$4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$5)
    BarUiMsg(&app->settings, (const enum anonymous$34)MSG_ERR, "Invalid song url.\n");

  else
  {
    memset((void *)&app->player, 0, sizeof(struct anonymous$3) /*216ul*/ );
    app->player.url = curSong->audioUrl;
    app->player.gain = (double)curSong->fileGain;
    app->player.settings = &app->settings;
    app->player.songDuration = curSong->length;
    pthread_mutex_init(&app->player.pauseMutex, (const union anonymous$0 *)(void *)0);
    pthread_cond_init(&app->player.pauseCond, (const union anonymous$0 *)(void *)0);
    BarUiStartEventCmd(&app->settings, "songstart", app->curStation, curSong, &app->player, app->ph.stations, (enum anonymous$4)PIANO_RET_OK, (enum anonymous$5)WAITRESS_RET_OK);
    app->player.mode = (enum anonymous$41)PLAYER_STARTING;
    pthread_create(playerThread, (const union pthread_attr_t *)(void *)0, BarPlayerThread, (void *)&app->player);
  }
}

// BarPianoHttpRequest
// file src/ui.c line 138
static enum anonymous$5 BarPianoHttpRequest(struct anonymous$7 *waith, struct PianoRequest *req)
{
  waith->extraHeaders = "Content-Type: text/plain\r\n";
  waith->postData = req->postData;
  waith->method = (enum anonymous$22)WAITRESS_METHOD_POST;
  waith->url.path = req->urlPath;
  waith->url.tls = req->secure;
  enum anonymous$5 return_value_WaitressFetchBuf$1;
  return_value_WaitressFetchBuf$1=WaitressFetchBuf(waith, &req->responseData);
  return return_value_WaitressFetchBuf$1;
}

// BarPlayerDestroy
// file src/player.h line 88
void BarPlayerDestroy()
{
  avformat_network_deinit();
  avfilter_uninit();
  ao_shutdown();
}

// BarPlayerInit
// file src/player.h line 87
void BarPlayerInit()
{
  ao_initialize();
  av_register_all();
  avfilter_register_all();
  avformat_network_init();
}

// BarPlayerSetVolume
// file src/player.c line 86
void BarPlayerSetVolume(struct anonymous$3 * const player)
{
  /* assertion player != ((void *)0) */
  assert(player != (struct anonymous$3 *)(void *)0);
  /* assertion player->fvolume != ((void *)0) */
  assert(player->fvolume != (struct AVFilterContext *)(void *)0);
  signed int ret;
  char strbuf[16l];
  snprintf(strbuf, sizeof(char [16l]) /*16ul*/ , "%fdB", (double)player->settings->volume + player->gain);
  ret=avfilter_graph_send_command(player->fgraph, "volume", "volume", strbuf, (char *)(void *)0, 0, 0);
  if(!(ret >= 0))
    printError(player->settings, "Cannot set volume", ret);

}

// BarPlayerThread
// file src/player.h line 85
void * BarPlayerThread(void *data)
{
  /* assertion data != ((void *)0) */
  assert(data != (void *)0);
  struct anonymous$3 * const player = (struct anonymous$3 *)data;
  signed long int pret = (signed long int)0;
  _Bool retry;
  _Bool tmp_if_expr$4;
  _Bool return_value_openDevice$3;
  do
  {
    retry = (_Bool)0;
    _Bool return_value_openStream$5;
    return_value_openStream$5=openStream(player);
    if(!(return_value_openStream$5 == (_Bool)0))
    {
      _Bool return_value_openFilter$2;
      return_value_openFilter$2=openFilter(player);
      if(!(return_value_openFilter$2 == (_Bool)0))
      {
        return_value_openDevice$3=openDevice(player);
        tmp_if_expr$4 = return_value_openDevice$3 != (_Bool)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$4 = (_Bool)0;
      if(tmp_if_expr$4)
      {
        signed int return_value_play$1;
        return_value_play$1=play(player);
        retry = return_value_play$1 == -((signed int)((unsigned int)(73 | 78 << 8 | 68 << 16) | (unsigned int)65 << 24));
      }

      else
        pret = (signed long int)1;
    }

    else
      pret = (signed long int)2;
    finish(player);
  }
  while(retry != (_Bool)0);
  player->mode = (enum anonymous$41)PLAYER_FINISHED;
  return (void *)pret;
}

// BarReadline
// file src/ui_readline.h line 42
unsigned long int BarReadline(char *buf, const unsigned long int bufSize, const char *mask, struct anonymous$40 *input, const enum anonymous$45 flags, signed int timeout)
{
  unsigned long int bufLen = (unsigned long int)0;
  unsigned char escapeState = (unsigned char)0;
  struct anonymous$47 set;
  const _Bool echo = !(((signed int)flags & BAR_RL_NOECHO) != 0);
  /* assertion buf != ((void *)0) */
  assert(buf != (char *)(void *)0);
  /* assertion bufSize > 0 */
  assert(bufSize > (unsigned long int)0);
  /* assertion input != ((void *)0) */
  assert(input != (struct anonymous$40 *)(void *)0);
  memset((void *)buf, 0, bufSize);
  char *return_value_strchr$3;
  while((_Bool)1)
  {
    signed int curFd = -1;
    unsigned char chr;
    struct timeval timeoutstruct;
    memcpy((void *)&set, (const void *)&input->set, sizeof(struct anonymous$47) /*128ul*/ );
    timeoutstruct.tv_sec = (signed long int)timeout;
    timeoutstruct.tv_usec = (signed long int)0;
    signed int return_value_select$1;
    return_value_select$1=select(input->maxfd, &set, (struct anonymous$47 *)(void *)0, (struct anonymous$47 *)(void *)0, timeout == -1 ? (struct timeval *)(void *)0 : &timeoutstruct);
    if(!(return_value_select$1 >= 1))
      break;

    /* assertion sizeof (input->fds) / sizeof (*input->fds) == 2 */
    assert(sizeof(signed int [2l]) /*8ul*/  / sizeof(signed int) /*4ul*/  == (unsigned long int)2);
    if(!((set.__fds_bits[(signed long int)(input->fds[0l] / 8)] & 1l << input->fds[0l] % 8) == 0l))
      curFd = input->fds[(signed long int)0];

    else
      if(!(input->fds[1l] == -1))
      {
        if(!((set.__fds_bits[(signed long int)(input->fds[1l] / 8)] & 1l << input->fds[1l] % 8) == 0l))
          curFd = input->fds[(signed long int)1];

      }

    signed long int return_value_read$2;
    return_value_read$2=read(curFd, (void *)&chr, sizeof(unsigned char) /*1ul*/ );
    if(!(return_value_read$2 >= 1l))
    {
      if(curFd == 0)
        (&input->set)->__fds_bits[(signed long int)(curFd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&input->set)->__fds_bits[(signed long int)(curFd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & ~((signed long int)1 << curFd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));

    }

    else
      switch((signed int)chr)
      {
        case 4:

        case 10:
        {
          if(!(echo == (_Bool)0))
            fputs("\n", stdout);

          buf[(signed long int)bufLen] = (char)0;
          return bufLen;
        }
        case 21:
        {
          if(!(echo == (_Bool)0))
          {
            while(bufLen >= 1ul)
            {
              unsigned long int moveSize;
              moveSize=BarReadlinePrevUtf8(&buf[(signed long int)bufLen]);
              /* assertion bufLen >= moveSize */
              assert(bufLen >= moveSize);
              fputs("\033[D\033[K", stdout);
              bufLen = bufLen - moveSize;
            }
            fflush(stdout);
          }

          bufLen = (unsigned long int)0;
          break;
        }
        case 27:
        {
          escapeState = (unsigned char)1;
          break;
        }
        case 126:
          break;
        case 8:

        case 127:
        {
          if(bufLen >= 1ul)
          {
            unsigned long int BarReadline$$1$$1$$5$$3$$moveSize;
            BarReadline$$1$$1$$5$$3$$moveSize=BarReadlinePrevUtf8(&buf[(signed long int)bufLen]);
            /* assertion bufLen >= moveSize */
            assert(bufLen >= BarReadline$$1$$1$$5$$3$$moveSize);
            memmove((void *)&buf[(signed long int)(bufLen - BarReadline$$1$$1$$5$$3$$moveSize)], (const void *)&buf[(signed long int)bufLen], BarReadline$$1$$1$$5$$3$$moveSize);
            bufLen = bufLen - BarReadline$$1$$1$$5$$3$$moveSize;
            if(!(echo == (_Bool)0))
            {
              fputs("\033[D\033[K", stdout);
              fflush(stdout);
            }

          }

          break;
        }
        default:
        {
          if(!((signed int)chr >= 32))
            break;

          if((signed int)escapeState == 2)
          {
            escapeState = (unsigned char)0;
            break;
          }

          if((signed int)chr == 91 && (signed int)escapeState == 1)
          {
            escapeState = (unsigned char)2;
            break;
          }

          if(!(mask == ((const char *)NULL)))
          {
            return_value_strchr$3=strchr(mask, (signed int)chr);
            if(return_value_strchr$3 == ((char *)NULL))
              break;

          }

          if(!(bufLen >= bufSize + 18446744073709551615ul))
          {
            buf[(signed long int)bufLen] = (char)chr;
            bufLen = bufLen + 1ul;
            if(!(echo == (_Bool)0))
            {
              putchar((signed int)chr);
              fflush(stdout);
            }

            if(bufLen >= bufSize + 18446744073709551615ul && !((BAR_RL_FULLRETURN & (signed int)flags) == 0))
            {
              if(!(echo == (_Bool)0))
                fputs("\n", stdout);

              buf[(signed long int)bufLen] = (char)0;
              return bufLen;
            }

          }

        }
      }
  }
  buf[(signed long int)0] = (char)0;
  return (unsigned long int)0;
}

// BarReadlineInt
// file src/ui_readline.h line 46
unsigned long int BarReadlineInt(signed int *ret, struct anonymous$40 *input)
{
  signed int rlRet = 0;
  char buf[16l];
  unsigned long int return_value_BarReadline$1;
  return_value_BarReadline$1=BarReadline(buf, sizeof(char [16l]) /*16ul*/ , "0123456789", input, (const enum anonymous$45)BAR_RL_DEFAULT, -1);
  rlRet = (signed int)return_value_BarReadline$1;
  *ret=atoi((char *)buf);
  return (unsigned long int)rlRet;
}

// BarReadlinePrevUtf8
// file src/ui_readline.c line 34
static unsigned long int BarReadlinePrevUtf8(char *ptr)
{
  unsigned long int i = (unsigned long int)0;
  _Bool tmp_if_expr$1;
  do
  {
    i = i + 1ul;
    ptr = ptr - 1l;
    if(!((128 & (signed int)*ptr) == 0))
      tmp_if_expr$1 = !(((signed int)*ptr & 1 << 6) != 0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
  }
  while(tmp_if_expr$1);
  return i;
}

// BarReadlineStr
// file src/ui_readline.h line 44
unsigned long int BarReadlineStr(char *buf, const unsigned long int bufSize, struct anonymous$40 *input, const enum anonymous$45 flags)
{
  unsigned long int return_value_BarReadline$1;
  return_value_BarReadline$1=BarReadline(buf, bufSize, (const char *)(void *)0, input, flags, -1);
  return return_value_BarReadline$1;
}

// BarReadlineYesNo
// file src/ui_readline.h line 47
_Bool BarReadlineYesNo(_Bool def, struct anonymous$40 *input)
{
  char buf[2l];
  BarReadline(buf, sizeof(char [2l]) /*2ul*/ , "yYnN", input, (const enum anonymous$45)BAR_RL_FULLRETURN, -1);
  _Bool tmp_if_expr$1;
  if((signed int)buf[0l] == 121)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)buf[0l] == 89 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    if((signed int)def == 1)
      tmp_if_expr$2 = (signed int)buf[0l] == 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3)
    return (_Bool)1;

  else
    return (_Bool)0;
}

// BarSettingsDestroy
// file src/settings.h line 114
void BarSettingsDestroy(struct anonymous$33 *settings)
{
  free((void *)settings->controlProxy);
  free((void *)settings->proxy);
  free((void *)settings->username);
  free((void *)settings->password);
  free((void *)settings->passwordCmd);
  free((void *)settings->autostartStation);
  free((void *)settings->eventCmd);
  free((void *)settings->loveIcon);
  free((void *)settings->banIcon);
  free((void *)settings->atIcon);
  free((void *)settings->npSongFormat);
  free((void *)settings->npStationFormat);
  free((void *)settings->listSongFormat);
  free((void *)settings->fifo);
  free((void *)settings->rpcHost);
  free((void *)settings->rpcTlsPort);
  free((void *)settings->partnerUser);
  free((void *)settings->partnerPassword);
  free((void *)settings->device);
  free((void *)settings->inkey);
  free((void *)settings->outkey);
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= 7ul); i = i + 1ul)
  {
    free((void *)settings->msgFormat[(signed long int)i].prefix);
    free((void *)settings->msgFormat[(signed long int)i].postfix);
  }
  memset((void *)settings, 0, sizeof(struct anonymous$33) /*360ul*/ );
}

// BarSettingsExpandTilde
// file src/settings.c line 88
char * BarSettingsExpandTilde(const char * const path, const char * const home)
{
  /* assertion path != ((void *)0) */
  assert(path != (const char *)(void *)0);
  /* assertion home != ((void *)0) */
  assert(home != (const char *)(void *)0);
  signed int return_value_strncmp$4;
  return_value_strncmp$4=strncmp(path, "~/", (unsigned long int)2);
  if(return_value_strncmp$4 == 0)
  {
    char *expanded;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(home);
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(path);
    void *return_value_malloc$3;
    return_value_malloc$3=malloc((((return_value_strlen$1 + (unsigned long int)1 + return_value_strlen$2) - (unsigned long int)2) + (unsigned long int)1) * sizeof(char) /*1ul*/ );
    expanded = (char *)return_value_malloc$3;
    sprintf(expanded, "%s/%s", home, &path[(signed long int)2]);
    return expanded;
  }

  char *return_value_strdup$5;
  return_value_strdup$5=strdup(path);
  return return_value_strdup$5;
}

// BarSettingsGetHome
// file src/settings.c line 50
static char * BarSettingsGetHome()
{
  char *home;
  home=getenv("HOME");
  unsigned long int return_value_strlen$2;
  if(!(home == ((char *)NULL)))
  {
    return_value_strlen$2=strlen(home);
    if(return_value_strlen$2 >= 1ul)
    {
      char *return_value_strdup$1;
      return_value_strdup$1=strdup(home);
      return return_value_strdup$1;
    }

  }

  struct passwd *pw;
  unsigned int return_value_getuid$3;
  return_value_getuid$3=getuid();
  pw=getpwuid(return_value_getuid$3);
  unsigned long int return_value_strlen$5;
  if(!(pw == ((struct passwd *)NULL)))
  {
    if(!(pw->pw_dir == ((char *)NULL)))
    {
      return_value_strlen$5=strlen(pw->pw_dir);
      if(return_value_strlen$5 >= 1ul)
      {
        char *return_value_strdup$4;
        return_value_strdup$4=strdup(pw->pw_dir);
        return return_value_strdup$4;
      }

    }

  }

  return (char *)(void *)0;
}

// BarSettingsInit
// file src/settings.h line 113
void BarSettingsInit(struct anonymous$33 *settings)
{
  memset((void *)settings, 0, sizeof(struct anonymous$33) /*360ul*/ );
}

// BarSettingsRead
// file src/settings.h line 115
void BarSettingsRead(struct anonymous$33 *settings)
{
  char * const configfiles[2l] = { "pianobar/state", "pianobar/config" };
  char *userhome;
  userhome=BarSettingsGetHome();
  /* assertion userhome != ((void *)0) */
  assert(userhome != (char *)(void *)0);
  char *defaultxdg;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(userhome);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen("/.config");
  void *return_value_malloc$3;
  return_value_malloc$3=malloc(return_value_strlen$1 + return_value_strlen$2 + (unsigned long int)1);
  defaultxdg = (char *)return_value_malloc$3;
  sprintf(defaultxdg, "%s/.config", userhome);
  setenv("XDG_CONFIG_HOME", defaultxdg, 0);
  free((void *)defaultxdg);
  /* assertion sizeof (settings->keys) / sizeof (*settings->keys) == sizeof (dispatchActions) / sizeof (*dispatchActions) */
  assert(sizeof(char [29l]) /*29ul*/  / sizeof(char) /*1ul*/  == sizeof(const struct anonymous$31 [29l]) /*928ul*/  / sizeof(const struct anonymous$31) /*32ul*/ );
  settings->audioQuality = (enum anonymous$1)PIANO_AQ_HIGH;
  settings->autoselect = (_Bool)1;
  settings->history = (unsigned int)5;
  settings->volume = 0;
  settings->maxPlayerErrors = (unsigned int)5;
  settings->sortOrder = (enum anonymous$38)BAR_SORT_NAME_AZ;
  settings->loveIcon=strdup(" <3");
  settings->banIcon=strdup(" </3");
  settings->atIcon=strdup(" @ ");
  settings->npSongFormat=strdup("\"%t\" by \"%a\" on \"%l\"%r%@%s");
  settings->npStationFormat=strdup("Station \"%n\" (%i)");
  settings->listSongFormat=strdup("%i) %a - %t%r");
  settings->rpcHost=strdup("tuner.pandora.com");
  settings->rpcTlsPort = (char *)(void *)0;
  settings->partnerUser=strdup("android");
  settings->partnerPassword=strdup("AC7IBG09A3DTSYM4R41UJWL07VLN8JI7");
  settings->device=strdup("android-generic");
  settings->inkey=strdup("R=U!LH$O2B#");
  settings->outkey=strdup("6#26FRL$ZWD");
  settings->fifo=BarGetXdgConfigDir("pianobar/ctl");
  /* assertion settings->fifo != ((void *)0) */
  assert(settings->fifo != (char *)(void *)0);
  memcpy((void *)settings->tlsFingerprint, (const void *)"-\noK\\\nC\035GRSU\a", sizeof(char [20l]) /*20ul*/ );
  settings->msgFormat[(signed long int)MSG_NONE].prefix = (char *)(void *)0;
  settings->msgFormat[(signed long int)MSG_NONE].postfix = (char *)(void *)0;
  settings->msgFormat[(signed long int)MSG_INFO].prefix=strdup("(i) ");
  settings->msgFormat[(signed long int)MSG_INFO].postfix = (char *)(void *)0;
  settings->msgFormat[(signed long int)MSG_PLAYING].prefix=strdup("|>  ");
  settings->msgFormat[(signed long int)MSG_PLAYING].postfix = (char *)(void *)0;
  settings->msgFormat[(signed long int)MSG_TIME].prefix=strdup("#   ");
  settings->msgFormat[(signed long int)MSG_TIME].postfix = (char *)(void *)0;
  settings->msgFormat[(signed long int)MSG_ERR].prefix=strdup("/!\\ ");
  settings->msgFormat[(signed long int)MSG_ERR].postfix = (char *)(void *)0;
  settings->msgFormat[(signed long int)MSG_QUESTION].prefix=strdup("[?] ");
  settings->msgFormat[(signed long int)MSG_QUESTION].postfix = (char *)(void *)0;
  settings->msgFormat[(signed long int)MSG_LIST].prefix=strdup("\t");
  settings->msgFormat[(signed long int)MSG_LIST].postfix = (char *)(void *)0;
  unsigned long int BarSettingsRead$$1$$1$$i = (unsigned long int)0;
  for( ; !(BarSettingsRead$$1$$1$$i >= 29ul); BarSettingsRead$$1$$1$$i = BarSettingsRead$$1$$1$$i + 1ul)
    settings->keys[(signed long int)BarSettingsRead$$1$$1$$i] = dispatchActions[(signed long int)BarSettingsRead$$1$$1$$i].defaultKey;
  unsigned long int j = (unsigned long int)0;
  signed int return_value_strcmp$49;
  signed int return_value_strcmp$48;
  signed int return_value_strcmp$47;
  signed int return_value_strcmp$46;
  signed int return_value_strcmp$45;
  signed int return_value_strcmp$44;
  signed int return_value_strcmp$43;
  signed int return_value_strcmp$42;
  signed int return_value_strcmp$41;
  signed int return_value_strcmp$40;
  signed int return_value_strcmp$39;
  signed int return_value_memcmp$38;
  signed int return_value_strcmp$37;
  signed int return_value_strcmp$7;
  signed int return_value_strcmp$6;
  signed int return_value_strcmp$36;
  signed int return_value_strcmp$35;
  signed int return_value_strcmp$34;
  signed int return_value_strcmp$33;
  signed int return_value_strcmp$32;
  signed int return_value_strcmp$31;
  signed int return_value_strcmp$30;
  signed int return_value_strcmp$29;
  signed int return_value_strcmp$28;
  signed int return_value_strcmp$27;
  signed int return_value_strcmp$26;
  signed int return_value_strcmp$25;
  signed int return_value_strcmp$24;
  signed int return_value_strcmp$23;
  signed int return_value_strcmp$22;
  unsigned long int return_value_strlen$20;
  signed int return_value_strncmp$21;
  for( ; !(j >= 2ul); j = j + 1ul)
  {
    char key[256l];
    char val[256l];
    struct _IO_FILE *configfd;
    char *path;
    path=BarGetXdgConfigDir(configfiles[(signed long int)j]);
    /* assertion path != ((void *)0) */
    assert(path != (char *)(void *)0);
    configfd=fopen(path, "r");
    if(configfd == ((struct _IO_FILE *)NULL))
      free((void *)path);

    else
    {
      while((_Bool)1)
      {
        char lwhite;
        char rwhite;
        signed int scanRet;
        scanRet=fscanf(configfd, "%255s%c=%c%255[^\n]", (const void *)key, &lwhite, &rwhite, (const void *)val);
        if(scanRet == -1)
          break;

        else
          if(!(scanRet == 4) || !((signed int)lwhite == 32) || !((signed int)rwhite == 32))
            continue;

        signed int return_value_strcmp$50;
        return_value_strcmp$50=strcmp("control_proxy", key);
        if(return_value_strcmp$50 == 0)
          settings->controlProxy=strdup(val);

        else
        {
          return_value_strcmp$49=strcmp("proxy", key);
          if(return_value_strcmp$49 == 0)
            settings->proxy=strdup(val);

          else
          {
            return_value_strcmp$48=strcmp("user", key);
            if(return_value_strcmp$48 == 0)
              settings->username=strdup(val);

            else
            {
              return_value_strcmp$47=strcmp("password", key);
              if(return_value_strcmp$47 == 0)
                settings->password=strdup(val);

              else
              {
                return_value_strcmp$46=strcmp("password_command", key);
                if(return_value_strcmp$46 == 0)
                  settings->passwordCmd=strdup(val);

                else
                {
                  return_value_strcmp$45=strcmp("rpc_host", key);
                  if(return_value_strcmp$45 == 0)
                  {
                    free((void *)settings->rpcHost);
                    settings->rpcHost=strdup(val);
                  }

                  else
                  {
                    return_value_strcmp$44=strcmp("rpc_tls_port", key);
                    if(return_value_strcmp$44 == 0)
                    {
                      free((void *)settings->rpcTlsPort);
                      settings->rpcTlsPort=strdup(val);
                    }

                    else
                    {
                      return_value_strcmp$43=strcmp("partner_user", key);
                      if(return_value_strcmp$43 == 0)
                      {
                        free((void *)settings->partnerUser);
                        settings->partnerUser=strdup(val);
                      }

                      else
                      {
                        return_value_strcmp$42=strcmp("partner_password", key);
                        if(return_value_strcmp$42 == 0)
                        {
                          free((void *)settings->partnerPassword);
                          settings->partnerPassword=strdup(val);
                        }

                        else
                        {
                          return_value_strcmp$41=strcmp("device", key);
                          if(return_value_strcmp$41 == 0)
                          {
                            free((void *)settings->device);
                            settings->device=strdup(val);
                          }

                          else
                          {
                            return_value_strcmp$40=strcmp("encrypt_password", key);
                            if(return_value_strcmp$40 == 0)
                            {
                              free((void *)settings->outkey);
                              settings->outkey=strdup(val);
                            }

                            else
                            {
                              return_value_strcmp$39=strcmp("decrypt_password", key);
                              if(return_value_strcmp$39 == 0)
                              {
                                free((void *)settings->inkey);
                                settings->inkey=strdup(val);
                              }

                              else
                              {
                                return_value_memcmp$38=memcmp((const void *)"act_", (const void *)key, (unsigned long int)4);
                                if(return_value_memcmp$38 == 0)
                                {
                                  unsigned long int i = (unsigned long int)0;
                                  for( ; !(i >= 29ul); i = i + 1ul)
                                  {
                                    signed int return_value_strcmp$5;
                                    return_value_strcmp$5=strcmp(dispatchActions[(signed long int)i].configKey, key);
                                    if(return_value_strcmp$5 == 0)
                                    {
                                      signed int return_value_strcmp$4;
                                      return_value_strcmp$4=strcmp(val, "disabled");
                                      if(return_value_strcmp$4 == 0)
                                        settings->keys[(signed long int)i] = (char)0;

                                      else
                                        settings->keys[(signed long int)i] = val[(signed long int)0];
                                      break;
                                    }

                                  }
                                }

                                else
                                {
                                  return_value_strcmp$37=strcmp("audio_quality", key);
                                  if(return_value_strcmp$37 == 0)
                                  {
                                    signed int return_value_strcmp$8;
                                    return_value_strcmp$8=strcmp(val, "low");
                                    if(return_value_strcmp$8 == 0)
                                      settings->audioQuality = (enum anonymous$1)PIANO_AQ_LOW;

                                    else
                                    {
                                      return_value_strcmp$7=strcmp(val, "medium");
                                      if(return_value_strcmp$7 == 0)
                                        settings->audioQuality = (enum anonymous$1)PIANO_AQ_MEDIUM;

                                      else
                                      {
                                        return_value_strcmp$6=strcmp(val, "high");
                                        if(return_value_strcmp$6 == 0)
                                          settings->audioQuality = (enum anonymous$1)PIANO_AQ_HIGH;

                                      }
                                    }
                                  }

                                  else
                                  {
                                    return_value_strcmp$36=strcmp("autostart_station", key);
                                    if(return_value_strcmp$36 == 0)
                                    {
                                      free((void *)settings->autostartStation);
                                      settings->autostartStation=strdup(val);
                                    }

                                    else
                                    {
                                      return_value_strcmp$35=strcmp("event_command", key);
                                      if(return_value_strcmp$35 == 0)
                                        settings->eventCmd=strdup(val);

                                      else
                                      {
                                        return_value_strcmp$34=strcmp("history", key);
                                        if(return_value_strcmp$34 == 0)
                                        {
                                          signed int return_value_atoi$9;
                                          return_value_atoi$9=atoi(val);
                                          settings->history = (unsigned int)return_value_atoi$9;
                                        }

                                        else
                                        {
                                          return_value_strcmp$33=strcmp("max_player_errors", key);
                                          if(return_value_strcmp$33 == 0)
                                          {
                                            signed int return_value_atoi$10;
                                            return_value_atoi$10=atoi(val);
                                            settings->maxPlayerErrors = (unsigned int)return_value_atoi$10;
                                          }

                                          else
                                          {
                                            return_value_strcmp$32=strcmp("sort", key);
                                            if(return_value_strcmp$32 == 0)
                                            {
                                              unsigned long int BarSettingsRead$$1$$2$$1$$2$$21$$i = (unsigned long int)0;
                                              for( ; !(BarSettingsRead$$1$$2$$1$$2$$21$$i >= 6ul); BarSettingsRead$$1$$2$$1$$2$$21$$i = BarSettingsRead$$1$$2$$1$$2$$21$$i + 1ul)
                                              {
                                                signed int return_value_strcmp$11;
                                                static const char *mapping[6l] = { "name_az", "name_za", "quickmix_01_name_az", "quickmix_01_name_za", "quickmix_10_name_az", "quickmix_10_name_za" };
                                                return_value_strcmp$11=strcmp(mapping[(signed long int)BarSettingsRead$$1$$2$$1$$2$$21$$i], val);
                                                if(return_value_strcmp$11 == 0)
                                                {
                                                  settings->sortOrder = (enum anonymous$38)BarSettingsRead$$1$$2$$1$$2$$21$$i;
                                                  break;
                                                }

                                              }
                                            }

                                            else
                                            {
                                              return_value_strcmp$31=strcmp("love_icon", key);
                                              if(return_value_strcmp$31 == 0)
                                              {
                                                free((void *)settings->loveIcon);
                                                settings->loveIcon=strdup(val);
                                              }

                                              else
                                              {
                                                return_value_strcmp$30=strcmp("ban_icon", key);
                                                if(return_value_strcmp$30 == 0)
                                                {
                                                  free((void *)settings->banIcon);
                                                  settings->banIcon=strdup(val);
                                                }

                                                else
                                                {
                                                  return_value_strcmp$29=strcmp("at_icon", key);
                                                  if(return_value_strcmp$29 == 0)
                                                  {
                                                    free((void *)settings->atIcon);
                                                    settings->atIcon=strdup(val);
                                                  }

                                                  else
                                                  {
                                                    return_value_strcmp$28=strcmp("volume", key);
                                                    if(return_value_strcmp$28 == 0)
                                                      settings->volume=atoi(val);

                                                    else
                                                    {
                                                      return_value_strcmp$27=strcmp("format_nowplaying_song", key);
                                                      if(return_value_strcmp$27 == 0)
                                                      {
                                                        free((void *)settings->npSongFormat);
                                                        settings->npSongFormat=strdup(val);
                                                      }

                                                      else
                                                      {
                                                        return_value_strcmp$26=strcmp("format_nowplaying_station", key);
                                                        if(return_value_strcmp$26 == 0)
                                                        {
                                                          free((void *)settings->npStationFormat);
                                                          settings->npStationFormat=strdup(val);
                                                        }

                                                        else
                                                        {
                                                          return_value_strcmp$25=strcmp("format_list_song", key);
                                                          if(return_value_strcmp$25 == 0)
                                                          {
                                                            free((void *)settings->listSongFormat);
                                                            settings->listSongFormat=strdup(val);
                                                          }

                                                          else
                                                          {
                                                            return_value_strcmp$24=strcmp("fifo", key);
                                                            if(return_value_strcmp$24 == 0)
                                                            {
                                                              free((void *)settings->fifo);
                                                              settings->fifo=BarSettingsExpandTilde(val, userhome);
                                                            }

                                                            else
                                                            {
                                                              return_value_strcmp$23=strcmp("autoselect", key);
                                                              if(return_value_strcmp$23 == 0)
                                                              {
                                                                signed int return_value_atoi$12;
                                                                return_value_atoi$12=atoi(val);
                                                                settings->autoselect = (_Bool)return_value_atoi$12;
                                                              }

                                                              else
                                                              {
                                                                return_value_strcmp$22=strcmp("tls_fingerprint", key);
                                                                if(return_value_strcmp$22 == 0)
                                                                {
                                                                  unsigned long int return_value_strlen$14;
                                                                  return_value_strlen$14=strlen(val);
                                                                  if(return_value_strlen$14 == 40ul)
                                                                  {
                                                                    unsigned long int BarSettingsRead$$1$$2$$1$$2$$31$$1$$1$$i = (unsigned long int)0;
                                                                    for( ; !(BarSettingsRead$$1$$2$$1$$2$$31$$1$$1$$i >= 20ul); BarSettingsRead$$1$$2$$1$$2$$31$$1$$1$$i = BarSettingsRead$$1$$2$$1$$2$$31$$1$$1$$i + 1ul)
                                                                    {
                                                                      char hex[3l];
                                                                      memcpy((void *)hex, (const void *)&val[(signed long int)(BarSettingsRead$$1$$2$$1$$2$$31$$1$$1$$i * (unsigned long int)2)], (unsigned long int)2);
                                                                      hex[(signed long int)2] = (char)0;
                                                                      signed long int return_value_strtol$13;
                                                                      return_value_strtol$13=strtol(hex, (char ** restrict )(void *)0, 16);
                                                                      settings->tlsFingerprint[(signed long int)BarSettingsRead$$1$$2$$1$$2$$31$$1$$1$$i] = (char)return_value_strtol$13;
                                                                    }
                                                                  }

                                                                }

                                                                else
                                                                {
                                                                  static const char *formatMsgPrefix = "format_msg_";
                                                                  return_value_strlen$20=strlen(formatMsgPrefix);
                                                                  return_value_strncmp$21=strncmp(formatMsgPrefix, key, return_value_strlen$20);
                                                                  if(return_value_strncmp$21 == 0)
                                                                  {
                                                                    const char *typeStart;
                                                                    unsigned long int return_value_strlen$15;
                                                                    return_value_strlen$15=strlen(formatMsgPrefix);
                                                                    typeStart = key + (signed long int)return_value_strlen$15;
                                                                    unsigned long int BarSettingsRead$$1$$2$$1$$2$$32$$1$$i = (unsigned long int)0;
                                                                    for( ; !(BarSettingsRead$$1$$2$$1$$2$$32$$1$$i >= 7ul); BarSettingsRead$$1$$2$$1$$2$$32$$1$$i = BarSettingsRead$$1$$2$$1$$2$$32$$1$$i + 1ul)
                                                                    {
                                                                      signed int return_value_strcmp$19;
                                                                      static const char *BarSettingsRead$$1$$2$$1$$2$$32$$mapping[7l] = { "none", "info", "nowplaying", "time", "err", "question", "list" };
                                                                      return_value_strcmp$19=strcmp(typeStart, BarSettingsRead$$1$$2$$1$$2$$32$$mapping[(signed long int)BarSettingsRead$$1$$2$$1$$2$$32$$1$$i]);
                                                                      if(return_value_strcmp$19 == 0)
                                                                      {
                                                                        const char *formatPos;
                                                                        formatPos=strstr(val, "%s");
                                                                        if(!(formatPos == ((const char *)NULL)))
                                                                        {
                                                                          struct anonymous$39 *format = &settings->msgFormat[(signed long int)BarSettingsRead$$1$$2$$1$$2$$32$$1$$i];
                                                                          free((void *)format->prefix);
                                                                          free((void *)format->postfix);
                                                                          const unsigned long int prefixLen = (const unsigned long int)(formatPos - val);
                                                                          void *return_value_calloc$16;
                                                                          return_value_calloc$16=calloc(prefixLen + (unsigned long int)1, sizeof(char) /*1ul*/ );
                                                                          format->prefix = (char *)return_value_calloc$16;
                                                                          memcpy((void *)format->prefix, (const void *)val, prefixLen);
                                                                          unsigned long int postfixLen;
                                                                          unsigned long int return_value_strlen$17;
                                                                          return_value_strlen$17=strlen(val);
                                                                          postfixLen = (return_value_strlen$17 - (unsigned long int)(formatPos - val)) - (unsigned long int)2;
                                                                          void *return_value_calloc$18;
                                                                          return_value_calloc$18=calloc(postfixLen + (unsigned long int)1, sizeof(char) /*1ul*/ );
                                                                          format->postfix = (char *)return_value_calloc$18;
                                                                          memcpy((void *)format->postfix, (const void *)(formatPos + (signed long int)2), postfixLen);
                                                                        }

                                                                        break;
                                                                      }

                                                                    }
                                                                  }

                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      fclose(configfd);
      free((void *)path);
    }
  }
  unsigned long int return_value_strlen$51;
  if(settings->proxy == ((char *)NULL))
  {
    char *tmpProxy;
    tmpProxy=getenv("http_proxy");
    if(!(tmpProxy == ((char *)NULL)))
    {
      return_value_strlen$51=strlen(tmpProxy);
      if(return_value_strlen$51 >= 1ul)
        settings->proxy=strdup(tmpProxy);

    }

  }

  free((void *)userhome);
}

// BarSettingsWrite
// file src/settings.h line 116
void BarSettingsWrite(struct PianoStation *station, struct anonymous$33 *settings)
{
  struct _IO_FILE *fd;
  /* assertion settings != ((void *)0) */
  assert(settings != (struct anonymous$33 *)(void *)0);
  char *path;
  path=BarGetXdgConfigDir("pianobar/state");
  /* assertion path != ((void *)0) */
  assert(path != (char *)(void *)0);
  fd=fopen(path, "w");
  if(fd == ((struct _IO_FILE *)NULL))
    free((void *)path);

  else
  {
    fputs("# do not edit this file\n", fd);
    fprintf(fd, "volume = %i\n", settings->volume);
    if(!(station == ((struct PianoStation *)NULL)))
      fprintf(fd, "autostart_station = %s\n", station->id);

    fclose(fd);
    free((void *)path);
  }
}

// BarSortedStations
// file src/ui.c line 294
static struct PianoStation ** BarSortedStations(struct PianoStation *unsortedStations, unsigned long int *retStationCount, enum anonymous$38 order)
{
  struct PianoStation **stationArray = (struct PianoStation **)(void *)0;
  struct PianoStation *currStation = (struct PianoStation *)(void *)0;
  unsigned long int stationCount = (unsigned long int)0;
  unsigned long int i;
  /* assertion order < sizeof (orderMapping)/sizeof(*orderMapping) */
  assert((unsigned long int)order < sizeof(signed int (* const [6l])(const void *, const void *)) /*48ul*/  / sizeof(signed int (*)(const void *, const void *)) /*8ul*/ );
  stationCount=PianoListCount(&unsortedStations->head);
  void *return_value_calloc$1;
  return_value_calloc$1=calloc(stationCount, sizeof(struct PianoStation *) /*8ul*/ );
  stationArray = (struct PianoStation **)return_value_calloc$1;
  i = (unsigned long int)0;
  currStation = unsortedStations;
  for( ; !(currStation == ((struct PianoStation *)NULL)); currStation = (struct PianoStation *)(void *)currStation->head.next)
  {
    stationArray[(signed long int)i] = currStation;
    i = i + 1ul;
  }
  static signed int (* const orderMapping[6l])(const void *, const void *) = { BarStationNameAZCmp, BarStationNameZACmp, BarStationCmpQuickmix01NameAZ, BarStationCmpQuickmix01NameZA, BarStationCmpQuickmix10NameAZ, BarStationCmpQuickmix10NameZA };
  qsort((void *)stationArray, stationCount, sizeof(struct PianoStation *) /*8ul*/ , orderMapping[(signed long int)order]);
  *retStationCount = stationCount;
  return stationArray;
}

// BarStationCmpQuickmix01NameAZ
// file src/ui.c line 268
static signed int BarStationCmpQuickmix01NameAZ(const void *a, const void *b)
{
  signed int return_value_BarStationQuickmixNameCmp$1;
  return_value_BarStationQuickmixNameCmp$1=BarStationQuickmixNameCmp(a, b, a, b);
  return return_value_BarStationQuickmixNameCmp$1;
}

// BarStationCmpQuickmix01NameZA
// file src/ui.c line 274
static signed int BarStationCmpQuickmix01NameZA(const void *a, const void *b)
{
  signed int return_value_BarStationQuickmixNameCmp$1;
  return_value_BarStationQuickmixNameCmp$1=BarStationQuickmixNameCmp(a, b, b, a);
  return return_value_BarStationQuickmixNameCmp$1;
}

// BarStationCmpQuickmix10NameAZ
// file src/ui.c line 280
static signed int BarStationCmpQuickmix10NameAZ(const void *a, const void *b)
{
  signed int return_value_BarStationQuickmixNameCmp$1;
  return_value_BarStationQuickmixNameCmp$1=BarStationQuickmixNameCmp(b, a, a, b);
  return return_value_BarStationQuickmixNameCmp$1;
}

// BarStationCmpQuickmix10NameZA
// file src/ui.c line 286
static signed int BarStationCmpQuickmix10NameZA(const void *a, const void *b)
{
  signed int return_value_BarStationQuickmixNameCmp$1;
  return_value_BarStationQuickmixNameCmp$1=BarStationQuickmixNameCmp(b, a, b, a);
  return return_value_BarStationQuickmixNameCmp$1;
}

// BarStationNameAZCmp
// file src/ui.c line 246
static inline signed int BarStationNameAZCmp(const void *a, const void *b)
{
  const struct PianoStation *stationA = *((struct PianoStation * const *)a);
  const struct PianoStation *stationB = *((struct PianoStation * const *)b);
  signed int return_value_strcasecmp$1;
  return_value_strcasecmp$1=strcasecmp(stationA->name, stationB->name);
  return return_value_strcasecmp$1;
}

// BarStationNameZACmp
// file src/ui.c line 254
static signed int BarStationNameZACmp(const void *a, const void *b)
{
  signed int return_value_BarStationNameAZCmp$1;
  return_value_BarStationNameAZCmp$1=BarStationNameAZCmp(b, a);
  return return_value_BarStationNameAZCmp$1;
}

// BarStationQuickmix01Cmp
// file src/ui.c line 238
static inline signed int BarStationQuickmix01Cmp(const void *a, const void *b)
{
  const struct PianoStation *stationA = *((struct PianoStation * const *)a);
  const struct PianoStation *stationB = *((struct PianoStation * const *)b);
  return (signed int)stationA->isQuickMix - (signed int)stationB->isQuickMix;
}

// BarStationQuickmixNameCmp
// file src/ui.c line 260
static inline signed int BarStationQuickmixNameCmp(const void *a, const void *b, const void *c, const void *d)
{
  signed int qmc;
  qmc=BarStationQuickmix01Cmp(a, b);
  signed int tmp_if_expr$2;
  signed int return_value_BarStationNameAZCmp$1;
  if(qmc == 0)
  {
    return_value_BarStationNameAZCmp$1=BarStationNameAZCmp(c, d);
    tmp_if_expr$2 = return_value_BarStationNameAZCmp$1;
  }

  else
    tmp_if_expr$2 = qmc;
  return tmp_if_expr$2;
}

// BarStrCaseStr
// file src/ui.c line 68
static const char * BarStrCaseStr(const char *haystack, const char *needle)
{
  const char *needlePos = needle;
  /* assertion haystack != ((void *)0) */
  assert(haystack != (const char *)(void *)0);
  /* assertion needle != ((void *)0) */
  assert(needle != (const char *)(void *)0);
  if((signed int)*needle == 0)
    return haystack;

  else
  {
    while(!((signed int)*haystack == 0))
    {
      signed int return_value_tolower$1;
      return_value_tolower$1=tolower((signed int)(unsigned char)*haystack);
      signed int return_value_tolower$2;
      return_value_tolower$2=tolower((signed int)(unsigned char)*needlePos);
      if(return_value_tolower$1 == return_value_tolower$2)
        needlePos = needlePos + 1l;

      else
        needlePos = needle;
      haystack = haystack + 1l;
      if((signed int)*needlePos == 0)
      {
        unsigned long int return_value_strlen$3;
        return_value_strlen$3=strlen(needle);
        return haystack - (signed long int)return_value_strlen$3;
      }

    }
    return (const char *)(void *)0;
  }
}

// BarTermHandleCont
// file src/terminal.c line 38
static void BarTermHandleCont(signed int sig)
{
  BarTermInit();
}

// BarTermInit
// file src/terminal.h line 27
void BarTermInit()
{
  struct termios newopt;
  tcgetattr(0, &restore);
  memcpy((void *)&newopt, (const void *)&restore, sizeof(struct termios) /*60ul*/ );
  newopt.c_lflag = newopt.c_lflag & (unsigned int)~(0000010 | 0000002);
  tcsetattr(0, 0, &newopt);
  signal(18, BarTermHandleCont);
}

// BarTermRestore
// file src/terminal.h line 28
void BarTermRestore()
{
  tcsetattr(0, 0, &restore);
}

// BarTransformIfShared
// file src/ui_act.c line 64
static signed int BarTransformIfShared(struct anonymous$35 *app, struct PianoStation *station)
{
  enum anonymous$4 pRet;
  enum anonymous$5 wRet;
  /* assertion station != ((void *)0) */
  assert(station != (struct PianoStation *)(void *)0);
  if(station->isCreator == 0)
  {
    BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Transforming station... ");
    signed int return_value_BarUiPianoCall$1;
    return_value_BarUiPianoCall$1=BarUiPianoCall(app, (enum anonymous$2)PIANO_REQUEST_TRANSFORM_STATION, (void *)station, &pRet, &wRet);
    if(return_value_BarUiPianoCall$1 == 0)
      return 0;

  }

  return 1;
}

// BarUiActAddMusic
// file src/ui_act.h line 37
void BarUiActAddMusic(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  enum anonymous$4 pRet;
  enum anonymous$5 wRet;
  struct anonymous$54 reqData;
  /* assertion selStation != ((void *)0) */
  assert(selStation != (struct PianoStation *)(void *)0);
  reqData.musicId=BarUiSelectMusicId(app, selStation, "Add artist or title to station: ");
  if(!(reqData.musicId == ((char *)NULL)))
  {
    signed int return_value_BarTransformIfShared$1;
    return_value_BarTransformIfShared$1=BarTransformIfShared(app, selStation);
    if(return_value_BarTransformIfShared$1 == 0)
      goto __CPROVER_DUMP_L3;

    reqData.station = selStation;
    BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Adding music to station... ");
    BarUiPianoCall(app, (enum anonymous$2)PIANO_REQUEST_ADD_SEED, (void *)&reqData, &pRet, &wRet);
    free((void *)reqData.musicId);
    BarUiStartEventCmd(&app->settings, "stationaddmusic", selStation, selSong, &app->player, app->ph.stations, pRet, wRet);
  }


__CPROVER_DUMP_L3:
  ;
}

// BarUiActAddSharedStation
// file src/ui_act.h line 41
void BarUiActAddSharedStation(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  enum anonymous$4 pRet;
  enum anonymous$5 wRet;
  char stationId[50l];
  struct anonymous$44 reqData;
  reqData.token = stationId;
  reqData.type = (enum anonymous$43)PIANO_MUSICTYPE_INVALID;
  BarUiMsg(&app->settings, (const enum anonymous$34)MSG_QUESTION, "Station id: ");
  unsigned long int return_value_BarReadline$1;
  return_value_BarReadline$1=BarReadline(stationId, sizeof(char [50l]) /*50ul*/ , "0123456789", &app->input, (const enum anonymous$45)BAR_RL_DEFAULT, -1);
  if(return_value_BarReadline$1 >= 1ul)
  {
    BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Adding shared station... ");
    BarUiPianoCall(app, (enum anonymous$2)PIANO_REQUEST_CREATE_STATION, (void *)&reqData, &pRet, &wRet);
    BarUiStartEventCmd(&app->settings, "stationaddshared", selStation, selSong, &app->player, app->ph.stations, pRet, wRet);
  }

}

// BarUiActBanSong
// file src/ui_act.h line 38
void BarUiActBanSong(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  enum anonymous$4 pRet;
  enum anonymous$5 wRet;
  struct PianoStation *realStation;
  /* assertion selStation != ((void *)0) */
  assert(selStation != (struct PianoStation *)(void *)0);
  /* assertion selSong != ((void *)0) */
  assert(selSong != (struct PianoSong *)(void *)0);
  /* assertion selSong->stationId != ((void *)0) */
  assert(selSong->stationId != (char *)(void *)0);
  realStation=PianoFindStationById(app->ph.stations, selSong->stationId);
  if(realStation == ((struct PianoStation *)NULL))
    /* assertion 0 */
    assert(0 != 0);

  else
  {
    signed int return_value_BarTransformIfShared$1;
    return_value_BarTransformIfShared$1=BarTransformIfShared(app, realStation);
    if(!(return_value_BarTransformIfShared$1 == 0))
    {
      struct anonymous$48 reqData;
      reqData.song = selSong;
      reqData.rating = (enum anonymous$29)PIANO_RATE_BAN;
      BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Banning song... ");
      signed int return_value_BarUiPianoCall$2;
      return_value_BarUiPianoCall$2=BarUiPianoCall(app, (enum anonymous$2)PIANO_REQUEST_RATE_SONG, (void *)&reqData, &pRet, &wRet);
      if(!(return_value_BarUiPianoCall$2 == 0))
      {
        if(selSong == app->playlist)
          BarUiDoSkipSong(&app->player);

      }

      BarUiStartEventCmd(&app->settings, "songban", selStation, selSong, &app->player, app->ph.stations, pRet, wRet);
    }

  }
}

// BarUiActBookmark
// file src/ui_act.h line 59
void BarUiActBookmark(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  enum anonymous$4 pRet;
  enum anonymous$5 wRet;
  char selectBuf[2l];
  /* assertion selSong != ((void *)0) */
  assert(selSong != (struct PianoSong *)(void *)0);
  BarUiMsg(&app->settings, (const enum anonymous$34)MSG_QUESTION, "Bookmark [s]ong or [a]rtist? ");
  BarReadline(selectBuf, sizeof(char [2l]) /*2ul*/ , "sa", &app->input, (const enum anonymous$45)BAR_RL_FULLRETURN, -1);
  if((signed int)selectBuf[0l] == 115)
  {
    BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Bookmarking song... ");
    BarUiPianoCall(app, (enum anonymous$2)PIANO_REQUEST_BOOKMARK_SONG, (void *)selSong, &pRet, &wRet);
    BarUiStartEventCmd(&app->settings, "songbookmark", selStation, selSong, &app->player, app->ph.stations, pRet, wRet);
  }

  else
    if((signed int)selectBuf[0l] == 97)
    {
      BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Bookmarking artist... ");
      BarUiPianoCall(app, (enum anonymous$2)PIANO_REQUEST_BOOKMARK_ARTIST, (void *)selSong, &pRet, &wRet);
      BarUiStartEventCmd(&app->settings, "artistbookmark", selStation, selSong, &app->player, app->ph.stations, pRet, wRet);
    }

}

// BarUiActCreateStation
// file src/ui_act.h line 39
void BarUiActCreateStation(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  enum anonymous$4 pRet;
  enum anonymous$5 wRet;
  struct anonymous$44 reqData;
  reqData.type = (enum anonymous$43)PIANO_MUSICTYPE_INVALID;
  reqData.token=BarUiSelectMusicId(app, (struct PianoStation *)(void *)0, "Create station from artist or title: ");
  if(!(reqData.token == ((char *)NULL)))
  {
    BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Creating station... ");
    BarUiPianoCall(app, (enum anonymous$2)PIANO_REQUEST_CREATE_STATION, (void *)&reqData, &pRet, &wRet);
    free((void *)reqData.token);
    BarUiStartEventCmd(&app->settings, "stationcreate", selStation, selSong, &app->player, app->ph.stations, pRet, wRet);
  }

}

// BarUiActCreateStationFromSong
// file src/ui_act.h line 40
void BarUiActCreateStationFromSong(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  enum anonymous$4 pRet;
  enum anonymous$5 wRet;
  struct anonymous$44 reqData;
  char selectBuf[2l];
  reqData.token = selSong->trackToken;
  reqData.type = (enum anonymous$43)PIANO_MUSICTYPE_INVALID;
  BarUiMsg(&app->settings, (const enum anonymous$34)MSG_QUESTION, "Create station from [s]ong or [a]rtist? ");
  BarReadline(selectBuf, sizeof(char [2l]) /*2ul*/ , "sa", &app->input, (const enum anonymous$45)BAR_RL_FULLRETURN, -1);
  switch((signed int)selectBuf[(signed long int)0])
  {
    case 115:
    {
      reqData.type = (enum anonymous$43)PIANO_MUSICTYPE_SONG;
      break;
    }
    case 97:
      reqData.type = (enum anonymous$43)PIANO_MUSICTYPE_ARTIST;
  }
  if(!((signed int)reqData.type == PIANO_MUSICTYPE_INVALID))
  {
    BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Creating station... ");
    BarUiPianoCall(app, (enum anonymous$2)PIANO_REQUEST_CREATE_STATION, (void *)&reqData, &pRet, &wRet);
    BarUiStartEventCmd(&app->settings, "stationcreate", selStation, selSong, &app->player, app->ph.stations, pRet, wRet);
  }

}

// BarUiActDebug
// file src/ui_act.h line 57
void BarUiActDebug(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  /* assertion selSong != ((void *)0) */
  assert(selSong != (struct PianoSong *)(void *)0);
  BarUiMsg(&app->settings, (const enum anonymous$34)MSG_NONE, "album:\t%s\nartist:\t%s\naudioFormat:\t%i\naudioUrl:\t%s\ncoverArt:\t%s\ndetailUrl:\t%s\nfileGain:\t%f\nmusicId:\t%s\nrating:\t%i\nstationId:\t%s\ntitle:\t%s\ntrackToken:\t%s\n", selSong->album, selSong->artist, selSong->audioFormat, selSong->audioUrl, selSong->coverArt, selSong->detailUrl, selSong->fileGain, selSong->musicId, selSong->rating, selSong->stationId, selSong->title, selSong->trackToken);
}

// BarUiActDeleteStation
// file src/ui_act.h line 42
void BarUiActDeleteStation(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  enum anonymous$4 pRet;
  enum anonymous$5 wRet;
  /* assertion selStation != ((void *)0) */
  assert(selStation != (struct PianoStation *)(void *)0);
  BarUiMsg(&app->settings, (const enum anonymous$34)MSG_QUESTION, "Really delete \"%s\"? [yN] ", selStation->name);
  _Bool return_value_BarReadlineYesNo$2;
  return_value_BarReadlineYesNo$2=BarReadlineYesNo((_Bool)0, &app->input);
  if(!(return_value_BarReadlineYesNo$2 == (_Bool)0))
  {
    BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Deleting station... ");
    signed int return_value_BarUiPianoCall$1;
    return_value_BarUiPianoCall$1=BarUiPianoCall(app, (enum anonymous$2)PIANO_REQUEST_DELETE_STATION, (void *)selStation, &pRet, &wRet);
    if(!(return_value_BarUiPianoCall$1 == 0))
    {
      if(selStation == app->curStation)
      {
        BarUiDoSkipSong(&app->player);
        PianoDestroyPlaylist((struct PianoSong *)(void *)app->playlist->head.next);
        app->playlist->head.next = (struct PianoListHead *)(void *)0;
        BarUiHistoryPrepend(app, app->playlist);
        app->playlist = (struct PianoSong *)(void *)0;
        app->curStation = (struct PianoStation *)(void *)0;
      }

    }

    BarUiStartEventCmd(&app->settings, "stationdelete", selStation, selSong, &app->player, app->ph.stations, pRet, wRet);
  }

}

// BarUiActExplain
// file src/ui_act.h line 43
void BarUiActExplain(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  enum anonymous$4 pRet;
  enum anonymous$5 wRet;
  struct anonymous$42 reqData;
  /* assertion selSong != ((void *)0) */
  assert(selSong != (struct PianoSong *)(void *)0);
  reqData.song = selSong;
  BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Receiving explanation... ");
  signed int return_value_BarUiPianoCall$1;
  return_value_BarUiPianoCall$1=BarUiPianoCall(app, (enum anonymous$2)PIANO_REQUEST_EXPLAIN, (void *)&reqData, &pRet, &wRet);
  if(!(return_value_BarUiPianoCall$1 == 0))
  {
    BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "%s\n", reqData.retExplain);
    free((void *)reqData.retExplain);
  }

  BarUiStartEventCmd(&app->settings, "songexplain", selStation, selSong, &app->player, app->ph.stations, pRet, wRet);
}

// BarUiActHelp
// file src/ui_act.h line 36
void BarUiActHelp(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  BarUiMsg(&app->settings, (const enum anonymous$34)MSG_NONE, "\r");
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= 29ul); i = i + 1ul)
    if(!(dispatchActions$link1[(signed long int)i].helpText == ((const char *)NULL)))
    {
      if(((signed int)dispatchActions$link1[(signed long int)i].context & (signed int)context) == (signed int)dispatchActions$link1[(signed long int)i].context)
      {
        if(!((signed int)app->settings.keys[(signed long int)i] == 0))
          BarUiMsg(&app->settings, (const enum anonymous$34)MSG_LIST, "%c    %s\n", app->settings.keys[(signed long int)i], dispatchActions$link1[(signed long int)i].helpText);

      }

    }

}

// BarUiActHistory
// file src/ui_act.h line 58
void BarUiActHistory(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  char buf[2l];
  struct PianoSong *histSong;
  if(!(app->songHistory == ((struct PianoSong *)NULL)))
  {
    histSong=BarUiSelectSong(&app->settings, app->songHistory, &app->input);
    if(!(histSong == ((struct PianoSong *)NULL)))
    {
      enum anonymous$36 action;
      struct PianoStation *songStation;
      songStation=PianoFindStationById(app->ph.stations, histSong->stationId);
      if(songStation == ((struct PianoStation *)NULL))
      {
        BarUiMsg(&app->settings, (const enum anonymous$34)MSG_ERR, "Station does not exist any more.\n");
        goto __CPROVER_DUMP_L6;
      }

      do
      {
        action = (enum anonymous$36)BAR_KS_COUNT;
        BarUiMsg(&app->settings, (const enum anonymous$34)MSG_QUESTION, "What to do with this song? ");
        unsigned long int return_value_BarReadline$1;
        return_value_BarReadline$1=BarReadline(buf, sizeof(char [2l]) /*2ul*/ , (const char *)(void *)0, &app->input, (const enum anonymous$45)BAR_RL_FULLRETURN, -1);
        if(return_value_BarReadline$1 >= 1ul)
          action=BarUiDispatch(app, buf[(signed long int)0], songStation, histSong, (const _Bool)0, (enum anonymous$28)BAR_DC_UNDEFINED);

      }
      while((signed int)action == BAR_KS_HELP);
    }

  }

  else
    BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, app->settings.history == (unsigned int)0 ? "History disabled.\n" : "No history yet.\n");

__CPROVER_DUMP_L6:
  ;
}

// BarUiActLoveSong
// file src/ui_act.h line 46
void BarUiActLoveSong(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  enum anonymous$4 pRet;
  enum anonymous$5 wRet;
  struct PianoStation *realStation;
  /* assertion selStation != ((void *)0) */
  assert(selStation != (struct PianoStation *)(void *)0);
  /* assertion selSong != ((void *)0) */
  assert(selSong != (struct PianoSong *)(void *)0);
  /* assertion selSong->stationId != ((void *)0) */
  assert(selSong->stationId != (char *)(void *)0);
  realStation=PianoFindStationById(app->ph.stations, selSong->stationId);
  if(realStation == ((struct PianoStation *)NULL))
    /* assertion 0 */
    assert(0 != 0);

  else
  {
    signed int return_value_BarTransformIfShared$1;
    return_value_BarTransformIfShared$1=BarTransformIfShared(app, realStation);
    if(!(return_value_BarTransformIfShared$1 == 0))
    {
      struct anonymous$48 reqData;
      reqData.song = selSong;
      reqData.rating = (enum anonymous$29)PIANO_RATE_LOVE;
      BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Loving song... ");
      BarUiPianoCall(app, (enum anonymous$2)PIANO_REQUEST_RATE_SONG, (void *)&reqData, &pRet, &wRet);
      BarUiStartEventCmd(&app->settings, "songlove", selStation, selSong, &app->player, app->ph.stations, pRet, wRet);
    }

  }
}

// BarUiActManageStation
// file src/ui_act.h line 62
void BarUiActManageStation(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  enum anonymous$4 pRet;
  enum anonymous$5 wRet;
  struct anonymous$51 reqData;
  char selectBuf[2l];
  char allowedActions[6l];
  char *allowedPos = allowedActions;
  char question[64l];
  memset((void *)&reqData, 0, sizeof(struct anonymous$51) /*40ul*/ );
  reqData.station = selStation;
  BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Fetching station info... ");
  _Bool bret;
  signed int return_value_BarUiPianoCall$1;
  return_value_BarUiPianoCall$1=BarUiPianoCall(app, (enum anonymous$2)PIANO_REQUEST_GET_STATION_INFO, (void *)&reqData, &pRet, &wRet);
  bret = (const _Bool)return_value_BarUiPianoCall$1;
  BarUiStartEventCmd(&app->settings, "stationfetchinfo", selStation, selSong, &app->player, app->ph.stations, pRet, wRet);
  char *tmp_post$2;
  char *tmp_post$3;
  char *tmp_post$4;
  char *tmp_post$5;
  if(!(bret == (_Bool)0))
  {
    strcpy(question, "Delete ");
    if(!(reqData.info.artistSeeds == ((struct PianoArtist *)NULL)))
    {
      strcat(question, "[a]rtist");
      tmp_post$2 = allowedPos;
      allowedPos = allowedPos + 1l;
      *tmp_post$2 = (char)97;
    }

    if(!(reqData.info.songSeeds == ((struct PianoSong *)NULL)))
    {
      if(!(allowedPos == allowedActions))
        strcat(question, "/");

      strcat(question, "[s]ong");
      tmp_post$3 = allowedPos;
      allowedPos = allowedPos + 1l;
      *tmp_post$3 = (char)115;
    }

    if(!(reqData.info.stationSeeds == ((struct PianoStation *)NULL)))
    {
      if(!(allowedPos == allowedActions))
        strcat(question, "/");

      strcat(question, "s[t]ation");
      tmp_post$4 = allowedPos;
      allowedPos = allowedPos + 1l;
      *tmp_post$4 = (char)116;
    }

    if(!(allowedPos == allowedActions))
      strcat(question, " seeds");

    if(!(reqData.info.feedback == ((struct PianoSong *)NULL)))
    {
      if(!(allowedPos == allowedActions))
        strcat(question, " or ");

      strcat(question, "[f]eedback");
      tmp_post$5 = allowedPos;
      allowedPos = allowedPos + 1l;
      *tmp_post$5 = (char)102;
    }

    *allowedPos = (char)0;
    strcat(question, "? ");
    unsigned long int return_value_strlen$6;
    return_value_strlen$6=strlen(question);
    /* assertion strlen (question) < sizeof (question) / sizeof (*question) */
    assert(return_value_strlen$6 < sizeof(char [64l]) /*64ul*/  / sizeof(char) /*1ul*/ );
    if(allowedPos == allowedActions)
    {
      BarUiMsg(&app->settings, (const enum anonymous$34)MSG_ERR, "No seeds or feedback available yet.\n");
      PianoDestroyStationInfo(&reqData.info);
    }

    else
    {
      BarUiMsg(&app->settings, (const enum anonymous$34)MSG_QUESTION, "%s", (const void *)question);
      unsigned long int return_value_BarReadline$7;
      return_value_BarReadline$7=BarReadline(selectBuf, sizeof(char [2l]) /*2ul*/ , allowedActions, &app->input, (const enum anonymous$45)BAR_RL_FULLRETURN, -1);
      if(!(return_value_BarReadline$7 == 0ul))
      {
        if((signed int)selectBuf[0l] == 97)
        {
          struct PianoArtist *artist;
          artist=BarUiSelectArtist(app, reqData.info.artistSeeds);
          if(!(artist == ((struct PianoArtist *)NULL)))
          {
            struct anonymous$52 subReqData;
            memset((void *)&subReqData, 0, sizeof(struct anonymous$52) /*24ul*/ );
            subReqData.artist = artist;
            BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Deleting artist seed... ");
            BarUiPianoCall(app, (enum anonymous$2)PIANO_REQUEST_DELETE_SEED, (void *)&subReqData, &pRet, &wRet);
            BarUiStartEventCmd(&app->settings, "stationdeleteartistseed", selStation, selSong, &app->player, app->ph.stations, pRet, wRet);
          }

        }

        else
          if((signed int)selectBuf[0l] == 115)
          {
            struct PianoSong *song;
            song=BarUiSelectSong(&app->settings, reqData.info.songSeeds, &app->input);
            if(!(song == ((struct PianoSong *)NULL)))
            {
              struct anonymous$52 BarUiActManageStation$$1$$8$$2$$1$$subReqData;
              memset((void *)&BarUiActManageStation$$1$$8$$2$$1$$subReqData, 0, sizeof(struct anonymous$52) /*24ul*/ );
              BarUiActManageStation$$1$$8$$2$$1$$subReqData.song = song;
              BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Deleting song seed... ");
              BarUiPianoCall(app, (enum anonymous$2)PIANO_REQUEST_DELETE_SEED, (void *)&BarUiActManageStation$$1$$8$$2$$1$$subReqData, &pRet, &wRet);
              BarUiStartEventCmd(&app->settings, "stationdeletesongseed", selStation, selSong, &app->player, app->ph.stations, pRet, wRet);
            }

          }

          else
            if((signed int)selectBuf[0l] == 116)
            {
              struct PianoStation *station;
              station=BarUiSelectStation(app, reqData.info.stationSeeds, "Delete seed station: ", (void (*)(struct anonymous$35 *, char *))(void *)0, (_Bool)0);
              if(!(station == ((struct PianoStation *)NULL)))
              {
                struct anonymous$52 BarUiActManageStation$$1$$8$$3$$1$$subReqData;
                memset((void *)&BarUiActManageStation$$1$$8$$3$$1$$subReqData, 0, sizeof(struct anonymous$52) /*24ul*/ );
                BarUiActManageStation$$1$$8$$3$$1$$subReqData.station = station;
                BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Deleting station seed... ");
                BarUiPianoCall(app, (enum anonymous$2)PIANO_REQUEST_DELETE_SEED, (void *)&BarUiActManageStation$$1$$8$$3$$1$$subReqData, &pRet, &wRet);
                BarUiStartEventCmd(&app->settings, "stationdeletestationseed", selStation, selSong, &app->player, app->ph.stations, pRet, wRet);
              }

            }

            else
              if((signed int)selectBuf[0l] == 102)
              {
                struct PianoSong *BarUiActManageStation$$1$$8$$4$$song;
                BarUiActManageStation$$1$$8$$4$$song=BarUiSelectSong(&app->settings, reqData.info.feedback, &app->input);
                if(!(BarUiActManageStation$$1$$8$$4$$song == ((struct PianoSong *)NULL)))
                {
                  BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Deleting feedback... ");
                  BarUiPianoCall(app, (enum anonymous$2)PIANO_REQUEST_DELETE_FEEDBACK, (void *)BarUiActManageStation$$1$$8$$4$$song, &pRet, &wRet);
                  BarUiStartEventCmd(&app->settings, "stationdeletefeedback", selStation, selSong, &app->player, app->ph.stations, pRet, wRet);
                }

              }

      }

      PianoDestroyStationInfo(&reqData.info);
    }
  }

}

// BarUiActPause
// file src/ui_act.h line 49
void BarUiActPause(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  pthread_mutex_lock(&app->player.pauseMutex);
  app->player.doPause = (volatile _Bool)1;
  pthread_cond_broadcast(&app->player.pauseCond);
  pthread_mutex_unlock(&app->player.pauseMutex);
}

// BarUiActPlay
// file src/ui_act.h line 48
void BarUiActPlay(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  pthread_mutex_lock(&app->player.pauseMutex);
  app->player.doPause = (volatile _Bool)0;
  pthread_cond_broadcast(&app->player.pauseCond);
  pthread_mutex_unlock(&app->player.pauseMutex);
}

// BarUiActPrintUpcoming
// file src/ui_act.h line 54
void BarUiActPrintUpcoming(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  /* assertion selSong != ((void *)0) */
  assert(selSong != (struct PianoSong *)(void *)0);
  struct PianoSong *nextSong = (struct PianoSong *)(void *)selSong->head.next;
  if(!(nextSong == ((struct PianoSong *)NULL)))
    BarUiListSongs(&app->settings, nextSong, (const char *)(void *)0);

  else
    BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "No songs in queue.\n");
}

// BarUiActQuickmixCallback
// file src/ui_act.c line 512
static void BarUiActQuickmixCallback(struct anonymous$35 *app, char *buf)
{
  struct PianoStation *curStation = app->ph.stations;
  _Bool tmp_if_expr$1;
  if((signed int)*buf == 0)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)buf[(signed long int)1] != 0 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr$1)
    switch((signed int)*buf)
    {
      case 116:
      {
        for( ; !(curStation == ((struct PianoStation *)NULL)); curStation = (struct PianoStation *)(void *)curStation->head.next)
          curStation->useQuickMix = (char)!(curStation->useQuickMix != 0);
        *buf = (char)0;
        break;
      }
      case 97:
      {
        for( ; !(curStation == ((struct PianoStation *)NULL)); curStation = (struct PianoStation *)(void *)curStation->head.next)
          curStation->useQuickMix = (char)1;
        *buf = (char)0;
        break;
      }
      case 110:
      {
        for( ; !(curStation == ((struct PianoStation *)NULL)); curStation = (struct PianoStation *)(void *)curStation->head.next)
          curStation->useQuickMix = (char)0;
        *buf = (char)0;
      }
    }

}

// BarUiActQuit
// file src/ui_act.h line 56
void BarUiActQuit(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  app->doQuit = (char)1;
  BarUiDoSkipSong(&app->player);
}

// BarUiActRenameStation
// file src/ui_act.h line 51
void BarUiActRenameStation(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  enum anonymous$4 pRet;
  enum anonymous$5 wRet;
  char lineBuf[100l];
  /* assertion selStation != ((void *)0) */
  assert(selStation != (struct PianoStation *)(void *)0);
  BarUiMsg(&app->settings, (const enum anonymous$34)MSG_QUESTION, "New name: ");
  unsigned long int return_value_BarReadlineStr$2;
  return_value_BarReadlineStr$2=BarReadlineStr(lineBuf, sizeof(char [100l]) /*100ul*/ , &app->input, (const enum anonymous$45)BAR_RL_DEFAULT);
  if(return_value_BarReadlineStr$2 >= 1ul)
  {
    struct anonymous$49 reqData;
    signed int return_value_BarTransformIfShared$1;
    return_value_BarTransformIfShared$1=BarTransformIfShared(app, selStation);
    if(return_value_BarTransformIfShared$1 == 0)
      goto __CPROVER_DUMP_L3;

    reqData.station = selStation;
    reqData.newName = lineBuf;
    BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Renaming station... ");
    BarUiPianoCall(app, (enum anonymous$2)PIANO_REQUEST_RENAME_STATION, (void *)&reqData, &pRet, &wRet);
    BarUiStartEventCmd(&app->settings, "stationrename", selStation, selSong, &app->player, app->ph.stations, pRet, wRet);
  }


__CPROVER_DUMP_L3:
  ;
}

// BarUiActSelectQuickMix
// file src/ui_act.h line 55
void BarUiActSelectQuickMix(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  enum anonymous$4 pRet;
  enum anonymous$5 wRet;
  /* assertion selStation != ((void *)0) */
  assert(selStation != (struct PianoStation *)(void *)0);
  if(!(selStation->isQuickMix == 0))
  {
    struct PianoStation *toggleStation;
    do
    {
      toggleStation=BarUiSelectStation(app, app->ph.stations, "Toggle quickmix for station: ", BarUiActQuickmixCallback, (_Bool)0);
      if(toggleStation == ((struct PianoStation *)NULL))
        break;

      toggleStation->useQuickMix = (char)!(toggleStation->useQuickMix != 0);
    }
    while((_Bool)1);
    BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Setting quickmix stations... ");
    BarUiPianoCall(app, (enum anonymous$2)PIANO_REQUEST_SET_QUICKMIX, (void *)0, &pRet, &wRet);
    BarUiStartEventCmd(&app->settings, "stationquickmixtoggle", selStation, selSong, &app->player, app->ph.stations, pRet, wRet);
  }

  else
    BarUiMsg(&app->settings, (const enum anonymous$34)MSG_ERR, "Not a QuickMix station.\n");
}

// BarUiActSelectStation
// file src/ui_act.h line 52
void BarUiActSelectStation(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  struct PianoStation *newStation;
  newStation=BarUiSelectStation(app, app->ph.stations, "Select station: ", (void (*)(struct anonymous$35 *, char *))(void *)0, app->settings.autoselect);
  if(!(newStation == ((struct PianoStation *)NULL)))
  {
    app->curStation = newStation;
    BarUiPrintStation(&app->settings, app->curStation);
    BarUiDoSkipSong(&app->player);
    if(!(app->playlist == ((struct PianoSong *)NULL)))
    {
      PianoDestroyPlaylist((struct PianoSong *)(void *)app->playlist->head.next);
      app->playlist->head.next = (struct PianoListHead *)(void *)0;
      BarUiHistoryPrepend(app, app->playlist);
      app->playlist = (struct PianoSong *)(void *)0;
    }

  }

}

// BarUiActSkipSong
// file src/ui_act.h line 47
void BarUiActSkipSong(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  BarUiDoSkipSong(&app->player);
}

// BarUiActSongInfo
// file src/ui_act.h line 45
void BarUiActSongInfo(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  /* assertion selStation != ((void *)0) */
  assert(selStation != (struct PianoStation *)(void *)0);
  /* assertion selSong != ((void *)0) */
  assert(selSong != (struct PianoSong *)(void *)0);
  BarUiPrintStation(&app->settings, selStation);
  struct PianoStation *tmp_if_expr$2;
  struct PianoStation *return_value_PianoFindStationById$1;
  if(!(selStation->isQuickMix == 0))
  {
    return_value_PianoFindStationById$1=PianoFindStationById(app->ph.stations, selSong->stationId);
    tmp_if_expr$2 = return_value_PianoFindStationById$1;
  }

  else
    tmp_if_expr$2 = (struct PianoStation *)(void *)0;
  BarUiPrintSong(&app->settings, selSong, tmp_if_expr$2);
}

// BarUiActStationFromGenre
// file src/ui_act.h line 44
void BarUiActStationFromGenre(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  enum anonymous$4 pRet;
  enum anonymous$5 wRet;
  const struct PianoGenreCategory *curCat;
  const struct PianoGenre *curGenre;
  signed int i;
  if(app->ph.genreStations == ((struct PianoGenreCategory *)NULL))
  {
    BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Receiving genre stations... ");
    _Bool ret;
    signed int return_value_BarUiPianoCall$1;
    return_value_BarUiPianoCall$1=BarUiPianoCall(app, (enum anonymous$2)PIANO_REQUEST_GET_GENRE_STATIONS, (void *)0, &pRet, &wRet);
    ret = (const _Bool)return_value_BarUiPianoCall$1;
    BarUiStartEventCmd(&app->settings, "stationfetchgenre", selStation, selSong, &app->player, app->ph.stations, pRet, wRet);
    if(ret == (_Bool)0)
      goto __CPROVER_DUMP_L9;

  }

  curCat = app->ph.genreStations;
  i = 0;
  for( ; !(curCat == ((const struct PianoGenreCategory *)NULL)); curCat = (const struct PianoGenreCategory *)(void *)curCat->head.next)
  {
    BarUiMsg(&app->settings, (const enum anonymous$34)MSG_LIST, "%2i) %s\n", i, curCat->name);
    i = i + 1;
  }
  do
  {
    BarUiMsg(&app->settings, (const enum anonymous$34)MSG_QUESTION, "Select category: ");
    unsigned long int return_value_BarReadlineInt$2;
    return_value_BarReadlineInt$2=BarReadlineInt(&i, &app->input);
    if(return_value_BarReadlineInt$2 == 0ul)
      goto __CPROVER_DUMP_L9;

    void *return_value_PianoListGet$3;
    return_value_PianoListGet$3=PianoListGet(&app->ph.genreStations->head, (const unsigned long int)i);
    curCat = (const struct PianoGenreCategory *)return_value_PianoListGet$3;
  }
  while(curCat == ((const struct PianoGenreCategory *)NULL));
  i = 0;
  curGenre = curCat->genres;
  for( ; !(curGenre == ((const struct PianoGenre *)NULL)); curGenre = (const struct PianoGenre *)(void *)curGenre->head.next)
  {
    BarUiMsg(&app->settings, (const enum anonymous$34)MSG_LIST, "%2i) %s\n", i, curGenre->name);
    i = i + 1;
  }
  do
  {
    BarUiMsg(&app->settings, (const enum anonymous$34)MSG_QUESTION, "Select genre: ");
    unsigned long int return_value_BarReadlineInt$4;
    return_value_BarReadlineInt$4=BarReadlineInt(&i, &app->input);
    if(return_value_BarReadlineInt$4 == 0ul)
      goto __CPROVER_DUMP_L9;

    void *return_value_PianoListGet$5;
    return_value_PianoListGet$5=PianoListGet(&curCat->genres->head, (const unsigned long int)i);
    curGenre = (const struct PianoGenre *)return_value_PianoListGet$5;
  }
  while(curGenre == ((const struct PianoGenre *)NULL));
  struct anonymous$44 reqData;
  reqData.token = curGenre->musicId;
  reqData.type = (enum anonymous$43)PIANO_MUSICTYPE_INVALID;
  BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Adding genre station \"%s\"... ", curGenre->name);
  BarUiPianoCall(app, (enum anonymous$2)PIANO_REQUEST_CREATE_STATION, (void *)&reqData, &pRet, &wRet);
  BarUiStartEventCmd(&app->settings, "stationaddgenre", selStation, selSong, &app->player, app->ph.stations, pRet, wRet);

__CPROVER_DUMP_L9:
  ;
}

// BarUiActTempBanSong
// file src/ui_act.h line 53
void BarUiActTempBanSong(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  enum anonymous$4 pRet;
  enum anonymous$5 wRet;
  /* assertion selSong != ((void *)0) */
  assert(selSong != (struct PianoSong *)(void *)0);
  BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Putting song on shelf... ");
  signed int return_value_BarUiPianoCall$1;
  return_value_BarUiPianoCall$1=BarUiPianoCall(app, (enum anonymous$2)PIANO_REQUEST_ADD_TIRED_SONG, (void *)selSong, &pRet, &wRet);
  if(!(return_value_BarUiPianoCall$1 == 0))
  {
    if(selSong == app->playlist)
      BarUiDoSkipSong(&app->player);

  }

  BarUiStartEventCmd(&app->settings, "songshelf", selStation, selSong, &app->player, app->ph.stations, pRet, wRet);
}

// BarUiActTogglePause
// file src/ui_act.h line 50
void BarUiActTogglePause(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  pthread_mutex_lock(&app->player.pauseMutex);
  app->player.doPause = !(app->player.doPause != (_Bool)0);
  pthread_cond_broadcast(&app->player.pauseCond);
  pthread_mutex_unlock(&app->player.pauseMutex);
}

// BarUiActVolDown
// file src/ui_act.h line 60
void BarUiActVolDown(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  app->settings.volume = app->settings.volume - 1;
  BarPlayerSetVolume(&app->player);
}

// BarUiActVolReset
// file src/ui_act.h line 63
void BarUiActVolReset(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  app->settings.volume = 0;
  BarPlayerSetVolume(&app->player);
}

// BarUiActVolUp
// file src/ui_act.h line 61
void BarUiActVolUp(struct anonymous$35 *app, struct PianoStation *selStation, struct PianoSong *selSong, enum anonymous$28 context)
{
  app->settings.volume = app->settings.volume + 1;
  BarPlayerSetVolume(&app->player);
}

// BarUiAppendNewline
// file src/ui.c line 598
static void BarUiAppendNewline(char *s, unsigned long int maxlen)
{
  unsigned long int len;
  len=strlen(s);
  if(len == maxlen + 18446744073709551615ul)
    s[(signed long int)(maxlen - (unsigned long int)2)] = (char)10;

  else
  {
    s[(signed long int)len] = (char)10;
    s[(signed long int)(len + (unsigned long int)1)] = (char)0;
  }
}

// BarUiCustomFormat
// file src/ui.c line 544
static void BarUiCustomFormat(char *dest, unsigned long int destSize, const char *format, const char *formatChars, const char **formatVals)
{
  _Bool haveFormatChar = (_Bool)0;
  for( ; !((signed int)*format == 0); format = format + 1l)
  {
    if(!(destSize >= 2ul))
      break;

    if(haveFormatChar == (_Bool)0 && (signed int)*format == 37)
      haveFormatChar = (_Bool)1;

    else
      if(!(haveFormatChar == (_Bool)0))
      {
        const char *testChar = formatChars;
        const char *val = (const char *)(void *)0;
        for( ; !((signed int)*testChar == 0); testChar = testChar + 1l)
          if(*testChar == *format)
          {
            val = formatVals[(signed long int)((unsigned long int)(testChar - formatChars) / sizeof(const char) /*1ul*/ )];
            break;
          }

        if(!(val == ((const char *)NULL)))
          for( ; !((signed int)*val == 0); destSize = destSize - 1ul)
          {
            if(!(destSize >= 2ul))
              break;

            *dest = *val;
            val = val + 1l;
            dest = dest + 1l;
          }

        else
        {
          *dest = (char)37;
          dest = dest + 1l;
          destSize = destSize - 1ul;
          if(destSize >= 2ul)
          {
            *dest = *format;
            dest = dest + 1l;
            destSize = destSize - 1ul;
          }

        }
        haveFormatChar = (_Bool)0;
      }

      else
      {
        *dest = *format;
        dest = dest + 1l;
        destSize = destSize - 1ul;
      }
  }
  *dest = (char)0;
}

// BarUiDispatch
// file src/ui_dispatch.h line 112
enum anonymous$36 BarUiDispatch(struct anonymous$35 *app, const char key, struct PianoStation *selStation, struct PianoSong *selSong, const _Bool verbose, enum anonymous$28 context)
{
  /* assertion app != ((void *)0) */
  assert(app != (struct anonymous$35 *)(void *)0);
  /* assertion sizeof (app->settings.keys) / sizeof (*app->settings.keys) == sizeof (dispatchActions) / sizeof (*dispatchActions) */
  assert(sizeof(char [29l]) /*29ul*/  / sizeof(char) /*1ul*/  == sizeof(const struct anonymous$31 [29l]) /*928ul*/  / sizeof(const struct anonymous$31) /*32ul*/ );
  if(!(selStation == ((struct PianoStation *)NULL)))
    context = context | (enum anonymous$28)BAR_DC_STATION;

  if(!(selSong == ((struct PianoSong *)NULL)))
    context = context | (enum anonymous$28)BAR_DC_SONG;

  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= 29ul); i = i + 1ul)
    if(!((signed int)app->settings.keys[(signed long int)i] == 0))
    {
      if(app->settings.keys[(signed long int)i] == key)
      {
        if(((signed int)dispatchActions$link2[(signed long int)i].context & (signed int)context) == (signed int)dispatchActions$link2[(signed long int)i].context)
        {
          /* assertion dispatchActions[i].function != ((void *)0) */
          assert(dispatchActions$link2[(signed long int)i].function != (void (*)(struct anonymous$35 *, struct PianoStation *, struct PianoSong *, enum anonymous$28))(void *)0);
          dispatchActions$link2[(signed long int)i].function(app, selStation, selSong, context);
          return (enum anonymous$36)i;
        }

        else
          if(!(verbose == (_Bool)0))
          {
            if(!((BAR_DC_SONG & (signed int)dispatchActions$link2[(signed long int)i].context) == 0))
              BarUiMsg(&app->settings, (const enum anonymous$34)MSG_ERR, "No song playing.\n");

            else
              if(!((BAR_DC_STATION & (signed int)dispatchActions$link2[(signed long int)i].context) == 0))
                BarUiMsg(&app->settings, (const enum anonymous$34)MSG_ERR, "No station selected.\n");

              else
                /* assertion 0 */
                assert(0 != 0);
            return (enum anonymous$36)BAR_KS_COUNT;
          }

      }

    }

  return (enum anonymous$36)BAR_KS_COUNT;
}

// BarUiDoSkipSong
// file src/ui_act.c line 49
static inline void BarUiDoSkipSong(struct anonymous$3 * const player)
{
  /* assertion player != ((void *)0) */
  assert(player != (struct anonymous$3 *)(void *)0);
  pthread_mutex_lock(&player->pauseMutex);
  player->doQuit = (volatile _Bool)1;
  player->doPause = (volatile _Bool)0;
  pthread_cond_broadcast(&player->pauseCond);
  pthread_mutex_unlock(&player->pauseMutex);
}

// BarUiHistoryPrepend
// file src/ui.h line 56
void BarUiHistoryPrepend(struct anonymous$35 *app, struct PianoSong *song)
{
  /* assertion app != ((void *)0) */
  assert(app != (struct anonymous$35 *)(void *)0);
  /* assertion song != ((void *)0) */
  assert(song != (struct PianoSong *)(void *)0);
  /* assertion ((void *) (song)->head.next) == ((void *)0) */
  assert((void *)song->head.next == (void *)0);
  struct PianoListHead *tmp_if_expr$1;
  struct PianoListHead *tmp_if_expr$4;
  if(!(app->settings.history == 0u))
  {
    if(app->songHistory == ((struct PianoSong *)NULL))
      tmp_if_expr$1 = (struct PianoListHead *)(void *)0;

    else
      tmp_if_expr$1 = &app->songHistory->head;
    void *return_value_PianoListPrepend$2;
    return_value_PianoListPrepend$2=PianoListPrepend(tmp_if_expr$1, &song->head);
    app->songHistory = (struct PianoSong *)return_value_PianoListPrepend$2;
    struct PianoSong *del;
    do
    {
      void *return_value_PianoListGet$3;
      return_value_PianoListGet$3=PianoListGet(&app->songHistory->head, (const unsigned long int)app->settings.history);
      del = (struct PianoSong *)return_value_PianoListGet$3;
      if(!(del == ((struct PianoSong *)NULL)))
      {
        if(app->songHistory == ((struct PianoSong *)NULL))
          tmp_if_expr$4 = (struct PianoListHead *)(void *)0;

        else
          tmp_if_expr$4 = &app->songHistory->head;
        void *return_value_PianoListDelete$5;
        return_value_PianoListDelete$5=PianoListDelete(tmp_if_expr$4, &del->head);
        app->songHistory = (struct PianoSong *)return_value_PianoListDelete$5;
        PianoDestroyPlaylist(del);
      }

      else
        break;
    }
    while((_Bool)1);
  }

  else
    PianoDestroyPlaylist(song);
}

// BarUiListSongs
// file src/ui.h line 50
unsigned long int BarUiListSongs(const struct anonymous$33 *settings, const struct PianoSong *song, const char *filter)
{
  unsigned long int i = (unsigned long int)0;
  char digits[8l];
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$6;
  const char *return_value_BarStrCaseStr$3;
  _Bool tmp_if_expr$5;
  const char *return_value_BarStrCaseStr$4;
  char *tmp_if_expr$2;
  char *tmp_if_expr$1;
  for( ; !(song == ((const struct PianoSong *)NULL)); song = (const struct PianoSong *)(void *)song->head.next)
  {
    if(filter == ((const char *)NULL))
      tmp_if_expr$7 = (_Bool)1;

    else
    {
      if(!(filter == ((const char *)NULL)))
      {
        return_value_BarStrCaseStr$3=BarStrCaseStr(song->artist, filter);
        if(!(return_value_BarStrCaseStr$3 == ((const char *)NULL)))
          tmp_if_expr$5 = (_Bool)1;

        else
        {
          return_value_BarStrCaseStr$4=BarStrCaseStr(song->title, filter);
          tmp_if_expr$5 = return_value_BarStrCaseStr$4 != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
        }
        tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$6 = (_Bool)0;
      tmp_if_expr$7 = tmp_if_expr$6 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$7)
    {
      char outstr[512l];
      const char *vals[4l];
      if((signed int)song->rating == PIANO_RATE_LOVE)
        tmp_if_expr$2 = settings->loveIcon;

      else
      {
        if((signed int)song->rating == PIANO_RATE_BAN)
          tmp_if_expr$1 = settings->banIcon;

        else
          tmp_if_expr$1 = "";
        tmp_if_expr$2 = tmp_if_expr$1;
      }
      vals[0] = digits;
      vals[1] = song->artist;
      vals[2] = song->title;
      vals[3] = tmp_if_expr$2;
      snprintf(digits, sizeof(char [8l]) /*8ul*/  / sizeof(char) /*1ul*/ , "%2zu", i);
      BarUiCustomFormat(outstr, sizeof(char [512l]) /*512ul*/ , settings->listSongFormat, "iatr", vals);
      BarUiAppendNewline(outstr, sizeof(char [512l]) /*512ul*/ );
      BarUiMsg(settings, (const enum anonymous$34)MSG_LIST, "%s", (const void *)outstr);
    }

    i = i + 1ul;
  }
  return i;
}

// BarUiMsg
// file src/ui.h line 40
void BarUiMsg(const struct anonymous$33 *settings, const enum anonymous$34 type, const char *format, ...)
{
  void **fmtargs;
  /* assertion settings != ((void *)0) */
  assert(settings != (const struct anonymous$33 *)(void *)0);
  /* assertion type < MSG_COUNT */
  assert((signed int)type < MSG_COUNT);
  /* assertion format != ((void *)0) */
  assert(format != (const char *)(void *)0);
  if((signed int)type == MSG_INFO || (signed int)type == MSG_PLAYING || (signed int)type == MSG_TIME || (signed int)type == MSG_ERR || (signed int)type == MSG_QUESTION || (signed int)type == MSG_LIST)
    fputs("\033[2K", stdout);

  if(!(settings->msgFormat[(signed long int)type].prefix == ((char *)NULL)))
    fputs(settings->msgFormat[(signed long int)type].prefix, stdout);

  fmtargs = (void **)&format;
  vprintf(format, fmtargs);
  fmtargs = ((void **)NULL);
  if(!(settings->msgFormat[(signed long int)type].postfix == ((char *)NULL)))
    fputs(settings->msgFormat[(signed long int)type].postfix, stdout);

  fflush(stdout);
}

// BarUiPianoCall
// file src/ui.h line 54
signed int BarUiPianoCall(struct anonymous$35 * const app, enum anonymous$2 type, void *data, enum anonymous$4 *pRet, enum anonymous$5 *wRet)
{
  struct PianoRequest req;
  memset((void *)&req, 0, sizeof(struct PianoRequest) /*1056ul*/ );
  do
  {
    req.data = data;
    *pRet=PianoRequest(&app->ph, &req, type);
    if(!((signed int)*pRet == PIANO_RET_OK))
    {
      const char *return_value_PianoErrorToStr$1;
      return_value_PianoErrorToStr$1=PianoErrorToStr(*pRet);
      BarUiMsg(&app->settings, (const enum anonymous$34)MSG_NONE, "Error: %s\n", return_value_PianoErrorToStr$1);
      PianoDestroyRequest(&req);
      return 0;
    }

    *wRet=BarPianoHttpRequest(&app->waith, &req);
    if(!((signed int)*wRet == WAITRESS_RET_OK))
    {
      const char *return_value_WaitressErrorToStr$2;
      return_value_WaitressErrorToStr$2=WaitressErrorToStr(*wRet);
      BarUiMsg(&app->settings, (const enum anonymous$34)MSG_NONE, "Network error: %s\n", return_value_WaitressErrorToStr$2);
      if(!(req.responseData == ((char *)NULL)))
        free((void *)req.responseData);

      PianoDestroyRequest(&req);
      return 0;
    }

    *pRet=PianoResponse(&app->ph, &req);
    if(!((signed int)*pRet == PIANO_RET_CONTINUE_REQUEST))
    {
      if((signed int)*pRet == PIANO_RET_P_INVALID_AUTH_TOKEN && !((signed int)type == PIANO_REQUEST_LOGIN))
      {
        enum anonymous$4 authpRet;
        enum anonymous$5 authwRet;
        struct anonymous$13 reqData;
        reqData.user = app->settings.username;
        reqData.password = app->settings.password;
        reqData.step = (unsigned char)0;
        BarUiMsg(&app->settings, (const enum anonymous$34)MSG_NONE, "Reauthentication required... ");
        signed int return_value_BarUiPianoCall$3;
        return_value_BarUiPianoCall$3=BarUiPianoCall(app, (enum anonymous$2)PIANO_REQUEST_LOGIN, (void *)&reqData, &authpRet, &authwRet);
        if(return_value_BarUiPianoCall$3 == 0)
        {
          *pRet = authpRet;
          *wRet = authwRet;
          if(!(req.responseData == ((char *)NULL)))
            free((void *)req.responseData);

          PianoDestroyRequest(&req);
          return 0;
        }

        else
        {
          *pRet = (enum anonymous$4)PIANO_RET_CONTINUE_REQUEST;
          BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Trying again... ");
        }
      }

      else
        if(!((signed int)*pRet == PIANO_RET_OK))
        {
          const char *return_value_PianoErrorToStr$4;
          return_value_PianoErrorToStr$4=PianoErrorToStr(*pRet);
          BarUiMsg(&app->settings, (const enum anonymous$34)MSG_NONE, "Error: %s\n", return_value_PianoErrorToStr$4);
          if(!(req.responseData == ((char *)NULL)))
            free((void *)req.responseData);

          PianoDestroyRequest(&req);
          return 0;
        }

        else
          BarUiMsg(&app->settings, (const enum anonymous$34)MSG_NONE, "Ok.\n");
    }

    if(!(req.responseData == ((char *)NULL)))
      free((void *)req.responseData);

    PianoDestroyRequest(&req);
  }
  while((signed int)*pRet == PIANO_RET_CONTINUE_REQUEST);
  return 1;
}

// BarUiPrintSong
// file src/ui.h line 48
void BarUiPrintSong(const struct anonymous$33 *settings, const struct PianoSong *song, const struct PianoStation *station)
{
  char outstr[512l];
  const char *vals[7l];
  char *tmp_if_expr$1;
  if((signed int)song->rating == PIANO_RATE_LOVE)
    tmp_if_expr$1 = settings->loveIcon;

  else
    tmp_if_expr$1 = "";
  char *tmp_if_expr$2;
  if(!(station == ((const struct PianoStation *)NULL)))
    tmp_if_expr$2 = settings->atIcon;

  else
    tmp_if_expr$2 = "";
  char *tmp_if_expr$3;
  if(!(station == ((const struct PianoStation *)NULL)))
    tmp_if_expr$3 = station->name;

  else
    tmp_if_expr$3 = "";
  vals[0] = song->title;
  vals[1] = song->artist;
  vals[2] = song->album;
  vals[3] = tmp_if_expr$1;
  vals[4] = tmp_if_expr$2;
  vals[5] = tmp_if_expr$3;
  vals[6] = song->detailUrl;
  BarUiCustomFormat(outstr, sizeof(char [512l]) /*512ul*/ , settings->npSongFormat, "talr@su", vals);
  BarUiAppendNewline(outstr, sizeof(char [512l]) /*512ul*/ );
  BarUiMsg(settings, (const enum anonymous$34)MSG_PLAYING, "%s", (const void *)outstr);
}

// BarUiPrintStation
// file src/ui.h line 47
void BarUiPrintStation(const struct anonymous$33 *settings, struct PianoStation *station)
{
  char outstr[512l];
  const char *vals[2l] = { station->name, station->id };
  BarUiCustomFormat(outstr, sizeof(char [512l]) /*512ul*/ , settings->npStationFormat, "ni", vals);
  BarUiAppendNewline(outstr, sizeof(char [512l]) /*512ul*/ );
  BarUiMsg(settings, (const enum anonymous$34)MSG_PLAYING, "%s", (const void *)outstr);
}

// BarUiSelectArtist
// file src/ui.h line 45
struct PianoArtist * BarUiSelectArtist(struct anonymous$35 *app, struct PianoArtist *startArtist)
{
  struct PianoArtist *tmpArtist = (struct PianoArtist *)(void *)0;
  char buf[100l];
  unsigned long int i;
  memset((void *)buf, 0, sizeof(char [100l]) /*100ul*/ );
  do
  {
    i = (unsigned long int)0;
    tmpArtist = startArtist;
    for( ; !(tmpArtist == ((struct PianoArtist *)NULL)); tmpArtist = (struct PianoArtist *)(void *)tmpArtist->head.next)
    {
      const char *return_value_BarStrCaseStr$1;
      return_value_BarStrCaseStr$1=BarStrCaseStr(tmpArtist->name, buf);
      if(!(return_value_BarStrCaseStr$1 == ((const char *)NULL)))
        BarUiMsg(&app->settings, (const enum anonymous$34)MSG_LIST, "%2lu) %s\n", i, tmpArtist->name);

      i = i + 1ul;
    }
    BarUiMsg(&app->settings, (const enum anonymous$34)MSG_QUESTION, "Select artist: ");
    unsigned long int return_value_BarReadlineStr$2;
    return_value_BarReadlineStr$2=BarReadlineStr(buf, sizeof(char [100l]) /*100ul*/ , &app->input, (const enum anonymous$45)BAR_RL_DEFAULT);
    if(return_value_BarReadlineStr$2 == 0ul)
      return (struct PianoArtist *)(void *)0;

    _Bool return_value_isnumeric$4;
    return_value_isnumeric$4=isnumeric(buf);
    if(!(return_value_isnumeric$4 == (_Bool)0))
    {
      i=strtoul(buf, (char ** restrict )(void *)0, 0);
      void *return_value_PianoListGet$3;
      return_value_PianoListGet$3=PianoListGet(&startArtist->head, i);
      tmpArtist = (struct PianoArtist *)return_value_PianoListGet$3;
    }

  }
  while(tmpArtist == ((struct PianoArtist *)NULL));
  return tmpArtist;
}

// BarUiSelectMusicId
// file src/ui.h line 46
char * BarUiSelectMusicId(struct anonymous$35 *app, struct PianoStation *station, const char *msg)
{
  char *musicId = (char *)(void *)0;
  char lineBuf[100l];
  char selectBuf[2l];
  struct PianoSearchResult searchResult;
  struct PianoArtist *tmpArtist;
  struct PianoSong *tmpSong;
  BarUiMsg(&app->settings, (const enum anonymous$34)MSG_QUESTION, "%s", msg);
  unsigned long int return_value_BarReadlineStr$2;
  return_value_BarReadlineStr$2=BarReadlineStr(lineBuf, sizeof(char [100l]) /*100ul*/ , &app->input, (const enum anonymous$45)BAR_RL_DEFAULT);
  if(return_value_BarReadlineStr$2 >= 1ul)
  {
    enum anonymous$4 pRet;
    enum anonymous$5 wRet;
    struct anonymous$55 reqData;
    reqData.searchStr = lineBuf;
    BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Searching... ");
    signed int return_value_BarUiPianoCall$1;
    return_value_BarUiPianoCall$1=BarUiPianoCall(app, (enum anonymous$2)PIANO_REQUEST_SEARCH, (void *)&reqData, &pRet, &wRet);
    if(return_value_BarUiPianoCall$1 == 0)
      return (char *)(void *)0;

    memcpy((void *)&searchResult, (const void *)&reqData.searchResult, sizeof(struct PianoSearchResult) /*16ul*/ );
    BarUiMsg(&app->settings, (const enum anonymous$34)MSG_NONE, "\r");
    if(!(searchResult.artists == ((struct PianoArtist *)NULL)) && !(searchResult.songs == ((struct PianoSong *)NULL)))
    {
      BarUiMsg(&app->settings, (const enum anonymous$34)MSG_QUESTION, "Is this an [a]rtist or [t]rack name? ");
      BarReadline(selectBuf, sizeof(char [2l]) /*2ul*/ , "at", &app->input, (const enum anonymous$45)BAR_RL_FULLRETURN, -1);
      if((signed int)selectBuf[0l] == 97)
      {
        tmpArtist=BarUiSelectArtist(app, searchResult.artists);
        if(!(tmpArtist == ((struct PianoArtist *)NULL)))
          musicId=strdup(tmpArtist->musicId);

      }

      else
        if((signed int)selectBuf[0l] == 116)
        {
          tmpSong=BarUiSelectSong(&app->settings, searchResult.songs, &app->input);
          if(!(tmpSong == ((struct PianoSong *)NULL)))
            musicId=strdup(tmpSong->musicId);

        }

    }

    else
      if(!(searchResult.songs == ((struct PianoSong *)NULL)))
      {
        tmpSong=BarUiSelectSong(&app->settings, searchResult.songs, &app->input);
        if(!(tmpSong == ((struct PianoSong *)NULL)))
          musicId=strdup(tmpSong->musicId);

      }

      else
        if(!(searchResult.artists == ((struct PianoArtist *)NULL)))
        {
          tmpArtist=BarUiSelectArtist(app, searchResult.artists);
          if(!(tmpArtist == ((struct PianoArtist *)NULL)))
            musicId=strdup(tmpArtist->musicId);

        }

        else
          BarUiMsg(&app->settings, (const enum anonymous$34)MSG_INFO, "Nothing found...\n");
    PianoDestroySearchResult(&searchResult);
  }

  return musicId;
}

// BarUiSelectSong
// file src/ui.h line 43
struct PianoSong * BarUiSelectSong(const struct anonymous$33 *settings, struct PianoSong *startSong, struct anonymous$40 *input)
{
  struct PianoSong *tmpSong = (struct PianoSong *)(void *)0;
  char buf[100l];
  memset((void *)buf, 0, sizeof(char [100l]) /*100ul*/ );
  do
  {
    BarUiListSongs(settings, startSong, buf);
    BarUiMsg(settings, (const enum anonymous$34)MSG_QUESTION, "Select song: ");
    unsigned long int return_value_BarReadlineStr$1;
    return_value_BarReadlineStr$1=BarReadlineStr(buf, sizeof(char [100l]) /*100ul*/ , input, (const enum anonymous$45)BAR_RL_DEFAULT);
    if(return_value_BarReadlineStr$1 == 0ul)
      return (struct PianoSong *)(void *)0;

    _Bool return_value_isnumeric$3;
    return_value_isnumeric$3=isnumeric(buf);
    if(!(return_value_isnumeric$3 == (_Bool)0))
    {
      unsigned long int i;
      i=strtoul(buf, (char ** restrict )(void *)0, 0);
      void *return_value_PianoListGet$2;
      return_value_PianoListGet$2=PianoListGet(&startSong->head, i);
      tmpSong = (struct PianoSong *)return_value_PianoListGet$2;
    }

  }
  while(tmpSong == ((struct PianoSong *)NULL));
  return tmpSong;
}

// BarUiSelectStation
// file src/ui.h line 41
struct PianoStation * BarUiSelectStation(struct anonymous$35 *app, struct PianoStation *stations, const char *prompt, void (*callback)(struct anonymous$35 *, char *), _Bool autoselect)
{
  struct PianoStation **sortedStations = (struct PianoStation **)(void *)0;
  struct PianoStation *retStation = (struct PianoStation *)(void *)0;
  unsigned long int stationCount;
  unsigned long int i;
  unsigned long int lastDisplayed;
  unsigned long int displayCount;
  char buf[100l];
  if(stations == ((struct PianoStation *)NULL))
  {
    BarUiMsg(&app->settings, (const enum anonymous$34)MSG_ERR, "No station available.\n");
    return (struct PianoStation *)(void *)0;
  }

  else
  {
    memset((void *)buf, 0, sizeof(char [100l]) /*100ul*/ );
    sortedStations=BarSortedStations(stations, &stationCount, app->settings.sortOrder);
    do
    {
      displayCount = (unsigned long int)0;
      i = (unsigned long int)0;
      for( ; !(i >= stationCount); i = i + 1ul)
      {
        const struct PianoStation *currStation = sortedStations[(signed long int)i];
        const char *return_value_BarStrCaseStr$1;
        return_value_BarStrCaseStr$1=BarStrCaseStr(currStation->name, buf);
        if(!(return_value_BarStrCaseStr$1 == ((const char *)NULL)))
        {
          BarUiMsg(&app->settings, (const enum anonymous$34)MSG_LIST, "%2zi) %c%c%c %s\n", i, currStation->useQuickMix != 0 ? 113 : 32, currStation->isQuickMix != 0 ? 81 : 32, !(currStation->isCreator != 0) ? 83 : 32, currStation->name);
          displayCount = displayCount + 1ul;
          lastDisplayed = i;
        }

      }
      BarUiMsg(&app->settings, (const enum anonymous$34)MSG_QUESTION, "%s", prompt);
      if(displayCount == 1ul && !(stationCount == 1ul) && !(autoselect == (_Bool)0))
      {
        BarUiMsg(&app->settings, (const enum anonymous$34)MSG_NONE, "%zi\n", lastDisplayed);
        retStation = sortedStations[(signed long int)lastDisplayed];
      }

      else
      {
        unsigned long int return_value_BarReadlineStr$2;
        return_value_BarReadlineStr$2=BarReadlineStr(buf, sizeof(char [100l]) /*100ul*/ , &app->input, (const enum anonymous$45)BAR_RL_DEFAULT);
        if(return_value_BarReadlineStr$2 == 0ul)
          break;

        _Bool return_value_isnumeric$3;
        return_value_isnumeric$3=isnumeric(buf);
        if(!(return_value_isnumeric$3 == (_Bool)0))
        {
          unsigned long int selected;
          selected=strtoul(buf, (char ** restrict )(void *)0, 0);
          if(!(selected >= stationCount))
            retStation = sortedStations[(signed long int)selected];

        }

        if(retStation == ((struct PianoStation *)NULL) && !(callback == ((void (*)(struct anonymous$35 *, char *))NULL)))
          callback(app, buf);

      }
    }
    while(retStation == ((struct PianoStation *)NULL));
    free((void *)sortedStations);
    return retStation;
  }
}

// BarUiStartEventCmd
// file src/ui.h line 51
void BarUiStartEventCmd(const struct anonymous$33 *settings, const char *type, const struct PianoStation *curStation, const struct PianoSong *curSong, const struct anonymous$3 * const player, struct PianoStation *stations, enum anonymous$4 pRet, enum anonymous$5 wRet)
{
  signed int chld;
  signed int pipeFd[2l];
  char *tmp_if_expr$9;
  char *tmp_if_expr$10;
  char *tmp_if_expr$11;
  char *tmp_if_expr$12;
  char *tmp_if_expr$13;
  char *tmp_if_expr$14;
  signed int tmp_if_expr$17;
  char *tmp_if_expr$18;
  if(!(settings->eventCmd == ((char *)NULL)))
  {
    signed int return_value_pipe$3;
    return_value_pipe$3=pipe(pipeFd);
    if(return_value_pipe$3 == -1)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      char *return_value_strerror$2;
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      BarUiMsg(settings, (const enum anonymous$34)MSG_ERR, "Cannot create eventcmd pipe. (%s)\n", return_value_strerror$2);
      goto __CPROVER_DUMP_L27;
    }

    chld=fork();
    if(chld == 0)
    {
      close(pipeFd[(signed long int)1]);
      signed int return_value_fileno$4;
      return_value_fileno$4=fileno(stdin);
      dup2(pipeFd[(signed long int)0], return_value_fileno$4);
      execl(settings->eventCmd, settings->eventCmd, type, (char *)(void *)0);
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      char *return_value_strerror$6;
      return_value_strerror$6=strerror(*return_value___errno_location$5);
      BarUiMsg(settings, (const enum anonymous$34)MSG_ERR, "Cannot start eventcmd. (%s)\n", return_value_strerror$6);
      close(pipeFd[(signed long int)0]);
      exit(1);
    }

    else
      if(chld == -1)
      {
        signed int *return_value___errno_location$7;
        return_value___errno_location$7=__errno_location();
        char *return_value_strerror$8;
        return_value_strerror$8=strerror(*return_value___errno_location$7);
        BarUiMsg(settings, (const enum anonymous$34)MSG_ERR, "Cannot fork eventcmd. (%s)\n", return_value_strerror$8);
      }

      else
      {
        signed int status;
        struct PianoStation *songStation = (struct PianoStation *)(void *)0;
        struct _IO_FILE *pipeWriteFd;
        close(pipeFd[(signed long int)0]);
        pipeWriteFd=fdopen(pipeFd[(signed long int)1], "w");
        if(!(curSong == ((const struct PianoSong *)NULL)) && !(stations == ((struct PianoStation *)NULL)))
        {
          if(!(curStation->isQuickMix == 0))
            songStation=PianoFindStationById(stations, curSong->stationId);

        }

        if(curSong == ((const struct PianoSong *)NULL))
          tmp_if_expr$9 = "";

        else
          tmp_if_expr$9 = curSong->artist;
        if(curSong == ((const struct PianoSong *)NULL))
          tmp_if_expr$10 = "";

        else
          tmp_if_expr$10 = curSong->title;
        if(curSong == ((const struct PianoSong *)NULL))
          tmp_if_expr$11 = "";

        else
          tmp_if_expr$11 = curSong->album;
        if(curSong == ((const struct PianoSong *)NULL))
          tmp_if_expr$12 = "";

        else
          tmp_if_expr$12 = curSong->coverArt;
        if(curStation == ((const struct PianoStation *)NULL))
          tmp_if_expr$13 = "";

        else
          tmp_if_expr$13 = curStation->name;
        if(songStation == ((struct PianoStation *)NULL))
          tmp_if_expr$14 = "";

        else
          tmp_if_expr$14 = songStation->name;
        const char *return_value_PianoErrorToStr$15;
        return_value_PianoErrorToStr$15=PianoErrorToStr(pRet);
        const char *return_value_WaitressErrorToStr$16;
        return_value_WaitressErrorToStr$16=WaitressErrorToStr(wRet);
        if(curSong == ((const struct PianoSong *)NULL))
          tmp_if_expr$17 = PIANO_RATE_NONE;

        else
          tmp_if_expr$17 = (signed int)curSong->rating;
        if(curSong == ((const struct PianoSong *)NULL))
          tmp_if_expr$18 = "";

        else
          tmp_if_expr$18 = curSong->detailUrl;
        fprintf(pipeWriteFd, "artist=%s\ntitle=%s\nalbum=%s\ncoverArt=%s\nstationName=%s\nsongStationName=%s\npRet=%i\npRetStr=%s\nwRet=%i\nwRetStr=%s\nsongDuration=%u\nsongPlayed=%u\nrating=%i\ndetailUrl=%s\n", tmp_if_expr$9, tmp_if_expr$10, tmp_if_expr$11, tmp_if_expr$12, tmp_if_expr$13, tmp_if_expr$14, pRet, return_value_PianoErrorToStr$15, wRet, return_value_WaitressErrorToStr$16, player->songDuration, player->songPlayed, tmp_if_expr$17, tmp_if_expr$18);
        if(!(stations == ((struct PianoStation *)NULL)))
        {
          struct PianoStation **sortedStations = (struct PianoStation **)(void *)0;
          unsigned long int stationCount;
          sortedStations=BarSortedStations(stations, &stationCount, settings->sortOrder);
          /* assertion sortedStations != ((void *)0) */
          assert(sortedStations != (struct PianoStation **)(void *)0);
          fprintf(pipeWriteFd, "stationCount=%zd\n", stationCount);
          unsigned long int i = (unsigned long int)0;
          for( ; !(i >= stationCount); i = i + 1ul)
          {
            const struct PianoStation *currStation = sortedStations[(signed long int)i];
            fprintf(pipeWriteFd, "station%zd=%s\n", i, currStation->name);
          }
          free((void *)sortedStations);
        }

        else
        {
          const char * const msg = "stationCount=0\n";
          unsigned long int return_value_strlen$19;
          return_value_strlen$19=strlen(msg);
          fwrite((const void *)msg, sizeof(const char) /*1ul*/ , return_value_strlen$19, pipeWriteFd);
        }
        fclose(pipeWriteFd);
        waitpid(chld, &status, 0);
      }
  }


__CPROVER_DUMP_L27:
  ;
}

// PianoDecryptString
// file src/libpiano/crypt.c line 39
char * PianoDecryptString(struct gcry_cipher_handle *h, const char * const input, unsigned long int * const retSize)
{
  unsigned long int inputLen;
  inputLen=strlen(input);
  unsigned int gret;
  unsigned char *output;
  unsigned long int outputLen = inputLen / (unsigned long int)2;
  /* assertion inputLen%2 == 0 */
  assert(inputLen % (unsigned long int)2 == (unsigned long int)0);
  void *return_value_calloc$1;
  return_value_calloc$1=calloc(outputLen + (unsigned long int)1, sizeof(unsigned char) /*1ul*/ );
  output = (unsigned char *)return_value_calloc$1;
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= outputLen); i = i + 1ul)
  {
    char hex[3l];
    memcpy((void *)hex, (const void *)&input[(signed long int)(i * (unsigned long int)2)], (unsigned long int)2);
    hex[(signed long int)2] = (char)0;
    signed long int return_value_strtol$2;
    return_value_strtol$2=strtol(hex, (char ** restrict )(void *)0, 16);
    output[(signed long int)i] = (unsigned char)return_value_strtol$2;
  }
  gret=gcry_cipher_decrypt(h, (void *)output, outputLen, (void *)0, (unsigned long int)0);
  if(!(gret == 0u))
  {
    free((void *)output);
    return (char *)(void *)0;
  }

  else
  {
    *retSize = outputLen;
    return (char *)output;
  }
}

// PianoDestroy
// file src/libpiano/piano.h line 333
void PianoDestroy(struct PianoHandle *ph)
{
  PianoDestroyUserInfo(&ph->user);
  PianoDestroyStations(ph->stations);
  PianoDestroyPartner(&ph->partner);
  struct PianoGenreCategory *curGenreCat = ph->genreStations;
  struct PianoGenreCategory *lastGenreCat;
  while(!(curGenreCat == ((struct PianoGenreCategory *)NULL)))
  {
    PianoDestroyGenres(curGenreCat->genres);
    free((void *)curGenreCat->name);
    lastGenreCat = curGenreCat;
    curGenreCat = (struct PianoGenreCategory *)curGenreCat->head.next;
    free((void *)lastGenreCat);
  }
  memset((void *)ph, 0, sizeof(struct PianoHandle) /*96ul*/ );
}

// PianoDestroyArtists
// file src/libpiano/piano.c line 74
static void PianoDestroyArtists(struct PianoArtist *artists)
{
  struct PianoArtist *curArtist;
  struct PianoArtist *lastArtist;
  curArtist = artists;
  while(!(curArtist == ((struct PianoArtist *)NULL)))
  {
    free((void *)curArtist->name);
    free((void *)curArtist->musicId);
    free((void *)curArtist->seedId);
    lastArtist = curArtist;
    curArtist = (struct PianoArtist *)curArtist->head.next;
    free((void *)lastArtist);
  }
}

// PianoDestroyGenres
// file src/libpiano/piano.c line 158
static void PianoDestroyGenres(struct PianoGenre *genres)
{
  struct PianoGenre *curGenre;
  struct PianoGenre *lastGenre;
  curGenre = genres;
  while(!(curGenre == ((struct PianoGenre *)NULL)))
  {
    free((void *)curGenre->name);
    free((void *)curGenre->musicId);
    lastGenre = curGenre;
    curGenre = (struct PianoGenre *)curGenre->head.next;
    free((void *)lastGenre);
  }
}

// PianoDestroyPartner
// file src/libpiano/piano.c line 180
static void PianoDestroyPartner(struct PianoPartner *partner)
{
  free((void *)partner->user);
  free((void *)partner->password);
  free((void *)partner->device);
  free((void *)partner->authToken);
  gcry_cipher_close(partner->in);
  gcry_cipher_close(partner->out);
  memset((void *)partner, 0, sizeof(struct PianoPartner) /*56ul*/ );
}

// PianoDestroyPlaylist
// file src/libpiano/piano.h line 334
void PianoDestroyPlaylist(struct PianoSong *playlist)
{
  struct PianoSong *curSong;
  struct PianoSong *lastSong;
  curSong = playlist;
  while(!(curSong == ((struct PianoSong *)NULL)))
  {
    free((void *)curSong->audioUrl);
    free((void *)curSong->coverArt);
    free((void *)curSong->artist);
    free((void *)curSong->musicId);
    free((void *)curSong->title);
    free((void *)curSong->stationId);
    free((void *)curSong->album);
    free((void *)curSong->feedbackId);
    free((void *)curSong->seedId);
    free((void *)curSong->detailUrl);
    free((void *)curSong->trackToken);
    lastSong = curSong;
    curSong = (struct PianoSong *)curSong->head.next;
    free((void *)lastSong);
  }
}

// PianoDestroyRequest
// file src/libpiano/piano.h line 342
void PianoDestroyRequest(struct PianoRequest *req)
{
  free((void *)req->postData);
  memset((void *)req, 0, sizeof(struct PianoRequest) /*1056ul*/ );
}

// PianoDestroySearchResult
// file src/libpiano/piano.h line 335
void PianoDestroySearchResult(struct PianoSearchResult *searchResult)
{
  PianoDestroyArtists(searchResult->artists);
  PianoDestroyPlaylist(searchResult->songs);
}

// PianoDestroyStation
// file src/libpiano/piano.c line 100
void PianoDestroyStation(struct PianoStation *station)
{
  free((void *)station->name);
  free((void *)station->id);
  free((void *)station->seedId);
  memset((void *)station, 0, sizeof(struct PianoStation) /*40ul*/ );
}

// PianoDestroyStationInfo
// file src/libpiano/piano.h line 336
void PianoDestroyStationInfo(struct anonymous$50 *info)
{
  PianoDestroyPlaylist(info->feedback);
  PianoDestroyPlaylist(info->songSeeds);
  PianoDestroyArtists(info->artistSeeds);
  PianoDestroyStations(info->stationSeeds);
}

// PianoDestroyStations
// file src/libpiano/piano.c line 110
static void PianoDestroyStations(struct PianoStation *stations)
{
  struct PianoStation *curStation;
  struct PianoStation *lastStation;
  curStation = stations;
  while(!(curStation == ((struct PianoStation *)NULL)))
  {
    lastStation = curStation;
    curStation = (struct PianoStation *)curStation->head.next;
    PianoDestroyStation(lastStation);
    free((void *)lastStation);
  }
}

// PianoDestroyUserInfo
// file src/libpiano/piano.c line 173
void PianoDestroyUserInfo(struct PianoUserInfo *user)
{
  free((void *)user->authToken);
  free((void *)user->listenerId);
}

// PianoEncryptString
// file src/libpiano/crypt.c line 73
char * PianoEncryptString(struct gcry_cipher_handle *h, const char *s)
{
  unsigned char *paddedInput;
  unsigned char *hexOutput;
  unsigned long int inputLen;
  inputLen=strlen(s);
  unsigned long int paddedInputLen = inputLen % (unsigned long int)8 == (unsigned long int)0 ? inputLen : inputLen + ((unsigned long int)8 - inputLen % (unsigned long int)8);
  unsigned int gret;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc(paddedInputLen + (unsigned long int)1, sizeof(unsigned char) /*1ul*/ );
  paddedInput = (unsigned char *)return_value_calloc$1;
  memcpy((void *)paddedInput, (const void *)s, inputLen);
  gret=gcry_cipher_encrypt(h, (void *)paddedInput, paddedInputLen, (void *)0, (unsigned long int)0);
  if(!(gret == 0u))
  {
    free((void *)paddedInput);
    return (char *)(void *)0;
  }

  else
  {
    void *return_value_calloc$2;
    return_value_calloc$2=calloc(paddedInputLen * (unsigned long int)2 + (unsigned long int)1, sizeof(unsigned char) /*1ul*/ );
    hexOutput = (unsigned char *)return_value_calloc$2;
    unsigned long int i = (unsigned long int)0;
    for( ; !(i >= paddedInputLen); i = i + 1ul)
      snprintf((char *)&hexOutput[(signed long int)(i * (unsigned long int)2)], (unsigned long int)3, "%02x", paddedInput[(signed long int)i]);
    free((void *)paddedInput);
    return (char *)hexOutput;
  }
}

// PianoErrorToStr
// file src/libpiano/piano.h line 347
const char * PianoErrorToStr(enum anonymous$4 ret)
{
  switch((signed int)ret)
  {
    case PIANO_RET_OK:
      return "Everything is fine :)";
    case PIANO_RET_ERR:
      return "Unknown.";
    case PIANO_RET_INVALID_RESPONSE:
      return "Invalid response.";
    case PIANO_RET_CONTINUE_REQUEST:
    {
      /* assertion 0 */
      assert(0 != 0);
      return "Fix your program.";
    }
    case PIANO_RET_OUT_OF_MEMORY:
      return "Out of memory.";
    case PIANO_RET_INVALID_LOGIN:
      return "Wrong email address or password.";
    case PIANO_RET_QUALITY_UNAVAILABLE:
      return "Selected audio quality is not available.";
    case PIANO_RET_GCRY_ERR:
      return "libgcrypt initialization failed.";
    case PIANO_RET_P_INTERNAL:
      return "Internal error.";
    case PIANO_RET_P_CALL_NOT_ALLOWED:
      return "Call not allowed.";
    case PIANO_RET_P_INVALID_AUTH_TOKEN:
      return "Invalid auth token.";
    case PIANO_RET_P_MAINTENANCE_MODE:
      return "Maintenance mode.";
    case PIANO_RET_P_MAX_STATIONS_REACHED:
      return "Max number of stations reached.";
    case PIANO_RET_P_READ_ONLY_MODE:
      return "Read only mode. Try again later.";
    case PIANO_RET_P_STATION_DOES_NOT_EXIST:
      return "Station does not exist.";
    case PIANO_RET_P_INVALID_PARTNER_LOGIN:
      return "Invalid partner login.";
    case PIANO_RET_P_LICENSING_RESTRICTIONS:
      return "Pandora is not available in your country. Set up a control proxy (see manpage).";
    case PIANO_RET_P_PARTNER_NOT_AUTHORIZED:
      return "Invalid partner credentials.";
    case PIANO_RET_P_LISTENER_NOT_AUTHORIZED:
      return "Listener not authorized.";
    case PIANO_RET_P_RATE_LIMIT:
      return "Access denied. Try again later.";
    default:
      return "No error message available.";
  }
}

// PianoFindStationById
// file src/libpiano/piano.h line 345
struct PianoStation * PianoFindStationById(struct PianoStation * const stations, const char * const searchStation)
{
  /* assertion searchStation != ((void *)0) */
  assert(searchStation != (const char *)(void *)0);
  struct PianoStation *currStation = stations;
  for( ; !(currStation == ((struct PianoStation *)NULL)); currStation = (struct PianoStation *)(void *)currStation->head.next)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(currStation->id, searchStation);
    if(return_value_strcmp$1 == 0)
      return currStation;

  }
  return (struct PianoStation *)(void *)0;
}

// PianoInit
// file src/libpiano/piano.h line 330
enum anonymous$4 PianoInit(struct PianoHandle *ph, const char *partnerUser, const char *partnerPassword, const char *device, const char *inkey, const char *outkey)
{
  memset((void *)ph, 0, sizeof(struct PianoHandle) /*96ul*/ );
  ph->partner.user=strdup(partnerUser);
  ph->partner.password=strdup(partnerPassword);
  ph->partner.device=strdup(device);
  unsigned int return_value_gcry_cipher_open$1;
  return_value_gcry_cipher_open$1=gcry_cipher_open(&ph->partner.in, 4, 1, (unsigned int)0);
  if(!(return_value_gcry_cipher_open$1 == 0u))
    return (enum anonymous$4)PIANO_RET_GCRY_ERR;

  else
  {
    unsigned long int return_value_strlen$2;
    return_value_strlen$2=strlen(inkey);
    unsigned int return_value_gcry_cipher_setkey$3;
    return_value_gcry_cipher_setkey$3=gcry_cipher_setkey(ph->partner.in, (const void *)(const unsigned char *)inkey, return_value_strlen$2);
    if(!(return_value_gcry_cipher_setkey$3 == 0u))
      return (enum anonymous$4)PIANO_RET_GCRY_ERR;

    else
    {
      unsigned int return_value_gcry_cipher_open$4;
      return_value_gcry_cipher_open$4=gcry_cipher_open(&ph->partner.out, 4, 1, (unsigned int)0);
      if(!(return_value_gcry_cipher_open$4 == 0u))
        return (enum anonymous$4)PIANO_RET_GCRY_ERR;

      else
      {
        unsigned long int return_value_strlen$5;
        return_value_strlen$5=strlen(outkey);
        unsigned int return_value_gcry_cipher_setkey$6;
        return_value_gcry_cipher_setkey$6=gcry_cipher_setkey(ph->partner.out, (const void *)(const unsigned char *)outkey, return_value_strlen$5);
        if(!(return_value_gcry_cipher_setkey$6 == 0u))
          return (enum anonymous$4)PIANO_RET_GCRY_ERR;

        else
          return (enum anonymous$4)PIANO_RET_OK;
      }
    }
  }
}

// PianoJsonParseStation
// file src/libpiano/response.c line 43
static void PianoJsonParseStation(struct json_object *j, struct PianoStation *s)
{
  s->name=PianoJsonStrdup(j, "stationName");
  s->id=PianoJsonStrdup(j, "stationToken");
  struct json_object *return_value_json_object_object_get$1;
  return_value_json_object_object_get$1=json_object_object_get(j, "isShared");
  signed int return_value_json_object_get_boolean$2;
  return_value_json_object_get_boolean$2=json_object_get_boolean(return_value_json_object_object_get$1);
  s->isCreator = (char)!(return_value_json_object_get_boolean$2 != 0);
  struct json_object *return_value_json_object_object_get$3;
  return_value_json_object_object_get$3=json_object_object_get(j, "isQuickMix");
  signed int return_value_json_object_get_boolean$4;
  return_value_json_object_get_boolean$4=json_object_get_boolean(return_value_json_object_object_get$3);
  s->isQuickMix = (char)return_value_json_object_get_boolean$4;
}

// PianoJsonStrdup
// file src/libpiano/response.c line 39
static char * PianoJsonStrdup(struct json_object *j, const char *key)
{
  struct json_object *return_value_json_object_object_get$1;
  return_value_json_object_object_get$1=json_object_object_get(j, key);
  const char *return_value_json_object_get_string$2;
  return_value_json_object_get_string$2=json_object_get_string(return_value_json_object_object_get$1);
  char *return_value_strdup$3;
  return_value_strdup$3=strdup(return_value_json_object_get_string$2);
  return return_value_strdup$3;
}

// PianoListAppend
// file src/libpiano/piano.h line 312
void * PianoListAppend(struct PianoListHead * const l, struct PianoListHead * const e)
{
  /* assertion e != ((void *)0) */
  assert(e != (struct PianoListHead *)(void *)0);
  /* assertion e->next == ((void *)0) */
  assert(e->next == (struct PianoListHead *)(void *)0);
  if(l == ((struct PianoListHead *)NULL))
    return (void *)e;

  else
  {
    struct PianoListHead *curr = l;
    for( ; !(curr->next == ((struct PianoListHead *)NULL)); curr = curr->next)
      ;
    curr->next = e;
    return (void *)l;
  }
}

// PianoListCount
// file src/libpiano/piano.h line 310
unsigned long int PianoListCount(const struct PianoListHead * const l)
{
  /* assertion l != ((void *)0) */
  assert(l != (const struct PianoListHead *)(void *)0);
  unsigned long int count = (unsigned long int)0;
  const struct PianoListHead *curr = l;
  for( ; !(curr == ((const struct PianoListHead *)NULL)); curr = (const struct PianoListHead *)(void *)curr->next)
    count = count + 1ul;
  return count;
}

// PianoListDelete
// file src/libpiano/piano.h line 316
void * PianoListDelete(struct PianoListHead * const l, struct PianoListHead * const e)
{
  /* assertion l != ((void *)0) */
  assert(l != (struct PianoListHead *)(void *)0);
  /* assertion e != ((void *)0) */
  assert(e != (struct PianoListHead *)(void *)0);
  struct PianoListHead *first = l;
  struct PianoListHead *curr = l;
  struct PianoListHead *prev = (struct PianoListHead *)(void *)0;
  for( ; !(curr == ((struct PianoListHead *)NULL)); curr = (struct PianoListHead *)(void *)curr->next)
  {
    if(curr == e)
    {
      if(!(prev == ((struct PianoListHead *)NULL)))
        prev->next = curr->next;

      else
        first = curr->next;
      break;
    }

    prev = curr;
  }
  return (void *)first;
}

// PianoListGet
// file src/libpiano/piano.h line 325
void * PianoListGet(struct PianoListHead * const l, const unsigned long int n)
{
  struct PianoListHead *curr = l;
  unsigned long int i = n;
  for( ; !(curr == ((struct PianoListHead *)NULL)); curr = (struct PianoListHead *)(void *)curr->next)
  {
    if(i == 0ul)
      return (void *)curr;

    i = i - 1ul;
  }
  return (void *)0;
}

// PianoListPrepend
// file src/libpiano/piano.h line 321
void * PianoListPrepend(struct PianoListHead * const l, struct PianoListHead * const e)
{
  /* assertion e != ((void *)0) */
  assert(e != (struct PianoListHead *)(void *)0);
  /* assertion e->next == ((void *)0) */
  assert(e->next == (struct PianoListHead *)(void *)0);
  e->next = l;
  return (void *)e;
}

// PianoRequest
// file src/libpiano/piano.h line 339
enum anonymous$4 PianoRequest(struct PianoHandle *ph, struct PianoRequest *req, enum anonymous$2 type)
{
  enum anonymous$4 ret = (enum anonymous$4)PIANO_RET_OK;
  const char *jsonSendBuf;
  const char *method = (const char *)(void *)0;
  struct json_object *j;
  j=json_object_new_object();
  signed long int timestamp;
  signed long int return_value_time$1;
  return_value_time$1=time((signed long int *)(void *)0);
  timestamp = return_value_time$1 - (signed long int)ph->timeOffset;
  _Bool encrypted = (_Bool)1;
  /* assertion ph != ((void *)0) */
  assert(ph != (struct PianoHandle *)(void *)0);
  /* assertion req != ((void *)0) */
  assert(req != (struct PianoRequest *)(void *)0);
  req->type = type;
  req->secure = (_Bool)0;
  struct anonymous$13 *logindata;
  struct json_object *return_value_json_object_new_string$2;
  struct json_object *return_value_json_object_new_string$3;
  struct json_object *return_value_json_object_new_string$4;
  struct json_object *return_value_json_object_new_string$5;
  struct json_object *return_value_json_object_new_boolean$6;
  char *urlencAuthToken;
  struct json_object *return_value_json_object_new_string$7;
  struct json_object *return_value_json_object_new_string$8;
  struct json_object *return_value_json_object_new_string$9;
  struct json_object *return_value_json_object_new_string$10;
  struct json_object *return_value_json_object_new_int$11;
  struct anonymous$14 *PianoRequest$$1$$1$$3$$reqData;
  struct json_object *return_value_json_object_new_string$12;
  struct json_object *return_value_json_object_new_boolean$13;
  struct anonymous$56 *PianoRequest$$1$$1$$4$$reqData;
  struct json_object *return_value_json_object_new_string$14;
  struct json_object *return_value_json_object_new_string$15;
  struct json_object *return_value_json_object_new_boolean$16;
  struct anonymous$49 *PianoRequest$$1$$1$$5$$reqData;
  struct json_object *return_value_json_object_new_string$17;
  struct json_object *return_value_json_object_new_string$18;
  struct PianoStation *PianoRequest$$1$$1$$6$$station;
  struct json_object *return_value_json_object_new_string$19;
  struct anonymous$55 *PianoRequest$$1$$1$$7$$reqData;
  struct json_object *return_value_json_object_new_string$20;
  struct anonymous$44 *PianoRequest$$1$$1$$8$$reqData;
  struct json_object *return_value_json_object_new_string$23;
  struct json_object *return_value_json_object_new_string$24;
  struct anonymous$54 *PianoRequest$$1$$1$$9$$reqData;
  struct json_object *return_value_json_object_new_string$25;
  struct json_object *return_value_json_object_new_string$26;
  struct PianoSong *PianoRequest$$1$$1$$10$$song;
  struct json_object *return_value_json_object_new_string$27;
  struct PianoStation *curStation;
  struct json_object *a;
  struct PianoStation *station;
  struct json_object *return_value_json_object_new_string$29;
  struct anonymous$42 *reqData;
  struct json_object *return_value_json_object_new_string$30;
  struct PianoSong *song;
  struct json_object *return_value_json_object_new_string$31;
  struct PianoSong *PianoRequest$$1$$1$$16$$song;
  struct json_object *return_value_json_object_new_string$32;
  struct anonymous$51 *PianoRequest$$1$$1$$17$$reqData;
  struct json_object *return_value_json_object_new_string$33;
  struct json_object *return_value_json_object_new_boolean$34;
  struct PianoSong *PianoRequest$$1$$1$$18$$song;
  struct json_object *return_value_json_object_new_string$35;
  struct anonymous$52 *PianoRequest$$1$$1$$19$$reqData;
  char *seedId;
  _Bool tmp_if_expr$36;
  _Bool tmp_if_expr$37;
  struct json_object *return_value_json_object_new_string$38;
  struct anonymous$48 *PianoRequest$$1$$1$$20$$reqData;
  struct anonymous$56 transformedReqData;
  switch((signed int)req->type)
  {
    case PIANO_REQUEST_LOGIN:
    {
      logindata = (struct anonymous$13 *)req->data;
      /* assertion logindata != ((void *)0) */
      assert(logindata != (struct anonymous$13 *)(void *)0);
      switch((signed int)logindata->step)
      {
        case 0:
        {
          encrypted = (_Bool)0;
          req->secure = (_Bool)1;
          return_value_json_object_new_string$2=json_object_new_string(ph->partner.user);
          json_object_object_add(j, "username", return_value_json_object_new_string$2);
          return_value_json_object_new_string$3=json_object_new_string(ph->partner.password);
          json_object_object_add(j, "password", return_value_json_object_new_string$3);
          return_value_json_object_new_string$4=json_object_new_string(ph->partner.device);
          json_object_object_add(j, "deviceModel", return_value_json_object_new_string$4);
          return_value_json_object_new_string$5=json_object_new_string("5");
          json_object_object_add(j, "version", return_value_json_object_new_string$5);
          return_value_json_object_new_boolean$6=json_object_new_boolean(1);
          json_object_object_add(j, "includeUrls", return_value_json_object_new_boolean$6);
          snprintf(req->urlPath, sizeof(char [1024l]) /*1024ul*/ , "/services/json/?method=auth.partnerLogin");
          break;
        }
        case 1:
        {
          req->secure = (_Bool)1;
          return_value_json_object_new_string$7=json_object_new_string("user");
          json_object_object_add(j, "loginType", return_value_json_object_new_string$7);
          return_value_json_object_new_string$8=json_object_new_string(logindata->user);
          json_object_object_add(j, "username", return_value_json_object_new_string$8);
          return_value_json_object_new_string$9=json_object_new_string(logindata->password);
          json_object_object_add(j, "password", return_value_json_object_new_string$9);
          return_value_json_object_new_string$10=json_object_new_string(ph->partner.authToken);
          json_object_object_add(j, "partnerAuthToken", return_value_json_object_new_string$10);
          return_value_json_object_new_int$11=json_object_new_int((signed int)timestamp);
          json_object_object_add(j, "syncTime", return_value_json_object_new_int$11);
          urlencAuthToken=WaitressUrlEncode(ph->partner.authToken);
          /* assertion urlencAuthToken != ((void *)0) */
          assert(urlencAuthToken != (char *)(void *)0);
          snprintf(req->urlPath, sizeof(char [1024l]) /*1024ul*/ , "/services/json/?method=auth.userLogin&auth_token=%s&partner_id=%i", urlencAuthToken, ph->partner.id);
          free((void *)urlencAuthToken);
        }
      }
      goto __CPROVER_DUMP_L40;
    }
    case PIANO_REQUEST_GET_STATIONS:
    {
      /* assertion ph->user.listenerId != ((void *)0) */
      assert(ph->user.listenerId != (char *)(void *)0);
      method = "user.getStationList";
      goto __CPROVER_DUMP_L40;
    }
    case PIANO_REQUEST_GET_PLAYLIST:
    {
      PianoRequest$$1$$1$$3$$reqData = (struct anonymous$14 *)req->data;
      /* assertion reqData != ((void *)0) */
      assert(PianoRequest$$1$$1$$3$$reqData != (struct anonymous$14 *)(void *)0);
      /* assertion reqData->station != ((void *)0) */
      assert(PianoRequest$$1$$1$$3$$reqData->station != (struct PianoStation *)(void *)0);
      /* assertion reqData->station->id != ((void *)0) */
      assert(PianoRequest$$1$$1$$3$$reqData->station->id != (char *)(void *)0);
      req->secure = (_Bool)1;
      return_value_json_object_new_string$12=json_object_new_string(PianoRequest$$1$$1$$3$$reqData->station->id);
      json_object_object_add(j, "stationToken", return_value_json_object_new_string$12);
      return_value_json_object_new_boolean$13=json_object_new_boolean(1);
      json_object_object_add(j, "includeTrackLength", return_value_json_object_new_boolean$13);
      method = "station.getPlaylist";
      goto __CPROVER_DUMP_L40;
    }
    case PIANO_REQUEST_ADD_FEEDBACK:
    {
      PianoRequest$$1$$1$$4$$reqData = (struct anonymous$56 *)req->data;
      /* assertion reqData != ((void *)0) */
      assert(PianoRequest$$1$$1$$4$$reqData != (struct anonymous$56 *)(void *)0);
      /* assertion reqData->trackToken != ((void *)0) */
      assert(PianoRequest$$1$$1$$4$$reqData->trackToken != (char *)(void *)0);
      /* assertion reqData->stationId != ((void *)0) */
      assert(PianoRequest$$1$$1$$4$$reqData->stationId != (char *)(void *)0);
      /* assertion reqData->rating != PIANO_RATE_NONE */
      assert((signed int)PianoRequest$$1$$1$$4$$reqData->rating != PIANO_RATE_NONE);
      return_value_json_object_new_string$14=json_object_new_string(PianoRequest$$1$$1$$4$$reqData->stationId);
      json_object_object_add(j, "stationToken", return_value_json_object_new_string$14);
      return_value_json_object_new_string$15=json_object_new_string(PianoRequest$$1$$1$$4$$reqData->trackToken);
      json_object_object_add(j, "trackToken", return_value_json_object_new_string$15);
      return_value_json_object_new_boolean$16=json_object_new_boolean((signed int)((signed int)PianoRequest$$1$$1$$4$$reqData->rating == PIANO_RATE_LOVE));
      json_object_object_add(j, "isPositive", return_value_json_object_new_boolean$16);
      method = "station.addFeedback";
      goto __CPROVER_DUMP_L40;
    }
    case PIANO_REQUEST_RENAME_STATION:
    {
      PianoRequest$$1$$1$$5$$reqData = (struct anonymous$49 *)req->data;
      /* assertion reqData != ((void *)0) */
      assert(PianoRequest$$1$$1$$5$$reqData != (struct anonymous$49 *)(void *)0);
      /* assertion reqData->station != ((void *)0) */
      assert(PianoRequest$$1$$1$$5$$reqData->station != (struct PianoStation *)(void *)0);
      /* assertion reqData->newName != ((void *)0) */
      assert(PianoRequest$$1$$1$$5$$reqData->newName != (char *)(void *)0);
      return_value_json_object_new_string$17=json_object_new_string(PianoRequest$$1$$1$$5$$reqData->station->id);
      json_object_object_add(j, "stationToken", return_value_json_object_new_string$17);
      return_value_json_object_new_string$18=json_object_new_string(PianoRequest$$1$$1$$5$$reqData->newName);
      json_object_object_add(j, "stationName", return_value_json_object_new_string$18);
      method = "station.renameStation";
      goto __CPROVER_DUMP_L40;
    }
    case PIANO_REQUEST_DELETE_STATION:
    {
      PianoRequest$$1$$1$$6$$station = (struct PianoStation *)req->data;
      /* assertion station != ((void *)0) */
      assert(PianoRequest$$1$$1$$6$$station != (struct PianoStation *)(void *)0);
      /* assertion station->id != ((void *)0) */
      assert(PianoRequest$$1$$1$$6$$station->id != (char *)(void *)0);
      return_value_json_object_new_string$19=json_object_new_string(PianoRequest$$1$$1$$6$$station->id);
      json_object_object_add(j, "stationToken", return_value_json_object_new_string$19);
      method = "station.deleteStation";
      goto __CPROVER_DUMP_L40;
    }
    case PIANO_REQUEST_SEARCH:
    {
      PianoRequest$$1$$1$$7$$reqData = (struct anonymous$55 *)req->data;
      /* assertion reqData != ((void *)0) */
      assert(PianoRequest$$1$$1$$7$$reqData != (struct anonymous$55 *)(void *)0);
      /* assertion reqData->searchStr != ((void *)0) */
      assert(PianoRequest$$1$$1$$7$$reqData->searchStr != (char *)(void *)0);
      return_value_json_object_new_string$20=json_object_new_string(PianoRequest$$1$$1$$7$$reqData->searchStr);
      json_object_object_add(j, "searchText", return_value_json_object_new_string$20);
      method = "music.search";
      goto __CPROVER_DUMP_L40;
    }
    case PIANO_REQUEST_CREATE_STATION:
    {
      PianoRequest$$1$$1$$8$$reqData = (struct anonymous$44 *)req->data;
      /* assertion reqData != ((void *)0) */
      assert(PianoRequest$$1$$1$$8$$reqData != (struct anonymous$44 *)(void *)0);
      /* assertion reqData->token != ((void *)0) */
      assert(PianoRequest$$1$$1$$8$$reqData->token != (char *)(void *)0);
      if((signed int)PianoRequest$$1$$1$$8$$reqData->type == PIANO_MUSICTYPE_INVALID)
      {
        struct json_object *return_value_json_object_new_string$21;
        return_value_json_object_new_string$21=json_object_new_string(PianoRequest$$1$$1$$8$$reqData->token);
        json_object_object_add(j, "musicToken", return_value_json_object_new_string$21);
      }

      else
      {
        struct json_object *return_value_json_object_new_string$22;
        return_value_json_object_new_string$22=json_object_new_string(PianoRequest$$1$$1$$8$$reqData->token);
        json_object_object_add(j, "trackToken", return_value_json_object_new_string$22);
        switch((signed int)PianoRequest$$1$$1$$8$$reqData->type)
        {
          case PIANO_MUSICTYPE_SONG:
          {
            return_value_json_object_new_string$23=json_object_new_string("song");
            json_object_object_add(j, "musicType", return_value_json_object_new_string$23);
            break;
          }
          case PIANO_MUSICTYPE_ARTIST:
          {
            return_value_json_object_new_string$24=json_object_new_string("artist");
            json_object_object_add(j, "musicType", return_value_json_object_new_string$24);
            break;
          }
          default:
            /* assertion 0 */
            assert(0 != 0);
        }
      }
      method = "station.createStation";
      goto __CPROVER_DUMP_L40;
    }
    case PIANO_REQUEST_ADD_SEED:
    {
      PianoRequest$$1$$1$$9$$reqData = (struct anonymous$54 *)req->data;
      /* assertion reqData != ((void *)0) */
      assert(PianoRequest$$1$$1$$9$$reqData != (struct anonymous$54 *)(void *)0);
      /* assertion reqData->station != ((void *)0) */
      assert(PianoRequest$$1$$1$$9$$reqData->station != (struct PianoStation *)(void *)0);
      /* assertion reqData->musicId != ((void *)0) */
      assert(PianoRequest$$1$$1$$9$$reqData->musicId != (char *)(void *)0);
      return_value_json_object_new_string$25=json_object_new_string(PianoRequest$$1$$1$$9$$reqData->musicId);
      json_object_object_add(j, "musicToken", return_value_json_object_new_string$25);
      return_value_json_object_new_string$26=json_object_new_string(PianoRequest$$1$$1$$9$$reqData->station->id);
      json_object_object_add(j, "stationToken", return_value_json_object_new_string$26);
      method = "station.addMusic";
      goto __CPROVER_DUMP_L40;
    }
    case PIANO_REQUEST_ADD_TIRED_SONG:
    {
      PianoRequest$$1$$1$$10$$song = (struct PianoSong *)req->data;
      /* assertion song != ((void *)0) */
      assert(PianoRequest$$1$$1$$10$$song != (struct PianoSong *)(void *)0);
      return_value_json_object_new_string$27=json_object_new_string(PianoRequest$$1$$1$$10$$song->trackToken);
      json_object_object_add(j, "trackToken", return_value_json_object_new_string$27);
      method = "user.sleepSong";
      goto __CPROVER_DUMP_L40;
    }
    case PIANO_REQUEST_SET_QUICKMIX:
    {
      curStation = ph->stations;
      a=json_object_new_array();
      for( ; !(curStation == ((struct PianoStation *)NULL)); curStation = (struct PianoStation *)(void *)curStation->head.next)
        if(!(curStation->useQuickMix == 0))
        {
          if(curStation->isQuickMix == 0)
          {
            struct json_object *return_value_json_object_new_string$28;
            return_value_json_object_new_string$28=json_object_new_string(curStation->id);
            json_object_array_add(a, return_value_json_object_new_string$28);
          }

        }

      json_object_object_add(j, "quickMixStationIds", a);
      method = "user.setQuickMix";
      goto __CPROVER_DUMP_L40;
    }
    case PIANO_REQUEST_GET_GENRE_STATIONS:
    {
      method = "station.getGenreStations";
      goto __CPROVER_DUMP_L40;
    }
    case PIANO_REQUEST_TRANSFORM_STATION:
    {
      station = (struct PianoStation *)req->data;
      /* assertion station != ((void *)0) */
      assert(station != (struct PianoStation *)(void *)0);
      return_value_json_object_new_string$29=json_object_new_string(station->id);
      json_object_object_add(j, "stationToken", return_value_json_object_new_string$29);
      method = "station.transformSharedStation";
      goto __CPROVER_DUMP_L40;
    }
    case PIANO_REQUEST_EXPLAIN:
    {
      reqData = (struct anonymous$42 *)req->data;
      /* assertion reqData != ((void *)0) */
      assert(reqData != (struct anonymous$42 *)(void *)0);
      /* assertion reqData->song != ((void *)0) */
      assert(reqData->song != (struct PianoSong *)(void *)0);
      return_value_json_object_new_string$30=json_object_new_string(reqData->song->trackToken);
      json_object_object_add(j, "trackToken", return_value_json_object_new_string$30);
      method = "track.explainTrack";
      goto __CPROVER_DUMP_L40;
    }
    case PIANO_REQUEST_BOOKMARK_SONG:
    {
      song = (struct PianoSong *)req->data;
      /* assertion song != ((void *)0) */
      assert(song != (struct PianoSong *)(void *)0);
      return_value_json_object_new_string$31=json_object_new_string(song->trackToken);
      json_object_object_add(j, "trackToken", return_value_json_object_new_string$31);
      method = "bookmark.addSongBookmark";
      goto __CPROVER_DUMP_L40;
    }
    case PIANO_REQUEST_BOOKMARK_ARTIST:
    {
      PianoRequest$$1$$1$$16$$song = (struct PianoSong *)req->data;
      /* assertion song != ((void *)0) */
      assert(PianoRequest$$1$$1$$16$$song != (struct PianoSong *)(void *)0);
      return_value_json_object_new_string$32=json_object_new_string(PianoRequest$$1$$1$$16$$song->trackToken);
      json_object_object_add(j, "trackToken", return_value_json_object_new_string$32);
      method = "bookmark.addArtistBookmark";
      goto __CPROVER_DUMP_L40;
    }
    case PIANO_REQUEST_GET_STATION_INFO:
    {
      PianoRequest$$1$$1$$17$$reqData = (struct anonymous$51 *)req->data;
      /* assertion reqData != ((void *)0) */
      assert(PianoRequest$$1$$1$$17$$reqData != (struct anonymous$51 *)(void *)0);
      /* assertion reqData->station != ((void *)0) */
      assert(PianoRequest$$1$$1$$17$$reqData->station != (struct PianoStation *)(void *)0);
      return_value_json_object_new_string$33=json_object_new_string(PianoRequest$$1$$1$$17$$reqData->station->id);
      json_object_object_add(j, "stationToken", return_value_json_object_new_string$33);
      return_value_json_object_new_boolean$34=json_object_new_boolean(1);
      json_object_object_add(j, "includeExtendedAttributes", return_value_json_object_new_boolean$34);
      method = "station.getStation";
      goto __CPROVER_DUMP_L40;
    }
    case PIANO_REQUEST_DELETE_FEEDBACK:
    {
      PianoRequest$$1$$1$$18$$song = (struct PianoSong *)req->data;
      /* assertion song != ((void *)0) */
      assert(PianoRequest$$1$$1$$18$$song != (struct PianoSong *)(void *)0);
      return_value_json_object_new_string$35=json_object_new_string(PianoRequest$$1$$1$$18$$song->feedbackId);
      json_object_object_add(j, "feedbackId", return_value_json_object_new_string$35);
      method = "station.deleteFeedback";
      goto __CPROVER_DUMP_L40;
    }
    case PIANO_REQUEST_DELETE_SEED:
    {
      PianoRequest$$1$$1$$19$$reqData = (struct anonymous$52 *)req->data;
      seedId = (char *)(void *)0;
      /* assertion reqData != ((void *)0) */
      assert(PianoRequest$$1$$1$$19$$reqData != (struct anonymous$52 *)(void *)0);
      if(!(PianoRequest$$1$$1$$19$$reqData->song == ((struct PianoSong *)NULL)))
        tmp_if_expr$36 = (_Bool)1;

      else
        tmp_if_expr$36 = PianoRequest$$1$$1$$19$$reqData->artist != (struct PianoArtist *)(void *)0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$36)
        tmp_if_expr$37 = (_Bool)1;

      else
        tmp_if_expr$37 = PianoRequest$$1$$1$$19$$reqData->station != (struct PianoStation *)(void *)0 ? (_Bool)1 : (_Bool)0;
      /* assertion reqData->song != ((void *)0) || reqData->artist != ((void *)0) || reqData->station != ((void *)0) */
      assert(tmp_if_expr$37);
      if(!(PianoRequest$$1$$1$$19$$reqData->song == ((struct PianoSong *)NULL)))
        seedId = PianoRequest$$1$$1$$19$$reqData->song->seedId;

      else
        if(!(PianoRequest$$1$$1$$19$$reqData->artist == ((struct PianoArtist *)NULL)))
          seedId = PianoRequest$$1$$1$$19$$reqData->artist->seedId;

        else
          if(!(PianoRequest$$1$$1$$19$$reqData->station == ((struct PianoStation *)NULL)))
            seedId = PianoRequest$$1$$1$$19$$reqData->station->seedId;

      /* assertion seedId != ((void *)0) */
      assert(seedId != (char *)(void *)0);
      return_value_json_object_new_string$38=json_object_new_string(seedId);
      json_object_object_add(j, "seedId", return_value_json_object_new_string$38);
      method = "station.deleteMusic";
      goto __CPROVER_DUMP_L40;
    }
    case PIANO_REQUEST_RATE_SONG:
    {
      PianoRequest$$1$$1$$20$$reqData = (struct anonymous$48 *)req->data;
      /* assertion reqData != ((void *)0) */
      assert(PianoRequest$$1$$1$$20$$reqData != (struct anonymous$48 *)(void *)0);
      /* assertion reqData->song != ((void *)0) */
      assert(PianoRequest$$1$$1$$20$$reqData->song != (struct PianoSong *)(void *)0);
      /* assertion reqData->rating != PIANO_RATE_NONE */
      assert((signed int)PianoRequest$$1$$1$$20$$reqData->rating != PIANO_RATE_NONE);
      transformedReqData.stationId = PianoRequest$$1$$1$$20$$reqData->song->stationId;
      transformedReqData.trackToken = PianoRequest$$1$$1$$20$$reqData->song->trackToken;
      transformedReqData.rating = PianoRequest$$1$$1$$20$$reqData->rating;
      req->data = (void *)&transformedReqData;
      ret=PianoRequest(ph, req, (enum anonymous$2)PIANO_REQUEST_ADD_FEEDBACK);
      req->type = (enum anonymous$2)PIANO_REQUEST_RATE_SONG;
      req->data = (void *)PianoRequest$$1$$1$$20$$reqData;
      break;
    }
    default:
    {

    __CPROVER_DUMP_L40:
      ;
      if(!(method == ((const char *)NULL)))
      {
        char *PianoRequest$$1$$2$$urlencAuthToken;
        /* assertion ph->user.authToken != ((void *)0) */
        assert(ph->user.authToken != (char *)(void *)0);
        PianoRequest$$1$$2$$urlencAuthToken=WaitressUrlEncode(ph->user.authToken);
        /* assertion urlencAuthToken != ((void *)0) */
        assert(PianoRequest$$1$$2$$urlencAuthToken != (char *)(void *)0);
        snprintf(req->urlPath, sizeof(char [1024l]) /*1024ul*/ , "/services/json/?method=%s&auth_token=%s&partner_id=%i&user_id=%s", method, PianoRequest$$1$$2$$urlencAuthToken, ph->partner.id, ph->user.listenerId);
        free((void *)PianoRequest$$1$$2$$urlencAuthToken);
        struct json_object *return_value_json_object_new_string$39;
        return_value_json_object_new_string$39=json_object_new_string(ph->user.authToken);
        json_object_object_add(j, "userAuthToken", return_value_json_object_new_string$39);
        struct json_object *return_value_json_object_new_int$40;
        return_value_json_object_new_int$40=json_object_new_int((signed int)timestamp);
        json_object_object_add(j, "syncTime", return_value_json_object_new_int$40);
      }

      jsonSendBuf=json_object_to_json_string(j);
      if(!(encrypted == (_Bool)0))
      {
        req->postData=PianoEncryptString(ph->partner.out, jsonSendBuf);
        if(req->postData == ((char *)NULL))
          ret = (enum anonymous$4)PIANO_RET_OUT_OF_MEMORY;

      }

      else
        req->postData=strdup(jsonSendBuf);
    }
  }

cleanup:
  ;
  json_object_put(j);
  return ret;
}

// PianoResponse
// file src/libpiano/piano.h line 341
enum anonymous$4 PianoResponse(struct PianoHandle *ph, struct PianoRequest *req)
{
  enum anonymous$4 ret = (enum anonymous$4)PIANO_RET_OK;
  struct json_object *j;
  struct json_object *result;
  struct json_object *status;
  /* assertion ph != ((void *)0) */
  assert(ph != (struct PianoHandle *)(void *)0);
  /* assertion req != ((void *)0) */
  assert(req != (struct PianoRequest *)(void *)0);
  j=json_tokener_parse(req->responseData);
  status=json_object_object_get(j, "stat");
  struct anonymous$13 *PianoResponse$$1$$3$$1$$reqData;
  const char *cryptedTimestamp;
  struct json_object *return_value_json_object_object_get$4;
  signed long int realTimestamp;
  char *decryptedTimestamp;
  unsigned long int decryptedSize;
  struct json_object *return_value_json_object_object_get$5;
  signed int return_value_json_object_get_int$6;
  struct json_object *PianoResponse$$1$$3$$2$$stations;
  struct json_object *mix;
  signed int return_value_json_object_array_length$7;
  struct PianoListHead *tmp_if_expr$9;
  signed int return_value_json_object_array_length$11;
  struct anonymous$14 *reqData;
  struct PianoSong *playlist;
  struct json_object *items;
  signed int return_value_json_object_array_length$14;
  struct PianoListHead *tmp_if_expr$25;
  struct anonymous$48 *PianoResponse$$1$$3$$4$$reqData;
  struct anonymous$49 *PianoResponse$$1$$3$$5$$reqData;
  struct PianoStation *station;
  struct PianoListHead *tmp_if_expr$27;
  void *return_value_PianoListDelete$28;
  struct anonymous$55 *PianoResponse$$1$$3$$7$$reqData;
  struct PianoSearchResult *searchResult;
  struct json_object *artists;
  signed int return_value_json_object_array_length$29;
  struct PianoListHead *tmp_if_expr$31;
  struct json_object *songs;
  signed int return_value_json_object_array_length$33;
  struct PianoListHead *tmp_if_expr$35;
  struct PianoStation *tmpStation;
  void *return_value_calloc$37;
  struct PianoStation *search;
  struct PianoListHead *tmp_if_expr$38;
  struct PianoListHead *tmp_if_expr$40;
  void *return_value_PianoListAppend$41;
  struct json_object *categories;
  signed int return_value_json_object_array_length$42;
  signed int return_value_json_object_array_length$44;
  struct PianoListHead *tmp_if_expr$46;
  struct PianoListHead *tmp_if_expr$48;
  struct PianoStation *PianoResponse$$1$$3$$10$$station;
  struct anonymous$42 *PianoResponse$$1$$3$$11$$reqData;
  unsigned long int strSize;
  struct json_object *explanations;
  signed int return_value_json_object_array_length$51;
  signed int return_value_json_object_array_length$53;
  struct anonymous$51 *PianoResponse$$1$$3$$12$$reqData;
  struct anonymous$50 *info;
  struct json_object *music;
  signed int return_value_json_object_array_length$55;
  struct PianoListHead *tmp_if_expr$57;
  signed int return_value_json_object_array_length$59;
  struct PianoListHead *tmp_if_expr$61;
  struct json_object *feedback;
  signed int return_value_json_object_array_length$64;
  struct PianoListHead *tmp_if_expr$68;
  if(status == ((struct json_object *)NULL))
  {
    json_object_put(j);
    return (enum anonymous$4)PIANO_RET_INVALID_RESPONSE;
  }

  else
  {
    const char *return_value_json_object_get_string$2;
    return_value_json_object_get_string$2=json_object_get_string(status);
    signed int return_value_strcmp$3;
    return_value_strcmp$3=strcmp(return_value_json_object_get_string$2, "ok");
    if(!(return_value_strcmp$3 == 0))
    {
      struct json_object *code;
      code=json_object_object_get(j, "code");
      if(code == ((struct json_object *)NULL))
        ret = (enum anonymous$4)PIANO_RET_INVALID_RESPONSE;

      else
      {
        signed int return_value_json_object_get_int$1;
        return_value_json_object_get_int$1=json_object_get_int(code);
        ret = (enum anonymous$4)(return_value_json_object_get_int$1 + 1024);
        if((signed int)ret == PIANO_RET_P_INVALID_PARTNER_LOGIN)
        {
          if((signed int)req->type == PIANO_REQUEST_LOGIN)
          {
            struct anonymous$13 *PianoResponse$$1$$2$$2$$1$$reqData = (struct anonymous$13 *)req->data;
            if((signed int)PianoResponse$$1$$2$$2$$1$$reqData->step == 1)
              ret = (enum anonymous$4)PIANO_RET_INVALID_LOGIN;

          }

        }

      }
      json_object_put(j);
      return ret;
    }

    result=json_object_object_get(j, "result");
    switch((signed int)req->type)
    {
      case PIANO_REQUEST_LOGIN:
      {
        PianoResponse$$1$$3$$1$$reqData = (struct anonymous$13 *)req->data;
        /* assertion req->responseData != ((void *)0) */
        assert(req->responseData != (char *)(void *)0);
        /* assertion reqData != ((void *)0) */
        assert(PianoResponse$$1$$3$$1$$reqData != (struct anonymous$13 *)(void *)0);
        switch((signed int)PianoResponse$$1$$3$$1$$reqData->step)
        {
          case 0:
          {
            return_value_json_object_object_get$4=json_object_object_get(result, "syncTime");
            cryptedTimestamp=json_object_get_string(return_value_json_object_object_get$4);
            realTimestamp=time((signed long int *)(void *)0);
            decryptedTimestamp = (char *)(void *)0;
            ret = (enum anonymous$4)PIANO_RET_ERR;
            decryptedTimestamp=PianoDecryptString(ph->partner.in, cryptedTimestamp, &decryptedSize);
            if(!(decryptedTimestamp == ((char *)NULL)))
            {
              if(decryptedSize >= 5ul)
              {
                unsigned long int timestamp;
                timestamp=strtoul(decryptedTimestamp + (signed long int)4, (char ** restrict )(void *)0, 0);
                ph->timeOffset = (signed int)((signed long int)realTimestamp - (signed long int)timestamp);
                ret = (enum anonymous$4)PIANO_RET_CONTINUE_REQUEST;
              }

            }

            free((void *)decryptedTimestamp);
            ph->partner.authToken=PianoJsonStrdup(result, "partnerAuthToken");
            return_value_json_object_object_get$5=json_object_object_get(result, "partnerId");
            return_value_json_object_get_int$6=json_object_get_int(return_value_json_object_object_get$5);
            ph->partner.id = (unsigned int)return_value_json_object_get_int$6;
            PianoResponse$$1$$3$$1$$reqData->step = PianoResponse$$1$$3$$1$$reqData->step + 1;
            break;
          }
          case 1:
          {
            if(!(ph->user.listenerId == ((char *)NULL)))
              PianoDestroyUserInfo(&ph->user);

            ph->user.listenerId=PianoJsonStrdup(result, "userId");
            ph->user.authToken=PianoJsonStrdup(result, "userAuthToken");
          }
        }
        break;
      }
      case PIANO_REQUEST_GET_STATIONS:
      {
        /* assertion req->responseData != ((void *)0) */
        assert(req->responseData != (char *)(void *)0);
        PianoResponse$$1$$3$$2$$stations=json_object_object_get(result, "stations");
        mix = (struct json_object *)(void *)0;
        signed int PianoResponse$$1$$3$$2$$1$$i = 0;
        do
        {
          return_value_json_object_array_length$7=json_object_array_length(PianoResponse$$1$$3$$2$$stations);
          if(PianoResponse$$1$$3$$2$$1$$i >= return_value_json_object_array_length$7)
            break;

          struct PianoStation *PianoResponse$$1$$3$$2$$1$$1$$tmpStation;
          struct json_object *s;
          s=json_object_array_get_idx(PianoResponse$$1$$3$$2$$stations, PianoResponse$$1$$3$$2$$1$$i);
          void *return_value_calloc$8;
          return_value_calloc$8=calloc((unsigned long int)1, sizeof(struct PianoStation) /*40ul*/ );
          PianoResponse$$1$$3$$2$$1$$1$$tmpStation = (struct PianoStation *)return_value_calloc$8;
          if(PianoResponse$$1$$3$$2$$1$$1$$tmpStation == ((struct PianoStation *)NULL))
            return (enum anonymous$4)PIANO_RET_OUT_OF_MEMORY;

          PianoJsonParseStation(s, PianoResponse$$1$$3$$2$$1$$1$$tmpStation);
          if(!(PianoResponse$$1$$3$$2$$1$$1$$tmpStation->isQuickMix == 0))
            mix=json_object_object_get(s, "quickMixStationIds");

          if(ph->stations == ((struct PianoStation *)NULL))
            tmp_if_expr$9 = (struct PianoListHead *)(void *)0;

          else
            tmp_if_expr$9 = &ph->stations->head;
          void *return_value_PianoListAppend$10;
          return_value_PianoListAppend$10=PianoListAppend(tmp_if_expr$9, &PianoResponse$$1$$3$$2$$1$$1$$tmpStation->head);
          ph->stations = (struct PianoStation *)return_value_PianoListAppend$10;
          PianoResponse$$1$$3$$2$$1$$i = PianoResponse$$1$$3$$2$$1$$i + 1;
        }
        while((_Bool)1);
        if(!(mix == ((struct json_object *)NULL)))
        {
          struct PianoStation *curStation = ph->stations;
          for( ; !(curStation == ((struct PianoStation *)NULL)); curStation = (struct PianoStation *)(void *)curStation->head.next)
          {
            signed int i = 0;
            do
            {
              return_value_json_object_array_length$11=json_object_array_length(mix);
              if(i >= return_value_json_object_array_length$11)
                break;

              struct json_object *id;
              id=json_object_array_get_idx(mix, i);
              const char *return_value_json_object_get_string$12;
              return_value_json_object_get_string$12=json_object_get_string(id);
              signed int return_value_strcmp$13;
              return_value_strcmp$13=strcmp(return_value_json_object_get_string$12, curStation->id);
              if(return_value_strcmp$13 == 0)
                curStation->useQuickMix = (char)1;

              i = i + 1;
            }
            while((_Bool)1);
          }
        }

        break;
      }
      case PIANO_REQUEST_GET_PLAYLIST:
      {
        reqData = (struct anonymous$14 *)req->data;
        playlist = (struct PianoSong *)(void *)0;
        /* assertion req->responseData != ((void *)0) */
        assert(req->responseData != (char *)(void *)0);
        /* assertion reqData != ((void *)0) */
        assert(reqData != (struct anonymous$14 *)(void *)0);
        /* assertion reqData->quality != PIANO_AQ_UNKNOWN */
        assert((signed int)reqData->quality != PIANO_AQ_UNKNOWN);
        items=json_object_object_get(result, "items");
        /* assertion items != ((void *)0) */
        assert(items != (struct json_object *)(void *)0);
        signed int PianoResponse$$1$$3$$3$$1$$i = 0;
        do
        {
          return_value_json_object_array_length$14=json_object_array_length(items);
          if(PianoResponse$$1$$3$$3$$1$$i >= return_value_json_object_array_length$14)
            break;

          struct json_object *PianoResponse$$1$$3$$3$$1$$1$$s;
          PianoResponse$$1$$3$$3$$1$$1$$s=json_object_array_get_idx(items, PianoResponse$$1$$3$$3$$1$$i);
          struct PianoSong *song;
          void *return_value_calloc$15;
          return_value_calloc$15=calloc((unsigned long int)1, sizeof(struct PianoSong) /*112ul*/ );
          song = (struct PianoSong *)return_value_calloc$15;
          if(song == ((struct PianoSong *)NULL))
            return (enum anonymous$4)PIANO_RET_OUT_OF_MEMORY;

          struct json_object *return_value_json_object_object_get$16;
          return_value_json_object_object_get$16=json_object_object_get(PianoResponse$$1$$3$$3$$1$$1$$s, "artistName");
          if(return_value_json_object_object_get$16 == ((struct json_object *)NULL))
            free((void *)song);

          else
          {
            /* assertion reqData->quality < sizeof (qualityMap)/sizeof (*qualityMap) */
            assert((unsigned long int)reqData->quality < sizeof(const char *[4l]) /*32ul*/  / sizeof(const char *) /*8ul*/ );
            struct json_object *map;
            map=json_object_object_get(PianoResponse$$1$$3$$3$$1$$1$$s, "audioUrlMap");
            /* assertion map != ((void *)0) */
            assert(map != (struct json_object *)(void *)0);
            if(!(map == ((struct json_object *)NULL)))
            {
              static const char *qualityMap[4l] = { "", "lowQuality", "mediumQuality", "highQuality" };
              map=json_object_object_get(map, qualityMap[(signed long int)reqData->quality]);
              if(!(map == ((struct json_object *)NULL)))
              {
                const char *encoding;
                struct json_object *return_value_json_object_object_get$17;
                return_value_json_object_object_get$17=json_object_object_get(map, "encoding");
                encoding=json_object_get_string(return_value_json_object_object_get$17);
                /* assertion encoding != ((void *)0) */
                assert(encoding != (const char *)(void *)0);
                unsigned long int k = (unsigned long int)0;
                for( ; !(k >= 3ul); k = k + 1ul)
                {
                  signed int return_value_strcmp$18;
                  static const char *formatMap[3l] = { "", "aacplus", "mp3" };
                  return_value_strcmp$18=strcmp(formatMap[(signed long int)k], encoding);
                  if(return_value_strcmp$18 == 0)
                  {
                    song->audioFormat = (enum anonymous$30)k;
                    break;
                  }

                }
                song->audioUrl=PianoJsonStrdup(map, "audioUrl");
              }

              else
              {
                ret = (enum anonymous$4)PIANO_RET_QUALITY_UNAVAILABLE;
                free((void *)song);
                PianoDestroyPlaylist(playlist);
                goto cleanup;
              }
            }

            song->artist=PianoJsonStrdup(PianoResponse$$1$$3$$3$$1$$1$$s, "artistName");
            song->album=PianoJsonStrdup(PianoResponse$$1$$3$$3$$1$$1$$s, "albumName");
            song->title=PianoJsonStrdup(PianoResponse$$1$$3$$3$$1$$1$$s, "songName");
            song->trackToken=PianoJsonStrdup(PianoResponse$$1$$3$$3$$1$$1$$s, "trackToken");
            song->stationId=PianoJsonStrdup(PianoResponse$$1$$3$$3$$1$$1$$s, "stationId");
            song->coverArt=PianoJsonStrdup(PianoResponse$$1$$3$$3$$1$$1$$s, "albumArtUrl");
            song->detailUrl=PianoJsonStrdup(PianoResponse$$1$$3$$3$$1$$1$$s, "songDetailUrl");
            struct json_object *return_value_json_object_object_get$19;
            return_value_json_object_object_get$19=json_object_object_get(PianoResponse$$1$$3$$3$$1$$1$$s, "trackGain");
            double return_value_json_object_get_double$20;
            return_value_json_object_get_double$20=json_object_get_double(return_value_json_object_object_get$19);
            song->fileGain = (float)return_value_json_object_get_double$20;
            struct json_object *return_value_json_object_object_get$21;
            return_value_json_object_object_get$21=json_object_object_get(PianoResponse$$1$$3$$3$$1$$1$$s, "trackLength");
            signed int return_value_json_object_get_int$22;
            return_value_json_object_get_int$22=json_object_get_int(return_value_json_object_object_get$21);
            song->length = (unsigned int)return_value_json_object_get_int$22;
            struct json_object *return_value_json_object_object_get$23;
            return_value_json_object_object_get$23=json_object_object_get(PianoResponse$$1$$3$$3$$1$$1$$s, "songRating");
            signed int return_value_json_object_get_int$24;
            return_value_json_object_get_int$24=json_object_get_int(return_value_json_object_object_get$23);
            if(return_value_json_object_get_int$24 == 1)
              song->rating = (enum anonymous$29)PIANO_RATE_LOVE;

            if(playlist == ((struct PianoSong *)NULL))
              tmp_if_expr$25 = (struct PianoListHead *)(void *)0;

            else
              tmp_if_expr$25 = &playlist->head;
            void *return_value_PianoListAppend$26;
            return_value_PianoListAppend$26=PianoListAppend(tmp_if_expr$25, &song->head);
            playlist = (struct PianoSong *)return_value_PianoListAppend$26;
          }
          PianoResponse$$1$$3$$3$$1$$i = PianoResponse$$1$$3$$3$$1$$i + 1;
        }
        while((_Bool)1);
        reqData->retPlaylist = playlist;
        break;
      }
      case PIANO_REQUEST_RATE_SONG:
      {
        PianoResponse$$1$$3$$4$$reqData = (struct anonymous$48 *)req->data;
        PianoResponse$$1$$3$$4$$reqData->song->rating = PianoResponse$$1$$3$$4$$reqData->rating;
        break;
      }
      case PIANO_REQUEST_ADD_FEEDBACK:
      {
        /* assertion 0 */
        assert(0 != 0);
        break;
      }
      case PIANO_REQUEST_RENAME_STATION:
      {
        PianoResponse$$1$$3$$5$$reqData = (struct anonymous$49 *)req->data;
        /* assertion reqData != ((void *)0) */
        assert(PianoResponse$$1$$3$$5$$reqData != (struct anonymous$49 *)(void *)0);
        /* assertion reqData->station != ((void *)0) */
        assert(PianoResponse$$1$$3$$5$$reqData->station != (struct PianoStation *)(void *)0);
        /* assertion reqData->newName != ((void *)0) */
        assert(PianoResponse$$1$$3$$5$$reqData->newName != (char *)(void *)0);
        free((void *)PianoResponse$$1$$3$$5$$reqData->station->name);
        PianoResponse$$1$$3$$5$$reqData->station->name=strdup(PianoResponse$$1$$3$$5$$reqData->newName);
        break;
      }
      case PIANO_REQUEST_DELETE_STATION:
      {
        station = (struct PianoStation *)req->data;
        /* assertion station != ((void *)0) */
        assert(station != (struct PianoStation *)(void *)0);
        if(ph->stations == ((struct PianoStation *)NULL))
          tmp_if_expr$27 = (struct PianoListHead *)(void *)0;

        else
          tmp_if_expr$27 = &ph->stations->head;
        return_value_PianoListDelete$28=PianoListDelete(tmp_if_expr$27, &station->head);
        ph->stations = (struct PianoStation *)return_value_PianoListDelete$28;
        PianoDestroyStation(station);
        free((void *)station);
        break;
      }
      case PIANO_REQUEST_SEARCH:
      {
        PianoResponse$$1$$3$$7$$reqData = (struct anonymous$55 *)req->data;
        /* assertion req->responseData != ((void *)0) */
        assert(req->responseData != (char *)(void *)0);
        /* assertion reqData != ((void *)0) */
        assert(PianoResponse$$1$$3$$7$$reqData != (struct anonymous$55 *)(void *)0);
        searchResult = &PianoResponse$$1$$3$$7$$reqData->searchResult;
        memset((void *)searchResult, 0, sizeof(struct PianoSearchResult) /*16ul*/ );
        artists=json_object_object_get(result, "artists");
        if(!(artists == ((struct json_object *)NULL)))
        {
          signed int PianoResponse$$1$$3$$7$$1$$1$$i = 0;
          do
          {
            return_value_json_object_array_length$29=json_object_array_length(artists);
            if(PianoResponse$$1$$3$$7$$1$$1$$i >= return_value_json_object_array_length$29)
              break;

            struct json_object *a;
            a=json_object_array_get_idx(artists, PianoResponse$$1$$3$$7$$1$$1$$i);
            struct PianoArtist *artist;
            void *return_value_calloc$30;
            return_value_calloc$30=calloc((unsigned long int)1, sizeof(struct PianoArtist) /*40ul*/ );
            artist = (struct PianoArtist *)return_value_calloc$30;
            if(artist == ((struct PianoArtist *)NULL))
              return (enum anonymous$4)PIANO_RET_OUT_OF_MEMORY;

            artist->name=PianoJsonStrdup(a, "artistName");
            artist->musicId=PianoJsonStrdup(a, "musicToken");
            if(searchResult->artists == ((struct PianoArtist *)NULL))
              tmp_if_expr$31 = (struct PianoListHead *)(void *)0;

            else
              tmp_if_expr$31 = &searchResult->artists->head;
            void *return_value_PianoListAppend$32;
            return_value_PianoListAppend$32=PianoListAppend(tmp_if_expr$31, &artist->head);
            searchResult->artists = (struct PianoArtist *)return_value_PianoListAppend$32;
            PianoResponse$$1$$3$$7$$1$$1$$i = PianoResponse$$1$$3$$7$$1$$1$$i + 1;
          }
          while((_Bool)1);
        }

        songs=json_object_object_get(result, "songs");
        if(!(songs == ((struct json_object *)NULL)))
        {
          signed int PianoResponse$$1$$3$$7$$2$$1$$i = 0;
          do
          {
            return_value_json_object_array_length$33=json_object_array_length(songs);
            if(PianoResponse$$1$$3$$7$$2$$1$$i >= return_value_json_object_array_length$33)
              break;

            struct json_object *PianoResponse$$1$$3$$7$$2$$1$$1$$s;
            PianoResponse$$1$$3$$7$$2$$1$$1$$s=json_object_array_get_idx(songs, PianoResponse$$1$$3$$7$$2$$1$$i);
            struct PianoSong *PianoResponse$$1$$3$$7$$2$$1$$1$$song;
            void *return_value_calloc$34;
            return_value_calloc$34=calloc((unsigned long int)1, sizeof(struct PianoSong) /*112ul*/ );
            PianoResponse$$1$$3$$7$$2$$1$$1$$song = (struct PianoSong *)return_value_calloc$34;
            if(PianoResponse$$1$$3$$7$$2$$1$$1$$song == ((struct PianoSong *)NULL))
              return (enum anonymous$4)PIANO_RET_OUT_OF_MEMORY;

            PianoResponse$$1$$3$$7$$2$$1$$1$$song->title=PianoJsonStrdup(PianoResponse$$1$$3$$7$$2$$1$$1$$s, "songName");
            PianoResponse$$1$$3$$7$$2$$1$$1$$song->artist=PianoJsonStrdup(PianoResponse$$1$$3$$7$$2$$1$$1$$s, "artistName");
            PianoResponse$$1$$3$$7$$2$$1$$1$$song->musicId=PianoJsonStrdup(PianoResponse$$1$$3$$7$$2$$1$$1$$s, "musicToken");
            if(searchResult->songs == ((struct PianoSong *)NULL))
              tmp_if_expr$35 = (struct PianoListHead *)(void *)0;

            else
              tmp_if_expr$35 = &searchResult->songs->head;
            void *return_value_PianoListAppend$36;
            return_value_PianoListAppend$36=PianoListAppend(tmp_if_expr$35, &PianoResponse$$1$$3$$7$$2$$1$$1$$song->head);
            searchResult->songs = (struct PianoSong *)return_value_PianoListAppend$36;
            PianoResponse$$1$$3$$7$$2$$1$$i = PianoResponse$$1$$3$$7$$2$$1$$i + 1;
          }
          while((_Bool)1);
        }

        break;
      }
      case PIANO_REQUEST_CREATE_STATION:
      {
        return_value_calloc$37=calloc((unsigned long int)1, sizeof(struct PianoStation) /*40ul*/ );
        tmpStation = (struct PianoStation *)return_value_calloc$37;
        if(tmpStation == ((struct PianoStation *)NULL))
          return (enum anonymous$4)PIANO_RET_OUT_OF_MEMORY;

        PianoJsonParseStation(result, tmpStation);
        search=PianoFindStationById(ph->stations, tmpStation->id);
        if(!(search == ((struct PianoStation *)NULL)))
        {
          if(ph->stations == ((struct PianoStation *)NULL))
            tmp_if_expr$38 = (struct PianoListHead *)(void *)0;

          else
            tmp_if_expr$38 = &ph->stations->head;
          void *return_value_PianoListDelete$39;
          return_value_PianoListDelete$39=PianoListDelete(tmp_if_expr$38, &search->head);
          ph->stations = (struct PianoStation *)return_value_PianoListDelete$39;
          PianoDestroyStation(search);
          free((void *)search);
        }

        if(ph->stations == ((struct PianoStation *)NULL))
          tmp_if_expr$40 = (struct PianoListHead *)(void *)0;

        else
          tmp_if_expr$40 = &ph->stations->head;
        return_value_PianoListAppend$41=PianoListAppend(tmp_if_expr$40, &tmpStation->head);
        ph->stations = (struct PianoStation *)return_value_PianoListAppend$41;
        break;
      }
      case PIANO_REQUEST_ADD_SEED:

      case PIANO_REQUEST_ADD_TIRED_SONG:

      case PIANO_REQUEST_SET_QUICKMIX:

      case PIANO_REQUEST_BOOKMARK_SONG:

      case PIANO_REQUEST_BOOKMARK_ARTIST:

      case PIANO_REQUEST_DELETE_FEEDBACK:

      case PIANO_REQUEST_DELETE_SEED:
        break;
      case PIANO_REQUEST_GET_GENRE_STATIONS:
      {
        categories=json_object_object_get(result, "categories");
        if(!(categories == ((struct json_object *)NULL)))
        {
          signed int PianoResponse$$1$$3$$9$$1$$1$$i = 0;
          do
          {
            return_value_json_object_array_length$42=json_object_array_length(categories);
            if(PianoResponse$$1$$3$$9$$1$$1$$i >= return_value_json_object_array_length$42)
              break;

            struct json_object *c;
            c=json_object_array_get_idx(categories, PianoResponse$$1$$3$$9$$1$$1$$i);
            struct PianoGenreCategory *tmpGenreCategory;
            void *return_value_calloc$43;
            return_value_calloc$43=calloc((unsigned long int)1, sizeof(struct PianoGenreCategory) /*24ul*/ );
            tmpGenreCategory = (struct PianoGenreCategory *)return_value_calloc$43;
            if(tmpGenreCategory == ((struct PianoGenreCategory *)NULL))
              return (enum anonymous$4)PIANO_RET_OUT_OF_MEMORY;

            tmpGenreCategory->name=PianoJsonStrdup(c, "categoryName");
            struct json_object *stations;
            stations=json_object_object_get(c, "stations");
            if(!(stations == ((struct json_object *)NULL)))
            {
              signed int PianoResponse$$1$$3$$9$$1$$1$$1$$2$$1$$k = 0;
              do
              {
                return_value_json_object_array_length$44=json_object_array_length(stations);
                if(PianoResponse$$1$$3$$9$$1$$1$$1$$2$$1$$k >= return_value_json_object_array_length$44)
                  break;

                struct json_object *PianoResponse$$1$$3$$9$$1$$1$$1$$2$$1$$1$$s;
                PianoResponse$$1$$3$$9$$1$$1$$1$$2$$1$$1$$s=json_object_array_get_idx(stations, PianoResponse$$1$$3$$9$$1$$1$$1$$2$$1$$k);
                struct PianoGenre *tmpGenre;
                void *return_value_calloc$45;
                return_value_calloc$45=calloc((unsigned long int)1, sizeof(struct PianoGenre) /*24ul*/ );
                tmpGenre = (struct PianoGenre *)return_value_calloc$45;
                if(tmpGenre == ((struct PianoGenre *)NULL))
                  return (enum anonymous$4)PIANO_RET_OUT_OF_MEMORY;

                tmpGenre->name=PianoJsonStrdup(PianoResponse$$1$$3$$9$$1$$1$$1$$2$$1$$1$$s, "stationName");
                tmpGenre->musicId=PianoJsonStrdup(PianoResponse$$1$$3$$9$$1$$1$$1$$2$$1$$1$$s, "stationToken");
                if(tmpGenreCategory->genres == ((struct PianoGenre *)NULL))
                  tmp_if_expr$46 = (struct PianoListHead *)(void *)0;

                else
                  tmp_if_expr$46 = &tmpGenreCategory->genres->head;
                void *return_value_PianoListAppend$47;
                return_value_PianoListAppend$47=PianoListAppend(tmp_if_expr$46, &tmpGenre->head);
                tmpGenreCategory->genres = (struct PianoGenre *)return_value_PianoListAppend$47;
                PianoResponse$$1$$3$$9$$1$$1$$1$$2$$1$$k = PianoResponse$$1$$3$$9$$1$$1$$1$$2$$1$$k + 1;
              }
              while((_Bool)1);
            }

            if(ph->genreStations == ((struct PianoGenreCategory *)NULL))
              tmp_if_expr$48 = (struct PianoListHead *)(void *)0;

            else
              tmp_if_expr$48 = &ph->genreStations->head;
            void *return_value_PianoListAppend$49;
            return_value_PianoListAppend$49=PianoListAppend(tmp_if_expr$48, &tmpGenreCategory->head);
            ph->genreStations = (struct PianoGenreCategory *)return_value_PianoListAppend$49;
            PianoResponse$$1$$3$$9$$1$$1$$i = PianoResponse$$1$$3$$9$$1$$1$$i + 1;
          }
          while((_Bool)1);
        }

        break;
      }
      case PIANO_REQUEST_TRANSFORM_STATION:
      {
        PianoResponse$$1$$3$$10$$station = (struct PianoStation *)req->data;
        /* assertion req->responseData != ((void *)0) */
        assert(req->responseData != (char *)(void *)0);
        /* assertion station != ((void *)0) */
        assert(PianoResponse$$1$$3$$10$$station != (struct PianoStation *)(void *)0);
        PianoResponse$$1$$3$$10$$station->isCreator = (char)1;
        break;
      }
      case PIANO_REQUEST_EXPLAIN:
      {
        PianoResponse$$1$$3$$11$$reqData = (struct anonymous$42 *)req->data;
        strSize = (const unsigned long int)768;
        /* assertion reqData != ((void *)0) */
        assert(PianoResponse$$1$$3$$11$$reqData != (struct anonymous$42 *)(void *)0);
        explanations=json_object_object_get(result, "explanations");
        if(!(explanations == ((struct json_object *)NULL)))
        {
          void *return_value_malloc$50;
          return_value_malloc$50=malloc(strSize * sizeof(char) /*1ul*/ );
          PianoResponse$$1$$3$$11$$reqData->retExplain = (char *)return_value_malloc$50;
          strncpy(PianoResponse$$1$$3$$11$$reqData->retExplain, "We're playing this track because it features ", strSize);
          signed int PianoResponse$$1$$3$$11$$1$$1$$i = 0;
          do
          {
            return_value_json_object_array_length$51=json_object_array_length(explanations);
            if(PianoResponse$$1$$3$$11$$1$$1$$i >= return_value_json_object_array_length$51)
              break;

            struct json_object *e;
            e=json_object_array_get_idx(explanations, PianoResponse$$1$$3$$11$$1$$1$$i);
            const char *PianoResponse$$1$$3$$11$$1$$1$$1$$s;
            struct json_object *return_value_json_object_object_get$52;
            return_value_json_object_object_get$52=json_object_object_get(e, "focusTraitName");
            PianoResponse$$1$$3$$11$$1$$1$$1$$s=json_object_get_string(return_value_json_object_object_get$52);
            PianoStrpcat(PianoResponse$$1$$3$$11$$reqData->retExplain, PianoResponse$$1$$3$$11$$1$$1$$1$$s, strSize);
            signed int return_value_json_object_array_length$54;
            return_value_json_object_array_length$54=json_object_array_length(explanations);
            if(!(PianoResponse$$1$$3$$11$$1$$1$$i >= return_value_json_object_array_length$54 + -2))
              PianoStrpcat(PianoResponse$$1$$3$$11$$reqData->retExplain, ", ", strSize);

            else
            {
              return_value_json_object_array_length$53=json_object_array_length(explanations);
              if(PianoResponse$$1$$3$$11$$1$$1$$i == return_value_json_object_array_length$53 + -2)
                PianoStrpcat(PianoResponse$$1$$3$$11$$reqData->retExplain, " and ", strSize);

              else
                PianoStrpcat(PianoResponse$$1$$3$$11$$reqData->retExplain, ".", strSize);
            }
            PianoResponse$$1$$3$$11$$1$$1$$i = PianoResponse$$1$$3$$11$$1$$1$$i + 1;
          }
          while((_Bool)1);
        }

        break;
      }
      case PIANO_REQUEST_GET_STATION_INFO:
      {
        PianoResponse$$1$$3$$12$$reqData = (struct anonymous$51 *)req->data;
        /* assertion reqData != ((void *)0) */
        assert(PianoResponse$$1$$3$$12$$reqData != (struct anonymous$51 *)(void *)0);
        info = &PianoResponse$$1$$3$$12$$reqData->info;
        /* assertion info != ((void *)0) */
        assert(info != (struct anonymous$50 *)(void *)0);
        music=json_object_object_get(result, "music");
        if(!(music == ((struct json_object *)NULL)))
        {
          struct json_object *PianoResponse$$1$$3$$12$$1$$songs;
          PianoResponse$$1$$3$$12$$1$$songs=json_object_object_get(music, "songs");
          if(!(PianoResponse$$1$$3$$12$$1$$songs == ((struct json_object *)NULL)))
          {
            signed int PianoResponse$$1$$3$$12$$1$$1$$1$$i = 0;
            do
            {
              return_value_json_object_array_length$55=json_object_array_length(PianoResponse$$1$$3$$12$$1$$songs);
              if(PianoResponse$$1$$3$$12$$1$$1$$1$$i >= return_value_json_object_array_length$55)
                break;

              struct json_object *PianoResponse$$1$$3$$12$$1$$1$$1$$1$$s;
              PianoResponse$$1$$3$$12$$1$$1$$1$$1$$s=json_object_array_get_idx(PianoResponse$$1$$3$$12$$1$$songs, PianoResponse$$1$$3$$12$$1$$1$$1$$i);
              struct PianoSong *seedSong;
              void *return_value_calloc$56;
              return_value_calloc$56=calloc((unsigned long int)1, sizeof(struct PianoSong) /*112ul*/ );
              seedSong = (struct PianoSong *)return_value_calloc$56;
              if(seedSong == ((struct PianoSong *)NULL))
                return (enum anonymous$4)PIANO_RET_OUT_OF_MEMORY;

              seedSong->title=PianoJsonStrdup(PianoResponse$$1$$3$$12$$1$$1$$1$$1$$s, "songName");
              seedSong->artist=PianoJsonStrdup(PianoResponse$$1$$3$$12$$1$$1$$1$$1$$s, "artistName");
              seedSong->seedId=PianoJsonStrdup(PianoResponse$$1$$3$$12$$1$$1$$1$$1$$s, "seedId");
              if(info->songSeeds == ((struct PianoSong *)NULL))
                tmp_if_expr$57 = (struct PianoListHead *)(void *)0;

              else
                tmp_if_expr$57 = &info->songSeeds->head;
              void *return_value_PianoListAppend$58;
              return_value_PianoListAppend$58=PianoListAppend(tmp_if_expr$57, &seedSong->head);
              info->songSeeds = (struct PianoSong *)return_value_PianoListAppend$58;
              PianoResponse$$1$$3$$12$$1$$1$$1$$i = PianoResponse$$1$$3$$12$$1$$1$$1$$i + 1;
            }
            while((_Bool)1);
          }

          struct json_object *PianoResponse$$1$$3$$12$$1$$artists;
          PianoResponse$$1$$3$$12$$1$$artists=json_object_object_get(music, "artists");
          if(!(PianoResponse$$1$$3$$12$$1$$artists == ((struct json_object *)NULL)))
          {
            signed int PianoResponse$$1$$3$$12$$1$$2$$1$$i = 0;
            do
            {
              return_value_json_object_array_length$59=json_object_array_length(PianoResponse$$1$$3$$12$$1$$artists);
              if(PianoResponse$$1$$3$$12$$1$$2$$1$$i >= return_value_json_object_array_length$59)
                break;

              struct json_object *PianoResponse$$1$$3$$12$$1$$2$$1$$1$$a;
              PianoResponse$$1$$3$$12$$1$$2$$1$$1$$a=json_object_array_get_idx(PianoResponse$$1$$3$$12$$1$$artists, PianoResponse$$1$$3$$12$$1$$2$$1$$i);
              struct PianoArtist *seedArtist;
              void *return_value_calloc$60;
              return_value_calloc$60=calloc((unsigned long int)1, sizeof(struct PianoArtist) /*40ul*/ );
              seedArtist = (struct PianoArtist *)return_value_calloc$60;
              if(seedArtist == ((struct PianoArtist *)NULL))
                return (enum anonymous$4)PIANO_RET_OUT_OF_MEMORY;

              seedArtist->name=PianoJsonStrdup(PianoResponse$$1$$3$$12$$1$$2$$1$$1$$a, "artistName");
              seedArtist->seedId=PianoJsonStrdup(PianoResponse$$1$$3$$12$$1$$2$$1$$1$$a, "seedId");
              if(info->artistSeeds == ((struct PianoArtist *)NULL))
                tmp_if_expr$61 = (struct PianoListHead *)(void *)0;

              else
                tmp_if_expr$61 = &info->artistSeeds->head;
              void *return_value_PianoListAppend$62;
              return_value_PianoListAppend$62=PianoListAppend(tmp_if_expr$61, &seedArtist->head);
              info->artistSeeds = (struct PianoArtist *)return_value_PianoListAppend$62;
              PianoResponse$$1$$3$$12$$1$$2$$1$$i = PianoResponse$$1$$3$$12$$1$$2$$1$$i + 1;
            }
            while((_Bool)1);
          }

        }

        feedback=json_object_object_get(result, "feedback");
        if(!(feedback == ((struct json_object *)NULL)))
        {
          unsigned long int PianoResponse$$1$$3$$12$$2$$1$$i = (unsigned long int)0;
          for( ; !(PianoResponse$$1$$3$$12$$2$$1$$i >= 2ul); PianoResponse$$1$$3$$12$$2$$1$$i = PianoResponse$$1$$3$$12$$2$$1$$i + 1ul)
          {
            struct json_object *val;
            static const char * const keys[2l] = { "thumbsUp", "thumbsDown" };
            val=json_object_object_get(feedback, keys[(signed long int)PianoResponse$$1$$3$$12$$2$$1$$i]);
            if(!(val == ((struct json_object *)NULL)))
            {
              signed int return_value_json_object_is_type$63;
              return_value_json_object_is_type$63=json_object_is_type(val, (enum json_type)json_type_array);
              /* assertion json_object_is_type (val, json_type_array) */
              assert(return_value_json_object_is_type$63 != 0);
              signed int PianoResponse$$1$$3$$12$$2$$1$$1$$2$$i = 0;
              do
              {
                return_value_json_object_array_length$64=json_object_array_length(val);
                if(PianoResponse$$1$$3$$12$$2$$1$$1$$2$$i >= return_value_json_object_array_length$64)
                  break;

                struct json_object *PianoResponse$$1$$3$$12$$2$$1$$1$$2$$1$$s;
                PianoResponse$$1$$3$$12$$2$$1$$1$$2$$1$$s=json_object_array_get_idx(val, PianoResponse$$1$$3$$12$$2$$1$$1$$2$$i);
                struct PianoSong *feedbackSong;
                void *return_value_calloc$65;
                return_value_calloc$65=calloc((unsigned long int)1, sizeof(struct PianoSong) /*112ul*/ );
                feedbackSong = (struct PianoSong *)return_value_calloc$65;
                if(feedbackSong == ((struct PianoSong *)NULL))
                  return (enum anonymous$4)PIANO_RET_OUT_OF_MEMORY;

                feedbackSong->title=PianoJsonStrdup(PianoResponse$$1$$3$$12$$2$$1$$1$$2$$1$$s, "songName");
                feedbackSong->artist=PianoJsonStrdup(PianoResponse$$1$$3$$12$$2$$1$$1$$2$$1$$s, "artistName");
                feedbackSong->feedbackId=PianoJsonStrdup(PianoResponse$$1$$3$$12$$2$$1$$1$$2$$1$$s, "feedbackId");
                struct json_object *return_value_json_object_object_get$66;
                return_value_json_object_object_get$66=json_object_object_get(PianoResponse$$1$$3$$12$$2$$1$$1$$2$$1$$s, "isPositive");
                signed int return_value_json_object_get_boolean$67;
                return_value_json_object_get_boolean$67=json_object_get_boolean(return_value_json_object_object_get$66);
                feedbackSong->rating = (enum anonymous$29)(return_value_json_object_get_boolean$67 != 0 ? PIANO_RATE_LOVE : PIANO_RATE_BAN);
                if(info->feedback == ((struct PianoSong *)NULL))
                  tmp_if_expr$68 = (struct PianoListHead *)(void *)0;

                else
                  tmp_if_expr$68 = &info->feedback->head;
                void *return_value_PianoListAppend$69;
                return_value_PianoListAppend$69=PianoListAppend(tmp_if_expr$68, &feedbackSong->head);
                info->feedback = (struct PianoSong *)return_value_PianoListAppend$69;
                PianoResponse$$1$$3$$12$$2$$1$$1$$2$$i = PianoResponse$$1$$3$$12$$2$$1$$1$$2$$i + 1;
              }
              while((_Bool)1);
            }

          }
        }

      }
    }

  cleanup:
    ;
    json_object_put(j);
    return ret;
  }
}

// PianoStrpcat
// file src/libpiano/response.c line 57
static void PianoStrpcat(char * restrict dest, const char * restrict src, unsigned long int len)
{
  for( ; !((signed int)*dest == 0); len = len - 1ul)
  {
    if(!(len >= 2ul))
      break;

    dest = dest + 1l;
  }
  for( ; !((signed int)*src == 0); len = len - 1ul)
  {
    if(!(len >= 2ul))
      break;

    *dest = *src;
    dest = dest + 1l;
    src = src + 1l;
  }
  *dest = (char)0;
}

// WaitressBase64Encode
// file src/libwaitress/waitress.c line 127
static char * WaitressBase64Encode(const char *in)
{
  /* assertion in != ((void *)0) */
  assert(in != (const char *)(void *)0);
  unsigned long int inLen;
  inLen=strlen(in);
  char *out;
  char *outPos;
  const char *inPos;
  unsigned long int alphabetLen;
  static const char *alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  alphabetLen=strlen(alphabet);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((inLen * (unsigned long int)2 + (unsigned long int)1) * sizeof(char) /*1ul*/ );
  out = (char *)return_value_malloc$1;
  unsigned char WaitressBase64Encode$$1$$3$$1$$idx;
  unsigned char idx;
  if(out == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    outPos = out;
    inPos = in;
    while(inLen >= 3ul)
    {
      unsigned char WaitressBase64Encode$$1$$2$$idx = (unsigned char)((signed int)*inPos >> 2 & 0x3f);
      /* assertion idx < alphabetLen */
      assert((unsigned long int)WaitressBase64Encode$$1$$2$$idx < alphabetLen);
      *outPos = alphabet[(signed long int)WaitressBase64Encode$$1$$2$$idx];
      outPos = outPos + 1l;
      WaitressBase64Encode$$1$$2$$idx = (unsigned char)(((signed int)*inPos & 0x3) << 4);
      inPos = inPos + 1l;
      WaitressBase64Encode$$1$$2$$idx = WaitressBase64Encode$$1$$2$$idx | (unsigned char)((signed int)*inPos >> 4 & 0xf);
      /* assertion idx < alphabetLen */
      assert((unsigned long int)WaitressBase64Encode$$1$$2$$idx < alphabetLen);
      *outPos = alphabet[(signed long int)WaitressBase64Encode$$1$$2$$idx];
      outPos = outPos + 1l;
      WaitressBase64Encode$$1$$2$$idx = (unsigned char)(((signed int)*inPos & 0xf) << 2);
      inPos = inPos + 1l;
      WaitressBase64Encode$$1$$2$$idx = WaitressBase64Encode$$1$$2$$idx | (unsigned char)((signed int)*inPos >> 6 & 0x3);
      /* assertion idx < alphabetLen */
      assert((unsigned long int)WaitressBase64Encode$$1$$2$$idx < alphabetLen);
      *outPos = alphabet[(signed long int)WaitressBase64Encode$$1$$2$$idx];
      outPos = outPos + 1l;
      WaitressBase64Encode$$1$$2$$idx = (unsigned char)((signed int)*inPos & 0x3f);
      inPos = inPos + 1l;
      /* assertion idx < alphabetLen */
      assert((unsigned long int)WaitressBase64Encode$$1$$2$$idx < alphabetLen);
      *outPos = alphabet[(signed long int)WaitressBase64Encode$$1$$2$$idx];
      outPos = outPos + 1l;
      inLen = inLen - (unsigned long int)3;
    }
    switch(inLen)
    {
      case (unsigned long int)2:
      {
        WaitressBase64Encode$$1$$3$$1$$idx = (unsigned char)((signed int)*inPos >> 2 & 0x3f);
        /* assertion idx < alphabetLen */
        assert((unsigned long int)WaitressBase64Encode$$1$$3$$1$$idx < alphabetLen);
        *outPos = alphabet[(signed long int)WaitressBase64Encode$$1$$3$$1$$idx];
        outPos = outPos + 1l;
        WaitressBase64Encode$$1$$3$$1$$idx = (unsigned char)(((signed int)*inPos & 0x3) << 4);
        inPos = inPos + 1l;
        WaitressBase64Encode$$1$$3$$1$$idx = WaitressBase64Encode$$1$$3$$1$$idx | (unsigned char)((signed int)*inPos >> 4 & 0xf);
        /* assertion idx < alphabetLen */
        assert((unsigned long int)WaitressBase64Encode$$1$$3$$1$$idx < alphabetLen);
        *outPos = alphabet[(signed long int)WaitressBase64Encode$$1$$3$$1$$idx];
        outPos = outPos + 1l;
        WaitressBase64Encode$$1$$3$$1$$idx = (unsigned char)(((signed int)*inPos & 0xf) << 2);
        /* assertion idx < alphabetLen */
        assert((unsigned long int)WaitressBase64Encode$$1$$3$$1$$idx < alphabetLen);
        *outPos = alphabet[(signed long int)WaitressBase64Encode$$1$$3$$1$$idx];
        outPos = outPos + 1l;
        *outPos = (char)61;
        outPos = outPos + 1l;
        break;
      }
      case (unsigned long int)1:
      {
        idx = (unsigned char)((signed int)*inPos >> 2 & 0x3f);
        /* assertion idx < alphabetLen */
        assert((unsigned long int)idx < alphabetLen);
        *outPos = alphabet[(signed long int)idx];
        outPos = outPos + 1l;
        idx = (unsigned char)(((signed int)*inPos & 0x3) << 4);
        /* assertion idx < alphabetLen */
        assert((unsigned long int)idx < alphabetLen);
        *outPos = alphabet[(signed long int)idx];
        outPos = outPos + 1l;
        *outPos = (char)61;
        outPos = outPos + 1l;
        *outPos = (char)61;
        outPos = outPos + 1l;
      }
    }
    *outPos = (char)0;
    return out;
  }
}

// WaitressConnect
// file src/libwaitress/waitress.c line 772
static enum anonymous$5 WaitressConnect(struct anonymous$7 *waith)
{
  enum anonymous$5 ret;
  struct addrinfo hints;
  struct addrinfo *gares;
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  _Bool return_value_WaitressProxyEnabled$5;
  return_value_WaitressProxyEnabled$5=WaitressProxyEnabled(waith);
  if(!(return_value_WaitressProxyEnabled$5 == (_Bool)0))
  {
    const char *return_value_WaitressDefaultPort$1;
    return_value_WaitressDefaultPort$1=WaitressDefaultPort(&waith->proxy);
    signed int return_value_getaddrinfo$2;
    return_value_getaddrinfo$2=getaddrinfo(waith->proxy.host, return_value_WaitressDefaultPort$1, &hints, &gares);
    if(!(return_value_getaddrinfo$2 == 0))
      return (enum anonymous$5)WAITRESS_RET_GETADDR_ERR;

  }

  else
  {
    const char *return_value_WaitressDefaultPort$3;
    return_value_WaitressDefaultPort$3=WaitressDefaultPort(&waith->url);
    signed int return_value_getaddrinfo$4;
    return_value_getaddrinfo$4=getaddrinfo(waith->url.host, return_value_WaitressDefaultPort$3, &hints, &gares);
    if(!(return_value_getaddrinfo$4 == 0))
      return (enum anonymous$5)WAITRESS_RET_GETADDR_ERR;

  }
  struct addrinfo *gacurr = gares;
  for( ; !(gacurr == ((struct addrinfo *)NULL)); gacurr = gacurr->ai_next)
  {
    signed int sock = -1;
    ret = (enum anonymous$5)WAITRESS_RET_OK;
    sock=socket(gacurr->ai_family, gacurr->ai_socktype, gacurr->ai_protocol);
    if(sock == -1)
      ret = (enum anonymous$5)WAITRESS_RET_SOCK_ERR;

    else
    {
      signed int pollres;
      fcntl(sock, 4, 04000);
      connect(sock, gacurr->ai_addr, gacurr->ai_addrlen);
      pollres=WaitressPollLoop(sock, (signed short int)0x004, waith->timeout);
      if(pollres == 0)
        ret = (enum anonymous$5)WAITRESS_RET_TIMEOUT;

      else
        if(pollres == -1)
          ret = (enum anonymous$5)WAITRESS_RET_ERR;

        else
        {
          unsigned int pollresSize = (unsigned int)sizeof(signed int) /*4ul*/ ;
          getsockopt(sock, 1, 4, (void *)&pollres, &pollresSize);
          if(!(pollres == 0))
            ret = (enum anonymous$5)WAITRESS_RET_CONNECT_REFUSED;

          else
          {
            waith->request.sockfd = sock;
            break;
          }
        }
      close(sock);
    }
  }
  freeaddrinfo(gares);
  if(!((signed int)ret == WAITRESS_RET_OK))
    return ret;

  else
  {
    if(!(waith->url.tls == (_Bool)0))
    {
      enum anonymous$5 wRet;
      _Bool return_value_WaitressProxyEnabled$11;
      return_value_WaitressProxyEnabled$11=WaitressProxyEnabled(waith);
      if(!(return_value_WaitressProxyEnabled$11 == (_Bool)0))
      {
        char buf[256l];
        unsigned long int size;
        const char *return_value_WaitressDefaultPort$6;
        return_value_WaitressDefaultPort$6=WaitressDefaultPort(&waith->url);
        const char *return_value_WaitressDefaultPort$7;
        return_value_WaitressDefaultPort$7=WaitressDefaultPort(&waith->url);
        snprintf(buf, sizeof(char [256l]) /*256ul*/ , "CONNECT %s:%s HTTP/1.1\r\nHost: %s:%s\r\nProxy-Connection: close\r\n", waith->url.host, return_value_WaitressDefaultPort$6, waith->url.host, return_value_WaitressDefaultPort$7);
        unsigned long int return_value_strlen$8;
        return_value_strlen$8=strlen(buf);
        wRet=waith->request.write((void *)waith, buf, return_value_strlen$8);
        if(!((signed int)wRet == WAITRESS_RET_OK))
          return wRet;

        _Bool return_value_WaitressFormatAuthorization$10;
        return_value_WaitressFormatAuthorization$10=WaitressFormatAuthorization(waith, &waith->proxy, "Proxy-", buf, (const unsigned long int)(10 * 1024));
        if(!(return_value_WaitressFormatAuthorization$10 == (_Bool)0))
        {
          unsigned long int return_value_strlen$9;
          return_value_strlen$9=strlen(buf);
          wRet=waith->request.write((void *)waith, buf, return_value_strlen$9);
          if(!((signed int)wRet == WAITRESS_RET_OK))
            return wRet;

        }

        wRet=waith->request.write((void *)waith, "\r\n", (const unsigned long int)2);
        if(!((signed int)wRet == WAITRESS_RET_OK))
          return wRet;

        wRet=WaitressReceiveHeaders(waith, &size);
        if(!((signed int)wRet == WAITRESS_RET_OK))
          return wRet;

      }

      unsigned long int return_value_strlen$12;
      return_value_strlen$12=strlen(waith->url.host);
      gnutls_server_name_set(waith->request.tlsSession, (enum anonymous$25)GNUTLS_NAME_DNS, (const void *)waith->url.host, return_value_strlen$12);
      signed int return_value_gnutls_handshake$13;
      return_value_gnutls_handshake$13=gnutls_handshake(waith->request.tlsSession);
      if(!(return_value_gnutls_handshake$13 == 0))
        return (enum anonymous$5)WAITRESS_RET_TLS_HANDSHAKE_ERR;

      wRet=WaitressTlsVerify(waith);
      if(!((signed int)wRet == WAITRESS_RET_OK))
        return wRet;

      waith->request.read = WaitressGnutlsRead;
      waith->request.write = WaitressGnutlsWrite;
    }

    return (enum anonymous$5)WAITRESS_RET_OK;
  }
}

// WaitressDefaultPort
// file src/libwaitress/waitress.c line 577
static const char * WaitressDefaultPort(const struct anonymous$16 * const url)
{
  /* assertion url != ((void *)0) */
  assert(url != (const struct anonymous$16 *)(void *)0);
  char *tmp_if_expr$1;
  char *tmp_if_expr$2;
  if(!(url->tls == (_Bool)0))
  {
    if(url->tlsPort == ((const char *)NULL))
      tmp_if_expr$1 = "443";

    else
      tmp_if_expr$1 = url->tlsPort;
    return tmp_if_expr$1;
  }

  else
  {
    if(url->port == ((const char *)NULL))
      tmp_if_expr$2 = "80";

    else
      tmp_if_expr$2 = url->port;
    return tmp_if_expr$2;
  }
}

// WaitressErrorToStr
// file src/libwaitress/waitress.h line 133
const char * WaitressErrorToStr(enum anonymous$5 wRet)
{
  switch((signed int)wRet)
  {
    case WAITRESS_RET_OK:
      return "Everything's fine :)";
    case WAITRESS_RET_ERR:
      return "Unknown.";
    case WAITRESS_RET_STATUS_UNKNOWN:
      return "Unknown HTTP status code.";
    case WAITRESS_RET_NOTFOUND:
      return "File not found.";
    case WAITRESS_RET_FORBIDDEN:
      return "Forbidden.";
    case WAITRESS_RET_CONNECT_REFUSED:
      return "Connection refused.";
    case WAITRESS_RET_SOCK_ERR:
      return "Socket error.";
    case WAITRESS_RET_GETADDR_ERR:
      return "DNS lookup failed.";
    case WAITRESS_RET_CB_ABORT:
      return "Callback aborted request.";
    case WAITRESS_RET_PARTIAL_FILE:
      return "Partial file.";
    case WAITRESS_RET_TIMEOUT:
      return "Timeout.";
    case WAITRESS_RET_READ_ERR:
      return "Read error.";
    case WAITRESS_RET_CONNECTION_CLOSED:
      return "Connection closed by remote host.";
    case WAITRESS_RET_DECODING_ERR:
      return "Invalid encoded data.";
    case WAITRESS_RET_TLS_WRITE_ERR:
      return "TLS write failed.";
    case WAITRESS_RET_TLS_READ_ERR:
      return "TLS read failed.";
    case WAITRESS_RET_TLS_HANDSHAKE_ERR:
      return "TLS handshake failed.";
    case WAITRESS_RET_TLS_FINGERPRINT_MISMATCH:
      return "TLS fingerprint mismatch.";
    default:
      return "No error message available.";
  }
}

// WaitressFetchBuf
// file src/libwaitress/waitress.h line 131
enum anonymous$5 WaitressFetchBuf(struct anonymous$7 *waith, char **retBuffer)
{
  struct anonymous$9 buffer;
  enum anonymous$5 wRet;
  /* assertion waith != ((void *)0) */
  assert(waith != (struct anonymous$7 *)(void *)0);
  /* assertion retBuffer != ((void *)0) */
  assert(retBuffer != (char **)(void *)0);
  memset((void *)&buffer, 0, sizeof(struct anonymous$9) /*16ul*/ );
  waith->data = (void *)&buffer;
  waith->callback = WaitressFetchBufCb;
  wRet=WaitressFetchCall(waith);
  *retBuffer = buffer.data;
  return wRet;
}

// WaitressFetchBufCb
// file src/libwaitress/waitress.c line 375
static enum anonymous$8 WaitressFetchBufCb(void *recvData, unsigned long int recvDataSize, void *extraData)
{
  char *recvBytes = (char *)recvData;
  struct anonymous$9 *buffer = (struct anonymous$9 *)extraData;
  if(buffer->data == ((char *)NULL))
  {
    void *return_value_malloc$1;
    return_value_malloc$1=malloc(sizeof(char) /*1ul*/  * (recvDataSize + (unsigned long int)1));
    buffer->data = (char *)return_value_malloc$1;
    if(buffer->data == ((char *)NULL))
      return (enum anonymous$8)WAITRESS_CB_RET_ERR;

  }

  else
  {
    char *newbuf;
    void *return_value_realloc$2;
    return_value_realloc$2=realloc((void *)buffer->data, sizeof(char) /*1ul*/  * (buffer->pos + recvDataSize + (unsigned long int)1));
    newbuf = (char *)return_value_realloc$2;
    if(newbuf == ((char *)NULL))
    {
      free((void *)buffer->data);
      return (enum anonymous$8)WAITRESS_CB_RET_ERR;
    }

    buffer->data = newbuf;
  }
  memcpy((void *)(buffer->data + (signed long int)buffer->pos), (const void *)recvBytes, recvDataSize);
  buffer->pos = buffer->pos + recvDataSize;
  buffer->data[(signed long int)buffer->pos] = (char)0;
  return (enum anonymous$8)WAITRESS_CB_RET_OK;
}

// WaitressFetchCall
// file src/libwaitress/waitress.c line 1099
enum anonymous$5 WaitressFetchCall(struct anonymous$7 *waith)
{
  enum anonymous$5 wRet = (enum anonymous$5)WAITRESS_RET_OK;
  memset((void *)&waith->request, 0, sizeof(struct anonymous$15) /*80ul*/ );
  waith->request.sockfd = -1;
  waith->request.dataHandler = WaitressHandleIdentity;
  waith->request.read = WaitressOrdinaryRead;
  waith->request.write = WaitressOrdinaryWrite;
  waith->request.contentLengthKnown = (_Bool)0;
  if(!(waith->url.tls == (_Bool)0))
  {
    gnutls_init(&waith->request.tlsSession, (unsigned int)(1 << 1));
    gnutls_set_default_priority(waith->request.tlsSession);
    gnutls_certificate_allocate_credentials(&waith->tlsCred);
    signed int return_value_gnutls_credentials_set$1;
    return_value_gnutls_credentials_set$1=gnutls_credentials_set(waith->request.tlsSession, (enum anonymous$19)GNUTLS_CRD_CERTIFICATE, (void *)waith->tlsCred);
    if(!(return_value_gnutls_credentials_set$1 == 0))
      return (enum anonymous$5)WAITRESS_RET_ERR;

    gnutls_transport_set_ptr(waith->request.tlsSession, (void *)waith);
    gnutls_transport_set_pull_function(waith->request.tlsSession, WaitressPollRead);
    gnutls_transport_set_push_function(waith->request.tlsSession, WaitressPollWrite);
  }

  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)(10 * 1024) * sizeof(char) /*1ul*/ );
  waith->request.buf = (char *)return_value_malloc$2;
  wRet=WaitressConnect(waith);
  if((signed int)wRet == WAITRESS_RET_OK)
  {
    wRet=WaitressSendRequest(waith);
    if((signed int)wRet == WAITRESS_RET_OK)
      wRet=WaitressReceiveResponse(waith);

    if(!(waith->url.tls == (_Bool)0))
      gnutls_bye(waith->request.tlsSession, (enum anonymous$23)GNUTLS_SHUT_RDWR);

  }

  if(!(waith->url.tls == (_Bool)0))
  {
    gnutls_deinit(waith->request.tlsSession);
    gnutls_certificate_free_credentials(waith->tlsCred);
  }

  if(!(waith->request.sockfd == -1))
    close(waith->request.sockfd);

  free((void *)waith->request.buf);
  if((signed int)wRet == WAITRESS_RET_OK)
  {
    if(waith->request.contentReceived >= waith->request.contentLength)
      goto __CPROVER_DUMP_L7;

    return (enum anonymous$5)WAITRESS_RET_PARTIAL_FILE;
  }

  else
  {

  __CPROVER_DUMP_L7:
    ;
    return wRet;
  }
}

// WaitressFormatAuthorization
// file src/libwaitress/waitress.c line 552
static _Bool WaitressFormatAuthorization(struct anonymous$7 *waith, struct anonymous$16 *url, const char *prefix, char *writeBuf, const unsigned long int writeBufSize)
{
  /* assertion waith != ((void *)0) */
  assert(waith != (struct anonymous$7 *)(void *)0);
  /* assertion url != ((void *)0) */
  assert(url != (struct anonymous$16 *)(void *)0);
  /* assertion prefix != ((void *)0) */
  assert(prefix != (const char *)(void *)0);
  /* assertion writeBuf != ((void *)0) */
  assert(writeBuf != (char *)(void *)0);
  /* assertion writeBufSize > 0 */
  assert(writeBufSize > (unsigned long int)0);
  const char *tmp_if_expr$1;
  if(!(url->user == ((const char *)NULL)))
  {
    char userPass[1024l];
    char *encodedUserPass;
    if(!(url->password == ((const char *)NULL)))
      tmp_if_expr$1 = url->password;

    else
      tmp_if_expr$1 = "";
    snprintf(userPass, sizeof(char [1024l]) /*1024ul*/ , "%s:%s", url->user, tmp_if_expr$1);
    encodedUserPass=WaitressBase64Encode(userPass);
    /* assertion encodedUserPass != ((void *)0) */
    assert(encodedUserPass != (char *)(void *)0);
    snprintf(writeBuf, writeBufSize, "%sAuthorization: Basic %s\r\n", prefix, encodedUserPass);
    free((void *)encodedUserPass);
    return (_Bool)1;
  }

  return (_Bool)0;
}

// WaitressFree
// file src/libwaitress/waitress.h line 127
void WaitressFree(struct anonymous$7 *waith)
{
  /* assertion waith != ((void *)0) */
  assert(waith != (struct anonymous$7 *)(void *)0);
  free((void *)waith->url.url);
  free((void *)waith->proxy.url);
  memset((void *)waith, 0, sizeof(struct anonymous$7) /*264ul*/ );
}

// WaitressGetline
// file src/libwaitress/waitress.c line 591
static char * WaitressGetline(char * const str)
{
  char *eol;
  /* assertion str != ((void *)0) */
  assert(str != (char *)(void *)0);
  eol=strchr(str, 10);
  if(eol == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    *eol = (char)0;
    if(eol + -1l >= str)
    {
      if((signed int)eol[-1l] == 13)
        *(eol - (signed long int)1) = (char)0;

    }

    eol = eol + 1l;
    /* assertion eol >= str */
    assert(eol >= str);
    return eol;
  }
}

// WaitressGnutlsRead
// file src/libwaitress/waitress.c line 534
static enum anonymous$5 WaitressGnutlsRead(void *data, char *buf, const unsigned long int size, unsigned long int *retSize)
{
  struct anonymous$7 *waith = (struct anonymous$7 *)data;
  signed long int ret;
  ret=gnutls_record_recv(waith->request.tlsSession, (void *)buf, size);
  if(!(ret >= 0l))
    return (enum anonymous$5)WAITRESS_RET_TLS_READ_ERR;

  else
    *retSize = (unsigned long int)ret;
  return waith->request.readWriteRet;
}

// WaitressGnutlsWrite
// file src/libwaitress/waitress.c line 481
static enum anonymous$5 WaitressGnutlsWrite(void *data, const char *buf, const unsigned long int size)
{
  struct anonymous$7 *waith = (struct anonymous$7 *)data;
  signed long int return_value_gnutls_record_send$1;
  return_value_gnutls_record_send$1=gnutls_record_send(waith->request.tlsSession, (const void *)buf, size);
  if(!(return_value_gnutls_record_send$1 >= 0l))
    return (enum anonymous$5)WAITRESS_RET_TLS_WRITE_ERR;

  else
    return waith->request.readWriteRet;
}

// WaitressHandleChunked
// file src/libwaitress/waitress.c line 633
static enum anonymous$12 WaitressHandleChunked(void *data, char *buf, const unsigned long int size)
{
  /* assertion data != ((void *)0) */
  assert(data != (void *)0);
  /* assertion buf != ((void *)0) */
  assert(buf != (char *)(void *)0);
  struct anonymous$7 * const waith = (struct anonymous$7 *)data;
  unsigned long int pos = (unsigned long int)0;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  while(!(pos >= size))
    switch((signed int)waith->request.chunkedState)
    {
      case CHUNKSIZE:
      {
        if((signed int)buf[(signed long int)pos] >= 48)
          tmp_if_expr$2 = (signed int)buf[(signed long int)pos] <= 57 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        if(tmp_if_expr$2)
        {
          waith->request.chunkSize = waith->request.chunkSize << 4;
          waith->request.chunkSize = waith->request.chunkSize | (unsigned long int)((signed int)buf[(signed long int)pos] & 0xf);
        }

        else
        {
          if((signed int)buf[(signed long int)pos] >= 97)
            tmp_if_expr$1 = (signed int)buf[(signed long int)pos] <= 102 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$1 = (_Bool)0;
          if(tmp_if_expr$1)
          {
            waith->request.chunkSize = waith->request.chunkSize << 4;
            waith->request.chunkSize = waith->request.chunkSize | (unsigned long int)((signed int)buf[(signed long int)pos] + 9 & 0xf);
          }

          else
            if(!((signed int)buf[(signed long int)pos] == 13))
            {
              if((signed int)buf[(signed long int)pos] == 10)
              {
                waith->request.chunkedState = (enum anonymous$46)DATA;
                if(waith->request.chunkSize == 0ul)
                  return (enum anonymous$12)WAITRESS_HANDLER_DONE;

              }

              else
                return (enum anonymous$12)WAITRESS_HANDLER_ERR;
            }

        }
        pos = pos + 1ul;
        break;
      }
      case DATA:
        if(waith->request.chunkSize >= 1ul)
        {
          /* assertion size >= pos */
          assert(size >= pos);
          unsigned long int payloadSize = size - pos;
          if(!(waith->request.chunkSize >= payloadSize))
            payloadSize = waith->request.chunkSize;

          enum anonymous$12 return_value_WaitressHandleIdentity$3;
          return_value_WaitressHandleIdentity$3=WaitressHandleIdentity((void *)waith, &buf[(signed long int)pos], payloadSize);
          if((signed int)return_value_WaitressHandleIdentity$3 == WAITRESS_HANDLER_ABORTED)
            return (enum anonymous$12)WAITRESS_HANDLER_ABORTED;

          pos = pos + payloadSize;
          /* assertion waith->request.chunkSize >= payloadSize */
          assert(waith->request.chunkSize >= payloadSize);
          waith->request.chunkSize = waith->request.chunkSize - payloadSize;
        }

        else
        {
          if((signed int)buf[(signed long int)pos] == 10)
            waith->request.chunkedState = (enum anonymous$46)CHUNKSIZE;

          pos = pos + 1ul;
        }
    }
  return (enum anonymous$12)WAITRESS_HANDLER_CONTINUE;
}

// WaitressHandleHeader
// file src/libwaitress/waitress.c line 698
static void WaitressHandleHeader(struct anonymous$7 *waith, const char * const key, const char * const value)
{
  /* assertion waith != ((void *)0) */
  assert(waith != (struct anonymous$7 *)(void *)0);
  /* assertion key != ((void *)0) */
  assert(key != (const char *)(void *)0);
  /* assertion value != ((void *)0) */
  assert(value != (const char *)(void *)0);
  signed int return_value_strcasecmp$4;
  return_value_strcasecmp$4=strcasecmp(key, "Content-Length");
  signed int return_value_strcasecmp$3;
  if(return_value_strcasecmp$4 == 0)
  {
    signed long int return_value_atol$1;
    return_value_atol$1=atol(value);
    waith->request.contentLength = (unsigned long int)return_value_atol$1;
    waith->request.contentLengthKnown = (_Bool)1;
  }

  else
  {
    return_value_strcasecmp$3=strcasecmp(key, "Transfer-Encoding");
    if(return_value_strcasecmp$3 == 0)
    {
      signed int return_value_strcasecmp$2;
      return_value_strcasecmp$2=strcasecmp(value, "chunked");
      if(return_value_strcasecmp$2 == 0)
        waith->request.dataHandler = WaitressHandleChunked;

    }

  }
}

// WaitressHandleIdentity
// file src/libwaitress/waitress.c line 616
static enum anonymous$12 WaitressHandleIdentity(void *data, char *buf, const unsigned long int size)
{
  /* assertion data != ((void *)0) */
  assert(data != (void *)0);
  /* assertion buf != ((void *)0) */
  assert(buf != (char *)(void *)0);
  struct anonymous$7 *waith = (struct anonymous$7 *)data;
  waith->request.contentReceived = waith->request.contentReceived + size;
  enum anonymous$8 return_value;
  return_value=waith->callback((void *)buf, size, waith->data);
  if((signed int)return_value == WAITRESS_CB_RET_ERR)
    return (enum anonymous$12)WAITRESS_HANDLER_ABORTED;

  else
    return (enum anonymous$12)WAITRESS_HANDLER_CONTINUE;
}

// WaitressInit
// file src/libwaitress/waitress.h line 126
void WaitressInit(struct anonymous$7 *waith)
{
  /* assertion waith != ((void *)0) */
  assert(waith != (struct anonymous$7 *)(void *)0);
  memset((void *)waith, 0, sizeof(struct anonymous$7) /*264ul*/ );
  waith->timeout = 30000;
}

// WaitressOrdinaryRead
// file src/libwaitress/waitress.c line 522
static enum anonymous$5 WaitressOrdinaryRead(void *data, char *buf, const unsigned long int size, unsigned long int *retSize)
{
  struct anonymous$7 *waith = (struct anonymous$7 *)data;
  signed long int ret;
  ret=WaitressPollRead((void *)waith, (void *)buf, size);
  if(!(ret == -1l))
  {
    /* assertion ret >= 0 */
    assert(ret >= (signed long int)0);
    *retSize = (unsigned long int)ret;
  }

  return waith->request.readWriteRet;
}

// WaitressOrdinaryWrite
// file src/libwaitress/waitress.c line 473
static enum anonymous$5 WaitressOrdinaryWrite(void *data, const char *buf, const unsigned long int size)
{
  struct anonymous$7 *waith = (struct anonymous$7 *)data;
  WaitressPollWrite((void *)waith, (const void *)buf, size);
  return waith->request.readWriteRet;
}

// WaitressParseStatusline
// file src/libwaitress/waitress.c line 716
static signed int WaitressParseStatusline(const char * const line)
{
  char status[4l] = { '0', '0', '0', 0 };
  /* assertion line != ((void *)0) */
  assert(line != (const char *)(void *)0);
  signed int return_value_sscanf$2;
  return_value_sscanf$2=sscanf(line, "HTTP/1.%*1[0-9] %3[0-9] ", (const void *)status);
  if(return_value_sscanf$2 == 1)
  {
    signed int return_value_atoi$1;
    return_value_atoi$1=atoi(status);
    return return_value_atoi$1;
  }

  return -1;
}

// WaitressPollLoop
// file src/libwaitress/waitress.c line 427
static signed int WaitressPollLoop(signed int fd, signed short int events, signed int timeout)
{
  signed int pollres = -1;
  struct pollfd sockpoll = { .fd=fd, .events=events, .revents=(signed short int)0 };
  /* assertion fd != -1 */
  assert(fd != -1);
  signed int *return_value___errno_location$1;
  _Bool tmp_if_expr$3;
  signed int *return_value___errno_location$2;
  _Bool tmp_if_expr$5;
  signed int *return_value___errno_location$4;
  do
  {
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    *return_value___errno_location$6 = 0;
    pollres=poll(&sockpoll, (unsigned long int)1, timeout);
    return_value___errno_location$1=__errno_location();
    if(*return_value___errno_location$1 == 4)
      tmp_if_expr$3 = (_Bool)1;

    else
    {
      return_value___errno_location$2=__errno_location();
      tmp_if_expr$3 = *return_value___errno_location$2 == 115 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$3)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      return_value___errno_location$4=__errno_location();
      tmp_if_expr$5 = *return_value___errno_location$4 == 11 ? (_Bool)1 : (_Bool)0;
    }
  }
  while(tmp_if_expr$5);
  return pollres;
}

// WaitressPollRead
// file src/libwaitress/waitress.c line 497
static signed long int WaitressPollRead(void *data, void *buf, unsigned long int count)
{
  signed int pollres = -1;
  signed long int retSize;
  struct anonymous$7 *waith = (struct anonymous$7 *)data;
  /* assertion waith != ((void *)0) */
  assert(waith != (struct anonymous$7 *)(void *)0);
  /* assertion buf != ((void *)0) */
  assert(buf != (void *)0);
  pollres=WaitressPollLoop(waith->request.sockfd, (signed short int)0x001, waith->timeout);
  if(pollres == 0)
  {
    waith->request.readWriteRet = (enum anonymous$5)WAITRESS_RET_TIMEOUT;
    return (signed long int)-1;
  }

  else
    if(pollres == -1)
    {
      waith->request.readWriteRet = (enum anonymous$5)WAITRESS_RET_ERR;
      return (signed long int)-1;
    }

  retSize=read(waith->request.sockfd, buf, count);
  if(retSize == -1l)
  {
    waith->request.readWriteRet = (enum anonymous$5)WAITRESS_RET_READ_ERR;
    return (signed long int)-1;
  }

  else
  {
    waith->request.readWriteRet = (enum anonymous$5)WAITRESS_RET_OK;
    return retSize;
  }
}

// WaitressPollWrite
// file src/libwaitress/waitress.c line 447
static signed long int WaitressPollWrite(void *data, const void *buf, unsigned long int count)
{
  signed int pollres = -1;
  signed long int retSize;
  struct anonymous$7 *waith = (struct anonymous$7 *)data;
  /* assertion waith != ((void *)0) */
  assert(waith != (struct anonymous$7 *)(void *)0);
  /* assertion buf != ((void *)0) */
  assert(buf != (void *)0);
  pollres=WaitressPollLoop(waith->request.sockfd, (signed short int)0x004, waith->timeout);
  if(pollres == 0)
  {
    waith->request.readWriteRet = (enum anonymous$5)WAITRESS_RET_TIMEOUT;
    return (signed long int)-1;
  }

  else
    if(pollres == -1)
    {
      waith->request.readWriteRet = (enum anonymous$5)WAITRESS_RET_ERR;
      return (signed long int)-1;
    }

  retSize=write(waith->request.sockfd, buf, count);
  if(retSize == -1l)
  {
    waith->request.readWriteRet = (enum anonymous$5)WAITRESS_RET_ERR;
    return (signed long int)-1;
  }

  else
  {
    waith->request.readWriteRet = (enum anonymous$5)WAITRESS_RET_OK;
    return retSize;
  }
}

// WaitressProxyEnabled
// file src/libwaitress/waitress.c line 89
static _Bool WaitressProxyEnabled(const struct anonymous$7 *waith)
{
  /* assertion waith != ((void *)0) */
  assert(waith != (const struct anonymous$7 *)(void *)0);
  return waith->proxy.host != (const char *)(void *)0;
}

// WaitressReceiveHeaders
// file src/libwaitress/waitress.c line 961
static enum anonymous$5 WaitressReceiveHeaders(struct anonymous$7 *waith, unsigned long int *retRemaining)
{
  char * const buf = waith->request.buf;
  unsigned long int bufFilled = (unsigned long int)0;
  unsigned long int recvSize = (unsigned long int)0;
  char *nextLine = (char *)(void *)0;
  char *thisLine = (char *)(void *)0;
  /* #anon_enum$HDRM_HEAD=0$HDRM_LINES=1$HDRM_FINISHED=2 */
enum anonymous$26 { HDRM_HEAD=0, HDRM_LINES=1, HDRM_FINISHED=2 };

/* */
  ;
  enum anonymous$26 hdrParseMode = (enum anonymous$26)HDRM_HEAD;
  enum anonymous$5 wRet = (enum anonymous$5)WAITRESS_RET_OK;
  nextLine = buf;
  signed int return_value_WaitressParseStatusline$1;
  char *tmp_post$2;
  const unsigned short int **return_value___ctype_b_loc$3;
  if(!((signed int)hdrParseMode == HDRM_FINISHED))
  {
    wRet=waith->request.read((void *)waith, buf + (signed long int)bufFilled, (unsigned long int)(10 * 1024 - 1) - bufFilled, &recvSize);
    if(!((signed int)wRet == WAITRESS_RET_OK))
      return wRet;

    if(recvSize == 0ul)
      return (enum anonymous$5)WAITRESS_RET_CONNECTION_CLOSED;

    bufFilled = bufFilled + recvSize;
    buf[(signed long int)bufFilled] = (char)0;
    thisLine = buf;
    if(!((signed int)hdrParseMode == HDRM_FINISHED))
    {
      nextLine=WaitressGetline(thisLine);
      if(!(nextLine == ((char *)NULL)))
      {
        if((signed int)hdrParseMode == HDRM_HEAD)
        {
          return_value_WaitressParseStatusline$1=WaitressParseStatusline(thisLine);
          if(return_value_WaitressParseStatusline$1 == 200 || return_value_WaitressParseStatusline$1 == 206)
          {
            hdrParseMode = (enum anonymous$26)HDRM_LINES;
            return (enum anonymous$5)WAITRESS_RET_BAD_REQUEST;
            return (enum anonymous$5)WAITRESS_RET_FORBIDDEN;
            return (enum anonymous$5)WAITRESS_RET_NOTFOUND;
          }

          return (enum anonymous$5)WAITRESS_RET_STATUS_UNKNOWN;
          if((signed int)*thisLine == 0)
            hdrParseMode = (enum anonymous$26)HDRM_FINISHED;

          else
          {
            char *key = thisLine;
            char *val;
            val=strchr(thisLine, 58);
            if(!(val == ((char *)NULL)))
            {
              tmp_post$2 = val;
              val = val + 1l;
              *tmp_post$2 = (char)0;
              if(!((signed int)*val == 0))
              {
                return_value___ctype_b_loc$3=__ctype_b_loc();
                if(!((8192 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)(unsigned char)*val]) == 0))
                  val = val + 1l;

              }

              WaitressHandleHeader(waith, key, val);
            }

          }
        }

        thisLine = nextLine;
      }

    }

    memmove((void *)buf, (const void *)thisLine, bufFilled - (unsigned long int)(thisLine - buf));
    bufFilled = bufFilled - (unsigned long int)(thisLine - buf);
  }

  *retRemaining = bufFilled;
  return wRet;
}

// WaitressReceiveResponse
// file src/libwaitress/waitress.c line 1051
static enum anonymous$5 WaitressReceiveResponse(struct anonymous$7 *waith)
{
  /* assertion waith != ((void *)0) */
  assert(waith != (struct anonymous$7 *)(void *)0);
  /* assertion waith->request.buf != ((void *)0) */
  assert(waith->request.buf != (char *)(void *)0);
  char * const buf = waith->request.buf;
  unsigned long int recvSize = (unsigned long int)0;
  enum anonymous$5 wRet = (enum anonymous$5)WAITRESS_RET_OK;
  wRet=WaitressReceiveHeaders(waith, &recvSize);
  if(!((signed int)wRet == WAITRESS_RET_OK))
    return wRet;

  else
  {
    buf[(signed long int)recvSize] = (char)0;
    enum anonymous$12 return_value;
    return_value=waith->request.dataHandler((void *)waith, buf, recvSize);
    if((signed int)return_value == WAITRESS_HANDLER_DONE)
    {
      return (enum anonymous$5)WAITRESS_RET_OK;
      return (enum anonymous$5)WAITRESS_RET_DECODING_ERR;
      return (enum anonymous$5)WAITRESS_RET_CB_ABORT;
    }

    wRet=waith->request.read((void *)waith, buf, (const unsigned long int)(10 * 1024 - 1), &recvSize);
    if(!((signed int)wRet == WAITRESS_RET_OK))
      return wRet;

    else
      return (enum anonymous$5)WAITRESS_RET_OK;
  }
}

// WaitressSendRequest
// file src/libwaitress/waitress.c line 893
static enum anonymous$5 WaitressSendRequest(struct anonymous$7 *waith)
{
  /* assertion waith != ((void *)0) */
  assert(waith != (struct anonymous$7 *)(void *)0);
  /* assertion waith->request.buf != ((void *)0) */
  assert(waith->request.buf != (char *)(void *)0);
  const char *path = waith->url.path;
  char * const buf = waith->request.buf;
  enum anonymous$5 wRet = (enum anonymous$5)WAITRESS_RET_OK;
  if(waith->url.path == ((const char *)NULL))
    path = "";

  else
    if((signed int)*waith->url.path == 47)
      path = path + 1l;

  _Bool return_value_WaitressProxyEnabled$2;
  return_value_WaitressProxyEnabled$2=WaitressProxyEnabled(waith);
  _Bool tmp_if_expr$3;
  if(!(return_value_WaitressProxyEnabled$2 == (_Bool)0))
    tmp_if_expr$3 = !(waith->url.tls != (_Bool)0) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$3 = (_Bool)0;
  if(tmp_if_expr$3)
  {
    const char *return_value_WaitressDefaultPort$1;
    return_value_WaitressDefaultPort$1=WaitressDefaultPort(&waith->url);
    snprintf(buf, (unsigned long int)(10 * 1024), "%s http://%s:%s/%s HTTP/1.1\r\nHost: %s\r\nUser-Agent: libwaitress\r\nConnection: Close\r\n", (signed int)waith->method == WAITRESS_METHOD_GET ? "GET" : "POST", waith->url.host, return_value_WaitressDefaultPort$1, path, waith->url.host);
  }

  else
    snprintf(buf, (unsigned long int)(10 * 1024), "%s /%s HTTP/1.1\r\nHost: %s\r\nUser-Agent: libwaitress\r\nConnection: Close\r\n", (signed int)waith->method == WAITRESS_METHOD_GET ? "GET" : "POST", path, waith->url.host);
  unsigned long int return_value_strlen$4;
  return_value_strlen$4=strlen(buf);
  wRet=waith->request.write((void *)waith, buf, return_value_strlen$4);
  _Bool return_value_WaitressFormatAuthorization$10;
  if(!((signed int)wRet == WAITRESS_RET_OK))
    return wRet;

  else
  {
    if((signed int)waith->method == WAITRESS_METHOD_POST)
    {
      if(!(waith->postData == ((const char *)NULL)))
      {
        unsigned long int return_value_strlen$5;
        return_value_strlen$5=strlen(waith->postData);
        snprintf(buf, (unsigned long int)(10 * 1024), "Content-Length: %zu\r\n", return_value_strlen$5);
        unsigned long int return_value_strlen$6;
        return_value_strlen$6=strlen(buf);
        wRet=waith->request.write((void *)waith, buf, return_value_strlen$6);
        if(!((signed int)wRet == WAITRESS_RET_OK))
          return wRet;

      }

    }

    _Bool return_value_WaitressFormatAuthorization$8;
    return_value_WaitressFormatAuthorization$8=WaitressFormatAuthorization(waith, &waith->url, "", buf, (const unsigned long int)(10 * 1024));
    if(!(return_value_WaitressFormatAuthorization$8 == (_Bool)0))
    {
      unsigned long int return_value_strlen$7;
      return_value_strlen$7=strlen(buf);
      wRet=waith->request.write((void *)waith, buf, return_value_strlen$7);
      if(!((signed int)wRet == WAITRESS_RET_OK))
        return wRet;

    }

    if(waith->url.tls == (_Bool)0)
    {
      return_value_WaitressFormatAuthorization$10=WaitressFormatAuthorization(waith, &waith->proxy, "Proxy-", buf, (const unsigned long int)(10 * 1024));
      if(!(return_value_WaitressFormatAuthorization$10 == (_Bool)0))
      {
        unsigned long int return_value_strlen$9;
        return_value_strlen$9=strlen(buf);
        wRet=waith->request.write((void *)waith, buf, return_value_strlen$9);
        if(!((signed int)wRet == WAITRESS_RET_OK))
          return wRet;

      }

    }

    if(!(waith->extraHeaders == ((const char *)NULL)))
    {
      unsigned long int return_value_strlen$11;
      return_value_strlen$11=strlen(waith->extraHeaders);
      wRet=waith->request.write((void *)waith, waith->extraHeaders, return_value_strlen$11);
      if(!((signed int)wRet == WAITRESS_RET_OK))
        return wRet;

    }

    wRet=waith->request.write((void *)waith, "\r\n", (const unsigned long int)2);
    if(!((signed int)wRet == WAITRESS_RET_OK))
      return wRet;

    else
    {
      if((signed int)waith->method == WAITRESS_METHOD_POST)
      {
        if(!(waith->postData == ((const char *)NULL)))
        {
          unsigned long int return_value_strlen$12;
          return_value_strlen$12=strlen(waith->postData);
          wRet=waith->request.write((void *)waith, waith->postData, return_value_strlen$12);
          if(!((signed int)wRet == WAITRESS_RET_OK))
            return wRet;

        }

      }

      return (enum anonymous$5)WAITRESS_RET_OK;
    }
  }
}

// WaitressSetProxy
// file src/libwaitress/waitress.h line 128
_Bool WaitressSetProxy(struct anonymous$7 *waith, const char *url)
{
  _Bool return_value_WaitressSplitUrl$1;
  return_value_WaitressSplitUrl$1=WaitressSplitUrl(url, &waith->proxy);
  return return_value_WaitressSplitUrl$1;
}

// WaitressSetUrl
// file src/libwaitress/waitress.c line 357
_Bool WaitressSetUrl(struct anonymous$7 *waith, const char *url)
{
  _Bool return_value_WaitressSplitUrl$1;
  return_value_WaitressSplitUrl$1=WaitressSplitUrl(url, &waith->url);
  return return_value_WaitressSplitUrl$1;
}

// WaitressSplitUrl
// file src/libwaitress/waitress.c line 233
static _Bool WaitressSplitUrl(const char *inurl, struct anonymous$16 *retUrl)
{
  /* assertion inurl != ((void *)0) */
  assert(inurl != (const char *)(void *)0);
  /* assertion retUrl != ((void *)0) */
  assert(retUrl != (struct anonymous$16 *)(void *)0);
  unsigned long int return_value_strlen$2;
  static const char *httpPrefix = "http://";
  return_value_strlen$2=strlen(httpPrefix);
  signed int return_value_strncmp$3;
  return_value_strncmp$3=strncmp(httpPrefix, inurl, return_value_strlen$2);
  if(return_value_strncmp$3 == 0)
  {
    /* #anon_enum$FIND_USER=0$FIND_PASS=1$FIND_HOST=2$FIND_PORT=3$FIND_PATH=4$DONE=5 */
enum anonymous$27 { FIND_USER=0, FIND_PASS=1, FIND_HOST=2, FIND_PORT=3, FIND_PATH=4, DONE=5 };

/* */
    ;
    enum anonymous$27 state = (enum anonymous$27)FIND_USER;
    enum anonymous$27 newState = (enum anonymous$27)FIND_USER;
    char *url;
    char *urlPos;
    char *assignStart;
    const char **assign = (const char **)(void *)0;
    url=strdup(inurl);
    retUrl->url = url;
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(httpPrefix);
    urlPos = url + (signed long int)return_value_strlen$1;
    assignStart = urlPos;
    if((signed int)*urlPos == 0)
      state = (enum anonymous$27)DONE;

    while(!((signed int)state == DONE))
    {
      const char c = *urlPos;
      switch((signed int)state)
      {
        case FIND_USER:
        {
          if((signed int)c == 58)
          {
            assign = &retUrl->user;
            newState = (enum anonymous$27)FIND_PASS;
          }

          else
            if((signed int)c == 64)
            {
              assign = &retUrl->user;
              newState = (enum anonymous$27)FIND_HOST;
            }

            else
              if((signed int)c == 47)
              {
                assign = &retUrl->host;
                newState = (enum anonymous$27)FIND_PATH;
              }

              else
                if((signed int)c == 0)
                {
                  assign = &retUrl->host;
                  newState = (enum anonymous$27)DONE;
                }

          goto __CPROVER_DUMP_L19;
        }
        case FIND_PASS:
        {
          if((signed int)c == 64)
          {
            assign = &retUrl->password;
            newState = (enum anonymous$27)FIND_HOST;
          }

          else
            if((signed int)c == 47)
            {
              assign = &retUrl->port;
              newState = (enum anonymous$27)FIND_PATH;
            }

            else
              if((signed int)c == 0)
              {
                assign = &retUrl->port;
                newState = (enum anonymous$27)DONE;
              }

          goto __CPROVER_DUMP_L19;
        }
        case FIND_HOST:
        {
          if((signed int)c == 58)
          {
            assign = &retUrl->host;
            newState = (enum anonymous$27)FIND_PORT;
          }

          else
            if((signed int)c == 47)
            {
              assign = &retUrl->host;
              newState = (enum anonymous$27)FIND_PATH;
            }

            else
              if((signed int)c == 0)
              {
                assign = &retUrl->host;
                newState = (enum anonymous$27)DONE;
              }

          goto __CPROVER_DUMP_L19;
        }
        case FIND_PORT:
        {
          if((signed int)c == 47)
          {
            assign = &retUrl->port;
            newState = (enum anonymous$27)FIND_PATH;
          }

          else
            if((signed int)c == 0)
            {
              assign = &retUrl->port;
              newState = (enum anonymous$27)DONE;
            }

          goto __CPROVER_DUMP_L19;
        }
        case FIND_PATH:
          if((signed int)c == 0)
          {
            assign = &retUrl->path;
            newState = (enum anonymous$27)DONE;
          }

        case DONE:

        default:
        {

        __CPROVER_DUMP_L19:
          ;
          if(!(assign == ((const char **)NULL)))
          {
            *assign = assignStart;
            *urlPos = (char)0;
            assignStart = urlPos + (signed long int)1;
            state = newState;
            assign = (const char **)(void *)0;
          }

          urlPos = urlPos + 1l;
        }
      }
    }
    if(!(retUrl->user == ((const char *)NULL)))
    {
      if(retUrl->host == ((const char *)NULL))
      {
        if(!(retUrl->port == ((const char *)NULL)))
        {
          retUrl->host = retUrl->user;
          retUrl->user = (const char *)(void *)0;
        }

      }

    }

    return (_Bool)1;
  }

  return (_Bool)0;
}

// WaitressTlsVerify
// file src/libwaitress/waitress.c line 729
static enum anonymous$5 WaitressTlsVerify(const struct anonymous$7 *waith)
{
  struct gnutls_session_int *session = waith->request.tlsSession;
  unsigned int certListSize;
  const struct anonymous$11 *certList;
  struct gnutls_x509_crt_int *cert;
  enum anonymous$10 return_value_gnutls_certificate_type_get$1;
  return_value_gnutls_certificate_type_get$1=gnutls_certificate_type_get(session);
  if(!((signed int)return_value_gnutls_certificate_type_get$1 == GNUTLS_CRT_X509))
    return (enum anonymous$5)WAITRESS_RET_TLS_HANDSHAKE_ERR;

  else
  {
    certList=gnutls_certificate_get_peers(session, &certListSize);
    if(certList == ((const struct anonymous$11 *)NULL))
      return (enum anonymous$5)WAITRESS_RET_TLS_HANDSHAKE_ERR;

    else
    {
      signed int return_value_gnutls_x509_crt_init$2;
      return_value_gnutls_x509_crt_init$2=gnutls_x509_crt_init(&cert);
      if(!(return_value_gnutls_x509_crt_init$2 == 0))
        return (enum anonymous$5)WAITRESS_RET_TLS_HANDSHAKE_ERR;

      else
      {
        signed int return_value_gnutls_x509_crt_import$3;
        return_value_gnutls_x509_crt_import$3=gnutls_x509_crt_import(cert, &certList[(signed long int)0], (enum anonymous$20)GNUTLS_X509_FMT_DER);
        if(!(return_value_gnutls_x509_crt_import$3 == 0))
          return (enum anonymous$5)WAITRESS_RET_TLS_HANDSHAKE_ERR;

        else
        {
          char fingerprint[20l];
          unsigned long int fingerprintSize = sizeof(char [20l]) /*20ul*/ ;
          signed int return_value_gnutls_x509_crt_get_fingerprint$4;
          return_value_gnutls_x509_crt_get_fingerprint$4=gnutls_x509_crt_get_fingerprint(cert, (enum anonymous$21)GNUTLS_DIG_SHA1, (void *)fingerprint, &fingerprintSize);
          if(!(return_value_gnutls_x509_crt_get_fingerprint$4 == 0))
            return (enum anonymous$5)WAITRESS_RET_TLS_HANDSHAKE_ERR;

          else
          {
            /* assertion waith->tlsFingerprint != ((void *)0) */
            assert(waith->tlsFingerprint != (const char *)(void *)0);
            signed int return_value_memcmp$5;
            return_value_memcmp$5=memcmp((const void *)fingerprint, (const void *)waith->tlsFingerprint, sizeof(char [20l]) /*20ul*/ );
            if(!(return_value_memcmp$5 == 0))
              return (enum anonymous$5)WAITRESS_RET_TLS_FINGERPRINT_MISMATCH;

            else
            {
              gnutls_x509_crt_deinit(cert);
              return (enum anonymous$5)WAITRESS_RET_OK;
            }
          }
        }
      }
    }
  }
}

// WaitressUrlEncode
// file src/libwaitress/waitress.h line 129
char * WaitressUrlEncode(const char *in)
{
  /* assertion in != ((void *)0) */
  assert(in != (const char *)(void *)0);
  unsigned long int inLen;
  inLen=strlen(in);
  char *out;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc(inLen * (unsigned long int)3 + (unsigned long int)1, sizeof(const char) /*1ul*/ );
  out = (char *)return_value_calloc$1;
  const char *inPos = in;
  char *outPos = out;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  char *tmp_post$2;
  char *tmp_post$3;
  while(!((unsigned long int)(inPos - in) >= inLen))
  {
    const unsigned short int **return_value___ctype_b_loc$4;
    return_value___ctype_b_loc$4=__ctype_b_loc();
    if((8 & (signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)*inPos]) == 0)
      tmp_if_expr$5 = (signed int)*inPos != 95 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$5 = (_Bool)0;
    if(tmp_if_expr$5)
      tmp_if_expr$6 = (signed int)*inPos != 45 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$6 = (_Bool)0;
    if(tmp_if_expr$6)
      tmp_if_expr$7 = (signed int)*inPos != 46 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$7 = (_Bool)0;
    if(tmp_if_expr$7)
    {
      tmp_post$2 = outPos;
      outPos = outPos + 1l;
      *tmp_post$2 = (char)37;
      snprintf(outPos, (unsigned long int)3, "%02x", (signed int)*inPos & 0xff);
      outPos = outPos + (signed long int)2;
    }

    else
    {
      tmp_post$3 = outPos;
      outPos = outPos + 1l;
      *tmp_post$3 = *inPos;
    }
    inPos = inPos + 1l;
  }
  return out;
}

// av_q2d
// file /usr/include/x86_64-linux-gnu/libavutil/rational.h line 80
static inline double av_q2d(struct AVRational a)
{
  return (double)a.num / (double)a.den;
}

// finish
// file src/player.c line 391
static void finish(struct anonymous$3 * const player)
{
  ao_close(player->aoDev);
  player->aoDev = (struct ao_device *)(void *)0;
  if(!(player->fgraph == ((struct AVFilterGraph *)NULL)))
  {
    avfilter_graph_free(&player->fgraph);
    player->fgraph = (struct AVFilterGraph *)(void *)0;
  }

  if(!(player->st == ((struct AVStream *)NULL)))
  {
    if(!(player->st->codec == ((struct AVCodecContext *)NULL)))
    {
      avcodec_close(player->st->codec);
      player->st = (struct AVStream *)(void *)0;
    }

  }

  if(!(player->fctx == ((struct AVFormatContext *)NULL)))
    avformat_close_input(&player->fctx);

}

// isnumeric
// file src/ui.c line 53
static _Bool isnumeric(const char *s)
{
  if((signed int)*s == 0)
    return (_Bool)0;

  else
  {
    while(!((signed int)*s == 0))
    {
      const unsigned short int **return_value___ctype_b_loc$1;
      return_value___ctype_b_loc$1=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)(unsigned char)*s]) == 0)
        return (_Bool)0;

      s = s + 1l;
    }
    return (_Bool)1;
  }
}

// main
// file src/main.c line 415
signed int main(signed int argc, char **argv)
{
  static struct anonymous$35 app;
  memset((void *)&app, 0, sizeof(struct anonymous$35) /*1120ul*/ );
  BarTermInit();
  signal(13, (void (*)(signed int))1);
  gcry_check_version((const char *)(void *)0);
  gcry_control((enum gcry_ctl_cmds)GCRYCTL_DISABLE_SECMEM, 0);
  gcry_control((enum gcry_ctl_cmds)GCRYCTL_INITIALIZATION_FINISHED, 0);
  gnutls_global_init();
  BarPlayerInit();
  BarSettingsInit(&app.settings);
  BarSettingsRead(&app.settings);
  enum anonymous$4 pret;
  pret=PianoInit(&app.ph, app.settings.partnerUser, app.settings.partnerPassword, app.settings.device, app.settings.inkey, app.settings.outkey);
  if(!((signed int)pret == PIANO_RET_OK))
  {
    const char *return_value_PianoErrorToStr$1;
    return_value_PianoErrorToStr$1=PianoErrorToStr(pret);
    BarUiMsg(&app.settings, (const enum anonymous$34)MSG_ERR, "Initialization failed: %s\n", return_value_PianoErrorToStr$1);
    return 0;
  }

  BarUiMsg(&app.settings, (const enum anonymous$34)MSG_NONE, "Welcome to pianobar (2014.09.28)! ");
  if((signed int)app.settings.keys[0l] == 0)
    BarUiMsg(&app.settings, (const enum anonymous$34)MSG_NONE, "\n");

  else
    BarUiMsg(&app.settings, (const enum anonymous$34)MSG_NONE, "Press %c for a list of commands.\n", app.settings.keys[(signed long int)BAR_KS_HELP]);
  WaitressInit(&app.waith);
  app.waith.url.host = app.settings.rpcHost;
  app.waith.url.tlsPort = app.settings.rpcTlsPort;
  app.waith.tlsFingerprint = app.settings.tlsFingerprint;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$47) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&app.input.set)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  app.input.fds[(signed long int)0] = 0;
  (&app.input.set)->__fds_bits[(signed long int)(app.input.fds[(signed long int)0] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&app.input.set)->__fds_bits[(signed long int)(app.input.fds[(signed long int)0] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << app.input.fds[(signed long int)0] % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
  /* assertion sizeof (app.input.fds) / sizeof (*app.input.fds) >= 2 */
  assert(sizeof(signed int [2l]) /*8ul*/  / sizeof(signed int) /*4ul*/  >= (unsigned long int)2);
  app.input.fds[(signed long int)1]=open(app.settings.fifo, 02);
  if(!(app.input.fds[1l] == -1))
  {
    struct stat s;
    fstat(app.input.fds[(signed long int)1], &s);
    if(!((61440u & s.st_mode) == 4096u))
    {
      BarUiMsg(&app.settings, (const enum anonymous$34)MSG_ERR, "File at %s is not a fifo\n", app.settings.fifo);
      close(app.input.fds[(signed long int)1]);
      app.input.fds[(signed long int)1] = -1;
    }

    else
    {
      (&app.input.set)->__fds_bits[(signed long int)(app.input.fds[(signed long int)1] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&app.input.set)->__fds_bits[(signed long int)(app.input.fds[(signed long int)1] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)1 << app.input.fds[(signed long int)1] % (8 * (signed int)sizeof(signed long int) /*8ul*/ );
      BarUiMsg(&app.settings, (const enum anonymous$34)MSG_INFO, "Control fifo at %s opened\n", app.settings.fifo);
    }
  }

  signed int tmp_if_expr$2;
  if(!(app.input.fds[1l] >= app.input.fds[0l]))
    tmp_if_expr$2 = app.input.fds[(signed long int)0];

  else
    tmp_if_expr$2 = app.input.fds[(signed long int)1];
  app.input.maxfd = tmp_if_expr$2;
  app.input.maxfd = app.input.maxfd + 1;
  BarMainLoop(&app);
  if(!(app.input.fds[1l] == -1))
    close(app.input.fds[(signed long int)1]);

  BarSettingsWrite(app.curStation, &app.settings);
  PianoDestroy(&app.ph);
  PianoDestroyPlaylist(app.songHistory);
  PianoDestroyPlaylist(app.playlist);
  WaitressFree(&app.waith);
  BarPlayerDestroy();
  gnutls_global_deinit();
  BarSettingsDestroy(&app.settings);
  BarTermRestore();
  return 0;
}

// openDevice
// file src/player.c line 271
static _Bool openDevice(struct anonymous$3 * const player)
{
  struct AVCodecContext * const cctx = player->st->codec;
  struct ao_sample_format aoFmt;
  memset((void *)&aoFmt, 0, sizeof(struct ao_sample_format) /*24ul*/ );
  signed int return_value_av_get_bytes_per_sample$1;
  return_value_av_get_bytes_per_sample$1=av_get_bytes_per_sample(avformat);
  aoFmt.bits = return_value_av_get_bytes_per_sample$1 * 8;
  /* assertion aoFmt.bits > 0 */
  assert(aoFmt.bits > 0);
  aoFmt.channels = cctx->channels;
  aoFmt.rate = cctx->sample_rate;
  aoFmt.byte_format = 4;
  signed int driver;
  driver=ao_default_driver_id();
  player->aoDev=ao_open_live(driver, &aoFmt, (struct ao_option *)(void *)0);
  if(player->aoDev == ((struct ao_device *)NULL))
  {
    BarUiMsg(player->settings, (const enum anonymous$34)MSG_ERR, "Cannot open audio device.\n");
    return (_Bool)0;
  }

  else
    return (_Bool)1;
}

// openFilter
// file src/player.c line 207
static _Bool openFilter(struct anonymous$3 * const player)
{
  char strbuf[256l];
  signed int ret = 0;
  struct AVCodecContext * const cctx = player->st->codec;
  player->fgraph=avfilter_graph_alloc();
  _Bool tmp_if_expr$9;
  signed int return_value_avfilter_link$8;
  _Bool tmp_if_expr$11;
  signed int return_value_avfilter_link$10;
  if(player->fgraph == ((struct AVFilterGraph *)NULL))
  {
    printError(player->settings, "graph_alloc", ret);
    return (_Bool)0;
  }

  else
  {
    struct AVRational time_base = player->st->time_base;
    const char *return_value_av_get_sample_fmt_name$1;
    return_value_av_get_sample_fmt_name$1=av_get_sample_fmt_name(cctx->sample_fmt);
    snprintf(strbuf, sizeof(char [256l]) /*256ul*/ , "time_base=%d/%d:sample_rate=%d:sample_fmt=%s:channel_layout=0x%lx", time_base.num, time_base.den, cctx->sample_rate, return_value_av_get_sample_fmt_name$1, cctx->channel_layout);
    struct AVFilter *return_value_avfilter_get_by_name$2;
    return_value_avfilter_get_by_name$2=avfilter_get_by_name("abuffer");
    ret=avfilter_graph_create_filter(&player->fabuf, return_value_avfilter_get_by_name$2, (const char *)(void *)0, strbuf, (void *)0, player->fgraph);
    if(!(ret >= 0))
    {
      printError(player->settings, "create_filter abuffer", ret);
      return (_Bool)0;
    }

    else
    {
      struct AVFilter *return_value_avfilter_get_by_name$3;
      return_value_avfilter_get_by_name$3=avfilter_get_by_name("volume");
      ret=avfilter_graph_create_filter(&player->fvolume, return_value_avfilter_get_by_name$3, (const char *)(void *)0, (const char *)(void *)0, (void *)0, player->fgraph);
      if(!(ret >= 0))
      {
        printError(player->settings, "create_filter volume", ret);
        return (_Bool)0;
      }

      else
      {
        BarPlayerSetVolume(player);
        struct AVFilterContext *fafmt = (struct AVFilterContext *)(void *)0;
        const char *return_value_av_get_sample_fmt_name$4;
        return_value_av_get_sample_fmt_name$4=av_get_sample_fmt_name(avformat);
        snprintf(strbuf, sizeof(char [256l]) /*256ul*/ , "sample_fmts=%s", return_value_av_get_sample_fmt_name$4);
        struct AVFilter *return_value_avfilter_get_by_name$5;
        return_value_avfilter_get_by_name$5=avfilter_get_by_name("aformat");
        ret=avfilter_graph_create_filter(&fafmt, return_value_avfilter_get_by_name$5, (const char *)(void *)0, strbuf, (void *)0, player->fgraph);
        if(!(ret >= 0))
        {
          printError(player->settings, "create_filter aformat", ret);
          return (_Bool)0;
        }

        else
        {
          struct AVFilter *return_value_avfilter_get_by_name$6;
          return_value_avfilter_get_by_name$6=avfilter_get_by_name("abuffersink");
          ret=avfilter_graph_create_filter(&player->fbufsink, return_value_avfilter_get_by_name$6, (const char *)(void *)0, (const char *)(void *)0, (void *)0, player->fgraph);
          if(!(ret >= 0))
          {
            printError(player->settings, "create_filter abuffersink", ret);
            return (_Bool)0;
          }

          else
          {
            signed int return_value_avfilter_link$7;
            return_value_avfilter_link$7=avfilter_link(player->fabuf, (unsigned int)0, player->fvolume, (unsigned int)0);
            if(!(return_value_avfilter_link$7 == 0))
              tmp_if_expr$9 = (_Bool)1;

            else
            {
              return_value_avfilter_link$8=avfilter_link(player->fvolume, (unsigned int)0, fafmt, (unsigned int)0);
              tmp_if_expr$9 = return_value_avfilter_link$8 != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$9)
              tmp_if_expr$11 = (_Bool)1;

            else
            {
              return_value_avfilter_link$10=avfilter_link(fafmt, (unsigned int)0, player->fbufsink, (unsigned int)0);
              tmp_if_expr$11 = return_value_avfilter_link$10 != 0 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$11)
            {
              printError(player->settings, "filter_link", ret);
              return (_Bool)0;
            }

            else
            {
              ret=avfilter_graph_config(player->fgraph, (void *)0);
              if(!(ret >= 0))
              {
                printError(player->settings, "graph_config", ret);
                return (_Bool)0;
              }

              else
                return (_Bool)1;
            }
          }
        }
      }
    }
  }
}

// openStream
// file src/player.c line 133
static _Bool openStream(struct anonymous$3 * const player)
{
  /* assertion player != ((void *)0) */
  assert(player != (struct anonymous$3 *)(void *)0);
  /* assertion player->fctx == ((void *)0) */
  assert(player->fctx == (struct AVFormatContext *)(void *)0);
  signed int ret;
  struct AVDictionary *options = (struct AVDictionary *)(void *)0;
  av_dict_set(&options, "timeout", "10000000", 0);
  /* assertion player->url != ((void *)0) */
  assert(player->url != (char *)(void *)0);
  ret=avformat_open_input(&player->fctx, player->url, (struct AVInputFormat *)(void *)0, &options);
  if(!(ret >= 0))
  {
    printError(player->settings, "Unable to open audio file", ret);
    return (_Bool)0;
  }

  else
  {
    ret=avformat_find_stream_info(player->fctx, (struct AVDictionary **)(void *)0);
    if(!(ret >= 0))
    {
      printError(player->settings, "find_stream_info", ret);
      return (_Bool)0;
    }

    else
    {
      unsigned long int i = (unsigned long int)0;
      for( ; !(i >= (unsigned long int)player->fctx->nb_streams); i = i + 1ul)
        player->fctx->streams[(signed long int)i]->discard = (enum AVDiscard)AVDISCARD_ALL;
      player->streamIdx=av_find_best_stream(player->fctx, (enum AVMediaType)AVMEDIA_TYPE_AUDIO, -1, -1, (struct AVCodec **)(void *)0, 0);
      if(!(player->streamIdx >= 0))
      {
        printError(player->settings, "find_best_stream", ret);
        return (_Bool)0;
      }

      else
      {
        player->st = player->fctx->streams[(signed long int)player->streamIdx];
        struct AVCodecContext * const cctx = player->st->codec;
        player->st->discard = (enum AVDiscard)AVDISCARD_DEFAULT;
        struct AVCodec *decoder;
        decoder=avcodec_find_decoder(cctx->codec_id);
        if(decoder == ((struct AVCodec *)NULL))
        {
          printError(player->settings, "find_decoder", ret);
          return (_Bool)0;
        }

        else
        {
          ret=avcodec_open2(cctx, decoder, (struct AVDictionary **)(void *)0);
          if(!(ret >= 0))
          {
            printError(player->settings, "codec_open2", ret);
            return (_Bool)0;
          }

          else
          {
            if(player->lastTimestamp >= 1l)
              av_seek_frame(player->fctx, player->streamIdx, player->lastTimestamp, 0);

            player->songPlayed = (volatile unsigned int)0;
            double return_value_av_q2d$1;
            return_value_av_q2d$1=av_q2d(player->st->time_base);
            player->songDuration = (volatile unsigned int)(return_value_av_q2d$1 * (double)player->st->duration);
            player->mode = (enum anonymous$41)PLAYER_PLAYING;
            return (_Bool)1;
          }
        }
      }
    }
  }
}

// play
// file src/player.c line 293
static signed int play(struct anonymous$3 * const player)
{
  /* assertion player != ((void *)0) */
  assert(player != (struct anonymous$3 *)(void *)0);
  struct AVPacket pkt;
  av_init_packet(&pkt);
  pkt.data = (unsigned char *)(void *)0;
  pkt.size = 0;
  struct AVFrame *frame = (struct AVFrame *)(void *)0;
  struct AVFrame *filteredFrame = (struct AVFrame *)(void *)0;
  frame=avcodec_alloc_frame();
  /* assertion frame != ((void *)0) */
  assert(frame != (struct AVFrame *)(void *)0);
  filteredFrame=avcodec_alloc_frame();
  /* assertion filteredFrame != ((void *)0) */
  assert(filteredFrame != (struct AVFrame *)(void *)0);
  while(player->doQuit == (_Bool)0)
  {
    signed int ret;
    ret=av_read_frame(player->fctx, &pkt);
    if(!(ret >= 0))
    {
      av_free_packet(&pkt);
      return ret;
    }

    else
      if(!(pkt.stream_index == player->streamIdx))
      {
        av_free_packet(&pkt);
        continue;
      }

    struct AVPacket pkt_orig = pkt;
    pthread_mutex_lock(&player->pauseMutex);
    if(!(player->doPause == (_Bool)0))
    {
      av_read_pause(player->fctx);
      do
        pthread_cond_wait(&player->pauseCond, &player->pauseMutex);
      while(player->doPause != (_Bool)0);
      av_read_play(player->fctx);
    }

    pthread_mutex_unlock(&player->pauseMutex);
    while(pkt.size >= 1)
    {
      if(player->doQuit != (_Bool)0)
        break;

      signed int got_frame = 0;
      signed int decoded;
      decoded=avcodec_decode_audio4(player->st->codec, frame, &got_frame, &pkt);
      if(!(decoded >= 0))
        break;

      if(!(got_frame == 0))
      {
        if(frame->pts == -9223372036854775808l)
          frame->pts = (signed long int)0;

        ret=av_buffersrc_write_frame(player->fabuf, frame);
        /* assertion ret >= 0 */
        assert(ret >= 0);
        while((_Bool)1)
        {
          struct AVFilterBufferRef *audioref = (struct AVFilterBufferRef *)(void *)0;
          signed int return_value_av_buffersink_read$1;
          return_value_av_buffersink_read$1=av_buffersink_read(player->fbufsink, &audioref);
          if(!(return_value_av_buffersink_read$1 >= 0))
            break;

          ret=avfilter_copy_buf_props(filteredFrame, audioref);
          /* assertion ret >= 0 */
          assert(ret >= 0);
          signed int numChannels;
          numChannels=av_get_channel_layout_nb_channels(filteredFrame->channel_layout);
          signed int bps;
          bps=av_get_bytes_per_sample((enum AVSampleFormat)filteredFrame->format);
          ao_play(player->aoDev, (char *)filteredFrame->data[(signed long int)0], (unsigned int)(filteredFrame->nb_samples * numChannels * bps));
          avfilter_unref_bufferp(&audioref);
        }
      }

      pkt.data = pkt.data + (signed long int)decoded;
      pkt.size = pkt.size - decoded;
    }
    av_free_packet(&pkt_orig);
    double return_value_av_q2d$2;
    return_value_av_q2d$2=av_q2d(player->st->time_base);
    player->songPlayed = (volatile unsigned int)(return_value_av_q2d$2 * (double)pkt.pts);
    player->lastTimestamp = pkt.pts;
  }
  avcodec_free_frame(&filteredFrame);
  avcodec_free_frame(&frame);
  return 0;
}

// printError
// file src/player.c line 59
static void printError(const struct anonymous$33 * const settings, const char * const msg, signed int ret)
{
  char avmsg[128l];
  av_strerror(ret, avmsg, sizeof(char [128l]) /*128ul*/ );
  BarUiMsg(settings, (const enum anonymous$34)MSG_ERR, "%s (%s)\n", msg, (const void *)avmsg);
}

