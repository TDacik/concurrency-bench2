// #anon_enum_BR_INIT_ERROR_NOMEM=0_BR_INIT_ERROR_OPEN_MAPS=1_BR_INIT_ERROR_READ_MAPS=2_BR_INIT_ERROR_INVALID_MAPS=3_BR_INIT_ERROR_DISABLED=4
// file binreloc.h line 22
enum anonymous_11 { BR_INIT_ERROR_NOMEM=0, BR_INIT_ERROR_OPEN_MAPS=1, BR_INIT_ERROR_READ_MAPS=2, BR_INIT_ERROR_INVALID_MAPS=3, BR_INIT_ERROR_DISABLED=4 };

// #anon_enum_CAP_CLEAR=0_CAP_SET=1
// file /usr/include/sys/capability.h line 63
enum anonymous_13 { CAP_CLEAR=0, CAP_SET=1 };

// #anon_enum_CAP_EFFECTIVE=0_CAP_PERMITTED=1_CAP_INHERITABLE=2
// file /usr/include/sys/capability.h line 54
enum anonymous_12 { CAP_EFFECTIVE=0, CAP_PERMITTED=1, CAP_INHERITABLE=2 };

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous;

// tag-#anon#ST[U32'prefix'||U32'server_ip'||U16'flags'||U16'client_port'||U32'client_ip'|]
// file ../libteredo/teredo.h line 53
struct anonymous_14;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous_5;

// tag-#anon#UN[ARR1{U32}_U32_'icmp6_un_data32'||ARR2{U16}_U16_'icmp6_un_data16'||ARR4{U8}_U8_'icmp6_un_data8'|]
// file /usr/include/netinet/icmp6.h line 43
union anonymous_3;

// tag-#anon#UN[ARR1{U64}_U64_'align'||ARR65507{U8}_U8_'fill'||U524096'_pad'|]
// file teredo-udp.h line 71
union anonymous_6;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_1;

// tag-#anon#UN[SYM#tag-ip6_hdrctl#'ip6_un1'||U8'ip6_un2_vfc'|]
// file /usr/include/netinet/ip6.h line 26
union anonymous_4;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_7;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_2;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-__rlimit_resource
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 31
enum __rlimit_resource { RLIMIT_CPU=0, RLIMIT_FSIZE=1, RLIMIT_DATA=2, RLIMIT_STACK=3, RLIMIT_CORE=4, __RLIMIT_RSS=5, RLIMIT_NOFILE=7, __RLIMIT_OFILE=7, RLIMIT_AS=9, __RLIMIT_NPROC=6, __RLIMIT_MEMLOCK=8, __RLIMIT_LOCKS=10, __RLIMIT_SIGPENDING=11, __RLIMIT_MSGQUEUE=12, __RLIMIT_NICE=13, __RLIMIT_RTPRIO=14, __RLIMIT_RTTIME=15, __RLIMIT_NLIMITS=16, __RLIM_NLIMITS=16 };

// tag-_cap_struct
// file /usr/include/sys/capability.h line 41
struct _cap_struct;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-cmsghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 242
struct cmsghdr;

// tag-icmp6_hdr
// file /usr/include/netinet/icmp6.h line 38
struct icmp6_hdr;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-in_pktinfo
// file /usr/include/x86_64-linux-gnu/bits/in.h line 153
struct in_pktinfo;

// tag-iovec
// file /usr/include/x86_64-linux-gnu/bits/uio.h line 43
struct iovec;

// tag-ip6_hdr
// file /usr/include/netinet/ip6.h line 24
struct ip6_hdr;

// tag-ip6_hdrctl
// file /usr/include/netinet/ip6.h line 28
struct ip6_hdrctl;

// tag-miredo_conf
// file miredo.h line 34
struct miredo_conf;

// tag-miredo_conf_syslog_facility
// file conf.c line 494
struct miredo_conf_syslog_facility;

// tag-msghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 224
struct msghdr;

// tag-nd_opt_mtu
// file /usr/include/netinet/icmp6.h line 226
struct nd_opt_mtu;

// tag-nd_opt_prefix_info
// file /usr/include/netinet/icmp6.h line 201
struct nd_opt_prefix_info;

// tag-nd_router_advert
// file /usr/include/netinet/icmp6.h line 122
struct nd_router_advert;

// tag-nd_router_solicit
// file /usr/include/netinet/icmp6.h line 111
struct nd_router_solicit;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-rlimit
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 139
struct rlimit;

// tag-setting
// file conf.c line 48
struct setting;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-teredo_addr
// file ../libteredo/teredo.h line 50
union teredo_addr;

// tag-teredo_orig_ind
// file teredo.h line 119
struct teredo_orig_ind;

// tag-teredo_packet
// file teredo-udp.h line 41
struct teredo_packet;

// tag-teredo_server
// file server.h line 27
struct teredo_server;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

#ifndef NULL
#define NULL ((void*)0)
#endif

// GetIPv4ByName
// file conf.h line 46
signed int GetIPv4ByName(const char *hostname, unsigned int *ipv4);
// IN6_IS_ADDR_GLOBAL
// file server.c line 250
static inline _Bool IN6_IS_ADDR_GLOBAL(struct in6_addr *addr);
// IsBubble
// file packets.h line 48
static inline _Bool IsBubble(struct ip6_hdr *hdr);
// LogError
// file conf.c line 91
static void LogError(struct miredo_conf *conf, const char *fmt, ...);
// LogWarning
// file conf.c line 111
static void LogWarning(struct miredo_conf *conf, const char *fmt, ...);
// Pryt4897810065911_br_build_path
// file binreloc.c line 690
char * Pryt4897810065911_br_build_path(const char *dir, const char *file);
// Pryt4897810065911_br_dirname
// file binreloc.c line 746
char * Pryt4897810065911_br_dirname(const char *path);
// Pryt4897810065911_br_find_bin_dir
// file binreloc.c line 438
char * Pryt4897810065911_br_find_bin_dir(const char *default_bin_dir);
// Pryt4897810065911_br_find_data_dir
// file binreloc.c line 505
char * Pryt4897810065911_br_find_data_dir(const char *default_data_dir);
// Pryt4897810065911_br_find_etc_dir
// file binreloc.h line 68
char * Pryt4897810065911_br_find_etc_dir(const char *default_etc_dir);
// Pryt4897810065911_br_find_exe
// file binreloc.c line 349
char * Pryt4897810065911_br_find_exe(const char *default_exe);
// Pryt4897810065911_br_find_exe_dir
// file binreloc.c line 377
char * Pryt4897810065911_br_find_exe_dir(const char *default_dir);
// Pryt4897810065911_br_find_lib_dir
// file binreloc.c line 571
char * Pryt4897810065911_br_find_lib_dir(const char *default_lib_dir);
// Pryt4897810065911_br_find_libexec_dir
// file binreloc.c line 604
char * Pryt4897810065911_br_find_libexec_dir(const char *default_libexec_dir);
// Pryt4897810065911_br_find_locale_dir
// file binreloc.h line 65
char * Pryt4897810065911_br_find_locale_dir(const char *default_locale_dir);
// Pryt4897810065911_br_find_prefix
// file binreloc.c line 405
char * Pryt4897810065911_br_find_prefix(const char *default_prefix);
// Pryt4897810065911_br_find_sbin_dir
// file binreloc.c line 471
char * Pryt4897810065911_br_find_sbin_dir(const char *default_sbin_dir);
// Pryt4897810065911_br_init
// file binreloc.h line 56
signed int Pryt4897810065911_br_init(enum anonymous_11 *error);
// Pryt4897810065911_br_init_lib
// file binreloc.c line 332
signed int Pryt4897810065911_br_init_lib(enum anonymous_11 *error);
// Pryt4897810065911_br_strcat
// file binreloc.c line 667
char * Pryt4897810065911_br_strcat(const char *str1, const char *str2);
// SendRA
// file server.c line 78
static _Bool SendRA(const struct teredo_server * restrict s, struct teredo_packet *p, struct in6_addr *dest_ip6, _Bool secondary);
// __cmsg_nxthdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 272
extern struct cmsghdr * __cmsg_nxthdr(struct msghdr *, struct cmsghdr *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _br_find_exe
// file binreloc.c line 43
static char * _br_find_exe(enum anonymous_11 *error);
// _br_find_exe_for_symbol
// file binreloc.c line 182
static char * _br_find_exe_for_symbol(const void *symbol, enum anonymous_11 *error);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// bindtextdomain
// file /usr/include/libintl.h line 86
extern char * bindtextdomain(const char *, const char *);
// br_strndup
// file binreloc.c line 712
static char * br_strndup(const char *str, unsigned long int size);
// cap_free
// file /usr/include/sys/capability.h line 74
extern signed int cap_free(void *);
// cap_init
// file /usr/include/sys/capability.h line 75
extern struct _cap_struct * cap_init(void);
// cap_set_flag
// file /usr/include/sys/capability.h line 79
extern signed int cap_set_flag(struct _cap_struct *, enum anonymous_12, signed int, const signed int *, enum anonymous_13);
// cap_set_proc
// file /usr/include/sys/capability.h line 93
extern signed int cap_set_proc(struct _cap_struct *);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// chroot
// file /usr/include/unistd.h line 944
extern signed int chroot(const char *);
// clearenv
// file /usr/include/stdlib.h line 595
extern signed int clearenv(void);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closefrom
// file closefrom.c line 39
signed int closefrom(signed int fd);
// closelog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 175
extern void closelog(void);
// create_pidfile
// file main.c line 156
static signed int create_pidfile(const char *path);
// dgettext
// file /usr/include/libintl.h line 44
extern char * dgettext(const char *, const char *);
// drop_privileges
// file miredo.h line 44
signed int drop_privileges(void);
// dup
// file /usr/include/unistd.h line 531
extern signed int dup(signed int);
// error_dup
// file main.c line 112
static signed int error_dup(signed int opt, const char *already, const char *additionnal);
// error_errno
// file main.c line 142
static signed int error_errno(const char *str);
// error_extra
// file main.c line 134
static signed int error_extra(const char *extra);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fdatasync
// file /usr/include/unistd.h line 1112
extern signed int fdatasync(signed int);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fgetc
// file /usr/include/stdio.h line 531
extern signed int fgetc(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// freopen
// file /usr/include/stdio.h line 278
extern struct _IO_FILE * freopen(const char *, const char *, struct _IO_FILE *);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 213
extern signed int fstat(signed int, struct stat *);
// ftruncate
// file /usr/include/unistd.h line 1016
extern signed int ftruncate(signed int, signed long int);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getpwnam
// file /usr/include/pwd.h line 116
extern struct passwd * getpwnam(const char *);
// getrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 50
extern signed int getrlimit(enum __rlimit_resource, struct rlimit *);
// gettext
// file /usr/include/libintl.h line 39
extern char * gettext(const char *);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// icmp6_checksum
// file checksum.h line 34
static inline unsigned short int icmp6_checksum(struct ip6_hdr *ip6, struct icmp6_hdr *icmp6);
// in6_matches_teredo_client
// file teredo.h line 95
static inline signed int in6_matches_teredo_client(struct in6_addr *ip6, unsigned int ip, unsigned short int port);
// in_cksum
// file teredo.c line 338
static unsigned short int in_cksum(struct iovec *iov, unsigned long int n);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// init_locale
// file main.c line 313
static void init_locale(void);
// init_security
// file main.c line 207
static signed int init_security(const char *username);
// initgroups
// file /usr/include/grp.h line 200
extern signed int initgroups(const char *, unsigned int);
// is_ipv4_global_unicast
// file v4global.h line 34
signed int is_ipv4_global_unicast(unsigned int ip);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// lockf
// file /usr/include/unistd.h line 1081
extern signed int lockf(signed int, signed int, signed long int);
// logger
// file miredo.c line 96
static void logger(void *dummy, _Bool error, const char *fmt, void **ap);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// miredo
// file miredo.h line 43
signed int miredo(const char *confpath, const char *server_name, signed int pidfd);
// miredo_conf_clear
// file conf.h line 38
void miredo_conf_clear(struct miredo_conf *conf, signed int show);
// miredo_conf_create
// file conf.h line 33
struct miredo_conf * miredo_conf_create(void (*logger)(void *, _Bool, const char *, void **), void *opaque);

//
void logger_object(void *, _Bool, const char *, void **);
// miredo_conf_destroy
// file conf.h line 34
void miredo_conf_destroy(struct miredo_conf *conf);
// miredo_conf_get
// file conf.c line 206
char * miredo_conf_get(struct miredo_conf *conf, const char *name, unsigned int *line);
// miredo_conf_get_int16
// file conf.h line 41
_Bool miredo_conf_get_int16(struct miredo_conf *conf, const char *name, unsigned short int *value, unsigned int *line);
// miredo_conf_parse_IPv4
// file conf.h line 48
_Bool miredo_conf_parse_IPv4(struct miredo_conf *conf, const char *name, unsigned int *ipv4);
// miredo_conf_parse_IPv6
// file conf.c line 436
_Bool miredo_conf_parse_IPv6(struct miredo_conf *conf, const char *name, struct in6_addr *value);
// miredo_conf_parse_syslog_facility
// file conf.h line 55
_Bool miredo_conf_parse_syslog_facility(struct miredo_conf *conf, const char *name, signed int *facility);
// miredo_conf_parse_teredo_prefix
// file conf.h line 52
_Bool miredo_conf_parse_teredo_prefix(struct miredo_conf *conf, const char *name, unsigned int *value);
// miredo_conf_read_FILE
// file conf.c line 233
static _Bool miredo_conf_read_FILE(struct miredo_conf *conf, struct _IO_FILE *stream);
// miredo_conf_read_file
// file conf.h line 36
_Bool miredo_conf_read_file(struct miredo_conf *conf, const char *path);
// miredo_conf_set
// file conf.c line 157
static _Bool miredo_conf_set(struct miredo_conf *conf, const char *name, const char *value, unsigned int line);
// miredo_diagnose_object
//
signed int miredo_diagnose_object(void);
// miredo_main
// file miredo.h line 41
signed int miredo_main(signed int argc, char **argv);
// miredo_run_object
//
signed int miredo_run_object(struct miredo_conf *, const char *);
// miredo_version
// file main.c line 90
signed int miredo_version(void);
// ntohl
// file /usr/include/netinet/in.h line 374
extern unsigned int ntohl(unsigned int);
// ntohs
// file /usr/include/netinet/in.h line 375
extern unsigned short int ntohs(unsigned short int);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_1 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_1 *);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous *, struct anonymous *);
// pthread_testcancel
// file /usr/include/pthread.h line 520
extern void pthread_testcancel(void);
// puts
// file /usr/include/stdio.h line 695
extern signed int puts(const char *);
// quick_usage
// file main.c line 64
static signed int quick_usage(const char *path);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// recvmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 202
extern signed long int recvmsg(signed int, struct msghdr *, signed int);
// sendmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 184
extern signed long int sendmsg(signed int, struct msghdr *, signed int);
// sendto
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 163
extern signed long int sendto(signed int, const void *, unsigned long int, signed int,  struct sockaddr *, unsigned int);
// server_diagnose
// file serverd.c line 55
static signed int server_diagnose(void);
// server_run
// file serverd.c line 69
static signed int server_run(struct miredo_conf *conf, const char *server_name);
// seteuid
// file /usr/include/unistd.h line 710
extern signed int seteuid(unsigned int);
// setgid
// file /usr/include/unistd.h line 717
extern signed int setgid(unsigned int);
// setlocale
// file /usr/include/locale.h line 124
extern char * setlocale(signed int, const char *);
// setrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 69
extern signed int setrlimit(enum __rlimit_resource, struct rlimit *);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// setuid
// file /usr/include/unistd.h line 700
extern signed int setuid(unsigned int);
// setuid_notice
// file main.c line 193
static void setuid_notice(void);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous *);
// sigismember
// file /usr/include/signal.h line 227
extern signed int sigismember(const struct anonymous *, signed int);
// sigwait
// file /usr/include/signal.h line 270
extern signed int sigwait(const struct anonymous *, signed int *);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlcpy
// file strlcpy.c line 27
unsigned long int strlcpy(char *tgt, const char *src, unsigned long int bufsize);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strsignal
// file /usr/include/string.h line 563
extern char * strsignal(signed int);
// strtoul
// file /usr/include/stdlib.h line 187
extern unsigned long int strtoul(const char *, char ** restrict , signed int);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// teredo_cksum
// file teredo-udp.h line 152
unsigned short int teredo_cksum(const void *src, const void *dst, unsigned char protocol, struct iovec *data, unsigned long int n);
// teredo_close
// file teredo-udp.h line 163
void teredo_close(signed int fd);
// teredo_forward_udp
// file server.c line 166
static _Bool teredo_forward_udp(signed int fd, struct teredo_packet *packet, _Bool insert_orig);
// teredo_process_packet
// file server.c line 292
static signed int teredo_process_packet(const struct teredo_server *s, _Bool sec);
// teredo_recv
// file teredo.c line 306
signed int teredo_recv(signed int fd, struct teredo_packet *p);
// teredo_recv_inner
// file teredo.c line 173
static signed int teredo_recv_inner(signed int fd, struct teredo_packet *p, signed int flags);
// teredo_recverr
// file teredo.c line 118
static signed long int teredo_recverr(signed int fd);
// teredo_send
// file teredo.c line 165
signed int teredo_send(signed int fd, const void *packet, unsigned long int plen, unsigned int dest_ip, unsigned short int dest_port);
// teredo_send_ipv6
// file server.c line 206
static _Bool teredo_send_ipv6(struct ip6_hdr *p, unsigned long int len);
// teredo_sendv
// file teredo-udp.h line 113
signed int teredo_sendv(signed int fd, struct iovec *iov, unsigned long int count, unsigned int dest_ip, unsigned short int dest_port);
// teredo_server_check
// file ../libteredo/server.h line 33
signed int teredo_server_check(char *errmsg, unsigned long int len);
// teredo_server_create
// file ../libteredo/server.h line 46
struct teredo_server * teredo_server_create(unsigned int ip1, unsigned int ip2);
// teredo_server_destroy
// file ../libteredo/server.h line 108
void teredo_server_destroy(struct teredo_server *s);
// teredo_server_get_MTU
// file server.c line 600
unsigned short int teredo_server_get_MTU(const struct teredo_server *s);
// teredo_server_get_prefix
// file server.c line 585
unsigned int teredo_server_get_prefix(const struct teredo_server *s);
// teredo_server_set_MTU
// file ../libteredo/server.h line 76
signed int teredo_server_set_MTU(struct teredo_server *s, unsigned short int mtu);
// teredo_server_set_prefix
// file ../libteredo/server.h line 57
signed int teredo_server_set_prefix(struct teredo_server *s, unsigned int prefix);
// teredo_server_start
// file ../libteredo/server.h line 92
signed int teredo_server_start(struct teredo_server *s);
// teredo_server_stop
// file ../libteredo/server.h line 99
void teredo_server_stop(struct teredo_server *s);
// teredo_socket
// file teredo-udp.h line 90
signed int teredo_socket(unsigned int bind_ip, unsigned short int port);
// teredo_wait_recv
// file teredo-udp.h line 145
signed int teredo_wait_recv(signed int fd, struct teredo_packet *p);
// textdomain
// file /usr/include/libintl.h line 82
extern char * textdomain(const char *);
// thread_primary
// file server.c line 467
static void * thread_primary(void *data);
// thread_secondary
// file server.c line 477
static void * thread_secondary(void *data);
// umask
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 311
extern unsigned int umask(unsigned int);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// usage
// file main.c line 73
static signed int usage(const char *path);
// vsyslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 200
extern void vsyslog(signed int, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_14
{
  // prefix
  unsigned int prefix;
  // server_ip
  unsigned int server_ip;
  // flags
  unsigned short int flags;
  // client_port
  unsigned short int client_port;
  // client_ip
  unsigned int client_ip;
};

union anonymous_5
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_3
{
  // icmp6_un_data32
  unsigned int icmp6_un_data32[1l];
  // icmp6_un_data16
  unsigned short int icmp6_un_data16[2l];
  // icmp6_un_data8
  unsigned char icmp6_un_data8[4l];
};

union anonymous_6
{
  // align
  unsigned long int align[1l];
  // fill
  unsigned char fill[65507l];
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_1
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct ip6_hdrctl
{
  // ip6_un1_flow
  unsigned int ip6_un1_flow;
  // ip6_un1_plen
  unsigned short int ip6_un1_plen;
  // ip6_un1_nxt
  unsigned char ip6_un1_nxt;
  // ip6_un1_hlim
  unsigned char ip6_un1_hlim;
};

union anonymous_4
{
  // ip6_un1
  struct ip6_hdrctl ip6_un1;
  // ip6_un2_vfc
  unsigned char ip6_un2_vfc;
};

union anonymous_7
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_2
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct cmsghdr
{
  // cmsg_len
  unsigned long int cmsg_len;
  // cmsg_level
  signed int cmsg_level;
  // cmsg_type
  signed int cmsg_type;
  // __cmsg_data
  unsigned char __cmsg_data[0l];
};

struct icmp6_hdr
{
  // icmp6_type
  unsigned char icmp6_type;
  // icmp6_code
  unsigned char icmp6_code;
  // icmp6_cksum
  unsigned short int icmp6_cksum;
  // icmp6_dataun
  union anonymous_3 icmp6_dataun;
};

struct in6_addr
{
  // __in6_u
  union anonymous_5 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct in_pktinfo
{
  // ipi_ifindex
  signed int ipi_ifindex;
  // ipi_spec_dst
  struct in_addr ipi_spec_dst;
  // ipi_addr
  struct in_addr ipi_addr;
};

struct iovec
{
  // iov_base
  void *iov_base;
  // iov_len
  unsigned long int iov_len;
};

struct ip6_hdr
{
  // ip6_ctlun
  union anonymous_4 ip6_ctlun;
  // ip6_src
  struct in6_addr ip6_src;
  // ip6_dst
  struct in6_addr ip6_dst;
};

struct miredo_conf
{
  // head
  struct setting *head;
  // tail
  struct setting *tail;
  // logger
  void (*logger)(void *, _Bool, const char *, void **);
  // logger_data
  void *logger_data;
};

struct miredo_conf_syslog_facility
{
  // str
  const char *str;
  // facility
  signed int facility;
};

struct msghdr
{
  // msg_name
  void *msg_name;
  // msg_namelen
  unsigned int msg_namelen;
  // msg_iov
  struct iovec *msg_iov;
  // msg_iovlen
  unsigned long int msg_iovlen;
  // msg_control
  void *msg_control;
  // msg_controllen
  unsigned long int msg_controllen;
  // msg_flags
  signed int msg_flags;
};

struct nd_opt_mtu
{
  // nd_opt_mtu_type
  unsigned char nd_opt_mtu_type;
  // nd_opt_mtu_len
  unsigned char nd_opt_mtu_len;
  // nd_opt_mtu_reserved
  unsigned short int nd_opt_mtu_reserved;
  // nd_opt_mtu_mtu
  unsigned int nd_opt_mtu_mtu;
};

struct nd_opt_prefix_info
{
  // nd_opt_pi_type
  unsigned char nd_opt_pi_type;
  // nd_opt_pi_len
  unsigned char nd_opt_pi_len;
  // nd_opt_pi_prefix_len
  unsigned char nd_opt_pi_prefix_len;
  // nd_opt_pi_flags_reserved
  unsigned char nd_opt_pi_flags_reserved;
  // nd_opt_pi_valid_time
  unsigned int nd_opt_pi_valid_time;
  // nd_opt_pi_preferred_time
  unsigned int nd_opt_pi_preferred_time;
  // nd_opt_pi_reserved2
  unsigned int nd_opt_pi_reserved2;
  // nd_opt_pi_prefix
  struct in6_addr nd_opt_pi_prefix;
};

struct nd_router_advert
{
  // nd_ra_hdr
  struct icmp6_hdr nd_ra_hdr;
  // nd_ra_reachable
  unsigned int nd_ra_reachable;
  // nd_ra_retransmit
  unsigned int nd_ra_retransmit;
};

struct nd_router_solicit
{
  // nd_rs_hdr
  struct icmp6_hdr nd_rs_hdr;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rlimit
{
  // rlim_cur
  unsigned long int rlim_cur;
  // rlim_max
  unsigned long int rlim_max;
};

struct setting
{
  // name
  char *name;
  // value
  char *value;
  // line
  unsigned int line;
  // next
  struct setting *next;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

union teredo_addr
{
  // ip6
  struct in6_addr ip6;
  // teredo
  struct anonymous_14 teredo;
  // t6_addr32
  unsigned int t6_addr32[4l];
};

struct teredo_orig_ind
{
  // orig_zero
  unsigned char orig_zero;
  // orig_code
  unsigned char orig_code;
  // orig_port
  unsigned short int orig_port;
  // orig_addr
  unsigned int orig_addr;
};

struct teredo_packet
{
  // ip6
  struct ip6_hdr *ip6;
  // ip6_len
  unsigned long int ip6_len;
  // source_ipv4
  unsigned int source_ipv4;
  // source_port
  unsigned short int source_port;
  // orig_port
  unsigned short int orig_port;
  // orig_ipv4
  unsigned int orig_ipv4;
  // dest_ipv4
  unsigned int dest_ipv4;
  // auth_present
  _Bool auth_present;
  // auth_fail
  _Bool auth_fail;
  // auth_nonce
  unsigned char auth_nonce[8l];
  // buf
  union anonymous_6 buf;
};

struct teredo_server
{
  // t1
  unsigned long int t1;
  // t2
  unsigned long int t2;
  // fd_primary
  signed int fd_primary;
  // fd_secondary
  signed int fd_secondary;
  // server_ip
  unsigned int server_ip;
  // server_ip2
  unsigned int server_ip2;
  // prefix
  unsigned int prefix;
  // advLinkMTU
  unsigned int advLinkMTU;
  // lladdr
  union teredo_addr lladdr;
};


// exe
// file binreloc.c line 292
static char *exe = (char *)(void *)0;
// facilities
// file conf.c line 498
static struct miredo_conf_syslog_facility facilities[21l] = { { .str="auth", .facility=4 << 3 }, { .str="authpriv", .facility=10 << 3 }, { .str="cron", .facility=9 << 3 }, { .str="daemon", .facility=3 << 3 }, { .str="ftp", .facility=11 << 3 }, { .str="kern", .facility=0 << 3 }, { .str="local0", .facility=16 << 3 }, { .str="local1", .facility=17 << 3 }, { .str="local2", .facility=18 << 3 }, { .str="local3", .facility=19 << 3 }, { .str="local4", .facility=20 << 3 }, { .str="local5", .facility=21 << 3 }, { .str="local6", .facility=22 << 3 }, { .str="local7", .facility=23 << 3 }, { .str="lpr", .facility=6 << 3 }, { .str="mail", .facility=2 << 3 }, { .str="news", .facility=7 << 3 }, { .str="syslog", .facility=5 << 3 }, { .str="user", .facility=1 << 3 }, { .str="uucp", .facility=8 << 3 }, { .str=(const char *)(void *)0, .facility=0 } };
// in6addr_allrouters
// file server.c line 246
static struct in6_addr in6addr_allrouters = { .__in6_u={ .__u6_addr8={ (unsigned char)0xff, (unsigned char)0x02, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0x2 } } };
// miredo_capc
// file miredo.c line 243
signed int miredo_capc;
// miredo_capv
// file miredo.c line 242
const signed int *miredo_capv;
// miredo_chrootdir
// file miredo.c line 57
const char *miredo_chrootdir = (const char *)(void *)0;
// miredo_diagnose
// file miredo.c line 236
signed int (*miredo_diagnose)(void);
// miredo_name
// file miredo.c line 239
const char *miredo_name;
// miredo_run
// file miredo.c line 237
signed int (*miredo_run)(struct miredo_conf *, const char *);
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// raw_fd
// file server.c line 59
static signed int raw_fd;
// raw_mutex
// file server.c line 58
static union anonymous_1 raw_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// raw_users
// file server.c line 60
static unsigned int raw_users = (unsigned int)0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// teredo_cone
// file teredo.c line 63
struct in6_addr teredo_cone = { .__in6_u={ .__u6_addr8={ (unsigned char)0xfe, (unsigned char)0x80, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0x80, (unsigned char)0, (unsigned char)84, (unsigned char)69, (unsigned char)82, (unsigned char)69, (unsigned char)68, (unsigned char)79 } } };
// teredo_restrict
// file teredo.c line 54
struct in6_addr teredo_restrict = { .__in6_u={ .__u6_addr8={ (unsigned char)0xfe, (unsigned char)0x80, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff } } };
// unpriv_uid
// file miredo.c line 56
unsigned int unpriv_uid = (unsigned int)0;

// GetIPv4ByName
// file conf.h line 46
signed int GetIPv4ByName(const char *hostname, unsigned int *ipv4)
{
  struct addrinfo help = { .ai_flags=0, .ai_family=2, .ai_socktype=2, .ai_protocol=17,
    .ai_addrlen=0u, .ai_addr=((struct sockaddr *)NULL), .ai_canonname=((char *)NULL),
    .ai_next=((struct addrinfo *)NULL) };
  struct addrinfo *res;
  signed int check;
  check=getaddrinfo(hostname, (const char *)(void *)0, &help, &res);
  if(!(check == 0))
    return check;

  else
  {
    *ipv4 = ((struct sockaddr_in *)res->ai_addr)->sin_addr.s_addr;
    freeaddrinfo(res);
    return 0;
  }
}

// IN6_IS_ADDR_GLOBAL
// file server.c line 250
static inline _Bool IN6_IS_ADDR_GLOBAL(struct in6_addr *addr)
{
  _Bool tmp_statement_expression_1;
  struct in6_addr *__a = (struct in6_addr *)addr;
  _Bool tmp_if_expr_2;
  if(__a->__in6_u.__u6_addr32[0l] == 0u)
    tmp_if_expr_2 = __a->__in6_u.__u6_addr32[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    tmp_if_expr_3 = __a->__in6_u.__u6_addr32[(signed long int)2] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_3 = (_Bool)0;
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_3)
    tmp_if_expr_4 = __a->__in6_u.__u6_addr32[(signed long int)3] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_4 = (_Bool)0;
  tmp_statement_expression_1 = tmp_if_expr_4;
  _Bool tmp_if_expr_10;
  _Bool tmp_statement_expression_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_9;
  unsigned int return_value_htonl_8;
  if(tmp_statement_expression_1)
    tmp_if_expr_10 = (_Bool)1;

  else
  {
    struct in6_addr *IN6_IS_ADDR_GLOBAL__1__2____a = (struct in6_addr *)addr;
    if(IN6_IS_ADDR_GLOBAL__1__2____a->__in6_u.__u6_addr32[0l] == 0u)
      tmp_if_expr_6 = IN6_IS_ADDR_GLOBAL__1__2____a->__in6_u.__u6_addr32[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_6 = (_Bool)0;
    if(tmp_if_expr_6)
      tmp_if_expr_7 = IN6_IS_ADDR_GLOBAL__1__2____a->__in6_u.__u6_addr32[(signed long int)2] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_7 = (_Bool)0;
    if(tmp_if_expr_7)
    {
      return_value_htonl_8=htonl((unsigned int)1);
      tmp_if_expr_9 = IN6_IS_ADDR_GLOBAL__1__2____a->__in6_u.__u6_addr32[(signed long int)3] == return_value_htonl_8 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_9 = (_Bool)0;
    tmp_statement_expression_5 = tmp_if_expr_9;
    tmp_if_expr_10 = tmp_statement_expression_5 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_14;
  _Bool tmp_statement_expression_11;
  if(tmp_if_expr_10)
    tmp_if_expr_14 = (_Bool)1;

  else
  {
    struct in6_addr *IN6_IS_ADDR_GLOBAL__1__3____a = (struct in6_addr *)addr;
    unsigned int return_value_htonl_12;
    return_value_htonl_12=htonl(0xffc00000);
    unsigned int return_value_htonl_13;
    return_value_htonl_13=htonl(0xfe800000);
    tmp_statement_expression_11 = (IN6_IS_ADDR_GLOBAL__1__3____a->__in6_u.__u6_addr32[(signed long int)0] & return_value_htonl_12) == return_value_htonl_13;
    tmp_if_expr_14 = tmp_statement_expression_11 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_15;
  if(tmp_if_expr_14)
    tmp_if_expr_15 = (_Bool)1;

  else
    tmp_if_expr_15 = (signed int)((const unsigned char *)addr)[(signed long int)0] == 0xff ? (_Bool)1 : (_Bool)0;
  return !tmp_if_expr_15;
}

// IsBubble
// file packets.h line 48
static inline _Bool IsBubble(struct ip6_hdr *hdr)
{
  _Bool tmp_if_expr_1;
  if((signed int)hdr->ip6_ctlun.ip6_un1.ip6_un1_plen == 0)
    tmp_if_expr_1 = (signed int)hdr->ip6_ctlun.ip6_un1.ip6_un1_nxt == 59 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  return tmp_if_expr_1;
}

// LogError
// file conf.c line 91
static void LogError(struct miredo_conf *conf, const char *fmt, ...)
{
  if(!(conf->logger == ((void (*)(void *, _Bool, const char *, void **))NULL)))
  {
    void **ap = (void **)&fmt;
    conf->logger(conf->logger_data, (_Bool)1, fmt, ap);
    ap = ((void **)NULL);
  }

}

// LogWarning
// file conf.c line 111
static void LogWarning(struct miredo_conf *conf, const char *fmt, ...)
{
  if(!(conf->logger == ((void (*)(void *, _Bool, const char *, void **))NULL)))
  {
    void **ap = (void **)&fmt;
    conf->logger(conf->logger_data, (_Bool)0, fmt, ap);
    ap = ((void **)NULL);
  }

}

// Pryt4897810065911_br_build_path
// file binreloc.c line 690
char * Pryt4897810065911_br_build_path(const char *dir, const char *file)
{
  char *dir2;
  char *result;
  unsigned long int len;
  signed int must_free = 0;
  len=strlen(dir);
  _Bool tmp_if_expr_1;
  if(len >= 1ul)
    tmp_if_expr_1 = (signed int)dir[(signed long int)(len - (unsigned long int)1)] != 47 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
  {
    dir2=Pryt4897810065911_br_strcat(dir, "/");
    must_free = 1;
  }

  else
    dir2 = (char *)dir;
  result=Pryt4897810065911_br_strcat(dir2, file);
  if(!(must_free == 0))
    free((void *)dir2);

  return result;
}

// Pryt4897810065911_br_dirname
// file binreloc.c line 746
char * Pryt4897810065911_br_dirname(const char *path)
{
  char *end;
  char *result;
  char *return_value_strdup_1;
  if(path == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    end=strrchr(path, 47);
    if(end == ((const char *)NULL))
    {
      return_value_strdup_1=strdup(".");
      return return_value_strdup_1;
    }

    else
    {
      for( ; !(path >= end); end = end - 1l)
        if(!((signed int)*end == 47))
          break;

      result=br_strndup(path, (unsigned long int)((end - path) + (signed long int)1));
      if((signed int)*result == 0)
      {
        free((void *)result);
        char *return_value_strdup_2;
        return_value_strdup_2=strdup("/");
        return return_value_strdup_2;
      }

      else
        return result;
    }
  }
}

// Pryt4897810065911_br_find_bin_dir
// file binreloc.c line 438
char * Pryt4897810065911_br_find_bin_dir(const char *default_bin_dir)
{
  char *prefix;
  char *dir;
  prefix=Pryt4897810065911_br_find_prefix((const char *)(void *)0);
  char *return_value_strdup_1;
  if(prefix == ((char *)NULL))
  {
    if(!(default_bin_dir == ((const char *)NULL)))
    {
      return_value_strdup_1=strdup(default_bin_dir);
      return return_value_strdup_1;
    }

    else
      return (char *)(void *)0;
  }

  dir=Pryt4897810065911_br_build_path(prefix, "bin");
  free((void *)prefix);
  return dir;
}

// Pryt4897810065911_br_find_data_dir
// file binreloc.c line 505
char * Pryt4897810065911_br_find_data_dir(const char *default_data_dir)
{
  char *prefix;
  char *dir;
  prefix=Pryt4897810065911_br_find_prefix((const char *)(void *)0);
  char *return_value_strdup_1;
  if(prefix == ((char *)NULL))
  {
    if(!(default_data_dir == ((const char *)NULL)))
    {
      return_value_strdup_1=strdup(default_data_dir);
      return return_value_strdup_1;
    }

    else
      return (char *)(void *)0;
  }

  dir=Pryt4897810065911_br_build_path(prefix, "share");
  free((void *)prefix);
  return dir;
}

// Pryt4897810065911_br_find_etc_dir
// file binreloc.h line 68
char * Pryt4897810065911_br_find_etc_dir(const char *default_etc_dir)
{
  char *prefix;
  char *dir;
  prefix=Pryt4897810065911_br_find_prefix((const char *)(void *)0);
  char *return_value_strdup_1;
  if(prefix == ((char *)NULL))
  {
    if(!(default_etc_dir == ((const char *)NULL)))
    {
      return_value_strdup_1=strdup(default_etc_dir);
      return return_value_strdup_1;
    }

    else
      return (char *)(void *)0;
  }

  dir=Pryt4897810065911_br_build_path(prefix, "etc");
  free((void *)prefix);
  return dir;
}

// Pryt4897810065911_br_find_exe
// file binreloc.c line 349
char * Pryt4897810065911_br_find_exe(const char *default_exe)
{
  char *return_value_strdup_1;
  if(exe == ((char *)NULL))
  {
    if(!(default_exe == ((const char *)NULL)))
    {
      return_value_strdup_1=strdup(default_exe);
      return return_value_strdup_1;
    }

    else
      return (char *)(void *)0;
  }

  char *return_value_strdup_2;
  return_value_strdup_2=strdup(exe);
  return return_value_strdup_2;
}

// Pryt4897810065911_br_find_exe_dir
// file binreloc.c line 377
char * Pryt4897810065911_br_find_exe_dir(const char *default_dir)
{
  char *return_value_strdup_1;
  if(exe == ((char *)NULL))
  {
    if(!(default_dir == ((const char *)NULL)))
    {
      return_value_strdup_1=strdup(default_dir);
      return return_value_strdup_1;
    }

    else
      return (char *)(void *)0;
  }

  char *return_value_Pryt4897810065911_br_dirname_2;
  return_value_Pryt4897810065911_br_dirname_2=Pryt4897810065911_br_dirname(exe);
  return return_value_Pryt4897810065911_br_dirname_2;
}

// Pryt4897810065911_br_find_lib_dir
// file binreloc.c line 571
char * Pryt4897810065911_br_find_lib_dir(const char *default_lib_dir)
{
  char *prefix;
  char *dir;
  prefix=Pryt4897810065911_br_find_prefix((const char *)(void *)0);
  char *return_value_strdup_1;
  if(prefix == ((char *)NULL))
  {
    if(!(default_lib_dir == ((const char *)NULL)))
    {
      return_value_strdup_1=strdup(default_lib_dir);
      return return_value_strdup_1;
    }

    else
      return (char *)(void *)0;
  }

  dir=Pryt4897810065911_br_build_path(prefix, "lib");
  free((void *)prefix);
  return dir;
}

// Pryt4897810065911_br_find_libexec_dir
// file binreloc.c line 604
char * Pryt4897810065911_br_find_libexec_dir(const char *default_libexec_dir)
{
  char *prefix;
  char *dir;
  prefix=Pryt4897810065911_br_find_prefix((const char *)(void *)0);
  char *return_value_strdup_1;
  if(prefix == ((char *)NULL))
  {
    if(!(default_libexec_dir == ((const char *)NULL)))
    {
      return_value_strdup_1=strdup(default_libexec_dir);
      return return_value_strdup_1;
    }

    else
      return (char *)(void *)0;
  }

  dir=Pryt4897810065911_br_build_path(prefix, "libexec");
  free((void *)prefix);
  return dir;
}

// Pryt4897810065911_br_find_locale_dir
// file binreloc.h line 65
char * Pryt4897810065911_br_find_locale_dir(const char *default_locale_dir)
{
  char *data_dir;
  char *dir;
  data_dir=Pryt4897810065911_br_find_data_dir((const char *)(void *)0);
  char *return_value_strdup_1;
  if(data_dir == ((char *)NULL))
  {
    if(!(default_locale_dir == ((const char *)NULL)))
    {
      return_value_strdup_1=strdup(default_locale_dir);
      return return_value_strdup_1;
    }

    else
      return (char *)(void *)0;
  }

  dir=Pryt4897810065911_br_build_path(data_dir, "locale");
  free((void *)data_dir);
  return dir;
}

// Pryt4897810065911_br_find_prefix
// file binreloc.c line 405
char * Pryt4897810065911_br_find_prefix(const char *default_prefix)
{
  char *dir1;
  char *dir2;
  char *return_value_strdup_1;
  if(exe == ((char *)NULL))
  {
    if(!(default_prefix == ((const char *)NULL)))
    {
      return_value_strdup_1=strdup(default_prefix);
      return return_value_strdup_1;
    }

    else
      return (char *)(void *)0;
  }

  dir1=Pryt4897810065911_br_dirname(exe);
  dir2=Pryt4897810065911_br_dirname(dir1);
  free((void *)dir1);
  return dir2;
}

// Pryt4897810065911_br_find_sbin_dir
// file binreloc.c line 471
char * Pryt4897810065911_br_find_sbin_dir(const char *default_sbin_dir)
{
  char *prefix;
  char *dir;
  prefix=Pryt4897810065911_br_find_prefix((const char *)(void *)0);
  char *return_value_strdup_1;
  if(prefix == ((char *)NULL))
  {
    if(!(default_sbin_dir == ((const char *)NULL)))
    {
      return_value_strdup_1=strdup(default_sbin_dir);
      return return_value_strdup_1;
    }

    else
      return (char *)(void *)0;
  }

  dir=Pryt4897810065911_br_build_path(prefix, "sbin");
  free((void *)prefix);
  return dir;
}

// Pryt4897810065911_br_init
// file binreloc.h line 56
signed int Pryt4897810065911_br_init(enum anonymous_11 *error)
{
  exe=_br_find_exe(error);
  return (signed int)(exe != (char *)(void *)0);
}

// Pryt4897810065911_br_init_lib
// file binreloc.c line 332
signed int Pryt4897810065911_br_init_lib(enum anonymous_11 *error)
{
  exe=_br_find_exe_for_symbol((const void *)"", error);
  return (signed int)(exe != (char *)(void *)0);
}

// Pryt4897810065911_br_strcat
// file binreloc.c line 667
char * Pryt4897810065911_br_strcat(const char *str1, const char *str2)
{
  char *result;
  unsigned long int len1;
  unsigned long int len2;
  if(str1 == ((const char *)NULL))
    str1 = "";

  if(str2 == ((const char *)NULL))
    str2 = "";

  len1=strlen(str1);
  len2=strlen(str2);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(len1 + len2 + (unsigned long int)1);
  result = (char *)return_value_malloc_1;
  memcpy((void *)result, (const void *)str1, len1);
  memcpy((void *)(result + (signed long int)len1), (const void *)str2, len2);
  result[(signed long int)(len1 + len2)] = (char)0;
  return result;
}

// SendRA
// file server.c line 78
static _Bool SendRA(const struct teredo_server * restrict s, struct teredo_packet *p, struct in6_addr *dest_ip6, _Bool secondary)
{
  const unsigned char *nonce;
  struct in6_addr *addr;
  unsigned char auth[13l] = { (unsigned char)0, (unsigned char)1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  struct teredo_orig_ind orig;
  /* tag-#anon#lST[lSYM#tag-ip6_hdr#'ip6'||lSYM#tag-nd_router_advert#'ra'||lSYM#tag-nd_opt_prefix_info#'pi'||lSYM#tag-nd_opt_mtu#'mtu'|] */
struct anonymous_9
{
  // ip6
  struct ip6_hdr ip6;
  // ra
  struct nd_router_advert ra;
  // pi
  struct nd_opt_prefix_info pi;
  // mtu
  struct nd_opt_mtu mtu;
};

/* */
  ;
  struct anonymous_9 ra;
  struct iovec iov[3l] = { { .iov_base=(void *)auth, .iov_len=(unsigned long int)13 },
    { .iov_base=(void *)&orig, .iov_len=(unsigned long int)8 },
    { .iov_base=(void *)&ra, .iov_len=sizeof(struct anonymous_9) /*96ul*/  } };
  nonce = p->auth_nonce;
  if(!(nonce == ((const unsigned char *)NULL)))
    memcpy((void *)(auth + (signed long int)4), (const void *)nonce, (unsigned long int)8);

  else
    iov[(signed long int)0].iov_len = (unsigned long int)0;
  orig.orig_zero = (unsigned char)0;
  orig.orig_code = (unsigned char)0;
  orig.orig_port = (unsigned short int)~((signed int)p->source_port);
  orig.orig_addr = ~p->source_ipv4;
  memset((void *)&ra, 0, sizeof(struct anonymous_9) /*96ul*/ );
  ra.ip6.ip6_ctlun.ip6_un1.ip6_un1_flow=htonl((unsigned int)0x60000000);
  ra.ip6.ip6_ctlun.ip6_un1.ip6_un1_plen=htons((unsigned short int)(sizeof(struct anonymous_9) /*96ul*/  - sizeof(struct ip6_hdr) /*40ul*/ ));
  ra.ip6.ip6_ctlun.ip6_un1.ip6_un1_nxt = (unsigned char)58;
  ra.ip6.ip6_ctlun.ip6_un1.ip6_un1_hlim = (unsigned char)255;
  ra.ip6.ip6_src = s->lladdr.ip6;
  ra.ip6.ip6_dst = *dest_ip6;
  ra.ra.nd_ra_hdr.icmp6_type = (unsigned char)134;
  ra.ra.nd_ra_retransmit=htonl((unsigned int)2000);
  ra.pi.nd_opt_pi_type = (unsigned char)3;
  ra.pi.nd_opt_pi_len = (unsigned char)(sizeof(struct nd_opt_prefix_info) /*32ul*/  >> 3);
  ra.pi.nd_opt_pi_prefix_len = (unsigned char)64;
  ra.pi.nd_opt_pi_flags_reserved = (unsigned char)0x40;
  ra.pi.nd_opt_pi_valid_time = 0xffffffff;
  ra.pi.nd_opt_pi_preferred_time = 0xffffffff;
  addr = &ra.pi.nd_opt_pi_prefix;
  memcpy((void *)&addr->__in6_u.__u6_addr8[(signed long int)0], (const void *)&s->prefix, sizeof(unsigned int) /*4ul*/ );
  memcpy((void *)&addr->__in6_u.__u6_addr8[(signed long int)4], (const void *)&s->server_ip, sizeof(unsigned int) /*4ul*/ );
  ra.mtu.nd_opt_mtu_type = (unsigned char)5;
  ra.mtu.nd_opt_mtu_len = (unsigned char)(sizeof(struct nd_opt_mtu) /*8ul*/  >> 3);
  ra.mtu.nd_opt_mtu_mtu = s->advLinkMTU;
  ra.ra.nd_ra_hdr.icmp6_cksum=icmp6_checksum(&ra.ip6, (struct icmp6_hdr *)&ra.ra);
  unsigned short int return_value_htons_1;
  return_value_htons_1=htons((unsigned short int)0x8000);
  if(!(((signed int)((union teredo_addr *)dest_ip6)->teredo.flags & (signed int)return_value_htons_1) == 0))
    secondary = !(secondary != (_Bool)0);

  signed int tmp_if_expr_2;
  if(!(secondary == (_Bool)0))
    tmp_if_expr_2 = s->fd_secondary;

  else
    tmp_if_expr_2 = s->fd_primary;
  signed int return_value_teredo_sendv_3;
  return_value_teredo_sendv_3=teredo_sendv(tmp_if_expr_2, iov, (unsigned long int)3, p->source_ipv4, p->source_port);
  return return_value_teredo_sendv_3 > 0;
}

// _br_find_exe
// file binreloc.c line 43
static char * _br_find_exe(enum anonymous_11 *error)
{
  if(!(error == ((enum anonymous_11 *)NULL)))
    *error = (enum anonymous_11)BR_INIT_ERROR_DISABLED;

  return (char *)(void *)0;
}

// _br_find_exe_for_symbol
// file binreloc.c line 182
static char * _br_find_exe_for_symbol(const void *symbol, enum anonymous_11 *error)
{
  (void)symbol;
  if(!(error == ((enum anonymous_11 *)NULL)))
    *error = (enum anonymous_11)BR_INIT_ERROR_DISABLED;

  return (char *)(void *)0;
}

// br_strndup
// file binreloc.c line 712
static char * br_strndup(const char *str, unsigned long int size)
{
  char *result = (char *)(void *)0;
  unsigned long int len;
  char *return_value_strdup_1;
  if(str == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    len=strlen(str);
    if(len == 0ul)
    {
      return_value_strdup_1=strdup("");
      return return_value_strdup_1;
    }

    else
    {
      if(!(len >= size))
        size = len;

      void *return_value_malloc_2;
      return_value_malloc_2=malloc(len + (unsigned long int)1);
      result = (char *)return_value_malloc_2;
      memcpy((void *)result, (const void *)str, size);
      result[(signed long int)size] = (char)0;
      return result;
    }
  }
}

// closefrom
// file closefrom.c line 39
signed int closefrom(signed int fd)
{
  struct rlimit lim;
  unsigned int found = (unsigned int)0;
  signed int saved_errno;
  signed int return_value_getrlimit_1;
  return_value_getrlimit_1=getrlimit((enum __rlimit_resource)RLIMIT_NOFILE, &lim);
  signed int tmp_post_3;
  signed int return_value_close_4;
  if(!(return_value_getrlimit_1 == 0))
    return -1;

  else
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    saved_errno = *return_value___errno_location_2;
    if(lim.rlim_max >= 1025ul)
    {
      if(lim.rlim_cur >= 1025ul)
        lim.rlim_cur = (unsigned long int)1024;

      lim.rlim_max = (unsigned long int)1024;
      setrlimit((enum __rlimit_resource)RLIMIT_NOFILE, &lim);
    }

    while(!((unsigned long int)(unsigned int)fd >= lim.rlim_max))
    {
      tmp_post_3 = fd;
      fd = fd + 1;
      return_value_close_4=close(tmp_post_3);
      if(return_value_close_4 == 0)
        found = found + 1u;

    }
    if(found == 0u)
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      *return_value___errno_location_5 = 9;
      return -1;
    }

    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    *return_value___errno_location_6 = saved_errno;
    return 0;
  }
}

// create_pidfile
// file main.c line 156
static signed int create_pidfile(const char *path)
{
  signed int fd;
  fd=open(path, 01 | 0100 | 0400000, 0644);
  signed int return_value_lockf_9;
  signed int return_value_ftruncate_8;
  unsigned long int return_value_strlen_5;
  signed long int return_value_write_6;
  unsigned long int return_value_strlen_7;
  signed int return_value_fdatasync_4;
  signed int *return_value___errno_location_11;
  if(!(fd == -1))
  {
    char buf[20l];
    struct stat s;
    signed int return_value_getpid_1;
    return_value_getpid_1=getpid();
    snprintf(buf, sizeof(char [20l]) /*20ul*/ , "%d", (signed int)return_value_getpid_1);
    buf[(signed long int)(sizeof(char [20l]) /*20ul*/  - (unsigned long int)1)] = (char)0;
    signed int return_value_fcntl_2;
    return_value_fcntl_2=fcntl(fd, 1);
    fcntl(fd, 2, return_value_fcntl_2 | 1);
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    *return_value___errno_location_3 = 0;
    signed int return_value_fstat_10;
    return_value_fstat_10=fstat(fd, &s);
    if(return_value_fstat_10 == 0)
    {
      if((61440u & s.st_mode) == 32768u)
      {
        return_value_lockf_9=lockf(fd, 2, (signed long int)0);
        if(return_value_lockf_9 == 0)
        {
          return_value_ftruncate_8=ftruncate(fd, (signed long int)0);
          if(return_value_ftruncate_8 == 0)
          {
            return_value_strlen_5=strlen(buf);
            return_value_write_6=write(fd, (const void *)buf, return_value_strlen_5);
            return_value_strlen_7=strlen(buf);
            if(return_value_write_6 == (signed long int)return_value_strlen_7)
            {
              return_value_fdatasync_4=fdatasync(fd);
              if(return_value_fdatasync_4 == 0)
                return fd;

            }

          }

        }

      }

    }

    signed int *return_value___errno_location_12;
    return_value___errno_location_12=__errno_location();
    if(*return_value___errno_location_12 == 0)
    {
      return_value___errno_location_11=__errno_location();
      *return_value___errno_location_11 = 13;
    }

    close(fd);
  }

  return -1;
}

// drop_privileges
// file miredo.h line 44
signed int drop_privileges(void)
{
  signed int return_value_chroot_2;
  _Bool tmp_if_expr_4;
  signed int return_value_chdir_3;
  if(!(miredo_chrootdir == ((const char *)NULL)))
  {
    return_value_chroot_2=chroot(miredo_chrootdir);
    if(!(return_value_chroot_2 == 0))
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_chdir_3=chdir("/");
      tmp_if_expr_4 = return_value_chdir_3 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
    {
      char *return_value_dgettext_1;
      return_value_dgettext_1=dgettext("miredo", "Error (%s): %m");
      syslog(1, return_value_dgettext_1, (const void *)"chroot");
      return -1;
    }

  }

  signed int return_value_setuid_6;
  return_value_setuid_6=setuid(unpriv_uid);
  if(!(return_value_setuid_6 == 0))
  {
    char *return_value_dgettext_5;
    return_value_dgettext_5=dgettext("miredo", "Error (%s): %m");
    syslog(1, return_value_dgettext_5, (const void *)"setuid");
    return -1;
  }

  struct _cap_struct *s;
  s=cap_init();
  if(!(s == ((struct _cap_struct *)NULL)))
  {
    cap_set_proc(s);
    cap_free((void *)s);
  }

  return 0;
}

// error_dup
// file main.c line 112
static signed int error_dup(signed int opt, const char *already, const char *additionnal)
{
  char *return_value_dgettext_1;
  return_value_dgettext_1=dgettext("miredo", "Duplicate parameter \"%s\" for option -%c\nwould override previous value \"%s\".\n");
  fprintf(stderr, return_value_dgettext_1, additionnal, opt, already);
  return 2;
}

// error_errno
// file main.c line 142
static signed int error_errno(const char *str)
{
  char *return_value_dgettext_1;
  return_value_dgettext_1=dgettext("miredo", "Error (%s): %s\n");
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  char *return_value_strerror_3;
  return_value_strerror_3=strerror(*return_value___errno_location_2);
  fprintf(stderr, return_value_dgettext_1, str, return_value_strerror_3);
  return -1;
}

// error_extra
// file main.c line 134
static signed int error_extra(const char *extra)
{
  char *return_value_dgettext_1;
  return_value_dgettext_1=dgettext("miredo", "%s: unexpected extra parameter\n");
  fprintf(stderr, return_value_dgettext_1, extra);
  return 2;
}

// icmp6_checksum
// file checksum.h line 34
static inline unsigned short int icmp6_checksum(struct ip6_hdr *ip6, struct icmp6_hdr *icmp6)
{
  struct iovec iov;
  unsigned short int return_value_ntohs_1;
  return_value_ntohs_1=ntohs(ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);
  iov = (struct iovec){ .iov_base=(void *)icmp6, .iov_len=(unsigned long int)return_value_ntohs_1 };
  unsigned short int return_value_teredo_cksum_2;
  return_value_teredo_cksum_2=teredo_cksum((const void *)&ip6->ip6_src, (const void *)&ip6->ip6_dst, (unsigned char)58, &iov, (unsigned long int)1);
  return return_value_teredo_cksum_2;
}

// in6_matches_teredo_client
// file teredo.h line 95
static inline signed int in6_matches_teredo_client(struct in6_addr *ip6, unsigned int ip, unsigned short int port)
{
  _Bool tmp_if_expr_1;
  if(!((0xffffffff ^ ((union teredo_addr *)ip6)->teredo.client_ip ^ ip) == 0u))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = ((signed int)port ^ (signed int)(&((union teredo_addr *)ip6)->teredo)->client_port ^ 0xffff) != 0 ? (_Bool)1 : (_Bool)0;
  return (signed int)!tmp_if_expr_1;
}

// in_cksum
// file teredo.c line 338
static unsigned short int in_cksum(struct iovec *iov, unsigned long int n)
{
  unsigned int sum = (unsigned int)0;
  /* tag-#anon#lUN[U16'word'||lARR2{U8}_U8_'bytes'|] */
union anonymous_8
{
  // word
  unsigned short int word;
  // bytes
  unsigned char bytes[2l];
};

/* */
  ;
  union anonymous_8 w;
  _Bool odd = (_Bool)0;
  const unsigned char *tmp_post_1;
  const unsigned char *tmp_post_2;
  while(n >= 1ul)
  {
    const unsigned char *ptr = (const unsigned char *)iov->iov_base;
    unsigned long int len = iov->iov_len;
    for( ; len >= 1ul; len = len - 1ul)
    {
      if(!(odd == (_Bool)0))
      {
        tmp_post_1 = ptr;
        ptr = ptr + 1l;
        w.bytes[(signed long int)1] = *tmp_post_1;
        sum = sum + (unsigned int)w.word;
        if(sum >= 65536u)
          sum = sum - (unsigned int)0xffff;

      }

      else
      {
        tmp_post_2 = ptr;
        ptr = ptr + 1l;
        w.bytes[(signed long int)0] = *tmp_post_2;
      }
      odd = !(odd != (_Bool)0);
    }
    iov = iov + 1l;
    n = n - 1ul;
  }
  if(!(odd == (_Bool)0))
  {
    w.bytes[(signed long int)1] = (unsigned char)0;
    sum = sum + (unsigned int)w.word;
    if(sum >= 65536u)
      sum = sum - (unsigned int)0xffff;

  }

  return (unsigned short int)(sum ^ (unsigned int)0xffff);
}

// init_locale
// file main.c line 313
static void init_locale(void)
{
  Pryt4897810065911_br_init((enum anonymous_11 *)(void *)0);
  setlocale(6, "");
  char *path;
  path=Pryt4897810065911_br_find_locale_dir("/usr/share/locale");
  bindtextdomain("miredo", path);
  free((void *)path);
  textdomain("miredo");
}

// init_security
// file main.c line 207
static signed int init_security(const char *username)
{
  signed int val;
  umask((unsigned int)022);
  signed int return_value_chdir_1;
  return_value_chdir_1=chdir("/");
  char *tmp_if_expr_8;
  signed int *return_value___errno_location_5;
  char *return_value_strerror_6;
  char *return_value_dgettext_7;
  _Bool tmp_if_expr_15;
  signed int return_value_setgid_14;
  _Bool tmp_if_expr_17;
  signed int return_value_initgroups_16;
  signed int return_value_error_errno_18;
  if(!(return_value_chdir_1 == 0))
    return -1;

  else
  {
    closefrom(3);
    val=dup(2);
    if(!(val == 3))
      return -1;

    else
    {
      close(val);
      clearenv();
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = 0;
      struct passwd *pw;
      pw=getpwnam(username);
      if(pw == ((struct passwd *)NULL))
      {
        char *return_value_dgettext_3;
        return_value_dgettext_3=dgettext("miredo", "User \"%s\": %s\n");
        signed int *return_value___errno_location_4;
        return_value___errno_location_4=__errno_location();
        if(!(*return_value___errno_location_4 == 0))
        {
          return_value___errno_location_5=__errno_location();
          return_value_strerror_6=strerror(*return_value___errno_location_5);
          tmp_if_expr_8 = return_value_strerror_6;
        }

        else
        {
          return_value_dgettext_7=dgettext("miredo", "User not found");
          tmp_if_expr_8 = return_value_dgettext_7;
        }
        fprintf(stderr, return_value_dgettext_3, username, tmp_if_expr_8);
        return -1;
      }

      if(pw->pw_uid == 0u)
      {
        char *return_value_dgettext_9;
        return_value_dgettext_9=dgettext("miredo", "Error: This program is not supposed to keep root\nprivileges. That is potentially very dangerous\n(all the more as it has never been externally audited).\n");
        fputs(return_value_dgettext_9, stderr);
        return -1;
      }

      unpriv_uid = pw->pw_uid;
      signed int return_value_seteuid_13;
      return_value_seteuid_13=seteuid((unsigned int)0);
      if(!(return_value_seteuid_13 == 0))
        tmp_if_expr_15 = (_Bool)1;

      else
      {
        return_value_setgid_14=setgid(pw->pw_gid);
        tmp_if_expr_15 = return_value_setgid_14 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_15)
        tmp_if_expr_17 = (_Bool)1;

      else
      {
        return_value_initgroups_16=initgroups(username, pw->pw_gid);
        tmp_if_expr_17 = return_value_initgroups_16 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_17)
      {
        char *return_value_dgettext_10;
        return_value_dgettext_10=dgettext("miredo", "SetUID to root: %s\n");
        signed int *return_value___errno_location_11;
        return_value___errno_location_11=__errno_location();
        char *return_value_strerror_12;
        return_value_strerror_12=strerror(*return_value___errno_location_11);
        fprintf(stderr, return_value_dgettext_10, return_value_strerror_12);
        setuid_notice();
        return -1;
      }

      struct _cap_struct *s;
      s=cap_init();
      if(s == ((struct _cap_struct *)NULL))
      {
        return_value_error_errno_18=error_errno("cap_init");
        return return_value_error_errno_18;
      }

      else
      {
        static signed int caps[2l] = { 5, 7 };
        cap_set_flag(s, (enum anonymous_12)CAP_PERMITTED, 3, caps, (enum anonymous_13)CAP_SET);
        cap_set_flag(s, (enum anonymous_12)CAP_EFFECTIVE, 3, caps, (enum anonymous_13)CAP_SET);
        if(!(miredo_chrootdir == ((const char *)NULL)))
        {
          static signed int chroot_cap[1l] = { 18 };
          cap_set_flag(s, (enum anonymous_12)CAP_PERMITTED, 1, chroot_cap, (enum anonymous_13)CAP_SET);
          cap_set_flag(s, (enum anonymous_12)CAP_EFFECTIVE, 1, chroot_cap, (enum anonymous_13)CAP_SET);
        }

        cap_set_flag(s, (enum anonymous_12)CAP_PERMITTED, miredo_capc, (signed int *)miredo_capv, (enum anonymous_13)CAP_SET);
        cap_set_flag(s, (enum anonymous_12)CAP_EFFECTIVE, miredo_capc, (signed int *)miredo_capv, (enum anonymous_13)CAP_SET);
        val=cap_set_proc(s);
        cap_free((void *)s);
        if(!(val == 0))
        {
          error_errno("cap_set_proc");
          setuid_notice();
          return -1;
        }

        else
          return 0;
      }
    }
  }
}

// is_ipv4_global_unicast
// file v4global.h line 34
signed int is_ipv4_global_unicast(unsigned int ip)
{
  unsigned int return_value_htonl_7;
  return_value_htonl_7=htonl(0x80000000);
  _Bool tmp_if_expr_4;
  unsigned int return_value_htonl_3;
  _Bool tmp_if_expr_6;
  unsigned int return_value_htonl_5;
  if((return_value_htonl_7 & ip) == 0u)
  {
    unsigned int return_value_htonl_1;
    return_value_htonl_1=htonl(0xff000000);
    ip = ip & return_value_htonl_1;
    unsigned int return_value_htonl_2;
    return_value_htonl_2=htonl((unsigned int)0x0a000000);
    if(!(ip == return_value_htonl_2))
    {
      return_value_htonl_3=htonl((unsigned int)0x7f000000);
      tmp_if_expr_4 = ip != return_value_htonl_3 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
    {
      return_value_htonl_5=htonl((unsigned int)0x00000000);
      tmp_if_expr_6 = ip != return_value_htonl_5 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_6 = (_Bool)0;
    return (signed int)tmp_if_expr_6;
  }

  unsigned int return_value_htonl_13;
  return_value_htonl_13=htonl((unsigned int)0x40000000);
  _Bool tmp_if_expr_12;
  unsigned int return_value_htonl_10;
  unsigned int return_value_htonl_11;
  if((return_value_htonl_13 & ip) == 0u)
  {
    unsigned int return_value_htonl_8;
    return_value_htonl_8=htonl(0xffff0000);
    unsigned int return_value_htonl_9;
    return_value_htonl_9=htonl(0xa9fe0000);
    if(!((return_value_htonl_8 & ip) == return_value_htonl_9))
    {
      return_value_htonl_10=htonl(0xfff00000);
      return_value_htonl_11=htonl(0xac100000);
      tmp_if_expr_12 = (ip & return_value_htonl_10) != return_value_htonl_11 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_12 = (_Bool)0;
    return (signed int)tmp_if_expr_12;
  }

  unsigned int return_value_htonl_19;
  return_value_htonl_19=htonl((unsigned int)0x20000000);
  _Bool tmp_if_expr_18;
  unsigned int return_value_htonl_16;
  unsigned int return_value_htonl_17;
  if((return_value_htonl_19 & ip) == 0u)
  {
    unsigned int return_value_htonl_14;
    return_value_htonl_14=htonl(0xffff0000);
    unsigned int return_value_htonl_15;
    return_value_htonl_15=htonl(0xc0a80000);
    if(!((return_value_htonl_14 & ip) == return_value_htonl_15))
    {
      return_value_htonl_16=htonl(0xffffff00);
      return_value_htonl_17=htonl(0xc0586200);
      tmp_if_expr_18 = (ip & return_value_htonl_16) != return_value_htonl_17 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_18 = (_Bool)0;
    return (signed int)tmp_if_expr_18;
  }

  unsigned int return_value_htonl_20;
  return_value_htonl_20=htonl((unsigned int)0x10000000);
  if((return_value_htonl_20 & ip) == 0u)
    return 0;

  else
  {
    unsigned int return_value_htonl_21;
    return_value_htonl_21=htonl(0xffffffff);
    return (signed int)(ip != return_value_htonl_21);
  }
}

// logger
// file miredo.c line 96
static void logger(void *dummy, _Bool error, const char *fmt, void **ap)
{
  (void)dummy;
  vsyslog(error != (_Bool)0 ? 3 : 4, fmt, ap);
}

// main
// file serverd.c line 164
signed int main(signed int argc, char **argv)
{
  static const signed int capv[1l] = { 13 };
  miredo_capv = capv;
  miredo_capc = (signed int)(sizeof(const signed int [1l]) /*4ul*/  / sizeof(const signed int) /*4ul*/ );
  miredo_name = "miredo-server";
  miredo_diagnose = server_diagnose;
  miredo_run = server_run;
  signed int return_value_miredo_main_1;
  return_value_miredo_main_1=miredo_main(argc, argv);
  return return_value_miredo_main_1;
}

// miredo
// file miredo.h line 43
signed int miredo(const char *confpath, const char *server_name, signed int pidfd)
{
  struct anonymous set;
  struct anonymous exit_set;
  struct anonymous reload_set;
  signed int retval;
  struct miredo_conf *cnf;
  cnf=miredo_conf_create(logger, (void *)0);
  char *return_value_dgettext_1;
  char *return_value_dgettext_4;
  signed int return_value_waitpid_6;
  signed int return_value_sigismember_11;
  signed int return_value_waitpid_13;
  if(cnf == ((struct miredo_conf *)NULL))
    return -1;

  else
  {
    sigemptyset(&set);
    sigaddset(&set, 2);
    sigaddset(&set, 3);
    sigaddset(&set, 15);
    exit_set = set;
    sigaddset(&set, 1);
    reload_set = set;
    sigaddset(&set, 17);
    pthread_sigmask(0, &set, (struct anonymous *)(void *)0);
    openlog(miredo_name, 0x01 | 0x20, 3 << 3);
    do
    {
      signed int facility = 3 << 3;
      retval = 1;
      _Bool return_value_miredo_conf_read_file_2;
      return_value_miredo_conf_read_file_2=miredo_conf_read_file(cnf, confpath);
      if(return_value_miredo_conf_read_file_2 == (_Bool)0)
      {
        return_value_dgettext_1=dgettext("miredo", "Loading configuration from %s failed");
        syslog(4, return_value_dgettext_1, confpath);
      }

      miredo_conf_parse_syslog_facility(cnf, "SyslogFacility", &facility);
      closelog();
      openlog(miredo_name, 0x01 | 0x20, facility);
      char *return_value_dgettext_3;
      return_value_dgettext_3=dgettext("miredo", "Starting...");
      syslog(6, return_value_dgettext_3);
      signed int pid;
      pid=fork();
      if(!(pid == -1))
      {
        if(pid == 0)
          goto __CPROVER_DUMP_L5;

      }

      else
      {
        return_value_dgettext_4=dgettext("miredo", "Error (%s): %m");
        syslog(1, return_value_dgettext_4, (const void *)"fork");
        continue;

      __CPROVER_DUMP_L5:
        ;
        close(pidfd);
        retval=miredo_run(cnf, server_name);
        miredo_conf_destroy(cnf);
        closelog();
        exit(-retval);
      }
      miredo_conf_clear(cnf, 0);
      signed int status;
      signed int signum;
      do
      {

      __CPROVER_DUMP_L8:
        ;
        signed int return_value_sigwait_5;
        return_value_sigwait_5=sigwait(&set, &signum);
        if(!(return_value_sigwait_5 == 0))
          goto __CPROVER_DUMP_L8;

        if(signum == 17)
        {
          return_value_waitpid_6=waitpid(pid, &status, 1);
          if(return_value_waitpid_6 == pid)
            break;

        }

        signed int return_value_sigismember_12;
        return_value_sigismember_12=sigismember(&exit_set, signum);
        if(!(return_value_sigismember_12 == 0))
        {
          char *return_value_dgettext_7;
          return_value_dgettext_7=dgettext("miredo", "Exiting on signal %d (%s)");
          char *return_value_strsignal_8;
          return_value_strsignal_8=strsignal(signum);
          syslog(5, return_value_dgettext_7, signum, return_value_strsignal_8);
          retval = 0;
        }

        else
        {
          return_value_sigismember_11=sigismember(&reload_set, signum);
          if(!(return_value_sigismember_11 == 0))
          {
            char *return_value_dgettext_9;
            return_value_dgettext_9=dgettext("miredo", "Reloading configuration on signal %d (%s)");
            char *return_value_strsignal_10;
            return_value_strsignal_10=strsignal(signum);
            syslog(5, return_value_dgettext_9, signum, return_value_strsignal_10);
            retval = 2;
          }

          else
            continue;
        }
        kill(pid, 15);
        do
        {
          return_value_waitpid_13=waitpid(pid, &status, 0);
          if(return_value_waitpid_13 == pid)
            break;

        }
        while((_Bool)1);
        break;
      }
      while((_Bool)1);
      /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous_0
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
      ;
      if((0x7f & status) == 0)
      {
        status = (((union anonymous_0){ .__in=status }).__i & 0xff00) >> 8;
        char *return_value_dgettext_14;
        return_value_dgettext_14=dgettext("miredo", "Child %d exited (code: %d)");
        syslog(5, return_value_dgettext_14, (signed int)pid, status);
        if(!(status == 0))
          retval = 1;

      }

      else
        if((signed int)((127 & (signed char)status) + 1) >> 1 >= 1)
        {
          status = ((union anonymous_0){ .__in=status }).__i & 0x7f;
          char *return_value_dgettext_15;
          return_value_dgettext_15=dgettext("miredo", "Child %d killed by signal %d (%s)");
          char *return_value_strsignal_16;
          return_value_strsignal_16=strsignal(status);
          syslog(6, return_value_dgettext_15, (signed int)pid, status, return_value_strsignal_16);
          retval = 2;
          sleep((unsigned int)1);
        }

    }
    while(retval == 2);
    miredo_conf_destroy(cnf);
    char *return_value_gettext_17;
    return_value_gettext_17=gettext(retval != 0 ? "Terminated with error(s)." : "Terminated with no error.");
    syslog(6, return_value_gettext_17);
    closelog();
    return -retval;
  }
}

// miredo_conf_clear
// file conf.h line 38
void miredo_conf_clear(struct miredo_conf *conf, signed int show)
{
  struct setting *ptr = conf->head;
  conf->head = (struct setting *)(void *)0;
  while(!(ptr == ((struct setting *)NULL)))
  {
    struct setting *buf = ptr->next;
    if(show >= 1)
    {
      char *return_value_dgettext_1;
      return_value_dgettext_1=dgettext("miredo", "Superfluous directive %s at line %u");
      LogWarning(conf, return_value_dgettext_1, ptr->name, ptr->line);
      show = show - 1;
    }

    free((void *)ptr->name);
    free((void *)ptr->value);
    free((void *)ptr);
    ptr = buf;
  }
}

// miredo_conf_create
// file conf.h line 33
struct miredo_conf * miredo_conf_create(void (*logger)(void *, _Bool, const char *, void **), void *opaque)
{
  struct miredo_conf *conf;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct miredo_conf) /*32ul*/ );
  conf = (struct miredo_conf *)return_value_malloc_1;
  if(conf == ((struct miredo_conf *)NULL))
    return (struct miredo_conf *)(void *)0;

  else
  {
    conf->tail = (struct setting *)(void *)0;
    conf->head = conf->tail;
    conf->logger = logger;
    conf->logger_data = opaque;
    return conf;
  }
}

// miredo_conf_destroy
// file conf.h line 34
void miredo_conf_destroy(struct miredo_conf *conf)
{
  miredo_conf_clear(conf, 0);
  free((void *)conf);
}

// miredo_conf_get
// file conf.c line 206
char * miredo_conf_get(struct miredo_conf *conf, const char *name, unsigned int *line)
{
  struct setting *p = conf->head;
  struct setting *prev = (struct setting *)(void *)0;
  for( ; !(p == ((struct setting *)NULL)); p = p->next)
  {
    signed int return_value_strcasecmp_1;
    return_value_strcasecmp_1=strcasecmp(p->name, name);
    if(return_value_strcasecmp_1 == 0)
    {
      char *buf = p->value;
      if(!(line == ((unsigned int *)NULL)))
        *line = p->line;

      if(!(prev == ((struct setting *)NULL)))
        prev->next = p->next;

      else
        conf->head = p->next;
      free((void *)p->name);
      free((void *)p);
      return buf;
    }

    prev = p;
  }
  return (char *)(void *)0;
}

// miredo_conf_get_int16
// file conf.h line 41
_Bool miredo_conf_get_int16(struct miredo_conf *conf, const char *name, unsigned short int *value, unsigned int *line)
{
  char *val;
  val=miredo_conf_get(conf, name, line);
  if(val == ((char *)NULL))
    return (_Bool)1;

  else
  {
    char *end;
    unsigned long int l;
    l=strtoul(val, &end, 0);
    if(l >= 65536ul || !(*end == 0))
    {
      char *return_value_dgettext_1;
      return_value_dgettext_1=dgettext("miredo", "Invalid integer value \"%s\" for %s: %s");
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      char *return_value_strerror_3;
      return_value_strerror_3=strerror(*return_value___errno_location_2);
      LogError(conf, return_value_dgettext_1, val, name, return_value_strerror_3);
      free((void *)val);
      return (_Bool)0;
    }

    *value = (unsigned short int)l;
    free((void *)val);
    return (_Bool)1;
  }
}

// miredo_conf_parse_IPv4
// file conf.h line 48
_Bool miredo_conf_parse_IPv4(struct miredo_conf *conf, const char *name, unsigned int *ipv4)
{
  unsigned int line;
  char *val;
  val=miredo_conf_get(conf, name, &line);
  if(val == ((char *)NULL))
    return (_Bool)1;

  else
  {
    signed int check;
    check=GetIPv4ByName(val, ipv4);
    if(!(check == 0))
    {
      char *return_value_dgettext_1;
      return_value_dgettext_1=dgettext("miredo", "Invalid hostname \"%s\" at line %u: %s");
      const char *return_value_gai_strerror_2;
      return_value_gai_strerror_2=gai_strerror(check);
      LogError(conf, return_value_dgettext_1, val, line, return_value_gai_strerror_2);
      free((void *)val);
      return (_Bool)0;
    }

    free((void *)val);
    return (_Bool)1;
  }
}

// miredo_conf_parse_IPv6
// file conf.c line 436
_Bool miredo_conf_parse_IPv6(struct miredo_conf *conf, const char *name, struct in6_addr *value)
{
  unsigned int line;
  char *val;
  val=miredo_conf_get(conf, name, &line);
  if(val == ((char *)NULL))
    return (_Bool)1;

  else
  {
    struct addrinfo help = { .ai_flags=0, .ai_family=10, .ai_socktype=2, .ai_protocol=17,
    .ai_addrlen=0u, .ai_addr=((struct sockaddr *)NULL), .ai_canonname=((char *)NULL),
    .ai_next=((struct addrinfo *)NULL) };
    struct addrinfo *res;
    signed int check;
    check=getaddrinfo(val, (const char *)(void *)0, &help, &res);
    if(!(check == 0))
    {
      char *return_value_dgettext_1;
      return_value_dgettext_1=dgettext("miredo", "Invalid hostname \"%s\" at line %u: %s");
      const char *return_value_gai_strerror_2;
      return_value_gai_strerror_2=gai_strerror(check);
      LogError(conf, return_value_dgettext_1, val, line, return_value_gai_strerror_2);
      free((void *)val);
      return (_Bool)0;
    }

    memcpy((void *)value, (const void *)&((struct sockaddr_in6 *)res->ai_addr)->sin6_addr, sizeof(struct in6_addr) /*16ul*/ );
    freeaddrinfo(res);
    free((void *)val);
    return (_Bool)1;
  }
}

// miredo_conf_parse_syslog_facility
// file conf.h line 55
_Bool miredo_conf_parse_syslog_facility(struct miredo_conf *conf, const char *name, signed int *facility)
{
  unsigned int line;
  char *str;
  str=miredo_conf_get(conf, name, &line);
  if(str == ((char *)NULL))
    return (_Bool)1;

  else
  {
    struct miredo_conf_syslog_facility *ptr = facilities;
    for( ; !(ptr->str == ((const char *)NULL)); ptr = ptr + 1l)
    {
      signed int return_value_strcasecmp_1;
      return_value_strcasecmp_1=strcasecmp(str, ptr->str);
      if(return_value_strcasecmp_1 == 0)
      {
        *facility = ptr->facility;
        free((void *)str);
        return (_Bool)1;
      }

    }
    char *return_value_dgettext_2;
    return_value_dgettext_2=dgettext("miredo", "Unknown syslog facility \"%s\" at line %u");
    LogError(conf, return_value_dgettext_2, str, line);
    free((void *)str);
    return (_Bool)0;
  }
}

// miredo_conf_parse_teredo_prefix
// file conf.h line 52
_Bool miredo_conf_parse_teredo_prefix(struct miredo_conf *conf, const char *name, unsigned int *value)
{
  union teredo_addr addr;
  memset((void *)&addr, 0, sizeof(union teredo_addr) /*16ul*/ );
  addr.teredo.prefix = *value;
  _Bool return_value_miredo_conf_parse_IPv6_2;
  return_value_miredo_conf_parse_IPv6_2=miredo_conf_parse_IPv6(conf, name, &addr.ip6);
  if(!(return_value_miredo_conf_parse_IPv6_2 == (_Bool)0))
  {
    if((0xff000000 & addr.teredo.prefix) == 0xff000000)
    {
      char *return_value_dgettext_1;
      return_value_dgettext_1=dgettext("miredo", "Invalid Teredo IPv6 prefix: %x::/32");
      LogError(conf, return_value_dgettext_1, addr.teredo.prefix);
      return (_Bool)0;
    }

    *value = addr.teredo.prefix;
    return (_Bool)1;
  }

  else
    return (_Bool)0;
}

// miredo_conf_read_FILE
// file conf.c line 233
static _Bool miredo_conf_read_FILE(struct miredo_conf *conf, struct _IO_FILE *stream)
{
  char lbuf[1056l];
  unsigned int line = (unsigned int)0;
  char *return_value_fgets_1;
  signed int return_value_fgetc_3;
  signed int return_value_feof_4;
  _Bool tmp_if_expr_6;
  signed int return_value_ferror_5;
  _Bool return_value_miredo_conf_set_9;
  char *return_value_dgettext_10;
  do
  {
    return_value_fgets_1=fgets(lbuf, (signed int)sizeof(char [1056l]) /*1056ul*/ , stream);
    if(return_value_fgets_1 == ((char *)NULL))
      break;

    unsigned long int len;
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(lbuf);
    len = return_value_strlen_2 - (unsigned long int)1;
    line = line + 1u;
    if(!((signed int)lbuf[(signed long int)len] == 10))
    {
      do
      {
        return_value_fgetc_3=fgetc(stream);
        if(return_value_fgetc_3 == 10)
          break;

        return_value_feof_4=feof(stream);
        if(!(return_value_feof_4 == 0))
          tmp_if_expr_6 = (_Bool)1;

        else
        {
          return_value_ferror_5=ferror(stream);
          tmp_if_expr_6 = return_value_ferror_5 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_6)
          break;

      }
      while((_Bool)1);
      char *return_value_dgettext_7;
      return_value_dgettext_7=dgettext("miredo", "Skipped overly long line %u");
      LogWarning(conf, return_value_dgettext_7, line);
      continue;
    }

    lbuf[(signed long int)len] = (char)0;
    char nbuf[32l];
    char vbuf[1024l];
    signed int return_value_sscanf_8;
    return_value_sscanf_8=sscanf(lbuf, " %31s %1023s", (const void *)nbuf, (const void *)vbuf);
    switch(return_value_sscanf_8)
    {
      case 2:
      {
        if(!((signed int)nbuf[0l] == 35))
        {
          return_value_miredo_conf_set_9=miredo_conf_set(conf, nbuf, vbuf, line);
          if(return_value_miredo_conf_set_9 == (_Bool)0)
            return (_Bool)0;

        }

        break;
      }
      case 1:
        if(!((signed int)nbuf[0l] == 35))
        {
          return_value_dgettext_10=dgettext("miredo", "Ignoring line %u: %s");
          LogWarning(conf, return_value_dgettext_10, line, (const void *)nbuf);
        }

    }
  }
  while((_Bool)1);
  signed int return_value_ferror_14;
  return_value_ferror_14=ferror(stream);
  if(!(return_value_ferror_14 == 0))
  {
    char *return_value_dgettext_11;
    return_value_dgettext_11=dgettext("miredo", "Error reading configuration file: %s");
    signed int *return_value___errno_location_12;
    return_value___errno_location_12=__errno_location();
    char *return_value_strerror_13;
    return_value_strerror_13=strerror(*return_value___errno_location_12);
    LogError(conf, return_value_dgettext_11, return_value_strerror_13);
    return (_Bool)0;
  }

  return (_Bool)1;
}

// miredo_conf_read_file
// file conf.h line 36
_Bool miredo_conf_read_file(struct miredo_conf *conf, const char *path)
{
  struct _IO_FILE *stream;
  stream=fopen(path, "r");
  if(!(stream == ((struct _IO_FILE *)NULL)))
  {
    _Bool ret;
    ret=miredo_conf_read_FILE(conf, stream);
    fclose(stream);
    return ret;
  }

  char *return_value_dgettext_1;
  return_value_dgettext_1=dgettext("miredo", "Error opening configuration file %s: %s");
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  char *return_value_strerror_3;
  return_value_strerror_3=strerror(*return_value___errno_location_2);
  LogError(conf, return_value_dgettext_1, path, return_value_strerror_3);
  return (_Bool)0;
}

// miredo_conf_set
// file conf.c line 157
static _Bool miredo_conf_set(struct miredo_conf *conf, const char *name, const char *value, unsigned int line)
{
  struct setting *parm;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct setting) /*32ul*/ );
  parm = (struct setting *)return_value_malloc_1;
  if(!(parm == ((struct setting *)NULL)))
  {
    parm->name=strdup(name);
    if(!(parm->name == ((char *)NULL)))
    {
      parm->value=strdup(value);
      if(!(parm->value == ((char *)NULL)))
      {
        parm->line = line;
        parm->next = (struct setting *)(void *)0;
        if(conf->head == ((struct setting *)NULL))
          conf->head = parm;

        else
          conf->tail->next = parm;
        conf->tail = parm;
        return (_Bool)1;
      }

      free((void *)parm->name);
    }

    free((void *)parm);
  }

  char *return_value_dgettext_2;
  return_value_dgettext_2=dgettext("miredo", "Error (%s): %s");
  signed int *return_value___errno_location_3;
  return_value___errno_location_3=__errno_location();
  char *return_value_strerror_4;
  return_value_strerror_4=strerror(*return_value___errno_location_3);
  LogError(conf, return_value_dgettext_2, (const void *)"strdup", return_value_strerror_4);
  return (_Bool)0;
}

// miredo_main
// file miredo.h line 41
signed int miredo_main(signed int argc, char **argv)
{
  const char *username = (const char *)(void *)0;
  const char *conffile = (const char *)(void *)0;
  const char *servername = (const char *)(void *)0;
  const char *pidfile = (const char *)(void *)0;
  const char *chrootdir = (const char *)(void *)0;
  /* tag-#anon#lST[lBF{U32}_U32_'foreground'||BF{U7}_U7_'_bit_field_pad0'||U24'_pad0'|] */
struct anonymous_10
{
  // foreground
  unsigned int foreground : 1;
};

/* */
  ;
  struct anonymous_10 flags;
  init_locale();
  memset((void *)&flags, 0, sizeof(struct anonymous_10) /*4ul*/ );
  signed int c;
  signed int return_value_error_dup_1;
  signed int return_value_usage_2;
  signed int return_value_error_dup_3;
  signed int return_value_error_dup_4;
  signed int return_value_error_dup_5;
  signed int return_value_miredo_version_6;
  signed int return_value_quick_usage_7;
  do
  {
    static struct option opts[11l] = { { .name="conf", .has_arg=1, .flag=(signed int *)(void *)0, .val=99 },
    { .name="config", .has_arg=1, .flag=(signed int *)(void *)0, .val=99 },
    { .name="foreground", .has_arg=0, .flag=(signed int *)(void *)0, .val=102 },
    { .name="help", .has_arg=0, .flag=(signed int *)(void *)0, .val=104 },
    { .name="pidfile", .has_arg=1, .flag=(signed int *)(void *)0, .val=112 },
    { .name="chroot", .has_arg=1, .flag=(signed int *)(void *)0, .val=116 },
    { .name="chrootdir", .has_arg=1, .flag=(signed int *)(void *)0, .val=116 },
    { .name="user", .has_arg=1, .flag=(signed int *)(void *)0, .val=117 },
    { .name="username", .has_arg=1, .flag=(signed int *)(void *)0, .val=117 },
    { .name="version", .has_arg=0, .flag=(signed int *)(void *)0, .val=86 },
    { .name=(const char *)(void *)0, .has_arg=0, .flag=(signed int *)(void *)0,
    .val=0 } };
    c=getopt_long(argc, argv, "c:fhp:t:u:V", opts, (signed int *)(void *)0);
    if(c == -1)
      break;

    switch(c)
    {
      case 99:
      {
        if(!(conffile == ((const char *)NULL)))
        {
          return_value_error_dup_1=error_dup(c, optarg, conffile);
          return return_value_error_dup_1;
        }

        else
          conffile = optarg;
        break;
      }
      case 102:
      {
        flags.foreground = (unsigned int)1;
        break;
      }
      case 104:
      {
        return_value_usage_2=usage(argv[(signed long int)0]);
        return return_value_usage_2;
      }
      case 112:
      {
        if(!(pidfile == ((const char *)NULL)))
        {
          return_value_error_dup_3=error_dup(c, optarg, pidfile);
          return return_value_error_dup_3;
        }

        else
          pidfile = optarg;
        break;
      }
      case 117:
      {
        if(!(username == ((const char *)NULL)))
        {
          return_value_error_dup_4=error_dup(c, optarg, username);
          return return_value_error_dup_4;
        }

        else
          username = optarg;
        break;
      }
      case 116:
      {
        if(!(chrootdir == ((const char *)NULL)))
        {
          return_value_error_dup_5=error_dup(c, optarg, chrootdir);
          return return_value_error_dup_5;
        }

        else
          chrootdir = optarg;
        break;
      }
      case 86:
      {
        return_value_miredo_version_6=miredo_version();
        return return_value_miredo_version_6;
      }
      case 63:

      default:
      {
        return_value_quick_usage_7=quick_usage(argv[(signed long int)0]);
        return return_value_quick_usage_7;
      }
    }
  }
  while((_Bool)1);
  signed int tmp_post_8;
  if(!(optind >= argc))
  {
    tmp_post_8 = optind;
    optind = optind + 1;
    servername = argv[(signed long int)tmp_post_8];
  }

  signed int return_value_error_extra_9;
  signed int return_value_access_15;
  _Bool tmp_if_expr_21;
  signed int return_value_access_20;
  signed int *return_value___errno_location_17;
  unsigned long int return_value_strlen_22;
  char *return_value_dgettext_25;
  signed int *return_value___errno_location_26;
  char *return_value_strerror_27;
  _Bool tmp_if_expr_35;
  signed int *return_value___errno_location_34;
  char *return_value_dgettext_32;
  _Bool tmp_if_expr_38;
  struct _IO_FILE *return_value_freopen_37;
  _Bool tmp_if_expr_40;
  struct _IO_FILE *return_value_freopen_39;
  _Bool tmp_if_expr_42;
  signed long int return_value_write_41;
  if(!(optind >= argc))
  {
    return_value_error_extra_9=error_extra(argv[(signed long int)optind]);
    return return_value_error_extra_9;
  }

  else
  {
    if(username == ((const char *)NULL))
      username = "miredo";

    unsigned long int str_len = (unsigned long int)0;
    char *path = (char *)(void *)0;
    if(conffile == ((const char *)NULL))
    {
      path=Pryt4897810065911_br_find_etc_dir("/etc");
      unsigned long int return_value_strlen_10;
      return_value_strlen_10=strlen(path);
      unsigned long int return_value_strlen_11;
      return_value_strlen_11=strlen(miredo_name);
      str_len = return_value_strlen_10 + return_value_strlen_11 + sizeof(char [14l]) /*14ul*/ ;
    }

    const signed long int path_array_size0 = (signed long int)str_len;
    char conffile_buf[path_array_size0];
    if(conffile == ((const char *)NULL))
    {
      snprintf(conffile_buf, str_len, "%s/miredo/%s.conf", path, miredo_name);
      free((void *)path);
      conffile = conffile_buf;
    }

    if(servername == ((const char *)NULL))
    {
      return_value_access_15=access(conffile, 4);
      if(!(return_value_access_15 == 0))
      {
        char *return_value_dgettext_12;
        return_value_dgettext_12=dgettext("miredo", "Reading configuration from %s: %s\n");
        signed int *return_value___errno_location_13;
        return_value___errno_location_13=__errno_location();
        char *return_value_strerror_14;
        return_value_strerror_14=strerror(*return_value___errno_location_13);
        fprintf(stderr, return_value_dgettext_12, conffile, return_value_strerror_14);
        return 1;
      }

    }

    if(!(chrootdir == ((const char *)NULL)))
    {
      struct stat s;
      signed int *return_value___errno_location_16;
      return_value___errno_location_16=__errno_location();
      *return_value___errno_location_16 = 0;
      signed int return_value_stat_19;
      return_value_stat_19=stat(chrootdir, &s);
      if(!((61440u & s.st_mode) == 16384u) || !(return_value_stat_19 == 0))
        tmp_if_expr_21 = (_Bool)1;

      else
      {
        return_value_access_20=access(chrootdir, 1);
        tmp_if_expr_21 = return_value_access_20 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_21)
      {
        signed int *return_value___errno_location_18;
        return_value___errno_location_18=__errno_location();
        if(*return_value___errno_location_18 == 0)
        {
          return_value___errno_location_17=__errno_location();
          *return_value___errno_location_17 = 20;
        }

        error_errno(chrootdir);
        return 1;
      }

    }

    miredo_chrootdir = chrootdir;
    if(pidfile == ((const char *)NULL))
    {
      return_value_strlen_22=strlen(miredo_name);
      str_len = sizeof(char [14l]) /*14ul*/  + return_value_strlen_22;
    }

    else
      str_len = (unsigned long int)0;
    const signed long int s_array_size0 = (signed long int)str_len;
    char pidfile_buf[s_array_size0];
    if(pidfile == ((const char *)NULL))
    {
      snprintf(pidfile_buf, str_len, "/var/run/%s.pid", miredo_name);
      pidfile = pidfile_buf;
    }

    signed int return_value_init_security_23;
    return_value_init_security_23=init_security(username);
    if(!(return_value_init_security_23 == 0))
      return 1;

    else
    {
      signed int return_value;
      return_value=miredo_diagnose();
      if(!(return_value == 0))
        return 1;

      else
      {
        signed int pipes[2l];
        signed int return_value_pipe_24;
        return_value_pipe_24=pipe(pipes);
        if(!(return_value_pipe_24 == 0))
        {
          pipes[(signed long int)1] = -1;
          pipes[(signed long int)0] = pipes[(signed long int)1];
        }

        if(flags.foreground == 0u)
        {
          signed int pid;
          pid=fork();
          if(pid == -1)
          {
            return_value_dgettext_25=dgettext("miredo", "Error (%s): %s\n");
            return_value___errno_location_26=__errno_location();
            return_value_strerror_27=strerror(*return_value___errno_location_26);
            fprintf(stderr, return_value_dgettext_25, (const void *)"fork", return_value_strerror_27);
            return 1;
          }

          close(pipes[(signed long int)1]);
          signed long int return_value_read_28;
          return_value_read_28=read(pipes[(signed long int)0], (void *)&c, sizeof(signed int) /*4ul*/ );
          if(!((unsigned long int)return_value_read_28 == sizeof(signed int) /*4ul*/ ))
            c = 1;

          close(pipes[(signed long int)0]);
          return c;
        }

        close(pipes[(signed long int)0]);
        signed int fd;
        fd=create_pidfile(pidfile);
        if(fd == -1)
        {
          char *return_value_dgettext_29;
          return_value_dgettext_29=dgettext("miredo", "Cannot create PID file %s:\n %s\n");
          signed int *return_value___errno_location_30;
          return_value___errno_location_30=__errno_location();
          char *return_value_strerror_31;
          return_value_strerror_31=strerror(*return_value___errno_location_30);
          fprintf(stderr, return_value_dgettext_29, pidfile, return_value_strerror_31);
          signed int *return_value___errno_location_33;
          return_value___errno_location_33=__errno_location();
          if(*return_value___errno_location_33 == 11)
            tmp_if_expr_35 = (_Bool)1;

          else
          {
            return_value___errno_location_34=__errno_location();
            tmp_if_expr_35 = *return_value___errno_location_34 == 13 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_35)
          {
            return_value_dgettext_32=dgettext("miredo", "Please make sure another instance of the program is not already running.");
            fprintf(stderr, "%s\n", return_value_dgettext_32);
          }

          exit(1);
        }

        if(flags.foreground == 0u)
        {
          c = 0;
          setsid();
          struct _IO_FILE *return_value_freopen_36;
          return_value_freopen_36=freopen("/dev/null", "r", stdin);
          if(return_value_freopen_36 == ((struct _IO_FILE *)NULL))
            tmp_if_expr_38 = (_Bool)1;

          else
          {
            return_value_freopen_37=freopen("/dev/null", "w", stdout);
            tmp_if_expr_38 = return_value_freopen_37 == (struct _IO_FILE *)(void *)0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_38)
            tmp_if_expr_40 = (_Bool)1;

          else
          {
            return_value_freopen_39=freopen("/dev/null", "w", stderr);
            tmp_if_expr_40 = return_value_freopen_39 == (struct _IO_FILE *)(void *)0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_40)
            tmp_if_expr_42 = (_Bool)1;

          else
          {
            return_value_write_41=write(pipes[(signed long int)1], (const void *)&c, sizeof(signed int) /*4ul*/ );
            tmp_if_expr_42 = return_value_write_41 <= (signed long int)0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_42)
            exit(1);

        }

        close(pipes[(signed long int)1]);
        c=miredo(conffile, servername, fd);
        unlink(pidfile);
        close(fd);
        exit(c != 0 ? 1 : 0);
      }
    }
  }
}

// miredo_version
// file main.c line 90
signed int miredo_version(void)
{
  const char *UNKNOWN = "N/A";
  char *return_value_dgettext_1;
  return_value_dgettext_1=dgettext("miredo", "Miredo: Teredo IPv6 tunneling software %s (%s)\n built %s on %s (%s)\n");
  printf(return_value_dgettext_1, (const void *)"1.2.6", UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN);
  char *return_value_dgettext_2;
  return_value_dgettext_2=dgettext("miredo", "Configured with: %s\n");
  printf(return_value_dgettext_2, (const void *)"./configure  '--build=x86_64-linux-gnu' '--prefix=/usr' '--includedir=_{prefix}/include' '--mandir=_{prefix}/share/man' '--infodir=_{prefix}/share/info' '--sysconfdir=/etc' '--localstatedir=/var' '--disable-silent-rules' '--libdir=_{prefix}/lib/x86_64-linux-gnu' '--libexecdir=_{prefix}/lib/x86_64-linux-gnu' '--disable-maintainer-mode' '--disable-dependency-tracking' '--enable-static' '--disable-shared' '--disable-binreloc' '--enable-miredo-user' '--disable-sample-conf' '--with-Judy' '--disable-assert' 'build_alias=x86_64-linux-gnu' 'CFLAGS=-g -O0 -fstack-protector-strong -Wformat -Werror=format-security' 'LDFLAGS=-Wl,-z,relro' 'CPPFLAGS=-Wdate-time'");
  char *return_value_dgettext_3;
  return_value_dgettext_3=dgettext("miredo", "Written by Remi Denis-Courmont.\n");
  puts(return_value_dgettext_3);
  char *return_value_dgettext_4;
  return_value_dgettext_4=dgettext("miredo", "Copyright (C) 2004-%u Remi Denis-Courmont\nThis is free software; see the source for copying conditions.\nThere is NO warranty; not even for MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.\n");
  printf(return_value_dgettext_4, 2006);
  return 0;
}

// quick_usage
// file main.c line 64
static signed int quick_usage(const char *path)
{
  char *return_value_dgettext_1;
  return_value_dgettext_1=dgettext("miredo", "Try \"%s -h | more\" for more information.\n");
  fprintf(stderr, return_value_dgettext_1, path);
  return 2;
}

// server_diagnose
// file serverd.c line 55
static signed int server_diagnose(void)
{
  char buf[1024l];
  signed int check;
  check=teredo_server_check(buf, sizeof(char [1024l]) /*1024ul*/ );
  if(!(check == 0))
  {
    buf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
    fprintf(stderr, "%s\n", (const void *)buf);
  }

  return check;
}

// server_run
// file serverd.c line 69
static signed int server_run(struct miredo_conf *conf, const char *server_name)
{
  struct teredo_server *server;
  union teredo_addr prefix;
  unsigned int server_ip = (unsigned int)0x00000000;
  unsigned int server_ip2 = (unsigned int)0x00000000;
  unsigned short int mtu = (unsigned short int)1280;
  memset((void *)&prefix, 0, sizeof(union teredo_addr) /*16ul*/ );
  prefix.teredo.prefix=htonl((unsigned int)0x20010000);
  _Bool tmp_if_expr_6;
  _Bool return_value_miredo_conf_parse_IPv4_5;
  if(!(server_name == ((const char *)NULL)))
  {
    signed int check;
    check=GetIPv4ByName(server_name, &server_ip);
    if(!(check == 0))
    {
      char *return_value_dgettext_1;
      return_value_dgettext_1=dgettext("miredo", "Invalid server hostname \"%s\": %s");
      const char *return_value_gai_strerror_2;
      return_value_gai_strerror_2=gai_strerror(check);
      syslog(1, return_value_dgettext_1, server_name, return_value_gai_strerror_2);
      return -2;
    }

  }

  else
  {
    _Bool return_value_miredo_conf_parse_IPv4_4;
    return_value_miredo_conf_parse_IPv4_4=miredo_conf_parse_IPv4(conf, "ServerBindAddress", &server_ip);
    if(return_value_miredo_conf_parse_IPv4_4 == (_Bool)0)
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_miredo_conf_parse_IPv4_5=miredo_conf_parse_IPv4(conf, "ServerBindAddress2", &server_ip2);
      tmp_if_expr_6 = !(return_value_miredo_conf_parse_IPv4_5 != (_Bool)0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
    {
      char *return_value_dgettext_3;
      return_value_dgettext_3=dgettext("miredo", "Fatal configuration error");
      syslog(1, return_value_dgettext_3);
      return -2;
    }

  }
  if(server_ip == 0u)
  {
    char *return_value_dgettext_7;
    return_value_dgettext_7=dgettext("miredo", "Server address not specified");
    syslog(1, return_value_dgettext_7);
    char *return_value_dgettext_8;
    return_value_dgettext_8=dgettext("miredo", "Fatal configuration error");
    syslog(1, return_value_dgettext_8);
    return -2;
  }

  unsigned int return_value_ntohl_9;
  if(server_ip2 == 0u)
  {
    return_value_ntohl_9=ntohl(server_ip);
    server_ip2=htonl(return_value_ntohl_9 + (unsigned int)1);
  }

  _Bool return_value_miredo_conf_parse_teredo_prefix_11;
  return_value_miredo_conf_parse_teredo_prefix_11=miredo_conf_parse_teredo_prefix(conf, "Prefix", &prefix.teredo.prefix);
  _Bool tmp_if_expr_13;
  _Bool return_value_miredo_conf_get_int16_12;
  if(return_value_miredo_conf_parse_teredo_prefix_11 == (_Bool)0)
    tmp_if_expr_13 = (_Bool)1;

  else
  {
    return_value_miredo_conf_get_int16_12=miredo_conf_get_int16(conf, "InterfaceMTU", &mtu, (unsigned int *)(void *)0);
    tmp_if_expr_13 = !(return_value_miredo_conf_get_int16_12 != (_Bool)0) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_13)
  {
    char *return_value_dgettext_10;
    return_value_dgettext_10=dgettext("miredo", "Fatal configuration error");
    syslog(1, return_value_dgettext_10);
    return -2;
  }

  miredo_conf_clear(conf, 5);
  server=teredo_server_create(server_ip, server_ip2);
  signed int return_value_drop_privileges_14;
  return_value_drop_privileges_14=drop_privileges();
  signed int return_value_teredo_server_set_MTU_17;
  signed int return_value_teredo_server_start_16;
  signed int return_value_sigwait_15;
  if(!(return_value_drop_privileges_14 == 0))
    return -1;

  else
  {
    if(!(server == ((struct teredo_server *)NULL)))
    {
      signed int return_value_teredo_server_set_prefix_18;
      return_value_teredo_server_set_prefix_18=teredo_server_set_prefix(server, prefix.teredo.prefix);
      if(return_value_teredo_server_set_prefix_18 == 0)
      {
        return_value_teredo_server_set_MTU_17=teredo_server_set_MTU(server, mtu);
        if(return_value_teredo_server_set_MTU_17 == 0)
        {
          return_value_teredo_server_start_16=teredo_server_start(server);
          if(return_value_teredo_server_start_16 == 0)
          {
            struct anonymous dummyset;
            struct anonymous set;
            signed int dummy;
            sigemptyset(&dummyset);
            pthread_sigmask(0, &dummyset, &set);
            do
            {
              return_value_sigwait_15=sigwait(&set, &dummy);
              if(return_value_sigwait_15 == 0)
                break;

            }
            while((_Bool)1);
            teredo_server_stop(server);
            teredo_server_destroy(server);
            return 0;
          }

        }

      }

      teredo_server_destroy(server);
    }

    char *return_value_dgettext_19;
    return_value_dgettext_19=dgettext("miredo", "Teredo server fatal error");
    syslog(1, return_value_dgettext_19);
    char *return_value_dgettext_20;
    return_value_dgettext_20=dgettext("miredo", "Make sure another instance of the program is not already running.");
    syslog(5, return_value_dgettext_20);
    return -1;
  }
}

// setuid_notice
// file main.c line 193
static void setuid_notice(void)
{
  char *return_value_dgettext_1;
  return_value_dgettext_1=dgettext("miredo", "That is usually an indication that you are trying to start\nthe program as an user with insufficient system privileges.\nThis program should normally be started by root.\n");
  fputs(return_value_dgettext_1, stderr);
}

// strlcpy
// file strlcpy.c line 27
unsigned long int strlcpy(char *tgt, const char *src, unsigned long int bufsize)
{
  unsigned long int length = (unsigned long int)1;
  _Bool tmp_if_expr_1;
  char *tmp_post_2;
  const char *tmp_post_3;
  do
  {
    if(!(length >= bufsize))
      tmp_if_expr_1 = *src != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    tmp_post_2 = tgt;
    tgt = tgt + 1l;
    tmp_post_3 = src;
    src = src + 1l;
    *tmp_post_2 = *tmp_post_3;
    length = length + 1ul;
  }
  while((_Bool)1);
  if(!(bufsize == 0ul))
    *tgt = (char)0;

  const char *tmp_post_4;
  do
  {
    tmp_post_4 = src;
    src = src + 1l;
    if(*tmp_post_4 == 0)
      break;

    length = length + 1ul;
  }
  while((_Bool)1);
  return length - (unsigned long int)1;
}

// teredo_cksum
// file teredo-udp.h line 152
unsigned short int teredo_cksum(const void *src, const void *dst, unsigned char protocol, struct iovec *data, unsigned long int n)
{
  const signed long int teredo_cksum_array_size0 = (signed long int)((unsigned long int)3 + n);
  struct iovec iov[teredo_cksum_array_size0];
  unsigned long int plen = (unsigned long int)0;
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= n); i = i + 1ul)
  {
    iov[(signed long int)((unsigned long int)3 + i)].iov_base = (data + (signed long int)i)->iov_base;
    iov[(signed long int)((unsigned long int)3 + i)].iov_len = (data + (signed long int)i)->iov_len;
    plen = plen + iov[(signed long int)((unsigned long int)3 + i)].iov_len;
  }
  unsigned int pseudo[4l];
  unsigned int return_value_htonl_1;
  return_value_htonl_1=htonl((unsigned int)plen);
  unsigned int return_value_htonl_2;
  return_value_htonl_2=htonl((unsigned int)protocol);
  pseudo[0] = return_value_htonl_1;
  pseudo[1] = return_value_htonl_2;
  pseudo[2] = 0u;
  pseudo[3] = 0u;
  iov[(signed long int)0].iov_base = (void *)src;
  iov[(signed long int)0].iov_len = (unsigned long int)16;
  iov[(signed long int)1].iov_base = (void *)dst;
  iov[(signed long int)1].iov_len = (unsigned long int)16;
  iov[(signed long int)2].iov_base = (void *)pseudo;
  iov[(signed long int)2].iov_len = (unsigned long int)8;
  unsigned short int return_value_in_cksum_3;
  return_value_in_cksum_3=in_cksum(iov, (unsigned long int)3 + n);
  return return_value_in_cksum_3;
}

// teredo_close
// file teredo-udp.h line 163
void teredo_close(signed int fd)
{
  close(fd);
}

// teredo_forward_udp
// file server.c line 166
static _Bool teredo_forward_udp(signed int fd, struct teredo_packet *packet, _Bool insert_orig)
{
  struct teredo_orig_ind orig;
  struct iovec iov[2l];
  unsigned int dest_ipv4 = (&((union teredo_addr *)&packet->ip6->ip6_dst)->teredo)->client_ip ^ 0xffffffff;
  unsigned short int dest_port = (unsigned short int)((signed int)(&((union teredo_addr *)&packet->ip6->ip6_dst)->teredo)->client_port ^ 0xffff);
  signed int return_value_is_ipv4_global_unicast_1;
  return_value_is_ipv4_global_unicast_1=is_ipv4_global_unicast(dest_ipv4);
  if(return_value_is_ipv4_global_unicast_1 == 0)
    return (_Bool)0;

  else
  {
    iov[(signed long int)0].iov_base = (void *)&orig;
    if(!(insert_orig == (_Bool)0))
    {
      iov[(signed long int)0].iov_len = sizeof(struct teredo_orig_ind) /*8ul*/ ;
      orig.orig_zero = (unsigned char)0;
      orig.orig_code = (unsigned char)0;
      orig.orig_port = (unsigned short int)~((signed int)packet->source_port);
      orig.orig_addr = ~packet->source_ipv4;
    }

    else
      iov[(signed long int)0].iov_len = (unsigned long int)0;
    iov[(signed long int)1].iov_base = (void *)packet->ip6;
    iov[(signed long int)1].iov_len = packet->ip6_len;
    signed int return_value_teredo_sendv_2;
    return_value_teredo_sendv_2=teredo_sendv(fd, iov, (unsigned long int)2, dest_ipv4, dest_port);
    return return_value_teredo_sendv_2 > 0;
  }
}

// teredo_process_packet
// file server.c line 292
static signed int teredo_process_packet(const struct teredo_server *s, _Bool sec)
{
  struct teredo_packet packet;
  signed int tmp_if_expr_1;
  if(!(sec == (_Bool)0))
    tmp_if_expr_1 = s->fd_secondary;

  else
    tmp_if_expr_1 = s->fd_primary;
  signed int return_value_teredo_wait_recv_2;
  return_value_teredo_wait_recv_2=teredo_wait_recv(tmp_if_expr_1, &packet);
  _Bool tmp_statement_expression_10;
  _Bool tmp_statement_expression_6;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_15;
  unsigned short int return_value_htons_14;
  _Bool tmp_statement_expression_17;
  _Bool tmp_if_expr_18;
  _Bool tmp_if_expr_19;
  _Bool tmp_if_expr_20;
  _Bool tmp_if_expr_25;
  _Bool tmp_statement_expression_21;
  _Bool tmp_if_expr_22;
  _Bool tmp_if_expr_23;
  _Bool tmp_if_expr_24;
  _Bool return_value_SendRA_16;
  _Bool return_value_teredo_send_ipv6_27;
  if(!(return_value_teredo_wait_recv_2 == 0))
    return -1;

  else
  {
    struct ip6_hdr *ip6 = packet.ip6;
    if(!(packet.ip6_len >= sizeof(struct ip6_hdr) /*40ul*/ ))
      return -2;

    else
    {
      unsigned long int plen;
      unsigned short int return_value_ntohs_3;
      return_value_ntohs_3=ntohs(ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);
      plen = (unsigned long int)return_value_ntohs_3;
      if(!((signed int)ip6->ip6_ctlun.ip6_un2_vfc >> 4 == 6) || !(packet.ip6_len >= sizeof(struct ip6_hdr) /*40ul*/  + plen))
        return -2;

      else
      {
        _Bool return_value_IsBubble_4;
        return_value_IsBubble_4=IsBubble(ip6);
        if(return_value_IsBubble_4 == (_Bool)0)
        {
          if((signed int)ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt == 58)
            goto __CPROVER_DUMP_L6;

          return -2;
        }

        else
        {

        __CPROVER_DUMP_L6:
          ;
          signed int return_value_is_ipv4_global_unicast_5;
          return_value_is_ipv4_global_unicast_5=is_ipv4_global_unicast(packet.source_ipv4);
          if(return_value_is_ipv4_global_unicast_5 == 0)
            return -2;

          else
          {
            const unsigned int myprefix = s->prefix;
            struct in6_addr *__a = (struct in6_addr *)&ip6->ip6_src;
            unsigned int return_value_htonl_11;
            return_value_htonl_11=htonl(0xffc00000);
            unsigned int return_value_htonl_12;
            return_value_htonl_12=htonl(0xfe800000);
            tmp_statement_expression_10 = (__a->__in6_u.__u6_addr32[(signed long int)0] & return_value_htonl_11) == return_value_htonl_12;
            if(tmp_statement_expression_10)
            {
              struct in6_addr *teredo_process_packet__1__6____a = (struct in6_addr *)&in6addr_allrouters;
              struct in6_addr *__b = (struct in6_addr *)&ip6->ip6_dst;
              if(teredo_process_packet__1__6____a->__in6_u.__u6_addr32[0l] == __b->__in6_u.__u6_addr32[0l])
                tmp_if_expr_7 = teredo_process_packet__1__6____a->__in6_u.__u6_addr32[(signed long int)1] == __b->__in6_u.__u6_addr32[(signed long int)1] ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_7 = (_Bool)0;
              if(tmp_if_expr_7)
                tmp_if_expr_8 = teredo_process_packet__1__6____a->__in6_u.__u6_addr32[(signed long int)2] == __b->__in6_u.__u6_addr32[(signed long int)2] ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_8 = (_Bool)0;
              if(tmp_if_expr_8)
                tmp_if_expr_9 = teredo_process_packet__1__6____a->__in6_u.__u6_addr32[(signed long int)3] == __b->__in6_u.__u6_addr32[(signed long int)3] ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_9 = (_Bool)0;
              tmp_statement_expression_6 = tmp_if_expr_9;
              if(tmp_statement_expression_6)
              {
                if((signed int)ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt == 58)
                {
                  if(plen >= sizeof(struct nd_router_solicit) /*8ul*/ )
                  {
                    if((signed int)((struct icmp6_hdr *)(ip6 + 1l))->icmp6_type == 133)
                      goto accept;

                  }

                }

              }

            }

            if(((union teredo_addr *)&ip6->ip6_src)->teredo.prefix == myprefix)
            {
              signed int return_value_in6_matches_teredo_client_13;
              return_value_in6_matches_teredo_client_13=in6_matches_teredo_client(&ip6->ip6_src, packet.source_ipv4, packet.source_port);
              if(!(return_value_in6_matches_teredo_client_13 == 0))
                goto accept;

            }

            else
              if(((union teredo_addr *)&ip6->ip6_dst)->teredo.prefix == myprefix)
              {
                if(((union teredo_addr *)&ip6->ip6_dst)->teredo.server_ip == s->server_ip)
                  goto accept;

              }

            return -2;

          accept:
            ;
            if(packet.source_ipv4 == s->server_ip)
              tmp_if_expr_15 = (_Bool)1;

            else
              tmp_if_expr_15 = packet.source_ipv4 == s->server_ip2 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_15)
            {
              return_value_htons_14=htons((unsigned short int)3544);
              if(!(packet.source_port == return_value_htons_14))
                goto __CPROVER_DUMP_L20;

              return -2;
            }

            else
            {

            __CPROVER_DUMP_L20:
              ;
              struct in6_addr *teredo_process_packet__1__10____a = (struct in6_addr *)&in6addr_allrouters;
              struct in6_addr *teredo_process_packet__1__10____b = (struct in6_addr *)&ip6->ip6_dst;
              if(teredo_process_packet__1__10____a->__in6_u.__u6_addr32[0l] == teredo_process_packet__1__10____b->__in6_u.__u6_addr32[0l])
                tmp_if_expr_18 = teredo_process_packet__1__10____a->__in6_u.__u6_addr32[(signed long int)1] == teredo_process_packet__1__10____b->__in6_u.__u6_addr32[(signed long int)1] ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_18 = (_Bool)0;
              if(tmp_if_expr_18)
                tmp_if_expr_19 = teredo_process_packet__1__10____a->__in6_u.__u6_addr32[(signed long int)2] == teredo_process_packet__1__10____b->__in6_u.__u6_addr32[(signed long int)2] ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_19 = (_Bool)0;
              if(tmp_if_expr_19)
                tmp_if_expr_20 = teredo_process_packet__1__10____a->__in6_u.__u6_addr32[(signed long int)3] == teredo_process_packet__1__10____b->__in6_u.__u6_addr32[(signed long int)3] ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_20 = (_Bool)0;
              tmp_statement_expression_17 = tmp_if_expr_20;
              if(tmp_statement_expression_17)
                tmp_if_expr_25 = (_Bool)1;

              else
              {
                struct in6_addr *teredo_process_packet__1__11____a = (struct in6_addr *)&s->lladdr.ip6;
                struct in6_addr *teredo_process_packet__1__11____b = (struct in6_addr *)&ip6->ip6_dst;
                if(teredo_process_packet__1__11____a->__in6_u.__u6_addr32[0l] == teredo_process_packet__1__11____b->__in6_u.__u6_addr32[0l])
                  tmp_if_expr_22 = teredo_process_packet__1__11____a->__in6_u.__u6_addr32[(signed long int)1] == teredo_process_packet__1__11____b->__in6_u.__u6_addr32[(signed long int)1] ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_22 = (_Bool)0;
                if(tmp_if_expr_22)
                  tmp_if_expr_23 = teredo_process_packet__1__11____a->__in6_u.__u6_addr32[(signed long int)2] == teredo_process_packet__1__11____b->__in6_u.__u6_addr32[(signed long int)2] ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_23 = (_Bool)0;
                if(tmp_if_expr_23)
                  tmp_if_expr_24 = teredo_process_packet__1__11____a->__in6_u.__u6_addr32[(signed long int)3] == teredo_process_packet__1__11____b->__in6_u.__u6_addr32[(signed long int)3] ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr_24 = (_Bool)0;
                tmp_statement_expression_21 = tmp_if_expr_24;
                tmp_if_expr_25 = tmp_statement_expression_21 ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_25)
              {
                struct icmp6_hdr *icmp = (struct icmp6_hdr *)(ip6 + (signed long int)1);
                if((signed int)ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt == 58)
                {
                  if(plen >= sizeof(struct nd_router_solicit) /*8ul*/ )
                  {
                    if((signed int)icmp->icmp6_type == 133)
                    {
                      return_value_SendRA_16=SendRA(s, &packet, &ip6->ip6_src, sec);
                      return return_value_SendRA_16 != (_Bool)0 ? 1 : -1;
                    }

                  }

                }

                return -2;
              }

              _Bool return_value_IN6_IS_ADDR_GLOBAL_26;
              return_value_IN6_IS_ADDR_GLOBAL_26=IN6_IS_ADDR_GLOBAL(&ip6->ip6_dst);
              if(return_value_IN6_IS_ADDR_GLOBAL_26 == (_Bool)0)
                return -2;

              else
                if(!((signed int)ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt == 59))
                {
                  if(!(plen >= 89ul))
                    goto __CPROVER_DUMP_L38;

                  return -2;
                }

                else
                {

                __CPROVER_DUMP_L38:
                  ;
                  if(!(((union teredo_addr *)&ip6->ip6_dst)->teredo.prefix == myprefix))
                  {
                    return_value_teredo_send_ipv6_27=teredo_send_ipv6(packet.ip6, sizeof(struct ip6_hdr) /*40ul*/  + plen);
                    return return_value_teredo_send_ipv6_27 != (_Bool)0 ? 2 : -1;
                  }

                  else
                  {
                    _Bool return_value_teredo_forward_udp_28;
                    return_value_teredo_forward_udp_28=teredo_forward_udp(s->fd_primary, &packet, (&((union teredo_addr *)&ip6->ip6_dst)->teredo)->server_ip == s->server_ip);
                    return return_value_teredo_forward_udp_28 != (_Bool)0 ? 3 : -1;
                  }
                }
            }
          }
        }
      }
    }
  }
}

// teredo_recv
// file teredo.c line 306
signed int teredo_recv(signed int fd, struct teredo_packet *p)
{
  signed int return_value_teredo_recv_inner_1;
  return_value_teredo_recv_inner_1=teredo_recv_inner(fd, p, 64);
  return return_value_teredo_recv_inner_1;
}

// teredo_recv_inner
// file teredo.c line 173
static signed int teredo_recv_inner(signed int fd, struct teredo_packet *p, signed int flags)
{
  struct sockaddr_in ad;
  char cbuf[32l];
  struct iovec iov = { .iov_base=(void *)p->buf.fill, .iov_len=(unsigned long int)65507 };
  struct msghdr msg = { .msg_name=(void *)&ad, .msg_namelen=(unsigned int)sizeof(struct sockaddr_in) /*16ul*/ , .msg_iov=&iov,
    .msg_iovlen=(unsigned long int)1, .msg_control=(void *)cbuf,
    .msg_controllen=sizeof(char [32l]) /*32ul*/ , .msg_flags=0 };
  signed long int length;
  length=recvmsg(fd, &msg, flags);
  if(length == -1l)
    teredo_recverr(fd);

  struct cmsghdr *tmp_if_expr_1;
  unsigned char *tmp_post_2;
  unsigned char *tmp_post_3;
  if(!(length >= 2l))
    return -1;

  else
  {
    p->source_ipv4 = ad.sin_addr.s_addr;
    p->source_port = ad.sin_port;
    p->dest_ipv4 = (unsigned int)0;
    struct cmsghdr *cmsg;
    if(msg.msg_controllen >= sizeof(struct cmsghdr) /*16ul*/ )
      tmp_if_expr_1 = (struct cmsghdr *)(&msg)->msg_control;

    else
      tmp_if_expr_1 = (struct cmsghdr *)0;
    cmsg = tmp_if_expr_1;
    while(!(cmsg == ((struct cmsghdr *)NULL)))
    {
      if(cmsg->cmsg_level == 0)
      {
        if(cmsg->cmsg_type == 8)
        {
          struct in_pktinfo *nfo = (struct in_pktinfo *)cmsg->__cmsg_data;
          p->dest_ipv4 = nfo->ipi_addr.s_addr;
        }

      }

      cmsg=__cmsg_nxthdr(&msg, cmsg);
    }
    unsigned char *ptr = p->buf.fill;
    p->auth_present = (_Bool)0;
    p->orig_ipv4 = (unsigned int)0;
    p->orig_port = (unsigned short int)0;
    if((signed int)*ptr == 0)
    {
      if((signed int)ptr[1l] == 1)
      {
        unsigned char id_len;
        unsigned char au_len;
        p->auth_present = (_Bool)1;
        length = length - (signed long int)13;
        if(!(length >= 0l))
          return -1;

        ptr = ptr + (signed long int)2;
        tmp_post_2 = ptr;
        ptr = ptr + 1l;
        id_len = *tmp_post_2;
        tmp_post_3 = ptr;
        ptr = ptr + 1l;
        au_len = *tmp_post_3;
        length = length - (signed long int)((signed int)id_len + (signed int)au_len);
        if(!(length >= 0l))
          return -1;

        ptr = ptr + (signed long int)((signed int)id_len + (signed int)au_len);
        memcpy((void *)p->auth_nonce, (const void *)ptr, (unsigned long int)8);
        ptr = ptr + (signed long int)8;
        p->auth_fail = !(!(*ptr != 0));
        ptr = ptr + 1l;
        memmove((void *)p->buf.align, (const void *)ptr, (unsigned long int)length);
        ptr = p->buf.fill;
      }

    }

    if((signed int)*ptr == 0)
    {
      if((signed int)ptr[1l] == 0)
      {
        unsigned int addr;
        unsigned short int port;
        length = length - (signed long int)8;
        if(!(length >= 0l))
          return -1;

        ptr = ptr + (signed long int)2;
        memcpy((void *)&port, (const void *)ptr, (unsigned long int)2);
        ptr = ptr + (signed long int)2;
        p->orig_port = (unsigned short int)~((signed int)port);
        memcpy((void *)&addr, (const void *)ptr, (unsigned long int)4);
        ptr = ptr + (signed long int)4;
        p->orig_ipv4 = ~addr;
      }

    }

    p->ip6_len = (unsigned long int)length;
    p->ip6 = (struct ip6_hdr *)ptr;
    return 0;
  }
}

// teredo_recverr
// file teredo.c line 118
static signed long int teredo_recverr(signed int fd)
{
  struct msghdr msg;
  memset((void *)&msg, 0, sizeof(struct msghdr) /*56ul*/ );
  signed long int return_value_recvmsg_1;
  return_value_recvmsg_1=recvmsg(fd, &msg, 8192);
  return return_value_recvmsg_1;
}

// teredo_send
// file teredo.c line 165
signed int teredo_send(signed int fd, const void *packet, unsigned long int plen, unsigned int dest_ip, unsigned short int dest_port)
{
  struct iovec iov = { .iov_base=(void *)packet, .iov_len=plen };
  signed int return_value_teredo_sendv_1;
  return_value_teredo_sendv_1=teredo_sendv(fd, &iov, (unsigned long int)1, dest_ip, dest_port);
  return return_value_teredo_sendv_1;
}

// teredo_send_ipv6
// file server.c line 206
static _Bool teredo_send_ipv6(struct ip6_hdr *p, unsigned long int len)
{
  struct sockaddr_in6 dst;
  memset((void *)&dst, 0, sizeof(struct sockaddr_in6) /*28ul*/ );
  dst.sin6_family = (unsigned short int)10;
  dst.sin6_addr = p->ip6_dst;
  signed int tries = 0;
  for( ; !(tries >= 10); tries = tries + 1)
  {
    signed long int res;
    res=sendto(raw_fd, (const void *)p, len, 0, (struct sockaddr *)&dst, (unsigned int)sizeof(struct sockaddr_in6) /*28ul*/ );
    if(!(res == -1l))
      return res == (signed long int)len;

    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(*return_value___errno_location_1 == 13 || *return_value___errno_location_1 == 71 || *return_value___errno_location_1 == 90 || *return_value___errno_location_1 == 101 || *return_value___errno_location_1 == 111 || *return_value___errno_location_1 == 113)
      goto __CPROVER_DUMP_L5;

    return (_Bool)0;

  __CPROVER_DUMP_L5:
    ;
  }
  return (_Bool)0;
}

// teredo_sendv
// file teredo-udp.h line 113
signed int teredo_sendv(signed int fd, struct iovec *iov, unsigned long int count, unsigned int dest_ip, unsigned short int dest_port)
{
  struct sockaddr_in addr = { .sin_family=(unsigned short int)2, .sin_port=dest_port, .sin_addr={ .s_addr=dest_ip },
    .sin_zero={ 0, 0, 0, 0, 0, 0, 0, 0 } };
  struct msghdr msg = { .msg_name=(void *)&addr, .msg_namelen=(unsigned int)sizeof(struct sockaddr_in) /*16ul*/ , .msg_iov=(struct iovec *)iov,
    .msg_iovlen=count, .msg_control=NULL,
    .msg_controllen=0ul, .msg_flags=0 };
  signed long int res;
  _Bool tmp_if_expr_2;
  signed long int return_value_teredo_recverr_1;
  do
  {
    res=sendmsg(fd, &msg, 0);
    if(res == -1l)
    {
      return_value_teredo_recverr_1=teredo_recverr(fd);
      tmp_if_expr_2 = return_value_teredo_recverr_1 != (signed long int)-1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
  }
  while(tmp_if_expr_2);
  return (signed int)res;
}

// teredo_server_check
// file ../libteredo/server.h line 33
signed int teredo_server_check(char *errmsg, unsigned long int len)
{
  signed int fd;
  fd=socket(10, 3, 255);
  if(fd >= 0)
  {
    close(fd);
    return 0;
  }

  else
  {
    char *return_value_dgettext_1;
    return_value_dgettext_1=dgettext("miredo", "Raw IPv6 socket not working: %s");
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    char *return_value_strerror_3;
    return_value_strerror_3=strerror(*return_value___errno_location_2);
    snprintf(errmsg, len, return_value_dgettext_1, return_value_strerror_3);
    return -1;
  }
}

// teredo_server_create
// file ../libteredo/server.h line 46
struct teredo_server * teredo_server_create(unsigned int ip1, unsigned int ip2)
{
  bindtextdomain("miredo", "/usr/share/locale");
  pthread_mutex_lock(&raw_mutex);
  unsigned int tmp_post_1;
  _Bool tmp_if_expr_6;
  signed int return_value_is_ipv4_global_unicast_5;
  if(raw_users == 1U)
  {
    pthread_mutex_unlock(&raw_mutex);
    return (struct teredo_server *)(void *)0;
  }

  else
  {
    tmp_post_1 = raw_users;
    raw_users = raw_users + 1u;
    if(tmp_post_1 == 0u)
    {
      raw_fd=socket(10, 3, 255);
      if(!(raw_fd == -1))
      {
        signed int flags;
        flags=fcntl(raw_fd, 3, 0);
        fcntl(raw_fd, 4, 04000 | (flags != -1 ? flags : 0));
        fcntl(raw_fd, 2, 1);
      }

    }

    pthread_mutex_unlock(&raw_mutex);
    if(raw_fd == -1)
    {
      char *return_value_dgettext_2;
      return_value_dgettext_2=dgettext("miredo", "Raw IPv6 socket not working: %m");
      syslog(3, return_value_dgettext_2);
      return (struct teredo_server *)(void *)0;
    }

    signed int return_value_is_ipv4_global_unicast_4;
    return_value_is_ipv4_global_unicast_4=is_ipv4_global_unicast(ip1);
    if(return_value_is_ipv4_global_unicast_4 == 0)
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_is_ipv4_global_unicast_5=is_ipv4_global_unicast(ip2);
      tmp_if_expr_6 = !(return_value_is_ipv4_global_unicast_5 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
    {
      char *return_value_dgettext_3;
      return_value_dgettext_3=dgettext("miredo", "Teredo server UDP socket error: Server IPv4 addresses must be global unicast.");
      syslog(3, return_value_dgettext_3);
      return (struct teredo_server *)(void *)0;
    }

    struct teredo_server *s;
    void *return_value_malloc_7;
    return_value_malloc_7=malloc(sizeof(struct teredo_server) /*56ul*/ );
    s = (struct teredo_server *)return_value_malloc_7;
    if(!(s == ((struct teredo_server *)NULL)))
    {
      signed int fd;
      memset((void *)s, 0, sizeof(struct teredo_server) /*56ul*/ );
      s->server_ip = ip1;
      s->server_ip2 = ip2;
      s->prefix=htonl((unsigned int)0x20010000);
      s->advLinkMTU=htonl((unsigned int)1280);
      s->lladdr.teredo.prefix=htonl(0xfe800000);
      s->lladdr.teredo.flags=htons((unsigned short int)0x8000);
      unsigned short int return_value_htons_8;
      return_value_htons_8=htons((unsigned short int)3544);
      s->lladdr.teredo.client_port = (unsigned short int)~((signed int)return_value_htons_8);
      s->lladdr.teredo.client_ip = ~s->server_ip;
      unsigned short int return_value_htons_9;
      return_value_htons_9=htons((unsigned short int)3544);
      s->fd_primary=teredo_socket(ip1, return_value_htons_9);
      fd = s->fd_primary;
      if(!(fd == -1))
      {
        unsigned short int return_value_htons_10;
        return_value_htons_10=htons((unsigned short int)3544);
        s->fd_secondary=teredo_socket(ip2, return_value_htons_10);
        fd = s->fd_secondary;
        if(!(fd == -1))
          return s;

        else
        {
          char teredo_server_create__1__5__1__1__str[16l];
          inet_ntop(2, (const void *)&ip2, teredo_server_create__1__5__1__1__str, (unsigned int)sizeof(char [16l]) /*16ul*/ );
          char *return_value_dgettext_11;
          return_value_dgettext_11=dgettext("miredo", "Error (%s): %m");
          syslog(3, return_value_dgettext_11, (const void *)teredo_server_create__1__5__1__1__str);
        }
        teredo_close(s->fd_primary);
      }

      else
      {
        char str[16l];
        inet_ntop(2, (const void *)&ip1, str, (unsigned int)sizeof(char [16l]) /*16ul*/ );
        char *return_value_dgettext_12;
        return_value_dgettext_12=dgettext("miredo", "Error (%s): %m");
        syslog(3, return_value_dgettext_12, (const void *)str);
      }
      free((void *)s);
    }

    return (struct teredo_server *)(void *)0;
  }
}

// teredo_server_destroy
// file ../libteredo/server.h line 108
void teredo_server_destroy(struct teredo_server *s)
{
  teredo_close(s->fd_primary);
  teredo_close(s->fd_secondary);
  free((void *)s);
  pthread_mutex_lock(&raw_mutex);
  raw_users = raw_users - 1u;
  if(raw_users == 0u)
    close(raw_fd);

  pthread_mutex_unlock(&raw_mutex);
}

// teredo_server_get_MTU
// file server.c line 600
unsigned short int teredo_server_get_MTU(const struct teredo_server *s)
{
  unsigned int return_value_ntohl_1;
  return_value_ntohl_1=ntohl(s->advLinkMTU);
  return (unsigned short int)return_value_ntohl_1;
}

// teredo_server_get_prefix
// file server.c line 585
unsigned int teredo_server_get_prefix(const struct teredo_server *s)
{
  return s->prefix;
}

// teredo_server_set_MTU
// file ../libteredo/server.h line 76
signed int teredo_server_set_MTU(struct teredo_server *s, unsigned short int mtu)
{
  if(!((signed int)mtu >= 1280))
    return -1;

  else
  {
    s->advLinkMTU=htonl((unsigned int)mtu);
    return 0;
  }
}

// teredo_server_set_prefix
// file ../libteredo/server.h line 57
signed int teredo_server_set_prefix(struct teredo_server *s, unsigned int prefix)
{
  if(!((0xff000000 & prefix) == 0xff000000))
  {
    s->prefix = prefix;
    return 0;
  }

  else
    return -1;
}

// teredo_server_start
// file ../libteredo/server.h line 92
signed int teredo_server_start(struct teredo_server *s)
{
  signed int return_value_pthread_create_2;
  return_value_pthread_create_2=pthread_create(&s->t1, (const union pthread_attr_t *)(void *)0, thread_primary, (void *)s);
  if(return_value_pthread_create_2 == 0)
  {
    signed int return_value_pthread_create_1;
    return_value_pthread_create_1=pthread_create(&s->t2, (const union pthread_attr_t *)(void *)0, thread_secondary, (void *)s);
    if(return_value_pthread_create_1 == 0)
      return 0;

    pthread_cancel(s->t1);
    pthread_join(s->t1, (void **)(void *)0);
  }

  return -1;
}

// teredo_server_stop
// file ../libteredo/server.h line 99
void teredo_server_stop(struct teredo_server *s)
{
  pthread_cancel(s->t1);
  pthread_cancel(s->t2);
  pthread_join(s->t1, (void **)(void *)0);
  pthread_join(s->t2, (void **)(void *)0);
}

// teredo_socket
// file teredo-udp.h line 90
signed int teredo_socket(unsigned int bind_ip, unsigned short int port)
{
  struct sockaddr_in myaddr = { .sin_family=(unsigned short int)2, .sin_port=port, .sin_addr={ .s_addr=bind_ip },
    .sin_zero={ 0, 0, 0, 0, 0, 0, 0, 0 } };
  signed int fd;
  fd=socket(2, 2, 17);
  if(fd == -1)
    return -1;

  else
  {
    fcntl(fd, 2, 1);
    signed int return_value_bind_1;
    return_value_bind_1=bind(fd, (struct sockaddr *)&myaddr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    if(!(return_value_bind_1 == 0))
    {
      close(fd);
      return -1;
    }

    else
    {
      signed int literal_2 = 0;
      setsockopt(fd, 0, 10, (const void *)&literal_2, (unsigned int)sizeof(signed int) /*4ul*/ );
      signed int literal_3 = 1;
      setsockopt(fd, 0, 11, (const void *)&literal_3, (unsigned int)sizeof(signed int) /*4ul*/ );
      signed int literal_4 = 1;
      setsockopt(fd, 0, 8, (const void *)&literal_4, (unsigned int)sizeof(signed int) /*4ul*/ );
      signed int literal_5 = 1;
      setsockopt(fd, 0, 33, (const void *)&literal_5, (unsigned int)sizeof(signed int) /*4ul*/ );
      return fd;
    }
  }
}

// teredo_wait_recv
// file teredo-udp.h line 145
signed int teredo_wait_recv(signed int fd, struct teredo_packet *p)
{
  signed int return_value_teredo_recv_inner_1;
  return_value_teredo_recv_inner_1=teredo_recv_inner(fd, p, 0);
  return return_value_teredo_recv_inner_1;
}

// thread_primary
// file server.c line 467
static void * thread_primary(void *data)
{
  do
  {
    pthread_testcancel();
    teredo_process_packet((struct teredo_server *)data, (_Bool)0);
  }
  while((_Bool)1);
}

// thread_secondary
// file server.c line 477
static void * thread_secondary(void *data)
{
  do
  {
    pthread_testcancel();
    teredo_process_packet((struct teredo_server *)data, (_Bool)1);
  }
  while((_Bool)1);
}

// usage
// file main.c line 73
static signed int usage(const char *path)
{
  char *return_value_dgettext_1;
  return_value_dgettext_1=dgettext("miredo", "Usage: %s [OPTIONS] [SERVER_NAME]\nCreates a Teredo tunneling interface for encapsulation of IPv6 over UDP.\n\n  -c, --config     specify an configuration file\n  -f, --foreground run in the foreground\n  -h, --help       display this help and exit\n  -p, --pidfile    override the location of the PID file\n  -u, --user       override the user to set UID to\n  -V, --version    display program version and exit\n");
  printf(return_value_dgettext_1, path);
  return 0;
}

