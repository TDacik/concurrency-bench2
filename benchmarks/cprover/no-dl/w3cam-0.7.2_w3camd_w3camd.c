// #anon_enum_JCS_UNKNOWN=0_JCS_GRAYSCALE=1_JCS_RGB=2_JCS_YCbCr=3_JCS_CMYK=4_JCS_YCCK=5_JCS_EXT_RGB=6_JCS_EXT_RGBX=7_JCS_EXT_BGR=8_JCS_EXT_BGRX=9_JCS_EXT_XBGR=10_JCS_EXT_XRGB=11_JCS_EXT_RGBA=12_JCS_EXT_BGRA=13_JCS_EXT_ABGR=14_JCS_EXT_ARGB=15_JCS_RGB565=16
// file /usr/include/jpeglib.h line 215
enum anonymous_6 { JCS_UNKNOWN=0, JCS_GRAYSCALE=1, JCS_RGB=2, JCS_YCbCr=3, JCS_CMYK=4, JCS_YCCK=5, JCS_EXT_RGB=6, JCS_EXT_RGBX=7, JCS_EXT_BGR=8, JCS_EXT_BGRX=9, JCS_EXT_XBGR=10, JCS_EXT_XRGB=11, JCS_EXT_RGBA=12, JCS_EXT_BGRA=13, JCS_EXT_ABGR=14, JCS_EXT_ARGB=15, JCS_RGB565=16 };

// #anon_enum_JDCT_ISLOW=0_JDCT_IFAST=1_JDCT_FLOAT=2
// file /usr/include/jpeglib.h line 244
enum anonymous_7 { JDCT_ISLOW=0, JDCT_IFAST=1, JDCT_FLOAT=2 };

// tag-#anon#ST[*{S8}_S8_'dev'||*{SYM#tag-#anon#ST[S32'childs'||U32'_pad0'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'childs_lock'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]#'childs_cond'||S32'state'||S32'width'||S32'height'||S32'input'||*{U8}_U8_'img'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'img_lock'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]#'img_cond'|]#}_SYM#tag-#anon#ST[S32'childs'||U32'_pad0'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'childs_lock'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]#'childs_cond'||S32'state'||S32'width'||S32'height'||S32'input'||*{U8}_U8_'img'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'img_lock'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]#'img_cond'|]#_'img'|]
// file w3camd.c line 80
struct anonymous_8;

// tag-#anon#ST[ARR17{U8}_U8_'bits'||ARR256{U8}_U8_'huffval'||U24'_pad0'||S32'sent_table'|]
// file /usr/include/jpeglib.h line 101
struct anonymous_2;

// tag-#anon#ST[ARR64{U16}_U16_'quantval'||S32'sent_table'|]
// file /usr/include/jpeglib.h line 84
struct anonymous_1;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_3;

// tag-#anon#ST[S32'childs'||U32'_pad0'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'childs_lock'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]#'childs_cond'||S32'state'||S32'width'||S32'height'||S32'input'||*{U8}_U8_'img'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'img_lock'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]#'img_cond'|]
// file w3camd.c line 54
struct anonymous_9;

// tag-#anon#ST[S32'component_id'||S32'component_index'||S32'h_samp_factor'||S32'v_samp_factor'||S32'quant_tbl_no'||S32'dc_tbl_no'||S32'ac_tbl_no'||U32'width_in_blocks'||U32'height_in_blocks'||S32'DCT_scaled_size'||U32'downsampled_width'||U32'downsampled_height'||S32'component_needed'||S32'MCU_width'||S32'MCU_height'||S32'MCU_blocks'||S32'MCU_sample_width'||S32'last_col_width'||S32'last_row_height'||U32'_pad0'||*{SYM#tag-#anon#ST[ARR64{U16}_U16_'quantval'||S32'sent_table'|]#}_SYM#tag-#anon#ST[ARR64{U16}_U16_'quantval'||S32'sent_table'|]#_'quant_table'||*{V}_V_'dct_table'|]
// file /usr/include/jpeglib.h line 117
struct anonymous_4;

// tag-#anon#ST[S32'comps_in_scan'||ARR4{S32}_S32_'component_index'||S32'Ss'||S32'Se'||S32'Ah'||S32'Al'|]
// file /usr/include/jpeglib.h line 190
struct anonymous_5;

// tag-#anon#ST[S32'fd'||S32'map_size'||*{S8}_S8_'mem'||S32'width'||S32'height'|]
// file w3v4l.h line 25
struct anonymous_13;

// tag-#anon#ST[S32'fd'||S32'verbose'||*{S8}_S8_'url'||*{S8}_S8_'image'||S32'image_size'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'childs'||U32'_pad0'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'childs_lock'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]#'childs_cond'||S32'state'||S32'width'||S32'height'||S32'input'||*{U8}_U8_'img'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'img_lock'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]#'img_cond'|]#}_SYM#tag-#anon#ST[S32'childs'||U32'_pad0'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'childs_lock'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]#'childs_cond'||S32'state'||S32'width'||S32'height'||S32'input'||*{U8}_U8_'img'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'img_lock'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]#'img_cond'|]#_'img'||U64'thread'||F32'refresh'||S32'quality'|]
// file w3camd.c line 67
struct anonymous_15;

// tag-#anon#ST[S32'num'||U32'_pad0'||*{S8}_S8_'str'||S32'len'||U32'_pad1'|]
// file w3http.h line 25
struct anonymous;

// tag-#anon#ST[SYM#tag-jpeg_destination_mgr#'pub'||S32'fd'||U32'_pad0'||*{U8}_U8_'buffer'|]
// file w3jpeg.c line 29
struct anonymous_14;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_11;

// tag-#anon#UN[ARR8{S32}_S32_'i'||ARR80{S8}_S8_'s'|]
// file /usr/include/jpeglib.h line 736
union anonymous_12;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_10;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_0;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-jpeg_c_coef_controller
// file /usr/include/jpeglib.h line 457
struct jpeg_c_coef_controller;

// tag-jpeg_c_main_controller
// file /usr/include/jpeglib.h line 455
struct jpeg_c_main_controller;

// tag-jpeg_c_prep_controller
// file /usr/include/jpeglib.h line 456
struct jpeg_c_prep_controller;

// tag-jpeg_color_converter
// file /usr/include/jpeglib.h line 459
struct jpeg_color_converter;

// tag-jpeg_common_struct
// file /usr/include/jpeglib.h line 280
struct jpeg_common_struct;

// tag-jpeg_comp_master
// file /usr/include/jpeglib.h line 454
struct jpeg_comp_master;

// tag-jpeg_compress_struct
// file /usr/include/jpeglib.h line 289
struct jpeg_compress_struct;

// tag-jpeg_destination_mgr
// file /usr/include/jpeglib.h line 299
struct jpeg_destination_mgr;

// tag-jpeg_downsampler
// file /usr/include/jpeglib.h line 460
struct jpeg_downsampler;

// tag-jpeg_entropy_encoder
// file /usr/include/jpeglib.h line 462
struct jpeg_entropy_encoder;

// tag-jpeg_error_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_error_mgr;

// tag-jpeg_forward_dct
// file /usr/include/jpeglib.h line 461
struct jpeg_forward_dct;

// tag-jpeg_marker_writer
// file /usr/include/jpeglib.h line 458
struct jpeg_marker_writer;

// tag-jpeg_memory_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_memory_mgr;

// tag-jpeg_progress_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_progress_mgr;

// tag-jvirt_barray_control
// file /usr/include/jpeglib.h line 828
struct jvirt_barray_control;

// tag-jvirt_sarray_control
// file /usr/include/jpeglib.h line 827
struct jvirt_sarray_control;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-video_capability
// file /usr/include/libv4l1-videodev.h line 30
struct video_capability;

// tag-video_channel
// file /usr/include/libv4l1-videodev.h line 43
struct video_channel;

// tag-video_clip
// file /usr/include/libv4l1-videodev.h line 130
struct video_clip;

// tag-video_mbuf
// file /usr/include/libv4l1-videodev.h line 167
struct video_mbuf;

// tag-video_mmap
// file /usr/include/libv4l1-videodev.h line 160
struct video_mmap;

// tag-video_window
// file /usr/include/libv4l1-videodev.h line 137
struct video_window;

#ifndef NULL
#define NULL ((void*)0)
#endif

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// accept_con
// file w3socket.h line 26
signed int accept_con(signed int sd);
// atof
// file /usr/include/x86_64-linux-gnu/bits/stdlib-float.h line 26
static inline double atof(const char *__nptr);
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// bind_port
// file w3socket.h line 25
signed int bind_port(char *host, signed int port);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// e_error
// file w3camd.c line 246
void e_error(struct anonymous_15 *cn);
// e_help
// file w3camd.c line 209
void e_help(struct anonymous_15 *cn);
// e_wrong_url
// file w3camd.c line 229
void e_wrong_url(struct anonymous_15 *cn);
// empty_output_buffer
// file w3jpeg.c line 59
static signed int empty_output_buffer(struct jpeg_compress_struct *cinfo);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// gethostbyname
// file /usr/include/netdb.h line 144
extern struct hostent * gethostbyname(const char *);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// gmtime
// file /usr/include/time.h line 239
extern struct tm * gmtime(const signed long int *);
// hex_to_asc
// file w3http.c line 102
static char * hex_to_asc(const char *str, signed int len);
// host_addr
// file w3socket.c line 40
unsigned long int host_addr(char *host);
// http_arg_val
// file w3http.h line 57
char * http_arg_val(char **args, char *key);
// http_free_args
// file w3http.h line 58
void http_free_args(char **args);
// http_header
// file w3http.h line 55
signed int http_header(signed int fd, signed int no, char *value);
// http_parse
// file w3http.h line 56
char * http_parse(char *buf, char ***args);
// http_status
// file w3http.h line 54
signed int http_status(signed int fd, signed int no);
// image_thread
// file w3camd.c line 153
void * image_thread(void *data);
// inet_addr
// file /usr/include/arpa/inet.h line 34
extern unsigned int inet_addr(const char *);
// init_destination
// file w3jpeg.c line 43
static void init_destination(struct jpeg_compress_struct *cinfo);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// jpeg_CreateCompress
// file /usr/include/jpeglib.h line 904
extern void jpeg_CreateCompress(struct jpeg_compress_struct *, signed int, unsigned long int);
// jpeg_destroy_compress
// file /usr/include/jpeglib.h line 909
extern void jpeg_destroy_compress(struct jpeg_compress_struct *);
// jpeg_finish_compress
// file /usr/include/jpeglib.h line 954
extern void jpeg_finish_compress(struct jpeg_compress_struct *);
// jpeg_io_dest
// file w3jpeg.h line 24
void jpeg_io_dest(struct jpeg_compress_struct *cinfo, signed int fd);
// jpeg_set_defaults
// file /usr/include/jpeglib.h line 926
extern void jpeg_set_defaults(struct jpeg_compress_struct *);
// jpeg_set_quality
// file /usr/include/jpeglib.h line 931
extern void jpeg_set_quality(struct jpeg_compress_struct *, signed int, signed int);
// jpeg_start_compress
// file /usr/include/jpeglib.h line 949
extern void jpeg_start_compress(struct jpeg_compress_struct *, signed int);
// jpeg_std_error
// file /usr/include/jpeglib.h line 889
extern struct jpeg_error_mgr * jpeg_std_error(struct jpeg_error_mgr *);
// jpeg_write_scanlines
// file /usr/include/jpeglib.h line 951
extern unsigned int jpeg_write_scanlines(struct jpeg_compress_struct *, unsigned char **, unsigned int);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 57
extern void * mmap(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// munmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 76
extern signed int munmap(void *, unsigned long int);
// on_sig_pipe
// file w3camd.c line 395
static void on_sig_pipe(signed int signum);
// on_signal
// file w3camd.c line 401
static void on_signal(signed int signum);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// parse_string
// file w3http.c line 138
static char ** parse_string(const char *str);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process_url
// file w3camd.c line 262
void process_url(struct anonymous_15 *cn);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous_10 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_10 *, const union anonymous_11 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_10 *, union anonymous_0 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_0 *, const union anonymous_11 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_0 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_0 *);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// server_thread
// file w3camd.c line 325
void * server_thread(void *data);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// term_destination
// file w3jpeg.c line 77
static void term_destination(struct jpeg_compress_struct *cinfo);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// usage
// file w3camd.c line 90
void usage(char *pname);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// v4l_fini
// file w3v4l.h line 33
void v4l_fini(struct anonymous_13 *vid);
// v4l_image
// file w3v4l.h line 34
signed int v4l_image(struct anonymous_13 *vid);
// v4l_init
// file w3v4l.h line 32
struct anonymous_13 * v4l_init(char *dev, signed int input, signed int width, signed int height);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_jpeg
// file w3camd.c line 101
signed int write_jpeg(struct anonymous_9 *img, signed int fd, signed int quality);

struct anonymous_8
{
  // dev
  char *dev;
  // img
  struct anonymous_9 *img;
};

struct anonymous_2
{
  // bits
  unsigned char bits[17l];
  // huffval
  unsigned char huffval[256l];
  // sent_table
  signed int sent_table;
};

struct anonymous_1
{
  // quantval
  unsigned short int quantval[64l];
  // sent_table
  signed int sent_table;
};

struct anonymous_3
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_0
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous_10
{
  // __data
  struct anonymous_3 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct anonymous_9
{
  // childs
  signed int childs;
  // childs_lock
  union anonymous_0 childs_lock;
  // childs_cond
  union anonymous_10 childs_cond;
  // state
  signed int state;
  // width
  signed int width;
  // height
  signed int height;
  // input
  signed int input;
  // img
  unsigned char *img;
  // img_lock
  union anonymous_0 img_lock;
  // img_cond
  union anonymous_10 img_cond;
};

struct anonymous_4
{
  // component_id
  signed int component_id;
  // component_index
  signed int component_index;
  // h_samp_factor
  signed int h_samp_factor;
  // v_samp_factor
  signed int v_samp_factor;
  // quant_tbl_no
  signed int quant_tbl_no;
  // dc_tbl_no
  signed int dc_tbl_no;
  // ac_tbl_no
  signed int ac_tbl_no;
  // width_in_blocks
  unsigned int width_in_blocks;
  // height_in_blocks
  unsigned int height_in_blocks;
  // DCT_scaled_size
  signed int DCT_scaled_size;
  // downsampled_width
  unsigned int downsampled_width;
  // downsampled_height
  unsigned int downsampled_height;
  // component_needed
  signed int component_needed;
  // MCU_width
  signed int MCU_width;
  // MCU_height
  signed int MCU_height;
  // MCU_blocks
  signed int MCU_blocks;
  // MCU_sample_width
  signed int MCU_sample_width;
  // last_col_width
  signed int last_col_width;
  // last_row_height
  signed int last_row_height;
  // quant_table
  struct anonymous_1 *quant_table;
  // dct_table
  void *dct_table;
};

struct anonymous_5
{
  // comps_in_scan
  signed int comps_in_scan;
  // component_index
  signed int component_index[4l];
  // Ss
  signed int Ss;
  // Se
  signed int Se;
  // Ah
  signed int Ah;
  // Al
  signed int Al;
};

struct anonymous_13
{
  // fd
  signed int fd;
  // map_size
  signed int map_size;
  // mem
  char *mem;
  // width
  signed int width;
  // height
  signed int height;
};

struct anonymous_15
{
  // fd
  signed int fd;
  // verbose
  signed int verbose;
  // url
  char *url;
  // image
  char *image;
  // image_size
  signed int image_size;
  // img
  struct anonymous_9 *img;
  // thread
  unsigned long int thread;
  // refresh
  float refresh;
  // quality
  signed int quality;
};

struct anonymous
{
  // num
  signed int num;
  // str
  char *str;
  // len
  signed int len;
};

struct jpeg_destination_mgr
{
  // next_output_byte
  unsigned char *next_output_byte;
  // free_in_buffer
  unsigned long int free_in_buffer;
  // init_destination
  void (*init_destination)(struct jpeg_compress_struct *);
  // empty_output_buffer
  signed int (*empty_output_buffer)(struct jpeg_compress_struct *);
  // term_destination
  void (*term_destination)(struct jpeg_compress_struct *);
};

struct anonymous_14
{
  // pub
  struct jpeg_destination_mgr pub;
  // fd
  signed int fd;
  // buffer
  unsigned char *buffer;
};

union anonymous_11
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_12
{
  // i
  signed int i[8l];
  // s
  char s[80l];
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct jpeg_common_struct
{
  // err
  struct jpeg_error_mgr *err;
  // mem
  struct jpeg_memory_mgr *mem;
  // progress
  struct jpeg_progress_mgr *progress;
  // client_data
  void *client_data;
  // is_decompressor
  signed int is_decompressor;
  // global_state
  signed int global_state;
};

struct jpeg_compress_struct
{
  // err
  struct jpeg_error_mgr *err;
  // mem
  struct jpeg_memory_mgr *mem;
  // progress
  struct jpeg_progress_mgr *progress;
  // client_data
  void *client_data;
  // is_decompressor
  signed int is_decompressor;
  // global_state
  signed int global_state;
  // dest
  struct jpeg_destination_mgr *dest;
  // image_width
  unsigned int image_width;
  // image_height
  unsigned int image_height;
  // input_components
  signed int input_components;
  // in_color_space
  enum anonymous_6 in_color_space;
  // input_gamma
  double input_gamma;
  // data_precision
  signed int data_precision;
  // num_components
  signed int num_components;
  // jpeg_color_space
  enum anonymous_6 jpeg_color_space;
  // comp_info
  struct anonymous_4 *comp_info;
  // quant_tbl_ptrs
  struct anonymous_1 *quant_tbl_ptrs[4l];
  // dc_huff_tbl_ptrs
  struct anonymous_2 *dc_huff_tbl_ptrs[4l];
  // ac_huff_tbl_ptrs
  struct anonymous_2 *ac_huff_tbl_ptrs[4l];
  // arith_dc_L
  unsigned char arith_dc_L[16l];
  // arith_dc_U
  unsigned char arith_dc_U[16l];
  // arith_ac_K
  unsigned char arith_ac_K[16l];
  // num_scans
  signed int num_scans;
  // scan_info
  const struct anonymous_5 *scan_info;
  // raw_data_in
  signed int raw_data_in;
  // arith_code
  signed int arith_code;
  // optimize_coding
  signed int optimize_coding;
  // CCIR601_sampling
  signed int CCIR601_sampling;
  // smoothing_factor
  signed int smoothing_factor;
  // dct_method
  enum anonymous_7 dct_method;
  // restart_interval
  unsigned int restart_interval;
  // restart_in_rows
  signed int restart_in_rows;
  // write_JFIF_header
  signed int write_JFIF_header;
  // JFIF_major_version
  unsigned char JFIF_major_version;
  // JFIF_minor_version
  unsigned char JFIF_minor_version;
  // density_unit
  unsigned char density_unit;
  // X_density
  unsigned short int X_density;
  // Y_density
  unsigned short int Y_density;
  // write_Adobe_marker
  signed int write_Adobe_marker;
  // next_scanline
  unsigned int next_scanline;
  // progressive_mode
  signed int progressive_mode;
  // max_h_samp_factor
  signed int max_h_samp_factor;
  // max_v_samp_factor
  signed int max_v_samp_factor;
  // total_iMCU_rows
  unsigned int total_iMCU_rows;
  // comps_in_scan
  signed int comps_in_scan;
  // cur_comp_info
  struct anonymous_4 *cur_comp_info[4l];
  // MCUs_per_row
  unsigned int MCUs_per_row;
  // MCU_rows_in_scan
  unsigned int MCU_rows_in_scan;
  // blocks_in_MCU
  signed int blocks_in_MCU;
  // MCU_membership
  signed int MCU_membership[10l];
  // Ss
  signed int Ss;
  // Se
  signed int Se;
  // Ah
  signed int Ah;
  // Al
  signed int Al;
  // master
  struct jpeg_comp_master *master;
  // main
  struct jpeg_c_main_controller *main;
  // prep
  struct jpeg_c_prep_controller *prep;
  // coef
  struct jpeg_c_coef_controller *coef;
  // marker
  struct jpeg_marker_writer *marker;
  // cconvert
  struct jpeg_color_converter *cconvert;
  // downsample
  struct jpeg_downsampler *downsample;
  // fdct
  struct jpeg_forward_dct *fdct;
  // entropy
  struct jpeg_entropy_encoder *entropy;
  // script_space
  struct anonymous_5 *script_space;
  // script_space_size
  signed int script_space_size;
};

struct jpeg_error_mgr
{
  // error_exit
  void (*error_exit)(struct jpeg_common_struct *);
  // emit_message
  void (*emit_message)(struct jpeg_common_struct *, signed int);
  // output_message
  void (*output_message)(struct jpeg_common_struct *);
  // format_message
  void (*format_message)(struct jpeg_common_struct *, char *);
  // reset_error_mgr
  void (*reset_error_mgr)(struct jpeg_common_struct *);
  // msg_code
  signed int msg_code;
  // msg_parm
  union anonymous_12 msg_parm;
  // trace_level
  signed int trace_level;
  // num_warnings
  signed long int num_warnings;
  // jpeg_message_table
  const char * const *jpeg_message_table;
  // last_jpeg_message
  signed int last_jpeg_message;
  // addon_message_table
  const char * const *addon_message_table;
  // first_addon_message
  signed int first_addon_message;
  // last_addon_message
  signed int last_addon_message;
};

struct jpeg_memory_mgr
{
  // alloc_small
  void * (*alloc_small)(struct jpeg_common_struct *, signed int, unsigned long int);
  // alloc_large
  void * (*alloc_large)(struct jpeg_common_struct *, signed int, unsigned long int);
  // alloc_sarray
  unsigned char ** (*alloc_sarray)(struct jpeg_common_struct *, signed int, unsigned int, unsigned int);
  // alloc_barray
  signed short int (**(*alloc_barray)(struct jpeg_common_struct *, signed int, unsigned int, unsigned int))[64l];
  // request_virt_sarray
  struct jvirt_sarray_control * (*request_virt_sarray)(struct jpeg_common_struct *, signed int, signed int, unsigned int, unsigned int, unsigned int);
  // request_virt_barray
  struct jvirt_barray_control * (*request_virt_barray)(struct jpeg_common_struct *, signed int, signed int, unsigned int, unsigned int, unsigned int);
  // realize_virt_arrays
  void (*realize_virt_arrays)(struct jpeg_common_struct *);
  // access_virt_sarray
  unsigned char ** (*access_virt_sarray)(struct jpeg_common_struct *, struct jvirt_sarray_control *, unsigned int, unsigned int, signed int);
  // access_virt_barray
  signed short int (**(*access_virt_barray)(struct jpeg_common_struct *, struct jvirt_barray_control *, unsigned int, unsigned int, signed int))[64l];
  // free_pool
  void (*free_pool)(struct jpeg_common_struct *, signed int);
  // self_destruct
  void (*self_destruct)(struct jpeg_common_struct *);
  // max_memory_to_use
  signed long int max_memory_to_use;
  // max_alloc_chunk
  signed long int max_alloc_chunk;
};

struct jpeg_progress_mgr
{
  // progress_monitor
  void (*progress_monitor)(struct jpeg_common_struct *);
  // pass_counter
  signed long int pass_counter;
  // pass_limit
  signed long int pass_limit;
  // completed_passes
  signed int completed_passes;
  // total_passes
  signed int total_passes;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct video_capability
{
  // name
  char name[32l];
  // type
  signed int type;
  // channels
  signed int channels;
  // audios
  signed int audios;
  // maxwidth
  signed int maxwidth;
  // maxheight
  signed int maxheight;
  // minwidth
  signed int minwidth;
  // minheight
  signed int minheight;
};

struct video_channel
{
  // channel
  signed int channel;
  // name
  char name[32l];
  // tuners
  signed int tuners;
  // flags
  unsigned int flags;
  // type
  unsigned short int type;
  // norm
  unsigned short int norm;
};

struct video_clip
{
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // next
  struct video_clip *next;
};

struct video_mbuf
{
  // size
  signed int size;
  // frames
  signed int frames;
  // offsets
  signed int offsets[32l];
};

struct video_mmap
{
  // frame
  unsigned int frame;
  // height
  signed int height;
  // width
  signed int width;
  // format
  unsigned int format;
};

struct video_window
{
  // x
  unsigned int x;
  // y
  unsigned int y;
  // width
  unsigned int width;
  // height
  unsigned int height;
  // chromakey
  unsigned int chromakey;
  // flags
  unsigned int flags;
  // clips
  struct video_clip *clips;
  // clipcount
  signed int clipcount;
};


// _http_header
// file w3http.c line 39
static struct anonymous _http_header[6l] = { { .num=0, .str="Server: ", .len=(signed int)sizeof(char [9l]) /*9ul*/  },
    { .num=1, .str="Content-Type: ", .len=(signed int)sizeof(char [15l]) /*15ul*/  },
    { .num=2, .str="Content-Length: ", .len=(signed int)sizeof(char [17l]) /*17ul*/  },
    { .num=3, .str="MIME-Version: ", .len=(signed int)sizeof(char [15l]) /*15ul*/  },
    { .num=4, .str="Expires: ", .len=(signed int)sizeof(char [10l]) /*10ul*/  },
    { .num=5, .str="\r\n", .len=(signed int)sizeof(char [3l]) /*3ul*/  } };
// _http_status
// file w3http.c line 28
static struct anonymous _http_status[8l] = { { .num=100, .str="Continue", .len=(signed int)sizeof(char [9l]) /*9ul*/  },
    { .num=101, .str="Switching Protocols", .len=(signed int)sizeof(char [20l]) /*20ul*/  },
    { .num=200, .str="Ok", .len=(signed int)sizeof(char [3l]) /*3ul*/  },
    { .num=201, .str="Created", .len=(signed int)sizeof(char [8l]) /*8ul*/  },
    { .num=202, .str="Accepted", .len=(signed int)sizeof(char [9l]) /*9ul*/  },
    { .num=204, .str="No Content", .len=(signed int)sizeof(char [11l]) /*11ul*/  },
    { .num=400, .str="Bad Request", .len=(signed int)sizeof(char [12l]) /*12ul*/  },
    { .num=500, .str="Internal Server Error", .len=(signed int)sizeof(char [22l]) /*22ul*/  } };
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx)
{
  signed long int return_value___builtin_bswap32_1;
  return_value___builtin_bswap32_1=__builtin_bswap32((signed long int)__bsx);
  return (unsigned int)return_value___builtin_bswap32_1;
}

// accept_con
// file w3socket.h line 26
signed int accept_con(signed int sd)
{
  signed int nd = -1;
  signed int len;
  struct sockaddr raddr;
  _Bool tmp_if_expr_2;
  signed int *return_value___errno_location_1;
  do
  {
    nd=accept(sd, &raddr, (unsigned int *)&len);
    if(!(nd >= 1))
    {
      return_value___errno_location_1=__errno_location();
      tmp_if_expr_2 = *return_value___errno_location_1 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
  }
  while(tmp_if_expr_2);
  if(!(nd >= 0))
    return -1;

  else
    return nd;
}

// atof
// file /usr/include/x86_64-linux-gnu/bits/stdlib-float.h line 26
static inline double atof(const char *__nptr)
{
  double return_value_strtod_1;
  return_value_strtod_1=strtod(__nptr, (char **)(void *)0);
  return return_value_strtod_1;
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol_1;
  return_value_strtol_1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1;
}

// bind_port
// file w3socket.h line 25
signed int bind_port(char *host, signed int port)
{
  signed int sd = 0;
  struct sockaddr_in addr;
  signed int one = 1;
  memset((void *)(char *)&addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
  addr.sin_family = (unsigned short int)2;
  unsigned long int return_value_host_addr_1;
  return_value_host_addr_1=host_addr(host);
  addr.sin_addr.s_addr = (unsigned int)return_value_host_addr_1;
  signed int *return_value___errno_location_2;
  return_value___errno_location_2=__errno_location();
  unsigned short int tmp_statement_expression_3;
  signed int return_value_listen_6;
  if(*return_value___errno_location_2 == 22)
  {
    perror(host);
    return -1;
  }

  else
  {
    {
      unsigned short int __v;
      unsigned short int __x = (unsigned short int)port;
      asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
      tmp_statement_expression_3 = __v;
      addr.sin_port = tmp_statement_expression_3;
    }
    sd=socket(2, 1, 0);
    if(!(sd >= 0))
    {
      perror(host);
      return -1;
    }

    else
    {
      printf("%s, sd=%d host_addr()=%d\n", (const void *)"w3socket.c", sd, addr.sin_addr.s_addr);
      setsockopt(sd, 1, 2, (const void *)(char *)&one, (unsigned int)sizeof(signed int) /*4ul*/ );
      signed int return_value_bind_5;
      return_value_bind_5=bind(sd, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
      if(!(return_value_bind_5 >= 0))
      {
        close(sd);
        perror("bind()");
        return -1;
      }

      else
      {
        do
        {
          return_value_listen_6=listen(sd, 3);
          if(!(return_value_listen_6 == -1))
            break;

          signed int *return_value___errno_location_7;
          return_value___errno_location_7=__errno_location();
          if(!(*return_value___errno_location_7 == 4))
            return -1;

        }
        while((_Bool)1);
        return sd;
      }
    }
  }
}

// e_error
// file w3camd.c line 246
void e_error(struct anonymous_15 *cn)
{
  char buf[64l];
  http_status(cn->fd, 6);
  http_header(cn->fd, 0, "w3camd/0.3");
  http_header(cn->fd, 1, "text/plain");
  http_header(cn->fd, 5, (char *)(void *)0);
  sprintf(buf, "can't read image! device busy?!\n");
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(buf);
  write(cn->fd, (const void *)buf, return_value_strlen_1);
}

// e_help
// file w3camd.c line 209
void e_help(struct anonymous_15 *cn)
{
  char buf[16l];
  char *e = "Usage:\n  /image[?quality=<#>[&stream]] - retrieve an image\n  /help                - see these lines\n";
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(e);
  sprintf(buf, "%d", return_value_strlen_1);
  http_status(cn->fd, 2);
  http_header(cn->fd, 0, "w3camd/0.3");
  http_header(cn->fd, 1, "text/plain");
  http_header(cn->fd, 2, buf);
  http_header(cn->fd, 5, (char *)(void *)0);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(e);
  write(cn->fd, (const void *)e, return_value_strlen_2);
}

// e_wrong_url
// file w3camd.c line 229
void e_wrong_url(struct anonymous_15 *cn)
{
  char buf[16l];
  char *e = "wrong url!\n  try \"/help\"\n";
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(e);
  sprintf(buf, "%d", return_value_strlen_1);
  http_status(cn->fd, 6);
  http_header(cn->fd, 0, "w3camd/0.3");
  http_header(cn->fd, 1, "text/plain");
  http_header(cn->fd, 2, buf);
  http_header(cn->fd, 5, (char *)(void *)0);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(e);
  write(cn->fd, (const void *)e, return_value_strlen_2);
}

// empty_output_buffer
// file w3jpeg.c line 59
static signed int empty_output_buffer(struct jpeg_compress_struct *cinfo)
{
  struct anonymous_14 *dest = (struct anonymous_14 *)cinfo->dest;
  signed long int return_value_write_1;
  return_value_write_1=write(dest->fd, (const void *)dest->buffer, (unsigned long int)2048);
  if(!(return_value_write_1 == 2048l))
  {
    return 0;
    cinfo->err->msg_code = 37;
    cinfo->err->error_exit((struct jpeg_common_struct *)cinfo);
  }

  dest->pub.next_output_byte = dest->buffer;
  dest->pub.free_in_buffer = (unsigned long int)2048;
  return 1;
}

// hex_to_asc
// file w3http.c line 102
static char * hex_to_asc(const char *str, signed int len)
{
  char *p;
  char *s;
  char buff[4l];
  signed int chr;
  if(str == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)(len + 1));
    s = (char *)return_value_malloc_1;
    p = s;
    buff[(signed long int)2] = (char)0;
    for( ; !(*str == 0); p = p + 1l)
    {
      if(len == 0)
        break;

      if((signed int)*str == 37)
      {
        __builtin_strncpy(buff, str + (signed long int)1, (unsigned long int)2);
        sscanf(buff, "%02X", &chr);
        *p = (char)(unsigned char)chr;
        str = str + (signed long int)3;
        len = len - 3;
      }

      else
      {
        if((signed int)*str == 43)
          *p = (char)32;

        else
          *p = *str;
        str = str + 1l;
        len = len - 1;
      }
    }
    *p = (char)0;
    return s;
  }
}

// host_addr
// file w3socket.c line 40
unsigned long int host_addr(char *host)
{
  unsigned long int bhost = (unsigned long int)0;
  struct hostent *hostp;
  _Bool tmp_if_expr_1;
  if(host == ((char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (signed int)*host == 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return (unsigned long int)(unsigned int)0x00000000;

  else
  {
    unsigned int return_value_inet_addr_2;
    return_value_inet_addr_2=inet_addr(host);
    bhost = (unsigned long int)return_value_inet_addr_2;
    hostp=gethostbyname(host);
    if(hostp == ((struct hostent *)NULL))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = 22;
      return (unsigned long int)-1;
    }

    if(!(hostp->h_addrtype == 2))
    {
      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      *return_value___errno_location_4 = 22;
      return (unsigned long int)-1;
    }

    return *((unsigned long int *)hostp->h_addr_list[(signed long int)0]);
  }
}

// http_arg_val
// file w3http.h line 57
char * http_arg_val(char **args, char *key)
{
  char *val = (char *)(void *)0;
  signed int tmp_statement_expression_1;
  if(args == ((char **)NULL))
    return (char *)(void *)0;

  else
    if(key == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      for( ; !(*args == ((char *)NULL)); args = args + (signed long int)2)
      {
        unsigned long int __s1_len;
        unsigned long int __s2_len;
        signed int return_value___builtin_strcmp_2;
        return_value___builtin_strcmp_2=__builtin_strcmp(key, *args);
        tmp_statement_expression_1 = return_value___builtin_strcmp_2;
        if(tmp_statement_expression_1 == 0)
          return args[(signed long int)1];

      }
      return val;
    }
}

// http_free_args
// file w3http.h line 58
void http_free_args(char **args)
{
  char **p;
  char **tmp_post_1;
  if(!(args == ((char **)NULL)))
  {
    p = args;
    while(!(*p == ((char *)NULL)))
    {
      tmp_post_1 = p;
      p = p + 1l;
      free((void *)*tmp_post_1);
    }
    free((void *)args);
  }

}

// http_header
// file w3http.h line 55
signed int http_header(signed int fd, signed int no, char *value)
{
  struct anonymous *c;
  char buf[2051l];
  signed int rc;
  signed int len;
  if(no >= 6 || !(no >= 0))
    no = 1;

  c = &_http_header[(signed long int)no];
  sprintf(buf, "%s", c->str);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(buf);
  signed long int return_value_write_2;
  return_value_write_2=write(fd, (const void *)buf, return_value_strlen_1);
  rc = (signed int)return_value_write_2;
  if(!(value == ((char *)NULL)))
  {
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(value);
    len = (signed int)return_value_strlen_3;
    if(len >= 2049)
      value = "--buffer too short!--";

    sprintf(buf, "%s\r\n", value);
    unsigned long int return_value_strlen_4;
    return_value_strlen_4=strlen(buf);
    signed long int return_value_write_5;
    return_value_write_5=write(fd, (const void *)buf, return_value_strlen_4);
    rc = rc + (signed int)return_value_write_5;
  }

  return rc;
}

// http_parse
// file w3http.h line 56
char * http_parse(char *buf, char ***args)
{
  char *url;
  char *ep;
  signed int len;
  signed int return_value_strncasecmp_1;
  return_value_strncasecmp_1=strncasecmp(buf, "GET ", (unsigned long int)4);
  if(!(return_value_strncasecmp_1 == 0))
    return (char *)(void *)0;

  else
  {
    ep=strstr(buf, " HTTP/");
    if(ep == ((char *)NULL))
      ep=strstr(buf, " http/");

    if(ep == ((char *)NULL))
      return (char *)(void *)0;

    else
    {
      len = (signed int)((ep - buf) - (signed long int)4);
      void *return_value_malloc_2;
      return_value_malloc_2=malloc((unsigned long int)(len + 1));
      url = (char *)return_value_malloc_2;
      if(url == ((char *)NULL))
        return (char *)(void *)0;

      else
      {
        __builtin_strncpy(url, buf + (signed long int)4, (unsigned long int)len);
        url[(signed long int)len] = (char)0;
        if(!(args == ((char ***)NULL)))
        {
          char *p;
          char *return_value___builtin_strchr_3;
          return_value___builtin_strchr_3=__builtin_strchr(url, 63);
          p = return_value___builtin_strchr_3;
          if(!(p == ((char *)NULL)))
            *args=parse_string(p + (signed long int)1);

        }

        return url;
      }
    }
  }
}

// http_status
// file w3http.h line 54
signed int http_status(signed int fd, signed int no)
{
  struct anonymous *c;
  char buf[128l];
  signed int rc;
  if(no >= 8 || !(no >= 0))
    no = 7;

  c = &_http_status[(signed long int)no];
  sprintf(buf, "HTTP/1.1 %d %s\r\n", c->num, c->str);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(buf);
  signed long int return_value_write_2;
  return_value_write_2=write(fd, (const void *)buf, return_value_strlen_1);
  rc = (signed int)return_value_write_2;
  return rc;
}

// image_thread
// file w3camd.c line 153
void * image_thread(void *data)
{
  struct anonymous_8 *cam = (struct anonymous_8 *)data;
  struct anonymous_9 *img = cam->img;
  struct anonymous_13 *vid;
  printf("%s: image_thread() img->childs=%d\n", (const void *)"w3camd.c", img->childs);
  signed int return_value_getpid_1;
  return_value_getpid_1=getpid();
  printf("%s:  pid = %d\n", (const void *)"w3camd.c", return_value_getpid_1);
  do
  {

  WAIT:
    ;
    img->state = 0;
    pthread_mutex_lock(&img->childs_lock);
    while((_Bool)1)
    {
      pthread_cond_wait(&img->childs_cond, &img->childs_lock);
      printf("%s: no. of childs changed: childs=%d\n", (const void *)"w3camd.c", img->childs);
      if(img->childs >= 1)
        break;

    }
    pthread_mutex_unlock(&img->childs_lock);
    vid=v4l_init(cam->dev, img->input, img->width, img->height);
    if(vid == ((struct anonymous_13 *)NULL))
    {
      img->state = 1;
      printf("%s: can't init v4l\n", (const void *)"w3camd.c");
      goto WAIT;
    }

    vid->width = img->width;
    vid->height = img->height;
    while(img->childs >= 1)
    {
      signed int return_value_v4l_image_2;
      return_value_v4l_image_2=v4l_image(vid);
      if(return_value_v4l_image_2 == 0)
      {
        img->state = 1;
        printf("image_thread() error\n");
      }

      else
      {
        img->state = 2;
        pthread_mutex_lock(&img->img_lock);
        printf("0x%X 0x%X %dx%d\n", img, vid->mem, vid->width, vid->height);
        memcpy((void *)img->img, (const void *)vid->mem, (unsigned long int)(vid->width * vid->height * 3));
        printf("done ..\n");
        printf("%s: unlocking img..\n", (const void *)"w3camd.c");
        pthread_mutex_unlock(&img->img_lock);
        img->state = 3;
        pthread_cond_broadcast(&img->img_cond);
        usleep((unsigned int)(signed int)(0.005 * (double)1000000));
      }
    }
    v4l_fini(vid);
  }
  while((_Bool)1);
  return (void *)0;
}

// init_destination
// file w3jpeg.c line 43
static void init_destination(struct jpeg_compress_struct *cinfo)
{
  struct anonymous_14 *dest = (struct anonymous_14 *)cinfo->dest;
  void *return_value;
  return_value=cinfo->mem->alloc_small((struct jpeg_common_struct *)cinfo, 1, (unsigned long int)2048 * sizeof(unsigned char) /*1ul*/ );
  dest->buffer = (unsigned char *)return_value;
  dest->pub.next_output_byte = dest->buffer;
  dest->pub.free_in_buffer = (unsigned long int)2048;
}

// jpeg_io_dest
// file w3jpeg.h line 24
void jpeg_io_dest(struct jpeg_compress_struct *cinfo, signed int fd)
{
  struct anonymous_14 *dest;
  if(cinfo->dest == ((struct jpeg_destination_mgr *)NULL))
  {
    void *return_value;
    return_value=cinfo->mem->alloc_small((struct jpeg_common_struct *)cinfo, 0, sizeof(struct anonymous_14) /*56ul*/ );
    cinfo->dest = (struct jpeg_destination_mgr *)return_value;
  }

  dest = (struct anonymous_14 *)cinfo->dest;
  dest->pub.init_destination = init_destination;
  dest->pub.empty_output_buffer = empty_output_buffer;
  dest->pub.term_destination = term_destination;
  dest->fd = fd;
}

// main
// file w3camd.c line 412
signed int main(signed int argc, char **argv)
{
  signed int c;
  signed int sd;
  signed int cd;
  signed int fps = 25;
  signed int input = -1;
  signed int verbose = 0;
  signed int max_connections = 10;
  signed int width = 240;
  signed int height = 180;
  signed int port = 8999;
  char *host = "localhost";
  struct anonymous_15 *cn;
  struct anonymous_9 *img;
  unsigned long int ithread;
  struct anonymous_8 cam;
  cam.dev = "/dev/video0";
  do
  {
    c=getopt(argc, argv, "vp:h:i:s:f:m:d:");
    if(c == -1)
      break;

    switch(c)
    {
      case 100:
      {
        cam.dev = optarg;
        break;
      }
      case 102:
      {
        fps=atoi(optarg);
        break;
      }
      case 104:
      {
        host = optarg;
        break;
      }
      case 105:
      {
        input=atoi(optarg);
        break;
      }
      case 109:
      {
        max_connections=atoi(optarg);
        break;
      }
      case 112:
      {
        port=atoi(optarg);
        break;
      }
      case 115:
      {
        sscanf(optarg, "%dx%d", &width, &height);
        break;
      }
      case 118:
      {
        verbose = verbose + 1;
        break;
      }
      default:
        usage(argv[(signed long int)0]);
    }
  }
  while((_Bool)1);
  signed int return_value_getpid_1;
  if(!(verbose == 0))
  {
    return_value_getpid_1=getpid();
    printf("main thread pid = %d\n", return_value_getpid_1);
  }

  void *return_value_malloc_2;
  return_value_malloc_2=malloc(sizeof(struct anonymous_9) /*208ul*/  + (unsigned long int)(3 * 768 * 576));
  img = (struct anonymous_9 *)return_value_malloc_2;
  if(img == ((struct anonymous_9 *)NULL))
    exit(1);

  img->img = (unsigned char *)(img + (signed long int)1);
  img->childs = 0;
  img->width = width;
  img->height = height;
  img->state = 0;
  img->input = input;
  cam.img = img;
  signal(13, on_sig_pipe);
  signal(11, on_signal);
  pthread_mutex_init(&img->childs_lock, (const union anonymous_11 *)(void *)0);
  pthread_mutex_init(&img->img_lock, (const union anonymous_11 *)(void *)0);
  pthread_cond_init(&img->childs_cond, (const union anonymous_11 *)(void *)0);
  pthread_cond_init(&img->img_cond, (const union anonymous_11 *)(void *)0);
  sd=bind_port(host, port);
  if(!(verbose == 0))
    printf("bind %s:%d to file descriptor %d\n", host, port, sd);

  if(!(sd >= 0))
    return -1;

  else
  {
    pthread_create(&ithread, (const union pthread_attr_t *)(void *)0, image_thread, (void *)&cam);
    while((_Bool)1)
    {
      cd=accept_con(sd);
      if(!(cd >= 0))
        printf("oops!? accept_con() returned < 0\n");

      else
      {
        if(!(verbose == 0))
          printf("incoming connection..\n");

        if(!(max_connections >= 1 + img->childs))
        {
          if(!(verbose == 0))
            printf("too much connections!\n");

        }

        else
        {
          pthread_mutex_lock(&img->childs_lock);
          img->childs = img->childs + 1;
          pthread_cond_broadcast(&img->childs_cond);
          pthread_mutex_unlock(&img->childs_lock);
          void *return_value_malloc_3;
          return_value_malloc_3=malloc(sizeof(struct anonymous_15) /*56ul*/ );
          cn = (struct anonymous_15 *)return_value_malloc_3;
          if(cn == ((struct anonymous_15 *)NULL))
            exit(2);

          cn->fd = cd;
          cn->img = img;
          cn->verbose = verbose;
          cn->quality = 75;
          if(!(verbose == 0))
            printf("serving connection, (childs=%d)\n", cn->img->childs);

          pthread_create(&cn->thread, (const union pthread_attr_t *)(void *)0, server_thread, (void *)cn);
        }
      }
    }
    return 0;
  }
}

// on_sig_pipe
// file w3camd.c line 395
static void on_sig_pipe(signed int signum)
{
  printf("** signal pipe received\n");
}

// on_signal
// file w3camd.c line 401
static void on_signal(signed int signum)
{
  signed int return_value_getpid_1;
  return_value_getpid_1=getpid();
  printf("%d received signal %d\n", return_value_getpid_1, signum);
  exit(1);
}

// parse_string
// file w3http.c line 138
static char ** parse_string(const char *str)
{
  char **kv = (char **)(void *)0;
  const char *p;
  const char *end;
  signed int num = 1;
  signed int i;
  signed int len;
  char *return_value___builtin_strchr_1;
  char *return_value___builtin_strchr_3;
  if(str == ((const char *)NULL))
    return (char **)(void *)0;

  else
  {
    p = str;
    do
    {
      return_value___builtin_strchr_1=__builtin_strchr(p, 38);
      p = return_value___builtin_strchr_1;
      if(p == ((const char *)NULL))
        break;

      num = num + 1;
      p = p + 1l;
    }
    while((_Bool)1);
    void *return_value_calloc_2;
    return_value_calloc_2=calloc((unsigned long int)(num * 2 + 1), sizeof(char **) /*8ul*/ );
    kv = (char **)return_value_calloc_2;
    p = str;
    i = 0;
    do
    {
      len = 0;
      if((signed int)*p == 38)
        p = p + 1l;

      end = p;
      for( ; !((signed int)*end == 61); end = end + 1l)
      {
        if((signed int)*end == 0)
          break;

        if((signed int)*end == 38)
          break;

        len = len + 1;
      }
      kv[(signed long int)i]=hex_to_asc(p, len);
      if((signed int)*end == 38)
      {
        p = p + (signed long int)len;
        i = i + 1;
      }

      else
      {
        p = p + (signed long int)(len + 1);
        end = p;
        i = i + 1;
        len = 0;
        for( ; !((signed int)*end == 38); end = end + 1l)
        {
          if((signed int)*end == 0)
            break;

          len = len + 1;
        }
        kv[(signed long int)i]=hex_to_asc(p, len);
        if(len >= 1)
          p = p + 1l;

        i = i + 1;
      }
      return_value___builtin_strchr_3=__builtin_strchr(p, 38);
      p = return_value___builtin_strchr_3;
    }
    while(!(p == ((const char *)NULL)));
    return kv;
  }
}

// process_url
// file w3camd.c line 262
void process_url(struct anonymous_15 *cn)
{
  char rfc1123[64l];
  signed long int gmt;
  signed int stream = 0;
  char buf[128l];
  gmt=time((signed long int *)(void *)0);
  struct tm *return_value_gmtime_1;
  return_value_gmtime_1=gmtime(&gmt);
  strftime(rfc1123, (unsigned long int)64, "%a, %d %b %Y %H:%M:%S GMT", return_value_gmtime_1);
  if(cn->url == ((char *)NULL))
    e_wrong_url(cn);

  else
  {
    signed int return_value_strncmp_3;
    return_value_strncmp_3=strncmp(cn->url, "/image", (unsigned long int)6);
    if(!(return_value_strncmp_3 == 0))
    {
      signed int return_value_strncmp_2;
      return_value_strncmp_2=strncmp(cn->url, "/help", (unsigned long int)5);
      if(return_value_strncmp_2 == 0)
        e_help(cn);

      else
        e_wrong_url(cn);
      goto __CPROVER_DUMP_L15;
    }

    char *return_value_strstr_4;
    return_value_strstr_4=strstr(cn->url, "stream");
    if(!(return_value_strstr_4 == ((char *)NULL)))
      stream = 1;

    if(cn->img->state == 1)
      e_error(cn);

    else
    {
      http_status(cn->fd, 2);
      http_header(cn->fd, 0, "w3camd/0.3");
      if(!(stream == 0))
        http_header(cn->fd, 1, "multipart/x-mixed-replace;boundary=--w3camd-ns-boundary--may-not-work-with-ie--");

      else
        http_header(cn->fd, 1, "image/jpeg");
      http_header(cn->fd, 4, rfc1123);
      http_header(cn->fd, 5, (char *)(void *)0);
      while((_Bool)1)
      {
        pthread_cond_wait(&cn->img->img_cond, &cn->img->img_lock);
        printf("process_url() state=%d\n", cn->img->state);
        if(cn->img->state == 3)
        {
          if(!(stream == 0))
          {
            sprintf(buf, "\n%s\n", (const void *)"--w3camd-ns-boundary--may-not-work-with-ie--");
            unsigned long int return_value_strlen_5;
            return_value_strlen_5=strlen(buf);
            write(cn->fd, (const void *)buf, return_value_strlen_5);
            sprintf(buf, "Content-Type: image/jpeg\n\n");
            unsigned long int return_value_strlen_6;
            return_value_strlen_6=strlen(buf);
            write(cn->fd, (const void *)buf, return_value_strlen_6);
          }

          signed int return_value_write_jpeg_7;
          return_value_write_jpeg_7=write_jpeg(cn->img, cn->fd, cn->quality);
          if(return_value_write_jpeg_7 == 0)
            goto __CPROVER_DUMP_L15;

          if(stream == 0)
            break;

        }

      }
    }
  }

__CPROVER_DUMP_L15:
  ;
}

// server_thread
// file w3camd.c line 325
void * server_thread(void *data)
{
  struct anonymous_15 *cn = (struct anonymous_15 *)data;
  signed int len;
  signed int inlen = 0;
  char buf[1025l];
  char inbuf[4097l];
  char **args;
  char *val;
  buf[(signed long int)1024] = (char)0;
  inbuf[(signed long int)1024] = (char)0;
  if(!(cn->verbose == 0))
    printf("server_thread() state=%d\n", cn->img->state);

  _Bool tmp_if_expr_4;
  char *return_value_strstr_3;
  _Bool tmp_if_expr_6;
  char *return_value_strstr_5;
  while((_Bool)1)
  {
    signed long int return_value_read_1;
    return_value_read_1=read(cn->fd, (void *)buf, (unsigned long int)1024);
    len = (signed int)return_value_read_1;
    if(!(len >= 1))
    {
      goto CLIENT_END;
      return (void *)0;
    }

    buf[(signed long int)len] = (char)0;
    if(inlen + len >= 4097)
    {
      printf("input overrun\n");
      break;
    }

    memcpy((void *)(inbuf + (signed long int)inlen), (const void *)buf, (unsigned long int)len);
    inlen = inlen + len;
    char *return_value_strstr_2;
    return_value_strstr_2=strstr(inbuf, "\n\n");
    if(!(return_value_strstr_2 == ((char *)NULL)))
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_strstr_3=strstr(inbuf, "\r\n\r\n");
      tmp_if_expr_4 = return_value_strstr_3 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      return_value_strstr_5=strstr(inbuf, "\r\r");
      tmp_if_expr_6 = return_value_strstr_5 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
      break;

  }
  inbuf[(signed long int)inlen] = (char)0;
  cn->url=http_parse(inbuf, &args);
  if(cn->verbose >= 2)
    printf("getting url=%s\n", cn->url);

  double return_value_atof_7;
  if(!(args == ((char **)NULL)))
  {
    val=http_arg_val(args, "refresh");
    if(!(val == ((char *)NULL)))
    {
      return_value_atof_7=atof(val);
      cn->refresh = (float)return_value_atof_7;
    }

    val=http_arg_val(args, "quality");
    if(!(val == ((char *)NULL)))
      cn->quality=atoi(val);

  }

  if(cn->verbose >= 3)
  {
    printf("  quality=%d\n", cn->quality);
    printf("  refresh=%f\n", cn->refresh);
  }

  process_url(cn);
  close(cn->fd);
  cn->img->childs = cn->img->childs - 1;
  if(!(args == ((char **)NULL)))
    http_free_args(args);

  free((void *)cn->url);
  if(!(cn->verbose == 0))
    printf("connection closed\n");


CLIENT_END:
  ;
  pthread_detach(cn->thread);
  free((void *)cn);
  return (void *)0;
}

// term_destination
// file w3jpeg.c line 77
static void term_destination(struct jpeg_compress_struct *cinfo)
{
  struct anonymous_14 *dest = (struct anonymous_14 *)cinfo->dest;
  unsigned long int datacount = (unsigned long int)2048 - dest->pub.free_in_buffer;
  if(datacount >= 1ul)
  {
    signed long int return_value_write_1;
    return_value_write_1=write(dest->fd, (const void *)dest->buffer, datacount);
    if(!((unsigned long int)return_value_write_1 == datacount))
    {
      goto __CPROVER_DUMP_L3;
      cinfo->err->msg_code = 37;
      cinfo->err->error_exit((struct jpeg_common_struct *)cinfo);
    }

  }


__CPROVER_DUMP_L3:
  ;
}

// usage
// file w3camd.c line 90
void usage(char *pname)
{
  fprintf(stderr, "Usage: %s [-v] [-p #] [-h host] [-s #x#] [-m #] [-i #] [-d device] \n", pname);
  exit(1);
}

// v4l_fini
// file w3v4l.h line 33
void v4l_fini(struct anonymous_13 *vid)
{
  if(vid->fd >= 0)
  {
    if(vid->map_size == 0)
      free((void *)vid->mem);

    else
      munmap((void *)vid->mem, (unsigned long int)vid->map_size);
    close(vid->fd);
  }

  free((void *)vid);
}

// v4l_image
// file w3v4l.h line 34
signed int v4l_image(struct anonymous_13 *vid)
{
  struct video_mmap vid_mmap;
  if(vid->map_size == 0)
  {
    printf("%s: reading image .. \n", (const void *)"w3v4l.c");
    signed long int return_value_read_1;
    return_value_read_1=read(vid->fd, (void *)vid->mem, (unsigned long int)(vid->width * vid->height * 3));
    if(!(return_value_read_1 >= 1l))
    {
      free((void *)vid->mem);
      return 0;
    }

  }

  else
  {
    vid_mmap.format = (unsigned int)4;
    vid_mmap.frame = (unsigned int)0;
    vid_mmap.width = vid->width;
    vid_mmap.height = vid->height;
    signed int return_value_ioctl_2;
    return_value_ioctl_2=ioctl(vid->fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(118 << 0 + 8) | (unsigned int)(19 << 0)) | sizeof(struct video_mmap) /*16ul*/  << 0 + 8 + 8, &vid_mmap);
    if(return_value_ioctl_2 == -1)
    {
      perror("ioctl (VIDIOCMCAPTURE)");
      return 0;
    }

    signed int return_value_ioctl_3;
    return_value_ioctl_3=ioctl(vid->fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(118 << 0 + 8) | (unsigned int)(18 << 0)) | sizeof(signed int) /*4ul*/  << 0 + 8 + 8, &vid_mmap);
    if(return_value_ioctl_3 == -1)
    {
      perror("ioctl (VIDIOCSYNC)");
      return 0;
    }

  }
  printf("%s: done\n", (const void *)"w3v4l.c");
  return 1;
}

// v4l_init
// file w3v4l.h line 32
struct anonymous_13 * v4l_init(char *dev, signed int input, signed int width, signed int height)
{
  signed int fd;
  struct video_capability vid_caps;
  struct video_mbuf vid_mbuf;
  struct video_channel vid_chnl;
  struct anonymous_13 *vid;
  fd=open(dev, 02);
  if(fd == -1)
  {
    perror(dev);
    return (struct anonymous_13 *)(void *)0;
  }

  else
  {
    signed int return_value_ioctl_1;
    return_value_ioctl_1=ioctl(fd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(118 << 0 + 8) | (unsigned int)(1 << 0)) | sizeof(struct video_capability) /*60ul*/  << 0 + 8 + 8, &vid_caps);
    if(return_value_ioctl_1 == -1)
    {
      perror("ioctl (VIDIOCGCAP)");
      return (struct anonymous_13 *)(void *)0;
    }

    else
    {
      void *return_value_malloc_2;
      return_value_malloc_2=malloc(sizeof(struct anonymous_13) /*24ul*/ );
      vid = (struct anonymous_13 *)return_value_malloc_2;
      vid->fd = fd;
      signed int return_value_ioctl_4;
      return_value_ioctl_4=ioctl(fd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(118 << 0 + 8) | (unsigned int)(20 << 0)) | sizeof(struct video_mbuf) /*136ul*/  << 0 + 8 + 8, &vid_mbuf);
      if(return_value_ioctl_4 == -1)
      {
        struct video_window vid_win;
        vid->map_size = 0;
        signed int return_value_ioctl_3;
        return_value_ioctl_3=ioctl(fd, (unsigned long int)(2U << 0 + 8 + 8 + 14 | (unsigned int)(118 << 0 + 8) | (unsigned int)(9 << 0)) | sizeof(struct video_window) /*40ul*/  << 0 + 8 + 8, &vid_win);
        if(!(return_value_ioctl_3 == -1))
        {
          vid_win.width = (unsigned int)width;
          vid_win.height = (unsigned int)height;
          ioctl(fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(118 << 0 + 8) | (unsigned int)(10 << 0)) | sizeof(struct video_window) /*40ul*/  << 0 + 8 + 8, &vid_win);
        }

      }

      else
        vid->map_size = vid_mbuf.size;
      printf("%s: mbuf.size=%d\n", (const void *)"w3v4l.c", vid_mbuf.size);
      if(input >= 0)
      {
        vid_chnl.channel = input;
        signed int return_value_ioctl_6;
        return_value_ioctl_6=ioctl(fd, (unsigned long int)((2U | 1U) << 0 + 8 + 8 + 14 | (unsigned int)(118 << 0 + 8) | (unsigned int)(2 << 0)) | sizeof(struct video_channel) /*48ul*/  << 0 + 8 + 8, &vid_chnl);
        if(return_value_ioctl_6 == -1)
          perror("ioctl (VIDIOCGCHAN)");

        else
        {
          vid_chnl.channel = input;
          signed int return_value_ioctl_5;
          return_value_ioctl_5=ioctl(fd, (unsigned long int)(1U << 0 + 8 + 8 + 14 | (unsigned int)(118 << 0 + 8) | (unsigned int)(3 << 0)) | sizeof(struct video_channel) /*48ul*/  << 0 + 8 + 8, &vid_chnl);
          if(return_value_ioctl_5 == -1)
            perror("ioctl (VIDIOCSCHAN)");

        }
      }

      if(vid->map_size >= 1)
      {
        void *return_value_mmap_7;
        return_value_mmap_7=mmap(NULL, (unsigned long int)vid->map_size, 0x1 | 0x2, 0x01, fd, (signed long int)0);
        vid->mem = (char *)return_value_mmap_7;
        if((unsigned char *)-1 == (unsigned char *)vid->mem)
        {
          perror("mmap()");
          close(fd);
          free((void *)vid);
          return (struct anonymous_13 *)(void *)0;
        }

      }

      else
      {
        void *return_value_malloc_8;
        return_value_malloc_8=malloc((unsigned long int)(width * height * 3));
        vid->mem = (char *)return_value_malloc_8;
      }
      vid->width = width;
      vid->height = height;
      return vid;
    }
  }
}

// write_jpeg
// file w3camd.c line 101
signed int write_jpeg(struct anonymous_9 *img, signed int fd, signed int quality)
{
  unsigned char *row_ptr[1l];
  struct jpeg_compress_struct jpeg;
  struct jpeg_error_mgr jerr;
  char *line;
  char *image;
  signed int y;
  signed int x;
  signed int line_width;
  fprintf(stderr, "%s: write_jpeg() width=%d height=%d\n", (const void *)"w3camd.c", img->width, img->height);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(img->width * 3));
  line = (char *)return_value_malloc_1;
  if(line == ((char *)NULL))
    return 0;

  else
  {
    jpeg.err=jpeg_std_error(&jerr);
    jpeg_CreateCompress(&jpeg, 62, (unsigned long int)sizeof(struct jpeg_compress_struct) /*520ul*/ );
    jpeg.image_width = (unsigned int)img->width;
    jpeg.image_height = (unsigned int)img->height;
    jpeg.input_components = 3;
    jpeg.in_color_space = (enum anonymous_6)JCS_RGB;
    jpeg_set_defaults(&jpeg);
    jpeg_set_quality(&jpeg, quality, 1);
    jpeg.dct_method = (enum anonymous_7)JDCT_IFAST;
    jpeg_io_dest(&jpeg, fd);
    jpeg_start_compress(&jpeg, 1);
    row_ptr[(signed long int)0] = (unsigned char *)line;
    line_width = img->width * 3;
    image = (char *)img->img;
    y = 0;
    for( ; !(y >= img->height); y = y + 1)
    {
      x = 0;
      for( ; !(x >= line_width); x = x + 3)
      {
        line[(signed long int)x] = image[(signed long int)(x + 2)];
        line[(signed long int)(x + 1)] = image[(signed long int)(x + 1)];
        line[(signed long int)(x + 2)] = image[(signed long int)x];
      }
      unsigned int return_value_jpeg_write_scanlines_2;
      return_value_jpeg_write_scanlines_2=jpeg_write_scanlines(&jpeg, row_ptr, (unsigned int)1);
      if(return_value_jpeg_write_scanlines_2 == 0u)
      {
        jpeg_destroy_compress(&jpeg);
        free((void *)line);
        return 0;
      }

      image = image + (signed long int)line_width;
    }
    jpeg_finish_compress(&jpeg);
    jpeg_destroy_compress(&jpeg);
    free((void *)line);
    return 1;
  }
}

