// #anon_enum$G_CONNECT_AFTER=1$G_CONNECT_SWAPPED=2
// file /usr/include/glib-2.0/gobject/gsignal.h line 155
enum anonymous$5 { G_CONNECT_AFTER=1, G_CONNECT_SWAPPED=2 };

// #anon_enum$G_FILE_MONITOR_EVENT_CHANGED=0$G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT=1$G_FILE_MONITOR_EVENT_DELETED=2$G_FILE_MONITOR_EVENT_CREATED=3$G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED=4$G_FILE_MONITOR_EVENT_PRE_UNMOUNT=5$G_FILE_MONITOR_EVENT_UNMOUNTED=6$G_FILE_MONITOR_EVENT_MOVED=7$G_FILE_MONITOR_EVENT_RENAMED=8$G_FILE_MONITOR_EVENT_MOVED_IN=9$G_FILE_MONITOR_EVENT_MOVED_OUT=10
// file /usr/include/glib-2.0/gio/gioenums.h line 416
enum anonymous$8 { G_FILE_MONITOR_EVENT_CHANGED=0, G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT=1, G_FILE_MONITOR_EVENT_DELETED=2, G_FILE_MONITOR_EVENT_CREATED=3, G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED=4, G_FILE_MONITOR_EVENT_PRE_UNMOUNT=5, G_FILE_MONITOR_EVENT_UNMOUNTED=6, G_FILE_MONITOR_EVENT_MOVED=7, G_FILE_MONITOR_EVENT_RENAMED=8, G_FILE_MONITOR_EVENT_MOVED_IN=9, G_FILE_MONITOR_EVENT_MOVED_OUT=10 };

// #anon_enum$G_FILE_MONITOR_NONE=0$G_FILE_MONITOR_WATCH_MOUNTS=1$G_FILE_MONITOR_SEND_MOVED=2$G_FILE_MONITOR_WATCH_HARD_LINKS=4$G_FILE_MONITOR_WATCH_MOVES=8
// file /usr/include/glib-2.0/gio/gioenums.h line 342
enum anonymous$9 { G_FILE_MONITOR_NONE=0, G_FILE_MONITOR_WATCH_MOUNTS=1, G_FILE_MONITOR_SEND_MOVED=2, G_FILE_MONITOR_WATCH_HARD_LINKS=4, G_FILE_MONITOR_WATCH_MOVES=8 };

// #anon_enum$G_FILE_QUERY_INFO_NONE=0$G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS=1
// file /usr/include/glib-2.0/gio/gioenums.h line 184
enum anonymous$7 { G_FILE_QUERY_INFO_NONE=0, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS=1 };

// #anon_enum$G_FILE_TYPE_UNKNOWN=0$G_FILE_TYPE_REGULAR=1$G_FILE_TYPE_DIRECTORY=2$G_FILE_TYPE_SYMBOLIC_LINK=3$G_FILE_TYPE_SPECIAL=4$G_FILE_TYPE_SHORTCUT=5$G_FILE_TYPE_MOUNTABLE=6
// file /usr/include/glib-2.0/gio/gioenums.h line 365
enum anonymous$6 { G_FILE_TYPE_UNKNOWN=0, G_FILE_TYPE_REGULAR=1, G_FILE_TYPE_DIRECTORY=2, G_FILE_TYPE_SYMBOLIC_LINK=3, G_FILE_TYPE_SPECIAL=4, G_FILE_TYPE_SHORTCUT=5, G_FILE_TYPE_MOUNTABLE=6 };

// #anon_enum$G_KEY_FILE_NONE=0$G_KEY_FILE_KEEP_COMMENTS=1$G_KEY_FILE_KEEP_TRANSLATIONS=2
// file /usr/include/glib-2.0/glib/gkeyfile.h line 50
enum anonymous$28 { G_KEY_FILE_NONE=0, G_KEY_FILE_KEEP_COMMENTS=1, G_KEY_FILE_KEEP_TRANSLATIONS=2 };

// tag-#anon#ST[*{SYM#tag-_ftsent#}$SYM#tag-_ftsent#$'fts_cur'||*{SYM#tag-_ftsent#}$SYM#tag-_ftsent#$'fts_child'||*{*{SYM#tag-_ftsent#}$SYM#tag-_ftsent#$}$*{SYM#tag-_ftsent#}$SYM#tag-_ftsent#$$'fts_array'||U64'fts_dev'||*{S8}$S8$'fts_path'||S32'fts_rfd'||S32'fts_pathlen'||S32'fts_nitems'||U32'$pad0'||*{S32(*{cV}$cV$|*{cV}$cV$)->S32}$S32(*{cV}$cV$|*{cV}$cV$)->S32$'fts_compar'||S32'fts_options'||U32'$pad1'|]
// file /usr/include/fts.h line 45
struct anonymous$16;

// tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous$25;

// tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous$23;

// tag-#anon#ST[ARR16{S64}$S64$'fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$3;

// tag-#anon#ST[ARR16{U64}$U64$'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous$15;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$2;

// tag-#anon#ST[S32'rm_so'||S32'rm_eo'|]
// file /usr/include/regex.h line 452
struct anonymous$10;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous$19;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous$22;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous$21;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous$27;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous$20;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous$24;

// tag-#anon#UN[*{SYM#tag-_GHashTable#}$SYM#tag-_GHashTable#$'ht_dst'||*{SYM#tag-_GTree#}$SYM#tag-_GTree#$'bt_dst'|]
// file glibex.c line 25
union anonymous$11;

// tag-#anon#UN[*{V(S32)->V}$V(S32)->V$'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V}$V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}$SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'$pad0'||SYM#tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#$|*{V}$V$)->V$'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous$18;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'||ARR8{U16}$U16$'__u6_addr16'||ARR4{U32}$U32$'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous$12;

// tag-#anon#UN[ARR28{S32}$S32$'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'$pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}$V$'si_addr'||S16'si_addr_lsb'||U48'$pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'$pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}$V$'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous$26;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$0;

// tag-#anon#UN[S32'v_int'||U32'v_uint'||S64'v_long'||U64'v_ulong'||S64'v_int64'||U64'v_uint64'||F32'v_float'||F64'v_double'||*{V}$V$'v_pointer'|]
// file /usr/include/glib-2.0/gobject/gvalue.h line 112
union anonymous$4;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$1;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$14;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$17;

// tag-_GCancellable
// file /usr/include/glib-2.0/gio/giotypes.h line 38
struct _GCancellable;

// tag-_GCancellablePrivate
// file /usr/include/glib-2.0/gio/gcancellable.h line 45
struct _GCancellablePrivate;

// tag-_GClosure
// file /usr/include/glib-2.0/gobject/gclosure.h line 74
struct _GClosure;

// tag-_GClosureNotifyData
// file /usr/include/glib-2.0/gobject/gclosure.h line 75
struct _GClosureNotifyData;

// tag-_GData
// file /usr/include/glib-2.0/glib/gdataset.h line 36
struct _GData;

// tag-_GError
// file /usr/include/glib-2.0/glib/gerror.h line 42
struct _GError;

// tag-_GFile
// file /usr/include/glib-2.0/gio/giotypes.h line 83
struct _GFile;

// tag-_GFileMonitor
// file /usr/include/glib-2.0/gio/giotypes.h line 72
struct _GFileMonitor;

// tag-_GFileMonitorPrivate
// file /usr/include/glib-2.0/gio/gfilemonitor.h line 40
struct _GFileMonitorPrivate;

// tag-_GHashTable
// file /usr/include/glib-2.0/glib/ghash.h line 37
struct _GHashTable;

// tag-_GKeyFile
// file /usr/include/glib-2.0/glib/gkeyfile.h line 48
struct _GKeyFile;

// tag-_GMainContext
// file /usr/include/glib-2.0/glib/gmain.h line 48
struct _GMainContext;

// tag-_GMainLoop
// file /usr/include/glib-2.0/glib/gmain.h line 56
struct _GMainLoop;

// tag-_GObject
// file /usr/include/glib-2.0/gobject/gobject.h line 187
struct _GObject;

// tag-_GTree
// file /usr/include/glib-2.0/glib/gtree.h line 36
struct _GTree;

// tag-_GTypeClass
// file /usr/include/glib-2.0/gobject/gtype.h line 389
struct _GTypeClass;

// tag-_GTypeInstance
// file /usr/include/glib-2.0/gobject/gtype.h line 391
struct _GTypeInstance;

// tag-_GValue
// file /usr/include/glib-2.0/gobject/gtype.h line 386
struct _GValue;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_ftsent
// file /usr/include/fts.h line 46
struct _ftsent;

// tag-api_eventinfo
// file clsync.h line 43
struct api_eventinfo;

// tag-api_functs
// file ctx.h line 219
struct api_functs;

// tag-clsynccbqueue
// file socket.h line 56
struct clsynccbqueue;

// tag-clsyncsock
// file socket.h line 64
struct clsyncsock;

// tag-clsyncsock_state
// file socket.h line 90
enum clsyncsock_state { CLSTATE_NONE=0, CLSTATE_AUTH=1, CLSTATE_MAIN=2, CLSTATE_DYING=3, CLSTATE_DIED=4 };

// tag-ctx
// file clsync.h line 53
struct ctx;

// tag-detachnetwork_way
// file ctx.h line 136
enum detachnetwork_way { DN_OFF=0, DN_NONPRIVILEGED=1, DN_EVERYWHERE=2 };

// tag-dosync_arg
// file common.h line 218
struct dosync_arg;

// tag-dump_dirfd_obj
// file sync.c line 3431
enum dump_dirfd_obj { DUMP_DIRFD_ROOT=0, DUMP_DIRFD_QUEUE=1, DUMP_DIRFD_THREAD=2, DUMP_DIRFD_MAX=3 };

// tag-event
// file mon_gio.c line 41
struct event;

// tag-eventinfo
// file common.h line 198
struct eventinfo;

// tag-eventinfo_flags
// file clsync.h line 60
enum eventinfo_flags { EVIF_NONE=0, EVIF_RECURSIVELY=1, EVIF_CONTENTRECURSIVELY=2 };

// tag-eventobjtype
// file clsync.h line 33
enum eventobjtype { EOT_UNKNOWN=0, EOT_DOESNTEXIST=1, EOT_FILE=2, EOT_DIR=3 };

// tag-fileinfo
// file indexes.h line 29
struct fileinfo;

// tag-filemondata
// file mon_gio.c line 33
struct filemondata;

// tag-group
// file /usr/include/grp.h line 42
struct group;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-indexes
// file clsync.h line 54
struct indexes;

// tag-initsync
// file common.h line 267
enum initsync { INITSYNC_UNKNOWN=0, INITSYNC_FULL=1, INITSYNC_SUBDIR=2 };

// tag-inotify_event
// file /usr/include/x86_64-linux-gnu/sys/inotify.h line 28
struct inotify_event;

// tag-ipc_perm
// file /usr/include/x86_64-linux-gnu/bits/ipc.h line 42
struct ipc_perm;

// tag-ipc_type
// file error.h line 59
enum ipc_type { IPCT_PRIVATE=0, IPCT_SHARED=1 };

// tag-keyvalue_copy_arg
// file glibex.c line 24
struct keyvalue_copy_arg;

// tag-mntent
// file /usr/include/mntent.h line 53
struct mntent;

// tag-notifyengine_enum
// file common.h line 162
enum notifyengine_enum { NE_UNDEFINED=0, NE_FANOTIFY=1, NE_INOTIFY=2, NE_KQUEUE=3, NE_BSM=4, NE_BSM_PREFETCH=5, NE_DTRACEPIPE=6, NE_GIO=7 };

// tag-notifyenginefuncts
// file ctx.h line 227
struct notifyenginefuncts;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-outputmethod
// file error.h line 69
enum outputmethod { OM_STDERR=0, OM_STDOUT=1, OM_SYSLOG=2, OM_MAX=3 };

// tag-paramsource_enum
// file common.h line 150
enum paramsource_enum { PS_UNKNOWN=0, PS_ARGUMENT=1, PS_CONFIG=2, PS_CONTROL=3, PS_DEFAULTS=4, PS_CORRECTION=5 };

// tag-passwd
// file /usr/include/pwd.h line 49
struct passwd;

// tag-pivotroot_way
// file ctx.h line 143
enum pivotroot_way { PW_OFF=0, PW_DIRECT=1, PW_AUTO=2, PW_AUTORO=3 };

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-queue_id
// file ctx.h line 171
enum queue_id { QUEUE_NORMAL=0, QUEUE_BIGFILE=1, QUEUE_INSTANT=2, QUEUE_LOCKWAIT=3, QUEUE_MAX=4, QUEUE_AUTO=5 };

// tag-queueinfo
// file ctx.h line 213
struct queueinfo;

// tag-re_pattern_buffer
// file /usr/include/regex.h line 357
struct re_pattern_buffer;

// tag-recognize_event_return
// file mon_inotify.c line 33
struct recognize_event_return;

// tag-rule
// file ctx.h line 204
struct rule;

// tag-ruleaction_enum
// file ctx.h line 188
enum ruleaction_enum { RA_NONE=0, RA_MONITOR=1, RA_WALK=2, RA_ALL=15 };

// tag-shargsid
// file ctx.h line 242
enum shargsid { SHARGS_PRIMARY=0, SHARGS_INITIAL=1, SHARGS_MAX=2 };

// tag-shflags
// file ctx.h line 233
enum shflags { SHFL_NONE=0, SHFL_RSYNC_ARGS=1, SHFL_INCLUDE_LIST=2, SHFL_INCLUDE_LIST_PATH=4, SHFL_EXCLUDE_LIST_PATH=8 };

// tag-shmid_ds
// file /usr/include/x86_64-linux-gnu/bits/shm.h line 49
struct shmid_ds;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sighandler_arg
// file common.h line 274
struct sighandler_arg;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-sockauth_id
// file socket.h line 198
enum sockauth_id { SOCKAUTH_UNSET=0, SOCKAUTH_NULL=1, SOCKAUTH_PAM=2 };

// tag-sockcmd
// file socket.h line 53
struct sockcmd;

// tag-sockcmd_dat_ack
// file socket.h line 134
struct sockcmd_dat_ack;

// tag-sockcmd_dat_dump
// file socket.h line 164
struct sockcmd_dat_dump;

// tag-sockcmd_dat_eexist
// file socket.h line 169
struct sockcmd_dat_eexist;

// tag-sockcmd_dat_eperm
// file socket.h line 174
struct sockcmd_dat_eperm;

// tag-sockcmd_dat_info
// file socket.h line 156
struct sockcmd_dat_info;

// tag-sockcmd_dat_invalidcmd
// file socket.h line 144
struct sockcmd_dat_invalidcmd;

// tag-sockcmd_dat_negotiation
// file socket.h line 128
struct sockcmd_dat_negotiation;

// tag-sockcmd_dat_set
// file socket.h line 179
struct sockcmd_dat_set;

// tag-sockcmd_dat_version
// file socket.h line 149
struct sockcmd_dat_version;

// tag-sockcmd_id
// file socket.h line 99
enum sockcmd_id { SOCKCMD_REQUEST_NEGOTIATION=0, SOCKCMD_REPLY_NEGOTIATION=1, SOCKCMD_REPLY_ACK=150, SOCKCMD_REPLY_UNKNOWNCMD=160, SOCKCMD_REPLY_INVALIDCMDID=161, SOCKCMD_REPLY_EINVAL=162, SOCKCMD_REPLY_EEXIST=163, SOCKCMD_REPLY_EPERM=164, SOCKCMD_REPLY_ECUSTOM=199, SOCKCMD_REQUEST_VERSION=200, SOCKCMD_REQUEST_INFO=201, SOCKCMD_REQUEST_DUMP=202, SOCKCMD_REQUEST_LOGIN=210, SOCKCMD_REQUEST_SET=211, SOCKCMD_REQUEST_DIE=240, SOCKCMD_REQUEST_QUIT=250, SOCKCMD_REPLY_VERSION=300, SOCKCMD_REPLY_INFO=301, SOCKCMD_REPLY_DUMP=302, SOCKCMD_REPLY_LOGIN=310, SOCKCMD_REPLY_SET=311, SOCKCMD_REPLY_DIE=340, SOCKCMD_REPLY_BYE=350, SOCKCMD_REPLY_UNEXPECTEDEND=351, SOCKCMD_MAXID=352 };

// tag-socket_sockthreaddata
// file socket.h line 52
struct socket_sockthreaddata;

// tag-sockprocflags
// file socket.h line 193
enum sockprocflags { SOCKPROCFLAG_NONE=0 };

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-stat64
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 119
struct stat64;

// tag-state_enum
// file ctx.h line 256
enum state_enum { STATE_EXIT=0, STATE_STARTING=1, STATE_RUNNING=2, STATE_SYNCHANDLER_ERR=3, STATE_REHASH=4, STATE_PREEXIT=5, STATE_TERM=6, STATE_THREAD_GC=7, STATE_INITSYNC=8, STATE_HOLDON=9, STATE_UNKNOWN=10 };

// tag-sync_dump_arg
// file sync.c line 3445
struct sync_dump_arg;

// tag-synchandler_args
// file ctx.h line 248
struct synchandler_args;

// tag-thread_callbackfunct_arg
// file sync.h line 23
struct thread_callbackfunct_arg;

// tag-threadinfo
// file sync.h line 30
struct threadinfo;

// tag-threadingmode
// file common.h line 174
enum threadingmode { PM_OFF=0, PM_SAFE=1, PM_FULL=2 };

// tag-threadsinfo
// file sync.h line 55
struct threadsinfo;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-trylocked_arg
// file sync.c line 2337
struct trylocked_arg;

#ifndef NULL
#define NULL ((void*)0)
#endif

// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __privileged_fork_execvp
// file privileged.c line 1635
signed int __privileged_fork_execvp(const char *file, char * const *argv);
// __privileged_kill_child_itself
// file privileged.c line 455
signed int __privileged_kill_child_itself(signed int child_pid, signed int signal, char ignoreerrors);
// __sync_exec_thread
// file sync.c line 1086
signed int __sync_exec_thread(struct threadinfo *threadinfo_p);
// _critical
// file error.c line 170
extern void _critical(const char * const function_name, const char *fmt, ...);
// _debug
// file error.h line 46
extern void _debug(signed int debug_level, const char * const function_name, const char *fmt, ...);
// _error
// file error.c line 227
extern void _error(const char * const function_name, const char *fmt, ...);
// _exitcode_process
// file sync.c line 156
static inline signed int _exitcode_process(struct ctx *ctx_p, signed int exitcode);
// _info
// file error.c line 256
extern void _info(const char * const function_name, const char *fmt, ...);
// _privileged_fork_execvp$object
//
signed int _privileged_fork_execvp$object(const char *, char * const *);
// _privileged_kill_child$object
//
signed int _privileged_kill_child$object(signed int, signed int, char);
// _socket_send
// file socket.c line 272
signed int _socket_send(struct clsyncsock *clsyncsock, unsigned long int *cmd_num_p, enum sockcmd_id cmd_id, void **ap);
// _str_splitargs
// file stringex.c line 27
static signed int _str_splitargs(char *ptr, char **arg_start_p, signed int quotes, signed int (*handler)(char *, unsigned long int, void *), char *additional_arg);
// _str_splitargs::handler$object
//
signed int handler$object(char *, unsigned long int, void *);
// _sync_idle_dosync_collectedevents
// file sync.c line 2262
void _sync_idle_dosync_collectedevents(void *fpath_gp, void *evinfo_gp, void *arg_gp);
// _sync_idle_dosync_collectedexcludes
// file sync.c line 2190
void _sync_idle_dosync_collectedexcludes(void *fpath_gp, void *flags_gp, void *arg_gp);
// _sync_islocked
// file sync.c line 2245
signed int _sync_islocked(struct threadinfo *threadinfo_p, void *_fpath);
// _thread_info_lock
// file sync.c line 202
static inline struct threadsinfo * _thread_info_lock(const char * const function_name);
// _thread_info_unlock
// file sync.c line 212
static inline signed int _thread_info_unlock(const char * const function_name, signed int rc);
// _warning
// file error.h line 39
extern void _warning(const char * const function_name, const char *fmt, ...);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, union anonymous$17, unsigned int *);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// adler32_calc
// file calc.c line 41
extern unsigned int adler32_calc(const unsigned char * const data, unsigned int len);
// alarm
// file /usr/include/unistd.h line 432
extern unsigned int alarm(unsigned int);
// api_evinfo_initialevmask
// file sync.c line 1247
static inline void api_evinfo_initialevmask(struct ctx *ctx_p, struct api_eventinfo *evinfo_p, signed int isdir);
// apievinfo2rsynclist
// file sync.c line 2990
extern signed int apievinfo2rsynclist(struct indexes *indexes_p, struct _IO_FILE *listfile, signed int n, struct api_eventinfo *apievinfo);
// arguments_parse
// file main.c line 1698
signed int arguments_parse(signed int argc, char **argv, struct ctx *ctx_p);
// argv_dump
// file sync.c line 883
static inline void argv_dump(signed int debug_level, char **argv);
// argv_free
// file sync.c line 1540
static void argv_free(char **argv);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// backtrace
// file /usr/include/execinfo.h line 27
extern signed int backtrace(void **, signed int);
// backtrace_symbols
// file /usr/include/execinfo.h line 32
extern char ** backtrace_symbols(void * const *, signed int);
// becomedaemon
// file main.c line 2257
signed int becomedaemon();
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous$17, unsigned int);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// child_sigchld
// file main.c line 431
void child_sigchld();
// chmod
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 283
extern signed int chmod(const char *, unsigned int);
// chown
// file /usr/include/unistd.h line 473
extern signed int chown(const char *, unsigned int, unsigned int);
// chroot
// file /usr/include/unistd.h line 944
extern signed int chroot(const char *);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closecontrol
// file control.c line 89
static inline void closecontrol(struct ctx *ctx_p);
// clsyncapi_fork
// file sync.c line 986
extern signed int clsyncapi_fork(struct ctx *ctx_p);
// clsyncapi_getapiversion
// file main.c line 545
extern signed int clsyncapi_getapiversion();
// config_block_parse
// file main.c line 2191
signed int config_block_parse(struct ctx *ctx_p, const char * const config_block_name);
// configs_parse
// file main.c line 1783
signed int configs_parse(struct ctx *ctx_p, enum paramsource_enum paramsource);
// control_cleanup
// file control.h line 24
extern signed int control_cleanup(struct ctx *ctx_p);
// control_dump
// file control.c line 46
signed int control_dump(struct ctx *ctx_p, struct clsyncsock *clsyncsock_p, struct sockcmd *sockcmd_p);
// control_error
// file control.c line 40
static inline signed int control_error(struct clsyncsock *clsyncsock_p, struct sockcmd *sockcmd_p, const char * const funct, const char * const args);
// control_loop
// file control.c line 96
signed int control_loop(struct ctx *ctx_p);
// control_procclsyncsock
// file control.c line 56
signed int control_procclsyncsock(struct socket_sockthreaddata *arg, struct sockcmd *sockcmd_p);
// control_run
// file control.h line 23
extern signed int control_run(struct ctx *ctx_p);
// ctx_check
// file main.c line 1846
signed int ctx_check(struct ctx *ctx_p);
// ctx_cleanup
// file main.c line 2225
void ctx_cleanup(struct ctx *ctx_p);
// ctx_set
// file main.c line 2205
signed int ctx_set(struct ctx *ctx_p, const char * const parameter_name, const char * const parameter_value);
// dir_gotevent
// file mon_gio.c line 103
static void dir_gotevent(struct _GFileMonitor *filemon, struct _GFile *file, struct _GFile *file_other, enum anonymous$8 event, void *arg);
// dlclose
// file /usr/include/dlfcn.h line 60
extern signed int dlclose(void *);
// dlerror
// file /usr/include/dlfcn.h line 82
extern char * dlerror(void);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// dprintf
// file /usr/include/stdio.h line 415
extern signed int dprintf(signed int, const char *, ...);
// eidup
// file sync.c line 97
void * eidup(void *ei_gp);
// endmntent
// file /usr/include/mntent.h line 87
extern signed int endmntent(struct _IO_FILE *);
// error_deinit
// file error.c line 370
extern void error_deinit();
// error_init
// file error.c line 339
extern void error_init(void *_outputmethod, signed int *_quiet, signed int *_verbose, signed int *_debug);
// error_init_ipc
// file error.c line 351
extern void error_init_ipc(enum ipc_type _ipc_type);
// event_free
// file mon_gio.c line 59
static inline void event_free(struct event *ev);
// event_pop
// file mon_gio.c line 90
static inline struct event * event_pop();
// event_push
// file mon_gio.c line 64
static inline signed int event_push(char *path, unsigned long int handle_id, enum anonymous$8 event, enum eventobjtype objtype_event, enum eventobjtype objtype_old, enum eventobjtype objtype_new);
// evinfo_initialevmask
// file sync.c line 1209
static inline void evinfo_initialevmask(struct ctx *ctx_p, struct eventinfo *evinfo_p, signed int isdir);
// evinfo_merge
// file sync.c line 106
static inline void evinfo_merge(struct ctx *ctx_p, struct eventinfo *evinfo_dst, struct eventinfo *evinfo_src);
// exec_argv
// file sync.c line 506
signed int exec_argv(char **argv, signed int *child_pid);
// execvp
// file /usr/include/unistd.h line 578
extern signed int execvp(const char *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// exitcode_process
// file sync.c line 168
signed int exitcode_process(struct ctx *ctx_p, signed int exitcode);
// fchown
// file /usr/include/unistd.h line 478
extern signed int fchown(signed int, unsigned int, unsigned int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fd2fpath_malloc
// file fileutils.c line 26
char * fd2fpath_malloc(signed int fd);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fileischanged
// file sync.c line 1946
signed int fileischanged(struct ctx *ctx_p, struct indexes *indexes_p, const char *path_rel, struct stat64 *lstat_p, signed int is_deleted);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// fileutils_calcdirlevel
// file fileutils.c line 131
signed short int fileutils_calcdirlevel(const char *path);
// fileutils_copy
// file fileutils.c line 75
signed int fileutils_copy(const char *path_from, const char *path_to);
// finish_iteration
// file sync.c line 84
static inline void finish_iteration(struct ctx *ctx_p);
// flush_stderr
// file error.c line 79
static void flush_stderr(signed int level);
// flush_stdout
// file error.c line 84
static void flush_stdout(signed int level);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fork_helper
// file main.c line 462
signed int fork_helper();
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_filemondat
// file mon_gio.c line 343
void free_filemondat(void *_fmdat);
// ftruncate
// file /usr/include/unistd.h line 1016
extern signed int ftruncate(signed int, signed long int);
// fts_close
// file /usr/include/fts.h line 124
signed int fts_close(struct anonymous$16 *);
// fts_open
// file /usr/include/fts.h line 125
struct anonymous$16 * fts_open(char * const *, signed int, signed int (*)(const struct _ftsent **, const struct _ftsent **));
// fts_read
// file /usr/include/fts.h line 127
struct _ftsent * fts_read(struct anonymous$16 *);
// fts_set
// file /usr/include/fts.h line 128
signed int fts_set(struct anonymous$16 *, struct _ftsent *, signed int);
// fwrite
// file /usr/include/stdio.h line 715
extern unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// g_direct_equal
// file /usr/include/glib-2.0/glib/ghash.h line 180
extern signed int g_direct_equal(const void *, const void *);
// g_direct_hash
// file /usr/include/glib-2.0/glib/ghash.h line 178
extern unsigned int g_direct_hash(const void *);
// g_file_get_path
// file /usr/include/glib-2.0/gio/gfile.h line 619
extern char * g_file_get_path(struct _GFile *);
// g_file_monitor_directory
// file /usr/include/glib-2.0/gio/gfile.h line 1098
extern struct _GFileMonitor * g_file_monitor_directory(struct _GFile *, enum anonymous$9, struct _GCancellable *, struct _GError **);
// g_file_new_for_path
// file /usr/include/glib-2.0/gio/gfile.h line 595
extern struct _GFile * g_file_new_for_path(const char *);
// g_file_query_file_type
// file /usr/include/glib-2.0/gio/gfile.h line 772
extern enum anonymous$6 g_file_query_file_type(struct _GFile *, enum anonymous$7, struct _GCancellable *);
// g_free
// file /usr/include/glib-2.0/glib/gmem.h line 71
extern void g_free(void *);
// g_hash_table_destroy
// file /usr/include/glib-2.0/glib/ghash.h line 65
extern void g_hash_table_destroy(struct _GHashTable *);
// g_hash_table_dup
// file glibex.c line 43
extern struct _GHashTable * g_hash_table_dup(struct _GHashTable *src, unsigned int (*hash_funct)(const void *), signed int (*key_equal_funct)(const void *, const void *), void (*key_destroy_funct)(void *), void (*value_destroy_funct)(void *), void * (*key_dup_funct)(void *), void * (*value_dup_funct)(void *));
// g_hash_table_dup::hash_funct$object
//
unsigned int hash_funct$object(const void *);
// g_hash_table_dup::key_destroy_funct$object
//
void key_destroy_funct$object(void *);
// g_hash_table_dup::key_dup_funct$object
//
void * key_dup_funct$object(void *);
// g_hash_table_dup::key_equal_funct$object
//
signed int key_equal_funct$object(const void *, const void *);
// g_hash_table_dup::value_destroy_funct$object
//
void value_destroy_funct$object(void *);
// g_hash_table_dup::value_dup_funct$object
//
void * value_dup_funct$object(void *);
// g_hash_table_dup_item
// file glibex.c line 33
void g_hash_table_dup_item(void *k, void *v, void *arg_gp);
// g_hash_table_dup_item::1::k_dup_funct$object
//
void * k_dup_funct$object(void *);
// g_hash_table_dup_item::1::v_dup_funct$object
//
void * v_dup_funct$object(void *);
// g_hash_table_foreach
// file /usr/include/glib-2.0/glib/ghash.h line 99
extern void g_hash_table_foreach(struct _GHashTable *, void (*)(void *, void *, void *), void *);
// g_hash_table_foreach_remove
// file /usr/include/glib-2.0/glib/ghash.h line 107
extern unsigned int g_hash_table_foreach_remove(struct _GHashTable *, signed int (*)(void *, void *, void *), void *);
// g_hash_table_insert
// file /usr/include/glib-2.0/glib/ghash.h line 67
extern signed int g_hash_table_insert(struct _GHashTable *, void *, void *);
// g_hash_table_lookup
// file /usr/include/glib-2.0/glib/ghash.h line 88
extern void * g_hash_table_lookup(struct _GHashTable *, const void *);
// g_hash_table_new_full
// file /usr/include/glib-2.0/glib/ghash.h line 60
extern struct _GHashTable * g_hash_table_new_full(unsigned int (*)(const void *), signed int (*)(const void *, const void *), void (*)(void *), void (*)(void *));
// g_hash_table_remove
// file /usr/include/glib-2.0/glib/ghash.h line 78
extern signed int g_hash_table_remove(struct _GHashTable *, const void *);
// g_hash_table_remove_all
// file /usr/include/glib-2.0/glib/ghash.h line 81
extern void g_hash_table_remove_all(struct _GHashTable *);
// g_hash_table_replace
// file /usr/include/glib-2.0/glib/ghash.h line 71
extern signed int g_hash_table_replace(struct _GHashTable *, void *, void *);
// g_hash_table_size
// file /usr/include/glib-2.0/glib/ghash.h line 115
extern unsigned int g_hash_table_size(struct _GHashTable *);
// g_iteration_stop
// file mon_gio.c line 201
void * g_iteration_stop(void *_timeout_p);
// g_key_file_free
// file /usr/include/glib-2.0/glib/gkeyfile.h line 64
extern void g_key_file_free(struct _GKeyFile *);
// g_key_file_get_value
// file /usr/include/glib-2.0/glib/gkeyfile.h line 119
extern char * g_key_file_get_value(struct _GKeyFile *, const char *, const char *, struct _GError **);
// g_key_file_load_from_file
// file /usr/include/glib-2.0/glib/gkeyfile.h line 69
extern signed int g_key_file_load_from_file(struct _GKeyFile *, const char *, enum anonymous$28, struct _GError **);
// g_key_file_new
// file /usr/include/glib-2.0/glib/gkeyfile.h line 58
extern struct _GKeyFile * g_key_file_new(void);
// g_main_context_iteration
// file /usr/include/glib-2.0/glib/gmain.h line 315
extern signed int g_main_context_iteration(struct _GMainContext *, signed int);
// g_main_context_wakeup
// file /usr/include/glib-2.0/glib/gmain.h line 336
extern void g_main_context_wakeup(struct _GMainContext *);
// g_main_loop_new
// file /usr/include/glib-2.0/glib/gmain.h line 400
extern struct _GMainLoop * g_main_loop_new(struct _GMainContext *, signed int);
// g_signal_connect_data
// file /usr/include/glib-2.0/gobject/gsignal.h line 388
extern unsigned long int g_signal_connect_data(void *, const char *, void (*)(void), void *, void (*)(void *, struct _GClosure *), enum anonymous$5);
// g_signal_handler_disconnect
// file /usr/include/glib-2.0/gobject/gsignal.h line 401
extern void g_signal_handler_disconnect(void *, unsigned long int);
// g_str_equal
// file /usr/include/glib-2.0/glib/ghash.h line 154
extern signed int g_str_equal(const void *, const void *);
// g_str_hash
// file /usr/include/glib-2.0/glib/ghash.h line 157
extern unsigned int g_str_hash(const void *);
// g_tree_dup
// file glibex.c line 66
extern struct _GTree * g_tree_dup(struct _GTree *src, signed int (*key_compare_func)(const void *, const void *, void *), void *key_compare_data, void (*key_destroy_func)(void *), void (*value_destroy_func)(void *), void * (*key_dup_funct)(void *), void * (*value_dup_funct)(void *));
// g_tree_dup::key_compare_func$object
//
signed int key_compare_func$object(const void *, const void *, void *);
// g_tree_dup::key_destroy_func$object
//
void key_destroy_func$object(void *);
// g_tree_dup::key_dup_funct$object
//
void * key_dup_funct$object(void *);
// g_tree_dup::value_destroy_func$object
//
void value_destroy_func$object(void *);
// g_tree_dup::value_dup_funct$object
//
void * value_dup_funct$object(void *);
// g_tree_dup_item
// file glibex.c line 56
signed int g_tree_dup_item(void *k, void *v, void *arg_gp);
// g_tree_dup_item::1::k_dup_funct$object
//
void * k_dup_funct$object(void *);
// g_tree_dup_item::1::v_dup_funct$object
//
void * v_dup_funct$object(void *);
// g_tree_foreach
// file /usr/include/glib-2.0/glib/gtree.h line 83
extern void g_tree_foreach(struct _GTree *, signed int (*)(void *, void *, void *), void *);
// g_tree_new_full
// file /usr/include/glib-2.0/glib/gtree.h line 50
extern struct _GTree * g_tree_new_full(signed int (*)(const void *, const void *, void *), void *, void (*)(void *), void (*)(void *));
// g_tree_replace
// file /usr/include/glib-2.0/glib/gtree.h line 65
extern void g_tree_replace(struct _GTree *, void *, void *);
// getegid
// file /usr/include/unistd.h line 684
extern unsigned int getegid(void);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// geteuid
// file /usr/include/unistd.h line 678
extern unsigned int geteuid(void);
// getgid
// file /usr/include/unistd.h line 681
extern unsigned int getgid(void);
// getgrnam
// file /usr/include/grp.h line 110
extern struct group * getgrnam(const char *);
// getline
// file /usr/include/stdio.h line 678
extern signed long int getline(char ** restrict , unsigned long int *, struct _IO_FILE *);
// getmntent
// file /usr/include/mntent.h line 71
extern struct mntent * getmntent(struct _IO_FILE *);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getppid
// file /usr/include/unistd.h line 631
extern signed int getppid(void);
// getpwnam
// file /usr/include/pwd.h line 116
extern struct passwd * getpwnam(const char *);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// getsubopt
// file /usr/include/stdlib.h line 898
extern signed int getsubopt(char ** restrict , char * const * restrict , char ** restrict );
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// gio_add_watch_dir
// file mon_gio.h line 22
extern signed int gio_add_watch_dir(struct ctx *ctx_p, struct indexes *indexes_p, const char * const accpath);
// gio_deinit
// file mon_gio.h line 24
extern signed int gio_deinit(struct ctx *ctx_p);
// gio_handle
// file mon_gio.h line 21
extern signed int gio_handle(struct ctx *ctx_p, struct indexes *indexes_p);
// gio_init
// file mon_gio.h line 23
extern signed int gio_init(struct ctx *ctx_p);
// gio_wait
// file mon_gio.h line 20
extern signed int gio_wait(struct ctx *ctx_p, struct indexes *indexes_p, struct timeval *tv_p);
// gio_wait_now
// file mon_gio.c line 238
static inline signed int gio_wait_now(struct ctx *ctx_p, struct indexes *indexes_p, struct timeval *tv_p);
// gkf_parse
// file main.c line 1752
void gkf_parse(struct ctx *ctx_p, struct _GKeyFile *gkf, enum paramsource_enum paramsource);
// hook_preexit
// file sync.c line 3174
void hook_preexit(struct ctx *ctx_p);
// ht_fpath_isincluded
// file sync.c line 2202
struct eventinfo * ht_fpath_isincluded(struct _GHashTable *ht, const char * const fpath);
// indexes_add_wd
// file indexes.h line 89
static inline signed int indexes_add_wd(struct indexes *indexes_p, signed int wd, const char *fpath_const, unsigned long int fpathlen);
// indexes_addexclude
// file indexes.h line 137
static inline signed int indexes_addexclude(struct indexes *indexes_p, char *fpath, enum eventinfo_flags flags, enum queue_id queue_id);
// indexes_addexclude_aggr
// file indexes.h line 144
static inline signed int indexes_addexclude_aggr(struct indexes *indexes_p, char *fpath, enum eventinfo_flags flags);
// indexes_fileinfo
// file indexes.h line 176
static inline struct fileinfo * indexes_fileinfo(struct indexes *indexes_p, const char *fpath);
// indexes_fileinfo_add
// file indexes.h line 180
static inline signed int indexes_fileinfo_add(struct indexes *indexes_p, const char *fpath_const, struct fileinfo *fi);
// indexes_fpath2ei
// file indexes.h line 101
static inline struct eventinfo * indexes_fpath2ei(struct indexes *indexes_p, const char *fpath);
// indexes_fpath2ei_add
// file indexes.h line 105
static inline signed int indexes_fpath2ei_add(struct indexes *indexes_p, char *fpath, struct eventinfo *evinfo);
// indexes_fpath2wd
// file indexes.h line 78
static inline signed int indexes_fpath2wd(struct indexes *indexes_p, const char *fpath);
// indexes_lookupinqueue
// file indexes.h line 120
static inline struct eventinfo * indexes_lookupinqueue(struct indexes *indexes_p, const char *fpath, enum queue_id queue_id);
// indexes_outaggr_add
// file indexes.h line 161
static inline signed int indexes_outaggr_add(struct indexes *indexes_p, char *outline, enum eventinfo_flags flags);
// indexes_queueevent
// file indexes.h line 112
static inline signed int indexes_queueevent(struct indexes *indexes_p, char *fpath, struct eventinfo *evinfo, enum queue_id queue_id);
// indexes_queuelen
// file indexes.h line 124
static inline signed int indexes_queuelen(struct indexes *indexes_p, enum queue_id queue_id);
// indexes_remove_bywd
// file indexes.h line 53
static inline signed int indexes_remove_bywd(struct indexes *indexes_p, signed int wd);
// indexes_removefromqueue
// file indexes.h line 128
static inline signed int indexes_removefromqueue(struct indexes *indexes_p, char *fpath, enum queue_id queue_id);
// indexes_wd2fpath
// file indexes.h line 71
static inline char * indexes_wd2fpath(struct indexes *indexes_p, signed int wd);
// inotify_add_watch
// file /usr/include/x86_64-linux-gnu/sys/inotify.h line 91
extern signed int inotify_add_watch(signed int, const char *, unsigned int);
// inotify_add_watch_dir
// file mon_inotify.h line 22
extern signed int inotify_add_watch_dir(struct ctx *ctx_p, struct indexes *indexes_p, const char * const accpath);
// inotify_deinit
// file mon_inotify.h line 23
extern signed int inotify_deinit(struct ctx *ctx_p);
// inotify_handle
// file mon_inotify.h line 21
extern signed int inotify_handle(struct ctx *ctx_p, struct indexes *indexes_p);
// inotify_init1
// file /usr/include/x86_64-linux-gnu/sys/inotify.h line 87
extern signed int inotify_init1(signed int);
// inotify_wait
// file mon_inotify.h line 20
extern signed int inotify_wait(struct ctx *ctx_p, struct indexes *indexes_p, struct timeval *tv_p);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// lstat64
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 275
extern signed int lstat64(const char *, struct stat64 *);
// main_cleanup
// file main.c line 2275
signed int main_cleanup(struct ctx *ctx_p);
// main_rehash
// file main.c line 2285
signed int main_rehash(struct ctx *ctx_p);
// main_status_update
// file main.c line 2304
signed int main_status_update(struct ctx *ctx_p);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memory_init
// file malloc.c line 165
extern signed int memory_init();
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// mkdirat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 327
extern signed int mkdirat(signed int, const char *, unsigned int);
// mkdirat_open
// file fileutils.c line 171
signed int mkdirat_open(const char * const dir_path, signed int dirfd_parent, unsigned int dir_mode);
// mkdtemp
// file /usr/include/stdlib.h line 662
extern char * mkdtemp(char *);
// mount
// file /usr/include/x86_64-linux-gnu/sys/mount.h line 135
extern signed int mount(const char *, const char *, const char *, unsigned long int, const void *);
// notify_wait
// file sync.c line 3059
signed int notify_wait(struct ctx *ctx_p, struct indexes *indexes_p);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// openat
// file /usr/include/fcntl.h line 170
extern signed int openat(signed int, const char *, signed int, ...);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// parameter_expand
// file main.c line 642
char * parameter_expand(struct ctx *ctx_p, char *arg, signed int exceptionflags, signed int *macro_count_p, signed int *expand_count_p, const char * (*parameter_get)(const char *, void *), void *parameter_get_arg);
// parameter_expand::parameter_get$object
//
const char * parameter_get$object(const char *, void *);
// parameter_get
// file main.c line 559
const char * parameter_get(const char *variable_name, void *_ctx_p);
// parameter_get_wmacro
// file main.c line 595
const char * parameter_get_wmacro(const char *variable_name, void *_ctx_p);
// parent_isalive
// file main.c line 417
signed int parent_isalive();
// parse_customsignals
// file main.c line 832
static inline signed int parse_customsignals(struct ctx *ctx_p, char *arg);
// parse_parameter
// file main.c line 915
static signed int parse_parameter(struct ctx *ctx_p, unsigned short int param_id, char *arg, enum paramsource_enum paramsource);
// parse_rules_fromfile
// file rules.h line 20
extern signed int parse_rules_fromfile(struct ctx *ctx_p);
// parse_text_data
// file socket.c line 415
static inline signed int parse_text_data(struct sockcmd *sockcmd_p, char *args, unsigned long int args_len);
// pivot_root
// file syscalls.h line 20
extern signed int pivot_root(const char *, const char *);
// prctl
// file /usr/include/x86_64-linux-gnu/sys/prctl.h line 27
extern signed int prctl(signed int, ...);
// printf_stderr
// file error.c line 48
static signed int printf_stderr(const char *fmt, ...);
// printf_stdout
// file error.c line 59
static signed int printf_stdout(const char *fmt, ...);
// privileged_deinit
// file privileged.h line 139
extern signed int privileged_deinit(struct ctx *ctx_p);
// privileged_init
// file privileged.h line 138
extern signed int privileged_init(struct ctx *ctx_p);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous$1 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous$1 *);
// pthread_cond_destroy_shared
// file pthreadex.c line 54
extern signed int pthread_cond_destroy_shared(union anonymous$1 *cond_p);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$1 *, const union anonymous$0 *);
// pthread_cond_init_shared
// file pthreadex.c line 43
extern signed int pthread_cond_init_shared(union anonymous$1 **cond_p);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous$1 *, union anonymous *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$1 *, union anonymous *);
// pthread_condattr_init
// file /usr/include/pthread.h line 1010
extern signed int pthread_condattr_init(union anonymous$0 *);
// pthread_condattr_setpshared
// file /usr/include/pthread.h line 1024
extern signed int pthread_condattr_setpshared(union anonymous$0 *, signed int);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_kill
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 35
extern signed int pthread_kill(unsigned long int, signed int);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous *);
// pthread_mutex_destroy_shared
// file pthreadex.h line 23
extern signed int pthread_mutex_destroy_shared(union anonymous *mutex_p);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous *, const union anonymous$0 *);
// pthread_mutex_init_shared
// file pthreadex.h line 22
extern signed int pthread_mutex_init_shared(union anonymous **mutex_p);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous *);
// pthread_mutex_reltimedlock
// file pthreadex.h line 26
extern signed int pthread_mutex_reltimedlock(union anonymous *mutex_p, signed long int tv_sec, signed long int tv_nsec);
// pthread_mutex_timedlock
// file /usr/include/pthread.h line 769
extern signed int pthread_mutex_timedlock(union anonymous *, struct timespec *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_trylock(union anonymous *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous *);
// pthread_mutexattr_init
// file /usr/include/pthread.h line 808
extern signed int pthread_mutexattr_init(union anonymous$0 *);
// pthread_mutexattr_setpshared
// file /usr/include/pthread.h line 822
extern signed int pthread_mutexattr_setpshared(union anonymous$0 *, signed int);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_sigmask
// file /usr/include/x86_64-linux-gnu/bits/sigthread.h line 30
extern signed int pthread_sigmask(signed int, const struct anonymous$15 *, struct anonymous$15 *);
// pthread_spin_init
// file /usr/include/pthread.h line 1046
extern signed int pthread_spin_init(volatile signed int *, signed int);
// pthread_spin_lock
// file /usr/include/pthread.h line 1054
extern signed int pthread_spin_lock(volatile signed int *);
// pthread_spin_unlock
// file /usr/include/pthread.h line 1062
extern signed int pthread_spin_unlock(volatile signed int *);
// pthread_tryjoin_np
// file /usr/include/pthread.h line 257
extern signed int pthread_tryjoin_np(unsigned long int, void **);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// readlink
// file /usr/include/unistd.h line 809
extern signed long int readlink(const char *, char *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// realpath
// file /usr/include/stdlib.h line 733
extern char * realpath(const char *, char *);
// recognize_event
// file mon_inotify.c line 38
static inline void recognize_event(struct recognize_event_return *r, unsigned int event);
// recv
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 156
extern signed long int recv(signed int, void *, unsigned long int, signed int);
// regcomp
// file /usr/include/regex.h line 562
extern signed int regcomp(struct re_pattern_buffer *, const char *, signed int);
// regerror
// file /usr/include/regex.h line 571
extern unsigned long int regerror(signed int, const struct re_pattern_buffer *, char *, unsigned long int);
// regexec
// file /usr/include/regex.h line 566
extern signed int regexec(const struct re_pattern_buffer *, const char *, unsigned long int, struct anonymous$10 *, signed int);
// regfree
// file /usr/include/regex.h line 574
extern void regfree(struct re_pattern_buffer *);
// rewind
// file /usr/include/stdio.h line 759
extern void rewind(struct _IO_FILE *);
// rmdir
// file /usr/include/unistd.h line 835
extern signed int rmdir(const char *);
// rsync_aggrout
// file sync.c line 2585
signed int rsync_aggrout(void *outline_gp, void *flags_gp, void *arg_gp);
// rsync_escape
// file sync.c line 2516
const char * rsync_escape(const char *path);
// rsync_escape_cleanup
// file sync.c line 2511
void rsync_escape_cleanup();
// rsync_listpush
// file sync.c line 2601
static inline signed int rsync_listpush(struct indexes *indexes_p, const char *fpath, unsigned long int fpath_len, enum eventinfo_flags flags, signed int *linescount_p);
// rsync_outline
// file sync.c line 2565
static inline signed int rsync_outline(struct _IO_FILE *outf, char *outline, enum eventinfo_flags flags);
// rule_complete
// file rules.c line 27
signed int rule_complete(struct rule *rule_p, char *expr, unsigned long int *rules_count_p);
// rules_getperm
// file rules.c line 371
extern enum ruleaction_enum rules_getperm(const char *fpath, unsigned int st_mode, struct rule *rules_p, enum ruleaction_enum ruleactions);
// rules_search_getperm
// file rules.c line 300
extern enum ruleaction_enum rules_search_getperm(const char *fpath, unsigned int st_mode, struct rule *rules_p, const enum ruleaction_enum ruleaction, struct rule **rule_pp);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$3 *, struct anonymous$3 *, struct anonymous$3 *, struct timeval *);
// send
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 149
extern signed long int send(signed int, const void *, unsigned long int, signed int);
// setbuffer
// file /usr/include/stdio.h line 343
extern void setbuffer(struct _IO_FILE *, char *, unsigned long int);
// setegid
// file /usr/include/unistd.h line 727
extern signed int setegid(unsigned int);
// setenv
// file /usr/include/stdlib.h line 584
extern signed int setenv(const char *, const char *, signed int);
// setenv_iteration
// file sync.c line 75
static inline void setenv_iteration(unsigned int iteration_num);
// seteuid
// file /usr/include/unistd.h line 710
extern signed int seteuid(unsigned int);
// setgid
// file /usr/include/unistd.h line 717
extern signed int setgid(unsigned int);
// sethandler_sigchld
// file main.c line 440
signed int sethandler_sigchld(void (*handler)());
// sethandler_sigchld::handler$object
//
void handler$object();
// setmntent
// file /usr/include/mntent.h line 66
extern struct _IO_FILE * setmntent(const char *, const char *);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// setuid
// file /usr/include/unistd.h line 700
extern signed int setuid(unsigned int);
// shm_calloc
// file malloc.c line 221
extern void * shm_calloc(unsigned long int nmemb, unsigned long int size);
// shm_free
// file malloc.c line 238
extern void shm_free(void *ptr);
// shm_malloc
// file malloc.c line 212
extern void * shm_malloc(unsigned long int size);
// shm_malloc_try
// file malloc.c line 183
extern void * shm_malloc_try(unsigned long int size);
// shmat
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 56
extern void * shmat(signed int, const void *, signed int);
// shmctl
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 50
extern signed int shmctl(signed int, signed int, struct shmid_ds *);
// shmdt
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 60
extern signed int shmdt(const void *);
// shmget
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 53
extern signed int shmget(signed int, unsigned long int, signed int);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous$15 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous$15 *);
// sigfillset
// file /usr/include/signal.h line 218
extern signed int sigfillset(struct anonymous$15 *);
// sigismember
// file /usr/include/signal.h line 227
extern signed int sigismember(const struct anonymous$15 *, signed int);
// signal
// file /usr/include/signal.h line 102
extern void (*signal(signed int, void (*)(signed int)))(signed int);
// sigwait
// file /usr/include/signal.h line 270
extern signed int sigwait(const struct anonymous$15 *, signed int *);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// so_call_rsync
// file sync.c line 795
static inline signed int so_call_rsync(struct ctx *ctx_p, struct indexes *indexes_p, const char *inclistfile, const char *exclistfile);
// so_call_rsync_finished
// file sync.c line 722
static inline signed int so_call_rsync_finished(struct ctx *ctx_p, const char *inclistfile, const char *exclistfile);
// so_call_rsync_thread
// file sync.c line 750
signed int so_call_rsync_thread(struct threadinfo *threadinfo_p);
// so_call_sync
// file sync.c line 646
static inline signed int so_call_sync(struct ctx *ctx_p, struct indexes *indexes_p, signed int n, struct api_eventinfo *ei);
// so_call_sync_finished
// file sync.c line 584
static inline void so_call_sync_finished(signed int n, struct api_eventinfo *ei);
// so_call_sync_thread
// file sync.c line 605
signed int so_call_sync_thread(struct threadinfo *threadinfo_p);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// socket_accept
// file socket.c line 183
extern struct clsyncsock * socket_accept(signed int sock);
// socket_check
// file socket.c line 122
static inline signed int socket_check(struct clsyncsock *clsyncsock_p);
// socket_check_bysock
// file socket.c line 106
extern signed int socket_check_bysock(signed int sock);
// socket_cleanup
// file socket.c line 139
extern signed int socket_cleanup(struct clsyncsock *clsyncsock_p);
// socket_close
// file socket.c line 152
extern signed int socket_close(struct clsyncsock *clsyncsock_p);
// socket_deinit
// file socket.c line 807
extern signed int socket_deinit();
// socket_gc
// file socket.c line 49
signed int socket_gc();
// socket_init
// file socket.c line 803
extern signed int socket_init();
// socket_listen_unix
// file socket.c line 197
extern struct clsyncsock * socket_listen_unix(const char * const socket_path);
// socket_new
// file socket.c line 126
struct clsyncsock * socket_new(signed int clsyncsock_sock);
// socket_overflow_fix
// file socket.c line 386
static inline signed int socket_overflow_fix(char *buf, char **data_start_p, char **data_end_p);
// socket_procclsyncsock
// file socket.c line 616
extern signed int socket_procclsyncsock(struct socket_sockthreaddata *arg);
// socket_procclsyncsock::1::procfunct$object
//
signed int procfunct$object(struct socket_sockthreaddata *, struct sockcmd *);
// socket_recv
// file socket.c line 485
extern signed int socket_recv(struct clsyncsock *clsyncsock, struct sockcmd *sockcmd_p);
// socket_reply
// file socket.c line 326
extern signed int socket_reply(struct clsyncsock *clsyncsock_p, struct sockcmd *sockcmd_p, enum sockcmd_id cmd_id, ...);
// socket_send
// file socket.c line 338
extern signed int socket_send(struct clsyncsock *clsyncsock_p, enum sockcmd_id cmd_id, ...);
// socket_send_cb
// file socket.c line 349
extern signed int socket_send_cb(struct clsyncsock *clsyncsock_p, enum sockcmd_id cmd_id, signed int (*cb)(struct socket_sockthreaddata *, struct sockcmd *, void *), void *cb_arg, ...);
// socket_send_cb::cb$object
//
signed int cb$object(struct socket_sockthreaddata *, struct sockcmd *, void *);
// socket_sendinvalid
// file socket.c line 609
extern signed int socket_sendinvalid(struct clsyncsock *clsyncsock_p, struct sockcmd *sockcmd_p);
// socket_thread_attach
// file socket.c line 782
extern struct socket_sockthreaddata * socket_thread_attach(struct clsyncsock *clsyncsock_p);
// socket_thread_delete
// file socket.c line 158
signed int socket_thread_delete(struct socket_sockthreaddata *threaddata_p);
// socket_thread_new
// file socket.c line 741
struct socket_sockthreaddata * socket_thread_new();
// socket_thread_start
// file socket.c line 794
extern signed int socket_thread_start(struct socket_sockthreaddata *threaddata_p);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// srand
// file /usr/include/stdlib.h line 376
extern void srand(unsigned int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// stat_diff
// file fileutils.c line 209
unsigned int stat_diff(struct stat64 *a, struct stat64 *b);
// str_splitargs
// file stringex.c line 72
signed int str_splitargs(char *_instr, signed int (*handler)(char *, unsigned long int, void *), void *arg);
// str_splitargs::handler$object
//
signed int handler$object(char *, unsigned long int, void *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strpbrk
// file /usr/include/string.h line 314
extern char * strpbrk(const char *, const char *);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// sync_customargv
// file sync.c line 1475
static char ** sync_customargv(struct ctx *ctx_p, struct dosync_arg *dosync_arg_p, struct synchandler_args *args_p);
// sync_dosync
// file sync.c line 1926
signed int sync_dosync(const char *fpath, unsigned int evmask, struct ctx *ctx_p, struct indexes *indexes_p);
// sync_dosync_exec
// file sync.c line 1899
static inline signed int sync_dosync_exec(struct ctx *ctx_p, struct indexes *indexes_p, const char *evmask_str, const char *fpath);
// sync_dump
// file sync.c line 3524
extern signed int sync_dump(struct ctx *ctx_p, const char * const dir_path);
// sync_dump_liststep
// file sync.c line 3452
void sync_dump_liststep(void *fpath_gp, void *evinfo_gp, void *arg_gp);
// sync_dump_thread
// file sync.c line 3485
signed int sync_dump_thread(struct threadinfo *threadinfo_p, void *_arg);
// sync_exec_argv
// file sync.c line 1011
signed int sync_exec_argv(struct ctx *ctx_p, struct indexes *indexes_p, signed int (*callback)(struct ctx *, struct thread_callbackfunct_arg *), struct thread_callbackfunct_arg *callback_arg_p, char **argv);
// sync_exec_argv::callback$object
//
signed int callback$object(struct ctx *, struct thread_callbackfunct_arg *);
// sync_exec_argv_thread
// file sync.c line 1128
static inline signed int sync_exec_argv_thread(struct ctx *ctx_p, struct indexes *indexes_p, signed int (*callback)(struct ctx *, struct thread_callbackfunct_arg *), struct thread_callbackfunct_arg *callback_arg_p, char **argv);
// sync_exec_argv_thread::callback$object
//
signed int callback$object(struct ctx *, struct thread_callbackfunct_arg *);
// sync_idle
// file sync.c line 3011
signed int sync_idle(struct ctx *ctx_p, struct indexes *indexes_p);
// sync_idle_dosync_collectedevents
// file sync.c line 2875
signed int sync_idle_dosync_collectedevents(struct ctx *ctx_p, struct indexes *indexes_p);
// sync_idle_dosync_collectedevents_aggrqueue
// file sync.c line 2413
signed int sync_idle_dosync_collectedevents_aggrqueue(enum queue_id queue_id, struct ctx *ctx_p, struct indexes *indexes_p, struct dosync_arg *dosync_arg);
// sync_idle_dosync_collectedevents_cleanup
// file sync.c line 2366
signed int sync_idle_dosync_collectedevents_cleanup(struct ctx *ctx_p, struct thread_callbackfunct_arg *arg_p);
// sync_idle_dosync_collectedevents_commitpart
// file sync.c line 2679
signed int sync_idle_dosync_collectedevents_commitpart(struct dosync_arg *dosync_arg_p);
// sync_idle_dosync_collectedevents_listcreate
// file sync.c line 2483
signed int sync_idle_dosync_collectedevents_listcreate(struct dosync_arg *dosync_arg_p, char *name);
// sync_idle_dosync_collectedevents_listpush
// file sync.c line 2796
void sync_idle_dosync_collectedevents_listpush(void *fpath_gp, void *evinfo_gp, void *arg_gp);
// sync_idle_dosync_collectedevents_rsync_exclistpush
// file sync.c line 2645
signed int sync_idle_dosync_collectedevents_rsync_exclistpush(void *fpath_gp, void *flags_gp, void *arg_gp);
// sync_idle_dosync_collectedevents_uniqfname
// file sync.c line 2464
signed int sync_idle_dosync_collectedevents_uniqfname(struct ctx *ctx_p, char *fpath, char *name);
// sync_inclist_rotate
// file sync.c line 2756
void sync_inclist_rotate(struct ctx *ctx_p, struct dosync_arg *dosync_arg_p);
// sync_indexes_fpath2ei_addfixed
// file sync.c line 1979
static inline signed int sync_indexes_fpath2ei_addfixed(struct ctx *ctx_p, struct indexes *indexes_p, const char *fpath, struct eventinfo *evinfo);
// sync_initialsync
// file sync.c line 1566
signed int sync_initialsync(const char *path, struct ctx *ctx_p, struct indexes *indexes_p, enum initsync initsync);
// sync_initialsync_finish
// file sync.c line 1561
static inline signed int sync_initialsync_finish(struct ctx *ctx_p, enum initsync initsync, signed int ret);
// sync_initialsync_walk
// file sync.c line 1255
signed int sync_initialsync_walk(struct ctx *ctx_p, const char *dirpath, struct indexes *indexes_p, enum queue_id queue_id, enum initsync initsync);
// sync_islocked
// file sync.c line 2256
static inline signed int sync_islocked(const char * const fpath);
// sync_loop
// file sync.c line 3188
signed int sync_loop(struct ctx *ctx_p, struct indexes *indexes_p);
// sync_mark_walk
// file sync.c line 1718
signed int sync_mark_walk(struct ctx *ctx_p, const char *dirpath, struct indexes *indexes_p);
// sync_notify_init
// file sync.c line 1833
signed int sync_notify_init(struct ctx *ctx_p);
// sync_notify_mark
// file sync.c line 1684
signed int sync_notify_mark(struct ctx *ctx_p, const char *accpath, const char *path, unsigned long int pathlen, struct indexes *indexes_p);
// sync_parameter_get
// file sync.h line 100
extern const char * sync_parameter_get(const char *variable_name, void *_dosync_arg_p);
// sync_path_abs2rel
// file sync.c line 943
char * sync_path_abs2rel(struct ctx *ctx_p, const char *path_abs, unsigned long int path_abs_len, unsigned long int *path_rel_len_p, char *path_rel_oldptr);
// sync_path_rel2abs
// file sync.c line 913
char * sync_path_rel2abs(struct ctx *ctx_p, const char *path_rel, unsigned long int path_rel_len, unsigned long int *path_abs_len_p, char *path_abs_oldptr);
// sync_prequeue_loadmark
// file sync.c line 1998
extern signed int sync_prequeue_loadmark(signed int monitored, struct ctx *ctx_p, struct indexes *indexes_p, const char *path_full, const char *path_rel, struct stat64 *lstat_p, enum eventobjtype objtype_old, enum eventobjtype objtype_new, unsigned int event_mask, signed int event_wd, unsigned int st_mode, signed long int st_size, char **path_buf_p, unsigned long int *path_buf_len_p, struct eventinfo *evinfo);
// sync_prequeue_unload
// file sync.c line 2400
extern signed int sync_prequeue_unload(struct ctx *ctx_p, struct indexes *indexes_p);
// sync_queuesync
// file sync.c line 1172
static signed int sync_queuesync(const char *fpath_rel, struct eventinfo *evinfo, struct ctx *ctx_p, struct indexes *indexes_p, enum queue_id queue_id);
// sync_queuesync_wrapper
// file sync.c line 2389
void sync_queuesync_wrapper(void *fpath_gp, void *evinfo_gp, void *arg_gp);
// sync_run
// file sync.h line 68
extern signed int sync_run(struct ctx *ctx_p);
// sync_seqid
// file sync.c line 71
static inline unsigned int sync_seqid();
// sync_sig_int
// file sync.c line 3315
void sync_sig_int(signed int signal);
// sync_sigchld
// file sync.c line 3616
void sync_sigchld();
// sync_sighandler
// file sync.c line 3624
signed int sync_sighandler(struct sighandler_arg *sighandler_arg_p);
// sync_switch_state
// file sync.c line 3357
signed int sync_switch_state(struct ctx *ctx_p, unsigned long int pthread_parent, signed int newstate);
// sync_term
// file sync.c line 3730
extern signed int sync_term(signed int exitcode);
// sync_tryforcecycle
// file sync.c line 3323
signed int sync_tryforcecycle(struct ctx *ctx_p, unsigned long int pthread_parent);
// sync_trylocked
// file sync.c line 2341
signed int sync_trylocked(void *fpath_gp, void *evinfo_gp, void *arg_gp);
// synchandler_arg
// file main.c line 770
static inline signed int synchandler_arg(char *arg, unsigned long int arg_len, void *_ctx_p, enum shargsid shargsid);
// synchandler_arg0
// file main.c line 810
static signed int synchandler_arg0(char *arg, unsigned long int arg_len, void *_ctx_p);
// synchandler_arg1
// file main.c line 814
static signed int synchandler_arg1(char *arg, unsigned long int arg_len, void *_ctx_p);
// syntax
// file main.c line 368
signed int syntax();
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// syslog_buf
// file error.c line 132
static signed int syslog_buf(const char *fmt, ...);
// syslog_flush
// file error.c line 143
static void syslog_flush(signed int level);
// thread_cleanup
// file sync.c line 445
signed int thread_cleanup(struct ctx *ctx_p);
// thread_del_bynum
// file sync.c line 318
signed int thread_del_bynum(signed int thread_num);
// thread_exit
// file sync.c line 552
static inline signed int thread_exit(struct threadinfo *threadinfo_p, signed int exitcode);
// thread_gc
// file sync.c line 365
signed int thread_gc(struct ctx *ctx_p);
// thread_info
// file sync.c line 180
extern struct threadsinfo * thread_info();
// thread_new
// file sync.c line 273
struct threadinfo * thread_new();
// thread_nextexpiretime
// file sync.c line 242
extern signed long int thread_nextexpiretime();
// threads_foreach
// file sync.c line 221
extern signed int threads_foreach(signed int (*funct)(struct threadinfo *, void *), enum state_enum state, void *arg);
// threads_foreach::funct$object
//
signed int funct$object(struct threadinfo *, void *);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// umount2
// file /usr/include/x86_64-linux-gnu/sys/mount.h line 143
extern signed int umount2(const char *, signed int);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// unshare
// file /usr/include/x86_64-linux-gnu/bits/sched.h line 85
extern signed int unshare(signed int);
// version
// file main.c line 485
signed int version();
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vprintf_stderr
// file error.c line 70
static signed int vprintf_stderr(const char *fmt, void **args);
// vprintf_stdout
// file error.c line 74
static signed int vprintf_stdout(const char *fmt, void **args);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// vsprintf
// file /usr/include/stdio.h line 379
extern signed int vsprintf(char *, const char *, void **);
// vsyslog_buf
// file error.c line 93
static signed int vsyslog_buf(const char *fmt, void **args);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// waitpid_timed
// file main.c line 391
signed int waitpid_timed(signed int child_pid, signed int *status_p, signed long int sec, signed long int nsec);
// xcalloc
// file malloc.h line 23
extern void * xcalloc(unsigned long int nmemb, unsigned long int size);
// xmalloc
// file malloc.h line 22
extern void * xmalloc(unsigned long int size);
// xrealloc
// file malloc.h line 24
extern void * xrealloc(void *oldptr, unsigned long int size);
// xstrtol
// file main.c line 819
static inline signed long int xstrtol(const char *str, signed int *err);

struct anonymous$16
{
  // fts_cur
  struct _ftsent *fts_cur;
  // fts_child
  struct _ftsent *fts_child;
  // fts_array
  struct _ftsent **fts_array;
  // fts_dev
  unsigned long int fts_dev;
  // fts_path
  char *fts_path;
  // fts_rfd
  signed int fts_rfd;
  // fts_pathlen
  signed int fts_pathlen;
  // fts_nitems
  signed int fts_nitems;
  // fts_compar
  signed int (*fts_compar)(const void *, const void *);
  // fts_options
  signed int fts_options;
};

struct anonymous$25
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous$23
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous$3
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous$15
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous$2
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$10
{
  // rm_so
  signed int rm_so;
  // rm_eo
  signed int rm_eo;
};

struct anonymous$19
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous$22
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous$21
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$20
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous$24
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous$26
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous$19 _kill;
  // _timer
  struct anonymous$20 _timer;
  // _rt
  struct anonymous$21 _rt;
  // _sigchld
  struct anonymous$22 _sigchld;
  // _sigfault
  struct anonymous$23 _sigfault;
  // _sigpoll
  struct anonymous$24 _sigpoll;
  // _sigsys
  struct anonymous$25 _sigsys;
};

struct anonymous$27
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous$26 _sifields;
};

union anonymous$11
{
  // ht_dst
  struct _GHashTable *ht_dst;
  // bt_dst
  struct _GTree *bt_dst;
};

union anonymous$18
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous$27 *, void *);
};

union anonymous$12
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$0
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$4
{
  // v_int
  signed int v_int;
  // v_uint
  unsigned int v_uint;
  // v_long
  signed long int v_long;
  // v_ulong
  unsigned long int v_ulong;
  // v_int64
  signed long int v_int64;
  // v_uint64
  unsigned long int v_uint64;
  // v_float
  float v_float;
  // v_double
  double v_double;
  // v_pointer
  void *v_pointer;
};

union anonymous$1
{
  // __data
  struct anonymous$2 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous$14
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous$17
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _GTypeInstance
{
  // g_class
  struct _GTypeClass *g_class;
};

struct _GObject
{
  // g_type_instance
  struct _GTypeInstance g_type_instance;
  // ref_count
  volatile unsigned int ref_count;
  // qdata
  struct _GData *qdata;
};

struct _GCancellable
{
  // parent_instance
  struct _GObject parent_instance;
  // priv
  struct _GCancellablePrivate *priv;
};

struct _GClosure
{
  // ref_count
  volatile unsigned int ref_count : 15;
  // meta_marshal_nouse
  volatile unsigned int meta_marshal_nouse : 1;
  // n_guards
  volatile unsigned int n_guards : 1;
  // n_fnotifiers
  volatile unsigned int n_fnotifiers : 2;
  // n_inotifiers
  volatile unsigned int n_inotifiers : 8;
  // in_inotify
  volatile unsigned int in_inotify : 1;
  // floating
  volatile unsigned int floating : 1;
  // derivative_flag
  volatile unsigned int derivative_flag : 1;
  // in_marshal
  volatile unsigned int in_marshal : 1;
  // is_invalid
  volatile unsigned int is_invalid : 1;
  // marshal
  void (*marshal)(struct _GClosure *, struct _GValue *, unsigned int, const struct _GValue *, void *, void *);
  // data
  void *data;
  // notifiers
  struct _GClosureNotifyData *notifiers;
};

struct _GClosureNotifyData
{
  // data
  void *data;
  // notify
  void (*notify)(void *, struct _GClosure *);
};

struct _GError
{
  // domain
  unsigned int domain;
  // code
  signed int code;
  // message
  char *message;
};

struct _GFileMonitor
{
  // parent_instance
  struct _GObject parent_instance;
  // priv
  struct _GFileMonitorPrivate *priv;
};

struct _GTypeClass
{
  // g_type
  unsigned long int g_type;
};

struct _GValue
{
  // g_type
  unsigned long int g_type;
  // data
  union anonymous$4 data[2l];
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _ftsent
{
  // fts_cycle
  struct _ftsent *fts_cycle;
  // fts_parent
  struct _ftsent *fts_parent;
  // fts_link
  struct _ftsent *fts_link;
  // fts_number
  signed long int fts_number;
  // fts_pointer
  void *fts_pointer;
  // fts_accpath
  char *fts_accpath;
  // fts_path
  char *fts_path;
  // fts_errno
  signed int fts_errno;
  // fts_symfd
  signed int fts_symfd;
  // fts_pathlen
  unsigned short int fts_pathlen;
  // fts_namelen
  unsigned short int fts_namelen;
  // fts_ino
  unsigned long int fts_ino;
  // fts_dev
  unsigned long int fts_dev;
  // fts_nlink
  unsigned long int fts_nlink;
  // fts_level
  signed short int fts_level;
  // fts_info
  unsigned short int fts_info;
  // fts_flags
  unsigned short int fts_flags;
  // fts_instr
  unsigned short int fts_instr;
  // fts_statp
  struct stat *fts_statp;
  // fts_name
  char fts_name[1l];
};

struct api_eventinfo
{
  // evmask
  unsigned int evmask;
  // flags
  unsigned int flags;
  // path_len
  unsigned long int path_len;
  // path
  const char *path;
  // objtype_old
  enum eventobjtype objtype_old;
  // objtype_new
  enum eventobjtype objtype_new;
};

struct api_functs
{
  // init
  signed int (*init)(struct ctx *, struct indexes *);
  // sync
  signed int (*sync)(signed int, struct api_eventinfo *);
  // rsync
  signed int (*rsync)(const char *, const char *);
  // deinit
  signed int (*deinit)();
};

struct clsynccbqueue
{
  // cmd_num
  unsigned long int cmd_num;
  // callback_funct
  signed int (*callback_funct)(struct socket_sockthreaddata *, struct sockcmd *, void *);
  // callback_arg
  void *callback_arg;
};

struct clsyncsock
{
  // sock
  signed int sock;
  // prot
  unsigned short int prot;
  // subprot
  unsigned short int subprot;
  // cmd_num
  unsigned long int cmd_num;
  // cbqueue_len
  unsigned long int cbqueue_len;
  // cbqueue
  struct clsynccbqueue cbqueue[257l];
  // cbqueue_cache
  struct clsynccbqueue *cbqueue_cache[1025l];
};

struct re_pattern_buffer
{
  // buffer
  unsigned char *buffer;
  // allocated
  unsigned long int allocated;
  // used
  unsigned long int used;
  // syntax
  unsigned long int syntax;
  // fastmap
  char *fastmap;
  // translate
  unsigned char *translate;
  // re_nsub
  unsigned long int re_nsub;
  // can_be_null
  unsigned int can_be_null : 1;
  // regs_allocated
  unsigned int regs_allocated : 2;
  // fastmap_accurate
  unsigned int fastmap_accurate : 1;
  // no_sub
  unsigned int no_sub : 1;
  // not_bol
  unsigned int not_bol : 1;
  // not_eol
  unsigned int not_eol : 1;
  // newline_anchor
  unsigned int newline_anchor : 1;
};

struct rule
{
  // num
  signed int num;
  // expr
  struct re_pattern_buffer expr;
  // objtype
  unsigned int objtype;
  // perm
  enum ruleaction_enum perm;
  // mask
  enum ruleaction_enum mask;
};

struct notifyenginefuncts
{
  // wait
  signed int (*wait)(struct ctx *, struct indexes *, struct timeval *);
  // handle
  signed int (*handle)(struct ctx *, struct indexes *);
  // add_watch_dir
  signed int (*add_watch_dir)(struct ctx *, struct indexes *, const char *);
};

struct queueinfo
{
  // collectdelay
  unsigned int collectdelay;
  // stime
  signed long int stime;
};

struct synchandler_args
{
  // v
  char *v[256l];
  // c
  signed int c;
  // isexpanded
  char isexpanded[256l];
};

struct ctx
{
  // state
  volatile enum state_enum state;
  // pid
  signed int pid;
  // pid_str
  char pid_str[65l];
  // pid_str_len
  unsigned long int pid_str_len;
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
  // privileged_uid
  unsigned int privileged_uid;
  // privileged_gid
  unsigned int privileged_gid;
  // synchandler_uid
  unsigned int synchandler_uid;
  // synchandler_gid
  unsigned int synchandler_gid;
  // child_pid
  signed int child_pid[256l];
  // children
  signed int children;
  // iteration_num
  unsigned int iteration_num;
  // rules
  struct rule rules[256l];
  // rules_count
  unsigned long int rules_count;
  // st_dev
  unsigned long int st_dev;
  // flags_values_raw
  char *flags_values_raw[1024l];
  // flags
  signed int flags[1024l];
  // flags_set
  signed int flags_set[1024l];
  // config_path
  char *config_path;
  // config_block
  const char *config_block;
  // customsignal
  char *customsignal[513l];
  // label
  char *label;
  // watchdir
  char *watchdir;
  // pidfile
  char *pidfile;
  // standbyfile
  char *standbyfile;
  // exithookfile
  char *exithookfile;
  // preexithookfile
  char *preexithookfile;
  // destdir
  char *destdir;
  // destproto
  char *destproto;
  // watchdirwslash
  char *watchdirwslash;
  // destdirwslash
  char *destdirwslash;
  // statusfile
  char *statusfile;
  // socketpath
  char *socketpath;
  // dump_path
  char *dump_path;
  // socket
  signed int socket;
  // socketmod
  unsigned int socketmod;
  // socketuid
  unsigned int socketuid;
  // socketgid
  unsigned int socketgid;
  // watchdirlen
  unsigned long int watchdirlen;
  // destdirlen
  unsigned long int destdirlen;
  // watchdirsize
  unsigned long int watchdirsize;
  // destdirsize
  unsigned long int destdirsize;
  // watchdirwslashsize
  unsigned long int watchdirwslashsize;
  // destdirwslashsize
  unsigned long int destdirwslashsize;
  // watchdir_dirlevel
  signed short int watchdir_dirlevel;
  // handlerfpath
  char *handlerfpath;
  // handler_handle
  void *handler_handle;
  // handler_funct
  struct api_functs handler_funct;
  // rulfpath
  char *rulfpath;
  // rulfpathsize
  unsigned long int rulfpathsize;
  // listoutdir
  char *listoutdir;
  // notifyenginefunct
  struct notifyenginefuncts notifyenginefunct;
  // retries
  signed int retries;
  // bfilethreshold
  unsigned long int bfilethreshold;
  // syncdelay
  unsigned int syncdelay;
  // _queues
  struct queueinfo _queues[4l];
  // rsyncinclimit
  unsigned int rsyncinclimit;
  // synctime
  signed long int synctime;
  // synctimeout
  unsigned int synctimeout;
  // sigset
  struct anonymous$15 *sigset;
  // isignoredexitcode
  char isignoredexitcode[256l];
  // blockthread
  unsigned long int blockthread[16l];
  // blockthread_count
  unsigned long int blockthread_count;
  // chroot_dir
  char *chroot_dir;
  // mountpoint
  char *mountpoint[257l];
  // mountpoints
  signed int mountpoints;
  // synchandler_args
  struct synchandler_args synchandler_args[2l];
  // synchandler_argf
  enum shflags synchandler_argf;
  // indexes_p
  void *indexes_p;
  // fsmondata
  void *fsmondata;
};

struct dosync_arg
{
  // evcount
  signed int evcount;
  // excf_path
  char excf_path[4097l];
  // outf_path
  char outf_path[4097l];
  // outf
  struct _IO_FILE *outf;
  // ctx_p
  struct ctx *ctx_p;
  // indexes_p
  struct indexes *indexes_p;
  // data
  void *data;
  // linescount
  signed int linescount;
  // api_ei
  struct api_eventinfo *api_ei;
  // api_ei_count
  signed int api_ei_count;
  // buf
  char buf[8193l];
  // include_list
  const char *include_list[258l];
  // include_list_count
  unsigned long int include_list_count;
  // list_type_str
  const char *list_type_str;
  // evmask_str
  const char *evmask_str;
};

struct event
{
  // path
  char *path;
  // handle_id
  unsigned long int handle_id;
  // event_id
  enum anonymous$8 event_id;
  // objtype_event
  enum eventobjtype objtype_event;
  // objtype_old
  enum eventobjtype objtype_old;
  // objtype_new
  enum eventobjtype objtype_new;
};

struct eventinfo
{
  // evmask
  unsigned int evmask;
  // seqid_min
  unsigned int seqid_min;
  // seqid_max
  unsigned int seqid_max;
  // objtype_old
  enum eventobjtype objtype_old;
  // objtype_new
  enum eventobjtype objtype_new;
  // wd
  signed int wd;
  // fsize
  unsigned long int fsize;
  // flags
  unsigned int flags;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat64
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct fileinfo
{
  // lstat
  struct stat64 lstat;
};

struct filemondata
{
  // ctx_p
  struct ctx *ctx_p;
  // file
  struct _GFile *file;
  // filemon
  struct _GFileMonitor *filemon;
  // handle_id
  unsigned long int handle_id;
};

struct group
{
  // gr_name
  char *gr_name;
  // gr_passwd
  char *gr_passwd;
  // gr_gid
  unsigned int gr_gid;
  // gr_mem
  char **gr_mem;
};

struct in6_addr
{
  // __in6_u
  union anonymous$12 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct indexes
{
  // wd2fpath_ht
  struct _GHashTable *wd2fpath_ht;
  // fpath2wd_ht
  struct _GHashTable *fpath2wd_ht;
  // fpath2ei_ht
  struct _GHashTable *fpath2ei_ht;
  // exc_fpath_ht
  struct _GHashTable *exc_fpath_ht;
  // exc_fpath_coll_ht
  struct _GHashTable *exc_fpath_coll_ht[4l];
  // fpath2ei_coll_ht
  struct _GHashTable *fpath2ei_coll_ht[4l];
  // out_lines_aggr_ht
  struct _GHashTable *out_lines_aggr_ht;
  // nonthreaded_syncing_fpath2ei_ht
  struct _GHashTable *nonthreaded_syncing_fpath2ei_ht;
  // fileinfo_ht
  struct _GHashTable *fileinfo_ht;
};

struct inotify_event
{
  // wd
  signed int wd;
  // mask
  unsigned int mask;
  // cookie
  unsigned int cookie;
  // len
  unsigned int len;
  // name
  char name[0l];
};

struct ipc_perm
{
  // __key
  signed int __key;
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
  // cuid
  unsigned int cuid;
  // cgid
  unsigned int cgid;
  // mode
  unsigned short int mode;
  // __pad1
  unsigned short int __pad1;
  // __seq
  unsigned short int __seq;
  // __pad2
  unsigned short int __pad2;
  // __glibc_reserved1
  unsigned long int __glibc_reserved1;
  // __glibc_reserved2
  unsigned long int __glibc_reserved2;
};

struct keyvalue_copy_arg
{
  // $anon0
  union anonymous$11 $anon0;
  // k_dup_funct
  void * (*k_dup_funct)(void *);
  // v_dup_funct
  void * (*v_dup_funct)(void *);
};

struct mntent
{
  // mnt_fsname
  char *mnt_fsname;
  // mnt_dir
  char *mnt_dir;
  // mnt_type
  char *mnt_type;
  // mnt_opts
  char *mnt_opts;
  // mnt_freq
  signed int mnt_freq;
  // mnt_passno
  signed int mnt_passno;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct passwd
{
  // pw_name
  char *pw_name;
  // pw_passwd
  char *pw_passwd;
  // pw_uid
  unsigned int pw_uid;
  // pw_gid
  unsigned int pw_gid;
  // pw_gecos
  char *pw_gecos;
  // pw_dir
  char *pw_dir;
  // pw_shell
  char *pw_shell;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct recognize_event_return
{
  // objtype_old
  enum eventobjtype objtype_old;
  // objtype_new
  enum eventobjtype objtype_new;
};

struct shmid_ds
{
  // shm_perm
  struct ipc_perm shm_perm;
  // shm_segsz
  unsigned long int shm_segsz;
  // shm_atime
  signed long int shm_atime;
  // shm_dtime
  signed long int shm_dtime;
  // shm_ctime
  signed long int shm_ctime;
  // shm_cpid
  signed int shm_cpid;
  // shm_lpid
  signed int shm_lpid;
  // shm_nattch
  unsigned long int shm_nattch;
  // __glibc_reserved4
  unsigned long int __glibc_reserved4;
  // __glibc_reserved5
  unsigned long int __glibc_reserved5;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous$18 __sigaction_handler;
  // sa_mask
  struct anonymous$15 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sighandler_arg
{
  // ctx_p
  struct ctx *ctx_p;
  // pthread_parent
  unsigned long int pthread_parent;
  // exitcode_p
  signed int *exitcode_p;
  // sigset_p
  struct anonymous$15 *sigset_p;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct sockcmd
{
  // cmd_num
  unsigned long int cmd_num;
  // cmd_id
  unsigned short int cmd_id;
  // data_len
  unsigned long int data_len;
  // data
  void *data;
};

struct sockcmd_dat_ack
{
  // cmd_num
  unsigned long int cmd_num;
  // cmd_id
  unsigned short int cmd_id;
};

struct sockcmd_dat_dump
{
  // dir_path
  char dir_path[4096l];
};

struct sockcmd_dat_eexist
{
  // file_path
  char file_path[4096l];
};

struct sockcmd_dat_eperm
{
  // descr
  char descr[8192l];
};

struct sockcmd_dat_info
{
  // config_block
  char config_block[256l];
  // label
  char label[256l];
  // flags
  char flags[1024l];
  // flags_set
  char flags_set[1024l];
};

struct sockcmd_dat_invalidcmd
{
  // cmd_num
  unsigned long int cmd_num;
};

struct sockcmd_dat_negotiation
{
  // prot
  unsigned short int prot;
  // subprot
  unsigned short int subprot;
};

struct sockcmd_dat_set
{
  // key
  char key[8192l];
  // value
  char value[8192l];
};

struct sockcmd_dat_version
{
  // major
  signed int major;
  // minor
  signed int minor;
  // revision
  char revision[256l];
};

struct socket_sockthreaddata
{
  // id
  signed int id;
  // procfunct
  signed int (*procfunct)(struct socket_sockthreaddata *, struct sockcmd *);
  // freefunct_arg
  void (*freefunct_arg)(void *);
  // clsyncsock_p
  struct clsyncsock *clsyncsock_p;
  // arg
  void *arg;
  // state
  enum clsyncsock_state state;
  // authtype
  enum sockauth_id authtype;
  // running
  signed int *running;
  // flags
  enum sockprocflags flags;
  // thread
  unsigned long int thread;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct sync_dump_arg
{
  // ctx_p
  struct ctx *ctx_p;
  // dirfd
  signed int dirfd[3l];
  // fd_out
  signed int fd_out;
  // data
  signed int data;
};

struct thread_callbackfunct_arg
{
  // excfpath
  char *excfpath;
  // incfpath
  char *incfpath;
};

struct threadinfo
{
  // thread_num
  signed int thread_num;
  // iteration
  unsigned int iteration;
  // callback
  signed int (*callback)(struct ctx *, struct thread_callbackfunct_arg *);
  // callback_arg
  struct thread_callbackfunct_arg *callback_arg;
  // argv
  char **argv;
  // pthread
  unsigned long int pthread;
  // exitcode
  signed int exitcode;
  // errcode
  signed int errcode;
  // state
  enum state_enum state;
  // ctx_p
  struct ctx *ctx_p;
  // starttime
  signed long int starttime;
  // expiretime
  signed long int expiretime;
  // child_pid
  signed int child_pid;
  // fpath2ei_ht
  struct _GHashTable *fpath2ei_ht;
  // try_n
  signed int try_n;
  // n
  signed int n;
  // ei
  struct api_eventinfo *ei;
};

struct threadsinfo
{
  // mutex
  union anonymous mutex[3l];
  // cond
  union anonymous$1 cond[3l];
  // mutex_init
  char mutex_init;
  // allocated
  signed int allocated;
  // used
  signed int used;
  // threads
  struct threadinfo *threads;
  // threadsstack
  struct threadinfo **threadsstack;
  // stacklen
  signed int stacklen;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct trylocked_arg
{
  // path_full
  char *path_full;
  // path_full_len
  unsigned long int path_full_len;
};


// __privileged_fork_execvp_gid
// file privileged.c line 1634
unsigned int __privileged_fork_execvp_gid;
// __privileged_fork_execvp_uid
// file privileged.c line 1633
unsigned int __privileged_fork_execvp_uid;
// _privileged_fork_execvp
// file privileged.c line 152
signed int (*_privileged_fork_execvp)(const char *, char * const *);
// _privileged_kill_child
// file privileged.c line 153
signed int (*_privileged_kill_child)(signed int, signed int, char);
// _sync_seqid_value
// file sync.c line 70
static unsigned int _sync_seqid_value = (unsigned int)0;
// _sync_tryforcecycle_i
// file sync.c line 3321
signed int _sync_tryforcecycle_i;
// _syslog_buffer
// file error.c line 90
static char _syslog_buffer[65537l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// _syslog_buffer_filled
// file error.c line 91
unsigned long int _syslog_buffer_filled = (unsigned long int)0;
// argc
// file main.c line 2352
signed int argc;
// argv
// file main.c line 2353
char **argv;
// cancel_g_iteration_stop
// file mon_gio.c line 199
signed int cancel_g_iteration_stop;
// clsyncsockthread_busy
// file socket.c line 45
char clsyncsockthread_busy[9l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0 };
// clsyncsockthreads_count
// file socket.c line 42
signed int clsyncsockthreads_count = 0;
// clsyncsockthreads_last
// file socket.c line 41
signed int clsyncsockthreads_last = -1;
// clsyncsockthreads_num
// file socket.c line 43
signed int clsyncsockthreads_num = 0;
// debug
// file error.c line 42
static signed int *debug;
// zero
// file error.c line 38
static signed int zero = 0;
// debug
// file error.c line 42
static signed int *debug = &zero;
// detachnetworkways
// file main.c line 176
static char * const detachnetworkways[4l] = { "off", "non-privileged", "everywhere", (char *)(void *)0 };
// error_mutex_p
// file error.c line 46
union anonymous *error_mutex_p = (union anonymous *)(void *)0;
// exitcode
// file sync.c line 503
volatile signed int exitcode = 0;
// flushfunct
// file error.c line 164
static void * (*flushfunct[3l])(signed int);
// flushfunct
// file error.c line 164
static void * (*flushfunct[3l])(signed int) = { (void * (*)(signed int))flush_stderr, (void * (*)(signed int))flush_stdout, (void * (*)(signed int))syslog_flush };
// gio_cond_gotevent
// file mon_gio.c line 54
union anonymous$1 gio_cond_gotevent = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// gio_loop
// file mon_gio.c line 355
struct _GMainLoop *gio_loop = (struct _GMainLoop *)(void *)0;
// gio_mutex_prefetcher
// file mon_gio.c line 53
union anonymous gio_mutex_prefetcher = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// ipc_type
// file error.c line 350
enum ipc_type ipc_type;
// long_options
// file main.c line 59
static struct option long_options[69l] = { { .name="watch-dir", .has_arg=1, .flag=(signed int *)(void *)0, .val=87 },
    { .name="sync-handler", .has_arg=1, .flag=(signed int *)(void *)0, .val=83 },
    { .name="--", .has_arg=1, .flag=(signed int *)(void *)0, .val=533 },
    { .name="---", .has_arg=1, .flag=(signed int *)(void *)0, .val=534 },
    { .name="rules-file", .has_arg=1, .flag=(signed int *)(void *)0, .val=82 },
    { .name="destination-dir", .has_arg=1, .flag=(signed int *)(void *)0, .val=68 },
    { .name="mode", .has_arg=1, .flag=(signed int *)(void *)0, .val=77 },
    { .name="socket", .has_arg=1, .flag=(signed int *)(void *)0, .val=115 },
    { .name="socket-auth", .has_arg=1, .flag=(signed int *)(void *)0, .val=525 },
    { .name="socket-mod", .has_arg=1, .flag=(signed int *)(void *)0, .val=526 },
    { .name="socket-own", .has_arg=1, .flag=(signed int *)(void *)0, .val=527 },
    { .name="status-file", .has_arg=1, .flag=(signed int *)(void *)0, .val=517 },
    { .name="background", .has_arg=2, .flag=(signed int *)(void *)0, .val=98 },
    { .name="config-file", .has_arg=1, .flag=(signed int *)(void *)0, .val=72 },
    { .name="config-block", .has_arg=1, .flag=(signed int *)(void *)0, .val=75 },
    { .name="config-block-inherits", .has_arg=1, .flag=(signed int *)(void *)0,
    .val=531 },
    { .name="custom-signals", .has_arg=1, .flag=(signed int *)(void *)0, .val=535 },
    { .name="pid-file", .has_arg=1, .flag=(signed int *)(void *)0, .val=122 },
    { .name="uid", .has_arg=1, .flag=(signed int *)(void *)0, .val=117 },
    { .name="gid", .has_arg=1, .flag=(signed int *)(void *)0, .val=103 },
    { .name="privileged-uid", .has_arg=1, .flag=(signed int *)(void *)0, .val=559 },
    { .name="privileged-gid", .has_arg=1, .flag=(signed int *)(void *)0, .val=560 },
    { .name="sync-handler-uid", .has_arg=1, .flag=(signed int *)(void *)0, .val=539 },
    { .name="sync-handler-gid", .has_arg=1, .flag=(signed int *)(void *)0, .val=540 },
    { .name="chroot", .has_arg=1, .flag=(signed int *)(void *)0, .val=536 },
    { .name="pivot-root", .has_arg=1, .flag=(signed int *)(void *)0, .val=543 },
    { .name="detach-network", .has_arg=1, .flag=(signed int *)(void *)0, .val=544 },
    { .name="detach-ipc", .has_arg=1, .flag=(signed int *)(void *)0, .val=558 },
    { .name="detach-miscellanea", .has_arg=2, .flag=(signed int *)(void *)0,
    .val=545 },
    { .name="mountpoints", .has_arg=1, .flag=(signed int *)(void *)0, .val=537 },
    { .name="threading", .has_arg=1, .flag=(signed int *)(void *)0, .val=112 },
    { .name="retries", .has_arg=1, .flag=(signed int *)(void *)0, .val=114 },
    { .name="ignore-failures", .has_arg=2, .flag=(signed int *)(void *)0, .val=529 },
    { .name="exit-on-sync-skipping", .has_arg=2, .flag=(signed int *)(void *)0,
    .val=557 },
    { .name="output", .has_arg=1, .flag=(signed int *)(void *)0, .val=89 },
    { .name="one-file-system", .has_arg=2, .flag=(signed int *)(void *)0, .val=516 },
    { .name="exclude-mount-points", .has_arg=2, .flag=(signed int *)(void *)0,
    .val=88 },
    { .name="max-iterations", .has_arg=1, .flag=(signed int *)(void *)0, .val=528 },
    { .name="standby-file", .has_arg=1, .flag=(signed int *)(void *)0, .val=521 },
    { .name="modification-signature", .has_arg=1, .flag=(signed int *)(void *)0,
    .val=555 },
    { .name="timeout-sync", .has_arg=1, .flag=(signed int *)(void *)0, .val=107 },
    { .name="delay-sync", .has_arg=1, .flag=(signed int *)(void *)0, .val=119 },
    { .name="delay-collect", .has_arg=1, .flag=(signed int *)(void *)0, .val=116 },
    { .name="delay-collect-bigfile", .has_arg=1, .flag=(signed int *)(void *)0,
    .val=84 },
    { .name="threshold-bigfile", .has_arg=1, .flag=(signed int *)(void *)0,
    .val=66 },
    { .name="cancel-syscalls", .has_arg=1, .flag=(signed int *)(void *)0, .val=556 },
    { .name="lists-dir", .has_arg=1, .flag=(signed int *)(void *)0, .val=76 },
    { .name="have-recursive-sync", .has_arg=2, .flag=(signed int *)(void *)0,
    .val=512 },
    { .name="synclist-simplify", .has_arg=2, .flag=(signed int *)(void *)0,
    .val=515 },
    { .name="rsync-inclimit", .has_arg=1, .flag=(signed int *)(void *)0, .val=513 },
    { .name="rsync-prefer-include", .has_arg=2, .flag=(signed int *)(void *)0,
    .val=514 },
    { .name="ignore-exitcode", .has_arg=1, .flag=(signed int *)(void *)0, .val=120 },
    { .name="dont-unlink-lists", .has_arg=2, .flag=(signed int *)(void *)0,
    .val=85 },
    { .name="fts-experimental-optimization", .has_arg=2,
    .flag=(signed int *)(void *)0, .val=550 },
    { .name="full-initialsync", .has_arg=2, .flag=(signed int *)(void *)0, .val=70 },
    { .name="only-initialsync", .has_arg=2, .flag=(signed int *)(void *)0, .val=519 },
    { .name="skip-initialsync", .has_arg=2, .flag=(signed int *)(void *)0, .val=518 },
    { .name="exit-on-no-events", .has_arg=2, .flag=(signed int *)(void *)0,
    .val=520 },
    { .name="exit-hook", .has_arg=1, .flag=(signed int *)(void *)0, .val=522 },
    { .name="pre-exit-hook", .has_arg=1, .flag=(signed int *)(void *)0, .val=524 },
    { .name="verbose", .has_arg=2, .flag=(signed int *)(void *)0, .val=118 },
    { .name="debug", .has_arg=2, .flag=(signed int *)(void *)0, .val=100 },
    { .name="dump-dir", .has_arg=1, .flag=(signed int *)(void *)0, .val=530 },
    { .name="quiet", .has_arg=2, .flag=(signed int *)(void *)0, .val=113 },
    { .name="monitor", .has_arg=1, .flag=(signed int *)(void *)0, .val=532 },
    { .name="label", .has_arg=1, .flag=(signed int *)(void *)0, .val=108 },
    { .name="help", .has_arg=2, .flag=(signed int *)(void *)0, .val=104 },
    { .name="version", .has_arg=2, .flag=(signed int *)(void *)0, .val=86 },
    { .name=(const char *)(void *)0, .has_arg=0, .flag=(signed int *)(void *)0,
    .val=0 } };
// main_statusfile_f
// file main.c line 2303
struct _IO_FILE *main_statusfile_f;
// modes
// file main.c line 343
static char * const modes[9l] = { "", "simple", "direct", "shell", "rsyncshell", "rsyncdirect", "rsyncso", "so", (char *)(void *)0 };
// mondirs_ht
// file mon_gio.c line 51
struct _GHashTable *mondirs_ht;
// ncpus
// file main.c line 388
signed int ncpus;
// notify_engines
// file main.c line 324
static char * const notify_engines[9l] = { "", "fanotify", "inotify", "kqueue", "bsm", "bsm_prefetch", "dtracepipe", "gio", (char *)(void *)0 };
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// outfunct
// file error.c line 152
static signed int * (*outfunct[3l])(const char *, ...);
// outfunct
// file error.c line 152
static signed int * (*outfunct[3l])(const char *, ...) = { (signed int * (*)(const char *, ...))printf_stderr,
    (signed int * (*)(const char *, ...))printf_stdout,
    (signed int * (*)(const char *, ...))syslog_buf };
// output_methods
// file main.c line 336
static char * const output_methods[4l] = { "stderr", "stdout", "syslog", (char *)(void *)0 };
// outputmethod
// file error.c line 41
static signed int *outputmethod;
// outputmethod
// file error.c line 41
static signed int *outputmethod = &zero;
// parent_pid
// file main.c line 389
signed int parent_pid;
// pivotrootways
// file main.c line 185
static char * const pivotrootways[5l] = { "off", "direct", "auto", "auto-ro", (char *)(void *)0 };
// pthread_control
// file control.c line 37
static unsigned long int pthread_control;
// pthread_sighandler
// file sync.c line 59
unsigned long int pthread_sighandler;
// pthread_watchforparent
// file main.c line 461
unsigned long int pthread_watchforparent;
// queue
// file mon_gio.c line 55
struct event *queue = (struct event *)(void *)0;
// queue_alloc
// file mon_gio.c line 57
signed int queue_alloc;
// queue_length
// file mon_gio.c line 56
signed int queue_length;
// queue_lock
// file mon_gio.c line 52
volatile signed int queue_lock;
// quiet
// file error.c line 43
static signed int *quiet;
// quiet
// file error.c line 43
static signed int *quiet = &zero;
// recv_ptrs
// file socket.c line 68
static char *recv_ptrs[8l];
// recv_stps
// file socket.c line 67
static char *recv_stps[8l];
// rsync_escape_result
// file sync.c line 2509
char *rsync_escape_result = (char *)(void *)0;
// rsync_escape_result_size
// file sync.c line 2508
unsigned long int rsync_escape_result_size = (unsigned long int)0;
// socket_thread_mutex
// file socket.c line 39
union anonymous socket_thread_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// socketauth
// file main.c line 301
static char * const socketauth[3l] = { "", "null", (char *)(void *)0 };
// sockthreaddata
// file socket.c line 47
struct socket_sockthreaddata sockthreaddata[9l] = { { .id=0, .procfunct=((signed int (*)(struct socket_sockthreaddata *, struct sockcmd *))NULL), .freefunct_arg=((void (*)(void *))NULL),
    .clsyncsock_p=((struct clsyncsock *)NULL),
    .arg=NULL,
    .state=(enum clsyncsock_state)0, .authtype=(enum sockauth_id)0,
    .running=((signed int *)NULL), .flags=(enum sockprocflags)0,
    .thread=0ul },
    { .id=0, .procfunct=((signed int (*)(struct socket_sockthreaddata *, struct sockcmd *))NULL), .freefunct_arg=((void (*)(void *))NULL),
    .clsyncsock_p=((struct clsyncsock *)NULL),
    .arg=NULL,
    .state=(enum clsyncsock_state)0, .authtype=(enum sockauth_id)0,
    .running=((signed int *)NULL), .flags=(enum sockprocflags)0,
    .thread=0ul },
    { .id=0, .procfunct=((signed int (*)(struct socket_sockthreaddata *, struct sockcmd *))NULL), .freefunct_arg=((void (*)(void *))NULL),
    .clsyncsock_p=((struct clsyncsock *)NULL),
    .arg=NULL,
    .state=(enum clsyncsock_state)0, .authtype=(enum sockauth_id)0,
    .running=((signed int *)NULL), .flags=(enum sockprocflags)0,
    .thread=0ul },
    { .id=0, .procfunct=((signed int (*)(struct socket_sockthreaddata *, struct sockcmd *))NULL), .freefunct_arg=((void (*)(void *))NULL),
    .clsyncsock_p=((struct clsyncsock *)NULL),
    .arg=NULL,
    .state=(enum clsyncsock_state)0, .authtype=(enum sockauth_id)0,
    .running=((signed int *)NULL), .flags=(enum sockprocflags)0,
    .thread=0ul },
    { .id=0, .procfunct=((signed int (*)(struct socket_sockthreaddata *, struct sockcmd *))NULL), .freefunct_arg=((void (*)(void *))NULL),
    .clsyncsock_p=((struct clsyncsock *)NULL),
    .arg=NULL,
    .state=(enum clsyncsock_state)0, .authtype=(enum sockauth_id)0,
    .running=((signed int *)NULL), .flags=(enum sockprocflags)0,
    .thread=0ul },
    { .id=0, .procfunct=((signed int (*)(struct socket_sockthreaddata *, struct sockcmd *))NULL), .freefunct_arg=((void (*)(void *))NULL),
    .clsyncsock_p=((struct clsyncsock *)NULL),
    .arg=NULL,
    .state=(enum clsyncsock_state)0, .authtype=(enum sockauth_id)0,
    .running=((signed int *)NULL), .flags=(enum sockprocflags)0,
    .thread=0ul },
    { .id=0, .procfunct=((signed int (*)(struct socket_sockthreaddata *, struct sockcmd *))NULL), .freefunct_arg=((void (*)(void *))NULL),
    .clsyncsock_p=((struct clsyncsock *)NULL),
    .arg=NULL,
    .state=(enum clsyncsock_state)0, .authtype=(enum sockauth_id)0,
    .running=((signed int *)NULL), .flags=(enum sockprocflags)0,
    .thread=0ul },
    { .id=0, .procfunct=((signed int (*)(struct socket_sockthreaddata *, struct sockcmd *))NULL), .freefunct_arg=((void (*)(void *))NULL),
    .clsyncsock_p=((struct clsyncsock *)NULL),
    .arg=NULL,
    .state=(enum clsyncsock_state)0, .authtype=(enum sockauth_id)0,
    .running=((signed int *)NULL), .flags=(enum sockprocflags)0,
    .thread=0ul },
    { .id=0, .procfunct=((signed int (*)(struct socket_sockthreaddata *, struct sockcmd *))NULL), .freefunct_arg=((void (*)(void *))NULL),
    .clsyncsock_p=((struct clsyncsock *)NULL),
    .arg=NULL,
    .state=(enum clsyncsock_state)0, .authtype=(enum sockauth_id)0,
    .running=((signed int *)NULL), .flags=(enum sockprocflags)0,
    .thread=0ul } };
// stat_fields
// file main.c line 230
static char * const stat_fields[16l] = { "", "dev", "ino", "mode", "nlink", "uid", "gid", "rdev", "size", "blksize", "blocks", "atime", "mtime", "ctime", "*", (char *)(void *)0 };
// state_p
// file sync.c line 502
volatile enum state_enum *state_p = (volatile enum state_enum *)(void *)0;
// status_descr
// file main.c line 355
static char * const status_descr[11l] = { "exiting", "starting", "running", "synchandler error", "rehashing", ((char *)NULL), "terminating", "thread gc", "initsync", "hold on", (char *)(void *)0 };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// sync_sighandler_exitcode_p
// file sync.c line 3623
signed int *sync_sighandler_exitcode_p = (signed int *)(void *)0;
// syscalls_bitmask
// file main.c line 259
static char * const syscalls_bitmask[3l] = { "", "mon_stat", (char *)(void *)0 };
// textmessage_args
// file socket.c line 70
const char * const textmessage_args[352l] = { "%u", "%u", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "%u %lu", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "%u %lu", "%lu", "%u %lu", "%s\003/", "%s\003/", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "%s\003/ %s\003/ %u %s\003/", ((const char *)NULL), ((const char *)NULL), "%s", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "%s\003/ %s\003/", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "%u %u %s", "%s\003/ %s\003/ %x %x", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) };
// textmessage_descr
// file socket.c line 86
const char * const textmessage_descr[352l] = { "Protocol version is %u.", "Protocol version is %u.", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "Acknowledged command: id == %u; num == %lu.",
    ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "Unknown command.", "Invalid command id. Required: 0 <= cmd_id < 1000.",
    "Rejected command: id == %u; num == %lu. Invalid arguments: %s.",
    "File exists: \"%s\".", "Permission denied: \"%s\".", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "%s(%s): Error #%u: \"%s\".", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "clsync v%u.%u%s", "config_block == \"%s\"; label == \"%s\"; flags == %x; flags_set == %x.",
    "Ready", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "Enter your login and password, please.",
    "Set", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "Okay :(", ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), "Bye.", "Need to go, sorry. :)" };
// thread_g_iteration_stop
// file mon_gio.c line 200
unsigned long int thread_g_iteration_stop;
// threading_modes
// file main.c line 308
static char * const threading_modes[4l] = { "off", "safe", "full", (char *)(void *)0 };
// three
// file error.c line 39
static signed int three = 3;
// verbose
// file error.c line 44
static signed int *verbose;
// verbose
// file error.c line 44
static signed int *verbose = &three;
// voutfunct
// file error.c line 158
static signed int * (*voutfunct[3l])(const char *, void **);
// voutfunct
// file error.c line 158
static signed int * (*voutfunct[3l])(const char *, void **) = { (signed int * (*)(const char *, void **))vprintf_stderr,
    (signed int * (*)(const char *, void **))vprintf_stdout,
    (signed int * (*)(const char *, void **))vsyslog_buf };
// xcsc_to_csc
// file main.c line 254
unsigned int xcsc_to_csc[2l] = { (unsigned int)0, (unsigned int)1 };
// xstatfield_to_statfield
// file main.c line 212
unsigned int xstatfield_to_statfield[15l] = { (unsigned int)0, (unsigned int)1, (unsigned int)2, (unsigned int)4, (unsigned int)8, (unsigned int)16, (unsigned int)32, (unsigned int)64, (unsigned int)128, (unsigned int)256, (unsigned int)512, (unsigned int)1024, (unsigned int)2048, (unsigned int)4096, (unsigned int)8183 };

// __privileged_fork_execvp
// file privileged.c line 1635
signed int __privileged_fork_execvp(const char *file, char * const *argv)
{
  _debug(4, "__privileged_fork_execvp", "");
  signed int pid;
  pid=fork();
  signed int return_value_setgid$1;
  signed int return_value_setuid$2;
  if(!(pid == -1))
  {
    if(pid == 0)
      goto __CPROVER_DUMP_L3;

  }

  else
  {
    _error("__privileged_fork_execvp", "Cannot fork().");
    return -1;

  __CPROVER_DUMP_L3:
    ;
    return_value_setgid$1=setgid(__privileged_fork_execvp_gid);
    _debug(4, "__privileged_fork_execvp", "setgid(%u) == %i", __privileged_fork_execvp_gid, return_value_setgid$1);
    return_value_setuid$2=setuid(__privileged_fork_execvp_uid);
    _debug(4, "__privileged_fork_execvp", "setuid(%u) == %i", __privileged_fork_execvp_uid, return_value_setuid$2);
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    *return_value___errno_location$3 = 0;
    execvp(file, argv);
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    exit(*return_value___errno_location$4);
  }
  return pid;
}

// __privileged_kill_child_itself
// file privileged.c line 455
signed int __privileged_kill_child_itself(signed int child_pid, signed int signal, char ignoreerrors)
{
  signed int return_value_waitpid$3;
  return_value_waitpid$3=waitpid(child_pid, (signed int *)(void *)0, 1);
  if(return_value_waitpid$3 >= 0)
  {
    _debug(3, "__privileged_kill_child_itself", "Sending signal %u to child process with pid %u.", signal, child_pid);
    signed int return_value_kill$2;
    return_value_kill$2=kill(child_pid, signal);
    if(!(return_value_kill$2 == 0))
    {
      if(ignoreerrors == 0)
        _error("__privileged_kill_child_itself", "Got error while kill(%u, %u)", child_pid, signal);

      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      return *return_value___errno_location$1;
    }

    waitpid_timed(child_pid, (signed int *)(void *)0, (signed long int)1, (signed long int)0);
  }

  else
    return 2;
  return 0;
}

// __sync_exec_thread
// file sync.c line 1086
signed int __sync_exec_thread(struct threadinfo *threadinfo_p)
{
  char **__sync_exec_thread$$1$$argv = threadinfo_p->argv;
  struct ctx *ctx_p = threadinfo_p->ctx_p;
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  _debug(3, "__sync_exec_thread", "thread_num == %i; threadinfo_p == %p; i_p->pthread %p; thread %p", threadinfo_p->thread_num, threadinfo_p, threadinfo_p->pthread, return_value_pthread_self$1);
  signed int err = 0;
  signed int exec_exitcode = 0;
  signed int try_again;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  do
  {
    try_again = 0;
    threadinfo_p->try_n = threadinfo_p->try_n + 1;
    exec_exitcode=exec_argv(__sync_exec_thread$$1$$argv, &threadinfo_p->child_pid);
    err=exitcode_process(threadinfo_p->ctx_p, exec_exitcode);
    if(!(err == 0))
    {
      if(ctx_p->retries == 0)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = threadinfo_p->try_n < ctx_p->retries ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (signed int)ctx_p->state != STATE_TERM ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      if(tmp_if_expr$3)
        tmp_if_expr$4 = (signed int)ctx_p->state != STATE_EXIT ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$4 = (_Bool)0;
      try_again = (signed int)tmp_if_expr$4;
      _warning("__sync_exec_thread", "__sync_exec_thread(): Bad exitcode %i (errcode %i). %s.", exec_exitcode, err, try_again != 0 ? "Retrying" : "Give up");
      if(!(try_again == 0))
      {
        _debug(2, "__sync_exec_thread", "Sleeping for %u seconds before the retry.", ctx_p->syncdelay);
        sleep(ctx_p->syncdelay);
      }

    }

  }
  while(!(try_again == 0));
  if(!(err == 0))
  {
    if(ctx_p->flags[529l] == 0)
    {
      _error("__sync_exec_thread", "Bad exitcode %i (errcode %i)", exec_exitcode, err);
      threadinfo_p->errcode = err;
    }

  }

  g_hash_table_destroy(threadinfo_p->fpath2ei_ht);
  err=thread_exit(threadinfo_p, exec_exitcode);
  if(!(err == 0))
  {
    exitcode = err;
    pthread_kill(pthread_sighandler, 15);
  }

  unsigned long int return_value_pthread_self$5;
  return_value_pthread_self$5=pthread_self();
  _debug(3, "__sync_exec_thread", "thread_num == %i; threadinfo_p == %p; i_p->pthread %p; thread %p; errcode %i", threadinfo_p->thread_num, threadinfo_p, threadinfo_p->pthread, return_value_pthread_self$5, threadinfo_p->errcode);
  return exec_exitcode;
}

// _critical
// file error.c line 170
extern void _critical(const char * const function_name, const char *fmt, ...)
{
  if(*quiet == 0)
  {
    struct timespec abs_time;
    clock_gettime(0, &abs_time);
    abs_time.tv_sec = abs_time.tv_sec + (signed long int)1;
    if(!(error_mutex_p == ((union anonymous *)NULL)))
      pthread_mutex_timedlock(error_mutex_p, &abs_time);

    enum outputmethod method = (enum outputmethod)*outputmethod;
    void **args;
    unsigned long int thread;
    thread=pthread_self();
    signed int pid;
    pid=getpid();
    outfunct[(signed long int)method]("Critical (pid: %u; thread: %p): %s(): ", pid, thread, function_name);
    args = (void **)&fmt;
    voutfunct[(signed long int)method](fmt, args);
    args = ((void **)NULL);
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    char *return_value_strerror$3;
    return_value_strerror$3=strerror(*return_value___errno_location$2);
    outfunct[(signed long int)method](" (current errno %i: %s)", *return_value___errno_location$1, return_value_strerror$3);
    flushfunct[(signed long int)method](2);
    void *buf[256l];
    char **strings;
    signed int backtrace_len;
    backtrace_len=backtrace((void **)buf, 256);
    strings=backtrace_symbols(buf, backtrace_len);
    if(strings == ((char **)NULL))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      char *return_value_strerror$6;
      return_value_strerror$6=strerror(*return_value___errno_location$5);
      outfunct[(signed long int)method]("_critical(): Got error, but cannot print the backtrace. Current errno: %u: %s\n", *return_value___errno_location$4, return_value_strerror$6);
      flushfunct[(signed long int)method](2);
      pthread_mutex_unlock(error_mutex_p);
      exit(1);
    }

    signed int j = 1;
    if(!(j >= backtrace_len))
    {
      outfunct[(signed long int)method]("        %s", strings[(signed long int)j]);
      flushfunct[(signed long int)method](2);
      j = j + 1;
    }

    if(!(error_mutex_p == ((union anonymous *)NULL)))
      pthread_mutex_unlock(error_mutex_p);

    error_deinit();
    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    exit(*return_value___errno_location$7);
  }

}

// _debug
// file error.h line 46
extern void _debug(signed int debug_level, const char * const function_name, const char *fmt, ...)
{
  void **args;
  if(*quiet == 0)
  {
    if(*debug >= debug_level)
    {
      if(!(error_mutex_p == ((union anonymous *)NULL)))
        pthread_mutex_reltimedlock(error_mutex_p, (signed long int)0, (signed long int)(100 * 1000 * 1000));

      unsigned long int thread;
      thread=pthread_self();
      signed int pid;
      pid=getpid();
      enum outputmethod method = (enum outputmethod)*outputmethod;
      outfunct[(signed long int)method]("Debug%u (pid: %u; thread: %p): %s(): ", debug_level, pid, thread, function_name);
      args = (void **)&fmt;
      voutfunct[(signed long int)method](fmt, args);
      args = ((void **)NULL);
      flushfunct[(signed long int)method](7);
      if(!(error_mutex_p == ((union anonymous *)NULL)))
        pthread_mutex_unlock(error_mutex_p);

    }

  }

}

// _error
// file error.c line 227
extern void _error(const char * const function_name, const char *fmt, ...)
{
  void **args;
  signed int *return_value___errno_location$1;
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  if(*quiet == 0)
  {
    if(*verbose >= 1)
    {
      if(!(error_mutex_p == ((union anonymous *)NULL)))
        pthread_mutex_reltimedlock(error_mutex_p, (signed long int)0, (signed long int)(100 * 1000 * 1000));

      unsigned long int thread;
      thread=pthread_self();
      signed int pid;
      pid=getpid();
      enum outputmethod method = (enum outputmethod)*outputmethod;
      outfunct[(signed long int)method](*debug != 0 ? "Error (pid: %u; thread: %p): %s(): " : "Error: ", pid, thread, function_name);
      args = (void **)&fmt;
      voutfunct[(signed long int)method](fmt, args);
      args = ((void **)NULL);
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      if(!(*return_value___errno_location$4 == 0))
      {
        return_value___errno_location$1=__errno_location();
        return_value___errno_location$2=__errno_location();
        return_value_strerror$3=strerror(*return_value___errno_location$2);
        outfunct[(signed long int)method](" (%i: %s)", *return_value___errno_location$1, return_value_strerror$3);
      }

      flushfunct[(signed long int)method](3);
      if(!(error_mutex_p == ((union anonymous *)NULL)))
        pthread_mutex_unlock(error_mutex_p);

    }

  }

}

// _exitcode_process
// file sync.c line 156
static inline signed int _exitcode_process(struct ctx *ctx_p, signed int exitcode)
{
  if(!(ctx_p->isignoredexitcode[(signed long int)(unsigned char)exitcode] == 0))
    return 0;

  else
    if(!(exitcode == 0))
    {
      if(ctx_p->flags[77l] == 5 && exitcode == 24)
        goto __CPROVER_DUMP_L2;

      _error("_exitcode_process", "Got non-zero exitcode %i from __sync_exec().", exitcode);
      return exitcode;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      return 0;
    }
}

// _info
// file error.c line 256
extern void _info(const char * const function_name, const char *fmt, ...)
{
  void **args;
  if(*quiet == 0)
  {
    if(*verbose >= 3)
    {
      if(!(error_mutex_p == ((union anonymous *)NULL)))
        pthread_mutex_reltimedlock(error_mutex_p, (signed long int)0, (signed long int)(100 * 1000 * 1000));

      unsigned long int thread;
      thread=pthread_self();
      signed int pid;
      pid=getpid();
      enum outputmethod method = (enum outputmethod)*outputmethod;
      outfunct[(signed long int)method](*debug != 0 ? "Info (pid: %u; thread: %p): %s(): " : "Info: ", pid, thread, function_name);
      args = (void **)&fmt;
      voutfunct[(signed long int)method](fmt, args);
      args = ((void **)NULL);
      flushfunct[(signed long int)method](6);
      if(!(error_mutex_p == ((union anonymous *)NULL)))
        pthread_mutex_unlock(error_mutex_p);

    }

  }

}

// _socket_send
// file socket.c line 272
signed int _socket_send(struct clsyncsock *clsyncsock, unsigned long int *cmd_num_p, enum sockcmd_id cmd_id, void **ap)
{
  signed int ret;
  char prebuf0[4096l];
  char prebuf1[4096l];
  char sendbuf[4096l];
  ret = 0;
  unsigned long int tmp_post$1;
  if((signed int)clsyncsock->prot == 0)
  {
    if((signed int)clsyncsock->subprot == 0)
    {
      void **ap_copy;
      _debug(3, "_socket_send", "%p %p %p", (const void *)prebuf0, textmessage_args[(signed long int)cmd_id], ap_copy);
      if(!(textmessage_args[(signed long int)cmd_id] == ((const char *)NULL)))
      {
        ap_copy = (void **)ap;
        vsprintf(prebuf0, textmessage_args[(signed long int)cmd_id], ap_copy);
      }

      else
        prebuf0[0l] = (char)0;
      ap_copy = (void **)ap;
      vsprintf(prebuf1, textmessage_descr[(signed long int)cmd_id], ap);
      unsigned long int sendlen;
      tmp_post$1 = *cmd_num_p;
      *cmd_num_p = *cmd_num_p + 1ul;
      signed int return_value_sprintf$2;
      return_value_sprintf$2=sprintf(sendbuf, "%lu %u %s :%s\n", tmp_post$1, cmd_id, (const void *)prebuf0, (const void *)prebuf1);
      sendlen = (unsigned long int)return_value_sprintf$2;
      _debug(5, "_socket_send", "send(): \"%s\"", (const void *)sendbuf);
      send(clsyncsock->sock, (const void *)sendbuf, sendlen, 0);
      goto __CPROVER_DUMP_L8;
    }

    _error("_socket_send", "Unknown subprotocol with id %u.", clsyncsock->subprot);
    ret = 22;
    goto l_socket_send_end;

  __CPROVER_DUMP_L8:
    ;
    goto l_socket_send_end;
  }

  _error("_socket_send", "Unknown protocol with id %u.", clsyncsock->prot);
  ret = 22;

l_socket_send_end:
  ;
  return ret;
}

// _str_splitargs
// file stringex.c line 27
static signed int _str_splitargs(char *ptr, char **arg_start_p, signed int quotes, signed int (*handler)(char *, unsigned long int, void *), char *additional_arg)
{
  char *arg_start;
  char *arg;
  unsigned long int arg_len;
  signed int rc;
  arg_start = *arg_start_p;
  *arg_start_p = &ptr[(signed long int)1];
  arg_len = (unsigned long int)(ptr - arg_start);
  signed int tmp_post$2;
  if(arg_len == 0ul)
    return 0;

  else
  {
    void *return_value_xmalloc$1;
    return_value_xmalloc$1=xmalloc(arg_len + (unsigned long int)1);
    arg = (char *)return_value_xmalloc$1;
    if(!(quotes == 0))
    {
      signed int s;
      signed int d = 0;
      s = d;
      for( ; !((unsigned long int)s >= arg_len); s = s + 1)
        if(!(arg_start[(signed long int)s] == 0))
        {
          tmp_post$2 = d;
          d = d + 1;
          arg[(signed long int)tmp_post$2] = arg_start[(signed long int)s];
        }

      arg_len = (unsigned long int)d;
    }

    else
      memcpy((void *)arg, (const void *)arg_start, arg_len);
    arg[(signed long int)arg_len] = (char)0;
    rc=handler(arg, arg_len, (void *)additional_arg);
    if(!(rc == 0))
    {
      free((void *)arg);
      return rc;
    }

    else
      return 0;
  }
}

// _sync_idle_dosync_collectedevents
// file sync.c line 2262
void _sync_idle_dosync_collectedevents(void *fpath_gp, void *evinfo_gp, void *arg_gp)
{
  char *fpath = (char *)fpath_gp;
  struct eventinfo *evinfo = (struct eventinfo *)evinfo_gp;
  signed int *evcount_p = &((struct dosync_arg *)arg_gp)->evcount;
  struct ctx *ctx_p = ((struct dosync_arg *)arg_gp)->ctx_p;
  struct indexes *indexes_p = ((struct dosync_arg *)arg_gp)->indexes_p;
  enum queue_id queue_id = (enum queue_id)((struct dosync_arg *)arg_gp)->data;
  _debug(3, "_sync_idle_dosync_collectedevents", "queue_id == %i.", queue_id);
  signed int return_value_sync_islocked$2;
  if(ctx_p->flags[112l] == PM_SAFE)
  {
    return_value_sync_islocked$2=sync_islocked(fpath);
    if(!(return_value_sync_islocked$2 == 0))
    {
      _debug(3, "_sync_idle_dosync_collectedevents", "\"%s\" is locked, dropping to waitlock queue", fpath);
      struct eventinfo *evinfo_dup;
      void *return_value_xmalloc$1;
      return_value_xmalloc$1=xmalloc(sizeof(struct eventinfo) /*40ul*/ );
      evinfo_dup = (struct eventinfo *)return_value_xmalloc$1;
      memcpy((void *)evinfo_dup, (const void *)evinfo, sizeof(struct eventinfo) /*40ul*/ );
      sync_queuesync(fpath, evinfo_dup, ctx_p, indexes_p, (enum queue_id)QUEUE_LOCKWAIT);
      goto __CPROVER_DUMP_L21;
    }

  }

  signed int tmp_if_expr$5;
  signed int *return_value___errno_location$4;
  if(ctx_p->listoutdir == ((char *)NULL))
  {
    if(!((SHFL_INCLUDE_LIST & (signed int)ctx_p->synchandler_argf) == 0))
      goto __CPROVER_DUMP_L9;

    if(ctx_p->flags[77l] == 7)
      goto __CPROVER_DUMP_L9;

    _debug(3, "_sync_idle_dosync_collectedevents", "calling sync_dosync()");
    signed long int _SAFE_rc;
    signed int return_value_sync_dosync$6;
    return_value_sync_dosync$6=sync_dosync(fpath, evinfo->evmask, ctx_p, indexes_p);
    _SAFE_rc = (signed long int)return_value_sync_dosync$6;
    if(!(_SAFE_rc == 0l))
    {
      _error("_sync_idle_dosync_collectedevents", "Got error while sync_dosync(fpath, evinfo->evmask, ctx_p, indexes_p)");
      _debug(1, "_sync_idle_dosync_collectedevents", "fpath == \"%s\"; evmask == 0x%o", fpath, evinfo->evmask);
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      if(!(*return_value___errno_location$3 == 0))
      {
        return_value___errno_location$4=__errno_location();
        tmp_if_expr$5 = *return_value___errno_location$4;
      }

      else
        tmp_if_expr$5 = -1;
      exit(tmp_if_expr$5);
    }

    _SAFE_rc;
  }

  else
  {

  __CPROVER_DUMP_L9:
    ;
    signed int isnew = 0;
    struct eventinfo *evinfo_idx;
    evinfo_idx=indexes_fpath2ei(indexes_p, fpath);
    if(evinfo_idx == ((struct eventinfo *)NULL))
    {
      void *return_value_xmalloc$7;
      return_value_xmalloc$7=xmalloc(sizeof(struct eventinfo) /*40ul*/ );
      evinfo_idx = (struct eventinfo *)return_value_xmalloc$7;
      memset((void *)evinfo_idx, 0, sizeof(struct eventinfo) /*40ul*/ );
      isnew = isnew + 1;
      *evcount_p = *evcount_p + 1;
      evinfo_idx->evmask = evinfo->evmask;
      evinfo_idx->flags = evinfo->flags;
      evinfo_idx->objtype_old = evinfo->objtype_old;
      evinfo_idx->objtype_new = evinfo->objtype_new;
      evinfo_idx->seqid_min = evinfo->seqid_min;
      evinfo_idx->seqid_max = evinfo->seqid_max;
    }

    else
      evinfo_merge(ctx_p, evinfo_idx, evinfo);
    signed int _queue_id = 0;
    while(!(_queue_id >= QUEUE_MAX))
      if(_queue_id == (signed int)queue_id)
        _queue_id = _queue_id + 1;

      else
      {
        struct eventinfo *evinfo_q;
        evinfo_q=indexes_lookupinqueue(indexes_p, fpath, (enum queue_id)_queue_id);
        if(!(evinfo_q == ((struct eventinfo *)NULL)))
        {
          evinfo_merge(ctx_p, evinfo_idx, evinfo_q);
          indexes_removefromqueue(indexes_p, fpath, (enum queue_id)_queue_id);
          signed int return_value_indexes_queuelen$8;
          return_value_indexes_queuelen$8=indexes_queuelen(indexes_p, (enum queue_id)_queue_id);
          if(return_value_indexes_queuelen$8 == 0)
            ctx_p->_queues[(signed long int)_queue_id].stime = (signed long int)0;

        }

        _queue_id = _queue_id + 1;
      }
    if(!(isnew == 0))
    {
      _debug(4, "_sync_idle_dosync_collectedevents", "Collecting \"%s\"", fpath);
      sync_indexes_fpath2ei_addfixed(ctx_p, indexes_p, fpath, evinfo_idx);
    }

    else
      free((void *)fpath);
    goto __CPROVER_DUMP_L21;
  }

__CPROVER_DUMP_L21:
  ;
}

// _sync_idle_dosync_collectedexcludes
// file sync.c line 2190
void _sync_idle_dosync_collectedexcludes(void *fpath_gp, void *flags_gp, void *arg_gp)
{
  char *fpath = (char *)fpath_gp;
  struct indexes *indexes_p = ((struct dosync_arg *)arg_gp)->indexes_p;
  _debug(3, "_sync_idle_dosync_collectedexcludes", "\"%s\", %u (%p).", fpath, (signed int)(signed long int)flags_gp, flags_gp);
  char *return_value_strdup$1;
  return_value_strdup$1=strdup(fpath);
  indexes_addexclude_aggr(indexes_p, return_value_strdup$1, (enum eventinfo_flags)(signed int)(signed long int)flags_gp);
  goto __CPROVER_DUMP_L2;

__CPROVER_DUMP_L2:
  ;
}

// _sync_islocked
// file sync.c line 2245
signed int _sync_islocked(struct threadinfo *threadinfo_p, void *_fpath)
{
  char *fpath = (char *)_fpath;
  struct eventinfo *evinfo;
  evinfo=ht_fpath_isincluded(threadinfo_p->fpath2ei_ht, fpath);
  _debug(4, "_sync_islocked", "scanning thread %p: fpath<%s> -> evinfo<%p>", threadinfo_p->pthread, fpath, evinfo);
  if(!(evinfo == ((struct eventinfo *)NULL)))
    return 1;

  else
    return 0;
}

// _thread_info_lock
// file sync.c line 202
static inline struct threadsinfo * _thread_info_lock(const char * const function_name)
{
  struct threadsinfo *threadsinfo_p;
  threadsinfo_p=thread_info();
  _debug(4, "_thread_info_lock", "used by %s()", function_name);
  pthread_mutex_lock(&threadsinfo_p->mutex[(signed long int)2]);
  return threadsinfo_p;
}

// _thread_info_unlock
// file sync.c line 212
static inline signed int _thread_info_unlock(const char * const function_name, signed int rc)
{
  struct threadsinfo *threadsinfo_p;
  threadsinfo_p=thread_info();
  _debug(4, "_thread_info_unlock", "used by %s()", function_name);
  pthread_mutex_unlock(&threadsinfo_p->mutex[(signed long int)2]);
  return rc;
}

// _warning
// file error.h line 39
extern void _warning(const char * const function_name, const char *fmt, ...)
{
  void **args;
  if(*quiet == 0)
  {
    if(*verbose >= 2)
    {
      if(!(error_mutex_p == ((union anonymous *)NULL)))
        pthread_mutex_reltimedlock(error_mutex_p, (signed long int)0, (signed long int)(100 * 1000 * 1000));

      unsigned long int thread;
      thread=pthread_self();
      signed int pid;
      pid=getpid();
      enum outputmethod method = (enum outputmethod)*outputmethod;
      outfunct[(signed long int)method](*debug != 0 ? "Warning (pid: %u; thread: %p): %s(): " : "Warning: ", pid, thread, function_name);
      args = (void **)&fmt;
      voutfunct[(signed long int)method](fmt, args);
      args = ((void **)NULL);
      flushfunct[(signed long int)method](4);
      if(!(error_mutex_p == ((union anonymous *)NULL)))
        pthread_mutex_unlock(error_mutex_p);

    }

  }

}

// adler32_calc
// file calc.c line 41
extern unsigned int adler32_calc(const unsigned char * const data, unsigned int len)
{
  if(!((3u & len) == 0u))
    _warning("adler32_calc", "len [%i] & 3 == %i != 0. Wrong length (not a multiple of 4).", len, len & (unsigned int)3);

  const signed int MOD_ADLER = 65521;
  unsigned int a = (unsigned int)1;
  unsigned int b = (unsigned int)0;
  signed int index = 0;
  for( ; !((unsigned int)index >= len); index = index + 1)
  {
    a = (a + (unsigned int)data[(signed long int)index]) % (unsigned int)MOD_ADLER;
    b = (b + a) % (unsigned int)MOD_ADLER;
  }
  return b << 16 | a;
}

// api_evinfo_initialevmask
// file sync.c line 1247
static inline void api_evinfo_initialevmask(struct ctx *ctx_p, struct api_eventinfo *evinfo_p, signed int isdir)
{
  struct eventinfo evinfo = { .evmask=(unsigned int)0, .seqid_min=0u, .seqid_max=0u,
    .objtype_old=(enum eventobjtype)0, .objtype_new=(enum eventobjtype)0,
    .wd=0, .fsize=0ul,
    .flags=0u };
  evinfo_initialevmask(ctx_p, &evinfo, isdir);
  evinfo_p->evmask = evinfo.evmask;
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// apievinfo2rsynclist
// file sync.c line 2990
extern signed int apievinfo2rsynclist(struct indexes *indexes_p, struct _IO_FILE *listfile, signed int n, struct api_eventinfo *apievinfo)
{
  signed int i;
  if(listfile == ((struct _IO_FILE *)NULL))
  {
    _error("apievinfo2rsynclist", "listfile == NULL.");
    return 22;
  }

  else
  {
    i = 0;
    for( ; !(i >= n); i = i + 1)
      rsync_listpush(indexes_p, (apievinfo + (signed long int)i)->path, (apievinfo + (signed long int)i)->path_len, (enum eventinfo_flags)(apievinfo + (signed long int)i)->flags, (signed int *)(void *)0);
    struct dosync_arg dosync_arg = { .evcount=0, .excf_path={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .outf_path={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .outf=((struct _IO_FILE *)NULL),
    .ctx_p=((struct ctx *)NULL), .indexes_p=((struct indexes *)NULL),
    .data=NULL,
    .linescount=0, .api_ei=((struct api_eventinfo *)NULL), .api_ei_count=0,
    .buf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .include_list={ ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) },
    .include_list_count=0ul,
    .list_type_str=((const char *)NULL), .evmask_str=((const char *)NULL) };
    dosync_arg.outf = listfile;
    g_hash_table_foreach_remove(indexes_p->out_lines_aggr_ht, rsync_aggrout, (void *)&dosync_arg);
    return 0;
  }
}

// arguments_parse
// file main.c line 1698
signed int arguments_parse(signed int argc, char **argv, struct ctx *ctx_p)
{
  signed int c;
  signed int option_index = 0;
  char *optstring;
  void *return_value___builtin_alloca$1;
  return_value___builtin_alloca$1=__builtin_alloca((unsigned long int)((((((122 - 97) + 1) * 3 + 57) - 48) + 1) * 3 + 1));
  optstring = (char *)return_value___builtin_alloca$1;
  char *optstring_ptr = optstring;
  struct option *lo_ptr = long_options;
  char *tmp_post$2;
  char *tmp_post$3;
  char *tmp_post$4;
  char *tmp_post$5;
  for( ; !(lo_ptr->name == ((const char *)NULL)); lo_ptr = lo_ptr + 1l)
    if((768 & lo_ptr->val) == 0)
    {
      tmp_post$2 = optstring_ptr;
      optstring_ptr = optstring_ptr + 1l;
      *tmp_post$2 = (char)(lo_ptr->val & 0xff);
      if(lo_ptr->has_arg == 1)
      {
        tmp_post$3 = optstring_ptr;
        optstring_ptr = optstring_ptr + 1l;
        *tmp_post$3 = (char)58;
      }

      if(lo_ptr->has_arg == 2)
      {
        tmp_post$4 = optstring_ptr;
        optstring_ptr = optstring_ptr + 1l;
        *tmp_post$4 = (char)58;
        tmp_post$5 = optstring_ptr;
        optstring_ptr = optstring_ptr + 1l;
        *tmp_post$5 = (char)58;
      }

    }

  *optstring_ptr = (char)0;
  char *tmp_if_expr$7;
  char *return_value_strdup$6;
  while((_Bool)1)
  {
    c=getopt_long(argc, argv, optstring, long_options, &option_index);
    if(c == -1)
      break;

    signed int ret;
    if(optarg == ((char *)NULL))
      tmp_if_expr$7 = (char *)(void *)0;

    else
    {
      return_value_strdup$6=strdup(optarg);
      tmp_if_expr$7 = return_value_strdup$6;
    }
    ret=parse_parameter(ctx_p, (unsigned short int)c, tmp_if_expr$7, (enum paramsource_enum)PS_ARGUMENT);
    if(!(ret == 0))
      return ret;

  }
  _Bool tmp_if_expr$12;
  signed int tmp_post$9;
  signed int *return_value___errno_location$8;
  if(!(optind >= argc))
  {
    struct synchandler_args *args_p = &ctx_p->synchandler_args[(signed long int)SHARGS_PRIMARY];
    while(!(args_p->c == 0))
    {
      args_p->c = args_p->c - 1;
      free((void *)args_p->v[(signed long int)args_p->c]);
    }
    if(!(1 + optind == argc))
      tmp_if_expr$12 = (_Bool)1;

    else
      tmp_if_expr$12 = *argv[(signed long int)optind] != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$12)
      do
      {
        tmp_post$9 = optind;
        optind = optind + 1;
        char *return_value_strdup$10;
        return_value_strdup$10=strdup(argv[(signed long int)tmp_post$9]);
        signed int return_value_synchandler_arg0$11;
        return_value_synchandler_arg0$11=synchandler_arg0(return_value_strdup$10, (unsigned long int)0, (void *)ctx_p);
        if(!(return_value_synchandler_arg0$11 == 0))
        {
          return_value___errno_location$8=__errno_location();
          return *return_value___errno_location$8;
        }

      }
      while(!(optind >= argc));

  }

  return 0;
}

// argv_dump
// file sync.c line 883
static inline void argv_dump(signed int debug_level, char **argv)
{
  char **argv_p = argv;
  for( ; !(*argv_p == ((char *)NULL)); argv_p = argv_p + 1l)
    if(!(debug_level >= 9))
      _debug(debug_level, "argv_dump", "%p: \"%s\"", *argv_p, *argv_p);

  goto __CPROVER_DUMP_L4;

__CPROVER_DUMP_L4:
  ;
}

// argv_free
// file sync.c line 1540
static void argv_free(char **argv)
{
  char **argv_p = argv;
  char **tmp_post$1;
  while(!(*argv_p == ((char *)NULL)))
  {
    tmp_post$1 = argv_p;
    argv_p = argv_p + 1l;
    free((void *)*tmp_post$1);
  }
  free((void *)argv);
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// becomedaemon
// file main.c line 2257
signed int becomedaemon()
{
  signed int pid;
  signal(13, (void (*)(signed int))1);
  pid=fork();
  signed int *return_value___errno_location$1;
  if(!(pid == -1))
  {
    if(pid == 0)
      goto __CPROVER_DUMP_L2;

  }

  else
  {
    _error("becomedaemon", "Cannot fork().");
    return_value___errno_location$1=__errno_location();
    return *return_value___errno_location$1;

  __CPROVER_DUMP_L2:
    ;
    setsid();
    goto __CPROVER_DUMP_L5;
  }
  _debug(1, "becomedaemon", "fork()-ed, pid is %i.", pid);
  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  *return_value___errno_location$2 = 0;
  exit(0);

__CPROVER_DUMP_L5:
  ;
  return 0;
}

// child_sigchld
// file main.c line 431
void child_sigchld()
{
  signed int return_value_getppid$1;
  return_value_getppid$1=getppid();
  if(return_value_getppid$1 == 1)
  {
    _debug(1, "child_sigchld", "Got SIGCHLD (parent ended). Exit.");
    exit(-1);
    goto __CPROVER_DUMP_L2;
  }


__CPROVER_DUMP_L2:
  ;
}

// closecontrol
// file control.c line 89
static inline void closecontrol(struct ctx *ctx_p)
{
  if(!(ctx_p->socket == 0))
  {
    close(ctx_p->socket);
    ctx_p->socket = 0;
  }

}

// clsyncapi_fork
// file sync.c line 986
extern signed int clsyncapi_fork(struct ctx *ctx_p)
{
  signed int i = 0;
  signed int *return_value___errno_location$1;
  while(!(i >= ctx_p->children))
  {
    signed int return_value_waitpid$2;
    return_value_waitpid$2=waitpid(ctx_p->child_pid[(signed long int)i], (signed int *)(void *)0, 1);
    if(!(return_value_waitpid$2 >= 0))
    {
      return_value___errno_location$1=__errno_location();
      if(*return_value___errno_location$1 == 10)
      {
        ctx_p->children = ctx_p->children - 1;
        ctx_p->child_pid[(signed long int)i] = ctx_p->child_pid[(signed long int)ctx_p->children];
      }

    }

    i = i + 1;
  }
  if(ctx_p->children >= 256)
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    *return_value___errno_location$3 = 125;
    return -1;
  }

  signed int pid;
  pid=fork();
  signed int tmp_post$4 = ctx_p->children;
  ctx_p->children = ctx_p->children + 1;
  ctx_p->child_pid[(signed long int)tmp_post$4] = pid;
  return pid;
}

// clsyncapi_getapiversion
// file main.c line 545
extern signed int clsyncapi_getapiversion()
{
  return 2;
}

// config_block_parse
// file main.c line 2191
signed int config_block_parse(struct ctx *ctx_p, const char * const config_block_name)
{
  signed int rc;
  _debug(1, "config_block_parse", "(ctx_p, \"%s\")", config_block_name);
  ctx_p->config_block = config_block_name;
  rc=configs_parse(ctx_p, (enum paramsource_enum)PS_CONTROL);
  if(rc == 0)
    rc=ctx_check(ctx_p);

  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = rc;
  return *return_value___errno_location$1;
}

// configs_parse
// file main.c line 1783
signed int configs_parse(struct ctx *ctx_p, enum paramsource_enum paramsource)
{
  struct _GKeyFile *gkf;
  gkf=g_key_file_new();
  unsigned long int tmp_if_expr$5;
  unsigned long int return_value_strlen$4;
  if(!(ctx_p->config_path == ((char *)NULL)))
  {
    struct _GError *g_error = (struct _GError *)(void *)0;
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(ctx_p->config_path, "/NULL/");
    if(return_value_strcmp$1 == 0)
    {
      _debug(2, "configs_parse", "Empty path to config file. Don't read any of config files.");
      return 0;
    }

    _debug(1, "configs_parse", "Trying config-file \"%s\" (case #0)", ctx_p->config_path);
    signed int return_value_g_key_file_load_from_file$2;
    return_value_g_key_file_load_from_file$2=g_key_file_load_from_file(gkf, ctx_p->config_path, (enum anonymous$28)G_KEY_FILE_NONE, &g_error);
    if(return_value_g_key_file_load_from_file$2 == 0)
    {
      _error("configs_parse", "Cannot open/parse file \"%s\" (g_error #%u.%u: %s)", ctx_p->config_path, g_error->domain, g_error->code, g_error->message);
      g_key_file_free(gkf);
      return -1;
    }

    else
      gkf_parse(ctx_p, gkf, paramsource);
  }

  else
  {
    char *config_paths[6l] = { ".clsync.conf", "/etc/clsync/clsync.conf", "/etc/clsync.conf", "/usr/local/etc/clsync/clsync.conf", "/usr/local/etc/clsync.conf", (char *)(void *)0 };
    char **config_path_p = config_paths;
    char *config_path_real;
    void *return_value_xmalloc$3;
    return_value_xmalloc$3=xmalloc((unsigned long int)4096);
    config_path_real = (char *)return_value_xmalloc$3;
    unsigned long int config_path_real_size = (unsigned long int)4096;
    char *homedir;
    homedir=getenv("HOME");
    unsigned long int homedir_len;
    if(homedir == ((char *)NULL))
      tmp_if_expr$5 = (unsigned long int)0;

    else
    {
      return_value_strlen$4=strlen(homedir);
      tmp_if_expr$5 = return_value_strlen$4;
    }
    homedir_len = tmp_if_expr$5;
    while(!(*config_path_p == ((char *)NULL)))
    {
      unsigned long int config_path_len;
      config_path_len=strlen(*config_path_p);
      if(!(config_path_real_size >= 3ul + config_path_len + homedir_len))
      {
        config_path_real_size = config_path_len + homedir_len + (unsigned long int)3;
        void *return_value_xmalloc$6;
        return_value_xmalloc$6=xmalloc(config_path_real_size);
        config_path_real = (char *)return_value_xmalloc$6;
      }

      if(!((signed int)*(*config_path_p) == 47))
      {
        memcpy((void *)config_path_real, (const void *)homedir, homedir_len);
        config_path_real[(signed long int)homedir_len] = (char)47;
        memcpy((void *)&config_path_real[(signed long int)(homedir_len + (unsigned long int)1)], (const void *)*config_path_p, config_path_len + (unsigned long int)1);
      }

      else
        memcpy((void *)config_path_real, (const void *)*config_path_p, config_path_len + (unsigned long int)1);
      _debug(1, "configs_parse", "Trying config-file \"%s\" (case #1)", config_path_real);
      signed int return_value_g_key_file_load_from_file$7;
      return_value_g_key_file_load_from_file$7=g_key_file_load_from_file(gkf, config_path_real, (enum anonymous$28)G_KEY_FILE_NONE, (struct _GError **)(void *)0);
      if(return_value_g_key_file_load_from_file$7 == 0)
      {
        _debug(1, "configs_parse", "Cannot open/parse file \"%s\"", config_path_real);
        config_path_p = config_path_p + 1l;
      }

      else
      {
        gkf_parse(ctx_p, gkf, paramsource);
        break;
      }
    }
    free((void *)config_path_real);
  }
  g_key_file_free(gkf);
  return 0;
}

// control_cleanup
// file control.h line 24
extern signed int control_cleanup(struct ctx *ctx_p)
{
  if(!(ctx_p->socketpath == ((char *)NULL)))
  {
    unlink(ctx_p->socketpath);
    closecontrol(ctx_p);
    socket_deinit();
  }

  return 0;
}

// control_dump
// file control.c line 46
signed int control_dump(struct ctx *ctx_p, struct clsyncsock *clsyncsock_p, struct sockcmd *sockcmd_p)
{
  struct sockcmd_dat_dump *dat = (struct sockcmd_dat_dump *)sockcmd_p->data;
  _debug(3, "control_dump", "%s", (const void *)dat->dir_path);
  signed int return_value_sync_dump$1;
  return_value_sync_dump$1=sync_dump(ctx_p, dat->dir_path);
  signed int tmp_if_expr$4;
  signed int return_value_control_error$2;
  signed int return_value_socket_reply$3;
  if(!(return_value_sync_dump$1 == 0))
  {
    return_value_control_error$2=control_error(clsyncsock_p, sockcmd_p, "sync_dump", dat->dir_path);
    tmp_if_expr$4 = return_value_control_error$2;
  }

  else
  {
    return_value_socket_reply$3=socket_reply(clsyncsock_p, sockcmd_p, (enum sockcmd_id)SOCKCMD_REPLY_DUMP);
    tmp_if_expr$4 = return_value_socket_reply$3;
  }
  return tmp_if_expr$4;
}

// control_error
// file control.c line 40
static inline signed int control_error(struct clsyncsock *clsyncsock_p, struct sockcmd *sockcmd_p, const char * const funct, const char * const args)
{
  signed int *return_value___errno_location$1;
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  return_value___errno_location$1=__errno_location();
  return_value___errno_location$2=__errno_location();
  return_value_strerror$3=strerror(*return_value___errno_location$2);
  _debug(3, "control_error", "%s(%s): %u: %s", funct, args, *return_value___errno_location$1, return_value_strerror$3);
  signed int *return_value___errno_location$4;
  return_value___errno_location$4=__errno_location();
  signed int *return_value___errno_location$5;
  return_value___errno_location$5=__errno_location();
  char *return_value_strerror$6;
  return_value_strerror$6=strerror(*return_value___errno_location$5);
  signed int return_value_socket_reply$7;
  return_value_socket_reply$7=socket_reply(clsyncsock_p, sockcmd_p, (enum sockcmd_id)SOCKCMD_REPLY_ECUSTOM, funct, args, *return_value___errno_location$4, return_value_strerror$6);
  return return_value_socket_reply$7;
}

// control_loop
// file control.c line 96
signed int control_loop(struct ctx *ctx_p)
{
  _debug(1, "control_loop", "started (ctx_p->socket == %u)", ctx_p->socket);
  signed int s;
  do
  {
    s = ctx_p->socket;
    if(s == 0)
      break;

    signed int return_value_socket_check_bysock$1;
    return_value_socket_check_bysock$1=socket_check_bysock(s);
    if(!(return_value_socket_check_bysock$1 == 0))
    {
      _error("control_loop", "Control socket closed [case 0]");
      closecontrol(ctx_p);
    }

    else
    {
      _debug(3, "control_loop", "waiting for events on the socket");
      struct anonymous$3 rfds;
      do
      {
        signed int __d0;
        signed int __d1;
        asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$3) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&rfds)->fds_bits[(signed long int)0]) : "memory");
      }
      while((_Bool)0);
      (&rfds)->fds_bits[(signed long int)(s / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfds)->fds_bits[(signed long int)(s / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << s % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
      signed int count;
      count=select(s + 1, &rfds, (struct anonymous$3 *)(void *)0, (struct anonymous$3 *)(void *)0, (struct timeval *)(void *)0);
      _debug(2, "control_loop", "got %i events with select()", count);
      if(count == 0)
        _debug(2, "control_loop", "select() timed out.");

      else
        if(!(count >= 0))
        {
          _debug(1, "control_loop", "Got negative events count. Closing the socket.");
          closecontrol(ctx_p);
        }

        else
          if((rfds.fds_bits[(signed long int)(s / 8)] & (signed long int)(1UL << s % 8)) == 0l)
          {
            _error("control_loop", "Got event, but not on the control socket. Closing the socket (cannot use \"select()\").");
            closecontrol(ctx_p);
          }

          else
          {
            struct clsyncsock *clsyncsock_p;
            clsyncsock_p=socket_accept(s);
            if(clsyncsock_p == ((struct clsyncsock *)NULL))
            {
              signed int *return_value___errno_location$2;
              return_value___errno_location$2=__errno_location();
              if(*return_value___errno_location$2 == 87)
                continue;

              _error("control_loop", "Cannot socket_accept()");
              closecontrol(ctx_p);
              continue;
            }

            _debug(2, "control_loop", "Starting new thread for new connection.");
            struct socket_sockthreaddata *threaddata_p;
            threaddata_p=socket_thread_attach(clsyncsock_p);
            if(threaddata_p == ((struct socket_sockthreaddata *)NULL))
            {
              _error("control_loop", "Cannot create a thread for connection");
              closecontrol(ctx_p);
            }

            else
            {
              threaddata_p->procfunct = control_procclsyncsock;
              threaddata_p->clsyncsock_p = clsyncsock_p;
              threaddata_p->arg = (void *)ctx_p;
              threaddata_p->running = &ctx_p->socket;
              threaddata_p->authtype = (enum sockauth_id)ctx_p->flags[(signed long int)525];
              threaddata_p->flags = (enum sockprocflags)0;
              signed int return_value_socket_thread_start$3;
              return_value_socket_thread_start$3=socket_thread_start(threaddata_p);
              if(!(return_value_socket_thread_start$3 == 0))
              {
                _error("control_loop", "Cannot start a thread for connection");
                closecontrol(ctx_p);
              }

            }
          }
    }
  }
  while((_Bool)1);
  _debug(1, "control_loop", "control_loop() finished");
  return 0;
}

// control_procclsyncsock
// file control.c line 56
signed int control_procclsyncsock(struct socket_sockthreaddata *arg, struct sockcmd *sockcmd_p)
{
  signed int rc;
  struct clsyncsock *clsyncsock_p = arg->clsyncsock_p;
  struct ctx *ctx_p = (struct ctx *)arg->arg;
  struct sockcmd_dat_set *dat;
  switch((signed int)sockcmd_p->cmd_id)
  {
    case SOCKCMD_REQUEST_DUMP:
    {
      rc=control_dump(ctx_p, clsyncsock_p, sockcmd_p);
      break;
    }
    case SOCKCMD_REQUEST_INFO:
    {
      rc=socket_reply(clsyncsock_p, sockcmd_p, (enum sockcmd_id)SOCKCMD_REPLY_INFO, ctx_p->config_block, ctx_p->label, (const void *)ctx_p->flags, (const void *)ctx_p->flags_set);
      break;
    }
    case SOCKCMD_REQUEST_SET:
    {
      dat = (struct sockcmd_dat_set *)sockcmd_p->data;
      rc=ctx_set(ctx_p, dat->key, dat->value);
      if(!(rc == 0))
      {
        control_error(clsyncsock_p, sockcmd_p, "ctx_set", dat->key);
        break;
      }

      rc=socket_reply(clsyncsock_p, sockcmd_p, (enum sockcmd_id)SOCKCMD_REPLY_SET);
      break;
    }
    case SOCKCMD_REQUEST_DIE:
    {
      rc=sync_term(15);
      break;
    }
    default:
      return 22;
  }
  _debug(3, "control_procclsyncsock", "rc == %u", rc);
  return rc;
}

// control_run
// file control.h line 23
extern signed int control_run(struct ctx *ctx_p)
{
  signed int return_value_chmod$3;
  signed int return_value_chown$5;
  if(!(ctx_p->socketpath == ((char *)NULL)))
  {
    signed int ret = 0;
    signed int s = -1;
    ret=socket_init();
    if(!(ret == 0))
      _error("control_run", "Cannot init clsync-sockets subsystem.");

    if(ret == 0)
    {
      struct clsyncsock *clsyncsock;
      clsyncsock=socket_listen_unix(ctx_p->socketpath);
      if(clsyncsock == ((struct clsyncsock *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        ret = *return_value___errno_location$1;
      }

      else
      {
        s = clsyncsock->sock;
        socket_cleanup(clsyncsock);
      }
    }

    if(ret == 0)
    {
      if(!(ctx_p->flags[526l] == 0))
      {
        return_value_chmod$3=chmod(ctx_p->socketpath, ctx_p->socketmod);
        if(!(return_value_chmod$3 == 0))
        {
          _error("control_run", "Error, Cannot chmod(\"%s\", %o)", ctx_p->socketpath, ctx_p->socketmod);
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          ret = *return_value___errno_location$2;
        }

      }

      if(!(ctx_p->flags[527l] == 0))
      {
        return_value_chown$5=chown(ctx_p->socketpath, ctx_p->socketuid, ctx_p->socketgid);
        if(!(return_value_chown$5 == 0))
        {
          _error("control_run", "Error, Cannot chown(\"%s\", %u, %u)", ctx_p->socketpath, ctx_p->socketuid, ctx_p->socketgid);
          signed int *return_value___errno_location$4;
          return_value___errno_location$4=__errno_location();
          ret = *return_value___errno_location$4;
        }

      }

    }

    if(!(ret == 0))
    {
      close(s);
      return ret;
    }

    ctx_p->socket = s;
    _debug(2, "control_run", "ctx_p->socket = %u", ctx_p->socket);
    ret=pthread_create(&pthread_control, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))control_loop, (void *)ctx_p);
  }

  return 0;
}

// ctx_check
// file main.c line 1846
signed int ctx_check(struct ctx *ctx_p)
{
  signed int ret = 0;
  if(!(ctx_p->socketpath == ((char *)NULL)))
  {
    if(ctx_p->flags[525l] == SOCKAUTH_UNSET)
      ctx_p->flags[(signed long int)525] = SOCKAUTH_NULL;

  }

  if(!(ctx_p->flags[527l] == 0))
  {
    if(ctx_p->socketpath == ((char *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      *return_value___errno_location$1 = 22;
      ret = *return_value___errno_location$1;
      _error("ctx_check", "\"--socket-own\" is useless without \"--socket\"");
    }

  }

  if(!(ctx_p->flags[526l] == 0))
  {
    if(ctx_p->socketpath == ((char *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      *return_value___errno_location$2 = 22;
      ret = *return_value___errno_location$2;
      _error("ctx_check", "\"--socket-mod\" is useless without \"--socket\"");
    }

  }

  if(!(ctx_p->flags[525l] == 0))
  {
    if(ctx_p->socketpath == ((char *)NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      *return_value___errno_location$3 = 22;
      ret = *return_value___errno_location$3;
      _error("ctx_check", "\"--socket-auth\" is useless without \"--socket\"");
    }

  }

  if(!(ctx_p->flags[543l] == PW_OFF))
  {
    if(ctx_p->chroot_dir == ((char *)NULL))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      *return_value___errno_location$4 = 22;
      ret = *return_value___errno_location$4;
      _error("ctx_check", "\"--pivot-root\" cannot be used without \"--chroot\"");
    }

  }

  if(!(ctx_p->flags[543l] == PW_OFF))
  {
    if(!(ctx_p->mountpoints == 0))
      _warning("ctx_check", "\"--mountpoints\" is set while \"--pivot-root\" is set, too");

  }

  if(!(ctx_p->flags[521l] == 0))
  {
    if(ctx_p->flags[77l] == 1)
    {
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      *return_value___errno_location$5 = 22;
      ret = *return_value___errno_location$5;
      _error("ctx_check", "Sorry but option \"--standby-file\" cannot be used in mode \"simple\", yet.");
    }

  }

  if(!(ctx_p->flags[112l] == 0))
  {
    if(!(ctx_p->flags[519l] == 0))
    {
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      *return_value___errno_location$6 = 22;
      ret = *return_value___errno_location$6;
      _error("ctx_check", "Conflicting options: This value of \"--threading\" cannot be used in conjunction with \"--only-initialsync\".");
    }

  }

  if(!(ctx_p->flags[112l] == 0))
  {
    if(!(ctx_p->flags[520l] == 0))
    {
      signed int *return_value___errno_location$7;
      return_value___errno_location$7=__errno_location();
      *return_value___errno_location$7 = 22;
      ret = *return_value___errno_location$7;
      _error("ctx_check", "Conflicting options: This value of \"--threading\" cannot be used in conjunction with \"--exit-on-no-events\".");
    }

  }

  if(!(ctx_p->flags[112l] == 0))
  {
    if(!(ctx_p->flags[528l] == 0))
    {
      signed int *return_value___errno_location$8;
      return_value___errno_location$8=__errno_location();
      *return_value___errno_location$8 = 22;
      ret = *return_value___errno_location$8;
      _error("ctx_check", "Conflicting options: This value of \"--threading\" cannot be used in conjunction with \"--max-iterations\".");
    }

  }

  if(!(ctx_p->flags[112l] == 0))
  {
    if(!(ctx_p->flags[524l] == 0))
    {
      signed int *return_value___errno_location$9;
      return_value___errno_location$9=__errno_location();
      *return_value___errno_location$9 = 22;
      ret = *return_value___errno_location$9;
      _error("ctx_check", "Conflicting options: This value of \"--threading\" cannot be used in conjunction with \"--pre-exit-hook\".");
    }

  }

  if(!(ctx_p->flags[112l] == 0))
  {
    if(ctx_p->flags[538l] == 1)
    {
      signed int *return_value___errno_location$10;
      return_value___errno_location$10=__errno_location();
      *return_value___errno_location$10 = 22;
      ret = *return_value___errno_location$10;
      _error("ctx_check", "Conflicting options: This value of \"--threading\" cannot be used in conjunction with \"--splitting=thread\".");
    }

  }

  if(!(ctx_p->flags[518l] == 0))
  {
    if(!(ctx_p->flags[520l] == 0))
    {
      signed int *return_value___errno_location$11;
      return_value___errno_location$11=__errno_location();
      *return_value___errno_location$11 = 22;
      ret = *return_value___errno_location$11;
      _error("ctx_check", "Conflicting options: \"--skip-initialsync\" and \"--exit-on-no-events\" cannot be used together.");
    }

  }

  if(!(ctx_p->flags[519l] == 0))
  {
    if(!(ctx_p->flags[520l] == 0))
    {
      signed int *return_value___errno_location$12;
      return_value___errno_location$12=__errno_location();
      *return_value___errno_location$12 = 22;
      ret = *return_value___errno_location$12;
      _error("ctx_check", "Conflicting options: \"--only-initialsync\" and \"--exit-on-no-events\" cannot be used together.");
    }

  }

  if(!(ctx_p->flags[518l] == 0))
  {
    if(!(ctx_p->flags[519l] == 0))
    {
      signed int *return_value___errno_location$13;
      return_value___errno_location$13=__errno_location();
      *return_value___errno_location$13 = 22;
      ret = *return_value___errno_location$13;
      _error("ctx_check", "Conflicting options: \"--skip-initialsync\" and \"--only-initialsync\" cannot be used together.");
    }

  }

  if(!(ctx_p->flags[70l] == 0))
  {
    if(!(ctx_p->flags[518l] == 0))
    {
      signed int *return_value___errno_location$14;
      return_value___errno_location$14=__errno_location();
      *return_value___errno_location$14 = 22;
      ret = *return_value___errno_location$14;
      _error("ctx_check", "Conflicting options: \"--full-initialsync\" and \"--skip-initialsync\" cannot be used together.");
    }

  }

  if(!(ctx_p->flags[555l] == 0))
  {
    if(!((1 & ctx_p->flags[556l]) == 0))
    {
      signed int *return_value___errno_location$15;
      return_value___errno_location$15=__errno_location();
      *return_value___errno_location$15 = 22;
      ret = *return_value___errno_location$15;
      _error("ctx_check", "Conflicting options: \"--modification-signature\" and \"--cancel-syscalls=mon_stat\" cannot be used together.");
    }

  }

  if(!(ctx_p->flags[88l] == 0))
    ctx_p->flags[(signed long int)516] = 1;

  if(ctx_p->flags[77l] == 0)
  {
    signed int *return_value___errno_location$16;
    return_value___errno_location$16=__errno_location();
    *return_value___errno_location$16 = 22;
    ret = *return_value___errno_location$16;
    _error("ctx_check", "\"--mode\" is not set.");
  }

  if(ctx_p->watchdir == ((char *)NULL))
  {
    signed int *return_value___errno_location$17;
    return_value___errno_location$17=__errno_location();
    *return_value___errno_location$17 = 22;
    ret = *return_value___errno_location$17;
    _error("ctx_check", "\"--watch-dir\" is not set.");
  }

  if(ctx_p->handlerfpath == ((char *)NULL))
    switch(ctx_p->flags[(signed long int)77])
    {
      case 2:
      {
        ctx_p->handlerfpath = "cp";
        break;
      }
      case 5:
      {
        ctx_p->handlerfpath = "rsync";
        break;
      }
      default:
      {
        signed int *return_value___errno_location$18;
        return_value___errno_location$18=__errno_location();
        *return_value___errno_location$18 = 22;
        ret = *return_value___errno_location$18;
        _error("ctx_check", "\"--sync-handler\" path is not set.");
      }
    }

  if(ctx_p->flags[77l] == 5)
  {
    if(ctx_p->destdir == ((char *)NULL))
    {
      signed int *return_value___errno_location$19;
      return_value___errno_location$19=__errno_location();
      *return_value___errno_location$19 = 22;
      ret = *return_value___errno_location$19;
      _error("ctx_check", "Mode \"rsyncdirect\" cannot be used without specifying \"--dest-dir\".");
    }

  }

  if(ctx_p->flags[77l] == 6)
  {
    ctx_p->synchandler_argf = ctx_p->synchandler_argf | (enum shflags)SHFL_EXCLUDE_LIST_PATH;
    ctx_p->synchandler_argf = ctx_p->synchandler_argf | (enum shflags)SHFL_INCLUDE_LIST_PATH;
  }

  _Bool tmp_if_expr$20;
  _Bool tmp_if_expr$21;
  if(!(ctx_p->flags[514l] == 0))
  {
    if(ctx_p->flags[77l] == 5)
      tmp_if_expr$20 = (_Bool)1;

    else
      tmp_if_expr$20 = ctx_p->flags[(signed long int)77] == 4 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$20)
      tmp_if_expr$21 = (_Bool)1;

    else
      tmp_if_expr$21 = ctx_p->flags[(signed long int)77] == 6 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$21)
      _warning("ctx_check", "Option \"--rsyncpreferinclude\" is useless if mode is not \"rsyncdirect\", \"rsyncshell\" or \"rsyncso\".");

  }

  _Bool tmp_if_expr$23;
  _Bool tmp_if_expr$24;
  if(!(ctx_p->flags[512l] == 0))
  {
    if(ctx_p->flags[77l] == 5)
      tmp_if_expr$23 = (_Bool)1;

    else
      tmp_if_expr$23 = ctx_p->flags[(signed long int)77] == 4 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$23)
      tmp_if_expr$24 = (_Bool)1;

    else
      tmp_if_expr$24 = ctx_p->flags[(signed long int)77] == 6 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$24)
    {
      signed int *return_value___errno_location$22;
      return_value___errno_location$22=__errno_location();
      *return_value___errno_location$22 = 22;
      ret = *return_value___errno_location$22;
      _error("ctx_check", "Option \"--have-recursive-sync\" with nodes \"rsyncdirect\", \"rsyncshell\" and \"rsyncso\" are incompatible.");
    }

  }

  if(!(ctx_p->flags[515l] == 0))
  {
    if(ctx_p->listoutdir == ((char *)NULL))
    {
      signed int *return_value___errno_location$25;
      return_value___errno_location$25=__errno_location();
      *return_value___errno_location$25 = 22;
      ret = *return_value___errno_location$25;
      _error("ctx_check", "Option \"--dir-lists\" should be set to use option \"--synclist-simplify\".");
    }

  }

  _Bool tmp_if_expr$27;
  _Bool tmp_if_expr$28;
  if(!(ctx_p->flags[515l] == 0))
  {
    if(ctx_p->flags[77l] == 5)
      tmp_if_expr$27 = (_Bool)1;

    else
      tmp_if_expr$27 = ctx_p->flags[(signed long int)77] == 4 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$27)
      tmp_if_expr$28 = (_Bool)1;

    else
      tmp_if_expr$28 = ctx_p->flags[(signed long int)77] == 6 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$28)
    {
      signed int *return_value___errno_location$26;
      return_value___errno_location$26=__errno_location();
      *return_value___errno_location$26 = 22;
      ret = *return_value___errno_location$26;
      _error("ctx_check", "Option \"--synclist-simplify\" with nodes \"rsyncdirect\" and \"rsyncshell\" are incompatible.");
    }

  }

  if(ctx_p->flags[532l] == NE_INOTIFY || ctx_p->flags[532l] == NE_GIO)
    goto __CPROVER_DUMP_L46;

  signed int *return_value___errno_location$29;
  return_value___errno_location$29=__errno_location();
  *return_value___errno_location$29 = 22;
  ret = *return_value___errno_location$29;
  _error("ctx_check", "Required one of the next options: \"--monitor=inotify\" \"--monitor=gio\"");

__CPROVER_DUMP_L46:
  ;
  signed int *return_value___errno_location$30;
  if(!(ctx_p->flags[522l] == 0))
  {
    signed int return_value_access$31;
    return_value_access$31=access(ctx_p->exithookfile, 1);
    if(return_value_access$31 == -1)
    {
      _error("ctx_check", "\"%s\" is not executable.", ctx_p->exithookfile);
      if(ret == 0)
      {
        return_value___errno_location$30=__errno_location();
        ret = *return_value___errno_location$30;
      }

    }

  }

  if(!(ctx_p->flags[542l] == 0))
  {
    if(ctx_p->flags[77l] == 2)
    {
      signed int *return_value___errno_location$32;
      return_value___errno_location$32=__errno_location();
      *return_value___errno_location$32 = 22;
      ret = *return_value___errno_location$32;
      _error("ctx_check", "Options --check-execvp-arguments/--secure-splitting cannot be used in conjunction with --mode=direct (see \"man 1 clsync\": --check-execvp-arguments).");
    }

  }

  return ret;
}

// ctx_cleanup
// file main.c line 2225
void ctx_cleanup(struct ctx *ctx_p)
{
  signed int ctx_cleanup$$1$$i = 0;
  for( ; !(ctx_cleanup$$1$$i >= 1024); ctx_cleanup$$1$$i = ctx_cleanup$$1$$i + 1)
    if(!(ctx_p->flags_values_raw[(signed long int)ctx_cleanup$$1$$i] == ((char *)NULL)))
    {
      free((void *)ctx_p->flags_values_raw[(signed long int)ctx_cleanup$$1$$i]);
      ctx_p->flags_values_raw[(signed long int)ctx_cleanup$$1$$i] = (char *)(void *)0;
    }

  signed int n = 0;
  while(!(n >= SHARGS_MAX))
  {
    signed int i = 0;
    signed int e = ctx_p->synchandler_args[(signed long int)n].c;
    for( ; !(i >= e); i = i + 1)
    {
      free((void *)ctx_p->synchandler_args[(signed long int)n].v[(signed long int)i]);
      ctx_p->synchandler_args[(signed long int)n].v[(signed long int)i] = (char *)(void *)0;
    }
    ctx_p->synchandler_args[(signed long int)n].c = 0;
    n = n + 1;
  }
  goto __CPROVER_DUMP_L8;

__CPROVER_DUMP_L8:
  ;
}

// ctx_set
// file main.c line 2205
signed int ctx_set(struct ctx *ctx_p, const char * const parameter_name, const char * const parameter_value)
{
  signed int ret = 2;
  struct option *lo_ptr = long_options;
  while(!(lo_ptr->name == ((const char *)NULL)))
  {
    signed int return_value_strcmp$2;
    return_value_strcmp$2=strcmp(lo_ptr->name, parameter_name);
    if(return_value_strcmp$2 == 0)
    {
      char *return_value_strdup$1;
      return_value_strdup$1=strdup(parameter_value);
      ret=parse_parameter(ctx_p, (unsigned short int)lo_ptr->val, return_value_strdup$1, (enum paramsource_enum)PS_CONTROL);
      break;
    }

    lo_ptr = lo_ptr + 1l;
  }
  ret=ctx_check(ctx_p);
  if(!(ret == 0))
    _critical("ctx_set", "Cannot continue with this setup");

  return ret;
}

// dir_gotevent
// file mon_gio.c line 103
static void dir_gotevent(struct _GFileMonitor *filemon, struct _GFile *file, struct _GFile *file_other, enum anonymous$8 event, void *arg)
{
  enum eventobjtype objtype_old;
  enum eventobjtype objtype_new;
  enum eventobjtype objtype;
  struct filemondata *fmdat = (struct filemondata *)arg;
  struct ctx *ctx_p = fmdat->ctx_p;
  enum anonymous$6 filetype;
  filetype=g_file_query_file_type(file, (enum anonymous$7)G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS, (struct _GCancellable *)(void *)0);
  char *path_full;
  char *path_rel;
  if((signed int)event == G_FILE_MONITOR_EVENT_CHANGED || (signed int)event == G_FILE_MONITOR_EVENT_DELETED || (signed int)event == G_FILE_MONITOR_EVENT_CREATED || (signed int)event == G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED)
  {
    path_full=g_file_get_path(file);
    path_rel=strdup(&path_full[(signed long int)(ctx_p->watchdirlen + (unsigned long int)1)]);
    g_free((void *)path_full);
  }

  if((signed int)filetype == G_FILE_TYPE_DIRECTORY)
  {
    objtype = (enum eventobjtype)EOT_DIR;
    goto __CPROVER_DUMP_L6;
  }

  objtype = (enum eventobjtype)EOT_FILE;

__CPROVER_DUMP_L6:
  ;
  switch((signed int)event)
  {
    case G_FILE_MONITOR_EVENT_DELETED:
    {
      objtype_old = objtype;
      objtype_new = (enum eventobjtype)EOT_DOESNTEXIST;
      break;
    }
    case G_FILE_MONITOR_EVENT_CREATED:
    {
      objtype_old = (enum eventobjtype)EOT_DOESNTEXIST;
      objtype_new = objtype;
      break;
    }
    default:
    {
      objtype_old = objtype;
      objtype_new = objtype;
    }
  }
  switch((signed int)event)
  {
    case G_FILE_MONITOR_EVENT_DELETED:
      g_hash_table_remove(mondirs_ht, (const void *)path_rel);
    case G_FILE_MONITOR_EVENT_CREATED:

    case G_FILE_MONITOR_EVENT_CHANGED:

    case G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED:
    {
      signed int return_value_event_push$1;
      return_value_event_push$1=event_push(path_rel, fmdat->handle_id, event, objtype, objtype_old, objtype_new);
      if(!(return_value_event_push$1 == 0))
        _critical("dir_gotevent", "Assert: event_push(path_rel, fmdat->handle_id, event, objtype, objtype_old, objtype_new)");

    }
    default:
      ;
  }
}

// eidup
// file sync.c line 97
void * eidup(void *ei_gp)
{
  struct eventinfo *ei = (struct eventinfo *)ei_gp;
  struct eventinfo *ei_dup;
  void *return_value_xmalloc$1;
  return_value_xmalloc$1=xmalloc(sizeof(struct eventinfo) /*40ul*/ );
  ei_dup = (struct eventinfo *)return_value_xmalloc$1;
  memcpy((void *)ei_dup, (const void *)ei, sizeof(struct eventinfo) /*40ul*/ );
  return (void *)ei_dup;
}

// error_deinit
// file error.c line 370
extern void error_deinit()
{
  if(!((signed int)ipc_type == IPCT_SHARED))
  {
    if((signed int)ipc_type == IPCT_PRIVATE)
      goto __CPROVER_DUMP_L2;

  }

  else
  {
    pthread_mutex_destroy_shared(error_mutex_p);
    error_mutex_p = (union anonymous *)(void *)0;
  }

__CPROVER_DUMP_L2:
  ;
}

// error_init
// file error.c line 339
extern void error_init(void *_outputmethod, signed int *_quiet, signed int *_verbose, signed int *_debug)
{
  outputmethod = (signed int *)_outputmethod;
  quiet = _quiet;
  verbose = _verbose;
  debug = _debug;
  openlog((const char *)(void *)0, 0x01 | 0x02, 3 << 3);
}

// error_init_ipc
// file error.c line 351
extern void error_init_ipc(enum ipc_type _ipc_type)
{
  ipc_type = _ipc_type;
  switch((signed int)ipc_type)
  {
    case IPCT_SHARED:
    {
      pthread_mutex_init_shared(&error_mutex_p);
      break;
    }
    case IPCT_PRIVATE:
    {
      static union anonymous error_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
      error_mutex_p = &error_mutex;
      pthread_mutex_init(error_mutex_p, (const union anonymous$0 *)(void *)0);
      break;
    }
    default:
      _critical("error_init_ipc", "Unknown ipc_type: %i", ipc_type);
  }
}

// event_free
// file mon_gio.c line 59
static inline void event_free(struct event *ev)
{
  free((void *)ev->path);
}

// event_pop
// file mon_gio.c line 90
static inline struct event * event_pop()
{
  pthread_spin_lock(&queue_lock);
  if(queue_length == 0)
    _critical("event_pop", "Assert: !queue_length");

  queue_length = queue_length - 1;
  static struct event ev;
  memcpy((void *)&ev, (const void *)&queue[(signed long int)queue_length], sizeof(struct event) /*32ul*/ );
  pthread_spin_unlock(&queue_lock);
  return &ev;
}

// event_push
// file mon_gio.c line 64
static inline signed int event_push(char *path, unsigned long int handle_id, enum anonymous$8 event, enum eventobjtype objtype_event, enum eventobjtype objtype_old, enum eventobjtype objtype_new)
{
  struct event *ev;
  pthread_spin_lock(&queue_lock);
  if(queue_length >= queue_alloc)
  {
    queue_alloc = queue_alloc + (1 << 10);
    if(queue_alloc >= 1024)
      _critical("event_push", "Assert: queue_alloc >= (1024*1024)");

    void *return_value_xrealloc$1;
    return_value_xrealloc$1=xrealloc((void *)queue, (unsigned long int)queue_alloc * sizeof(struct event) /*32ul*/ );
    queue = (struct event *)return_value_xrealloc$1;
  }

  signed int tmp_post$2 = queue_length;
  queue_length = queue_length + 1;
  ev = &queue[(signed long int)tmp_post$2];
  ev->path = path;
  ev->event_id = event;
  ev->handle_id = handle_id;
  ev->objtype_event = objtype_event;
  ev->objtype_old = objtype_old;
  ev->objtype_new = objtype_new;
  pthread_spin_unlock(&queue_lock);
  return 0;
}

// evinfo_initialevmask
// file sync.c line 1209
static inline void evinfo_initialevmask(struct ctx *ctx_p, struct eventinfo *evinfo_p, signed int isdir)
{
  switch(ctx_p->flags[(signed long int)532])
  {
    case NE_INOTIFY:
    {
      evinfo_p->evmask = (unsigned int)0x00000100;
      if(!(isdir == 0))
        evinfo_p->evmask = evinfo_p->evmask | (unsigned int)0x40000000;

      break;
    }
    case NE_GIO:
      evinfo_p->evmask = (unsigned int)G_FILE_MONITOR_EVENT_CREATED;
  }
}

// evinfo_merge
// file sync.c line 106
static inline void evinfo_merge(struct ctx *ctx_p, struct eventinfo *evinfo_dst, struct eventinfo *evinfo_src)
{
  _debug(3, "evinfo_merge", "evinfo_dst: seqid_min == %u; seqid_max == %u; objtype_old == %i; objtype_new == %i; \tevinfo_src: seqid_min == %u; seqid_max == %u; objtype_old == %i; objtype_new == %i", evinfo_dst->seqid_min, evinfo_dst->seqid_max, evinfo_dst->objtype_old, evinfo_dst->objtype_new, evinfo_src->seqid_min, evinfo_src->seqid_max, evinfo_src->objtype_old, evinfo_src->objtype_new);
  if(ctx_p->flags[532l] == NE_INOTIFY)
    evinfo_dst->evmask = evinfo_dst->evmask | evinfo_src->evmask;

  evinfo_dst->flags = evinfo_dst->flags | evinfo_src->flags;
  if(!(evinfo_dst->seqid_min + -evinfo_src->seqid_min >= 2147483647u))
  {
    evinfo_dst->objtype_old = evinfo_src->objtype_old;
    evinfo_dst->seqid_min = evinfo_src->seqid_min;
  }

  if(!(evinfo_src->seqid_max + -evinfo_dst->seqid_max >= 2147483647u))
  {
    evinfo_dst->objtype_new = evinfo_src->objtype_new;
    evinfo_dst->seqid_max = evinfo_src->seqid_max;
    if(ctx_p->flags[532l] == NE_GIO)
      evinfo_dst->evmask = evinfo_src->evmask;

  }

}

// exec_argv
// file sync.c line 506
signed int exec_argv(char **argv, signed int *child_pid)
{
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  _debug(3, "exec_argv", "Thread %p.", return_value_pthread_self$1);
  signed int pid;
  signed int status;
  pid=_privileged_fork_execvp(argv[(signed long int)0], (char * const *)argv);
  _debug(3, "exec_argv", "Child pid is %u", pid);
  if(!(child_pid == ((signed int *)NULL)))
    *child_pid = pid;

  signed int return_value_waitpid$4;
  return_value_waitpid$4=waitpid(pid, &status, 0);
  if(!(return_value_waitpid$4 == pid))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    if(*return_value___errno_location$2 == 10)
      _debug(2, "exec_argv", "Child %u is already dead.", pid);

    _error("exec_argv", "Cannot waitid().");
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    return *return_value___errno_location$3;
  }

  /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous$13
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
  ;
  signed int exec_argv$$1$$exitcode = (((union anonymous$13){ .__in=status }).__i & 0xff00) >> 8;
  _debug(3, "exec_argv", "execution completed with exitcode %i", exec_argv$$1$$exitcode);
  return exec_argv$$1$$exitcode;
}

// exitcode_process
// file sync.c line 168
signed int exitcode_process(struct ctx *ctx_p, signed int exitcode)
{
  signed int err;
  err=_exitcode_process(ctx_p, exitcode);
  char *return_value_strerror$1;
  if(!(err == 0))
  {
    return_value_strerror$1=strerror(exitcode);
    _error("exitcode_process", "Got error-report from exitcode_process().\nExitcode is %i, strerror(%i) returns \"%s\". However strerror() is not ensures compliance between exitcode and error description for every utility. So, e.g if you're using rsync, you should look for the error description into rsync's manpage (\"man 1 rsync\"). Also some advices about diagnostics can be found in clsync's manpage (\"man 1 clsync\", see DIAGNOSTICS)", exitcode, exitcode, return_value_strerror$1);
  }

  return err;
}

// fd2fpath_malloc
// file fileutils.c line 26
char * fd2fpath_malloc(signed int fd)
{
  struct stat64 st64;
  if(!(fd >= 1))
  {
    _error("fd2fpath_malloc", "Invalid file descriptor supplied: fd2fpath_malloc(%i).", fd);
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return (char *)(void *)0;
  }

  char *fpath;
  void *return_value_xmalloc$2;
  return_value_xmalloc$2=xmalloc((unsigned long int)((1 << 8) + 2));
  fpath = (char *)return_value_xmalloc$2;
  sprintf(fpath, "/proc/self/fd/%i", fd);
  signed int return_value_lstat64$3;
  return_value_lstat64$3=lstat64(fpath, &st64);
  void *return_value_xrealloc$4;
  if(!(return_value_lstat64$3 == 0))
  {
    _error("fd2fpath_malloc", "Cannot lstat64(\"%s\", st64).", fpath);
    return (char *)(void *)0;
  }

  else
  {
    signed long int fpathlen = st64.st_size;
    if(fpathlen >= 257l)
    {
      return_value_xrealloc$4=xrealloc((void *)fpath, (unsigned long int)(fpathlen + (signed long int)2));
      fpath = (char *)return_value_xrealloc$4;
    }

    _debug(3, "fd2fpath_malloc", "Getting file path from symlink \"%s\". Path length is: %i.", fpath, fpathlen);
    fpathlen=readlink(fpath, fpath, (unsigned long int)(fpathlen + (signed long int)1));
    if(!(fpathlen >= 0l))
    {
      _error("fd2fpath_malloc", "Cannot readlink(\"%s\", fpath, bufsize).", fpath);
      return (char *)(void *)0;
    }

    else
    {
      _debug(3, "fd2fpath_malloc", "The path is: \"%s\"", fpath);
      fpath[fpathlen] = (char)0;
      return fpath;
    }
  }
}

// fileischanged
// file sync.c line 1946
signed int fileischanged(struct ctx *ctx_p, struct indexes *indexes_p, const char *path_rel, struct stat64 *lstat_p, signed int is_deleted)
{
  _Bool tmp_if_expr$1;
  if(lstat_p == ((struct stat64 *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(ctx_p->flags[(signed long int)555] != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 1;

  else
  {
    struct fileinfo *finfo;
    finfo=indexes_fileinfo(indexes_p, path_rel);
    if(!(finfo == ((struct fileinfo *)NULL)))
    {
      unsigned int diff;
      unsigned int return_value_stat_diff$2;
      return_value_stat_diff$2=stat_diff(&finfo->lstat, lstat_p);
      diff = return_value_stat_diff$2 & (unsigned int)ctx_p->flags[(signed long int)555];
      if(diff == 0u)
      {
        _debug(8, "fileischanged", "Modification signature: File not changed: \"%s\"", path_rel);
        return 0;
      }

      _debug(8, "fileischanged", "Modification signature: stat_diff == 0x%o; significant diff == 0x%o (ctx_p->flags[MODSIGN] == 0x%o)", diff, diff & (unsigned int)ctx_p->flags[(signed long int)555], ctx_p->flags[(signed long int)555]);
      if(!(is_deleted == 0))
      {
        _debug(8, "fileischanged", "Modification signature: Deleting information about \"%s\"", path_rel);
        indexes_fileinfo_add(indexes_p, path_rel, (struct fileinfo *)(void *)0);
        free((void *)finfo);
      }

      else
      {
        _debug(8, "fileischanged", "Modification signature: Updating information about \"%s\"", path_rel);
        memcpy((void *)&finfo->lstat, (const void *)lstat_p, sizeof(struct stat64) /*144ul*/ );
      }
    }

    else
    {
      _debug(8, "fileischanged", "There's no information about this file/dir: \"%s\". Just remembering the current state.", path_rel);
      void *return_value_xmalloc$3;
      return_value_xmalloc$3=xmalloc(sizeof(struct fileinfo) /*144ul*/ );
      finfo = (struct fileinfo *)return_value_xmalloc$3;
      memcpy((void *)&finfo->lstat, (const void *)lstat_p, sizeof(struct stat64) /*144ul*/ );
      indexes_fileinfo_add(indexes_p, path_rel, finfo);
    }
    return 1;
  }
}

// fileutils_calcdirlevel
// file fileutils.c line 131
signed short int fileutils_calcdirlevel(const char *path)
{
  signed short int dirlevel = (signed short int)0;
  const char *ptr = path;
  if(path == ((const char *)NULL))
  {
    _error("fileutils_calcdirlevel", "path is NULL.");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return (signed short int)-1;
  }

  if((signed int)*path == 0)
  {
    _error("fileutils_calcdirlevel", "path has zero length.");
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 22;
    return (signed short int)-2;
  }

  if(!((signed int)*path == 47))
  {
    _error("fileutils_calcdirlevel", "path \"%s\" is not canonized.", path);
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    *return_value___errno_location$3 = 22;
    return (signed short int)-3;
  }

  const char *tmp_post$4;
  do
  {
    tmp_post$4 = ptr;
    ptr = ptr + 1l;
    if(*tmp_post$4 == 0)
      break;

    if((signed int)*ptr == 47)
      dirlevel = dirlevel + 1;

  }
  while((_Bool)1);
  return dirlevel;
}

// fileutils_copy
// file fileutils.c line 75
signed int fileutils_copy(const char *path_from, const char *path_to)
{
  char buf[8192l];
  struct _IO_FILE *from;
  struct _IO_FILE *to;
  from=fopen(path_from, "r");
  if(from == ((struct _IO_FILE *)NULL))
  {
    _error("fileutils_copy", "fileutils_copy(\"%s\", \"%s\"): Cannot open file \"%s\" for reading", path_from, path_to, path_from);
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    return *return_value___errno_location$1;
  }

  to=fopen(path_to, "w");
  if(to == ((struct _IO_FILE *)NULL))
  {
    _error("fileutils_copy", "fileutils_copy(\"%s\", \"%s\"): Cannot open file \"%s\" for writing", path_from, path_to, path_to);
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    return *return_value___errno_location$2;
  }

  signed int return_value_feof$3;
  do
  {
    return_value_feof$3=feof(from);
    if(!(return_value_feof$3 == 0))
      break;

    signed int err;
    unsigned long int r;
    unsigned long int w;
    r=fread((void *)buf, (unsigned long int)1, (unsigned long int)8192, from);
    err=ferror(from);
    if(!(err == 0))
    {
      _error("fileutils_copy", "fileutils_copy(\"%s\", \"%s\"): Cannot read from file \"%s\"", path_from, path_to, path_from);
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      return *return_value___errno_location$4;
    }

    w=fwrite((const void *)buf, (unsigned long int)1, r, to);
    err=ferror(to);
    if(!(err == 0))
    {
      _error("fileutils_copy", "fileutils_copy(\"%s\", \"%s\"): Cannot write to file \"%s\"", path_from, path_to, path_to);
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      return *return_value___errno_location$5;
    }

    if(!(r == w))
    {
      _error("fileutils_copy", "fileutils_copy(\"%s\", \"%s\"): Got error while writing to file \"%s\" (%u != %u)", path_from, path_to, path_to, r, w);
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      return *return_value___errno_location$6;
    }

  }
  while((_Bool)1);
  return 0;
}

// finish_iteration
// file sync.c line 84
static inline void finish_iteration(struct ctx *ctx_p)
{
  if(!(ctx_p->iteration_num >= 4294967295u))
    ctx_p->iteration_num = ctx_p->iteration_num + 1u;

  if(ctx_p->flags[112l] == 0)
    setenv_iteration(ctx_p->iteration_num);

  _debug(3, "finish_iteration", "next iteration: %u/%u", ctx_p->iteration_num, ctx_p->flags[(signed long int)528]);
}

// flush_stderr
// file error.c line 79
static void flush_stderr(signed int level)
{
  fprintf(stderr, "\n");
  fflush(stderr);
}

// flush_stdout
// file error.c line 84
static void flush_stdout(signed int level)
{
  fprintf(stdout, "\n");
  fflush(stdout);
}

// fork_helper
// file main.c line 462
signed int fork_helper()
{
  signed int pid;
  pid=fork();
  if(pid == 0)
  {
    parent_pid=getppid();
    sethandler_sigchld(child_sigchld);
    prctl(1, 17);
    return 0;
  }

  else
    return pid;
}

// free_filemondat
// file mon_gio.c line 343
void free_filemondat(void *_fmdat)
{
  struct filemondata *fmdat = (struct filemondata *)_fmdat;
  g_signal_handler_disconnect((void *)fmdat->file, fmdat->handle_id);
  free((void *)fmdat->file);
  free((void *)fmdat->filemon);
  free((void *)fmdat);
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// g_hash_table_dup
// file glibex.c line 43
extern struct _GHashTable * g_hash_table_dup(struct _GHashTable *src, unsigned int (*hash_funct)(const void *), signed int (*key_equal_funct)(const void *, const void *), void (*key_destroy_funct)(void *), void (*value_destroy_funct)(void *), void * (*key_dup_funct)(void *), void * (*value_dup_funct)(void *))
{
  struct _GHashTable *dst;
  dst=g_hash_table_new_full(hash_funct, key_equal_funct, key_destroy_funct, value_destroy_funct);
  struct keyvalue_copy_arg arg;
  arg.$anon0.ht_dst = dst;
  arg.k_dup_funct = key_dup_funct;
  arg.v_dup_funct = value_dup_funct;
  g_hash_table_foreach(src, g_hash_table_dup_item, (void *)&arg);
  return dst;
}

// g_hash_table_dup_item
// file glibex.c line 33
void g_hash_table_dup_item(void *k, void *v, void *arg_gp)
{
  struct _GHashTable *ht_dst = ((struct keyvalue_copy_arg *)arg_gp)->$anon0.ht_dst;
  void * (*k_dup_funct)(void *) = ((struct keyvalue_copy_arg *)arg_gp)->k_dup_funct;
  void * (*v_dup_funct)(void *) = ((struct keyvalue_copy_arg *)arg_gp)->v_dup_funct;
  void *tmp_if_expr$1;
  void *return_value;
  if(k_dup_funct == ((void * (*)(void *))NULL))
    tmp_if_expr$1 = (void *)0;

  else
  {
    return_value=k_dup_funct(k);
    tmp_if_expr$1 = return_value;
  }
  void *tmp_if_expr$2;
  void *return_value_1;
  if(v_dup_funct == ((void * (*)(void *))NULL))
    tmp_if_expr$2 = (void *)0;

  else
  {
    return_value_1=v_dup_funct(v);
    tmp_if_expr$2 = return_value_1;
  }
  g_hash_table_insert(ht_dst, tmp_if_expr$1, tmp_if_expr$2);
  goto __CPROVER_DUMP_L5;

__CPROVER_DUMP_L5:
  ;
}

// g_iteration_stop
// file mon_gio.c line 201
void * g_iteration_stop(void *_timeout_p)
{
  struct timeval *timeout_p = (struct timeval *)_timeout_p;
  struct timeval tv_abs;
  struct timeval timeout_abs;
  struct timespec ts_abs;
  signed int return_value_pthread_mutex_lock$1;
  return_value_pthread_mutex_lock$1=pthread_mutex_lock(&gio_mutex_prefetcher);
  if(!(return_value_pthread_mutex_lock$1 == 0))
    _critical("g_iteration_stop", "Assert: pthread_mutex_lock(&gio_mutex_prefetcher)");

  if(!(cancel_g_iteration_stop == 0))
  {
    signed int return_value_pthread_mutex_unlock$2;
    return_value_pthread_mutex_unlock$2=pthread_mutex_unlock(&gio_mutex_prefetcher);
    if(!(return_value_pthread_mutex_unlock$2 == 0))
      _critical("g_iteration_stop", "Assert: pthread_mutex_unlock(&gio_mutex_prefetcher)");

    return (void *)0;
  }

  else
  {
    if(timeout_p->tv_sec >= 315360001l)
      timeout_p->tv_sec = (signed long int)(3600 * 24 * 365 * 10);

    gettimeofday(&tv_abs, (struct timezone *)(void *)0);
    do
    {
      (&timeout_abs)->tv_sec = (&tv_abs)->tv_sec + timeout_p->tv_sec;
      (&timeout_abs)->tv_usec = (&tv_abs)->tv_usec + timeout_p->tv_usec;
      if(timeout_abs.tv_usec >= 1000000l)
      {
        (&timeout_abs)->tv_sec = (&timeout_abs)->tv_sec + 1l;
        (&timeout_abs)->tv_usec = (&timeout_abs)->tv_usec - (signed long int)1000000;
      }

    }
    while((_Bool)0);
    ts_abs.tv_sec = timeout_abs.tv_sec;
    ts_abs.tv_nsec = timeout_abs.tv_usec * (signed long int)1000;
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    *return_value___errno_location$3=pthread_cond_timedwait(&gio_cond_gotevent, &gio_mutex_prefetcher, &ts_abs);
    if(*return_value___errno_location$3 == 0 || *return_value___errno_location$3 == 110)
      goto __CPROVER_DUMP_L13;

    _critical("g_iteration_stop", "Got error while pthread_cond_timedwait(&gio_cond_gotevent, &gio_mutex_prefetcher, &ts_abs)");

  __CPROVER_DUMP_L13:
    ;
    g_main_context_wakeup((struct _GMainContext *)(void *)0);
    pthread_mutex_unlock(&gio_mutex_prefetcher);
    return (void *)0;
  }
}

// g_tree_dup
// file glibex.c line 66
extern struct _GTree * g_tree_dup(struct _GTree *src, signed int (*key_compare_func)(const void *, const void *, void *), void *key_compare_data, void (*key_destroy_func)(void *), void (*value_destroy_func)(void *), void * (*key_dup_funct)(void *), void * (*value_dup_funct)(void *))
{
  struct _GTree *dst;
  dst=g_tree_new_full(key_compare_func, key_compare_data, key_destroy_func, value_destroy_func);
  struct keyvalue_copy_arg arg;
  arg.$anon0.bt_dst = dst;
  arg.k_dup_funct = key_dup_funct;
  arg.v_dup_funct = value_dup_funct;
  g_tree_foreach(src, g_tree_dup_item, (void *)&arg);
  return dst;
}

// g_tree_dup_item
// file glibex.c line 56
signed int g_tree_dup_item(void *k, void *v, void *arg_gp)
{
  struct _GTree *bt_dst = ((struct keyvalue_copy_arg *)arg_gp)->$anon0.bt_dst;
  void * (*k_dup_funct)(void *) = ((struct keyvalue_copy_arg *)arg_gp)->k_dup_funct;
  void * (*v_dup_funct)(void *) = ((struct keyvalue_copy_arg *)arg_gp)->v_dup_funct;
  void *tmp_if_expr$1;
  void *return_value;
  if(k_dup_funct == ((void * (*)(void *))NULL))
    tmp_if_expr$1 = (void *)0;

  else
  {
    return_value=k_dup_funct(k);
    tmp_if_expr$1 = return_value;
  }
  void *tmp_if_expr$2;
  void *return_value_1;
  if(v_dup_funct == ((void * (*)(void *))NULL))
    tmp_if_expr$2 = (void *)0;

  else
  {
    return_value_1=v_dup_funct(v);
    tmp_if_expr$2 = return_value_1;
  }
  g_tree_replace(bt_dst, tmp_if_expr$1, tmp_if_expr$2);
  return 0;
}

// gio_add_watch_dir
// file mon_gio.h line 22
extern signed int gio_add_watch_dir(struct ctx *ctx_p, struct indexes *indexes_p, const char * const accpath)
{
  struct filemondata *fmdat;
  struct _GError *error = (struct _GError *)(void *)0;
  _debug(3, "gio_add_watch_dir", "\"%s\"", accpath);
  void *return_value_g_hash_table_lookup$1;
  return_value_g_hash_table_lookup$1=g_hash_table_lookup(mondirs_ht, (const void *)accpath);
  fmdat = (struct filemondata *)return_value_g_hash_table_lookup$1;
  if(!(fmdat == ((struct filemondata *)NULL)))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 98;
    _warning("gio_add_watch_dir", "Directory \"%s\" is already monitored.", accpath);
    return -1;
  }

  void *return_value_xmalloc$3;
  return_value_xmalloc$3=xmalloc(sizeof(struct filemondata) /*32ul*/ );
  fmdat = (struct filemondata *)return_value_xmalloc$3;
  fmdat->ctx_p = ctx_p;
  fmdat->file=g_file_new_for_path(accpath);
  fmdat->filemon=g_file_monitor_directory(fmdat->file, (enum anonymous$9)0, (struct _GCancellable *)(void *)0, &error);
  fmdat->handle_id=g_signal_connect_data((void *)fmdat->filemon, "changed", (void (*)(void))dir_gotevent, (void *)fmdat, (void (*)(void *, struct _GClosure *))(void *)0, (enum anonymous$5)0);
  char *return_value_strdup$4;
  return_value_strdup$4=strdup(accpath);
  g_hash_table_replace(mondirs_ht, (void *)return_value_strdup$4, (void *)fmdat);
  return (signed int)fmdat->handle_id;
}

// gio_deinit
// file mon_gio.h line 24
extern signed int gio_deinit(struct ctx *ctx_p)
{
  return 0;
}

// gio_handle
// file mon_gio.h line 21
extern signed int gio_handle(struct ctx *ctx_p, struct indexes *indexes_p)
{
  signed int count;
  char *path_full = (char *)(void *)0;
  unsigned long int path_full_len = (unsigned long int)0;
  count = 0;
  signed int return_value_gio_wait$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  signed int return_value_lstat64$3;
  do
  {
    static struct timeval tv = { .tv_sec=(signed long int)0, .tv_usec=0l };
    return_value_gio_wait$1=gio_wait(ctx_p, indexes_p, &tv);
    if(return_value_gio_wait$1 == 0)
      break;

    struct event *ev;
    ev=event_pop();
    struct stat64 lstat;
    struct stat64 *lstat_p;
    unsigned int st_mode;
    unsigned long int st_size;
    if((signed int)ev->objtype_new == EOT_DOESNTEXIST)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (ctx_p->flags[(signed long int)556] & 1) != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_lstat64$3=lstat64(ev->path, &lstat);
      tmp_if_expr$4 = return_value_lstat64$3 != 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
    {
      _debug(2, "gio_handle", "Cannot lstat64(\"%s\", lstat). Seems, that the object had been deleted (%i) or option \"--cancel-syscalls mon_stat\" (%i) is set.", ev->path, (signed int)ev->objtype_new == EOT_DOESNTEXIST, ctx_p->flags[(signed long int)556] & 1);
      st_mode = (unsigned int)((signed int)ev->objtype_event == EOT_DIR ? 0040000 : 0100000);
      st_size = (unsigned long int)0;
      lstat_p = (struct stat64 *)(void *)0;
    }

    else
    {
      st_mode = lstat.st_mode;
      st_size = (unsigned long int)lstat.st_size;
      lstat_p = &lstat;
    }
    signed int return_value_sync_prequeue_loadmark$5;
    return_value_sync_prequeue_loadmark$5=sync_prequeue_loadmark(1, ctx_p, indexes_p, (const char *)(void *)0, ev->path, lstat_p, ev->objtype_old, ev->objtype_new, (unsigned int)ev->event_id, (signed int)ev->handle_id, st_mode, (signed long int)st_size, &path_full, &path_full_len, (struct eventinfo *)(void *)0);
    if(!(return_value_sync_prequeue_loadmark$5 == 0))
    {
      event_free(ev);
      count = -1;
      break;
    }

    event_free(ev);
    count = count + 1;
  }
  while((_Bool)1);
  sync_prequeue_unload(ctx_p, indexes_p);
  free((void *)path_full);
  return count;
}

// gio_init
// file mon_gio.h line 23
extern signed int gio_init(struct ctx *ctx_p)
{
  queue_length = 0;
  queue_alloc = 0;
  pthread_mutex_init(&gio_mutex_prefetcher, (const union anonymous$0 *)(void *)0);
  pthread_cond_init(&gio_cond_gotevent, (const union anonymous$0 *)(void *)0);
  pthread_spin_init(&queue_lock, 1);
  mondirs_ht=g_hash_table_new_full(g_str_hash, g_str_equal, free, free_filemondat);
  gio_loop=g_main_loop_new((struct _GMainContext *)(void *)0, (signed int)!(0 != 0));
  g_main_context_iteration((struct _GMainContext *)(void *)0, 0);
  return 0;
}

// gio_wait
// file mon_gio.h line 20
extern signed int gio_wait(struct ctx *ctx_p, struct indexes *indexes_p, struct timeval *tv_p)
{
  signed int ret;
  signed int return_value_pthread_spin_lock$1;
  ret=gio_wait_now(ctx_p, indexes_p, tv_p);
  signed int return_value_pthread_spin_unlock$2;
  return ret;
}

// gio_wait_now
// file mon_gio.c line 238
static inline signed int gio_wait_now(struct ctx *ctx_p, struct indexes *indexes_p, struct timeval *tv_p)
{
  void *ret;
  signed int result;
  signed long int tmp_if_expr$1;
  signed long int tmp_if_expr$2;
  if(tv_p == ((struct timeval *)NULL))
    tmp_if_expr$1 = (signed long int)-1;

  else
    tmp_if_expr$1 = tv_p->tv_sec;
  if(tv_p == ((struct timeval *)NULL))
    tmp_if_expr$2 = (signed long int)0;

  else
    tmp_if_expr$2 = tv_p->tv_usec;
  _debug(3, "gio_wait_now", "(ctx_p, indexes_p, %p {%u, %u})", tv_p, tmp_if_expr$1, tmp_if_expr$2);
  if(tv_p == ((struct timeval *)NULL))
    _critical("gio_wait_now", "Assert: tv_p == ((void *)0)");

  signed int return_value_pthread_spin_unlock$3;
  signed int return_value_pthread_spin_lock$4;
  if(!(queue_length == 0))
    return queue_length;

  else
    if(tv_p->tv_sec == 0l)
    {
      if(!(tv_p->tv_usec == 0l))
        goto __CPROVER_DUMP_L11;

      g_main_context_iteration((struct _GMainContext *)(void *)0, 0);
      return queue_length;
    }

    else
    {

    __CPROVER_DUMP_L11:
      ;
      cancel_g_iteration_stop = 0;
      pthread_create(&thread_g_iteration_stop, (const union pthread_attr_t *)(void *)0, g_iteration_stop, (void *)tv_p);
      result=g_main_context_iteration((struct _GMainContext *)(void *)0, (signed int)!(0 != 0));
      signed int return_value_pthread_mutex_lock$5;
      return_value_pthread_mutex_lock$5=pthread_mutex_lock(&gio_mutex_prefetcher);
      if(!(return_value_pthread_mutex_lock$5 == 0))
        _critical("gio_wait_now", "Assert: pthread_mutex_lock(&gio_mutex_prefetcher)");

      cancel_g_iteration_stop = 1;
      signed int return_value_pthread_mutex_unlock$6;
      return_value_pthread_mutex_unlock$6=pthread_mutex_unlock(&gio_mutex_prefetcher);
      if(!(return_value_pthread_mutex_unlock$6 == 0))
        _critical("gio_wait_now", "Assert: pthread_mutex_unlock(&gio_mutex_prefetcher)");

      signed int return_value_pthread_cond_broadcast$7;
      return_value_pthread_cond_broadcast$7=pthread_cond_broadcast(&gio_cond_gotevent);
      if(!(return_value_pthread_cond_broadcast$7 == 0))
        _critical("gio_wait_now", "Assert: pthread_cond_broadcast(&gio_cond_gotevent)");

      signed int return_value_pthread_join$8;
      return_value_pthread_join$8=pthread_join(thread_g_iteration_stop, &ret);
      if(!(return_value_pthread_join$8 == 0))
        _critical("gio_wait_now", "Assert: pthread_join(thread_g_iteration_stop, &ret)");

      return queue_length;
    }
}

// gkf_parse
// file main.c line 1752
void gkf_parse(struct ctx *ctx_p, struct _GKeyFile *gkf, enum paramsource_enum paramsource)
{
  char *config_block = (char *)ctx_p->config_block;
  while(!(config_block == ((char *)NULL)))
  {
    struct option *lo_ptr = long_options;
    if(!(config_block == ctx_p->config_block))
    {
      ctx_p->flags_values_raw[(signed long int)531] = (char *)(void *)0;
      ctx_p->flags_set[(signed long int)531] = 0;
    }

    while(!(lo_ptr->name == ((const char *)NULL)))
    {
      char *value;
      value=g_key_file_get_value(gkf, config_block, lo_ptr->name, (struct _GError **)(void *)0);
      if(!(value == ((char *)NULL)))
      {
        signed int ret;
        ret=parse_parameter(ctx_p, (unsigned short int)lo_ptr->val, value, paramsource);
        if(!(ret == 0))
          exit(ret);

      }

      lo_ptr = lo_ptr + 1l;
    }
    if(!(config_block == ctx_p->config_block))
      free((void *)config_block);

    config_block = ctx_p->flags_values_raw[(signed long int)531];
    if(!(config_block == ((char *)NULL)))
      _debug(2, "gkf_parse", "Next block is: %s", config_block);

  }
  goto __CPROVER_DUMP_L10;

__CPROVER_DUMP_L10:
  ;
}

// hook_preexit
// file sync.c line 3174
void hook_preexit(struct ctx *ctx_p)
{
  _debug(2, "hook_preexit", "\"%s\" \"%s\"", ctx_p->preexithookfile, ctx_p->label);
  char *hook_preexit$$1$$argv[3l] = { ctx_p->preexithookfile, ctx_p->label, (char *)(void *)0 };
  exec_argv(hook_preexit$$1$$argv, (signed int *)(void *)0);
  goto __CPROVER_DUMP_L2;

__CPROVER_DUMP_L2:
  ;
}

// ht_fpath_isincluded
// file sync.c line 2202
struct eventinfo * ht_fpath_isincluded(struct _GHashTable *ht, const char * const fpath)
{
  char *ptr;
  char *end;
  struct eventinfo *evinfo;
  void *return_value_g_hash_table_lookup$1;
  return_value_g_hash_table_lookup$1=g_hash_table_lookup(ht, (const void *)fpath);
  evinfo = (struct eventinfo *)return_value_g_hash_table_lookup$1;
  _debug(5, "ht_fpath_isincluded", "looking up for \"%s\": %p", fpath, evinfo);
  if(!(evinfo == ((struct eventinfo *)NULL)))
    return evinfo;

  else
    if(*fpath == 0)
      return (struct eventinfo *)(void *)0;

    else
    {
      void *return_value_g_hash_table_lookup$2;
      return_value_g_hash_table_lookup$2=g_hash_table_lookup(ht, (const void *)"");
      evinfo = (struct eventinfo *)return_value_g_hash_table_lookup$2;
      if(!(evinfo == ((struct eventinfo *)NULL)))
      {
        _debug(5, "ht_fpath_isincluded", "recursive looking up for \"\": %p (%x: recusively: %x)", evinfo, evinfo->flags, evinfo->flags & (unsigned int)EVIF_RECURSIVELY);
        if((1u & evinfo->flags) == 0u)
          goto __CPROVER_DUMP_L5;

        return evinfo;
      }

      else
      {

      __CPROVER_DUMP_L5:
        ;
        unsigned long int fpath_len;
        fpath_len=strlen(fpath);
        static char buf[4098l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        memcpy((void *)buf, (const void *)fpath, fpath_len + (unsigned long int)1);
        ptr = buf;
        end = &buf[(signed long int)fpath_len];
        for( ; !(ptr >= end); ptr = ptr + 1l)
          if((signed int)*ptr == 47)
          {
            *ptr = (char)0;
            void *return_value_g_hash_table_lookup$3;
            return_value_g_hash_table_lookup$3=g_hash_table_lookup(ht, (const void *)buf);
            evinfo = (struct eventinfo *)return_value_g_hash_table_lookup$3;
            if(!(evinfo == ((struct eventinfo *)NULL)))
            {
              _debug(5, "ht_fpath_isincluded", "recursive looking up for \"%s\": %p (%x: recusively: %x)", (const void *)buf, evinfo, evinfo->flags, evinfo->flags & (unsigned int)EVIF_RECURSIVELY);
              *ptr = (char)47;
              if(!((1u & evinfo->flags) == 0u))
                return evinfo;

            }

          }

        return evinfo;
      }
    }
}

// indexes_add_wd
// file indexes.h line 89
static inline signed int indexes_add_wd(struct indexes *indexes_p, signed int wd, const char *fpath_const, unsigned long int fpathlen)
{
  _debug(4, "indexes_add_wd", "indexes_add_wd(indexes_p, %i, \"%s\", %i)", wd, fpath_const, fpathlen);
  char *fpath;
  void *return_value_xmalloc$1;
  return_value_xmalloc$1=xmalloc(fpathlen + (unsigned long int)1);
  fpath = (char *)return_value_xmalloc$1;
  memcpy((void *)fpath, (const void *)fpath_const, fpathlen + (unsigned long int)1);
  g_hash_table_insert(indexes_p->wd2fpath_ht, (void *)(signed long int)wd, (void *)fpath);
  g_hash_table_insert(indexes_p->fpath2wd_ht, (void *)fpath, (void *)(signed long int)wd);
  return 0;
}

// indexes_addexclude
// file indexes.h line 137
static inline signed int indexes_addexclude(struct indexes *indexes_p, char *fpath, enum eventinfo_flags flags, enum queue_id queue_id)
{
  g_hash_table_replace(indexes_p->exc_fpath_coll_ht[(signed long int)queue_id], (void *)fpath, (void *)(signed long int)flags);
  unsigned int return_value_g_hash_table_size$1;
  return_value_g_hash_table_size$1=g_hash_table_size(indexes_p->exc_fpath_coll_ht[(signed long int)queue_id]);
  _debug(3, "indexes_addexclude", "indexes_addexclude(indexes_p, \"%s\", %i). It's now %i events collected in queue %i.", fpath, queue_id, return_value_g_hash_table_size$1, queue_id);
  return 0;
}

// indexes_addexclude_aggr
// file indexes.h line 144
static inline signed int indexes_addexclude_aggr(struct indexes *indexes_p, char *fpath, enum eventinfo_flags flags)
{
  _debug(3, "indexes_addexclude_aggr", "indexes_addexclude_aggr(indexes_p, \"%s\", %u).", fpath, flags);
  void *flags_gp;
  flags_gp=g_hash_table_lookup(indexes_p->exc_fpath_ht, (const void *)fpath);
  if(!(flags_gp == NULL))
    flags = flags | (enum eventinfo_flags)(signed int)(signed long int)flags_gp;

  if((3 & (signed int)flags) == 3)
    flags = flags & (enum eventinfo_flags)~EVIF_CONTENTRECURSIVELY;

  g_hash_table_replace(indexes_p->exc_fpath_ht, (void *)fpath, (void *)(signed long int)flags);
  _debug(3, "indexes_addexclude_aggr", "indexes_addexclude_aggr(indexes_p, \"%s\", flags): %u.", fpath, flags);
  return 0;
}

// indexes_fileinfo
// file indexes.h line 176
static inline struct fileinfo * indexes_fileinfo(struct indexes *indexes_p, const char *fpath)
{
  void *return_value_g_hash_table_lookup$1;
  return_value_g_hash_table_lookup$1=g_hash_table_lookup(indexes_p->fileinfo_ht, (const void *)fpath);
  return (struct fileinfo *)return_value_g_hash_table_lookup$1;
}

// indexes_fileinfo_add
// file indexes.h line 180
static inline signed int indexes_fileinfo_add(struct indexes *indexes_p, const char *fpath_const, struct fileinfo *fi)
{
  unsigned long int fpathlen;
  fpathlen=strlen(fpath_const);
  _debug(4, "indexes_fileinfo_add", "indexes_add_wd(indexes_p, \"%s\", %p)", fpath_const, fpathlen);
  char *fpath;
  void *return_value_xmalloc$1;
  return_value_xmalloc$1=xmalloc(fpathlen + (unsigned long int)1);
  fpath = (char *)return_value_xmalloc$1;
  memcpy((void *)fpath, (const void *)fpath_const, fpathlen + (unsigned long int)1);
  g_hash_table_insert(indexes_p->fileinfo_ht, (void *)fpath, (void *)fi);
  return 0;
}

// indexes_fpath2ei
// file indexes.h line 101
static inline struct eventinfo * indexes_fpath2ei(struct indexes *indexes_p, const char *fpath)
{
  void *return_value_g_hash_table_lookup$1;
  return_value_g_hash_table_lookup$1=g_hash_table_lookup(indexes_p->fpath2ei_ht, (const void *)fpath);
  return (struct eventinfo *)return_value_g_hash_table_lookup$1;
}

// indexes_fpath2ei_add
// file indexes.h line 105
static inline signed int indexes_fpath2ei_add(struct indexes *indexes_p, char *fpath, struct eventinfo *evinfo)
{
  _debug(5, "indexes_fpath2ei_add", "\"%s\"", fpath);
  g_hash_table_replace(indexes_p->fpath2ei_ht, (void *)fpath, (void *)evinfo);
  return 0;
}

// indexes_fpath2wd
// file indexes.h line 78
static inline signed int indexes_fpath2wd(struct indexes *indexes_p, const char *fpath)
{
  void *gint_p;
  gint_p=g_hash_table_lookup(indexes_p->fpath2wd_ht, (const void *)fpath);
  if(gint_p == NULL)
    return -1;

  else
    return (signed int)(signed long int)gint_p;
}

// indexes_lookupinqueue
// file indexes.h line 120
static inline struct eventinfo * indexes_lookupinqueue(struct indexes *indexes_p, const char *fpath, enum queue_id queue_id)
{
  void *return_value_g_hash_table_lookup$1;
  return_value_g_hash_table_lookup$1=g_hash_table_lookup(indexes_p->fpath2ei_coll_ht[(signed long int)queue_id], (const void *)fpath);
  return (struct eventinfo *)return_value_g_hash_table_lookup$1;
}

// indexes_outaggr_add
// file indexes.h line 161
static inline signed int indexes_outaggr_add(struct indexes *indexes_p, char *outline, enum eventinfo_flags flags)
{
  void *flags_gp;
  flags_gp=g_hash_table_lookup(indexes_p->out_lines_aggr_ht, (const void *)outline);
  if(!(flags_gp == NULL))
    flags = flags | (enum eventinfo_flags)(signed int)(signed long int)flags_gp;

  if((3 & (signed int)flags) == 3)
    flags = flags & (enum eventinfo_flags)~EVIF_CONTENTRECURSIVELY;

  g_hash_table_replace(indexes_p->out_lines_aggr_ht, (void *)outline, (void *)(signed long int)flags);
  _debug(3, "indexes_outaggr_add", "indexes_outaggr_aggr(indexes_p, \"%s\").", outline);
  return 0;
}

// indexes_queueevent
// file indexes.h line 112
static inline signed int indexes_queueevent(struct indexes *indexes_p, char *fpath, struct eventinfo *evinfo, enum queue_id queue_id)
{
  g_hash_table_replace(indexes_p->fpath2ei_coll_ht[(signed long int)queue_id], (void *)fpath, (void *)evinfo);
  unsigned int return_value_g_hash_table_size$1;
  return_value_g_hash_table_size$1=g_hash_table_size(indexes_p->fpath2ei_coll_ht[(signed long int)queue_id]);
  _debug(3, "indexes_queueevent", "indexes_queueevent(indexes_p, \"%s\", evinfo, %i). It's now %i events collected in queue %i.", fpath, queue_id, return_value_g_hash_table_size$1, queue_id);
  return 0;
}

// indexes_queuelen
// file indexes.h line 124
static inline signed int indexes_queuelen(struct indexes *indexes_p, enum queue_id queue_id)
{
  unsigned int return_value_g_hash_table_size$1;
  return_value_g_hash_table_size$1=g_hash_table_size(indexes_p->fpath2ei_coll_ht[(signed long int)queue_id]);
  return (signed int)return_value_g_hash_table_size$1;
}

// indexes_remove_bywd
// file indexes.h line 53
static inline signed int indexes_remove_bywd(struct indexes *indexes_p, signed int wd)
{
  signed int ret = 0;
  char *fpath;
  void *return_value_g_hash_table_lookup$1;
  return_value_g_hash_table_lookup$1=g_hash_table_lookup(indexes_p->wd2fpath_ht, (void *)(signed long int)wd);
  fpath = (char *)return_value_g_hash_table_lookup$1;
  signed int return_value_g_hash_table_remove$2;
  return_value_g_hash_table_remove$2=g_hash_table_remove(indexes_p->wd2fpath_ht, (void *)(signed long int)wd);
  ret = ret | return_value_g_hash_table_remove$2;
  if(fpath == ((char *)NULL))
  {
    _error("indexes_remove_bywd", "Cannot remove from index \"fpath2wd\" by wd %i.", wd);
    return -1;
  }

  else
  {
    signed int return_value_g_hash_table_remove$3;
    return_value_g_hash_table_remove$3=g_hash_table_remove(indexes_p->fpath2wd_ht, (const void *)fpath);
    ret = ret | return_value_g_hash_table_remove$3;
    return ret;
  }
}

// indexes_removefromqueue
// file indexes.h line 128
static inline signed int indexes_removefromqueue(struct indexes *indexes_p, char *fpath, enum queue_id queue_id)
{
  g_hash_table_remove(indexes_p->fpath2ei_coll_ht[(signed long int)queue_id], (const void *)fpath);
  unsigned int return_value_g_hash_table_size$1;
  return_value_g_hash_table_size$1=g_hash_table_size(indexes_p->fpath2ei_coll_ht[(signed long int)queue_id]);
  _debug(3, "indexes_removefromqueue", "indexes_removefromqueue(indexes_p, \"%s\", %i). It's now %i events collected in queue %i.", fpath, queue_id, return_value_g_hash_table_size$1, queue_id);
  return 0;
}

// indexes_wd2fpath
// file indexes.h line 71
static inline char * indexes_wd2fpath(struct indexes *indexes_p, signed int wd)
{
  void *return_value_g_hash_table_lookup$1;
  return_value_g_hash_table_lookup$1=g_hash_table_lookup(indexes_p->wd2fpath_ht, (void *)(signed long int)wd);
  return (char *)return_value_g_hash_table_lookup$1;
}

// inotify_add_watch_dir
// file mon_inotify.h line 22
extern signed int inotify_add_watch_dir(struct ctx *ctx_p, struct indexes *indexes_p, const char * const accpath)
{
  signed int inotify_d = (signed int)(signed long int)ctx_p->fsmondata;
  signed int return_value_inotify_add_watch$1;
  return_value_inotify_add_watch$1=inotify_add_watch(inotify_d, accpath, (unsigned int)(0x00000004 | 0x00000008 | 0x00000100 | 0x00000200 | 0x00000400 | 0x00000800 | 0x00000040 | 0x00000080 | 0x00000002 | 0x02000000));
  return return_value_inotify_add_watch$1;
}

// inotify_deinit
// file mon_inotify.h line 23
extern signed int inotify_deinit(struct ctx *ctx_p)
{
  signed int inotify_d = (signed int)(signed long int)ctx_p->fsmondata;
  _debug(3, "inotify_deinit", "Closing inotify_d");
  signed int return_value_close$1;
  return_value_close$1=close(inotify_d);
  return return_value_close$1;
}

// inotify_handle
// file mon_inotify.h line 21
extern signed int inotify_handle(struct ctx *ctx_p, struct indexes *indexes_p)
{
  signed int inotify_d = (signed int)(signed long int)ctx_p->fsmondata;
  signed int count = 0;
  struct anonymous$3 rfds;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$3) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&rfds)->fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&rfds)->fds_bits[(signed long int)(inotify_d / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfds)->fds_bits[(signed long int)(inotify_d / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << inotify_d % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  char *path_rel = (char *)(void *)0;
  unsigned long int path_rel_len = (unsigned long int)0;
  char *path_full = (char *)(void *)0;
  unsigned long int path_full_size = (unsigned long int)0;
  signed int return_value_select$1;
  char *tmp_if_expr$3;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$8;
  signed int return_value_lstat64$7;
  do
  {
    static struct timeval tv = { .tv_sec=(signed long int)0, .tv_usec=0l };
    return_value_select$1=select(1024, &rfds, (struct anonymous$3 *)(void *)0, (struct anonymous$3 *)(void *)0, &tv);
    if(return_value_select$1 == 0)
      break;

    char buf[8193l];
    unsigned long int r;
    signed long int return_value_read$2;
    return_value_read$2=read(inotify_d, (void *)buf, (unsigned long int)8192);
    r = (unsigned long int)return_value_read$2;
    if(!(r >= 1ul))
    {
      _error("inotify_handle", "Got error while reading events from inotify with read().");
      count = -1;
      break;
    }

    g_hash_table_remove_all(indexes_p->fpath2ei_ht);
    char *ptr = buf;
    char *end = &buf[(signed long int)r];
    while(!(ptr >= end))
    {
      struct inotify_event *event = (struct inotify_event *)ptr;
      if(!((32768u & event->mask) == 0u))
      {
        _debug(2, "inotify_handle", "Cleaning up info about watch descriptor %i.", event->wd);
        indexes_remove_bywd(indexes_p, event->wd);
        ptr = ptr + (signed long int)(sizeof(struct inotify_event) /*16ul*/  + (unsigned long int)event->len);
        count = count + 1;
      }

      else
      {
        char *fpath;
        fpath=indexes_wd2fpath(indexes_p, event->wd);
        if(fpath == ((char *)NULL))
        {
          _debug(2, "inotify_handle", "Event %p on stale watch (wd: %i).", (void *)(signed long int)event->mask, event->wd);
          ptr = ptr + (signed long int)(sizeof(struct inotify_event) /*16ul*/  + (unsigned long int)event->len);
          count = count + 1;
        }

        else
        {
          if(event->len >= 1u)
            tmp_if_expr$3 = event->name;

          else
            tmp_if_expr$3 = "";
          _debug(2, "inotify_handle", "Event %p on \"%s\" (wd: %i; fpath: \"%s\").", (void *)(signed long int)event->mask, tmp_if_expr$3, event->wd, fpath);
          unsigned long int path_full_memreq;
          unsigned long int return_value_strlen$4;
          return_value_strlen$4=strlen(fpath);
          path_full_memreq = return_value_strlen$4 + (unsigned long int)event->len + (unsigned long int)2;
          if(!(path_full_size >= path_full_memreq))
          {
            void *return_value_xrealloc$5;
            return_value_xrealloc$5=xrealloc((void *)path_full, path_full_memreq);
            path_full = (char *)return_value_xrealloc$5;
            path_full_size = path_full_memreq;
          }

          if(event->len >= 1u)
            sprintf(path_full, "%s/%s", fpath, (const void *)event->name);

          else
            sprintf(path_full, "%s", fpath);
          struct recognize_event_return inotify_handle$$1$$2$$2$$r = { .objtype_old=(enum eventobjtype)0, .objtype_new=(enum eventobjtype)0 };
          recognize_event(&inotify_handle$$1$$2$$2$$r, event->mask);
          struct stat64 lstat;
          struct stat64 *lstat_p;
          unsigned int st_mode;
          unsigned long int st_size;
          if((signed int)inotify_handle$$1$$2$$2$$r.objtype_new == EOT_DOESNTEXIST)
            tmp_if_expr$6 = (_Bool)1;

          else
            tmp_if_expr$6 = (ctx_p->flags[(signed long int)556] & 1) != 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$6)
            tmp_if_expr$8 = (_Bool)1;

          else
          {
            return_value_lstat64$7=lstat64(path_full, &lstat);
            tmp_if_expr$8 = return_value_lstat64$7 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$8)
          {
            _debug(2, "inotify_handle", "Cannot lstat64(\"%s\", lstat). Seems, that the object had been deleted (%i) or option \"--cancel-syscalls mon_stat\" (%i) is set.", path_full, (signed int)inotify_handle$$1$$2$$2$$r.objtype_new == EOT_DOESNTEXIST, ctx_p->flags[(signed long int)556] & 1);
            st_mode = (unsigned int)((event->mask & (unsigned int)0x40000000) != 0u ? 0040000 : 0100000);
            st_size = (unsigned long int)0;
            lstat_p = (struct stat64 *)(void *)0;
          }

          else
          {
            st_mode = lstat.st_mode;
            st_size = (unsigned long int)lstat.st_size;
            lstat_p = &lstat;
          }
          signed int return_value_sync_prequeue_loadmark$9;
          return_value_sync_prequeue_loadmark$9=sync_prequeue_loadmark(1, ctx_p, indexes_p, path_full, (const char *)(void *)0, lstat_p, inotify_handle$$1$$2$$2$$r.objtype_old, inotify_handle$$1$$2$$2$$r.objtype_new, event->mask, event->wd, st_mode, (signed long int)st_size, &path_rel, &path_rel_len, (struct eventinfo *)(void *)0);
          if(!(return_value_sync_prequeue_loadmark$9 == 0))
          {
            count = -1;
            goto l_inotify_handle_end;
          }

          ptr = ptr + (signed long int)(sizeof(struct inotify_event) /*16ul*/  + (unsigned long int)event->len);
          count = count + 1;
        }
      }
    }
    sync_prequeue_unload(ctx_p, indexes_p);
  }
  while((_Bool)1);

l_inotify_handle_end:
  ;
  if(!(path_full == ((char *)NULL)))
    free((void *)path_full);

  if(!(path_rel == ((char *)NULL)))
    free((void *)path_rel);

  return count;
}

// inotify_wait
// file mon_inotify.h line 20
extern signed int inotify_wait(struct ctx *ctx_p, struct indexes *indexes_p, struct timeval *tv_p)
{
  signed int inotify_d = (signed int)(signed long int)ctx_p->fsmondata;
  _debug(3, "inotify_wait", "select with timeout %li secs (fd == %u).", tv_p->tv_sec, inotify_d);
  struct anonymous$3 rfds;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$3) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&rfds)->fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&rfds)->fds_bits[(signed long int)(inotify_d / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfds)->fds_bits[(signed long int)(inotify_d / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << inotify_d % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  signed int return_value_select$1;
  return_value_select$1=select(inotify_d + 1, &rfds, (struct anonymous$3 *)(void *)0, (struct anonymous$3 *)(void *)0, tv_p);
  return return_value_select$1;
}

// main
// file main.c line 2355
signed int main(signed int _argc, char **_argv)
{
  struct ctx *ctx_p;
  void *return_value_xcalloc$1;
  return_value_xcalloc$1=xcalloc((unsigned long int)1, sizeof(struct ctx) /*51696ul*/ );
  ctx_p = (struct ctx *)return_value_xcalloc$1;
  argv = _argv;
  argc = _argc;
  signed int ret = 0;
  signed int nret;
  signed int rm_listoutdir = 0;
  signed long int main$$1$$1$$_SAFE_rc = (signed long int)0;
  if(!(main$$1$$1$$_SAFE_rc == 0l))
  {
    _error("main", "Got error while (0)");
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    ret = (signed int)main$$1$$1$$_SAFE_rc;
    *return_value___errno_location$2 = ret;
  }

  main$$1$$1$$_SAFE_rc;
  ctx_p->flags[(signed long int)532] = NE_INOTIFY;
  ctx_p->syncdelay = (unsigned int)30;
  ctx_p->_queues[(signed long int)QUEUE_NORMAL].collectdelay = (unsigned int)30;
  ctx_p->_queues[(signed long int)QUEUE_BIGFILE].collectdelay = (unsigned int)1800;
  ctx_p->_queues[(signed long int)QUEUE_INSTANT].collectdelay = (unsigned int)~0;
  ctx_p->_queues[(signed long int)QUEUE_LOCKWAIT].collectdelay = (unsigned int)~0;
  ctx_p->bfilethreshold = (unsigned long int)(128 * 1024 * 1024);
  ctx_p->rsyncinclimit = (unsigned int)20000;
  ctx_p->synctimeout = (unsigned int)(3600 * 24);
  ctx_p->config_block = "default";
  ctx_p->retries = 1;
  ctx_p->flags[(signed long int)118] = 3;
  ctx_p->flags[(signed long int)543] = PW_OFF;
  ctx_p->pid=getpid();
  error_init((void *)&ctx_p->flags[(signed long int)89], &ctx_p->flags[(signed long int)113], &ctx_p->flags[(signed long int)118], &ctx_p->flags[(signed long int)100]);
  nret=arguments_parse(argc, argv, ctx_p);
  if(!(nret == 0))
    ret = nret;

  if(ret == 0)
  {
    nret=configs_parse(ctx_p, (enum paramsource_enum)PS_CONFIG);
    if(!(nret == 0))
      ret = nret;

  }

  if(ctx_p->flags[559l] == 0)
    ctx_p->privileged_uid=getuid();

  if(ctx_p->flags[560l] == 0)
    ctx_p->privileged_gid=getgid();

  if(ctx_p->flags[539l] == 0)
    ctx_p->synchandler_uid = ctx_p->privileged_uid;

  if(ctx_p->flags[540l] == 0)
    ctx_p->synchandler_gid = ctx_p->privileged_gid;

  if(ctx_p->dump_path == ((char *)NULL))
  {
    char *return_value_strdup$3;
    return_value_strdup$3=strdup("/tmp/clsync-dump-%label%");
    ctx_p->dump_path=parameter_expand(ctx_p, return_value_strdup$3, 2, (signed int *)(void *)0, (signed int *)(void *)0, parameter_get, (void *)ctx_p);
    ctx_p->flags_values_raw[(signed long int)530] = ctx_p->dump_path;
  }

  if(ctx_p->synchandler_args[0l].c == 0)
  {
    char *args_line0 = (char *)(void *)0;
    char *args_line1 = (char *)(void *)0;
    switch(ctx_p->flags[(signed long int)77])
    {
      case 1:
      {
        args_line0 = "sync %label% %EVENT-MASK% %INCLUDE-LIST%";
        break;
      }
      case 2:
      {
        args_line0 = "%INCLUDE-LIST% %destination-dir%/";
        break;
      }
      case 3:
      {
        args_line0 = "synclist %label% %INCLUDE-LIST-PATH%";
        args_line1 = "initialsync %label% %INCLUDE-LIST%";
        break;
      }
      case 5:
      {
        args_line0 = ctx_p->flags[(signed long int)514] != 0 ? "-aH --delete --include-from %INCLUDE-LIST-PATH% --exclude=* %watch-dir%/ %destination-dir%/" : "-aH --delete --exclude-from %EXCLUDE-LIST-PATH% --include-from %INCLUDE-LIST-PATH% --exclude=* %watch-dir%/ %destination-dir%/";
        break;
      }
      case 4:
        args_line0 = ctx_p->flags[(signed long int)514] != 0 ? "rsynclist %label% %INCLUDE-LIST-PATH%" : "rsynclist %label% %INCLUDE-LIST-PATH% %EXCLUDE-LIST-PATH%";
    }
    if(!(args_line0 == ((char *)NULL)))
    {
      char *args_line;
      args_line=strdup(args_line0);
      parse_parameter(ctx_p, (unsigned short int)533, args_line, (enum paramsource_enum)PS_DEFAULTS);
    }

    if(!(args_line1 == ((char *)NULL)))
    {
      char *main$$1$$4$$3$$args_line;
      main$$1$$4$$3$$args_line=strdup(args_line1);
      parse_parameter(ctx_p, (unsigned short int)534, main$$1$$4$$3$$args_line, (enum paramsource_enum)PS_DEFAULTS);
    }

  }

  _debug(4, "main", "ncpus == %u", ncpus);
  _debug(4, "main", "debugging flags: %u %u %u %u", ctx_p->flags[(signed long int)89], ctx_p->flags[(signed long int)113], ctx_p->flags[(signed long int)118], ctx_p->flags[(signed long int)100]);
  signed int *return_value___errno_location$5;
  if(!(ctx_p->watchdir == ((char *)NULL)))
  {
    char *rwatchdir;
    rwatchdir=realpath(ctx_p->watchdir, (char *)(void *)0);
    if(rwatchdir == ((char *)NULL))
    {
      _error("main", "Got error while realpath() on \"%s\" [#0].", ctx_p->watchdir);
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      ret = *return_value___errno_location$4;
    }

    _debug(5, "main", "rwatchdir == \"%s\"", rwatchdir);
    struct stat64 stat64 = { .st_dev=(unsigned long int)0, .st_ino=0ul, .st_nlink=0ul,
    .st_mode=0u, .st_uid=0u, .st_gid=0u,
    .__pad0=0, .st_rdev=0ul, .st_size=0l,
    .st_blksize=0l, .st_blocks=0l, .st_atim={ .tv_sec=0l, .tv_nsec=0l },
    .st_mtim={ .tv_sec=0l, .tv_nsec=0l },
    .st_ctim={ .tv_sec=0l, .tv_nsec=0l },
    .__glibc_reserved={ 0l, 0l, 0l } };
    signed int return_value_lstat64$6;
    return_value_lstat64$6=lstat64(ctx_p->watchdir, &stat64);
    if(!(return_value_lstat64$6 == 0))
    {
      _error("main", "Cannot lstat64() on \"%s\"", ctx_p->watchdir);
      if(ret == 0)
      {
        return_value___errno_location$5=__errno_location();
        ret = *return_value___errno_location$5;
      }

    }

    else
      ctx_p->st_dev = stat64.st_dev;
    if(ret == 0)
    {
      parse_parameter(ctx_p, (unsigned short int)87, rwatchdir, (enum paramsource_enum)PS_CORRECTION);
      ctx_p->watchdirlen=strlen(ctx_p->watchdir);
      ctx_p->watchdirsize = ctx_p->watchdirlen;
    }

    if(ret == 0)
    {
      if(ctx_p->watchdirlen == 1ul)
      {
        ctx_p->watchdirwslash = ctx_p->watchdir;
        ctx_p->watchdirwslashsize = (unsigned long int)0;
        ctx_p->watchdir_dirlevel = (signed short int)0;
      }

      else
      {
        unsigned long int main$$1$$7$$6$$2$$size = ctx_p->watchdirlen + (unsigned long int)2;
        char *newwatchdir;
        void *return_value_xmalloc$7;
        return_value_xmalloc$7=xmalloc(main$$1$$7$$6$$2$$size);
        newwatchdir = (char *)return_value_xmalloc$7;
        memcpy((void *)newwatchdir, (const void *)ctx_p->watchdir, ctx_p->watchdirlen);
        ctx_p->watchdirwslash = newwatchdir;
        ctx_p->watchdirwslashsize = main$$1$$7$$6$$2$$size;
        memcpy((void *)&ctx_p->watchdirwslash[(signed long int)ctx_p->watchdirlen], (const void *)"/", (unsigned long int)2);
        ctx_p->watchdir_dirlevel=fileutils_calcdirlevel(ctx_p->watchdirwslash);
      }
    }

  }

  _Bool tmp_if_expr$11;
  if(!(ctx_p->destdir == ((char *)NULL)))
    tmp_if_expr$11 = ctx_p->destproto == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$11 = (_Bool)0;
  if(tmp_if_expr$11)
  {
    char *rdestdir;
    rdestdir=realpath(ctx_p->destdir, (char *)(void *)0);
    if(rdestdir == ((char *)NULL))
    {
      _error("main", "Got error while realpath() on \"%s\" [#1].", ctx_p->destdir);
      signed int *return_value___errno_location$8;
      return_value___errno_location$8=__errno_location();
      ret = *return_value___errno_location$8;
    }

    _debug(5, "main", "rdestdir == \"%s\"", rdestdir);
    if(ret == 0)
    {
      parse_parameter(ctx_p, (unsigned short int)68, rdestdir, (enum paramsource_enum)PS_CORRECTION);
      ctx_p->destdirlen=strlen(ctx_p->destdir);
      ctx_p->destdirsize = ctx_p->destdirlen;
      if(ctx_p->destdirlen == 1ul)
      {
        signed int *return_value___errno_location$9;
        return_value___errno_location$9=__errno_location();
        *return_value___errno_location$9 = 22;
        ret = *return_value___errno_location$9;
        _error("main", "destdir is supposed to be not \"/\".");
      }

    }

    if(ret == 0)
    {
      unsigned long int size = ctx_p->destdirlen + (unsigned long int)2;
      char *newdestdir;
      void *return_value_xmalloc$10;
      return_value_xmalloc$10=xmalloc(size);
      newdestdir = (char *)return_value_xmalloc$10;
      memcpy((void *)newdestdir, (const void *)ctx_p->destdir, ctx_p->destdirlen);
      ctx_p->destdirwslash = newdestdir;
      ctx_p->destdirwslashsize = size;
      memcpy((void *)&ctx_p->destdirwslash[(signed long int)ctx_p->destdirlen], (const void *)"/", (unsigned long int)2);
    }

  }

  else
    if(!(ctx_p->destproto == ((char *)NULL)))
      ctx_p->destdirwslash = ctx_p->destdir;

  if(!(ctx_p->rulfpath == ((char *)NULL)))
  {
    if(!((signed int)*ctx_p->rulfpath == 47))
    {
      ctx_p->rulfpath=realpath(ctx_p->rulfpath, (char *)(void *)0);
      if(ctx_p->rulfpath == ((char *)NULL))
        _error("main", "Cannot find rules-file. Got error while realpath(\"%s\")", ctx_p->rulfpath);

      else
        ctx_p->rulfpathsize = (unsigned long int)1;
    }

  }

  if(!(ctx_p->handlerfpath == ((char *)NULL)))
  {
    char *rhandlerfpath;
    rhandlerfpath=realpath(ctx_p->handlerfpath, (char *)(void *)0);
    if(!(rhandlerfpath == ((char *)NULL)))
      ctx_p->handlerfpath = rhandlerfpath;

  }

  signed int return_value_chdir$13;
  return_value_chdir$13=chdir(ctx_p->watchdir);
  if(!(return_value_chdir$13 == 0))
  {
    _error("main", "Got error while chdir(\"%s\")", ctx_p->watchdir);
    signed int *return_value___errno_location$12;
    return_value___errno_location$12=__errno_location();
    ret = *return_value___errno_location$12;
  }

  signed int n = 0;
  signed int tmp_post$14;
  while(!(n >= SHARGS_MAX))
  {
    struct synchandler_args *args_p;
    tmp_post$14 = n;
    n = n + 1;
    args_p = &ctx_p->synchandler_args[(signed long int)tmp_post$14];
    signed int i = 0;
    while(!(i >= args_p->c))
    {
      signed int macros_count = -1;
      signed int expanded = -1;
      args_p->v[(signed long int)i]=parameter_expand(ctx_p, args_p->v[(signed long int)i], 4, &macros_count, &expanded, parameter_get_wmacro, (void *)ctx_p);
      if(macros_count == expanded)
        args_p->isexpanded[(signed long int)i] = args_p->isexpanded[(signed long int)i] + 1;

      i = i + 1;
    }
  }
  ctx_p->state = (volatile enum state_enum)STATE_STARTING;
  struct mntent *ent;
  struct _IO_FILE *ent_f = (struct _IO_FILE *)(void *)0;
  if(!(ctx_p->mountpoints == 0))
  {
    ent_f=setmntent("/proc/mounts", "r");
    if(ent_f == ((struct _IO_FILE *)NULL))
    {
      _error("main", "Got error while setmntent(\"/proc/mounts\", \"r\")");
      signed int *return_value___errno_location$15;
      return_value___errno_location$15=__errno_location();
      ret = *return_value___errno_location$15;
    }

  }

  if(!(ctx_p->flags[558l] == 0))
  {
    unshare(0x04000000);
    error_init_ipc((enum ipc_type)(ctx_p->flags[(signed long int)538] == 2 ? IPCT_SHARED : IPCT_PRIVATE));
  }

  if(!(ctx_p->flags[545l] == 0))
  {
    unshare(0x08000000);
    unshare(0x04000000);
    unshare(0x00040000);
  }

  _Bool tmp_if_expr$22;
  if(!(ctx_p->flags[543l] == PW_OFF))
    tmp_if_expr$22 = (_Bool)1;

  else
    tmp_if_expr$22 = ctx_p->mountpoints != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$22)
  {
    signed int return_value_unshare$17;
    return_value_unshare$17=unshare(0x00000400);
    if(!(return_value_unshare$17 == 0))
    {
      _error("main", "Got error from unshare(0x00000400)");
      signed int *return_value___errno_location$16;
      return_value___errno_location$16=__errno_location();
      ret = *return_value___errno_location$16;
    }

    signed int return_value_unshare$19;
    return_value_unshare$19=unshare(0x00000200);
    if(!(return_value_unshare$19 == 0))
    {
      _error("main", "Got error from unshare(0x00000200)");
      signed int *return_value___errno_location$18;
      return_value___errno_location$18=__errno_location();
      ret = *return_value___errno_location$18;
    }

    signed int return_value_unshare$21;
    return_value_unshare$21=unshare(0x00020000);
    if(!(return_value_unshare$21 == 0))
    {
      _error("main", "Got error from unshare(0x00020000)");
      signed int *return_value___errno_location$20;
      return_value___errno_location$20=__errno_location();
      ret = *return_value___errno_location$20;
    }

  }

  signed int return_value_unshare$24;
  if(ctx_p->flags[544l] == DN_EVERYWHERE)
  {
    return_value_unshare$24=unshare(0x40000000);
    if(!(return_value_unshare$24 == 0))
    {
      _error("main", "Got error from unshare(0x40000000)");
      signed int *return_value___errno_location$23;
      return_value___errno_location$23=__errno_location();
      ret = *return_value___errno_location$23;
    }

  }

  signed int return_value_chdir$26;
  signed int return_value_mkdir$29;
  signed int return_value_mkdir$32;
  unsigned long int mount_flags;
  signed int return_value_mount$34;
  if(!(ctx_p->chroot_dir == ((char *)NULL)))
    switch(ctx_p->flags[(signed long int)543])
    {
      case PW_OFF:

      case PW_DIRECT:
        goto __CPROVER_DUMP_L68;
      case PW_AUTO:

      case PW_AUTORO:
      {
        return_value_chdir$26=chdir(ctx_p->chroot_dir);
        if(!(return_value_chdir$26 == 0))
        {
          _error("main", "Got error while chdir(\"%s\")", ctx_p->chroot_dir);
          signed int *return_value___errno_location$25;
          return_value___errno_location$25=__errno_location();
          ret = *return_value___errno_location$25;
        }

        return_value_mkdir$29=mkdir("old_root", (unsigned int)0700);
        if(!(return_value_mkdir$29 == 0))
        {
          signed int *return_value___errno_location$28;
          return_value___errno_location$28=__errno_location();
          if(!(*return_value___errno_location$28 == 17))
          {
            _error("main", "Got error from mkdir(\"old_root\", 0700)");
            signed int *return_value___errno_location$27;
            return_value___errno_location$27=__errno_location();
            ret = *return_value___errno_location$27;
            goto __CPROVER_DUMP_L68;
          }

        }

        return_value_mkdir$32=mkdir("/dev/shm/clsync-rootfs", (unsigned int)0700);
        if(!(return_value_mkdir$32 == 0))
        {
          signed int *return_value___errno_location$31;
          return_value___errno_location$31=__errno_location();
          if(!(*return_value___errno_location$31 == 17))
          {
            _error("main", "Got error from mkdir(\"/dev/shm/clsync-rootfs\", 0700)");
            signed int *return_value___errno_location$30;
            return_value___errno_location$30=__errno_location();
            ret = *return_value___errno_location$30;
            goto __CPROVER_DUMP_L68;
          }

        }

        mount_flags = (unsigned long int)(4096 | 16384 | (ctx_p->flags[(signed long int)543] == PW_AUTORO ? 1 : 0));
        return_value_mount$34=mount(ctx_p->chroot_dir, "/dev/shm/clsync-rootfs", (const char *)(void *)0, mount_flags, (void *)0);
        if(!(return_value_mount$34 == 0))
        {
          _error("main", "Got error while mount(\"%s\", \"%s\", NULL, %o, NULL)", ctx_p->chroot_dir, (const void *)"/dev/shm/clsync-rootfs", mount_flags);
          signed int *return_value___errno_location$33;
          return_value___errno_location$33=__errno_location();
          ret = *return_value___errno_location$33;
          goto __CPROVER_DUMP_L68;
        }

        ctx_p->chroot_dir = "/dev/shm/clsync-rootfs";
      }
      default:
      {

      __CPROVER_DUMP_L68:
        ;
        _debug(7, "main", "chdir(\"%s\")", ctx_p->chroot_dir);
        signed int return_value_chdir$36;
        return_value_chdir$36=chdir(ctx_p->chroot_dir);
        if(!(return_value_chdir$36 == 0))
        {
          _error("main", "Got error while chdir(\"%s\")", ctx_p->chroot_dir);
          signed int *return_value___errno_location$35;
          return_value___errno_location$35=__errno_location();
          ret = *return_value___errno_location$35;
        }

      }
    }

  signed int *return_value___errno_location$40;
  signed int *return_value___errno_location$39;
  if(!(ctx_p->mountpoints == 0))
  {
    if(!(ent_f == ((struct _IO_FILE *)NULL)))
    {
      do
      {
        ent=getmntent(ent_f);
        if(ent == ((struct mntent *)NULL))
          break;

        signed int main$$1$$14$$7$$1$$i;
        _debug(8, "main", "Checking should \"%s\" be umount or not", ent->mnt_dir);
        main$$1$$14$$7$$1$$i = 0;
        while(!(main$$1$$14$$7$$1$$i >= ctx_p->mountpoints))
        {
          signed int return_value_strcmp$37;
          return_value_strcmp$37=strcmp(ent->mnt_dir, ctx_p->mountpoint[(signed long int)main$$1$$14$$7$$1$$i]);
          if(return_value_strcmp$37 == 0)
            break;

          main$$1$$14$$7$$1$$i = main$$1$$14$$7$$1$$i + 1;
        }
        if(main$$1$$14$$7$$1$$i >= ctx_p->mountpoints)
        {
          _debug(1, "main", "umount2(\"%s\", MNT_DETACH)", ent->mnt_dir);
          signed int return_value_umount2$41;
          return_value_umount2$41=umount2(ent->mnt_dir, 2);
          if(!(return_value_umount2$41 == 0))
          {
            return_value___errno_location$40=__errno_location();
            if(!(*return_value___errno_location$40 == 2))
            {
              return_value___errno_location$39=__errno_location();
              if(!(*return_value___errno_location$39 == 22))
              {
                _error("main", "Got error while umount2(\"%s\", MNT_DETACH)", ent->mnt_dir);
                signed int *return_value___errno_location$38;
                return_value___errno_location$38=__errno_location();
                ret = *return_value___errno_location$38;
              }

            }

          }

        }

      }
      while((_Bool)1);
      endmntent(ent_f);
    }

  }

  signed int return_value_pivot_root$43;
  signed int return_value_umount2$47;
  if(!(ctx_p->chroot_dir == ((char *)NULL)))
  {
    if(ret == 0)
      switch(ctx_p->flags[(signed long int)543])
      {
        case PW_OFF:
          break;
        case PW_DIRECT:

        case PW_AUTO:

        case PW_AUTORO:
        {
          return_value_pivot_root$43=pivot_root(".", "old_root");
          if(!(return_value_pivot_root$43 == 0))
          {
            _error("main", "Got error while pivot_root(\".\", \"old_root\")");
            signed int *return_value___errno_location$42;
            return_value___errno_location$42=__errno_location();
            ret = *return_value___errno_location$42;
          }

        }
        default:
          ;
      }

    _debug(7, "main", "chroot(\".\")");
    signed int return_value_chroot$45;
    return_value_chroot$45=chroot(".");
    if(!(return_value_chroot$45 == 0))
    {
      _error("main", "Got error while chroot(\".\")");
      signed int *return_value___errno_location$44;
      return_value___errno_location$44=__errno_location();
      ret = *return_value___errno_location$44;
    }

    if(ret == 0)
      switch(ctx_p->flags[(signed long int)543])
      {
        case PW_OFF:
          break;
        case PW_DIRECT:

        case PW_AUTO:

        case PW_AUTORO:
        {
          return_value_umount2$47=umount2("old_root", 2);
          if(!(return_value_umount2$47 == 0))
          {
            _error("main", "Got error while umount2(\"old_root\", MNT_DETACH)");
            signed int *return_value___errno_location$46;
            return_value___errno_location$46=__errno_location();
            ret = *return_value___errno_location$46;
          }

        }
        default:
          ;
      }

  }

  unsigned int tmp_if_expr$49;
  unsigned int return_value_getuid$48;
  unsigned int tmp_if_expr$51;
  unsigned int return_value_getgid$50;
  signed int return_value_fileno$52;
  if(!(ctx_p->statusfile == ((char *)NULL)))
  {
    _debug(1, "main", "Trying to open the status file for writing.");
    main_statusfile_f=fopen(ctx_p->statusfile, "w");
    if(!(main_statusfile_f == ((struct _IO_FILE *)NULL)))
    {
      unsigned int uid;
      if(!(ctx_p->flags[117l] == 0))
        tmp_if_expr$49 = ctx_p->uid;

      else
      {
        return_value_getuid$48=getuid();
        tmp_if_expr$49 = return_value_getuid$48;
      }
      uid = tmp_if_expr$49;
      unsigned int gid;
      if(!(ctx_p->flags[103l] == 0))
        tmp_if_expr$51 = ctx_p->gid;

      else
      {
        return_value_getgid$50=getgid();
        tmp_if_expr$51 = return_value_getgid$50;
      }
      gid = tmp_if_expr$51;
      _debug(1, "main", "Changing owner of the status file to %u:%u", uid, gid);
      signed int return_value_fileno$53;
      return_value_fileno$53=fileno(main_statusfile_f);
      signed int return_value_fchown$54;
      return_value_fchown$54=fchown(return_value_fileno$53, uid, gid);
      if(!(return_value_fchown$54 == 0))
      {
        return_value_fileno$52=fileno(main_statusfile_f);
        _warning("main", "Cannot fchown(%u -> \"%s\", %u, %u)", return_value_fileno$52, ctx_p->statusfile, uid, gid);
      }

      main_status_update(ctx_p);
    }

  }

  nret=main_rehash(ctx_p);
  if(!(nret == 0))
    ret = nret;

  if(!(ctx_p->flags[103l] == 0))
  {
    signed int rc;
    _debug(3, "main", "Trying to drop effective gid to %i", ctx_p->gid);
    rc=setegid(ctx_p->gid);
    if(!(rc == 0))
    {
      if(!(ctx_p->flags[103l] == 65536))
      {
        _error("main", "Cannot setegid(%u)", ctx_p->gid);
        signed int *return_value___errno_location$55;
        return_value___errno_location$55=__errno_location();
        ret = *return_value___errno_location$55;
      }

    }

  }

  if(!(ctx_p->flags[117l] == 0))
  {
    signed int main$$1$$17$$rc;
    _debug(3, "main", "Trying to drop effective uid to %i", ctx_p->uid);
    main$$1$$17$$rc=seteuid(ctx_p->uid);
    if(!(main$$1$$17$$rc == 0))
    {
      if(!(ctx_p->flags[117l] == 65536))
      {
        _error("main", "Cannot seteuid(%u)", ctx_p->uid);
        signed int *return_value___errno_location$56;
        return_value___errno_location$56=__errno_location();
        ret = *return_value___errno_location$56;
      }

    }

  }

  if(main_statusfile_f == ((struct _IO_FILE *)NULL))
  {
    if(!(ctx_p->statusfile == ((char *)NULL)))
    {
      _debug(1, "main", "Trying to open the status file for writing (after setuid()/setgid()).");
      main_statusfile_f=fopen(ctx_p->statusfile, "w");
      if(main_statusfile_f == ((struct _IO_FILE *)NULL))
      {
        _error("main", "Cannot open file \"%s\" for writing.", ctx_p->statusfile);
        signed int *return_value___errno_location$57;
        return_value___errno_location$57=__errno_location();
        ret = *return_value___errno_location$57;
      }

    }

  }

  char *tmp_if_expr$58;
  char *tmp_if_expr$59;
  if(!(ctx_p->destdir == ((char *)NULL)))
    tmp_if_expr$58 = ctx_p->destdir;

  else
    tmp_if_expr$58 = "";
  if(!(ctx_p->destdirwslash == ((char *)NULL)))
    tmp_if_expr$59 = ctx_p->destdirwslash;

  else
    tmp_if_expr$59 = "";
  _debug(1, "main", "%s [%s] (%p) -> %s [%s] (%p)", ctx_p->watchdir, ctx_p->watchdirwslash, ctx_p->watchdirwslash, tmp_if_expr$58, tmp_if_expr$59, ctx_p->destdirwslash);
  signed int main$$1$$20$$rc;
  main$$1$$20$$rc=ctx_check(ctx_p);
  if(ret == 0)
    ret = main$$1$$20$$rc;

  if(ctx_p->listoutdir == ((char *)NULL))
  {
    if(!((12 & (signed int)ctx_p->synchandler_argf) == 0))
    {
      char *template;
      template=strdup("/tmp/clsync-XXXXXX");
      ctx_p->listoutdir=mkdtemp(template);
      if(ctx_p->listoutdir == ((char *)NULL))
      {
        signed int *return_value___errno_location$60;
        return_value___errno_location$60=__errno_location();
        ret = *return_value___errno_location$60;
        _error("main", "Cannot create temporary dir for list files");
      }

      else
        rm_listoutdir = 2;
    }

  }

  if(!(ctx_p->listoutdir == ((char *)NULL)))
  {
    struct stat st = { .st_dev=(unsigned long int)0, .st_ino=0ul, .st_nlink=0ul,
    .st_mode=0u, .st_uid=0u, .st_gid=0u,
    .__pad0=0, .st_rdev=0ul, .st_size=0l,
    .st_blksize=0l, .st_blocks=0l, .st_atim={ .tv_sec=0l, .tv_nsec=0l },
    .st_mtim={ .tv_sec=0l, .tv_nsec=0l },
    .st_ctim={ .tv_sec=0l, .tv_nsec=0l },
    .__glibc_reserved={ 0l, 0l, 0l } };
    signed int *return_value___errno_location$61;
    return_value___errno_location$61=__errno_location();
    *return_value___errno_location$61 = 0;
    signed int return_value_stat$67;
    return_value_stat$67=stat(ctx_p->listoutdir, &st);
    if(!(return_value_stat$67 == 0))
    {
      signed int *return_value___errno_location$66;
      return_value___errno_location$66=__errno_location();
      if(*return_value___errno_location$66 == 2)
      {
        _warning("main", "Directory \"%s\" doesn't exist. Creating it.", ctx_p->listoutdir);
        signed int *return_value___errno_location$62;
        return_value___errno_location$62=__errno_location();
        *return_value___errno_location$62 = 0;
        signed int return_value_mkdir$64;
        return_value_mkdir$64=mkdir(ctx_p->listoutdir, (unsigned int)(0400 | 0200 | 0100));
        if(!(return_value_mkdir$64 == 0))
        {
          _error("main", "Cannot create directory \"%s\".", ctx_p->listoutdir);
          signed int *return_value___errno_location$63;
          return_value___errno_location$63=__errno_location();
          ret = *return_value___errno_location$63;
        }

        else
          rm_listoutdir = 1;
      }

      else
      {
        _error("main", "Got error while stat() on \"%s\".", ctx_p->listoutdir);
        signed int *return_value___errno_location$65;
        return_value___errno_location$65=__errno_location();
        ret = *return_value___errno_location$65;
      }
    }

    signed int *return_value___errno_location$69;
    return_value___errno_location$69=__errno_location();
    if(*return_value___errno_location$69 == 0)
    {
      if(!((63u & st.st_mode) == 0u))
      {
        signed int *return_value___errno_location$68;
        return_value___errno_location$68=__errno_location();
        *return_value___errno_location$68 = 13;
        ret = *return_value___errno_location$68;
        _error("main", "Insecure: Others have access to directory \"%s\". Exit.", ctx_p->listoutdir);
      }

    }

  }

  if(!(ctx_p->flags[98l] == 0))
  {
    nret=becomedaemon();
    if(!(nret == 0))
      ret = nret;

  }

  if(!(ctx_p->pidfile == ((char *)NULL)))
  {
    _debug(2, "main", "Trying to open the pidfile \"%s\"", ctx_p->pidfile);
    signed int pid;
    pid=getpid();
    struct _IO_FILE *pidfile;
    pidfile=fopen(ctx_p->pidfile, "w");
    if(pidfile == ((struct _IO_FILE *)NULL))
    {
      signed int *return_value___errno_location$85;
      return_value___errno_location$85=__errno_location();
      if(*return_value___errno_location$85 == 13)
      {
        signed int fd;
        unsigned int euid;
        euid=geteuid();
        unsigned int egid;
        egid=getegid();
        _debug(1, "main", "Don't have permissions to open file \"%s\". Trying seteuid(0)+open()+fchown()+close()+seteuid(%i)", ctx_p->pidfile, euid);
        signed int *return_value___errno_location$70;
        return_value___errno_location$70=__errno_location();
        *return_value___errno_location$70 = 0;
        signed int *return_value___errno_location$73;
        return_value___errno_location$73=__errno_location();
        if(*return_value___errno_location$73 == 0)
        {
          signed long int main$$1$$24$$2$$1$$2$$_SAFE_rc;
          signed int return_value_seteuid$72;
          return_value_seteuid$72=seteuid((unsigned int)0);
          main$$1$$24$$2$$1$$2$$_SAFE_rc = (signed long int)return_value_seteuid$72;
          if(!(main$$1$$24$$2$$1$$2$$_SAFE_rc == 0l))
          {
            _error("main", "Got error while seteuid(0)");
            signed int *return_value___errno_location$71;
            return_value___errno_location$71=__errno_location();
            ret = *return_value___errno_location$71;
          }

          main$$1$$24$$2$$1$$2$$_SAFE_rc;
        }

        signed int *return_value___errno_location$75;
        return_value___errno_location$75=__errno_location();
        if(*return_value___errno_location$75 == 0)
        {
          signed long int main$$1$$24$$2$$1$$3$$_SAFE_rc;
          fd=open(ctx_p->pidfile, 0100 | 01, 0644);
          main$$1$$24$$2$$1$$3$$_SAFE_rc = (signed long int)(fd == -1);
          if(!(main$$1$$24$$2$$1$$3$$_SAFE_rc == 0l))
          {
            _error("main", "Got error while (fd = open(ctx_p->pidfile, 0100|01, 0644)) == -1");
            signed int *return_value___errno_location$74;
            return_value___errno_location$74=__errno_location();
            ret = *return_value___errno_location$74;
          }

          main$$1$$24$$2$$1$$3$$_SAFE_rc;
        }

        signed int *return_value___errno_location$78;
        return_value___errno_location$78=__errno_location();
        if(*return_value___errno_location$78 == 0)
        {
          signed long int main$$1$$24$$2$$1$$4$$_SAFE_rc;
          signed int return_value_fchown$77;
          return_value_fchown$77=fchown(fd, euid, egid);
          main$$1$$24$$2$$1$$4$$_SAFE_rc = (signed long int)return_value_fchown$77;
          if(!(main$$1$$24$$2$$1$$4$$_SAFE_rc == 0l))
          {
            _error("main", "Got error while fchown(fd, euid, egid)");
            signed int *return_value___errno_location$76;
            return_value___errno_location$76=__errno_location();
            ret = *return_value___errno_location$76;
          }

          main$$1$$24$$2$$1$$4$$_SAFE_rc;
        }

        signed int *return_value___errno_location$81;
        return_value___errno_location$81=__errno_location();
        if(*return_value___errno_location$81 == 0)
        {
          signed long int main$$1$$24$$2$$1$$5$$_SAFE_rc;
          signed int return_value_close$80;
          return_value_close$80=close(fd);
          main$$1$$24$$2$$1$$5$$_SAFE_rc = (signed long int)return_value_close$80;
          if(!(main$$1$$24$$2$$1$$5$$_SAFE_rc == 0l))
          {
            _error("main", "Got error while close(fd)");
            signed int *return_value___errno_location$79;
            return_value___errno_location$79=__errno_location();
            ret = *return_value___errno_location$79;
          }

          main$$1$$24$$2$$1$$5$$_SAFE_rc;
        }

        signed int *return_value___errno_location$84;
        return_value___errno_location$84=__errno_location();
        if(*return_value___errno_location$84 == 0)
        {
          signed long int main$$1$$24$$2$$1$$6$$_SAFE_rc;
          signed int return_value_seteuid$83;
          return_value_seteuid$83=seteuid(euid);
          main$$1$$24$$2$$1$$6$$_SAFE_rc = (signed long int)return_value_seteuid$83;
          if(!(main$$1$$24$$2$$1$$6$$_SAFE_rc == 0l))
          {
            _error("main", "Got error while seteuid(euid)");
            signed int *return_value___errno_location$82;
            return_value___errno_location$82=__errno_location();
            ret = *return_value___errno_location$82;
          }

          main$$1$$24$$2$$1$$6$$_SAFE_rc;
        }

        pidfile=fopen(ctx_p->pidfile, "w");
      }

      if(pidfile == ((struct _IO_FILE *)NULL))
      {
        _error("main", "Cannot open file \"%s\" to write a pid there", ctx_p->pidfile);
        signed int *return_value___errno_location$86;
        return_value___errno_location$86=__errno_location();
        ret = *return_value___errno_location$86;
      }

    }

    if(!(pidfile == ((struct _IO_FILE *)NULL)))
    {
      signed int return_value_fprintf$88;
      return_value_fprintf$88=fprintf(pidfile, "%u", pid);
      if(!(return_value_fprintf$88 >= 0))
      {
        _error("main", "Cannot write pid into file \"%s\"", ctx_p->pidfile);
        signed int *return_value___errno_location$87;
        return_value___errno_location$87=__errno_location();
        ret = *return_value___errno_location$87;
      }

      fclose(pidfile);
    }

  }

  _debug(3, "main", "Current errno is %i.", ret);
  if(ret == 0)
    ret=sync_run(ctx_p);

  signed int *return_value___errno_location$89;
  char *return_value_strerror$90;
  if(!(ctx_p->pidfile == ((char *)NULL)))
  {
    signed int return_value_unlink$92;
    return_value_unlink$92=unlink(ctx_p->pidfile);
    if(!(return_value_unlink$92 == 0))
    {
      struct _IO_FILE *main$$1$$26$$1$$pidfile;
      return_value___errno_location$89=__errno_location();
      return_value_strerror$90=strerror(*return_value___errno_location$89);
      _debug(1, "main", "Cannot unlink pidfile \"%s\": %s. Just truncating the file.", ctx_p->pidfile, return_value_strerror$90);
      signed long int _SAFE_rc;
      main$$1$$26$$1$$pidfile=fopen(ctx_p->pidfile, "w");
      _SAFE_rc = (signed long int)(main$$1$$26$$1$$pidfile == (struct _IO_FILE *)(void *)0);
      if(!(_SAFE_rc == 0l))
      {
        _error("main", "Got error while (pidfile = fopen(ctx_p->pidfile, \"w\")) == ((void *)0)");
        signed int *return_value___errno_location$91;
        return_value___errno_location$91=__errno_location();
        ret = *return_value___errno_location$91;
      }

      _SAFE_rc;
      if(!(main$$1$$26$$1$$pidfile == ((struct _IO_FILE *)NULL)))
        fclose(main$$1$$26$$1$$pidfile);

    }

  }

  signed int return_value_fclose$94;
  if(!(ctx_p->statusfile == ((char *)NULL)))
  {
    if(!(main_statusfile_f == ((struct _IO_FILE *)NULL)))
    {
      return_value_fclose$94=fclose(main_statusfile_f);
      if(!(return_value_fclose$94 == 0))
      {
        _error("main", "Cannot close file \"%s\".", ctx_p->statusfile);
        signed int *return_value___errno_location$93;
        return_value___errno_location$93=__errno_location();
        ret = *return_value___errno_location$93;
      }

    }

    signed int return_value_unlink$96;
    return_value_unlink$96=unlink(ctx_p->statusfile);
    if(!(return_value_unlink$96 == 0))
    {
      _error("main", "Cannot unlink status file \"%s\"", ctx_p->statusfile);
      signed int *return_value___errno_location$95;
      return_value___errno_location$95=__errno_location();
      ret = *return_value___errno_location$95;
    }

  }

  if(ctx_p->flags[85l] == 0)
  {
    if(!(ctx_p->listoutdir == ((char *)NULL)))
    {
      if(!(rm_listoutdir == 0))
      {
        _debug(2, "main", "rmdir(\"%s\")", ctx_p->listoutdir);
        signed int return_value_rmdir$97;
        return_value_rmdir$97=rmdir(ctx_p->listoutdir);
        if(!(return_value_rmdir$97 == 0))
          _error("main", "Cannot rmdir(\"%s\")", ctx_p->listoutdir);

        if(rm_listoutdir == 2)
          free((void *)ctx_p->listoutdir);

      }

    }

  }

  main_cleanup(ctx_p);
  if(!(ctx_p->watchdirwslashsize == 0ul))
    free((void *)ctx_p->watchdirwslash);

  if(!(ctx_p->destdirwslashsize == 0ul))
    free((void *)ctx_p->destdirwslash);

  if(!(ctx_p->rulfpathsize == 0ul))
    free((void *)ctx_p->rulfpath);

  error_deinit();
  ctx_cleanup(ctx_p);
  char *return_value_strerror$98;
  return_value_strerror$98=strerror(ret);
  _debug(1, "main", "finished, exitcode: %i: %s.", ret, return_value_strerror$98);
  free((void *)ctx_p);
  signed long int main$$1$$30$$_SAFE_rc = (signed long int)0;
  if(!(main$$1$$30$$_SAFE_rc == 0l))
  {
    _error("main", "Got error while (0)");
    signed int *return_value___errno_location$99;
    return_value___errno_location$99=__errno_location();
    ret = (signed int)main$$1$$30$$_SAFE_rc;
    *return_value___errno_location$99 = ret;
  }

  main$$1$$30$$_SAFE_rc;
  return ret;
}

// main_cleanup
// file main.c line 2275
signed int main_cleanup(struct ctx *ctx_p)
{
  signed int i = 0;
  signed int tmp_post$1;
  while(!(i >= 256))
  {
    if((signed int)ctx_p->rules[(signed long int)i].mask == RA_NONE)
      break;

    tmp_post$1 = i;
    i = i + 1;
    regfree(&ctx_p->rules[(signed long int)tmp_post$1].expr);
  }
  _debug(3, "main_cleanup", "%i %i %i %i", ctx_p->watchdirsize, ctx_p->watchdirwslashsize, ctx_p->destdirsize, ctx_p->destdirwslashsize);
  return 0;
}

// main_rehash
// file main.c line 2285
signed int main_rehash(struct ctx *ctx_p)
{
  _debug(3, "main_rehash", "");
  signed int ret = 0;
  main_cleanup(ctx_p);
  if(!(ctx_p->rulfpath == ((char *)NULL)))
  {
    ret=parse_rules_fromfile(ctx_p);
    if(!(ret == 0))
      _error("main_rehash", "Got error from parse_rules_fromfile().");

  }

  else
  {
    ctx_p->rules[(signed long int)0].perm = (enum ruleaction_enum)RA_ALL;
    ctx_p->rules[(signed long int)0].mask = (enum ruleaction_enum)RA_NONE;
  }
  return ret;
}

// main_status_update
// file main.c line 2304
signed int main_status_update(struct ctx *ctx_p)
{
  enum state_enum state = ctx_p->state;
  _debug(4, "main_status_update", "%u", state);
  static enum state_enum state_old = (enum state_enum)STATE_UNKNOWN;
  if(state == state_old)
  {
    _debug(3, "main_status_update", "State unchanged: %u == %u", state, state_old);
    return 0;
  }

  else
  {
    setenv("CLSYNC_STATUS", status_descr[(signed long int)state], 1);
    if(ctx_p->statusfile == ((char *)NULL))
      return 0;

    else
    {
      _debug(3, "main_status_update", "Setting status to %i: %s.", state, status_descr[(signed long int)state]);
      state_old = state;
      signed int ret = 0;
      signed int return_value_fileno$2;
      return_value_fileno$2=fileno(main_statusfile_f);
      signed int return_value_ftruncate$3;
      return_value_ftruncate$3=ftruncate(return_value_fileno$2, (signed long int)0);
      if(!(return_value_ftruncate$3 == 0))
      {
        _error("main_status_update", "Cannot ftruncate() the file \"%s\".", ctx_p->statusfile);
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        return *return_value___errno_location$1;
      }

      rewind(main_statusfile_f);
      signed int return_value_fprintf$5;
      return_value_fprintf$5=fprintf(main_statusfile_f, "%s", status_descr[(signed long int)state]);
      if(!(return_value_fprintf$5 >= 1))
      {
        _error("main_status_update", "Cannot write to file \"%s\".", ctx_p->statusfile);
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        return *return_value___errno_location$4;
      }

      signed int return_value_fflush$7;
      return_value_fflush$7=fflush(main_statusfile_f);
      if(!(return_value_fflush$7 == 0))
      {
        _error("main_status_update", "Cannot fflush() on file \"%s\".", ctx_p->statusfile);
        signed int *return_value___errno_location$6;
        return_value___errno_location$6=__errno_location();
        return *return_value___errno_location$6;
      }

      return ret;
    }
  }
}

// memory_init
// file malloc.c line 165
extern signed int memory_init()
{
  return 0;
}

// mkdirat_open
// file fileutils.c line 171
signed int mkdirat_open(const char * const dir_path, signed int dirfd_parent, unsigned int dir_mode)
{
  signed int dirfd;
  _debug(5, "mkdirat_open", "mkdirat(%u, \"%s\", %o)", dirfd_parent, dir_path, dir_mode);
  signed int return_value_mkdirat$1;
  return_value_mkdirat$1=mkdirat(dirfd_parent, dir_path, dir_mode);
  if(!(return_value_mkdirat$1 == 0))
    return -1;

  else
  {
    _debug(5, "mkdirat_open", "openat(%u, \"%s\", %x)", dirfd_parent, dir_path, 02 | 0200000 | 010000000);
    dirfd=openat(dirfd_parent, dir_path, 02 | 0200000 | 010000000);
    if(dirfd == -1)
      return -1;

    else
      return dirfd;
  }
}

// notify_wait
// file sync.c line 3059
signed int notify_wait(struct ctx *ctx_p, struct indexes *indexes_p)
{
  signed long int tm;
  tm=time((signed long int *)(void *)0);
  signed long int delay = (signed long int)((unsigned long int)~0 >> 1);
  struct threadsinfo *threadsinfo_p;
  threadsinfo_p=thread_info();
  _debug(4, "notify_wait", "pthread_mutex_unlock(&threadsinfo_p->mutex[PTHREAD_MUTEX_STATE])");
  pthread_cond_broadcast(&threadsinfo_p->cond[(signed long int)0]);
  pthread_mutex_unlock(&threadsinfo_p->mutex[(signed long int)0]);
  signed long int queue_id = (signed long int)0;
  signed long int tmp_post$1;
  while(!(queue_id >= 4l))
  {
    struct queueinfo *queueinfo;
    tmp_post$1 = queue_id;
    queue_id = queue_id + 1l;
    queueinfo = &ctx_p->_queues[tmp_post$1];
    if(!(queueinfo->stime == 0l))
    {
      if(queueinfo->collectdelay == 4294967295u)
      {
        _debug(3, "notify_wait", "There're events in instant queue (#%i), don't waiting.", queue_id - (signed long int)1);
        return 0;
      }

      signed int qdelay = (signed int)((queueinfo->stime + (signed long int)queueinfo->collectdelay) - tm);
      _debug(3, "notify_wait", "queue #%i: %i %i %i -> %i", queue_id - (signed long int)1, queueinfo->stime, queueinfo->collectdelay, tm, qdelay);
      if(!((signed long int)qdelay >= -((signed long int)ctx_p->syncdelay)))
        qdelay = (signed int)-((signed long int)ctx_p->syncdelay);

      delay = delay < (signed long int)qdelay ? delay : (signed long int)qdelay;
    }

  }
  signed long int synctime_delay = (signed long int)ctx_p->synctime - (signed long int)tm;
  synctime_delay = synctime_delay > (signed long int)0 ? synctime_delay : (signed long int)0;
  _debug(3, "notify_wait", "delay = MAX(%li, %li)", delay, synctime_delay);
  delay = delay > synctime_delay ? delay : synctime_delay;
  delay = delay > (signed long int)0 ? delay : (signed long int)0;
  if(!(ctx_p->flags[112l] == 0))
  {
    signed long int _thread_nextexpiretime;
    _thread_nextexpiretime=thread_nextexpiretime();
    _debug(3, "notify_wait", "thread_nextexpiretime == %i", _thread_nextexpiretime);
    if(!(_thread_nextexpiretime == 0l))
    {
      signed long int thread_expiredelay;
      signed long int return_value_thread_nextexpiretime$2;
      return_value_thread_nextexpiretime$2=thread_nextexpiretime();
      thread_expiredelay = ((signed long int)return_value_thread_nextexpiretime$2 - (signed long int)tm) + (signed long int)1;
      _debug(3, "notify_wait", "thread_expiredelay == %i", thread_expiredelay);
      thread_expiredelay = thread_expiredelay > (signed long int)0 ? thread_expiredelay : (signed long int)0;
      _debug(3, "notify_wait", "delay = MIN(%li, %li)", delay, thread_expiredelay);
      delay = delay < thread_expiredelay ? delay : thread_expiredelay;
    }

  }

  _Bool tmp_if_expr$3;
  if(delay == 0l)
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = (signed int)ctx_p->state != STATE_RUNNING ? (_Bool)1 : (_Bool)0;
  signed int *return_value___errno_location$5;
  if(tmp_if_expr$3)
    return 0;

  else
  {
    static struct timeval tv;
    if(!(ctx_p->flags[520l] == 0))
    {
      tv.tv_sec = (signed long int)0;
      tv.tv_usec = (signed long int)0;
    }

    else
    {
      _debug(3, "notify_wait", "sleeping for %li second(s).", 1);
      sleep((unsigned int)1);
      delay = (signed long int)delay > (signed long int)1 ? delay - (signed long int)1 : (signed long int)0;
      tv.tv_sec = delay;
      tv.tv_usec = (signed long int)0;
    }
    _debug(4, "notify_wait", "pthread_mutex_lock(&threadsinfo_p->mutex[PTHREAD_MUTEX_STATE])");
    pthread_mutex_lock(&threadsinfo_p->mutex[(signed long int)0]);
    if(!((signed int)ctx_p->state == STATE_RUNNING))
      return 0;

    else
    {
      _debug(4, "notify_wait", "pthread_mutex_unlock(&threadsinfo_p->mutex[PTHREAD_MUTEX_STATE])");
      pthread_cond_broadcast(&threadsinfo_p->cond[(signed long int)0]);
      pthread_mutex_lock(&threadsinfo_p->mutex[(signed long int)1]);
      pthread_mutex_unlock(&threadsinfo_p->mutex[(signed long int)0]);
      _debug(8, "notify_wait", "ctx_p->notifyenginefunct.wait() [%p]", ctx_p->notifyenginefunct.wait);
      signed int ret;
      ret=ctx_p->notifyenginefunct.wait(ctx_p, indexes_p, &tv);
      pthread_mutex_unlock(&threadsinfo_p->mutex[(signed long int)1]);
      if(ret == -1)
      {
        return_value___errno_location$5=__errno_location();
        if(*return_value___errno_location$5 == 4)
        {
          signed int *return_value___errno_location$4;
          return_value___errno_location$4=__errno_location();
          *return_value___errno_location$4 = 0;
          ret = 0;
        }

      }

      _debug(4, "notify_wait", "pthread_mutex_lock(&threadsinfo_p->mutex[PTHREAD_MUTEX_STATE])");
      pthread_mutex_lock(&threadsinfo_p->mutex[(signed long int)0]);
      if(!(ctx_p->flags[520l] == 0))
      {
        if(ret == 0)
        {
          if(!(ctx_p->flags[524l] == 0))
            ctx_p->state = (volatile enum state_enum)STATE_PREEXIT;

          else
            ctx_p->state = (volatile enum state_enum)STATE_EXIT;
        }

      }

      return ret;
    }
  }
}

// parameter_expand
// file main.c line 642
char * parameter_expand(struct ctx *ctx_p, char *arg, signed int exceptionflags, signed int *macro_count_p, signed int *expand_count_p, const char * (*parameter_get)(const char *, void *), void *parameter_get_arg)
{
  char *ret = (char *)(void *)0;
  unsigned long int ret_size = (unsigned long int)0;
  unsigned long int ret_len = (unsigned long int)0;
  if(arg == ((char *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return (char *)(void *)0;
  }

  if(!(macro_count_p == ((signed int *)NULL)))
    *macro_count_p = 0;

  if(!(expand_count_p == ((signed int *)NULL)))
    *expand_count_p = 0;

  char *ptr = &arg[(signed long int)-1];
  unsigned long int tmp_post$2;
  char *tmp_post$3;
  char nest_searching;
  char *ptr_nest;
  char *variable_name;
  const char *variable_value;
  unsigned long int variable_value_len;
  signed int return_value_strcmp$10;
  _Bool tmp_if_expr$9;
  signed int *return_value___errno_location$7;
  signed int *return_value___errno_location$5;
  char *return_value_strerror$6;
  unsigned long int tmp_post$13;
  while((_Bool)1)
  {
    ptr = ptr + 1l;
    switch((signed int)*ptr)
    {
      case 0:
      {
        if(ret == ((char *)NULL))
        {
          _debug(3, "parameter_expand", "Expanding value \"%s\" to \"%s\" (case #1)", arg, arg);
          return arg;
        }

        ret[(signed long int)ret_len] = (char)0;
        _debug(3, "parameter_expand", "Expanding value \"%s\" to \"%s\" (case #0)", arg, ret);
        free((void *)arg);
        return ret;
      }
      case 37:
      {
        if((signed int)ptr[1l] == 37)
        {
          tmp_post$2 = ret_len;
          ret_len = ret_len + 1ul;
          tmp_post$3 = ptr;
          ptr = ptr + 1l;
          ret[(signed long int)tmp_post$2] = *tmp_post$3;
          break;
        }

        nest_searching = (char)1;
        ptr_nest = ptr;
        while(!(nest_searching == 0))
        {
          ptr_nest = ptr_nest + 1l;
          switch((signed int)*ptr_nest)
          {
            case 0:
            {
              ret[(signed long int)ret_len] = (char)0;
              if((1 & exceptionflags) == 0)
                _warning("parameter_expand", "Unexpected end of macro-substitution \"%s\" in value \"%s\"; result value is \"%s\"", ptr, arg, ret);

              free((void *)arg);
              return ret;
            }
            case 37:
            {
              if(!(macro_count_p == ((signed int *)NULL)))
                *macro_count_p = *macro_count_p + 1;

              nest_searching = (char)0;
              *ptr_nest = (char)0;
              variable_name = &ptr[(signed long int)1];
              return_value_strcmp$10=strcmp(variable_name, "PID");
              if(return_value_strcmp$10 == 0)
              {
                if(ctx_p->pid_str[0l] == 0)
                {
                  snprintf(ctx_p->pid_str, (unsigned long int)64, "%u", ctx_p->pid);
                  ctx_p->pid_str_len=strlen(ctx_p->pid_str);
                }

                variable_value = ctx_p->pid_str;
                variable_value_len = ctx_p->pid_str_len;
              }

              else
              {
                if((signed int)*variable_name >= 65)
                  tmp_if_expr$9 = (signed int)*variable_name <= 90 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$9 = (_Bool)0;
                if(!((4 & exceptionflags) == 0) && tmp_if_expr$9)
                {
                  variable_value = ptr;
                  variable_value_len = (unsigned long int)((ptr_nest - ptr) + (signed long int)1);
                  parameter_get(variable_name, parameter_get_arg);
                }

                else
                {
                  signed int *return_value___errno_location$4;
                  return_value___errno_location$4=__errno_location();
                  *return_value___errno_location$4 = 0;
                  variable_value=parameter_get(variable_name, parameter_get_arg);
                  if(variable_value == ((const char *)NULL))
                  {
                    if((2 & exceptionflags) == 0)
                    {
                      return_value___errno_location$7=__errno_location();
                      if(!(*return_value___errno_location$7 == 2))
                      {
                        return_value___errno_location$5=__errno_location();
                        return_value_strerror$6=strerror(*return_value___errno_location$5);
                        _warning("parameter_expand", "Variable \"%s\" is not set (%s)", variable_name, return_value_strerror$6);
                      }

                    }

                    *ptr_nest = (char)37;
                    signed int *return_value___errno_location$8;
                    return_value___errno_location$8=__errno_location();
                    *return_value___errno_location$8 = 0;
                    break;
                  }

                  variable_value_len=strlen(variable_value);
                  if(!(expand_count_p == ((signed int *)NULL)))
                    *expand_count_p = *expand_count_p + 1;

                }
              }
              *ptr_nest = (char)37;
              if(1ul + variable_value_len + ret_len >= ret_size)
              {
                ret_size = ret_len + variable_value_len + (unsigned long int)1 + (unsigned long int)(1 << 10);
                void *return_value_xrealloc$11;
                return_value_xrealloc$11=xrealloc((void *)ret, ret_size);
                ret = (char *)return_value_xrealloc$11;
              }

              memcpy((void *)&ret[(signed long int)ret_len], (const void *)variable_value, variable_value_len);
              ret_len = ret_len + variable_value_len;
            }
            default:
              ;
          }
        }
        ptr = ptr_nest;
        break;
      }
      default:
      {
        if(2ul + ret_len >= ret_size)
        {
          ret_size = ret_size + (unsigned long int)((1 << 10) + 2);
          void *return_value_xrealloc$12;
          return_value_xrealloc$12=xrealloc((void *)ret, ret_size);
          ret = (char *)return_value_xrealloc$12;
        }

        tmp_post$13 = ret_len;
        ret_len = ret_len + 1ul;
        ret[(signed long int)tmp_post$13] = *ptr;
      }
    }
  }
  _error("parameter_expand", "Unknown internal error");
  return arg;
}

// parameter_get
// file main.c line 559
const char * parameter_get(const char *variable_name, void *_ctx_p)
{
  const struct ctx *ctx_p = (const struct ctx *)_ctx_p;
  struct option *long_option_p = long_options;
  signed int param_id = -1;
  _debug(8, "parameter_get", "(\"%s\", %p)", variable_name, ctx_p);
  while(!(long_option_p->name == ((const char *)NULL)))
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(long_option_p->name, variable_name);
    if(return_value_strcmp$1 == 0)
    {
      param_id = long_option_p->val;
      break;
    }

    long_option_p = long_option_p + 1l;
  }
  if(param_id == -1)
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 2;
    return (const char *)(void *)0;
  }

  return ctx_p->flags_values_raw[(signed long int)param_id];
}

// parameter_get_wmacro
// file main.c line 595
const char * parameter_get_wmacro(const char *variable_name, void *_ctx_p)
{
  struct ctx *ctx_p = (struct ctx *)_ctx_p;
  _Bool tmp_if_expr$2;
  if(!((signed int)*variable_name >= 65))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = (signed int)*variable_name > 90 ? (_Bool)1 : (_Bool)0;
  const char *return_value_parameter_get$1;
  if(tmp_if_expr$2)
  {
    return_value_parameter_get$1=parameter_get(variable_name, _ctx_p);
    return return_value_parameter_get$1;
  }

  else
  {
    signed int return_value_strcmp$3;
    return_value_strcmp$3=strcmp(variable_name, "RSYNC-ARGS");
    if(return_value_strcmp$3 == 0)
    {
      ctx_p->synchandler_argf = ctx_p->synchandler_argf | (enum shflags)SHFL_RSYNC_ARGS;
      return (const char *)(void *)0;
    }

    else
    {
      signed int return_value_strcmp$4;
      return_value_strcmp$4=strcmp(variable_name, "INCLUDE-LIST");
      if(return_value_strcmp$4 == 0)
      {
        ctx_p->synchandler_argf = ctx_p->synchandler_argf | (enum shflags)SHFL_INCLUDE_LIST;
        return (const char *)(void *)0;
      }

      else
      {
        const char *r;
        static struct dosync_arg dosync_arg = { .evcount=0, .excf_path={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .outf_path={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .outf=((struct _IO_FILE *)NULL),
    .ctx_p=((struct ctx *)NULL), .indexes_p=((struct indexes *)NULL),
    .data=NULL,
    .linescount=0, .api_ei=((struct api_eventinfo *)NULL), .api_ei_count=0,
    .buf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .include_list={ ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) },
    .include_list_count=0ul,
    .list_type_str=((const char *)NULL), .evmask_str=((const char *)NULL) };
        r=sync_parameter_get(variable_name, (void *)&dosync_arg);
        if(r == dosync_arg.outf_path)
        {
          ctx_p->synchandler_argf = ctx_p->synchandler_argf | (enum shflags)SHFL_INCLUDE_LIST_PATH;
          return (const char *)(void *)0;
        }

        else
          if(r == dosync_arg.excf_path)
          {
            ctx_p->synchandler_argf = ctx_p->synchandler_argf | (enum shflags)SHFL_EXCLUDE_LIST_PATH;
            return (const char *)(void *)0;
          }

          else
          {
            signed int *return_value___errno_location$5;
            return_value___errno_location$5=__errno_location();
            *return_value___errno_location$5 = 2;
            return (const char *)(void *)0;
          }
      }
    }
  }
}

// parent_isalive
// file main.c line 417
signed int parent_isalive()
{
  signed int rc;
  rc=kill(parent_pid, 0);
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  if(!(rc == 0))
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    if(*return_value___errno_location$3 == 3)
    {
      return_value___errno_location$1=__errno_location();
      return_value_strerror$2=strerror(*return_value___errno_location$1);
      _debug(1, "parent_isalive", "kill(%u, 0) => %i; errno => %s", parent_pid, rc, return_value_strerror$2);
      return 0;
    }

  }

  return 1;
}

// parse_customsignals
// file main.c line 832
static inline signed int parse_customsignals(struct ctx *ctx_p, char *arg)
{
  char *ptr = arg;
  char *start = arg;
  signed int ret = 0;
  unsigned int parse_customsignals$$1$$signal;
  signed int return_value_atoi$2;
  char *tmp_post$1;
  while((_Bool)1)
  {
    if((signed int)*ptr == 0 || (signed int)*ptr == 44 || (signed int)*ptr == 58)
    {
      return_value_atoi$2=atoi(start);
      parse_customsignals$$1$$signal = (unsigned int)return_value_atoi$2;
      if(!(ret == 0))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        *return_value___errno_location$3 = ret;
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        return *return_value___errno_location$4;
      }

      if(parse_customsignals$$1$$signal == 0u)
      {
        signed int i = 0;
        for( ; !(i >= 256); i = i + 1)
          if(!(ctx_p->customsignal[(signed long int)i] == ((char *)NULL)))
          {
            free((void *)ctx_p->customsignal[(signed long int)i]);
            ctx_p->customsignal[(signed long int)i] = (char *)(void *)0;
          }

      }

      else
      {
        if(!((signed int)*ptr == 58))
        {
          char ch = *ptr;
          *ptr = (char)0;
          signed int *return_value___errno_location$5;
          return_value___errno_location$5=__errno_location();
          *return_value___errno_location$5 = 22;
          _error("parse_customsignals", "Expected \":\" in \"%s\"", start);
          *ptr = ch;
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          return *return_value___errno_location$6;
        }

        char parse_customsignals$$1$$1$$1$$3$$2$$ch;
        char *end;
        ptr = ptr + 1l;
        end = ptr;
        for( ; !(*end == 0); end = end + 1l)
          if((signed int)*end == 44)
            break;

        if(end == ptr)
        {
          signed int *return_value___errno_location$7;
          return_value___errno_location$7=__errno_location();
          *return_value___errno_location$7 = 22;
          _error("parse_customsignals", "Empty config block name on signal \"%u\"", parse_customsignals$$1$$signal);
          signed int *return_value___errno_location$8;
          return_value___errno_location$8=__errno_location();
          return *return_value___errno_location$8;
        }

        if(parse_customsignals$$1$$signal >= 513u)
        {
          signed int *return_value___errno_location$9;
          return_value___errno_location$9=__errno_location();
          *return_value___errno_location$9 = 22;
          _error("parse_customsignals", "Too high value of the signal: \"%u\" > (1<<9)", parse_customsignals$$1$$signal);
          signed int *return_value___errno_location$10;
          return_value___errno_location$10=__errno_location();
          return *return_value___errno_location$10;
        }

        parse_customsignals$$1$$1$$1$$3$$2$$ch = *end;
        *end = (char)0;
        ctx_p->customsignal[(signed long int)parse_customsignals$$1$$signal]=strdup(ptr);
        *end = parse_customsignals$$1$$1$$1$$3$$2$$ch;
        ptr = end;
      }
      start = ptr + (signed long int)1;
      goto __CPROVER_DUMP_L15;
    }

    signed int *return_value___errno_location$11;
    return_value___errno_location$11=__errno_location();
    *return_value___errno_location$11 = 22;
    _error("parse_customsignals", "Expected a digit, comma (or colon) but got \"%c\"", *ptr);
    signed int *return_value___errno_location$12;
    return_value___errno_location$12=__errno_location();
    return *return_value___errno_location$12;

  __CPROVER_DUMP_L15:
    ;
    tmp_post$1 = ptr;
    ptr = ptr + 1l;
    if(*tmp_post$1 == 0)
      break;

  }
  return 0;
}

// parse_parameter
// file main.c line 915
static signed int parse_parameter(struct ctx *ctx_p, unsigned short int param_id, char *arg, enum paramsource_enum paramsource)
{
  signed int ret = 0;
  switch((signed int)paramsource)
  {
    case PS_CONTROL:

    case PS_ARGUMENT:
    {
      if(!((256 & (signed int)param_id) == 0))
      {
        syntax();
        return 0;
      }

      ctx_p->flags_set[(signed long int)param_id] = 1;
      break;
    }
    case PS_CONFIG:
    {
      if(!(ctx_p->flags_set[(signed long int)param_id] == 0))
        return 0;

      ctx_p->flags_set[(signed long int)param_id] = 1;
      break;
    }
    case PS_DEFAULTS:
      break;
    case PS_CORRECTION:
    {
      if(arg == ((char *)NULL))
        _critical("parse_parameter", "Assert: arg == ((void *)0)");

      break;
    }
    default:
      _error("parse_parameter", "Unknown parameter #%i source (value \"%s\").", param_id, arg != (char *)(void *)0 ? arg : "");
  }
  if(!(arg == ((char *)NULL)))
  {
    if(!((signed int)param_id == 533) && !((signed int)param_id == 534))
      arg=parameter_expand(ctx_p, arg, 0, (signed int *)(void *)0, (signed int *)(void *)0, parameter_get, (void *)ctx_p);

    if(!(ctx_p->flags_values_raw[(signed long int)param_id] == ((char *)NULL)))
      free((void *)ctx_p->flags_values_raw[(signed long int)param_id]);

    ctx_p->flags_values_raw[(signed long int)param_id] = arg;
  }

  signed int return_value_parse_customsignals$2;
  signed int *return_value___errno_location$1;
  struct passwd *pwd;
  struct group *grp;
  char *parse_parameter$$1$$3$$6$$value;
  char *parse_parameter$$1$$3$$6$$arg_orig;
  enum pivotroot_way pivotway;
  signed int return_value_getsubopt$5;
  char *value;
  char *arg_orig;
  enum detachnetwork_way detachnetwork_way;
  signed int return_value_getsubopt$7;
  char *parse_parameter$$1$$3$$8$$ptr;
  signed int tmp_post$11;
  signed long int return_value_xstrtol$12;
  char *parse_parameter$$1$$3$$10$$value;
  char *parse_parameter$$1$$3$$10$$arg_orig;
  enum threadingmode threadingmode;
  signed int return_value_getsubopt$13;
  char *parse_parameter$$1$$3$$11$$value;
  char *parse_parameter$$1$$3$$11$$arg_orig;
  enum outputmethod parse_parameter$$1$$3$$11$$outputmethod;
  signed int return_value_getsubopt$15;
  unsigned long int return_value_strlen$17;
  char *parse_parameter$$1$$3$$14$$subopts;
  signed long int return_value_xstrtol$18;
  signed long int return_value_xstrtol$19;
  signed long int return_value_xstrtol$20;
  signed long int return_value_xstrtol$21;
  char *subopts;
  char *parse_parameter$$1$$3$$16$$value;
  char *parse_parameter$$1$$3$$16$$arg_orig;
  enum notifyengine_enum notifyengine;
  signed int return_value_getsubopt$22;
  signed long int return_value_xstrtol$24;
  signed long int return_value_xstrtol$25;
  unsigned long int return_value_strlen$26;
  unsigned long int return_value_strlen$27;
  char *parse_parameter$$1$$3$$21$$ptr;
  char *start;
  unsigned char parse_parameter$$1$$3$$21$$exitcode;
  signed int return_value_atoi$29;
  signed int tmp_post$30;
  char *tmp_post$28;
  char *sep;
  _Bool tmp_if_expr$33;
  signed int return_value_sscanf$35;
  char *colon;
  unsigned int uid;
  unsigned int gid;
  char *parse_parameter$$1$$3$$27$$value;
  signed long int return_value_xstrtol$38;
  switch((signed int)param_id)
  {
    case 63:

    case 104:
    {
      syntax();
      break;
    }
    case 72:
    {
      ctx_p->config_path = *arg != 0 ? arg : (char *)(void *)0;
      break;
    }
    case 75:
    {
      ctx_p->config_block = *arg != 0 ? arg : (char *)(void *)0;
      break;
    }
    case 531:
      break;
    case 535:
    {
      if((signed int)paramsource == PS_CONTROL)
      {
        _warning("parse_parameter", "Cannot change \"custom-signal\" in run-time. Ignoring.");
        return 0;
      }

      return_value_parse_customsignals$2=parse_customsignals(ctx_p, arg);
      if(!(return_value_parse_customsignals$2 == 0))
      {
        return_value___errno_location$1=__errno_location();
        return *return_value___errno_location$1;
      }

      break;
    }
    case 117:
    {
      pwd=getpwnam(arg);
      ctx_p->flags[(signed long int)param_id] = ctx_p->flags[(signed long int)param_id] + 1;
      if(pwd == ((struct passwd *)NULL))
      {
        signed long int return_value_xstrtol$3;
        return_value_xstrtol$3=xstrtol(arg, &ret);
        ctx_p->uid = (unsigned int)return_value_xstrtol$3;
        break;
      }

      ctx_p->uid = pwd->pw_uid;
      break;
    }
    case 103:
    {
      grp=getgrnam(arg);
      ctx_p->flags[(signed long int)param_id] = ctx_p->flags[(signed long int)param_id] + 1;
      if(grp == ((struct group *)NULL))
      {
        signed long int return_value_xstrtol$4;
        return_value_xstrtol$4=xstrtol(arg, &ret);
        ctx_p->gid = (unsigned int)return_value_xstrtol$4;
        break;
      }

      ctx_p->gid = grp->gr_gid;
      break;
    }
    case 536:
    {
      if((signed int)paramsource == PS_CONTROL)
      {
        _warning("parse_parameter", "Cannot change \"chroot\" in run-time. Ignoring.");
        return 0;
      }

      if(*arg == 0)
      {
        free((void *)ctx_p->chroot_dir);
        ctx_p->chroot_dir = (char *)(void *)0;
        return 0;
      }

      ctx_p->chroot_dir = arg;
      break;
    }
    case 543:
    {
      parse_parameter$$1$$3$$6$$arg_orig = arg;
      if(*arg == 0)
      {
        ctx_p->flags[(signed long int)543] = PW_OFF;
        return 0;
      }

      return_value_getsubopt$5=getsubopt(&arg, pivotrootways, &parse_parameter$$1$$3$$6$$value);
      pivotway = (enum pivotroot_way)return_value_getsubopt$5;
      if((signed int)pivotway == -1)
      {
        signed int *return_value___errno_location$6;
        return_value___errno_location$6=__errno_location();
        *return_value___errno_location$6 = 22;
        _error("parse_parameter", "Invalid pivot_root use way entered: \"%s\"", parse_parameter$$1$$3$$6$$arg_orig);
        return 22;
      }

      ctx_p->flags[(signed long int)543] = (signed int)pivotway;
      break;
    }
    case 544:
    {
      arg_orig = arg;
      if(*arg == 0)
      {
        ctx_p->flags[(signed long int)param_id] = 0;
        return 0;
      }

      return_value_getsubopt$7=getsubopt(&arg, detachnetworkways, &value);
      detachnetwork_way = (enum detachnetwork_way)return_value_getsubopt$7;
      if((signed int)detachnetwork_way == -1)
      {
        signed int *return_value___errno_location$8;
        return_value___errno_location$8=__errno_location();
        *return_value___errno_location$8 = 22;
        _error("parse_parameter", "Invalid network detach way entered: \"%s\"", arg_orig);
        return 22;
      }

      ctx_p->flags[(signed long int)544] = (signed int)detachnetwork_way;
      break;
    }
    case 537:
    {
      if((signed int)paramsource == PS_CONTROL)
      {
        _warning("parse_parameter", "Cannot change \"mountpoints\" in run-time. Ignoring.");
        return 0;
      }

      while(!(ctx_p->mountpoints == 0))
      {
        ctx_p->mountpoints = ctx_p->mountpoints - 1;
        free((void *)ctx_p->mountpoint[(signed long int)ctx_p->mountpoints]);
      }
      if(*arg == 0)
        break;

      parse_parameter$$1$$3$$8$$ptr = arg;
      while((_Bool)1)
      {
        char *end;
        end=strchr(parse_parameter$$1$$3$$8$$ptr, 44);
        if(!(end == ((char *)NULL)))
          *end = (char)0;

        if(*parse_parameter$$1$$3$$8$$ptr == 0)
        {
          while(!(ctx_p->mountpoints == 0))
          {
            ctx_p->mountpoints = ctx_p->mountpoints - 1;
            free((void *)ctx_p->mountpoint[(signed long int)ctx_p->mountpoints]);
          }
          if(!(end == ((char *)NULL)))
            parse_parameter$$1$$3$$8$$ptr = &end[(signed long int)1];

        }

        else
        {
          if(ctx_p->mountpoints >= 256)
          {
            signed int *return_value___errno_location$9;
            return_value___errno_location$9=__errno_location();
            *return_value___errno_location$9 = 22;
            _error("parse_parameter", "Too many mountpoints");
            signed int *return_value___errno_location$10;
            return_value___errno_location$10=__errno_location();
            return *return_value___errno_location$10;
          }

          tmp_post$11 = ctx_p->mountpoints;
          ctx_p->mountpoints = ctx_p->mountpoints + 1;
          ctx_p->mountpoint[(signed long int)tmp_post$11]=strdup(parse_parameter$$1$$3$$8$$ptr);
          if(end == ((char *)NULL))
            break;

          *end = (char)44;
          parse_parameter$$1$$3$$8$$ptr = &end[(signed long int)1];
        }
      }
      break;
    }
    case 122:
    {
      if((signed int)paramsource == PS_CONTROL)
      {
        _warning("parse_parameter", "Cannot change \"pid-file\" in run-time. Ignoring.");
        return 0;
      }

      ctx_p->pidfile = arg;
      break;
    }
    case 114:
    {
      return_value_xstrtol$12=xstrtol(arg, &ret);
      ctx_p->retries = (signed int)(unsigned int)return_value_xstrtol$12;
      break;
    }
    case 112:
    {
      parse_parameter$$1$$3$$10$$arg_orig = arg;
      if(*arg == 0)
      {
        ctx_p->flags[(signed long int)param_id] = 0;
        return 0;
      }

      return_value_getsubopt$13=getsubopt(&arg, threading_modes, &parse_parameter$$1$$3$$10$$value);
      threadingmode = (enum threadingmode)return_value_getsubopt$13;
      if((signed int)threadingmode == -1)
      {
        signed int *return_value___errno_location$14;
        return_value___errno_location$14=__errno_location();
        *return_value___errno_location$14 = 22;
        _error("parse_parameter", "Invalid threading mode entered: \"%s\"", parse_parameter$$1$$3$$10$$arg_orig);
        return 22;
      }

      ctx_p->flags[(signed long int)112] = (signed int)threadingmode;
      break;
    }
    case 89:
    {
      parse_parameter$$1$$3$$11$$arg_orig = arg;
      if(*arg == 0)
      {
        ctx_p->flags[(signed long int)param_id] = 0;
        return 0;
      }

      return_value_getsubopt$15=getsubopt(&arg, output_methods, &parse_parameter$$1$$3$$11$$value);
      parse_parameter$$1$$3$$11$$outputmethod = (enum outputmethod)return_value_getsubopt$15;
      if((signed int)parse_parameter$$1$$3$$11$$outputmethod == -1)
      {
        signed int *return_value___errno_location$16;
        return_value___errno_location$16=__errno_location();
        *return_value___errno_location$16 = 22;
        _error("parse_parameter", "Invalid log writing destination entered: \"%s\"", parse_parameter$$1$$3$$11$$arg_orig);
        return 22;
      }

      ctx_p->flags[(signed long int)89] = (signed int)parse_parameter$$1$$3$$11$$outputmethod;
      break;
    }
    case 76:
    {
      ctx_p->listoutdir = arg;
      break;
    }
    case 108:
    {
      ctx_p->label = arg;
      break;
    }
    case 521:
    {
      return_value_strlen$17=strlen(arg);
      if(!(return_value_strlen$17 == 0ul))
      {
        ctx_p->standbyfile = arg;
        ctx_p->flags[(signed long int)521] = 1;
      }

      else
      {
        ctx_p->standbyfile = (char *)(void *)0;
        ctx_p->flags[(signed long int)521] = 0;
      }
      break;
    }
    case 555:
    {
      parse_parameter$$1$$3$$14$$subopts = arg;
      ctx_p->flags[(signed long int)555] = 0;
      while(!((signed int)*parse_parameter$$1$$3$$14$$subopts == 0))
      {
        char *parse_parameter$$1$$3$$14$$1$$value;
        signed int field;
        field=getsubopt(&parse_parameter$$1$$3$$14$$subopts, stat_fields, &parse_parameter$$1$$3$$14$$1$$value);
        _debug(4, "parse_parameter", "field == %i -> %x (%s)", field, xstatfield_to_statfield[(signed long int)field], parse_parameter$$1$$3$$14$$1$$value);
        if(!(field == 0))
          ctx_p->flags[(signed long int)555] = ctx_p->flags[(signed long int)555] | (signed int)xstatfield_to_statfield[(signed long int)field];

      }
      _debug(5, "parse_parameter", "ctx_p->flags[MODSIGN] == 0x%x", ctx_p->flags[(signed long int)555]);
      break;
    }
    case 119:
    {
      return_value_xstrtol$18=xstrtol(arg, &ret);
      ctx_p->syncdelay = (unsigned int)return_value_xstrtol$18;
      break;
    }
    case 116:
    {
      return_value_xstrtol$19=xstrtol(arg, &ret);
      ctx_p->_queues[(signed long int)QUEUE_NORMAL].collectdelay = (unsigned int)return_value_xstrtol$19;
      break;
    }
    case 84:
    {
      return_value_xstrtol$20=xstrtol(arg, &ret);
      ctx_p->_queues[(signed long int)QUEUE_BIGFILE].collectdelay = (unsigned int)return_value_xstrtol$20;
      break;
    }
    case 66:
    {
      return_value_xstrtol$21=xstrtol(arg, &ret);
      ctx_p->bfilethreshold = (unsigned long int)return_value_xstrtol$21;
      break;
    }
    case 556:
    {
      subopts = arg;
      while(!((signed int)*subopts == 0))
      {
        char *parse_parameter$$1$$3$$15$$1$$value;
        signed int syscall_bitmask;
        syscall_bitmask=getsubopt(&subopts, syscalls_bitmask, &parse_parameter$$1$$3$$15$$1$$value);
        _debug(4, "parse_parameter", "cancel syscall == %i -> 0x%x", syscall_bitmask, xcsc_to_csc[(signed long int)syscall_bitmask]);
        if(syscall_bitmask == 0)
          ctx_p->flags[(signed long int)556] = 0;

        else
          ctx_p->flags[(signed long int)556] = ctx_p->flags[(signed long int)556] | (signed int)xcsc_to_csc[(signed long int)syscall_bitmask];
      }
      break;
    }
    case 532:
    {
      parse_parameter$$1$$3$$16$$arg_orig = arg;
      if((signed int)paramsource == PS_CONTROL)
      {
        _warning("parse_parameter", "Cannot change \"monitor\" in run-time. Ignoring.");
        return 0;
      }

      if(*arg == 0)
      {
        ctx_p->flags_set[(signed long int)param_id] = 0;
        return 0;
      }

      return_value_getsubopt$22=getsubopt(&arg, notify_engines, &parse_parameter$$1$$3$$16$$value);
      notifyengine = (enum notifyengine_enum)return_value_getsubopt$22;
      if((signed int)notifyengine == -1)
      {
        signed int *return_value___errno_location$23;
        return_value___errno_location$23=__errno_location();
        *return_value___errno_location$23 = 22;
        _error("parse_parameter", "Invalid FS monitor subsystem entered: \"%s\"", parse_parameter$$1$$3$$16$$arg_orig);
        return 22;
      }

      if((signed int)notifyengine == NE_INOTIFY || (signed int)notifyengine == NE_GIO)
        goto __CPROVER_DUMP_L83;

      _error("parse_parameter", "clsync is compiled without %s subsystem support. Recompile with option \"--with-%s\" if you're planning to use it.", parse_parameter$$1$$3$$16$$arg_orig, parse_parameter$$1$$3$$16$$arg_orig);
      return 22;

    __CPROVER_DUMP_L83:
      ;
      ctx_p->flags[(signed long int)532] = (signed int)notifyengine;
      break;
    }
    case 513:
    {
      return_value_xstrtol$24=xstrtol(arg, &ret);
      ctx_p->rsyncinclimit = (unsigned int)return_value_xstrtol$24;
      break;
    }
    case 107:
    {
      return_value_xstrtol$25=xstrtol(arg, &ret);
      ctx_p->synctimeout = (unsigned int)return_value_xstrtol$25;
      break;
    }
    case 524:
    {
      return_value_strlen$26=strlen(arg);
      if(!(return_value_strlen$26 == 0ul))
      {
        ctx_p->preexithookfile = arg;
        ctx_p->flags[(signed long int)524] = 1;
      }

      else
      {
        ctx_p->preexithookfile = (char *)(void *)0;
        ctx_p->flags[(signed long int)524] = 0;
      }
      break;
    }
    case 522:
    {
      return_value_strlen$27=strlen(arg);
      if(!(return_value_strlen$27 == 0ul))
      {
        ctx_p->exithookfile = arg;
        ctx_p->flags[(signed long int)522] = 1;
      }

      else
      {
        ctx_p->exithookfile = (char *)(void *)0;
        ctx_p->flags[(signed long int)522] = 0;
      }
      break;
    }
    case 120:
    {
      parse_parameter$$1$$3$$21$$ptr = arg;
      start = arg;
      while((_Bool)1)
      {
        if((signed int)*parse_parameter$$1$$3$$21$$ptr == 0 || (signed int)*parse_parameter$$1$$3$$21$$ptr == 44)
        {
          return_value_atoi$29=atoi(start);
          parse_parameter$$1$$3$$21$$exitcode = (unsigned char)return_value_atoi$29;
          if((signed int)parse_parameter$$1$$3$$21$$exitcode == 0)
          {
            signed int i = 0;
            for( ; !(i >= 256); ctx_p->isignoredexitcode[(signed long int)tmp_post$30] = (char)0)
            {
              tmp_post$30 = i;
              i = i + 1;
            }
          }

          else
            ctx_p->isignoredexitcode[(signed long int)parse_parameter$$1$$3$$21$$exitcode] = (char)1;
          start = parse_parameter$$1$$3$$21$$ptr + (signed long int)1;
          goto __CPROVER_DUMP_L100;
        }

        signed int *return_value___errno_location$31;
        return_value___errno_location$31=__errno_location();
        *return_value___errno_location$31 = 22;
        _error("parse_parameter", "Expected a digit or comma but got \"%c\"", *parse_parameter$$1$$3$$21$$ptr);
        signed int *return_value___errno_location$32;
        return_value___errno_location$32=__errno_location();
        return *return_value___errno_location$32;

      __CPROVER_DUMP_L100:
        ;
        tmp_post$28 = parse_parameter$$1$$3$$21$$ptr;
        parse_parameter$$1$$3$$21$$ptr = parse_parameter$$1$$3$$21$$ptr + 1l;
        if(*tmp_post$28 == 0)
          break;

      }
      break;
    }
    case 86:
    {
      version();
      break;
    }
    case 87:
    {
      if((signed int)paramsource == PS_CONTROL)
      {
        _warning("parse_parameter", "Cannot change \"watch-dir\" in run-time. Ignoring.");
        return 0;
      }

      ctx_p->watchdir = arg;
      break;
    }
    case 83:
    {
      ctx_p->handlerfpath = arg;
      break;
    }
    case 82:
    {
      ctx_p->rulfpath = arg;
      break;
    }
    case 68:
    {
      sep=strstr(arg, "://");
      if(!(ctx_p->destproto == ((char *)NULL)))
      {
        free((void *)ctx_p->destproto);
        ctx_p->destproto = (char *)(void *)0;
      }

      ctx_p->destdir = arg;
      if(sep == ((char *)NULL))
      {
        char *at_ptr;
        at_ptr=strchr(arg, 64);
        char *cl_ptr;
        cl_ptr=strchr(arg, 58);
        if(!(at_ptr == ((char *)NULL)) && !(cl_ptr == ((char *)NULL)) && !(at_ptr >= cl_ptr))
        {
          ctx_p->destproto=strdup("rsync+ssh");
          _debug(5, "parse_parameter", "Destination proto is: %s (case #0)", ctx_p->destproto);
        }

        break;
      }

      char *ptr = arg;
      for( ; !(ptr >= sep); ptr = ptr + 1l)
      {
        if(!((signed int)*ptr >= 97))
          tmp_if_expr$33 = (_Bool)1;

        else
          tmp_if_expr$33 = (signed int)*ptr > 122 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$33)
          break;

      }
      if(ptr == sep)
      {
        unsigned long int len = (unsigned long int)((ptr - arg) + (signed long int)1);
        void *return_value_xmalloc$34;
        return_value_xmalloc$34=xmalloc(len + (unsigned long int)1);
        ctx_p->destproto = (char *)return_value_xmalloc$34;
        memcpy((void *)ctx_p->destproto, (const void *)arg, len);
        ctx_p->destproto[(signed long int)len] = (char)0;
      }

      _debug(5, "parse_parameter", "Destination proto is: %s (case #1)", ctx_p->destproto);
      break;
    }
    case 115:
    {
      ctx_p->socketpath = arg;
      break;
    }
    case 525:
    {
      char *parse_parameter$$1$$3$$24$$value;
      ctx_p->flags[(signed long int)525]=getsubopt(&arg, socketauth, &parse_parameter$$1$$3$$24$$value);
      if(ctx_p->flags[525l] == -1)
      {
        _error("parse_parameter", "Wrong socket auth mech entered: \"%s\"", arg);
        return 22;
      }

    }
    case 526:
    {
      return_value_sscanf$35=sscanf(arg, "%o", (unsigned int *)&ctx_p->socketmod);
      if(return_value_sscanf$35 == 0)
      {
        _error("parse_parameter", "Non octal value passed to --socket-mod: \"%s\"", arg);
        return 22;
      }

      ctx_p->flags[(signed long int)param_id] = ctx_p->flags[(signed long int)param_id] + 1;
      break;
    }
    case 527:
    {
      colon=strchr(arg, 58);
      if(colon == ((char *)NULL))
      {
        struct passwd *pwent;
        pwent=getpwnam(arg);
        if(pwent == ((struct passwd *)NULL))
        {
          _error("parse_parameter", "Cannot find username \"%s\" (case #0)", arg);
          return 22;
        }

        uid = pwent->pw_uid;
        gid = pwent->pw_gid;
      }

      else
      {
        char user[258l];
        char group[258l];
        memcpy((void *)user, (const void *)arg, (unsigned long int)((signed long int)(1 << 8) < colon - arg ? (signed long int)(1 << 8) : colon - arg));
        user[colon - arg] = (char)0;
        strncpy(group, &colon[(signed long int)1], (unsigned long int)(1 << 8));
        signed int *return_value___errno_location$36;
        return_value___errno_location$36=__errno_location();
        *return_value___errno_location$36 = 0;
        struct passwd *parse_parameter$$1$$3$$26$$2$$pwent;
        parse_parameter$$1$$3$$26$$2$$pwent=getpwnam(user);
        if(parse_parameter$$1$$3$$26$$2$$pwent == ((struct passwd *)NULL))
        {
          _error("parse_parameter", "Cannot find username \"%s\" (case #1)", (const void *)user);
          return 22;
        }

        signed int *return_value___errno_location$37;
        return_value___errno_location$37=__errno_location();
        *return_value___errno_location$37 = 0;
        struct group *grent;
        grent=getgrnam(group);
        if(grent == ((struct group *)NULL))
        {
          _error("parse_parameter", "Cannot find group \"%s\"", (const void *)group);
          return 22;
        }

        uid = parse_parameter$$1$$3$$26$$2$$pwent->pw_uid;
        gid = grent->gr_gid;
      }
      ctx_p->socketuid = uid;
      ctx_p->socketgid = gid;
      ctx_p->flags[(signed long int)param_id] = ctx_p->flags[(signed long int)param_id] + 1;
      _debug(2, "parse_parameter", "socket: uid == %u; gid == %u", uid, gid);
      break;
    }
    case 517:
    {
      ctx_p->statusfile = arg;
      break;
    }
    case 530:
    {
      ctx_p->dump_path = arg;
      break;
    }
    case 77:
    {
      ctx_p->flags[(signed long int)77]=getsubopt(&arg, modes, &parse_parameter$$1$$3$$27$$value);
      if(ctx_p->flags[77l] == -1)
      {
        _error("parse_parameter", "Wrong mode name entered: \"%s\"", arg);
        return 22;
      }

      break;
    }
    case 533:
    {
      str_splitargs(arg, synchandler_arg0, (void *)ctx_p);
      break;
    }
    case 534:
    {
      str_splitargs(arg, synchandler_arg1, (void *)ctx_p);
      break;
    }
    default:
      if(arg == ((char *)NULL))
        ctx_p->flags[(signed long int)param_id] = ctx_p->flags[(signed long int)param_id] + 1;

      else
      {
        return_value_xstrtol$38=xstrtol(arg, &ret);
        ctx_p->flags[(signed long int)param_id] = (signed int)return_value_xstrtol$38;
      }
  }
  return ret;
}

// parse_rules_fromfile
// file rules.h line 20
extern signed int parse_rules_fromfile(struct ctx *ctx_p)
{
  signed int ret = 0;
  char *rulfpath = ctx_p->rulfpath;
  struct rule *rules = ctx_p->rules;
  unsigned long int *rules_count_p = &ctx_p->rules_count;
  char *line_buf = (char *)(void *)0;
  struct _IO_FILE *f;
  f=fopen(rulfpath, "r");
  if(f == ((struct _IO_FILE *)NULL))
  {
    rules->mask = (enum ruleaction_enum)RA_NONE;
    rules->perm = (enum ruleaction_enum)RA_ALL;
    _error("parse_rules_fromfile", "Cannot open \"%s\" for reading.", rulfpath);
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    return *return_value___errno_location$1;
  }

  struct _GHashTable *autowrules_ht;
  autowrules_ht=g_hash_table_new_full(g_str_hash, g_str_equal, free, ((void (*)(void *))NULL));
  signed int i = 0;
  unsigned long int linelen;
  unsigned long int size = (unsigned long int)0;
  signed long int return_value_getline$2;
  signed int tmp_post$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  do
  {
    return_value_getline$2=getline(&line_buf, &size, f);
    linelen = (unsigned long int)return_value_getline$2;
    if(linelen == 18446744073709551615ul)
      break;

    if(linelen >= 2ul)
    {
      unsigned char sign = (unsigned char)0;
      char *line = line_buf;
      struct rule *rule = &rules[(signed long int)i];
      tmp_post$3 = i;
      i = i + 1;
      rule->num = tmp_post$3;
      linelen = linelen - 1ul;
      line[(signed long int)linelen] = (char)0;
      switch((signed int)*line)
      {
        case 43:
        {
          sign = (unsigned char)1;
          break;
        }
        case 45:
        {
          sign = (unsigned char)0;
          break;
        }
        case 35:
        {
          i = i - 1;
          goto __CPROVER_DUMP_L23;
        }
        default:
        {
          _error("parse_rules_fromfile", "Wrong rule action <%c>.", *line);
          return 22;
        }
      }
      line = line + 1l;
      linelen = linelen - 1ul;
      *line = *line | (char)0x20;
      rule->mask = (enum ruleaction_enum)RA_ALL;
      switch((signed int)sign)
      {
        case 0:
        {
          rule->perm = (enum ruleaction_enum)RA_NONE;
          break;
        }
        case 1:
          rule->perm = (enum ruleaction_enum)RA_ALL;
      }
      switch((signed int)*line)
      {
        case 42:
        {
          rule->objtype = (unsigned int)0;
          break;
        }
        case 102:
        {
          rule->objtype = (unsigned int)0100000;
          break;
        }
        case 100:
        {
          rule->objtype = (unsigned int)0040000;
          break;
        }
        case 119:
        {
          if(ctx_p->flags[77l] == 5)
            tmp_if_expr$4 = (_Bool)1;

          else
            tmp_if_expr$4 = ctx_p->flags[(signed long int)77] == 4 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$4)
            tmp_if_expr$5 = (_Bool)1;

          else
            tmp_if_expr$5 = ctx_p->flags[(signed long int)77] == 6 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$5)
            _warning("parse_rules_fromfile", "Used \"w\" rule in \"--rsync\" case. This may cause unexpected problems.");

          rule->objtype = (unsigned int)0040000;
          rule->mask = (enum ruleaction_enum)RA_WALK;
          break;
        }
        default:
        {
          _warning("parse_rules_fromfile", "Cannot parse the rule <%s>", &line[(signed long int)-1]);
          i = i - 1;
          goto __CPROVER_DUMP_L23;
        }
      }
      line = line + 1l;
      linelen = linelen - 1ul;
      _debug(1, "parse_rules_fromfile", "Rule #%i <%c>[0x%02x 0x%02x] <%c>[0x%04x] pattern <%s> (length: %i).", rule->num, line[(signed long int)-2], rule->perm, rule->mask, line[(signed long int)-1], rule->objtype, line, linelen);
      ret=rule_complete(rule, line, rules_count_p);
      if(!(ret == 0))
        break;

      line = line - 1l;
      linelen = linelen + 1ul;
    }


  __CPROVER_DUMP_L23:
    ;
  }
  while((_Bool)1);

l_parse_rules_fromfile_end:
  ;
  if(!(size == 0ul))
    free((void *)line_buf);

  fclose(f);
  _debug(3, "parse_rules_fromfile", "Adding tail-rule #%u (effective #%u).", -1, i);
  (rules + (signed long int)i)->mask = (enum ruleaction_enum)RA_NONE;
  (rules + (signed long int)i)->perm = (enum ruleaction_enum)RA_ALL;
  g_hash_table_destroy(autowrules_ht);
  return ret;
}

// parse_text_data
// file socket.c line 415
static inline signed int parse_text_data(struct sockcmd *sockcmd_p, char *args, unsigned long int args_len)
{
  _debug(6, "parse_text_data", "(%p, %p, %u)", sockcmd_p, args, args_len);
  if(args_len == 0ul)
    return 0;

  else
  {
    signed int min_args = 0;
    const char *ptr = (const char *)textmessage_args[(signed long int)sockcmd_p->cmd_id];
    if(!(ptr == ((const char *)NULL)))
      for( ; !(*ptr == 0); ptr = ptr + 1l)
        if((signed int)*ptr == 37)
        {
          if((signed int)ptr[1l] == 37)
            ptr = ptr + 1l;

          else
            min_args = min_args + 1;
        }


    switch((signed int)sockcmd_p->cmd_id)
    {
      case SOCKCMD_REQUEST_NEGOTIATION:

      case SOCKCMD_REPLY_NEGOTIATION:
      {
        sockcmd_p->data=xmalloc(sizeof(struct sockcmd_dat_negotiation) /*4ul*/ );
        struct sockcmd_dat_negotiation *d = (struct sockcmd_dat_negotiation *)sockcmd_p->data;
        signed int return_value_sscanf$1;
        return_value_sscanf$1=sscanf(args, textmessage_args[(signed long int)sockcmd_p->cmd_id], &d->prot, &d->subprot);
        if(!(return_value_sscanf$1 >= min_args))
          return 22;

        break;
      }
      case SOCKCMD_REQUEST_DUMP:
      {
        sockcmd_p->data=xmalloc(sizeof(struct sockcmd_dat_dump) /*4096ul*/ );
        struct sockcmd_dat_dump *parse_text_data$$1$$3$$2$$d = (struct sockcmd_dat_dump *)sockcmd_p->data;
        signed int return_value_sscanf$2;
        return_value_sscanf$2=sscanf(args, textmessage_args[(signed long int)sockcmd_p->cmd_id], &parse_text_data$$1$$3$$2$$d->dir_path);
        if(!(return_value_sscanf$2 >= min_args))
          return 22;

        break;
      }
      case SOCKCMD_REQUEST_SET:
      {
        sockcmd_p->data=xmalloc(sizeof(struct sockcmd_dat_set) /*16384ul*/ );
        struct sockcmd_dat_set *parse_text_data$$1$$3$$3$$d = (struct sockcmd_dat_set *)sockcmd_p->data;
        signed int return_value_sscanf$3;
        return_value_sscanf$3=sscanf(args, textmessage_args[(signed long int)sockcmd_p->cmd_id], &parse_text_data$$1$$3$$3$$d->key, &parse_text_data$$1$$3$$3$$d->value);
        if(!(return_value_sscanf$3 >= min_args))
          return 22;

        break;
      }
      case SOCKCMD_REPLY_ACK:
      {
        sockcmd_p->data=xmalloc(sizeof(struct sockcmd_dat_ack) /*16ul*/ );
        struct sockcmd_dat_ack *parse_text_data$$1$$3$$4$$d = (struct sockcmd_dat_ack *)sockcmd_p->data;
        signed int return_value_sscanf$4;
        return_value_sscanf$4=sscanf(args, textmessage_args[(signed long int)sockcmd_p->cmd_id], &parse_text_data$$1$$3$$4$$d->cmd_id, &parse_text_data$$1$$3$$4$$d->cmd_num);
        if(!(return_value_sscanf$4 >= min_args))
          return 22;

        break;
      }
      case SOCKCMD_REPLY_EINVAL:
      {
        sockcmd_p->data=xmalloc(sizeof(struct sockcmd_dat_ack) /*16ul*/ );
        struct sockcmd_dat_ack *parse_text_data$$1$$3$$5$$d = (struct sockcmd_dat_ack *)sockcmd_p->data;
        signed int return_value_sscanf$5;
        return_value_sscanf$5=sscanf(args, textmessage_args[(signed long int)sockcmd_p->cmd_id], &parse_text_data$$1$$3$$5$$d->cmd_id, &parse_text_data$$1$$3$$5$$d->cmd_num);
        if(!(return_value_sscanf$5 >= min_args))
          return 22;

        break;
      }
      case SOCKCMD_REPLY_VERSION:
      {
        if(args_len >= 5ul)
        {
          args_len = (unsigned long int)(1 << 8);
          args[(signed long int)args_len] = (char)0;
        }

        sockcmd_p->data=xmalloc(sizeof(struct sockcmd_dat_version) /*264ul*/ );
        struct sockcmd_dat_version *parse_text_data$$1$$3$$6$$d = (struct sockcmd_dat_version *)sockcmd_p->data;
        signed int return_value_sscanf$6;
        return_value_sscanf$6=sscanf(args, textmessage_args[(signed long int)sockcmd_p->cmd_id], &parse_text_data$$1$$3$$6$$d->major, &parse_text_data$$1$$3$$6$$d->minor, &parse_text_data$$1$$3$$6$$d->revision);
        if(!(return_value_sscanf$6 >= min_args))
          return 22;

        break;
      }
      case SOCKCMD_REPLY_INFO:
      {
        if(args_len >= 5ul)
        {
          args_len = (unsigned long int)(1 << 8);
          args[(signed long int)args_len] = (char)0;
        }

        sockcmd_p->data=xmalloc(sizeof(struct sockcmd_dat_info) /*2560ul*/ );
        struct sockcmd_dat_info *parse_text_data$$1$$3$$7$$d = (struct sockcmd_dat_info *)sockcmd_p->data;
        signed int return_value_sscanf$7;
        return_value_sscanf$7=sscanf(args, textmessage_args[(signed long int)sockcmd_p->cmd_id], &parse_text_data$$1$$3$$7$$d->config_block, &parse_text_data$$1$$3$$7$$d->label, &parse_text_data$$1$$3$$7$$d->flags, &parse_text_data$$1$$3$$7$$d->flags_set);
        if(!(return_value_sscanf$7 >= min_args))
          return 22;

        break;
      }
      case SOCKCMD_REPLY_UNKNOWNCMD:
      {
        sockcmd_p->data=xmalloc(sizeof(struct sockcmd_dat_ack) /*16ul*/ );
        struct sockcmd_dat_ack *parse_text_data$$1$$3$$8$$d = (struct sockcmd_dat_ack *)sockcmd_p->data;
        signed int return_value_sscanf$8;
        return_value_sscanf$8=sscanf(args, textmessage_args[(signed long int)sockcmd_p->cmd_id], &parse_text_data$$1$$3$$8$$d->cmd_id, &parse_text_data$$1$$3$$8$$d->cmd_num);
        if(!(return_value_sscanf$8 >= min_args))
          return 22;

        break;
      }
      case SOCKCMD_REPLY_INVALIDCMDID:
      {
        sockcmd_p->data=xmalloc(sizeof(struct sockcmd_dat_invalidcmd) /*8ul*/ );
        struct sockcmd_dat_invalidcmd *parse_text_data$$1$$3$$9$$d = (struct sockcmd_dat_invalidcmd *)sockcmd_p->data;
        signed int return_value_sscanf$9;
        return_value_sscanf$9=sscanf(args, textmessage_args[(signed long int)sockcmd_p->cmd_id], &parse_text_data$$1$$3$$9$$d->cmd_num);
        if(!(return_value_sscanf$9 >= min_args))
          return 22;

        break;
      }
      case SOCKCMD_REPLY_EEXIST:
      {
        sockcmd_p->data=xmalloc(sizeof(struct sockcmd_dat_eexist) /*4096ul*/ );
        struct sockcmd_dat_eexist *parse_text_data$$1$$3$$10$$d = (struct sockcmd_dat_eexist *)sockcmd_p->data;
        signed int return_value_sscanf$10;
        return_value_sscanf$10=sscanf(args, textmessage_args[(signed long int)sockcmd_p->cmd_id], &parse_text_data$$1$$3$$10$$d->file_path);
        if(!(return_value_sscanf$10 >= min_args))
          return 22;

        break;
      }
      case SOCKCMD_REPLY_EPERM:
      {
        sockcmd_p->data=xmalloc(sizeof(struct sockcmd_dat_eperm) /*8192ul*/ );
        struct sockcmd_dat_eperm *parse_text_data$$1$$3$$11$$d = (struct sockcmd_dat_eperm *)sockcmd_p->data;
        signed int return_value_sscanf$11;
        return_value_sscanf$11=sscanf(args, textmessage_args[(signed long int)sockcmd_p->cmd_id], &parse_text_data$$1$$3$$11$$d->descr);
        if(!(return_value_sscanf$11 >= min_args))
          return 22;

        break;
      }
      default:
      {
        sockcmd_p->data=xmalloc(args_len + (unsigned long int)1);
        memcpy(sockcmd_p->data, (const void *)args, args_len);
        ((char *)sockcmd_p->data)[(signed long int)args_len] = (char)0;
      }
    }
    return 0;
  }
}

// printf_stderr
// file error.c line 48
static signed int printf_stderr(const char *fmt, ...)
{
  void **args;
  signed int rc;
  args = (void **)&fmt;
  rc=vfprintf(stderr, fmt, args);
  args = ((void **)NULL);
  return rc;
}

// printf_stdout
// file error.c line 59
static signed int printf_stdout(const char *fmt, ...)
{
  void **args;
  signed int rc;
  args = (void **)&fmt;
  rc=vfprintf(stdout, fmt, args);
  args = ((void **)NULL);
  return rc;
}

// privileged_deinit
// file privileged.h line 139
extern signed int privileged_deinit(struct ctx *ctx_p)
{
  signed int ret = 0;
  _debug(2, "privileged_deinit", "endof privileged_deinit()");
  return ret;
}

// privileged_init
// file privileged.h line 138
extern signed int privileged_init(struct ctx *ctx_p)
{
  _privileged_fork_execvp = __privileged_fork_execvp;
  __privileged_fork_execvp_uid = ctx_p->synchandler_uid;
  __privileged_fork_execvp_gid = ctx_p->synchandler_gid;
  _privileged_kill_child = __privileged_kill_child_itself;
  return 0;
}

// pthread_cond_destroy_shared
// file pthreadex.c line 54
extern signed int pthread_cond_destroy_shared(union anonymous$1 *cond_p)
{
  signed int rc;
  rc=pthread_cond_destroy(cond_p);
  shm_free((void *)cond_p);
  return rc;
}

// pthread_cond_init_shared
// file pthreadex.c line 43
extern signed int pthread_cond_init_shared(union anonymous$1 **cond_p)
{
  void *return_value_shm_malloc$1;
  return_value_shm_malloc$1=shm_malloc(sizeof(union anonymous$1) /*48ul*/ );
  *cond_p = (union anonymous$1 *)return_value_shm_malloc$1;
  static union anonymous$1 cond_initial = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
  memcpy((void *)*cond_p, (const void *)&cond_initial, sizeof(union anonymous$1) /*48ul*/ );
  union anonymous$0 attr;
  pthread_condattr_init(&attr);
  pthread_condattr_setpshared(&attr, 1);
  signed int return_value_pthread_cond_init$2;
  return_value_pthread_cond_init$2=pthread_cond_init(*cond_p, &attr);
  return return_value_pthread_cond_init$2;
}

// pthread_mutex_destroy_shared
// file pthreadex.h line 23
extern signed int pthread_mutex_destroy_shared(union anonymous *mutex_p)
{
  signed int rc;
  rc=pthread_mutex_destroy(mutex_p);
  shm_free((void *)mutex_p);
  return rc;
}

// pthread_mutex_init_shared
// file pthreadex.h line 22
extern signed int pthread_mutex_init_shared(union anonymous **mutex_p)
{
  void *return_value_shm_malloc_try$1;
  return_value_shm_malloc_try$1=shm_malloc_try(sizeof(union anonymous) /*40ul*/ );
  *mutex_p = (union anonymous *)return_value_shm_malloc_try$1;
  static union anonymous mutex_initial = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
  memcpy((void *)*mutex_p, (const void *)&mutex_initial, sizeof(union anonymous) /*40ul*/ );
  union anonymous$0 attr;
  pthread_mutexattr_init(&attr);
  pthread_mutexattr_setpshared(&attr, 1);
  signed int return_value_pthread_mutex_init$2;
  return_value_pthread_mutex_init$2=pthread_mutex_init(*mutex_p, &attr);
  return return_value_pthread_mutex_init$2;
}

// pthread_mutex_reltimedlock
// file pthreadex.h line 26
extern signed int pthread_mutex_reltimedlock(union anonymous *mutex_p, signed long int tv_sec, signed long int tv_nsec)
{
  struct timespec abs_time;
  signed int return_value_clock_gettime$1;
  return_value_clock_gettime$1=clock_gettime(0, &abs_time);
  if(!(return_value_clock_gettime$1 == 0))
    return -1;

  else
  {
    abs_time.tv_sec = abs_time.tv_sec + tv_sec;
    abs_time.tv_nsec = abs_time.tv_nsec + tv_nsec;
    if(abs_time.tv_nsec >= 1000000001l)
    {
      abs_time.tv_sec = abs_time.tv_sec + 1l;
      abs_time.tv_nsec = abs_time.tv_nsec - (signed long int)(1000 * 1000 * 1000);
    }

    signed int return_value_pthread_mutex_timedlock$2;
    return_value_pthread_mutex_timedlock$2=pthread_mutex_timedlock(mutex_p, &abs_time);
    return return_value_pthread_mutex_timedlock$2;
  }
}

// recognize_event
// file mon_inotify.c line 38
static inline void recognize_event(struct recognize_event_return *r, unsigned int event)
{
  enum eventobjtype type;
  signed int is_created;
  signed int is_deleted;
  type = (enum eventobjtype)((event & (unsigned int)0x40000000) != 0u ? EOT_DIR : EOT_FILE);
  is_created = (signed int)(event & (unsigned int)(0x00000100 | 0x00000080));
  is_deleted = (signed int)(event & (unsigned int)(0x00000400 | 0x00000200 | 0x00000040));
  _debug(4, "recognize_event", "type == %x; is_created == %x; is_deleted == %x", type, is_created, is_deleted);
  r->objtype_old = (enum eventobjtype)(is_created != 0 ? EOT_DOESNTEXIST : (signed int)type);
  r->objtype_new = (enum eventobjtype)(is_deleted != 0 ? EOT_DOESNTEXIST : (signed int)type);
  goto __CPROVER_DUMP_L2;

__CPROVER_DUMP_L2:
  ;
}

// rsync_aggrout
// file sync.c line 2585
signed int rsync_aggrout(void *outline_gp, void *flags_gp, void *arg_gp)
{
  struct dosync_arg *dosync_arg_p = (struct dosync_arg *)arg_gp;
  char *outline = (char *)outline_gp;
  struct _IO_FILE *outf = dosync_arg_p->outf;
  enum eventinfo_flags flags = (enum eventinfo_flags)(signed int)(signed long int)flags_gp;
  signed int ret;
  ret=rsync_outline(outf, outline, flags);
  if(!(ret == 0))
  {
    _error("rsync_aggrout", "Got error from rsync_outline(). Exit.");
    exit(ret);
  }

  return (signed int)!(0 != 0);
}

// rsync_escape
// file sync.c line 2516
const char * rsync_escape(const char *path)
{
  unsigned long int sc_count = (unsigned long int)0;
  unsigned long int i = (unsigned long int)0;
  while((_Bool)1)
    switch((signed int)path[(signed long int)i])
    {
      case 0:
        goto l_rsync_escape_loop0_end;
      case 91:

      case 93:

      case 42:

      case 63:

      case 92:
        sc_count = sc_count + 1ul;
      default:
        i = i + 1ul;
    }

l_rsync_escape_loop0_end:
  ;
  unsigned long int tmp_post$2;
  if(sc_count == 0ul)
    return path;

  else
  {
    unsigned long int required_size = i + sc_count + (unsigned long int)1;
    if(required_size >= rsync_escape_result_size)
    {
      rsync_escape_result_size = required_size + (unsigned long int)(1 << 10);
      void *return_value_xrealloc$1;
      return_value_xrealloc$1=xrealloc((void *)rsync_escape_result, rsync_escape_result_size);
      rsync_escape_result = (char *)return_value_xrealloc$1;
    }

    i = i + 1ul;
    do
    {
      tmp_post$2 = i;
      i = i - 1ul;
      if(tmp_post$2 == 0ul)
        break;

      rsync_escape_result[(signed long int)(i + sc_count)] = path[(signed long int)i];
      if((signed int)path[(signed long int)i] == 42 || (signed int)path[(signed long int)i] == 63 || (signed int)path[(signed long int)i] == 91 || (signed int)path[(signed long int)i] == 92 || (signed int)path[(signed long int)i] == 93)
      {
        sc_count = sc_count - 1ul;
        rsync_escape_result[(signed long int)(i + sc_count)] = (char)92;
      }

    }
    while((_Bool)1);
    return rsync_escape_result;
  }
}

// rsync_escape_cleanup
// file sync.c line 2511
void rsync_escape_cleanup()
{
  if(!(rsync_escape_result_size == 0ul))
    free((void *)rsync_escape_result);

}

// rsync_listpush
// file sync.c line 2601
static inline signed int rsync_listpush(struct indexes *indexes_p, const char *fpath, unsigned long int fpath_len, enum eventinfo_flags flags, signed int *linescount_p)
{
  char *fpathwslash;
  if(fpath_len >= 1ul)
  {
    void *return_value___builtin_alloca$1;
    return_value___builtin_alloca$1=__builtin_alloca(fpath_len + (unsigned long int)2);
    fpathwslash = (char *)return_value___builtin_alloca$1;
    fpathwslash[(signed long int)0] = (char)47;
    memcpy((void *)&fpathwslash[(signed long int)1], (const void *)fpath, fpath_len + (unsigned long int)1);
  }

  else
    fpathwslash = (char *)fpath;
  const char *return_value_rsync_escape$2;
  return_value_rsync_escape$2=rsync_escape(fpathwslash);
  fpathwslash = (char *)return_value_rsync_escape$2;
  char *end = fpathwslash;
  _debug(3, "rsync_listpush", "\"%s\": Adding to rsynclist: \"%s\" with flags %p.", fpathwslash, fpathwslash, (void *)(signed long int)flags);
  char *return_value_strdup$3;
  return_value_strdup$3=strdup(fpathwslash);
  indexes_outaggr_add(indexes_p, return_value_strdup$3, flags);
  if(!(linescount_p == ((signed int *)NULL)))
    *linescount_p = *linescount_p + 1;

  while(!(end == ((char *)NULL)))
  {
    if((signed int)*fpathwslash == 0x00)
      break;

    _debug(3, "rsync_listpush", "Non-recursively \"%s\": Adding to rsynclist: \"%s\".", fpathwslash, fpathwslash);
    char *return_value_strdup$4;
    return_value_strdup$4=strdup(fpathwslash);
    indexes_outaggr_add(indexes_p, return_value_strdup$4, (enum eventinfo_flags)EVIF_NONE);
    if(!(linescount_p == ((signed int *)NULL)))
      *linescount_p = *linescount_p + 1;

    end=strrchr(fpathwslash, 47);
    if(end == ((char *)NULL))
      break;

    if(!(end - fpathwslash >= 1l))
      break;

    *end = (char)0x00;
  }
  return 0;
}

// rsync_outline
// file sync.c line 2565
static inline signed int rsync_outline(struct _IO_FILE *outf, char *outline, enum eventinfo_flags flags)
{
  if(!((EVIF_RECURSIVELY & (signed int)flags) == 0))
  {
    _debug(3, "rsync_outline", "Recursively \"%s\": Writing to rsynclist: \"%s/***\".", outline, outline);
    signed int return_value_fprintf$1;
    return_value_fprintf$1=fprintf(outf, "%s/***\n", outline);
    if(!(return_value_fprintf$1 >= 1))
      _critical("rsync_outline", "Assert: fprintf(outf, \"%s/***\\n\", outline) <= 0");

  }

  else
    if(!((EVIF_CONTENTRECURSIVELY & (signed int)flags) == 0))
    {
      _debug(3, "rsync_outline", "Content-recursively \"%s\": Writing to rsynclist: \"%s/**\".", outline, outline);
      signed int return_value_fprintf$2;
      return_value_fprintf$2=fprintf(outf, "%s/**\n", outline);
      if(!(return_value_fprintf$2 >= 1))
        _critical("rsync_outline", "Assert: fprintf(outf, \"%s/**\\n\", outline) <= 0");

    }

    else
    {
      _debug(3, "rsync_outline", "Non-recursively \"%s\": Writing to rsynclist: \"%s\".", outline, outline);
      signed int return_value_fprintf$3;
      return_value_fprintf$3=fprintf(outf, "%s\n", outline);
      if(!(return_value_fprintf$3 >= 1))
        _critical("rsync_outline", "Assert: fprintf(outf, \"%s\\n\", outline) <= 0");

    }
  return 0;
}

// rule_complete
// file rules.c line 27
signed int rule_complete(struct rule *rule_p, char *expr, unsigned long int *rules_count_p)
{
  _debug(3, "rule_complete", "<%s>.", expr);
  char buf[8192l];
  signed int ret = 0;
  if(rule_p->num >= 256)
  {
    _error("rule_complete", "Too many rules (%i >= %i).", rule_p->num, 1 << 8);
    return 12;
  }

  else
  {
    ret=regcomp(&rule_p->expr, expr, 1 | ((1 << 1) << 1) << 1);
    if(!(ret == 0))
    {
      regerror(ret, &rule_p->expr, buf, (unsigned long int)8192);
      _error("rule_complete", "Invalid regexp pattern <%s>: %s (regex-errno: %i).", expr, (const void *)buf, ret);
      return ret;
    }

    else
    {
      *rules_count_p = *rules_count_p + 1ul;
      return ret;
    }
  }
}

// rules_getperm
// file rules.c line 371
extern enum ruleaction_enum rules_getperm(const char *fpath, unsigned int st_mode, struct rule *rules_p, enum ruleaction_enum ruleactions)
{
  struct rule *rule_p = (struct rule *)(void *)0;
  enum ruleaction_enum gotpermto = (enum ruleaction_enum)0;
  enum ruleaction_enum resultperm = (enum ruleaction_enum)0;
  _debug(3, "rules_getperm", "rules_getperm(\"%s\", %p, %p (#%u), %p)", fpath, (void *)(signed long int)st_mode, rules_p, rules_p->num, (void *)(signed long int)ruleactions);
  for( ; !(((signed int)gotpermto & (signed int)ruleactions) == (signed int)ruleactions); gotpermto = gotpermto | rule_p->mask)
  {
    rules_search_getperm(fpath, st_mode, rules_p, ruleactions, &rule_p);
    if((signed int)rule_p->mask == RA_NONE)
    {
      resultperm = resultperm | (enum ruleaction_enum)((signed int)rule_p->perm & ((signed int)gotpermto ^ RA_ALL));
      break;
    }

    resultperm = resultperm | (enum ruleaction_enum)((signed int)rule_p->perm & ((signed int)gotpermto ^ (signed int)rule_p->mask) & (signed int)rule_p->mask);
  }
  _debug(3, "rules_getperm", "rules_getperm(\"%s\", %p, rules_p, %p): result perm is %p", fpath, (void *)(signed long int)st_mode, (void *)(signed long int)ruleactions, (void *)(signed long int)resultperm);
  return resultperm;
}

// rules_search_getperm
// file rules.c line 300
extern enum ruleaction_enum rules_search_getperm(const char *fpath, unsigned int st_mode, struct rule *rules_p, const enum ruleaction_enum ruleaction, struct rule **rule_pp)
{
  _debug(3, "rules_search_getperm", "rules_search_getperm(\"%s\", %p, %p, %p, %p)", fpath, (void *)(unsigned long int)st_mode, rules_p, (void *)(signed long int)ruleaction, (void *)(signed long int)rule_pp);
  signed int i = 0;
  struct rule *rule_p = rules_p;
  unsigned int ftype = st_mode & (unsigned int)0170000;
  i = 0;
  if(!(rule_pp == ((struct rule **)NULL)))
  {
    if(!(*rule_pp == ((struct rule *)NULL)))
    {
      _debug(3, "rules_search_getperm", "Previous position is set.");
      if((signed int)rule_p->mask == RA_NONE)
        return rule_p->perm;

      *rule_pp = *rule_pp + 1l;
      rule_p = *rule_pp;
      i = rule_p->num;
    }

  }

  _debug(3, "rules_search_getperm", "Starting from position %i", i);
  _Bool tmp_if_expr$1;
  while(!((signed int)rule_p->mask == RA_NONE))
  {
    if(!(rule_p->objtype == 0u))
      tmp_if_expr$1 = rule_p->objtype != ftype ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    _debug(3, "rules_search_getperm", "%i -> %p/%p: type compare: %p, %p -> %i", i, (void *)(signed long int)rule_p->perm, (void *)(signed long int)rule_p->mask, (void *)(unsigned long int)ftype, (void *)(unsigned long int)rule_p->objtype, (unsigned char)!tmp_if_expr$1);
    if(((signed int)rule_p->mask & (signed int)ruleaction) == 0)
    {
      _debug(3, "rules_search_getperm", "action-mask mismatch. Skipping.");
      rule_p = rule_p + 1l;
      i = i + 1;
    }

    else
      if(!(rule_p->objtype == 0u))
      {
        if(rule_p->objtype == ftype)
          goto __CPROVER_DUMP_L12;

        _debug(3, "rules_search_getperm", "objtype mismatch. Skipping.");
        rule_p = rule_p + 1l;
        i = i + 1;
      }

      else
      {

      __CPROVER_DUMP_L12:
        ;
        signed int return_value_regexec$2;
        return_value_regexec$2=regexec(&rule_p->expr, fpath, (unsigned long int)0, (struct anonymous$10 *)(void *)0, 0);
        if(return_value_regexec$2 == 0)
          break;

        _debug(3, "rules_search_getperm", "doesn't match regex. Skipping.");
        rule_p = rule_p + 1l;
        i = i + 1;
      }
  }
  _debug(2, "rules_search_getperm", "matched to rule #%u for \"%s\":\t%p/%p (queried: %p).", (signed int)rule_p->mask == RA_NONE ? -1 : i, fpath, (void *)(signed long int)rule_p->perm, (void *)(signed long int)rule_p->mask, (void *)(signed long int)ruleaction);
  if(!(rule_pp == ((struct rule **)NULL)))
    *rule_pp = rule_p;

  return rule_p->perm;
}

// setenv_iteration
// file sync.c line 75
static inline void setenv_iteration(unsigned int iteration_num)
{
  char iterations[(signed long int)sizeof(char [11l]) /*11l*/ ];
  sprintf(iterations, "%i", iteration_num);
  setenv("CLSYNC_ITERATION", iterations, 1);
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// sethandler_sigchld
// file main.c line 440
signed int sethandler_sigchld(void (*handler)())
{
  struct sigaction sa;
  sa.__sigaction_handler.sa_handler = (void (*)(signed int))handler;
  sigemptyset(&sa.sa_mask);
  sa.sa_flags = 0x10000000 | 1;
  signed int return_value_sigaction$1;
  return_value_sigaction$1=sigaction(17, &sa, ((struct sigaction *)NULL));
  if(return_value_sigaction$1 == -1)
    _critical("sethandler_sigchld", "Assert: sigaction(17, &sa, 0) == -1");

  return 0;
}

// shm_calloc
// file malloc.c line 221
extern void * shm_calloc(unsigned long int nmemb, unsigned long int size)
{
  void *ret;
  unsigned long int total_size;
  nmemb = nmemb + 1ul;
  size = size + 1ul;
  total_size = nmemb * size;
  ret=shm_malloc(total_size);
  if(ret == NULL)
    _critical("shm_calloc", "Assert: ret == ((void *)0)");

  memset(ret, 0, total_size);
  return ret;
}

// shm_free
// file malloc.c line 238
extern void shm_free(void *ptr)
{
  shmdt(ptr);
}

// shm_malloc
// file malloc.c line 212
extern void * shm_malloc(unsigned long int size)
{
  void *ret;
  ret=shm_malloc_try(size);
  if(ret == NULL)
    _critical("shm_malloc", "Assert: ret == ((void *)0)");

  return ret;
}

// shm_malloc_try
// file malloc.c line 183
extern void * shm_malloc_try(unsigned long int size)
{
  void *ret;
  size = size + 1ul;
  signed int privileged_shmid;
  privileged_shmid=shmget(0, size, (signed int)0 | 01000 | 0600);
  struct shmid_ds shmid_ds;
  if(privileged_shmid == -1)
    return (void *)0;

  else
  {
    ret=shmat(privileged_shmid, (void *)0, 0);
    if((signed long int)ret == -1l)
      return (void *)0;

    else
    {
      shmctl(privileged_shmid, 2, &shmid_ds);
      shmid_ds.shm_perm.mode = (unsigned short int)0;
      shmctl(privileged_shmid, 1, &shmid_ds);
      shmctl(privileged_shmid, 2, &shmid_ds);
      if(!(shmid_ds.shm_lpid == shmid_ds.shm_cpid))
      {
        _error("shm_malloc_try", "A process (pid %u) attached to my shared memory. It's a security problem. Emergency exit.");
        shmdt(ret);
        return (void *)0;
      }

      else
        return ret;
    }
  }
}

// so_call_rsync
// file sync.c line 795
static inline signed int so_call_rsync(struct ctx *ctx_p, struct indexes *indexes_p, const char *inclistfile, const char *exclistfile)
{
  _debug(2, "so_call_rsync", "inclistfile == \"%s\"; exclistfile == \"%s\"", inclistfile, exclistfile);
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$5;
  if(!(ctx_p->flags[112l] == PM_OFF))
  {
    if(!(ctx_p->flags[112l] == PM_SAFE))
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = ctx_p->iteration_num != 0u ? (_Bool)1 : (_Bool)0;
    tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$6 = (_Bool)0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(!tmp_if_expr$6)
  {
    _debug(3, "so_call_rsync", "ctx_p->handler_funct.rsync == %p", ctx_p->handler_funct.rsync);
    indexes_p->nonthreaded_syncing_fpath2ei_ht = indexes_p->fpath2ei_ht;
    signed int rc = 0;
    signed int err = 0;
    signed int try_n = 0;
    signed int try_again;
    enum state_enum status = (enum state_enum)STATE_UNKNOWN;
    try_again = 0;
    try_n = try_n + 1;
    alarm(ctx_p->synctimeout);
    rc=ctx_p->handler_funct.rsync(inclistfile, exclistfile);
    alarm((unsigned int)0);
    err=exitcode_process(ctx_p, rc);
    if(!(err == 0))
    {
      if(try_n == 1)
      {
        if(!((signed int)ctx_p->state == STATE_TERM))
        {
          if(!((signed int)ctx_p->state == STATE_EXIT))
          {
            status = ctx_p->state;
            ctx_p->state = (volatile enum state_enum)STATE_SYNCHANDLER_ERR;
            main_status_update(ctx_p);
          }

        }

      }

      if(ctx_p->retries == 0)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = try_n < ctx_p->retries ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        tmp_if_expr$2 = (signed int)ctx_p->state != STATE_TERM ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (signed int)ctx_p->state != STATE_EXIT ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      try_again = (signed int)tmp_if_expr$3;
      _warning("so_call_rsync", "Bad exitcode %i (errcode %i). %s.", rc, err, try_again != 0 ? "Retrying" : "Give up");
      if(!(try_again == 0))
      {
        _debug(2, "so_call_rsync", "Sleeping for %u seconds before the retry.", ctx_p->syncdelay);
        sleep(ctx_p->syncdelay);
      }

    }

    if(!(err == 0))
      tmp_if_expr$4 = !(ctx_p->flags[(signed long int)529] != 0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
    {
      _error("so_call_rsync", "Bad exitcode %i (errcode %i)", rc, err);
      rc = err;
    }

    else
      if(!((signed int)status == STATE_UNKNOWN))
      {
        ctx_p->state = status;
        main_status_update(ctx_p);
      }

    indexes_p->nonthreaded_syncing_fpath2ei_ht = (struct _GHashTable *)(void *)0;
    signed int ret_cleanup;
    ret_cleanup=so_call_rsync_finished(ctx_p, inclistfile, exclistfile);
    if(!(ret_cleanup == 0))
      return rc != 0 ? rc : ret_cleanup;

    return rc;
  }

  struct threadinfo *threadinfo_p;
  threadinfo_p=thread_new();
  signed int *return_value___errno_location$7;
  if(threadinfo_p == ((struct threadinfo *)NULL))
  {
    return_value___errno_location$7=__errno_location();
    return *return_value___errno_location$7;
  }

  else
  {
    threadinfo_p->try_n = 0;
    threadinfo_p->callback = (signed int (*)(struct ctx *, struct thread_callbackfunct_arg *))(void *)0;
    void *return_value_xmalloc$8;
    return_value_xmalloc$8=xmalloc(sizeof(char *) /*8ul*/  * (unsigned long int)3);
    threadinfo_p->argv = (char **)return_value_xmalloc$8;
    threadinfo_p->ctx_p = ctx_p;
    threadinfo_p->starttime=time((signed long int *)(void *)0);
    threadinfo_p->fpath2ei_ht=g_hash_table_dup(indexes_p->fpath2ei_ht, g_str_hash, g_str_equal, free, free, (void * (*)(void *))strdup, eidup);
    threadinfo_p->iteration = ctx_p->iteration_num;
    threadinfo_p->argv[(signed long int)0]=strdup(inclistfile);
    threadinfo_p->argv[(signed long int)1]=strdup(exclistfile);
    if(!(ctx_p->synctimeout == 0u))
      threadinfo_p->expiretime = threadinfo_p->starttime + (signed long int)ctx_p->synctimeout;

    signed int return_value_pthread_create$10;
    return_value_pthread_create$10=pthread_create(&threadinfo_p->pthread, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))so_call_rsync_thread, (void *)threadinfo_p);
    if(!(return_value_pthread_create$10 == 0))
    {
      _error("so_call_rsync", "Cannot pthread_create().");
      signed int *return_value___errno_location$9;
      return_value___errno_location$9=__errno_location();
      return *return_value___errno_location$9;
    }

    _debug(3, "so_call_rsync", "thread %p", threadinfo_p->pthread);
    return 0;
  }
}

// so_call_rsync_finished
// file sync.c line 722
static inline signed int so_call_rsync_finished(struct ctx *ctx_p, const char *inclistfile, const char *exclistfile)
{
  signed int ret0;
  signed int ret1;
  _debug(5, "so_call_rsync_finished", "");
  if(!(ctx_p->flags[85l] == 0))
    return 0;

  else
    if(inclistfile == ((const char *)NULL))
    {
      _error("so_call_rsync_finished", "inclistfile == NULL.");
      return 22;
    }

    else
    {
      _debug(3, "so_call_rsync_finished", "unlink()-ing \"%s\"", inclistfile);
      ret0=unlink(inclistfile);
      if(!(ctx_p->flags[514l] == 0))
        return ret0;

      else
        if(exclistfile == ((const char *)NULL))
        {
          _error("so_call_rsync_finished", "exclistfile == NULL.");
          return 22;
        }

        else
        {
          _debug(3, "so_call_rsync_finished", "unlink()-ing \"%s\"", exclistfile);
          ret1=unlink(exclistfile);
          return ret0 == 0 ? ret1 : ret0;
        }
    }
}

// so_call_rsync_thread
// file sync.c line 750
signed int so_call_rsync_thread(struct threadinfo *threadinfo_p)
{
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  _debug(3, "so_call_rsync_thread", "thread_num == %i; threadinfo_p == %p; i_p->pthread %p; thread %p", threadinfo_p->thread_num, threadinfo_p, threadinfo_p->pthread, return_value_pthread_self$1);
  struct ctx *ctx_p = threadinfo_p->ctx_p;
  char **so_call_rsync_thread$$1$$argv = threadinfo_p->argv;
  signed int err = 0;
  signed int rc = 0;
  signed int try_again;
  try_again = 0;
  threadinfo_p->try_n = threadinfo_p->try_n + 1;
  rc=ctx_p->handler_funct.rsync(so_call_rsync_thread$$1$$argv[(signed long int)0], so_call_rsync_thread$$1$$argv[(signed long int)1]);
  err=exitcode_process(threadinfo_p->ctx_p, rc);
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(!(err == 0))
  {
    if(ctx_p->retries == 0)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = threadinfo_p->try_n < ctx_p->retries ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (signed int)ctx_p->state != STATE_TERM ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (signed int)ctx_p->state != STATE_EXIT ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    try_again = (signed int)tmp_if_expr$4;
    _warning("so_call_rsync_thread", "Bad exitcode %i (errcode %i). %s.", rc, err, try_again != 0 ? "Retrying" : "Give up");
    if(!(try_again == 0))
    {
      _debug(2, "so_call_rsync_thread", "Sleeping for %u seconds before the retry.", ctx_p->syncdelay);
      sleep(ctx_p->syncdelay);
    }

  }

  if(!(err == 0))
  {
    if(ctx_p->flags[529l] == 0)
    {
      _error("so_call_rsync_thread", "Bad exitcode %i (errcode %i)", rc, err);
      threadinfo_p->errcode = err;
    }

  }

  err=so_call_rsync_finished(ctx_p, so_call_rsync_thread$$1$$argv[(signed long int)0], so_call_rsync_thread$$1$$argv[(signed long int)1]);
  if(!(err == 0))
  {
    exitcode = err;
    pthread_kill(pthread_sighandler, 15);
  }

  free((void *)so_call_rsync_thread$$1$$argv[(signed long int)0]);
  free((void *)so_call_rsync_thread$$1$$argv[(signed long int)1]);
  free((void *)so_call_rsync_thread$$1$$argv);
  err=thread_exit(threadinfo_p, rc);
  if(!(err == 0))
  {
    exitcode = err;
    pthread_kill(pthread_sighandler, 15);
  }

  return rc;
}

// so_call_sync
// file sync.c line 646
static inline signed int so_call_sync(struct ctx *ctx_p, struct indexes *indexes_p, signed int n, struct api_eventinfo *ei)
{
  _debug(2, "so_call_sync", "n == %i", n);
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$9;
  if(!(ctx_p->flags[112l] == PM_OFF))
  {
    if(!(ctx_p->flags[112l] == PM_SAFE))
      tmp_if_expr$9 = (_Bool)1;

    else
      tmp_if_expr$9 = ctx_p->iteration_num != 0u ? (_Bool)1 : (_Bool)0;
    tmp_if_expr$10 = tmp_if_expr$9 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$10 = (_Bool)0;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$8;
  if(!tmp_if_expr$10)
  {
    signed int rc = 0;
    signed int ret = 0;
    signed int err = 0;
    signed int try_n = 0;
    signed int try_again;
    enum state_enum status = (enum state_enum)STATE_UNKNOWN;
    indexes_p->nonthreaded_syncing_fpath2ei_ht = indexes_p->fpath2ei_ht;
    try_again = 0;
    try_n = try_n + 1;
    alarm(ctx_p->synctimeout);
    rc=ctx_p->handler_funct.sync(n, ei);
    alarm((unsigned int)0);
    err=exitcode_process(ctx_p, rc);
    if(!(err == 0))
    {
      if(try_n == 1)
      {
        if(!((signed int)ctx_p->state == STATE_TERM))
        {
          if(!((signed int)ctx_p->state == STATE_EXIT))
          {
            status = ctx_p->state;
            ctx_p->state = (volatile enum state_enum)STATE_SYNCHANDLER_ERR;
            main_status_update(ctx_p);
          }

        }

      }

      if(ctx_p->retries == 0)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = try_n < ctx_p->retries ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$5)
        tmp_if_expr$6 = (signed int)ctx_p->state != STATE_TERM ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$6 = (_Bool)0;
      if(tmp_if_expr$6)
        tmp_if_expr$7 = (signed int)ctx_p->state != STATE_EXIT ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$7 = (_Bool)0;
      try_again = (signed int)tmp_if_expr$7;
      _warning("so_call_sync", "Bad exitcode %i (errcode %i). %s.", rc, err, try_again != 0 ? "Retrying" : "Give up");
      if(!(try_again == 0))
      {
        _debug(2, "so_call_sync", "Sleeping for %u seconds before the retry.", ctx_p->syncdelay);
        sleep(ctx_p->syncdelay);
      }

    }

    if(!(err == 0))
    {
      if(ctx_p->retries == 0)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = try_n < ctx_p->retries ? (_Bool)1 : (_Bool)0;
      tmp_if_expr$2 = tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = (signed int)ctx_p->state != STATE_TERM ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
      tmp_if_expr$4 = (signed int)ctx_p->state != STATE_EXIT ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    if(!(err == 0))
      tmp_if_expr$8 = !(ctx_p->flags[(signed long int)529] != 0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$8 = (_Bool)0;
    if(tmp_if_expr$8)
    {
      _error("so_call_sync", "Bad exitcode %i (errcode %i)", rc, err);
      ret = err;
    }

    else
      if(!((signed int)status == STATE_UNKNOWN))
      {
        ctx_p->state = status;
        main_status_update(ctx_p);
      }

    indexes_p->nonthreaded_syncing_fpath2ei_ht = (struct _GHashTable *)(void *)0;
    so_call_sync_finished(n, ei);
    return ret;
  }

  struct threadinfo *threadinfo_p;
  threadinfo_p=thread_new();
  signed int *return_value___errno_location$11;
  if(threadinfo_p == ((struct threadinfo *)NULL))
  {
    return_value___errno_location$11=__errno_location();
    return *return_value___errno_location$11;
  }

  else
  {
    threadinfo_p->try_n = 0;
    threadinfo_p->callback = (signed int (*)(struct ctx *, struct thread_callbackfunct_arg *))(void *)0;
    threadinfo_p->argv = (char **)(void *)0;
    threadinfo_p->ctx_p = ctx_p;
    threadinfo_p->starttime=time((signed long int *)(void *)0);
    threadinfo_p->fpath2ei_ht=g_hash_table_dup(indexes_p->fpath2ei_ht, g_str_hash, g_str_equal, free, free, (void * (*)(void *))strdup, eidup);
    threadinfo_p->n = n;
    threadinfo_p->ei = ei;
    threadinfo_p->iteration = ctx_p->iteration_num;
    if(!(ctx_p->synctimeout == 0u))
      threadinfo_p->expiretime = threadinfo_p->starttime + (signed long int)ctx_p->synctimeout;

    signed int return_value_pthread_create$13;
    return_value_pthread_create$13=pthread_create(&threadinfo_p->pthread, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))so_call_sync_thread, (void *)threadinfo_p);
    if(!(return_value_pthread_create$13 == 0))
    {
      _error("so_call_sync", "Cannot pthread_create().");
      signed int *return_value___errno_location$12;
      return_value___errno_location$12=__errno_location();
      return *return_value___errno_location$12;
    }

    _debug(3, "so_call_sync", "thread %p", threadinfo_p->pthread);
    return 0;
  }
}

// so_call_sync_finished
// file sync.c line 584
static inline void so_call_sync_finished(signed int n, struct api_eventinfo *ei)
{
  signed int i = 0;
  struct api_eventinfo *ei_i = ei;
  while(!(i >= n))
    if(ei_i->path == ((const char *)NULL))
    {
      _warning("so_call_sync_finished", "ei_i->path == NULL");
      i = i + 1;
    }

    else
    {
      free((void *)(char *)ei_i->path);
      ei_i = ei_i + 1l;
      i = i + 1;
    }
  if(!(ei == ((struct api_eventinfo *)NULL)))
    free((void *)ei);

  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L6:
  ;
}

// so_call_sync_thread
// file sync.c line 605
signed int so_call_sync_thread(struct threadinfo *threadinfo_p)
{
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  _debug(3, "so_call_sync_thread", "thread_num == %i; threadinfo_p == %p; i_p->pthread %p; thread %p", threadinfo_p->thread_num, threadinfo_p, threadinfo_p->pthread, return_value_pthread_self$1);
  struct ctx *ctx_p = threadinfo_p->ctx_p;
  signed int n = threadinfo_p->n;
  struct api_eventinfo *ei = threadinfo_p->ei;
  signed int err = 0;
  signed int rc = 0;
  signed int try_again = 0;
  try_again = 0;
  threadinfo_p->try_n = threadinfo_p->try_n + 1;
  rc=ctx_p->handler_funct.sync(n, ei);
  err=exitcode_process(threadinfo_p->ctx_p, rc);
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  if(!(err == 0))
  {
    if(ctx_p->retries == 0)
      tmp_if_expr$6 = (_Bool)1;

    else
      tmp_if_expr$6 = threadinfo_p->try_n < ctx_p->retries ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$6)
      tmp_if_expr$7 = (signed int)ctx_p->state != STATE_TERM ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$7 = (_Bool)0;
    if(tmp_if_expr$7)
      tmp_if_expr$8 = (signed int)ctx_p->state != STATE_EXIT ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$8 = (_Bool)0;
    try_again = (signed int)tmp_if_expr$8;
    _warning("so_call_sync_thread", "Bad exitcode %i (errcode %i). %s.", rc, err, try_again != 0 ? "Retrying" : "Give up");
    if(!(try_again == 0))
    {
      _debug(2, "so_call_sync_thread", "Sleeping for %u seconds before the retry.", ctx_p->syncdelay);
      sleep(ctx_p->syncdelay);
    }

  }

  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  if(!(err == 0))
  {
    if(ctx_p->retries == 0)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = threadinfo_p->try_n < ctx_p->retries ? (_Bool)1 : (_Bool)0;
    tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$3 = (_Bool)0;
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$3)
    tmp_if_expr$4 = (signed int)ctx_p->state != STATE_TERM ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$4 = (_Bool)0;
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$4)
    tmp_if_expr$5 = (signed int)ctx_p->state != STATE_EXIT ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$5 = (_Bool)0;
  if(!(err == 0))
  {
    if(ctx_p->flags[529l] == 0)
    {
      _error("so_call_sync_thread", "Bad exitcode %i (errcode %i)", rc, err);
      threadinfo_p->errcode = err;
    }

  }

  so_call_sync_finished(n, ei);
  err=thread_exit(threadinfo_p, rc);
  if(!(err == 0))
  {
    exitcode = err;
    pthread_kill(pthread_sighandler, 15);
  }

  return rc;
}

// socket_accept
// file socket.c line 183
extern struct clsyncsock * socket_accept(signed int sock)
{
  socket_gc();
  signed int clsyncsock_sock;
  clsyncsock_sock=accept(sock, (void *)0, (unsigned int *)(void *)0);
  if(clsyncsock_sock == -1)
  {
    _error("socket_accept", "socket_accept(%i): Cannot accept()", sock);
    return (struct clsyncsock *)(void *)0;
  }

  else
  {
    struct clsyncsock *return_value_socket_new$1;
    return_value_socket_new$1=socket_new(clsyncsock_sock);
    return return_value_socket_new$1;
  }
}

// socket_check
// file socket.c line 122
static inline signed int socket_check(struct clsyncsock *clsyncsock_p)
{
  signed int return_value_socket_check_bysock$1;
  return_value_socket_check_bysock$1=socket_check_bysock(clsyncsock_p->sock);
  return return_value_socket_check_bysock$1;
}

// socket_check_bysock
// file socket.c line 106
extern signed int socket_check_bysock(signed int sock)
{
  signed int error_code;
  signed int ret;
  unsigned int error_code_len = (unsigned int)sizeof(signed int) /*4ul*/ ;
  ret=getsockopt(sock, 1, 4, (void *)&error_code, &error_code_len);
  if(!(ret == 0))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    return *return_value___errno_location$1;
  }

  if(!(error_code == 0))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = error_code;
    return error_code;
  }

  return 0;
}

// socket_cleanup
// file socket.c line 139
extern signed int socket_cleanup(struct clsyncsock *clsyncsock_p)
{
  signed int clsyncsock_sock = clsyncsock_p->sock;
  _debug(2, "socket_cleanup", "sock == %i.", clsyncsock_sock);
  recv_ptrs[(signed long int)clsyncsock_sock] = (char *)(void *)0;
  recv_stps[(signed long int)clsyncsock_sock] = (char *)(void *)0;
  free((void *)clsyncsock_p);
  return 0;
}

// socket_close
// file socket.c line 152
extern signed int socket_close(struct clsyncsock *clsyncsock_p)
{
  close(clsyncsock_p->sock);
  signed int return_value_socket_cleanup$1;
  return_value_socket_cleanup$1=socket_cleanup(clsyncsock_p);
  return return_value_socket_cleanup$1;
}

// socket_deinit
// file socket.c line 807
extern signed int socket_deinit()
{
  return 0;
}

// socket_gc
// file socket.c line 49
signed int socket_gc()
{
  signed int i = clsyncsockthreads_last + 1;
  while(!(i == 0))
  {
    i = i - 1;
    if((signed int)sockthreaddata[(signed long int)i].state == CLSTATE_DIED)
    {
      _debug(3, "socket_gc", "Forgeting clsyncsock #%u", i);
      pthread_join(sockthreaddata[(signed long int)i].thread, (void **)(void *)0);
      sockthreaddata[(signed long int)i].state = (enum clsyncsock_state)CLSTATE_NONE;
    }

  }
  return 0;
}

// socket_init
// file socket.c line 803
extern signed int socket_init()
{
  return 0;
}

// socket_listen_unix
// file socket.c line 197
extern struct clsyncsock * socket_listen_unix(const char * const socket_path)
{
  signed int s;
  s=socket(1, 1, 0);
  signed int return_value_access$2;
  return_value_access$2=access(socket_path, 0);
  signed int return_value_unlink$1;
  if(return_value_access$2 == 0)
  {
    return_value_unlink$1=unlink(socket_path);
    if(return_value_unlink$1 == 0)
      goto __CPROVER_DUMP_L1;

    _error("socket_listen_unix", "Cannot unlink() \"%s\".", socket_path);
    close(s);
    return (struct clsyncsock *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    struct sockaddr_un addr;
    memset((void *)&addr, 0, sizeof(struct sockaddr_un) /*110ul*/ );
    addr.sun_family = (unsigned short int)1;
    strncpy(addr.sun_path, socket_path, sizeof(char [108l]) /*108ul*/  - (unsigned long int)1);
    signed int return_value_bind$3;
    return_value_bind$3=bind(s, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ );
    if(!(return_value_bind$3 == 0))
    {
      _error("socket_listen_unix", "Cannot bind() on address \"%s\".", socket_path);
      close(s);
      return (struct clsyncsock *)(void *)0;
    }

    else
    {
      signed int return_value_listen$4;
      return_value_listen$4=listen(s, 2);
      if(!(return_value_listen$4 == 0))
      {
        _error("socket_listen_unix", "Cannot listen() on address \"%s\".", socket_path);
        close(s);
        return (struct clsyncsock *)(void *)0;
      }

      else
      {
        struct clsyncsock *return_value_socket_new$5;
        return_value_socket_new$5=socket_new(s);
        return return_value_socket_new$5;
      }
    }
  }
}

// socket_new
// file socket.c line 126
struct clsyncsock * socket_new(signed int clsyncsock_sock)
{
  struct clsyncsock *clsyncsock_p;
  void *return_value_xmalloc$1;
  return_value_xmalloc$1=xmalloc(sizeof(struct clsyncsock) /*14392ul*/ );
  clsyncsock_p = (struct clsyncsock *)return_value_xmalloc$1;
  _debug(2, "socket_new", "sock == %i.", clsyncsock_sock);
  clsyncsock_p->sock = clsyncsock_sock;
  clsyncsock_p->prot = (unsigned short int)0;
  clsyncsock_p->subprot = (unsigned short int)0;
  return clsyncsock_p;
}

// socket_overflow_fix
// file socket.c line 386
static inline signed int socket_overflow_fix(char *buf, char **data_start_p, char **data_end_p)
{
  _debug(3, "socket_overflow_fix", "buf==%p; data_start==%p; data_end==%p", buf, *data_start_p, *data_end_p);
  if(buf == *data_start_p)
    return 0;

  else
  {
    unsigned long int ptr_diff = (unsigned long int)(*data_start_p - buf);
    if(!(*data_start_p == *data_end_p))
    {
      *data_start_p = buf;
      *data_end_p = buf;
      return (signed int)ptr_diff;
    }

    else
    {
      unsigned long int data_length = (unsigned long int)(*data_end_p - *data_start_p);
      memmove((void *)buf, (const void *)*data_start_p, data_length);
      *data_start_p = buf;
      *data_end_p = &buf[(signed long int)data_length];
      return (signed int)ptr_diff;
    }
  }
}

// socket_procclsyncsock
// file socket.c line 616
extern signed int socket_procclsyncsock(struct socket_sockthreaddata *arg)
{
  char _sockcmd_buf[4096l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  struct sockcmd *sockcmd_p = (struct sockcmd *)_sockcmd_buf;
  struct clsyncsock *clsyncsock_p = arg->clsyncsock_p;
  signed int (*procfunct)(struct socket_sockthreaddata *, struct sockcmd *) = arg->procfunct;
  /* socket_procclsyncsock::1::tag-auth_flags */
enum auth_flags { AUTHFLAG_ENTERED_LOGIN=1 };

/* */
  ;
  enum auth_flags auth_flags = (enum auth_flags)0;
  _debug(3, "socket_procclsyncsock", "Started new thread for new connection.");
  arg->state = (enum clsyncsock_state)((signed int)arg->authtype == SOCKAUTH_NULL ? CLSTATE_MAIN : CLSTATE_AUTH);
  socket_send(clsyncsock_p, (enum sockcmd_id)SOCKCMD_REQUEST_NEGOTIATION, clsyncsock_p->prot, clsyncsock_p->subprot);
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  if(!(arg->running == ((signed int *)NULL)))
  {
    if(!(*arg->running == 0))
    {
      if(!((signed int)arg->state == CLSTATE_AUTH))
      {
        if((signed int)arg->state == CLSTATE_MAIN)
          goto __CPROVER_DUMP_L3;

      }

      else
      {

      __CPROVER_DUMP_L3:
        ;
        _debug(3, "socket_procclsyncsock", "Iteration.");
        signed int ret;
        ret=socket_recv(clsyncsock_p, sockcmd_p);
        if(!(ret == 0))
          _debug(2, "socket_procclsyncsock", "Got error while receiving a message from clsyncsock with sock %u. Ending the thread.", arg->clsyncsock_p->sock);

        else
        {
          unsigned long int cmd_num = sockcmd_p->cmd_num;
          signed int i = (signed int)(cmd_num % (unsigned long int)(2 * (1 << 8)));
          for( ; !(clsyncsock_p->cbqueue_cache[(signed long int)i] == ((struct clsynccbqueue *)NULL)); i = i + 1)
            if(clsyncsock_p->cbqueue_cache[(signed long int)i]->cmd_num == cmd_num)
            {
              struct clsynccbqueue *cbq = clsyncsock_p->cbqueue_cache[(signed long int)i];
              cbq->callback_funct(arg, sockcmd_p, cbq->callback_arg);
              clsyncsock_p->cbqueue_len = clsyncsock_p->cbqueue_len - 1ul;
              memcpy((void *)cbq, (const void *)&clsyncsock_p->cbqueue[(signed long int)clsyncsock_p->cbqueue_len], sizeof(struct clsynccbqueue) /*24ul*/ );
              clsyncsock_p->cbqueue_cache[(signed long int)i] = (struct clsynccbqueue *)(void *)0;
            }

          signed int return_value;
          return_value=procfunct(arg, sockcmd_p);
          if(!(return_value == 0))
          {
            if((signed int)sockcmd_p->cmd_id == SOCKCMD_REQUEST_NEGOTIATION || (signed int)sockcmd_p->cmd_id == SOCKCMD_REPLY_NEGOTIATION)
            {
              struct sockcmd_dat_negotiation *data = (struct sockcmd_dat_negotiation *)sockcmd_p->data;
              if((signed int)data->prot == 0)
              {
                if((signed int)data->subprot == 0 || (signed int)data->subprot == 1)
                {
                  clsyncsock_p->subprot = data->subprot;
                  if((signed int)sockcmd_p->cmd_id == SOCKCMD_REQUEST_NEGOTIATION)
                    socket_reply(clsyncsock_p, sockcmd_p, (enum sockcmd_id)SOCKCMD_REPLY_NEGOTIATION, data->prot, data->subprot);

                  else
                  {
                    socket_reply(clsyncsock_p, sockcmd_p, (enum sockcmd_id)SOCKCMD_REPLY_ACK, sockcmd_p->cmd_id, sockcmd_p->cmd_num);
                    _debug(1, "socket_procclsyncsock", "Negotiated proto: %u %u", data->prot, data->subprot);
                  }
                }

                socket_reply(clsyncsock_p, sockcmd_p, (enum sockcmd_id)SOCKCMD_REPLY_EINVAL, sockcmd_p->cmd_id, sockcmd_p->cmd_num, (const void *)"Incorrect subprotocol id");
              }

              socket_reply(clsyncsock_p, sockcmd_p, (enum sockcmd_id)SOCKCMD_REPLY_EINVAL, sockcmd_p->cmd_id, sockcmd_p->cmd_num, (const void *)"Incorrect protocol id");
              socket_reply(clsyncsock_p, sockcmd_p, (enum sockcmd_id)SOCKCMD_REPLY_VERSION, 0, 1, (const void *)"-release");
              socket_reply(clsyncsock_p, sockcmd_p, (enum sockcmd_id)SOCKCMD_REPLY_BYE);
              arg->state = (enum clsyncsock_state)CLSTATE_DYING;
            }

            socket_sendinvalid(clsyncsock_p, sockcmd_p);
          }

          if(!(sockcmd_p->data == NULL))
          {
            free(sockcmd_p->data);
            sockcmd_p->data = (void *)0;
          }

          signed int return_value_socket_check$3;
          return_value_socket_check$3=socket_check(clsyncsock_p);
          if(!(return_value_socket_check$3 == 0))
          {
            return_value___errno_location$1=__errno_location();
            return_value_strerror$2=strerror(*return_value___errno_location$1);
            _debug(1, "socket_procclsyncsock", "clsyncsock socket error: %s", return_value_strerror$2);
          }

          else
            if((signed int)arg->state == CLSTATE_AUTH)
            {
              if((AUTHFLAG_ENTERED_LOGIN & (signed int)auth_flags) == 0)
                socket_send(clsyncsock_p, (enum sockcmd_id)SOCKCMD_REQUEST_LOGIN);

            }

        }
      }
    }

  }

  _debug(3, "socket_procclsyncsock", "Ending a connection thread.");
  socket_thread_delete(arg);
  return 0;
}

// socket_recv
// file socket.c line 485
extern signed int socket_recv(struct clsyncsock *clsyncsock, struct sockcmd *sockcmd_p)
{
  char *buf;
  char *ptr;
  char *start;
  char *end;
  signed int clsyncsock_sock;
  unsigned long int filled_length;
  unsigned long int rest_length;
  unsigned long int recv_length;
  unsigned long int filled_length_new;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  clsyncsock_sock = clsyncsock->sock;
  static char bufs[8l][4096l];
  buf = bufs[(signed long int)clsyncsock_sock];
  start = recv_stps[(signed long int)clsyncsock_sock];
  start = start == (char *)(void *)0 ? buf : start;
  ptr = recv_ptrs[(signed long int)clsyncsock_sock];
  ptr = ptr == (char *)(void *)0 ? buf : ptr;
  _debug(3, "socket_recv", "buf==%p; start==%p; ptr==%p", buf, start, ptr);
  signed int *return_value___errno_location$4;
  while((_Bool)1)
  {
    filled_length = (unsigned long int)(ptr - buf);
    rest_length = ((unsigned long int)(1 << 12) - filled_length) - (unsigned long int)16;
    if(!(rest_length >= 1ul))
    {
      signed int return_value_socket_overflow_fix$2;
      return_value_socket_overflow_fix$2=socket_overflow_fix(buf, &start, &ptr);
      if(return_value_socket_overflow_fix$2 == 0)
      {
        _debug(1, "socket_recv", "Got too big message. Ignoring.");
        ptr = buf;
      }

      continue;
    }

    signed long int return_value_recv$3;
    return_value_recv$3=recv(clsyncsock_sock, (void *)ptr, rest_length, 0);
    recv_length = (unsigned long int)return_value_recv$3;
    filled_length_new = filled_length + recv_length;
    _debug(5, "socket_recv", "recv_length == %u; filled_length_new == %u", recv_length, filled_length_new);
    if(recv_length == 0ul)
      return 104;

    if((signed int)clsyncsock->prot == 0)
    {
      unsigned short int cmd_id_binary = *((unsigned short int *)buf);
      clsyncsock->subprot = (unsigned short int)((signed int)cmd_id_binary == SOCKCMD_REQUEST_NEGOTIATION || (signed int)cmd_id_binary == SOCKCMD_REPLY_NEGOTIATION ? 1 : 0);
      if((signed int)clsyncsock->subprot == 0)
      {
        end=strchr(ptr, 10);
        if(!(end == ((char *)NULL)))
        {
          signed int return_value_sscanf$6;
          return_value_sscanf$6=sscanf(start, "%lu %u", &sockcmd_p->cmd_num, (unsigned int *)&sockcmd_p->cmd_id);
          if(!(return_value_sscanf$6 == 2))
          {
            *end = (char)0;
            _error("socket_recv", "It's expected to parse \"%%lu %%u\" from \"%s\"", start);
            *end = (char)10;
            signed int *return_value___errno_location$5;
            return_value___errno_location$5=__errno_location();
            *return_value___errno_location$5 = 42;
            return *return_value___errno_location$5;
          }

          char *str_args = start;
          for( ; (signed int)*str_args >= 48; str_args = str_args + 1l)
            if((signed int)*str_args >= 58)
              break;

          str_args = str_args + 1l;
          for( ; (signed int)*str_args >= 48; str_args = str_args + 1l)
            if((signed int)*str_args >= 58)
              break;

          str_args = str_args + 1l;
          if(!(str_args >= end))
            parse_text_data(sockcmd_p, str_args, (unsigned long int)(end - str_args));

          break;
        }

        goto __CPROVER_DUMP_L18;
      }

      signed int *return_value___errno_location$7;
      return_value___errno_location$7=__errno_location();
      *return_value___errno_location$7 = 92;
      return *return_value___errno_location$7;

    __CPROVER_DUMP_L18:
      ;
      goto __CPROVER_DUMP_L20;
    }

    signed int *return_value___errno_location$8;
    return_value___errno_location$8=__errno_location();
    *return_value___errno_location$8 = 92;
    return *return_value___errno_location$8;

  __CPROVER_DUMP_L20:
    ;
  }

l_socket_recv_end:
  ;
  start = &end[(signed long int)1];
  ptr = &buf[(signed long int)filled_length_new];
  if(start == ptr)
  {
    start = buf;
    ptr = buf;
  }

  recv_stps[(signed long int)clsyncsock_sock] = start;
  recv_ptrs[(signed long int)clsyncsock_sock] = ptr;
  _debug(3, "socket_recv", "sockcmd_p->cmd_num == %lu; sockcmd_p->cmd_id == %i; buf==%p; ptr==%p; end==%p, filled=%p, buf_end==%p", sockcmd_p->cmd_num, sockcmd_p->cmd_id, buf, ptr, end, &buf[(signed long int)filled_length_new], &buf[(signed long int)(1 << 12)]);
  return 0;
}

// socket_reply
// file socket.c line 326
extern signed int socket_reply(struct clsyncsock *clsyncsock_p, struct sockcmd *sockcmd_p, enum sockcmd_id cmd_id, ...)
{
  void **ap;
  signed int ret;
  unsigned long int cmd_num = sockcmd_p->cmd_num;
  ap = (void **)&cmd_id;
  ret=_socket_send(clsyncsock_p, &cmd_num, cmd_id, ap);
  ap = ((void **)NULL);
  return ret;
}

// socket_send
// file socket.c line 338
extern signed int socket_send(struct clsyncsock *clsyncsock_p, enum sockcmd_id cmd_id, ...)
{
  void **ap;
  signed int ret;
  ap = (void **)&cmd_id;
  ret=_socket_send(clsyncsock_p, &clsyncsock_p->cmd_num, cmd_id, ap);
  ap = ((void **)NULL);
  return ret;
}

// socket_send_cb
// file socket.c line 349
extern signed int socket_send_cb(struct clsyncsock *clsyncsock_p, enum sockcmd_id cmd_id, signed int (*cb)(struct socket_sockthreaddata *, struct sockcmd *, void *), void *cb_arg, ...)
{
  if(clsyncsock_p->cbqueue_len >= 256ul)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 75;
    _error("socket_send_cb", "Callback queue overflowed. Closing the socket.");
    socket_close(clsyncsock_p);
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    return *return_value___errno_location$2;
  }

  void **ap;
  signed int ret;
  unsigned long int cmd_num = clsyncsock_p->cmd_num;
  ap = (void **)&cb_arg;
  ret=_socket_send(clsyncsock_p, &clsyncsock_p->cmd_num, cmd_id, ap);
  ap = ((void **)NULL);
  if(ret == 0)
  {
    struct clsynccbqueue *cbq = &clsyncsock_p->cbqueue[(signed long int)clsyncsock_p->cbqueue_len];
    signed int id;
    cbq->cmd_num = cmd_num;
    cbq->callback_funct = cb;
    cbq->callback_arg = cb_arg;
    id = (signed int)(cmd_num % (unsigned long int)(2 * (1 << 8)));
    for( ; !(clsyncsock_p->cbqueue_cache[(signed long int)id] == ((struct clsynccbqueue *)NULL)); id = id + 1)
      ;
    clsyncsock_p->cbqueue_cache[(signed long int)id] = cbq;
    clsyncsock_p->cbqueue_len = clsyncsock_p->cbqueue_len + 1ul;
  }

  return ret;
}

// socket_sendinvalid
// file socket.c line 609
extern signed int socket_sendinvalid(struct clsyncsock *clsyncsock_p, struct sockcmd *sockcmd_p)
{
  signed int return_value_socket_reply$1;
  signed int return_value_socket_reply$2;
  if((signed int)sockcmd_p->cmd_id >= 1000)
  {
    return_value_socket_reply$1=socket_reply(clsyncsock_p, sockcmd_p, (enum sockcmd_id)SOCKCMD_REPLY_INVALIDCMDID, sockcmd_p->cmd_num);
    return return_value_socket_reply$1;
  }

  else
  {
    return_value_socket_reply$2=socket_reply(clsyncsock_p, sockcmd_p, (enum sockcmd_id)SOCKCMD_REPLY_UNKNOWNCMD, sockcmd_p->cmd_id, sockcmd_p->cmd_num);
    return return_value_socket_reply$2;
  }
}

// socket_thread_attach
// file socket.c line 782
extern struct socket_sockthreaddata * socket_thread_attach(struct clsyncsock *clsyncsock_p)
{
  struct socket_sockthreaddata *threaddata_p;
  threaddata_p=socket_thread_new();
  if(threaddata_p == ((struct socket_sockthreaddata *)NULL))
    return (struct socket_sockthreaddata *)(void *)0;

  else
  {
    threaddata_p->clsyncsock_p = clsyncsock_p;
    return threaddata_p;
  }
}

// socket_thread_delete
// file socket.c line 158
signed int socket_thread_delete(struct socket_sockthreaddata *threaddata_p)
{
  signed int thread_id;
  pthread_mutex_lock(&socket_thread_mutex);
  thread_id = threaddata_p->id;
  socket_close(threaddata_p->clsyncsock_p);
  clsyncsockthreads_count = clsyncsockthreads_count - 1;
  if(clsyncsockthreads_last == thread_id)
    clsyncsockthreads_last = thread_id - 1;

  clsyncsockthread_busy[(signed long int)thread_id] = (char)0;
  threaddata_p->state = (enum clsyncsock_state)CLSTATE_DIED;
  if(!(threaddata_p->freefunct_arg == ((void (*)(void *))NULL)))
    threaddata_p->freefunct_arg(threaddata_p->arg);

  pthread_mutex_unlock(&socket_thread_mutex);
  return 0;
}

// socket_thread_new
// file socket.c line 741
struct socket_sockthreaddata * socket_thread_new()
{
  pthread_mutex_lock(&socket_thread_mutex);
  struct socket_sockthreaddata *threaddata_p = &sockthreaddata[(signed long int)clsyncsockthreads_num];
  if(clsyncsockthreads_num >= 8)
  {
    _error("socket_thread_new", "Warning: socket_thread_new(): Too many connection threads.");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 87;
    pthread_mutex_unlock(&socket_thread_mutex);
    return (struct socket_sockthreaddata *)(void *)0;
  }

  threaddata_p->id = clsyncsockthreads_num;
  clsyncsockthread_busy[(signed long int)clsyncsockthreads_num] = (char)1;
  do
  {
    clsyncsockthreads_num = clsyncsockthreads_num + 1;
    if(clsyncsockthread_busy[(signed long int)clsyncsockthreads_num] == 0)
      break;

  }
  while((_Bool)1);
  if(!((signed int)threaddata_p->state == CLSTATE_NONE))
  {
    _error("socket_thread_new", "Internal-Error: socket_newconnarg(): connproc_arg->state != CLSTATE_NONE");
    pthread_mutex_unlock(&socket_thread_mutex);
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 84;
    return (struct socket_sockthreaddata *)(void *)0;
  }

  _debug(3, "socket_thread_new", "clsyncsockthreads_count == %u;\tclsyncsockthreads_last == %u;\tclsyncsockthreads_num == %u", clsyncsockthreads_count, clsyncsockthreads_last, clsyncsockthreads_num);
  clsyncsockthreads_last = clsyncsockthreads_last > clsyncsockthreads_num ? clsyncsockthreads_last : clsyncsockthreads_num;
  clsyncsockthreads_count = clsyncsockthreads_count + 1;
  pthread_mutex_unlock(&socket_thread_mutex);
  return threaddata_p;
}

// socket_thread_start
// file socket.c line 794
extern signed int socket_thread_start(struct socket_sockthreaddata *threaddata_p)
{
  signed int return_value_pthread_create$2;
  return_value_pthread_create$2=pthread_create(&threaddata_p->thread, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))socket_procclsyncsock, (void *)threaddata_p);
  if(!(return_value_pthread_create$2 == 0))
  {
    _error("socket_thread_start", "Cannot create a thread for connection");
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    return *return_value___errno_location$1;
  }

  return 0;
}

// stat_diff
// file fileutils.c line 209
unsigned int stat_diff(struct stat64 *a, struct stat64 *b)
{
  unsigned int difference;
  if(a == ((struct stat64 *)NULL))
    _critical("stat_diff", "Assert: a == ((void *)0)");

  if(b == ((struct stat64 *)NULL))
    _critical("stat_diff", "Assert: b == ((void *)0)");

  difference = (unsigned int)0x0000;
  if(!(a->st_dev == b->st_dev))
    difference = difference | (unsigned int)1;

  if(!(a->st_ino == b->st_ino))
    difference = difference | (unsigned int)2;

  if(!(a->st_mode == b->st_mode))
    difference = difference | (unsigned int)4;

  if(!(a->st_nlink == b->st_nlink))
    difference = difference | (unsigned int)8;

  if(!(a->st_uid == b->st_uid))
    difference = difference | (unsigned int)16;

  if(!(a->st_gid == b->st_gid))
    difference = difference | (unsigned int)32;

  if(!(a->st_rdev == b->st_rdev))
    difference = difference | (unsigned int)64;

  if(!(a->st_size == b->st_size))
    difference = difference | (unsigned int)128;

  if(!(a->st_blksize == b->st_blksize))
    difference = difference | (unsigned int)256;

  if(!(a->st_blocks == b->st_blocks))
    difference = difference | (unsigned int)512;

  if(!(a->st_atim.tv_sec == b->st_atim.tv_sec))
    difference = difference | (unsigned int)1024;

  if(!(a->st_mtim.tv_sec == b->st_mtim.tv_sec))
    difference = difference | (unsigned int)2048;

  if(!(a->st_ctim.tv_sec == b->st_ctim.tv_sec))
    difference = difference | (unsigned int)4096;

  return difference;
}

// str_splitargs
// file stringex.c line 72
signed int str_splitargs(char *_instr, signed int (*handler)(char *, unsigned long int, void *), void *arg)
{
  char *arg_start;
  char *ptr;
  char *instr;
  signed int quotes = 0;
  instr=strdup(_instr);
  ptr = instr;
  arg_start = instr;
  char *tmp_post$1;
  signed int str_splitargs$$1$$2$$1$$1$$rc;
  while((_Bool)1)
  {
    ptr=strpbrk(ptr, " \t\"'");
    if(ptr == ((char *)NULL))
      break;

    tmp_post$1 = ptr;
    ptr = ptr + 1l;
    switch((signed int)*tmp_post$1)
    {
      case 32:

      case 9:
      {
        str_splitargs$$1$$2$$1$$1$$rc=_str_splitargs(&ptr[(signed long int)-1], &arg_start, quotes, handler, (char *)arg);
        if(!(str_splitargs$$1$$2$$1$$1$$rc == 0))
          return str_splitargs$$1$$2$$1$$1$$rc;

        quotes = 0;
        break;
      }
      case 34:
      {
        ptr[(signed long int)-1] = (char)0;
        quotes = quotes + 1;
        do
        {
          ptr=strchr(ptr, 34);
          if(ptr == ((char *)NULL))
            break;

          char *p = &ptr[(signed long int)-1];
          while((signed int)*p == 92)
          {
            p = p - 1l;
            if(!(p >= instr))
              _critical("str_splitargs", "Dangerous internal error");

          }
          if(!((ptr - p) % 2l == 0l))
            break;

        }
        while((_Bool)1);
        if(ptr == ((char *)NULL))
        {
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          *return_value___errno_location$2 = 22;
          _error("str_splitargs", "Unterminated quote <\"> in string: <%s>", instr);
          signed int *return_value___errno_location$3;
          return_value___errno_location$3=__errno_location();
          return *return_value___errno_location$3;
        }

        *ptr = (char)0;
        quotes = quotes + 1;
        ptr = ptr + 1l;
        break;
      }
      case 39:
      {
        ptr[(signed long int)-1] = (char)0;
        quotes = quotes + 1;
        ptr=strchr(ptr, 39);
        if(ptr == ((char *)NULL))
        {
          signed int *return_value___errno_location$4;
          return_value___errno_location$4=__errno_location();
          *return_value___errno_location$4 = 22;
          _error("str_splitargs", "Unterminated quote <'> in string: <%s>", instr);
          signed int *return_value___errno_location$5;
          return_value___errno_location$5=__errno_location();
          return *return_value___errno_location$5;
        }

        *ptr = (char)0;
        quotes = quotes + 1;
        ptr = ptr + 1l;
      }
    }
  }
  signed int rc;
  char *return_value_strchr$6;
  return_value_strchr$6=strchr(arg_start, 0);
  rc=_str_splitargs(return_value_strchr$6, &arg_start, quotes, handler, (char *)arg);
  free((void *)instr);
  return rc;
}

// sync_customargv
// file sync.c line 1475
static char ** sync_customargv(struct ctx *ctx_p, struct dosync_arg *dosync_arg_p, struct synchandler_args *args_p)
{
  signed int d;
  signed int s;
  char **sync_customargv$$1$$argv;
  void *return_value_xcalloc$1;
  return_value_xcalloc$1=xcalloc(sizeof(char *) /*8ul*/ , (unsigned long int)((1 << 8) + 2));
  sync_customargv$$1$$argv = (char **)return_value_xcalloc$1;
  d = 0;
  s = d;
  signed int tmp_post$2 = d;
  d = d + 1;
  sync_customargv$$1$$argv[(signed long int)tmp_post$2]=strdup(ctx_p->handlerfpath);
  signed int tmp_post$3;
  signed int tmp_post$5;
  signed int tmp_post$6;
  while(!(s >= args_p->c))
  {
    char *arg = args_p->v[(signed long int)s];
    char isexpanded = args_p->isexpanded[(signed long int)s];
    s = s + 1;
    if(!(isexpanded == 0))
    {
      tmp_post$3 = d;
      d = d + 1;
      sync_customargv$$1$$argv[(signed long int)tmp_post$3]=strdup(arg);
    }

    else
    {
      signed int return_value_strcmp$8;
      return_value_strcmp$8=strcmp(arg, "%INCLUDE-LIST%");
      if(return_value_strcmp$8 == 0)
      {
        signed int i = 0;
        signed int e = (signed int)dosync_arg_p->include_list_count;
        const char **include_list = dosync_arg_p->include_list;
        while(!(i >= e))
        {
          if(d >= 256)
          {
            signed int *return_value___errno_location$4;
            return_value___errno_location$4=__errno_location();
            *return_value___errno_location$4 = 7;
            _critical("sync_customargv", "Too many arguments");
          }

          tmp_post$5 = d;
          d = d + 1;
          tmp_post$6 = i;
          i = i + 1;
          char *return_value_strdup$7;
          return_value_strdup$7=strdup(include_list[(signed long int)tmp_post$6]);
          sync_customargv$$1$$argv[(signed long int)tmp_post$5]=parameter_expand(ctx_p, return_value_strdup$7, 0, (signed int *)(void *)0, (signed int *)(void *)0, sync_parameter_get, (void *)dosync_arg_p);
        }
        continue;
      }

      if(d >= 256)
      {
        signed int *return_value___errno_location$9;
        return_value___errno_location$9=__errno_location();
        *return_value___errno_location$9 = 7;
        _critical("sync_customargv", "Too many arguments");
      }

      char *return_value_strdup$10;
      return_value_strdup$10=strdup(arg);
      sync_customargv$$1$$argv[(signed long int)d]=parameter_expand(ctx_p, return_value_strdup$10, 0, (signed int *)(void *)0, (signed int *)(void *)0, sync_parameter_get, (void *)dosync_arg_p);
      d = d + 1;
    }
  }
  sync_customargv$$1$$argv[(signed long int)d] = (char *)(void *)0;
  return sync_customargv$$1$$argv;
}

// sync_dosync
// file sync.c line 1926
signed int sync_dosync(const char *fpath, unsigned int evmask, struct ctx *ctx_p, struct indexes *indexes_p)
{
  signed int ret;
  char *evmask_str;
  void *return_value_xmalloc$1;
  return_value_xmalloc$1=xmalloc((unsigned long int)(1 << 8));
  evmask_str = (char *)return_value_xmalloc$1;
  sprintf(evmask_str, "%u", evmask);
  ret=sync_dosync_exec(ctx_p, indexes_p, evmask_str, fpath);
  free((void *)evmask_str);
  return ret;
}

// sync_dosync_exec
// file sync.c line 1899
static inline signed int sync_dosync_exec(struct ctx *ctx_p, struct indexes *indexes_p, const char *evmask_str, const char *fpath)
{
  signed int rc;
  struct dosync_arg dosync_arg;
  dosync_arg.ctx_p = ctx_p;
  dosync_arg.include_list[0l] = fpath;
  dosync_arg.include_list_count = (unsigned long int)1;
  dosync_arg.list_type_str = "sync";
  dosync_arg.evmask_str = evmask_str;
  char **sync_dosync_exec$$1$$argv;
  sync_dosync_exec$$1$$argv=sync_customargv(ctx_p, &dosync_arg, &ctx_p->synchandler_args[(signed long int)SHARGS_PRIMARY]);
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  if(!(ctx_p->flags[112l] == PM_OFF))
  {
    if(!(ctx_p->flags[112l] == PM_SAFE))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = ctx_p->iteration_num != 0u ? (_Bool)1 : (_Bool)0;
    tmp_if_expr$2 = tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$2 = (_Bool)0;
  rc=(tmp_if_expr$2 ? sync_exec_argv_thread : sync_exec_argv)(ctx_p, indexes_p, (signed int (*)(struct ctx *, struct thread_callbackfunct_arg *))(void *)0, (struct thread_callbackfunct_arg *)(void *)0, sync_dosync_exec$$1$$argv);
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$3;
  if(!(ctx_p->flags[112l] == PM_OFF))
  {
    if(!(ctx_p->flags[112l] == PM_SAFE))
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = ctx_p->iteration_num != 0u ? (_Bool)1 : (_Bool)0;
    tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$4 = (_Bool)0;
  if(!tmp_if_expr$4)
    argv_free(sync_dosync_exec$$1$$argv);

  return rc;
}

// sync_dump
// file sync.c line 3524
extern signed int sync_dump(struct ctx *ctx_p, const char * const dir_path)
{
  struct indexes *indexes_p = (struct indexes *)ctx_p->indexes_p;
  signed int rootfd;
  signed int fd_out;
  struct sync_dump_arg arg = { .ctx_p=((struct ctx *)NULL), .dirfd={ 0, 0, 0 }, .fd_out=0,
    .data=0 };
  enum dump_dirfd_obj dirfd_obj;
  arg.ctx_p = ctx_p;
  _debug(3, "sync_dump", "%s", dir_path);
  char *return_value_getenv$2;
  signed int queue_id;
  if(dir_path == ((const char *)NULL))
    return 22;

  else
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 0;
    rootfd=mkdirat_open(dir_path, -100, (unsigned int)0750);
    if(rootfd == -1)
      _error("sync_dump", "Cannot open directory \"%s\"", dir_path);

    else
    {
      fd_out=openat(rootfd, "instance", 01 | 0100, 0644);
      if(fd_out == -1)
        _error("sync_dump", "Cannot open file \"%s\" for writing");

      else
      {
        return_value_getenv$2=getenv("CLSYNC_STATUS");
        dprintf(fd_out, "status == %s\n", return_value_getenv$2);
        arg.fd_out = fd_out;
        arg.data = 2;
        if(!(indexes_p->nonthreaded_syncing_fpath2ei_ht == ((struct _GHashTable *)NULL)))
          g_hash_table_foreach(indexes_p->nonthreaded_syncing_fpath2ei_ht, sync_dump_liststep, (void *)&arg);

        close(fd_out);
        arg.dirfd[(signed long int)DUMP_DIRFD_ROOT] = rootfd;
        dirfd_obj = (enum dump_dirfd_obj)(DUMP_DIRFD_ROOT + 1);
        while(!((signed int)dirfd_obj >= DUMP_DIRFD_MAX))
        {
          static const char * const subdirs[3l] = { ((const char *)NULL), "queue", "threads" };
          const char * const subdir = subdirs[(signed long int)dirfd_obj];
          arg.dirfd[(signed long int)dirfd_obj]=mkdirat_open(subdir, rootfd, (unsigned int)0750);
          if(arg.dirfd[(signed long int)dirfd_obj] == -1)
          {
            _error("sync_dump", "Cannot open directory \"%s\"", subdir);
            goto l_sync_dump_end;
          }

          dirfd_obj = (enum dump_dirfd_obj)((signed int)dirfd_obj + 1);
        }
        queue_id = 0;
        while(!(queue_id >= QUEUE_MAX))
        {
          char buf[8192l];
          snprintf(buf, (unsigned long int)8192, "%u", queue_id);
          arg.fd_out=openat(arg.dirfd[(signed long int)DUMP_DIRFD_QUEUE], buf, 01 | 0100, 0644);
          arg.data = 2;
          g_hash_table_foreach(indexes_p->fpath2ei_coll_ht[(signed long int)queue_id], sync_dump_liststep, (void *)&arg);
          if(!(indexes_p->exc_fpath_coll_ht[(signed long int)queue_id] == ((struct _GHashTable *)NULL)))
          {
            arg.data = 1;
            g_hash_table_foreach(indexes_p->exc_fpath_coll_ht[(signed long int)queue_id], sync_dump_liststep, (void *)&arg);
          }

          close(arg.fd_out);
          queue_id = queue_id + 1;
        }
        threads_foreach(sync_dump_thread, (enum state_enum)STATE_RUNNING, (void *)&arg);
      }
    }

  l_sync_dump_end:
    ;
    dirfd_obj = (enum dump_dirfd_obj)DUMP_DIRFD_ROOT;
    for( ; !((signed int)dirfd_obj >= DUMP_DIRFD_MAX); dirfd_obj = (enum dump_dirfd_obj)((signed int)dirfd_obj + 1))
      if(!(arg.dirfd[(signed long int)dirfd_obj] == -1))
      {
        if(!(arg.dirfd[(signed long int)dirfd_obj] == 0))
          close(arg.dirfd[(signed long int)dirfd_obj]);

      }

    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    if(!(*return_value___errno_location$3 == 0))
      _error("sync_dump", "Cannot create the dump to \"%s\"", dir_path);

    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    return *return_value___errno_location$4;
  }
}

// sync_dump_liststep
// file sync.c line 3452
void sync_dump_liststep(void *fpath_gp, void *evinfo_gp, void *arg_gp)
{
  char *fpath = (char *)fpath_gp;
  struct eventinfo *evinfo = (struct eventinfo *)evinfo_gp;
  struct sync_dump_arg *arg = (struct sync_dump_arg *)arg_gp;
  char act;
  char num;
  signed int tmp_if_expr$1;
  if(!(fpath == ((char *)NULL)) && !(evinfo == ((struct eventinfo *)NULL)))
  {
    switch(arg->data)
    {
      case 0:
      {
        act = (char)43;
        num = (char)49;
        break;
      }
      case 1:
      {
        act = (char)45;
        num = (char)49;
        break;
      }
      case 2:
      {
        act = (char)43;
        if(!((1u & evinfo->flags) == 0u))
          tmp_if_expr$1 = 42;

        else
          tmp_if_expr$1 = (evinfo->flags & (unsigned int)EVIF_CONTENTRECURSIVELY) != 0u ? 47 : 49;
        num = (char)tmp_if_expr$1;
        break;
      }
      default:
      {
        act = (char)63;
        num = (char)63;
      }
    }
    dprintf(arg->fd_out, "%c%c\t%s\n", act, num, fpath);
    goto __CPROVER_DUMP_L9;
  }


__CPROVER_DUMP_L9:
  ;
}

// sync_dump_thread
// file sync.c line 3485
signed int sync_dump_thread(struct threadinfo *threadinfo_p, void *_arg)
{
  struct sync_dump_arg *arg = (struct sync_dump_arg *)_arg;
  char buf[8192l];
  snprintf(buf, (unsigned long int)8192, "%u-%u-%lx", threadinfo_p->iteration, threadinfo_p->thread_num, (signed long int)threadinfo_p->pthread);
  arg->fd_out=openat(arg->dirfd[(signed long int)DUMP_DIRFD_THREAD], buf, 01 | 0100, 0644);
  signed int *return_value___errno_location$1;
  char **tmp_post$2;
  if(arg->fd_out == -1)
  {
    return_value___errno_location$1=__errno_location();
    return *return_value___errno_location$1;
  }

  else
  {
    char **sync_dump_thread$$1$$1$$argv;
    dprintf(arg->fd_out, "thread:\n\titeration == %u\n\tnum == %u\n\tpthread == %lx\n\tstarttime == %lu\n\texpiretime == %lu\n\tchild_pid == %u\n\ttry_n == %u\nCommand:", threadinfo_p->iteration, threadinfo_p->thread_num, (signed long int)threadinfo_p->pthread, threadinfo_p->starttime, threadinfo_p->expiretime, threadinfo_p->child_pid, threadinfo_p->try_n);
    sync_dump_thread$$1$$1$$argv = threadinfo_p->argv;
    while(!(*sync_dump_thread$$1$$1$$argv == ((char *)NULL)))
    {
      tmp_post$2 = sync_dump_thread$$1$$1$$argv;
      sync_dump_thread$$1$$1$$argv = sync_dump_thread$$1$$1$$argv + 1l;
      dprintf(arg->fd_out, " \"%s\"", *tmp_post$2);
    }
    dprintf(arg->fd_out, "\n");
    arg->data = 2;
    g_hash_table_foreach(threadinfo_p->fpath2ei_ht, sync_dump_liststep, (void *)arg);
    close(arg->fd_out);
    return 0;
  }
}

// sync_exec_argv
// file sync.c line 1011
signed int sync_exec_argv(struct ctx *ctx_p, struct indexes *indexes_p, signed int (*callback)(struct ctx *, struct thread_callbackfunct_arg *), struct thread_callbackfunct_arg *callback_arg_p, char **argv)
{
  _debug(2, "sync_exec_argv", "");
  if(ctx_p->flags[100l] >= 2)
    argv_dump(2, argv);

  indexes_p->nonthreaded_syncing_fpath2ei_ht = indexes_p->fpath2ei_ht;
  signed int sync_exec_argv$$1$$exitcode = 0;
  signed int ret = 0;
  signed int err = 0;
  signed int try_n = 0;
  signed int try_again;
  enum state_enum status = (enum state_enum)STATE_UNKNOWN;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  do
  {
    try_again = 0;
    try_n = try_n + 1;
    _debug(2, "sync_exec_argv", "try_n == %u (retries == %u)", try_n, ctx_p->retries);
    alarm(ctx_p->synctimeout);
    ctx_p->children = 1;
    sync_exec_argv$$1$$exitcode=exec_argv(argv, ctx_p->child_pid);
    ctx_p->children = 0;
    alarm((unsigned int)0);
    err=exitcode_process(ctx_p, sync_exec_argv$$1$$exitcode);
    if(!(err == 0))
    {
      if(try_n == 1)
      {
        if(!((signed int)ctx_p->state == STATE_TERM))
        {
          if(!((signed int)ctx_p->state == STATE_EXIT))
          {
            status = ctx_p->state;
            ctx_p->state = (volatile enum state_enum)STATE_SYNCHANDLER_ERR;
            main_status_update(ctx_p);
          }

        }

      }

      if(ctx_p->retries == 0)
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = try_n < ctx_p->retries ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
        tmp_if_expr$2 = (signed int)ctx_p->state != STATE_TERM ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$2 = (_Bool)0;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = (signed int)ctx_p->state != STATE_EXIT ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$3 = (_Bool)0;
      try_again = (signed int)tmp_if_expr$3;
      _warning("sync_exec_argv", "Bad exitcode %i (errcode %i). %s.", sync_exec_argv$$1$$exitcode, err, try_again != 0 ? "Retrying" : "Give up");
      if(!(try_again == 0))
      {
        _debug(2, "sync_exec_argv", "Sleeping for %u seconds before the retry.", ctx_p->syncdelay);
        sleep(ctx_p->syncdelay);
      }

    }

  }
  while(!(try_again == 0));
  _Bool tmp_if_expr$4;
  if(!(err == 0))
    tmp_if_expr$4 = !(ctx_p->flags[(signed long int)529] != 0) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$4 = (_Bool)0;
  if(tmp_if_expr$4)
  {
    _error("sync_exec_argv", "Bad exitcode %i (errcode %i)", sync_exec_argv$$1$$exitcode, err);
    ret = err;
  }

  else
    if(!((signed int)status == STATE_UNKNOWN))
    {
      ctx_p->state = status;
      main_status_update(ctx_p);
    }

  if(!(callback == ((signed int (*)(struct ctx *, struct thread_callbackfunct_arg *))NULL)))
  {
    signed int nret;
    nret=callback(ctx_p, callback_arg_p);
    if(!(nret == 0))
    {
      _error("sync_exec_argv", "Got error while callback().");
      if(ret == 0)
        ret = nret;

    }

  }

  indexes_p->nonthreaded_syncing_fpath2ei_ht = (struct _GHashTable *)(void *)0;
  return ret;
}

// sync_exec_argv_thread
// file sync.c line 1128
static inline signed int sync_exec_argv_thread(struct ctx *ctx_p, struct indexes *indexes_p, signed int (*callback)(struct ctx *, struct thread_callbackfunct_arg *), struct thread_callbackfunct_arg *callback_arg_p, char **argv)
{
  _debug(2, "sync_exec_argv_thread", "");
  if(ctx_p->flags[100l] >= 2)
    argv_dump(2, argv);

  struct threadinfo *threadinfo_p;
  threadinfo_p=thread_new();
  signed int *return_value___errno_location$1;
  if(threadinfo_p == ((struct threadinfo *)NULL))
  {
    return_value___errno_location$1=__errno_location();
    return *return_value___errno_location$1;
  }

  else
  {
    threadinfo_p->try_n = 0;
    threadinfo_p->callback = callback;
    threadinfo_p->callback_arg = callback_arg_p;
    threadinfo_p->argv = argv;
    threadinfo_p->ctx_p = ctx_p;
    threadinfo_p->starttime=time((signed long int *)(void *)0);
    threadinfo_p->fpath2ei_ht=g_hash_table_dup(indexes_p->fpath2ei_ht, g_str_hash, g_str_equal, free, free, (void * (*)(void *))strdup, eidup);
    threadinfo_p->iteration = ctx_p->iteration_num;
    if(!(ctx_p->synctimeout == 0u))
      threadinfo_p->expiretime = threadinfo_p->starttime + (signed long int)ctx_p->synctimeout;

    signed int return_value_pthread_create$3;
    return_value_pthread_create$3=pthread_create(&threadinfo_p->pthread, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))__sync_exec_thread, (void *)threadinfo_p);
    if(!(return_value_pthread_create$3 == 0))
    {
      _error("sync_exec_argv_thread", "Cannot pthread_create().");
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      return *return_value___errno_location$2;
    }

    _debug(3, "sync_exec_argv_thread", "thread %p", threadinfo_p->pthread);
    return 0;
  }
}

// sync_idle
// file sync.c line 3011
signed int sync_idle(struct ctx *ctx_p, struct indexes *indexes_p)
{
  signed int ret;
  ret=thread_gc(ctx_p);
  if(!(ret == 0))
    return ret;

  else
  {
    if(!(ctx_p->flags[521l] == 0))
    {
      struct stat st;
      signed int return_value_stat$1;
      return_value_stat$1=stat(ctx_p->standbyfile, &st);
      if(return_value_stat$1 == 0)
      {
        enum state_enum state_old = ctx_p->state;
        ctx_p->state = (volatile enum state_enum)STATE_HOLDON;
        main_status_update(ctx_p);
        _debug(1, "sync_idle", "Found standby file. Holding over syncs. Sleeping 1 second.");
        sleep((unsigned int)1);
        ctx_p->state = state_old;
        main_status_update(ctx_p);
        return 0;
      }

    }

    _debug(3, "sync_idle", "calling sync_idle_dosync_collectedevents()");
    ret=sync_idle_dosync_collectedevents(ctx_p, indexes_p);
    if(!(ret == 0))
      return ret;

    else
      return 0;
  }
}

// sync_idle_dosync_collectedevents
// file sync.c line 2875
signed int sync_idle_dosync_collectedevents(struct ctx *ctx_p, struct indexes *indexes_p)
{
  _debug(3, "sync_idle_dosync_collectedevents", "");
  struct dosync_arg dosync_arg = { .evcount=0, .excf_path={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .outf_path={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .outf=((struct _IO_FILE *)NULL),
    .ctx_p=((struct ctx *)NULL), .indexes_p=((struct indexes *)NULL),
    .data=NULL,
    .linescount=0, .api_ei=((struct api_eventinfo *)NULL), .api_ei_count=0,
    .buf={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .include_list={ ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL), ((const char *)NULL) },
    .include_list_count=0ul,
    .list_type_str=((const char *)NULL), .evmask_str=((const char *)NULL) };
  dosync_arg.ctx_p = ctx_p;
  dosync_arg.indexes_p = indexes_p;
  char isrsyncpreferexclude;
  _Bool tmp_if_expr$1;
  if(ctx_p->flags[77l] == 5)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = ctx_p->flags[(signed long int)77] == 4 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = ctx_p->flags[(signed long int)77] == 6 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$3 = !(ctx_p->flags[(signed long int)514] != 0) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$3 = (_Bool)0;
  isrsyncpreferexclude = (char)tmp_if_expr$3;
  if(!(ctx_p->listoutdir == ((char *)NULL)))
  {
    g_hash_table_remove_all(indexes_p->fpath2ei_ht);
    if(!(isrsyncpreferexclude == 0))
      g_hash_table_remove_all(indexes_p->exc_fpath_ht);

  }

  signed long int return_value_time$4;
  return_value_time$4=time((signed long int *)(void *)0);
  ctx_p->synctime = return_value_time$4 + (signed long int)ctx_p->syncdelay;
  _debug(3, "sync_idle_dosync_collectedevents", "Next sync will be not before: %u", ctx_p->synctime);
  signed int queue_id = 0;
  while(!(queue_id >= QUEUE_MAX))
  {
    signed int sync_idle_dosync_collectedevents$$1$$4$$ret;
    if(queue_id == QUEUE_LOCKWAIT)
    {
      if(ctx_p->flags[112l] == PM_SAFE)
        goto __CPROVER_DUMP_L11;

      queue_id = queue_id + 1;
    }

    else
    {

    __CPROVER_DUMP_L11:
      ;
      enum queue_id *queue_id_p = (enum queue_id *)&dosync_arg.data;
      *queue_id_p = (enum queue_id)queue_id;
      sync_idle_dosync_collectedevents$$1$$4$$ret=sync_idle_dosync_collectedevents_aggrqueue((enum queue_id)queue_id, ctx_p, indexes_p, &dosync_arg);
      if(!(sync_idle_dosync_collectedevents$$1$$4$$ret == 0))
      {
        _error("sync_idle_dosync_collectedevents", "Got error while processing queue #%i\n.", queue_id);
        g_hash_table_remove_all(indexes_p->fpath2ei_ht);
        if(!(isrsyncpreferexclude == 0))
          g_hash_table_remove_all(indexes_p->exc_fpath_ht);

        return sync_idle_dosync_collectedevents$$1$$4$$ret;
      }

      queue_id = queue_id + 1;
    }
  }
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  if(dosync_arg.evcount == 0)
  {
    _debug(3, "sync_idle_dosync_collectedevents", "Summary events' count is zero. Return 0.");
    return 0;
  }

  else
  {
    if(ctx_p->flags[77l] == 7)
    {
      _debug(3, "sync_idle_dosync_collectedevents", "There's %i events. Processing.", dosync_arg.evcount);
      void *return_value_xmalloc$5;
      return_value_xmalloc$5=xmalloc((unsigned long int)dosync_arg.evcount * sizeof(struct api_eventinfo) /*32ul*/ );
      dosync_arg.api_ei = (struct api_eventinfo *)return_value_xmalloc$5;
    }

    signed int ret;
    if(!(ctx_p->listoutdir == ((char *)NULL)))
      tmp_if_expr$7 = (_Bool)1;

    else
      tmp_if_expr$7 = ctx_p->flags[(signed long int)77] == 7 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$7)
    {
      if(ctx_p->flags[77l] == 7)
        goto __CPROVER_DUMP_L26;

      dosync_arg.excf_path[0l] = (char)0x00;
      if(!(isrsyncpreferexclude == 0))
      {
        ret=sync_idle_dosync_collectedevents_listcreate(&dosync_arg, "exclist");
        if(!(ret == 0))
        {
          _error("sync_idle_dosync_collectedevents", "Cannot create list-file");
          return ret;
        }

        g_hash_table_remove_all(indexes_p->out_lines_aggr_ht);
        g_hash_table_foreach_remove(indexes_p->exc_fpath_ht, sync_idle_dosync_collectedevents_rsync_exclistpush, (void *)&dosync_arg);
        g_hash_table_foreach_remove(indexes_p->out_lines_aggr_ht, rsync_aggrout, (void *)&dosync_arg);
        signed int return_value_fclose$6;
        return_value_fclose$6=fclose(dosync_arg.outf);
        if(!(return_value_fclose$6 == 0))
          _critical("sync_idle_dosync_collectedevents", "Assert: fclose(dosync_arg.outf)");

        strcpy(dosync_arg.excf_path, dosync_arg.outf_path);
      }

      ret=sync_idle_dosync_collectedevents_listcreate(&dosync_arg, "list");
      if(ret == 0)
        goto __CPROVER_DUMP_L26;

      _error("sync_idle_dosync_collectedevents", "Cannot create list-file");
      return ret;
    }

    else
    {

    __CPROVER_DUMP_L26:
      ;
      if(!(ctx_p->listoutdir == ((char *)NULL)))
        tmp_if_expr$8 = (_Bool)1;

      else
        tmp_if_expr$8 = ctx_p->flags[(signed long int)77] == 7 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$8)
        tmp_if_expr$9 = (_Bool)1;

      else
        tmp_if_expr$9 = ((signed int)ctx_p->synchandler_argf & SHFL_INCLUDE_LIST) != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$9)
      {
        g_hash_table_remove_all(indexes_p->out_lines_aggr_ht);
        g_hash_table_foreach(indexes_p->fpath2ei_ht, sync_idle_dosync_collectedevents_listpush, (void *)&dosync_arg);
        ret=sync_idle_dosync_collectedevents_commitpart(&dosync_arg);
        if(!(ret == 0))
        {
          _error("sync_idle_dosync_collectedevents", "Cannot submit to sync the list \"%s\"", (const void *)dosync_arg.outf_path);
          g_hash_table_remove_all(indexes_p->fpath2ei_ht);
          return ret;
        }

        g_hash_table_remove_all(indexes_p->fpath2ei_ht);
      }

      finish_iteration(ctx_p);
      return 0;
    }
  }
}

// sync_idle_dosync_collectedevents_aggrqueue
// file sync.c line 2413
signed int sync_idle_dosync_collectedevents_aggrqueue(enum queue_id queue_id, struct ctx *ctx_p, struct indexes *indexes_p, struct dosync_arg *dosync_arg)
{
  signed long int tm;
  tm=time((signed long int *)(void *)0);
  struct queueinfo *queueinfo = &ctx_p->_queues[(signed long int)queue_id];
  if(!(tm >= queueinfo->stime + (signed long int)queueinfo->collectdelay))
  {
    if(queueinfo->collectdelay == 4294967295u)
      goto __CPROVER_DUMP_L2;

    if(!(ctx_p->flags[520l] == 0))
      goto __CPROVER_DUMP_L2;

    _debug(3, "sync_idle_dosync_collectedevents_aggrqueue", "(%i, ...): too early (%i + %i > %i).", queue_id, queueinfo->stime, queueinfo->collectdelay, tm);
    return 0;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    queueinfo->stime = (signed long int)0;
    signed int evcount_real;
    unsigned int return_value_g_hash_table_size$1;
    return_value_g_hash_table_size$1=g_hash_table_size(indexes_p->fpath2ei_coll_ht[(signed long int)queue_id]);
    evcount_real = (signed int)return_value_g_hash_table_size$1;
    _debug(3, "sync_idle_dosync_collectedevents_aggrqueue", "(%i, ...): evcount_real == %i", queue_id, evcount_real);
    if(!(evcount_real >= 1))
    {
      _debug(3, "sync_idle_dosync_collectedevents_aggrqueue", "(%i, ...): no events, return 0.", queue_id);
      return 0;
    }

    else
    {
      if((signed int)queue_id == QUEUE_LOCKWAIT)
      {
        struct trylocked_arg arg_data = { .path_full=((char *)NULL), .path_full_len=0ul };
        dosync_arg->data = (void *)&arg_data;
        g_hash_table_foreach_remove(indexes_p->fpath2ei_coll_ht[(signed long int)queue_id], sync_trylocked, (void *)dosync_arg);
        sync_prequeue_unload(ctx_p, indexes_p);
        if(!(arg_data.path_full == ((char *)NULL)))
          free((void *)arg_data.path_full);

        goto __CPROVER_DUMP_L9;
      }

      g_hash_table_foreach(indexes_p->fpath2ei_coll_ht[(signed long int)queue_id], _sync_idle_dosync_collectedevents, (void *)dosync_arg);
      g_hash_table_remove_all(indexes_p->fpath2ei_coll_ht[(signed long int)queue_id]);
      if(ctx_p->flags[514l] == 0)
      {
        g_hash_table_foreach(indexes_p->exc_fpath_coll_ht[(signed long int)queue_id], _sync_idle_dosync_collectedexcludes, (void *)dosync_arg);
        g_hash_table_remove_all(indexes_p->exc_fpath_coll_ht[(signed long int)queue_id]);
      }


    __CPROVER_DUMP_L9:
      ;
      return 0;
    }
  }
}

// sync_idle_dosync_collectedevents_cleanup
// file sync.c line 2366
signed int sync_idle_dosync_collectedevents_cleanup(struct ctx *ctx_p, struct thread_callbackfunct_arg *arg_p)
{
  signed int ret0 = 0;
  signed int ret1 = 0;
  unsigned long int return_value_pthread_self$1;
  if(!(ctx_p->flags[85l] == 0))
    return 0;

  else
  {
    return_value_pthread_self$1=pthread_self();
    _debug(3, "sync_idle_dosync_collectedevents_cleanup", "(ctx_p, {inc: %p, exc: %p}) thread %p", arg_p->incfpath, arg_p->excfpath, return_value_pthread_self$1);
    if(!(arg_p->excfpath == ((char *)NULL)))
    {
      _debug(3, "sync_idle_dosync_collectedevents_cleanup", "unlink()-ing exclude-file: \"%s\"", arg_p->excfpath);
      ret0=unlink(arg_p->excfpath);
      free((void *)arg_p->excfpath);
    }

    if(!(arg_p->incfpath == ((char *)NULL)))
    {
      _debug(3, "sync_idle_dosync_collectedevents_cleanup", "unlink()-ing include-file: \"%s\"", arg_p->incfpath);
      ret1=unlink(arg_p->incfpath);
      free((void *)arg_p->incfpath);
    }

    free((void *)arg_p);
    return ret0 != 0 ? ret0 : ret1;
  }
}

// sync_idle_dosync_collectedevents_commitpart
// file sync.c line 2679
signed int sync_idle_dosync_collectedevents_commitpart(struct dosync_arg *dosync_arg_p)
{
  struct ctx *ctx_p = dosync_arg_p->ctx_p;
  struct indexes *indexes_p = dosync_arg_p->indexes_p;
  _debug(3, "sync_idle_dosync_collectedevents_commitpart", "Committing the file (flags[MODE] == %i)", ctx_p->flags[(signed long int)77]);
  _Bool tmp_if_expr$1;
  if(ctx_p->flags[77l] == 5)
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = ctx_p->flags[(signed long int)77] == 4 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = ctx_p->flags[(signed long int)77] == 6 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
    g_hash_table_foreach_remove(indexes_p->out_lines_aggr_ht, rsync_aggrout, (void *)dosync_arg_p);

  if(!(dosync_arg_p->outf == ((struct _IO_FILE *)NULL)))
  {
    signed int return_value_fclose$3;
    return_value_fclose$3=fclose(dosync_arg_p->outf);
    if(!(return_value_fclose$3 == 0))
      _critical("sync_idle_dosync_collectedevents_commitpart", "Assert: fclose(dosync_arg_p->outf)");

    dosync_arg_p->outf = (struct _IO_FILE *)(void *)0;
  }

  char *tmp_if_expr$4;
  char *tmp_if_expr$5;
  char *tmp_if_expr$7;
  signed int return_value_so_call_rsync$8;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$12;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$14;
  _Bool tmp_if_expr$13;
  if(dosync_arg_p->evcount >= 1)
  {
    struct thread_callbackfunct_arg *callback_arg_p;
    if(!(ctx_p->destdir == ((char *)NULL)))
      tmp_if_expr$4 = ctx_p->destdir;

    else
      tmp_if_expr$4 = "";
    if(!(ctx_p->destdirwslash == ((char *)NULL)))
      tmp_if_expr$5 = ctx_p->destdirwslash;

    else
      tmp_if_expr$5 = "";
    _debug(3, "sync_idle_dosync_collectedevents_commitpart", "%s [%s] (%p) -> %s [%s]", ctx_p->watchdir, ctx_p->watchdirwslash, ctx_p->watchdirwslash, tmp_if_expr$4, tmp_if_expr$5);
    if(ctx_p->flags[77l] == 7)
    {
      struct api_eventinfo *ei = dosync_arg_p->api_ei;
      signed int return_value_so_call_sync$6;
      return_value_so_call_sync$6=so_call_sync(ctx_p, indexes_p, dosync_arg_p->evcount, ei);
      return return_value_so_call_sync$6;
    }

    if(ctx_p->flags[77l] == 6)
    {
      if(!(dosync_arg_p->excf_path[0l] == 0))
        tmp_if_expr$7 = dosync_arg_p->excf_path;

      else
        tmp_if_expr$7 = (char *)(void *)0;
      return_value_so_call_rsync$8=so_call_rsync(ctx_p, indexes_p, dosync_arg_p->outf_path, tmp_if_expr$7);
      return return_value_so_call_rsync$8;
    }

    void *return_value_xcalloc$9;
    return_value_xcalloc$9=xcalloc((unsigned long int)1, sizeof(struct thread_callbackfunct_arg) /*16ul*/ );
    callback_arg_p = (struct thread_callbackfunct_arg *)return_value_xcalloc$9;
    if(!((SHFL_INCLUDE_LIST_PATH & (signed int)ctx_p->synchandler_argf) == 0))
      callback_arg_p->incfpath=strdup(dosync_arg_p->outf_path);

    if(!((SHFL_EXCLUDE_LIST_PATH & (signed int)ctx_p->synchandler_argf) == 0))
      callback_arg_p->excfpath=strdup(dosync_arg_p->excf_path);

    signed int rc;
    if(ctx_p->flags[77l] == 5)
      tmp_if_expr$10 = (_Bool)1;

    else
      tmp_if_expr$10 = ctx_p->flags[(signed long int)77] == 4 ? (_Bool)1 : (_Bool)0;
    dosync_arg_p->list_type_str = tmp_if_expr$10 ? "rsynclist" : "synclist";
    char **sync_idle_dosync_collectedevents_commitpart$$1$$3$$3$$argv;
    sync_idle_dosync_collectedevents_commitpart$$1$$3$$3$$argv=sync_customargv(ctx_p, dosync_arg_p, &ctx_p->synchandler_args[(signed long int)SHARGS_PRIMARY]);
    while(!(dosync_arg_p->include_list_count == 0ul))
    {
      dosync_arg_p->include_list_count = dosync_arg_p->include_list_count - 1ul;
      free((void *)(char *)dosync_arg_p->include_list[(signed long int)dosync_arg_p->include_list_count]);
    }
    if(!(ctx_p->flags[112l] == PM_OFF))
    {
      if(!(ctx_p->flags[112l] == PM_SAFE))
        tmp_if_expr$11 = (_Bool)1;

      else
        tmp_if_expr$11 = ctx_p->iteration_num != 0u ? (_Bool)1 : (_Bool)0;
      tmp_if_expr$12 = tmp_if_expr$11 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$12 = (_Bool)0;
    rc=(tmp_if_expr$12 ? sync_exec_argv_thread : sync_exec_argv)(ctx_p, indexes_p, sync_idle_dosync_collectedevents_cleanup, callback_arg_p, sync_idle_dosync_collectedevents_commitpart$$1$$3$$3$$argv);
    if(!(ctx_p->flags[112l] == PM_OFF))
    {
      if(!(ctx_p->flags[112l] == PM_SAFE))
        tmp_if_expr$13 = (_Bool)1;

      else
        tmp_if_expr$13 = ctx_p->iteration_num != 0u ? (_Bool)1 : (_Bool)0;
      tmp_if_expr$14 = tmp_if_expr$13 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$14 = (_Bool)0;
    if(!tmp_if_expr$14)
      argv_free(sync_idle_dosync_collectedevents_commitpart$$1$$3$$3$$argv);

    return rc;
  }

  return 0;
}

// sync_idle_dosync_collectedevents_listcreate
// file sync.c line 2483
signed int sync_idle_dosync_collectedevents_listcreate(struct dosync_arg *dosync_arg_p, char *name)
{
  _debug(3, "sync_idle_dosync_collectedevents_listcreate", "Creating %s file", name);
  char *fpath = dosync_arg_p->outf_path;
  struct ctx *ctx_p = dosync_arg_p->ctx_p;
  signed int ret;
  ret=sync_idle_dosync_collectedevents_uniqfname(ctx_p, fpath, name);
  if(!(ret == 0))
  {
    _error("sync_idle_dosync_collectedevents_listcreate", "sync_idle_dosync_collectedevents_listcreate: Cannot get unique file name.");
    return ret;
  }

  else
  {
    dosync_arg_p->outf=fopen(fpath, "w");
    if(dosync_arg_p->outf == ((struct _IO_FILE *)NULL))
    {
      _error("sync_idle_dosync_collectedevents_listcreate", "Cannot open \"%s\" as file for writing.", fpath);
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      return *return_value___errno_location$1;
    }

    setbuffer(dosync_arg_p->outf, dosync_arg_p->buf, (unsigned long int)8192);
    _debug(3, "sync_idle_dosync_collectedevents_listcreate", "Created list-file \"%s\"", fpath);
    dosync_arg_p->linescount = 0;
    return 0;
  }
}

// sync_idle_dosync_collectedevents_listpush
// file sync.c line 2796
void sync_idle_dosync_collectedevents_listpush(void *fpath_gp, void *evinfo_gp, void *arg_gp)
{
  struct dosync_arg *dosync_arg_p = (struct dosync_arg *)arg_gp;
  char *fpath = (char *)fpath_gp;
  struct eventinfo *evinfo = (struct eventinfo *)evinfo_gp;
  struct _IO_FILE *outf = dosync_arg_p->outf;
  struct ctx *ctx_p = dosync_arg_p->ctx_p;
  signed int *linescount_p = &dosync_arg_p->linescount;
  struct indexes *indexes_p = dosync_arg_p->indexes_p;
  struct api_eventinfo **api_ei_p = &dosync_arg_p->api_ei;
  signed int *api_ei_count_p = &dosync_arg_p->api_ei_count;
  _debug(3, "sync_idle_dosync_collectedevents_listpush", "\"%s\" with int-flags %p. evinfo: seqid_min == %u, seqid_max == %u type_o == %i, type_n == %i", fpath, (void *)(unsigned long int)evinfo->flags, evinfo->seqid_min, evinfo->seqid_max, evinfo->objtype_old, evinfo->objtype_new);
  signed int tmp_post$1;
  if(ctx_p->flags[77l] == 7)
  {
    struct api_eventinfo *ei;
    tmp_post$1 = *api_ei_count_p;
    *api_ei_count_p = *api_ei_count_p + 1;
    ei = &(*api_ei_p)[(signed long int)tmp_post$1];
    ei->evmask = evinfo->evmask;
    ei->flags = evinfo->flags;
    ei->objtype_old = evinfo->objtype_old;
    ei->objtype_new = evinfo->objtype_new;
    ei->path_len=strlen(fpath);
    ei->path=strdup(fpath);
    goto __CPROVER_DUMP_L20;
  }

  unsigned long int tmp_post$2;
  signed int tmp_if_expr$3;
  if(!((SHFL_INCLUDE_LIST & (signed int)ctx_p->synchandler_argf) == 0))
  {
    tmp_post$2 = dosync_arg_p->include_list_count;
    dosync_arg_p->include_list_count = dosync_arg_p->include_list_count + 1ul;
    dosync_arg_p->include_list[(signed long int)tmp_post$2]=strdup(fpath);
    if(!(ctx_p->synchandler_args[1l].c >= ctx_p->synchandler_args[0l].c))
      tmp_if_expr$3 = ctx_p->synchandler_args[(signed long int)SHARGS_PRIMARY].c;

    else
      tmp_if_expr$3 = ctx_p->synchandler_args[(signed long int)SHARGS_INITIAL].c;
    if(dosync_arg_p->include_list_count >= (unsigned long int)(256 + -tmp_if_expr$3))
      sync_inclist_rotate(ctx_p, dosync_arg_p);

  }

  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  if(!((12 & (signed int)ctx_p->synchandler_argf) == 0))
  {
    if(ctx_p->flags[77l] == 4)
      tmp_if_expr$6 = (_Bool)1;

    else
      tmp_if_expr$6 = ctx_p->flags[(signed long int)77] == 5 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$6)
      tmp_if_expr$7 = (_Bool)1;

    else
      tmp_if_expr$7 = ctx_p->flags[(signed long int)77] == 6 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$7)
    {
      if(!(ctx_p->flags[515l] == 0))
      {
        signed int return_value_fprintf$4;
        return_value_fprintf$4=fprintf(outf, "%s\n", fpath);
        if(!(return_value_fprintf$4 >= 1))
          _critical("sync_idle_dosync_collectedevents_listpush", "Assert: fprintf(outf, \"%s\\n\", fpath) <= 0");

      }

      else
      {
        signed int return_value_fprintf$5;
        return_value_fprintf$5=fprintf(outf, "sync %s %i %s\n", ctx_p->label, evinfo->evmask, fpath);
        if(!(return_value_fprintf$5 >= 1))
          _critical("sync_idle_dosync_collectedevents_listpush", "Assert: fprintf(outf, \"sync %s %i %s\\n\", ctx_p->label, evinfo->evmask, fpath) <= 0");

      }
    }

    else
    {
      if(!(ctx_p->rsyncinclimit == 0u))
      {
        if((unsigned int)*linescount_p >= ctx_p->rsyncinclimit)
          sync_inclist_rotate(ctx_p, dosync_arg_p);

      }

      signed int ret;
      unsigned long int return_value_strlen$8;
      return_value_strlen$8=strlen(fpath);
      ret=rsync_listpush(indexes_p, fpath, return_value_strlen$8, (enum eventinfo_flags)evinfo->flags, linescount_p);
      if(!(ret == 0))
      {
        _error("sync_idle_dosync_collectedevents_listpush", "Got error from rsync_listpush(). Exit.");
        exit(ret);
      }

      goto __CPROVER_DUMP_L20;
    }
  }


__CPROVER_DUMP_L20:
  ;
}

// sync_idle_dosync_collectedevents_rsync_exclistpush
// file sync.c line 2645
signed int sync_idle_dosync_collectedevents_rsync_exclistpush(void *fpath_gp, void *flags_gp, void *arg_gp)
{
  struct dosync_arg *dosync_arg_p = (struct dosync_arg *)arg_gp;
  char *fpath = (char *)fpath_gp;
  struct _IO_FILE *excf = dosync_arg_p->outf;
  enum eventinfo_flags flags = (enum eventinfo_flags)(signed int)(signed long int)flags_gp;
  _debug(3, "sync_idle_dosync_collectedevents_rsync_exclistpush", "\"%s\"", fpath);
  unsigned long int fpath_len;
  fpath_len=strlen(fpath);
  char *fpathwslash;
  if(fpath_len >= 1ul)
  {
    void *return_value___builtin_alloca$1;
    return_value___builtin_alloca$1=__builtin_alloca(fpath_len + (unsigned long int)2);
    fpathwslash = (char *)return_value___builtin_alloca$1;
    fpathwslash[(signed long int)0] = (char)47;
    memcpy((void *)&fpathwslash[(signed long int)1], (const void *)fpath, fpath_len + (unsigned long int)1);
  }

  else
    fpathwslash = fpath;
  const char *return_value_rsync_escape$2;
  return_value_rsync_escape$2=rsync_escape(fpathwslash);
  fpathwslash = (char *)return_value_rsync_escape$2;
  signed int ret;
  ret=rsync_outline(excf, fpathwslash, flags);
  if(!(ret == 0))
  {
    _error("sync_idle_dosync_collectedevents_rsync_exclistpush", "Got error from rsync_outline(). Exit.");
    exit(ret);
  }

  return (signed int)!(0 != 0);
}

// sync_idle_dosync_collectedevents_uniqfname
// file sync.c line 2464
signed int sync_idle_dosync_collectedevents_uniqfname(struct ctx *ctx_p, char *fpath, char *name)
{
  signed int pid;
  pid=getpid();
  signed long int tm;
  tm=time((signed long int *)(void *)0);
  struct stat64 stat64;
  signed int counter = 0;
  signed int tmp_post$4;
  signed int *return_value___errno_location$1;
  do
  {
    unsigned long int return_value_pthread_self$2;
    return_value_pthread_self$2=pthread_self();
    signed int return_value_rand$3;
    return_value_rand$3=rand();
    snprintf(fpath, (unsigned long int)4096, "%s/.clsync-%s.%u.%lu.%lu.%u", ctx_p->listoutdir, name, pid, (signed long int)return_value_pthread_self$2, (unsigned long int)tm, return_value_rand$3);
    lstat64(fpath, &stat64);
    tmp_post$4 = counter;
    counter = counter + 1;
    if(tmp_post$4 >= 1025)
    {
      _error("sync_idle_dosync_collectedevents_uniqfname", "Cannot find unused filename for list-file. The last try was \"%s\".", fpath);
      return 2;
    }

    return_value___errno_location$1=__errno_location();
  }
  while(!(*return_value___errno_location$1 == 2));
  signed int *return_value___errno_location$5;
  return_value___errno_location$5=__errno_location();
  *return_value___errno_location$5 = 0;
  return 0;
}

// sync_inclist_rotate
// file sync.c line 2756
void sync_inclist_rotate(struct ctx *ctx_p, struct dosync_arg *dosync_arg_p)
{
  signed int ret;
  char newexc_path[4097l];
  if(!((SHFL_EXCLUDE_LIST_PATH & (signed int)ctx_p->synchandler_argf) == 0))
  {
    ret=sync_idle_dosync_collectedevents_uniqfname(ctx_p, newexc_path, "exclist");
    if(!(ret == 0))
    {
      _error("sync_inclist_rotate", "Cannot get unique file name.");
      exit(ret);
    }

    ret=fileutils_copy(dosync_arg_p->excf_path, newexc_path);
    if(!(ret == 0))
    {
      _error("sync_inclist_rotate", "Cannot copy file \"%s\" to \"%s\".", (const void *)dosync_arg_p->excf_path, (const void *)newexc_path);
      exit(ret);
    }

  }

  ret=sync_idle_dosync_collectedevents_commitpart(dosync_arg_p);
  if(!(ret == 0))
  {
    _error("sync_inclist_rotate", "Cannot commit list-file \"%s\"", (const void *)dosync_arg_p->outf_path);
    exit(ret);
  }

  if(!((SHFL_INCLUDE_LIST_PATH & (signed int)ctx_p->synchandler_argf) == 0))
  {
    strcpy(dosync_arg_p->excf_path, newexc_path);
    ret=sync_idle_dosync_collectedevents_listcreate(dosync_arg_p, "list");
    if(!(ret == 0))
    {
      _error("sync_inclist_rotate", "Cannot create new list-file");
      exit(ret);
    }

  }

  goto __CPROVER_DUMP_L5;

__CPROVER_DUMP_L5:
  ;
}

// sync_indexes_fpath2ei_addfixed
// file sync.c line 1979
static inline signed int sync_indexes_fpath2ei_addfixed(struct ctx *ctx_p, struct indexes *indexes_p, const char *fpath, struct eventinfo *evinfo)
{
  const char *fpath_fixed = fpath;
  if(ctx_p->flags[77l] == 2)
  {
    static const char fpath_dot[2l] = { '.', 0 };
    if(*fpath == 0)
      fpath_fixed = fpath_dot;

  }

  char *return_value_strdup$1;
  return_value_strdup$1=strdup(fpath_fixed);
  signed int return_value_indexes_fpath2ei_add$2;
  return_value_indexes_fpath2ei_add$2=indexes_fpath2ei_add(indexes_p, return_value_strdup$1, evinfo);
  return return_value_indexes_fpath2ei_add$2;
}

// sync_initialsync
// file sync.c line 1566
signed int sync_initialsync(const char *path, struct ctx *ctx_p, struct indexes *indexes_p, enum initsync initsync)
{
  signed int ret;
  enum queue_id queue_id;
  _debug(3, "sync_initialsync", "(\"%s\", ctx_p, indexes_p, %i)", path, initsync);
  if((signed int)initsync == INITSYNC_FULL)
    queue_id = (enum queue_id)QUEUE_INSTANT;

  else
    queue_id = (enum queue_id)QUEUE_NORMAL;
  _Bool tmp_if_expr$10;
  if(ctx_p->flags[77l] == 5)
    tmp_if_expr$10 = (_Bool)1;

  else
    tmp_if_expr$10 = ctx_p->flags[(signed long int)77] == 4 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$11;
  if(tmp_if_expr$10)
    tmp_if_expr$11 = (_Bool)1;

  else
    tmp_if_expr$11 = ctx_p->flags[(signed long int)77] == 6 ? (_Bool)1 : (_Bool)0;
  struct synchandler_args *tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$6;
  if(!tmp_if_expr$11)
  {
    _debug(3, "sync_initialsync", "syncing \"%s\"", path);
    if(!(ctx_p->flags[512l] == 0))
    {
      if(ctx_p->flags[77l] == 7)
      {
        struct api_eventinfo *ei;
        void *return_value_xmalloc$1;
        return_value_xmalloc$1=xmalloc(sizeof(struct api_eventinfo) /*32ul*/ );
        ei = (struct api_eventinfo *)return_value_xmalloc$1;
        api_evinfo_initialevmask(ctx_p, ei, 1);
        ei->flags = (unsigned int)EVIF_RECURSIVELY;
        ei->path_len=strlen(path);
        ei->path=strdup(path);
        ei->objtype_old = (enum eventobjtype)EOT_DOESNTEXIST;
        ei->objtype_new = (enum eventobjtype)EOT_DIR;
        ret=so_call_sync(ctx_p, indexes_p, 1, ei);
        signed int return_value_sync_initialsync_finish$2;
        return_value_sync_initialsync_finish$2=sync_initialsync_finish(ctx_p, initsync, ret);
        return return_value_sync_initialsync_finish$2;
      }

      else
      {
        struct dosync_arg dosync_arg;
        struct synchandler_args *args_p;
        if(!(ctx_p->synchandler_args[1l].c == 0))
          tmp_if_expr$3 = &ctx_p->synchandler_args[(signed long int)SHARGS_INITIAL];

        else
          tmp_if_expr$3 = &ctx_p->synchandler_args[(signed long int)SHARGS_PRIMARY];
        args_p = tmp_if_expr$3;
        dosync_arg.ctx_p = ctx_p;
        dosync_arg.include_list[0l] = path;
        dosync_arg.include_list_count = (unsigned long int)1;
        dosync_arg.list_type_str = "initialsync";
        char **sync_initialsync$$1$$2$$2$$2$$argv;
        sync_initialsync$$1$$2$$2$$2$$argv=sync_customargv(ctx_p, &dosync_arg, args_p);
        if(!(ctx_p->flags[112l] == PM_OFF))
        {
          if(!(ctx_p->flags[112l] == PM_SAFE))
            tmp_if_expr$4 = (_Bool)1;

          else
            tmp_if_expr$4 = ctx_p->iteration_num != 0u ? (_Bool)1 : (_Bool)0;
          tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$5 = (_Bool)0;
        ret=(tmp_if_expr$5 ? sync_exec_argv_thread : sync_exec_argv)(ctx_p, indexes_p, (signed int (*)(struct ctx *, struct thread_callbackfunct_arg *))(void *)0, (struct thread_callbackfunct_arg *)(void *)0, sync_initialsync$$1$$2$$2$$2$$argv);
        if(!(ctx_p->flags[112l] == PM_OFF))
        {
          if(!(ctx_p->flags[112l] == PM_SAFE))
            tmp_if_expr$6 = (_Bool)1;

          else
            tmp_if_expr$6 = ctx_p->iteration_num != 0u ? (_Bool)1 : (_Bool)0;
          tmp_if_expr$7 = tmp_if_expr$6 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$7 = (_Bool)0;
        if(!tmp_if_expr$7)
          argv_free(sync_initialsync$$1$$2$$2$$2$$argv);

        signed int return_value_sync_initialsync_finish$8;
        return_value_sync_initialsync_finish$8=sync_initialsync_finish(ctx_p, initsync, ret);
        return return_value_sync_initialsync_finish$8;
      }
    }

    ret=sync_initialsync_walk(ctx_p, path, indexes_p, queue_id, initsync);
    if(!(ret == 0))
      _error("sync_initialsync", "Cannot get synclist");

    signed int return_value_sync_initialsync_finish$9;
    return_value_sync_initialsync_finish$9=sync_initialsync_finish(ctx_p, initsync, ret);
    return return_value_sync_initialsync_finish$9;
  }

  if(ctx_p->flags[514l] == 0)
  {
    struct queueinfo *queueinfo = &ctx_p->_queues[(signed long int)queue_id];
    if(queueinfo->stime == 0l)
      queueinfo->stime=time((signed long int *)(void *)0);

    struct eventinfo *evinfo;
    void *return_value_xmalloc$12;
    return_value_xmalloc$12=xmalloc(sizeof(struct eventinfo) /*40ul*/ );
    evinfo = (struct eventinfo *)return_value_xmalloc$12;
    memset((void *)evinfo, 0, sizeof(struct eventinfo) /*40ul*/ );
    evinfo->flags = evinfo->flags | (unsigned int)EVIF_RECURSIVELY;
    evinfo->seqid_min=sync_seqid();
    evinfo->seqid_max = evinfo->seqid_min;
    evinfo->objtype_old = (enum eventobjtype)EOT_DOESNTEXIST;
    evinfo->objtype_new = (enum eventobjtype)EOT_DIR;
    ret=sync_initialsync_walk(ctx_p, path, indexes_p, queue_id, initsync);
    if(!(ret == 0))
    {
      _error("sync_initialsync", "Cannot get exclude what to exclude");
      signed int return_value_sync_initialsync_finish$13;
      return_value_sync_initialsync_finish$13=sync_initialsync_finish(ctx_p, initsync, ret);
      return return_value_sync_initialsync_finish$13;
    }

    _debug(3, "sync_initialsync", "queueing \"%s\" with int-flags %p", path, (void *)(unsigned long int)evinfo->flags);
    char *path_rel;
    path_rel=sync_path_abs2rel(ctx_p, path, (unsigned long int)-1, (unsigned long int *)(void *)0, (char *)(void *)0);
    ret=indexes_queueevent(indexes_p, path_rel, evinfo, queue_id);
    signed int return_value_sync_initialsync_finish$14;
    return_value_sync_initialsync_finish$14=sync_initialsync_finish(ctx_p, initsync, ret);
    return return_value_sync_initialsync_finish$14;
  }

  ret=sync_initialsync_walk(ctx_p, path, indexes_p, queue_id, initsync);
  signed int return_value_sync_initialsync_finish$15;
  return_value_sync_initialsync_finish$15=sync_initialsync_finish(ctx_p, initsync, ret);
  return return_value_sync_initialsync_finish$15;
}

// sync_initialsync_finish
// file sync.c line 1561
static inline signed int sync_initialsync_finish(struct ctx *ctx_p, enum initsync initsync, signed int ret)
{
  finish_iteration(ctx_p);
  return ret;
}

// sync_initialsync_walk
// file sync.c line 1255
signed int sync_initialsync_walk(struct ctx *ctx_p, const char *dirpath, struct indexes *indexes_p, enum queue_id queue_id, enum initsync initsync)
{
  signed int ret = 0;
  const char *rootpaths[2l] = { dirpath, (const char *)(void *)0 };
  struct eventinfo evinfo;
  struct anonymous$16 *tree;
  struct rule *rules_p = ctx_p->rules;
  _debug(2, "sync_initialsync_walk", "(ctx_p, \"%s\", indexes_p, %i, %i).", dirpath, queue_id, initsync);
  char skip_rules;
  _Bool tmp_if_expr$1;
  if((signed int)initsync == INITSYNC_FULL)
    tmp_if_expr$1 = ctx_p->flags[(signed long int)70] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  skip_rules = (char)tmp_if_expr$1;
  char rsync_and_prefer_excludes;
  _Bool tmp_if_expr$2;
  if(ctx_p->flags[77l] == 5)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = ctx_p->flags[(signed long int)77] == 4 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = ctx_p->flags[(signed long int)77] == 6 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$3)
    tmp_if_expr$4 = !(ctx_p->flags[(signed long int)514] != 0) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$4 = (_Bool)0;
  rsync_and_prefer_excludes = (char)tmp_if_expr$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  signed int fts_errno;
  char *return_value_strerror$9;
  char *return_value_strerror$10;
  char *return_value_strdup$11;
  signed int tmp_post$12;
  char *return_value_strdup$13;
  unsigned int tmp_if_expr$14;
  char *return_value_strdup$15;
  signed int tmp_post$16;
  char *return_value_strdup$17;
  signed long int tmp_if_expr$19;
  if(ctx_p->flags[514l] == 0)
  {
    if(skip_rules == 0)
      goto __CPROVER_DUMP_L10;

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L10:
    ;
    skip_rules = skip_rules | (char)(ctx_p->rules_count == (unsigned long int)0);
    char fts_no_stat;
    if((signed int)initsync == INITSYNC_FULL)
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = ctx_p->_queues[(signed long int)QUEUE_NORMAL].collectdelay == ctx_p->_queues[(signed long int)QUEUE_BIGFILE].collectdelay ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
      tmp_if_expr$6 = (_Bool)1;

    else
      tmp_if_expr$6 = ctx_p->bfilethreshold == (unsigned long int)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$6)
      tmp_if_expr$7 = !(ctx_p->flags[(signed long int)88] != 0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$7 = (_Bool)0;
    fts_no_stat = (char)tmp_if_expr$7;
    signed int fts_opts = 0x0004 | 0x0010 | (fts_no_stat != 0 ? 0x0008 : 0) | (ctx_p->flags[(signed long int)516] != 0 ? 0x0040 : 0);
    _debug(3, "sync_initialsync_walk", "fts_opts == %p", (void *)(signed long int)fts_opts);
    tree=fts_open((char * const *)&rootpaths, fts_opts, (signed int (*)(const struct _ftsent **, const struct _ftsent **))(void *)0);
    if(tree == ((struct anonymous$16 *)NULL))
    {
      _error("sync_initialsync_walk", "Cannot privileged_fts_open() on \"%s\".", dirpath);
      signed int *return_value___errno_location$8;
      return_value___errno_location$8=__errno_location();
      return *return_value___errno_location$8;
    }

    memset((void *)&evinfo, 0, sizeof(struct eventinfo) /*40ul*/ );
    struct _ftsent *node;
    char *path_rel = (char *)(void *)0;
    unsigned long int path_rel_len = (unsigned long int)0;
    do
    {
      node=fts_read(tree);
      if(node == ((struct _ftsent *)NULL))
        break;

      switch((signed int)node->fts_info)
      {
        case 6:
          goto __CPROVER_DUMP_L60;
        case 3:

        case 12:

        case 13:

        case 8:

        case 1:

        case 5:

        case 2:

        case 11:
          break;
        case 7:

        case 10:

        case 4:
        {
          fts_errno = node->fts_errno;
          if(fts_errno == 2)
          {
            return_value_strerror$9=strerror(fts_errno);
            _debug(1, "sync_initialsync_walk", "Got error while privileged_fts_read(): %s (errno: %i; fts_info: %i).", return_value_strerror$9, fts_errno, node->fts_info);
            goto __CPROVER_DUMP_L60;
          }

          return_value_strerror$10=strerror(fts_errno);
          _error("sync_initialsync_walk", "Got error while privileged_fts_read(): %s (errno: %i; fts_info: %i).", return_value_strerror$10, fts_errno, node->fts_info);
          ret = node->fts_errno;
          goto l_sync_initialsync_walk_end;
        }
        default:
        {
          _error("sync_initialsync_walk", "Got unknown fts_info vlaue while privileged_fts_read(): %i.", node->fts_info);
          ret = 22;
          goto l_sync_initialsync_walk_end;
        }
      }
      path_rel=sync_path_abs2rel(ctx_p, node->fts_path, (unsigned long int)-1, &path_rel_len, path_rel);
      _debug(3, "sync_initialsync_walk", "Pointing to \"%s\" (node->fts_info == %i)", path_rel, node->fts_info);
      if(!(ctx_p->flags[88l] == 0))
      {
        if((signed int)node->fts_info == 1)
        {
          if(!(rsync_and_prefer_excludes == 0))
          {
            if(!(node->fts_statp->st_dev == ctx_p->st_dev))
            {
              _debug(3, "sync_initialsync_walk", "Excluding \"%s\" due to location on other device: node->fts_statp->st_dev [0x%o] != ctx_p->st_dev [0x%o]", path_rel, node->fts_statp->st_dev, ctx_p->st_dev);
              if((signed int)queue_id == QUEUE_AUTO)
              {
                signed int i = 0;
                while(!(i >= QUEUE_MAX))
                {
                  return_value_strdup$11=strdup(path_rel);
                  tmp_post$12 = i;
                  i = i + 1;
                  indexes_addexclude(indexes_p, return_value_strdup$11, (enum eventinfo_flags)EVIF_CONTENTRECURSIVELY, (enum queue_id)tmp_post$12);
                }
              }

              else
              {
                return_value_strdup$13=strdup(path_rel);
                indexes_addexclude(indexes_p, return_value_strdup$13, (enum eventinfo_flags)EVIF_CONTENTRECURSIVELY, queue_id);
              }
              fts_set(tree, node, 4);
            }

          }

          else
            if(ctx_p->flags[514l] == 0)
              _error("sync_initialsync_walk", "Excluding mount points is not implentemted for non \"rsync*\" modes.");

        }

      }

      unsigned int st_mode;
      if(!(fts_no_stat == 0))
        tmp_if_expr$14 = (unsigned int)((signed int)node->fts_info == 1 ? 0040000 : 0100000);

      else
        tmp_if_expr$14 = node->fts_statp->st_mode;
      st_mode = tmp_if_expr$14;
      if(skip_rules == 0)
      {
        enum ruleaction_enum perm;
        perm=rules_getperm(path_rel, st_mode, rules_p, (enum ruleaction_enum)(RA_WALK | RA_MONITOR));
        if((RA_WALK & (signed int)perm) == 0)
        {
          _debug(3, "sync_initialsync_walk", "Rejecting to walk into \"%s\".", path_rel);
          fts_set(tree, node, 4);
        }

        if((RA_MONITOR & (signed int)perm) == 0)
        {
          _debug(3, "sync_initialsync_walk", "Excluding \"%s\".", path_rel);
          if(!(rsync_and_prefer_excludes == 0))
          {
            if((signed int)queue_id == QUEUE_AUTO)
            {
              signed int sync_initialsync_walk$$1$$4$$4$$2$$2$$1$$i = 0;
              while(!(sync_initialsync_walk$$1$$4$$4$$2$$2$$1$$i >= QUEUE_MAX))
              {
                return_value_strdup$15=strdup(path_rel);
                tmp_post$16 = sync_initialsync_walk$$1$$4$$4$$2$$2$$1$$i;
                sync_initialsync_walk$$1$$4$$4$$2$$2$$1$$i = sync_initialsync_walk$$1$$4$$4$$2$$2$$1$$i + 1;
                indexes_addexclude(indexes_p, return_value_strdup$15, (enum eventinfo_flags)EVIF_NONE, (enum queue_id)tmp_post$16);
              }
            }

            else
            {
              return_value_strdup$17=strdup(path_rel);
              indexes_addexclude(indexes_p, return_value_strdup$17, (enum eventinfo_flags)EVIF_NONE, queue_id);
            }
          }

          continue;
        }

      }

      if(rsync_and_prefer_excludes == 0)
      {
        evinfo_initialevmask(ctx_p, &evinfo, (signed int)((signed int)node->fts_info == 1));
        if(ctx_p->flags[77l] == 1)
        {
          signed long int _SAFE_rc;
          signed int return_value_sync_dosync$18;
          return_value_sync_dosync$18=sync_dosync(node->fts_path, evinfo.evmask, ctx_p, indexes_p);
          _SAFE_rc = (signed long int)return_value_sync_dosync$18;
          if(!(_SAFE_rc == 0l))
          {
            _error("sync_initialsync_walk", "Got error while sync_dosync(node->fts_path, evinfo.evmask, ctx_p, indexes_p)");
            _debug(1, "sync_initialsync_walk", "fpath == \"%s\"; evmask == 0x%o", node->fts_path, evinfo.evmask);
            return -1;
          }

          _SAFE_rc;
          continue;
        }

        evinfo.seqid_min=sync_seqid();
        evinfo.seqid_max = evinfo.seqid_min;
        evinfo.objtype_old = (enum eventobjtype)EOT_DOESNTEXIST;
        evinfo.objtype_new = (enum eventobjtype)((signed int)node->fts_info == 1 ? EOT_DIR : EOT_FILE);
        if(!(fts_no_stat == 0))
          tmp_if_expr$19 = (signed long int)0;

        else
          tmp_if_expr$19 = node->fts_statp->st_size;
        evinfo.fsize = (unsigned long int)tmp_if_expr$19;
        _debug(3, "sync_initialsync_walk", "queueing \"%s\" (depth: %i) with int-flags %p", node->fts_path, node->fts_level, (void *)(unsigned long int)evinfo.flags);
        signed int _ret;
        _ret=sync_queuesync(path_rel, &evinfo, ctx_p, indexes_p, queue_id);
        if(!(_ret == 0))
        {
          _error("sync_initialsync_walk", "Got error while queueing \"%s\".", node->fts_path);
          signed int *return_value___errno_location$20;
          return_value___errno_location$20=__errno_location();
          ret = *return_value___errno_location$20;
          goto l_sync_initialsync_walk_end;
        }

        continue;
      }

      if(!(skip_rules == 0))
      {
        if((signed int)node->fts_info == 1)
        {
          if(ctx_p->flags[88l] == 0)
          {
            _debug(4, "sync_initialsync_walk", "\"FTS optimizator\"");
            fts_set(tree, node, 4);
          }

        }

      }


    __CPROVER_DUMP_L60:
      ;
    }
    while((_Bool)1);
    signed int *return_value___errno_location$22;
    return_value___errno_location$22=__errno_location();
    if(!(*return_value___errno_location$22 == 0))
    {
      _error("sync_initialsync_walk", "Got error while privileged_fts_read() and related routines.");
      signed int *return_value___errno_location$21;
      return_value___errno_location$21=__errno_location();
      ret = *return_value___errno_location$21;
      goto l_sync_initialsync_walk_end;
    }

    signed int return_value_fts_close$24;
    return_value_fts_close$24=fts_close(tree);
    if(!(return_value_fts_close$24 == 0))
    {
      _error("sync_initialsync_walk", "Got error while privileged_fts_close().");
      signed int *return_value___errno_location$23;
      return_value___errno_location$23=__errno_location();
      ret = *return_value___errno_location$23;
      goto l_sync_initialsync_walk_end;
    }


  l_sync_initialsync_walk_end:
    ;
    if(!(path_rel == ((char *)NULL)))
      free((void *)path_rel);

    return ret;
  }
}

// sync_islocked
// file sync.c line 2256
static inline signed int sync_islocked(const char * const fpath)
{
  signed int rc;
  rc=threads_foreach(_sync_islocked, (enum state_enum)STATE_RUNNING, (void *)fpath);
  _debug(3, "sync_islocked", "<%s>: %u", fpath, rc);
  return rc;
}

// sync_loop
// file sync.c line 3188
signed int sync_loop(struct ctx *ctx_p, struct indexes *indexes_p)
{
  signed int sync_loop$$1$$ret;
  struct threadsinfo *threadsinfo_p;
  threadsinfo_p=thread_info();
  state_p = &ctx_p->state;
  ctx_p->state = (volatile enum state_enum)(ctx_p->flags[(signed long int)518] != 0 ? STATE_RUNNING : STATE_INITSYNC);
  signed int return_value_thread_gc$1;
  while(!((signed int)ctx_p->state == STATE_EXIT))
  {
    signed int events;
    _debug(4, "sync_loop", "pthread_mutex_lock()");
    pthread_mutex_lock(&threadsinfo_p->mutex[(signed long int)0]);
    _debug(3, "sync_loop", "current state is %i (iteration: %u/%u); threadsinfo_p->used == %u", ctx_p->state, ctx_p->iteration_num, ctx_p->flags[(signed long int)528], threadsinfo_p->used);
    while(ctx_p->flags[112l] == PM_OFF)
    {
      if(threadsinfo_p->used == 0)
        break;

      _debug(1, "sync_loop", "We are in non-threading mode but have %u syncer threads. Waiting for them end.", threadsinfo_p->used);
      pthread_cond_wait(&threadsinfo_p->cond[(signed long int)0], &threadsinfo_p->mutex[(signed long int)0]);
      pthread_mutex_unlock(&threadsinfo_p->mutex[(signed long int)0]);
    }
    events = 0;
    switch((signed int)ctx_p->state)
    {
      case STATE_THREAD_GC:
      {
        main_status_update(ctx_p);
        return_value_thread_gc$1=thread_gc(ctx_p);
        if(!(return_value_thread_gc$1 == 0))
        {
          ctx_p->state = (volatile enum state_enum)STATE_EXIT;
          break;
        }

        ctx_p->state = (volatile enum state_enum)STATE_RUNNING;
        pthread_cond_broadcast(&threadsinfo_p->cond[(signed long int)0]);
        _debug(4, "sync_loop", "pthread_mutex_unlock()");
        pthread_mutex_unlock(&threadsinfo_p->mutex[(signed long int)0]);
        goto __CPROVER_DUMP_L38;
      }
      case STATE_INITSYNC:
      {
        if(ctx_p->flags[112l] == 0)
        {
          ctx_p->iteration_num = (unsigned int)0;
          setenv_iteration(ctx_p->iteration_num);
        }

        main_status_update(ctx_p);
        pthread_cond_broadcast(&threadsinfo_p->cond[(signed long int)0]);
        pthread_mutex_unlock(&threadsinfo_p->mutex[(signed long int)0]);
        sync_loop$$1$$ret=sync_initialsync(ctx_p->watchdir, ctx_p, indexes_p, (enum initsync)INITSYNC_FULL);
        if(!(sync_loop$$1$$ret == 0))
          return sync_loop$$1$$ret;

        if(!(ctx_p->flags[519l] == 0))
        {
          signed int sync_loop$$1$$1$$4$$4$$1$$ret;
          sync_loop$$1$$1$$4$$4$$1$$ret=sync_idle(ctx_p, indexes_p);
          if(!(sync_loop$$1$$1$$4$$4$$1$$ret == 0))
          {
            _error("sync_loop", "got error while sync_idle().");
            return sync_loop$$1$$1$$4$$4$$1$$ret;
          }

          ctx_p->state = (volatile enum state_enum)STATE_EXIT;
          return sync_loop$$1$$ret;
        }

        ctx_p->state = (volatile enum state_enum)STATE_RUNNING;
        goto __CPROVER_DUMP_L38;
      }
      case STATE_PREEXIT:

      case STATE_RUNNING:
      {
        if(ctx_p->flags[112l] == 0)
        {
          if(!(ctx_p->flags[528l] == 0))
          {
            if((unsigned int)ctx_p->flags[528l] == ctx_p->iteration_num + 4294967295u)
              ctx_p->state = (volatile enum state_enum)STATE_PREEXIT;

            else
              if(ctx_p->iteration_num >= (unsigned int)ctx_p->flags[528l])
                ctx_p->state = (volatile enum state_enum)STATE_EXIT;

          }

        }

        switch((signed int)ctx_p->state)
        {
          case STATE_PREEXIT:
          {
            main_status_update(ctx_p);
            if(!(ctx_p->flags[524l] == 0))
              hook_preexit(ctx_p);

            ctx_p->state = (volatile enum state_enum)STATE_TERM;
          }
          case STATE_RUNNING:
          {
            events=notify_wait(ctx_p, indexes_p);
            break;
          }
          default:
          {
            pthread_cond_broadcast(&threadsinfo_p->cond[(signed long int)0]);
            _debug(4, "sync_loop", "pthread_mutex_unlock()");
            pthread_mutex_unlock(&threadsinfo_p->mutex[(signed long int)0]);
            goto __CPROVER_DUMP_L38;
          }
        }
        break;
      }
      case STATE_REHASH:
      {
        main_status_update(ctx_p);
        _debug(1, "sync_loop", "rehashing.");
        main_rehash(ctx_p);
        ctx_p->state = (volatile enum state_enum)STATE_RUNNING;
        pthread_cond_broadcast(&threadsinfo_p->cond[(signed long int)0]);
        _debug(4, "sync_loop", "pthread_mutex_unlock()");
        pthread_mutex_unlock(&threadsinfo_p->mutex[(signed long int)0]);
        goto __CPROVER_DUMP_L38;
      }
      case STATE_TERM:
      {
        main_status_update(ctx_p);
        ctx_p->state = (volatile enum state_enum)STATE_EXIT;
      }
      case STATE_EXIT:
      {
        main_status_update(ctx_p);
        pthread_cond_broadcast(&threadsinfo_p->cond[(signed long int)0]);
        _debug(4, "sync_loop", "pthread_mutex_unlock()");
        pthread_mutex_unlock(&threadsinfo_p->mutex[(signed long int)0]);
        goto __CPROVER_DUMP_L38;
      }
      default:
        _critical("sync_loop", "internal error: ctx_p->state == %u", ctx_p->state);
    }
    pthread_cond_broadcast(&threadsinfo_p->cond[(signed long int)0]);
    pthread_mutex_unlock(&threadsinfo_p->mutex[(signed long int)0]);
    if(events == 0)
    {
      _debug(2, "sync_loop", "sync_x_wait(ctx_p, indexes_p) timed-out.");
      signed int ret;
      ret=sync_idle(ctx_p, indexes_p);
      if(!(ret == 0))
      {
        _error("sync_loop", "got error while sync_idle().");
        return ret;
      }

    }

    else
    {
      if(!(events >= 0))
      {
        _error("sync_loop", "Got error while waiting for event from notify subsystem.");
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        return *return_value___errno_location$2;
      }

      signed int count;
      count=ctx_p->notifyenginefunct.handle(ctx_p, indexes_p);
      if(!(count >= 1))
      {
        _error("sync_loop", "Cannot handle with notify events.");
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        return *return_value___errno_location$3;
      }

      main_status_update(ctx_p);
      if(!(ctx_p->flags[520l] == 0))
      {
        signed int sync_loop$$1$$1$$8$$ret;
        sync_loop$$1$$1$$8$$ret=sync_idle(ctx_p, indexes_p);
        if(!(sync_loop$$1$$1$$8$$ret == 0))
        {
          _error("sync_loop", "got error while sync_idle().");
          return sync_loop$$1$$1$$8$$ret;
        }

      }

    }

  __CPROVER_DUMP_L38:
    ;
  }
  signed int sync_loop$$1$$2$$ret;
  sync_loop$$1$$2$$ret=sync_idle(ctx_p, indexes_p);
  if(!(sync_loop$$1$$2$$ret == 0))
  {
    _error("sync_loop", "got error while sync_idle().");
    return sync_loop$$1$$2$$ret;
  }

  else
  {
    _debug(1, "sync_loop", "end");
    return exitcode;
  }
}

// sync_mark_walk
// file sync.c line 1718
signed int sync_mark_walk(struct ctx *ctx_p, const char *dirpath, struct indexes *indexes_p)
{
  signed int ret = 0;
  const char *rootpaths[2l] = { dirpath, (const char *)(void *)0 };
  struct anonymous$16 *tree;
  struct rule *rules_p = ctx_p->rules;
  _debug(2, "sync_mark_walk", "(ctx_p, \"%s\", indexes_p).", dirpath);
  signed int fts_opts = 0x0004 | 0x0010 | 0x0008 | (ctx_p->flags[(signed long int)516] != 0 ? 0x0040 : 0);
  _debug(3, "sync_mark_walk", "fts_opts == %p", (void *)(signed long int)fts_opts);
  tree=fts_open((char * const *)rootpaths, fts_opts, (signed int (*)(const struct _ftsent **, const struct _ftsent **))(void *)0);
  if(tree == ((struct anonymous$16 *)NULL))
  {
    if((signed int)ctx_p->state == STATE_STARTING)
      _error("sync_mark_walk", "Cannot privileged_fts_open() on \"%s\".", dirpath);

    else
      _debug((signed int)ctx_p->state == STATE_STARTING ? -1 : 2, "sync_mark_walk", "Cannot privileged_fts_open() on \"%s\".", dirpath);
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    return *return_value___errno_location$1;
  }

  struct _ftsent *node;
  char *path_rel = (char *)(void *)0;
  unsigned long int path_rel_len = (unsigned long int)0;
  signed int *return_value___errno_location$3;
  signed int *return_value___errno_location$2;
  do
  {
    node=fts_read(tree);
    if(node == ((struct _ftsent *)NULL))
      break;

    _debug(2, "sync_mark_walk", "walking: \"%s\" (depth %u): fts_info == %i", node->fts_path, node->fts_level, node->fts_info);
    switch((signed int)node->fts_info)
    {
      case 6:
        goto __CPROVER_DUMP_L31;
      case 3:

      case 12:

      case 13:

      case 8:

      case 11:
        goto __CPROVER_DUMP_L31;
      case 1:

      case 2:

      case 5:
        break;
      case 7:

      case 10:

      case 4:
      {
        return_value___errno_location$3=__errno_location();
        if(*return_value___errno_location$3 == 2)
        {
          _debug(1, "sync_mark_walk", "Got error while privileged_fts_read(); fts_info: %i.", node->fts_info);
          goto __CPROVER_DUMP_L31;
        }

        if((signed int)ctx_p->state == STATE_STARTING)
          _error("sync_mark_walk", "Got error while privileged_fts_read(); fts_info: %i.", node->fts_info);

        else
          _debug((signed int)ctx_p->state == STATE_STARTING ? -1 : 2, "sync_mark_walk", "Got error while privileged_fts_read(); fts_info: %i.", node->fts_info);
        return_value___errno_location$2=__errno_location();
        ret = *return_value___errno_location$2;
        goto l_sync_mark_walk_end;
      }
      default:
      {
        if((signed int)ctx_p->state == STATE_STARTING)
          _error("sync_mark_walk", "Got unknown fts_info vlaue while privileged_fts_read(): %i.", node->fts_info);

        else
          _debug((signed int)ctx_p->state == STATE_STARTING ? -1 : 2, "sync_mark_walk", "Got unknown fts_info vlaue while privileged_fts_read(): %i.", node->fts_info);
        ret = 22;
        goto l_sync_mark_walk_end;
      }
    }
    path_rel=sync_path_abs2rel(ctx_p, node->fts_path, (unsigned long int)-1, &path_rel_len, path_rel);
    enum ruleaction_enum perm;
    perm=rules_search_getperm(path_rel, (unsigned int)0040000, rules_p, (const enum ruleaction_enum)RA_WALK, (struct rule **)(void *)0);
    _debug(3, "sync_mark_walk", "perm == 0x%o", perm);
    if((RA_WALK & (signed int)perm) == 0)
    {
      _debug(2, "sync_mark_walk", "setting an FTS_SKIP on the directory");
      signed int return_value_fts_set$4;
      return_value_fts_set$4=fts_set(tree, node, 4);
      if(!(return_value_fts_set$4 == 0))
        _warning("sync_mark_walk", "Got error while fts_set(tree, node, FTS_SKIP): %s", path_rel);

    }

    if((RA_MONITOR & (signed int)perm) == 0)
      _debug(2, "sync_mark_walk", "don't mark the directory");

    else
    {
      _debug(2, "sync_mark_walk", "marking \"%s\" (depth %u)", node->fts_path, node->fts_level);
      signed int wd;
      wd=sync_notify_mark(ctx_p, node->fts_accpath, node->fts_path, (unsigned long int)node->fts_pathlen, indexes_p);
      if(wd == -1)
      {
        if((signed int)ctx_p->state == STATE_STARTING)
          _error("sync_mark_walk", "Got error while notify-marking \"%s\".", node->fts_path);

        else
          _debug((signed int)ctx_p->state == STATE_STARTING ? -1 : 2, "sync_mark_walk", "Got error while notify-marking \"%s\".", node->fts_path);
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        ret = *return_value___errno_location$5;
        goto l_sync_mark_walk_end;
      }

      _debug(2, "sync_mark_walk", "watching descriptor is %i.", wd);
    }

  __CPROVER_DUMP_L31:
    ;
  }
  while((_Bool)1);
  signed int *return_value___errno_location$7;
  return_value___errno_location$7=__errno_location();
  if(!(*return_value___errno_location$7 == 0))
  {
    if((signed int)ctx_p->state == STATE_STARTING)
      _error("sync_mark_walk", "Got error while privileged_fts_read() and related routines.");

    else
      _debug((signed int)ctx_p->state == STATE_STARTING ? -1 : 2, "sync_mark_walk", "Got error while privileged_fts_read() and related routines.");
    signed int *return_value___errno_location$6;
    return_value___errno_location$6=__errno_location();
    ret = *return_value___errno_location$6;
    goto l_sync_mark_walk_end;
  }

  signed int return_value_fts_close$9;
  return_value_fts_close$9=fts_close(tree);
  if(!(return_value_fts_close$9 == 0))
  {
    if((signed int)ctx_p->state == STATE_STARTING)
      _error("sync_mark_walk", "Got error while privileged_fts_close().");

    else
      _debug((signed int)ctx_p->state == STATE_STARTING ? -1 : 2, "sync_mark_walk", "Got error while privileged_fts_close().");
    signed int *return_value___errno_location$8;
    return_value___errno_location$8=__errno_location();
    ret = *return_value___errno_location$8;
    goto l_sync_mark_walk_end;
  }


l_sync_mark_walk_end:
  ;
  if(!(path_rel == ((char *)NULL)))
    free((void *)path_rel);

  return ret;
}

// sync_notify_init
// file sync.c line 1833
signed int sync_notify_init(struct ctx *ctx_p)
{
  signed int return_value_inotify_init1$1;
  signed int *return_value___errno_location$3;
  switch(ctx_p->flags[(signed long int)532])
  {
    case NE_INOTIFY:
    {
      return_value_inotify_init1$1=inotify_init1(524288);
      ctx_p->fsmondata = (void *)(signed long int)return_value_inotify_init1$1;
      if((signed long int)ctx_p->fsmondata == -1l)
      {
        _error("sync_notify_init", "cannot inotify_init1(%i).", 524288);
        return -1;
      }

      return 0;
    }
    case NE_GIO:
    {
      signed int return_value_gio_init$2;
      return_value_gio_init$2=gio_init(ctx_p);
      if(return_value_gio_init$2 == -1)
        _critical("sync_notify_init", "Assert: gio_init(ctx_p) == -1");

      return 0;
    }
    default:
    {
      _error("sync_notify_init", "unknown notify-engine: %i", ctx_p->flags[(signed long int)532]);
      return_value___errno_location$3=__errno_location();
      *return_value___errno_location$3 = 22;
      return -1;
    }
  }
}

// sync_notify_mark
// file sync.c line 1684
signed int sync_notify_mark(struct ctx *ctx_p, const char *accpath, const char *path, unsigned long int pathlen, struct indexes *indexes_p)
{
  _debug(3, "sync_notify_mark", "(..., \"%s\", %i,...)", path, pathlen);
  signed int wd;
  wd=indexes_fpath2wd(indexes_p, path);
  if(!(wd == -1))
  {
    _debug(1, "sync_notify_mark", "\"%s\" is already marked (wd: %i). Skipping.", path, wd);
    return wd;
  }

  else
  {
    _debug(5, "sync_notify_mark", "ctx_p->notifyenginefunct.add_watch_dir(ctx_p, indexes_p, \"%s\")", accpath);
    wd=ctx_p->notifyenginefunct.add_watch_dir(ctx_p, indexes_p, accpath);
    if(wd == -1)
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      if(*return_value___errno_location$1 == 2)
        return -2;

      _error("sync_notify_mark", "Cannot ctx_p->notifyenginefunct.add_watch_dir() on \"%s\".", path);
      return -1;
    }

    _debug(6, "sync_notify_mark", "endof ctx_p->notifyenginefunct.add_watch_dir(ctx_p, indexes_p, \"%s\")", accpath);
    indexes_add_wd(indexes_p, wd, path, pathlen);
    return wd;
  }
}

// sync_parameter_get
// file sync.h line 100
extern const char * sync_parameter_get(const char *variable_name, void *_dosync_arg_p)
{
  struct dosync_arg *dosync_arg_p = (struct dosync_arg *)_dosync_arg_p;
  struct ctx *ctx_p = dosync_arg_p->ctx_p;
  _Bool tmp_if_expr$6;
  if(ctx_p == ((struct ctx *)NULL))
    tmp_if_expr$6 = (_Bool)1;

  else
    tmp_if_expr$6 = ((signed int)ctx_p->synchandler_argf & SHFL_INCLUDE_LIST_PATH) != 0 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$8;
  signed int return_value_strcmp$7;
  if(tmp_if_expr$6)
  {
    return_value_strcmp$7=strcmp(variable_name, "INCLUDE-LIST-PATH");
    tmp_if_expr$8 = !(return_value_strcmp$7 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$8 = (_Bool)0;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  signed int return_value_strcmp$4;
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$1;
  if(tmp_if_expr$8)
    return dosync_arg_p->outf_path;

  else
  {
    if(ctx_p == ((struct ctx *)NULL))
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = ((signed int)ctx_p->synchandler_argf & SHFL_EXCLUDE_LIST_PATH) != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      return_value_strcmp$4=strcmp(variable_name, "EXCLUDE-LIST-PATH");
      tmp_if_expr$5 = !(return_value_strcmp$4 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$5 = (_Bool)0;
    if(tmp_if_expr$5)
      return dosync_arg_p->excf_path;

    else
    {
      return_value_strcmp$2=strcmp(variable_name, "TYPE");
      if(return_value_strcmp$2 == 0)
        return dosync_arg_p->list_type_str;

      else
      {
        return_value_strcmp$1=strcmp(variable_name, "EVENT-MASK");
        if(return_value_strcmp$1 == 0)
          return dosync_arg_p->evmask_str;

      }
    }
  }
  signed int *return_value___errno_location$9;
  return_value___errno_location$9=__errno_location();
  *return_value___errno_location$9 = 2;
  return (const char *)(void *)0;
}

// sync_path_abs2rel
// file sync.c line 943
char * sync_path_abs2rel(struct ctx *ctx_p, const char *path_abs, unsigned long int path_abs_len, unsigned long int *path_rel_len_p, char *path_rel_oldptr)
{
  unsigned long int tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  char *tmp_if_expr$4;
  void *return_value_xrealloc$3;
  if(path_abs == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    if(path_abs_len == 18446744073709551615ul)
      path_abs_len=strlen(path_abs);

    unsigned long int path_rel_len;
    char *path_rel;
    unsigned long int watchdirlen;
    if(ctx_p->watchdir == ctx_p->watchdirwslash)
      tmp_if_expr$1 = (unsigned long int)0;

    else
      tmp_if_expr$1 = ctx_p->watchdirlen;
    watchdirlen = tmp_if_expr$1;
    signed long int path_rel_len_signed = (signed long int)(path_abs_len - (watchdirlen + (unsigned long int)1));
    path_rel_len = (unsigned long int)(path_rel_len_signed > (signed long int)0 ? path_rel_len_signed : (signed long int)0);
    if(path_rel_len_p == ((unsigned long int *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = path_rel_len >= *path_rel_len_p ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      return_value_xrealloc$3=xrealloc((void *)path_rel_oldptr, path_rel_len + (unsigned long int)1);
      tmp_if_expr$4 = (char *)return_value_xrealloc$3;
    }

    else
      tmp_if_expr$4 = path_rel_oldptr;
    path_rel = tmp_if_expr$4;
    if(path_rel_len == 0ul)
    {
      path_rel[(signed long int)0] = (char)0;
      return path_rel;
    }

    else
    {
      memcpy((void *)path_rel, (const void *)&path_abs[(signed long int)(watchdirlen + (unsigned long int)1)], path_rel_len + (unsigned long int)1);
      if(!(path_rel_len_p == ((unsigned long int *)NULL)))
        *path_rel_len_p = path_rel_len;

      return path_rel;
    }
  }
}

// sync_path_rel2abs
// file sync.c line 913
char * sync_path_rel2abs(struct ctx *ctx_p, const char *path_rel, unsigned long int path_rel_len, unsigned long int *path_abs_len_p, char *path_abs_oldptr)
{
  unsigned long int tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  char *tmp_if_expr$4;
  void *return_value_xrealloc$3;
  if(path_rel == ((const char *)NULL))
    return (char *)(void *)0;

  else
  {
    if(path_rel_len == 18446744073709551615ul)
      path_rel_len=strlen(path_rel);

    char *path_abs;
    unsigned long int watchdirlen;
    if(ctx_p->watchdir == ctx_p->watchdirwslash)
      tmp_if_expr$1 = (unsigned long int)0;

    else
      tmp_if_expr$1 = ctx_p->watchdirlen;
    watchdirlen = tmp_if_expr$1;
    unsigned long int path_abs_len = path_rel_len + watchdirlen + (unsigned long int)1;
    if(path_abs_len_p == ((unsigned long int *)NULL))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = path_abs_len >= *path_abs_len_p ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      return_value_xrealloc$3=xrealloc((void *)path_abs_oldptr, path_abs_len + (unsigned long int)1);
      tmp_if_expr$4 = (char *)return_value_xrealloc$3;
    }

    else
      tmp_if_expr$4 = path_abs_oldptr;
    path_abs = tmp_if_expr$4;
    if(path_abs_oldptr == ((char *)NULL))
    {
      memcpy((void *)path_abs, (const void *)ctx_p->watchdir, watchdirlen);
      path_abs[(signed long int)watchdirlen] = (char)47;
    }

    memcpy((void *)&path_abs[(signed long int)(watchdirlen + (unsigned long int)1)], (const void *)path_rel, path_rel_len + (unsigned long int)1);
    if(!(path_abs_len_p == ((unsigned long int *)NULL)))
      *path_abs_len_p = path_abs_len;

    return path_abs;
  }
}

// sync_prequeue_loadmark
// file sync.c line 1998
extern signed int sync_prequeue_loadmark(signed int monitored, struct ctx *ctx_p, struct indexes *indexes_p, const char *path_full, const char *path_rel, struct stat64 *lstat_p, enum eventobjtype objtype_old, enum eventobjtype objtype_new, unsigned int event_mask, signed int event_wd, unsigned int st_mode, signed long int st_size, char **path_buf_p, unsigned long int *path_buf_len_p, struct eventinfo *evinfo)
{
  signed long int tmp_statement_expression$4;
  if((path_buf_p == ((char **)NULL) || path_buf_len_p == ((unsigned long int *)NULL)) && (path_full == ((const char *)NULL) || path_rel == ((const char *)NULL)))
  {
    _error("sync_prequeue_loadmark", "path_rel_p == NULL || path_rel_len_p == NULL");
    return 22;
  }

  else
  {
    if(path_rel == ((const char *)NULL))
    {
      *path_buf_p=sync_path_abs2rel(ctx_p, path_full, (unsigned long int)-1, path_buf_len_p, *path_buf_p);
      path_rel = *path_buf_p;
    }

    enum ruleaction_enum perm = (enum ruleaction_enum)RA_ALL;
    if(!(st_mode == 0u))
    {
      perm=rules_getperm(path_rel, st_mode, ctx_p->rules, (enum ruleaction_enum)(RA_WALK | RA_MONITOR));
      if(!((3 & (signed int)perm) == 0))
        goto __CPROVER_DUMP_L4;

      return 0;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      signed int is_dir = (signed int)((signed int)objtype_old == EOT_DIR || (signed int)objtype_new == EOT_DIR);
      signed int is_created = (signed int)((signed int)objtype_old == EOT_DOESNTEXIST);
      signed int is_deleted = (signed int)((signed int)objtype_new == EOT_DOESNTEXIST);
      _debug(4, "sync_prequeue_loadmark", "is_dir == %x; is_created == %x; is_deleted == %x", is_dir, is_created, is_deleted);
      if(!(is_dir == 0))
      {
        if(!(is_created == 0))
        {
          signed int ret;
          if(!((RA_WALK & (signed int)perm) == 0))
          {
            if(path_full == ((const char *)NULL))
            {
              *path_buf_p=sync_path_rel2abs(ctx_p, path_rel, (unsigned long int)-1, path_buf_len_p, *path_buf_p);
              path_full = *path_buf_p;
            }

            if(!(monitored == 0))
            {
              ret=sync_mark_walk(ctx_p, path_full, indexes_p);
              if(!(ret == 0))
              {
                _debug(1, "sync_prequeue_loadmark", "Seems, that directory \"%s\" disappeared, while trying to mark it.", path_full);
                return 0;
              }

            }

            ret=sync_initialsync(path_full, ctx_p, indexes_p, (enum initsync)INITSYNC_SUBDIR);
            if(!(ret == 0))
            {
              signed int *return_value___errno_location$1;
              return_value___errno_location$1=__errno_location();
              *return_value___errno_location$1 = ret;
              _error("sync_prequeue_loadmark", "Got error from sync_initialsync()");
              signed int *return_value___errno_location$2;
              return_value___errno_location$2=__errno_location();
              return *return_value___errno_location$2;
            }

          }

          fileischanged(ctx_p, indexes_p, path_rel, lstat_p, is_deleted);
          return 0;
        }

        else
          if(!(is_deleted == 0))
            _debug(2, "sync_prequeue_loadmark", "Disappeared \".../%s\".", path_rel);

      }

      if((RA_WALK & (signed int)perm) == 0)
        return 0;

      else
      {
        signed int return_value_fileischanged$3;
        return_value_fileischanged$3=fileischanged(ctx_p, indexes_p, path_rel, lstat_p, is_deleted);
        if(return_value_fileischanged$3 == 0)
        {
          _debug(4, "sync_prequeue_loadmark", "The file is not changed. Returning.");
          return 0;
        }

        else
        {
          if(ctx_p->flags[77l] == 1)
          {
            signed long int _SAFE_rc;
            signed int return_value_sync_dosync$5;
            return_value_sync_dosync$5=sync_dosync(path_rel, event_mask, ctx_p, indexes_p);
            _SAFE_rc = (signed long int)return_value_sync_dosync$5;
            if(!(_SAFE_rc == 0l))
            {
              _error("sync_prequeue_loadmark", "Got error while sync_dosync(path_rel, event_mask, ctx_p, indexes_p)");
              _debug(1, "sync_prequeue_loadmark", "fpath == \"%s\"; evmask == 0x%o", path_rel, event_mask);
              return -1;
            }

            tmp_statement_expression$4 = _SAFE_rc;
            return (signed int)tmp_statement_expression$4;
          }

          signed int isnew = 0;
          if(evinfo == ((struct eventinfo *)NULL))
            evinfo=indexes_fpath2ei(indexes_p, path_rel);

          else
            isnew = isnew + 1;
          if(evinfo == ((struct eventinfo *)NULL))
          {
            void *return_value_xmalloc$6;
            return_value_xmalloc$6=xmalloc(sizeof(struct eventinfo) /*40ul*/ );
            evinfo = (struct eventinfo *)return_value_xmalloc$6;
            memset((void *)evinfo, 0, sizeof(struct eventinfo) /*40ul*/ );
            evinfo->fsize = (unsigned long int)st_size;
            evinfo->wd = event_wd;
            evinfo->seqid_min=sync_seqid();
            evinfo->seqid_max = evinfo->seqid_min;
            evinfo->objtype_old = objtype_old;
            isnew = isnew + 1;
            _debug(3, "sync_prequeue_loadmark", "new event: fsize == %i; wd == %i", evinfo->fsize, evinfo->wd);
          }

          else
            evinfo->seqid_max=sync_seqid();
          switch(ctx_p->flags[(signed long int)532])
          {
            case NE_INOTIFY:
            {
              evinfo->evmask = evinfo->evmask | event_mask;
              break;
            }
            case NE_GIO:
              evinfo->evmask = event_mask;
          }
          evinfo->objtype_new = objtype_new;
          _debug(2, "sync_prequeue_loadmark", "path_rel == \"%s\"; evinfo->objtype_old == %i; evinfo->objtype_new == %i; evinfo->seqid_min == %u; evinfo->seqid_max == %u", path_rel, evinfo->objtype_old, evinfo->objtype_new, evinfo->seqid_min, evinfo->seqid_max);
          if(!(isnew == 0))
            sync_indexes_fpath2ei_addfixed(ctx_p, indexes_p, path_rel, evinfo);

          return 0;
        }
      }
    }
  }
}

// sync_prequeue_unload
// file sync.c line 2400
extern signed int sync_prequeue_unload(struct ctx *ctx_p, struct indexes *indexes_p)
{
  struct dosync_arg dosync_arg;
  dosync_arg.ctx_p = ctx_p;
  dosync_arg.indexes_p = indexes_p;
  unsigned int return_value_g_hash_table_size$1;
  return_value_g_hash_table_size$1=g_hash_table_size(indexes_p->fpath2ei_ht);
  _debug(3, "sync_prequeue_unload", "collected %i events per this time.", return_value_g_hash_table_size$1);
  g_hash_table_foreach(indexes_p->fpath2ei_ht, sync_queuesync_wrapper, (void *)&dosync_arg);
  g_hash_table_remove_all(indexes_p->fpath2ei_ht);
  return 0;
}

// sync_queuesync
// file sync.c line 1172
static signed int sync_queuesync(const char *fpath_rel, struct eventinfo *evinfo, struct ctx *ctx_p, struct indexes *indexes_p, enum queue_id queue_id)
{
  _debug(3, "sync_queuesync", "sync_queuesync(\"%s\", ...): fsize == %lu; tres == %lu, queue_id == %u", fpath_rel, evinfo->fsize, ctx_p->bfilethreshold, queue_id);
  if((signed int)queue_id == QUEUE_AUTO)
    queue_id = (enum queue_id)(evinfo->fsize > ctx_p->bfilethreshold ? QUEUE_BIGFILE : QUEUE_NORMAL);

  struct queueinfo *queueinfo = &ctx_p->_queues[(signed long int)queue_id];
  if(queueinfo->stime == 0l)
    queueinfo->stime=time((signed long int *)(void *)0);

  char *return_value_strchr$1;
  return_value_strchr$1=strchr(fpath_rel, 10);
  if(!(return_value_strchr$1 == ((char *)NULL)))
  {
    _debug(3, "sync_queuesync", "There's \"\\n\" character in path \"%s\". Ignoring it :(. Feedback to: https://github.com/xaionaro/clsync/issues/12", fpath_rel);
    return 0;
  }

  else
  {
    struct eventinfo *evinfo_q;
    evinfo_q=indexes_lookupinqueue(indexes_p, fpath_rel, queue_id);
    if(evinfo_q == ((struct eventinfo *)NULL))
    {
      struct eventinfo *evinfo_dup;
      void *return_value_xmalloc$2;
      return_value_xmalloc$2=xmalloc(sizeof(struct eventinfo) /*40ul*/ );
      evinfo_dup = (struct eventinfo *)return_value_xmalloc$2;
      memcpy((void *)evinfo_dup, (const void *)evinfo, sizeof(struct eventinfo) /*40ul*/ );
      char *return_value_strdup$3;
      return_value_strdup$3=strdup(fpath_rel);
      signed int return_value_indexes_queueevent$4;
      return_value_indexes_queueevent$4=indexes_queueevent(indexes_p, return_value_strdup$3, evinfo_dup, queue_id);
      return return_value_indexes_queueevent$4;
    }

    else
      evinfo_merge(ctx_p, evinfo_q, evinfo);
    return 0;
  }
}

// sync_queuesync_wrapper
// file sync.c line 2389
void sync_queuesync_wrapper(void *fpath_gp, void *evinfo_gp, void *arg_gp)
{
  char *fpath_rel = (char *)fpath_gp;
  struct eventinfo *evinfo = (struct eventinfo *)evinfo_gp;
  struct ctx *ctx_p = ((struct dosync_arg *)arg_gp)->ctx_p;
  struct indexes *indexes_p = ((struct dosync_arg *)arg_gp)->indexes_p;
  sync_queuesync(fpath_rel, evinfo, ctx_p, indexes_p, (enum queue_id)QUEUE_AUTO);
  goto __CPROVER_DUMP_L1;

__CPROVER_DUMP_L1:
  ;
}

// sync_run
// file sync.h line 68
extern signed int sync_run(struct ctx *ctx_p)
{
  signed int sync_run$$1$$ret;
  struct sighandler_arg sighandler_arg = { .ctx_p=((struct ctx *)NULL), .pthread_parent=0ul, .exitcode_p=((signed int *)NULL),
    .sigset_p=((struct anonymous$15 *)NULL) };
  struct indexes indexes = { .wd2fpath_ht=(struct _GHashTable *)(void *)0, .fpath2wd_ht=((struct _GHashTable *)NULL),
    .fpath2ei_ht=((struct _GHashTable *)NULL),
    .exc_fpath_ht=((struct _GHashTable *)NULL),
    .exc_fpath_coll_ht={ ((struct _GHashTable *)NULL), ((struct _GHashTable *)NULL), ((struct _GHashTable *)NULL), ((struct _GHashTable *)NULL) },
    .fpath2ei_coll_ht={ ((struct _GHashTable *)NULL), ((struct _GHashTable *)NULL), ((struct _GHashTable *)NULL), ((struct _GHashTable *)NULL) },
    .out_lines_aggr_ht=((struct _GHashTable *)NULL),
    .nonthreaded_syncing_fpath2ei_ht=((struct _GHashTable *)NULL),
    .fileinfo_ht=((struct _GHashTable *)NULL) };
  signed int sync_run$$1$$2$$i;
  if(ctx_p->blockthread_count >= 16ul)
    _critical("sync_run", "Assert: ctx_p->blockthread_count >= (1<<4)");

  unsigned long int tmp_post$1 = ctx_p->blockthread_count;
  ctx_p->blockthread_count = ctx_p->blockthread_count + 1ul;
  ctx_p->blockthread[(signed long int)tmp_post$1]=pthread_self();
  _debug(3, "sync_run", "register_blockthread(): ctx_p->blockthread_count -> %i", ctx_p->blockthread_count);
  struct anonymous$15 sigset_sighandler;
  sigemptyset(&sigset_sighandler);
  sigaddset(&sigset_sighandler, 14);
  sigaddset(&sigset_sighandler, 1);
  sigaddset(&sigset_sighandler, 3);
  sigaddset(&sigset_sighandler, 15);
  sigaddset(&sigset_sighandler, 2);
  sigaddset(&sigset_sighandler, 17);
  sigaddset(&sigset_sighandler, 10);
  sigaddset(&sigset_sighandler, 12);
  sigaddset(&sigset_sighandler, 29);
  sync_run$$1$$2$$i = 0;
  for( ; !(sync_run$$1$$2$$i >= 512); sync_run$$1$$2$$i = sync_run$$1$$2$$i + 1)
    if(!(ctx_p->customsignal[(signed long int)sync_run$$1$$2$$i] == ((char *)NULL)))
      sigaddset(&sigset_sighandler, sync_run$$1$$2$$i);

  sync_run$$1$$ret=pthread_sigmask(0, &sigset_sighandler, (struct anonymous$15 *)(void *)0);
  _Bool tmp_if_expr$16;
  unsigned int return_value_getuid$10;
  signed long int return_value_time$17;
  signed int *return_value___errno_location$18;
  if(!(sync_run$$1$$ret == 0))
    return sync_run$$1$$ret;

  else
  {
    sighandler_arg.ctx_p = ctx_p;
    sighandler_arg.pthread_parent=pthread_self();
    sighandler_arg.exitcode_p = &sync_run$$1$$ret;
    sighandler_arg.sigset_p = &sigset_sighandler;
    sync_run$$1$$ret=pthread_create(&pthread_sighandler, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))sync_sighandler, (void *)&sighandler_arg);
    if(!(sync_run$$1$$ret == 0))
      return sync_run$$1$$ret;

    else
    {
      struct anonymous$15 sigset_parent;
      sigemptyset(&sigset_parent);
      sigaddset(&sigset_parent, 16);
      sync_run$$1$$ret=pthread_sigmask(1, &sigset_parent, (struct anonymous$15 *)(void *)0);
      if(!(sync_run$$1$$ret == 0))
        return sync_run$$1$$ret;

      else
      {
        signal(16, sync_sig_int);
        signed int sync_run$$1$$4$$i;
        ctx_p->indexes_p = (void *)&indexes;
        indexes.wd2fpath_ht=g_hash_table_new_full(g_direct_hash, g_direct_equal, ((void (*)(void *))NULL), ((void (*)(void *))NULL));
        indexes.fpath2wd_ht=g_hash_table_new_full(g_str_hash, g_str_equal, free, ((void (*)(void *))NULL));
        indexes.fpath2ei_ht=g_hash_table_new_full(g_str_hash, g_str_equal, free, free);
        indexes.exc_fpath_ht=g_hash_table_new_full(g_str_hash, g_str_equal, free, ((void (*)(void *))NULL));
        indexes.out_lines_aggr_ht=g_hash_table_new_full(g_str_hash, g_str_equal, free, ((void (*)(void *))NULL));
        indexes.fileinfo_ht=g_hash_table_new_full(g_str_hash, g_str_equal, free, free);
        sync_run$$1$$4$$i = 0;
        for( ; !(sync_run$$1$$4$$i >= QUEUE_MAX); sync_run$$1$$4$$i = sync_run$$1$$4$$i + 1)
        {
          if(sync_run$$1$$4$$i == QUEUE_LOCKWAIT)
          {
            indexes.fpath2ei_coll_ht[(signed long int)sync_run$$1$$4$$i]=g_hash_table_new_full(g_str_hash, g_str_equal, free, ((void (*)(void *))NULL));
            goto __CPROVER_DUMP_L15;
          }

          indexes.fpath2ei_coll_ht[(signed long int)sync_run$$1$$4$$i]=g_hash_table_new_full(g_str_hash, g_str_equal, free, free);
          indexes.exc_fpath_coll_ht[(signed long int)sync_run$$1$$4$$i]=g_hash_table_new_full(g_str_hash, g_str_equal, free, ((void (*)(void *))NULL));

        __CPROVER_DUMP_L15:
          ;
        }
        if(ctx_p->flags[77l] == 7)
          tmp_if_expr$16 = (_Bool)1;

        else
          tmp_if_expr$16 = ctx_p->flags[(signed long int)77] == 6 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$16)
        {
          struct stat so_stat;
          signed int return_value_stat$5;
          return_value_stat$5=stat(ctx_p->handlerfpath, &so_stat);
          if(return_value_stat$5 == -1)
          {
            signed int *return_value___errno_location$2;
            return_value___errno_location$2=__errno_location();
            char *return_value_strerror$3;
            return_value_strerror$3=strerror(*return_value___errno_location$2);
            _error("sync_run", "Can't stat shared object file \"%s\": %s", ctx_p->handlerfpath, return_value_strerror$3);
            signed int *return_value___errno_location$4;
            return_value___errno_location$4=__errno_location();
            return *return_value___errno_location$4;
          }

          if(!((61440u & so_stat.st_mode) == 32768u))
          {
            _error("sync_run", "Shared object \"%s\" must be a regular file (or symlink to a regular file).", ctx_p->handlerfpath, so_stat.st_uid);
            return 1;
          }

          if(!(so_stat.st_uid == 0u))
          {
            return_value_getuid$10=getuid();
            if(!(so_stat.st_uid == return_value_getuid$10))
            {
              struct stat cl_stat;
              char *cl_str;
              void *return_value___builtin_alloca$6;
              return_value___builtin_alloca$6=__builtin_alloca((unsigned long int)20);
              cl_str = (char *)return_value___builtin_alloca$6;
              signed int ret;
              signed int return_value_getpid$7;
              return_value_getpid$7=getpid();
              snprintf(cl_str, (unsigned long int)20, "/proc/%i/exe", return_value_getpid$7);
              ret=stat(cl_str, &cl_stat);
              if(ret == -1)
              {
                signed int *return_value___errno_location$8;
                return_value___errno_location$8=__errno_location();
                char *return_value_strerror$9;
                return_value_strerror$9=strerror(*return_value___errno_location$8);
                _error("sync_run", "Can't stat clsync binary file \"%s\": %s", cl_str, return_value_strerror$9);
              }

              if(ret == -1 || !(so_stat.st_uid == cl_stat.st_uid))
              {
                _error("sync_run", "Wrong owner for shared object \"%s\": %i. Only root, clsync file owner and user started the program are allowed.", ctx_p->handlerfpath, so_stat.st_uid);
                return 1;
              }

            }

          }

          if(!((3602u & so_stat.st_mode) == 0u))
          {
            _error("sync_run", "Wrong shared object \"%s\" permissions: %#loSpecial bits, group and world writable are not allowed.", ctx_p->handlerfpath, so_stat.st_mode & (unsigned int)07777);
            return 1;
          }

          void *synchandler_handle;
          synchandler_handle=dlopen(ctx_p->handlerfpath, 0x00002 | 0);
          if(synchandler_handle == NULL)
          {
            char *return_value_dlerror$11;
            return_value_dlerror$11=dlerror();
            _error("sync_run", "Cannot load shared object file \"%s\": %s", ctx_p->handlerfpath, return_value_dlerror$11);
            return -1;
          }

          ctx_p->handler_handle = synchandler_handle;
          void *return_value_dlsym$12;
          return_value_dlsym$12=dlsym(ctx_p->handler_handle, "clsyncapi_init");
          ctx_p->handler_funct.init = (signed int (*)(struct ctx *, struct indexes *))return_value_dlsym$12;
          if(ctx_p->flags[77l] == 6)
          {
            void *return_value_dlsym$13;
            return_value_dlsym$13=dlsym(ctx_p->handler_handle, "clsyncapi_rsync");
            ctx_p->handler_funct.rsync = (signed int (*)(const char *, const char *))return_value_dlsym$13;
            if(ctx_p->handler_funct.rsync == ((signed int (*)(const char *, const char *))NULL))
            {
              char *sync_run$$1$$6$$6$$1$$dlerror_str;
              sync_run$$1$$6$$6$$1$$dlerror_str=dlerror();
              _error("sync_run", "Cannot resolve symbol clsyncapi_rsync in shared object \"%s\": %s", ctx_p->handlerfpath, sync_run$$1$$6$$6$$1$$dlerror_str != (char *)(void *)0 ? sync_run$$1$$6$$6$$1$$dlerror_str : "No error description returned.");
            }

          }

          else
          {
            void *return_value_dlsym$14;
            return_value_dlsym$14=dlsym(ctx_p->handler_handle, "clsyncapi_sync");
            ctx_p->handler_funct.sync = (signed int (*)(signed int, struct api_eventinfo *))return_value_dlsym$14;
            if(ctx_p->handler_funct.sync == ((signed int (*)(signed int, struct api_eventinfo *))NULL))
            {
              char *dlerror_str;
              dlerror_str=dlerror();
              _error("sync_run", "Cannot resolve symbol clsyncapi_sync in shared object \"%s\": %s", ctx_p->handlerfpath, dlerror_str != (char *)(void *)0 ? dlerror_str : "No error description returned.");
            }

          }
          void *return_value_dlsym$15;
          return_value_dlsym$15=dlsym(ctx_p->handler_handle, "clsyncapi_deinit");
          ctx_p->handler_funct.deinit = (signed int (*)())return_value_dlsym$15;
          if(!(ctx_p->handler_funct.init == ((signed int (*)(struct ctx *, struct indexes *))NULL)))
          {
            sync_run$$1$$ret=ctx_p->handler_funct.init(ctx_p, &indexes);
            if(!(sync_run$$1$$ret == 0))
            {
              _error("sync_run", "Cannot init sync-handler module.");
              return sync_run$$1$$ret;
            }

          }

        }

        if(!(ctx_p->listoutdir == ((char *)NULL)))
        {
          return_value_time$17=time((signed long int *)(void *)0);
          srand((unsigned int)return_value_time$17);
        }

        if(ctx_p->flags[519l] == 0)
        {
          signed int return_value_sync_notify_init$19;
          return_value_sync_notify_init$19=sync_notify_init(ctx_p);
          if(!(return_value_sync_notify_init$19 == 0))
          {
            return_value___errno_location$18=__errno_location();
            return *return_value___errno_location$18;
          }

        }

        sync_run$$1$$ret=privileged_init(ctx_p);
        if(!(sync_run$$1$$ret == 0))
          return sync_run$$1$$ret;

        else
        {
          switch(ctx_p->flags[(signed long int)532])
          {
            case NE_INOTIFY:
            {
              ctx_p->notifyenginefunct.add_watch_dir = inotify_add_watch_dir;
              ctx_p->notifyenginefunct.wait = inotify_wait;
              ctx_p->notifyenginefunct.handle = inotify_handle;
              break;
            }
            case NE_GIO:
            {
              ctx_p->notifyenginefunct.add_watch_dir = gio_add_watch_dir;
              ctx_p->notifyenginefunct.wait = gio_wait;
              ctx_p->notifyenginefunct.handle = gio_handle;
            }
          }
          if(!(ctx_p->socketpath == ((char *)NULL)))
            sync_run$$1$$ret=control_run(ctx_p);

          if(ctx_p->flags[519l] == 0)
          {
            sync_run$$1$$ret=sync_mark_walk(ctx_p, ctx_p->watchdir, &indexes);
            if(sync_run$$1$$ret == 0)
              goto __CPROVER_DUMP_L43;

            return sync_run$$1$$ret;
          }

          else
          {

          __CPROVER_DUMP_L43:
            ;
            sync_run$$1$$ret=sync_loop(ctx_p, &indexes);
            if(!(sync_run$$1$$ret == 0))
              return sync_run$$1$$ret;

            else
            {
              _debug(1, "sync_run", "sync_loop() ended");
              if(!(ctx_p->socketpath == ((char *)NULL)))
                control_cleanup(ctx_p);

              _debug(1, "sync_run", "killing sighandler");
              pthread_kill(pthread_sighandler, 2);
              thread_cleanup(ctx_p);
              _debug(2, "sync_run", "Deinitializing the FS monitor subsystem");
              switch(ctx_p->flags[(signed long int)532])
              {
                case NE_INOTIFY:
                {
                  inotify_deinit(ctx_p);
                  break;
                }
                case NE_GIO:
                  gio_deinit(ctx_p);
              }
              if(ctx_p->flags[77l] == 7)
              {
                signed int _ret;
                if(!(ctx_p->handler_funct.deinit == ((signed int (*)())NULL)))
                {
                  _ret=ctx_p->handler_funct.deinit();
                  if(!(_ret == 0))
                  {
                    _error("sync_run", "Cannot deinit sync-handler module.");
                    if(sync_run$$1$$ret == 0)
                      sync_run$$1$$ret = _ret;

                  }

                }

                signed int return_value_dlclose$21;
                return_value_dlclose$21=dlclose(ctx_p->handler_handle);
                if(!(return_value_dlclose$21 == 0))
                {
                  char *return_value_dlerror$20;
                  return_value_dlerror$20=dlerror();
                  _error("sync_run", "Cannot unload shared object file \"%s\": %s", ctx_p->handlerfpath, return_value_dlerror$20);
                  if(sync_run$$1$$ret == 0)
                    sync_run$$1$$ret = -1;

                }

              }

              rsync_escape_cleanup();
              signed int i;
              _debug(3, "sync_run", "Closing hash tables");
              g_hash_table_destroy(indexes.wd2fpath_ht);
              g_hash_table_destroy(indexes.fpath2wd_ht);
              g_hash_table_destroy(indexes.fpath2ei_ht);
              g_hash_table_destroy(indexes.exc_fpath_ht);
              g_hash_table_destroy(indexes.out_lines_aggr_ht);
              g_hash_table_destroy(indexes.fileinfo_ht);
              i = 0;
              for( ; !(i >= QUEUE_MAX); i = i + 1)
              {
                if(i == QUEUE_LOCKWAIT)
                {
                  g_hash_table_destroy(indexes.fpath2ei_coll_ht[(signed long int)i]);
                  goto __CPROVER_DUMP_L60;
                }

                g_hash_table_destroy(indexes.fpath2ei_coll_ht[(signed long int)i]);
                g_hash_table_destroy(indexes.exc_fpath_coll_ht[(signed long int)i]);

              __CPROVER_DUMP_L60:
                ;
              }
              if(!(ctx_p->flags[522l] == 0))
              {
                char *sync_run$$1$$16$$argv[3l] = { ctx_p->exithookfile, ctx_p->label, (char *)(void *)0 };
                exec_argv(sync_run$$1$$16$$argv, (signed int *)(void *)0);
              }

              _debug(3, "sync_run", "privileged_deinit()");
              signed int return_value_privileged_deinit$22;
              return_value_privileged_deinit$22=privileged_deinit(ctx_p);
              sync_run$$1$$ret = sync_run$$1$$ret | return_value_privileged_deinit$22;
              _debug(3, "sync_run", "finish");
              return sync_run$$1$$ret;
            }
          }
        }
      }
    }
  }
}

// sync_seqid
// file sync.c line 71
static inline unsigned int sync_seqid()
{
  unsigned int tmp_post$1 = _sync_seqid_value;
  _sync_seqid_value = _sync_seqid_value + 1u;
  return tmp_post$1;
}

// sync_sig_int
// file sync.c line 3315
void sync_sig_int(signed int signal)
{
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  _debug(2, "sync_sig_int", "%i: Thread %p", signal, return_value_pthread_self$1);
}

// sync_sigchld
// file sync.c line 3616
void sync_sigchld()
{
  ;
}

// sync_sighandler
// file sync.c line 3624
signed int sync_sighandler(struct sighandler_arg *sighandler_arg_p)
{
  signed int sync_sighandler$$1$$signal = 0;
  signed int ret;
  struct anonymous$15 sigset_full;
  struct ctx *ctx_p = sighandler_arg_p->ctx_p;
  unsigned long int pthread_parent = sighandler_arg_p->pthread_parent;
  signed int *exitcode_p = sighandler_arg_p->exitcode_p;
  sync_sighandler_exitcode_p = exitcode_p;
  sethandler_sigchld(sync_sigchld);
  sigfillset(&sigset_full);
  signed int return_value_sigismember$1;
  signed int return_value_1;
  signed int return_value_2;
  while((_Bool)1)
  {
    if(!(state_p == ((volatile enum state_enum *)NULL)))
    {
      if(!((signed int)ctx_p->state == STATE_TERM))
      {
        if((signed int)ctx_p->state == STATE_EXIT)
          goto __CPROVER_DUMP_L2;

      }

      else
      {

      __CPROVER_DUMP_L2:
        ;
        goto __CPROVER_DUMP_L32;
      }
    }

    return_value_sigismember$1=sigismember(&sigset_full, 15);
    _debug(3, "sync_sighandler", "waiting for signal (is sigset filled == %i)", return_value_sigismember$1);
    ret=sigwait(&sigset_full, &sync_sighandler$$1$$signal);
    if(state_p == ((volatile enum state_enum *)NULL))
      switch(sync_sighandler$$1$$signal)
      {
        case 14:
          *exitcode_p = 62;
        case 3:

        case 15:

        case 2:

        case 17:
        {
          exit(*exitcode_p);
          break;
        }
        default:
          _warning("sync_sighandler", "Got signal %i, but the main loop is not started, yet. Ignoring the signal.", sync_sighandler$$1$$signal);
      }

    else
    {
      _debug(3, "sync_sighandler", "got signal %i. ctx_p->state == %i.", sync_sighandler$$1$$signal, ctx_p->state);
      if(!(ctx_p->customsignal[(signed long int)sync_sighandler$$1$$signal] == ((char *)NULL)))
      {
        signed int return_value_config_block_parse$3;
        return_value_config_block_parse$3=config_block_parse(ctx_p, ctx_p->customsignal[(signed long int)sync_sighandler$$1$$signal]);
        if(!(return_value_config_block_parse$3 == 0))
        {
          signed int *return_value___errno_location$2;
          return_value___errno_location$2=__errno_location();
          *exitcode_p = *return_value___errno_location$2;
          sync_sighandler$$1$$signal = 15;
        }

        continue;
      }

      switch(sync_sighandler$$1$$signal)
      {
        case 14:
          *exitcode_p = 62;
        case 3:
        {
          if(!(ctx_p->flags[524l] == 0))
            sync_switch_state(ctx_p, pthread_parent, STATE_PREEXIT);

          else
            sync_switch_state(ctx_p, pthread_parent, STATE_TERM);
          break;
        }
        case 15:

        case 2:
        {
          sync_switch_state(ctx_p, pthread_parent, STATE_TERM);
          if(!(ctx_p->children == 0))
          {
            signed int child_pid;
            ctx_p->children = ctx_p->children - 1;
            child_pid = ctx_p->child_pid[(signed long int)ctx_p->children];
            signed int return_value;
            return_value=_privileged_kill_child(child_pid, sync_sighandler$$1$$signal, (char)0);
            if(!(return_value == 2))
            {
              if(!(sync_sighandler$$1$$signal == 3))
                return_value_1=_privileged_kill_child(child_pid, 3, (char)0);

              else
                if(!(sync_sighandler$$1$$signal == 15))
                  return_value_2=_privileged_kill_child(child_pid, 15, (char)0);

                else
                {
                  signed int return_value_3;
                  return_value_3=_privileged_kill_child(child_pid, 9, (char)0);
                }
            }

          }

          break;
        }
        case 1:
        {
          sync_switch_state(ctx_p, pthread_parent, STATE_REHASH);
          break;
        }
        case 17:
        {
          sync_sigchld();
          break;
        }
        case 10:
        {
          sync_switch_state(ctx_p, pthread_parent, STATE_THREAD_GC);
          break;
        }
        case 12:
        {
          sync_switch_state(ctx_p, pthread_parent, STATE_INITSYNC);
          break;
        }
        case 29:
        {
          sync_dump(ctx_p, ctx_p->dump_path);
          break;
        }
        default:
        {
          _error("sync_sighandler", "Unknown signal: %i. Exit.", sync_sighandler$$1$$signal);
          sync_switch_state(ctx_p, pthread_parent, STATE_TERM);
        }
      }
    }
  }

__CPROVER_DUMP_L32:
  ;
  _debug(3, "sync_sighandler", "signal handler closed.");
  return 0;
}

// sync_switch_state
// file sync.c line 3357
signed int sync_switch_state(struct ctx *ctx_p, unsigned long int pthread_parent, signed int newstate)
{
  union anonymous *pthread_mutex_state;
  union anonymous *pthread_mutex_select;
  union anonymous$1 *pthread_cond_state;
  signed int return_value_pthread_mutex_trylock$1;
  signed int return_value_pthread_mutex_trylock$2;
  signed int return_value__thread_info_unlock$3;
  if(state_p == ((volatile enum state_enum *)NULL))
  {
    _debug(3, "sync_switch_state", "sync_switch_state(ctx_p, %p, %i), but state_p == NULL", pthread_parent, newstate);
    return 0;
  }

  else
  {
    _debug(3, "sync_switch_state", "sync_switch_state(ctx_p, %p, %i)", pthread_parent, newstate);
    struct threadsinfo *threadsinfo_p;
    threadsinfo_p=thread_info();
    if(!(threadsinfo_p == ((struct threadsinfo *)NULL)))
    {
      if(threadsinfo_p->mutex_init == 0)
        goto l_sync_parent_interrupt_end;

      pthread_mutex_state = &threadsinfo_p->mutex[(signed long int)0];
      pthread_mutex_select = &threadsinfo_p->mutex[(signed long int)1];
      pthread_cond_state = &threadsinfo_p->cond[(signed long int)0];
      _sync_tryforcecycle_i = 0;
      _debug(4, "sync_switch_state", "while(pthread_mutex_trylock( pthread_mutex_state ))");
      do
      {
        return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(pthread_mutex_state);
        if(!(return_value_pthread_mutex_trylock$1 == 16))
          break;

        signed int rc;
        rc=sync_tryforcecycle(ctx_p, pthread_parent);
        if(!(rc == 0) && !(rc == 115))
          return rc;

        if(rc == 0)
          break;

      }
      while((_Bool)1);
      _sync_tryforcecycle_i = 0;
      _debug(4, "sync_switch_state", "while(pthread_mutex_trylock( pthread_mutex_select ))");
      do
      {
        return_value_pthread_mutex_trylock$2=pthread_mutex_trylock(pthread_mutex_select);
        if(!(return_value_pthread_mutex_trylock$2 == 16))
          break;

        signed int sync_switch_state$$1$$8$$rc;
        sync_switch_state$$1$$8$$rc=sync_tryforcecycle(ctx_p, pthread_parent);
        if(!(sync_switch_state$$1$$8$$rc == 0) && !(sync_switch_state$$1$$8$$rc == 115))
          return sync_switch_state$$1$$8$$rc;

        if(sync_switch_state$$1$$8$$rc == 0)
          break;

      }
      while((_Bool)1);
      *state_p = (volatile enum state_enum)newstate;
      pthread_kill(pthread_parent, 16);
      _debug(4, "sync_switch_state", "pthread_cond_broadcast(). New state is %i.", *state_p);
      pthread_cond_broadcast(pthread_cond_state);
      _debug(4, "sync_switch_state", "pthread_mutex_unlock( pthread_mutex_state )");
      pthread_mutex_unlock(pthread_mutex_state);
      _debug(4, "sync_switch_state", "pthread_mutex_unlock( pthread_mutex_select )");
      pthread_mutex_unlock(pthread_mutex_select);
      return_value__thread_info_unlock$3=_thread_info_unlock("sync_switch_state", 0);
      return return_value__thread_info_unlock$3;
    }

    else
    {

    l_sync_parent_interrupt_end:
      ;
      *state_p = (volatile enum state_enum)newstate;
      pthread_kill(pthread_parent, 16);
      signed int return_value__thread_info_unlock$4;
      return_value__thread_info_unlock$4=_thread_info_unlock("sync_switch_state", 0);
      return return_value__thread_info_unlock$4;
    }
  }
}

// sync_term
// file sync.c line 3730
extern signed int sync_term(signed int exitcode)
{
  *sync_sighandler_exitcode_p = exitcode;
  signed int return_value_pthread_kill$1;
  return_value_pthread_kill$1=pthread_kill(pthread_sighandler, 15);
  return return_value_pthread_kill$1;
}

// sync_tryforcecycle
// file sync.c line 3323
signed int sync_tryforcecycle(struct ctx *ctx_p, unsigned long int pthread_parent)
{
  _debug(3, "sync_tryforcecycle", "sending signal to interrupt blocking operations like select()-s and so on (ctx_p->blockthread_count == %i)", ctx_p->blockthread_count);
  signed int i;
  signed int count = (signed int)ctx_p->blockthread_count;
  i = 0;
  for( ; !(i >= count); i = i + 1)
  {
    _debug(2, "sync_tryforcecycle", "Sending SIGUSR_BLOPINT to thread %p", ctx_p->blockthread[(signed long int)i]);
    pthread_kill(ctx_p->blockthread[(signed long int)i], 16);
  }
  _sync_tryforcecycle_i = _sync_tryforcecycle_i + 1;
  if(_sync_tryforcecycle_i >= 61)
  {
    _error("sync_tryforcecycle", "Seems we got a deadlock.");
    return 35;
  }

  else
  {
    sleep((unsigned int)1);
    return 115;
  }
}

// sync_trylocked
// file sync.c line 2341
signed int sync_trylocked(void *fpath_gp, void *evinfo_gp, void *arg_gp)
{
  char *fpath = (char *)fpath_gp;
  struct eventinfo *evinfo = (struct eventinfo *)evinfo_gp;
  struct dosync_arg *arg_p = (struct dosync_arg *)arg_gp;
  struct ctx *ctx_p = arg_p->ctx_p;
  struct indexes *indexes_p = arg_p->indexes_p;
  struct trylocked_arg *data = (struct trylocked_arg *)arg_p->data;
  signed int return_value_sync_islocked$2;
  return_value_sync_islocked$2=sync_islocked(fpath);
  if(return_value_sync_islocked$2 == 0)
  {
    signed int return_value_sync_prequeue_loadmark$1;
    return_value_sync_prequeue_loadmark$1=sync_prequeue_loadmark(0, ctx_p, indexes_p, (const char *)(void *)0, fpath, (struct stat64 *)(void *)0, (enum eventobjtype)evinfo->evmask, evinfo->objtype_old, (unsigned int)evinfo->objtype_new, 0, (unsigned int)0, (signed long int)0, &data->path_full, &data->path_full_len, evinfo);
    if(!(return_value_sync_prequeue_loadmark$1 == 0))
    {
      _critical("sync_trylocked", "Cannot re-queue \"%s\" to be synced", fpath);
      return 0;
    }

    return (signed int)!(0 != 0);
  }

  return 0;
}

// synchandler_arg
// file main.c line 770
static inline signed int synchandler_arg(char *arg, unsigned long int arg_len, void *_ctx_p, enum shargsid shargsid)
{
  struct ctx *ctx_p = (struct ctx *)_ctx_p;
  signed int return_value_strcmp$6;
  return_value_strcmp$6=strcmp(arg, "%RSYNC-ARGS%");
  char **tmp_if_expr$1;
  signed int *return_value___errno_location$2;
  if(return_value_strcmp$6 == 0)
  {
    char *args_e[8l] = { "-aH", "--delete", "--exclude-from", "%EXCLUDE-LIST-PATH%", "--include-from", "%INCLUDE-LIST-PATH%", "--exclude=*", (char *)(void *)0 };
    char *args_i[6l] = { "-aH", "--delete", "--include-from", "%INCLUDE-LIST-PATH%", "--exclude=*", (char *)(void *)0 };
    char **args_p;
    free((void *)arg);
    if(!(ctx_p->flags[514l] == 0))
      tmp_if_expr$1 = args_i;

    else
      tmp_if_expr$1 = args_e;
    args_p = tmp_if_expr$1;
    while(!(*args_p == ((char *)NULL)))
    {
      char *return_value_strdup$3;
      return_value_strdup$3=strdup(*args_p);
      unsigned long int return_value_strlen$4;
      return_value_strlen$4=strlen(*args_p);
      signed int return_value_synchandler_arg$5;
      return_value_synchandler_arg$5=synchandler_arg(return_value_strdup$3, return_value_strlen$4, (void *)ctx_p, shargsid);
      if(!(return_value_synchandler_arg$5 == 0))
      {
        return_value___errno_location$2=__errno_location();
        return *return_value___errno_location$2;
      }

      args_p = args_p + 1l;
    }
    return 0;
  }

  if(ctx_p->synchandler_args[(signed long int)shargsid].c >= 254)
  {
    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    *return_value___errno_location$7 = 7;
    _error("synchandler_arg", "There're too many sync-handler arguments (%u > (1<<8)-2; arg == \"%s\").", arg);
    signed int *return_value___errno_location$8;
    return_value___errno_location$8=__errno_location();
    return *return_value___errno_location$8;
  }

  signed int tmp_post$9 = ctx_p->synchandler_args[(signed long int)shargsid].c;
  ctx_p->synchandler_args[(signed long int)shargsid].c = ctx_p->synchandler_args[(signed long int)shargsid].c + 1;
  ctx_p->synchandler_args[(signed long int)shargsid].v[(signed long int)tmp_post$9] = arg;
  return 0;
}

// synchandler_arg0
// file main.c line 810
static signed int synchandler_arg0(char *arg, unsigned long int arg_len, void *_ctx_p)
{
  signed int return_value_synchandler_arg$1;
  return_value_synchandler_arg$1=synchandler_arg(arg, arg_len, _ctx_p, (enum shargsid)SHARGS_PRIMARY);
  return return_value_synchandler_arg$1;
}

// synchandler_arg1
// file main.c line 814
static signed int synchandler_arg1(char *arg, unsigned long int arg_len, void *_ctx_p)
{
  signed int return_value_synchandler_arg$1;
  return_value_synchandler_arg$1=synchandler_arg(arg, arg_len, _ctx_p, (enum shargsid)SHARGS_INITIAL);
  return return_value_synchandler_arg$1;
}

// syntax
// file main.c line 368
signed int syntax()
{
  _info("syntax", "possible options:");
  signed int i = -1;
  signed int tmp_if_expr$1;
  do
  {
    i = i + 1;
    if(long_options[(signed long int)i].name == ((const char *)NULL))
      break;

    if(long_options[(signed long int)i].val == 533 || long_options[(signed long int)i].val == 534)
      continue;

    if((256 & long_options[(signed long int)i].val) == 0)
    {
      if(!((512 & long_options[(signed long int)i].val) == 0))
        tmp_if_expr$1 = 32;

      else
        tmp_if_expr$1 = long_options[(signed long int)i].val;
      _info("syntax", "\t--%-24s%c%c%s", long_options[(signed long int)i].name, (long_options[(signed long int)i].val & 1 << 9) != 0 ? 32 : 45, tmp_if_expr$1, long_options[(signed long int)i].has_arg == 1 ? " argument" : "");
    }

  }
  while((_Bool)1);
  exit(22);
}

// syslog_buf
// file error.c line 132
static signed int syslog_buf(const char *fmt, ...)
{
  void **args;
  signed int rc;
  args = (void **)&fmt;
  rc=vsyslog_buf(fmt, args);
  args = ((void **)NULL);
  return rc;
}

// syslog_flush
// file error.c line 143
static void syslog_flush(signed int level)
{
  syslog(level, "%s", (const void *)_syslog_buffer);
  _syslog_buffer_filled = (unsigned long int)0;
}

// thread_cleanup
// file sync.c line 445
signed int thread_cleanup(struct ctx *ctx_p)
{
  _debug(3, "thread_cleanup", "");
  struct threadsinfo *threadsinfo_p;
  threadsinfo_p=_thread_info_lock("thread_cleanup");
  signed int *return_value___errno_location$1;
  signed int return_value__thread_info_unlock$2;
  char **tmp_post$3;
  if(threadsinfo_p == ((struct threadsinfo *)NULL))
  {
    return_value___errno_location$1=__errno_location();
    return_value__thread_info_unlock$2=_thread_info_unlock("thread_cleanup", *return_value___errno_location$1);
    return return_value__thread_info_unlock$2;
  }

  else
  {
    _debug(1, "thread_cleanup", "There're %i opened threads. Waiting.", threadsinfo_p->used);
    while(!(threadsinfo_p->used == 0))
    {
      struct threadinfo *threadinfo_p;
      threadsinfo_p->used = threadsinfo_p->used - 1;
      threadinfo_p = &threadsinfo_p->threads[(signed long int)threadsinfo_p->used];
      if(!((signed int)threadinfo_p->state == STATE_EXIT))
      {
        _debug(1, "thread_cleanup", "killing pid %i with SIGTERM", threadinfo_p->child_pid);
        kill(threadinfo_p->child_pid, 15);
        pthread_join(threadinfo_p->pthread, (void **)(void *)0);
        _debug(2, "thread_cleanup", "thread #%i exitcode: %i", threadsinfo_p->used, threadinfo_p->exitcode);
        char **ptr = threadinfo_p->argv;
        while(!(*ptr == ((char *)NULL)))
        {
          tmp_post$3 = ptr;
          ptr = ptr + 1l;
          free((void *)*tmp_post$3);
        }
        free((void *)threadinfo_p->argv);
      }

    }
    _debug(3, "thread_cleanup", "All threads are closed.");
    if(!(threadsinfo_p->allocated == 0))
    {
      free((void *)threadsinfo_p->threads);
      free((void *)threadsinfo_p->threadsstack);
    }

    if(!(threadsinfo_p->mutex_init == 0))
    {
      signed int i = 0;
      for( ; !(i >= 3); i = i + 1)
      {
        pthread_mutex_destroy(&threadsinfo_p->mutex[(signed long int)i]);
        pthread_cond_destroy(&threadsinfo_p->cond[(signed long int)i]);
      }
    }

    memset((void *)threadsinfo_p, 0, sizeof(struct threadsinfo) /*304ul*/ );
    _debug(3, "thread_cleanup", "done.");
    signed int return_value__thread_info_unlock$4;
    return_value__thread_info_unlock$4=_thread_info_unlock("thread_cleanup", 0);
    return return_value__thread_info_unlock$4;
  }
}

// thread_del_bynum
// file sync.c line 318
signed int thread_del_bynum(signed int thread_num)
{
  _debug(2, "thread_del_bynum", "thread_del_bynum(%i)", thread_num);
  struct threadsinfo *threadsinfo_p;
  threadsinfo_p=_thread_info_lock("thread_del_bynum");
  signed int *return_value___errno_location$1;
  signed int return_value__thread_info_unlock$2;
  signed int return_value__thread_info_unlock$3;
  char **tmp_post$4;
  signed int tmp_post$7;
  if(threadsinfo_p == ((struct threadsinfo *)NULL))
  {
    return_value___errno_location$1=__errno_location();
    return_value__thread_info_unlock$2=_thread_info_unlock("thread_del_bynum", *return_value___errno_location$1);
    return return_value__thread_info_unlock$2;
  }

  else
    if(thread_num >= threadsinfo_p->used)
    {
      return_value__thread_info_unlock$3=_thread_info_unlock("thread_del_bynum", 22);
      return return_value__thread_info_unlock$3;
    }

    else
    {
      struct threadinfo *threadinfo_p = &threadsinfo_p->threads[(signed long int)thread_num];
      threadinfo_p->state = (enum state_enum)STATE_EXIT;
      char **ptr = threadinfo_p->argv;
      if(!(ptr == ((char **)NULL)))
      {
        while(!(*ptr == ((char *)NULL)))
        {
          tmp_post$4 = ptr;
          ptr = ptr + 1l;
          free((void *)*tmp_post$4);
        }
        free((void *)threadinfo_p->argv);
      }

      if(thread_num == threadsinfo_p->used + -1)
      {
        threadsinfo_p->used = threadsinfo_p->used - 1;
        _debug(3, "thread_del_bynum", "thread_del_bynum(%i): there're %i threads left (#0).", thread_num, threadsinfo_p->used - threadsinfo_p->stacklen);
        signed int return_value__thread_info_unlock$5;
        return_value__thread_info_unlock$5=_thread_info_unlock("thread_del_bynum", 0);
        return return_value__thread_info_unlock$5;
      }

      struct threadinfo *t = &threadsinfo_p->threads[(signed long int)(threadsinfo_p->used - 1)];
      if((signed int)t->state == STATE_EXIT)
      {
        threadsinfo_p->used = threadsinfo_p->used - 1;
        _debug(3, "thread_del_bynum", "%i [%p] -> %i [%p]; left: %i", threadsinfo_p->used, t->pthread, thread_num, threadinfo_p->pthread, threadsinfo_p->used - threadsinfo_p->stacklen);
        memcpy((void *)threadinfo_p, (const void *)t, sizeof(struct threadinfo) /*112ul*/ );
      }

      else
      {
        if(threadsinfo_p->stacklen >= threadsinfo_p->allocated)
        {
          _error("thread_del_bynum", "Threads metadata structures pointers stack overflowed!");
          signed int return_value__thread_info_unlock$6;
          return_value__thread_info_unlock$6=_thread_info_unlock("thread_del_bynum", 22);
          return return_value__thread_info_unlock$6;
        }

        tmp_post$7 = threadsinfo_p->stacklen;
        threadsinfo_p->stacklen = threadsinfo_p->stacklen + 1;
        threadsinfo_p->threadsstack[(signed long int)tmp_post$7] = threadinfo_p;
      }
      _debug(3, "thread_del_bynum", "thread_del_bynum(%i): there're %i threads left (#1).", thread_num, threadsinfo_p->used - threadsinfo_p->stacklen);
      signed int return_value__thread_info_unlock$8;
      return_value__thread_info_unlock$8=_thread_info_unlock("thread_del_bynum", 0);
      return return_value__thread_info_unlock$8;
    }
}

// thread_exit
// file sync.c line 552
static inline signed int thread_exit(struct threadinfo *threadinfo_p, signed int exitcode)
{
  signed int err = 0;
  threadinfo_p->exitcode = exitcode;
  if(!(threadinfo_p->callback == ((signed int (*)(struct ctx *, struct thread_callbackfunct_arg *))NULL)))
  {
    if(threadinfo_p->ctx_p->flags[100l] >= 3)
    {
      _debug(3, "thread_exit", "thread %p, argv: ", threadinfo_p->pthread);
      char **thread_exit$$1$$1$$1$$argv = threadinfo_p->argv;
      for( ; !(*thread_exit$$1$$1$$1$$argv == ((char *)NULL)); thread_exit$$1$$1$$1$$argv = thread_exit$$1$$1$$1$$argv + 1l)
        _debug(3, "thread_exit", "\t%p == %s", *thread_exit$$1$$1$$1$$argv, *thread_exit$$1$$1$$1$$argv);
    }

    err=threadinfo_p->callback(threadinfo_p->ctx_p, threadinfo_p->callback_arg);
    if(!(err == 0))
    {
      char *return_value_strerror$1;
      return_value_strerror$1=strerror(err);
      _error("thread_exit", "Got error from callback function.", return_value_strerror$1, err);
      threadinfo_p->errcode = err;
    }

  }

  threadinfo_p->state = (enum state_enum)STATE_TERM;
  _debug(3, "thread_exit", "thread %p is sending signal to sighandler to call GC", threadinfo_p->pthread);
  signed int return_value_pthread_kill$2;
  return_value_pthread_kill$2=pthread_kill(pthread_sighandler, 10);
  return return_value_pthread_kill$2;
}

// thread_gc
// file sync.c line 365
signed int thread_gc(struct ctx *ctx_p)
{
  signed int thread_num;
  signed long int tm;
  tm=time((signed long int *)(void *)0);
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  _debug(3, "thread_gc", "tm == %i; thread %p", tm, return_value_pthread_self$1);
  signed int *return_value___errno_location$2;
  signed int return_value__thread_info_unlock$3;
  signed int *return_value___errno_location$9;
  if(ctx_p->flags[112l] == 0)
    return 0;

  else
  {
    struct threadsinfo *threadsinfo_p;
    threadsinfo_p=_thread_info_lock("thread_gc");
    if(threadsinfo_p == ((struct threadsinfo *)NULL))
    {
      return_value___errno_location$2=__errno_location();
      return_value__thread_info_unlock$3=_thread_info_unlock("thread_gc", *return_value___errno_location$2);
      return return_value__thread_info_unlock$3;
    }

    else
    {
      _debug(2, "thread_gc", "There're %i threads.", threadsinfo_p->used);
      thread_num = -1;
      do
      {
        thread_num = thread_num + 1;
        if(thread_num >= threadsinfo_p->used)
          break;

        signed int err;
        struct threadinfo *threadinfo_p = &threadsinfo_p->threads[(signed long int)thread_num];
        _debug(3, "thread_gc", "Trying thread #%i (==%i) (state: %i; expire at: %i, now: %i, exitcode: %i, errcode: %i; i_p: %p; p: %p).", thread_num, threadinfo_p->thread_num, threadinfo_p->state, threadinfo_p->expiretime, tm, threadinfo_p->exitcode, threadinfo_p->errcode, threadinfo_p, threadinfo_p->pthread);
        if(!((signed int)threadinfo_p->state == STATE_EXIT))
        {
          if(!(threadinfo_p->expiretime == 0l))
          {
            if(tm >= threadinfo_p->expiretime)
            {
              signed int return_value_pthread_tryjoin_np$5;
              return_value_pthread_tryjoin_np$5=pthread_tryjoin_np(threadinfo_p->pthread, (void **)(void *)0);
              if(!(return_value_pthread_tryjoin_np$5 == 0))
              {
                _error("thread_gc", "Debug3: thread_gc(): Thread #%i is alive too long: %lu <= %lu (started at %lu)", thread_num, threadinfo_p->expiretime, tm, threadinfo_p->starttime);
                signed int return_value__thread_info_unlock$4;
                return_value__thread_info_unlock$4=_thread_info_unlock("thread_gc", 62);
                return return_value__thread_info_unlock$4;
              }

            }

          }

          if(!((signed int)threadinfo_p->state == STATE_TERM))
            _debug(3, "thread_gc", "Thread #%i is busy, skipping (#0).", thread_num);

          else
          {
            _debug(3, "thread_gc", "Trying to join thread #%i: %p", thread_num, threadinfo_p->pthread);
            err=pthread_join(threadinfo_p->pthread, (void **)(void *)0);
            if(err == 0 || err == 22 || err == 35)
            {
              _debug(3, "thread_gc", "Thread #%i is finished with exitcode %i (errcode %i), deleting. threadinfo_p == %p", thread_num, threadinfo_p->exitcode, threadinfo_p->errcode, threadinfo_p);
              goto __CPROVER_DUMP_L16;
            }

            char *return_value_strerror$6;
            return_value_strerror$6=strerror(err);
            _error("thread_gc", "Got error while pthread_join() or pthread_tryjoin_np().", return_value_strerror$6, err);
            signed int *return_value___errno_location$7;
            return_value___errno_location$7=__errno_location();
            signed int return_value__thread_info_unlock$8;
            return_value__thread_info_unlock$8=_thread_info_unlock("thread_gc", *return_value___errno_location$7);
            return return_value__thread_info_unlock$8;

          __CPROVER_DUMP_L16:
            ;
            if(!(threadinfo_p->errcode == 0))
            {
              _error("thread_gc", "Got error from thread #%i: errcode %i.", thread_num, threadinfo_p->errcode);
              _thread_info_unlock("thread_gc", 0);
              thread_del_bynum(thread_num);
              return threadinfo_p->errcode;
            }

            _thread_info_unlock("thread_gc", 0);
            signed int return_value_thread_del_bynum$10;
            return_value_thread_del_bynum$10=thread_del_bynum(thread_num);
            if(!(return_value_thread_del_bynum$10 == 0))
            {
              return_value___errno_location$9=__errno_location();
              return *return_value___errno_location$9;
            }

            _thread_info_lock("thread_gc");
          }
        }

      }
      while((_Bool)1);
      _debug(3, "thread_gc", "There're %i threads left.", threadsinfo_p->used - threadsinfo_p->stacklen);
      signed int return_value__thread_info_unlock$11;
      return_value__thread_info_unlock$11=_thread_info_unlock("thread_gc", 0);
      return return_value__thread_info_unlock$11;
    }
  }
}

// thread_info
// file sync.c line 180
extern struct threadsinfo * thread_info()
{
  static struct threadsinfo threadsinfo = { .mutex={ { .__data={ .__lock=0, .__count=0u, .__owner=0, .__nusers=0u, .__kind=0,
    .__spins=0, .__elision=0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } },
    { .__data={ .__lock=0, .__count=0u, .__owner=0, .__nusers=0u, .__kind=0,
    .__spins=0, .__elision=0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } },
    { .__data={ .__lock=0, .__count=0u, .__owner=0, .__nusers=0u, .__kind=0,
    .__spins=0, .__elision=0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } } }, .cond={ { .__data={ .__lock=0, .__futex=0u, .__total_seq=0ull, .__wakeup_seq=0ull,
    .__woken_seq=0ull, .__mutex=NULL,
    .__nwaiters=0u, .__broadcast_seq=0u } },
    { .__data={ .__lock=0, .__futex=0u, .__total_seq=0ull, .__wakeup_seq=0ull,
    .__woken_seq=0ull, .__mutex=NULL,
    .__nwaiters=0u, .__broadcast_seq=0u } },
    { .__data={ .__lock=0, .__futex=0u, .__total_seq=0ull, .__wakeup_seq=0ull,
    .__woken_seq=0ull, .__mutex=NULL,
    .__nwaiters=0u, .__broadcast_seq=0u } } },
    .mutex_init=(char)0,
    .allocated=0, .used=0, .threads=((struct threadinfo *)NULL),
    .threadsstack=((struct threadinfo **)NULL),
    .stacklen=0 };
  if(threadsinfo.mutex_init == 0)
  {
    signed int i = 0;
    while(!(i >= 3))
    {
      signed int return_value_pthread_mutex_init$1;
      return_value_pthread_mutex_init$1=pthread_mutex_init(&threadsinfo.mutex[(signed long int)i], (const union anonymous$0 *)(void *)0);
      if(!(return_value_pthread_mutex_init$1 == 0))
      {
        _error("thread_info", "Cannot pthread_mutex_init().");
        return (struct threadsinfo *)(void *)0;
      }

      signed int return_value_pthread_cond_init$2;
      return_value_pthread_cond_init$2=pthread_cond_init(&threadsinfo.cond[(signed long int)i], (const union anonymous$0 *)(void *)0);
      if(!(return_value_pthread_cond_init$2 == 0))
      {
        _error("thread_info", "Cannot pthread_cond_init().");
        return (struct threadsinfo *)(void *)0;
      }

      i = i + 1;
    }
    threadsinfo.mutex_init = threadsinfo.mutex_init + 1;
  }

  return &threadsinfo;
}

// thread_new
// file sync.c line 273
struct threadinfo * thread_new()
{
  struct threadsinfo *threadsinfo_p;
  threadsinfo_p=_thread_info_lock("thread_new");
  signed int tmp_post$3;
  if(threadsinfo_p == ((struct threadsinfo *)NULL))
  {
    _thread_info_unlock("thread_new", 0);
    return (struct threadinfo *)(void *)0;
  }

  else
  {
    signed int thread_num;
    struct threadinfo *threadinfo_p;
    if(!(threadsinfo_p->stacklen == 0))
    {
      threadsinfo_p->stacklen = threadsinfo_p->stacklen - 1;
      threadinfo_p = threadsinfo_p->threadsstack[(signed long int)threadsinfo_p->stacklen];
      thread_num = threadinfo_p->thread_num;
    }

    else
    {
      if(threadsinfo_p->used >= threadsinfo_p->allocated)
      {
        threadsinfo_p->allocated = threadsinfo_p->allocated + (1 << 10);
        _debug(2, "thread_new", "Reallocated memory for threadsinfo -> %i.", threadsinfo_p->allocated);
        void *return_value_xrealloc$1;
        return_value_xrealloc$1=xrealloc((void *)(char *)threadsinfo_p->threads, sizeof(struct threadinfo) /*112ul*/  * (unsigned long int)(threadsinfo_p->allocated + 2));
        threadsinfo_p->threads = (struct threadinfo *)return_value_xrealloc$1;
        void *return_value_xrealloc$2;
        return_value_xrealloc$2=xrealloc((void *)(char *)threadsinfo_p->threadsstack, sizeof(struct threadinfo *) /*8ul*/  * (unsigned long int)(threadsinfo_p->allocated + 2));
        threadsinfo_p->threadsstack = (struct threadinfo **)return_value_xrealloc$2;
      }

      tmp_post$3 = threadsinfo_p->used;
      threadsinfo_p->used = threadsinfo_p->used + 1;
      thread_num = tmp_post$3;
      threadinfo_p = &threadsinfo_p->threads[(signed long int)thread_num];
    }
    memset((void *)threadinfo_p, 0, sizeof(struct threadinfo) /*112ul*/ );
    threadinfo_p->thread_num = thread_num;
    threadinfo_p->state = (enum state_enum)STATE_RUNNING;
    _debug(2, "thread_new", "thread_new -> thread_num: %i; used: %i", thread_num, threadsinfo_p->used);
    _thread_info_unlock("thread_new", 0);
    return threadinfo_p;
  }
}

// thread_nextexpiretime
// file sync.c line 242
extern signed long int thread_nextexpiretime()
{
  signed long int nextexpiretime = (signed long int)0;
  struct threadsinfo *threadsinfo_p;
  threadsinfo_p=_thread_info_lock("thread_nextexpiretime");
  signed int return_value__thread_info_unlock$1;
  signed int tmp_post$2;
  signed long int tmp_if_expr$3;
  if(threadsinfo_p == ((struct threadsinfo *)NULL))
  {
    return_value__thread_info_unlock$1=_thread_info_unlock("thread_nextexpiretime", 0);
    return (signed long int)return_value__thread_info_unlock$1;
  }

  else
  {
    signed int thread_num = threadsinfo_p->used;
    do
    {
      tmp_post$2 = thread_num;
      thread_num = thread_num - 1;
      if(tmp_post$2 == 0)
        break;

      struct threadinfo *threadinfo_p = &threadsinfo_p->threads[(signed long int)thread_num];
      _debug(3, "thread_nextexpiretime", "threadsinfo_p->threads[%i].state == %i;\tthreadsinfo_p->threads[%i].pthread == %p;\tthreadsinfo_p->threads[%i].expiretime == %i", thread_num, threadinfo_p->state, thread_num, threadinfo_p->pthread, thread_num, threadinfo_p->expiretime);
      if(!((signed int)threadinfo_p->state == STATE_EXIT))
      {
        if(!(threadinfo_p->expiretime == 0l))
        {
          if(!(nextexpiretime == 0l))
          {
            if(!(nextexpiretime >= threadinfo_p->expiretime))
              tmp_if_expr$3 = nextexpiretime;

            else
              tmp_if_expr$3 = threadinfo_p->expiretime;
            nextexpiretime = tmp_if_expr$3;
          }

          else
            nextexpiretime = threadinfo_p->expiretime;
        }

      }

    }
    while((_Bool)1);
    _thread_info_unlock("thread_nextexpiretime", 0);
    _debug(3, "thread_nextexpiretime", "nextexpiretime == %i", nextexpiretime);
    return nextexpiretime;
  }
}

// threads_foreach
// file sync.c line 221
extern signed int threads_foreach(signed int (*funct)(struct threadinfo *, void *), enum state_enum state, void *arg)
{
  signed int i;
  signed int rc;
  struct threadsinfo *threadsinfo_p;
  threadsinfo_p=_thread_info_lock("threads_foreach");
  signed int return_value__thread_info_unlock$1;
  signed int tmp_post$2;
  _Bool tmp_if_expr$3;
  if(threadsinfo_p == ((struct threadsinfo *)NULL))
  {
    return_value__thread_info_unlock$1=_thread_info_unlock("threads_foreach", 22);
    return return_value__thread_info_unlock$1;
  }

  else
  {
    rc = 0;
    i = 0;
    while(!(i >= threadsinfo_p->used))
    {
      struct threadinfo *threadinfo_p;
      tmp_post$2 = i;
      i = i + 1;
      threadinfo_p = &threadsinfo_p->threads[(signed long int)tmp_post$2];
      if((signed int)state == STATE_UNKNOWN)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = threadinfo_p->state == state ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
      {
        rc=funct(threadinfo_p, arg);
        if(!(rc == 0))
          break;

      }

    }
    signed int return_value__thread_info_unlock$4;
    return_value__thread_info_unlock$4=_thread_info_unlock("threads_foreach", rc);
    return return_value__thread_info_unlock$4;
  }
}

// version
// file main.c line 485
signed int version()
{
  _info("version", "clsync v%i.%i.%i-release\n\tDmitry Yu Okunev <dyokunev@ut.mephi.ru> 0x8E30679C\n\nCompiled with options -D_DEBUG_SUPPORT -DINOTIFY_SUPPORT -DGIO_SUPPORT -DBACKTRACE_SUPPORT -DGETMNTENT_SUPPORT -DUNSHARE_SUPPORT -DPIVOTROOT_OPT_SUPPORT -DHL_LOCKS", 0, 4, 1);
  exit(0);
}

// vprintf_stderr
// file error.c line 70
static signed int vprintf_stderr(const char *fmt, void **args)
{
  signed int return_value_vfprintf$1;
  return_value_vfprintf$1=vfprintf(stderr, fmt, args);
  return return_value_vfprintf$1;
}

// vprintf_stdout
// file error.c line 74
static signed int vprintf_stdout(const char *fmt, void **args)
{
  signed int return_value_vfprintf$1;
  return_value_vfprintf$1=vfprintf(stdout, fmt, args);
  return return_value_vfprintf$1;
}

// vsyslog_buf
// file error.c line 93
static signed int vsyslog_buf(const char *fmt, void **args)
{
  signed int len;
  unsigned long int size = (unsigned long int)(1 << 16) - _syslog_buffer_filled;
  if(size == 0ul)
    return 0;

  else
  {
    len=vsnprintf(&_syslog_buffer[(signed long int)_syslog_buffer_filled], size, fmt, args);
    if(len >= 1)
    {
      _syslog_buffer_filled = _syslog_buffer_filled + (unsigned long int)len;
      if(_syslog_buffer_filled >= 65537ul)
        _syslog_buffer_filled = (unsigned long int)(1 << 16);

    }

    return 0;
  }
}

// waitpid_timed
// file main.c line 391
signed int waitpid_timed(signed int child_pid, signed int *status_p, signed long int sec, signed long int nsec)
{
  struct timespec ts;
  signed int status;
  ts.tv_sec = sec;
  ts.tv_nsec = nsec;
  while(ts.tv_sec >= 0l)
  {
    signed int return_value_waitpid$2;
    return_value_waitpid$2=waitpid(child_pid, &status, 1);
    if(!(return_value_waitpid$2 >= 0))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      if(*return_value___errno_location$1 == 10)
        return child_pid;

      return -1;
    }

    else
      if(!(status_p == ((signed int *)NULL)))
        *status_p = status;

    ts.tv_nsec = ts.tv_nsec - (signed long int)(30 * 1000 * 1000);
    if(!(ts.tv_nsec >= 0l))
    {
      ts.tv_nsec = ts.tv_nsec + (signed long int)(1000 * 1000 * 1000);
      ts.tv_sec = ts.tv_sec - 1l;
    }

  }
  return 0;
}

// xcalloc
// file malloc.h line 23
extern void * xcalloc(unsigned long int nmemb, unsigned long int size)
{
  nmemb = nmemb + 1ul;
  size = size + 1ul;
  void *ret;
  ret=calloc(nmemb, size);
  if(ret == NULL)
    _critical("xcalloc", "(%li): Cannot allocate memory.", size);

  return ret;
}

// xmalloc
// file malloc.h line 22
extern void * xmalloc(unsigned long int size)
{
  size = size + 1ul;
  void *ret;
  ret=malloc(size);
  if(ret == NULL)
    _critical("xmalloc", "(%li): Cannot allocate memory.", size);

  memset(ret, 0, size);
  return ret;
}

// xrealloc
// file malloc.h line 24
extern void * xrealloc(void *oldptr, unsigned long int size)
{
  size = size + 1ul;
  void *ret;
  ret=realloc(oldptr, size);
  if(ret == NULL)
    _critical("xrealloc", "(%p, %li): Cannot reallocate memory.", oldptr, size);

  return ret;
}

// xstrtol
// file main.c line 819
static inline signed long int xstrtol(const char *str, signed int *err)
{
  signed long int res;
  char *endptr;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 0;
  res=strtol(str, &endptr, 0);
  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  _Bool tmp_if_expr$3;
  if(!(*return_value___errno_location$2 == 0))
    tmp_if_expr$3 = (_Bool)1;

  else
    tmp_if_expr$3 = *endptr != 0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$3)
  {
    _error("xstrtol", "argument \"%s\" can't be parsed as a number", str);
    *err = 22;
  }

  return res;
}

