// #anon_enum_A2_GR_FULL=1_A2_GR_LORES=2_A2_GR_HIRES=4
// file apple2.h line 24
enum anonymous_53 { A2_GR_FULL=1, A2_GR_LORES=2, A2_GR_HIRES=4 };

// #anon_enum_XrmoptionNoArg=0_XrmoptionIsArg=1_XrmoptionStickyArg=2_XrmoptionSepArg=3_XrmoptionResArg=4_XrmoptionSkipArg=5_XrmoptionSkipLine=6_XrmoptionSkipNArgs=7
// file /usr/include/X11/Xresource.h line 326
enum anonymous_40 { XrmoptionNoArg=0, XrmoptionIsArg=1, XrmoptionStickyArg=2, XrmoptionSepArg=3, XrmoptionResArg=4, XrmoptionSkipArg=5, XrmoptionSkipLine=6, XrmoptionSkipNArgs=7 };

// #anon_enum_XtGeometryYes=0_XtGeometryNo=1_XtGeometryAlmost=2_XtGeometryDone=3
// file /usr/include/X11/Intrinsic.h line 340
enum anonymous_50 { XtGeometryYes=0, XtGeometryNo=1, XtGeometryAlmost=2, XtGeometryDone=3 };

// #anon_enum_XtGrabNone=0_XtGrabNonexclusive=1_XtGrabExclusive=2
// file /usr/include/X11/Intrinsic.h line 347
enum anonymous_51 { XtGrabNone=0, XtGrabNonexclusive=1, XtGrabExclusive=2 };

// tag-#anon#ST[*{S8}_S8_'name'|S64'value']
// file /usr/include/X11/Intrinsic.h line 316
struct anonymous_45;

// tag-#anon#ST[*{S8}_S8_'option'|*{S8}_S8_'specifier'|SYM##anon_enum_XrmoptionNoArg=0_XrmoptionIsArg=1_XrmoptionStickyArg=2_XrmoptionSepArg=3_XrmoptionResArg=4_XrmoptionSkipArg=5_XrmoptionSkipLine=6_XrmoptionSkipNArgs=7#'argKind'|U32'_pad0'|*{S8}_S8_'value']
// file /usr/include/X11/Xresource.h line 338
struct anonymous_39;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visual'|U64'visualid'|S32'screen'|S32'depth'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'colormap_size'|S32'bits_per_rgb']
// file /usr/include/X11/Xutil.h line 287
struct anonymous_3;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']
// file /usr/include/X11/Xlib.h line 257
struct anonymous_9;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XPrivate#}_SYM#tag-_XPrivate#_'private1'|S32'fd'|S32'private2'|S32'proto_major_version'|S32'proto_minor_version'|*{S8}_S8_'vendor'|U64'private3'|U64'private4'|U64'private5'|S32'private6'|U32'_pad0'|*{U64(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->U64}_U64(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->U64_'resource_alloc'|S32'byte_order'|S32'bitmap_unit'|S32'bitmap_pad'|S32'bitmap_bit_order'|S32'nformats'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|S32'depth'|S32'bits_per_pixel'|S32'scanline_pad'|U32'_pad0']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|S32'depth'|S32'bits_per_pixel'|S32'scanline_pad'|U32'_pad0']#_'pixmap_format'|S32'private8'|S32'release'|*{SYM#tag-_XPrivate#}_SYM#tag-_XPrivate#_'private9'|*{SYM#tag-_XPrivate#}_SYM#tag-_XPrivate#_'private10'|S32'qlen'|U32'_pad2'|U64'last_request_read'|U64'request'|*{S8}_S8_'private11'|*{S8}_S8_'private12'|*{S8}_S8_'private13'|*{S8}_S8_'private14'|U32'max_request_size'|U32'_pad3'|*{SYM#tag-_XrmHashBucketRec#}_SYM#tag-_XrmHashBucketRec#_'db'|*{S32(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->S32}_S32(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->S32_'private15'|*{S8}_S8_'display_name'|S32'default_screen'|S32'nscreens'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']#_'screens'|U64'motion_buffer'|U64'private16'|S32'min_keycode'|S32'max_keycode'|*{S8}_S8_'private17'|*{S8}_S8_'private18'|S32'private19'|U32'_pad4'|*{S8}_S8_'xdefaults']
// file /usr/include/X11/Xlib.h line 493
struct anonymous_63;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|S32'depth'|S32'bits_per_pixel'|S32'scanline_pad'|U32'_pad0']
// file /usr/include/X11/Xlib.h line 280
struct anonymous_62;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'fid'|U32'direction'|U32'min_char_or_byte2'|U32'max_char_or_byte2'|U32'min_byte1'|U32'max_byte1'|S32'all_chars_exist'|U32'default_char'|S32'n_properties'|*{SYM#tag-#anon#ST[U64'name'|U64'card32']#}_SYM#tag-#anon#ST[U64'name'|U64'card32']#_'properties'|SYM#tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']#'min_bounds'|SYM#tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']#'max_bounds'|*{SYM#tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']#}_SYM#tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']#_'per_char'|S32'ascent'|S32'descent']
// file /usr/include/X11/Xlib.h line 1035
struct anonymous_59;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']
// file /usr/include/X11/Xlib.h line 227
struct anonymous_5;

// tag-#anon#ST[*{V(*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']#_|U64|U64|*{cS8}_cS8_|*{SYM#tag-#anon#ST[S16'x'|S16'y'|U16'width'|U16'height']#}_SYM#tag-#anon#ST[S16'x'|S16'y'|U16'width'|U16'height']#_|*{V}_V_)->V}_V(*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']#_|U64|U64|*{cS8}_cS8_|*{SYM#tag-#anon#ST[S16'x'|S16'y'|U16'width'|U16'height']#}_SYM#tag-#anon#ST[S16'x'|S16'y'|U16'width'|U16'height']#_|*{V}_V_)->V_'callback'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']#_'screen'|U64'window'|U64'drawable'|*{V}_V_'closure'|*{SYM#tag-_IO_FILE#}_SYM#tag-_IO_FILE#_'read_pipe'|*{SYM#tag-_IO_FILE#}_SYM#tag-_IO_FILE#_'write_pipe'|U64'pipe_id'|S32'pid'|U32'_pad0']
// file grabclient.c line 311
struct anonymous_64;

// tag-#anon#ST[ARR16{S64}_S64_'__fds_bits']
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_6;

// tag-#anon#ST[BF{U32}_U32_'bold'|BF{U32}_U32_'blink'|BF{U32}_U32_'rev'|BF{U5}_U5_'_bit_field_pad0'|U24'_pad0']
// file apple2-main.c line 804
struct anonymous_42;

// tag-#anon#ST[S16'lbearing'|S16'rbearing'|S16'width'|S16'ascent'|S16'descent'|U16'attributes']
// file /usr/include/X11/Xlib.h line 1017
struct anonymous_0;

// tag-#anon#ST[S16'x'|S16'y'|U16'width'|U16'height']
// file /usr/include/X11/Xlib.h line 430
struct anonymous_54;

// tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}_V_'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_52;

// tag-#anon#ST[S32'depth'|S32'bits_per_pixel'|S32'scanline_pad']
// file /usr/include/X11/Xlib.h line 171
struct anonymous_2;

// tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']
// file /usr/include/X11/Xlib.h line 243
struct anonymous_69;

// tag-#anon#ST[S32'function'|U32'_pad0'|U64'plane_mask'|U64'foreground'|U64'background'|S32'line_width'|S32'line_style'|S32'cap_style'|S32'join_style'|S32'fill_style'|S32'fill_rule'|S32'arc_mode'|U32'_pad1'|U64'tile'|U64'stipple'|S32'ts_x_origin'|S32'ts_y_origin'|U64'font'|S32'subwindow_mode'|S32'graphics_exposures'|S32'clip_x_origin'|S32'clip_y_origin'|U64'clip_mask'|S32'dash_offset'|S8'dashes'|U24'_pad2']
// file /usr/include/X11/Xlib.h line 181
struct anonymous_58;

// tag-#anon#ST[S32'index'|U32'_pad0'|F64'value']
// file analogtv.h line 222
struct anonymous_61;

// tag-#anon#ST[S32'max_keypermod'|U32'_pad0'|*{U8}_U8_'modifiermap']
// file /usr/include/X11/Xlib.h line 475
struct anonymous_68;

// tag-#anon#ST[S32'type'|U32'_pad0'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'resourceid'|U64'serial'|U8'error_code'|U8'request_code'|U8'minor_code'|U40'_pad1']
// file /usr/include/X11/Xlib.h line 924
struct anonymous_7;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|S32'extension'|S32'evtype']
// file /usr/include/X11/Xlib.h line 948
struct anonymous_38;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|S32'extension'|S32'evtype'|U32'cookie'|U32'_pad2'|*{V}_V_'data']
// file /usr/include/X11/Xlib.h line 958
struct anonymous_41;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'drawable'|S32'major_code'|S32'minor_code']
// file /usr/include/X11/Xlib.h line 686
struct anonymous_14;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'drawable'|S32'x'|S32'y'|S32'width'|S32'height'|S32'count'|S32'major_code'|S32'minor_code'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 673
struct anonymous_13;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window']
// file /usr/include/X11/Xlib.h line 718
struct anonymous_18;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|S32'from_configure'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 727
struct anonymous_19;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|S32'override_redirect'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 737
struct anonymous_20;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|S32'place'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 816
struct anonymous_28;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|S32'x'|S32'y']
// file /usr/include/X11/Xlib.h line 782
struct anonymous_24;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|S32'x'|S32'y'|S32'width'|S32'height'|S32'border_width'|U32'_pad2'|U64'above'|S32'override_redirect'|U32'_pad3']
// file /usr/include/X11/Xlib.h line 768
struct anonymous_23;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'event'|U64'window'|U64'parent'|S32'x'|S32'y'|S32'override_redirect'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 756
struct anonymous_22;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'owner'|U64'requestor'|U64'selection'|U64'target'|U64'property'|U64'time']
// file /usr/include/X11/Xlib.h line 857
struct anonymous_33;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'parent'|U64'window']
// file /usr/include/X11/Xlib.h line 747
struct anonymous_21;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'parent'|U64'window'|S32'place'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 826
struct anonymous_29;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'parent'|U64'window'|S32'x'|S32'y'|S32'width'|S32'height'|S32'border_width'|S32'override_redirect']
// file /usr/include/X11/Xlib.h line 705
struct anonymous_17;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'parent'|U64'window'|S32'x'|S32'y'|S32'width'|S32'height'|S32'border_width'|U32'_pad2'|U64'above'|S32'detail'|U32'_pad3'|U64'value_mask']
// file /usr/include/X11/Xlib.h line 801
struct anonymous_27;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'requestor'|U64'selection'|U64'target'|U64'property'|U64'time']
// file /usr/include/X11/Xlib.h line 870
struct anonymous_34;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window']
// file /usr/include/X11/Xlib.h line 934
struct anonymous_37;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|ARR32{S8}_S8_'key_vector']
// file /usr/include/X11/Xlib.h line 653
struct anonymous_8;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|S32'mode'|S32'detail']
// file /usr/include/X11/Xlib.h line 634
struct anonymous_49;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|S32'request'|S32'first_keycode'|S32'count'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 912
struct anonymous_36;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|S32'state'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 696
struct anonymous_15;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|S32'width'|S32'height']
// file /usr/include/X11/Xlib.h line 792
struct anonymous_25;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|S32'x'|S32'y'|S32'width'|S32'height'|S32'count'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 662
struct anonymous_10;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'atom'|U64'time'|S32'state'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 836
struct anonymous_31;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'colormap'|S32'new'|S32'state']
// file /usr/include/X11/Xlib.h line 882
struct anonymous_35;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'message_type'|S32'format'|U32'_pad2'|SYM#tag-#anon#UN[ARR20{S8}_S8_'b'|ARR10{S16}_S16_'s'|ARR5{S64}_S64_'l']#'data']
// file /usr/include/X11/Xlib.h line 897
struct anonymous_66;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'root'|U64'subwindow'|U64'time'|S32'x'|S32'y'|S32'x_root'|S32'y_root'|S32'mode'|S32'detail'|S32'same_screen'|S32'focus'|U32'state'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 610
struct anonymous_48;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'root'|U64'subwindow'|U64'time'|S32'x'|S32'y'|S32'x_root'|S32'y_root'|U32'state'|S8'is_hint'|U24'_pad2'|S32'same_screen'|U32'_pad3']
// file /usr/include/X11/Xlib.h line 593
struct anonymous_47;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'root'|U64'subwindow'|U64'time'|S32'x'|S32'y'|S32'x_root'|S32'y_root'|U32'state'|U32'button'|S32'same_screen'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 575
struct anonymous_46;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'root'|U64'subwindow'|U64'time'|S32'x'|S32'y'|S32'x_root'|S32'y_root'|U32'state'|U32'keycode'|S32'same_screen'|U32'_pad2']
// file /usr/include/X11/Xlib.h line 557
struct anonymous_26;

// tag-#anon#ST[S32'type'|U32'_pad0'|U64'serial'|S32'send_event'|U32'_pad1'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'window'|U64'selection'|U64'time']
// file /usr/include/X11/Xlib.h line 847
struct anonymous_32;

// tag-#anon#ST[S32'x'|S32'y'|S32'width'|S32'height'|S32'border_width'|S32'depth'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visual'|U64'root'|S32'class'|S32'bit_gravity'|S32'win_gravity'|S32'backing_store'|U64'backing_planes'|U64'backing_pixel'|S32'save_under'|U32'_pad0'|U64'colormap'|S32'map_installed'|S32'map_state'|S64'all_event_masks'|S64'your_event_mask'|S64'do_not_propagate_mask'|S32'override_redirect'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'|U64'root'|S32'width'|S32'height'|S32'mwidth'|S32'mheight'|S32'ndepths'|U32'_pad0'|*{SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#}_SYM#tag-#anon#ST[S32'depth'|S32'nvisuals'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'visuals']#_'depths'|S32'root_depth'|U32'_pad1'|*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'|U64'visualid'|S32'class'|U32'_pad0'|U64'red_mask'|U64'green_mask'|U64'blue_mask'|S32'bits_per_rgb'|S32'map_entries']#_'root_visual'|*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'|U64'cmap'|U64'white_pixel'|U64'black_pixel'|S32'max_maps'|S32'min_maps'|S32'backing_store'|S32'save_unders'|S64'root_input_mask']#_'screen']
// file /usr/include/X11/Xlib.h line 308
struct anonymous_16;

// tag-#anon#ST[U32'request_mode'|S16'x'|S16'y'|U16'width'|U16'height'|U16'border_width'|U16'_pad0'|*{SYM#tag-_WidgetRec#}_SYM#tag-_WidgetRec#_'sibling'|S32'stack_mode'|U32'_pad1']
// file /usr/include/X11/Intrinsic.h line 212
struct anonymous_44;

// tag-#anon#ST[U32'size'|U32'_pad0'|*{S8}_S8_'addr']
// file /usr/include/X11/Xresource.h line 160
struct anonymous_1;

// tag-#anon#ST[U64'background_pixmap'|U64'background_pixel'|U64'border_pixmap'|U64'border_pixel'|S32'bit_gravity'|S32'win_gravity'|S32'backing_store'|U32'_pad0'|U64'backing_planes'|U64'backing_pixel'|S32'save_under'|U32'_pad1'|S64'event_mask'|S64'do_not_propagate_mask'|S32'override_redirect'|U32'_pad2'|U64'colormap'|U64'cursor']
// file /usr/include/X11/Xlib.h line 290
struct anonymous_60;

// tag-#anon#ST[U64'name'|U64'card32']
// file /usr/include/X11/Xlib.h line 1030
struct anonymous;

// tag-#anon#ST[U64'pixel'|U16'red'|U16'green'|U16'blue'|S8'flags'|S8'pad']
// file /usr/include/X11/Xlib.h line 410
struct anonymous_57;

// tag-#anon#ST[U64'shmseg'|S32'shmid'|U32'_pad0'|*{S8}_S8_'shmaddr'|S32'readOnly'|U32'_pad1']
// file /usr/include/X11/extensions/XShm.h line 50
struct anonymous_4;

// tag-#anon#ST[U8'byte1'|U8'byte2']
// file /usr/include/X11/Xlib.h line 1064
struct anonymous_11;

// tag-#anon#UN[ARR20{S8}_S8_'b'|ARR10{S16}_S16_'s'|ARR5{S64}_S64_'l']
// file /usr/include/X11/Xlib.h line 905
union anonymous_67;

// tag-#anon#UN[F32'f'|S32'i']
// file analogtv.c line 159
union anonymous_55;

// tag-#anon#UN[SYM#tag-#anon#ST[BF{U32}_U32_'bold'|BF{U32}_U32_'blink'|BF{U32}_U32_'rev'|BF{U5}_U5_'_bit_field_pad0'|U24'_pad0']#'bf'|S32'w']
// file apple2-main.c line 803
union anonymous_43;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}_V_'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']#'__data'|ARR48{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_30;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_12;

// tag-#anon#cST[*{c*{cS8}_cS8_}_c*{cS8}_cS8__'progtext'|S32'progstep'|U32'_pad0']
// file apple2-main.c line 1597
struct anonymous_56;

// tag-_CoreClassPart
// file /usr/include/X11/CoreP.h line 125
struct _CoreClassPart;

// tag-_CorePart
// file /usr/include/X11/CoreP.h line 72
struct _CorePart;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 156
struct _IO_marker;

// tag-_TranslationData
// file /usr/include/X11/Intrinsic.h line 170
struct _TranslationData;

// tag-_WidgetClassRec
// file /usr/include/X11/Intrinsic.h line 109
struct _WidgetClassRec;

// tag-_WidgetRec
// file /usr/include/X11/Intrinsic.h line 107
struct _WidgetRec;

// tag-_XComposeStatus
// file /usr/include/X11/Xutil.h line 231
struct _XComposeStatus;

// tag-_XDisplay
// file /usr/include/X11/Xlib.h line 255
struct _XDisplay;

// tag-_XEvent
// file /usr/include/X11/Xlib.h line 973
union _XEvent;

// tag-_XExtData
// file /usr/include/X11/Xlib.h line 148
struct _XExtData;

// tag-_XGC
// file /usr/include/X11/Xlib.h line 214
struct _XGC;

// tag-_XImage
// file /usr/include/X11/Xlib.h line 360
struct _XImage;

// tag-_XPrivate
// file /usr/include/X11/Xlib.h line 490
struct _XPrivate;

// tag-_XRegion
// file /usr/include/X11/Xutil.h line 273
struct _XRegion;

// tag-_XrmHashBucketRec
// file /usr/include/X11/Xlib.h line 491
struct _XrmHashBucketRec;

// tag-_XtActionsRec
// file /usr/include/X11/Intrinsic.h line 111
struct _XtActionsRec;

// tag-_XtAppStruct
// file /usr/include/X11/Intrinsic.h line 114
struct _XtAppStruct;

// tag-_XtCallbackRec
// file /usr/include/X11/Intrinsic.h line 329
struct _XtCallbackRec;

// tag-_XtEventRec
// file /usr/include/X11/Intrinsic.h line 112
struct _XtEventRec;

// tag-_XtResource
// file /usr/include/X11/Intrinsic.h line 354
struct _XtResource;

// tag-_XtStateRec
// file /usr/include/X11/IntrinsicP.h line 187
struct _XtStateRec;

// tag-_XtTMRec
// file /usr/include/X11/IntrinsicP.h line 189
struct _XtTMRec;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_io_thread_status
// file thread_util.h line 360
enum _io_thread_status { _io_thread_working=0, _io_thread_done=1, _io_thread_cancelled=2 };

// tag-_parallel_startup_type
// file thread_util.c line 534
struct _parallel_startup_type;

// tag-analogtv_font_s
// file analogtv.h line 89
struct analogtv_font_s;

// tag-analogtv_input_s
// file analogtv.h line 77
struct analogtv_input_s;

// tag-analogtv_reception_s
// file analogtv.h line 95
struct analogtv_reception_s;

// tag-analogtv_s
// file analogtv.h line 119
struct analogtv_s;

// tag-analogtv_thread_s
// file analogtv.c line 430
struct analogtv_thread_s;

// tag-analogtv_yiq_s
// file analogtv.h line 115
struct analogtv_yiq_s;

// tag-apple2_sim_s
// file apple2.h line 36
struct apple2_sim_s;

// tag-apple2_state
// file apple2.h line 20
struct apple2_state;

// tag-async_load_state
// file grabscreen.h line 53
struct async_load_state;

// tag-basic_controller_data
// file apple2-main.c line 1423
struct basic_controller_data;

// tag-fps_state
// file fps.h line 20
struct fps_state;

// tag-funcs
// file /usr/include/X11/Xlib.h line 376
struct funcs;

// tag-io_thread
// file thread_util.h line 365
struct io_thread;

// tag-ipc_perm
// file /usr/include/x86_64-linux-gnu/bits/ipc.h line 42
struct ipc_perm;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-shmid_ds
// file /usr/include/x86_64-linux-gnu/bits/shm.h line 49
struct shmid_ds;

// tag-slideshow_data_s
// file apple2-main.c line 510
struct slideshow_data_s;

// tag-state
// file apple2-main.c line 1794
struct state;

// tag-terminal_controller_data
// file apple2-main.c line 790
struct terminal_controller_data;

// tag-termios
// file /usr/include/pty.h line 24
struct termios;

// tag-text_data
// file textclient.h line 21
struct text_data;

// tag-threadpool
// file ./../utils/thread_util.h line 227
struct threadpool;

// tag-threadpool_class
// file ./../utils/thread_util.h line 277
struct threadpool_class;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-winsize
// file /usr/include/x86_64-linux-gnu/bits/ioctl-types.h line 27
struct winsize;

// tag-xscreensaver_function_table
// file screenhackI.h line 114
struct xscreensaver_function_table;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// MapNotify_event_p
// file screenhack.c line 256
static signed int MapNotify_event_p(struct _XDisplay *dpy, union _XEvent *event, char *window);
// VirtualRootWindowOfScreen
// file ./../utils/vroot.h line 87
static unsigned long int VirtualRootWindowOfScreen(struct anonymous_9 *screen);
// VirtualRootWindowOfScreen_link1
// file vroot.h line 87
static unsigned long int VirtualRootWindowOfScreen_link1(struct anonymous_9 *screen_link1);
// XAllocColor
// file /usr/include/X11/Xlib.h line 1958
extern signed int XAllocColor(struct _XDisplay *, unsigned long int, struct anonymous_57 *);
// XBell
// file /usr/include/X11/Xlib.h line 2010
extern signed int XBell(struct _XDisplay *, signed int);
// XChangeProperty
// file /usr/include/X11/Xlib.h line 2068
extern signed int XChangeProperty(struct _XDisplay *, unsigned long int, unsigned long int, unsigned long int, signed int, signed int, const unsigned char *, signed int);
// XChar2b_to_utf8
// file utf8wc.c line 306
extern char * XChar2b_to_utf8(const struct anonymous_11 *in, signed int *length_ret);
// XClearArea
// file /usr/include/X11/Xlib.h line 2145
extern signed int XClearArea(struct _XDisplay *, unsigned long int, signed int, signed int, unsigned int, unsigned int, signed int);
// XClearWindow
// file /usr/include/X11/Xlib.h line 2155
extern signed int XClearWindow(struct _XDisplay *, unsigned long int);
// XCreateColormap
// file /usr/include/X11/Xlib.h line 1552
extern unsigned long int XCreateColormap(struct _XDisplay *, unsigned long int, struct anonymous_5 *, signed int);
// XCreateGC
// file /usr/include/X11/Xlib.h line 1584
extern struct _XGC * XCreateGC(struct _XDisplay *, unsigned long int, unsigned long int, struct anonymous_58 *);
// XCreateImage
// file /usr/include/X11/Xlib.h line 1441
extern struct _XImage * XCreateImage(struct _XDisplay *, struct anonymous_5 *, unsigned int, signed int, signed int, char *, unsigned int, unsigned int, signed int, signed int);
// XCreatePixmap
// file /usr/include/X11/Xlib.h line 1597
extern unsigned long int XCreatePixmap(struct _XDisplay *, unsigned long int, unsigned int, unsigned int, unsigned int);
// XCreatePixmapFromBitmapData
// file /usr/include/X11/Xlib.h line 1611
extern unsigned long int XCreatePixmapFromBitmapData(struct _XDisplay *, unsigned long int, char *, unsigned int, unsigned int, unsigned long int, unsigned long int, unsigned int);
// XDrawImageString
// file /usr/include/X11/Xlib.h line 2322
extern signed int XDrawImageString(struct _XDisplay *, unsigned long int, struct _XGC *, signed int, signed int, const char *, signed int);
// XDrawString
// file /usr/include/X11/Xlib.h line 2404
extern signed int XDrawString(struct _XDisplay *, unsigned long int, struct _XGC *, signed int, signed int, const char *, signed int);
// XFillRectangle
// file /usr/include/X11/Xlib.h line 2489
extern signed int XFillRectangle(struct _XDisplay *, unsigned long int, struct _XGC *, signed int, signed int, unsigned int, unsigned int);
// XFree
// file /usr/include/X11/Xlib.h line 2516
extern signed int XFree(void *);
// XFreeColors
// file /usr/include/X11/Xlib.h line 2525
extern signed int XFreeColors(struct _XDisplay *, unsigned long int, unsigned long int *, signed int, unsigned long int);
// XFreeFont
// file /usr/include/X11/Xlib.h line 2542
extern signed int XFreeFont(struct _XDisplay *, struct anonymous_59 *);
// XFreeGC
// file /usr/include/X11/Xlib.h line 2561
extern signed int XFreeGC(struct _XDisplay *, struct _XGC *);
// XFreeModifiermap
// file /usr/include/X11/Xlib.h line 2566
extern signed int XFreeModifiermap(struct anonymous_68 *);
// XFreePixmap
// file /usr/include/X11/Xlib.h line 2570
extern signed int XFreePixmap(struct _XDisplay *, unsigned long int);
// XGetAtomName
// file /usr/include/X11/Xlib.h line 1500
extern char * XGetAtomName(struct _XDisplay *, unsigned long int);
// XGetGeometry
// file /usr/include/X11/Xlib.h line 2620
extern signed int XGetGeometry(struct _XDisplay *, unsigned long int, unsigned long int *, signed int *, signed int *, unsigned int *, unsigned int *, unsigned int *, unsigned int *);
// XGetImage
// file /usr/include/X11/Xlib.h line 1456
extern struct _XImage * XGetImage(struct _XDisplay *, unsigned long int, signed int, signed int, unsigned int, unsigned int, unsigned long int, signed int);
// XGetKeyboardMapping
// file /usr/include/X11/Xlib.h line 1700
extern unsigned long int * XGetKeyboardMapping(struct _XDisplay *, unsigned char, signed int, signed int *);
// XGetModifierMapping
// file /usr/include/X11/Xlib.h line 1423
extern struct anonymous_68 * XGetModifierMapping(struct _XDisplay *);
// XGetVisualInfo
// file /usr/include/X11/Xutil.h line 471
extern struct anonymous_3 * XGetVisualInfo(struct _XDisplay *, signed long int, struct anonymous_3 *, signed int *);
// XGetWindowAttributes
// file /usr/include/X11/Xlib.h line 2691
extern signed int XGetWindowAttributes(struct _XDisplay *, unsigned long int, struct anonymous_16 *);
// XGetWindowProperty
// file /usr/include/X11/Xlib.h line 2676
extern signed int XGetWindowProperty(struct _XDisplay *, unsigned long int, unsigned long int, signed long int, signed long int, signed int, unsigned long int, unsigned long int *, signed int *, unsigned long int *, unsigned long int *, unsigned char **);
// XIfEvent
// file /usr/include/X11/Xlib.h line 2753
extern signed int XIfEvent(struct _XDisplay *, union _XEvent *, signed int (*)(struct _XDisplay *, union _XEvent *, char *), char *);
// XInternAtom
// file /usr/include/X11/Xlib.h line 1536
extern unsigned long int XInternAtom(struct _XDisplay *, const char *, signed int);
// XListDepths
// file /usr/include/X11/Xlib.h line 1866
extern signed int * XListDepths(struct _XDisplay *, signed int, signed int *);
// XListPixmapFormats
// file /usr/include/X11/Xlib.h line 1862
extern struct anonymous_2 * XListPixmapFormats(struct _XDisplay *, signed int *);
// XLoadQueryFont
// file /usr/include/X11/Xlib.h line 1394
extern struct anonymous_59 * XLoadQueryFont(struct _XDisplay *, const char *);
// XLookupString
// file /usr/include/X11/Xutil.h line 534
extern signed int XLookupString(struct anonymous_26 *, char *, signed int, unsigned long int *, struct _XComposeStatus *);
// XNextEvent
// file /usr/include/X11/Xlib.h line 2841
extern signed int XNextEvent(struct _XDisplay *, union _XEvent *);
// XParseColor
// file /usr/include/X11/Xlib.h line 2850
extern signed int XParseColor(struct _XDisplay *, unsigned long int, const char *, struct anonymous_57 *);
// XParseGeometry
// file /usr/include/X11/Xlib.h line 2857
extern signed int XParseGeometry(const char *, signed int *, signed int *, unsigned int *, unsigned int *);
// XPending
// file /usr/include/X11/Xlib.h line 2881
extern signed int XPending(struct _XDisplay *);
// XPutImage
// file /usr/include/X11/Xlib.h line 2903
extern signed int XPutImage(struct _XDisplay *, unsigned long int, struct _XGC *, struct _XImage *, signed int, signed int, signed int, signed int, unsigned int, unsigned int);
// XQueryColors
// file /usr/include/X11/Xlib.h line 2963
extern signed int XQueryColors(struct _XDisplay *, unsigned long int, struct anonymous_57 *, signed int);
// XQueryTree
// file /usr/include/X11/Xlib.h line 3017
extern signed int XQueryTree(struct _XDisplay *, unsigned long int, unsigned long int *, unsigned long int *, unsigned long int **, unsigned int *);
// XSelectInput
// file /usr/include/X11/Xlib.h line 3129
extern signed int XSelectInput(struct _XDisplay *, unsigned long int, signed long int);
// XSetErrorHandler
// file /usr/include/X11/Xlib.h line 1848
extern signed int (*XSetErrorHandler(signed int (*)(struct _XDisplay *, struct anonymous_7 *)))(struct _XDisplay *, struct anonymous_7 *);
// XSetForeground
// file /usr/include/X11/Xlib.h line 3227
extern signed int XSetForeground(struct _XDisplay *, struct _XGC *, unsigned long int);
// XSetWindowBackground
// file /usr/include/X11/Xlib.h line 3333
extern signed int XSetWindowBackground(struct _XDisplay *, unsigned long int, unsigned long int);
// XSetWindowColormap
// file /usr/include/X11/Xlib.h line 3363
extern signed int XSetWindowColormap(struct _XDisplay *, unsigned long int, unsigned long int);
// XShmAttach
// file /usr/include/X11/extensions/XShm.h line 78
signed int XShmAttach(struct _XDisplay *, struct anonymous_4 *);
// XShmCreateImage
// file /usr/include/X11/extensions/XShm.h line 111
struct _XImage * XShmCreateImage(struct _XDisplay *, struct anonymous_5 *, unsigned int, signed int, char *, struct anonymous_4 *, unsigned int, unsigned int);
// XShmDetach
// file /usr/include/X11/extensions/XShm.h line 83
signed int XShmDetach(struct _XDisplay *, struct anonymous_4 *);
// XShmPutImage
// file /usr/include/X11/extensions/XShm.h line 88
signed int XShmPutImage(struct _XDisplay *, unsigned long int, struct _XGC *, struct _XImage *, signed int, signed int, signed int, signed int, unsigned int, unsigned int, signed int);
// XShmQueryExtension
// file /usr/include/X11/extensions/XShm.h line 59
signed int XShmQueryExtension(struct _XDisplay *);
// XSync
// file /usr/include/X11/Xlib.h line 3409
extern signed int XSync(struct _XDisplay *, signed int);
// XTextWidth
// file /usr/include/X11/Xlib.h line 3434
extern signed int XTextWidth(struct anonymous_59 *, const char *, signed int);
// XVisualIDFromVisual
// file /usr/include/X11/Xlib.h line 1728
extern unsigned long int XVisualIDFromVisual(struct anonymous_5 *);
// XmuPrintDefaultErrorMessage
// file ./../utils/xmu.h line 12
signed int XmuPrintDefaultErrorMessage(struct _XDisplay *, struct anonymous_7 *, struct _IO_FILE *);
// XrmGetResource
// file /usr/include/X11/Xresource.h line 223
extern signed int XrmGetResource(struct _XrmHashBucketRec *, const char *, const char *, char **, struct anonymous_1 *);
// XtAppAddInput
// file /usr/include/X11/Intrinsic.h line 996
extern unsigned long int XtAppAddInput(struct _XtAppStruct *, signed int, void *, void (*)(void *, signed int *, unsigned long int *), void *);
// XtAppAddTimeOut
// file /usr/include/X11/Intrinsic.h line 978
extern unsigned long int XtAppAddTimeOut(struct _XtAppStruct *, unsigned long int, void (*)(void *, unsigned long int *), void *);
// XtAppInitialize
// file /usr/include/X11/Intrinsic.h line 1468
extern struct _WidgetRec * XtAppInitialize(struct _XtAppStruct **, const char *, struct anonymous_39 *, unsigned int, signed int *, char **, char **, struct anonymous_45 *, unsigned int);
// XtAppPending
// file /usr/include/X11/Intrinsic.h line 1045
extern unsigned long int XtAppPending(struct _XtAppStruct *);
// XtAppProcessEvent
// file /usr/include/X11/Intrinsic.h line 931
extern void XtAppProcessEvent(struct _XtAppStruct *, unsigned long int);
// XtDatabase
// file resources.c line 27
extern struct _XrmHashBucketRec * XtDatabase(struct _XDisplay *);
// XtDestroyApplicationContext
// file /usr/include/X11/Intrinsic.h line 1520
extern void XtDestroyApplicationContext(struct _XtAppStruct *);
// XtDestroyWidget
// file /usr/include/X11/Intrinsic.h line 1112
extern void XtDestroyWidget(struct _WidgetRec *);
// XtDisplayToApplicationContext
// file /usr/include/X11/Intrinsic.h line 1532
extern struct _XtAppStruct * XtDisplayToApplicationContext(struct _XDisplay *);
// XtGetApplicationNameAndClass
// file /usr/include/X11/Intrinsic.h line 2176
extern void XtGetApplicationNameAndClass(struct _XDisplay *, char **, char **);
// XtPopup
// file /usr/include/X11/Intrinsic.h line 1318
extern void XtPopup(struct _WidgetRec *, enum anonymous_51);
// XtRealizeWidget
// file /usr/include/X11/Intrinsic.h line 1104
extern void XtRealizeWidget(struct _WidgetRec *);
// XtRemoveInput
// file /usr/include/X11/Intrinsic.h line 1004
extern void XtRemoveInput(unsigned long int);
// XtRemoveTimeOut
// file /usr/include/X11/Intrinsic.h line 985
extern void XtRemoveTimeOut(unsigned long int);
// XtVaAppCreateShell
// file /usr/include/X11/Intrinsic.h line 1408
extern struct _WidgetRec * XtVaAppCreateShell(const char *, const char *, struct _WidgetClassRec *, struct _XDisplay *, ...);
// XtVaSetValues
// file /usr/include/X11/Intrinsic.h line 1592
extern void XtVaSetValues(struct _WidgetRec *, ...);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __atomic_exchange_n
// file thread_util.c line 993 function io_thread_return
signed int __atomic_exchange_n();
// __atomic_load_n
// file thread_util.c line 1006 function io_thread_is_done
signed int __atomic_load_n();
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __isoc99_sscanf
// file /usr/include/stdio.h line 448
extern signed int __isoc99_sscanf(const char *, const char *, ...);
// _add_next_thread
// file thread_util.c line 551
static void _add_next_thread(struct _parallel_startup_type *self);
// _get_cache_line_size
// file thread_util.c line 184
static unsigned int _get_cache_line_size(void);
// _hardware_concurrency
// file thread_util.c line 462
static unsigned int _hardware_concurrency(void);
// _parallel_abort
// file thread_util.c line 527
static void _parallel_abort(struct threadpool *self);
// _serial_destroy
// file thread_util.c line 511
static void _serial_destroy(struct threadpool *self);
// _start_routine
// file thread_util.c line 585
static void * _start_routine(void *startup_raw);
// _thread_destroy_and_unlock
// file thread_util.c line 577
static void * _thread_destroy_and_unlock(struct threadpool *self, void *thread);
// _thread_free_and_unlock
// file thread_util.c line 568
static void * _thread_free_and_unlock(struct threadpool *self, void *thread);
// _threadpool_count_parallel
// file thread_util.c line 541
static unsigned int _threadpool_count_parallel(struct threadpool *self);
// _threadpool_count_serial
// file thread_util.c line 501
static unsigned int _threadpool_count_serial(struct threadpool *self);
// _unlock_and_destroy
// file thread_util.c line 685
static void _unlock_and_destroy(struct threadpool *self);
// a2_ascii_printc
// file apple2-main.c line 863
static void a2_ascii_printc(struct apple2_state *st, unsigned char c, signed int bold_p, signed int blink_p, signed int rev_p, signed int scroll_p);
// a2_clear_gr
// file apple2.c line 169
void a2_clear_gr(struct apple2_state *st);
// a2_clear_hgr
// file apple2.c line 178
void a2_clear_hgr(struct apple2_state *st);
// a2_cls
// file apple2.c line 160
void a2_cls(struct apple2_state *st);
// a2_display_image_loading
// file apple2.c line 318
void a2_display_image_loading(struct apple2_state *st, unsigned char *image, signed int lineno);
// a2_dither
// file apple2-main.c line 228
static void a2_dither(unsigned int *in, unsigned char *out, signed int w, signed int h);
// a2_goto
// file apple2.c line 149
void a2_goto(struct apple2_state *st, signed int r, signed int c);
// a2_hline
// file apple2.c line 246
void a2_hline(struct apple2_state *st, signed int hcolor, signed int x1, signed int y1, signed int x2, signed int y2);
// a2_hplot
// file apple2.c line 220
void a2_hplot(struct apple2_state *st, signed int hcolor, signed int x, signed int y);
// a2_init_memory_active
// file apple2.c line 340
void a2_init_memory_active(struct apple2_sim_s *sim);
// a2_invalidate
// file apple2.c line 187
void a2_invalidate(struct apple2_state *st);
// a2_make_font
// file apple2.c line 398
static void a2_make_font(struct apple2_sim_s *sim);
// a2_plot
// file apple2.c line 301
void a2_plot(struct apple2_state *st, signed int color, signed int x, signed int y);
// a2_poke
// file apple2.c line 192
void a2_poke(struct apple2_state *st, signed int addr, signed int val);
// a2_printc
// file apple2.c line 130
void a2_printc(struct apple2_state *st, char c);
// a2_printc_1
// file apple2.c line 76
static void a2_printc_1(struct apple2_state *st, char c, signed int scroll_p);
// a2_printc_noscroll
// file apple2.c line 136
void a2_printc_noscroll(struct apple2_state *st, char c);
// a2_prints
// file apple2.c line 143
void a2_prints(struct apple2_state *st, char *s);
// a2_scroll
// file apple2.c line 64
void a2_scroll(struct apple2_state *st);
// a2_vt100_printc
// file apple2-main.c line 894
static void a2_vt100_printc(struct apple2_sim_s *sim, struct terminal_controller_data *state, unsigned char c);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// aligned_free
// file aligned_malloc.c line 42
void aligned_free(void *ptr);
// aligned_malloc
// file aligned_malloc.c line 26
signed int aligned_malloc(void **ptr, unsigned int alignment, unsigned long int size);
// analogtv_add_signal
// file analogtv.c line 1231
static void analogtv_add_signal(const struct analogtv_s *it, const struct analogtv_reception_s *rec, unsigned int start, unsigned int end, signed int ec);
// analogtv_alloc_image
// file analogtv.c line 279
static void analogtv_alloc_image(struct analogtv_s *it);
// analogtv_allocate
// file analogtv.h line 239
struct analogtv_s * analogtv_allocate(struct _XDisplay *dpy, unsigned long int window);
// analogtv_blast_imagerow
// file analogtv.c line 1390
static void analogtv_blast_imagerow(const struct analogtv_s *it, float *rgbf, float *rgbf_end, signed int ytop, signed int ybot);
// analogtv_configure
// file analogtv.c line 319
static void analogtv_configure(struct analogtv_s *it);
// analogtv_draw
// file analogtv.h line 250
void analogtv_draw(struct analogtv_s *it, double noiselevel, const struct analogtv_reception_s * const *recs, unsigned int rec_count);
// analogtv_draw_char
// file analogtv.c line 2364
void analogtv_draw_char(struct analogtv_input_s *input, struct analogtv_font_s *f, signed int c, signed int x, signed int y, signed int *ntsc);
// analogtv_draw_solid
// file analogtv.c line 2329
void analogtv_draw_solid(struct analogtv_input_s *input, signed int left, signed int right, signed int top, signed int bot, signed int *ntsc);
// analogtv_draw_solid_rel_lcp
// file analogtv.c line 2347
void analogtv_draw_solid_rel_lcp(struct analogtv_input_s *input, double left, double right, double top, double bot, double luma, double chroma, double phase);
// analogtv_draw_string
// file analogtv.c line 2388
void analogtv_draw_string(struct analogtv_input_s *input, struct analogtv_font_s *f, char *s, signed int x, signed int y, signed int *ntsc);
// analogtv_draw_string_centered
// file analogtv.c line 2399
void analogtv_draw_string_centered(struct analogtv_input_s *input, struct analogtv_font_s *f, char *s, signed int x, signed int y, signed int *ntsc);
// analogtv_draw_xpm
// file analogtv.c line 2422
void analogtv_draw_xpm(struct analogtv_s *tv, struct analogtv_input_s *input, const char * const *xpm, signed int left, signed int top);
// analogtv_font_pixel
// file analogtv.c line 2280
signed int analogtv_font_pixel(struct analogtv_font_s *f, signed int c, signed int x, signed int y);
// analogtv_font_set_char
// file analogtv.c line 2299
void analogtv_font_set_char(struct analogtv_font_s *f, signed int c, char *s);
// analogtv_font_set_pixel
// file analogtv.c line 2289
void analogtv_font_set_pixel(struct analogtv_font_s *f, signed int c, signed int x, signed int y, signed int value);
// analogtv_free_image
// file analogtv.c line 262
static void analogtv_free_image(struct analogtv_s *it);
// analogtv_get_line
// file analogtv.c line 1365
static signed int analogtv_get_line(const struct analogtv_s *it, signed int lineno, signed int *slineno, signed int *ytop, signed int *ybot, unsigned int *signal_offset);
// analogtv_init
// file analogtv.c line 165
static void analogtv_init(void);
// analogtv_init_signal
// file analogtv.c line 1210
static void analogtv_init_signal(const struct analogtv_s *it, double noiselevel, unsigned int start, unsigned int end);
// analogtv_input_allocate
// file analogtv.h line 240
struct analogtv_input_s * analogtv_input_allocate(void);
// analogtv_lcp_to_ntsc
// file analogtv.c line 2316
void analogtv_lcp_to_ntsc(double luma, double chroma, double phase, signed int *ntsc);
// analogtv_level
// file analogtv.c line 1122
static signed int analogtv_level(const struct analogtv_s *it, signed int y, signed int ytop, signed int ybot);
// analogtv_levelmult
// file analogtv.c line 1115
static double analogtv_levelmult(const struct analogtv_s *it, signed int level);
// analogtv_load_ximage
// file analogtv.c line 2015
signed int analogtv_load_ximage(struct analogtv_s *it, struct analogtv_input_s *input, struct _XImage *pic_im);
// analogtv_make_font
// file analogtv.c line 2209
void analogtv_make_font(struct _XDisplay *dpy, unsigned long int window, struct analogtv_font_s *f, signed int w, signed int h, char *fontname);
// analogtv_ntsc_to_yiq
// file analogtv.c line 776
static void analogtv_ntsc_to_yiq(const struct analogtv_s *it, signed int lineno, const float *signal, signed int start, signed int end, struct analogtv_yiq_s *it_yiq);
// analogtv_reception_update
// file analogtv.h line 255
void analogtv_reception_update(struct analogtv_reception_s *rec);
// analogtv_reconfigure
// file analogtv.h line 243
void analogtv_reconfigure(struct analogtv_s *it);
// analogtv_release
// file analogtv.h line 246
void analogtv_release(struct analogtv_s *it);
// analogtv_set_defaults
// file analogtv.h line 245
void analogtv_set_defaults(struct analogtv_s *it, char *prefix);
// analogtv_set_demod
// file analogtv.c line 647
signed int analogtv_set_demod(struct analogtv_s *it);
// analogtv_setup_frame
// file analogtv.h line 248
void analogtv_setup_frame(struct analogtv_s *it);
// analogtv_setup_levels
// file analogtv.c line 1154
static void analogtv_setup_levels(struct analogtv_s *it, double avgheight);
// analogtv_setup_sync
// file analogtv.h line 249
void analogtv_setup_sync(struct analogtv_input_s *input, signed int do_cb, signed int do_ssavi);
// analogtv_setup_teletext
// file analogtv.c line 892
void analogtv_setup_teletext(struct analogtv_input_s *input);
// analogtv_sync
// file analogtv.c line 1028
static void analogtv_sync(struct analogtv_s *it);
// analogtv_thread_add_signals
// file analogtv.c line 1323
static void analogtv_thread_add_signals(void *thread_raw);
// analogtv_thread_create
// file analogtv.c line 440
static signed int analogtv_thread_create(void *thread_raw, struct threadpool *threads, unsigned int thread_id);
// analogtv_thread_destroy
// file analogtv.c line 463
static void analogtv_thread_destroy(void *thread_raw);
// analogtv_thread_draw_lines
// file analogtv.c line 1519
static void analogtv_thread_draw_lines(void *thread_raw);
// apple2_draw
// file apple2-main.c line 1857
static unsigned long int apple2_draw(struct _XDisplay *dpy, unsigned long int window, void *closure);
// apple2_event
// file apple2-main.c line 1888
static signed int apple2_event(struct _XDisplay *dpy, unsigned long int window, void *closure, union _XEvent *event);
// apple2_free
// file apple2-main.c line 1903
static void apple2_free(struct _XDisplay *dpy, unsigned long int window, void *closure);
// apple2_init
// file apple2-main.c line 1803
static void * apple2_init(struct _XDisplay *dpy, unsigned long int window);
// apple2_one_frame
// file apple2.c line 592
extern signed int apple2_one_frame(struct apple2_sim_s *sim);
// apple2_reshape
// file apple2-main.c line 1879
static void apple2_reshape(struct _XDisplay *dpy, unsigned long int window, void *closure, unsigned int w, unsigned int h);
// apple2_start
// file apple2.c line 535
extern struct apple2_sim_s * apple2_start(struct _XDisplay *dpy, unsigned long int window, signed int delay, void (*controller)(struct apple2_sim_s *, signed int *, double *));
// apple2_start::controller_object
//
void controller_object(struct apple2_sim_s *, signed int *, double *);
// basic_controller
// file apple2-main.c line 1608
static void basic_controller(struct apple2_sim_s *sim, signed int *stepno, double *next_actiontime);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// checkerboard
// file grabclient.c line 123
static void checkerboard(struct anonymous_9 *screen, unsigned long int drawable);
// close
// file /usr/include/unistd.h line 356
extern signed int close(signed int);
// close_pipe
// file textclient.c line 268
static void close_pipe(struct text_data *d);
// cos
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 63
extern double cos(double);
// cosf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 63
extern float cosf(float);
// create_xshm_image
// file ./../utils/xshm.h line 27
extern struct _XImage * create_xshm_image(struct _XDisplay *dpy, struct anonymous_5 *visual, unsigned int depth, signed int format, char *data, struct anonymous_4 *shm_info, unsigned int width, unsigned int height);
// decode_mask
// file apple2-main.c line 42
static void decode_mask(unsigned int mask, unsigned int *pos_ret, unsigned int *size_ret);
// describe_visual
// file visual.c line 445
extern void describe_visual(struct _IO_FILE *f, struct anonymous_9 *screen, struct anonymous_5 *visual, signed int private_cmap_p);
// destroy_xshm_image
// file ./../utils/xshm.h line 32
extern void destroy_xshm_image(struct _XDisplay *dpy, struct _XImage *image, struct anonymous_4 *shm_info);
// do_icccm_meta_key_stupidity
// file textclient.c line 485
static unsigned int do_icccm_meta_key_stupidity(struct _XDisplay *dpy);
// drawable_window_p
// file grabclient.c line 64
static signed int drawable_window_p(struct _XDisplay *dpy, unsigned long int d);
// drawable_window_p::1::old_handler_object
//
signed int drawable_window_p__1__old_handler_object(struct _XDisplay *, struct anonymous_7 *);
// dup2
// file /usr/include/unistd.h line 537
extern signed int dup2(signed int, signed int);
// exec_simple_command
// file grabclient.c line 269
static void exec_simple_command(const char *command);
// execvp
// file /usr/include/unistd.h line 581
extern signed int execvp(const char *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// expf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 100
extern float expf(float);
// fabs
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 181
extern double fabs(double);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fdopen
// file /usr/include/stdio.h line 306
extern struct _IO_FILE * fdopen(signed int, const char *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// finalize_cb
// file grabclient.c line 410
static void finalize_cb(void *closure, signed int *fd, unsigned long int *id);
// find_similar_visual
// file visual.c line 503
extern struct anonymous_5 * find_similar_visual(struct anonymous_9 *screen, struct anonymous_5 *old_visual);
// fix_fds
// file screenhack.c line 403
static void fix_fds(void);
// fork
// file /usr/include/unistd.h line 759
extern signed int fork(void);
// fork_exec_cb
// file grabclient.c line 328
static void fork_exec_cb(const char *command, struct anonymous_9 *screen, unsigned long int window, unsigned long int drawable, void (*callback)(struct anonymous_9 *, unsigned long int, unsigned long int, const char *, struct anonymous_54 *, void *), void *closure);
// fork_exec_cb::callback_object
//
void callback_object(struct anonymous_9 *, unsigned long int, unsigned long int, const char *, struct anonymous_54 *, void *);
// fork_exec_wait
// file grabclient.c line 286
static void fork_exec_wait(const char *command);
// forkpty
// file /usr/include/pty.h line 42
extern signed int forkpty(signed int *, char *, struct termios *, struct winsize *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fps_compute
// file fps.h line 25
extern double fps_compute(struct fps_state *st, unsigned long int polys, double depth);
// fps_draw
// file fps.h line 26
extern void fps_draw(struct fps_state *st);
// fps_free
// file fps.h line 23
extern void fps_free(struct fps_state *st);
// fps_init
// file fps.h line 22
extern struct fps_state * fps_init(struct _XDisplay *dpy, unsigned long int window);
// fps_slept
// file fps.h line 24
extern void fps_slept(struct fps_state *st, unsigned long int usecs);
// fputc
// file /usr/include/stdio.h line 573
extern signed int fputc(signed int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// get_bits_per_pixel
// file visual.c line 545
extern signed int get_bits_per_pixel(struct _XDisplay *dpy, signed int depth);
// get_boolean_resource
// file ./../utils/resources.h line 16
extern signed int get_boolean_resource(struct _XDisplay *dpy, char *res_name, char *res_class);
// get_float_resource
// file resources.c line 122
extern double get_float_resource(struct _XDisplay *dpy, char *res_name, char *res_class);
// get_geometry
// file grabclient.c line 201
static signed int get_geometry(struct _XDisplay *dpy, unsigned long int window, struct anonymous_54 *ret);
// get_integer_resource
// file ./../utils/resources.h line 17
extern signed int get_integer_resource(struct _XDisplay *dpy, char *res_name, char *res_class);
// get_minutes_resource
// file resources.c line 261
extern unsigned int get_minutes_resource(struct _XDisplay *dpy, char *res_name, char *res_class);
// get_name
// file grabclient.c line 181
static char * get_name(struct _XDisplay *dpy, unsigned long int window);
// get_pixel_resource
// file ./../utils/resources.h line 19
extern unsigned int get_pixel_resource(struct _XDisplay *dpy, unsigned long int cmap, char *res_name, char *res_class);
// get_seconds_resource
// file resources.c line 255
extern unsigned int get_seconds_resource(struct _XDisplay *dpy, char *res_name, char *res_class);
// get_string_resource
// file ./../utils/resources.h line 15
extern char * get_string_resource(struct _XDisplay *dpy, char *res_name, char *res_class);
// get_time_resource
// file resources.c line 244
static unsigned int get_time_resource(struct _XDisplay *dpy, char *res_name, char *res_class, signed int sec_p);
// get_visual
// file visual.c line 50
extern struct anonymous_5 * get_visual(struct anonymous_9 *screen, const char *string, signed int prefer_writable_cells, signed int verbose_p);
// get_visual_resource
// file ./../utils/visual.h line 16
extern struct anonymous_5 * get_visual_resource(struct anonymous_9 *screen, char *name, char *class, signed int prefer_writable_cells);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getpid
// file /usr/include/unistd.h line 631
extern signed int getpid(void);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// hack_subproc_environment
// file grabclient.c line 237
static void hack_subproc_environment(struct _XDisplay *dpy);
// hardware_concurrency
// file ./../utils/thread_util.h line 101
unsigned int hardware_concurrency(struct _XDisplay *dpy);
// has_writable_cells
// file ./../utils/visual.h line 25
extern signed int has_writable_cells(struct anonymous_9 *screen, struct anonymous_5 *visual);
// id_to_visual
// file visual.c line 340
extern struct anonymous_5 * id_to_visual(struct anonymous_9 *screen, signed int id);
// ignore_all_errors_ehandler
// file grabclient.c line 54
static signed int ignore_all_errors_ehandler(struct _XDisplay *dpy, struct anonymous_7 *error);
// image_loaded_cb
// file apple2-main.c line 520
static void image_loaded_cb(struct anonymous_9 *screen, unsigned long int window, unsigned long int p, const char *name, struct anonymous_54 *geometry, void *closure);
// init_window
// file screenhack.c line 675
static void init_window(struct _XDisplay *dpy, struct _WidgetRec *toplevel, const char *title);
// io_thread_cancel
// file thread_util.c line 1013
signed int io_thread_cancel(struct io_thread *self);
// io_thread_create
// file thread_util.c line 950
void * io_thread_create(struct io_thread *self, void *parent, void * (*start_routine)(void *), struct _XDisplay *dpy, unsigned int stacksize);
// io_thread_create::start_routine_object
//
void * start_routine_object(void *);
// io_thread_finish
// file thread_util.c line 1029
void io_thread_finish(struct io_thread *self);
// io_thread_is_done
// file thread_util.c line 1002
signed int io_thread_is_done(struct io_thread *self);
// io_thread_return
// file thread_util.c line 989
signed int io_thread_return(struct io_thread *self);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// launch_text_generator
// file textclient.c line 103
static void launch_text_generator(struct text_data *d);
// load_image_async
// file ./../utils/grabscreen.h line 40
extern void load_image_async(struct anonymous_9 *screen, unsigned long int window, unsigned long int drawable, void (*callback)(struct anonymous_9 *, unsigned long int, unsigned long int, const char *, struct anonymous_54 *, void *), void *closure);
// load_image_async::callback_object
//
void callback_object(struct anonymous_9 *, unsigned long int, unsigned long int, const char *, struct anonymous_54 *, void *);
// load_image_async_simple
// file grabclient.c line 949
extern struct async_load_state * load_image_async_simple(struct async_load_state *state, struct anonymous_9 *screen, unsigned long int window, unsigned long int drawable, char **filename_ret, struct anonymous_54 *geometry_ret);
// load_image_async_simple_cb
// file grabclient.c line 939
static void load_image_async_simple_cb(struct anonymous_9 *screen, unsigned long int window, unsigned long int drawable, const char *name, struct anonymous_54 *geom, void *closure);
// load_random_image_1
// file grabclient.c line 444
static void load_random_image_1(struct anonymous_9 *screen, unsigned long int window, unsigned long int drawable, void (*callback)(struct anonymous_9 *, unsigned long int, unsigned long int, const char *, struct anonymous_54 *, void *), void *closure, char **name_ret, struct anonymous_54 *geom_ret);
// load_random_image_1::callback_object
//
void callback_object(struct anonymous_9 *, unsigned long int, unsigned long int, const char *, struct anonymous_54 *, void *);
// make_shell
// file screenhack.c line 612
static struct _WidgetRec * make_shell(struct anonymous_9 *screen, struct _WidgetRec *toplevel, signed int width, signed int height);
// make_typo
// file apple2-main.c line 1503
static signed int make_typo(char *out_buf, const char *orig, char *err_buf);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 42
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 46
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 62
extern void * memset(void *, signed int, unsigned long int);
// merge_options
// file screenhack.c line 182
static void merge_options(void);
// meta_modifier
// file textclient.c line 514
static unsigned int meta_modifier(struct text_data *d);
// old_handler_object
//
signed int old_handler_object(struct _XDisplay *, struct anonymous_7 *);
// open
// file /usr/include/fcntl.h line 156
extern signed int open(const char *, signed int, ...);
// parse_time
// file resources.c line 203
extern signed int parse_time(const char *string, signed int seconds_default_p, signed int silent_p);
// pclose
// file /usr/include/stdio.h line 878
extern signed int pclose(struct _IO_FILE *);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pick_a2_subimage
// file apple2-main.c line 190
static void pick_a2_subimage(struct _XDisplay *dpy, unsigned long int window, struct _XImage *in, unsigned int *out, signed int w, signed int h);
// pick_best_gl_visual
// file visual.c line 281
static struct anonymous_5 * pick_best_gl_visual(struct anonymous_9 *screen);
// pick_best_visual
// file visual.c line 174
static struct anonymous_5 * pick_best_visual(struct anonymous_9 *screen, signed int prefer_writable_cells, signed int color_only);
// pick_best_visual_of_class
// file visual.c line 242
static struct anonymous_5 * pick_best_visual_of_class(struct anonymous_9 *screen, signed int visual_class);
// pick_mono_visual
// file visual.c line 218
static struct anonymous_5 * pick_mono_visual(struct anonymous_9 *screen);
// pick_visual
// file screenhack.c line 321
static struct anonymous_5 * pick_visual(struct anonymous_9 *screen);
// pipe
// file /usr/include/unistd.h line 420
extern signed int pipe(signed int *);
// popen
// file /usr/include/stdio.h line 872
extern struct _IO_FILE * popen(const char *, const char *);
// posix_memalign
// file /usr/include/stdlib.h line 503
extern signed int posix_memalign(void **, unsigned long int, unsigned long int);
// pow
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 153
extern double pow(double, double);
// powf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 153
extern float powf(float, float);
// print_loading_msg
// file grabclient.c line 879
static void print_loading_msg(struct anonymous_9 *screen, unsigned long int window);
// pthread_attr_destroy
// file /usr/include/pthread.h line 290
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 287
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setstacksize
// file /usr/include/pthread.h line 375
extern signed int pthread_attr_setstacksize(union pthread_attr_t *, unsigned long int);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 981
extern signed int pthread_cond_broadcast(union anonymous_30 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 973
extern signed int pthread_cond_destroy(union anonymous_30 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 989
extern signed int pthread_cond_wait(union anonymous_30 *, union anonymous_12 *);
// pthread_create
// file /usr/include/pthread.h line 233
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 271
extern signed int pthread_detach(unsigned long int);
// pthread_join
// file /usr/include/pthread.h line 250
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 754
extern signed int pthread_mutex_destroy(union anonymous_12 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 762
extern signed int pthread_mutex_lock(union anonymous_12 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 773
extern signed int pthread_mutex_unlock(union anonymous_12 *);
// puramp
// file analogtv.c line 119
static float puramp(const struct analogtv_s *it, float tc, float start, float over);
// putenv
// file /usr/include/stdlib.h line 578
extern signed int putenv(char *);
// read
// file /usr/include/unistd.h line 363
extern signed long int read(signed int, void *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// relaunch_generator_timer
// file textclient.c line 237
static void relaunch_generator_timer(void *closure, unsigned long int *id);
// rnd_combine
// file analogtv.c line 1184
static void rnd_combine(unsigned int *a0, unsigned int *c0, unsigned int a1, unsigned int c1);
// rnd_seek
// file analogtv.c line 1204
static unsigned int rnd_seek(unsigned int a, unsigned int c, unsigned int rnd, unsigned int dist);
// rnd_seek_ac
// file analogtv.c line 1190
static void rnd_seek_ac(unsigned int *a, unsigned int *c, unsigned int dist);
// run_screenhack_table
// file screenhack.c line 536
static void run_screenhack_table(struct _XDisplay *dpy, unsigned long int window, unsigned long int window2, struct xscreensaver_function_table *ft);
// run_screenhack_table::1::fps_cb_object
//
void fps_cb_object(struct _XDisplay *, unsigned long int, struct fps_state *, void *);
// run_screenhack_table::1::init_cb_object
//
void * init_cb_object(struct _XDisplay *, unsigned long int, void *);
// scale_image
// file apple2-main.c line 82
static void scale_image(struct _XDisplay *dpy, unsigned long int window, struct _XImage *in, signed int fromx, signed int fromy, signed int fromw, signed int fromh, unsigned int *out, signed int w, signed int h);
// screen_number
// file visual.c line 475
extern signed int screen_number(struct anonymous_9 *screen);
// screenhack_do_fps
// file screenhack.c line 528
static void screenhack_do_fps(struct _XDisplay *dpy, unsigned long int w, struct fps_state *fpst, void *closure);
// screenhack_ehandler
// file screenhack.c line 245
static signed int screenhack_ehandler(struct _XDisplay *dpy, struct anonymous_7 *error);
// screenhack_event_helper
// file resources.c line 276
extern signed int screenhack_event_helper(struct _XDisplay *dpy, unsigned long int window, union _XEvent *event);
// screenhack_handle_event_1
// file screenhack.c line 270
static signed int screenhack_handle_event_1(struct _XDisplay *dpy, union _XEvent *event);
// screenhack_table_handle_events
// file screenhack.c line 433
static char screenhack_table_handle_events(struct _XDisplay *dpy, struct xscreensaver_function_table *ft, unsigned long int window, void *closure, unsigned long int window2, void *closure2);
// screenhack_usleep
// file ./../utils/usleep.h line 23
extern void screenhack_usleep(unsigned long int usecs);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_6 *, struct anonymous_6 *, struct anonymous_6 *, struct timeval *);
// shm_ehandler
// file xshm.c line 62
static signed int shm_ehandler(struct _XDisplay *dpy, struct anonymous_7 *error);
// shmat
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 56
extern void * shmat(signed int, const void *, signed int);
// shmctl
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 50
extern signed int shmctl(signed int, signed int, struct shmid_ds *);
// shmdt
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 60
extern signed int shmdt(const void *);
// shmget
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 53
extern signed int shmget(signed int, unsigned long int, signed int);
// sin
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 65
extern double sin(double);
// slideshow_controller
// file apple2-main.c line 609
static void slideshow_controller(struct apple2_sim_s *sim, signed int *stepno, double *next_actiontime);
// spread_bits
// file apple2-main.c line 62
static unsigned char spread_bits(unsigned char value, unsigned char width);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sqrt
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 156
extern double sqrt(double);
// sqrtf
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 156
extern float sqrtf(float);
// start_timer
// file textclient.c line 250
static void start_timer(struct text_data *d);
// strcasecmp
// file /usr/include/string.h line 529
extern signed int strcasecmp(const char *, const char *);
// strcat
// file /usr/include/string.h line 133
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 231
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 140
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 125
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 171
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 408
extern char * strerror(signed int);
// string_width
// file fps.c line 175
static signed int string_width(struct anonymous_59 *f, const char *c, signed int *height_ret);
// strlen
// file /usr/include/string.h line 394
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 533
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 128
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 258
extern char * strrchr(const char *, signed int);
// strtok
// file /usr/include/string.h line 343
extern char * strtok(char *, const char *);
// subproc_cb
// file textclient.c line 85
static void subproc_cb(void *closure, signed int *source, unsigned long int *id);
// sysconf
// file /usr/include/unistd.h line 622
extern signed long int sysconf(signed int);
// terminal_closegen
// file apple2-main.c line 823
static void terminal_closegen(struct terminal_controller_data *mine);
// terminal_controller
// file apple2-main.c line 1336
static void terminal_controller(struct apple2_sim_s *sim, signed int *stepno, double *next_actiontime);
// terminal_keypress_handler
// file apple2-main.c line 851
static signed int terminal_keypress_handler(struct _XDisplay *dpy, union _XEvent *event, void *data);
// terminal_read
// file apple2-main.c line 832
static signed int terminal_read(struct terminal_controller_data *mine, unsigned char *buf, signed int n);
// textclient_close
// file ./../utils/textclient.h line 24
extern void textclient_close(struct text_data *d);
// textclient_getc
// file ./../utils/textclient.h line 29
extern signed int textclient_getc(struct text_data *d);
// textclient_open
// file ./../utils/textclient.h line 23
extern struct text_data * textclient_open(struct _XDisplay *dpy);
// textclient_putc
// file ./../utils/textclient.h line 30
extern signed int textclient_putc(struct text_data *d, struct anonymous_26 *k);
// textclient_reshape
// file ./../utils/textclient.h line 25
extern void textclient_reshape(struct text_data *d, signed int pix_w, signed int pix_h, signed int char_w, signed int char_h, signed int max_lines);
// thread_memory_alignment
// file ./../utils/thread_util.h line 112
unsigned int thread_memory_alignment(struct _XDisplay *dpy);
// threadpool_create
// file ./../utils/thread_util.h line 303
signed int threadpool_create(struct threadpool *self, struct threadpool_class *cls, struct _XDisplay *dpy, unsigned int count);
// threadpool_destroy
// file ./../utils/thread_util.h line 304
void threadpool_destroy(struct threadpool *self);
// threadpool_run
// file ./../utils/thread_util.h line 306
void threadpool_run(struct threadpool *self, void (*func)(void *));
// threadpool_run::func_object
//
void func_object(void *);
// threadpool_wait
// file ./../utils/thread_util.h line 307
void threadpool_wait(struct threadpool *self);
// threads_available
// file thread_util.c line 291
signed int threads_available(struct _XDisplay *dpy);
// toupper
// file /usr/include/ctype.h line 127
extern signed int toupper(signed int);
// uc_truncate
// file utf8wc.c line 38
static unsigned long int uc_truncate(unsigned long int uc);
// use_subwindow_mode_p
// file grabclient.c line 111
extern signed int use_subwindow_mode_p(struct anonymous_9 *screen, unsigned long int window);
// usleep_and_process_events
// file screenhack.c line 481
static char usleep_and_process_events(struct _XDisplay *dpy, struct xscreensaver_function_table *ft, unsigned long int window, struct fps_state *fpst, void *closure, unsigned long int delay, unsigned long int window2, struct fps_state *fpst2, void *closure2, unsigned long int delay2);
// utf8_decode
// file utf8wc.c line 56
extern signed long int utf8_decode(const unsigned char *in, signed long int length, unsigned long int *unicode_ret);
// utf8_encode
// file utf8wc.c line 160
extern signed int utf8_encode(unsigned long int uc, char *out, signed long int length);
// utf8_split
// file utf8wc.c line 256
extern char ** utf8_split(const char *string, signed int *length_ret);
// utf8_to_XChar2b
// file utf8wc.c line 215
extern struct anonymous_11 * utf8_to_XChar2b(const char *string, signed int *length_ret);
// utf8_to_latin1
// file ./../utils/utf8wc.h line 34
extern char * utf8_to_latin1(const char *string, signed int ascii_p);
// visual_cells
// file ./../utils/visual.h line 20
extern signed int visual_cells(struct anonymous_9 *screen, struct anonymous_5 *visual);
// visual_class
// file ./../utils/visual.h line 19
extern signed int visual_class(struct anonymous_9 *screen, struct anonymous_5 *visual);
// visual_depth
// file ./../utils/visual.h line 17
extern signed int visual_depth(struct anonymous_9 *screen, struct anonymous_5 *visual);
// visual_warning
// file screenhack.c line 341
static void visual_warning(struct anonymous_9 *screen, unsigned long int window, struct anonymous_5 *visual, unsigned long int cmap, signed int window_p);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// xscreensaver_window_p
// file grabclient.c line 85
static signed int xscreensaver_window_p(struct _XDisplay *dpy, unsigned long int window);
// ya_rand_init
// file ./../utils/yarandom.h line 37
extern void ya_rand_init(unsigned int seed);
// ya_random
// file ./../utils/yarandom.h line 36
extern unsigned int ya_random(void);

struct anonymous_45
{
  // name
  char *name;
  // value
  signed long int value;
};

struct anonymous_39
{
  // option
  char *option;
  // specifier
  char *specifier;
  // argKind
  enum anonymous_40 argKind;
  // value
  char *value;
};

struct anonymous_3
{
  // visual
  struct anonymous_5 *visual;
  // visualid
  unsigned long int visualid;
  // screen
  signed int screen;
  // depth
  signed int depth;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // colormap_size
  signed int colormap_size;
  // bits_per_rgb
  signed int bits_per_rgb;
};

struct anonymous_9
{
  // ext_data
  struct _XExtData *ext_data;
  // display
  struct _XDisplay *display;
  // root
  unsigned long int root;
  // width
  signed int width;
  // height
  signed int height;
  // mwidth
  signed int mwidth;
  // mheight
  signed int mheight;
  // ndepths
  signed int ndepths;
  // depths
  struct anonymous_69 *depths;
  // root_depth
  signed int root_depth;
  // root_visual
  struct anonymous_5 *root_visual;
  // default_gc
  struct _XGC *default_gc;
  // cmap
  unsigned long int cmap;
  // white_pixel
  unsigned long int white_pixel;
  // black_pixel
  unsigned long int black_pixel;
  // max_maps
  signed int max_maps;
  // min_maps
  signed int min_maps;
  // backing_store
  signed int backing_store;
  // save_unders
  signed int save_unders;
  // root_input_mask
  signed long int root_input_mask;
};

struct anonymous_63
{
  // ext_data
  struct _XExtData *ext_data;
  // private1
  struct _XPrivate *private1;
  // fd
  signed int fd;
  // private2
  signed int private2;
  // proto_major_version
  signed int proto_major_version;
  // proto_minor_version
  signed int proto_minor_version;
  // vendor
  char *vendor;
  // private3
  unsigned long int private3;
  // private4
  unsigned long int private4;
  // private5
  unsigned long int private5;
  // private6
  signed int private6;
  // resource_alloc
  unsigned long int (*resource_alloc)(struct _XDisplay *);
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_pad
  signed int bitmap_pad;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // nformats
  signed int nformats;
  // pixmap_format
  struct anonymous_62 *pixmap_format;
  // private8
  signed int private8;
  // release
  signed int release;
  // private9
  struct _XPrivate *private9;
  // private10
  struct _XPrivate *private10;
  // qlen
  signed int qlen;
  // last_request_read
  unsigned long int last_request_read;
  // request
  unsigned long int request;
  // private11
  char *private11;
  // private12
  char *private12;
  // private13
  char *private13;
  // private14
  char *private14;
  // max_request_size
  unsigned int max_request_size;
  // db
  struct _XrmHashBucketRec *db;
  // private15
  signed int (*private15)(struct _XDisplay *);
  // display_name
  char *display_name;
  // default_screen
  signed int default_screen;
  // nscreens
  signed int nscreens;
  // screens
  struct anonymous_9 *screens;
  // motion_buffer
  unsigned long int motion_buffer;
  // private16
  unsigned long int private16;
  // min_keycode
  signed int min_keycode;
  // max_keycode
  signed int max_keycode;
  // private17
  char *private17;
  // private18
  char *private18;
  // private19
  signed int private19;
  // xdefaults
  char *xdefaults;
};

struct anonymous_62
{
  // ext_data
  struct _XExtData *ext_data;
  // depth
  signed int depth;
  // bits_per_pixel
  signed int bits_per_pixel;
  // scanline_pad
  signed int scanline_pad;
};

struct anonymous_0
{
  // lbearing
  signed short int lbearing;
  // rbearing
  signed short int rbearing;
  // width
  signed short int width;
  // ascent
  signed short int ascent;
  // descent
  signed short int descent;
  // attributes
  unsigned short int attributes;
};

struct anonymous_59
{
  // ext_data
  struct _XExtData *ext_data;
  // fid
  unsigned long int fid;
  // direction
  unsigned int direction;
  // min_char_or_byte2
  unsigned int min_char_or_byte2;
  // max_char_or_byte2
  unsigned int max_char_or_byte2;
  // min_byte1
  unsigned int min_byte1;
  // max_byte1
  unsigned int max_byte1;
  // all_chars_exist
  signed int all_chars_exist;
  // default_char
  unsigned int default_char;
  // n_properties
  signed int n_properties;
  // properties
  struct anonymous *properties;
  // min_bounds
  struct anonymous_0 min_bounds;
  // max_bounds
  struct anonymous_0 max_bounds;
  // per_char
  struct anonymous_0 *per_char;
  // ascent
  signed int ascent;
  // descent
  signed int descent;
};

struct anonymous_5
{
  // ext_data
  struct _XExtData *ext_data;
  // visualid
  unsigned long int visualid;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // bits_per_rgb
  signed int bits_per_rgb;
  // map_entries
  signed int map_entries;
};

struct anonymous_64
{
  // callback
  void (*callback)(struct anonymous_9 *, unsigned long int, unsigned long int, const char *, struct anonymous_54 *, void *);
  // screen
  struct anonymous_9 *screen;
  // window
  unsigned long int window;
  // drawable
  unsigned long int drawable;
  // closure
  void *closure;
  // read_pipe
  struct _IO_FILE *read_pipe;
  // write_pipe
  struct _IO_FILE *write_pipe;
  // pipe_id
  unsigned long int pipe_id;
  // pid
  signed int pid;
};

struct anonymous_6
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous_42
{
  // bold
  unsigned int bold : 1;
  // blink
  unsigned int blink : 1;
  // rev
  unsigned int rev : 1;
};

struct anonymous_54
{
  // x
  signed short int x;
  // y
  signed short int y;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
};

struct anonymous_52
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_2
{
  // depth
  signed int depth;
  // bits_per_pixel
  signed int bits_per_pixel;
  // scanline_pad
  signed int scanline_pad;
};

struct anonymous_69
{
  // depth
  signed int depth;
  // nvisuals
  signed int nvisuals;
  // visuals
  struct anonymous_5 *visuals;
};

struct anonymous_58
{
  // function
  signed int function;
  // plane_mask
  unsigned long int plane_mask;
  // foreground
  unsigned long int foreground;
  // background
  unsigned long int background;
  // line_width
  signed int line_width;
  // line_style
  signed int line_style;
  // cap_style
  signed int cap_style;
  // join_style
  signed int join_style;
  // fill_style
  signed int fill_style;
  // fill_rule
  signed int fill_rule;
  // arc_mode
  signed int arc_mode;
  // tile
  unsigned long int tile;
  // stipple
  unsigned long int stipple;
  // ts_x_origin
  signed int ts_x_origin;
  // ts_y_origin
  signed int ts_y_origin;
  // font
  unsigned long int font;
  // subwindow_mode
  signed int subwindow_mode;
  // graphics_exposures
  signed int graphics_exposures;
  // clip_x_origin
  signed int clip_x_origin;
  // clip_y_origin
  signed int clip_y_origin;
  // clip_mask
  unsigned long int clip_mask;
  // dash_offset
  signed int dash_offset;
  // dashes
  char dashes;
};

struct anonymous_61
{
  // index
  signed int index;
  // value
  double value;
};

struct anonymous_68
{
  // max_keypermod
  signed int max_keypermod;
  // modifiermap
  unsigned char *modifiermap;
};

struct anonymous_7
{
  // type
  signed int type;
  // display
  struct _XDisplay *display;
  // resourceid
  unsigned long int resourceid;
  // serial
  unsigned long int serial;
  // error_code
  unsigned char error_code;
  // request_code
  unsigned char request_code;
  // minor_code
  unsigned char minor_code;
};

struct anonymous_38
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
};

struct anonymous_41
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
  // cookie
  unsigned int cookie;
  // data
  void *data;
};

struct anonymous_14
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous_13
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous_18
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
};

struct anonymous_19
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // from_configure
  signed int from_configure;
};

struct anonymous_20
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_28
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous_24
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
};

struct anonymous_23
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_22
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // parent
  unsigned long int parent;
  // x
  signed int x;
  // y
  signed int y;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_33
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // owner
  unsigned long int owner;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous_21
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
};

struct anonymous_29
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous_17
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // override_redirect
  signed int override_redirect;
};

struct anonymous_27
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // detail
  signed int detail;
  // value_mask
  unsigned long int value_mask;
};

struct anonymous_34
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous_37
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
};

struct anonymous_8
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // key_vector
  char key_vector[32l];
};

struct anonymous_49
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // mode
  signed int mode;
  // detail
  signed int detail;
};

struct anonymous_36
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // request
  signed int request;
  // first_keycode
  signed int first_keycode;
  // count
  signed int count;
};

struct anonymous_15
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // state
  signed int state;
};

struct anonymous_25
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // width
  signed int width;
  // height
  signed int height;
};

struct anonymous_10
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
};

struct anonymous_31
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // atom
  unsigned long int atom;
  // time
  unsigned long int time;
  // state
  signed int state;
};

struct anonymous_35
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // colormap
  unsigned long int colormap;
  // new
  signed int new;
  // state
  signed int state;
};

union anonymous_67
{
  // b
  char b[20l];
  // s
  signed short int s[10l];
  // l
  signed long int l[5l];
};

struct anonymous_66
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // message_type
  unsigned long int message_type;
  // format
  signed int format;
  // data
  union anonymous_67 data;
};

struct anonymous_48
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // mode
  signed int mode;
  // detail
  signed int detail;
  // same_screen
  signed int same_screen;
  // focus
  signed int focus;
  // state
  unsigned int state;
};

struct anonymous_47
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // is_hint
  char is_hint;
  // same_screen
  signed int same_screen;
};

struct anonymous_46
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // same_screen
  signed int same_screen;
};

struct anonymous_26
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // keycode
  unsigned int keycode;
  // same_screen
  signed int same_screen;
};

struct anonymous_32
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // selection
  unsigned long int selection;
  // time
  unsigned long int time;
};

struct anonymous_16
{
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // depth
  signed int depth;
  // visual
  struct anonymous_5 *visual;
  // root
  unsigned long int root;
  // class
  signed int class;
  // bit_gravity
  signed int bit_gravity;
  // win_gravity
  signed int win_gravity;
  // backing_store
  signed int backing_store;
  // backing_planes
  unsigned long int backing_planes;
  // backing_pixel
  unsigned long int backing_pixel;
  // save_under
  signed int save_under;
  // colormap
  unsigned long int colormap;
  // map_installed
  signed int map_installed;
  // map_state
  signed int map_state;
  // all_event_masks
  signed long int all_event_masks;
  // your_event_mask
  signed long int your_event_mask;
  // do_not_propagate_mask
  signed long int do_not_propagate_mask;
  // override_redirect
  signed int override_redirect;
  // screen
  struct anonymous_9 *screen;
};

struct anonymous_44
{
  // request_mode
  unsigned int request_mode;
  // x
  signed short int x;
  // y
  signed short int y;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // border_width
  unsigned short int border_width;
  // sibling
  struct _WidgetRec *sibling;
  // stack_mode
  signed int stack_mode;
};

struct anonymous_1
{
  // size
  unsigned int size;
  // addr
  char *addr;
};

struct anonymous_60
{
  // background_pixmap
  unsigned long int background_pixmap;
  // background_pixel
  unsigned long int background_pixel;
  // border_pixmap
  unsigned long int border_pixmap;
  // border_pixel
  unsigned long int border_pixel;
  // bit_gravity
  signed int bit_gravity;
  // win_gravity
  signed int win_gravity;
  // backing_store
  signed int backing_store;
  // backing_planes
  unsigned long int backing_planes;
  // backing_pixel
  unsigned long int backing_pixel;
  // save_under
  signed int save_under;
  // event_mask
  signed long int event_mask;
  // do_not_propagate_mask
  signed long int do_not_propagate_mask;
  // override_redirect
  signed int override_redirect;
  // colormap
  unsigned long int colormap;
  // cursor
  unsigned long int cursor;
};

struct anonymous
{
  // name
  unsigned long int name;
  // card32
  unsigned long int card32;
};

struct anonymous_57
{
  // pixel
  unsigned long int pixel;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
  // flags
  char flags;
  // pad
  char pad;
};

struct anonymous_4
{
  // shmseg
  unsigned long int shmseg;
  // shmid
  signed int shmid;
  // shmaddr
  char *shmaddr;
  // readOnly
  signed int readOnly;
};

struct anonymous_11
{
  // byte1
  unsigned char byte1;
  // byte2
  unsigned char byte2;
};

union anonymous_55
{
  // f
  float f;
  // i
  signed int i;
};

union anonymous_43
{
  // bf
  struct anonymous_42 bf;
  // w
  signed int w;
};

union anonymous_30
{
  // __data
  struct anonymous_52 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_12
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous_56
{
  // progtext
  const char * const *progtext;
  // progstep
  signed int progstep;
};

struct _CoreClassPart
{
  // superclass
  struct _WidgetClassRec *superclass;
  // class_name
  char *class_name;
  // widget_size
  unsigned int widget_size;
  // class_initialize
  void (*class_initialize)(void);
  // class_part_initialize
  void (*class_part_initialize)(struct _WidgetClassRec *);
  // class_inited
  unsigned char class_inited;
  // initialize
  void (*initialize)(struct _WidgetRec *, struct _WidgetRec *, struct anonymous_45 *, unsigned int *);
  // initialize_hook
  void (*initialize_hook)(struct _WidgetRec *, struct anonymous_45 *, unsigned int *);
  // realize
  void (*realize)(struct _WidgetRec *, unsigned long int *, struct anonymous_60 *);
  // actions
  struct _XtActionsRec *actions;
  // num_actions
  unsigned int num_actions;
  // resources
  struct _XtResource *resources;
  // num_resources
  unsigned int num_resources;
  // xrm_class
  signed int xrm_class;
  // compress_motion
  char compress_motion;
  // compress_exposure
  unsigned char compress_exposure;
  // compress_enterleave
  char compress_enterleave;
  // visible_interest
  char visible_interest;
  // destroy
  void (*destroy)(struct _WidgetRec *);
  // resize
  void (*resize)(struct _WidgetRec *);
  // expose
  void (*expose)(struct _WidgetRec *, union _XEvent *, struct _XRegion *);
  // set_values
  char (*set_values)(struct _WidgetRec *, struct _WidgetRec *, struct _WidgetRec *, struct anonymous_45 *, unsigned int *);
  // set_values_hook
  char (*set_values_hook)(struct _WidgetRec *, struct anonymous_45 *, unsigned int *);
  // set_values_almost
  void (*set_values_almost)(struct _WidgetRec *, struct _WidgetRec *, struct anonymous_44 *, struct anonymous_44 *);
  // get_values_hook
  void (*get_values_hook)(struct _WidgetRec *, struct anonymous_45 *, unsigned int *);
  // accept_focus
  char (*accept_focus)(struct _WidgetRec *, unsigned long int *);
  // version
  unsigned long int version;
  // callback_private
  void *callback_private;
  // tm_table
  char *tm_table;
  // query_geometry
  enum anonymous_50 (*query_geometry)(struct _WidgetRec *, struct anonymous_44 *, struct anonymous_44 *);
  // display_accelerator
  void (*display_accelerator)(struct _WidgetRec *, char *);
  // extension
  void *extension;
};

struct _XtTMRec
{
  // translations
  struct _TranslationData *translations;
  // proc_table
  void (**proc_table)(struct _WidgetRec *, union _XEvent *, char **, unsigned int *);
  // current_state
  struct _XtStateRec *current_state;
  // lastEventTime
  unsigned long int lastEventTime;
};

struct _CorePart
{
  // self
  struct _WidgetRec *self;
  // widget_class
  struct _WidgetClassRec *widget_class;
  // parent
  struct _WidgetRec *parent;
  // xrm_name
  signed int xrm_name;
  // being_destroyed
  char being_destroyed;
  // destroy_callbacks
  struct _XtCallbackRec *destroy_callbacks;
  // constraints
  void *constraints;
  // x
  signed short int x;
  // y
  signed short int y;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // border_width
  unsigned short int border_width;
  // managed
  char managed;
  // sensitive
  char sensitive;
  // ancestor_sensitive
  char ancestor_sensitive;
  // event_table
  struct _XtEventRec *event_table;
  // tm
  struct _XtTMRec tm;
  // accelerators
  struct _TranslationData *accelerators;
  // border_pixel
  unsigned long int border_pixel;
  // border_pixmap
  unsigned long int border_pixmap;
  // popup_list
  struct _WidgetRec **popup_list;
  // num_popups
  unsigned int num_popups;
  // name
  char *name;
  // screen
  struct anonymous_9 *screen;
  // colormap
  unsigned long int colormap;
  // window
  unsigned long int window;
  // depth
  unsigned int depth;
  // background_pixel
  unsigned long int background_pixel;
  // background_pixmap
  unsigned long int background_pixmap;
  // visible
  char visible;
  // mapped_when_managed
  char mapped_when_managed;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _WidgetClassRec
{
  // core_class
  struct _CoreClassPart core_class;
};

struct _WidgetRec
{
  // core
  struct _CorePart core;
};

struct _XComposeStatus
{
  // compose_ptr
  char *compose_ptr;
  // chars_matched
  signed int chars_matched;
};

union _XEvent
{
  // type
  signed int type;
  // xany
  struct anonymous_37 xany;
  // xkey
  struct anonymous_26 xkey;
  // xbutton
  struct anonymous_46 xbutton;
  // xmotion
  struct anonymous_47 xmotion;
  // xcrossing
  struct anonymous_48 xcrossing;
  // xfocus
  struct anonymous_49 xfocus;
  // xexpose
  struct anonymous_10 xexpose;
  // xgraphicsexpose
  struct anonymous_13 xgraphicsexpose;
  // xnoexpose
  struct anonymous_14 xnoexpose;
  // xvisibility
  struct anonymous_15 xvisibility;
  // xcreatewindow
  struct anonymous_17 xcreatewindow;
  // xdestroywindow
  struct anonymous_18 xdestroywindow;
  // xunmap
  struct anonymous_19 xunmap;
  // xmap
  struct anonymous_20 xmap;
  // xmaprequest
  struct anonymous_21 xmaprequest;
  // xreparent
  struct anonymous_22 xreparent;
  // xconfigure
  struct anonymous_23 xconfigure;
  // xgravity
  struct anonymous_24 xgravity;
  // xresizerequest
  struct anonymous_25 xresizerequest;
  // xconfigurerequest
  struct anonymous_27 xconfigurerequest;
  // xcirculate
  struct anonymous_28 xcirculate;
  // xcirculaterequest
  struct anonymous_29 xcirculaterequest;
  // xproperty
  struct anonymous_31 xproperty;
  // xselectionclear
  struct anonymous_32 xselectionclear;
  // xselectionrequest
  struct anonymous_33 xselectionrequest;
  // xselection
  struct anonymous_34 xselection;
  // xcolormap
  struct anonymous_35 xcolormap;
  // xclient
  struct anonymous_66 xclient;
  // xmapping
  struct anonymous_36 xmapping;
  // xerror
  struct anonymous_7 xerror;
  // xkeymap
  struct anonymous_8 xkeymap;
  // xgeneric
  struct anonymous_38 xgeneric;
  // xcookie
  struct anonymous_41 xcookie;
  // pad
  signed long int pad[24l];
};

struct _XExtData
{
  // number
  signed int number;
  // next
  struct _XExtData *next;
  // free_private
  signed int (*free_private)(struct _XExtData *);
  // private_data
  char *private_data;
};

struct funcs
{
  // create_image
  struct _XImage * (*create_image)(struct _XDisplay *, struct anonymous_5 *, unsigned int, signed int, signed int, char *, unsigned int, unsigned int, signed int, signed int);
  // destroy_image
  signed int (*destroy_image)(struct _XImage *);
  // get_pixel
  unsigned long int (*get_pixel)(struct _XImage *, signed int, signed int);
  // put_pixel
  signed int (*put_pixel)(struct _XImage *, signed int, signed int, unsigned long int);
  // sub_image
  struct _XImage * (*sub_image)(struct _XImage *, signed int, signed int, unsigned int, unsigned int);
  // add_pixel
  signed int (*add_pixel)(struct _XImage *, signed long int);
};

struct _XImage
{
  // width
  signed int width;
  // height
  signed int height;
  // xoffset
  signed int xoffset;
  // format
  signed int format;
  // data
  char *data;
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // bitmap_pad
  signed int bitmap_pad;
  // depth
  signed int depth;
  // bytes_per_line
  signed int bytes_per_line;
  // bits_per_pixel
  signed int bits_per_pixel;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // obdata
  char *obdata;
  // f
  struct funcs f;
};

struct _XtActionsRec
{
  // string
  char *string;
  // proc
  void (*proc)(struct _WidgetRec *, union _XEvent *, char **, unsigned int *);
};

struct _XtCallbackRec
{
  // callback
  void (*callback)(struct _WidgetRec *, void *, void *);
  // closure
  void *closure;
};

struct _XtResource
{
  // resource_name
  char *resource_name;
  // resource_class
  char *resource_class;
  // resource_type
  char *resource_type;
  // resource_size
  unsigned int resource_size;
  // resource_offset
  unsigned int resource_offset;
  // default_type
  char *default_type;
  // default_addr
  void *default_addr;
};

struct _parallel_startup_type
{
  // parent
  struct threadpool *parent;
  // thread_create
  signed int (*thread_create)(void *, struct threadpool *, unsigned int);
  // last_errno
  signed int last_errno;
};

struct analogtv_font_s
{
  // text_im
  struct _XImage *text_im;
  // char_w
  signed int char_w;
  // char_h
  signed int char_h;
  // x_mult
  signed int x_mult;
  // y_mult
  signed int y_mult;
};

struct analogtv_input_s
{
  // signal
  signed char signal[263l][912l];
  // do_teletext
  signed int do_teletext;
  // updater
  void (*updater)(struct analogtv_input_s *);
  // client_data
  void *client_data;
  // next_update_time
  double next_update_time;
};

struct analogtv_reception_s
{
  // input
  struct analogtv_input_s *input;
  // ofs
  double ofs;
  // level
  double level;
  // multipath
  double multipath;
  // freqerr
  double freqerr;
  // ghostfir
  double ghostfir[4l];
  // ghostfir2
  double ghostfir2[4l];
  // hfloss
  double hfloss;
  // hfloss2
  double hfloss2;
};

struct threadpool
{
  // count
  unsigned int count;
  // thread_size
  unsigned long int thread_size;
  // thread_run
  void (*thread_run)(void *);
  // thread_destroy
  void (*thread_destroy)(void *);
  // serial_threads
  void *serial_threads;
  // mutex
  union anonymous_12 mutex;
  // cond
  union anonymous_30 cond;
  // parallel_pending
  unsigned int parallel_pending;
  // parallel_unfinished
  unsigned int parallel_unfinished;
  // parallel_threads
  unsigned long int *parallel_threads;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct analogtv_s
{
  // dpy
  struct _XDisplay *dpy;
  // window
  unsigned long int window;
  // screen
  struct anonymous_9 *screen;
  // xgwa
  struct anonymous_16 xgwa;
  // threads
  struct threadpool threads;
  // n_colors
  signed int n_colors;
  // interlace
  signed int interlace;
  // interlace_counter
  signed int interlace_counter;
  // agclevel
  float agclevel;
  // tint_control
  float tint_control;
  // color_control
  float color_control;
  // brightness_control
  float brightness_control;
  // contrast_control
  float contrast_control;
  // height_control
  float height_control;
  // width_control
  float width_control;
  // squish_control
  float squish_control;
  // horiz_desync
  float horiz_desync;
  // squeezebottom
  float squeezebottom;
  // powerup
  float powerup;
  // blur_mult
  signed int blur_mult;
  // fakeit_top
  signed int fakeit_top;
  // fakeit_bot
  signed int fakeit_bot;
  // fakeit_scroll
  signed int fakeit_scroll;
  // redraw_all
  signed int redraw_all;
  // use_shm
  signed int use_shm;
  // use_cmap
  signed int use_cmap;
  // use_color
  signed int use_color;
  // bilevel_signal
  signed int bilevel_signal;
  // shm_info
  struct anonymous_4 shm_info;
  // visdepth
  signed int visdepth;
  // visclass
  signed int visclass;
  // visbits
  signed int visbits;
  // red_invprec
  signed int red_invprec;
  // red_shift
  signed int red_shift;
  // green_invprec
  signed int green_invprec;
  // green_shift
  signed int green_shift;
  // blue_invprec
  signed int blue_invprec;
  // blue_shift
  signed int blue_shift;
  // red_mask
  unsigned int red_mask;
  // green_mask
  unsigned int green_mask;
  // blue_mask
  unsigned int blue_mask;
  // colormap
  unsigned long int colormap;
  // usewidth
  signed int usewidth;
  // useheight
  signed int useheight;
  // xrepl
  signed int xrepl;
  // subwidth
  signed int subwidth;
  // image
  struct _XImage *image;
  // gc
  struct _XGC *gc;
  // screen_xo
  signed int screen_xo;
  // screen_yo
  signed int screen_yo;
  // flutter_horiz_desync
  signed int flutter_horiz_desync;
  // flutter_tint
  signed int flutter_tint;
  // last_display_time
  struct timeval last_display_time;
  // need_clear
  signed int need_clear;
  // hashnoise_rpm
  double hashnoise_rpm;
  // hashnoise_counter
  signed int hashnoise_counter;
  // hashnoise_times
  signed int hashnoise_times[262l];
  // hashnoise_signal
  signed int hashnoise_signal[262l];
  // hashnoise_on
  signed int hashnoise_on;
  // hashnoise_enable
  signed int hashnoise_enable;
  // shrinkpulse
  signed int shrinkpulse;
  // crtload
  float crtload[262l];
  // red_values
  unsigned int red_values[1024l];
  // green_values
  unsigned int green_values[1024l];
  // blue_values
  unsigned int blue_values[1024l];
  // colors
  unsigned long int colors[256l];
  // cmap_y_levels
  signed int cmap_y_levels;
  // cmap_i_levels
  signed int cmap_i_levels;
  // cmap_q_levels
  signed int cmap_q_levels;
  // tint_i
  float tint_i;
  // tint_q
  float tint_q;
  // cur_hsync
  signed int cur_hsync;
  // line_hsync
  signed int line_hsync[262l];
  // cur_vsync
  signed int cur_vsync;
  // cb_phase
  double cb_phase[4l];
  // line_cb_phase
  double line_cb_phase[262l][4l];
  // channel_change_cycles
  signed int channel_change_cycles;
  // rx_signal_level
  double rx_signal_level;
  // rx_signal
  float *rx_signal;
  // leveltable
  struct anonymous_61 leveltable[13l][13l];
  // random0
  unsigned int random0;
  // random1
  unsigned int random1;
  // noiselevel
  double noiselevel;
  // recs
  const struct analogtv_reception_s * const *recs;
  // rec_count
  unsigned int rec_count;
  // signal_subtotals
  float *signal_subtotals;
  // puheight
  float puheight;
};

struct analogtv_thread_s
{
  // it
  struct analogtv_s *it;
  // thread_id
  unsigned int thread_id;
  // signal_start
  unsigned long int signal_start;
  // signal_end
  unsigned long int signal_end;
};

struct analogtv_yiq_s
{
  // y
  float y;
  // i
  float i;
  // q
  float q;
};

struct apple2_sim_s
{
  // controller_data
  void *controller_data;
  // st
  struct apple2_state *st;
  // dec
  struct analogtv_s *dec;
  // inp
  struct analogtv_input_s *inp;
  // reception
  struct analogtv_reception_s reception;
  // typing
  const char *typing;
  // typing_buf
  char typing_buf[1024l];
  // typing_rate
  double typing_rate;
  // printing
  char *printing;
  // printing_buf
  char printing_buf[1024l];
  // prompt
  char prompt;
  // dpy
  struct _XDisplay *dpy;
  // window
  unsigned long int window;
  // xgwa
  struct anonymous_16 xgwa;
  // text_im
  struct _XImage *text_im;
  // basetime_tv
  struct timeval basetime_tv;
  // curtime
  double curtime;
  // delay
  double delay;
  // stepno
  signed int stepno;
  // next_actiontime
  double next_actiontime;
  // controller
  void (*controller)(struct apple2_sim_s *, signed int *, double *);
};

struct apple2_state
{
  // hireslines
  unsigned char hireslines[192l][40l];
  // textlines
  unsigned char textlines[24l][40l];
  // gr_text
  signed int gr_text;
  // gr_mode
  enum anonymous_53 gr_mode;
  // cursx
  signed int cursx;
  // cursy
  signed int cursy;
  // blink
  signed int blink;
};

struct async_load_state
{
  // done_p
  signed int done_p;
  // filename
  char *filename;
  // geom
  struct anonymous_54 geom;
};

struct basic_controller_data
{
  // prog_line
  signed int prog_line;
  // x
  signed int x;
  // y
  signed int y;
  // k
  signed int k;
  // progtext
  const char * const *progtext;
  // progstep
  signed int progstep;
  // rep_str
  char *rep_str;
  // rep_pos
  signed int rep_pos;
  // prog_start_time
  double prog_start_time;
  // error_buf
  char error_buf[256l];
};

struct fps_state
{
  // dpy
  struct _XDisplay *dpy;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // font
  struct anonymous_59 *font;
  // clear_p
  signed int clear_p;
  // string
  char string[1024l];
  // gl_fps_data
  void *gl_fps_data;
  // draw_gc
  struct _XGC *draw_gc;
  // erase_gc
  struct _XGC *erase_gc;
  // last_ifps
  signed int last_ifps;
  // last_fps
  double last_fps;
  // frame_count
  signed int frame_count;
  // slept
  unsigned long int slept;
  // prev_frame_end
  struct timeval prev_frame_end;
  // this_frame_end
  struct timeval this_frame_end;
};

struct io_thread
{
  // status
  enum _io_thread_status status;
  // thread
  unsigned long int thread;
};

struct ipc_perm
{
  // __key
  signed int __key;
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
  // cuid
  unsigned int cuid;
  // cgid
  unsigned int cgid;
  // mode
  unsigned short int mode;
  // __pad1
  unsigned short int __pad1;
  // __seq
  unsigned short int __seq;
  // __pad2
  unsigned short int __pad2;
  // __glibc_reserved1
  unsigned long int __glibc_reserved1;
  // __glibc_reserved2
  unsigned long int __glibc_reserved2;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct shmid_ds
{
  // shm_perm
  struct ipc_perm shm_perm;
  // shm_segsz
  unsigned long int shm_segsz;
  // shm_atime
  signed long int shm_atime;
  // shm_dtime
  signed long int shm_dtime;
  // shm_ctime
  signed long int shm_ctime;
  // shm_cpid
  signed int shm_cpid;
  // shm_lpid
  signed int shm_lpid;
  // shm_nattch
  unsigned long int shm_nattch;
  // __glibc_reserved4
  unsigned long int __glibc_reserved4;
  // __glibc_reserved5
  unsigned long int __glibc_reserved5;
};

struct slideshow_data_s
{
  // slideno
  signed int slideno;
  // render_img_lineno
  signed int render_img_lineno;
  // render_img
  unsigned char *render_img;
  // img_filename
  char *img_filename;
  // image_loading_p
  signed int image_loading_p;
};

struct state
{
  // duration
  signed int duration;
  // random_p
  signed int random_p;
  // sim
  struct apple2_sim_s *sim;
  // controller
  void (*controller)(struct apple2_sim_s *, signed int *, double *);
};

struct terminal_controller_data
{
  // dpy
  struct _XDisplay *dpy;
  // curword
  char curword[256l];
  // lastc
  unsigned char lastc;
  // last_emit_time
  double last_emit_time;
  // tc
  struct text_data *tc;
  // escstate
  signed int escstate;
  // csiparam
  signed int csiparam[16l];
  // curparam
  signed int curparam;
  // cursor_x
  signed int cursor_x;
  // cursor_y
  signed int cursor_y;
  // saved_x
  signed int saved_x;
  // saved_y
  signed int saved_y;
  // unicruds
  signed int unicruds;
  // unicrud
  char unicrud[7l];
  // termattrib
  union anonymous_43 termattrib;
  // fast_p
  signed int fast_p;
};

struct termios
{
  // c_iflag
  unsigned int c_iflag;
  // c_oflag
  unsigned int c_oflag;
  // c_cflag
  unsigned int c_cflag;
  // c_lflag
  unsigned int c_lflag;
  // c_line
  unsigned char c_line;
  // c_cc
  unsigned char c_cc[32l];
  // c_ispeed
  unsigned int c_ispeed;
  // c_ospeed
  unsigned int c_ospeed;
};

struct text_data
{
  // dpy
  struct _XDisplay *dpy;
  // program
  char *program;
  // pix_w
  signed int pix_w;
  // pix_h
  signed int pix_h;
  // char_w
  signed int char_w;
  // char_h
  signed int char_h;
  // max_lines
  signed int max_lines;
  // pty_p
  signed int pty_p;
  // pipe_timer
  unsigned long int pipe_timer;
  // pipe
  struct _IO_FILE *pipe;
  // pid
  signed int pid;
  // pipe_id
  unsigned long int pipe_id;
  // input_available_p
  signed int input_available_p;
  // subproc_relaunch_delay
  unsigned long int subproc_relaunch_delay;
  // compose
  struct _XComposeStatus compose;
  // meta_sends_esc_p
  signed int meta_sends_esc_p;
  // swap_bs_del_p
  signed int swap_bs_del_p;
  // meta_done_once
  signed int meta_done_once;
  // meta_mask
  unsigned int meta_mask;
  // out_buffer
  const char *out_buffer;
  // out_column
  signed int out_column;
};

struct threadpool_class
{
  // size
  unsigned long int size;
  // create
  signed int (*create)(void *, struct threadpool *, unsigned int);
  // destroy
  void (*destroy)(void *);
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct winsize
{
  // ws_row
  unsigned short int ws_row;
  // ws_col
  unsigned short int ws_col;
  // ws_xpixel
  unsigned short int ws_xpixel;
  // ws_ypixel
  unsigned short int ws_ypixel;
};

struct xscreensaver_function_table
{
  // progclass
  const char *progclass;
  // defaults
  const char * const *defaults;
  // options
  const struct anonymous_39 *options;
  // setup_cb
  void (*setup_cb)(struct xscreensaver_function_table *, void *);
  // setup_arg
  void *setup_arg;
  // init_cb
  void * (*init_cb)(struct _XDisplay *, unsigned long int);
  // draw_cb
  unsigned long int (*draw_cb)(struct _XDisplay *, unsigned long int, void *);
  // reshape_cb
  void (*reshape_cb)(struct _XDisplay *, unsigned long int, void *, unsigned int, unsigned int);
  // event_cb
  signed int (*event_cb)(struct _XDisplay *, unsigned long int, void *, union _XEvent *);
  // free_cb
  void (*free_cb)(struct _XDisplay *, unsigned long int, void *);
  // fps_cb
  void (*fps_cb)(struct _XDisplay *, unsigned long int, struct fps_state *, void *);
  // pick_visual_hook
  struct anonymous_5 * (*pick_visual_hook)(struct anonymous_9 *);
  // validate_visual_hook
  signed int (*validate_visual_hook)(struct anonymous_9 *, const char *, struct anonymous_5 *);
};


// XA_WM_DELETE_WINDOW
// file screenhack.c line 263
static unsigned long int XA_WM_DELETE_WINDOW;
// XA_WM_PROTOCOLS
// file screenhack.c line 263
static unsigned long int XA_WM_PROTOCOLS;
// XtShellStrings
// file /usr/include/X11/Shell.h line 189
extern const char XtShellStrings[];
// XtStrings
// file /usr/include/X11/StringDefs.h line 316
extern const char XtStrings[];
// _cache_line_size
// file thread_util.c line 288
static signed int _cache_line_size = (signed int)sizeof(void *) /*8ul*/ ;
// _has_pthread
// file thread_util.c line 287
static signed int _has_pthread = 0;
// a
// file yarandom.c line 73
static unsigned int a[55l] = { 035340171546, (unsigned int)010401501101, 022364657325, 024130436022, (unsigned int)002167303062, 037570375137, 037210607110, (unsigned int)016272055420, 023011770546, (unsigned int)017143426366, (unsigned int)014753657433, 021657231332, 023553406142, (unsigned int)004236526362, (unsigned int)010365611275, (unsigned int)007117336710, (unsigned int)011051276551, (unsigned int)002362132524, (unsigned int)001011540233, (unsigned int)012162531646, (unsigned int)007056762337, (unsigned int)006631245521, (unsigned int)014164542224, 032633236305, 023342700176, (unsigned int)002433062234, (unsigned int)015257225043, 026762051606, (unsigned int)000742573230, (unsigned int)005366042132, (unsigned int)012126416411, (unsigned int)000520471171, (unsigned int)000725646277, 020116577576, 025765742604, (unsigned int)007633473735, (unsigned int)015674255275, (unsigned int)017555634041, (unsigned int)006503154145, 021576344247, (unsigned int)014577627653, (unsigned int)002707523333, 034146376720, 030060227734, (unsigned int)013765414060, 036072251540, (unsigned int)007255221037, 024364674123, (unsigned int)006200353166, (unsigned int)010126373326, (unsigned int)015664104320, (unsigned int)016401041535, (unsigned int)016215305520, 033115351014, (unsigned int)017411670323 };
// all_programs
// file apple2-main.c line 1600
static struct anonymous_56 all_programs[3l];
// moire_program
// file apple2-main.c line 1438
static const char * const moire_program[14l] = { "10 HGR2\n", "20 FOR Y = 0 TO 190 STEP 2\n", "30 HCOLOR=4 : REM BLACK\n", "40 HPLOT 0,191-Y TO 279,Y\n", "60 HCOLOR=7 : REM WHITE\n", "80 HPLOT 0,190-Y TO 279,Y+1\n", "90 NEXT Y\n", "100 FOR X = 0 TO 278 STEP 3\n", "110 HCOLOR=4\n", "120 HPLOT 279-X,0 TO X,191\n", "140 HCOLOR=7\n", "150 HPLOT 278-X,0 TO X+1,191\n", "160 NEXT X\n", (const char *)(void *)0 };
// random_lores_program
// file apple2-main.c line 1478
static const char * const random_lores_program[17l] = { "1 REM APPLE ][ SCREEN SAVER\n", "10 GR\n", "100 COLOR= RND(1)*16\n", "110 X=RND(1)*40\n", "120 Y1=RND(1)*40\n", "130 Y2=RND(1)*40\n", "140 FOR Y = Y1 TO Y2\n", "150 PLOT X,Y\n", "160 NEXT Y\n", "210 Y=RND(1)*40\n", "220 X1=RND(1)*40\n", "230 X2=RND(1)*40\n", "240 FOR X = X1 TO X2\n", "250 PLOT X,Y\n", "260 NEXT X\n", "300 GOTO 100\n", (const char *)(void *)0 };
// sinewave_program
// file apple2-main.c line 1455
static const char * const sinewave_program[12l] = { "10 HGR\n", "25 K=0\n", "30 FOR X = 0 TO 279\n", "32 HCOLOR= 0\n", "35 HPLOT X,0 TO X,159\n", "38 HCOLOR= 3\n", "40 Y = 80 + SIN(15*(X-K)/279) * 40\n", "50 HPLOT X,Y\n", "60 NEXT X\n", "70 K=K+4\n", "80 GOTO 30\n", (const char *)(void *)0 };
// all_programs
// file apple2-main.c line 1600
static struct anonymous_56 all_programs[3l] = { { .progtext=moire_program, .progstep=100 },
    { .progtext=sinewave_program, .progstep=400 },
    { .progtext=random_lores_program, .progstep=500 } };
// apple2_defaults
// file apple2-main.c line 567
static const char *apple2_defaults[20l] = { ".background:\t\t   black", ".foreground:\t\t   white", "*mode:\t\t   random", "*duration:\t\t   60", "*program:\t\t   xscreensaver-text --cols 40",
    "*metaSendsESC:\t   True", "*swapBSDEL:\t\t   True", "*fast:\t\t   False", "*usePty:                True", "*TVColor:         70", "*TVTint:          5", "*TVBrightness:  2", "*TVContrast:    150", "*Background:      Black", "*use_cmap:        0", "*geometry:\t     800x600", "*fpsSolid:\t     True", "*useThreads: True", "*useSHM:           True", ((const char *)NULL) };
// apple2_font_bits
// file images/apple2font.xbm line 3
static unsigned char apple2_font_bits[448l] = { (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x85, (unsigned char)0x82, (unsigned char)0x30, (unsigned char)0x10, (unsigned char)0x10, (unsigned char)0x10, (unsigned char)0x02, (unsigned char)0x02, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x1c, (unsigned char)0x04, (unsigned char)0xc7, (unsigned char)0x07, (unsigned char)0xf1, (unsigned char)0xe1, (unsigned char)0x7c, (unsigned char)0x1c, (unsigned char)0x0e, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x01, (unsigned char)0x08, (unsigned char)0x38, (unsigned char)0x1c, (unsigned char)0x84, (unsigned char)0x87, (unsigned char)0xe3, (unsigned char)0xf1, (unsigned char)0xf9, (unsigned char)0x78, (unsigned char)0x22, (unsigned char)0x0e, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x10, (unsigned char)0x89, (unsigned char)0x38, (unsigned char)0x1e, (unsigned char)0x8e, (unsigned char)0x87, (unsigned char)0xe3, (unsigned char)0x13, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0xcf, (unsigned char)0x07, (unsigned char)0xf0, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x85, (unsigned char)0xc2, (unsigned char)0x33, (unsigned char)0x29, (unsigned char)0x10, (unsigned char)0x08, (unsigned char)0x84, (unsigned char)0x0a, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x22, (unsigned char)0x86, (unsigned char)0x08, (unsigned char)0x84, (unsigned char)0x11, (unsigned char)0x10, (unsigned char)0x40, (unsigned char)0x22, (unsigned char)0x11, (unsigned char)0x00, (unsigned char)0x80, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x8a, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x08, (unsigned char)0x04, (unsigned char)0x22, (unsigned char)0x04, (unsigned char)0x48, (unsigned char)0x22, (unsigned char)0xb0, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x84, (unsigned char)0x10, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x11, (unsigned char)0xc8, (unsigned char)0x20, (unsigned char)0x80, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0xc5, (unsigned char)0xa7, (unsigned char)0x80, (unsigned char)0x28, (unsigned char)0x10, (unsigned char)0x04, (unsigned char)0x08, (unsigned char)0x07, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x20, (unsigned char)0x32, (unsigned char)0x04, (unsigned char)0x08, (unsigned char)0x42, (unsigned char)0xf1, (unsigned char)0x08, (unsigned char)0x20, (unsigned char)0x22, (unsigned char)0x11, (unsigned char)0x02, (unsigned char)0x41, (unsigned char)0xf0, (unsigned char)0x21, (unsigned char)0x20, (unsigned char)0x2a, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x20, (unsigned char)0x12, (unsigned char)0x08, (unsigned char)0x04, (unsigned char)0x22, (unsigned char)0x04, (unsigned char)0x48, (unsigned char)0x21, (unsigned char)0x50, (unsigned char)0x99, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x80, (unsigned char)0x10, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x14, (unsigned char)0x0a, (unsigned char)0xc4, (unsigned char)0x40, (unsigned char)0x80, (unsigned char)0x21, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x80, (unsigned char)0xc2, (unsigned char)0x41, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x08, (unsigned char)0xc2, (unsigned char)0x07, (unsigned char)0xf0, (unsigned char)0x01, (unsigned char)0x10, (unsigned char)0x2a, (unsigned char)0x04, (unsigned char)0x06, (unsigned char)0x23, (unsigned char)0x01, (unsigned char)0x79, (unsigned char)0x10, (unsigned char)0x1c, (unsigned char)0x1e, (unsigned char)0x00, (unsigned char)0x20, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x10, (unsigned char)0x3a, (unsigned char)0x91, (unsigned char)0x47, (unsigned char)0x20, (unsigned char)0xf2, (unsigned char)0x78, (unsigned char)0x04, (unsigned char)0x3e, (unsigned char)0x04, (unsigned char)0xc8, (unsigned char)0x20, (unsigned char)0x50, (unsigned char)0xa9, (unsigned char)0x44, (unsigned char)0x1e, (unsigned char)0x91, (unsigned char)0x87, (unsigned char)0x83, (unsigned char)0x10, (unsigned char)0x89, (unsigned char)0x54, (unsigned char)0x08, (unsigned char)0x04, (unsigned char)0xc2, (unsigned char)0x80, (unsigned char)0x80, (unsigned char)0x51, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0xc0, (unsigned char)0x87, (unsigned char)0x22, (unsigned char)0xa8, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x08, (unsigned char)0x07, (unsigned char)0x81, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x26, (unsigned char)0x04, (unsigned char)0x01, (unsigned char)0xe4, (unsigned char)0x03, (unsigned char)0x89, (unsigned char)0x08, (unsigned char)0x22, (unsigned char)0x10, (unsigned char)0x02, (unsigned char)0x41, (unsigned char)0xf0, (unsigned char)0x21, (unsigned char)0x10, (unsigned char)0x1a, (unsigned char)0x9f, (unsigned char)0x48, (unsigned char)0x20, (unsigned char)0x12, (unsigned char)0x08, (unsigned char)0x64, (unsigned char)0x22, (unsigned char)0x04, (unsigned char)0x48, (unsigned char)0x21, (unsigned char)0x10, (unsigned char)0xc9, (unsigned char)0x44, (unsigned char)0x02, (unsigned char)0x95, (unsigned char)0x02, (unsigned char)0x84, (unsigned char)0x10, (unsigned char)0x89, (unsigned char)0x54, (unsigned char)0x14, (unsigned char)0x04, (unsigned char)0xc1, (unsigned char)0x00, (unsigned char)0x81, (unsigned char)0x89, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x80, (unsigned char)0xe2, (unsigned char)0x91, (unsigned char)0x49, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x84, (unsigned char)0x0a, (unsigned char)0x81, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x22, (unsigned char)0x84, (unsigned char)0x40, (unsigned char)0x04, (unsigned char)0x11, (unsigned char)0x89, (unsigned char)0x08, (unsigned char)0x22, (unsigned char)0x08, (unsigned char)0x00, (unsigned char)0x81, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x08, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x84, (unsigned char)0x48, (unsigned char)0x22, (unsigned char)0x10, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x02, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x84, (unsigned char)0x10, (unsigned char)0x51, (unsigned char)0x6c, (unsigned char)0x22, (unsigned char)0x84, (unsigned char)0xc0, (unsigned char)0x00, (unsigned char)0x82, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x80, (unsigned char)0x82, (unsigned char)0x80, (unsigned char)0xb1, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x02, (unsigned char)0x02, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x20, (unsigned char)0x00, (unsigned char)0x1c, (unsigned char)0x8e, (unsigned char)0x8f, (unsigned char)0x03, (unsigned char)0xe1, (unsigned char)0x70, (unsigned char)0x08, (unsigned char)0x1c, (unsigned char)0x07, (unsigned char)0x80, (unsigned char)0x00, (unsigned char)0x01, (unsigned char)0x08, (unsigned char)0x10, (unsigned char)0x3c, (unsigned char)0x91, (unsigned char)0x87, (unsigned char)0xe3, (unsigned char)0xf1, (unsigned char)0x09, (unsigned char)0x78, (unsigned char)0x22, (unsigned char)0x0e, (unsigned char)0x47, (unsigned char)0xe4, (unsigned char)0x13, (unsigned char)0x89, (unsigned char)0x38, (unsigned char)0x02, (unsigned char)0x96, (unsigned char)0x88, (unsigned char)0x83, (unsigned char)0xe0, (unsigned char)0x20, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x84, (unsigned char)0xcf, (unsigned char)0x07, (unsigned char)0xf0, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0xfe };
// apple2_options
// file apple2-main.c line 586
static struct anonymous_39 apple2_options[21l] = { { .option="-mode", .specifier=".mode", .argKind=(enum anonymous_40)XrmoptionSepArg, .value=((char *)NULL) },
    { .option="-slideshow", .specifier=".mode", .argKind=(enum anonymous_40)XrmoptionNoArg,
    .value="slideshow" },
    { .option="-basic", .specifier=".mode", .argKind=(enum anonymous_40)XrmoptionNoArg, .value="basic" },
    { .option="-text", .specifier=".mode", .argKind=(enum anonymous_40)XrmoptionNoArg, .value="text" },
    { .option="-program", .specifier=".program", .argKind=(enum anonymous_40)XrmoptionSepArg,
    .value=((char *)NULL) },
    { .option="-duration", .specifier=".duration", .argKind=(enum anonymous_40)XrmoptionSepArg,
    .value=((char *)NULL) },
    { .option="-pty", .specifier=".usePty", .argKind=(enum anonymous_40)XrmoptionNoArg, .value="True" },
    { .option="-pipe", .specifier=".usePty", .argKind=(enum anonymous_40)XrmoptionNoArg,
    .value="False" },
    { .option="-meta", .specifier=".metaSendsESC", .argKind=(enum anonymous_40)XrmoptionNoArg,
    .value="False" },
    { .option="-esc", .specifier=".metaSendsESC", .argKind=(enum anonymous_40)XrmoptionNoArg,
    .value="True" },
    { .option="-bs", .specifier=".swapBSDEL", .argKind=(enum anonymous_40)XrmoptionNoArg,
    .value="False" },
    { .option="-del", .specifier=".swapBSDEL", .argKind=(enum anonymous_40)XrmoptionNoArg,
    .value="True" },
    { .option="-fast", .specifier=".fast", .argKind=(enum anonymous_40)XrmoptionNoArg, .value="True" },
    { .option="-threads", .specifier=".useThreads", .argKind=(enum anonymous_40)XrmoptionNoArg,
    .value="True" },
    { .option="-no-threads", .specifier=".useThreads", .argKind=(enum anonymous_40)XrmoptionNoArg,
    .value="False" },
    { .option="-use-cmap", .specifier=".use_cmap", .argKind=(enum anonymous_40)XrmoptionSepArg,
    .value=((char *)NULL) },
    { .option="-tv-color", .specifier=".TVColor", .argKind=(enum anonymous_40)XrmoptionSepArg,
    .value=((char *)NULL) },
    { .option="-tv-tint", .specifier=".TVTint", .argKind=(enum anonymous_40)XrmoptionSepArg,
    .value=((char *)NULL) },
    { .option="-tv-brightness", .specifier=".TVBrightness", .argKind=(enum anonymous_40)XrmoptionSepArg,
    .value=((char *)NULL) },
    { .option="-tv-contrast", .specifier=".TVContrast", .argKind=(enum anonymous_40)XrmoptionSepArg,
    .value=((char *)NULL) },
    { .option=((char *)NULL), .specifier=((char *)NULL), .argKind=(enum anonymous_40)0,
    .value=((char *)NULL) } };
// apple2_xscreensaver_function_table
// file apple2-main.c line 1915
struct xscreensaver_function_table apple2_xscreensaver_function_table;
// apple2_xscreensaver_function_table
// file apple2-main.c line 1915
struct xscreensaver_function_table apple2_xscreensaver_function_table = { .progclass="Apple2", .defaults=apple2_defaults, .options=apple2_options,
    .setup_cb=((void (*)(struct xscreensaver_function_table *, void *))NULL), .setup_arg=NULL,
    .init_cb=apple2_init, .draw_cb=apple2_draw,
    .reshape_cb=apple2_reshape, .event_cb=apple2_event,
    .free_cb=apple2_free, .fps_cb=((void (*)(struct _XDisplay *, unsigned long int, struct fps_state *, void *))NULL),
    .pick_visual_hook=((struct anonymous_5 * (*)(struct anonymous_9 *))NULL),
    .validate_visual_hook=((signed int (*)(struct anonymous_9 *, const char *, struct anonymous_5 *))NULL) };
// cond_initializer
// file thread_util.c line 285
const union anonymous_30 cond_initializer = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// controllers
// file apple2-main.c line 1787
static void (* const controllers[3l])(struct apple2_sim_s *, signed int *, double *);
// controllers
// file apple2-main.c line 1787
static void (* const controllers[3l])(struct apple2_sim_s *, signed int *, double *) = { slideshow_controller, terminal_controller, basic_controller };
// default_defaults
// file screenhack.c line 163
static char *default_defaults[10l] = { ".root:\t\tfalse", "*geometry:\t\t1280x720", "*mono:\t\tfalse", "*installColormap:\tfalse", "*doFPS:\t\tfalse", "*multiSample:\tfalse", "*visualID:\t\tdefault", "*windowID:\t\t", "*desktopGrabber:\txscreensaver-getimage %s",
    ((char *)NULL) };
// default_options
// file screenhack.c line 141
static struct anonymous_39 default_options[11l] = { { .option="-root", .specifier=".root", .argKind=(enum anonymous_40)XrmoptionNoArg, .value="True" },
    { .option="-window", .specifier=".root", .argKind=(enum anonymous_40)XrmoptionNoArg,
    .value="False" },
    { .option="-mono", .specifier=".mono", .argKind=(enum anonymous_40)XrmoptionNoArg, .value="True" },
    { .option="-install", .specifier=".installColormap", .argKind=(enum anonymous_40)XrmoptionNoArg,
    .value="True" },
    { .option="-noinstall", .specifier=".installColormap", .argKind=(enum anonymous_40)XrmoptionNoArg,
    .value="False" },
    { .option="-visual", .specifier=".visualID", .argKind=(enum anonymous_40)XrmoptionSepArg,
    .value=((char *)NULL) },
    { .option="-window-id", .specifier=".windowID", .argKind=(enum anonymous_40)XrmoptionSepArg,
    .value=((char *)NULL) },
    { .option="-fps", .specifier=".doFPS", .argKind=(enum anonymous_40)XrmoptionNoArg, .value="True" },
    { .option="-no-fps", .specifier=".doFPS", .argKind=(enum anonymous_40)XrmoptionNoArg,
    .value="False" },
    { .option="-pair", .specifier=".pair", .argKind=(enum anonymous_40)XrmoptionNoArg, .value="True" },
    { .option=((char *)NULL), .specifier=((char *)NULL), .argKind=(enum anonymous_40)0,
    .value=((char *)NULL) } };
// error_handler_hit_p
// file grabclient.c line 51
static signed int error_handler_hit_p = 0;
// float_extraction_works
// file analogtv.c line 157
static signed int float_extraction_works;
// float_low8_ofs
// file analogtv.c line 156
static const double float_low8_ofs = 8388608.0;
// font6x10_bits
// file images/6x10font.xbm line 3
static unsigned char font6x10_bits[2240l] = { (unsigned char)0x00, (unsigned char)0x80, (unsigned char)0x0a, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x7e, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x14, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x7c, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x86, (unsigned char)0x03, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x18, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x08, (unsigned char)0x82, (unsigned char)0x44, (unsigned char)0x41, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x08, (unsigned char)0x82, (unsigned char)0x42, (unsigned char)0x80, (unsigned char)0x20, (unsigned char)0x28, (unsigned char)0x00, (unsigned char)0x14, (unsigned char)0x01, (unsigned char)0x82, (unsigned char)0x40, (unsigned char)0x51, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x04, (unsigned char)0x41, (unsigned char)0x81, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x08, (unsigned char)0x02, (unsigned char)0x05, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x08, (unsigned char)0x02, (unsigned char)0x40, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x14, (unsigned char)0x01, (unsigned char)0x82, (unsigned char)0x40, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x04, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x2a, (unsigned char)0x00, (unsigned char)0x55, (unsigned char)0xe2, (unsigned char)0xe0, (unsigned char)0x08, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x89, (unsigned char)0x04, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0xcc, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x61, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x85, (unsigned char)0x82, (unsigned char)0x20, (unsigned char)0x11, (unsigned char)0x10, (unsigned char)0x10, (unsigned char)0x02, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x08, (unsigned char)0x04, (unsigned char)0xc7, (unsigned char)0x07, (unsigned char)0xf1, (unsigned char)0x61, (unsigned char)0x7c, (unsigned char)0x1c, (unsigned char)0x0e, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x10, (unsigned char)0x38, (unsigned char)0x1c, (unsigned char)0x84, (unsigned char)0x87, (unsigned char)0xe3, (unsigned char)0xf1, (unsigned char)0xf9, (unsigned char)0x38, (unsigned char)0x22, (unsigned char)0x0e, (unsigned char)0x4e, (unsigned char)0x24, (unsigned char)0x10, (unsigned char)0x89, (unsigned char)0x38, (unsigned char)0x1e, (unsigned char)0x8e, (unsigned char)0x87, (unsigned char)0xe3, (unsigned char)0x13, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x8f, (unsigned char)0x23, (unsigned char)0xe0, (unsigned char)0x20, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x80, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x60, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x04, (unsigned char)0x48, (unsigned char)0xc0, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x86, (unsigned char)0x60, (unsigned char)0x90, (unsigned char)0x54, (unsigned char)0x2a, (unsigned char)0x95, (unsigned char)0x4a, (unsigned char)0xa5, (unsigned char)0x52, (unsigned char)0xa9, (unsigned char)0x54, (unsigned char)0x2a, (unsigned char)0x95, (unsigned char)0x4a, (unsigned char)0xa5, (unsigned char)0x52, (unsigned char)0xa9, (unsigned char)0x54, (unsigned char)0x2a, (unsigned char)0x95, (unsigned char)0x4a, (unsigned char)0xa5, (unsigned char)0x52, (unsigned char)0xa9, (unsigned char)0x54, (unsigned char)0x2a, (unsigned char)0x95, (unsigned char)0x4a, (unsigned char)0xa5, (unsigned char)0x52, (unsigned char)0xa9, (unsigned char)0x54, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x00, (unsigned char)0x03, (unsigned char)0x10, (unsigned char)0x21, (unsigned char)0x38, (unsigned char)0x00, (unsigned char)0x0e, (unsigned char)0x0e, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x70, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x00, (unsigned char)0x09, (unsigned char)0x84, (unsigned char)0x00, (unsigned char)0xf0, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x06, (unsigned char)0x06, (unsigned char)0x60, (unsigned char)0x30, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x08, (unsigned char)0x04, (unsigned char)0x45, (unsigned char)0x03, (unsigned char)0xa0, (unsigned char)0xe0, (unsigned char)0x39, (unsigned char)0x3e, (unsigned char)0x9f, (unsigned char)0xcf, (unsigned char)0x87, (unsigned char)0x40, (unsigned char)0x50, (unsigned char)0x00, (unsigned char)0x1e, (unsigned char)0x0a, (unsigned char)0x02, (unsigned char)0x41, (unsigned char)0xa1, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x1c, (unsigned char)0x04, (unsigned char)0x82, (unsigned char)0x02, (unsigned char)0x40, (unsigned char)0x08, (unsigned char)0x38, (unsigned char)0x08, (unsigned char)0x04, (unsigned char)0x85, (unsigned char)0x42, (unsigned char)0xa1, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x04, (unsigned char)0x85, (unsigned char)0x82, (unsigned char)0x20, (unsigned char)0x50, (unsigned char)0x28, (unsigned char)0x06, (unsigned char)0x0a, (unsigned char)0x02, (unsigned char)0x41, (unsigned char)0xa1, (unsigned char)0x50, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x82, (unsigned char)0x42, (unsigned char)0x81, (unsigned char)0x00, (unsigned char)0x28, (unsigned char)0x00, (unsigned char)0x84, (unsigned char)0x4a, (unsigned char)0x22, (unsigned char)0x10, (unsigned char)0x08, (unsigned char)0x28, (unsigned char)0x08, (unsigned char)0x8b, (unsigned char)0x04, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x3f, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x03, (unsigned char)0x03, (unsigned char)0x80, (unsigned char)0x90, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x85, (unsigned char)0xc2, (unsigned char)0x51, (unsigned char)0x29, (unsigned char)0x10, (unsigned char)0x08, (unsigned char)0x84, (unsigned char)0x08, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x14, (unsigned char)0x86, (unsigned char)0x08, (unsigned char)0x84, (unsigned char)0x11, (unsigned char)0x10, (unsigned char)0x40, (unsigned char)0x22, (unsigned char)0x11, (unsigned char)0x02, (unsigned char)0x01, (unsigned char)0x01, (unsigned char)0x20, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x0a, (unsigned char)0x49, (unsigned char)0x44, (unsigned char)0x12, (unsigned char)0x08, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x04, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x10, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x84, (unsigned char)0x10, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x11, (unsigned char)0x88, (unsigned char)0x20, (unsigned char)0x80, (unsigned char)0x50, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x80, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x90, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x80, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x81, (unsigned char)0x80, (unsigned char)0xa8, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x82, (unsigned char)0x04, (unsigned char)0x10, (unsigned char)0x21, (unsigned char)0x04, (unsigned char)0x00, (unsigned char)0x11, (unsigned char)0x09, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x88, (unsigned char)0x00, (unsigned char)0x14, (unsigned char)0x04, (unsigned char)0x04, (unsigned char)0x03, (unsigned char)0x00, (unsigned char)0xb8, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x09, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x1c, (unsigned char)0x0e, (unsigned char)0x87, (unsigned char)0xc3, (unsigned char)0xe1, (unsigned char)0x50, (unsigned char)0x44, (unsigned char)0x02, (unsigned char)0x81, (unsigned char)0x40, (unsigned char)0xc0, (unsigned char)0xe1, (unsigned char)0x70, (unsigned char)0x38, (unsigned char)0x24, (unsigned char)0x11, (unsigned char)0x87, (unsigned char)0xc3, (unsigned char)0xe1, (unsigned char)0x70, (unsigned char)0x00, (unsigned char)0x32, (unsigned char)0x91, (unsigned char)0x08, (unsigned char)0x20, (unsigned char)0x12, (unsigned char)0x79, (unsigned char)0x44, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x18, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x08, (unsigned char)0x00, (unsigned char)0x22, (unsigned char)0x0e, (unsigned char)0xd5, (unsigned char)0x63, (unsigned char)0x10, (unsigned char)0x08, (unsigned char)0x10, (unsigned char)0x08, (unsigned char)0x0b, (unsigned char)0x03, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x84, (unsigned char)0x00, (unsigned char)0xe4, (unsigned char)0xf3, (unsigned char)0x11, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0xc5, (unsigned char)0xa7, (unsigned char)0xa0, (unsigned char)0x28, (unsigned char)0x10, (unsigned char)0x04, (unsigned char)0x08, (unsigned char)0x05, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x20, (unsigned char)0x22, (unsigned char)0x05, (unsigned char)0x08, (unsigned char)0x42, (unsigned char)0xd1, (unsigned char)0x08, (unsigned char)0x20, (unsigned char)0x22, (unsigned char)0x19, (unsigned char)0x87, (unsigned char)0x83, (unsigned char)0xf0, (unsigned char)0x41, (unsigned char)0x20, (unsigned char)0x32, (unsigned char)0x11, (unsigned char)0x49, (unsigned char)0x40, (unsigned char)0x12, (unsigned char)0x08, (unsigned char)0x04, (unsigned char)0x22, (unsigned char)0x04, (unsigned char)0x44, (unsigned char)0x21, (unsigned char)0xb0, (unsigned char)0x99, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x80, (unsigned char)0x10, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x14, (unsigned char)0x0a, (unsigned char)0x84, (unsigned char)0x40, (unsigned char)0x80, (unsigned char)0x88, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x8e, (unsigned char)0x86, (unsigned char)0xc3, (unsigned char)0xe2, (unsigned char)0x10, (unsigned char)0x78, (unsigned char)0x1a, (unsigned char)0x06, (unsigned char)0x4c, (unsigned char)0x84, (unsigned char)0xb0, (unsigned char)0x68, (unsigned char)0x38, (unsigned char)0x1a, (unsigned char)0x96, (unsigned char)0x86, (unsigned char)0xe3, (unsigned char)0x11, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x0f, (unsigned char)0x82, (unsigned char)0x40, (unsigned char)0x48, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x8f, (unsigned char)0x20, (unsigned char)0xa2, (unsigned char)0x20, (unsigned char)0x1c, (unsigned char)0x00, (unsigned char)0x15, (unsigned char)0x0d, (unsigned char)0x09, (unsigned char)0x00, (unsigned char)0xb8, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x04, (unsigned char)0x02, (unsigned char)0x04, (unsigned char)0x10, (unsigned char)0xb9, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x49, (unsigned char)0x42, (unsigned char)0x20, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x49, (unsigned char)0x04, (unsigned char)0x02, (unsigned char)0x81, (unsigned char)0x40, (unsigned char)0x80, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x24, (unsigned char)0x93, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x32, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x24, (unsigned char)0x1c, (unsigned char)0x0e, (unsigned char)0x87, (unsigned char)0xc3, (unsigned char)0xe1, (unsigned char)0xf0, (unsigned char)0x38, (unsigned char)0x1c, (unsigned char)0x0e, (unsigned char)0x87, (unsigned char)0xc3, (unsigned char)0x60, (unsigned char)0x30, (unsigned char)0x18, (unsigned char)0x1c, (unsigned char)0x0d, (unsigned char)0x87, (unsigned char)0xc3, (unsigned char)0xe1, (unsigned char)0x70, (unsigned char)0x00, (unsigned char)0x3c, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x79, (unsigned char)0x44, (unsigned char)0x00, (unsigned char)0x9f, (unsigned char)0x4a, (unsigned char)0x22, (unsigned char)0xe0, (unsigned char)0x78, (unsigned char)0x00, (unsigned char)0x3e, (unsigned char)0x0d, (unsigned char)0x01, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x03, (unsigned char)0x43, (unsigned char)0x41, (unsigned char)0x38, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x80, (unsigned char)0xc2, (unsigned char)0x41, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x88, (unsigned char)0xcf, (unsigned char)0x07, (unsigned char)0xf0, (unsigned char)0x01, (unsigned char)0x10, (unsigned char)0x22, (unsigned char)0x04, (unsigned char)0x06, (unsigned char)0x23, (unsigned char)0x31, (unsigned char)0x69, (unsigned char)0x20, (unsigned char)0x1c, (unsigned char)0x16, (unsigned char)0x02, (unsigned char)0x41, (unsigned char)0x00, (unsigned char)0x80, (unsigned char)0x10, (unsigned char)0x2a, (unsigned char)0x11, (unsigned char)0x47, (unsigned char)0x40, (unsigned char)0xf2, (unsigned char)0x78, (unsigned char)0x04, (unsigned char)0x3e, (unsigned char)0x04, (unsigned char)0xc4, (unsigned char)0x20, (unsigned char)0x50, (unsigned char)0xa9, (unsigned char)0x44, (unsigned char)0x1e, (unsigned char)0x91, (unsigned char)0x87, (unsigned char)0x83, (unsigned char)0x10, (unsigned char)0x51, (unsigned char)0x54, (unsigned char)0x08, (unsigned char)0x04, (unsigned char)0x82, (unsigned char)0x80, (unsigned char)0x80, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x90, (unsigned char)0x49, (unsigned char)0x24, (unsigned char)0x13, (unsigned char)0x79, (unsigned char)0x44, (unsigned char)0x26, (unsigned char)0x04, (unsigned char)0x48, (unsigned char)0x82, (unsigned char)0x50, (unsigned char)0x99, (unsigned char)0x44, (unsigned char)0x26, (unsigned char)0x99, (unsigned char)0x49, (unsigned char)0x40, (unsigned char)0x10, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x14, (unsigned char)0x11, (unsigned char)0x84, (unsigned char)0x81, (unsigned char)0x80, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x84, (unsigned char)0xc2, (unsigned char)0xc1, (unsigned char)0x41, (unsigned char)0x00, (unsigned char)0x24, (unsigned char)0x00, (unsigned char)0x13, (unsigned char)0x8a, (unsigned char)0xc4, (unsigned char)0xe3, (unsigned char)0x99, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x1f, (unsigned char)0x8f, (unsigned char)0x03, (unsigned char)0x10, (unsigned char)0xb1, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x0e, (unsigned char)0x86, (unsigned char)0xe4, (unsigned char)0x74, (unsigned char)0x99, (unsigned char)0x10, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0xc9, (unsigned char)0x05, (unsigned char)0x1e, (unsigned char)0x8f, (unsigned char)0xc7, (unsigned char)0x83, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x2e, (unsigned char)0x95, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x28, (unsigned char)0x2a, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0xa2, (unsigned char)0x78, (unsigned char)0x14, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x08, (unsigned char)0x04, (unsigned char)0x02, (unsigned char)0x41, (unsigned char)0x45, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x84, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x22, (unsigned char)0x93, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x7c, (unsigned char)0x32, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x0e, (unsigned char)0x55, (unsigned char)0xa2, (unsigned char)0xe3, (unsigned char)0xf0, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x09, (unsigned char)0xcf, (unsigned char)0xe1, (unsigned char)0xc0, (unsigned char)0xe3, (unsigned char)0xfd, (unsigned char)0x00, (unsigned char)0x80, (unsigned char)0x1f, (unsigned char)0x00, (unsigned char)0xc0, (unsigned char)0x3b, (unsigned char)0xfc, (unsigned char)0x7e, (unsigned char)0x04, (unsigned char)0xcc, (unsigned char)0x40, (unsigned char)0xf1, (unsigned char)0x11, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0xc0, (unsigned char)0x87, (unsigned char)0xa2, (unsigned char)0xa8, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x08, (unsigned char)0x05, (unsigned char)0x01, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x22, (unsigned char)0x04, (unsigned char)0x01, (unsigned char)0xe4, (unsigned char)0x03, (unsigned char)0x99, (unsigned char)0x10, (unsigned char)0x22, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x80, (unsigned char)0xf0, (unsigned char)0x41, (unsigned char)0x10, (unsigned char)0x1a, (unsigned char)0x1f, (unsigned char)0x49, (unsigned char)0x40, (unsigned char)0x12, (unsigned char)0x08, (unsigned char)0x64, (unsigned char)0x22, (unsigned char)0x04, (unsigned char)0x44, (unsigned char)0x21, (unsigned char)0x10, (unsigned char)0xc9, (unsigned char)0x44, (unsigned char)0x02, (unsigned char)0x91, (unsigned char)0x02, (unsigned char)0x84, (unsigned char)0x10, (unsigned char)0x51, (unsigned char)0x54, (unsigned char)0x14, (unsigned char)0x04, (unsigned char)0x81, (unsigned char)0x00, (unsigned char)0x81, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x9e, (unsigned char)0x48, (unsigned char)0x20, (unsigned char)0xf2, (unsigned char)0x11, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x04, (unsigned char)0xc8, (unsigned char)0x81, (unsigned char)0x50, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x80, (unsigned char)0x43, (unsigned char)0x10, (unsigned char)0x51, (unsigned char)0x54, (unsigned char)0x08, (unsigned char)0x19, (unsigned char)0x02, (unsigned char)0x82, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x00, (unsigned char)0x84, (unsigned char)0x82, (unsigned char)0x40, (unsigned char)0xf1, (unsigned char)0x21, (unsigned char)0x48, (unsigned char)0x00, (unsigned char)0x15, (unsigned char)0x40, (unsigned char)0x02, (unsigned char)0x02, (unsigned char)0x98, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0xa1, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x09, (unsigned char)0x86, (unsigned char)0xc2, (unsigned char)0x08, (unsigned char)0x3e, (unsigned char)0x9f, (unsigned char)0xcf, (unsigned char)0xe7, (unsigned char)0xf3, (unsigned char)0x79, (unsigned char)0x04, (unsigned char)0x02, (unsigned char)0x81, (unsigned char)0x40, (unsigned char)0x80, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x24, (unsigned char)0x99, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x10, (unsigned char)0x26, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x42, (unsigned char)0x08, (unsigned char)0x24, (unsigned char)0x3c, (unsigned char)0x1e, (unsigned char)0x8f, (unsigned char)0xc7, (unsigned char)0xe3, (unsigned char)0xf1, (unsigned char)0x05, (unsigned char)0x3e, (unsigned char)0x9f, (unsigned char)0xcf, (unsigned char)0x87, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x00, (unsigned char)0x2a, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x92, (unsigned char)0x89, (unsigned char)0x64, (unsigned char)0x00, (unsigned char)0x84, (unsigned char)0x8a, (unsigned char)0x87, (unsigned char)0x20, (unsigned char)0x11, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x02, (unsigned char)0x04, (unsigned char)0x80, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x04, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x21, (unsigned char)0x90, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x80, (unsigned char)0xc2, (unsigned char)0x51, (unsigned char)0x49, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x84, (unsigned char)0x08, (unsigned char)0x81, (unsigned char)0x01, (unsigned char)0x20, (unsigned char)0x04, (unsigned char)0x14, (unsigned char)0x84, (unsigned char)0x40, (unsigned char)0x04, (unsigned char)0x11, (unsigned char)0x89, (unsigned char)0x08, (unsigned char)0x22, (unsigned char)0x08, (unsigned char)0x02, (unsigned char)0x03, (unsigned char)0x01, (unsigned char)0x20, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x11, (unsigned char)0x49, (unsigned char)0x44, (unsigned char)0x12, (unsigned char)0x08, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x84, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x10, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x02, (unsigned char)0x95, (unsigned char)0x44, (unsigned char)0x84, (unsigned char)0x10, (unsigned char)0x51, (unsigned char)0x6c, (unsigned char)0x22, (unsigned char)0x84, (unsigned char)0x80, (unsigned char)0x00, (unsigned char)0x82, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x91, (unsigned char)0x49, (unsigned char)0x24, (unsigned char)0x13, (unsigned char)0x10, (unsigned char)0x78, (unsigned char)0x22, (unsigned char)0x04, (unsigned char)0x48, (unsigned char)0x82, (unsigned char)0x50, (unsigned char)0x89, (unsigned char)0x44, (unsigned char)0x26, (unsigned char)0x99, (unsigned char)0x00, (unsigned char)0x44, (unsigned char)0x92, (unsigned char)0x51, (unsigned char)0x54, (unsigned char)0x14, (unsigned char)0x16, (unsigned char)0x01, (unsigned char)0x81, (unsigned char)0x80, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x84, (unsigned char)0x82, (unsigned char)0xc4, (unsigned char)0x41, (unsigned char)0x20, (unsigned char)0x70, (unsigned char)0x00, (unsigned char)0x11, (unsigned char)0x8f, (unsigned char)0x04, (unsigned char)0x00, (unsigned char)0x88, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x30, (unsigned char)0xa1, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x8f, (unsigned char)0x04, (unsigned char)0x05, (unsigned char)0xa2, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x49, (unsigned char)0x44, (unsigned char)0x02, (unsigned char)0x81, (unsigned char)0x40, (unsigned char)0x80, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x24, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x28, (unsigned char)0x26, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x42, (unsigned char)0x08, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x49, (unsigned char)0x44, (unsigned char)0x02, (unsigned char)0x81, (unsigned char)0x40, (unsigned char)0x80, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x10, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0x89, (unsigned char)0x10, (unsigned char)0x26, (unsigned char)0x99, (unsigned char)0x4c, (unsigned char)0x26, (unsigned char)0x63, (unsigned char)0x89, (unsigned char)0x58, (unsigned char)0x2a, (unsigned char)0x00, (unsigned char)0x15, (unsigned char)0x82, (unsigned char)0xe1, (unsigned char)0x70, (unsigned char)0x00, (unsigned char)0x3e, (unsigned char)0x02, (unsigned char)0x04, (unsigned char)0x80, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0xc0, (unsigned char)0x0f, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x84, (unsigned char)0xcf, (unsigned char)0x47, (unsigned char)0x11, (unsigned char)0x68, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x80, (unsigned char)0x82, (unsigned char)0x90, (unsigned char)0xb0, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x02, (unsigned char)0x00, (unsigned char)0x80, (unsigned char)0x00, (unsigned char)0x70, (unsigned char)0x04, (unsigned char)0x08, (unsigned char)0x9f, (unsigned char)0x8f, (unsigned char)0x03, (unsigned char)0xe1, (unsigned char)0x70, (unsigned char)0x08, (unsigned char)0x1c, (unsigned char)0x06, (unsigned char)0x07, (unsigned char)0x01, (unsigned char)0x02, (unsigned char)0x10, (unsigned char)0x10, (unsigned char)0x1c, (unsigned char)0x91, (unsigned char)0x87, (unsigned char)0xe3, (unsigned char)0xf1, (unsigned char)0x09, (unsigned char)0x38, (unsigned char)0x22, (unsigned char)0x0e, (unsigned char)0x43, (unsigned char)0xe4, (unsigned char)0x13, (unsigned char)0x89, (unsigned char)0x38, (unsigned char)0x02, (unsigned char)0x8e, (unsigned char)0x88, (unsigned char)0x83, (unsigned char)0xe0, (unsigned char)0x20, (unsigned char)0x44, (unsigned char)0x22, (unsigned char)0x84, (unsigned char)0x8f, (unsigned char)0x03, (unsigned char)0xe2, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x9e, (unsigned char)0x86, (unsigned char)0xc3, (unsigned char)0xe2, (unsigned char)0x10, (unsigned char)0x40, (unsigned char)0x22, (unsigned char)0x0e, (unsigned char)0x49, (unsigned char)0xc4, (unsigned char)0x11, (unsigned char)0x89, (unsigned char)0x38, (unsigned char)0x1a, (unsigned char)0x96, (unsigned char)0xc0, (unsigned char)0x83, (unsigned char)0x61, (unsigned char)0x21, (unsigned char)0x28, (unsigned char)0x22, (unsigned char)0x90, (unsigned char)0x0f, (unsigned char)0x86, (unsigned char)0x60, (unsigned char)0x00, (unsigned char)0x54, (unsigned char)0x2a, (unsigned char)0x95, (unsigned char)0x4a, (unsigned char)0xa5, (unsigned char)0x52, (unsigned char)0xa9, (unsigned char)0x54, (unsigned char)0x2a, (unsigned char)0x95, (unsigned char)0x4a, (unsigned char)0xa5, (unsigned char)0x52, (unsigned char)0xa9, (unsigned char)0x54, (unsigned char)0x2a, (unsigned char)0x95, (unsigned char)0x4a, (unsigned char)0xa5, (unsigned char)0x52, (unsigned char)0xa9, (unsigned char)0x54, (unsigned char)0x2a, (unsigned char)0x95, (unsigned char)0x4a, (unsigned char)0xa5, (unsigned char)0x52, (unsigned char)0xa9, (unsigned char)0x54, (unsigned char)0x00, (unsigned char)0x04, (unsigned char)0x4f, (unsigned char)0x23, (unsigned char)0x42, (unsigned char)0x20, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x0e, (unsigned char)0x00, (unsigned char)0x09, (unsigned char)0x00, (unsigned char)0x70, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x1f, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0xd0, (unsigned char)0xa0, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x82, (unsigned char)0x07, (unsigned char)0xf1, (unsigned char)0x38, (unsigned char)0x22, (unsigned char)0x91, (unsigned char)0x48, (unsigned char)0x24, (unsigned char)0x12, (unsigned char)0xc9, (unsigned char)0x39, (unsigned char)0x3e, (unsigned char)0x9f, (unsigned char)0xcf, (unsigned char)0xc7, (unsigned char)0xe1, (unsigned char)0x70, (unsigned char)0x38, (unsigned char)0x1e, (unsigned char)0x11, (unsigned char)0x87, (unsigned char)0xc3, (unsigned char)0xe1, (unsigned char)0x70, (unsigned char)0x44, (unsigned char)0x1c, (unsigned char)0x0e, (unsigned char)0x87, (unsigned char)0xc3, (unsigned char)0x41, (unsigned char)0x08, (unsigned char)0x34, (unsigned char)0x3c, (unsigned char)0x1e, (unsigned char)0x8f, (unsigned char)0xc7, (unsigned char)0xe3, (unsigned char)0xf1, (unsigned char)0x39, (unsigned char)0x1c, (unsigned char)0x0e, (unsigned char)0x87, (unsigned char)0xc3, (unsigned char)0xe1, (unsigned char)0x70, (unsigned char)0x38, (unsigned char)0x1c, (unsigned char)0x11, (unsigned char)0x87, (unsigned char)0xc3, (unsigned char)0xe1, (unsigned char)0x70, (unsigned char)0x00, (unsigned char)0x1e, (unsigned char)0x16, (unsigned char)0x8b, (unsigned char)0xc5, (unsigned char)0x02, (unsigned char)0x79, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x80, (unsigned char)0x0a, (unsigned char)0x82, (unsigned char)0x20, (unsigned char)0x11, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x04, (unsigned char)0x80, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x20, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x04, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x20, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x82, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x7c, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x44, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x09, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x11, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x00, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x38, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x84, (unsigned char)0x83, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x09, (unsigned char)0x44, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x15, (unsigned char)0x82, (unsigned char)0x20, (unsigned char)0x11, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x1e, (unsigned char)0x04, (unsigned char)0x80, (unsigned char)0x40, (unsigned char)0x00, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0xe0, (unsigned char)0x47, (unsigned char)0x20, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x04, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x38, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x06, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x02, (unsigned char)0x10, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x0e, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x08, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0x00, (unsigned char)0xe0, (unsigned char)0x08, (unsigned char)0x38 };
// global_fast_p
// file apple2-main.c line 819
static signed int global_fast_p;
// global_program
// file apple2-main.c line 818
static const char *global_program;
// hextonib
// file analogtv.c line 2409
static const char hextonib[128l] = { (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)1, (const char)2, (const char)3, (const char)4, (const char)5, (const char)6, (const char)7, (const char)8, (const char)9, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)10, (const char)11, (const char)12, (const char)13, (const char)14, (const char)15, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)10, (const char)11, (const char)12, (const char)13, (const char)14, (const char)15, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0 };
// i1
// file yarandom.c line 87
static signed int i1;
// i2
// file yarandom.c line 87
static signed int i2;
// localbyteorder
// file analogtv.c line 155
static signed int localbyteorder;
// merged_defaults
// file screenhack.c line 178
static char **merged_defaults;
// merged_options
// file screenhack.c line 176
static struct anonymous_39 *merged_options;
// merged_options_size
// file screenhack.c line 177
static signed int merged_options_size;
// mono_p
// file screenhack.c line 138
signed int mono_p;
// mutex_initializer
// file thread_util.c line 277
const union anonymous_12 mutex_initializer = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// old_handler
// file xshm.c line 60
signed int (*old_handler)(struct _XDisplay *, struct anonymous_7 *) = ((signed int (*)(struct _XDisplay *, struct anonymous_7 *))NULL);
// progclass
// file screenhack.c line 137
const char *progclass;
// progname
// file screenhack.c line 136
const char *progname;
// screensaver_id
// file ./../utils/version.h line 1
static const char screensaver_id[69l] = { '@', '(', '#', ')', 'x', 's', 'c', 'r', 'e', 'e', 'n', 's', 'a', 'v', 'e', 'r', ' ', '5', '.', '3', '4', ' ', '(', '2', '4', '-', 'O', 'c', 't', '-', '2', '0', '1', '5', ')', ',', ' ', 'b', 'y', ' ', 'J', 'a', 'm', 'i', 'e', ' ', 'Z', 'a', 'w', 'i', 'n', 's', 'k', 'i', ' ', '(', 'j', 'w', 'z', '@', 'j', 'w', 'z', '.', 'o', 'r', 'g', ')', 0 };
// shm_got_x_error
// file xshm.c line 59
static signed int shm_got_x_error = 0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// topLevelShellWidgetClass
// file /usr/include/X11/Shell.h line 556
extern struct _WidgetClassRec *topLevelShellWidgetClass;
// typo_map
// file apple2-main.c line 1501
static char typo_map[256l];
// xscreensaver_function_table
// file apple2-main.c line 1915
struct xscreensaver_function_table *xscreensaver_function_table;
// xscreensaver_function_table
// file apple2-main.c line 1915
struct xscreensaver_function_table *xscreensaver_function_table = &apple2_xscreensaver_function_table;

// MapNotify_event_p
// file screenhack.c line 256
static signed int MapNotify_event_p(struct _XDisplay *dpy, union _XEvent *event, char *window)
{
  _Bool tmp_if_expr_1;
  if(event->xany.type == 19)
    tmp_if_expr_1 = event->xvisibility.window == (unsigned long int)window ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  return (signed int)tmp_if_expr_1;
}

// VirtualRootWindowOfScreen
// file ./../utils/vroot.h line 87
static unsigned long int VirtualRootWindowOfScreen(struct anonymous_9 *screen)
{
  signed int return_value___isoc99_sscanf_2;
  static unsigned long int root = (unsigned long int)0;
  static struct anonymous_9 *save_screen = (struct anonymous_9 *)0;
  if(!(screen == save_screen))
  {
    struct _XDisplay *dpy = screen->display;
    unsigned long int __SWM_VROOT = (unsigned long int)0L;
    signed int i;
    unsigned long int rootReturn;
    unsigned long int parentReturn;
    unsigned long int *children;
    unsigned int numChildren;
    const char *xss_id;
    xss_id=getenv("XSCREENSAVER_WINDOW");
    if(!(xss_id == ((const char *)NULL)))
    {
      if(!(*xss_id == 0))
      {
        unsigned long int id = (unsigned long int)0;
        char c;
        signed int return_value___isoc99_sscanf_1;
        return_value___isoc99_sscanf_1=__isoc99_sscanf(xss_id, " 0x%lx %c", &id, &c);
        _Bool tmp_if_expr_3;
        if(return_value___isoc99_sscanf_1 == 1)
          tmp_if_expr_3 = (_Bool)1;

        else
        {
          return_value___isoc99_sscanf_2=__isoc99_sscanf(xss_id, " %lu %c", &id, &c);
          tmp_if_expr_3 = 1 == return_value___isoc99_sscanf_2 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_3)
        {
          root = (unsigned long int)id;
          save_screen = screen;
          return root;
        }

      }

    }

    root = screen->root;
    __SWM_VROOT=XInternAtom(dpy, "__SWM_VROOT", 0);
    signed int return_value_XQueryTree_5;
    return_value_XQueryTree_5=XQueryTree(dpy, root, &rootReturn, &parentReturn, &children, &numChildren);
    if(!(return_value_XQueryTree_5 == 0))
    {
      i = 0;
      for( ; !((unsigned int)i >= numChildren); i = i + 1)
      {
        unsigned long int actual_type;
        signed int actual_format;
        unsigned long int nitems;
        unsigned long int bytesafter;
        unsigned char *newRoot = ((unsigned char *)NULL);
        signed int return_value_XGetWindowProperty_4;
        return_value_XGetWindowProperty_4=XGetWindowProperty(dpy, children[(signed long int)i], __SWM_VROOT, (signed long int)0, (signed long int)1, 0, (unsigned long int)33, &actual_type, &actual_format, &nitems, &bytesafter, &newRoot);
        if(return_value_XGetWindowProperty_4 == 0)
        {
          if(!(newRoot == ((unsigned char *)NULL)))
          {
            root = *((unsigned long int *)newRoot);
            break;
          }

        }

      }
      if(!(children == ((unsigned long int *)NULL)))
        XFree((void *)(char *)children);

    }

    save_screen = screen;
  }

  return root;
}

// VirtualRootWindowOfScreen_link1
// file vroot.h line 87
static unsigned long int VirtualRootWindowOfScreen_link1(struct anonymous_9 *screen_link1)
{
  signed int return_value___isoc99_sscanf_2_link1;
  static unsigned long int root_link1 = (unsigned long int)0;
  static struct anonymous_9 *save_screen_link1 = (struct anonymous_9 *)0;
  if(!(screen_link1 == save_screen_link1))
  {
    struct _XDisplay *dpy_link1 = screen_link1->display;
    unsigned long int __SWM_VROOT_link1 = (unsigned long int)0L;
    signed int i_link1;
    unsigned long int rootReturn_link1;
    unsigned long int parentReturn_link1;
    unsigned long int *children_link1;
    unsigned int numChildren_link1;
    const char *xss_id_link1;
    xss_id_link1=getenv("XSCREENSAVER_WINDOW");
    if(!(xss_id_link1 == ((const char *)NULL)))
    {
      if(!(*xss_id_link1 == 0))
      {
        unsigned long int id_link1 = (unsigned long int)0;
        char c_link1;
        signed int return_value___isoc99_sscanf_1_link1;
        return_value___isoc99_sscanf_1_link1=__isoc99_sscanf(xss_id_link1, " 0x%lx %c", &id_link1, &c_link1);
        _Bool tmp_if_expr_3_link1;
        if(return_value___isoc99_sscanf_1_link1 == 1)
          tmp_if_expr_3_link1 = (_Bool)1;

        else
        {
          return_value___isoc99_sscanf_2_link1=__isoc99_sscanf(xss_id_link1, " %lu %c", &id_link1, &c_link1);
          tmp_if_expr_3_link1 = 1 == return_value___isoc99_sscanf_2_link1 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_3_link1)
        {
          root_link1 = (unsigned long int)id_link1;
          save_screen_link1 = screen_link1;
          return root_link1;
        }

      }

    }

    root_link1 = screen_link1->root;
    __SWM_VROOT_link1=XInternAtom(dpy_link1, "__SWM_VROOT", 0);
    signed int return_value_XQueryTree_5_link1;
    return_value_XQueryTree_5_link1=XQueryTree(dpy_link1, root_link1, &rootReturn_link1, &parentReturn_link1, &children_link1, &numChildren_link1);
    if(!(return_value_XQueryTree_5_link1 == 0))
    {
      i_link1 = 0;
      for( ; !((unsigned int)i_link1 >= numChildren_link1); i_link1 = i_link1 + 1)
      {
        unsigned long int actual_type_link1;
        signed int actual_format_link1;
        unsigned long int nitems_link1;
        unsigned long int bytesafter_link1;
        unsigned char *newRoot_link1 = ((unsigned char *)NULL);
        signed int return_value_XGetWindowProperty_4_link1;
        return_value_XGetWindowProperty_4_link1=XGetWindowProperty(dpy_link1, children_link1[(signed long int)i_link1], __SWM_VROOT_link1, (signed long int)0, (signed long int)1, 0, (unsigned long int)33, &actual_type_link1, &actual_format_link1, &nitems_link1, &bytesafter_link1, &newRoot_link1);
        if(return_value_XGetWindowProperty_4_link1 == 0)
        {
          if(!(newRoot_link1 == ((unsigned char *)NULL)))
          {
            root_link1 = *((unsigned long int *)newRoot_link1);
            break;
          }

        }

      }
      if(!(children_link1 == ((unsigned long int *)NULL)))
        XFree((void *)(char *)children_link1);

    }

    save_screen_link1 = screen_link1;
  }

  return root_link1;
}

// XChar2b_to_utf8
// file utf8wc.c line 306
extern char * XChar2b_to_utf8(const struct anonymous_11 *in, signed int *length_ret)
{
  signed int in_len = 0;
  const struct anonymous_11 *in_end;
  signed int out_len;
  char *utf8;
  char *out;
  const char *out_end;
  in_end = in;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(in_end->byte1 == 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = in_end->byte2 != 0 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    in_end = in_end + 1l;
    in_len = in_len + 1;
  }
  while((_Bool)1);
  out_len = (in_len + 1) * 3;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(out_len + 1));
  out = (char *)return_value_malloc_2;
  utf8 = out;
  if(out == ((char *)NULL))
    return ((char *)NULL);

  else
  {
    out_end = out + (signed long int)out_len;
    while(!(in >= in_end))
    {
      unsigned long int uc = (unsigned long int)((signed int)in->byte1 << 8 | (signed int)in->byte2);
      signed int wrote;
      wrote=utf8_encode(uc, out, out_end - out);
      if(wrote >= 4)
        abort();

      out = out + (signed long int)wrote;
      in = in + 1l;
    }
    *out = (char)0;
    out_len = (signed int)((out - utf8) + (signed long int)1);
    void *return_value_realloc_3;
    return_value_realloc_3=realloc((void *)utf8, (unsigned long int)out_len);
    utf8 = (char *)return_value_realloc_3;
    if(!(length_ret == ((signed int *)NULL)))
      *length_ret = out_len;

    return utf8;
  }
}

// _add_next_thread
// file thread_util.c line 551
static void _add_next_thread(struct _parallel_startup_type *self)
{
  /* assertion !self->last_errno */
  assert(!(self->last_errno != 0));
  unsigned int return_value__threadpool_count_parallel_2;
  return_value__threadpool_count_parallel_2=_threadpool_count_parallel(self->parent);
  if(self->parent->parallel_unfinished == return_value__threadpool_count_parallel_2)
  {
    signed int return_value_pthread_cond_broadcast_1;
    return_value_pthread_cond_broadcast_1=pthread_cond_broadcast(&self->parent->cond);
    /* assertion !(pthread_cond_broadcast(&self->parent->cond)) */
    assert(!(return_value_pthread_cond_broadcast_1 != 0));
  }

  else
  {
    unsigned long int *thread = self->parent->parallel_threads + (signed long int)self->parent->parallel_unfinished;
    self->last_errno=pthread_create(thread, (const union pthread_attr_t *)(void *)0, _start_routine, (void *)self);
    if(!(self->last_errno == 0))
      _parallel_abort(self->parent);

  }
}

// _get_cache_line_size
// file thread_util.c line 184
static unsigned int _get_cache_line_size(void)
{
  const signed int *name;
  signed long int result = (signed long int)0;
  static const signed int names[4l] = { 190, 193, 196, 199 };
  name = names;
  for( ; !(name == names + 4l); name = name + 1l)
  {
    signed long int sysconf_result;
    sysconf_result=sysconf(*name);
    if(!(result >= sysconf_result))
      result = sysconf_result;

  }
  if(!(result == 0l))
    return (unsigned int)result;

  else
    return (unsigned int)(1 << 7);
}

// _hardware_concurrency
// file thread_util.c line 462
static unsigned int _hardware_concurrency(void)
{
  signed long int count;
  count=sysconf(84);
  return (unsigned int)(count > (signed long int)0 ? count : (signed long int)1);
}

// _parallel_abort
// file thread_util.c line 527
static void _parallel_abort(struct threadpool *self)
{
  /* assertion self->count > 1 */
  assert(self->count > (unsigned int)1);
  self->count = self->parallel_unfinished + (unsigned int)1;
  signed int return_value_pthread_cond_broadcast_1;
  return_value_pthread_cond_broadcast_1=pthread_cond_broadcast(&self->cond);
  /* assertion !(pthread_cond_broadcast(&self->cond)) */
  assert(!(return_value_pthread_cond_broadcast_1 != 0));
}

// _serial_destroy
// file thread_util.c line 511
static void _serial_destroy(struct threadpool *self)
{
  void *thread = self->serial_threads;
  unsigned int i;
  unsigned int count;
  count=_threadpool_count_serial(self);
  i = (unsigned int)0;
  if(!(i == count))
  {
    self->thread_destroy(thread);
    thread = (void *)((char *)thread + (signed long int)self->thread_size);
    i = i + 1u;
  }

  free(self->serial_threads);
}

// _start_routine
// file thread_util.c line 585
static void * _start_routine(void *startup_raw)
{
  struct _parallel_startup_type *startup = (struct _parallel_startup_type *)startup_raw;
  struct threadpool *parent = startup->parent;
  void *thread;
  signed int return_value_pthread_mutex_lock_1;
  return_value_pthread_mutex_lock_1=pthread_mutex_lock(&parent->mutex);
  /* assertion !(pthread_mutex_lock(&parent->mutex)) */
  assert(!(return_value_pthread_mutex_lock_1 != 0));
  parent->parallel_unfinished = parent->parallel_unfinished + 1u;
  unsigned int return_value_thread_memory_alignment_2;
  return_value_thread_memory_alignment_2=thread_memory_alignment((struct _XDisplay *)(void *)0);
  startup->last_errno=aligned_malloc(&thread, return_value_thread_memory_alignment_2, parent->thread_size);
  if(!(startup->last_errno == 0))
  {
    _parallel_abort(parent);
    signed int return_value_pthread_mutex_unlock_3;
    return_value_pthread_mutex_unlock_3=pthread_mutex_unlock(&parent->mutex);
    /* assertion !(pthread_mutex_unlock(&parent->mutex)) */
    assert(!(return_value_pthread_mutex_unlock_3 != 0));
    return (void *)0;
  }

  startup->last_errno=startup->thread_create(thread, parent, parent->parallel_unfinished);
  if(!(startup->last_errno == 0))
  {
    _parallel_abort(parent);
    void *return_value__thread_free_and_unlock_4;
    return_value__thread_free_and_unlock_4=_thread_free_and_unlock(parent, thread);
    return return_value__thread_free_and_unlock_4;
  }

  /* assertion !startup->last_errno */
  assert(!(startup->last_errno != 0));
  _add_next_thread(startup);
  void *return_value__thread_destroy_and_unlock_5;
  if(!(startup->last_errno == 0))
  {
    return_value__thread_destroy_and_unlock_5=_thread_destroy_and_unlock(parent, thread);
    return return_value__thread_destroy_and_unlock_5;
  }

  void *return_value__thread_destroy_and_unlock_6;
  if(parent->parallel_pending == 0u)
  {
    if(parent->parallel_threads == ((unsigned long int *)NULL))
    {
      return_value__thread_destroy_and_unlock_6=_thread_destroy_and_unlock(parent, thread);
      return return_value__thread_destroy_and_unlock_6;
    }

    signed int return_value_pthread_cond_wait_7;
    return_value_pthread_cond_wait_7=pthread_cond_wait(&parent->cond, &parent->mutex);
    /* assertion !(pthread_cond_wait(&parent->cond, &parent->mutex)) */
    assert(!(return_value_pthread_cond_wait_7 != 0));
  }

  parent->parallel_pending = parent->parallel_pending - 1u;
  signed int return_value_pthread_cond_broadcast_8;
  if(parent->parallel_pending == 0u)
  {
    return_value_pthread_cond_broadcast_8=pthread_cond_broadcast(&parent->cond);
    /* assertion !(pthread_cond_broadcast(&parent->cond)) */
    assert(!(return_value_pthread_cond_broadcast_8 != 0));
  }

  signed int return_value_pthread_mutex_unlock_9;
  return_value_pthread_mutex_unlock_9=pthread_mutex_unlock(&parent->mutex);
  /* assertion !(pthread_mutex_unlock(&parent->mutex)) */
  assert(!(return_value_pthread_mutex_unlock_9 != 0));
  parent->thread_run(thread);
  signed int return_value_pthread_mutex_lock_10;
  return_value_pthread_mutex_lock_10=pthread_mutex_lock(&parent->mutex);
  /* assertion !(pthread_mutex_lock(&parent->mutex)) */
  assert(!(return_value_pthread_mutex_lock_10 != 0));
  signed int return_value_pthread_cond_wait_11;
  if(!(parent->parallel_pending == 0u))
  {
    return_value_pthread_cond_wait_11=pthread_cond_wait(&parent->cond, &parent->mutex);
    /* assertion !(pthread_cond_wait(&parent->cond, &parent->mutex)) */
    assert(!(return_value_pthread_cond_wait_11 != 0));
  }

  parent->parallel_unfinished = parent->parallel_unfinished - 1u;
  signed int return_value_pthread_cond_broadcast_12;
  if(parent->parallel_unfinished == 0u)
  {
    return_value_pthread_cond_broadcast_12=pthread_cond_broadcast(&parent->cond);
    /* assertion !(pthread_cond_broadcast(&parent->cond)) */
    assert(!(return_value_pthread_cond_broadcast_12 != 0));
  }

}

// _thread_destroy_and_unlock
// file thread_util.c line 577
static void * _thread_destroy_and_unlock(struct threadpool *self, void *thread)
{
  self->thread_destroy(thread);
  void *return_value__thread_free_and_unlock_1;
  return_value__thread_free_and_unlock_1=_thread_free_and_unlock(self, thread);
  return return_value__thread_free_and_unlock_1;
}

// _thread_free_and_unlock
// file thread_util.c line 568
static void * _thread_free_and_unlock(struct threadpool *self, void *thread)
{
  signed int return_value_pthread_mutex_unlock_1;
  return_value_pthread_mutex_unlock_1=pthread_mutex_unlock(&self->mutex);
  /* assertion !(pthread_mutex_unlock(&self->mutex)) */
  assert(!(return_value_pthread_mutex_unlock_1 != 0));
  aligned_free(thread);
  return (void *)0;
}

// _threadpool_count_parallel
// file thread_util.c line 541
static unsigned int _threadpool_count_parallel(struct threadpool *self)
{
  /* assertion _has_pthread */
  assert(_has_pthread != 0);
  /* assertion self->count >= 1 */
  assert(self->count >= (unsigned int)1);
  return self->count - (unsigned int)1;
}

// _threadpool_count_serial
// file thread_util.c line 501
static unsigned int _threadpool_count_serial(struct threadpool *self)
{
  /* assertion _has_pthread */
  assert(_has_pthread != 0);
  if(_has_pthread >= 0)
    return (unsigned int)(self->count != 0u ? 1 : 0);

  else
    return self->count;
}

// _unlock_and_destroy
// file thread_util.c line 685
static void _unlock_and_destroy(struct threadpool *self)
{
  unsigned long int *threads = self->parallel_threads;
  self->parallel_threads = (unsigned long int *)(void *)0;
  signed int return_value_pthread_cond_broadcast_1;
  if(!(threads == ((unsigned long int *)NULL)))
  {
    return_value_pthread_cond_broadcast_1=pthread_cond_broadcast(&self->cond);
    /* assertion !(pthread_cond_broadcast(&self->cond)) */
    assert(!(return_value_pthread_cond_broadcast_1 != 0));
  }

  signed int return_value_pthread_mutex_unlock_2;
  return_value_pthread_mutex_unlock_2=pthread_mutex_unlock(&self->mutex);
  /* assertion !(pthread_mutex_unlock(&self->mutex)) */
  assert(!(return_value_pthread_mutex_unlock_2 != 0));
  signed int return_value_pthread_join_3;
  if(!(threads == ((unsigned long int *)NULL)))
  {
    unsigned int i;
    unsigned int count;
    count=_threadpool_count_parallel(self);
    i = (unsigned int)0;
    for( ; !(i == count); i = i + 1u)
    {
      return_value_pthread_join_3=pthread_join(threads[(signed long int)i], (void **)(void *)0);
      /* assertion !(pthread_join(threads[i], ((void *)0))) */
      assert(!(return_value_pthread_join_3 != 0));
    }
    free((void *)threads);
    signed int return_value_pthread_cond_destroy_4;
    return_value_pthread_cond_destroy_4=pthread_cond_destroy(&self->cond);
    /* assertion !(pthread_cond_destroy(&self->cond)) */
    assert(!(return_value_pthread_cond_destroy_4 != 0));
    signed int return_value_pthread_mutex_destroy_5;
    return_value_pthread_mutex_destroy_5=pthread_mutex_destroy(&self->mutex);
    /* assertion !(pthread_mutex_destroy(&self->mutex)) */
    assert(!(return_value_pthread_mutex_destroy_5 != 0));
  }

  _serial_destroy(self);
}

// a2_ascii_printc
// file apple2-main.c line 863
static void a2_ascii_printc(struct apple2_state *st, unsigned char c, signed int bold_p, signed int blink_p, signed int rev_p, signed int scroll_p)
{
  if((signed int)c >= 97 && !((signed int)c >= 123))
    c = c & (unsigned char)0xDF;

  else
    if((signed int)c >= 193 || !((signed int)c == 9) && !((signed int)c == 10) && !((signed int)c == 014) && !((signed int)c == 13) && !((signed int)c >= 32))
      c = (unsigned char)((signed int)c & 0x1F | 0x80);

    else
      if((signed int)c >= 65 && !((signed int)c >= 91))
        c = c | (unsigned char)0x80;

  if(!(bold_p == 0))
    c = c | (unsigned char)0xc0;

  if(!(blink_p == 0))
    c = (unsigned char)((signed int)c & ~0x40 | 0x80);

  if(!(rev_p == 0))
    c = c | (unsigned char)0xc0;

  if(!(scroll_p == 0))
    a2_printc(st, (char)c);

  else
    a2_printc_noscroll(st, (char)c);
}

// a2_clear_gr
// file apple2.c line 169
void a2_clear_gr(struct apple2_state *st)
{
  signed int i = 0;
  for( ; !(i >= 24); i = i + 1)
    memset((void *)st->textlines[(signed long int)i], 0x00, (unsigned long int)40);
}

// a2_clear_hgr
// file apple2.c line 178
void a2_clear_hgr(struct apple2_state *st)
{
  signed int i = 0;
  for( ; !(i >= 192); i = i + 1)
    memset((void *)st->hireslines[(signed long int)i], 0, (unsigned long int)40);
}

// a2_cls
// file apple2.c line 160
void a2_cls(struct apple2_state *st)
{
  signed int i = 0;
  for( ; !(i >= 24); i = i + 1)
    memset((void *)st->textlines[(signed long int)i], 0xe0, (unsigned long int)40);
}

// a2_display_image_loading
// file apple2.c line 318
void a2_display_image_loading(struct apple2_state *st, unsigned char *image, signed int lineno)
{
  signed int row = ((lineno / 24) % 8) * 1 + ((lineno / 3) % 8) * 8 + ((lineno / 1) % 3) * 64;
  memcpy((void *)st->hireslines[(signed long int)row], (const void *)&image[(signed long int)(row * 40)], (unsigned long int)40);
}

// a2_dither
// file apple2-main.c line 228
static void a2_dither(unsigned int *in, unsigned char *out, signed int w, signed int h)
{
  signed int x;
  signed int y;
  unsigned int **pixels;
  unsigned int *pP;
  signed int maxval = 255;
  signed long int *this_rerr;
  signed long int *next_rerr;
  signed long int *this_gerr;
  signed long int *next_gerr;
  signed long int *this_berr;
  signed long int *next_berr;
  signed long int *temp_err;
  signed int fs_scale = 1024;
  signed int brightness = 75;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)(w + 2), sizeof(signed long int) /*8ul*/ );
  this_rerr = (signed long int *)return_value_calloc_1;
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)(w + 2), sizeof(signed long int) /*8ul*/ );
  next_rerr = (signed long int *)return_value_calloc_2;
  void *return_value_calloc_3;
  return_value_calloc_3=calloc((unsigned long int)(w + 2), sizeof(signed long int) /*8ul*/ );
  this_gerr = (signed long int *)return_value_calloc_3;
  void *return_value_calloc_4;
  return_value_calloc_4=calloc((unsigned long int)(w + 2), sizeof(signed long int) /*8ul*/ );
  next_gerr = (signed long int *)return_value_calloc_4;
  void *return_value_calloc_5;
  return_value_calloc_5=calloc((unsigned long int)(w + 2), sizeof(signed long int) /*8ul*/ );
  this_berr = (signed long int *)return_value_calloc_5;
  void *return_value_calloc_6;
  return_value_calloc_6=calloc((unsigned long int)(w + 2), sizeof(signed long int) /*8ul*/ );
  next_berr = (signed long int *)return_value_calloc_6;
  void *return_value_malloc_7;
  return_value_malloc_7=malloc((unsigned long int)h * sizeof(unsigned int *) /*8ul*/ );
  pixels = (unsigned int **)return_value_malloc_7;
  y = 0;
  void *return_value_malloc_8;
  for( ; !(y >= h); y = y + 1)
  {
    return_value_malloc_8=malloc((unsigned long int)w * sizeof(unsigned int) /*4ul*/ );
    pixels[(signed long int)y] = (unsigned int *)return_value_malloc_8;
  }
  x = 0;
  for( ; !(x >= 2 + w); x = x + 1)
  {
    unsigned int return_value_ya_random_9;
    return_value_ya_random_9=ya_random();
    this_rerr[(signed long int)x] = (signed long int)(return_value_ya_random_9 % (unsigned int)(fs_scale * 2) - (unsigned int)fs_scale);
    unsigned int return_value_ya_random_10;
    return_value_ya_random_10=ya_random();
    this_gerr[(signed long int)x] = (signed long int)(return_value_ya_random_10 % (unsigned int)(fs_scale * 2) - (unsigned int)fs_scale);
    unsigned int return_value_ya_random_11;
    return_value_ya_random_11=ya_random();
    this_berr[(signed long int)x] = (signed long int)(return_value_ya_random_11 % (unsigned int)(fs_scale * 2) - (unsigned int)fs_scale);
  }
  y = 0;
  for( ; !(y >= h); y = y + 1)
  {
    x = 0;
    for( ; !(x >= w); x = x + 1)
      pixels[(signed long int)y][(signed long int)x] = in[(signed long int)(y * w + x)];
  }
  y = 0;
  for( ; !(y >= h); y = y + 1)
  {
    signed int xbyte;
    signed int err;
    signed int prev_byte = 0;
    x = 0;
    for( ; !(x >= 2 + w); x = x + 1)
    {
      next_berr[(signed long int)x] = (signed long int)0;
      next_gerr[(signed long int)x] = next_berr[(signed long int)x];
      next_rerr[(signed long int)x] = next_gerr[(signed long int)x];
    }
    pP = pixels[(signed long int)y];
    xbyte = 0;
    for( ; !(xbyte >= 280); xbyte = xbyte + 7)
    {
      signed int best_byte = 0;
      signed int best_error = 2000000000;
      signed int hibit;
      signed int sr;
      signed int sg;
      signed int sb;
      signed int r2;
      signed int g2;
      signed int b2;
      signed int local_rerr = 0;
      signed int local_gerr = 0;
      signed int local_berr = 0;
      hibit = 0;
      static const signed int a2_cmap[2l][2l][3l] = { { { 0x00, 0x80, 0xff }, { 0xff, 0x80, 0x00 } },
    { { 0xa0, 0x40, 0xa0 }, { 0x40, 0xff, 0x40 } } };
      for( ; !(hibit >= 2); hibit = hibit + 1)
      {
        signed int byte = hibit << 7;
        signed int tot_error = 0;
        x = xbyte;
        for( ; !(x >= 7 + xbyte); x = x + 1)
        {
          signed int dist0;
          signed int dist1;
          sr = (signed int)(((pP[(signed long int)x] >> 16 & (unsigned int)0xFF) * (unsigned int)brightness) / (unsigned int)256);
          sg = (signed int)(((pP[(signed long int)x] >> 8 & (unsigned int)0xFF) * (unsigned int)brightness) / (unsigned int)256);
          sb = (signed int)(((pP[(signed long int)x] & (unsigned int)0xFF) * (unsigned int)brightness) / (unsigned int)256);
          sr = sr + (signed int)((this_rerr[(signed long int)(x + 1)] + (signed long int)local_rerr) / (signed long int)fs_scale);
          sg = sg + (signed int)((this_gerr[(signed long int)(x + 1)] + (signed long int)local_gerr) / (signed long int)fs_scale);
          sb = sb + (signed int)((this_berr[(signed long int)(x + 1)] + (signed long int)local_berr) / (signed long int)fs_scale);
          if(!(sr >= 0))
            sr = 0;

          else
            if(!(maxval >= sr))
              sr = maxval;

          if(!(sg >= 0))
            sg = 0;

          else
            if(!(maxval >= sg))
              sg = maxval;

          if(!(sb >= 0))
            sb = 0;

          else
            if(!(maxval >= sb))
              sb = maxval;

          r2 = a2_cmap[(signed long int)hibit][(signed long int)(x & 1)][(signed long int)0];
          g2 = a2_cmap[(signed long int)hibit][(signed long int)(x & 1)][(signed long int)1];
          b2 = a2_cmap[(signed long int)hibit][(signed long int)(x & 1)][(signed long int)2];
          dist1 = (sr - r2) * (sr - r2) + (sg - g2) * (sg - g2) + (sb - b2) * (sb - b2);
          dist0 = sr * sr + sg * sg + sb * sb;
          if(!(dist1 >= dist0))
          {
            byte = byte | 1 << x - xbyte;
            tot_error = tot_error + dist1;
            local_rerr = ((sr - r2) * fs_scale * 7) / 16;
            local_gerr = ((sg - g2) * fs_scale * 7) / 16;
            local_berr = ((sb - b2) * fs_scale * 7) / 16;
          }

          else
          {
            tot_error = tot_error + dist0;
            local_rerr = (sr * fs_scale * 7) / 16;
            local_gerr = (sg * fs_scale * 7) / 16;
            local_berr = (sb * fs_scale * 7) / 16;
          }
        }
        if(!(tot_error >= best_error))
        {
          best_byte = byte;
          best_error = tot_error;
        }

      }
      if((0x7f & best_byte) == 0x7f && (0x7f & prev_byte) == 0x7f)
        best_byte = prev_byte;

      prev_byte = best_byte;
      x = xbyte;
      for( ; !(x >= 7 + xbyte); x = x + 1)
      {
        signed int bit = best_byte >> x - xbyte & 1;
        hibit = best_byte >> 7 & 1;
        sr = (signed int)(pP[(signed long int)x] >> 16 & (unsigned int)0xFF);
        sg = (signed int)(pP[(signed long int)x] >> 8 & (unsigned int)0xFF);
        sb = (signed int)(pP[(signed long int)x] & (unsigned int)0xFF);
        sr = sr + (signed int)(this_rerr[(signed long int)(x + 1)] / (signed long int)fs_scale);
        sg = sg + (signed int)(this_gerr[(signed long int)(x + 1)] / (signed long int)fs_scale);
        sb = sb + (signed int)(this_berr[(signed long int)(x + 1)] / (signed long int)fs_scale);
        if(!(sr >= 0))
          sr = 0;

        else
          if(!(maxval >= sr))
            sr = maxval;

        if(!(sg >= 0))
          sg = 0;

        else
          if(!(maxval >= sg))
            sg = maxval;

        if(!(sb >= 0))
          sb = 0;

        else
          if(!(maxval >= sb))
            sb = maxval;

        r2 = a2_cmap[(signed long int)hibit][(signed long int)(x & 1)][(signed long int)0] * bit;
        g2 = a2_cmap[(signed long int)hibit][(signed long int)(x & 1)][(signed long int)1] * bit;
        b2 = a2_cmap[(signed long int)hibit][(signed long int)(x & 1)][(signed long int)2] * bit;
        pP[(signed long int)x] = (unsigned int)(r2 << 16 | g2 << 8 | b2);
        err = (sr - r2) * fs_scale;
        this_rerr[(signed long int)(x + 2)] = this_rerr[(signed long int)(x + 2)] + (signed long int)((err * 7) / 16);
        next_rerr[(signed long int)x] = next_rerr[(signed long int)x] + (signed long int)((err * 3) / 16);
        next_rerr[(signed long int)(x + 1)] = next_rerr[(signed long int)(x + 1)] + (signed long int)((err * 5) / 16);
        next_rerr[(signed long int)(x + 2)] = next_rerr[(signed long int)(x + 2)] + (signed long int)(err / 16);
        err = (sg - g2) * fs_scale;
        this_gerr[(signed long int)(x + 2)] = this_gerr[(signed long int)(x + 2)] + (signed long int)((err * 7) / 16);
        next_gerr[(signed long int)x] = next_gerr[(signed long int)x] + (signed long int)((err * 3) / 16);
        next_gerr[(signed long int)(x + 1)] = next_gerr[(signed long int)(x + 1)] + (signed long int)((err * 5) / 16);
        next_gerr[(signed long int)(x + 2)] = next_gerr[(signed long int)(x + 2)] + (signed long int)(err / 16);
        err = (sb - b2) * fs_scale;
        this_berr[(signed long int)(x + 2)] = this_berr[(signed long int)(x + 2)] + (signed long int)((err * 7) / 16);
        next_berr[(signed long int)x] = next_berr[(signed long int)x] + (signed long int)((err * 3) / 16);
        next_berr[(signed long int)(x + 1)] = next_berr[(signed long int)(x + 1)] + (signed long int)((err * 5) / 16);
        next_berr[(signed long int)(x + 2)] = next_berr[(signed long int)(x + 2)] + (signed long int)(err / 16);
      }
      out[(signed long int)(y * (w / 7) + xbyte / 7)] = (unsigned char)best_byte;
    }
    temp_err = this_rerr;
    this_rerr = next_rerr;
    next_rerr = temp_err;
    temp_err = this_gerr;
    this_gerr = next_gerr;
    next_gerr = temp_err;
    temp_err = this_berr;
    this_berr = next_berr;
    next_berr = temp_err;
  }
  free((void *)this_rerr);
  free((void *)next_rerr);
  free((void *)this_gerr);
  free((void *)next_gerr);
  free((void *)this_berr);
  free((void *)next_berr);
  y = 0;
  for( ; !(y >= h); y = y + 1)
    free((void *)pixels[(signed long int)y]);
  free((void *)pixels);
}

// a2_goto
// file apple2.c line 149
void a2_goto(struct apple2_state *st, signed int r, signed int c)
{
  if(r >= 24)
    r = 23;

  if(c >= 40)
    c = 39;

  st->textlines[(signed long int)st->cursy][(signed long int)st->cursx] = st->textlines[(signed long int)st->cursy][(signed long int)st->cursx] | (unsigned char)0xc0;
  st->cursy = r;
  st->cursx = c;
  st->textlines[(signed long int)st->cursy][(signed long int)st->cursx] = st->textlines[(signed long int)st->cursy][(signed long int)st->cursx] & (unsigned char)0x7f;
}

// a2_hline
// file apple2.c line 246
void a2_hline(struct apple2_state *st, signed int hcolor, signed int x1, signed int y1, signed int x2, signed int y2)
{
  signed int dx;
  signed int dy;
  signed int incx;
  signed int incy;
  signed int x;
  signed int y;
  signed int balance;
  if(x2 >= x1)
  {
    dx = x2 - x1;
    incx = 1;
  }

  else
  {
    dx = x1 - x2;
    incx = -1;
  }
  if(y2 >= y1)
  {
    dy = y2 - y1;
    incy = 1;
  }

  else
  {
    dy = y1 - y2;
    incy = -1;
  }
  x = x1;
  y = y1;
  if(dx >= dy)
  {
    dy = dy * 2;
    balance = dy - dx;
    dx = dx * 2;
    for( ; !(x == x2); x = x + incx)
    {
      a2_hplot(st, hcolor, x, y);
      if(balance >= 0)
      {
        y = y + incy;
        balance = balance - dx;
      }

      balance = balance + dy;
    }
    a2_hplot(st, hcolor, x, y);
  }

  else
  {
    dx = dx * 2;
    balance = dx - dy;
    dy = dy * 2;
    for( ; !(y == y2); y = y + incy)
    {
      a2_hplot(st, hcolor, x, y);
      if(balance >= 0)
      {
        x = x + incx;
        balance = balance - dy;
      }

      balance = balance + dx;
    }
    a2_hplot(st, hcolor, x, y);
  }
}

// a2_hplot
// file apple2.c line 220
void a2_hplot(struct apple2_state *st, signed int hcolor, signed int x, signed int y)
{
  signed int highbit;
  signed int run;
  highbit = hcolor << 5 & 0x80 ^ 0x80;
  if(!(x >= 280) && !(y >= 192) && x >= 0 && y >= 0)
  {
    run = 0;
    for( ; !(run >= 2) && !(x >= 280); run = run + 1)
    {
      unsigned char *vidbyte = &st->hireslines[(signed long int)y][(signed long int)(x / 7)];
      unsigned char whichbit = (unsigned char)(1 << x % 7);
      signed int masked_bit;
      *vidbyte = (unsigned char)((signed int)*vidbyte & 0x7f | highbit);
      masked_bit = hcolor >> 1 - (x & 1) & 1;
      *vidbyte = (unsigned char)((signed int)*vidbyte & ~((signed int)whichbit) | (masked_bit != 0 ? (signed int)whichbit : 0));
      x = x + 1;
    }
  }

}

// a2_init_memory_active
// file apple2.c line 340
void a2_init_memory_active(struct apple2_sim_s *sim)
{
  signed int i;
  signed int j;
  signed int x;
  signed int y;
  signed int c;
  signed int addr = 0;
  struct apple2_state *st = sim->st;
  unsigned int return_value_ya_random_2;
  unsigned int return_value_ya_random_4;
  unsigned int return_value_ya_random_7;
  unsigned int return_value_ya_random_10;
  while(!(addr >= 0x4000))
  {
    signed int n;
    unsigned int return_value_ya_random_1;
    return_value_ya_random_1=ya_random();
    switch(return_value_ya_random_1 % (unsigned int)4)
    {
      case (unsigned int)0:

      case (unsigned int)1:
      {
        return_value_ya_random_2=ya_random();
        n = (signed int)(return_value_ya_random_2 % (unsigned int)500);
        i = 0;
        for( ; !(addr >= 0x4000) && !(i >= n); i = i + 1)
        {
          unsigned char rb;
          unsigned int return_value_ya_random_3;
          return_value_ya_random_3=ya_random();
          unsigned int tmp_if_expr_5;
          if(return_value_ya_random_3 % 6u == 0u)
            tmp_if_expr_5 = (unsigned int)0;

          else
          {
            return_value_ya_random_4=ya_random();
            tmp_if_expr_5 = return_value_ya_random_4 % (unsigned int)16;
          }
          unsigned int return_value_ya_random_6;
          return_value_ya_random_6=ya_random();
          unsigned int tmp_if_expr_8;
          if(return_value_ya_random_6 % 5u == 0u)
            tmp_if_expr_8 = (unsigned int)0;

          else
          {
            return_value_ya_random_7=ya_random();
            tmp_if_expr_8 = return_value_ya_random_7 % (unsigned int)16;
          }
          rb = (unsigned char)(tmp_if_expr_5 | tmp_if_expr_8 << 4);
          signed int tmp_post_9 = addr;
          addr = addr + 1;
          a2_poke(st, tmp_post_9, (signed int)rb);
        }
        break;
      }
      case (unsigned int)2:
      {
        return_value_ya_random_10=ya_random();
        x = (signed int)(return_value_ya_random_10 % (unsigned int)sim->text_im->width);
        i = 0;
        for( ; !(i >= 100); i = i + 1)
        {
          y = 0;
          for( ; !(y >= 8); y = y + 1)
          {
            c = 0;
            j = 0;
            if(!(j >= 8))
            {
              unsigned long int return_value;
              return_value=sim->text_im->f.get_pixel(sim->text_im, (x + j) % sim->text_im->width, y);
              c = c | (signed int)(return_value << j);
              j = j + 1;
            }

            signed int tmp_post_11 = addr;
            addr = addr + 1;
            a2_poke(st, tmp_post_11, c);
          }
          x = (x + 1) % sim->text_im->width;
        }
        break;
      }
      case (unsigned int)3:
        if(addr >= 8193)
        {
          unsigned int return_value_ya_random_12;
          return_value_ya_random_12=ya_random();
          n = (signed int)(return_value_ya_random_12 % (unsigned int)200);
          i = 0;
          for( ; !(addr >= 0x4000) && !(i >= n); i = i + 1)
          {
            signed int tmp_post_13 = addr;
            addr = addr + 1;
            a2_poke(st, tmp_post_13, 0);
          }
        }

    }
  }
}

// a2_invalidate
// file apple2.c line 187
void a2_invalidate(struct apple2_state *st)
{
  ;
}

// a2_make_font
// file apple2.c line 398
static void a2_make_font(struct apple2_sim_s *sim)
{
  unsigned long int text_pm;
  text_pm=XCreatePixmapFromBitmapData(sim->dpy, sim->window, (char *)apple2_font_bits, (unsigned int)448, (unsigned int)8, (unsigned long int)1, (unsigned long int)0, (unsigned int)1);
  sim->text_im=XGetImage(sim->dpy, text_pm, 0, 0, (unsigned int)448, (unsigned int)8, (unsigned long int)~0L, 2);
  XFreePixmap(sim->dpy, text_pm);
}

// a2_plot
// file apple2.c line 301
void a2_plot(struct apple2_state *st, signed int color, signed int x, signed int y)
{
  signed int textrow = y / 2;
  unsigned char byte;
  if(!(x >= 40) && !(y >= 48) && x >= 0 && y >= 0)
  {
    byte = st->textlines[(signed long int)textrow][(signed long int)x];
    if(!((1 & y) == 0))
      byte = (unsigned char)((signed int)byte & 0xf0 | color & 0x0f);

    else
      byte = (unsigned char)((signed int)byte & 0x0f | (color & 0x0f) << 4);
    st->textlines[(signed long int)textrow][(signed long int)x] = byte;
  }

}

// a2_poke
// file apple2.c line 192
void a2_poke(struct apple2_state *st, signed int addr, signed int val)
{
  if(addr >= 0x400 && !(addr >= 0x800))
  {
    signed int row = (addr & 0x380) / 0x80 + ((addr & 0x7f) / 0x28) * 8;
    signed int col = (addr & 0x7f) % 0x28;
    if(!(col >= 40) && !(row >= 24))
    {
      st->textlines[(signed long int)row][(signed long int)col] = (unsigned char)val;
      _Bool tmp_if_expr_1;
      if((A2_GR_HIRES & (signed int)st->gr_mode) == 0)
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = (!(((signed int)st->gr_mode & A2_GR_FULL) != 0) ? (row >= 20 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
    }

  }

  else
    if(addr >= 0x2000 && !(addr >= 0x4000))
    {
      signed int a2_poke__1__2__row = ((addr & 0x1c00) / 0x400) * 1 + ((addr & 0x0380) / 0x80) * 8 + ((addr & 0x0078) / 0x28) * 64;
      signed int a2_poke__1__2__col = (addr & 0x07f) % 0x28;
      if(!(a2_poke__1__2__col >= 40) && !(a2_poke__1__2__row >= 192))
        st->hireslines[(signed long int)a2_poke__1__2__row][(signed long int)a2_poke__1__2__col] = (unsigned char)val;

    }

}

// a2_printc
// file apple2.c line 130
void a2_printc(struct apple2_state *st, char c)
{
  a2_printc_1(st, c, 1);
}

// a2_printc_1
// file apple2.c line 76
static void a2_printc_1(struct apple2_state *st, char c, signed int scroll_p)
{
  st->textlines[(signed long int)st->cursy][(signed long int)st->cursx] = st->textlines[(signed long int)st->cursy][(signed long int)st->cursx] | (unsigned char)0xc0;
  if((signed int)c == 10)
  {
    if(st->cursy == 23)
    {
      if(!(scroll_p == 0))
        a2_scroll(st);

    }

    else
      st->cursy = st->cursy + 1;
    st->cursx = 0;
  }

  else
    if((signed int)c == 014)
    {
      a2_cls(st);
      a2_goto(st, 0, 0);
    }

    else
      if((signed int)c == 9)
        a2_goto(st, st->cursy, st->cursx + 8 & ~7);

      else
        if((signed int)c == 010)
        {
          st->textlines[(signed long int)st->cursy][(signed long int)st->cursx] = (unsigned char)0xe0;
          a2_goto(st, st->cursy, st->cursx - 1);
        }

        else
          if((signed int)c == 13)
            st->cursx = 0;

          else
          {
            st->textlines[(signed long int)st->cursy][(signed long int)st->cursx] = (unsigned char)((signed int)c ^ 0xc0);
            st->cursx = st->cursx + 1;
            if(st->cursx == 40)
            {
              if(st->cursy == 23)
              {
                if(!(scroll_p == 0))
                  a2_scroll(st);

              }

              else
                st->cursy = st->cursy + 1;
              st->cursx = 0;
            }

          }
  st->textlines[(signed long int)st->cursy][(signed long int)st->cursx] = st->textlines[(signed long int)st->cursy][(signed long int)st->cursx] & (unsigned char)0x7f;
}

// a2_printc_noscroll
// file apple2.c line 136
void a2_printc_noscroll(struct apple2_state *st, char c)
{
  a2_printc_1(st, c, 0);
}

// a2_prints
// file apple2.c line 143
void a2_prints(struct apple2_state *st, char *s)
{
  while(!(*s == 0))
  {
    char *tmp_post_1 = s;
    s = s + 1l;
    a2_printc(st, *tmp_post_1);
  }
}

// a2_scroll
// file apple2.c line 64
void a2_scroll(struct apple2_state *st)
{
  signed int i;
  st->textlines[(signed long int)st->cursy][(signed long int)st->cursx] = st->textlines[(signed long int)st->cursy][(signed long int)st->cursx] | (unsigned char)0xc0;
  i = 0;
  for( ; !(i >= 23); i = i + 1)
    memcpy((void *)st->textlines[(signed long int)i], (const void *)st->textlines[(signed long int)(i + 1)], (unsigned long int)40);
  memset((void *)st->textlines[(signed long int)23], 0xe0, (unsigned long int)40);
}

// a2_vt100_printc
// file apple2-main.c line 894
static void a2_vt100_printc(struct apple2_sim_s *sim, struct terminal_controller_data *state, unsigned char c)
{
  struct apple2_state *st = sim->st;
  signed int cols = 40;
  signed int rows = 24;
  signed int i;
  signed int start;
  signed int end;
  if(!(state->escstate == 0))
  {
    if(state->escstate == 1)
      goto __CPROVER_DUMP_L29;

    if(state->escstate == 2)
      goto __CPROVER_DUMP_L46;

    if(state->escstate == 3)
      goto __CPROVER_DUMP_L109;

    if(state->escstate == 102 || state->escstate == 103 || state->escstate == 104 || state->escstate == 105 || state->escstate == 106)
      goto __CPROVER_DUMP_L110;

  }

  else
  {
    switch((signed int)c)
    {
      case 7:
        goto __CPROVER_DUMP_L28;
      case 8:
      {
        if(state->cursor_x >= 1)
          state->cursor_x = state->cursor_x - 1;

        goto __CPROVER_DUMP_L28;
      }
      case 9:
      {
        if(!(state->cursor_x >= cols + -8))
          state->cursor_x = (state->cursor_x & ~7) + 8;

        else
        {
          state->cursor_x = 0;
          if(!(state->cursor_y >= rows + -1))
            state->cursor_y = state->cursor_y + 1;

          else
            a2_scroll(st);
        }
        goto __CPROVER_DUMP_L28;
      }
      case 10:

      case 11:

      case 12:
      {
        if(!(state->cursor_y >= rows + -1))
          state->cursor_y = state->cursor_y + 1;

        else
          a2_scroll(st);
        goto __CPROVER_DUMP_L28;
      }
      case 13:
      {
        state->cursor_x = 0;
        goto __CPROVER_DUMP_L28;
      }
      case 14:

      case 15:
        goto __CPROVER_DUMP_L28;
      case 24:

      case 26:
        goto __CPROVER_DUMP_L28;
      case 27:
      {
        state->escstate = 1;
        goto __CPROVER_DUMP_L28;
      }
      case 127:
        goto __CPROVER_DUMP_L28;
      case 155:
      {
        state->escstate = 2;
        i = 0;
        for( ; !(i >= 16); i = i + 1)
          state->csiparam[(signed long int)i] = 0;
        state->curparam = 0;
        goto __CPROVER_DUMP_L28;
      }
      default:
        if((0xE0 & (signed int)c) == 0xC0)
        {
          state->unicruds = 1;
          state->unicrud[(signed long int)0] = (char)c;
          state->escstate = 102;
          goto __CPROVER_DUMP_L28;
        }

        else
          if((0xF0 & (signed int)c) == 0xE0)
          {
            state->unicruds = 1;
            state->unicrud[(signed long int)0] = (char)c;
            state->escstate = 103;
            goto __CPROVER_DUMP_L28;
          }

          else
            if((0xF8 & (signed int)c) == 0xF0)
            {
              state->unicruds = 1;
              state->unicrud[(signed long int)0] = (char)c;
              state->escstate = 104;
              goto __CPROVER_DUMP_L28;
            }

            else
              if((0xFC & (signed int)c) == 0xF8)
              {
                state->unicruds = 1;
                state->unicrud[(signed long int)0] = (char)c;
                state->escstate = 105;
                goto __CPROVER_DUMP_L28;
              }

              else
                if((0xFE & (signed int)c) == 0xFC)
                {
                  state->unicruds = 1;
                  state->unicrud[(signed long int)0] = (char)c;
                  state->escstate = 106;
                  goto __CPROVER_DUMP_L28;
                }

    }

  PRINT:
    ;
    if(state->cursor_x >= cols)
    {
      state->cursor_x = 0;
      if(state->cursor_y >= rows + -1)
        a2_scroll(st);

      else
        state->cursor_y = state->cursor_y + 1;
    }

    a2_goto(st, state->cursor_y, state->cursor_x);
    a2_ascii_printc(st, c, (signed int)state->termattrib.bf.bold, (signed int)state->termattrib.bf.blink, (signed int)state->termattrib.bf.rev, 0);
    state->cursor_x = state->cursor_x + 1;

  __CPROVER_DUMP_L28:
    ;
    goto __CPROVER_DUMP_L116;

  __CPROVER_DUMP_L29:
    ;
    switch((signed int)c)
    {
      case 24:

      case 26:
      {
        state->escstate = 0;
        break;
      }
      case 99:
      {
        a2_cls(st);
        state->escstate = 0;
        break;
      }
      case 68:
      {
        if(!(state->cursor_y >= rows + -1))
          state->cursor_y = state->cursor_y + 1;

        else
          a2_scroll(st);
        state->escstate = 0;
        break;
      }
      case 69:
      {
        state->cursor_x = 0;
        state->escstate = 0;
        break;
      }
      case 77:
      {
        if(state->cursor_y >= 1)
          state->cursor_y = state->cursor_y - 1;

        state->escstate = 0;
        break;
      }
      case 55:
      {
        state->saved_x = state->cursor_x;
        state->saved_y = state->cursor_y;
        state->escstate = 0;
        break;
      }
      case 56:
      {
        state->cursor_x = state->saved_x;
        state->cursor_y = state->saved_y;
        state->escstate = 0;
        break;
      }
      case 91:
      {
        state->escstate = 2;
        i = 0;
        for( ; !(i >= 16); i = i + 1)
          state->csiparam[(signed long int)i] = 0;
        state->curparam = 0;
        break;
      }
      case 37:

      case 40:

      case 41:
      {
        state->escstate = 3;
        break;
      }
      default:
        state->escstate = 0;
    }
    goto __CPROVER_DUMP_L116;

  __CPROVER_DUMP_L46:
    ;
    switch((signed int)c)
    {
      case 24:

      case 26:
      {
        state->escstate = 0;
        break;
      }
      case 48:

      case 49:

      case 50:

      case 51:

      case 52:

      case 53:

      case 54:

      case 55:

      case 56:

      case 57:
      {
        if(!(state->curparam >= 16))
          state->csiparam[(signed long int)state->curparam] = state->csiparam[(signed long int)state->curparam] * 10 + ((signed int)c - 48);

        break;
      }
      case 59:
      {
        state->curparam = state->curparam + 1;
        state->csiparam[(signed long int)state->curparam] = 0;
        break;
      }
      case 91:
      {
        state->escstate = 3;
        break;
      }
      case 64:
      {
        i = 0;
        for( ; !(i >= state->csiparam[0l]); i = i + 1)
        {
          state->cursor_x = state->cursor_x + 1;
          if(!(cols >= state->cursor_x))
          {
            state->cursor_x = 0;
            if(!(state->cursor_y >= rows + -1))
              state->cursor_y = state->cursor_y + 1;

            else
              a2_scroll(st);
          }

        }
        state->escstate = 0;
        break;
      }
      case 70:
        state->cursor_x = 0;
      case 65:
      {
        if(state->csiparam[0l] == 0)
          state->csiparam[(signed long int)0] = 1;

        state->cursor_y = state->cursor_y - state->csiparam[(signed long int)0];
        if(!(state->cursor_y >= 0))
          state->cursor_y = 0;

        state->escstate = 0;
        break;
      }
      case 69:
        state->cursor_x = 0;
      case 101:

      case 66:
      {
        if(state->csiparam[0l] == 0)
          state->csiparam[(signed long int)0] = 1;

        state->cursor_y = state->cursor_y + state->csiparam[(signed long int)0];
        if(state->cursor_y >= rows)
          state->cursor_y = rows - 1;

        state->escstate = 0;
        break;
      }
      case 97:

      case 67:
      {
        if(state->csiparam[0l] == 0)
          state->csiparam[(signed long int)0] = 1;

        state->cursor_x = state->cursor_x + state->csiparam[(signed long int)0];
        if(state->cursor_x >= cols)
          state->cursor_x = cols - 1;

        state->escstate = 0;
        break;
      }
      case 68:
      {
        if(state->csiparam[0l] == 0)
          state->csiparam[(signed long int)0] = 1;

        state->cursor_x = state->cursor_x - state->csiparam[(signed long int)0];
        if(!(state->cursor_x >= 0))
          state->cursor_x = 0;

        state->escstate = 0;
        break;
      }
      case 100:
      {
        state->cursor_y = state->csiparam[(signed long int)0] - 1;
        if(state->cursor_y >= rows)
          state->cursor_y = rows - 1;

        state->escstate = 0;
        break;
      }
      case 96:

      case 71:
      {
        state->cursor_x = state->csiparam[(signed long int)0] - 1;
        if(state->cursor_x >= cols)
          state->cursor_x = cols - 1;

        state->escstate = 0;
        break;
      }
      case 102:

      case 72:
      {
        state->cursor_y = state->csiparam[(signed long int)0] - 1;
        if(state->cursor_y >= rows)
          state->cursor_y = rows - 1;

        state->cursor_x = state->csiparam[(signed long int)1] - 1;
        if(state->cursor_x >= cols)
          state->cursor_x = cols - 1;

        if(!(state->cursor_y >= 0))
          state->cursor_y = 0;

        if(!(state->cursor_x >= 0))
          state->cursor_x = 0;

        state->escstate = 0;
        break;
      }
      case 74:
      {
        start = 0;
        end = rows * cols;
        if(state->csiparam[0l] == 0)
          start = cols * state->cursor_y + state->cursor_x;

        if(state->csiparam[0l] == 1)
          end = cols * state->cursor_y + state->cursor_x;

        a2_goto(st, state->cursor_y, state->cursor_x);
        i = start;
        for( ; !(i >= end); i = i + 1)
          a2_ascii_printc(st, (unsigned char)32, 0, 0, 0, 0);
        state->escstate = 0;
        break;
      }
      case 75:
      {
        start = 0;
        end = cols;
        if(state->csiparam[0l] == 0)
          start = state->cursor_x;

        if(state->csiparam[1l] == 1)
          end = state->cursor_x;

        a2_goto(st, state->cursor_y, state->cursor_x);
        i = start;
        for( ; !(i >= end); i = i + 1)
          a2_ascii_printc(st, (unsigned char)32, 0, 0, 0, 0);
        state->escstate = 0;
        break;
      }
      case 109:
      {
        i = 0;
        for( ; state->curparam >= i; i = i + 1)
          switch(state->csiparam[(signed long int)i])
          {
            case 0:
            {
              state->termattrib.w = 0;
              break;
            }
            case 1:
            {
              state->termattrib.bf.bold = (unsigned int)1;
              break;
            }
            case 5:
            {
              state->termattrib.bf.blink = (unsigned int)1;
              break;
            }
            case 7:
            {
              state->termattrib.bf.rev = (unsigned int)1;
              break;
            }
            case 21:

            case 22:
            {
              state->termattrib.bf.bold = (unsigned int)0;
              break;
            }
            case 25:
            {
              state->termattrib.bf.blink = (unsigned int)0;
              break;
            }
            case 27:
              state->termattrib.bf.rev = (unsigned int)0;
          }
        state->escstate = 0;
        break;
      }
      case 115:
      {
        state->saved_x = state->cursor_x;
        state->saved_y = state->cursor_y;
        state->escstate = 0;
        break;
      }
      case 117:
      {
        state->cursor_x = state->saved_x;
        state->cursor_y = state->saved_y;
        state->escstate = 0;
        break;
      }
      case 63:
      {
        _Bool tmp_if_expr_1;
        if(!(state->curparam == 0))
          tmp_if_expr_1 = (_Bool)1;

        else
          tmp_if_expr_1 = state->csiparam[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_1)
          state->escstate = 0;

        break;
      }
      default:
        state->escstate = 0;
    }
    goto __CPROVER_DUMP_L116;

  __CPROVER_DUMP_L109:
    ;
    state->escstate = 0;
    goto __CPROVER_DUMP_L116;

  __CPROVER_DUMP_L110:
    ;
    signed int total = state->escstate - 100;
    if(!(state->unicruds >= total))
    {
      signed int tmp_post_2 = state->unicruds;
      state->unicruds = state->unicruds + 1;
      state->unicrud[(signed long int)tmp_post_2] = (char)c;
    }

    if(state->unicruds >= total)
    {
      char *s;
      state->unicrud[(signed long int)state->unicruds] = (char)0;
      s=utf8_to_latin1((const char *)state->unicrud, 1);
      state->unicruds = 0;
      state->escstate = 0;
      if(!(s == ((char *)NULL)))
      {
        c = (unsigned char)s[(signed long int)0];
        free((void *)s);
        goto PRINT;
      }

      else
        c = (unsigned char)0;
    }

    goto __CPROVER_DUMP_L116;
  }
  abort();

__CPROVER_DUMP_L116:
  ;
  a2_goto(st, state->cursor_y, state->cursor_x);
}

// aligned_free
// file aligned_malloc.c line 42
void aligned_free(void *ptr)
{
  free(((void **)ptr)[(signed long int)-1]);
}

// aligned_malloc
// file aligned_malloc.c line 26
signed int aligned_malloc(void **ptr, unsigned int alignment, unsigned long int size)
{
  void *block_start;
  signed long int align1 = (signed long int)(alignment - (unsigned int)1);
  /* assertion alignment && !(alignment & (alignment - 1)) */
  assert(alignment != 0u && !((alignment & alignment - (unsigned int)1) != 0u));
  size = size + sizeof(void *) /*8ul*/  + (unsigned long int)align1;
  block_start=malloc(size);
  if(block_start == NULL)
    return 12;

  else
  {
    *ptr = (void *)((unsigned long int)(signed long int)block_start + sizeof(void *) /*8ul*/  + (unsigned long int)align1 & (unsigned long int)~align1);
    ((void **)*ptr)[(signed long int)-1] = block_start;
    return 0;
  }
}

// analogtv_add_signal
// file analogtv.c line 1231
static void analogtv_add_signal(const struct analogtv_s *it, const struct analogtv_reception_s *rec, unsigned int start, unsigned int end, signed int ec)
{
  struct analogtv_input_s *inp = rec->input;
  float *ps = it->rx_signal + (signed long int)start;
  float *pe = it->rx_signal + (signed long int)end;
  float *p = ps;
  signed char *ss = &inp->signal[(signed long int)0][(signed long int)0];
  signed char *se = &inp->signal[(signed long int)0][(signed long int)0] + (signed long int)238944;
  signed char *s = ss + (signed long int)((start + (unsigned int)rec->ofs) % (unsigned int)238944);
  signed char *s2;
  signed int i;
  float level = (float)rec->level;
  float hfloss = (float)rec->hfloss;
  unsigned int fastrnd;
  fastrnd=rnd_seek((unsigned int)1103515245, (unsigned int)12345, it->random1, start);
  float dp[5l];
  const float noise_decay = 0.99995f;
  float noise_ampl;
  float return_value_powf_1;
  return_value_powf_1=powf(noise_decay, (float)start);
  noise_ampl = 1.3f * return_value_powf_1;
  if(!(end >= (unsigned int)ec))
    ec = (signed int)end;

  i = (signed int)start;
  for( ; !(i >= ec); i = i + 1)
  {
    float analogtv_add_signal__1__1__sig0 = (float)s[(signed long int)0];
    unsigned int fastrnd_offset = fastrnd - (unsigned int)0x7fffffff;
    float noise = (float)(fastrnd_offset <= (unsigned int)0x7fffffff ? (signed int)fastrnd_offset : -1 - (signed int)(((unsigned int)0x7fffffff * 2U + 1U) - fastrnd_offset)) * (50.0f / (float)0x7fffffff);
    fastrnd = fastrnd * (unsigned int)1103515245 + (unsigned int)12345 & 0xffffffffu;
    p[(signed long int)0] = p[(signed long int)0] + analogtv_add_signal__1__1__sig0 * level * (1.0f - noise_ampl) + noise * noise_ampl;
    noise_ampl = noise_ampl * noise_decay;
    p = p + 1l;
    s = s + 1l;
    if(s >= se)
      s = ss;

  }
  dp[(signed long int)0] = (float)0.0;
  s2 = s;
  i = 1;
  for( ; !(i >= 5); i = i + 1)
  {
    s2 = s2 - (signed long int)4;
    if(!(s2 >= ss))
      s2 = s2 + (signed long int)238944;

    dp[(signed long int)i] = (float)((signed int)s2[(signed long int)0] + (signed int)s2[(signed long int)1] + (signed int)s2[(signed long int)2] + (signed int)s2[(signed long int)3]);
  }
  /* assertion p <= pe */
  assert(p <= pe);
  /* assertion !((pe - p) % 4) */
  assert(!((pe - p) % (signed long int)4 != 0l));
  while(!(p == pe))
  {
    float sig0;
    float sig1;
    float sig2;
    float sig3;
    float sigr;
    sig0 = (float)s[(signed long int)0];
    sig1 = (float)s[(signed long int)1];
    sig2 = (float)s[(signed long int)2];
    sig3 = (float)s[(signed long int)3];
    dp[(signed long int)0] = sig0 + sig1 + sig2 + sig3;
    sigr = (float)((double)dp[(signed long int)1] * rec->ghostfir[(signed long int)0] + (double)dp[(signed long int)2] * rec->ghostfir[(signed long int)1] + (double)dp[(signed long int)3] * rec->ghostfir[(signed long int)2] + (double)dp[(signed long int)4] * rec->ghostfir[(signed long int)3]);
    dp[(signed long int)4] = dp[(signed long int)3];
    dp[(signed long int)3] = dp[(signed long int)2];
    dp[(signed long int)2] = dp[(signed long int)1];
    dp[(signed long int)1] = dp[(signed long int)0];
    p[(signed long int)0] = p[(signed long int)0] + (sig0 + sigr + sig2 * hfloss) * level;
    p[(signed long int)1] = p[(signed long int)1] + (sig1 + sigr + sig3 * hfloss) * level;
    p[(signed long int)2] = p[(signed long int)2] + (sig2 + sigr + sig0 * hfloss) * level;
    p[(signed long int)3] = p[(signed long int)3] + (sig3 + sigr + sig1 * hfloss) * level;
    p = p + (signed long int)4;
    s = s + (signed long int)4;
    if(s >= se)
      s = ss + (s - se);

  }
  /* assertion p == pe */
  assert(p == pe);
}

// analogtv_alloc_image
// file analogtv.c line 279
static void analogtv_alloc_image(struct analogtv_s *it)
{
  unsigned int bits_per_pixel;
  signed int return_value_get_bits_per_pixel_1;
  return_value_get_bits_per_pixel_1=get_bits_per_pixel(it->dpy, it->xgwa.depth);
  bits_per_pixel = (unsigned int)return_value_get_bits_per_pixel_1;
  unsigned int align;
  unsigned int return_value_thread_memory_alignment_2;
  return_value_thread_memory_alignment_2=thread_memory_alignment(it->dpy);
  align = return_value_thread_memory_alignment_2 * (unsigned int)8 - (unsigned int)1;
  unsigned int width = (unsigned int)it->usewidth * bits_per_pixel + align & ~align;
  if(!(it->use_shm == 0))
  {
    it->image=create_xshm_image(it->dpy, it->xgwa.visual, (unsigned int)it->xgwa.depth, 2, ((char *)NULL), &it->shm_info, width / bits_per_pixel, (unsigned int)it->useheight);
    if(it->image == ((struct _XImage *)NULL))
      it->use_shm = 0;

  }

  if(it->image == ((struct _XImage *)NULL))
  {
    it->image=XCreateImage(it->dpy, it->xgwa.visual, (unsigned int)it->xgwa.depth, 2, 0, ((char *)NULL), (unsigned int)it->usewidth, (unsigned int)it->useheight, 8, (signed int)(width / (unsigned int)8));
    if(!(it->image == ((struct _XImage *)NULL)))
    {
      unsigned int return_value_thread_memory_alignment_3;
      return_value_thread_memory_alignment_3=thread_memory_alignment(it->dpy);
      signed int return_value_posix_memalign_4;
      return_value_posix_memalign_4=posix_memalign((void **)&it->image->data, (unsigned long int)return_value_thread_memory_alignment_3, (unsigned long int)(it->image->height * it->image->bytes_per_line));
      if(!(return_value_posix_memalign_4 == 0))
      {
        it->image->data = (char *)(void *)0;
        it->image->f.destroy_image(it->image);
        it->image = (struct _XImage *)(void *)0;
      }

    }

  }

  if(!(it->image == ((struct _XImage *)NULL)))
    memset((void *)it->image->data, 0, (unsigned long int)(it->image->height * it->image->bytes_per_line));

  else
  {
    char *return_value_strerror_5;
    return_value_strerror_5=strerror(12);
    fprintf(stderr, "analogtv: %s\n", return_value_strerror_5);
  }
}

// analogtv_allocate
// file analogtv.h line 239
struct analogtv_s * analogtv_allocate(struct _XDisplay *dpy, unsigned long int window)
{
  struct anonymous_58 gcv;
  struct analogtv_s *it = (struct analogtv_s *)(void *)0;
  signed int i;
  const unsigned long int rx_signal_len = (const unsigned long int)(238944 + 2 * 912);
  analogtv_init();
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct analogtv_s) /*30336ul*/ );
  it = (struct analogtv_s *)return_value_calloc_1;
  unsigned int return_value_thread_memory_alignment_4;
  signed int return_value_posix_memalign_5;
  unsigned int return_value_hardware_concurrency_6;
  signed int return_value_threadpool_create_7;
  unsigned int return_value_get_pixel_resource_14;
  if(it == ((struct analogtv_s *)NULL))
    return ((struct analogtv_s *)NULL);

  else
  {
    it->threads.count = (unsigned int)0;
    it->rx_signal = (float *)(void *)0;
    it->signal_subtotals = (float *)(void *)0;
    it->dpy = dpy;
    it->window = window;
    unsigned int return_value_thread_memory_alignment_2;
    return_value_thread_memory_alignment_2=thread_memory_alignment(dpy);
    signed int return_value_posix_memalign_3;
    return_value_posix_memalign_3=posix_memalign((void **)&it->rx_signal, (unsigned long int)return_value_thread_memory_alignment_2, sizeof(float) /*4ul*/  * rx_signal_len);
    if(return_value_posix_memalign_3 == 0)
    {
      /* assertion !(ANALOGTV_SIGNAL_LEN % 32) */
      assert(!(238944 % 32 != 0));
      return_value_thread_memory_alignment_4=thread_memory_alignment(dpy);
      return_value_posix_memalign_5=posix_memalign((void **)&it->signal_subtotals, (unsigned long int)return_value_thread_memory_alignment_4, sizeof(float) /*4ul*/  * (rx_signal_len / (unsigned long int)32));
      if(!(return_value_posix_memalign_5 == 0))
        goto fail;

      return_value_hardware_concurrency_6=hardware_concurrency(dpy);
      static struct threadpool_class cls = { .size=sizeof(struct analogtv_thread_s) /*32ul*/ , .create=analogtv_thread_create,
    .destroy=analogtv_thread_destroy };
      return_value_threadpool_create_7=threadpool_create(&it->threads, &cls, dpy, return_value_hardware_concurrency_6);
      if(!(return_value_threadpool_create_7 == 0))
        goto fail;

      /* assertion it->threads.count */
      assert(it->threads.count != 0u);
      it->shrinkpulse = -1;
      it->n_colors = 0;
      it->use_shm = 1;
      XGetWindowAttributes(it->dpy, it->window, &it->xgwa);
      it->screen = it->xgwa.screen;
      it->colormap = it->xgwa.colormap;
      it->visclass = it->xgwa.visual->class;
      it->visbits = it->xgwa.visual->bits_per_rgb;
      it->visdepth = it->xgwa.depth;
      _Bool tmp_if_expr_10;
      if(it->visclass == 4)
        tmp_if_expr_10 = (_Bool)1;

      else
        tmp_if_expr_10 = it->visclass == 5 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_10)
      {
        signed int return_value_get_integer_resource_8;
        return_value_get_integer_resource_8=get_integer_resource(it->dpy, "use_cmap", "Integer");
        if(!(return_value_get_integer_resource_8 == 0))
          it->use_cmap = 1;

        else
          it->use_cmap = 0;
        it->use_color = (signed int)!(mono_p != 0);
      }

      else
      {
        _Bool tmp_if_expr_9;
        if(it->visclass == 3)
          tmp_if_expr_9 = (_Bool)1;

        else
          tmp_if_expr_9 = it->visclass == 2 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_9)
        {
          it->use_cmap = 1;
          it->use_color = (signed int)!(mono_p != 0);
        }

        else
        {
          it->use_cmap = 1;
          it->use_color = 0;
        }
      }
      it->red_mask = (unsigned int)it->xgwa.visual->red_mask;
      it->green_mask = (unsigned int)it->xgwa.visual->green_mask;
      it->blue_mask = (unsigned int)it->xgwa.visual->blue_mask;
      it->red_invprec = -1;
      it->red_shift = it->red_invprec;
      it->green_invprec = -1;
      it->green_shift = it->green_invprec;
      it->blue_invprec = -1;
      it->blue_shift = it->blue_invprec;
      if(it->use_cmap == 0)
      {
        signed int shift;
        signed int prec;
        shift = 0;
        for( ; !(shift >= 32); shift = shift + 1)
        {
          prec = 1;
          for( ; !(prec >= 40 + -shift) && !(prec >= 16); prec = prec + 1)
          {
            unsigned long int mask = (0xffffUL >> 16 - prec) << shift;
            if(!(it->red_shift >= 0))
            {
              if(mask == (unsigned long int)it->red_mask)
              {
                it->red_shift = shift;
                it->red_invprec = 16 - prec;
              }

            }

            if(!(it->green_shift >= 0))
            {
              if(mask == (unsigned long int)it->green_mask)
              {
                it->green_shift = shift;
                it->green_invprec = 16 - prec;
              }

            }

            if(!(it->blue_shift >= 0))
            {
              if(mask == (unsigned long int)it->blue_mask)
              {
                it->blue_shift = shift;
                it->blue_invprec = 16 - prec;
              }

            }

          }
        }
        _Bool tmp_if_expr_11;
        if(!(it->red_shift >= 0))
          tmp_if_expr_11 = (_Bool)1;

        else
          tmp_if_expr_11 = it->green_shift < 0 ? (_Bool)1 : (_Bool)0;
        _Bool tmp_if_expr_12;
        if(tmp_if_expr_11)
          tmp_if_expr_12 = (_Bool)1;

        else
          tmp_if_expr_12 = it->blue_shift < 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_12)
          goto fail;

        i = 0;
        for( ; !(i >= 1024); i = i + 1)
        {
          signed int intensity;
          double return_value_pow_13;
          return_value_pow_13=pow((double)i / 256.0, 0.8);
          intensity = (signed int)(return_value_pow_13 * 65535.0);
          if(intensity >= 65536)
            intensity = 65535;

          it->red_values[(signed long int)i] = (unsigned int)((intensity >> it->red_invprec) << it->red_shift);
          it->green_values[(signed long int)i] = (unsigned int)((intensity >> it->green_invprec) << it->green_shift);
          it->blue_values[(signed long int)i] = (unsigned int)((intensity >> it->blue_invprec) << it->blue_shift);
        }
      }

      return_value_get_pixel_resource_14=get_pixel_resource(it->dpy, it->colormap, "background", "Background");
      gcv.background = (unsigned long int)return_value_get_pixel_resource_14;
      it->gc=XCreateGC(it->dpy, it->window, (unsigned long int)(1L << 3), &gcv);
      XSetWindowBackground(it->dpy, it->window, gcv.background);
      XClearWindow(dpy, window);
      analogtv_configure(it);
      return it;
    }

    else
    {

    fail:
      ;
      if(!(it == ((struct analogtv_s *)NULL)))
      {
        if(!(it->threads.count == 0u))
          threadpool_destroy(&it->threads);

        free((void *)it->signal_subtotals);
        free((void *)it->rx_signal);
        free((void *)it);
      }

      return (struct analogtv_s *)(void *)0;
    }
  }
}

// analogtv_blast_imagerow
// file analogtv.c line 1390
static void analogtv_blast_imagerow(const struct analogtv_s *it, float *rgbf, float *rgbf_end, signed int ytop, signed int ybot)
{
  signed int i;
  signed int j;
  signed int x;
  signed int y;
  float *rpf;
  char *level_copyfrom[3l];
  signed int xrepl = it->xrepl;
  unsigned int lineheight = (unsigned int)(ybot - ytop);
  if(lineheight >= 13u)
    lineheight = (unsigned int)12;

  i = 0;
  for( ; !(i >= 3); i = i + 1)
    level_copyfrom[(signed long int)i] = (char *)(void *)0;
  y = ytop;
  for( ; !(y >= ybot); y = y + 1)
  {
    char *rowdata = it->image->data + (signed long int)(y * it->image->bytes_per_line);
    unsigned int line = (unsigned int)(y - ytop);
    signed int level = it->leveltable[(signed long int)lineheight][(signed long int)line].index;
    float levelmult = (float)it->leveltable[(signed long int)lineheight][(signed long int)line].value;
    if(!(level_copyfrom[(signed long int)level] == ((char *)NULL)))
      memcpy((void *)rowdata, (const void *)level_copyfrom[(signed long int)level], (unsigned long int)it->image->bytes_per_line);

    else
    {
      level_copyfrom[(signed long int)level] = rowdata;
      {
        _Bool tmp_if_expr_5;
        if(it->image->format == 2)
          tmp_if_expr_5 = it->image->bits_per_pixel == 32 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_5 = (_Bool)0;
        _Bool tmp_if_expr_6;
        if(tmp_if_expr_5)
          tmp_if_expr_6 = it->image->byte_order == localbyteorder ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_6 = (_Bool)0;
        if(tmp_if_expr_6)
        {
          unsigned int *pixelptr = (unsigned int *)rowdata;
          unsigned int pix;
          rpf = rgbf;
          for( ; !(rpf == rgbf_end); rpf = rpf + (signed long int)3)
          {
            signed int ntscri = (signed int)(rpf[(signed long int)0] * levelmult);
            signed int ntscgi = (signed int)(rpf[(signed long int)1] * levelmult);
            signed int ntscbi = (signed int)(rpf[(signed long int)2] * levelmult);
            if(ntscri >= 1024)
              ntscri = 1024 - 1;

            if(ntscgi >= 1024)
              ntscgi = 1024 - 1;

            if(ntscbi >= 1024)
              ntscbi = 1024 - 1;

            pix = it->red_values[(signed long int)ntscri] | it->green_values[(signed long int)ntscgi] | it->blue_values[(signed long int)ntscbi];
            pixelptr[(signed long int)0] = pix;
            if(xrepl >= 2)
            {
              pixelptr[(signed long int)1] = pix;
              if(xrepl >= 3)
                pixelptr[(signed long int)2] = pix;

            }

            pixelptr = pixelptr + (signed long int)xrepl;
          }
        }

        else
        {
          _Bool tmp_if_expr_3;
          if(it->image->format == 2)
            tmp_if_expr_3 = it->image->bits_per_pixel == 16 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_3 = (_Bool)0;
          _Bool tmp_if_expr_4;
          if(!(float_extraction_works == 0) && tmp_if_expr_3)
            tmp_if_expr_4 = it->image->byte_order == localbyteorder ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4 = (_Bool)0;
          if(tmp_if_expr_4)
          {
            unsigned short int *analogtv_blast_imagerow__1__1__2__3__pixelptr = (unsigned short int *)rowdata;
            float r2;
            float g2;
            float b2;
            union anonymous_55 r1;
            union anonymous_55 g1;
            union anonymous_55 b1;
            unsigned short int analogtv_blast_imagerow__1__1__2__3__pix;
            rpf = rgbf;
            for( ; !(rpf == rgbf_end); rpf = rpf + (signed long int)3)
            {
              r2 = rpf[(signed long int)0];
              g2 = rpf[(signed long int)1];
              b2 = rpf[(signed long int)2];
              r1.f = (float)((double)(r2 * levelmult) + float_low8_ofs);
              g1.f = (float)((double)(g2 * levelmult) + float_low8_ofs);
              b1.f = (float)((double)(b2 * levelmult) + float_low8_ofs);
              analogtv_blast_imagerow__1__1__2__3__pix = (unsigned short int)(it->red_values[(signed long int)(r1.i & 0x3ff)] | it->green_values[(signed long int)(g1.i & 0x3ff)] | it->blue_values[(signed long int)(b1.i & 0x3ff)]);
              analogtv_blast_imagerow__1__1__2__3__pixelptr[(signed long int)0] = analogtv_blast_imagerow__1__1__2__3__pix;
              if(xrepl >= 2)
              {
                analogtv_blast_imagerow__1__1__2__3__pixelptr[(signed long int)1] = analogtv_blast_imagerow__1__1__2__3__pix;
                if(xrepl >= 3)
                  analogtv_blast_imagerow__1__1__2__3__pixelptr[(signed long int)2] = analogtv_blast_imagerow__1__1__2__3__pix;

              }

              analogtv_blast_imagerow__1__1__2__3__pixelptr = analogtv_blast_imagerow__1__1__2__3__pixelptr + (signed long int)xrepl;
            }
          }

          else
          {
            _Bool tmp_if_expr_1;
            if(it->image->format == 2)
              tmp_if_expr_1 = it->image->bits_per_pixel == 16 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_1 = (_Bool)0;
            _Bool tmp_if_expr_2;
            if(tmp_if_expr_1)
              tmp_if_expr_2 = it->image->byte_order == localbyteorder ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_2 = (_Bool)0;
            if(tmp_if_expr_2)
            {
              unsigned short int *analogtv_blast_imagerow__1__1__2__4__pixelptr = (unsigned short int *)rowdata;
              unsigned short int analogtv_blast_imagerow__1__1__2__4__pix;
              rpf = rgbf;
              for( ; !(rpf == rgbf_end); rpf = rpf + (signed long int)3)
              {
                signed int analogtv_blast_imagerow__1__1__2__4__1__r1 = (signed int)(rpf[(signed long int)0] * levelmult);
                signed int analogtv_blast_imagerow__1__1__2__4__1__g1 = (signed int)(rpf[(signed long int)1] * levelmult);
                signed int analogtv_blast_imagerow__1__1__2__4__1__b1 = (signed int)(rpf[(signed long int)2] * levelmult);
                if(analogtv_blast_imagerow__1__1__2__4__1__r1 >= 1024)
                  analogtv_blast_imagerow__1__1__2__4__1__r1 = 1024 - 1;

                if(analogtv_blast_imagerow__1__1__2__4__1__g1 >= 1024)
                  analogtv_blast_imagerow__1__1__2__4__1__g1 = 1024 - 1;

                if(analogtv_blast_imagerow__1__1__2__4__1__b1 >= 1024)
                  analogtv_blast_imagerow__1__1__2__4__1__b1 = 1024 - 1;

                analogtv_blast_imagerow__1__1__2__4__pix = (unsigned short int)(it->red_values[(signed long int)analogtv_blast_imagerow__1__1__2__4__1__r1] | it->green_values[(signed long int)analogtv_blast_imagerow__1__1__2__4__1__g1] | it->blue_values[(signed long int)analogtv_blast_imagerow__1__1__2__4__1__b1]);
                analogtv_blast_imagerow__1__1__2__4__pixelptr[(signed long int)0] = analogtv_blast_imagerow__1__1__2__4__pix;
                if(xrepl >= 2)
                {
                  analogtv_blast_imagerow__1__1__2__4__pixelptr[(signed long int)1] = analogtv_blast_imagerow__1__1__2__4__pix;
                  if(xrepl >= 3)
                    analogtv_blast_imagerow__1__1__2__4__pixelptr[(signed long int)2] = analogtv_blast_imagerow__1__1__2__4__pix;

                }

                analogtv_blast_imagerow__1__1__2__4__pixelptr = analogtv_blast_imagerow__1__1__2__4__pixelptr + (signed long int)xrepl;
              }
            }

            else
            {
              x = 0;
              rpf = rgbf;
              for( ; !(rpf == rgbf_end); rpf = rpf + (signed long int)3)
              {
                signed int analogtv_blast_imagerow__1__1__2__5__1__ntscri = (signed int)(rpf[(signed long int)0] * levelmult);
                signed int analogtv_blast_imagerow__1__1__2__5__1__ntscgi = (signed int)(rpf[(signed long int)1] * levelmult);
                signed int analogtv_blast_imagerow__1__1__2__5__1__ntscbi = (signed int)(rpf[(signed long int)2] * levelmult);
                if(analogtv_blast_imagerow__1__1__2__5__1__ntscri >= 1024)
                  analogtv_blast_imagerow__1__1__2__5__1__ntscri = 1024 - 1;

                if(analogtv_blast_imagerow__1__1__2__5__1__ntscgi >= 1024)
                  analogtv_blast_imagerow__1__1__2__5__1__ntscgi = 1024 - 1;

                if(analogtv_blast_imagerow__1__1__2__5__1__ntscbi >= 1024)
                  analogtv_blast_imagerow__1__1__2__5__1__ntscbi = 1024 - 1;

                j = 0;
                if(!(j >= xrepl))
                {
                  it->image->f.put_pixel(it->image, x * xrepl + j, y, (unsigned long int)(it->red_values[(signed long int)analogtv_blast_imagerow__1__1__2__5__1__ntscri] | it->green_values[(signed long int)analogtv_blast_imagerow__1__1__2__5__1__ntscgi] | it->blue_values[(signed long int)analogtv_blast_imagerow__1__1__2__5__1__ntscbi]));
                  j = j + 1;
                }

                x = x + 1;
              }
            }
          }
        }
      }
    }
  }
}

// analogtv_configure
// file analogtv.c line 319
static void analogtv_configure(struct analogtv_s *it)
{
  signed int oldwidth = it->usewidth;
  signed int oldheight = it->useheight;
  signed int wlim;
  signed int hlim;
  signed int height_diff;
  float percent = (float)0.15;
  float min_ratio = (float)((4.0 / 3.0) * (double)((float)1 - percent));
  float max_ratio = (float)((16.0 / 9.0) * (double)((float)1 + percent));
  float ratio;
  float height_snap = (float)0.025;
  hlim = it->xgwa.height;
  wlim = it->xgwa.width;
  ratio = (float)wlim / (float)hlim;
  if(!(hlim >= 200) || !(wlim >= 266))
  {
    wlim = 266;
    hlim = 200;
  }

  else
    if(!(ratio < max_ratio) || !(ratio > min_ratio))
    {
      if(ratio >= max_ratio)
        wlim = (signed int)((float)hlim * max_ratio);

      else
        hlim = (signed int)((float)wlim / min_ratio);
    }

  height_diff = (hlim + 200 / 2) % 200 - 200 / 2;
  double return_value_fabs_1;
  if(!(height_diff == 0))
  {
    return_value_fabs_1=fabs((double)height_diff);
    if(return_value_fabs_1 < (double)((float)hlim * height_snap))
      hlim = hlim - height_diff;

  }

  if(!(hlim == oldheight) || !(wlim == oldwidth))
  {
    it->usewidth = wlim;
    it->useheight = hlim;
    it->xrepl = 1 + it->usewidth / 640;
    if(it->xrepl >= 3)
      it->xrepl = 2;

    it->subwidth = it->usewidth / it->xrepl;
    analogtv_free_image(it);
    analogtv_alloc_image(it);
  }

  it->screen_xo = (it->xgwa.width - it->usewidth) / 2;
  it->screen_yo = (it->xgwa.height - it->useheight) / 2;
  it->need_clear = 1;
}

// analogtv_draw
// file analogtv.h line 250
void analogtv_draw(struct analogtv_s *it, double noiselevel, const struct analogtv_reception_s * const *recs, unsigned int rec_count)
{
  signed int i;
  signed int lineno;
  double baseload;
  signed int overall_top;
  signed int overall_bot;
  if(!(it->image == ((struct _XImage *)NULL)))
  {
    it->rx_signal_level = noiselevel;
    i = 0;
    for( ; !((unsigned int)i == rec_count); i = i + 1)
    {
      const struct analogtv_reception_s *rec = recs[(signed long int)i];
      double level = rec->level;
      struct analogtv_input_s *inp = rec->input;
      it->rx_signal_level=sqrt(it->rx_signal_level * it->rx_signal_level + level * level * (1.0 + 4.0 * (rec->ghostfir[(signed long int)0] + rec->ghostfir[(signed long int)1] + rec->ghostfir[(signed long int)2] + rec->ghostfir[(signed long int)3])));
      memcpy((void *)inp->signal[(signed long int)262], (const void *)inp->signal[(signed long int)0], (unsigned long int)912 * sizeof(signed char) /*1ul*/ );
    }
    analogtv_setup_frame(it);
    analogtv_set_demod(it);
    it->random0=ya_random();
    it->random1=ya_random();
    it->noiselevel = noiselevel;
    it->recs = recs;
    it->rec_count = rec_count;
    threadpool_run(&it->threads, analogtv_thread_add_signals);
    threadpool_wait(&it->threads);
    it->channel_change_cycles = 0;
    memcpy((void *)&it->rx_signal[(signed long int)238944], (const void *)&it->rx_signal[(signed long int)0], (unsigned long int)(2 * 912) * sizeof(float) /*4ul*/ );
    memcpy((void *)&it->signal_subtotals[(signed long int)(238944 / 32)], (const void *)&it->signal_subtotals[(signed long int)0], (unsigned long int)((2 * 912) / 32) * sizeof(float) /*4ul*/ );
    analogtv_sync(it);
    baseload = 0.5;
    it->crtload[(signed long int)(30 - 1)] = (float)baseload;
    float return_value_puramp_1;
    return_value_puramp_1=puramp(it, (float)2.0, (float)1.0, (float)1.3);
    float return_value_puramp_2;
    return_value_puramp_2=puramp(it, (float)2.0, (float)2.0, (float)1.1);
    it->puheight = (float)((double)(return_value_puramp_1 * it->height_control) * (1.125 - 0.125 * (double)return_value_puramp_2));
    analogtv_setup_levels(it, ((double)it->puheight * (double)it->useheight) / (double)200);
    double return_value_cos_3;
    return_value_cos_3=cos(((double)((float)103 + it->tint_control) * 3.1415926) / (double)180);
    it->tint_i = (float)-return_value_cos_3;
    double return_value_sin_4;
    return_value_sin_4=sin(((double)((float)103 + it->tint_control) * 3.1415926) / (double)180);
    it->tint_q = (float)return_value_sin_4;
    lineno = 30;
    for( ; !(lineno >= 230); lineno = lineno + 1)
    {
      signed int slineno;
      signed int ytop;
      signed int ybot;
      unsigned int signal_offset;
      signed int return_value_analogtv_get_line_5;
      return_value_analogtv_get_line_5=analogtv_get_line(it, lineno, &slineno, &ytop, &ybot, &signal_offset);
      if(!(return_value_analogtv_get_line_5 == 0))
      {
        if(lineno == it->shrinkpulse)
        {
          baseload = baseload + 0.4;
          it->shrinkpulse = -1;
        }

        float totsignal = (float)0;
        float ncl;
        unsigned int frac;
        unsigned long int end0;
        unsigned long int end1;
        const float *p;
        frac = signal_offset & (unsigned int)(32 - 1);
        p = it->rx_signal + (signed long int)(signal_offset & (unsigned int)~(32 - 1));
        i = 0;
        for( ; !((unsigned int)i == frac); i = i + 1)
          totsignal = totsignal - p[(signed long int)i];
        end0 = (unsigned long int)(signal_offset + (unsigned int)755);
        end1 = end0 / (unsigned long int)32;
        i = (signed int)(signal_offset / (unsigned int)32);
        for( ; !((unsigned long int)i >= end1); i = i + 1)
          totsignal = totsignal + it->signal_subtotals[(signed long int)i];
        frac = (unsigned int)(end0 & (unsigned long int)(32 - 1));
        p = it->rx_signal + (signed long int)(end0 & (unsigned long int)~(32 - 1));
        i = 0;
        for( ; !((unsigned int)i == frac); i = i + 1)
          totsignal = totsignal + p[(signed long int)i];
        totsignal = totsignal * it->agclevel;
        float tmp_if_expr_6;
        if(slineno >= 185)
          tmp_if_expr_6 = (float)((slineno - 184) * (lineno - 184)) * 0.001f * it->squeezebottom;

        else
          tmp_if_expr_6 = 0.0f;
        ncl = (float)((double)(0.95f * it->crtload[(signed long int)(lineno - 1)]) + (double)0.05f * (baseload + (double)((totsignal - (float)30000) / 100000.0f) + (double)tmp_if_expr_6));
        it->crtload[(signed long int)lineno] = ncl;
      }

    }
    threadpool_run(&it->threads, analogtv_thread_draw_lines);
    threadpool_wait(&it->threads);
    if(!(it->need_clear == 0))
    {
      XClearWindow(it->dpy, it->window);
      it->need_clear = 0;
    }

    overall_top = (signed int)(((float)it->useheight * ((float)1 - it->puheight)) / (float)2);
    overall_bot = (signed int)(((float)it->useheight * ((float)1 + it->puheight)) / (float)2);
    if(!(overall_top >= 0))
      overall_top = 0;

    if(!(it->useheight >= overall_bot))
      overall_bot = it->useheight;

    if(overall_top >= 1)
      XClearArea(it->dpy, it->window, it->screen_xo, it->screen_yo, (unsigned int)it->usewidth, (unsigned int)overall_top, 0);

    if(!(overall_bot >= it->useheight))
      XClearArea(it->dpy, it->window, it->screen_xo, it->screen_yo + overall_bot, (unsigned int)it->usewidth, (unsigned int)(it->useheight - overall_bot), 0);

    if(!(overall_top >= overall_bot))
    {
      if(!(it->use_shm == 0))
        XShmPutImage(it->dpy, it->window, it->gc, it->image, 0, overall_top, it->screen_xo, it->screen_yo + overall_top, (unsigned int)it->usewidth, (unsigned int)(overall_bot - overall_top), 0);

      else
        XPutImage(it->dpy, it->window, it->gc, it->image, 0, overall_top, it->screen_xo, it->screen_yo + overall_top, (unsigned int)it->usewidth, (unsigned int)(overall_bot - overall_top));
    }

  }

}

// analogtv_draw_char
// file analogtv.c line 2364
void analogtv_draw_char(struct analogtv_input_s *input, struct analogtv_font_s *f, signed int c, signed int x, signed int y, signed int *ntsc)
{
  signed int yc;
  signed int xc;
  signed int ys;
  signed int xs;
  signed int pix;
  yc = 0;
  for( ; !(yc >= f->char_h); yc = yc + 1)
  {
    ys = y + yc * f->y_mult;
    for( ; !(ys >= (1 + yc) * f->y_mult + y); ys = ys + 1)
      if(!(ys >= 262) && ys >= 0)
      {
        xc = 0;
        for( ; !(xc >= f->char_w); xc = xc + 1)
        {
          pix=analogtv_font_pixel(f, c, xc, yc);
          xs = x + xc * f->x_mult;
          for( ; !(xs >= (1 + xc) * f->x_mult + x); xs = xs + 1)
            if(!(xs >= 912) && xs >= 0)
            {
              if(!(pix == 0))
                input->signal[(signed long int)ys][(signed long int)xs] = (signed char)ntsc[(signed long int)(xs & 3)];

            }

        }
      }

  }
}

// analogtv_draw_solid
// file analogtv.c line 2329
void analogtv_draw_solid(struct analogtv_input_s *input, signed int left, signed int right, signed int top, signed int bot, signed int *ntsc)
{
  signed int x;
  signed int y;
  if(!(right + -left >= 4))
    right = left + 4;

  if(!(bot + -top >= 1))
    bot = top + 1;

  y = top;
  for( ; !(y >= bot); y = y + 1)
  {
    x = left;
    for( ; !(x >= right); x = x + 1)
      input->signal[(signed long int)y][(signed long int)x] = (signed char)ntsc[(signed long int)(x & 3)];
  }
}

// analogtv_draw_solid_rel_lcp
// file analogtv.c line 2347
void analogtv_draw_solid_rel_lcp(struct analogtv_input_s *input, double left, double right, double top, double bot, double luma, double chroma, double phase)
{
  signed int ntsc[4l];
  signed int topi = (signed int)((double)30 + (double)200 * top);
  signed int boti = (signed int)((double)30 + (double)200 * bot);
  signed int lefti = (signed int)((double)229 + (double)566 * left);
  signed int righti = (signed int)((double)229 + (double)566 * right);
  analogtv_lcp_to_ntsc(luma, chroma, phase, ntsc);
  analogtv_draw_solid(input, lefti, righti, topi, boti, ntsc);
}

// analogtv_draw_string
// file analogtv.c line 2388
void analogtv_draw_string(struct analogtv_input_s *input, struct analogtv_font_s *f, char *s, signed int x, signed int y, signed int *ntsc)
{
  for( ; !(*s == 0); s = s + 1l)
  {
    analogtv_draw_char(input, f, (signed int)*s, x, y, ntsc);
    x = x + f->char_w * 4;
  }
}

// analogtv_draw_string_centered
// file analogtv.c line 2399
void analogtv_draw_string_centered(struct analogtv_input_s *input, struct analogtv_font_s *f, char *s, signed int x, signed int y, signed int *ntsc)
{
  signed int width;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(s);
  width = (signed int)(return_value_strlen_1 * (unsigned long int)f->char_w * (unsigned long int)4);
  x = x - width / 2;
  analogtv_draw_string(input, f, s, x, y, ntsc);
}

// analogtv_draw_xpm
// file analogtv.c line 2422
void analogtv_draw_xpm(struct analogtv_s *tv, struct analogtv_input_s *input, const char * const *xpm, signed int left, signed int top)
{
  signed int xpmw;
  signed int xpmh;
  signed int x;
  signed int y;
  signed int tvx;
  signed int tvy;
  signed int i;
  signed int rawy;
  signed int rawi;
  signed int rawq;
  signed int ncolors;
  signed int nbytes;
  char dummyc;
  /* tag-#anon#lST[S32'r'|S32'g'|S32'b'] */
struct anonymous_65
{
  // r
  signed int r;
  // g
  signed int g;
  // b
  signed int b;
};

/* */
  ;
  struct anonymous_65 cmap[256l];
  signed int return_value___isoc99_sscanf_1;
  return_value___isoc99_sscanf_1=__isoc99_sscanf((const char *)*xpm, "%d %d %d %d %c", &xpmw, &xpmh, &ncolors, &nbytes, &dummyc);
  if(!(return_value___isoc99_sscanf_1 == 4))
    abort();

  if(ncolors >= 256 || !(ncolors >= 1))
    abort();

  if(!(nbytes == 1))
    abort();

  xpm = xpm + 1l;
  i = 0;
  for( ; !(i >= ncolors); i = i + 1)
  {
    const char *line = *xpm;
    signed int colori;
    const char *tmp_post_2 = line;
    line = line + 1l;
    colori = (signed int)(unsigned char)*tmp_post_2 & 0xff;
    while(!(*line == 0))
    {
      signed int r;
      signed int g;
      signed int b;
      char which;
      for( ; (_Bool)1; line = line + 1l)
        if(!((signed int)*line == 32))
        {
          if(!((signed int)*line == 9))
            goto __CPROVER_DUMP_L8;

        }


    __CPROVER_DUMP_L8:
      ;
      const char *tmp_post_3 = line;
      line = line + 1l;
      which = *tmp_post_3;
      if(!((signed int)which == 99) && !((signed int)which == 109))
        abort();

      for( ; (_Bool)1; line = line + 1l)
        if(!((signed int)*line == 32))
        {
          if(!((signed int)*line == 9))
            goto __CPROVER_DUMP_L11;

        }


    __CPROVER_DUMP_L11:
      ;
      signed int return_value_strncasecmp_4;
      return_value_strncasecmp_4=strncasecmp(line, "None", (unsigned long int)4);
      if(return_value_strncasecmp_4 == 0)
      {
        b = -1;
        g = b;
        r = g;
        line = line + (signed long int)4;
      }

      else
      {
        if((signed int)*line == 35)
          line = line + 1l;

        r = (signed int)hextonib[(signed long int)(signed int)line[(signed long int)0]] << 4 | (signed int)hextonib[(signed long int)(signed int)line[(signed long int)1]];
        line = line + (signed long int)2;
        g = (signed int)hextonib[(signed long int)(signed int)line[(signed long int)0]] << 4 | (signed int)hextonib[(signed long int)(signed int)line[(signed long int)1]];
        line = line + (signed long int)2;
        b = (signed int)hextonib[(signed long int)(signed int)line[(signed long int)0]] << 4 | (signed int)hextonib[(signed long int)(signed int)line[(signed long int)1]];
        line = line + (signed long int)2;
      }
      if((signed int)which == 99)
      {
        cmap[(signed long int)colori].r = r;
        cmap[(signed long int)colori].g = g;
        cmap[(signed long int)colori].b = b;
      }

    }
    xpm = xpm + 1l;
  }
  y = 0;
  for( ; !(y >= xpmh); y = y + 1)
  {
    const char *analogtv_draw_xpm__1__2__line;
    const char * const *tmp_post_5 = xpm;
    xpm = xpm + 1l;
    analogtv_draw_xpm__1__2__line = *tmp_post_5;
    tvy = y + top;
    if(!(tvy >= 230) && tvy >= 30)
    {
      x = 0;
      for( ; !(x >= xpmw); x = x + 1)
      {
        signed int cbyte = (signed int)(unsigned char)analogtv_draw_xpm__1__2__line[(signed long int)x] & 0xff;
        signed int ntsc[4l];
        tvx = x * 4 + left;
        if(!(4 + tvx >= 891) && tvx >= 135)
        {
          rawy = (5 * cmap[(signed long int)cbyte].r + 11 * cmap[(signed long int)cbyte].g + 2 * cmap[(signed long int)cbyte].b) / 64;
          rawi = ((10 * cmap[(signed long int)cbyte].r - 4 * cmap[(signed long int)cbyte].g) - 5 * cmap[(signed long int)cbyte].b) / 64;
          rawq = ((3 * cmap[(signed long int)cbyte].r - 8 * cmap[(signed long int)cbyte].g) + 5 * cmap[(signed long int)cbyte].b) / 64;
          ntsc[(signed long int)0] = rawy + rawq;
          ntsc[(signed long int)1] = rawy - rawi;
          ntsc[(signed long int)2] = rawy - rawq;
          ntsc[(signed long int)3] = rawy + rawi;
          i = 0;
          for( ; !(i >= 4); i = i + 1)
          {
            if(ntsc[(signed long int)i] >= 101)
              ntsc[(signed long int)i] = 100;

            if(!(ntsc[(signed long int)i] >= 10))
              ntsc[(signed long int)i] = 10;

          }
          input->signal[(signed long int)tvy][(signed long int)(tvx + 0)] = (signed char)ntsc[(signed long int)(tvx + 0 & 3)];
          input->signal[(signed long int)tvy][(signed long int)(tvx + 1)] = (signed char)ntsc[(signed long int)(tvx + 1 & 3)];
          input->signal[(signed long int)tvy][(signed long int)(tvx + 2)] = (signed char)ntsc[(signed long int)(tvx + 2 & 3)];
          input->signal[(signed long int)tvy][(signed long int)(tvx + 3)] = (signed char)ntsc[(signed long int)(tvx + 3 & 3)];
        }

      }
    }

  }
}

// analogtv_font_pixel
// file analogtv.c line 2280
signed int analogtv_font_pixel(struct analogtv_font_s *f, signed int c, signed int x, signed int y)
{
  _Bool tmp_if_expr_1;
  if(!(x >= 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = x >= f->char_w ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return 0;

  else
  {
    _Bool tmp_if_expr_2;
    if(!(y >= 0))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = y >= f->char_h ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
      return 0;

    else
      if(c >= 256 || !(c >= 0))
        return 0;

      else
      {
        unsigned long int return_value;
        return_value=f->text_im->f.get_pixel(f->text_im, c * f->char_w + x, y);
        return return_value != 0ul ? 1 : 0;
      }
  }
}

// analogtv_font_set_char
// file analogtv.c line 2299
void analogtv_font_set_char(struct analogtv_font_s *f, signed int c, char *s)
{
  signed int value;
  signed int x;
  signed int y;
  if(!(c >= 256) && c >= 0)
  {
    y = 0;
    for( ; !(y >= f->char_h); y = y + 1)
    {
      x = 0;
      for( ; !(x >= f->char_w); x = x + 1)
      {
        if(*s == 0)
          goto __CPROVER_DUMP_L7;

        value = (signed int)*s == 32 ? 0 : 1;
        analogtv_font_set_pixel(f, c, x, y, value);
        s = s + 1l;
      }
    }
  }


__CPROVER_DUMP_L7:
  ;
}

// analogtv_font_set_pixel
// file analogtv.c line 2289
void analogtv_font_set_pixel(struct analogtv_font_s *f, signed int c, signed int x, signed int y, signed int value)
{
  _Bool tmp_if_expr_1;
  if(!(x >= 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = x >= f->char_w ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr_1)
  {
    _Bool tmp_if_expr_2;
    if(!(y >= 0))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = y >= f->char_h ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_2)
    {
      if(!(c >= 256) && c >= 0)
        f->text_im->f.put_pixel(f->text_im, c * f->char_w + x, y, (unsigned long int)value);

    }

  }

}

// analogtv_free_image
// file analogtv.c line 262
static void analogtv_free_image(struct analogtv_s *it)
{
  if(!(it->image == ((struct _XImage *)NULL)))
  {
    if(!(it->use_shm == 0))
      destroy_xshm_image(it->dpy, it->image, &it->shm_info);

    else
    {
      free((void *)it->image->data);
      it->image->data = (char *)(void *)0;
      it->image->f.destroy_image(it->image);
    }
    it->image = (struct _XImage *)(void *)0;
  }

}

// analogtv_get_line
// file analogtv.c line 1365
static signed int analogtv_get_line(const struct analogtv_s *it, signed int lineno, signed int *slineno, signed int *ytop, signed int *ybot, unsigned int *signal_offset)
{
  *slineno = lineno - 30;
  *ytop = (signed int)((float)((*slineno * it->useheight) / 200 - it->useheight / 2) * it->puheight) + it->useheight / 2;
  *ybot = (signed int)((float)(((*slineno + 1) * it->useheight) / 200 - it->useheight / 2) * it->puheight) + it->useheight / 2;
  *signal_offset = (unsigned int)(((lineno + it->cur_vsync + 262) % 262) * 912 + it->line_hsync[(signed long int)lineno]);
  if(*ytop == *ybot)
    return 0;

  else
  {
    _Bool tmp_if_expr_1;
    if(!(*ybot >= 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = *ytop > it->useheight ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      return 0;

    else
    {
      if(!(*ytop >= 0))
        *ytop = 0;

      if(!(it->useheight >= *ybot))
        *ybot = it->useheight;

      if(!(12 + *ytop >= *ybot))
        *ybot = *ytop + 12;

      return 1;
    }
  }
}

// analogtv_init
// file analogtv.c line 165
static void analogtv_init(void)
{
  signed int i;
  unsigned int localbyteorder_loc = (unsigned int)(1 << 24 | 0 << 0);
  localbyteorder = (signed int)*((char *)&localbyteorder_loc);
  {
    union anonymous_55 fe;
    signed int ans;
    float_extraction_works = 1;
    i = 0;
    for( ; !(i >= 4); i = i + 1)
    {
      fe.f = (float)(float_low8_ofs + (double)i);
      ans = fe.i & 0x3ff;
      if(!(ans == i))
      {
        float_extraction_works = 0;
        break;
      }

    }
  }
}

// analogtv_init_signal
// file analogtv.c line 1210
static void analogtv_init_signal(const struct analogtv_s *it, double noiselevel, unsigned int start, unsigned int end)
{
  float *ps = it->rx_signal + (signed long int)start;
  float *pe = it->rx_signal + (signed long int)end;
  float *p = ps;
  unsigned int fastrnd;
  fastrnd=rnd_seek((unsigned int)1103515245, (unsigned int)12345, it->random0, start);
  unsigned int fastrnd_offset;
  float nm1;
  float nm2;
  float noisemul;
  double return_value_sqrt_1;
  return_value_sqrt_1=sqrt(noiselevel * (double)150);
  noisemul = (float)(return_value_sqrt_1 / (double)(float)0x7fffffff);
  fastrnd_offset = fastrnd - (unsigned int)0x7fffffff;
  nm1 = (float)(fastrnd_offset <= (unsigned int)0x7fffffff ? (signed int)fastrnd_offset : -1 - (signed int)(((unsigned int)0x7fffffff * 2U + 1U) - fastrnd_offset)) * noisemul;
  while(!(p == pe))
  {
    nm2 = nm1;
    fastrnd = fastrnd * (unsigned int)1103515245 + (unsigned int)12345 & 0xffffffffu;
    fastrnd_offset = fastrnd - (unsigned int)0x7fffffff;
    nm1 = (float)(fastrnd_offset <= (unsigned int)0x7fffffff ? (signed int)fastrnd_offset : -1 - (signed int)(((unsigned int)0x7fffffff * 2U + 1U) - fastrnd_offset)) * noisemul;
    float *tmp_post_2 = p;
    p = p + 1l;
    *tmp_post_2 = nm1 * nm2;
  }
}

// analogtv_input_allocate
// file analogtv.h line 240
struct analogtv_input_s * analogtv_input_allocate(void)
{
  struct analogtv_input_s *ret;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct analogtv_input_s) /*239888ul*/ );
  ret = (struct analogtv_input_s *)return_value_calloc_1;
  return ret;
}

// analogtv_lcp_to_ntsc
// file analogtv.c line 2316
void analogtv_lcp_to_ntsc(double luma, double chroma, double phase, signed int *ntsc)
{
  signed int i = 0;
  for( ; !(i >= 4); i = i + 1)
  {
    double w = 90.0 * (double)i + phase;
    double val;
    double return_value_cos_1;
    return_value_cos_1=cos((3.1415926 / 180.0) * w);
    val = luma + chroma * return_value_cos_1;
    if(val < 0.0)
      val = 0.0;

    if(val > 127.0)
      val = 127.0;

    ntsc[(signed long int)i] = (signed int)val;
  }
}

// analogtv_level
// file analogtv.c line 1122
static signed int analogtv_level(const struct analogtv_s *it, signed int y, signed int ytop, signed int ybot)
{
  signed int level;
  if(ybot + -ytop >= 7)
  {
    if(y == ybot + -1 || y == ytop)
      level = 0;

    else
      if(y == 1 + ytop || y == ybot + -2)
        level = 1;

      else
        level = 2;
  }

  else
    if(ybot + -ytop >= 5)
    {
      if(y == ybot + -1 || y == ytop)
        level = 0;

      else
        level = 2;
    }

    else
      if(ybot + -ytop >= 3)
      {
        if(y == ytop)
          level = 0;

        else
          level = 2;
      }

      else
        level = 2;
  return level;
}

// analogtv_levelmult
// file analogtv.c line 1115
static double analogtv_levelmult(const struct analogtv_s *it, signed int level)
{
  float return_value_puramp_1;
  return_value_puramp_1=puramp(it, (float)3.0, (float)6.0, (float)1.0);
  static const double levelfac[3l] = { -7.5, 5.5, 24.5 };
  return (40.0 + levelfac[(signed long int)level] * (double)return_value_puramp_1) / 256.0;
}

// analogtv_load_ximage
// file analogtv.c line 2015
signed int analogtv_load_ximage(struct analogtv_s *it, struct analogtv_input_s *input, struct _XImage *pic_im)
{
  signed int i;
  signed int x;
  signed int y;
  signed int img_w;
  signed int img_h;
  signed int fyx[7l];
  signed int fyy[7l];
  signed int fix[4l];
  signed int fiy[4l];
  signed int fqx[4l];
  signed int fqy[4l];
  struct anonymous_57 col1[755l];
  struct anonymous_57 col2[755l];
  signed int multiq[759l];
  signed int y_overscan = 5;
  signed int y_scanlength = 200 + 2 * y_overscan;
  img_w = pic_im->width;
  img_h = pic_im->height;
  i = 0;
  for( ; !(i >= 4); i = i + 1)
  {
    double phase = 90.0 - 90.0 * (double)i;
    double ampl = 1.0;
    double return_value_cos_1;
    return_value_cos_1=cos((3.1415926 / 180.0) * (phase - (double)303));
    multiq[(signed long int)i] = (signed int)(-return_value_cos_1 * 4096.0 * ampl);
  }
  y = 0;
  for( ; !(y >= y_scanlength); y = y + 1)
  {
    signed int picy1 = (y * img_h) / y_scanlength;
    signed int picy2 = (y * img_h + y_scanlength / 2) / y_scanlength;
    x = 0;
    if(!(x >= 755))
    {
      signed int picx = (x * img_w) / 755;
      col1[(signed long int)x].pixel=pic_im->f.get_pixel(pic_im, picx, picy1);
      col2[(signed long int)x].pixel=pic_im->f.get_pixel(pic_im, picx, picy2);
      x = x + 1;
    }

    XQueryColors(it->dpy, it->colormap, col1, 755);
    XQueryColors(it->dpy, it->colormap, col2, 755);
    i = 0;
    for( ; !(i >= 7); i = i + 1)
    {
      fyy[(signed long int)i] = 0;
      fyx[(signed long int)i] = fyy[(signed long int)i];
    }
    i = 0;
    for( ; !(i >= 4); i = i + 1)
    {
      fqy[(signed long int)i] = (signed int)0.0;
      fqx[(signed long int)i] = fqy[(signed long int)i];
      fiy[(signed long int)i] = fqx[(signed long int)i];
      fix[(signed long int)i] = fiy[(signed long int)i];
    }
    x = 0;
    for( ; !(x >= 755); x = x + 1)
    {
      signed int rawy;
      signed int rawi;
      signed int rawq;
      signed int filty;
      signed int filti;
      signed int filtq;
      signed int composite;
      rawy = 5 * (signed int)col1[(signed long int)x].red + 11 * (signed int)col1[(signed long int)x].green + 2 * (signed int)col1[(signed long int)x].blue + 5 * (signed int)col2[(signed long int)x].red + 11 * (signed int)col2[(signed long int)x].green + 2 * (signed int)col2[(signed long int)x].blue >> 7;
      rawi = ((((10 * (signed int)col1[(signed long int)x].red - 4 * (signed int)col1[(signed long int)x].green) - 5 * (signed int)col1[(signed long int)x].blue) + 10 * (signed int)col2[(signed long int)x].red) - 4 * (signed int)col2[(signed long int)x].green) - 5 * (signed int)col2[(signed long int)x].blue >> 7;
      rawq = (((3 * (signed int)col1[(signed long int)x].red - 8 * (signed int)col1[(signed long int)x].green) + 5 * (signed int)col1[(signed long int)x].blue + 3 * (signed int)col2[(signed long int)x].red) - 8 * (signed int)col2[(signed long int)x].green) + 5 * (signed int)col2[(signed long int)x].blue >> 7;
      fyx[(signed long int)0] = fyx[(signed long int)1];
      fyx[(signed long int)1] = fyx[(signed long int)2];
      fyx[(signed long int)2] = fyx[(signed long int)3];
      fyx[(signed long int)3] = fyx[(signed long int)4];
      fyx[(signed long int)4] = fyx[(signed long int)5];
      fyx[(signed long int)5] = fyx[(signed long int)6];
      fyx[(signed long int)6] = rawy * 1897 >> 16;
      fyy[(signed long int)0] = fyy[(signed long int)1];
      fyy[(signed long int)1] = fyy[(signed long int)2];
      fyy[(signed long int)2] = fyy[(signed long int)3];
      fyy[(signed long int)3] = fyy[(signed long int)4];
      fyy[(signed long int)4] = fyy[(signed long int)5];
      fyy[(signed long int)5] = fyy[(signed long int)6];
      fyy[(signed long int)6] = fyx[(signed long int)0] + fyx[(signed long int)6] + 4 * (fyx[(signed long int)1] + fyx[(signed long int)5]) + 7 * (fyx[(signed long int)2] + fyx[(signed long int)4]) + 8 * fyx[(signed long int)3] + (((-151 * fyy[(signed long int)2] + 8115 * fyy[(signed long int)3]) - 38312 * fyy[(signed long int)4]) + 36586 * fyy[(signed long int)5] >> 16);
      filty = fyy[(signed long int)6];
      fix[(signed long int)0] = fix[(signed long int)1];
      fix[(signed long int)1] = fix[(signed long int)2];
      fix[(signed long int)2] = fix[(signed long int)3];
      fix[(signed long int)3] = rawi * 1413 >> 16;
      fiy[(signed long int)0] = fiy[(signed long int)1];
      fiy[(signed long int)1] = fiy[(signed long int)2];
      fiy[(signed long int)2] = fiy[(signed long int)3];
      fiy[(signed long int)3] = fix[(signed long int)0] + fix[(signed long int)3] + 3 * (fix[(signed long int)1] + fix[(signed long int)2]) + ((16559 * fiy[(signed long int)0] - 72008 * fiy[(signed long int)1]) + 109682 * fiy[(signed long int)2] >> 16);
      filti = fiy[(signed long int)3];
      fqx[(signed long int)0] = fqx[(signed long int)1];
      fqx[(signed long int)1] = fqx[(signed long int)2];
      fqx[(signed long int)2] = fqx[(signed long int)3];
      fqx[(signed long int)3] = rawq * 75 >> 16;
      fqy[(signed long int)0] = fqy[(signed long int)1];
      fqy[(signed long int)1] = fqy[(signed long int)2];
      fqy[(signed long int)2] = fqy[(signed long int)3];
      fqy[(signed long int)3] = fqx[(signed long int)0] + fqx[(signed long int)3] + 3 * (fqx[(signed long int)1] + fqx[(signed long int)2]) + ((2612 * fqy[(signed long int)0] - 9007 * fqy[(signed long int)1]) + 10453 * fqy[(signed long int)2] >> 12);
      filtq = fqy[(signed long int)3];
      composite = filty + (multiq[(signed long int)x] * filti + multiq[(signed long int)(x + 3)] * filtq >> 12);
      composite = (composite * 100 >> 14) + 10;
      if(composite >= 126)
        composite = 125;

      if(!(composite >= 0))
        composite = 0;

      input->signal[(signed long int)((y - y_overscan) + 30)][(signed long int)(x + 135)] = (signed char)composite;
    }
  }
  return 1;
}

// analogtv_make_font
// file analogtv.c line 2209
void analogtv_make_font(struct _XDisplay *dpy, unsigned long int window, struct analogtv_font_s *f, signed int w, signed int h, char *fontname)
{
  signed int i;
  struct anonymous_59 *font;
  unsigned long int text_pm;
  struct _XGC *gc;
  struct anonymous_58 gcv;
  struct anonymous_16 xgwa;
  f->char_w = w;
  f->char_h = h;
  XGetWindowAttributes(dpy, window, &xgwa);
  _Bool tmp_if_expr_3;
  signed int return_value_strcmp_2;
  if(!(fontname == ((char *)NULL)))
  {
    return_value_strcmp_2=strcmp(fontname, "6x10");
    tmp_if_expr_3 = !(return_value_strcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3 = (_Bool)0;
  if(tmp_if_expr_3)
  {
    text_pm=XCreatePixmapFromBitmapData(dpy, window, (char *)font6x10_bits, (unsigned int)1792, (unsigned int)10, (unsigned long int)1, (unsigned long int)0, (unsigned int)1);
    f->text_im=XGetImage(dpy, text_pm, 0, 0, (unsigned int)1792, (unsigned int)10, (unsigned long int)1, 1);
    XFreePixmap(dpy, text_pm);
  }

  else
    if(!(fontname == ((char *)NULL)))
    {
      font=XLoadQueryFont(dpy, fontname);
      if(font == ((struct anonymous_59 *)NULL))
      {
        fprintf(stderr, "analogtv: can't load font %s\n", fontname);
        abort();
      }

      text_pm=XCreatePixmap(dpy, window, (unsigned int)(256 * f->char_w), (unsigned int)f->char_h, (unsigned int)1);
      memset((void *)&gcv, 0, sizeof(struct anonymous_58) /*128ul*/ );
      gcv.foreground = (unsigned long int)1;
      gcv.background = (unsigned long int)0;
      gcv.font = font->fid;
      gc=XCreateGC(dpy, text_pm, (unsigned long int)(1L << 14 | 1L << 3 | 1L << 2), &gcv);
      XSetForeground(dpy, gc, (unsigned long int)0);
      XFillRectangle(dpy, text_pm, gc, 0, 0, (unsigned int)(256 * f->char_w), (unsigned int)f->char_h);
      XSetForeground(dpy, gc, (unsigned long int)1);
      i = 0;
      for( ; !(i >= 256); i = i + 1)
      {
        char c = (char)i;
        signed int x = f->char_w * i + 1;
        signed int y = (f->char_h * 8) / 10;
        XDrawString(dpy, text_pm, gc, x, y, &c, 1);
      }
      f->text_im=XGetImage(dpy, text_pm, 0, 0, (unsigned int)(256 * f->char_w), (unsigned int)f->char_h, (unsigned long int)1, 1);
      XFreeGC(dpy, gc);
      XFreePixmap(dpy, text_pm);
    }

    else
    {
      f->text_im=XCreateImage(dpy, xgwa.visual, (unsigned int)1, 1, 0, ((char *)NULL), (unsigned int)(256 * f->char_w), (unsigned int)f->char_h, 8, 0);
      void *return_value_calloc_1;
      return_value_calloc_1=calloc((unsigned long int)f->text_im->height, (unsigned long int)f->text_im->bytes_per_line);
      f->text_im->data = (char *)return_value_calloc_1;
    }
  f->x_mult = 4;
  f->y_mult = 2;
}

// analogtv_ntsc_to_yiq
// file analogtv.c line 776
static void analogtv_ntsc_to_yiq(const struct analogtv_s *it, signed int lineno, const float *signal, signed int start, signed int end, struct analogtv_yiq_s *it_yiq)
{
  signed int i;
  const float *sp;
  signed int phasecorr = (signed int)(signal - it->rx_signal & (signed long int)3);
  struct analogtv_yiq_s *yiq;
  signed int colormode;
  float agclevel = it->agclevel;
  float brightadd = (float)((double)it->brightness_control * 100.0 - (double)10);
  float delay[787l];
  float *dp;
  float multiq2[4l];
  double cb_i = (it->line_cb_phase[(signed long int)lineno][(signed long int)(2 + phasecorr & 3)] - it->line_cb_phase[(signed long int)lineno][(signed long int)(0 + phasecorr & 3)]) / 16.0;
  double cb_q = (it->line_cb_phase[(signed long int)lineno][(signed long int)(3 + phasecorr & 3)] - it->line_cb_phase[(signed long int)lineno][(signed long int)(1 + phasecorr & 3)]) / 16.0;
  colormode = (signed int)(cb_i * cb_i + cb_q * cb_q > 2.8);
  if(!(colormode == 0))
  {
    multiq2[(signed long int)0] = (float)((cb_i * (double)it->tint_i - cb_q * (double)it->tint_q) * (double)it->color_control);
    multiq2[(signed long int)1] = (float)((cb_q * (double)it->tint_i + cb_i * (double)it->tint_q) * (double)it->color_control);
    multiq2[(signed long int)2] = -multiq2[(signed long int)0];
    multiq2[(signed long int)3] = -multiq2[(signed long int)1];
  }

  dp = (delay + (signed long int)755) - (signed long int)32;
  i = 0;
  for( ; !(i >= 5); i = i + 1)
    dp[(signed long int)i] = 0.0f;
  /* assertion start>=0 */
  assert(start >= 0);
  /* assertion end < ANALOGTV_PIC_LEN+10 */
  assert(end < 755 + 10);
  dp = (delay + (signed long int)755) - (signed long int)32;
  i = 0;
  for( ; !(i >= 24); i = i + 1)
    dp[(signed long int)i] = (float)0.0;
  i = start;
  yiq = it_yiq + (signed long int)start;
  sp = signal + (signed long int)start;
  for( ; !(i >= end); sp = sp + 1l)
  {
    dp[(signed long int)0] = sp[(signed long int)0] * 0.0469904257251935f * agclevel;
    dp[(signed long int)8] = ((+1.0f * (dp[(signed long int)6] + dp[(signed long int)0]) + 4.0f * (dp[(signed long int)5] + dp[(signed long int)1]) + 7.0f * (dp[(signed long int)4] + dp[(signed long int)2]) + 8.0f * dp[(signed long int)3]) - 0.0176648f * dp[(signed long int)12]) - 0.4860288f * dp[(signed long int)10];
    yiq->y = dp[(signed long int)8] + brightadd;
    i = i + 1;
    dp = dp - 1l;
    yiq = yiq + 1l;
  }
  if(!(colormode == 0))
  {
    dp = (delay + (signed long int)755) - (signed long int)32;
    i = 0;
    for( ; !(i >= 27); i = i + 1)
      dp[(signed long int)i] = (float)0.0;
    i = start;
    yiq = it_yiq + (signed long int)start;
    sp = signal + (signed long int)start;
    for( ; !(i >= end); sp = sp + 1l)
    {
      float sig = *sp;
      dp[(signed long int)0] = sig * multiq2[(signed long int)(i & 3)] * 0.0833333333333f;
      dp[(signed long int)8] = (dp[(signed long int)5] + dp[(signed long int)0] + 3.0f * (dp[(signed long int)4] + dp[(signed long int)1]) + 4.0f * (dp[(signed long int)3] + dp[(signed long int)2])) - 0.3333333333f * dp[(signed long int)10];
      yiq->i = dp[(signed long int)8];
      dp[(signed long int)16] = sig * multiq2[(signed long int)(i + 3 & 3)] * 0.0833333333333f;
      dp[(signed long int)24] = (dp[(signed long int)(16 + 5)] + dp[(signed long int)(16 + 0)] + 3.0f * (dp[(signed long int)(16 + 4)] + dp[(signed long int)(16 + 1)]) + 4.0f * (dp[(signed long int)(16 + 3)] + dp[(signed long int)(16 + 2)])) - 0.3333333333f * dp[(signed long int)(24 + 2)];
      yiq->q = dp[(signed long int)24];
      i = i + 1;
      dp = dp - 1l;
      yiq = yiq + 1l;
    }
  }

  else
  {
    i = start;
    yiq = it_yiq + (signed long int)start;
    for( ; !(i >= end); yiq = yiq + 1l)
    {
      yiq->q = 0.0f;
      yiq->i = yiq->q;
      i = i + 1;
    }
  }
}

// analogtv_reception_update
// file analogtv.h line 255
void analogtv_reception_update(struct analogtv_reception_s *rec)
{
  signed int i;
  if(rec->multipath > 0.0)
  {
    i = 0;
    for( ; !(i >= 4); i = i + 1)
    {
      double tmp_statement_expression_1;
      double analogtv_reception_update__1__1__1__1__tmp;
      unsigned int return_value_ya_random_2;
      return_value_ya_random_2=ya_random();
      analogtv_reception_update__1__1__1__1__tmp = ((double)return_value_ya_random_2 * (double)0.02) / (double)(unsigned int)~0;
      tmp_statement_expression_1 = analogtv_reception_update__1__1__1__1__tmp < (double)0 ? -analogtv_reception_update__1__1__1__1__tmp : analogtv_reception_update__1__1__1__1__tmp;
      rec->ghostfir2[(signed long int)i] = rec->ghostfir2[(signed long int)i] + -(rec->ghostfir2[(signed long int)i] / 16.0) + rec->multipath * (tmp_statement_expression_1 - 0.01);
    }
    unsigned int return_value_ya_random_6;
    return_value_ya_random_6=ya_random();
    if(return_value_ya_random_6 % 20u == 0u)
    {
      unsigned int return_value_ya_random_3;
      return_value_ya_random_3=ya_random();
      double tmp_statement_expression_4;
      double tmp;
      unsigned int return_value_ya_random_5;
      return_value_ya_random_5=ya_random();
      tmp = ((double)return_value_ya_random_5 * (double)0.08) / (double)(unsigned int)~0;
      tmp_statement_expression_4 = tmp < (double)0 ? -tmp : tmp;
      rec->ghostfir2[(signed long int)(return_value_ya_random_3 % (unsigned int)4)] = rec->multipath * (tmp_statement_expression_4 - 0.04);
    }

    i = 0;
    for( ; !(i >= 4); i = i + 1)
      rec->ghostfir[(signed long int)i] = 0.8 * rec->ghostfir[(signed long int)i] + 0.2 * rec->ghostfir2[(signed long int)i];
  }

  else
  {
    i = 0;
    for( ; !(i >= 4); i = i + 1)
      rec->ghostfir[(signed long int)i] = i >= 4 / 2 ? ((i & 1) != 0 ? +0.04 : -0.08) / (double)4 : 0.0;
  }
}

// analogtv_reconfigure
// file analogtv.h line 243
void analogtv_reconfigure(struct analogtv_s *it)
{
  XGetWindowAttributes(it->dpy, it->window, &it->xgwa);
  analogtv_configure(it);
}

// analogtv_release
// file analogtv.h line 246
void analogtv_release(struct analogtv_s *it)
{
  if(!(it->image == ((struct _XImage *)NULL)))
  {
    if(!(it->use_shm == 0))
      destroy_xshm_image(it->dpy, it->image, &it->shm_info);

    else
    {
      free((void *)it->image->data);
      it->image->data = (char *)(void *)0;
      it->image->f.destroy_image(it->image);
    }
    it->image = (struct _XImage *)(void *)0;
  }

  if(!(it->gc == ((struct _XGC *)NULL)))
    XFreeGC(it->dpy, it->gc);

  it->gc = (struct _XGC *)(void *)0;
  if(!(it->n_colors == 0))
    XFreeColors(it->dpy, it->colormap, it->colors, it->n_colors, (unsigned long int)0L);

  it->n_colors = 0;
  threadpool_destroy(&it->threads);
  free((void *)it->rx_signal);
  free((void *)it->signal_subtotals);
  free((void *)it);
}

// analogtv_set_defaults
// file analogtv.h line 245
void analogtv_set_defaults(struct analogtv_s *it, char *prefix)
{
  char buf[256l];
  sprintf(buf, "%sTVTint", prefix);
  double return_value_get_float_resource_1;
  return_value_get_float_resource_1=get_float_resource(it->dpy, buf, "TVTint");
  it->tint_control = (float)return_value_get_float_resource_1;
  sprintf(buf, "%sTVColor", prefix);
  double return_value_get_float_resource_2;
  return_value_get_float_resource_2=get_float_resource(it->dpy, buf, "TVColor");
  it->color_control = (float)(return_value_get_float_resource_2 / 100.0);
  sprintf(buf, "%sTVBrightness", prefix);
  double return_value_get_float_resource_3;
  return_value_get_float_resource_3=get_float_resource(it->dpy, buf, "TVBrightness");
  it->brightness_control = (float)(return_value_get_float_resource_3 / 100.0);
  sprintf(buf, "%sTVContrast", prefix);
  double return_value_get_float_resource_4;
  return_value_get_float_resource_4=get_float_resource(it->dpy, buf, "TVContrast");
  it->contrast_control = (float)(return_value_get_float_resource_4 / 100.0);
  it->height_control = (float)1.0;
  it->width_control = (float)1.0;
  it->squish_control = (float)0.0;
  it->powerup = (float)1000.0;
  it->hashnoise_rpm = (double)0;
  it->hashnoise_on = 0;
  it->hashnoise_enable = 1;
  double tmp_statement_expression_5;
  double analogtv_set_defaults__1__1__tmp;
  unsigned int return_value_ya_random_6;
  return_value_ya_random_6=ya_random();
  analogtv_set_defaults__1__1__tmp = ((double)return_value_ya_random_6 * (double)10.0) / (double)(unsigned int)~0;
  tmp_statement_expression_5 = analogtv_set_defaults__1__1__tmp < (double)0 ? -analogtv_set_defaults__1__1__tmp : analogtv_set_defaults__1__1__tmp;
  it->horiz_desync = (float)(tmp_statement_expression_5 - 5.0);
  double tmp_statement_expression_7;
  double tmp;
  unsigned int return_value_ya_random_8;
  return_value_ya_random_8=ya_random();
  tmp = ((double)return_value_ya_random_8 * (double)5.0) / (double)(unsigned int)~0;
  tmp_statement_expression_7 = tmp < (double)0 ? -tmp : tmp;
  it->squeezebottom = (float)(tmp_statement_expression_7 - 1.0);
}

// analogtv_set_demod
// file analogtv.c line 647
signed int analogtv_set_demod(struct analogtv_s *it)
{
  signed int y_levels = 10;
  signed int i_levels = 5;
  signed int q_levels = 5;

cmap_again:
  ;
  signed int yli;
  signed int qli;
  signed int ili;
  double interpy;
  double interpi;
  double interpq;
  double levelmult;
  signed int r;
  signed int g;
  signed int b;
  struct anonymous_57 col;
  signed int return_value_XAllocColor_1;
  while((_Bool)1)
  {
    if(it->use_cmap == 0)
      goto __CPROVER_DUMP_L20;

    if(!(it->n_colors == 0))
      goto __CPROVER_DUMP_L20;

    if(!(it->n_colors == 0))
    {
      XFreeColors(it->dpy, it->colormap, it->colors, it->n_colors, (unsigned long int)0L);
      it->n_colors = 0;
    }

    yli = 0;

  __CPROVER_DUMP_L3:
    ;
    if(yli >= y_levels)
      goto __CPROVER_DUMP_L19;

    ili = 0;

  __CPROVER_DUMP_L4:
    ;
    if(ili >= i_levels)
      goto __CPROVER_DUMP_L18;

    qli = 0;

  __CPROVER_DUMP_L5:
    ;
    if(qli >= q_levels)
      goto __CPROVER_DUMP_L17;

    levelmult = 700.0;
    interpy = 100.0 * ((double)yli / (double)y_levels);
    interpi = 50.0 * (((double)ili - 0.5 * (double)i_levels) / (double)i_levels);
    interpq = 50.0 * (((double)qli - 0.5 * (double)q_levels) / (double)q_levels);
    r = (signed int)((interpy + 1.04 * interpi + 0.624 * interpq) * levelmult);
    g = (signed int)(((interpy - 0.276 * interpi) - 0.639 * interpq) * levelmult);
    b = (signed int)(((interpy - 1.105 * interpi) + 1.729 * interpq) * levelmult);
    if(!(r >= 0))
      r = 0;

    if(r >= 65536)
      r = 65535;

    if(!(g >= 0))
      g = 0;

    if(g >= 65536)
      g = 65535;

    if(!(b >= 0))
      b = 0;

    if(b >= 65536)
      b = 65535;

    col.red = (unsigned short int)r;
    col.green = (unsigned short int)g;
    col.blue = (unsigned short int)b;
    col.pixel = (unsigned long int)0;
    return_value_XAllocColor_1=XAllocColor(it->dpy, it->colormap, &col);
    if(!(return_value_XAllocColor_1 == 0))
      break;

    if(!((4 * y_levels) / 12 >= q_levels))
      q_levels = q_levels - 1;

    else
      if(!((5 * y_levels) / 12 >= i_levels))
        i_levels = i_levels - 1;

      else
        y_levels = y_levels - 1;
    if(!(y_levels >= 2))
      return -1;

  }
  signed int tmp_post_2 = it->n_colors;
  it->n_colors = it->n_colors + 1;
  it->colors[(signed long int)tmp_post_2] = col.pixel;
  qli = qli + 1;
  goto __CPROVER_DUMP_L5;

__CPROVER_DUMP_L17:
  ;
  ili = ili + 1;
  goto __CPROVER_DUMP_L4;

__CPROVER_DUMP_L18:
  ;
  yli = yli + 1;
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L19:
  ;
  it->cmap_y_levels = y_levels;
  it->cmap_i_levels = i_levels;
  it->cmap_q_levels = q_levels;

__CPROVER_DUMP_L20:
  ;
  return 0;
}

// analogtv_setup_frame
// file analogtv.h line 248
void analogtv_setup_frame(struct analogtv_s *it)
{
  it->redraw_all = 0;
  if(!(it->flutter_horiz_desync == 0))
  {
    unsigned int return_value_ya_random_1;
    return_value_ya_random_1=ya_random();
    unsigned int return_value_ya_random_2;
    return_value_ya_random_2=ya_random();
    unsigned int return_value_ya_random_3;
    return_value_ya_random_3=ya_random();
    it->horiz_desync = it->horiz_desync + (float)(-0.10 * ((double)it->horiz_desync - 3.0) + (double)(((signed int)(return_value_ya_random_1 & (unsigned int)0xff) - 0x80) * ((signed int)(return_value_ya_random_2 & (unsigned int)0xff) - 0x80) * ((signed int)(return_value_ya_random_3 & (unsigned int)0xff) - 0x80)) * 0.000001);
  }

  if(!(it->hashnoise_enable == 0))
  {
    if(it->hashnoise_on == 0)
    {
      unsigned int return_value_ya_random_5;
      return_value_ya_random_5=ya_random();
      if(return_value_ya_random_5 % 10000u == 0u)
      {
        it->hashnoise_on = 1;
        unsigned int return_value_ya_random_4;
        return_value_ya_random_4=ya_random();
        it->shrinkpulse = (signed int)(return_value_ya_random_4 % (unsigned int)262);
      }

    }

  }

  unsigned int return_value_ya_random_6;
  return_value_ya_random_6=ya_random();
  if(return_value_ya_random_6 % 1000u == 0u)
    it->hashnoise_on = 0;

  if(IEEE_FLOAT_NOTEQUAL(it->rx_signal_level, 0.0))
    it->agclevel = (float)(1.0 / it->rx_signal_level);

}

// analogtv_setup_levels
// file analogtv.c line 1154
static void analogtv_setup_levels(struct analogtv_s *it, double avgheight)
{
  signed int i;
  signed int height = 0;
  for( ; (double)height < avgheight + 2.0 && !(height >= 13); height = height + 1)
  {
    i = 0;
    for( ; !(i >= height); i = i + 1)
      it->leveltable[(signed long int)height][(signed long int)i].index = 2;
    if(avgheight >= 3.000000)
      it->leveltable[(signed long int)height][(signed long int)0].index = 0;

    if(avgheight >= 5.000000)
    {
      if(height >= 1)
        it->leveltable[(signed long int)height][(signed long int)(height - 1)].index = 0;

    }

    if(avgheight >= 7.000000)
    {
      it->leveltable[(signed long int)height][(signed long int)1].index = 1;
      if(height >= 2)
        it->leveltable[(signed long int)height][(signed long int)(height - 2)].index = 1;

    }

    i = 0;
    for( ; !(i >= height); i = i + 1)
    {
      float return_value_puramp_1;
      return_value_puramp_1=puramp(it, (float)3.0, (float)6.0, (float)1.0);
      static const double levelfac[3l] = { -7.5, 5.5, 24.5 };
      it->leveltable[(signed long int)height][(signed long int)i].value = (40.0 + levelfac[(signed long int)it->leveltable[(signed long int)height][(signed long int)i].index] * (double)return_value_puramp_1) / 256.0;
    }
  }
}

// analogtv_setup_sync
// file analogtv.h line 249
void analogtv_setup_sync(struct analogtv_input_s *input, signed int do_cb, signed int do_ssavi)
{
  signed int i;
  signed int lineno;
  signed int vsync;
  signed char *sig;
  signed int synclevel = do_ssavi != 0 ? 100 : -40;
  lineno = 0;
  for( ; !(lineno >= 262); lineno = lineno + 1)
  {
    vsync = (signed int)(lineno >= 3 && lineno < 7);
    sig = input->signal[(signed long int)lineno];
    i = 0;
    if(!(vsync == 0))
    {
      while(!(i >= 67))
      {
        signed int tmp_post_1 = i;
        i = i + 1;
        sig[(signed long int)tmp_post_1] = (signed char)0;
      }
      while(!(i >= 912))
      {
        signed int tmp_post_2 = i;
        i = i + 1;
        sig[(signed long int)tmp_post_2] = (signed char)synclevel;
      }
    }

    else
    {
      while(!(i >= 67))
      {
        signed int tmp_post_3 = i;
        i = i + 1;
        sig[(signed long int)tmp_post_3] = (signed char)synclevel;
      }
      while(!(i >= 135))
      {
        signed int tmp_post_4 = i;
        i = i + 1;
        sig[(signed long int)tmp_post_4] = (signed char)0;
      }
      while(!(i >= 890))
      {
        signed int tmp_post_5 = i;
        i = i + 1;
        sig[(signed long int)tmp_post_5] = (signed char)10;
      }
    }
    while(!(i >= 912))
    {
      signed int tmp_post_6 = i;
      i = i + 1;
      sig[(signed long int)tmp_post_6] = (signed char)0;
    }
    if(!(do_cb == 0))
    {
      i = 83;
      for( ; !(i >= 36); i = i + 4)
      {
        sig[(signed long int)(i + 1)] = sig[(signed long int)(i + 1)] + (signed char)20;
        sig[(signed long int)(i + 3)] = sig[(signed long int)(i + 3)] - (signed char)20;
      }
    }

  }
}

// analogtv_setup_teletext
// file analogtv.c line 892
void analogtv_setup_teletext(struct analogtv_input_s *input)
{
  signed int x;
  signed int y;
  signed int teletext = 10;
  y = 19;
  for( ; !(y >= 22); y = y + 1)
  {
    x = 135;
    for( ; !(x >= 890); x = x + 1)
    {
      if((7 & x) == 0)
      {
        unsigned int return_value_ya_random_1;
        return_value_ya_random_1=ya_random();
        teletext = (return_value_ya_random_1 & (unsigned int)1) != 0u ? 100 : 10;
      }

      input->signal[(signed long int)y][(signed long int)x] = (signed char)teletext;
    }
  }
}

// analogtv_sync
// file analogtv.c line 1028
static void analogtv_sync(struct analogtv_s *it)
{
  signed int cur_hsync = it->cur_hsync;
  signed int cur_vsync = it->cur_vsync;
  signed int lineno = 0;
  signed int i;
  signed int j;
  float osc;
  float filt;
  float *sp;
  float cbfc = 1.0f / 128.0f;
  i = -32;
  for( ; !(i >= 32); i = i + 1)
  {
    lineno = (cur_vsync + i + 262) % 262;
    sp = it->rx_signal + (signed long int)(lineno * 912);
    filt = 0.0f;
    j = 0;
    for( ; !(j >= 912); j = j + 912 / 16)
      filt = filt + sp[(signed long int)j];
    filt = filt * it->agclevel;
    osc = (float)(262 + i) / (float)262;
    if(osc >= 1.05f + 0.0002f * filt)
      break;

  }
  cur_vsync = (cur_vsync + i + 262) % 262;
  lineno = 0;
  for( ; !(lineno >= 262); lineno = lineno + 1)
  {
    if(lineno >= 6 && !(lineno >= 259))
    {
      unsigned int lineno2 = (unsigned int)((lineno + cur_vsync + 262) % 262);
      if(lineno2 == 0u)
        lineno2 = (unsigned int)262;

      sp = it->rx_signal + (signed long int)(lineno2 * (unsigned int)912) + (signed long int)cur_hsync;
      i = -8;
      for( ; !(i >= 8); i = i + 1)
      {
        osc = (float)(912 + i) / (float)912;
        filt = (sp[(signed long int)(i - 3)] + sp[(signed long int)(i - 2)] + sp[(signed long int)(i - 1)] + sp[(signed long int)i]) * it->agclevel;
        if(osc >= 1.005f + 0.0001f * filt)
          break;

      }
      cur_hsync = (cur_hsync + i + 912) % 912;
    }

    it->line_hsync[(signed long int)lineno] = (cur_hsync + 135 + 912) % 912;
    if(lineno >= 16)
    {
      sp = it->rx_signal + (signed long int)(lineno * 912) + (signed long int)(cur_hsync & ~3);
      i = 83 + 8;
      for( ; !(i >= 36); i = i + 1)
        it->cb_phase[(signed long int)(i & 3)] = it->cb_phase[(signed long int)(i & 3)] * (double)(1.0f - cbfc) + (double)(sp[(signed long int)i] * it->agclevel * cbfc);
    }

    float tot = 0.1f;
    float cbgain;
    i = 0;
    for( ; !(i >= 4); i = i + 1)
      tot = tot + (float)(it->cb_phase[(signed long int)i] * it->cb_phase[(signed long int)i]);
    float return_value_sqrtf_1;
    return_value_sqrtf_1=sqrtf(tot);
    cbgain = 32.0f / return_value_sqrtf_1;
    i = 0;
    for( ; !(i >= 4); i = i + 1)
      it->line_cb_phase[(signed long int)lineno][(signed long int)i] = it->cb_phase[(signed long int)i] * (double)cbgain;
  }
  it->cur_hsync = cur_hsync;
  it->cur_vsync = cur_vsync;
}

// analogtv_thread_add_signals
// file analogtv.c line 1323
static void analogtv_thread_add_signals(void *thread_raw)
{
  const struct analogtv_thread_s *thread = (struct analogtv_thread_s *)thread_raw;
  const struct analogtv_s *it = thread->it;
  unsigned int i;
  unsigned int j;
  unsigned int subtotal_end;
  unsigned int start = (unsigned int)thread->signal_start;
  while(!((unsigned long int)start == thread->signal_end))
  {
    float *p;
    unsigned int end = start + (unsigned int)2048;
    if(!(thread->signal_end >= (unsigned long int)end))
      end = (unsigned int)thread->signal_end;

    analogtv_init_signal(it, it->noiselevel, start, end);
    i = (unsigned int)0;
    for( ; !(i == it->rec_count); i = i + 1u)
    {
      signed int tmp_if_expr_1;
      if(i == 0u)
        tmp_if_expr_1 = it->channel_change_cycles;

      else
        tmp_if_expr_1 = 0;
      analogtv_add_signal(it, it->recs[(signed long int)i], start, end, tmp_if_expr_1);
    }
    /* assertion !(start % 32) */
    assert(!(start % (unsigned int)32 != 0u));
    /* assertion !(end % 32) */
    assert(!(end % (unsigned int)32 != 0u));
    p = it->rx_signal + (signed long int)start;
    subtotal_end = end / (unsigned int)32;
    i = start / (unsigned int)32;
    for( ; !(i == subtotal_end); i = i + 1u)
    {
      float sum = p[(signed long int)0];
      j = (unsigned int)1;
      for( ; !(j == 32u); j = j + 1u)
        sum = sum + p[(signed long int)j];
      it->signal_subtotals[(signed long int)i] = sum;
      p = p + (signed long int)32;
    }
    start = end;
  }
}

// analogtv_thread_create
// file analogtv.c line 440
static signed int analogtv_thread_create(void *thread_raw, struct threadpool *threads, unsigned int thread_id)
{
  struct analogtv_thread_s *thread = (struct analogtv_thread_s *)thread_raw;
  unsigned int align;
  thread->it = (struct analogtv_s *)((char *)threads - (signed long int)160ul);
  thread->thread_id = thread_id;
  unsigned int return_value_thread_memory_alignment_1;
  return_value_thread_memory_alignment_1=thread_memory_alignment(thread->it->dpy);
  align = (unsigned int)((unsigned long int)return_value_thread_memory_alignment_1 / sizeof(float) /*4ul*/ );
  if(align == 0u)
    align = (unsigned int)1;

  align = ~(align * (unsigned int)32 - (unsigned int)1);
  thread->signal_start = (unsigned long int)(((unsigned int)238944 * thread_id) / threads->count & align);
  unsigned int tmp_if_expr_2;
  if(1u + thread_id == threads->count)
    tmp_if_expr_2 = (unsigned int)238944;

  else
    tmp_if_expr_2 = ((unsigned int)238944 * (thread_id + (unsigned int)1)) / threads->count & align;
  thread->signal_end = (unsigned long int)tmp_if_expr_2;
  return 0;
}

// analogtv_thread_destroy
// file analogtv.c line 463
static void analogtv_thread_destroy(void *thread_raw)
{
  ;
}

// analogtv_thread_draw_lines
// file analogtv.c line 1519
static void analogtv_thread_draw_lines(void *thread_raw)
{
  const struct analogtv_thread_s *thread = (struct analogtv_thread_s *)thread_raw;
  const struct analogtv_s *it = thread->it;
  signed int lineno;
  float *raw_rgb_start;
  float *raw_rgb_end;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)(it->subwidth * 3), sizeof(float) /*4ul*/ );
  raw_rgb_start = (float *)return_value_calloc_1;
  if(!(raw_rgb_start == ((float *)NULL)))
  {
    raw_rgb_end = raw_rgb_start + (signed long int)(3 * it->subwidth);
    lineno = (signed int)((unsigned int)30 + thread->thread_id);
    for( ; !(lineno >= 230); lineno = lineno + (signed int)it->threads.count)
    {
      signed int i;
      signed int j;
      signed int x;
      signed int y;
      signed int slineno;
      signed int ytop;
      signed int ybot;
      unsigned int signal_offset;
      const float *signal;
      signed int scanstart_i;
      signed int scanend_i;
      signed int squishright_i;
      signed int squishdiv;
      signed int pixrate;
      float *rgb_start;
      float *rgb_end;
      float pixbright;
      signed int pixmultinc;
      float *rrp;
      struct analogtv_yiq_s yiq[765l];
      signed int return_value_analogtv_get_line_2;
      return_value_analogtv_get_line_2=analogtv_get_line(it, lineno, &slineno, &ytop, &ybot, &signal_offset);
      if(!(return_value_analogtv_get_line_2 == 0))
      {
        signal = it->rx_signal + (signed long int)signal_offset;
        float bloomthisrow;
        float shiftthisrow;
        float viswidth;
        float middle;
        float scanwidth;
        signed int scw;
        signed int scl;
        signed int scr;
        bloomthisrow = -10.0f * it->crtload[(signed long int)lineno];
        if(bloomthisrow < -10.000000f)
          bloomthisrow = -10.0f;

        if(bloomthisrow > 2.0f)
          bloomthisrow = 2.0f;

        if(!(slineno >= 16))
        {
          float return_value_expf_3;
          return_value_expf_3=expf(-0.17f * (float)slineno);
          float return_value_cosf_4;
          return_value_cosf_4=cosf((float)slineno * 0.6f);
          shiftthisrow = it->horiz_desync * return_value_expf_3 * (0.7f + return_value_cosf_4);
        }

        else
          shiftthisrow = 0.0f;
        viswidth = (float)755 * 0.79f - 5.0f * bloomthisrow;
        middle = (float)(755 / 2) - shiftthisrow;
        float return_value_puramp_5;
        return_value_puramp_5=puramp(it, 0.5f, 0.3f, 1.0f);
        scanwidth = it->width_control * return_value_puramp_5;
        scw = (signed int)((float)it->subwidth * scanwidth);
        if(!(it->subwidth >= scw))
          scw = it->usewidth;

        scl = it->subwidth / 2 - scw / 2;
        scr = it->subwidth / 2 + scw / 2;
        pixrate = (signed int)((float)(signed int)((viswidth * 65536.0f * 1.0f) / (float)it->subwidth) / scanwidth);
        scanstart_i = (signed int)((middle - viswidth * 0.5f) * 65536.0f);
        scanend_i = (755 - 1) * 65536;
        float return_value_puramp_6;
        return_value_puramp_6=puramp(it, 2.0f, 0.0f, 1.1f);
        squishright_i = (signed int)((middle + viswidth * ((0.25f + 0.25f * return_value_puramp_6) - it->squish_control)) * 65536.0f);
        squishdiv = it->subwidth / 15;
        rgb_start = raw_rgb_start + (signed long int)(scl * 3);
        rgb_end = raw_rgb_start + (signed long int)(scr * 3);
        /* assertion scanstart_i>=0 */
        assert(scanstart_i >= 0);
        if(!(it->use_cmap == 0))
        {
          y = ytop;
          for( ; !(y >= ybot); y = y + 1)
          {
            signed int level;
            level=analogtv_level(it, y, ytop, ybot);
            float levelmult;
            double return_value_analogtv_levelmult_7;
            return_value_analogtv_levelmult_7=analogtv_levelmult(it, level);
            levelmult = (float)return_value_analogtv_levelmult_7;
            float levelmult_y;
            float return_value_puramp_8;
            return_value_puramp_8=puramp(it, 1.0f, 0.0f, 1.0f);
            levelmult_y = ((levelmult * it->contrast_control * return_value_puramp_8) / (0.5f + 0.5f * it->puheight)) * 0.070f;
            float levelmult_iq = levelmult * 0.090f;
            analogtv_ntsc_to_yiq(it, lineno, signal, (scanstart_i >> 16) - 10, (scanend_i >> 16) + 10, yiq);
            pixmultinc = pixrate;
            x = 0;
            i = scanstart_i;
            if(!(i >= 0))
            {
              if(!(x >= it->usewidth))
              {
                it->image->f.put_pixel(it->image, x, y, it->colors[(signed long int)0]);
                i = i + pixmultinc;
                x = x + 1;
              }

            }

            while(!(i >= scanend_i))
            {
              if(x >= it->usewidth)
                break;

              float analogtv_thread_draw_lines__1__1__2__1__2__pixfrac = (float)(i & 0xffff) / 65536.0f;
              float invpixfrac = 1.0f - analogtv_thread_draw_lines__1__1__2__1__2__pixfrac;
              signed int pati = i >> 16;
              signed int yli;
              signed int ili;
              signed int qli;
              signed int cmi;
              float analogtv_thread_draw_lines__1__1__2__1__2__interpy = (yiq[(signed long int)pati].y * invpixfrac + yiq[(signed long int)(pati + 1)].y * analogtv_thread_draw_lines__1__1__2__1__2__pixfrac) * levelmult_y;
              float analogtv_thread_draw_lines__1__1__2__1__2__interpi = (yiq[(signed long int)pati].i * invpixfrac + yiq[(signed long int)(pati + 1)].i * analogtv_thread_draw_lines__1__1__2__1__2__pixfrac) * levelmult_iq;
              float analogtv_thread_draw_lines__1__1__2__1__2__interpq = (yiq[(signed long int)pati].q * invpixfrac + yiq[(signed long int)(pati + 1)].q * analogtv_thread_draw_lines__1__1__2__1__2__pixfrac) * levelmult_iq;
              yli = (signed int)(analogtv_thread_draw_lines__1__1__2__1__2__interpy * (float)it->cmap_y_levels);
              ili = (signed int)((analogtv_thread_draw_lines__1__1__2__1__2__interpi + 0.5f) * (float)it->cmap_i_levels);
              qli = (signed int)((analogtv_thread_draw_lines__1__1__2__1__2__interpq + 0.5f) * (float)it->cmap_q_levels);
              if(!(yli >= 0))
                yli = 0;

              if(yli >= it->cmap_y_levels)
                yli = it->cmap_y_levels - 1;

              if(!(ili >= 0))
                ili = 0;

              if(ili >= it->cmap_i_levels)
                ili = it->cmap_i_levels - 1;

              if(!(qli >= 0))
                qli = 0;

              if(qli >= it->cmap_q_levels)
                qli = it->cmap_q_levels - 1;

              cmi = qli + it->cmap_i_levels * (ili + it->cmap_q_levels * yli);
              j = 0;
              if(!(j >= it->xrepl))
              {
                it->image->f.put_pixel(it->image, x, y, it->colors[(signed long int)cmi]);
                x = x + 1;
                j = j + 1;
              }

              if(i >= squishright_i)
                pixmultinc = pixmultinc + pixmultinc / squishdiv;

              i = i + pixmultinc;
            }
            if(!(x >= it->usewidth))
            {
              it->image->f.put_pixel(it->image, x, y, it->colors[(signed long int)0]);
              x = x + 1;
            }

          }
        }

        else
        {
          analogtv_ntsc_to_yiq(it, lineno, signal, (scanstart_i >> 16) - 10, (scanend_i >> 16) + 10, yiq);
          float return_value_puramp_9;
          return_value_puramp_9=puramp(it, 1.0f, 0.0f, 1.0f);
          pixbright = (((it->contrast_control * return_value_puramp_9) / (0.5f + 0.5f * it->puheight)) * 1024.0f) / 100.0f;
          pixmultinc = pixrate;
          i = scanstart_i;
          rrp = rgb_start;
          for( ; !(rrp == rgb_end) && !(i >= 0); rrp = rrp + (signed long int)3)
          {
            rrp[(signed long int)2] = (float)0;
            rrp[(signed long int)1] = rrp[(signed long int)2];
            rrp[(signed long int)0] = rrp[(signed long int)1];
            i = i + pixmultinc;
          }
          while(!(rrp == rgb_end) && !(i >= scanend_i))
          {
            float pixfrac = (float)(i & 0xffff) / 65536.0f;
            float analogtv_thread_draw_lines__1__1__3__2__invpixfrac = 1.0f - pixfrac;
            signed int analogtv_thread_draw_lines__1__1__3__2__pati = i >> 16;
            float r;
            float g;
            float b;
            float interpy = yiq[(signed long int)analogtv_thread_draw_lines__1__1__3__2__pati].y * analogtv_thread_draw_lines__1__1__3__2__invpixfrac + yiq[(signed long int)(analogtv_thread_draw_lines__1__1__3__2__pati + 1)].y * pixfrac;
            float interpi = yiq[(signed long int)analogtv_thread_draw_lines__1__1__3__2__pati].i * analogtv_thread_draw_lines__1__1__3__2__invpixfrac + yiq[(signed long int)(analogtv_thread_draw_lines__1__1__3__2__pati + 1)].i * pixfrac;
            float interpq = yiq[(signed long int)analogtv_thread_draw_lines__1__1__3__2__pati].q * analogtv_thread_draw_lines__1__1__3__2__invpixfrac + yiq[(signed long int)(analogtv_thread_draw_lines__1__1__3__2__pati + 1)].q * pixfrac;
            r = (interpy + 0.948f * interpi + 0.624f * interpq) * pixbright;
            g = ((interpy - 0.276f * interpi) - 0.639f * interpq) * pixbright;
            b = ((interpy - 1.105f * interpi) + 1.729f * interpq) * pixbright;
            if(r < 0.0f)
              r = 0.0f;

            if(g < 0.0f)
              g = 0.0f;

            if(b < 0.0f)
              b = 0.0f;

            rrp[(signed long int)0] = r;
            rrp[(signed long int)1] = g;
            rrp[(signed long int)2] = b;
            if(i >= squishright_i)
            {
              pixmultinc = pixmultinc + pixmultinc / squishdiv;
              pixbright = pixbright + (pixbright / (float)squishdiv) / (float)2;
            }

            i = i + pixmultinc;
            rrp = rrp + (signed long int)3;
          }
          for( ; !(rrp == rgb_end); rrp = rrp + (signed long int)3)
          {
            rrp[(signed long int)2] = 0.0f;
            rrp[(signed long int)1] = rrp[(signed long int)2];
            rrp[(signed long int)0] = rrp[(signed long int)1];
          }
          analogtv_blast_imagerow(it, raw_rgb_start, raw_rgb_end, ytop, ybot);
        }
      }

    }
    free((void *)raw_rgb_start);
  }

}

// apple2_draw
// file apple2-main.c line 1857
static unsigned long int apple2_draw(struct _XDisplay *dpy, unsigned long int window, void *closure)
{
  struct state *st = (struct state *)closure;
  unsigned int return_value_ya_random_1;
  if(st->sim == ((struct apple2_sim_s *)NULL))
  {
    if(!(st->random_p == 0))
    {
      return_value_ya_random_1=ya_random();
      st->controller = controllers[(signed long int)((unsigned long int)return_value_ya_random_1 % (sizeof(void (* const [3l])(struct apple2_sim_s *, signed int *, double *)) /*24ul*/  / sizeof(void (*)(struct apple2_sim_s *, signed int *, double *)) /*8ul*/ ))];
    }

    st->sim=apple2_start(dpy, window, st->duration, st->controller);
  }

  signed int return_value_apple2_one_frame_2;
  return_value_apple2_one_frame_2=apple2_one_frame(st->sim);
  if(return_value_apple2_one_frame_2 == 0)
    st->sim = ((struct apple2_sim_s *)NULL);

  return (unsigned long int)5000;
}

// apple2_event
// file apple2-main.c line 1888
static signed int apple2_event(struct _XDisplay *dpy, unsigned long int window, void *closure, union _XEvent *event)
{
  struct state *st = (struct state *)closure;
  if(!(st->sim == ((struct apple2_sim_s *)NULL)))
  {
    if(!(st->controller == terminal_controller))
      goto __CPROVER_DUMP_L1;

    if(!(event->xany.type == 2))
      goto __CPROVER_DUMP_L1;

    terminal_keypress_handler(dpy, event, st->sim->controller_data);
    return 1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 0;
  }
}

// apple2_free
// file apple2-main.c line 1903
static void apple2_free(struct _XDisplay *dpy, unsigned long int window, void *closure)
{
  struct state *st = (struct state *)closure;
  if(!(st->sim == ((struct apple2_sim_s *)NULL)))
  {
    st->sim->stepno = -1;
    signed int return_value_apple2_one_frame_1;
    return_value_apple2_one_frame_1=apple2_one_frame(st->sim);
    if(!(return_value_apple2_one_frame_1 == 0))
      abort();

  }

  free((void *)st);
}

// apple2_init
// file apple2-main.c line 1803
static void * apple2_init(struct _XDisplay *dpy, unsigned long int window)
{
  struct state *st;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct state) /*24ul*/ );
  st = (struct state *)return_value_calloc_1;
  char *s;
  st->duration=get_integer_resource(dpy, "duration", "Integer");
  st->controller = ((void (*)(struct apple2_sim_s *, signed int *, double *))NULL);
  if(!(st->duration >= 1))
    st->duration = 1;

  s=get_string_resource(dpy, "mode", "Mode");
  _Bool tmp_if_expr_5;
  if(s == ((char *)NULL))
    tmp_if_expr_5 = (_Bool)1;

  else
    tmp_if_expr_5 = !(*s != 0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_7;
  signed int return_value_strcasecmp_6;
  if(tmp_if_expr_5)
    tmp_if_expr_7 = (_Bool)1;

  else
  {
    return_value_strcasecmp_6=strcasecmp(s, "random");
    tmp_if_expr_7 = !(return_value_strcasecmp_6 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int return_value_strcasecmp_4;
  signed int return_value_strcasecmp_3;
  signed int return_value_strcasecmp_2;
  if(tmp_if_expr_7)
    st->random_p = 1;

  else
  {
    return_value_strcasecmp_4=strcasecmp(s, "text");
    if(return_value_strcasecmp_4 == 0)
      st->controller = terminal_controller;

    else
    {
      return_value_strcasecmp_3=strcasecmp(s, "slideshow");
      if(return_value_strcasecmp_3 == 0)
        st->controller = slideshow_controller;

      else
      {
        return_value_strcasecmp_2=strcasecmp(s, "basic");
        if(return_value_strcasecmp_2 == 0)
          st->controller = basic_controller;

        else
        {
          fprintf(stderr, "%s: mode must be text, slideshow, or random; not %s\n", progname, s);
          exit(1);
        }
      }
    }
  }
  if(!(s == ((char *)NULL)))
    free((void *)s);

  global_program=get_string_resource(dpy, "program", "Program");
  global_fast_p=get_boolean_resource(dpy, "fast", "Boolean");
  const char *apple2_init__1__2__s;
  apple2_init__1__2__s=getenv("XSCREENSAVER_STANDALONE");
  signed int return_value_strcmp_8;
  if(!(apple2_init__1__2__s == ((const char *)NULL)))
  {
    if(!(*apple2_init__1__2__s == 0))
    {
      return_value_strcmp_8=strcmp(apple2_init__1__2__s, "0");
      if(!(return_value_strcmp_8 == 0))
      {
        st->controller = terminal_controller;
        st->random_p = 0;
        global_program=getenv("SHELL");
        global_fast_p = 1;
      }

    }

  }

  if(st->random_p == 0)
  {
    _Bool tmp_if_expr_9;
    if(st->controller == terminal_controller)
      tmp_if_expr_9 = (_Bool)1;

    else
      tmp_if_expr_9 = st->controller == slideshow_controller ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_9)
      st->duration = 999999;

  }

  return (void *)st;
}

// apple2_one_frame
// file apple2.c line 592
extern signed int apple2_one_frame(struct apple2_sim_s *sim)
{
  double blinkphase;
  signed int i;
  signed int textrow;
  if(!(sim->stepno == -1))
  {
    struct timeval curtime_tv;
    struct timezone tzp;
    gettimeofday(&curtime_tv, &tzp);
    sim->curtime = (double)(curtime_tv.tv_sec - sim->basetime_tv.tv_sec) + 0.000001 * (double)(curtime_tv.tv_usec - sim->basetime_tv.tv_usec);
    if(sim->curtime > (double)sim->dec->powerup)
      sim->dec->powerup = (float)sim->curtime;

    blinkphase = sim->curtime / 0.8;
    i = sim->st->blink;
    sim->st->blink = (signed int)blinkphase & 1;
    if(!(sim->st->blink == i))
    {
      if((A2_GR_FULL & (signed int)sim->st->gr_mode) == 0)
      {
        signed int downcounter = 0;
        signed int apple2_one_frame__1__2__row;
        signed int apple2_one_frame__1__2__col;
        apple2_one_frame__1__2__row = sim->st->gr_mode != (enum anonymous_53)0 ? 20 : 0;
        for( ; !(apple2_one_frame__1__2__row >= 24); apple2_one_frame__1__2__row = apple2_one_frame__1__2__row + 1)
        {
          apple2_one_frame__1__2__col = 0;
          for( ; !(apple2_one_frame__1__2__col >= 40); apple2_one_frame__1__2__col = apple2_one_frame__1__2__col + 1)
          {
            signed int c = (signed int)sim->st->textlines[(signed long int)apple2_one_frame__1__2__row][(signed long int)apple2_one_frame__1__2__col];
            if((0xc0 & c) == 0x40)
            {
              downcounter = 4;
              break;
            }

          }
          if(downcounter >= 1)
            downcounter = downcounter - 1;

        }
      }

    }

    if(sim->curtime >= sim->delay)
      sim->stepno = -1;

    if(!(sim->printing == ((char *)NULL)))
    {
      signed int nlcnt = 0;
      while(!(*sim->printing == 0))
        if((signed int)*sim->printing == 1)
        {
          sim->printing = sim->printing + 1l;
          break;
        }

        else
          if((signed int)*sim->printing == 10)
          {
            a2_printc(sim->st, *sim->printing);
            sim->printing = sim->printing + 1l;
            nlcnt = nlcnt + 1;
            if(nlcnt >= 2)
              break;

          }

          else
          {
            a2_printc(sim->st, *sim->printing);
            sim->printing = sim->printing + 1l;
          }
      if(*sim->printing == 0)
        sim->printing = (char *)(void *)0;

      goto __CPROVER_DUMP_L24;
    }

    if(!(sim->curtime >= sim->next_actiontime))
      goto __CPROVER_DUMP_L24;

    if(!(sim->typing == ((const char *)NULL)))
    {
      signed int apple2_one_frame__1__4__1__c = (signed int)*sim->typing;
      if(apple2_one_frame__1__4__1__c == 0)
        sim->typing = (const char *)(void *)0;

      else
      {
        sim->typing = sim->typing + 1l;
        a2_printc(sim->st, (char)apple2_one_frame__1__4__1__c);
        if(apple2_one_frame__1__4__1__c == 10 || apple2_one_frame__1__4__1__c == 13)
          sim->next_actiontime = sim->curtime;

        else
          if(apple2_one_frame__1__4__1__c == 010)
            sim->next_actiontime = sim->curtime + 0.1;

          else
          {
            unsigned int return_value_ya_random_1;
            return_value_ya_random_1=ya_random();
            sim->next_actiontime = sim->curtime + ((double)(return_value_ya_random_1 % (unsigned int)1000) * 0.001 + 0.3) * sim->typing_rate;
          }
      }
      goto __CPROVER_DUMP_L24;
    }

    sim->next_actiontime = sim->curtime;
    sim->controller(sim, &sim->stepno, &sim->next_actiontime);
  }


DONE:
  ;
  sim->stepno = -2;
  sim->controller(sim, &sim->stepno, &sim->next_actiontime);
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_2;
  if(!(sim->stepno == -2))
    return 1;

  else
  {
    XClearWindow(sim->dpy, sim->window);
    free((void *)sim->text_im->data);
    sim->text_im->data = ((char *)NULL);
    sim->text_im->f.destroy_image(sim->text_im);
    analogtv_release(sim->dec);
    free((void *)sim->st);
    free((void *)sim->inp);
    free((void *)sim);
    return 0;

  __CPROVER_DUMP_L24:
    ;
    analogtv_setup_sync(sim->inp, sim->st->gr_mode != (enum anonymous_53)0 ? 1 : 0, 0);
    analogtv_setup_frame(sim->dec);
    textrow = 0;
    for( ; !(textrow >= 24); textrow = textrow + 1)
    {
      signed int row = textrow * 8;
      for( ; !(row >= 8 * textrow + 8); row = row + 1)
      {
        signed char *pp = &sim->inp->signal[(signed long int)(row + 30 + 4)][(signed long int)(135 + 100)];
        _Bool tmp_if_expr_7;
        if(!((A2_GR_HIRES & (signed int)sim->st->gr_mode) == 0))
        {
          if(!(row >= 160))
            tmp_if_expr_6 = (_Bool)1;

          else
            tmp_if_expr_6 = ((signed int)sim->st->gr_mode & A2_GR_FULL) != 0 ? (_Bool)1 : (_Bool)0;
          tmp_if_expr_7 = tmp_if_expr_6 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_7 = (_Bool)0;
        if(tmp_if_expr_7)
        {
          signed int apple2_one_frame__1__5__1__1__col;
          if(!((0x80 & (signed int)sim->st->hireslines[(signed long int)row][0l]) == 0))
          {
            if(!((0x40 & (signed int)sim->st->hireslines[(signed long int)row][39l]) == 0))
              pp[(signed long int)-1] = (signed char)100;

          }

          apple2_one_frame__1__5__1__1__col = 0;
          for( ; !(apple2_one_frame__1__5__1__1__col >= 40); apple2_one_frame__1__5__1__1__col = apple2_one_frame__1__5__1__1__col + 1)
          {
            unsigned char b = sim->st->hireslines[(signed long int)row][(signed long int)apple2_one_frame__1__5__1__1__col];
            signed int shift = ((signed int)b & 0x80) != 0 ? 0 : 1;
            i = 0;
            for( ; !(i >= 7); i = i + 1)
            {
              pp[(signed long int)shift] = (signed char)(((signed int)b >> i & 1) != 0 ? 100 : 10);
              pp[(signed long int)(shift + 1)] = pp[(signed long int)shift];
              pp = pp + (signed long int)2;
            }
          }
        }

        else
        {
          _Bool tmp_if_expr_5;
          if(!((A2_GR_LORES & (signed int)sim->st->gr_mode) == 0))
          {
            if(!(row >= 160))
              tmp_if_expr_4 = (_Bool)1;

            else
              tmp_if_expr_4 = ((signed int)sim->st->gr_mode & A2_GR_FULL) != 0 ? (_Bool)1 : (_Bool)0;
            tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_5 = (_Bool)0;
          if(tmp_if_expr_5)
          {
            signed int col = 0;
            for( ; !(col >= 40); col = col + 1)
            {
              unsigned char nib = (unsigned char)((signed int)sim->st->textlines[(signed long int)textrow][(signed long int)col] >> (row / 4 & 1) * 4 & 0xf);
              i = 0;
              for( ; !(i >= 14); i = i + 1)
              {
                *pp = (signed char)(((signed int)nib >> (col * 14 + i & 3) & 1) != 0 ? 100 : 10);
                pp = pp + 1l;
              }
            }
          }

          else
          {
            signed int apple2_one_frame__1__5__1__3__col = 0;
            for( ; !(apple2_one_frame__1__5__1__3__col >= 40); apple2_one_frame__1__5__1__3__col = apple2_one_frame__1__5__1__3__col + 1)
            {
              signed int rev;
              signed int apple2_one_frame__1__5__1__3__1__c = (signed int)sim->st->textlines[(signed long int)textrow][(signed long int)apple2_one_frame__1__5__1__3__col] & 0xff;
              _Bool tmp_if_expr_3;
              if((0x80 & apple2_one_frame__1__5__1__3__1__c) == 0)
              {
                if((0x40 & apple2_one_frame__1__5__1__3__1__c) == 0)
                  tmp_if_expr_2 = (_Bool)1;

                else
                  tmp_if_expr_2 = sim->st->blink != 0 ? (_Bool)1 : (_Bool)0;
                tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_3 = (_Bool)0;
              rev = (signed int)tmp_if_expr_3;
              i = 0;
              if(!(i >= 7))
              {
                unsigned long int pix;
                pix=sim->text_im->f.get_pixel(sim->text_im, (apple2_one_frame__1__5__1__3__1__c & 0x3f ^ 0x20) * 7 + i, row % 8);
                pp[(signed long int)2] = (signed char)((pix ^ (unsigned long int)rev) != 0ul ? 100 : 10);
                pp[(signed long int)1] = pp[(signed long int)2];
                pp = pp + (signed long int)2;
                i = i + 1;
              }

            }
          }
        }
      }
    }
    analogtv_reception_update(&sim->reception);
    const struct analogtv_reception_s *rec = &sim->reception;
    analogtv_draw(sim->dec, 0.02, &rec, (unsigned int)1);
    return 1;
  }
}

// apple2_reshape
// file apple2-main.c line 1879
static void apple2_reshape(struct _XDisplay *dpy, unsigned long int window, void *closure, unsigned int w, unsigned int h)
{
  struct state *st = (struct state *)closure;
  if(!(st->sim == ((struct apple2_sim_s *)NULL)))
    analogtv_reconfigure(st->sim->dec);

}

// apple2_start
// file apple2.c line 535
extern struct apple2_sim_s * apple2_start(struct _XDisplay *dpy, unsigned long int window, signed int delay, void (*controller)(struct apple2_sim_s *, signed int *, double *))
{
  struct apple2_sim_s *sim;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct apple2_sim_s) /*2448ul*/ );
  sim = (struct apple2_sim_s *)return_value_calloc_1;
  sim->dpy = dpy;
  sim->window = window;
  sim->delay = (double)delay;
  sim->controller = controller;
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)1, sizeof(struct apple2_state) /*8660ul*/ );
  sim->st = (struct apple2_state *)return_value_calloc_2;
  sim->dec=analogtv_allocate(dpy, window);
  sim->inp=analogtv_input_allocate();
  sim->reception.input = sim->inp;
  sim->reception.level = 1.0;
  sim->prompt = (char)93;
  unsigned int return_value_ya_random_4;
  return_value_ya_random_4=ya_random();
  _Bool tmp_if_expr_5;
  if(return_value_ya_random_4 % 4u == 0u)
    tmp_if_expr_5 = !(sim->dec->use_cmap != 0) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_5 = (_Bool)0;
  _Bool tmp_if_expr_6;
  if(tmp_if_expr_5)
    tmp_if_expr_6 = sim->dec->use_color != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_6 = (_Bool)0;
  _Bool tmp_if_expr_7;
  if(tmp_if_expr_6)
    tmp_if_expr_7 = sim->dec->visbits >= 8 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_7 = (_Bool)0;
  unsigned int return_value_ya_random_3;
  if(tmp_if_expr_7)
    sim->dec->flutter_tint = 1;

  else
  {
    return_value_ya_random_3=ya_random();
    if(return_value_ya_random_3 % 3u == 0u)
      sim->dec->flutter_horiz_desync = 1;

  }
  sim->typing_rate = 1.0;
  analogtv_set_defaults(sim->dec, "");
  sim->dec->squish_control = (float)0.05;
  analogtv_setup_sync(sim->inp, 1, 0);
  a2_make_font(sim);
  sim->stepno = 0;
  a2_goto(sim->st, 23, 0);
  unsigned int return_value_ya_random_8;
  return_value_ya_random_8=ya_random();
  if(return_value_ya_random_8 % 2u == 0u)
    sim->basetime_tv.tv_sec = sim->basetime_tv.tv_sec - (signed long int)1;

  sim->next_actiontime = 0.0;
  sim->curtime = 0.0;
  sim->next_actiontime = sim->curtime;
  sim->controller(sim, &sim->stepno, &sim->next_actiontime);
  gettimeofday(&sim->basetime_tv, (struct timezone *)(void *)0);
  return sim;
}

// basic_controller
// file apple2-main.c line 1608
static void basic_controller(struct apple2_sim_s *sim, signed int *stepno, double *next_actiontime)
{
  struct apple2_state *st = sim->st;
  signed int i;
  struct basic_controller_data *mine;
  if(sim->controller_data == NULL)
    sim->controller_data=calloc(sizeof(struct basic_controller_data) /*312ul*/ , (unsigned long int)1);

  mine = (struct basic_controller_data *)sim->controller_data;
  unsigned int return_value_ya_random_1;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  unsigned int return_value_ya_random_6;
  unsigned long int return_value_strlen_7;
  switch(*stepno)
  {
    case 0:
    {
      st->gr_mode = (enum anonymous_53)0;
      a2_cls(st);
      a2_goto(st, 0, 16);
      a2_prints(st, "APPLE ][");
      a2_goto(st, 23, 0);
      a2_printc(st, (char)93);
      sim->typing_rate = 0.2;
      return_value_ya_random_1=ya_random();
      i = (signed int)((unsigned long int)return_value_ya_random_1 % (sizeof(struct anonymous_56 [3l]) /*48ul*/  / sizeof(struct anonymous_56) /*16ul*/ ));
      mine->progtext = all_programs[(signed long int)i].progtext;
      mine->progstep = all_programs[(signed long int)i].progstep;
      mine->prog_line = 0;
      *next_actiontime = *next_actiontime + 1.0;
      *stepno = 10;
      break;
    }
    case 10:
    {
      if(st->cursx == 0)
        a2_printc(st, (char)93);

      if(!(mine->progtext[(signed long int)mine->prog_line] == ((const char *)NULL)))
      {
        unsigned int return_value_ya_random_3;
        return_value_ya_random_3=ya_random();
        if(return_value_ya_random_3 % 4u == 0u)
        {
          signed int err;
          err=make_typo(sim->typing_buf, mine->progtext[(signed long int)mine->prog_line], mine->error_buf);
          sim->typing = sim->typing_buf;
          if(!(err == 0))
            *stepno = 11;

          else
            mine->prog_line = mine->prog_line + 1;
        }

        else
        {
          signed int tmp_post_2 = mine->prog_line;
          mine->prog_line = mine->prog_line + 1;
          sim->typing = mine->progtext[(signed long int)tmp_post_2];
        }
      }

      else
        *stepno = 15;
      break;
    }
    case 11:
    {
      sim->printing = mine->error_buf;
      *stepno = 12;
      break;
    }
    case 12:
    {
      if(st->cursx == 0)
        a2_printc(st, (char)93);

      *next_actiontime = *next_actiontime + 1.0;
      *stepno = 10;
      break;
    }
    case 15:
    {
      sim->typing = "RUN\n";
      mine->y = 0;
      mine->x = 0;
      mine->k = 0;
      mine->prog_start_time = *next_actiontime;
      *stepno = mine->progstep;
      break;
    }
    case 100:
    {
      st->gr_mode = (enum anonymous_53)(A2_GR_HIRES | A2_GR_FULL);
      i = 0;
      do
      {
        if(!(i >= 24))
          tmp_if_expr_4 = mine->y < 192 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        if(!tmp_if_expr_4)
          break;

        a2_hline(st, 4, 0, 191 - mine->y, 279, mine->y);
        a2_hline(st, 7, 0, (191 - mine->y) - 1, 279, mine->y + 1);
        mine->y = mine->y + 2;
        i = i + 1;
      }
      while((_Bool)1);
      if(mine->y >= 192)
      {
        mine->x = 0;
        *stepno = 110;
      }

      break;
    }
    case 110:
    {
      i = 0;
      do
      {
        if(!(i >= 24))
          tmp_if_expr_5 = mine->x < 280 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_5 = (_Bool)0;
        if(!tmp_if_expr_5)
          break;

        a2_hline(st, 4, 279 - mine->x, 0, mine->x, 192);
        a2_hline(st, 7, (279 - mine->x) - 1, 0, mine->x + 1, 192);
        mine->x = mine->x + 3;
        i = i + 1;
      }
      while((_Bool)1);
      if(mine->x >= 280)
        *stepno = 120;

      break;
    }
    case 120:
    {
      if(*next_actiontime > mine->prog_start_time + sim->delay)
        *stepno = 999;

      break;
    }
    case 200:
    {
      mine->rep_str = "\nAPPLE ][ ROOLZ! TRS-80 DROOLZ!";
      i = 0;
      for( ; !(i >= 30); i = i + 1)
        a2_prints(st, mine->rep_str);
      *stepno = 210;
      break;
    }
    case 210:
    {
      return_value_ya_random_6=ya_random();
      return_value_strlen_7=strlen(mine->rep_str);
      i = (signed int)((unsigned long int)return_value_ya_random_6 % return_value_strlen_7);
      while(!(mine->rep_pos == i))
      {
        a2_printc(st, mine->rep_str[(signed long int)mine->rep_pos]);
        mine->rep_pos = mine->rep_pos + 1;
        if(mine->rep_str[(signed long int)mine->rep_pos] == 0)
          mine->rep_pos = 0;

      }
      if(*next_actiontime > mine->prog_start_time + sim->delay)
        *stepno = 999;

      break;
    }
    case 400:
    {
      st->gr_mode = (enum anonymous_53)A2_GR_HIRES;
      *stepno = 410;
      break;
    }
    case 410:
    {
      i = 0;
      for( ; !(i >= 48); i = i + 1)
      {
        signed int basic_controller__1__1__8__y;
        double return_value_sin_8;
        return_value_sin_8=sin((15.0 * (double)(mine->x - mine->k)) / 279.0);
        basic_controller__1__1__8__y = 80 + (signed int)(75.0 * return_value_sin_8);
        a2_hline(st, 0, mine->x, 0, mine->x, 159);
        a2_hplot(st, 3, mine->x, basic_controller__1__1__8__y);
        mine->x = mine->x + 1;
        if(mine->x >= 279)
        {
          mine->x = 0;
          mine->k = mine->k + 4;
        }

      }
      if(*next_actiontime > mine->prog_start_time + sim->delay)
        *stepno = 999;

      break;
    }
    case 420:
    {
      a2_prints(st, "]");
      *stepno = 999;
      break;
    }
    case 500:
    {
      st->gr_mode = (enum anonymous_53)(A2_GR_LORES | A2_GR_FULL);
      a2_clear_gr(st);
      *stepno = 510;
    }
    case 510:
    {
      i = 0;
      for( ; !(i >= 10); i = i + 1)
      {
        signed int color;
        signed int x;
        signed int y;
        signed int x1;
        signed int x2;
        signed int y1;
        signed int y2;
        unsigned int return_value_ya_random_9;
        return_value_ya_random_9=ya_random();
        color = (signed int)(return_value_ya_random_9 % (unsigned int)15);
        unsigned int return_value_ya_random_10;
        return_value_ya_random_10=ya_random();
        x = (signed int)(return_value_ya_random_10 % (unsigned int)40);
        unsigned int return_value_ya_random_11;
        return_value_ya_random_11=ya_random();
        y1 = (signed int)(return_value_ya_random_11 % (unsigned int)48);
        unsigned int return_value_ya_random_12;
        return_value_ya_random_12=ya_random();
        y2 = (signed int)(return_value_ya_random_12 % (unsigned int)48);
        y = y1;
        for( ; !(y >= y2); y = y + 1)
          a2_plot(st, color, x, y);
        unsigned int return_value_ya_random_13;
        return_value_ya_random_13=ya_random();
        x1 = (signed int)(return_value_ya_random_13 % (unsigned int)40);
        unsigned int return_value_ya_random_14;
        return_value_ya_random_14=ya_random();
        x2 = (signed int)(return_value_ya_random_14 % (unsigned int)40);
        unsigned int return_value_ya_random_15;
        return_value_ya_random_15=ya_random();
        y = (signed int)(return_value_ya_random_15 % (unsigned int)48);
        x = x1;
        for( ; !(x >= x2); x = x + 1)
          a2_plot(st, color, x, y);
      }
      if(*next_actiontime > mine->prog_start_time + sim->delay)
        *stepno = 999;

      break;
    }
    case 999:
    {
      *stepno = 0;
      break;
    }
    case -2:
    {
      free((void *)mine);
      mine = ((struct basic_controller_data *)NULL);
    }
  }
}

// checkerboard
// file grabclient.c line 123
static void checkerboard(struct anonymous_9 *screen, unsigned long int drawable)
{
  struct _XDisplay *dpy = screen->display;
  unsigned int x;
  unsigned int y;
  signed int size = 24;
  struct anonymous_57 fg;
  struct anonymous_57 bg;
  struct anonymous_58 gcv;
  struct _XGC *gc;
  gc=XCreateGC(dpy, drawable, (unsigned long int)0, &gcv);
  unsigned long int cmap;
  unsigned int win_width;
  unsigned int win_height;
  bg.flags = (char)(1 << 0 | 1 << 1 | 1 << 2);
  fg.flags = bg.flags;
  fg.blue = (unsigned short int)0x0000;
  fg.green = fg.blue;
  fg.red = fg.green;
  bg.blue = (unsigned short int)0x4444;
  bg.green = bg.blue;
  bg.red = bg.green;
  fg.pixel = (unsigned long int)0;
  bg.pixel = (unsigned long int)1;
  signed int return_value_drawable_window_p_2;
  return_value_drawable_window_p_2=drawable_window_p(dpy, drawable);
  if(!(return_value_drawable_window_p_2 == 0))
  {
    struct anonymous_16 xgwa;
    XGetWindowAttributes(dpy, drawable, &xgwa);
    win_width = (unsigned int)xgwa.width;
    win_height = (unsigned int)xgwa.height;
    cmap = xgwa.colormap;
    screen = xgwa.screen;
  }

  else
  {
    struct anonymous_16 checkerboard__1__2__xgwa;
    unsigned long int root;
    signed int checkerboard__1__2__x;
    signed int checkerboard__1__2__y;
    unsigned int bw;
    unsigned int d;
    unsigned long int return_value_VirtualRootWindowOfScreen_1;
    return_value_VirtualRootWindowOfScreen_1=VirtualRootWindowOfScreen_link1(screen);
    XGetWindowAttributes(dpy, return_value_VirtualRootWindowOfScreen_1, &checkerboard__1__2__xgwa);
    cmap = checkerboard__1__2__xgwa.colormap;
    XGetGeometry(dpy, drawable, &root, &checkerboard__1__2__x, &checkerboard__1__2__y, &win_width, &win_height, &bw, &d);
  }
  signed int return_value_XAllocColor_3;
  return_value_XAllocColor_3=XAllocColor(dpy, cmap, &fg);
  if(!(return_value_XAllocColor_3 == 0))
    XFreeColors(dpy, cmap, &fg.pixel, 1, (unsigned long int)0);

  signed int return_value_XAllocColor_4;
  return_value_XAllocColor_4=XAllocColor(dpy, cmap, &bg);
  if(!(return_value_XAllocColor_4 == 0))
    XFreeColors(dpy, cmap, &bg.pixel, 1, (unsigned long int)0);

  XSetForeground(dpy, gc, bg.pixel);
  XFillRectangle(dpy, drawable, gc, 0, 0, win_width, win_height);
  XSetForeground(dpy, gc, fg.pixel);
  y = (unsigned int)0;
  for( ; !(y >= win_height); y = y + (unsigned int)(size + size))
  {
    x = (unsigned int)0;
    for( ; !(x >= win_width); x = x + (unsigned int)(size + size))
    {
      XFillRectangle(dpy, drawable, gc, (signed int)x, (signed int)y, (unsigned int)size, (unsigned int)size);
      XFillRectangle(dpy, drawable, gc, (signed int)(x + (unsigned int)size), (signed int)(y + (unsigned int)size), (unsigned int)size, (unsigned int)size);
    }
  }
  XFreeGC(dpy, gc);
}

// close_pipe
// file textclient.c line 268
static void close_pipe(struct text_data *d)
{
  if(!(d->pid == 0))
    kill(d->pid, 15);

  d->pid = 0;
  if(!(d->pipe_id == 0ul))
    XtRemoveInput(d->pipe_id);

  d->pipe_id = (unsigned long int)0;
  if(!(d->pipe == ((struct _IO_FILE *)NULL)))
    pclose(d->pipe);

  d->pipe = ((struct _IO_FILE *)NULL);
}

// create_xshm_image
// file ./../utils/xshm.h line 27
extern struct _XImage * create_xshm_image(struct _XDisplay *dpy, struct anonymous_5 *visual, unsigned int depth, signed int format, char *data, struct anonymous_4 *shm_info, unsigned int width, unsigned int height)
{
  signed int status;
  struct _XImage *image = ((struct _XImage *)NULL);
  signed int return_value_get_boolean_resource_1;
  return_value_get_boolean_resource_1=get_boolean_resource(dpy, "useSHM", "Boolean");
  if(return_value_get_boolean_resource_1 == 0)
    return ((struct _XImage *)NULL);

  else
  {
    signed int return_value_XShmQueryExtension_2;
    return_value_XShmQueryExtension_2=XShmQueryExtension(dpy);
    if(return_value_XShmQueryExtension_2 == 0)
      return ((struct _XImage *)NULL);

    else
    {
      do
      {
        XSync(dpy, 0);
        shm_got_x_error = 0;
        if(!(old_handler == shm_ehandler))
          old_handler=XSetErrorHandler(shm_ehandler);

      }
      while((_Bool)0);
      image=XShmCreateImage(dpy, visual, depth, format, data, shm_info, width, height);
      do
      {
        XSync(dpy, 0);
        if(!(old_handler == ((signed int (*)(struct _XDisplay *, struct anonymous_7 *))NULL)))
          XSetErrorHandler(old_handler);

        old_handler = ((signed int (*)(struct _XDisplay *, struct anonymous_7 *))NULL);
      }
      while((_Bool)0);
      if(!(shm_got_x_error == 0))
        return ((struct _XImage *)NULL);

      else
      {
        shm_info->shmid=shmget((signed int)0, (unsigned long int)(image->bytes_per_line * image->height), 01000 | 0777);
        if(shm_info->shmid == -1)
        {
          char buf[1024l];
          sprintf(buf, "%s: shmget failed", progname);
          perror(buf);
          image->f.destroy_image(image);
          image = ((struct _XImage *)NULL);
          XSync(dpy, 0);
        }

        else
        {
          shm_info->readOnly = 0;
          void *return_value_shmat_3;
          return_value_shmat_3=shmat(shm_info->shmid, NULL, 0);
          shm_info->shmaddr = (char *)return_value_shmat_3;
          image->data = shm_info->shmaddr;
          do
          {
            XSync(dpy, 0);
            shm_got_x_error = 0;
            if(!(old_handler == shm_ehandler))
              old_handler=XSetErrorHandler(shm_ehandler);

          }
          while((_Bool)0);
          status=XShmAttach(dpy, shm_info);
          do
          {
            XSync(dpy, 0);
            if(!(old_handler == ((signed int (*)(struct _XDisplay *, struct anonymous_7 *))NULL)))
              XSetErrorHandler(old_handler);

            old_handler = ((signed int (*)(struct _XDisplay *, struct anonymous_7 *))NULL);
          }
          while((_Bool)0);
          if(!(shm_got_x_error == 0))
            status = 0;

          if(status == 0)
          {
            fprintf(stderr, "%s: XShmAttach failed!\n", progname);
            image->f.destroy_image(image);
            XSync(dpy, 0);
            shmdt((const void *)shm_info->shmaddr);
            image = ((struct _XImage *)NULL);
          }

          XSync(dpy, 0);
          shmctl(shm_info->shmid, 0, ((struct shmid_ds *)NULL));
        }
        return image;
      }
    }
  }
}

// decode_mask
// file apple2-main.c line 42
static void decode_mask(unsigned int mask, unsigned int *pos_ret, unsigned int *size_ret)
{
  signed int i = 0;
  for( ; !(i >= 32); i = i + 1)
    if(!((1L << i & (signed long int)mask) == 0l))
    {
      signed int j = 0;
      *pos_ret = (unsigned int)i;
      for( ; !(i >= 32); j = j + 1)
      {
        if((1L << i & (signed long int)mask) == 0l)
          break;

        i = i + 1;
      }
      *size_ret = (unsigned int)j;
      goto __CPROVER_DUMP_L6;
    }


__CPROVER_DUMP_L6:
  ;
}

// describe_visual
// file visual.c line 445
extern void describe_visual(struct _IO_FILE *f, struct anonymous_9 *screen, struct anonymous_5 *visual, signed int private_cmap_p)
{
  char n[10l];
  struct _XDisplay *dpy = screen->display;
  struct anonymous_3 vi_in;
  struct anonymous_3 *vi_out;
  signed int out_count;
  vi_in.screen=screen_number(screen);
  vi_in.visualid=XVisualIDFromVisual(visual);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x1), &vi_in, &out_count);
  if(vi_out == ((struct anonymous_3 *)NULL))
    abort();

  if(!(private_cmap_p == 0))
    sprintf(n, "%3d", vi_out->colormap_size);

  else
    strcpy(n, "default");
  char *tmp_if_expr_5;
  char *tmp_if_expr_4;
  char *tmp_if_expr_3;
  char *tmp_if_expr_2;
  char *tmp_if_expr_1;
  if(vi_out->class == 0)
    tmp_if_expr_5 = "StaticGray, ";

  else
  {
    if(vi_out->class == 2)
      tmp_if_expr_4 = "StaticColor,";

    else
    {
      if(vi_out->class == 4)
        tmp_if_expr_3 = "TrueColor,  ";

      else
      {
        if(vi_out->class == 1)
          tmp_if_expr_2 = "GrayScale,  ";

        else
        {
          if(vi_out->class == 3)
            tmp_if_expr_1 = "PseudoColor,";

          else
            tmp_if_expr_1 = vi_out->class == 5 ? "DirectColor," : "UNKNOWN:    ";
          tmp_if_expr_2 = tmp_if_expr_1;
        }
        tmp_if_expr_3 = tmp_if_expr_2;
      }
      tmp_if_expr_4 = tmp_if_expr_3;
    }
    tmp_if_expr_5 = tmp_if_expr_4;
  }
  fprintf(f, "0x%02x (%s depth: %2d, cmap: %s)\n", (unsigned int)vi_out->visualid, tmp_if_expr_5, vi_out->depth, (const void *)n);
  XFree((void *)(char *)vi_out);
}

// destroy_xshm_image
// file ./../utils/xshm.h line 32
extern void destroy_xshm_image(struct _XDisplay *dpy, struct _XImage *image, struct anonymous_4 *shm_info)
{
  signed int status;
  do
  {
    XSync(dpy, 0);
    shm_got_x_error = 0;
    if(!(old_handler == shm_ehandler))
      old_handler=XSetErrorHandler(shm_ehandler);

  }
  while((_Bool)0);
  status=XShmDetach(dpy, shm_info);
  do
  {
    XSync(dpy, 0);
    if(!(old_handler == ((signed int (*)(struct _XDisplay *, struct anonymous_7 *))NULL)))
      XSetErrorHandler(old_handler);

    old_handler = ((signed int (*)(struct _XDisplay *, struct anonymous_7 *))NULL);
  }
  while((_Bool)0);
  if(!(shm_got_x_error == 0))
    status = 0;

  if(status == 0)
    fprintf(stderr, "%s: XShmDetach failed!\n", progname);

  image->f.destroy_image(image);
  XSync(dpy, 0);
  status=shmdt((const void *)shm_info->shmaddr);
  if(!(status == 0))
  {
    char buf[1024l];
    sprintf(buf, "%s: shmdt(0x%lx) failed", progname, (unsigned long int)shm_info->shmaddr);
    perror(buf);
  }

  XSync(dpy, 0);
}

// do_icccm_meta_key_stupidity
// file textclient.c line 485
static unsigned int do_icccm_meta_key_stupidity(struct _XDisplay *dpy)
{
  unsigned int modbits = (unsigned int)0;
  signed int i;
  signed int j;
  signed int k;
  struct anonymous_68 *modmap;
  modmap=XGetModifierMapping(dpy);
  i = 3;
  for( ; !(i >= 8); i = i + 1)
  {
    j = 0;
    for( ; !(j >= modmap->max_keypermod); j = j + 1)
    {
      signed int code = (signed int)modmap->modifiermap[(signed long int)(i * modmap->max_keypermod + j)];
      unsigned long int *syms;
      signed int nsyms = 0;
      if(!(code == 0))
      {
        syms=XGetKeyboardMapping(dpy, (unsigned char)code, 1, &nsyms);
        k = 0;
        for( ; !(k >= nsyms); k = k + 1)
        {
          _Bool tmp_if_expr_1;
          if(syms[(signed long int)k] == 65511ul)
            tmp_if_expr_1 = (_Bool)1;

          else
            tmp_if_expr_1 = syms[(signed long int)k] == (unsigned long int)0xffe8 ? (_Bool)1 : (_Bool)0;
          _Bool tmp_if_expr_2;
          if(tmp_if_expr_1)
            tmp_if_expr_2 = (_Bool)1;

          else
            tmp_if_expr_2 = syms[(signed long int)k] == (unsigned long int)0xffe9 ? (_Bool)1 : (_Bool)0;
          _Bool tmp_if_expr_3;
          if(tmp_if_expr_2)
            tmp_if_expr_3 = (_Bool)1;

          else
            tmp_if_expr_3 = syms[(signed long int)k] == (unsigned long int)0xffea ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_3)
            modbits = modbits | (unsigned int)(1 << i);

        }
        XFree((void *)syms);
      }

    }
  }
  XFreeModifiermap(modmap);
  return modbits;
}

// drawable_window_p
// file grabclient.c line 64
static signed int drawable_window_p(struct _XDisplay *dpy, unsigned long int d)
{
  signed int (*drawable_window_p__1__old_handler)(struct _XDisplay *, struct anonymous_7 *);
  struct anonymous_16 xgwa;
  XSync(dpy, 0);
  drawable_window_p__1__old_handler=XSetErrorHandler(ignore_all_errors_ehandler);
  error_handler_hit_p = 0;
  XGetWindowAttributes(dpy, d, &xgwa);
  XSync(dpy, 0);
  XSetErrorHandler(drawable_window_p__1__old_handler);
  XSync(dpy, 0);
  if(error_handler_hit_p == 0)
    return 1;

  else
    return 0;
}

// exec_simple_command
// file grabclient.c line 269
static void exec_simple_command(const char *command)
{
  char *av[1024l];
  signed int ac = 0;
  char *token;
  char *return_value_strdup_1;
  return_value_strdup_1=strdup(command);
  token=strtok(return_value_strdup_1, " \t");
  while(!(token == ((char *)NULL)))
  {
    signed int tmp_post_2 = ac;
    ac = ac + 1;
    av[(signed long int)tmp_post_2] = token;
    token=strtok(((char *)NULL), " \t");
  }
  av[(signed long int)ac] = ((char *)NULL);
  execvp(av[(signed long int)0], av);
}

// finalize_cb
// file grabclient.c line 410
static void finalize_cb(void *closure, signed int *fd, unsigned long int *id)
{
  struct anonymous_64 *data = (struct anonymous_64 *)closure;
  struct _XDisplay *dpy = data->screen->display;
  char *name;
  struct anonymous_54 geom = { .x=(signed short int)0, .y=(signed short int)0, .width=(unsigned short int)0,
    .height=(unsigned short int)0 };
  XtRemoveInput(*id);
  name=get_name(dpy, data->window);
  get_geometry(dpy, data->window, &geom);
  data->callback(data->screen, data->window, data->drawable, name, &geom, data->closure);
  if(!(name == ((char *)NULL)))
    free((void *)name);

  fclose(data->read_pipe);
  if(!(data->pid == 0))
  {
    signed int status;
    waitpid(data->pid, &status, 0);
    data->pid = 0;
  }

  memset((void *)data, 0, sizeof(struct anonymous_64) /*72ul*/ );
  free((void *)data);
}

// find_similar_visual
// file visual.c line 503
extern struct anonymous_5 * find_similar_visual(struct anonymous_9 *screen, struct anonymous_5 *old_visual)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_3 vi_in;
  struct anonymous_3 *vi_out;
  struct anonymous_5 *result = ((struct anonymous_5 *)NULL);
  signed int out_count;
  vi_in.screen=screen_number(screen);
  vi_in.class=visual_class(screen, old_visual);
  vi_in.depth=visual_depth(screen, old_visual);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x8 | 0x4), &vi_in, &out_count);
  if(out_count >= 1 && !(vi_out == ((struct anonymous_3 *)NULL)))
    result = (vi_out + (signed long int)0)->visual;

  if(!(vi_out == ((struct anonymous_3 *)NULL)))
    XFree((void *)vi_out);

  vi_out = ((struct anonymous_3 *)NULL);
  if(result == ((struct anonymous_5 *)NULL))
  {
    vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x8), &vi_in, &out_count);
    if(out_count >= 1 && !(vi_out == ((struct anonymous_3 *)NULL)))
      result = (vi_out + (signed long int)0)->visual;

    if(!(vi_out == ((struct anonymous_3 *)NULL)))
      XFree((void *)vi_out);

    vi_out = ((struct anonymous_3 *)NULL);
  }

  if(result == ((struct anonymous_5 *)NULL))
    result = screen->root_visual;

  return result;
}

// fix_fds
// file screenhack.c line 403
static void fix_fds(void)
{
  signed int fd0;
  fd0=open("/dev/null", 02);
  signed int fd1;
  fd1=open("/dev/null", 02);
  signed int fd2;
  fd2=open("/dev/null", 02);
  if(fd0 >= 3)
    close(fd0);

  if(fd1 >= 3)
    close(fd1);

  if(fd2 >= 3)
    close(fd2);

}

// fork_exec_cb
// file grabclient.c line 328
static void fork_exec_cb(const char *command, struct anonymous_9 *screen, unsigned long int window, unsigned long int drawable, void (*callback)(struct anonymous_9 *, unsigned long int, unsigned long int, const char *, struct anonymous_54 *, void *), void *closure)
{
  struct _XtAppStruct *app;
  app=XtDisplayToApplicationContext(screen->display);
  struct anonymous_64 *data;
  char buf[255l];
  signed int forked;
  signed int fds[2l];
  signed int return_value_pipe_1;
  return_value_pipe_1=pipe(fds);
  if(!(return_value_pipe_1 == 0))
  {
    sprintf(buf, "%s: creating pipe", progname);
    perror(buf);
    exit(1);
  }

  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)1, sizeof(struct anonymous_64) /*72ul*/ );
  data = (struct anonymous_64 *)return_value_calloc_2;
  data->callback = callback;
  data->closure = closure;
  data->screen = screen;
  data->window = window;
  data->drawable = drawable;
  data->read_pipe=fdopen(fds[(signed long int)0], "r");
  data->write_pipe=fdopen(fds[(signed long int)1], "w");
  _Bool tmp_if_expr_3;
  if(data->read_pipe == ((struct _IO_FILE *)NULL))
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = !(data->write_pipe != ((struct _IO_FILE *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_3)
  {
    sprintf(buf, "%s: fdopen", progname);
    perror(buf);
    exit(1);
  }

  signed int return_value_fileno_4;
  return_value_fileno_4=fileno(data->read_pipe);
  data->pipe_id=XtAppAddInput(app, return_value_fileno_4, (void *)(1L << 0 | 1L << 2), finalize_cb, (void *)data);
  forked=fork();
  signed int return_value_fileno_5;
  signed int return_value_fileno_6;
  signed int return_value_fileno_7;
  if(!(forked == -1))
  {
    if(forked == 0)
      goto __CPROVER_DUMP_L6;

  }

  else
  {
    sprintf(buf, "%s: couldn't fork", progname);
    perror(buf);
    goto __CPROVER_DUMP_L9;

  __CPROVER_DUMP_L6:
    ;
    fclose(data->read_pipe);
    data->read_pipe = ((struct _IO_FILE *)NULL);
    return_value_fileno_5=fileno(stdout);
    close(return_value_fileno_5);
    return_value_fileno_6=fileno(stdout);
    dup2(fds[(signed long int)1], return_value_fileno_6);
    close(fds[(signed long int)1]);
    return_value_fileno_7=fileno(stdin);
    close(return_value_fileno_7);
    exec_simple_command(command);
    exit(1);
    goto __CPROVER_DUMP_L8;
  }
  fclose(data->write_pipe);
  data->write_pipe = ((struct _IO_FILE *)NULL);
  data->pid = forked;
  goto __CPROVER_DUMP_L8;

__CPROVER_DUMP_L8:
  ;

__CPROVER_DUMP_L9:
  ;
}

// fork_exec_wait
// file grabclient.c line 286
static void fork_exec_wait(const char *command)
{
  char buf[255l];
  signed int forked;
  signed int status;
  forked=fork();
  if(!(forked == -1))
  {
    if(forked == 0)
      goto __CPROVER_DUMP_L2;

  }

  else
  {
    sprintf(buf, "%s: couldn't fork", progname);
    perror(buf);
    goto __CPROVER_DUMP_L5;

  __CPROVER_DUMP_L2:
    ;
    exec_simple_command(command);
    exit(1);
    goto __CPROVER_DUMP_L4;
  }
  waitpid(forked, &status, 0);

__CPROVER_DUMP_L4:
  ;

__CPROVER_DUMP_L5:
  ;
}

// fps_compute
// file fps.h line 25
extern double fps_compute(struct fps_state *st, unsigned long int polys, double depth)
{
  unsigned long int return_value_strlen_2;
  unsigned long int return_value_strlen_3;
  unsigned long int return_value_strlen_4;
  if(st == ((struct fps_state *)NULL))
    return (double)0;

  else
  {
    signed int tmp_post_1 = st->frame_count;
    st->frame_count = st->frame_count + 1;
    if(tmp_post_1 >= st->last_ifps)
    {
      struct timezone tzp;
      gettimeofday(&st->this_frame_end, &tzp);
      if(st->prev_frame_end.tv_sec == 0l)
        st->prev_frame_end = st->this_frame_end;

    }

    if(!(st->this_frame_end.tv_sec == st->prev_frame_end.tv_sec))
    {
      double uprev_frame_end = (double)st->prev_frame_end.tv_sec + (double)st->prev_frame_end.tv_usec * 0.000001;
      double uthis_frame_end = (double)st->this_frame_end.tv_sec + (double)st->this_frame_end.tv_usec * 0.000001;
      double fps = (double)st->frame_count / (uthis_frame_end - uprev_frame_end);
      double idle = ((double)st->slept * 0.000001) / (uthis_frame_end - uprev_frame_end);
      double load = (double)100 * ((double)1 - idle);
      if(load < 0.000000)
        load = (double)0;

      st->prev_frame_end = st->this_frame_end;
      st->frame_count = 0;
      st->slept = (unsigned long int)0;
      st->last_ifps = (signed int)fps;
      st->last_fps = fps;
      sprintf(st->string, polys != 0ul ? "FPS:   %.1f \nLoad:  %.1f%% " : "FPS:  %.1f \nLoad: %.1f%% ", fps, load);
      if(polys >= 1ul)
      {
        const char *fps_compute__1__2__1__s = "";
        strcat(st->string, "\nPolys: ");
        if(polys >= 1000000ul)
        {
          return_value_strlen_2=strlen(st->string);
          sprintf(st->string + (signed long int)return_value_strlen_2, "%lu,%03lu,%03lu%s ", polys / (unsigned long int)1000000, (polys / (unsigned long int)1000) % (unsigned long int)1000, polys % (unsigned long int)1000, fps_compute__1__2__1__s);
        }

        else
          if(polys >= 1000ul)
          {
            return_value_strlen_3=strlen(st->string);
            sprintf(st->string + (signed long int)return_value_strlen_3, "%lu,%03lu%s ", polys / (unsigned long int)1000, polys % (unsigned long int)1000, fps_compute__1__2__1__s);
          }

          else
          {
            return_value_strlen_4=strlen(st->string);
            sprintf(st->string + (signed long int)return_value_strlen_4, "%lu%s ", polys, fps_compute__1__2__1__s);
          }
      }

      if(depth >= 0.0)
      {
        unsigned long int L;
        L=strlen(st->string);
        char *s = st->string + (signed long int)L;
        strcat(s, "\nDepth: ");
        unsigned long int return_value_strlen_5;
        return_value_strlen_5=strlen(s);
        sprintf(s + (signed long int)return_value_strlen_5, "%.1f", depth);
        L=strlen(s);
        if((signed int)s[-2l + (signed long int)L] == 46)
        {
          if((signed int)s[-1l + (signed long int)L] == 48)
            s[(signed long int)(L - (unsigned long int)2)] = (char)0;

        }

      }

    }

    return st->last_fps;
  }
}

// fps_draw
// file fps.h line 26
extern void fps_draw(struct fps_state *st)
{
  struct anonymous_16 xgwa;
  const char *string = st->string;
  const char *s;
  signed int x = st->x;
  signed int y = st->y;
  signed int lines = 1;
  signed int lh = st->font->ascent + st->font->descent;
  XGetWindowAttributes(st->dpy, st->window, &xgwa);
  s = string;
  for( ; !(*s == 0); s = s + 1l)
    if((signed int)*s == 10)
      lines = lines + 1;

  if(!(y >= 0))
    y = -y + (lines - 1) * lh;

  else
    y = xgwa.height - y;
  y = y - (lh * (lines - 1) + st->font->descent);
  if(!(st->clear_p == 0))
  {
    signed int w;
    signed int h;
    w=string_width(st->font, string, &h);
    XFillRectangle(st->dpy, st->window, st->erase_gc, x - st->font->descent, y - lh, (unsigned int)(w + 2 * st->font->descent), (unsigned int)(h + 2 * st->font->descent));
  }

  unsigned long int return_value_strlen_1;
  while(!(lines == 0))
  {
    s=strchr(string, 10);
    if(s == ((const char *)NULL))
    {
      return_value_strlen_1=strlen(string);
      s = string + (signed long int)return_value_strlen_1;
    }

    XDrawString(st->dpy, st->window, st->draw_gc, x, y, string, (signed int)(s - string));
    string = s;
    string = string + 1l;
    lines = lines - 1;
    y = y + lh;
  }
}

// fps_free
// file fps.h line 23
extern void fps_free(struct fps_state *st)
{
  if(!(st->draw_gc == ((struct _XGC *)NULL)))
    XFreeGC(st->dpy, st->draw_gc);

  if(!(st->erase_gc == ((struct _XGC *)NULL)))
    XFreeGC(st->dpy, st->erase_gc);

  if(!(st->font == ((struct anonymous_59 *)NULL)))
    XFreeFont(st->dpy, st->font);

  free((void *)st);
}

// fps_init
// file fps.h line 22
extern struct fps_state * fps_init(struct _XDisplay *dpy, unsigned long int window)
{
  struct fps_state *st;
  const char *font;
  struct anonymous_59 *f;
  signed int return_value_get_boolean_resource_1;
  return_value_get_boolean_resource_1=get_boolean_resource(dpy, "doFPS", "DoFPS");
  if(return_value_get_boolean_resource_1 == 0)
    return ((struct fps_state *)NULL);

  else
  {
    void *return_value_calloc_2;
    return_value_calloc_2=calloc((unsigned long int)1, sizeof(struct fps_state) /*1152ul*/ );
    st = (struct fps_state *)return_value_calloc_2;
    st->dpy = dpy;
    st->window = window;
    st->clear_p=get_boolean_resource(dpy, "fpsSolid", "FPSSolid");
    font=get_string_resource(dpy, "fpsFont", "Font");
    if(font == ((const char *)NULL))
      font = "-*-courier-bold-r-normal-*-180-*";

    f=XLoadQueryFont(dpy, font);
    if(f == ((struct anonymous_59 *)NULL))
      f=XLoadQueryFont(dpy, "fixed");

    struct anonymous_16 xgwa;
    struct anonymous_58 gcv;
    XGetWindowAttributes(dpy, window, &xgwa);
    gcv.font = f->fid;
    unsigned int return_value_get_pixel_resource_3;
    return_value_get_pixel_resource_3=get_pixel_resource(st->dpy, xgwa.colormap, "foreground", "Foreground");
    gcv.foreground = (unsigned long int)return_value_get_pixel_resource_3;
    st->draw_gc=XCreateGC(dpy, window, (unsigned long int)(1L << 14 | 1L << 2), &gcv);
    unsigned int return_value_get_pixel_resource_4;
    return_value_get_pixel_resource_4=get_pixel_resource(st->dpy, xgwa.colormap, "background", "Background");
    gcv.foreground = (unsigned long int)return_value_get_pixel_resource_4;
    st->erase_gc=XCreateGC(dpy, window, (unsigned long int)(1L << 14 | 1L << 2), &gcv);
    st->font = f;
    st->x = 10;
    st->y = 10;
    signed int return_value_get_boolean_resource_5;
    return_value_get_boolean_resource_5=get_boolean_resource(dpy, "fpsTop", "FPSTop");
    if(!(return_value_get_boolean_resource_5 == 0))
      st->y = -(st->font->ascent + st->font->descent + 10);

    strcpy(st->string, "FPS: ... ");
    return st;
  }
}

// fps_slept
// file fps.h line 24
extern void fps_slept(struct fps_state *st, unsigned long int usecs)
{
  st->slept = st->slept + usecs;
}

// get_bits_per_pixel
// file visual.c line 545
extern signed int get_bits_per_pixel(struct _XDisplay *dpy, signed int depth)
{
  unsigned int i = (unsigned int)0;
  signed int count;
  signed int result;
  struct anonymous_2 *formats;
  formats=XListPixmapFormats(dpy, &count);
  if(formats == ((struct anonymous_2 *)NULL))
    return 0;

  else
  {
    for( ; (_Bool)1; i = i + 1u)
    {
      if(i == (unsigned int)count)
      {
        result = 0;
        goto __CPROVER_DUMP_L4;
      }

      if((formats + (signed long int)i)->depth == depth)
      {
        result = (formats + (signed long int)i)->bits_per_pixel;
        break;
      }

    }

  __CPROVER_DUMP_L4:
    ;
    XFree((void *)formats);
    return result;
  }
}

// get_boolean_resource
// file ./../utils/resources.h line 16
extern signed int get_boolean_resource(struct _XDisplay *dpy, char *res_name, char *res_class)
{
  char *tmp;
  char buf[100l];
  char *s;
  s=get_string_resource(dpy, res_name, res_class);
  char *os = s;
  unsigned long int return_value_strlen_4;
  unsigned long int return_value_strlen_5;
  unsigned long int return_value_strlen_6;
  signed int return_value_strcmp_8;
  signed int return_value_strcmp_10;
  signed int return_value_strcmp_13;
  signed int return_value_strcmp_15;
  if(s == ((char *)NULL))
    return 0;

  else
  {
    tmp = buf;
    for( ; !(*s == 0); s = s + 1l)
    {
      char *tmp_post_1 = tmp;
      tmp = tmp + 1l;
      _Bool tmp_if_expr_2;
      if((signed int)*s >= 65)
        tmp_if_expr_2 = (signed int)*s <= 90 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      signed int tmp_if_expr_3;
      if(tmp_if_expr_2)
        tmp_if_expr_3 = ((signed int)*s - 65) + 97;

      else
        tmp_if_expr_3 = (signed int)*s;
      *tmp_post_1 = (char)tmp_if_expr_3;
    }
    *tmp = (char)0;
    free((void *)os);
    while(!(buf[0l] == 0))
    {
      return_value_strlen_4=strlen(buf);
      if(!((signed int)buf[-1l + (signed long int)return_value_strlen_4] == 32))
      {
        return_value_strlen_5=strlen(buf);
        if(!((signed int)buf[-1l + (signed long int)return_value_strlen_5] == 9))
          break;

      }

      return_value_strlen_6=strlen(buf);
      buf[(signed long int)(return_value_strlen_6 - (unsigned long int)1)] = (char)0;
    }
    signed int return_value_strcmp_7;
    return_value_strcmp_7=strcmp(buf, "on");
    _Bool tmp_if_expr_9;
    if(return_value_strcmp_7 == 0)
      tmp_if_expr_9 = (_Bool)1;

    else
    {
      return_value_strcmp_8=strcmp(buf, "true");
      tmp_if_expr_9 = !(return_value_strcmp_8 != 0) ? (_Bool)1 : (_Bool)0;
    }
    _Bool tmp_if_expr_11;
    if(tmp_if_expr_9)
      tmp_if_expr_11 = (_Bool)1;

    else
    {
      return_value_strcmp_10=strcmp(buf, "yes");
      tmp_if_expr_11 = !(return_value_strcmp_10 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_11)
      return 1;

    else
    {
      signed int return_value_strcmp_12;
      return_value_strcmp_12=strcmp(buf, "off");
      _Bool tmp_if_expr_14;
      if(return_value_strcmp_12 == 0)
        tmp_if_expr_14 = (_Bool)1;

      else
      {
        return_value_strcmp_13=strcmp(buf, "false");
        tmp_if_expr_14 = !(return_value_strcmp_13 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_16;
      if(tmp_if_expr_14)
        tmp_if_expr_16 = (_Bool)1;

      else
      {
        return_value_strcmp_15=strcmp(buf, "no");
        tmp_if_expr_16 = !(return_value_strcmp_15 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_16)
        return 0;

      else
      {
        fprintf(stderr, "%s: %s must be boolean, not %s.\n", progname, res_name, (const void *)buf);
        return 0;
      }
    }
  }
}

// get_float_resource
// file resources.c line 122
extern double get_float_resource(struct _XDisplay *dpy, char *res_name, char *res_class)
{
  double val;
  char c;
  char *s;
  s=get_string_resource(dpy, res_name, res_class);
  if(s == ((char *)NULL))
    return 0.0;

  else
  {
    signed int return_value___isoc99_sscanf_1;
    return_value___isoc99_sscanf_1=__isoc99_sscanf(s, " %lf %c", &val, &c);
    if(return_value___isoc99_sscanf_1 == 1)
    {
      free((void *)s);
      return val;
    }

    else
    {
      fprintf(stderr, "%s: %s must be a float, not %s.\n", progname, res_name, s);
      free((void *)s);
      return 0.0;
    }
  }
}

// get_geometry
// file grabclient.c line 201
static signed int get_geometry(struct _XDisplay *dpy, unsigned long int window, struct anonymous_54 *ret)
{
  unsigned long int type;
  signed int format;
  unsigned long int nitems;
  unsigned long int bytesafter;
  unsigned char *name = ((unsigned char *)NULL);
  unsigned long int atom;
  atom=XInternAtom(dpy, "_SCREENSAVER_IMAGE_GEOMETRY", 0);
  signed int x;
  signed int y;
  unsigned int w;
  unsigned int h;
  signed int return_value_XGetWindowProperty_1;
  return_value_XGetWindowProperty_1=XGetWindowProperty(dpy, window, atom, (signed long int)0, (signed long int)1024, 0, (unsigned long int)31, &type, &format, &nitems, &bytesafter, &name);
  if(return_value_XGetWindowProperty_1 == 0 && !(type == 0ul))
  {
    signed int flags;
    flags=XParseGeometry((char *)name, &x, &y, &w, &h);
    free((void *)name);
    if(flags == 15)
    {
      ret->x = (signed short int)x;
      ret->y = (signed short int)y;
      ret->width = (unsigned short int)w;
      ret->height = (unsigned short int)h;
      return 1;
    }

    else
      return 0;
  }

  else
    return 0;
}

// get_integer_resource
// file ./../utils/resources.h line 17
extern signed int get_integer_resource(struct _XDisplay *dpy, char *res_name, char *res_class)
{
  signed int val;
  char c;
  char *s;
  s=get_string_resource(dpy, res_name, res_class);
  char *ss = s;
  _Bool tmp_if_expr_3;
  if(s == ((char *)NULL))
    return 0;

  else
  {
    for( ; !(*ss == 0); ss = ss + 1l)
      if((signed int)*ss >= 33)
        break;

    _Bool tmp_if_expr_4;
    if((signed int)*ss == 48)
    {
      if((signed int)ss[1l] == 120)
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = (signed int)ss[(signed long int)1] == 88 ? (_Bool)1 : (_Bool)0;
      tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
    {
      signed int return_value___isoc99_sscanf_1;
      return_value___isoc99_sscanf_1=__isoc99_sscanf(ss + (signed long int)2, "%x %c", (unsigned int *)&val, &c);
      if(return_value___isoc99_sscanf_1 == 1)
      {
        free((void *)s);
        return val;
      }

    }

    else
    {
      signed int return_value___isoc99_sscanf_2;
      return_value___isoc99_sscanf_2=__isoc99_sscanf(ss, "%d %c", &val, &c);
      if(return_value___isoc99_sscanf_2 == 1)
      {
        free((void *)s);
        return val;
      }

    }
    fprintf(stderr, "%s: %s must be an integer, not %s.\n", progname, res_name, s);
    free((void *)s);
    return 0;
  }
}

// get_minutes_resource
// file resources.c line 261
extern unsigned int get_minutes_resource(struct _XDisplay *dpy, char *res_name, char *res_class)
{
  unsigned int return_value_get_time_resource_1;
  return_value_get_time_resource_1=get_time_resource(dpy, res_name, res_class, 0);
  return return_value_get_time_resource_1;
}

// get_name
// file grabclient.c line 181
static char * get_name(struct _XDisplay *dpy, unsigned long int window)
{
  unsigned long int type;
  signed int format;
  unsigned long int nitems;
  unsigned long int bytesafter;
  unsigned char *name = ((unsigned char *)NULL);
  unsigned long int atom;
  atom=XInternAtom(dpy, "_SCREENSAVER_IMAGE_FILENAME", 0);
  signed int return_value_XGetWindowProperty_1;
  return_value_XGetWindowProperty_1=XGetWindowProperty(dpy, window, atom, (signed long int)0, (signed long int)1024, 0, (unsigned long int)31, &type, &format, &nitems, &bytesafter, &name);
  if(return_value_XGetWindowProperty_1 == 0 && !(type == 0ul))
    return (char *)name;

  else
    return ((char *)NULL);
}

// get_pixel_resource
// file ./../utils/resources.h line 19
extern unsigned int get_pixel_resource(struct _XDisplay *dpy, unsigned long int cmap, char *res_name, char *res_class)
{
  struct anonymous_57 color;
  char *s;
  s=get_string_resource(dpy, res_name, res_class);
  char *s2;
  signed int ok = 1;
  unsigned long int return_value_strlen_1;
  signed int return_value_XParseColor_3;
  signed int return_value_XAllocColor_4;
  unsigned long int return_value_strlen_6;
  signed int return_value_strcasecmp_7;
  if(!(s == ((char *)NULL)))
  {
    return_value_strlen_1=strlen(s);
    s2 = (s + (signed long int)return_value_strlen_1) - (signed long int)1;
    for( ; !(s >= s2); s2 = s2 - 1l)
    {
      _Bool tmp_if_expr_2;
      if((signed int)*s2 == 32)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (signed int)*s2 == 9 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        *s2 = (char)0;

      else
        break;
    }
    return_value_XParseColor_3=XParseColor(dpy, cmap, s, &color);
    if(return_value_XParseColor_3 == 0)
    {
      fprintf(stderr, "%s: can't parse color %s", progname, s);
      ok = 0;
      goto DEFAULT;
    }

    return_value_XAllocColor_4=XAllocColor(dpy, cmap, &color);
    if(return_value_XAllocColor_4 == 0)
    {
      fprintf(stderr, "%s: couldn't allocate color %s", progname, s);
      ok = 0;
      goto DEFAULT;
    }

    free((void *)s);
    return (unsigned int)color.pixel;
  }

  else
  {

  DEFAULT:
    ;
    if(!(s == ((char *)NULL)))
      free((void *)s);

    signed int black_p;
    unsigned long int return_value_strlen_5;
    return_value_strlen_5=strlen(res_class);
    _Bool tmp_if_expr_8;
    if(return_value_strlen_5 >= 10ul)
    {
      return_value_strlen_6=strlen(res_class);
      return_value_strcasecmp_7=strcasecmp("Background", (res_class + (signed long int)return_value_strlen_6) - (signed long int)10);
      tmp_if_expr_8 = !(return_value_strcasecmp_7 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_8 = (_Bool)0;
    black_p = (signed int)tmp_if_expr_8;
    if(ok == 0)
      fprintf(stderr, ": using %s.\n", black_p != 0 ? "black" : "white");

    color.flags = (char)(1 << 0 | 1 << 1 | 1 << 2);
    color.blue = (unsigned short int)(black_p != 0 ? 0 : 0xFFFF);
    color.green = color.blue;
    color.red = color.green;
    signed int return_value_XAllocColor_9;
    return_value_XAllocColor_9=XAllocColor(dpy, cmap, &color);
    if(!(return_value_XAllocColor_9 == 0))
      return (unsigned int)color.pixel;

    else
    {
      fprintf(stderr, "%s: couldn't allocate %s either!\n", progname, black_p != 0 ? "black" : "white");
      return (unsigned int)0;
    }
  }
}

// get_seconds_resource
// file resources.c line 255
extern unsigned int get_seconds_resource(struct _XDisplay *dpy, char *res_name, char *res_class)
{
  unsigned int return_value_get_time_resource_1;
  return_value_get_time_resource_1=get_time_resource(dpy, res_name, res_class, 1);
  return return_value_get_time_resource_1;
}

// get_string_resource
// file ./../utils/resources.h line 15
extern char * get_string_resource(struct _XDisplay *dpy, char *res_name, char *res_class)
{
  struct anonymous_1 value;
  char *type;
  char full_name[1024l];
  char full_class[1024l];
  strcpy(full_name, progname);
  strcat(full_name, ".");
  strcat(full_name, res_name);
  strcpy(full_class, progclass);
  strcat(full_class, ".");
  strcat(full_class, res_class);
  struct _XrmHashBucketRec *return_value_XtDatabase_2;
  return_value_XtDatabase_2=XtDatabase(dpy);
  signed int return_value_XrmGetResource_3;
  return_value_XrmGetResource_3=XrmGetResource(return_value_XtDatabase_2, full_name, full_class, &type, &value);
  if(!(return_value_XrmGetResource_3 == 0))
  {
    char *str;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)(value.size + (unsigned int)1));
    str = (char *)return_value_malloc_1;
    strncpy(str, (char *)value.addr, (unsigned long int)value.size);
    str[(signed long int)value.size] = (char)0;
    return str;
  }

  return ((char *)NULL);
}

// get_time_resource
// file resources.c line 244
static unsigned int get_time_resource(struct _XDisplay *dpy, char *res_name, char *res_class, signed int sec_p)
{
  signed int val;
  char *s;
  s=get_string_resource(dpy, res_name, res_class);
  if(s == ((char *)NULL))
    return (unsigned int)0;

  else
  {
    val=parse_time(s, sec_p, 0);
    free((void *)s);
    return (unsigned int)(val < 0 ? 0 : val);
  }
}

// get_visual
// file visual.c line 50
extern struct anonymous_5 * get_visual(struct anonymous_9 *screen, const char *string, signed int prefer_writable_cells, signed int verbose_p)
{
  char *v;
  char *tmp_if_expr_2;
  char *return_value_strdup_1;
  if(!(string == ((const char *)NULL)))
  {
    return_value_strdup_1=strdup(string);
    tmp_if_expr_2 = return_value_strdup_1;
  }

  else
    tmp_if_expr_2 = ((char *)NULL);
  v = tmp_if_expr_2;
  char c;
  char *tmp;
  signed int vclass;
  unsigned long int id;
  struct anonymous_5 *result = ((struct anonymous_5 *)NULL);
  if(!(v == ((char *)NULL)))
  {
    tmp = v;
    for( ; !(*tmp == 0); tmp = tmp + 1l)
      if((signed int)*tmp >= 65)
      {
        if(!((signed int)*tmp >= 91))
          *tmp = (char)(((signed int)*tmp - 65) + 97);

      }

  }

  _Bool tmp_if_expr_20;
  if(v == ((char *)NULL))
    tmp_if_expr_20 = (_Bool)1;

  else
    tmp_if_expr_20 = !(*v != 0) ? (_Bool)1 : (_Bool)0;
  signed int return_value_strcmp_19;
  signed int return_value_strcmp_18;
  signed int return_value_strcmp_17;
  signed int return_value_strcmp_16;
  signed int return_value_strcmp_15;
  signed int return_value_strcmp_14;
  signed int return_value_strcmp_13;
  signed int return_value_strcmp_12;
  signed int return_value_strcmp_11;
  signed int return_value_strcmp_10;
  signed int return_value_strcmp_9;
  signed int return_value_strcmp_8;
  signed int return_value_strcmp_7;
  signed int return_value_strcmp_6;
  signed int return_value_strcmp_5;
  signed int return_value___isoc99_sscanf_4;
  signed int return_value___isoc99_sscanf_3;
  if(tmp_if_expr_20)
    vclass = -2;

  else
  {
    return_value_strcmp_19=strcmp(v, "default");
    if(return_value_strcmp_19 == 0)
      vclass = -1;

    else
    {
      return_value_strcmp_18=strcmp(v, "best");
      if(return_value_strcmp_18 == 0)
        vclass = -2;

      else
      {
        return_value_strcmp_17=strcmp(v, "mono");
        if(return_value_strcmp_17 == 0)
          vclass = -3;

        else
        {
          return_value_strcmp_16=strcmp(v, "monochrome");
          if(return_value_strcmp_16 == 0)
            vclass = -3;

          else
          {
            return_value_strcmp_15=strcmp(v, "gray");
            if(return_value_strcmp_15 == 0)
              vclass = -4;

            else
            {
              return_value_strcmp_14=strcmp(v, "grey");
              if(return_value_strcmp_14 == 0)
                vclass = -4;

              else
              {
                return_value_strcmp_13=strcmp(v, "color");
                if(return_value_strcmp_13 == 0)
                  vclass = -5;

                else
                {
                  return_value_strcmp_12=strcmp(v, "gl");
                  if(return_value_strcmp_12 == 0)
                    vclass = -6;

                  else
                  {
                    return_value_strcmp_11=strcmp(v, "staticgray");
                    if(return_value_strcmp_11 == 0)
                      vclass = 0;

                    else
                    {
                      return_value_strcmp_10=strcmp(v, "staticcolor");
                      if(return_value_strcmp_10 == 0)
                        vclass = 2;

                      else
                      {
                        return_value_strcmp_9=strcmp(v, "truecolor");
                        if(return_value_strcmp_9 == 0)
                          vclass = 4;

                        else
                        {
                          return_value_strcmp_8=strcmp(v, "grayscale");
                          if(return_value_strcmp_8 == 0)
                            vclass = 1;

                          else
                          {
                            return_value_strcmp_7=strcmp(v, "greyscale");
                            if(return_value_strcmp_7 == 0)
                              vclass = 1;

                            else
                            {
                              return_value_strcmp_6=strcmp(v, "pseudocolor");
                              if(return_value_strcmp_6 == 0)
                                vclass = 3;

                              else
                              {
                                return_value_strcmp_5=strcmp(v, "directcolor");
                                if(return_value_strcmp_5 == 0)
                                  vclass = 5;

                                else
                                {
                                  return_value___isoc99_sscanf_4=__isoc99_sscanf(v, " %lu %c", &id, &c);
                                  if(return_value___isoc99_sscanf_4 == 1)
                                    vclass = -7;

                                  else
                                  {
                                    return_value___isoc99_sscanf_3=__isoc99_sscanf(v, " 0x%lx %c", &id, &c);
                                    if(return_value___isoc99_sscanf_3 == 1)
                                      vclass = -7;

                                    else
                                    {
                                      fprintf(stderr, "%s: unrecognized visual \"%s\".\n", progname, v);
                                      vclass = -1;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  signed int return_value_visual_depth_21;
  if(vclass == -1)
    result = screen->root_visual;

  else
    if(vclass == -2)
      result=pick_best_visual(screen, prefer_writable_cells, 0);

    else
      if(vclass == -3)
      {
        result=pick_mono_visual(screen);
        if(result == ((struct anonymous_5 *)NULL) && !(verbose_p == 0))
          fprintf(stderr, "%s: no monochrome visuals.\n", progname);

      }

      else
        if(vclass == -4)
        {
          if(!(prefer_writable_cells == 0))
            result=pick_best_visual_of_class(screen, 1);

          if(result == ((struct anonymous_5 *)NULL))
            result=pick_best_visual_of_class(screen, 0);

          if(result == ((struct anonymous_5 *)NULL))
            result=pick_best_visual_of_class(screen, 1);

          if(result == ((struct anonymous_5 *)NULL) && !(verbose_p == 0))
            fprintf(stderr, "%s: no GrayScale or StaticGray visuals.\n", progname);

        }

        else
          if(vclass == -5)
          {
            signed int class;
            result = screen->root_visual;
            class=visual_class(screen, result);
            if(!(class == 2) && !(class == 3) && !(class == 4) && !(class == 5))
              result = ((struct anonymous_5 *)NULL);

            if(!(result == ((struct anonymous_5 *)NULL)))
            {
              return_value_visual_depth_21=visual_depth(screen, result);
              if(!(return_value_visual_depth_21 >= 2))
                result = ((struct anonymous_5 *)NULL);

            }

            if(result == ((struct anonymous_5 *)NULL))
              result=pick_best_visual(screen, prefer_writable_cells, 1);

            if(result == ((struct anonymous_5 *)NULL) && !(verbose_p == 0))
              fprintf(stderr, "%s: no color visuals.\n", progname);

          }

          else
            if(vclass == -6)
            {
              struct anonymous_5 *visual;
              visual=pick_best_gl_visual(screen);
              if(!(visual == ((struct anonymous_5 *)NULL)))
                result = visual;

              else
                if(!(verbose_p == 0))
                  fprintf(stderr, "%s: no visual suitable for GL.\n", progname);

            }

            else
              if(vclass == -7)
              {
                result=id_to_visual(screen, (signed int)id);
                if(result == ((struct anonymous_5 *)NULL) && !(verbose_p == 0))
                  fprintf(stderr, "%s: no visual with id 0x%x.\n", progname, (unsigned int)id);

              }

              else
              {
                struct anonymous_5 *get_visual__1__7__visual;
                get_visual__1__7__visual=pick_best_visual_of_class(screen, vclass);
                if(!(get_visual__1__7__visual == ((struct anonymous_5 *)NULL)))
                  result = get_visual__1__7__visual;

                else
                  if(!(verbose_p == 0))
                    fprintf(stderr, "%s: no visual of class %s.\n", progname, v);

              }
  if(!(v == ((char *)NULL)))
    free((void *)v);

  return result;
}

// get_visual_resource
// file ./../utils/visual.h line 16
extern struct anonymous_5 * get_visual_resource(struct anonymous_9 *screen, char *name, char *class, signed int prefer_writable_cells)
{
  char *string;
  string=get_string_resource(screen->display, name, class);
  struct anonymous_5 *v;
  v=get_visual(screen, string, prefer_writable_cells, 1);
  if(!(string == ((char *)NULL)))
    free((void *)string);

  if(!(v == ((struct anonymous_5 *)NULL)))
    return v;

  else
    return screen->root_visual;
}

// hack_subproc_environment
// file grabclient.c line 237
static void hack_subproc_environment(struct _XDisplay *dpy)
{
  const char *odpy = ((struct anonymous_63 *)dpy)->display_name;
  char *ndpy;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(odpy);
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(return_value_strlen_1 + (unsigned long int)20);
  ndpy = (char *)return_value_malloc_2;
  strcpy(ndpy, "DISPLAY=");
  strcat(ndpy, odpy);
  signed int return_value_putenv_3;
  return_value_putenv_3=putenv(ndpy);
  if(!(return_value_putenv_3 == 0))
    abort();

}

// hardware_concurrency
// file ./../utils/thread_util.h line 101
unsigned int hardware_concurrency(struct _XDisplay *dpy)
{
  signed int return_value_threads_available_2;
  return_value_threads_available_2=threads_available(dpy);
  unsigned int return_value__hardware_concurrency_1;
  if(return_value_threads_available_2 >= 0)
  {
    return_value__hardware_concurrency_1=_hardware_concurrency();
    return return_value__hardware_concurrency_1;
  }

  return (unsigned int)1;
}

// has_writable_cells
// file ./../utils/visual.h line 25
extern signed int has_writable_cells(struct anonymous_9 *screen, struct anonymous_5 *visual)
{
  signed int return_value_visual_class_1;
  return_value_visual_class_1=visual_class(screen, visual);
  switch(return_value_visual_class_1)
  {
    case 1:

    case 3:

    case 5:
      return 1;
    case 0:

    case 4:

    case 2:
      return 0;
    default:
    {
      abort();
      return 0;
    }
  }
}

// id_to_visual
// file visual.c line 340
extern struct anonymous_5 * id_to_visual(struct anonymous_9 *screen, signed int id)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_3 vi_in;
  struct anonymous_3 *vi_out;
  signed int out_count;
  vi_in.screen=screen_number(screen);
  vi_in.visualid = (unsigned long int)id;
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x1), &vi_in, &out_count);
  if(!(vi_out == ((struct anonymous_3 *)NULL)))
  {
    struct anonymous_5 *v = (vi_out + (signed long int)0)->visual;
    XFree((void *)(char *)vi_out);
    return v;
  }

  return ((struct anonymous_5 *)NULL);
}

// ignore_all_errors_ehandler
// file grabclient.c line 54
static signed int ignore_all_errors_ehandler(struct _XDisplay *dpy, struct anonymous_7 *error)
{
  error_handler_hit_p = 1;
  return 0;
}

// image_loaded_cb
// file apple2-main.c line 520
static void image_loaded_cb(struct anonymous_9 *screen, unsigned long int window, unsigned long int p, const char *name, struct anonymous_54 *geometry, void *closure)
{
  struct _XDisplay *dpy = screen->display;
  struct apple2_sim_s *sim = (struct apple2_sim_s *)closure;
  struct slideshow_data_s *mine = (struct slideshow_data_s *)sim->controller_data;
  struct anonymous_16 xgwa;
  signed int w = 280;
  signed int h = 192;
  struct _XImage *image;
  unsigned int *buf32;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)w, (unsigned long int)(h * 4));
  buf32 = (unsigned int *)return_value_calloc_1;
  unsigned char *buf8;
  void *return_value_calloc_2;
  return_value_calloc_2=calloc((unsigned long int)(w / 7), (unsigned long int)h);
  buf8 = (unsigned char *)return_value_calloc_2;
  if(buf32 == ((unsigned int *)NULL) || buf8 == ((unsigned char *)NULL))
  {
    fprintf(stderr, "%s: out of memory (%dx%d)\n", progname, w, h);
    exit(1);
  }

  XGetWindowAttributes(dpy, window, &xgwa);
  image=XGetImage(dpy, p, 0, 0, (unsigned int)xgwa.width, (unsigned int)xgwa.height, (unsigned long int)~0, 2);
  XFreePixmap(dpy, p);
  p = (unsigned long int)0;
  pick_a2_subimage(dpy, window, image, buf32, w, h);
  free((void *)image->data);
  image->data = ((char *)NULL);
  image->f.destroy_image(image);
  a2_dither(buf32, buf8, w, h);
  free((void *)buf32);
  mine->image_loading_p = 0;
  char *tmp_if_expr_4;
  char *return_value_strdup_3;
  if(!(name == ((const char *)NULL)))
  {
    return_value_strdup_3=strdup(name);
    tmp_if_expr_4 = return_value_strdup_3;
  }

  else
    tmp_if_expr_4 = ((char *)NULL);
  mine->img_filename = tmp_if_expr_4;
  mine->render_img = buf8;
}

// init_window
// file screenhack.c line 675
static void init_window(struct _XDisplay *dpy, struct _WidgetRec *toplevel, const char *title)
{
  unsigned long int window;
  struct anonymous_16 xgwa;
  XtPopup(toplevel, (enum anonymous_51)XtGrabNone);
  XtVaSetValues(toplevel, (char *)&XtShellStrings[(signed long int)356], title, (void *)0);
  window = toplevel->core.window;
  XGetWindowAttributes(dpy, window, &xgwa);
  XSelectInput(dpy, window, xgwa.your_event_mask | 1L << 0 | 1L << 1 | 1L << 2 | 1L << 3);
  XChangeProperty(dpy, window, XA_WM_PROTOCOLS, (unsigned long int)4, 32, 0, (unsigned char *)&XA_WM_DELETE_WINDOW, 1);
}

// io_thread_cancel
// file thread_util.c line 1013
signed int io_thread_cancel(struct io_thread *self)
{
  if(_has_pthread >= 0)
  {
    enum _io_thread_status old_status;
    signed int return_value___atomic_exchange_n_1;
    return_value___atomic_exchange_n_1=__atomic_exchange_n(&self->status, _io_thread_cancelled, 5);
    old_status = (enum _io_thread_status)return_value___atomic_exchange_n_1;
    /* assertion old_status == _io_thread_working || old_status == _io_thread_done */
    assert((signed int)old_status == _io_thread_working || (signed int)old_status == _io_thread_done);
    signed int return_value_pthread_detach_2;
    return_value_pthread_detach_2=pthread_detach(self->thread);
    /* assertion !(pthread_detach(self->thread)) */
    assert(!(return_value_pthread_detach_2 != 0));
    return (signed int)((signed int)old_status != _io_thread_working);
  }

  return 0;
}

// io_thread_create
// file thread_util.c line 950
void * io_thread_create(struct io_thread *self, void *parent, void * (*start_routine)(void *), struct _XDisplay *dpy, unsigned int stacksize)
{
  signed int return_value_threads_available_4;
  return_value_threads_available_4=threads_available(dpy);
  signed int return_value_pthread_attr_destroy_3;
  if(return_value_threads_available_4 >= 0)
  {
    signed int error;
    union pthread_attr_t attr;
    union pthread_attr_t *attr_ptr = (union pthread_attr_t *)(void *)0;
    if(!(stacksize == 0u))
    {
      attr_ptr = &attr;
      signed int return_value_pthread_attr_init_1;
      return_value_pthread_attr_init_1=pthread_attr_init(&attr);
      if(!(return_value_pthread_attr_init_1 == 0))
        return (void *)0;

      /* assertion stacksize >= 16384 */
      assert(stacksize >= (unsigned int)16384);
      signed int return_value_pthread_attr_setstacksize_2;
      return_value_pthread_attr_setstacksize_2=pthread_attr_setstacksize(&attr, (unsigned long int)stacksize);
      /* assertion !(pthread_attr_setstacksize(&attr, stacksize)) */
      assert(!(return_value_pthread_attr_setstacksize_2 != 0));
    }

    self->status = (enum _io_thread_status)_io_thread_working;
    error=pthread_create(&self->thread, attr_ptr, start_routine, parent);
    /* assertion !error || error == 11 */
    assert(!(error != 0) || error == 11);
    if(!(error == 0))
      parent = (void *)0;

    if(!(attr_ptr == ((union pthread_attr_t *)NULL)))
    {
      return_value_pthread_attr_destroy_3=pthread_attr_destroy(attr_ptr);
      /* assertion !(pthread_attr_destroy(attr_ptr)) */
      assert(!(return_value_pthread_attr_destroy_3 != 0));
    }

    return parent;
  }

  return (void *)0;
}

// io_thread_finish
// file thread_util.c line 1029
void io_thread_finish(struct io_thread *self)
{
  if(_has_pthread >= 0)
  {
    enum _io_thread_status status;
    signed int return_value___atomic_load_n_1;
    return_value___atomic_load_n_1=__atomic_load_n(&self->status, 5);
    status = (enum _io_thread_status)return_value___atomic_load_n_1;
    /* assertion status == _io_thread_working || status == _io_thread_done */
    assert((signed int)status == _io_thread_working || (signed int)status == _io_thread_done);
    signed int return_value_pthread_join_2;
    return_value_pthread_join_2=pthread_join(self->thread, (void **)(void *)0);
    /* assertion !(pthread_join(self->thread, ((void *)0))) */
    assert(!(return_value_pthread_join_2 != 0));
    signed int return_value___atomic_load_n_3;
    return_value___atomic_load_n_3=__atomic_load_n(&self->status, 5);
    /* assertion (__atomic_load_n((&self->status), 5)) == _io_thread_done */
    assert(return_value___atomic_load_n_3 == _io_thread_done);
  }

}

// io_thread_is_done
// file thread_util.c line 1002
signed int io_thread_is_done(struct io_thread *self)
{
  if(_has_pthread >= 0)
  {
    signed int result;
    result=__atomic_load_n(&self->status, 5);
    /* assertion result != _io_thread_cancelled */
    assert(result != _io_thread_cancelled);
    return result;
  }

  return 1;
}

// io_thread_return
// file thread_util.c line 989
signed int io_thread_return(struct io_thread *self)
{
  if(_has_pthread >= 0)
  {
    enum _io_thread_status old_status;
    signed int return_value___atomic_exchange_n_1;
    return_value___atomic_exchange_n_1=__atomic_exchange_n(&self->status, _io_thread_done, 5);
    old_status = (enum _io_thread_status)return_value___atomic_exchange_n_1;
    /* assertion old_status == _io_thread_working || old_status == _io_thread_cancelled */
    assert((signed int)old_status == _io_thread_working || (signed int)old_status == _io_thread_cancelled);
    return (signed int)((signed int)old_status != _io_thread_working);
  }

  return 0;
}

// launch_text_generator
// file textclient.c line 103
static void launch_text_generator(struct text_data *d)
{
  struct _XtAppStruct *app;
  app=XtDisplayToApplicationContext(d->dpy);
  char buf[255l];
  const char *oprogram = d->program;
  char *s;
  char *cmd;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(oprogram);
  void *return_value_malloc_2;
  return_value_malloc_2=malloc(return_value_strlen_1 * (unsigned long int)2 + (unsigned long int)100);
  s = (char *)return_value_malloc_2;
  cmd = s;
  strcpy(s, "( ");
  strcat(s, oprogram);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(s);
  s = s + (signed long int)return_value_strlen_3;
  signed int return_value_strcmp_5;
  return_value_strcmp_5=strcmp(oprogram, "xscreensaver-text");
  if(return_value_strcmp_5 == 0)
  {
    if(!(d->char_w == 0))
      sprintf(s, " --cols %d", d->char_w);

    if(!(d->max_lines == 0))
      sprintf(s, " --lines %d", d->max_lines);

    unsigned long int return_value_strlen_4;
    return_value_strlen_4=strlen(s);
    s = s + (signed long int)return_value_strlen_4;
  }

  strcpy(s, " ) 2>&1");
  if(!(d->pty_p == 0))
  {
    signed int fd;
    struct winsize ws;
    ws.ws_col = (unsigned short int)d->char_w;
    ws.ws_row = (unsigned short int)d->char_h;
    ws.ws_xpixel = (unsigned short int)d->pix_w;
    ws.ws_ypixel = (unsigned short int)d->pix_h;
    d->pipe = ((struct _IO_FILE *)NULL);
    d->pid=forkpty(&fd, (char *)(void *)0, (struct termios *)(void *)0, &ws);
    if(!(d->pid >= 0))
    {
      sprintf(buf, "%.100s: forkpty", progname);
      perror(buf);
    }

    else
      if(d->pid == 0)
      {
        char *av[10l];
        signed int i = 0;
        signed int return_value_putenv_6;
        return_value_putenv_6=putenv("TERM=vt100");
        if(!(return_value_putenv_6 == 0))
          abort();

        signed int tmp_post_7 = i;
        i = i + 1;
        av[(signed long int)tmp_post_7] = "/bin/sh";
        signed int tmp_post_8 = i;
        i = i + 1;
        av[(signed long int)tmp_post_8] = "-c";
        signed int tmp_post_9 = i;
        i = i + 1;
        av[(signed long int)tmp_post_9] = cmd;
        av[(signed long int)i] = ((char *)NULL);
        execvp(av[(signed long int)0], av);
        sprintf(buf, "%.100s: %.100s", progname, oprogram);
        perror(buf);
        exit(1);
      }

      else
      {
        if(!(d->pipe == ((struct _IO_FILE *)NULL)))
          abort();

        d->pipe=fdopen(fd, "r+");
        if(!(d->pipe_id == 0ul))
          abort();

        signed int return_value_fileno_10;
        return_value_fileno_10=fileno(d->pipe);
        d->pipe_id=XtAppAddInput(app, return_value_fileno_10, (void *)(1L << 0 | 1L << 2), subproc_cb, (void *)d);
      }
  }

  else
  {
    static signed int protected_stdin_p = 0;
    if(protected_stdin_p == 0)
    {
      fclose(stdin);
      open("/dev/null", 02);
      protected_stdin_p = 1;
    }

    if(!(d->pipe == ((struct _IO_FILE *)NULL)))
      abort();

    d->pipe=popen(cmd, "r");
    if(!(d->pipe == ((struct _IO_FILE *)NULL)))
    {
      if(!(d->pipe_id == 0ul))
        abort();

      signed int return_value_fileno_11;
      return_value_fileno_11=fileno(d->pipe);
      d->pipe_id=XtAppAddInput(app, return_value_fileno_11, (void *)(1L << 0 | 1L << 2), subproc_cb, (void *)d);
    }

    else
    {
      sprintf(buf, "%.100s: %.100s", progname, cmd);
      perror(buf);
    }
  }
  free((void *)cmd);
}

// load_image_async
// file ./../utils/grabscreen.h line 40
extern void load_image_async(struct anonymous_9 *screen, unsigned long int window, unsigned long int drawable, void (*callback)(struct anonymous_9 *, unsigned long int, unsigned long int, const char *, struct anonymous_54 *, void *), void *closure)
{
  load_random_image_1(screen, window, drawable, callback, closure, ((char **)NULL), ((struct anonymous_54 *)NULL));
}

// load_image_async_simple
// file grabclient.c line 949
extern struct async_load_state * load_image_async_simple(struct async_load_state *state, struct anonymous_9 *screen, unsigned long int window, unsigned long int drawable, char **filename_ret, struct anonymous_54 *geometry_ret)
{
  _Bool tmp_if_expr_2;
  if(!(state == ((struct async_load_state *)NULL)))
    tmp_if_expr_2 = state->done_p != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  if(tmp_if_expr_2)
  {
    if(!(filename_ret == ((char **)NULL)))
      *filename_ret = state->filename;

    else
      if(!(state->filename == ((char *)NULL)))
        free((void *)state->filename);

    if(!(geometry_ret == ((struct anonymous_54 *)NULL)))
      *geometry_ret = state->geom;

    free((void *)state);
    return ((struct async_load_state *)NULL);
  }

  else
    if(state == ((struct async_load_state *)NULL))
    {
      void *return_value_calloc_1;
      return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct async_load_state) /*24ul*/ );
      state = (struct async_load_state *)return_value_calloc_1;
      state->done_p = 0;
      print_loading_msg(screen, window);
      load_image_async(screen, window, drawable, load_image_async_simple_cb, (void *)state);
      return state;
    }

    else
      return state;
}

// load_image_async_simple_cb
// file grabclient.c line 939
static void load_image_async_simple_cb(struct anonymous_9 *screen, unsigned long int window, unsigned long int drawable, const char *name, struct anonymous_54 *geom, void *closure)
{
  struct async_load_state *state = (struct async_load_state *)closure;
  state->done_p = 1;
  char *tmp_if_expr_2;
  char *return_value_strdup_1;
  if(!(name == ((const char *)NULL)))
  {
    return_value_strdup_1=strdup(name);
    tmp_if_expr_2 = return_value_strdup_1;
  }

  else
    tmp_if_expr_2 = ((char *)NULL);
  state->filename = tmp_if_expr_2;
  state->geom = *geom;
}

// load_random_image_1
// file grabclient.c line 444
static void load_random_image_1(struct anonymous_9 *screen, unsigned long int window, unsigned long int drawable, void (*callback)(struct anonymous_9 *, unsigned long int, unsigned long int, const char *, struct anonymous_54 *, void *), void *closure, char **name_ret, struct anonymous_54 *geom_ret)
{
  struct _XDisplay *dpy = screen->display;
  char *grabber;
  grabber=get_string_resource(dpy, "desktopGrabber", "DesktopGrabber");
  char *cmd;
  char id[200l];
  _Bool tmp_if_expr_1;
  if(grabber == ((char *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(*grabber != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    fprintf(stderr, "%s: resources installed incorrectly: \"desktopGrabber\" is unset!\n", progname);
    exit(1);
  }

  sprintf(id, "0x%lx 0x%lx", (unsigned long int)window, (unsigned long int)drawable);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(grabber);
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(id);
  void *return_value_malloc_4;
  return_value_malloc_4=malloc(return_value_strlen_2 + return_value_strlen_3 + (unsigned long int)1);
  cmd = (char *)return_value_malloc_4;
  sprintf(cmd, grabber, (const void *)id);
  free((void *)grabber);
  grabber = ((char *)NULL);
  checkerboard(screen, drawable);
  if(window == drawable)
    print_loading_msg(screen, window);

  XSync(dpy, 1);
  hack_subproc_environment(dpy);
  if(!(callback == ((void (*)(struct anonymous_9 *, unsigned long int, unsigned long int, const char *, struct anonymous_54 *, void *))NULL)))
  {
    if(!(name_ret == ((char **)NULL)))
      abort();

    fork_exec_cb(cmd, screen, window, drawable, callback, closure);
  }

  else
  {
    fork_exec_wait(cmd);
    if(!(name_ret == ((char **)NULL)))
      *name_ret=get_name(dpy, window);

    if(!(geom_ret == ((struct anonymous_54 *)NULL)))
      get_geometry(dpy, window, geom_ret);

  }
  free((void *)cmd);
  XSync(dpy, 1);
}

// main
// file screenhack.c line 696
signed int main(signed int argc, char **argv)
{
  struct xscreensaver_function_table *ft = xscreensaver_function_table;
  struct anonymous_16 xgwa;
  struct _WidgetRec *toplevel;
  struct _XDisplay *dpy;
  unsigned long int window;
  unsigned long int window2 = (unsigned long int)0;
  struct _WidgetRec *toplevel2 = ((struct _WidgetRec *)NULL);
  struct _XtAppStruct *app;
  signed int root_p;
  unsigned long int on_window = (unsigned long int)0;
  union _XEvent event;
  char dont_clear;
  char version[255l];
  fix_fds();
  progname = argv[(signed long int)0];
  progclass = ft->progclass;
  if(!(ft->setup_cb == ((void (*)(struct xscreensaver_function_table *, void *))NULL)))
    ft->setup_cb(ft, ft->setup_arg);

  merge_options();
  toplevel=XtAppInitialize(&app, progclass, merged_options, (unsigned int)merged_options_size, &argc, argv, merged_defaults, ((struct anonymous_45 *)NULL), (unsigned int)0);
  dpy = toplevel->core.screen->display;
  XtGetApplicationNameAndClass(dpy, (char **)&progname, (char **)&progclass);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(progname);
  if(return_value_strlen_1 >= 100ul)
    ((char *)progname)[(signed long int)100] = (char)0;

  XSetErrorHandler(screenhack_ehandler);
  XA_WM_PROTOCOLS=XInternAtom(dpy, "WM_PROTOCOLS", 0);
  XA_WM_DELETE_WINDOW=XInternAtom(dpy, "WM_DELETE_WINDOW", 0);
  char *v;
  char *return_value_strchr_2;
  return_value_strchr_2=strchr(screensaver_id, 32);
  char *return_value_strdup_3;
  return_value_strdup_3=strdup(return_value_strchr_2);
  v = (char *)return_value_strdup_3;
  char *s1;
  char *s2;
  char *s3;
  char *s4;
  const char *ot;
  ot=get_string_resource(dpy, "title", "Title");
  char *return_value_strchr_4;
  return_value_strchr_4=strchr(v, 32);
  s1 = (char *)return_value_strchr_4;
  s1 = s1 + 1l;
  char *return_value_strchr_5;
  return_value_strchr_5=strchr(s1, 32);
  s2 = (char *)return_value_strchr_5;
  char *return_value_strchr_6;
  return_value_strchr_6=strchr(v, 40);
  s3 = (char *)return_value_strchr_6;
  s3 = s3 + 1l;
  char *return_value_strchr_7;
  return_value_strchr_7=strchr(s3, 41);
  s4 = (char *)return_value_strchr_7;
  *s2 = (char)0;
  *s4 = (char)0;
  if(!(ot == ((const char *)NULL)))
  {
    if(*ot == 0)
      ot = ((const char *)NULL);

  }

  sprintf(version, "%.50s%s%s: from the XScreenSaver %s distribution (%s)", ot != ((const char *)NULL) ? ot : "", ot != ((const char *)NULL) ? ": " : "", progclass, s1, s3);
  free((void *)v);
  signed int return_value_strcmp_9;
  if(argc >= 2)
  {
    const char *main__1__2__s;
    signed int i;
    signed int x = 18;
    signed int end = 78;
    signed int help_p;
    signed int return_value_strcmp_8;
    return_value_strcmp_8=strcmp(argv[(signed long int)1], "-help");
    _Bool tmp_if_expr_10;
    if(return_value_strcmp_8 == 0)
      tmp_if_expr_10 = (_Bool)1;

    else
    {
      return_value_strcmp_9=strcmp(argv[(signed long int)1], "--help");
      tmp_if_expr_10 = !(return_value_strcmp_9 != 0) ? (_Bool)1 : (_Bool)0;
    }
    help_p = (signed int)tmp_if_expr_10;
    fprintf(stderr, "%s\n", (const void *)version);
    main__1__2__s = progclass;
    for( ; !(*main__1__2__s == 0); main__1__2__s = main__1__2__s + 1l)
      fprintf(stderr, " ");
    fprintf(stderr, "  http://www.jwz.org/xscreensaver/\n\n");
    if(help_p == 0)
      fprintf(stderr, "Unrecognised option: %s\n", argv[(signed long int)1]);

    fprintf(stderr, "Options include: ");
    i = 0;
    for( ; !(i >= merged_options_size); i = i + 1)
    {
      char *sw = (merged_options + (signed long int)i)->option;
      signed int argp = (signed int)((signed int)(merged_options + (signed long int)i)->argKind == XrmoptionSepArg);
      signed int size;
      unsigned long int return_value_strlen_11;
      return_value_strlen_11=strlen(sw);
      size = (signed int)(return_value_strlen_11 + (unsigned long int)(argp != 0 ? 6 : 0) + (unsigned long int)2);
      if(size + x >= end)
      {
        fprintf(stderr, "\n\t\t ");
        x = 18;
      }

      x = x + size;
      fprintf(stderr, "%s", sw);
      if(!(argp == 0))
        fprintf(stderr, " <arg>");

      if(!(i == merged_options_size + -1))
        fprintf(stderr, ", ");

    }
    fprintf(stderr, ".\n");
    exit(help_p != 0 ? 0 : 1);
  }

  char **s = merged_defaults;
  for( ; !(*s == ((char *)NULL)); s = s + 1l)
    free((void *)*s);
  free((void *)merged_options);
  free((void *)merged_defaults);
  merged_options = ((struct anonymous_39 *)NULL);
  merged_defaults = ((char **)NULL);
  signed int return_value_get_boolean_resource_12;
  return_value_get_boolean_resource_12=get_boolean_resource(dpy, "dontClearRoot", "Boolean");
  dont_clear = (char)return_value_get_boolean_resource_12;
  mono_p=get_boolean_resource(dpy, "mono", "Boolean");
  if(!((((struct anonymous_63 *)dpy)->screens + (signed long int)((struct anonymous_63 *)dpy)->default_screen)->root_visual->map_entries >= 3))
    mono_p = 1;

  root_p=get_boolean_resource(dpy, "root", "Boolean");
  char *main__1__4__s;
  main__1__4__s=get_string_resource(dpy, "windowID", "WindowID");
  signed int return_value_get_integer_resource_13;
  if(!(main__1__4__s == ((char *)NULL)))
  {
    if(!(*main__1__4__s == 0))
    {
      return_value_get_integer_resource_13=get_integer_resource(dpy, "windowID", "WindowID");
      on_window = (unsigned long int)return_value_get_integer_resource_13;
    }

  }

  if(!(main__1__4__s == ((char *)NULL)))
    free((void *)main__1__4__s);

  if(!(on_window == 0ul))
  {
    window = (unsigned long int)on_window;
    XtDestroyWidget(toplevel);
    XGetWindowAttributes(dpy, window, &xgwa);
    visual_warning(xgwa.screen, window, xgwa.visual, xgwa.colormap, 1);
    xgwa.your_event_mask = xgwa.your_event_mask | 1L << 0 | 1L << 17;
    XSelectInput(dpy, window, xgwa.your_event_mask);
    if((12l & xgwa.all_event_masks) == 0l)
      XSelectInput(dpy, window, xgwa.your_event_mask | 1L << 2 | 1L << 3);

  }

  else
    if(!(root_p == 0))
    {
      window=VirtualRootWindowOfScreen(toplevel->core.screen);
      XtDestroyWidget(toplevel);
      XGetWindowAttributes(dpy, window, &xgwa);
      XSelectInput(dpy, window, xgwa.your_event_mask | 1L << 17);
      visual_warning(xgwa.screen, window, xgwa.visual, xgwa.colormap, 0);
    }

    else
    {
      struct _WidgetRec *new;
      new=make_shell(toplevel->core.screen, toplevel, (signed int)toplevel->core.width, (signed int)toplevel->core.height);
      if(!(new == toplevel))
      {
        XtDestroyWidget(toplevel);
        toplevel = new;
      }

      init_window(dpy, toplevel, version);
      window = toplevel->core.window;
      XGetWindowAttributes(dpy, window, &xgwa);
      signed int return_value_get_boolean_resource_14;
      return_value_get_boolean_resource_14=get_boolean_resource(dpy, "pair", "Boolean");
      if(!(return_value_get_boolean_resource_14 == 0))
      {
        toplevel2=make_shell(xgwa.screen, ((struct _WidgetRec *)NULL), (signed int)toplevel->core.width, (signed int)toplevel->core.height);
        init_window(dpy, toplevel2, version);
        window2 = toplevel2->core.window;
      }

    }
  if(dont_clear == 0)
  {
    unsigned int bg;
    bg=get_pixel_resource(dpy, xgwa.colormap, "background", "Background");
    XSetWindowBackground(dpy, window, (unsigned long int)bg);
    XClearWindow(dpy, window);
    if(!(window2 == 0ul))
    {
      XSetWindowBackground(dpy, window2, (unsigned long int)bg);
      XClearWindow(dpy, window2);
    }

  }

  if(root_p == 0 && on_window == 0ul)
    XIfEvent(dpy, &event, MapNotify_event_p, (char *)window);

  XSync(dpy, 0);
  ya_rand_init((unsigned int)0);
  run_screenhack_table(dpy, window, window2, ft);
  XtDestroyWidget(toplevel);
  XtDestroyApplicationContext(app);
  return 0;
}

// make_shell
// file screenhack.c line 612
static struct _WidgetRec * make_shell(struct anonymous_9 *screen, struct _WidgetRec *toplevel, signed int width, signed int height)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_5 *visual;
  visual=pick_visual(screen);
  char def_visual_p;
  _Bool tmp_if_expr_1;
  if(!(toplevel == ((struct _WidgetRec *)NULL)))
    tmp_if_expr_1 = visual == screen->root_visual ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  def_visual_p = (char)tmp_if_expr_1;
  if(!(width >= 1))
    width = 600;

  if(!(height >= 1))
    height = 480;

  if(!(def_visual_p == 0))
  {
    unsigned long int window;
    XtVaSetValues(toplevel, (char *)&XtStrings[(signed long int)453], 0, (char *)&XtStrings[(signed long int)872], width, (char *)&XtStrings[(signed long int)234], height, (char *)&XtShellStrings[(signed long int)417], 1, (void *)0);
    XtRealizeWidget(toplevel);
    window = toplevel->core.window;
    signed int return_value_get_boolean_resource_2;
    return_value_get_boolean_resource_2=get_boolean_resource(dpy, "installColormap", "InstallColormap");
    if(!(return_value_get_boolean_resource_2 == 0))
    {
      unsigned long int make_shell__1__1__1__cmap;
      make_shell__1__1__1__cmap=XCreateColormap(dpy, window, screen->root_visual, 0);
      XSetWindowColormap(dpy, window, make_shell__1__1__1__cmap);
    }

  }

  else
  {
    unsigned int bg;
    unsigned int bd;
    struct _WidgetRec *new;
    unsigned long int cmap;
    unsigned long int return_value_VirtualRootWindowOfScreen_3;
    return_value_VirtualRootWindowOfScreen_3=VirtualRootWindowOfScreen(screen);
    cmap=XCreateColormap(dpy, return_value_VirtualRootWindowOfScreen_3, visual, 0);
    bg=get_pixel_resource(dpy, cmap, "background", "Background");
    bd=get_pixel_resource(dpy, cmap, "borderColor", "Foreground");
    signed int return_value_visual_depth_4;
    return_value_visual_depth_4=visual_depth(screen, visual);
    new=XtVaAppCreateShell(progname, progclass, topLevelShellWidgetClass, dpy, (char *)&XtStrings[(signed long int)453], 0, (char *)&XtShellStrings[(signed long int)104], visual, (char *)&XtStrings[(signed long int)163], return_value_visual_depth_4, (char *)&XtStrings[(signed long int)872], width, (char *)&XtStrings[(signed long int)234], height, (char *)&XtStrings[(signed long int)154], cmap, (char *)&XtStrings[(signed long int)52], (unsigned long int)bg, (char *)&XtStrings[(signed long int)87], (unsigned long int)bd, (char *)&XtShellStrings[(signed long int)417], 1, (void *)0);
    if(toplevel == ((struct _WidgetRec *)NULL))
      XtVaSetValues(new, (char *)&XtStrings[(signed long int)885], 0, (char *)&XtStrings[(signed long int)887], 550, (void *)0);

    XtRealizeWidget(new);
    toplevel = new;
  }
  return toplevel;
}

// make_typo
// file apple2-main.c line 1503
static signed int make_typo(char *out_buf, const char *orig, char *err_buf)
{
  signed int i;
  signed int j;
  signed int errc;
  signed int success = 0;
  err_buf[(signed long int)0] = (char)0;
  typo_map[(signed long int)65] = (char)81;
  typo_map[(signed long int)83] = (char)65;
  typo_map[(signed long int)68] = (char)83;
  typo_map[(signed long int)70] = (char)71;
  typo_map[(signed long int)71] = (char)72;
  typo_map[(signed long int)72] = (char)74;
  typo_map[(signed long int)74] = (char)72;
  typo_map[(signed long int)75] = (char)76;
  typo_map[(signed long int)76] = (char)59;
  typo_map[(signed long int)81] = (char)49;
  typo_map[(signed long int)87] = (char)81;
  typo_map[(signed long int)69] = (char)51;
  typo_map[(signed long int)82] = (char)84;
  typo_map[(signed long int)84] = (char)89;
  typo_map[(signed long int)89] = (char)85;
  typo_map[(signed long int)85] = (char)89;
  typo_map[(signed long int)73] = (char)79;
  typo_map[(signed long int)79] = (char)80;
  typo_map[(signed long int)80] = (char)91;
  typo_map[(signed long int)90] = (char)88;
  typo_map[(signed long int)88] = (char)67;
  typo_map[(signed long int)67] = (char)86;
  typo_map[(signed long int)86] = (char)67;
  typo_map[(signed long int)66] = (char)78;
  typo_map[(signed long int)78] = (char)66;
  typo_map[(signed long int)77] = (char)78;
  typo_map[(signed long int)44] = (char)46;
  typo_map[(signed long int)46] = (char)44;
  typo_map[(signed long int)33] = (char)49;
  typo_map[(signed long int)64] = (char)50;
  typo_map[(signed long int)35] = (char)51;
  typo_map[(signed long int)36] = (char)52;
  typo_map[(signed long int)37] = (char)53;
  typo_map[(signed long int)94] = (char)54;
  typo_map[(signed long int)38] = (char)55;
  typo_map[(signed long int)42] = (char)56;
  typo_map[(signed long int)40] = (char)57;
  typo_map[(signed long int)41] = (char)48;
  typo_map[(signed long int)49] = (char)81;
  typo_map[(signed long int)50] = (char)87;
  typo_map[(signed long int)51] = (char)69;
  typo_map[(signed long int)52] = (char)82;
  typo_map[(signed long int)53] = (char)84;
  typo_map[(signed long int)54] = (char)89;
  typo_map[(signed long int)55] = (char)85;
  typo_map[(signed long int)56] = (char)73;
  typo_map[(signed long int)57] = (char)79;
  typo_map[(signed long int)48] = (char)45;
  strcpy(out_buf, orig);
  i = 0;
  const unsigned short int **return_value___ctype_b_loc_2;
  unsigned int return_value_ya_random_1;
  unsigned long int return_value_strlen_6;
  for( ; !(out_buf[(signed long int)i] == 0); i = i + 1)
  {
    char *p = out_buf + (signed long int)i;
    if(i >= 3)
    {
      if((signed int)p[-2l] == 82)
      {
        if((signed int)p[-1l] == 69)
        {
          if((signed int)*p == 77)
            break;

        }

      }

    }

    const unsigned short int **return_value___ctype_b_loc_3;
    return_value___ctype_b_loc_3=__ctype_b_loc();
    if(!((1024 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)*p]) == 0))
    {
      return_value___ctype_b_loc_2=__ctype_b_loc();
      if(!((1024 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)p[1l]]) == 0))
      {
        if(!(*p == p[1l]))
        {
          return_value_ya_random_1=ya_random();
          if(return_value_ya_random_1 % 15u == 0u)
          {
            signed int tmp = (signed int)p[(signed long int)1];
            p[(signed long int)1] = p[(signed long int)0];
            p[(signed long int)0] = (char)tmp;
            success = 1;
            sprintf(err_buf, "?SYNTAX ERROR\n");
            break;
          }

        }

      }

    }

    unsigned int return_value_ya_random_7;
    return_value_ya_random_7=ya_random();
    if(return_value_ya_random_7 % 10u == 0u)
    {
      return_value_strlen_6=strlen(p);
      if(return_value_strlen_6 >= 4ul)
      {
        errc = (signed int)typo_map[(signed long int)(signed int)(unsigned char)p[(signed long int)0]];
        if(!(errc == 0))
        {
          signed int remain;
          unsigned long int return_value_strlen_4;
          return_value_strlen_4=strlen(p);
          remain = (signed int)return_value_strlen_4;
          signed int past;
          unsigned int return_value_ya_random_5;
          return_value_ya_random_5=ya_random();
          past = (signed int)(return_value_ya_random_5 % (unsigned int)(remain - 2) + (unsigned int)1);
          memmove((void *)(p + (signed long int)past + (signed long int)past), (const void *)p, (unsigned long int)(remain + 1));
          p[(signed long int)0] = (char)errc;
          j = 0;
          for( ; !(j >= past); j = j + 1)
            p[(signed long int)(past + j)] = (char)010;
          break;
        }

      }

    }

  }
  return success;
}

// merge_options
// file screenhack.c line 182
static void merge_options(void)
{
  struct xscreensaver_function_table *ft = xscreensaver_function_table;
  const struct anonymous_39 *options = ft->options;
  const char * const *defaults = ft->defaults;
  const char *merge_options__1__progclass = ft->progclass;
  signed int def_opts_size;
  signed int opts_size;
  signed int def_defaults_size;
  signed int defaults_size;
  def_opts_size = 0;
  for( ; !(default_options[(signed long int)def_opts_size].option == ((char *)NULL)); def_opts_size = def_opts_size + 1)
    ;
  opts_size = 0;
  for( ; !((options + (signed long int)opts_size)->option == ((char *)NULL)); opts_size = opts_size + 1)
    ;
  merged_options_size = def_opts_size + opts_size;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)(merged_options_size + 1) * sizeof(struct anonymous_39) /*32ul*/ );
  merged_options = (struct anonymous_39 *)return_value_malloc_1;
  memcpy((void *)merged_options, (const void *)default_options, (unsigned long int)def_opts_size * sizeof(struct anonymous_39) /*32ul*/ );
  memcpy((void *)(merged_options + (signed long int)def_opts_size), (const void *)options, (unsigned long int)(opts_size + 1) * sizeof(struct anonymous_39) /*32ul*/ );
  def_defaults_size = 0;
  for( ; !(default_defaults[(signed long int)def_defaults_size] == ((char *)NULL)); def_defaults_size = def_defaults_size + 1)
    ;
  defaults_size = 0;
  for( ; !(defaults[(signed long int)defaults_size] == ((const char *)NULL)); defaults_size = defaults_size + 1)
    ;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(def_defaults_size + defaults_size + 1) * sizeof(const char *) /*8ul*/ );
  merged_defaults = (char **)return_value_malloc_2;
  memcpy((void *)merged_defaults, (const void *)default_defaults, (unsigned long int)def_defaults_size * sizeof(const char *) /*8ul*/ );
  memcpy((void *)(merged_defaults + (signed long int)def_defaults_size), (const void *)defaults, (unsigned long int)(defaults_size + 1) * sizeof(const char *) /*8ul*/ );
  char **s = merged_defaults;
  for( ; !(*s == ((char *)NULL)); s = s + 1l)
    if((signed int)*(*s) == 46)
    {
      const char *oldr = *s;
      char *newr;
      unsigned long int return_value_strlen_3;
      return_value_strlen_3=strlen(oldr);
      unsigned long int return_value_strlen_4;
      return_value_strlen_4=strlen(merge_options__1__progclass);
      void *return_value_malloc_5;
      return_value_malloc_5=malloc(return_value_strlen_3 + return_value_strlen_4 + (unsigned long int)3);
      newr = (char *)return_value_malloc_5;
      strcpy(newr, merge_options__1__progclass);
      strcat(newr, oldr);
      *s = newr;
    }

    else
      *s=strdup(*s);
}

// meta_modifier
// file textclient.c line 514
static unsigned int meta_modifier(struct text_data *d)
{
  if(d->meta_done_once == 0)
  {
    d->meta_done_once = 1;
    d->meta_mask=do_icccm_meta_key_stupidity(d->dpy);
  }

  return d->meta_mask;
}

// parse_time
// file resources.c line 203
extern signed int parse_time(const char *string, signed int seconds_default_p, signed int silent_p)
{
  unsigned int h;
  unsigned int m;
  unsigned int s;
  char c;
  signed int return_value___isoc99_sscanf_6;
  return_value___isoc99_sscanf_6=__isoc99_sscanf(string, " %u : %2u : %2u %c", &h, &m, &s, &c);
  signed int return_value___isoc99_sscanf_3;
  signed int return_value___isoc99_sscanf_4;
  signed int return_value___isoc99_sscanf_2;
  signed int return_value___isoc99_sscanf_1;
  if(!(return_value___isoc99_sscanf_6 == 3))
  {
    return_value___isoc99_sscanf_3=__isoc99_sscanf(string, " : %2u : %2u %c", &m, &s, &c);
    _Bool tmp_if_expr_5;
    if(return_value___isoc99_sscanf_3 == 2)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value___isoc99_sscanf_4=__isoc99_sscanf(string, " %u : %2u %c", &m, &s, &c);
      tmp_if_expr_5 = 2 == return_value___isoc99_sscanf_4 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      h = (unsigned int)0;

    else
    {
      return_value___isoc99_sscanf_2=__isoc99_sscanf(string, " : %2u %c", &s, &c);
      if(return_value___isoc99_sscanf_2 == 1)
      {
        m = (unsigned int)0;
        h = m;
      }

      else
      {
        return_value___isoc99_sscanf_1=__isoc99_sscanf(string, " %u %c", seconds_default_p != 0 ? &s : &m, &c);
        if(return_value___isoc99_sscanf_1 == 1)
        {
          h = (unsigned int)0;
          if(!(seconds_default_p == 0))
            m = (unsigned int)0;

          else
            s = (unsigned int)0;
        }

        else
        {
          if(silent_p == 0)
            fprintf(stderr, "%s: invalid time interval specification \"%s\".\n", progname, string);

          return -1;
        }
      }
    }
  }

  if(s >= 60u && (!(h == 0u) || !(m == 0u)))
  {
    if(silent_p == 0)
      fprintf(stderr, "%s: seconds > 59 in \"%s\".\n", progname, string);

    return -1;
  }

  else
    if(h >= 1u && m >= 60u)
    {
      if(silent_p == 0)
        fprintf(stderr, "%s: minutes > 59 in \"%s\".\n", progname, string);

      return -1;
    }

    else
      return (signed int)(h * (unsigned int)60 * (unsigned int)60 + m * (unsigned int)60 + s);
}

// pick_a2_subimage
// file apple2-main.c line 190
static void pick_a2_subimage(struct _XDisplay *dpy, unsigned long int window, struct _XImage *in, unsigned int *out, signed int w, signed int h)
{
  signed int fromx;
  signed int fromy;
  signed int fromw;
  signed int fromh;
  _Bool tmp_if_expr_12;
  if(w >= in->width)
    tmp_if_expr_12 = (_Bool)1;

  else
    tmp_if_expr_12 = in->height <= h ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_1;
  unsigned int return_value_ya_random_8;
  unsigned int return_value_ya_random_10;
  if(tmp_if_expr_12)
  {
    fromx = 0;
    fromy = 0;
    fromw = in->width;
    fromh = in->height;
  }

  else
  {
    signed int dw;
    signed int dh;
    do
    {
      double scale;
      double tmp_statement_expression_2;
      double pick_a2_subimage__1__2__1__1__tmp;
      unsigned int return_value_ya_random_3;
      return_value_ya_random_3=ya_random();
      pick_a2_subimage__1__2__1__1__tmp = ((double)return_value_ya_random_3 * (double)0.7) / (double)(unsigned int)~0;
      tmp_statement_expression_2 = pick_a2_subimage__1__2__1__1__tmp < (double)0 ? -pick_a2_subimage__1__2__1__1__tmp : pick_a2_subimage__1__2__1__1__tmp;
      double tmp_statement_expression_4;
      double tmp;
      unsigned int return_value_ya_random_5;
      return_value_ya_random_5=ya_random();
      tmp = ((double)return_value_ya_random_5 * (double)0.7) / (double)(unsigned int)~0;
      tmp_statement_expression_4 = tmp < (double)0 ? -tmp : tmp;
      double tmp_statement_expression_6;
      double pick_a2_subimage__1__2__1__3__tmp;
      unsigned int return_value_ya_random_7;
      return_value_ya_random_7=ya_random();
      pick_a2_subimage__1__2__1__3__tmp = ((double)return_value_ya_random_7 * (double)0.7) / (double)(unsigned int)~0;
      tmp_statement_expression_6 = pick_a2_subimage__1__2__1__3__tmp < (double)0 ? -pick_a2_subimage__1__2__1__3__tmp : pick_a2_subimage__1__2__1__3__tmp;
      scale = 0.5 + tmp_statement_expression_2 + tmp_statement_expression_4 + tmp_statement_expression_6;
      fromw = (signed int)((double)w * scale);
      fromh = (signed int)((double)h * scale);
      if(!(in->width >= fromw))
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = fromh > in->height ? (_Bool)1 : (_Bool)0;
    }
    while(tmp_if_expr_1);
    dw = (in->width - fromw) / 2;
    dh = (in->height - fromh) / 2;
    unsigned int tmp_if_expr_9;
    if(!(dw >= 1))
      tmp_if_expr_9 = (unsigned int)0;

    else
    {
      return_value_ya_random_8=ya_random();
      tmp_if_expr_9 = return_value_ya_random_8 % (unsigned int)dw + (unsigned int)(dw / 2);
    }
    fromx = (signed int)tmp_if_expr_9;
    unsigned int tmp_if_expr_11;
    if(!(dh >= 1))
      tmp_if_expr_11 = (unsigned int)0;

    else
    {
      return_value_ya_random_10=ya_random();
      tmp_if_expr_11 = return_value_ya_random_10 % (unsigned int)dh + (unsigned int)(dh / 2);
    }
    fromy = (signed int)tmp_if_expr_11;
  }
  scale_image(dpy, window, in, fromx, fromy, fromw, fromh, out, w, h);
}

// pick_best_gl_visual
// file visual.c line 281
static struct anonymous_5 * pick_best_gl_visual(struct anonymous_9 *screen)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_3 vi_in;
  struct anonymous_3 *vi_out;
  signed int out_count;
  struct anonymous_5 *result = ((struct anonymous_5 *)NULL);
  signed int ndepths = 0;
  signed int *depths;
  signed int return_value_screen_number_1;
  return_value_screen_number_1=screen_number(screen);
  depths=XListDepths(dpy, return_value_screen_number_1, &ndepths);
  signed int screen_depth;
  signed int tmp_if_expr_2;
  if(!(depths == ((signed int *)NULL)) && !(ndepths == 0))
    tmp_if_expr_2 = depths[(signed long int)(ndepths - 1)];

  else
    tmp_if_expr_2 = 0;
  screen_depth = tmp_if_expr_2;
  XFree((void *)depths);
  vi_in.class = 4;
  vi_in.screen=screen_number(screen);
  vi_in.depth = screen_depth / 2;
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x8 | 0x2 | 0x4), &vi_in, &out_count);
  if(out_count >= 1)
    result = (vi_out + (signed long int)0)->visual;

  if(!(vi_out == ((struct anonymous_3 *)NULL)))
    XFree((void *)(char *)vi_out);

  if(result == ((struct anonymous_5 *)NULL) && screen_depth >= 25)
  {
    vi_in.class = 4;
    vi_in.screen=screen_number(screen);
    vi_in.depth = 12;
    vi_out=XGetVisualInfo(dpy, (signed long int)(0x8 | 0x2 | 0x4), &vi_in, &out_count);
    if(out_count >= 1)
      result = (vi_out + (signed long int)0)->visual;

  }

  if(result == ((struct anonymous_5 *)NULL))
    result=pick_best_visual_of_class(screen, 4);

  if(result == ((struct anonymous_5 *)NULL))
    result=pick_best_visual(screen, 0, 0);

  return result;
}

// pick_best_visual
// file visual.c line 174
static struct anonymous_5 * pick_best_visual(struct anonymous_9 *screen, signed int prefer_writable_cells, signed int color_only)
{
  struct anonymous_5 *visual;
  signed int return_value_visual_depth_1;
  if(prefer_writable_cells == 0)
  {
    visual=pick_best_visual_of_class(screen, 4);
    if(!(visual == ((struct anonymous_5 *)NULL)))
    {
      return_value_visual_depth_1=visual_depth(screen, visual);
      if(return_value_visual_depth_1 >= 16)
        return visual;

    }

  }

  visual=pick_best_visual_of_class(screen, 3);
  signed int return_value_visual_depth_2;
  if(!(visual == ((struct anonymous_5 *)NULL)))
  {
    _Bool tmp_if_expr_3;
    if(color_only == 0)
      tmp_if_expr_3 = (_Bool)1;

    else
    {
      return_value_visual_depth_2=visual_depth(screen, visual);
      tmp_if_expr_3 = return_value_visual_depth_2 > 1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_3)
      return visual;

  }

  visual=pick_best_visual_of_class(screen, 4);
  signed int return_value_visual_depth_4;
  if(!(visual == ((struct anonymous_5 *)NULL)))
  {
    _Bool tmp_if_expr_5;
    if(color_only == 0)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_visual_depth_4=visual_depth(screen, visual);
      tmp_if_expr_5 = return_value_visual_depth_4 > 1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_5)
      return visual;

  }

  visual=pick_best_visual_of_class(screen, 5);
  signed int return_value_visual_depth_6;
  if(!(visual == ((struct anonymous_5 *)NULL)))
  {
    _Bool tmp_if_expr_7;
    if(color_only == 0)
      tmp_if_expr_7 = (_Bool)1;

    else
    {
      return_value_visual_depth_6=visual_depth(screen, visual);
      tmp_if_expr_7 = return_value_visual_depth_6 > 1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_7)
      return visual;

  }

  visual=pick_best_visual_of_class(screen, 2);
  signed int return_value_visual_depth_8;
  if(!(visual == ((struct anonymous_5 *)NULL)))
  {
    _Bool tmp_if_expr_9;
    if(color_only == 0)
      tmp_if_expr_9 = (_Bool)1;

    else
    {
      return_value_visual_depth_8=visual_depth(screen, visual);
      tmp_if_expr_9 = return_value_visual_depth_8 > 1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_9)
      return visual;

  }

  signed int return_value_visual_depth_10;
  signed int return_value_visual_depth_12;
  if(color_only == 0)
  {
    visual=pick_best_visual_of_class(screen, 1);
    if(!(visual == ((struct anonymous_5 *)NULL)))
    {
      _Bool tmp_if_expr_11;
      if(color_only == 0)
        tmp_if_expr_11 = (_Bool)1;

      else
      {
        return_value_visual_depth_10=visual_depth(screen, visual);
        tmp_if_expr_11 = return_value_visual_depth_10 > 1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_11)
        return visual;

    }

    visual=pick_best_visual_of_class(screen, 0);
    if(!(visual == ((struct anonymous_5 *)NULL)))
    {
      _Bool tmp_if_expr_13;
      if(color_only == 0)
        tmp_if_expr_13 = (_Bool)1;

      else
      {
        return_value_visual_depth_12=visual_depth(screen, visual);
        tmp_if_expr_13 = return_value_visual_depth_12 > 1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_13)
        return visual;

    }

  }

  visual = screen->root_visual;
  _Bool tmp_if_expr_15;
  signed int return_value_visual_depth_14;
  if(color_only == 0)
    tmp_if_expr_15 = (_Bool)1;

  else
  {
    return_value_visual_depth_14=visual_depth(screen, visual);
    tmp_if_expr_15 = return_value_visual_depth_14 > 1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_15)
    return visual;

  else
    return ((struct anonymous_5 *)NULL);
}

// pick_best_visual_of_class
// file visual.c line 242
static struct anonymous_5 * pick_best_visual_of_class(struct anonymous_9 *screen, signed int visual_class)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_3 vi_in;
  struct anonymous_3 *vi_out;
  signed int out_count;
  vi_in.class = visual_class;
  vi_in.screen=screen_number(screen);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x8 | 0x2), &vi_in, &out_count);
  _Bool tmp_if_expr_1;
  if(!(vi_out == ((struct anonymous_3 *)NULL)))
  {
    signed int i;
    signed int best;
    struct anonymous_5 *visual;
    i = out_count - 1;
    best = i;
    for( ; i >= 0; i = i - 1)
    {
      _Bool tmp_if_expr_2;
      if(!((vi_out + (signed long int)best)->depth >= (vi_out + (signed long int)i)->depth))
        tmp_if_expr_2 = (_Bool)1;

      else
      {
        if((vi_out + (signed long int)i)->depth == (vi_out + (signed long int)best)->depth)
          tmp_if_expr_1 = (vi_out + (signed long int)i)->colormap_size > (vi_out + (signed long int)best)->colormap_size ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_2)
        best = i;

    }
    struct anonymous_5 *tmp_if_expr_3;
    if(!(best >= out_count))
      tmp_if_expr_3 = (vi_out + (signed long int)best)->visual;

    else
      tmp_if_expr_3 = ((struct anonymous_5 *)NULL);
    visual = tmp_if_expr_3;
    XFree((void *)(char *)vi_out);
    return visual;
  }

  else
    return ((struct anonymous_5 *)NULL);
}

// pick_mono_visual
// file visual.c line 218
static struct anonymous_5 * pick_mono_visual(struct anonymous_9 *screen)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_3 vi_in;
  struct anonymous_3 *vi_out;
  signed int out_count;
  vi_in.depth = 1;
  vi_in.screen=screen_number(screen);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x4 | 0x2), &vi_in, &out_count);
  if(!(vi_out == ((struct anonymous_3 *)NULL)))
  {
    struct anonymous_5 *v;
    struct anonymous_5 *tmp_if_expr_1;
    if(out_count >= 1)
      tmp_if_expr_1 = (vi_out + (signed long int)0)->visual;

    else
      tmp_if_expr_1 = ((struct anonymous_5 *)NULL);
    v = tmp_if_expr_1;
    if(!(v == ((struct anonymous_5 *)NULL)))
    {
      if(!(vi_out->depth == 1))
        v = ((struct anonymous_5 *)NULL);

    }

    XFree((void *)(char *)vi_out);
    return v;
  }

  else
    return ((struct anonymous_5 *)NULL);
}

// pick_visual
// file screenhack.c line 321
static struct anonymous_5 * pick_visual(struct anonymous_9 *screen)
{
  struct xscreensaver_function_table *ft = xscreensaver_function_table;
  if(!(ft->pick_visual_hook == ((struct anonymous_5 * (*)(struct anonymous_9 *))NULL)))
  {
    struct anonymous_5 *v;
    v=ft->pick_visual_hook(screen);
    if(!(v == ((struct anonymous_5 *)NULL)))
      return v;

  }

  struct anonymous_5 *return_value_get_visual_resource_1;
  return_value_get_visual_resource_1=get_visual_resource(screen, "visualID", "VisualID", 0);
  return return_value_get_visual_resource_1;
}

// print_loading_msg
// file grabclient.c line 879
static void print_loading_msg(struct anonymous_9 *screen, unsigned long int window)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_16 xgwa;
  struct anonymous_58 gcv;
  struct anonymous_59 *f = ((struct anonymous_59 *)NULL);
  struct _XGC *gc;
  char *fn;
  fn=get_string_resource(dpy, "labelFont", "Font");
  const char *text = "Loading...";
  signed int w;
  if(fn == ((char *)NULL))
    fn=get_string_resource(dpy, "titleFont", "Font");

  if(fn == ((char *)NULL))
    fn=get_string_resource(dpy, "font", "Font");

  if(fn == ((char *)NULL))
    fn=strdup("-*-times-bold-r-normal-*-180-*");

  f=XLoadQueryFont(dpy, fn);
  if(f == ((struct anonymous_59 *)NULL))
    f=XLoadQueryFont(dpy, "fixed");

  if(f == ((struct anonymous_59 *)NULL))
    abort();

  free((void *)fn);
  fn = ((char *)NULL);
  XGetWindowAttributes(dpy, window, &xgwa);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(text);
  w=XTextWidth(f, text, (signed int)return_value_strlen_1);
  unsigned int return_value_get_pixel_resource_2;
  return_value_get_pixel_resource_2=get_pixel_resource(dpy, xgwa.colormap, "foreground", "Foreground");
  gcv.foreground = (unsigned long int)return_value_get_pixel_resource_2;
  unsigned int return_value_get_pixel_resource_3;
  return_value_get_pixel_resource_3=get_pixel_resource(dpy, xgwa.colormap, "background", "Background");
  gcv.background = (unsigned long int)return_value_get_pixel_resource_3;
  gcv.font = f->fid;
  gc=XCreateGC(dpy, window, (unsigned long int)(1L << 14 | 1L << 2 | 1L << 3), &gcv);
  unsigned long int return_value_strlen_4;
  return_value_strlen_4=strlen(text);
  XDrawImageString(dpy, window, gc, (xgwa.width - w) / 2, (xgwa.height - (f->ascent + f->descent)) / 2 + f->ascent, text, (signed int)return_value_strlen_4);
  XFreeFont(dpy, f);
  XFreeGC(dpy, gc);
  XSync(dpy, 0);
}

// puramp
// file analogtv.c line 119
static float puramp(const struct analogtv_s *it, float tc, float start, float over)
{
  float pt = it->powerup - start;
  float ret;
  if(pt < 0.0f)
    return 0.0f;

  else
    if(pt / tc > 8.0f || pt > 900.0f)
      return 1.0f;

    else
    {
      float return_value_expf_1;
      return_value_expf_1=expf(-pt / tc);
      ret = (1.0f - return_value_expf_1) * over;
      if(ret > 1.0f)
        return 1.0f;

      else
        return ret * ret;
    }
}

// relaunch_generator_timer
// file textclient.c line 237
static void relaunch_generator_timer(void *closure, unsigned long int *id)
{
  struct text_data *d = (struct text_data *)closure;
  d->pipe_timer = (unsigned long int)0;
  launch_text_generator(d);
}

// rnd_combine
// file analogtv.c line 1184
static void rnd_combine(unsigned int *a0, unsigned int *c0, unsigned int a1, unsigned int c1)
{
  *a0 = *a0 * a1 & 0xffffffffu;
  *c0 = c1 + a1 * *c0 & 0xffffffffu;
}

// rnd_seek
// file analogtv.c line 1204
static unsigned int rnd_seek(unsigned int a, unsigned int c, unsigned int rnd, unsigned int dist)
{
  rnd_seek_ac(&a, &c, dist);
  return a * rnd + c;
}

// rnd_seek_ac
// file analogtv.c line 1190
static void rnd_seek_ac(unsigned int *a, unsigned int *c, unsigned int dist)
{
  unsigned int a1 = *a;
  unsigned int c1 = *c;
  *a = (unsigned int)1;
  *c = (unsigned int)0;
  while(!(dist == 0u))
  {
    if(!((1u & dist) == 0u))
      rnd_combine(a, c, a1, c1);

    dist = dist >> 1;
    rnd_combine(&a1, &c1, a1, c1);
  }
}

// run_screenhack_table
// file screenhack.c line 536
static void run_screenhack_table(struct _XDisplay *dpy, unsigned long int window, unsigned long int window2, struct xscreensaver_function_table *ft)
{
  void * (*init_cb)(struct _XDisplay *, unsigned long int, void *) = (void * (*)(struct _XDisplay *, unsigned long int, void *))ft->init_cb;
  void (*fps_cb)(struct _XDisplay *, unsigned long int, struct fps_state *, void *) = ft->fps_cb;
  void *closure;
  closure=init_cb(dpy, window, ft->setup_arg);
  struct fps_state *fpst;
  fpst=fps_init(dpy, window);
  void *closure2 = NULL;
  struct fps_state *fpst2 = ((struct fps_state *)NULL);
  if(!(window2 == 0ul))
    closure2=init_cb(dpy, window2, ft->setup_arg);

  if(!(window2 == 0ul))
    fpst2=fps_init(dpy, window2);

  if(closure == NULL)
    abort();

  if(fps_cb == ((void (*)(struct _XDisplay *, unsigned long int, struct fps_state *, void *))NULL))
    fps_cb = screenhack_do_fps;

  {
    unsigned long int delay;
    delay=ft->draw_cb(dpy, window, closure);
    unsigned long int delay2 = (unsigned long int)0;
    if(!(window2 == 0ul))
      delay2=ft->draw_cb(dpy, window2, closure2);

    if(!(fpst == ((struct fps_state *)NULL)))
      fps_cb(dpy, window, fpst, closure);

    if(!(fpst2 == ((struct fps_state *)NULL)))
      fps_cb(dpy, window, fpst2, closure);

    char return_value_usleep_and_process_events_1;
    return_value_usleep_and_process_events_1=usleep_and_process_events(dpy, ft, window, fpst, closure, delay, window2, fpst2, closure2, delay2);
  }
  ft->free_cb(dpy, window, closure);
  if(!(fpst == ((struct fps_state *)NULL)))
    fps_free(fpst);

  if(!(window2 == 0ul))
    ft->free_cb(dpy, window2, closure2);

  if(!(fpst2 == ((struct fps_state *)NULL)))
    fps_free(fpst2);

}

// scale_image
// file apple2-main.c line 82
static void scale_image(struct _XDisplay *dpy, unsigned long int window, struct _XImage *in, signed int fromx, signed int fromy, signed int fromw, signed int fromh, unsigned int *out, signed int w, signed int h)
{
  float scale;
  signed int x;
  signed int y;
  signed int i;
  unsigned int rpos = (unsigned int)0;
  unsigned int gpos = (unsigned int)0;
  unsigned int bpos = (unsigned int)0;
  unsigned int rsiz = (unsigned int)0;
  unsigned int gsiz = (unsigned int)0;
  unsigned int bsiz = (unsigned int)0;
  unsigned int rmsk = (unsigned int)0;
  unsigned int gmsk = (unsigned int)0;
  unsigned int bmsk = (unsigned int)0;
  unsigned char spread_map[3l][256l];
  struct anonymous_16 xgwa;
  struct anonymous_57 *colors = ((struct anonymous_57 *)NULL);
  _Bool tmp_if_expr_1;
  if(!(in->width >= fromw + fromx))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = fromy + fromh > in->height ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    abort();

  XGetWindowAttributes(dpy, window, &xgwa);
  signed int return_value_visual_class_3;
  return_value_visual_class_3=visual_class(xgwa.screen, xgwa.visual);
  _Bool tmp_if_expr_5;
  signed int return_value_visual_class_4;
  if(return_value_visual_class_3 == 3)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_visual_class_4=visual_class(xgwa.screen, xgwa.visual);
    tmp_if_expr_5 = return_value_visual_class_4 == 1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
  {
    signed int ncolors;
    ncolors=visual_cells(xgwa.screen, xgwa.visual);
    void *return_value_calloc_2;
    return_value_calloc_2=calloc(sizeof(struct anonymous_57) /*16ul*/ , (unsigned long int)(ncolors + 1));
    colors = (struct anonymous_57 *)return_value_calloc_2;
    i = 0;
    for( ; !(i >= ncolors); i = i + 1)
      (colors + (signed long int)i)->pixel = (unsigned long int)i;
    XQueryColors(dpy, xgwa.colormap, colors, ncolors);
  }

  else
  {
    rmsk = (unsigned int)xgwa.visual->red_mask;
    gmsk = (unsigned int)xgwa.visual->green_mask;
    bmsk = (unsigned int)xgwa.visual->blue_mask;
    decode_mask(rmsk, &rpos, &rsiz);
    decode_mask(gmsk, &gpos, &gsiz);
    decode_mask(bmsk, &bpos, &bsiz);
    i = 0;
    for( ; !(i >= 256); i = i + 1)
    {
      spread_map[(signed long int)0][(signed long int)i]=spread_bits((unsigned char)i, (unsigned char)rsiz);
      spread_map[(signed long int)1][(signed long int)i]=spread_bits((unsigned char)i, (unsigned char)gsiz);
      spread_map[(signed long int)2][(signed long int)i]=spread_bits((unsigned char)i, (unsigned char)bsiz);
    }
  }
  scale = fromw > fromh ? (float)fromw / (float)w : (float)fromh / (float)h;
  y = 0;
  unsigned long int return_value;
  for( ; !(y >= h + -1); y = y + 1)
  {
    x = 0;
    for( ; !(x >= w + -1); x = x + 1)
    {
      signed int xx;
      signed int yy;
      unsigned int r = (unsigned int)0;
      unsigned int g = (unsigned int)0;
      unsigned int b = (unsigned int)0;
      signed int xx1 = (signed int)((float)x * scale + (float)fromx);
      signed int yy1 = (signed int)((float)y * scale + (float)fromy);
      signed int xx2 = (signed int)((float)(x + 1) * scale + (float)fromx);
      signed int yy2 = (signed int)((float)(y + 1) * scale + (float)fromy);
      xx = xx1;
      for( ; !(xx >= xx2); xx = xx + 1)
      {
        yy = yy1;
        for( ; !(yy >= yy2); yy = yy + 1)
        {
          unsigned char rr;
          unsigned char gg;
          unsigned char bb;
          unsigned long int sp;
          _Bool tmp_if_expr_6;
          if(!(in->width >= xx))
            tmp_if_expr_6 = (_Bool)1;

          else
            tmp_if_expr_6 = yy > in->height ? (_Bool)1 : (_Bool)0;
          unsigned long int tmp_if_expr_7;
          if(tmp_if_expr_6)
            tmp_if_expr_7 = (unsigned long int)0;

          else
          {
            return_value=in->f.get_pixel(in, xx, yy);
            tmp_if_expr_7 = return_value;
          }
          sp = tmp_if_expr_7;
          if(!(colors == ((struct anonymous_57 *)NULL)))
          {
            rr = (unsigned char)((signed int)(colors + (signed long int)sp)->red & 0xFF);
            gg = (unsigned char)((signed int)(colors + (signed long int)sp)->green & 0xFF);
            bb = (unsigned char)((signed int)(colors + (signed long int)sp)->blue & 0xFF);
          }

          else
          {
            rr = (unsigned char)((sp & (unsigned long int)rmsk) >> rpos);
            gg = (unsigned char)((sp & (unsigned long int)gmsk) >> gpos);
            bb = (unsigned char)((sp & (unsigned long int)bmsk) >> bpos);
            rr = spread_map[(signed long int)0][(signed long int)rr];
            gg = spread_map[(signed long int)1][(signed long int)gg];
            bb = spread_map[(signed long int)2][(signed long int)bb];
          }
          r = r + (unsigned int)rr;
          g = g + (unsigned int)gg;
          b = b + (unsigned int)bb;
        }
      }
      i = (xx2 - xx1) * (yy2 - yy1);
      if(!(i >= 1))
        i = 1;

      r = r / (unsigned int)i;
      g = g / (unsigned int)i;
      b = b / (unsigned int)i;
      out[(signed long int)(y * w + x)] = r << 16 | g << 8 | b;
    }
  }
}

// screen_number
// file visual.c line 475
extern signed int screen_number(struct anonymous_9 *screen)
{
  struct _XDisplay *dpy = screen->display;
  signed int i = 0;
  for( ; !(i >= ((struct anonymous_63 *)dpy)->nscreens); i = i + 1)
    if(((struct anonymous_63 *)dpy)->screens + (signed long int)i == screen)
      return i;

  abort();
  return 0;
}

// screenhack_do_fps
// file screenhack.c line 528
static void screenhack_do_fps(struct _XDisplay *dpy, unsigned long int w, struct fps_state *fpst, void *closure)
{
  fps_compute(fpst, (unsigned long int)0, (double)-1);
  fps_draw(fpst);
}

// screenhack_ehandler
// file screenhack.c line 245
static signed int screenhack_ehandler(struct _XDisplay *dpy, struct anonymous_7 *error)
{
  fprintf(stderr, "\nX error in %s:\n", progname);
  signed int return_value_XmuPrintDefaultErrorMessage_1;
  return_value_XmuPrintDefaultErrorMessage_1=XmuPrintDefaultErrorMessage(dpy, error, stderr);
  if(!(return_value_XmuPrintDefaultErrorMessage_1 == 0))
    exit(-1);

  else
    fprintf(stderr, " (nonfatal.)\n");
  return 0;
}

// screenhack_event_helper
// file resources.c line 276
extern signed int screenhack_event_helper(struct _XDisplay *dpy, unsigned long int window, union _XEvent *event)
{
  if(event->xany.type == 2)
  {
    unsigned long int keysym;
    char c = (char)0;
    XLookupString(&event->xkey, &c, 1, &keysym, ((struct _XComposeStatus *)NULL));
    if(keysym == 65361ul || keysym == 65362ul || keysym == 65363ul || keysym == 65364ul || keysym == 65365ul || keysym == 65366ul || (signed int)c == 9 || (signed int)c == 10 || (signed int)c == 13 || (signed int)c == 32)
      return 1;

  }

  else
    if(event->xany.type == 4)
    {
      if(event->xbutton.button == 1u)
        return 1;

    }

  return 0;
}

// screenhack_handle_event_1
// file screenhack.c line 270
static signed int screenhack_handle_event_1(struct _XDisplay *dpy, union _XEvent *event)
{
  switch(event->xany.type)
  {
    case 2:
    {
      unsigned long int keysym;
      char c = (char)0;
      XLookupString(&event->xkey, &c, 1, &keysym, ((struct _XComposeStatus *)NULL));
      if((signed int)c == 3 || (signed int)c == 27 || (signed int)c == 81 || (signed int)c == 113)
        return 0;

      else
        if(!(keysym >= 65505ul) || keysym >= 65519ul)
          XBell(dpy, 0);

      goto __CPROVER_DUMP_L11;
    }
    case 4:
    {
      XBell(dpy, 0);
      goto __CPROVER_DUMP_L11;
    }
    case 33:
      if(!(event->xclient.message_type == XA_WM_PROTOCOLS))
      {
        char *s;
        s=XGetAtomName(dpy, event->xclient.message_type);
        if(s == ((char *)NULL))
          s = "(null)";

        fprintf(stderr, "%s: unknown ClientMessage %s received!\n", progname, s);
      }

      else
        if(!((unsigned long int)event->xclient.data.l[0l] == XA_WM_DELETE_WINDOW))
        {
          char *s1;
          s1=XGetAtomName(dpy, event->xclient.message_type);
          char *s2;
          s2=XGetAtomName(dpy, (unsigned long int)event->xclient.data.l[(signed long int)0]);
          if(s1 == ((char *)NULL))
            s1 = "(null)";

          if(s2 == ((char *)NULL))
            s2 = "(null)";

          fprintf(stderr, "%s: unknown ClientMessage %s[%s] received!\n", progname, s1, s2);
        }

        else
          return 0;
    default:
    {

    __CPROVER_DUMP_L11:
      ;
      return 1;
    }
  }
}

// screenhack_table_handle_events
// file screenhack.c line 433
static char screenhack_table_handle_events(struct _XDisplay *dpy, struct xscreensaver_function_table *ft, unsigned long int window, void *closure, unsigned long int window2, void *closure2)
{
  struct _XtAppStruct *app;
  app=XtDisplayToApplicationContext(dpy);
  unsigned long int return_value_XtAppPending_1;
  return_value_XtAppPending_1=XtAppPending(app);
  if(!((6ul & return_value_XtAppPending_1) == 0ul))
    XtAppProcessEvent(app, (unsigned long int)(2 | 4));

  signed int return_value_XPending_2;
  signed int tmp_if_expr_5;
  signed int return_value;
  signed int tmp_if_expr_4;
  signed int return_value_1;
  signed int return_value_screenhack_handle_event_1_3;
  do
  {
    return_value_XPending_2=XPending(dpy);
    if(return_value_XPending_2 == 0)
      break;

    union _XEvent event;
    XNextEvent(dpy, &event);
    if(event.xany.type == 22)
    {
      if(event.xany.window == window)
        ft->reshape_cb(dpy, window, closure, (unsigned int)event.xconfigure.width, (unsigned int)event.xconfigure.height);

      if(event.xany.window == window2 && !(window2 == 0ul))
        ft->reshape_cb(dpy, window2, closure2, (unsigned int)event.xconfigure.width, (unsigned int)event.xconfigure.height);

    }

    else
    {
      _Bool tmp_if_expr_6;
      if(event.xany.type == 33)
        tmp_if_expr_6 = (_Bool)1;

      else
      {
        if(event.xany.window == window)
        {
          return_value=ft->event_cb(dpy, window, closure, &event);
          tmp_if_expr_5 = return_value;
        }

        else
        {
          if(event.xany.window == window2 && !(window2 == 0ul))
          {
            return_value_1=ft->event_cb(dpy, window2, closure2, &event);
            tmp_if_expr_4 = return_value_1;
          }

          else
            tmp_if_expr_4 = 0;
          tmp_if_expr_5 = tmp_if_expr_4;
        }
        tmp_if_expr_6 = !(tmp_if_expr_5 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_6)
      {
        return_value_screenhack_handle_event_1_3=screenhack_handle_event_1(dpy, &event);
        if(return_value_screenhack_handle_event_1_3 == 0)
          return (char)0;

      }

    }
    unsigned long int return_value_XtAppPending_7;
    return_value_XtAppPending_7=XtAppPending(app);
    if(!((6ul & return_value_XtAppPending_7) == 0ul))
      XtAppProcessEvent(app, (unsigned long int)(2 | 4));

  }
  while((_Bool)1);
  return (char)1;
}

// screenhack_usleep
// file ./../utils/usleep.h line 23
extern void screenhack_usleep(unsigned long int usecs)
{
  struct timeval tv;
  tv.tv_sec = (signed long int)(usecs / (unsigned long int)1000000L);
  tv.tv_usec = (signed long int)(usecs % (unsigned long int)1000000L);
  select(0, ((struct anonymous_6 *)NULL), ((struct anonymous_6 *)NULL), ((struct anonymous_6 *)NULL), &tv);
}

// shm_ehandler
// file xshm.c line 62
static signed int shm_ehandler(struct _XDisplay *dpy, struct anonymous_7 *error)
{
  shm_got_x_error = 1;
  return 0;
}

// slideshow_controller
// file apple2-main.c line 609
static void slideshow_controller(struct apple2_sim_s *sim, signed int *stepno, double *next_actiontime)
{
  struct apple2_state *st = sim->st;
  signed int i;
  struct slideshow_data_s *mine;
  if(sim->controller_data == NULL)
    sim->controller_data=calloc((unsigned long int)1, sizeof(struct slideshow_data_s) /*32ul*/ );

  mine = (struct slideshow_data_s *)sim->controller_data;
  _Bool tmp_if_expr_4;
  switch(*stepno)
  {
    case 0:
    {
      a2_invalidate(st);
      a2_clear_hgr(st);
      a2_cls(st);
      sim->typing_rate = 0.3;
      sim->dec->powerup = (float)0.0;
      a2_goto(st, 0, 16);
      a2_prints(st, "APPLE ][");
      a2_goto(st, 23, 0);
      a2_printc(st, (char)93);
      *stepno = 10;
      goto __CPROVER_DUMP_L40;
    }
    case 10:
    {
      struct anonymous_16 xgwa;
      unsigned long int p;
      XGetWindowAttributes(sim->dpy, sim->window, &xgwa);
      p=XCreatePixmap(sim->dpy, sim->window, (unsigned int)xgwa.width, (unsigned int)xgwa.height, (unsigned int)xgwa.depth);
      mine->image_loading_p = 1;
      load_image_async(xgwa.screen, sim->window, p, image_loaded_cb, (void *)sim);
      *next_actiontime = *next_actiontime + 2.0;
      *stepno = 11;
      goto __CPROVER_DUMP_L40;
    }
    case 11:
    {
      if(mine->image_loading_p == 0)
      {
        if(!(st->gr_mode == /*enum*/0))
          *stepno = 30;

        else
          *stepno = 20;
        *next_actiontime = *next_actiontime + 3.0;
      }

      goto __CPROVER_DUMP_L40;
    }
    case 20:
    {
      sim->typing = "HGR\n";
      *stepno = 29;
      goto __CPROVER_DUMP_L40;
    }
    case 29:
    {
      sim->printing = "]";
      *stepno = 30;
      goto __CPROVER_DUMP_L40;
    }
    case 30:
    {
      st->gr_mode = (enum anonymous_53)A2_GR_HIRES;
      if(!(mine->img_filename == ((char *)NULL)))
      {
        char *basename;
        char *tmp;
        char *s;
        tmp=strdup(mine->img_filename);
        basename = tmp;
        while((_Bool)1)
        {
          char *slash;
          slash=strchr(basename, 47);
          _Bool tmp_if_expr_1;
          if(slash == ((char *)NULL))
            tmp_if_expr_1 = (_Bool)1;

          else
            tmp_if_expr_1 = !(slash[(signed long int)1] != 0) ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_1)
            break;

          basename = slash + (signed long int)1;
        }
        char *dot;
        dot=strrchr(basename, 46);
        if(!(dot == ((char *)NULL)))
          *dot = (char)0;

        unsigned long int return_value_strlen_2;
        return_value_strlen_2=strlen(basename);
        if(return_value_strlen_2 >= 21ul)
          basename[(signed long int)20] = (char)0;

        s = basename;
        for( ; !(*s == 0); s = s + 1l)
        {
          signed int return_value_toupper_3;
          return_value_toupper_3=toupper((signed int)*s);
          *s = (char)return_value_toupper_3;
          if(!((signed int)*s >= 33))
            *s = (char)95;

        }
        sprintf(sim->typing_buf, "BLOAD %s\n", basename);
        sim->typing = sim->typing_buf;
        free((void *)tmp);
      }

      else
        sim->typing = "BLOAD IMAGE\n";
      mine->render_img_lineno = 0;
      *stepno = 35;
      goto __CPROVER_DUMP_L40;
    }
    case 35:
    {
      *next_actiontime = *next_actiontime + 0.7;
      *stepno = 40;
      goto __CPROVER_DUMP_L40;
    }
    case 40:
    {
      if(mine->render_img_lineno >= 192)
      {
        sim->printing = "]";
        sim->typing = "POKE 49234,0\n";
        *stepno = 50;
        break;
      }

      i = 0;
      do
      {
        if(!(i >= 6))
          tmp_if_expr_4 = mine->render_img_lineno < 192 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        if(!tmp_if_expr_4)
          break;

        signed int tmp_post_5 = mine->render_img_lineno;
        mine->render_img_lineno = mine->render_img_lineno + 1;
        a2_display_image_loading(st, mine->render_img, tmp_post_5);
        i = i + 1;
      }
      while((_Bool)1);
      if(mine->render_img_lineno % 78 == 0)
        *next_actiontime = *next_actiontime + 0.5;

      else
        *next_actiontime = *next_actiontime + 0.08;
      goto __CPROVER_DUMP_L40;
    }
    case 50:
    {
      st->gr_mode = st->gr_mode | (enum anonymous_53)A2_GR_FULL;
      *stepno = 60;
      *next_actiontime = *next_actiontime + (double)2;
      goto __CPROVER_DUMP_L40;
    }
    case 60:
    {
      sim->printing = "]";
      sim->typing = "POKE 49235,0\n";
      *stepno = 70;
      goto __CPROVER_DUMP_L40;
    }
    case 70:
    {
      sim->printing = "]";
      st->gr_mode = st->gr_mode & (enum anonymous_53)~A2_GR_FULL;
      if(!(mine->render_img == ((unsigned char *)NULL)))
      {
        free((void *)mine->render_img);
        mine->render_img = (unsigned char *)(void *)0;
      }

      if(!(mine->img_filename == ((char *)NULL)))
      {
        free((void *)mine->img_filename);
        mine->img_filename = (char *)(void *)0;
      }

      *stepno = 10;
      goto __CPROVER_DUMP_L40;
    }
    case 80:
    {
      *next_actiontime = *next_actiontime + 2.0;
      *stepno = -2;
      goto __CPROVER_DUMP_L40;
    }
    case -2:
      if(!(mine->image_loading_p == 0))
        *stepno = 80;

      else
      {
        free((void *)mine->render_img);
        free((void *)mine->img_filename);
        free((void *)mine);
        mine = ((struct slideshow_data_s *)NULL);
        break;
      }
    default:

      __CPROVER_DUMP_L40:
        ;
  }
}

// spread_bits
// file apple2-main.c line 62
static unsigned char spread_bits(unsigned char value, unsigned char width)
{
  switch((signed int)width)
  {
    case 8:
      return value;
    case 7:
      return (unsigned char)((signed int)value << 1 | (signed int)value >> 6);
    case 6:
      return (unsigned char)((signed int)value << 2 | (signed int)value >> 4);
    case 5:
      return (unsigned char)((signed int)value << 3 | (signed int)value >> 2);
    case 4:
      return (unsigned char)((signed int)value << 4 | (signed int)value);
    case 3:
      return (unsigned char)((signed int)value << 5 | (signed int)value << 2 | (signed int)value >> 2);
    case 2:
      return (unsigned char)((signed int)value << 6 | (signed int)value << 4 | (signed int)value);
    default:
      abort();
  }
}

// start_timer
// file textclient.c line 250
static void start_timer(struct text_data *d)
{
  struct _XtAppStruct *app;
  app=XtDisplayToApplicationContext(d->dpy);
  if(!(d->pipe_timer == 0ul))
    XtRemoveTimeOut(d->pipe_timer);

  d->pipe_timer=XtAppAddTimeOut(app, d->subproc_relaunch_delay, relaunch_generator_timer, (void *)d);
}

// string_width
// file fps.c line 175
static signed int string_width(struct anonymous_59 *f, const char *c, signed int *height_ret)
{
  signed int x = 0;
  signed int max_w = 0;
  signed int h = f->ascent + f->descent;
  while(!(*c == 0))
  {
    signed int cc = (signed int)*((unsigned char *)c);
    if((signed int)*c == 10)
    {
      if(!(max_w >= x))
        max_w = x;

      x = 0;
      h = h + f->ascent + f->descent;
    }

    else
    {
      signed int tmp_if_expr_1;
      if(!(f->per_char == ((struct anonymous_0 *)NULL)))
        tmp_if_expr_1 = (signed int)(f->per_char + (signed long int)((unsigned int)cc - f->min_char_or_byte2))->width;

      else
        tmp_if_expr_1 = (signed int)f->min_bounds.rbearing;
      x = x + tmp_if_expr_1;
    }
    c = c + 1l;
  }
  if(!(max_w >= x))
    max_w = x;

  if(!(height_ret == ((signed int *)NULL)))
    *height_ret = h;

  return max_w;
}

// subproc_cb
// file textclient.c line 85
static void subproc_cb(void *closure, signed int *source, unsigned long int *id)
{
  struct text_data *d = (struct text_data *)closure;
  d->input_available_p = 1;
}

// terminal_closegen
// file apple2-main.c line 823
static void terminal_closegen(struct terminal_controller_data *mine)
{
  if(!(mine->tc == ((struct text_data *)NULL)))
  {
    textclient_close(mine->tc);
    mine->tc = ((struct text_data *)NULL);
  }

}

// terminal_controller
// file apple2-main.c line 1336
static void terminal_controller(struct apple2_sim_s *sim, signed int *stepno, double *next_actiontime)
{
  struct apple2_state *st = sim->st;
  signed int c;
  signed int i;
  struct terminal_controller_data *mine;
  if(sim->controller_data == NULL)
    sim->controller_data=calloc(sizeof(struct terminal_controller_data) /*400ul*/ , (unsigned long int)1);

  mine = (struct terminal_controller_data *)sim->controller_data;
  mine->dpy = sim->dpy;
  mine->fast_p = global_fast_p;
  unsigned int return_value_ya_random_1;
  switch(*stepno)
  {
    case 0:
    {
      return_value_ya_random_1=ya_random();
      if(!(return_value_ya_random_1 % 2u == 0u))
        st->gr_mode = st->gr_mode | (enum anonymous_53)A2_GR_FULL;

      a2_cls(st);
      a2_goto(st, 0, 16);
      a2_prints(st, "APPLE ][");
      a2_goto(st, 2, 0);
      mine->cursor_y = 2;
      if(mine->tc == ((struct text_data *)NULL))
      {
        mine->tc=textclient_open(mine->dpy);
        textclient_reshape(mine->tc, 40, 24, 40, 24, 0);
      }

      if(mine->fast_p == 0)
        *next_actiontime = *next_actiontime + 4.0;

      *stepno = 10;
      mine->last_emit_time = sim->curtime;
      goto __CPROVER_DUMP_L16;
    }
    case 10:

    case 11:
    {
      signed int first_line_p = (signed int)(*stepno == 10);
      unsigned char buf[1024l];
      signed int nr;
      signed int nwant;
      double elapsed = sim->curtime - mine->last_emit_time;
      nwant = (signed int)(elapsed * 25.0);
      if(!(first_line_p == 0))
      {
        *stepno = 11;
        nwant = 1;
      }

      if(nwant >= 41)
        nwant = 40;

      if(!(mine->fast_p == 0))
        nwant = (signed int)(sizeof(unsigned char [1024l]) /*1024ul*/  - (unsigned long int)1);

      if(!(nwant >= 1))
        goto __CPROVER_DUMP_L16;

      mine->last_emit_time = sim->curtime;
      nr=terminal_read(mine, buf, nwant);
      i = 0;
      for( ; !(i >= nr); i = i + 1)
      {
        c = (signed int)buf[(signed long int)i];
        if(!(mine->tc == ((struct text_data *)NULL)))
          a2_vt100_printc(sim, mine, (unsigned char)c);

        else
          a2_ascii_printc(st, (unsigned char)c, 0, 0, 0, 1);
      }
      goto __CPROVER_DUMP_L16;
    }
    case -2:
    {
      terminal_closegen(mine);
      free((void *)mine);
      mine = ((struct terminal_controller_data *)NULL);
      break;
    }
    default:

      __CPROVER_DUMP_L16:
        ;
  }
}

// terminal_keypress_handler
// file apple2-main.c line 851
static signed int terminal_keypress_handler(struct _XDisplay *dpy, union _XEvent *event, void *data)
{
  struct terminal_controller_data *mine = (struct terminal_controller_data *)data;
  mine->dpy = dpy;
  signed int return_value_textclient_putc_1;
  if(event->xany.type == 2)
  {
    if(!(mine->tc == ((struct text_data *)NULL)))
    {
      return_value_textclient_putc_1=textclient_putc(mine->tc, &event->xkey);
      return return_value_textclient_putc_1;
    }

  }

  return 0;
}

// terminal_read
// file apple2-main.c line 832
static signed int terminal_read(struct terminal_controller_data *mine, unsigned char *buf, signed int n)
{
  _Bool tmp_if_expr_1;
  if(mine == ((struct terminal_controller_data *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(mine->tc != ((struct text_data *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    return 0;

  else
  {
    signed int i;
    signed int count = 0;
    i = 0;
    for( ; !(i >= n); i = i + 1)
    {
      signed int c;
      c=textclient_getc(mine->tc);
      if(!(c >= 1))
        break;

      buf[(signed long int)i] = (unsigned char)c;
      mine->lastc = (unsigned char)c;
      count = count + 1;
    }
    return count;
  }
}

// textclient_close
// file ./../utils/textclient.h line 24
extern void textclient_close(struct text_data *d)
{
  close_pipe(d);
  if(!(d->program == ((char *)NULL)))
    free((void *)d->program);

  if(!(d->pipe_timer == 0ul))
    XtRemoveTimeOut(d->pipe_timer);

  d->pipe_timer = (unsigned long int)0;
  memset((void *)d, 0, sizeof(struct text_data) /*136ul*/ );
  free((void *)d);
}

// textclient_getc
// file ./../utils/textclient.h line 29
extern signed int textclient_getc(struct text_data *d)
{
  struct _XtAppStruct *app;
  app=XtDisplayToApplicationContext(d->dpy);
  signed int ret = -1;
  unsigned long int return_value_XtAppPending_1;
  return_value_XtAppPending_1=XtAppPending(app);
  if(!((6ul & return_value_XtAppPending_1) == 0ul))
    XtAppProcessEvent(app, (unsigned long int)(2 | 4));

  _Bool tmp_if_expr_4;
  if(!(d->out_buffer == ((const char *)NULL)))
    tmp_if_expr_4 = *d->out_buffer != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_4 = (_Bool)0;
  if(tmp_if_expr_4)
  {
    ret = (signed int)*d->out_buffer;
    d->out_buffer = d->out_buffer + 1l;
  }

  else
    if(!(d->input_available_p == 0))
    {
      if(!(d->pipe == ((struct _IO_FILE *)NULL)))
      {
        unsigned char s[2l];
        signed int n;
        signed int return_value_fileno_2;
        return_value_fileno_2=fileno(d->pipe);
        signed long int return_value_read_3;
        return_value_read_3=read(return_value_fileno_2, (void *)s, (unsigned long int)1);
        n = (signed int)return_value_read_3;
        if(n >= 1)
          ret = (signed int)s[(signed long int)0];

        else
        {
          if(!(d->pid == 0))
          {
            waitpid(d->pid, (signed int *)(void *)0, 0);
            d->pid = 0;
          }

          close_pipe(d);
          if(d->out_column >= 1)
            d->out_buffer = "\r\n\r\n";

          start_timer(d);
        }
        d->input_available_p = 0;
      }

    }

  if(ret == 10 || ret == 13)
    d->out_column = 0;

  else
    if(ret >= 1)
      d->out_column = d->out_column + 1;

  return ret;
}

// textclient_open
// file ./../utils/textclient.h line 23
extern struct text_data * textclient_open(struct _XDisplay *dpy)
{
  struct text_data *d;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct text_data) /*136ul*/ );
  d = (struct text_data *)return_value_calloc_1;
  d->dpy = dpy;
  signed int return_value_get_boolean_resource_2;
  return_value_get_boolean_resource_2=get_boolean_resource(dpy, "usePty", "UsePty");
  if(!(return_value_get_boolean_resource_2 == 0))
    d->pty_p = 1;

  signed int return_value_get_integer_resource_3;
  return_value_get_integer_resource_3=get_integer_resource(dpy, "relaunchDelay", "Time");
  d->subproc_relaunch_delay = (unsigned long int)return_value_get_integer_resource_3;
  if(!(d->subproc_relaunch_delay >= 1ul))
    d->subproc_relaunch_delay = (unsigned long int)1;

  d->subproc_relaunch_delay = d->subproc_relaunch_delay * (unsigned long int)1000;
  d->meta_sends_esc_p=get_boolean_resource(dpy, "metaSendsESC", "Boolean");
  d->swap_bs_del_p=get_boolean_resource(dpy, "swapBSDEL", "Boolean");
  d->program=get_string_resource(dpy, "program", "Program");
  const char *s;
  s=getenv("XSCREENSAVER_STANDALONE");
  signed int return_value_strcmp_5;
  if(!(s == ((const char *)NULL)))
  {
    if(!(*s == 0))
    {
      return_value_strcmp_5=strcmp(s, "0");
      if(!(return_value_strcmp_5 == 0))
      {
        d->pty_p = 1;
        char *return_value_getenv_4;
        return_value_getenv_4=getenv("SHELL");
        d->program=strdup(return_value_getenv_4);
      }

    }

  }

  start_timer(d);
  return d;
}

// textclient_putc
// file ./../utils/textclient.h line 30
extern signed int textclient_putc(struct text_data *d, struct anonymous_26 *k)
{
  unsigned long int keysym;
  unsigned char c = (unsigned char)0;
  XLookupString(k, (char *)&c, 1, &keysym, &d->compose);
  if(!((signed int)c == 0))
  {
    if(!(d->pipe == ((struct _IO_FILE *)NULL)))
    {
      if(!(d->swap_bs_del_p == 0))
      {
        if((signed int)c == 127)
          c = (unsigned char)8;

        else
          if((signed int)c == 8)
            c = (unsigned char)127;

      }

      unsigned int return_value_meta_modifier_1;
      return_value_meta_modifier_1=meta_modifier(d);
      if(!((k->state & return_value_meta_modifier_1) == 0u))
      {
        if(!(d->meta_sends_esc_p == 0))
          fputc(27, d->pipe);

        else
          c = c | (unsigned char)0x80;
      }

      fputc((signed int)c, d->pipe);
      fflush(d->pipe);
      k->type = 0;
      return 1;
    }

  }

  return 0;
}

// textclient_reshape
// file ./../utils/textclient.h line 25
extern void textclient_reshape(struct text_data *d, signed int pix_w, signed int pix_h, signed int char_w, signed int char_h, signed int max_lines)
{
  d->pix_w = pix_w;
  d->pix_h = pix_h;
  d->char_w = char_w;
  d->char_h = char_h;
  d->max_lines = max_lines;
  if(!(d->pid == 0))
  {
    if(!(d->pipe == ((struct _IO_FILE *)NULL)))
    {
      struct winsize ws;
      ws.ws_col = (unsigned short int)char_w;
      ws.ws_row = (unsigned short int)char_h;
      ws.ws_xpixel = (unsigned short int)pix_w;
      ws.ws_ypixel = (unsigned short int)pix_h;
      signed int return_value_fileno_1;
      return_value_fileno_1=fileno(d->pipe);
      ioctl(return_value_fileno_1, (unsigned long int)0x5414, &ws);
      kill(d->pid, 28);
    }

  }

  signed int return_value_strcmp_2;
  return_value_strcmp_2=strcmp(d->program, "xscreensaver-text");
  if(return_value_strcmp_2 == 0)
  {
    close_pipe(d);
    d->input_available_p = 0;
    start_timer(d);
  }

}

// thread_memory_alignment
// file ./../utils/thread_util.h line 112
unsigned int thread_memory_alignment(struct _XDisplay *dpy)
{
  threads_available(dpy);
  return (unsigned int)_cache_line_size;
}

// threadpool_create
// file ./../utils/thread_util.h line 303
signed int threadpool_create(struct threadpool *self, struct threadpool_class *cls, struct _XDisplay *dpy, unsigned int count)
{
  threads_available(dpy);
  self->count = count;
  /* assertion cls */
  assert(cls != ((struct threadpool_class *)NULL));
  self->thread_size = cls->size;
  self->thread_destroy = cls->destroy;
  void *thread;
  unsigned int i;
  unsigned int count_serial;
  count_serial=_threadpool_count_serial(self);
  if(!(count_serial == 0u))
  {
    thread=malloc(cls->size * (unsigned long int)count_serial);
    if(thread == NULL)
      return 12;

  }

  else
    thread = (void *)0;
  self->serial_threads = thread;
  i = (unsigned int)0;
  if(!(i == count_serial))
  {
    signed int error;
    error=cls->create(thread, self, i);
    if(!(error == 0))
    {
      self->count = i;
      _serial_destroy(self);
      return error;
    }

    thread = (void *)((char *)thread + (signed long int)self->thread_size);
    i = i + 1u;
  }

  /* assertion _has_pthread */
  assert(_has_pthread != 0);
  signed int return_value_pthread_cond_wait_3;
  if(_has_pthread >= 0)
  {
    unsigned int count_parallel;
    count_parallel=_threadpool_count_parallel(self);
    self->mutex = mutex_initializer;
    self->cond = cond_initializer;
    self->parallel_pending = (unsigned int)0;
    self->parallel_unfinished = (unsigned int)0;
    if(count_parallel == 0u)
    {
      self->parallel_threads = (unsigned long int *)(void *)0;
      return 0;
    }

    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(unsigned long int) /*8ul*/  * (unsigned long int)count_parallel);
    self->parallel_threads = (unsigned long int *)return_value_malloc_1;
    if(self->parallel_threads == ((unsigned long int *)NULL))
      return 12;

    struct _parallel_startup_type startup;
    startup.parent = self;
    startup.thread_create = cls->create;
    startup.last_errno = 0;
    signed int return_value_pthread_mutex_lock_2;
    return_value_pthread_mutex_lock_2=pthread_mutex_lock(&self->mutex);
    /* assertion !(pthread_mutex_lock(&self->mutex)) */
    assert(!(return_value_pthread_mutex_lock_2 != 0));
    _add_next_thread(&startup);
    if(startup.last_errno == 0)
      while(!(self->parallel_unfinished == count_parallel))
      {
        if(self->parallel_threads == ((unsigned long int *)NULL))
          break;

        return_value_pthread_cond_wait_3=pthread_cond_wait(&self->cond, &self->mutex);
        /* assertion !(pthread_cond_wait(&self->cond, &self->mutex)) */
        assert(!(return_value_pthread_cond_wait_3 != 0));
      }

    if(!(startup.last_errno == 0))
      _unlock_and_destroy(self);

    else
    {
      self->parallel_unfinished = (unsigned int)0;
      signed int return_value_pthread_mutex_unlock_4;
      return_value_pthread_mutex_unlock_4=pthread_mutex_unlock(&self->mutex);
      /* assertion !(pthread_mutex_unlock(&self->mutex)) */
      assert(!(return_value_pthread_mutex_unlock_4 != 0));
    }
    return startup.last_errno;
  }

  return 0;
}

// threadpool_destroy
// file ./../utils/thread_util.h line 304
void threadpool_destroy(struct threadpool *self)
{
  if(_has_pthread >= 0)
  {
    signed int return_value_pthread_mutex_lock_1;
    return_value_pthread_mutex_lock_1=pthread_mutex_lock(&self->mutex);
    /* assertion !(pthread_mutex_lock(&self->mutex)) */
    assert(!(return_value_pthread_mutex_lock_1 != 0));
    _unlock_and_destroy(self);
    goto __CPROVER_DUMP_L2;
  }

  _serial_destroy(self);

__CPROVER_DUMP_L2:
  ;
}

// threadpool_run
// file ./../utils/thread_util.h line 306
void threadpool_run(struct threadpool *self, void (*func)(void *))
{
  if(_has_pthread >= 0)
  {
    unsigned int count;
    count=_threadpool_count_parallel(self);
    signed int return_value_pthread_mutex_lock_1;
    return_value_pthread_mutex_lock_1=pthread_mutex_lock(&self->mutex);
    /* assertion !(pthread_mutex_lock(&self->mutex)) */
    assert(!(return_value_pthread_mutex_lock_1 != 0));
    /* assertion !self->parallel_pending */
    assert(!(self->parallel_pending != 0u));
    /* assertion !self->parallel_unfinished */
    assert(!(self->parallel_unfinished != 0u));
    self->parallel_pending = count;
    self->parallel_unfinished = count;
    self->thread_run = func;
    signed int return_value_pthread_cond_broadcast_2;
    return_value_pthread_cond_broadcast_2=pthread_cond_broadcast(&self->cond);
    /* assertion !(pthread_cond_broadcast(&self->cond)) */
    assert(!(return_value_pthread_cond_broadcast_2 != 0));
    signed int return_value_pthread_mutex_unlock_3;
    return_value_pthread_mutex_unlock_3=pthread_mutex_unlock(&self->mutex);
    /* assertion !(pthread_mutex_unlock(&self->mutex)) */
    assert(!(return_value_pthread_mutex_unlock_3 != 0));
  }

  void *thread = self->serial_threads;
  unsigned int i;
  unsigned int threadpool_run__1__2__count;
  threadpool_run__1__2__count=_threadpool_count_serial(self);
  i = (unsigned int)0;
  if(!(i == threadpool_run__1__2__count))
  {
    func(thread);
    thread = (void *)((char *)thread + (signed long int)self->thread_size);
    i = i + 1u;
  }

}

// threadpool_wait
// file ./../utils/thread_util.h line 307
void threadpool_wait(struct threadpool *self)
{
  signed int return_value_pthread_cond_wait_2;
  if(_has_pthread >= 0)
  {
    signed int return_value_pthread_mutex_lock_1;
    return_value_pthread_mutex_lock_1=pthread_mutex_lock(&self->mutex);
    /* assertion !(pthread_mutex_lock(&self->mutex)) */
    assert(!(return_value_pthread_mutex_lock_1 != 0));
    while(!(self->parallel_unfinished == 0u))
    {
      return_value_pthread_cond_wait_2=pthread_cond_wait(&self->cond, &self->mutex);
      /* assertion !(pthread_cond_wait(&self->cond, &self->mutex)) */
      assert(!(return_value_pthread_cond_wait_2 != 0));
    }
    signed int return_value_pthread_mutex_unlock_3;
    return_value_pthread_mutex_unlock_3=pthread_mutex_unlock(&self->mutex);
    /* assertion !(pthread_mutex_unlock(&self->mutex)) */
    assert(!(return_value_pthread_mutex_unlock_3 != 0));
  }

}

// threads_available
// file thread_util.c line 291
signed int threads_available(struct _XDisplay *dpy)
{
  if(_has_pthread == 0)
  {
    _has_pthread = (signed int)200809L;
    if(_has_pthread >= 0)
    {
      signed int return_value_get_boolean_resource_2;
      return_value_get_boolean_resource_2=get_boolean_resource(dpy, "useThreads", "Boolean");
      if(!(return_value_get_boolean_resource_2 == 0))
      {
        unsigned int return_value__get_cache_line_size_1;
        return_value__get_cache_line_size_1=_get_cache_line_size();
        _cache_line_size = (signed int)return_value__get_cache_line_size_1;
        /* assertion _cache_line_size >= sizeof(void *) */
        assert((unsigned long int)_cache_line_size >= sizeof(void *) /*8ul*/ );
        /* assertion ((_cache_line_size) > 0 && !((_cache_line_size) & ((_cache_line_size) - 1))) */
        assert(_cache_line_size > 0 && !((_cache_line_size & _cache_line_size - 1) != 0));
      }

      else
        _has_pthread = -1;
    }

  }

  return _has_pthread;
}

// uc_truncate
// file utf8wc.c line 38
static unsigned long int uc_truncate(unsigned long int uc)
{
  uc = uc & (unsigned long int)0x7FFFFFFFL;
  if(uc >= 1114112ul)
    uc = (unsigned long int)0xFFFD;

  if(uc == 0ul)
    uc = (unsigned long int)0xFFFD;

  if(uc >= 55296ul && !(uc >= 57344ul))
    uc = (unsigned long int)0xFFFD;

  return uc;
}

// use_subwindow_mode_p
// file grabclient.c line 111
extern signed int use_subwindow_mode_p(struct anonymous_9 *screen, unsigned long int window)
{
  unsigned long int return_value_VirtualRootWindowOfScreen_2;
  return_value_VirtualRootWindowOfScreen_2=VirtualRootWindowOfScreen_link1(screen);
  signed int return_value_xscreensaver_window_p_1;
  if(!(window == return_value_VirtualRootWindowOfScreen_2))
    return 0;

  else
  {
    return_value_xscreensaver_window_p_1=xscreensaver_window_p(screen->display, window);
    if(!(return_value_xscreensaver_window_p_1 == 0))
      return 0;

    else
      return 1;
  }
}

// usleep_and_process_events
// file screenhack.c line 481
static char usleep_and_process_events(struct _XDisplay *dpy, struct xscreensaver_function_table *ft, unsigned long int window, struct fps_state *fpst, void *closure, unsigned long int delay, unsigned long int window2, struct fps_state *fpst2, void *closure2, unsigned long int delay2)
{
  do
  {
    unsigned long int quantum = (unsigned long int)33333;
    if(!(delay >= quantum))
      quantum = delay;

    delay = delay - quantum;
    XSync(dpy, 0);
    if(quantum >= 1ul)
    {
      screenhack_usleep(quantum);
      if(!(fpst == ((struct fps_state *)NULL)))
        fps_slept(fpst, quantum);

      if(!(fpst2 == ((struct fps_state *)NULL)))
        fps_slept(fpst2, quantum);

    }

    char return_value_screenhack_table_handle_events_1;
    return_value_screenhack_table_handle_events_1=screenhack_table_handle_events(dpy, ft, window, closure, window2, closure2);
    if(return_value_screenhack_table_handle_events_1 == 0)
      return (char)0;

  }
  while(delay >= 1ul);
  return (char)1;
}

// utf8_decode
// file utf8wc.c line 56
extern signed long int utf8_decode(const unsigned char *in, signed long int length, unsigned long int *unicode_ret)
{
  const unsigned char *start = in;
  const unsigned char *end = in + length;
  unsigned long int uc = (unsigned long int)0xFFFD;
  unsigned long int min = (unsigned long int)0;
  unsigned char c;
  if(length >= 1l)
  {
    const unsigned char *tmp_post_1 = in;
    in = in + 1l;
    c = *tmp_post_1;
    if((0xC0 & (signed int)c) == 0x80)
      uc = (unsigned long int)0xFFFD;

    else
      if((0x80 & (signed int)c) == 0)
        uc = (unsigned long int)((signed int)c & 0x7F);

      else
        if((0xE0 & (signed int)c) == 0xC0)
        {
          if(!(end >= in + 1l))
          {
            in = end;
            goto DONE;
          }

          min = (unsigned long int)(1 << 7);
          uc = (unsigned long int)(((signed int)c & 0x1F) << 6 | (signed int)in[(signed long int)0] & 0x3F);
          in = in + (signed long int)1;
        }

        else
          if((0xF0 & (signed int)c) == 0xE0)
          {
            if(!(end >= in + 2l))
            {
              in = end;
              goto DONE;
            }

            min = (unsigned long int)(1 << 11);
            uc = (unsigned long int)(((signed int)c & 0x0F) << 12 | ((signed int)in[(signed long int)0] & 0x3F) << 6 | (signed int)in[(signed long int)1] & 0x3F);
            in = in + (signed long int)2;
          }

          else
            if((0xF8 & (signed int)c) == 0xF0)
            {
              if(!(end >= in + 3l))
              {
                in = end;
                goto DONE;
              }

              min = (unsigned long int)(1 << 16);
              uc = (unsigned long int)(((signed int)c & 0x07) << 18 | ((signed int)in[(signed long int)0] & 0x3F) << 12 | ((signed int)in[(signed long int)1] & 0x3F) << 6 | (signed int)in[(signed long int)2] & 0x3F);
              in = in + (signed long int)3;
            }

            else
              if((0xFC & (signed int)c) == 0xF8)
              {
                if(!(end >= in + 4l))
                {
                  in = end;
                  goto DONE;
                }

                min = (unsigned long int)(1 << 21);
                uc = (unsigned long int)(((signed int)c & 0x03) << 24 | ((signed int)in[(signed long int)0] & 0x3F) << 18 | ((signed int)in[(signed long int)1] & 0x3F) << 12 | ((signed int)in[(signed long int)2] & 0x3F) << 6 | (signed int)in[(signed long int)3] & 0x3F);
                in = in + (signed long int)4;
              }

              else
                if((0xFE & (signed int)c) == 0xFC)
                {
                  if(!(end >= in + 5l))
                  {
                    in = end;
                    goto DONE;
                  }

                  min = (unsigned long int)(1 << 26);
                  uc = (unsigned long int)(((signed int)c & 0x01) << 30 | ((signed int)in[(signed long int)0] & 0x3F) << 24 | ((signed int)in[(signed long int)1] & 0x3F) << 18 | ((signed int)in[(signed long int)2] & 0x3F) << 12 | ((signed int)in[(signed long int)3] & 0x3F) << 6 | (signed int)in[(signed long int)4] & 0x3F);
                  in = in + (signed long int)5;
                }

                else
                  uc = (unsigned long int)0xFFFD;
  }


DONE:
  ;
  length = in - start;
  signed int i = 1;
  for( ; !((signed long int)i >= length); i = i + 1)
    if(!((0xC0 & (signed int)start[(signed long int)i]) == 0x80))
    {
      uc = (unsigned long int)0xFFFD;
      length = (signed long int)(i + 1);
      break;
    }

  if(!(uc >= min))
    uc = (unsigned long int)0xFFFD;

  uc=uc_truncate(uc);
  if(!(unicode_ret == ((unsigned long int *)NULL)))
    *unicode_ret = uc;

  return length;
}

// utf8_encode
// file utf8wc.c line 160
extern signed int utf8_encode(unsigned long int uc, char *out, signed long int length)
{
  const char *old = out;
  uc=uc_truncate(uc);
  if(length >= 1l && !(uc >= 128ul))
  {
    char *tmp_post_1 = out;
    out = out + 1l;
    *tmp_post_1 = (char)uc;
  }

  else
    if(length >= 2l && !(uc >= 2048ul))
    {
      char *tmp_post_2 = out;
      out = out + 1l;
      *tmp_post_2 = (char)((unsigned long int)0xC0 | uc >> 6 & (unsigned long int)0x1F);
      char *tmp_post_3 = out;
      out = out + 1l;
      *tmp_post_3 = (char)((unsigned long int)0x80 | uc & (unsigned long int)0x3F);
    }

    else
      if(length >= 3l && !(uc >= 65536ul))
      {
        char *tmp_post_4 = out;
        out = out + 1l;
        *tmp_post_4 = (char)((unsigned long int)0xE0 | uc >> 12 & (unsigned long int)0x0F);
        char *tmp_post_5 = out;
        out = out + 1l;
        *tmp_post_5 = (char)((unsigned long int)0x80 | uc >> 6 & (unsigned long int)0x3F);
        char *tmp_post_6 = out;
        out = out + 1l;
        *tmp_post_6 = (char)((unsigned long int)0x80 | uc & (unsigned long int)0x3F);
      }

      else
        if(length >= 4l && !(uc >= 2097152ul))
        {
          char *tmp_post_7 = out;
          out = out + 1l;
          *tmp_post_7 = (char)((unsigned long int)0xF0 | uc >> 18 & (unsigned long int)0x07);
          char *tmp_post_8 = out;
          out = out + 1l;
          *tmp_post_8 = (char)((unsigned long int)0x80 | uc >> 12 & (unsigned long int)0x3F);
          char *tmp_post_9 = out;
          out = out + 1l;
          *tmp_post_9 = (char)((unsigned long int)0x80 | uc >> 6 & (unsigned long int)0x3F);
          char *tmp_post_10 = out;
          out = out + 1l;
          *tmp_post_10 = (char)((unsigned long int)0x80 | uc & (unsigned long int)0x3F);
        }

        else
          if(length >= 5l && !(uc >= 67108864ul))
          {
            char *tmp_post_11 = out;
            out = out + 1l;
            *tmp_post_11 = (char)((unsigned long int)0xF8 | uc >> 24 & (unsigned long int)0x03);
            char *tmp_post_12 = out;
            out = out + 1l;
            *tmp_post_12 = (char)((unsigned long int)0x80 | uc >> 18 & (unsigned long int)0x3F);
            char *tmp_post_13 = out;
            out = out + 1l;
            *tmp_post_13 = (char)((unsigned long int)0x80 | uc >> 12 & (unsigned long int)0x3F);
            char *tmp_post_14 = out;
            out = out + 1l;
            *tmp_post_14 = (char)((unsigned long int)0x80 | uc >> 6 & (unsigned long int)0x3F);
            char *tmp_post_15 = out;
            out = out + 1l;
            *tmp_post_15 = (char)((unsigned long int)0x80 | uc & (unsigned long int)0x3F);
          }

          else
            if(length >= 6l)
            {
              char *tmp_post_16 = out;
              out = out + 1l;
              *tmp_post_16 = (char)((unsigned long int)0xFC | uc >> 30 & (unsigned long int)0x01);
              char *tmp_post_17 = out;
              out = out + 1l;
              *tmp_post_17 = (char)((unsigned long int)0x80 | uc >> 24 & (unsigned long int)0x3F);
              char *tmp_post_18 = out;
              out = out + 1l;
              *tmp_post_18 = (char)((unsigned long int)0x80 | uc >> 18 & (unsigned long int)0x3F);
              char *tmp_post_19 = out;
              out = out + 1l;
              *tmp_post_19 = (char)((unsigned long int)0x80 | uc >> 12 & (unsigned long int)0x3F);
              char *tmp_post_20 = out;
              out = out + 1l;
              *tmp_post_20 = (char)((unsigned long int)0x80 | uc >> 6 & (unsigned long int)0x3F);
              char *tmp_post_21 = out;
              out = out + 1l;
              *tmp_post_21 = (char)((unsigned long int)0x80 | uc & (unsigned long int)0x3F);
            }

  return (signed int)(out - old);
}

// utf8_split
// file utf8wc.c line 256
extern char ** utf8_split(const char *string, signed int *length_ret)
{
  const unsigned char *in = (const unsigned char *)string;
  signed long int len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(string);
  len = (signed long int)return_value_strlen_1;
  const unsigned char *end = in + len;
  char **ret;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(len + (signed long int)1) * sizeof(char *) /*8ul*/ );
  ret = (char **)return_value_malloc_2;
  signed int i = 0;
  if(ret == ((char **)NULL))
    return ((char **)NULL);

  else
  {
    while(!(in >= end))
    {
      unsigned long int uc;
      signed long int len2;
      len2=utf8_decode(in, len, &uc);
      char tmp[10l];
      strncpy(tmp, (char *)in, (unsigned long int)len2);
      tmp[len2] = (char)0;
      signed int tmp_post_3 = i;
      i = i + 1;
      ret[(signed long int)tmp_post_3]=strdup(tmp);
      in = in + len2;
      if(i >= 2 && uc >= 768ul && !(uc >= 880ul))
      {
        signed long int L1;
        unsigned long int return_value_strlen_4;
        return_value_strlen_4=strlen(ret[(signed long int)(i - 2)]);
        L1 = (signed long int)return_value_strlen_4;
        signed long int L2;
        unsigned long int return_value_strlen_5;
        return_value_strlen_5=strlen(ret[(signed long int)(i - 1)]);
        L2 = (signed long int)return_value_strlen_5;
        char *s2;
        void *return_value_malloc_6;
        return_value_malloc_6=malloc((unsigned long int)(L1 + L2 + (signed long int)1));
        s2 = (char *)return_value_malloc_6;
        strncpy(s2, ret[(signed long int)(i - 2)], (unsigned long int)L1);
        strncpy(s2 + L1, ret[(signed long int)(i - 1)], (unsigned long int)L2);
        s2[L1 + L2] = (char)0;
        free((void *)ret[(signed long int)(i - 2)]);
        ret[(signed long int)(i - 2)] = s2;
        i = i - 1;
      }

    }
    ret[(signed long int)i] = ((char *)NULL);
    void *return_value_realloc_7;
    return_value_realloc_7=realloc((void *)ret, (unsigned long int)(i + 1) * sizeof(char *) /*8ul*/ );
    ret = (char **)return_value_realloc_7;
    if(!(length_ret == ((signed int *)NULL)))
      *length_ret = i;

    return ret;
  }
}

// utf8_to_XChar2b
// file utf8wc.c line 215
extern struct anonymous_11 * utf8_to_XChar2b(const char *string, signed int *length_ret)
{
  signed long int in_len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(string);
  in_len = (signed long int)return_value_strlen_1;
  const unsigned char *in = (const unsigned char *)string;
  const unsigned char *in_end = in + in_len;
  struct anonymous_11 *c2b;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(in_len + (signed long int)1) * sizeof(struct anonymous_11) /*2ul*/ );
  c2b = (struct anonymous_11 *)return_value_malloc_2;
  struct anonymous_11 *out = c2b;
  if(out == ((struct anonymous_11 *)NULL))
    return ((struct anonymous_11 *)NULL);

  else
  {
    while(!(in >= in_end))
    {
      unsigned long int uc = (unsigned long int)0;
      signed long int L;
      L=utf8_decode(in, in_end - in, &uc);
      in = in + L;
      if(uc >= 65536ul)
        uc = (unsigned long int)0xFFFD;

      out->byte1 = (unsigned char)(uc >> 8 & (unsigned long int)0xFF);
      out->byte2 = (unsigned char)(uc & (unsigned long int)0xFF);
      out = out + 1l;
    }
    out->byte1 = (unsigned char)0;
    out->byte2 = (unsigned char)0;
    void *return_value_realloc_3;
    return_value_realloc_3=realloc((void *)c2b, (unsigned long int)((out - c2b) + (signed long int)1) * sizeof(struct anonymous_11) /*2ul*/ );
    c2b = (struct anonymous_11 *)return_value_realloc_3;
    if(!(length_ret == ((signed int *)NULL)))
      *length_ret = (signed int)(out - c2b);

    return c2b;
  }
}

// utf8_to_latin1
// file ./../utils/utf8wc.h line 34
extern char * utf8_to_latin1(const char *string, signed int ascii_p)
{
  signed long int in_len;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(string);
  in_len = (signed long int)return_value_strlen_1;
  const unsigned char *in = (const unsigned char *)string;
  const unsigned char *in_end = in + in_len;
  unsigned char *ret;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)(in_len + (signed long int)1));
  ret = (unsigned char *)return_value_malloc_2;
  unsigned char *out = ret;
  if(ret == ((unsigned char *)NULL))
    return ((char *)NULL);

  else
  {
    while(!(in >= in_end))
    {
      unsigned long int uc = (unsigned long int)0;
      signed long int len2;
      len2=utf8_decode(in, in_end - in, &uc);
      in = in + len2;
      if(uc == 18446744073709551520ul)
        uc = (unsigned long int)32;

      else
        if(uc >= 768ul && !(uc >= 880ul))
          uc = (unsigned long int)0;

        else
          if(uc >= 256ul)
            switch(uc)
            {
              case (unsigned long int)0x2000:

              case (unsigned long int)0x2001:

              case (unsigned long int)0x2002:

              case (unsigned long int)0x2003:

              case (unsigned long int)0x2004:

              case (unsigned long int)0x2005:

              case (unsigned long int)0x2006:

              case (unsigned long int)0x2007:

              case (unsigned long int)0x2008:

              case (unsigned long int)0x2009:

              case (unsigned long int)0x200A:
              {
                uc = (unsigned long int)32;
                break;
              }
              case (unsigned long int)0x2010:

              case (unsigned long int)0x2011:

              case (unsigned long int)0x2012:

              case (unsigned long int)0x2013:

              case (unsigned long int)0x2014:

              case (unsigned long int)0x2015:
              {
                uc = (unsigned long int)45;
                break;
              }
              case (unsigned long int)0x2018:

              case (unsigned long int)0x2019:

              case (unsigned long int)0x201A:

              case (unsigned long int)0x201B:
              {
                uc = (unsigned long int)39;
                break;
              }
              case (unsigned long int)0x201C:

              case (unsigned long int)0x201D:

              case (unsigned long int)0x201E:

              case (unsigned long int)0x201F:
              {
                uc = (unsigned long int)34;
                break;
              }
              case (unsigned long int)0x2022:
              {
                uc = (unsigned long int)-73;
                break;
              }
              case (unsigned long int)0x2023:
              {
                uc = (unsigned long int)-69;
                break;
              }
              case (unsigned long int)0x2027:
              {
                uc = (unsigned long int)-73;
                break;
              }
              case (unsigned long int)0x202F:
              {
                uc = (unsigned long int)32;
                break;
              }
              case (unsigned long int)0x2038:
              {
                uc = (unsigned long int)94;
                break;
              }
              case (unsigned long int)0x2039:
              {
                uc = (unsigned long int)-85;
                break;
              }
              case (unsigned long int)0x203A:
              {
                uc = (unsigned long int)-69;
                break;
              }
              case (unsigned long int)0x2041:
              {
                uc = (unsigned long int)94;
                break;
              }
              case (unsigned long int)0x2042:
              {
                uc = (unsigned long int)42;
                break;
              }
              case (unsigned long int)0x2043:
              {
                uc = (unsigned long int)61;
                break;
              }
              case (unsigned long int)0x2044:
              {
                uc = (unsigned long int)47;
                break;
              }
              case (unsigned long int)0x204B:
              {
                uc = (unsigned long int)-74;
                break;
              }
              case (unsigned long int)0x204C:
              {
                uc = (unsigned long int)-73;
                break;
              }
              case (unsigned long int)0x204D:
              {
                uc = (unsigned long int)-73;
                break;
              }
              case (unsigned long int)0x204E:
              {
                uc = (unsigned long int)42;
                break;
              }
              case (unsigned long int)0x204F:
                uc = (unsigned long int)59;
            }

      if(uc >= 256ul)
        uc = (unsigned long int)(ascii_p != 0 ? 35 : -65);

      if(!(ascii_p == 0))
      {
        const unsigned char latin1_to_ascii[96l] = { ' ', '!', 'C', '#', '#', 'Y', '|', 'S', '_', 'C', '#', '<', '=', '-', 'R', '_', '#', '#', '2', '3', '\'', 'u', 'P', '.', ',', '1', 'o', '>', '#', '#', '#', '?', 'A', 'A', 'A', 'A', 'A', 'A', 'E', 'C', 'E', 'E', 'E', 'E', 'I', 'I', 'I', 'I', 'D', 'N', 'O', 'O', 'O', 'O', 'O', 'x', '0', 'U', 'U', 'U', 'U', 'Y', 'p', 'S', 'a', 'a', 'a', 'a', 'a', 'a', 'e', 'c', 'e', 'e', 'e', 'e', 'i', 'i', 'i', 'i', 'o', 'n', 'o', 'o', 'o', 'o', 'o', '/', 'o', 'u', 'u', 'u', 'u', 'y', 'p', 'y' };
        if(uc >= 160ul)
          uc = (unsigned long int)latin1_to_ascii[(signed long int)(uc - (unsigned long int)0xA0)];

      }

      if(uc >= 1ul)
      {
        unsigned char *tmp_post_3 = out;
        out = out + 1l;
        *tmp_post_3 = (unsigned char)uc;
      }

    }
    *out = (unsigned char)0;
    void *return_value_realloc_4;
    return_value_realloc_4=realloc((void *)ret, (unsigned long int)((out - ret) + (signed long int)1) * sizeof(unsigned char) /*1ul*/ );
    ret = (unsigned char *)return_value_realloc_4;
    return (char *)ret;
  }
}

// visual_cells
// file ./../utils/visual.h line 20
extern signed int visual_cells(struct anonymous_9 *screen, struct anonymous_5 *visual)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_3 vi_in;
  struct anonymous_3 *vi_out;
  signed int out_count;
  signed int c;
  vi_in.screen=screen_number(screen);
  vi_in.visualid=XVisualIDFromVisual(visual);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x1), &vi_in, &out_count);
  if(vi_out == ((struct anonymous_3 *)NULL))
    abort();

  c = (vi_out + (signed long int)0)->colormap_size;
  XFree((void *)(char *)vi_out);
  return c;
}

// visual_class
// file ./../utils/visual.h line 19
extern signed int visual_class(struct anonymous_9 *screen, struct anonymous_5 *visual)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_3 vi_in;
  struct anonymous_3 *vi_out;
  signed int out_count;
  signed int c;
  vi_in.screen=screen_number(screen);
  vi_in.visualid=XVisualIDFromVisual(visual);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x1), &vi_in, &out_count);
  if(vi_out == ((struct anonymous_3 *)NULL))
    abort();

  c = (vi_out + (signed long int)0)->class;
  XFree((void *)(char *)vi_out);
  return c;
}

// visual_depth
// file ./../utils/visual.h line 17
extern signed int visual_depth(struct anonymous_9 *screen, struct anonymous_5 *visual)
{
  struct _XDisplay *dpy = screen->display;
  struct anonymous_3 vi_in;
  struct anonymous_3 *vi_out;
  signed int out_count;
  signed int d;
  vi_in.screen=screen_number(screen);
  vi_in.visualid=XVisualIDFromVisual(visual);
  vi_out=XGetVisualInfo(dpy, (signed long int)(0x2 | 0x1), &vi_in, &out_count);
  if(vi_out == ((struct anonymous_3 *)NULL))
    abort();

  d = (vi_out + (signed long int)0)->depth;
  XFree((void *)(char *)vi_out);
  return d;
}

// visual_warning
// file screenhack.c line 341
static void visual_warning(struct anonymous_9 *screen, unsigned long int window, struct anonymous_5 *visual, unsigned long int cmap, signed int window_p)
{
  struct xscreensaver_function_table *ft = xscreensaver_function_table;
  char *visual_string;
  visual_string=get_string_resource(screen->display, "visualID", "VisualID");
  struct anonymous_5 *desired_visual;
  desired_visual=pick_visual(screen);
  char win[100l];
  char why[100l];
  unsigned long int return_value_VirtualRootWindowOfScreen_1;
  return_value_VirtualRootWindowOfScreen_1=VirtualRootWindowOfScreen(screen);
  if(window == return_value_VirtualRootWindowOfScreen_1)
    strcpy(win, "root window");

  else
    sprintf(win, "window 0x%lx", (unsigned long int)window);
  if(!(window_p == 0))
    sprintf(why, "-window-id 0x%lx", (unsigned long int)window);

  else
    strcpy(why, "-root");
  signed int return_value_strcmp_4;
  signed int return_value_strcmp_6;
  if(!(visual_string == ((char *)NULL)))
  {
    if(!(*visual_string == 0))
    {
      char *s = visual_string;
      for( ; !(*s == 0); s = s + 1l)
        if((signed int)*s >= 65)
        {
          if(!((signed int)*s >= 91))
            *s = (char)(((signed int)*s - 65) + 97);

        }

      signed int return_value_strcmp_3;
      return_value_strcmp_3=strcmp(visual_string, "default");
      _Bool tmp_if_expr_5;
      if(return_value_strcmp_3 == 0)
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        return_value_strcmp_4=strcmp(visual_string, "default");
        tmp_if_expr_5 = !(return_value_strcmp_4 != 0) ? (_Bool)1 : (_Bool)0;
      }
      _Bool tmp_if_expr_7;
      if(tmp_if_expr_5)
        tmp_if_expr_7 = (_Bool)1;

      else
      {
        return_value_strcmp_6=strcmp(visual_string, "best");
        tmp_if_expr_7 = !(return_value_strcmp_6 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr_7)
      {
        if(!(visual == desired_visual))
        {
          fprintf(stderr, "%s: ignoring `-visual %s' because of `%s'.\n", progname, visual_string, (const void *)why);
          unsigned long int return_value_XVisualIDFromVisual_2;
          return_value_XVisualIDFromVisual_2=XVisualIDFromVisual(visual);
          fprintf(stderr, "%s: using %s's visual 0x%lx.\n", progname, (const void *)win, return_value_XVisualIDFromVisual_2);
        }

      }

      free((void *)visual_string);
    }

  }

  signed int return_value_has_writable_cells_9;
  signed int return_value_get_boolean_resource_8;
  if(visual == screen->root_visual)
  {
    return_value_has_writable_cells_9=has_writable_cells(screen, visual);
    if(!(return_value_has_writable_cells_9 == 0))
    {
      return_value_get_boolean_resource_8=get_boolean_resource(screen->display, "installColormap", "InstallColormap");
      if(!(return_value_get_boolean_resource_8 == 0))
      {
        fprintf(stderr, "%s: ignoring `-install' because of `%s'.\n", progname, (const void *)why);
        fprintf(stderr, "%s: using %s's colormap 0x%lx.\n", progname, (const void *)win, (unsigned long int)cmap);
      }

    }

  }

  if(!(ft->validate_visual_hook == ((signed int (*)(struct anonymous_9 *, const char *, struct anonymous_5 *))NULL)))
  {
    signed int return_value;
    return_value=ft->validate_visual_hook(screen, win, visual);
    if(return_value == 0)
      exit(1);

  }

}

// xscreensaver_window_p
// file grabclient.c line 85
static signed int xscreensaver_window_p(struct _XDisplay *dpy, unsigned long int window)
{
  unsigned long int type;
  signed int format;
  unsigned long int nitems;
  unsigned long int bytesafter;
  unsigned char *version;
  unsigned long int return_value_XInternAtom_1;
  return_value_XInternAtom_1=XInternAtom(dpy, "_SCREENSAVER_VERSION", 0);
  signed int return_value_XGetWindowProperty_2;
  return_value_XGetWindowProperty_2=XGetWindowProperty(dpy, window, return_value_XInternAtom_1, (signed long int)0, (signed long int)1, 0, (unsigned long int)31, &type, &format, &nitems, &bytesafter, &version);
  if(return_value_XGetWindowProperty_2 == 0)
  {
    if(type == 0ul)
      goto __CPROVER_DUMP_L1;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return 0;
  }
}

// ya_rand_init
// file ./../utils/yarandom.h line 37
extern void ya_rand_init(unsigned int seed)
{
  signed int i;
  if(seed == 0u)
  {
    struct timeval tp;
    struct timezone tzp;
    gettimeofday(&tp, &tzp);
    seed = 999U * (unsigned int)tp.tv_sec;
    seed = seed << 11 | seed >> sizeof(unsigned int) /*4ul*/  * (unsigned long int)8 - (unsigned long int)11;
    seed = seed + (unsigned int)((signed long int)1001 * tp.tv_usec);
    seed = seed << 7 | seed >> sizeof(unsigned int) /*4ul*/  * (unsigned long int)8 - (unsigned long int)7;
    signed int return_value_getpid_1;
    return_value_getpid_1=getpid();
    seed = seed + (unsigned int)(1003 * return_value_getpid_1);
    seed = seed << 13 | seed >> sizeof(unsigned int) /*4ul*/  * (unsigned long int)8 - (unsigned long int)13;
  }

  a[(signed long int)0] = a[(signed long int)0] + seed;
  i = 1;
  for( ; !(i >= 55); i = i + 1)
  {
    seed = seed * (unsigned int)999;
    seed = seed << 9 | seed >> sizeof(unsigned int) /*4ul*/  * (unsigned long int)8 - (unsigned long int)9;
    seed = seed + a[(signed long int)(i - 1)] * (unsigned int)1001;
    seed = seed << 15 | seed >> sizeof(unsigned int) /*4ul*/  * (unsigned long int)8 - (unsigned long int)15;
    a[(signed long int)i] = a[(signed long int)i] + seed;
  }
  i1 = (signed int)(a[(signed long int)0] % (unsigned int)55);
  i2 = (i1 + 24) % 55;
}

// ya_random
// file ./../utils/yarandom.h line 36
extern unsigned int ya_random(void)
{
  signed int ret = (signed int)(a[(signed long int)i1] + a[(signed long int)i2]);
  a[(signed long int)i1] = (unsigned int)ret;
  i1 = i1 + 1;
  if(i1 >= 55)
    i1 = 0;

  i2 = i2 + 1;
  if(i2 >= 55)
    i2 = 0;

  return (unsigned int)ret;
}

