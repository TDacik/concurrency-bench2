// #anon_enum$ISO_11172_VIDEO=1$ISO_13818_VIDEO=2$ISO_11172_AUDIO=3$ISO_13818_AUDIO=4$ISO_13818_PRIVATE=5$ISO_13818_PES_PRIVATE=6$ISO_13522_MHEG=7$ISO_13818_DSMCC=8$ISO_13818_TYPE_A=10$ISO_13818_TYPE_B=11$ISO_13818_TYPE_C=12$ISO_13818_TYPE_D=13$ISO_13818_AUX=14$ISO_13818_PART7_AUDIO=15$ISO_14496_PART2_VIDEO=16$ISO_14496_PART3_AUDIO=17$ISO_14496_PART10_VIDEO=27$STREAM_VIDEO_MPEG=128$STREAM_AUDIO_AC3=129$STREAM_VIDEO_VC1=234$STREAM_AUDIO_EAC3=31238$STREAM_AUDIO_DTS=31494$STREAM_AUDIO_AAC=31750$STREAM_DVBSUB=22790$STREAM_HDMV=65280$HDMV_AUDIO_80_PCM=65408$HDMV_AUDIO_82_DTS=65410$HDMV_AUDIO_83_TRUEHD=65411$HDMV_AUDIO_84_EAC3=65412$HDMV_AUDIO_85_DTS_HRA=65413$HDMV_AUDIO_86_DTS_HD_MA=65414$HDMV_SPU_90_BITMAP=65424$HDMV_SPU_91_INTERACTIVE=65425$HDMV_SPU_92_TEXT=65426
// file xine/../tools/ts.h line 59
enum anonymous$11 { ISO_11172_VIDEO=1, ISO_13818_VIDEO=2, ISO_11172_AUDIO=3, ISO_13818_AUDIO=4, ISO_13818_PRIVATE=5, ISO_13818_PES_PRIVATE=6, ISO_13522_MHEG=7, ISO_13818_DSMCC=8, ISO_13818_TYPE_A=10, ISO_13818_TYPE_B=11, ISO_13818_TYPE_C=12, ISO_13818_TYPE_D=13, ISO_13818_AUX=14, ISO_13818_PART7_AUDIO=15, ISO_14496_PART2_VIDEO=16, ISO_14496_PART3_AUDIO=17, ISO_14496_PART10_VIDEO=27, STREAM_VIDEO_MPEG=128, STREAM_AUDIO_AC3=129, STREAM_VIDEO_VC1=234, STREAM_AUDIO_EAC3=31238, STREAM_AUDIO_DTS=31494, STREAM_AUDIO_AAC=31750, STREAM_DVBSUB=22790, STREAM_HDMV=65280, HDMV_AUDIO_80_PCM=65408, HDMV_AUDIO_82_DTS=65410, HDMV_AUDIO_83_TRUEHD=65411, HDMV_AUDIO_84_EAC3=65412, HDMV_AUDIO_85_DTS_HRA=65413, HDMV_AUDIO_86_DTS_HD_MA=65414, HDMV_SPU_90_BITMAP=65424, HDMV_SPU_91_INTERACTIVE=65425, HDMV_SPU_92_TEXT=65426 };

// tag-#anon#ST[*{S8}$S8$'filename'||S64'filesize'||S64'filemtime'||*{V}$V$'lib_handle'||S32'ref'||S32'no_unload'|]
// file /usr/include/xine/plugin_catalog.h line 35
struct anonymous$12;

// tag-#anon#ST[*{S8}$S8$'origin'||*{S8}$S8$'mrl'||*{S8}$S8$'link'||S64'size'||U32'type'||U32'$pad0'|]
// file /usr/include/xine.h line 1067
struct anonymous$30;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'filename'||S64'filesize'||S64'filemtime'||*{V}$V$'lib_handle'||S32'ref'||S32'no_unload'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'filename'||S64'filesize'||S64'filemtime'||*{V}$V$'lib_handle'||S32'ref'||S32'no_unload'|]#$'file'||*{SYM#tag-#anon#ST[U8'type'||U8'API'||U48'$pad0'||*{cS8}$cS8$'id'||U32'version'||U32'$pad1'||*{cV}$cV$'special_info'||*{*{V}$V$(*{SYM#tag-xine_s#}$SYM#tag-xine_s#$|*{V}$V$)->*{V}$V$}$*{V}$V$(*{SYM#tag-xine_s#}$SYM#tag-xine_s#$|*{V}$V$)->*{V}$V$$'init'|]#}$SYM#tag-#anon#ST[U8'type'||U8'API'||U48'$pad0'||*{cS8}$cS8$'id'||U32'version'||U32'$pad1'||*{cV}$cV$'special_info'||*{*{V}$V$(*{SYM#tag-xine_s#}$SYM#tag-xine_s#$|*{V}$V$)->*{V}$V$}$*{V}$V$(*{SYM#tag-xine_s#}$SYM#tag-xine_s#$|*{V}$V$)->*{V}$V$$'init'|]#$'info'||*{V}$V$'plugin_class'||*{SYM#tag-xine_list_s#}$SYM#tag-xine_list_s#$'config_entry_list'||S32'ref'||S32'priority'|]
// file /usr/include/xine/plugin_catalog.h line 44
struct anonymous$14;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'filename'||S64'filesize'||S64'filemtime'||*{V}$V$'lib_handle'||S32'ref'||S32'no_unload'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'filename'||S64'filesize'||S64'filemtime'||*{V}$V$'lib_handle'||S32'ref'||S32'no_unload'|]#$'file'||*{SYM#tag-#anon#ST[U8'type'||U8'API'||U48'$pad0'||*{cS8}$cS8$'id'||U32'version'||U32'$pad1'||*{cV}$cV$'special_info'||*{*{V}$V$(*{SYM#tag-xine_s#}$SYM#tag-xine_s#$|*{V}$V$)->*{V}$V$}$*{V}$V$(*{SYM#tag-xine_s#}$SYM#tag-xine_s#$|*{V}$V$)->*{V}$V$$'init'|]#}$SYM#tag-#anon#ST[U8'type'||U8'API'||U48'$pad0'||*{cS8}$cS8$'id'||U32'version'||U32'$pad1'||*{cV}$cV$'special_info'||*{*{V}$V$(*{SYM#tag-xine_s#}$SYM#tag-xine_s#$|*{V}$V$)->*{V}$V$}$*{V}$V$(*{SYM#tag-xine_s#}$SYM#tag-xine_s#$|*{V}$V$)->*{V}$V$$'init'|]#$'info'||*{V}$V$'plugin_class'||*{SYM#tag-xine_list_s#}$SYM#tag-xine_list_s#$'config_entry_list'||S32'ref'||S32'priority'|]$link1
// file /usr/include/xine/plugin_catalog.h line 44
struct anonymous$60;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'filename'||S64'filesize'||S64'filemtime'||*{V}$V$'lib_handle'||S32'ref'||S32'no_unload'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'filename'||S64'filesize'||S64'filemtime'||*{V}$V$'lib_handle'||S32'ref'||S32'no_unload'|]#$'file'||*{SYM#tag-#anon#ST[U8'type'||U8'API'||U48'$pad0'||*{cS8}$cS8$'id'||U32'version'||U32'$pad1'||*{cV}$cV$'special_info'||*{*{V}$V$(*{SYM#tag-xine_s#}$SYM#tag-xine_s#$|*{V}$V$)->*{V}$V$}$*{V}$V$(*{SYM#tag-xine_s#}$SYM#tag-xine_s#$|*{V}$V$)->*{V}$V$$'init'|]#}$SYM#tag-#anon#ST[U8'type'||U8'API'||U48'$pad0'||*{cS8}$cS8$'id'||U32'version'||U32'$pad1'||*{cV}$cV$'special_info'||*{*{V}$V$(*{SYM#tag-xine_s#}$SYM#tag-xine_s#$|*{V}$V$)->*{V}$V$}$*{V}$V$(*{SYM#tag-xine_s#}$SYM#tag-xine_s#$|*{V}$V$)->*{V}$V$$'init'|]#$'info'||*{V}$V$'plugin_class'||*{SYM#tag-xine_list_s#}$SYM#tag-xine_list_s#$'config_entry_list'||S32'ref'||S32'priority'|]$link2
// file /usr/include/xine/plugin_catalog.h line 44
struct anonymous$1;

// tag-#anon#ST[*{SYM#tag-#anon#ST[*{S8}$S8$'filename'||S64'filesize'||S64'filemtime'||*{V}$V$'lib_handle'||S32'ref'||S32'no_unload'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'filename'||S64'filesize'||S64'filemtime'||*{V}$V$'lib_handle'||S32'ref'||S32'no_unload'|]#$'file'||*{SYM#tag-#anon#ST[U8'type'||U8'API'||U48'$pad0'||*{cS8}$cS8$'id'||U32'version'||U32'$pad1'||*{cV}$cV$'special_info'||*{*{V}$V$(*{SYM#tag-xine_s#}$SYM#tag-xine_s#$|*{V}$V$)->*{V}$V$}$*{V}$V$(*{SYM#tag-xine_s#}$SYM#tag-xine_s#$|*{V}$V$)->*{V}$V$$'init'|]#}$SYM#tag-#anon#ST[U8'type'||U8'API'||U48'$pad0'||*{cS8}$cS8$'id'||U32'version'||U32'$pad1'||*{cV}$cV$'special_info'||*{*{V}$V$(*{SYM#tag-xine_s#}$SYM#tag-xine_s#$|*{V}$V$)->*{V}$V$}$*{V}$V$(*{SYM#tag-xine_s#}$SYM#tag-xine_s#$|*{V}$V$)->*{V}$V$$'init'|]#$'info'||*{V}$V$'plugin_class'||*{SYM#tag-xine_list_s#}$SYM#tag-xine_list_s#$'config_entry_list'||S32'ref'||S32'priority'|]$link3
// file /usr/include/xine/plugin_catalog.h line 44
struct anonymous$3;

// tag-#anon#ST[*{SYM#tag-xine_stream_s#}$SYM#tag-xine_stream_s#$'stream'||*{V}$V$'data'||S32'data_length'||S32'type'||SYM#tag-timeval#'tv'|]
// file /usr/include/xine.h line 1847
struct anonymous$22;

// tag-#anon#ST[*{SYM#tag-xine_stream_s#}$SYM#tag-xine_stream_s#$'stream'||*{V}$V$'data'||S32'data_length'||S32'type'||SYM#tag-timeval#'tv'|]$link1
// file /usr/include/xine.h line 1847
struct anonymous$54;

// tag-#anon#ST[*{U8}$U8$'pmt'||*{U8}$U8$'pmt_write_ptr'||U32'crc32'||U32'version_number'||U16'pcr_pid'||U16'video_pid'||EN#anon_enum$ISO_11172_VIDEO=1$ISO_13818_VIDEO=2$ISO_11172_AUDIO=3$ISO_13818_AUDIO=4$ISO_13818_PRIVATE=5$ISO_13818_PES_PRIVATE=6$ISO_13522_MHEG=7$ISO_13818_DSMCC=8$ISO_13818_TYPE_A=10$ISO_13818_TYPE_B=11$ISO_13818_TYPE_C=12$ISO_13818_TYPE_D=13$ISO_13818_AUX=14$ISO_13818_PART7_AUDIO=15$ISO_14496_PART2_VIDEO=16$ISO_14496_PART3_AUDIO=17$ISO_14496_PART10_VIDEO=27$STREAM_VIDEO_MPEG=128$STREAM_AUDIO_AC3=129$STREAM_VIDEO_VC1=234$STREAM_AUDIO_EAC3=31238$STREAM_AUDIO_DTS=31494$STREAM_AUDIO_AAC=31750$STREAM_DVBSUB=22790$STREAM_HDMV=65280$HDMV_AUDIO_80_PCM=65408$HDMV_AUDIO_82_DTS=65410$HDMV_AUDIO_83_TRUEHD=65411$HDMV_AUDIO_84_EAC3=65412$HDMV_AUDIO_85_DTS_HRA=65413$HDMV_AUDIO_86_DTS_HD_MA=65414$HDMV_SPU_90_BITMAP=65424$HDMV_SPU_91_INTERACTIVE=65425$HDMV_SPU_92_TEXT=65426#{U32}$U32$'video_type'||U8'audio_tracks_count'||U8'spu_tracks_count'||U16'$pad0'||ARR32{SYM#tag-#anon#ST[U16'pid'||U16'$pad0'||EN#anon_enum$ISO_11172_VIDEO=1$ISO_13818_VIDEO=2$ISO_11172_AUDIO=3$ISO_13818_AUDIO=4$ISO_13818_PRIVATE=5$ISO_13818_PES_PRIVATE=6$ISO_13522_MHEG=7$ISO_13818_DSMCC=8$ISO_13818_TYPE_A=10$ISO_13818_TYPE_B=11$ISO_13818_TYPE_C=12$ISO_13818_TYPE_D=13$ISO_13818_AUX=14$ISO_13818_PART7_AUDIO=15$ISO_14496_PART2_VIDEO=16$ISO_14496_PART3_AUDIO=17$ISO_14496_PART10_VIDEO=27$STREAM_VIDEO_MPEG=128$STREAM_AUDIO_AC3=129$STREAM_VIDEO_VC1=234$STREAM_AUDIO_EAC3=31238$STREAM_AUDIO_DTS=31494$STREAM_AUDIO_AAC=31750$STREAM_DVBSUB=22790$STREAM_HDMV=65280$HDMV_AUDIO_80_PCM=65408$HDMV_AUDIO_82_DTS=65410$HDMV_AUDIO_83_TRUEHD=65411$HDMV_AUDIO_84_EAC3=65412$HDMV_AUDIO_85_DTS_HRA=65413$HDMV_AUDIO_86_DTS_HD_MA=65414$HDMV_SPU_90_BITMAP=65424$HDMV_SPU_91_INTERACTIVE=65425$HDMV_SPU_92_TEXT=65426#{U32}$U32$'type'|]#}$SYM#tag-#anon#ST[U16'pid'||U16'$pad0'||EN#anon_enum$ISO_11172_VIDEO=1$ISO_13818_VIDEO=2$ISO_11172_AUDIO=3$ISO_13818_AUDIO=4$ISO_13818_PRIVATE=5$ISO_13818_PES_PRIVATE=6$ISO_13522_MHEG=7$ISO_13818_DSMCC=8$ISO_13818_TYPE_A=10$ISO_13818_TYPE_B=11$ISO_13818_TYPE_C=12$ISO_13818_TYPE_D=13$ISO_13818_AUX=14$ISO_13818_PART7_AUDIO=15$ISO_14496_PART2_VIDEO=16$ISO_14496_PART3_AUDIO=17$ISO_14496_PART10_VIDEO=27$STREAM_VIDEO_MPEG=128$STREAM_AUDIO_AC3=129$STREAM_VIDEO_VC1=234$STREAM_AUDIO_EAC3=31238$STREAM_AUDIO_DTS=31494$STREAM_AUDIO_AAC=31750$STREAM_DVBSUB=22790$STREAM_HDMV=65280$HDMV_AUDIO_80_PCM=65408$HDMV_AUDIO_82_DTS=65410$HDMV_AUDIO_83_TRUEHD=65411$HDMV_AUDIO_84_EAC3=65412$HDMV_AUDIO_85_DTS_HRA=65413$HDMV_AUDIO_86_DTS_HD_MA=65414$HDMV_SPU_90_BITMAP=65424$HDMV_SPU_91_INTERACTIVE=65425$HDMV_SPU_92_TEXT=65426#{U32}$U32$'type'|]#$'audio_tracks'||ARR32{SYM#tag-#anon#ST[U16'pid'||ARR8{U8}$U8$'lang'||U16'comp_page_id'||U16'aux_page_id'|]#}$SYM#tag-#anon#ST[U16'pid'||ARR8{U8}$U8$'lang'||U16'comp_page_id'||U16'aux_page_id'|]#$'spu_tracks'||U32'$pad1'|]
// file xine/../tools/ts.h line 145
struct anonymous$10;

// tag-#anon#ST[*{V}$V$'reserved'|]
// file /usr/include/xine/xine_internal.h line 78
struct anonymous$43;

// tag-#anon#ST[*{cU8}$cU8$'data'||S32'count'||S32'index'|]
// file tools/bitstream.h line 17
struct anonymous$15;

// tag-#anon#ST[ARR16{S64}$S64$'fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$9;

// tag-#anon#ST[ARR1{SYM#tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'$pad0'|]#}$SYM#tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'$pad0'|]#$'__cancel_jmp_buf'||ARR4{*{V}$V$}$*{V}$V$$'__pad'|]
// file /usr/include/pthread.h line 525
struct anonymous$39;

// tag-#anon#ST[ARR64{U16}$U16$'program_number'||ARR64{U16}$U16$'pmt_pid'||U8'version'||U24'$pad0'||U32'crc32'||U8'pat_changed_flag'||U24'$pad1'|]
// file xine/../tools/ts.h line 120
struct anonymous$8;

// tag-#anon#ST[ARR8{S64}$S64$'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'$pad0'|]
// file /usr/include/pthread.h line 527
struct anonymous$40;

// tag-#anon#ST[BF{U32}$U32$'cc'||BF{U32}$U32$'ext'||BF{U32}$U32$'padding'||BF{U32}$U32$'version'||BF{U32}$U32$'paytype'||BF{U32}$U32$'marker'||U16'seq'||U32'ts'||U32'ssrc'|]
// file tools/rtp.h line 60
struct anonymous$25;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$38;

// tag-#anon#ST[S32'biSize'||S32'biWidth'||S32'biHeight'||S16'biPlanes'||S16'biBitCount'||U32'biCompression'||S32'biSizeImage'||S32'biXPelsPerMeter'||S32'biYPelsPerMeter'||S32'biClrUsed'||S32'biClrImportant'|]
// file /usr/include/xine/buffer.h line 701
struct anonymous$53;

// tag-#anon#ST[S32'count'||U32'$pad0'||U64'holder'|]
// file /usr/include/xine/xine_internal.h line 179
struct anonymous$21;

// tag-#anon#ST[S32'handle'||SYM#tag-osd_command_s#'cmd'||U16'extent_width'||U16'extent_height'||U16'video_window_x'||U16'video_window_y'||U16'video_window_w'||U16'video_window_h'||U16'$pad0'||S64'last_changed_vpts'||*{SYM#tag-argb_layer_s#}$SYM#tag-argb_layer_s#$'argb_layer'||*{U32}$U32$'argb_buffer'|]
// file xine/osd_manager.c line 36
struct anonymous$4;

// tag-#anon#ST[S32'num_buttons'||S32'str_len'||ARR256{S8}$S8$'str'|]
// file /usr/include/xine.h line 1871
struct anonymous$45;

// tag-#anon#ST[S32'priority'|]
// file /usr/include/xine/xine_plugin.h line 67
struct anonymous$33;

// tag-#anon#ST[S32'width'||S32'height'||S32'aspect'||S32'pan_scan'|]
// file /usr/include/xine.h line 1912
struct anonymous$46;

// tag-#anon#ST[S32'width'||S32'height'||S32'crop_left'||S32'crop_right'||S32'crop_top'||S32'crop_bottom'||S32'ratio_code'||S32'interlaced'||S32'format'||S32'img_size'||*{U8}$U8$'img'|]
// file /usr/include/xine.h line 434
struct anonymous$62;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]#'lock'||*{V}$V$'object'||*{V(*{V}$V$)->V}$V(*{V}$V$)->V$'destructor'||S32'count'||U32'$pad0'|]
// file /usr/include/xine/refcounter.h line 25
struct anonymous$18;

// tag-#anon#ST[SYM#tag-demux_class_s#'demux_class'||*{SYM#tag-xine_s#}$SYM#tag-xine_s#$'xine'||*{SYM#tag-config_values_s#}$SYM#tag-config_values_s#$'config'|]$link1
// file xine/demux_xvdr.c line 106
struct anonymous$59;

// tag-#anon#ST[SYM#tag-input_plugin_s#'input_plugin'||SYM#tag-vdr_input_plugin_funcs_s#'funcs'|]
// file xine_input_vdr.c line 300
struct anonymous$51;

// tag-#anon#ST[SYM#tag-stream_rtp_header_ext#'hdr'||SYM#tag-#anon#UN[ARR12{U8}$U8$'raw'||ARR3{U32}$U32$'rawd'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U8'padding0'||SYM#tag-#anon#ST[U64'pos'||U16'seq'||U8'stream'||ARR0{U8}$U8$'payload'|]#'udphdr'|]#'$anon0'||SYM#tag-#anon#ST[U8'padding1'||U64'pos'||U16'seq'||U8'stream'|]#'$anon1'|]#'$anon0'|]#'$anon0'||ARR0{U8}$U8$'payload'|]
// file xine_input_vdr_net.h line 128
struct anonymous$32;

// tag-#anon#ST[U16'extent_width'||U16'extent_height'||U32'layer'||U8'scaling'||U24'$pad0'|]
// file xine/vo_props.h line 55
struct anonymous$5;

// tag-#anon#ST[U16'pid'||ARR8{U8}$U8$'lang'||U16'comp_page_id'||U16'aux_page_id'|]
// file xine/../tools/ts.h line 165
struct anonymous$58;

// tag-#anon#ST[U16'pid'||U16'$pad0'||EN#anon_enum$ISO_11172_VIDEO=1$ISO_13818_VIDEO=2$ISO_11172_AUDIO=3$ISO_13818_AUDIO=4$ISO_13818_PRIVATE=5$ISO_13818_PES_PRIVATE=6$ISO_13522_MHEG=7$ISO_13818_DSMCC=8$ISO_13818_TYPE_A=10$ISO_13818_TYPE_B=11$ISO_13818_TYPE_C=12$ISO_13818_TYPE_D=13$ISO_13818_AUX=14$ISO_13818_PART7_AUDIO=15$ISO_14496_PART2_VIDEO=16$ISO_14496_PART3_AUDIO=17$ISO_14496_PART10_VIDEO=27$STREAM_VIDEO_MPEG=128$STREAM_AUDIO_AC3=129$STREAM_VIDEO_VC1=234$STREAM_AUDIO_EAC3=31238$STREAM_AUDIO_DTS=31494$STREAM_AUDIO_AAC=31750$STREAM_DVBSUB=22790$STREAM_HDMV=65280$HDMV_AUDIO_80_PCM=65408$HDMV_AUDIO_82_DTS=65410$HDMV_AUDIO_83_TRUEHD=65411$HDMV_AUDIO_84_EAC3=65412$HDMV_AUDIO_85_DTS_HRA=65413$HDMV_AUDIO_86_DTS_HD_MA=65414$HDMV_SPU_90_BITMAP=65424$HDMV_SPU_91_INTERACTIVE=65425$HDMV_SPU_92_TEXT=65426#{U32}$U32$'type'|]
// file xine/../tools/ts.h line 159
struct anonymous$57;

// tag-#anon#ST[U16'type'||U16'size'|]
// file tools/rtp.h line 43
struct anonymous$23;

// tag-#anon#ST[U16'width'||U16'height'||SYM#tag-mpeg_rational_s#'pixel_aspect'|]
// file tools/h264.h line 37
struct anonymous$16;

// tag-#anon#ST[U32'cnt'||U32'fill_avg'||U32'fill_min'||U32'fill_max'|]
// file xine_input_vdr.c line 342
struct anonymous$29;

// tag-#anon#ST[U64'pos'||ARR0{U8}$U8$'payload'|]
// file xine_input_vdr.c line 125
struct anonymous$41;

// tag-#anon#ST[U64'pos'||U16'seq'||U8'stream'||ARR0{U8}$U8$'payload'|]
// file xine_input_vdr_net.h line 106
struct anonymous$7;

// tag-#anon#ST[U64'pos'||U32'len'||U8'stream'||ARR0{U8}$U8$'payload'|]
// file xine_input_vdr_net.h line 90
struct anonymous$56;

// tag-#anon#ST[U8'padding0'||SYM#tag-#anon#ST[U64'pos'||U16'seq'||U8'stream'||ARR0{U8}$U8$'payload'|]#'udphdr'|]
// file xine_input_vdr_net.h line 138
struct anonymous$48;

// tag-#anon#ST[U8'padding1'||U64'pos'||U16'seq'||U8'stream'|]
// file xine_input_vdr_net.h line 143
struct anonymous$49;

// tag-#anon#ST[U8'type'||U8'API'||U48'$pad0'||*{cS8}$cS8$'id'||U32'version'||U32'$pad1'||*{cV}$cV$'special_info'||*{*{V}$V$(*{SYM#tag-xine_s#}$SYM#tag-xine_s#$|*{V}$V$)->*{V}$V$}$*{V}$V$(*{SYM#tag-xine_s#}$SYM#tag-xine_s#$|*{V}$V$)->*{V}$V$$'init'|]
// file /usr/include/xine/xine_plugin.h line 50
struct anonymous$13;

// tag-#anon#ST[U8'type'||U8'API'||U48'$pad0'||*{cS8}$cS8$'id'||U32'version'||U32'$pad1'||*{cV}$cV$'special_info'||*{*{V}$V$(*{SYM#tag-xine_s#}$SYM#tag-xine_s#$|*{V}$V$)->*{V}$V$}$*{V}$V$(*{SYM#tag-xine_s#}$SYM#tag-xine_s#$|*{V}$V$)->*{V}$V$$'init'|]$link1
// file /usr/include/xine/xine_plugin.h line 50
struct anonymous$61;

// tag-#anon#ST[U8'type'||U8'API'||U48'$pad0'||*{cS8}$cS8$'id'||U32'version'||U32'$pad1'||*{cV}$cV$'special_info'||*{*{V}$V$(*{SYM#tag-xine_s#}$SYM#tag-xine_s#$|*{V}$V$)->*{V}$V$}$*{V}$V$(*{SYM#tag-xine_s#}$SYM#tag-xine_s#$|*{V}$V$)->*{V}$V$$'init'|]$link2
// file /usr/include/xine/xine_plugin.h line 50
struct anonymous$0;

// tag-#anon#ST[U8'type'||U8'API'||U48'$pad0'||*{cS8}$cS8$'id'||U32'version'||U32'$pad1'||*{cV}$cV$'special_info'||*{*{V}$V$(*{SYM#tag-xine_s#}$SYM#tag-xine_s#$|*{V}$V$)->*{V}$V$}$*{V}$V$(*{SYM#tag-xine_s#}$SYM#tag-xine_s#$|*{V}$V$)->*{V}$V$$'init'|]$link3
// file /usr/include/xine/xine_plugin.h line 50
struct anonymous$2;

// tag-#anon#UN[*{SYM#tag-osd_clut_s#}$SYM#tag-osd_clut_s#$'palette'||U64'dummy02'|]
// file tools/osd_command.h line 102
union anonymous$20;

// tag-#anon#UN[*{SYM#tag-osd_rle_elem_s#}$SYM#tag-osd_rle_elem_s#$'data'||*{U8}$U8$'raw_data'||U64'dummy01'|]
// file tools/osd_command.h line 96
union anonymous$19;

// tag-#anon#UN[ARR0{SYM#tag-stream_rtp_header_ext#}$SYM#tag-stream_rtp_header_ext#$'hdr_ext'||ARR0{U8}$U8$'payload'|]
// file tools/rtp.h line 87
union anonymous$27;

// tag-#anon#UN[ARR12{U8}$U8$'raw'||ARR3{U32}$U32$'rawd'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[U8'padding0'||SYM#tag-#anon#ST[U64'pos'||U16'seq'||U8'stream'||ARR0{U8}$U8$'payload'|]#'udphdr'|]#'$anon0'||SYM#tag-#anon#ST[U8'padding1'||U64'pos'||U16'seq'||U8'stream'|]#'$anon1'|]#'$anon0'|]
// file xine_input_vdr_net.h line 132
union anonymous$31;

// tag-#anon#UN[ARR12{U8}$U8$'raw'||SYM#tag-#anon#ST[BF{U32}$U32$'cc'||BF{U32}$U32$'ext'||BF{U32}$U32$'padding'||BF{U32}$U32$'version'||BF{U32}$U32$'paytype'||BF{U32}$U32$'marker'||U16'seq'||U32'ts'||U32'ssrc'|]#'$anon0'|]
// file tools/rtp.h line 57
union anonymous$26;

// tag-#anon#UN[ARR16{U8}$U8$'__u6_addr8'||ARR8{U16}$U16$'__u6_addr16'||ARR4{U32}$U32$'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous$44;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$37;

// tag-#anon#UN[ARR4{U8}$U8$'raw'||U32'rawd'||SYM#tag-#anon#ST[U16'type'||U16'size'|]#'$anon0'|]
// file tools/rtp.h line 39
union anonymous$24;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$17;

// tag-#anon#UN[SYM#tag-#anon#ST[U8'padding0'||SYM#tag-#anon#ST[U64'pos'||U16'seq'||U8'stream'||ARR0{U8}$U8$'payload'|]#'udphdr'|]#'$anon0'||SYM#tag-#anon#ST[U8'padding1'||U64'pos'||U16'seq'||U8'stream'|]#'$anon1'|]
// file xine_input_vdr_net.h line 136
union anonymous$50;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$6;

// tag-#anon#UN[SYM#tag-scr_plugin_s#'scr'||SYM#tag-adjustable_scr_s#'ascr'|]
// file xine/adjustable_scr.c line 53
union anonymous;

// tag-#anon#UN[SYM#tag-vdr_input_plugin_if_s#'iface'||SYM#tag-#anon#ST[SYM#tag-input_plugin_s#'input_plugin'||SYM#tag-vdr_input_plugin_funcs_s#'funcs'|]#'$anon0'|]
// file xine_input_vdr.c line 298
union anonymous$28;

// tag-#anon#UN[U8'cb'||U8'g'|]
// file tools/osd_command.h line 51
union anonymous$34;

// tag-#anon#UN[U8'cr'||U8'b'|]
// file tools/osd_command.h line 55
union anonymous$35;

// tag-#anon#UN[U8'y'||U8'r'|]
// file tools/osd_command.h line 59
union anonymous$36;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$47;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}$SYM#tag-sockaddr#$'__sockaddr__'||r*{SYM#tag-sockaddr_at#}$SYM#tag-sockaddr_at#$'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}$SYM#tag-sockaddr_ax25#$'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}$SYM#tag-sockaddr_dl#$'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}$SYM#tag-sockaddr_eon#$'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}$SYM#tag-sockaddr_in#$'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}$SYM#tag-sockaddr_in6#$'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}$SYM#tag-sockaddr_inarp#$'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}$SYM#tag-sockaddr_ipx#$'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}$SYM#tag-sockaddr_iso#$'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}$SYM#tag-sockaddr_ns#$'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}$SYM#tag-sockaddr_un#$'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}$SYM#tag-sockaddr_x25#$'__sockaddr_x25__'|]$transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous$55;

// tag-#anon#cST[cU32'event'||ARR12{cS8}$cS8$'name'|]
// file xine_input_vdr.c line 3747
struct anonymous$52;

// tag-#anon#cST[cU32'type'||ARR28{cS8}$cS8$'name'|]
// file xine_input_vdr.c line 2843
struct anonymous$42;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__jmp_buf_tag
// file /usr/include/pthread.h line 744
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-adjustable_scr_s
// file xine/adjustable_scr.h line 22
struct adjustable_scr_s;

// tag-ao_format_s
// file /usr/include/xine/audio_out.h line 138
struct ao_format_s;

// tag-argb_layer_s
// file /usr/include/xine/video_out.h line 462
struct argb_layer_s;

// tag-audio_buffer_s
// file /usr/include/xine/audio_out.h line 148
struct audio_buffer_s$1;

// tag-audio_buffer_s$link1
// file /usr/include/xine/audio_out.h line 148
struct audio_buffer_s;

// tag-audio_buffer_s$link2
// file /usr/include/xine/audio_out.h line 148
struct audio_buffer_s$0;

// tag-audio_decoder_s
// file /usr/include/xine/audio_decoder.h line 40
struct audio_decoder_s;

// tag-broadcaster_s
// file /usr/include/xine/broadcaster.h line 30
struct broadcaster_s;

// tag-buf_element_s
// file /usr/include/xine/buffer.h line 332
struct buf_element_s;

// tag-cfg_entry_s
// file /usr/include/xine/configfile.h line 43
struct cfg_entry_s;

// tag-config_values_s
// file /usr/include/xine/configfile.h line 44
struct config_values_s;

// tag-demux_class_s
// file /usr/include/xine/demux.h line 44
struct demux_class_s$0;

// tag-demux_class_s$link1
// file /usr/include/xine/demux.h line 44
struct demux_class_s;

// tag-demux_plugin_s
// file /usr/include/xine/demux.h line 45
struct demux_plugin_s;

// tag-demux_plugin_s$link1
// file /usr/include/xine/demux.h line 45
struct demux_plugin_s$0;

// tag-demux_xvdr_s$link1
// file xine/demux_xvdr.c line 75
struct demux_xvdr_s;

// tag-extra_info_s
// file /usr/include/xine/buffer.h line 303
struct extra_info_s;

// tag-fifo_buffer_s
// file /usr/include/xine/buffer.h line 571
struct fifo_buffer_s;

// tag-fifo_input_plugin_s
// file xine_input_vdr.c line 1819
struct fifo_input_plugin_s;

// tag-frontend_s
// file xine_input_vdr.h line 25
struct frontend_s;

// tag-grab_data_s
// file xine_input_vdr.h line 57
struct grab_data_s;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-input_class_s
// file /usr/include/xine/input_plugin.h line 37
struct input_class_s$1;

// tag-input_class_s$link1
// file /usr/include/xine/input_plugin.h line 37
struct input_class_s;

// tag-input_class_s$link2
// file /usr/include/xine/input_plugin.h line 37
struct input_class_s$0;

// tag-input_plugin_s
// file /usr/include/xine/input_plugin.h line 38
struct input_plugin_s$0;

// tag-input_plugin_s$link1
// file /usr/include/xine/input_plugin.h line 38
struct input_plugin_s$1;

// tag-input_plugin_s$link2
// file /usr/include/xine/input_plugin.h line 38
struct input_plugin_s;

// tag-ip_mreq
// file /usr/include/netinet/in.h line 264
struct ip_mreq;

// tag-metronom_clock_s
// file /usr/include/xine/metronom.h line 53
struct metronom_clock_s;

// tag-metronom_s
// file /usr/include/xine/metronom.h line 52
struct metronom_s$0;

// tag-metronom_s$link1
// file /usr/include/xine/metronom.h line 52
struct metronom_s$1;

// tag-metronom_s$link2
// file /usr/include/xine/metronom.h line 52
struct metronom_s;

// tag-mpeg_rational_s
// file xine/../tools/mpeg.h line 38
struct mpeg_rational_s;

// tag-osd_clut_s
// file tools/osd_command.h line 50
struct osd_clut_s;

// tag-osd_command_s
// file xine/osd_manager.h line 22
struct osd_command_s;

// tag-osd_font_s
// file /usr/include/xine/osd.h line 34
struct osd_font_s;

// tag-osd_ft2context_s
// file /usr/include/xine/osd.h line 35
struct osd_ft2context_s;

// tag-osd_manager_impl_s
// file xine/osd_manager.c line 56
struct osd_manager_impl_s;

// tag-osd_manager_s
// file xine/osd_manager.h line 24
struct osd_manager_s;

// tag-osd_object_s
// file /usr/include/xine/osd.h line 32
struct osd_object_s$1;

// tag-osd_object_s$link1
// file /usr/include/xine/osd.h line 32
struct osd_object_s;

// tag-osd_object_s$link2
// file /usr/include/xine/osd.h line 32
struct osd_object_s$0;

// tag-osd_rect_s
// file tools/osd_command.h line 71
struct osd_rect_s;

// tag-osd_renderer_s
// file /usr/include/xine/osd.h line 33
struct osd_renderer_s$1;

// tag-osd_renderer_s$link1
// file /usr/include/xine/osd.h line 33
struct osd_renderer_s;

// tag-osd_renderer_s$link2
// file /usr/include/xine/osd.h line 33
struct osd_renderer_s$0;

// tag-osd_rle_elem_s
// file tools/osd_command.h line 66
struct osd_rle_elem_s;

// tag-plugin_catalog_s
// file /usr/include/xine/plugin_catalog.h line 53
struct plugin_catalog_s$2;

// tag-plugin_catalog_s$link1
// file /usr/include/xine/plugin_catalog.h line 53
struct plugin_catalog_s;

// tag-plugin_catalog_s$link2
// file /usr/include/xine/plugin_catalog.h line 53
struct plugin_catalog_s$0;

// tag-plugin_catalog_s$link3
// file /usr/include/xine/plugin_catalog.h line 53
struct plugin_catalog_s$1;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-rle_elem_s
// file /usr/include/xine/video_out.h line 457
struct rle_elem_s;

// tag-scr_impl_s$link1
// file xine/adjustable_scr.c line 50
struct scr_impl_s;

// tag-scr_plugin_s
// file /usr/include/xine/metronom.h line 54
struct scr_plugin_s;

// tag-scratch_buffer_s
// file /usr/include/xine/scratch.h line 29
struct scratch_buffer_s;

// tag-sg_io_hdr
// file /usr/include/scsi/sg.h line 44
struct sg_io_hdr;

// tag-slave_stream_s
// file xine_input_vdr.c line 274
struct slave_stream_s;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-spu_decoder_s
// file /usr/include/xine/spu_decoder.h line 41
struct spu_decoder_s;

// tag-spu_dvb_descriptor_s
// file /usr/include/xine/buffer.h line 557
struct spu_dvb_descriptor_s;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-stream_rtp_header
// file tools/rtp.h line 55
struct stream_rtp_header;

// tag-stream_rtp_header_ext
// file tools/rtp.h line 37
struct stream_rtp_header_ext;

// tag-stream_rtp_header_impl
// file xine_input_vdr_net.h line 160
struct stream_rtp_header_impl;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-ts2es_s
// file xine/ts2es.h line 14
struct ts2es_s;

// tag-ts_data_s
// file xine/demux_xvdr_tsdata.h line 16
struct ts_data_s;

// tag-ts_state_s
// file tools/ts.h line 193
struct ts_state_s;

// tag-udp_data_s
// file xine_input_vdr.c line 273
struct udp_data_s;

// tag-vdr_input_class_s
// file xine_input_vdr.c line 277
struct vdr_input_class_s;

// tag-vdr_input_plugin_funcs_s
// file xine_input_vdr.h line 27
struct vdr_input_plugin_funcs_s;

// tag-vdr_input_plugin_if_s
// file xine_input_vdr.h line 23
struct vdr_input_plugin_if_s;

// tag-vdr_input_plugin_s
// file xine_input_vdr.c line 297
struct vdr_input_plugin_s;

// tag-video_decoder_s
// file /usr/include/xine/video_decoder.h line 41
struct video_decoder_s;

// tag-video_overlay_event_s
// file /usr/include/xine/video_overlay.h line 52
struct video_overlay_event_s;

// tag-video_overlay_manager_s
// file /usr/include/xine/video_out.h line 52
struct video_overlay_manager_s$1;

// tag-video_overlay_manager_s$link1
// file /usr/include/xine/video_out.h line 52
struct video_overlay_manager_s;

// tag-video_overlay_manager_s$link2
// file /usr/include/xine/video_out.h line 52
struct video_overlay_manager_s$0;

// tag-video_overlay_object_s
// file /usr/include/xine/video_overlay.h line 42
struct video_overlay_object_s;

// tag-video_size_s
// file xine/../tools/mpeg.h line 43
struct video_size_s;

// tag-vo_driver_s
// file /usr/include/xine/video_out.h line 49
struct vo_driver_s$1;

// tag-vo_driver_s$link1
// file /usr/include/xine/video_out.h line 49
struct vo_driver_s;

// tag-vo_driver_s$link2
// file /usr/include/xine/video_out.h line 49
struct vo_driver_s$0;

// tag-vo_frame_s
// file /usr/include/xine/video_out.h line 48
struct vo_frame_s$1;

// tag-vo_frame_s$link1
// file /usr/include/xine/video_out.h line 48
struct vo_frame_s;

// tag-vo_frame_s$link2
// file /usr/include/xine/video_out.h line 48
struct vo_frame_s$0;

// tag-vo_overlay_s
// file /usr/include/xine/video_out.h line 51
struct vo_overlay_s;

// tag-xine_audio_port_s
// file /usr/include/xine.h line 83
struct xine_audio_port_s$1;

// tag-xine_audio_port_s$link1
// file /usr/include/xine.h line 83
struct xine_audio_port_s;

// tag-xine_audio_port_s$link2
// file /usr/include/xine.h line 83
struct xine_audio_port_s$0;

// tag-xine_cfg_entry_s
// file /usr/include/xine.h line 1563
struct xine_cfg_entry_s;

// tag-xine_event_queue_s
// file /usr/include/xine.h line 2132
struct xine_event_queue_s;

// tag-xine_grab_video_frame_s
// file /usr/include/xine.h line 500
struct xine_grab_video_frame_s;

// tag-xine_list_s
// file /usr/include/xine/list.h line 45
struct xine_list_s;

// tag-xine_post_out_s
// file /usr/include/xine.h line 681
struct xine_post_out_s;

// tag-xine_s
// file /usr/include/xine.h line 81
struct xine_s$0;

// tag-xine_s$link1
// file /usr/include/xine.h line 81
struct xine_s$1;

// tag-xine_s$link2
// file /usr/include/xine.h line 81
struct xine_s$2;

// tag-xine_s$link3
// file /usr/include/xine.h line 81
struct xine_s;

// tag-xine_sarray_s
// file /usr/include/xine/sorted_array.h line 60
struct xine_sarray_s;

// tag-xine_stream_s
// file /usr/include/xine.h line 82
struct xine_stream_s;

// tag-xine_stream_s$link1
// file /usr/include/xine.h line 82
struct xine_stream_s$1;

// tag-xine_stream_s$link2
// file /usr/include/xine.h line 82
struct xine_stream_s$0;

// tag-xine_ticket_s
// file /usr/include/xine/xine_internal.h line 70
struct xine_ticket_s;

// tag-xine_video_port_s
// file /usr/include/xine.h line 84
struct xine_video_port_s$1;

// tag-xine_video_port_s$link1
// file /usr/include/xine.h line 84
struct xine_video_port_s;

// tag-xine_video_port_s$link2
// file /usr/include/xine.h line 84
struct xine_video_port_s$0;

// tag-xvdr_metronom_s
// file xine/xvdr_metronom.h line 30
struct xvdr_metronom_s;

// tag-xvdr_metronom_s$link1
// file xine/xvdr_metronom.h line 30
struct xvdr_metronom_s$0;

#ifndef NULL
#define NULL ((void*)0)
#endif

// SetupLogLevel
// file xine_input_vdr.c line 173
static void SetupLogLevel(void);
// __asprintf_chk
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 158
extern signed int __asprintf_chk(char ** restrict , signed int, const char *, ...);
// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __fdelt_chk
// file /usr/include/x86_64-linux-gnu/bits/select2.h line 24
extern signed long int __fdelt_chk(signed long int);
// __fdelt_warn
// file /usr/include/x86_64-linux-gnu/bits/select2.h line 25
extern signed long int __fdelt_warn(signed long int);
// __fprintf_chk
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 85
extern signed int __fprintf_chk(struct _IO_FILE *, signed int, const char *, ...);
// __open_2
// file /usr/include/x86_64-linux-gnu/bits/fcntl2.h line 30
extern signed int __open_2(const char *, signed int);
// __open_alias
// file /usr/include/x86_64-linux-gnu/bits/fcntl2.h line 32
extern signed int __open_alias(const char *, signed int, ...);
// __open_missing_mode
// file /usr/include/x86_64-linux-gnu/bits/fcntl2.h line 37
extern void __open_missing_mode(void);
// __open_too_many_args
// file /usr/include/x86_64-linux-gnu/bits/fcntl2.h line 35
extern void __open_too_many_args(void);
// __printf_chk
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 87
extern signed int __printf_chk(signed int, const char *, ...);
// __pthread_register_cancel
// file /usr/include/pthread.h line 682
extern void __pthread_register_cancel(struct anonymous$39 *);
// __pthread_unregister_cancel
// file /usr/include/pthread.h line 694
extern void __pthread_unregister_cancel(struct anonymous$39 *);
// __pthread_unwind_next
// file /usr/include/pthread.h line 735
extern void __pthread_unwind_next(struct anonymous$39 *);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// __read_alias
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 25
extern signed long int __read_alias(signed int, void *, unsigned long int);
// __read_chk
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 23
extern signed long int __read_chk(signed int, void *, unsigned long int, unsigned long int);
// __read_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 27
extern signed long int __read_chk_warn(signed int, void *, unsigned long int, unsigned long int);
// __recvfrom_alias
// file /usr/include/x86_64-linux-gnu/bits/socket2.h line 51
extern signed long int __recvfrom_alias(signed int, void *, unsigned long int, signed int, union anonymous$55, unsigned int *);
// __recvfrom_chk
// file /usr/include/x86_64-linux-gnu/bits/socket2.h line 47
extern signed long int __recvfrom_chk(signed int, void *, unsigned long int, unsigned long int, signed int, union anonymous$55, unsigned int *);
// __recvfrom_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/socket2.h line 55
extern signed long int __recvfrom_chk_warn(signed int, void *, unsigned long int, unsigned long int, signed int, union anonymous$55, unsigned int *);
// __sigsetjmp
// file /usr/include/pthread.h line 745
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// __strdup
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1278
extern char * __strdup(const char *);
// __syslog_chk
// file /usr/include/x86_64-linux-gnu/bits/syslog.h line 24
extern void __syslog_chk(signed int, signed int, const char *, ...);
// __xstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 412
extern signed int __xstat(signed int, const char *, struct stat *);
// _x_action_lower
// file /usr/include/xine/xine_internal.h line 449
void _x_action_lower(struct xine_stream_s *);
// _x_action_pending
// file /usr/include/xine/xine_internal.h line 446
signed int _x_action_pending(struct xine_stream_s *);
// _x_action_raise
// file /usr/include/xine/xine_internal.h line 448
void _x_action_raise(struct xine_stream_s *);
// _x_demux_control_newpts
// file /usr/include/xine/xine_internal.h line 435
void _x_demux_control_newpts(struct xine_stream_s *, signed long int, unsigned int);
// _x_demux_control_start
// file /usr/include/xine/xine_internal.h line 437
void _x_demux_control_start(struct xine_stream_s *);
// _x_demux_flush_engine
// file /usr/include/xine/xine_internal.h line 432
void _x_demux_flush_engine(struct xine_stream_s$1 *);
// _x_get_audio_channel
// file /usr/include/xine/xine_internal.h line 524
signed int _x_get_audio_channel(struct xine_stream_s *);
// _x_get_fine_speed
// file /usr/include/xine/xine_internal.h line 520
signed int _x_get_fine_speed(struct xine_stream_s *);
// _x_get_spu_channel
// file /usr/include/xine/xine_internal.h line 526
signed int _x_get_spu_channel(struct xine_stream_s *);
// _x_io_select
// file /usr/include/xine/io_helper.h line 61
signed int _x_io_select(struct xine_stream_s *, signed int, signed int, signed int);
// _x_io_tcp_connect
// file /usr/include/xine/io_helper.h line 74
signed int _x_io_tcp_connect(struct xine_stream_s *, const char *, signed int);
// _x_io_tcp_connect_finish
// file /usr/include/xine/io_helper.h line 90
signed int _x_io_tcp_connect_finish(struct xine_stream_s *, signed int, signed int);
// _x_io_tcp_write
// file /usr/include/xine/io_helper.h line 111
signed long int _x_io_tcp_write(struct xine_stream_s *, signed int, void *, signed long int);
// _x_select_spu_channel
// file /usr/include/xine/xine_internal.h line 522
void _x_select_spu_channel(struct xine_stream_s *, signed int);
// _x_set_fine_speed
// file /usr/include/xine/xine_internal.h line 518
void _x_set_fine_speed(struct xine_stream_s *, signed int);
// _x_stream_info_get
// file /usr/include/xine/info_helper.h line 71
unsigned int _x_stream_info_get(struct xine_stream_s *, signed int);
// _x_stream_info_set
// file /usr/include/xine/info_helper.h line 41
void _x_stream_info_set(struct xine_stream_s *, signed int, signed int);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// absdiff
// file xine/xvdr_metronom.c line 29
static signed long int absdiff(signed long int a, signed long int b);
// acquire_ticket
// file xine/osd_manager.c line 122
static void acquire_ticket(struct osd_manager_impl_s *this);
// adjust_scr_speed
// file xine_input_vdr.c line 4920
static signed int adjust_scr_speed(struct vdr_input_plugin_s *this);
// adjustable_scr_dispose
// file xine/adjustable_scr.c line 296
static void adjustable_scr_dispose(struct adjustable_scr_s *scr);
// adjustable_scr_got_pcr
// file xine/adjustable_scr.c line 257
static void adjustable_scr_got_pcr(struct adjustable_scr_s *scr, signed long int pcr);
// adjustable_scr_jump
// file xine/adjustable_scr.c line 240
static void adjustable_scr_jump(struct adjustable_scr_s *scr, signed int pts);
// adjustable_scr_set_buffering
// file xine/adjustable_scr.c line 266
static void adjustable_scr_set_buffering(struct adjustable_scr_s *scr, signed int buffering);
// adjustable_scr_speed_base
// file xine/adjustable_scr.c line 220
static void adjustable_scr_speed_base(struct adjustable_scr_s *scr, signed int hz);
// adjustable_scr_speed_tuning
// file xine/adjustable_scr.c line 200
static void adjustable_scr_speed_tuning(struct adjustable_scr_s *scr, double factor);
// adjustable_scr_start
// file xine/adjustable_scr.c line 312
struct adjustable_scr_s * adjustable_scr_start(struct xine_s$2 *xine);
// alloc_udp_data_socket
// file xine_input_vdr.c line 5318
static signed int alloc_udp_data_socket(signed int firstport, signed int trycount, signed int *port);
// argb_layer_create
// file xine/osd_manager.c line 80
static struct argb_layer_s * argb_layer_create();
// argb_layer_destroy
// file xine/osd_manager.c line 89
static void argb_layer_destroy(struct argb_layer_s *argb_layer);
// argb_supported
// file xine/osd_manager.c line 955
static signed int argb_supported(struct xine_stream_s *stream);
// asprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 176
static inline signed int asprintf(char ** restrict __ptr, const char * restrict __fmt, ...);
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// av_mallocz
// file /usr/include/x86_64-linux-gnu/libavutil/mem.h line 205
void * av_mallocz(unsigned long int);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous$55, unsigned int);
// br_get_bit
// file tools/bitstream.h line 34
static inline signed int br_get_bit(struct anonymous$15 *br);
// br_get_bits
// file tools/bitstream.h line 44
static inline unsigned int br_get_bits(struct anonymous$15 *br, unsigned int n);
// br_get_se_golomb
// file tools/bitstream.h line 157
static inline signed int br_get_se_golomb(struct anonymous$15 *br);
// br_get_ue_golomb
// file tools/bitstream.h line 149
static inline unsigned int br_get_ue_golomb(struct anonymous$15 *br);
// br_skip_bits
// file tools/bitstream.h line 54
static inline void br_skip_bits(struct anonymous$15 *br, signed int n);
// br_skip_golomb
// file tools/bitstream.h line 163
static inline void br_skip_golomb(struct anonymous$15 *br);
// buffer_pool_free
// file xine_input_vdr.c line 1192
static void buffer_pool_free(struct buf_element_s *element);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// check_buffering_done
// file xine/xvdr_metronom.c line 32
static void check_buffering_done(struct xvdr_metronom_s$0 *this);
// check_newpts
// file xine/demux_xvdr.c line 221
static void check_newpts(struct demux_xvdr_s *this, struct buf_element_s *buf, signed int video);
// clear_osdcmd
// file xine/osd_manager.c line 182
static void clear_osdcmd(struct osd_command_s *cmd);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// close_slave_stream
// file xine_input_vdr.c line 2354
static void close_slave_stream(struct vdr_input_plugin_s *this);
// connect_control_stream
// file xine_input_vdr.c line 5349
static signed int connect_control_stream(struct vdr_input_plugin_s *this, const char *host, signed int port, signed int *client_id);
// connect_pipe_data_stream
// file xine_input_vdr.c line 5705
static signed int connect_pipe_data_stream(struct vdr_input_plugin_s *this);
// connect_rtp_data_stream
// file xine_input_vdr.c line 5429
static signed int connect_rtp_data_stream(struct vdr_input_plugin_s *this);
// connect_tcp_data_stream
// file xine_input_vdr.c line 5652
static signed int connect_tcp_data_stream(struct vdr_input_plugin_s *this, const char *host, signed int port);
// connect_udp_data_stream
// file xine_input_vdr.c line 5561
static signed int connect_udp_data_stream(struct vdr_input_plugin_s *this);
// create_timeout_time
// file xine_input_vdr.c line 868
static void create_timeout_time(struct timespec *abstime, signed int timeout_ms);
// data_stream_parse_control
// file xine_input_vdr.c line 4003
static void data_stream_parse_control(struct vdr_input_plugin_s *this, char *cmd);
// demux_xvdr_dispose
// file xine/demux_xvdr.c line 1089
static void demux_xvdr_dispose(struct demux_plugin_s$0 *this_gen);
// demux_xvdr_fwd_buf
// file xine/demux_xvdr.c line 403
static void demux_xvdr_fwd_buf(struct demux_xvdr_s *this, struct buf_element_s *buf);
// demux_xvdr_get_capabilities
// file xine/demux_xvdr.c line 1174
static unsigned int demux_xvdr_get_capabilities(struct demux_plugin_s$0 *this_gen);
// demux_xvdr_get_optional_data
// file xine/demux_xvdr.c line 1179
static signed int demux_xvdr_get_optional_data(struct demux_plugin_s$0 *this_gen, void *data, signed int data_type);
// demux_xvdr_get_status
// file xine/demux_xvdr.c line 1100
static signed int demux_xvdr_get_status(struct demux_plugin_s$0 *this_gen);
// demux_xvdr_get_stream_length
// file xine/demux_xvdr.c line 1169
static signed int demux_xvdr_get_stream_length(struct demux_plugin_s$0 *this_gen);
// demux_xvdr_init_class
// file xine/demux_xvdr.c line 1251
void * demux_xvdr_init_class(struct xine_s$1 *xine, void *data);
// demux_xvdr_open_plugin
// file xine/demux_xvdr.c line 1185
static struct demux_plugin_s$0 * demux_xvdr_open_plugin(struct demux_class_s *class_gen, struct xine_stream_s$1 *stream, struct input_plugin_s$1 *input_gen);
// demux_xvdr_parse_pack
// file xine/demux_xvdr.c line 453
static void demux_xvdr_parse_pack(struct demux_xvdr_s *this);
// demux_xvdr_parse_pes
// file xine/demux_xvdr.c line 497
static void demux_xvdr_parse_pes(struct demux_xvdr_s *this, struct buf_element_s *buf);
// demux_xvdr_parse_ts
// file xine/demux_xvdr.c line 539
static void demux_xvdr_parse_ts(struct demux_xvdr_s *this, struct buf_element_s *buf);
// demux_xvdr_seek
// file xine/demux_xvdr.c line 1135
static signed int demux_xvdr_seek(struct demux_plugin_s$0 *this_gen, signed long int start_pos, signed int start_time, signed int playing);
// demux_xvdr_send_chunk
// file xine/demux_xvdr.c line 1080
static signed int demux_xvdr_send_chunk(struct demux_plugin_s$0 *this_gen);
// demux_xvdr_send_headers
// file xine/demux_xvdr.c line 1114
static void demux_xvdr_send_headers(struct demux_plugin_s$0 *this_gen);
// descriptor_to_stream_type
// file tools/ts.c line 235
static enum anonymous$11 descriptor_to_stream_type(const unsigned char descriptor_tag);
// detect_audio_decoders
// file xine/demux_xvdr.c line 160
static void detect_audio_decoders(struct demux_xvdr_s *this);
// detect_dvb_spu
// file xine/demux_xvdr.c line 807
signed int detect_dvb_spu(struct demux_xvdr_s *this, unsigned char *p, struct buf_element_s *buf);
// detect_h264
// file xine/demux_xvdr.c line 954
static signed int detect_h264(unsigned char *data);
// detect_video_decoders
// file xine/demux_xvdr.c line 141
static void detect_video_decoders(struct demux_xvdr_s *this);
// dlclose
// file /usr/include/dlfcn.h line 60
extern signed int dlclose(void *);
// dlerror
// file /usr/include/dlfcn.h line 82
extern char * dlerror(void);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// dvd_menu_domain
// file xine_input_vdr.c line 2341
static void dvd_menu_domain(struct vdr_input_plugin_s *this, signed int value);
// dvd_set_speed
// file xine_input_vdr.c line 2233
static void dvd_set_speed(const char *device, signed int speed);
// elapsed
// file xine/../tools/time_ms.h line 28
static unsigned long int elapsed(unsigned long int t);
// elapsed$link1
// file xine/../tools/time_ms.h line 28
static unsigned long int elapsed$link1(unsigned long int t$link1);
// exec_osd_close
// file xine/osd_manager.c line 371
static signed int exec_osd_close(struct osd_manager_impl_s *this, struct osd_command_s *cmd);
// exec_osd_command
// file xine/osd_manager.c line 871
static signed int exec_osd_command(struct osd_manager_s *this_gen, struct osd_command_s *cmd, struct xine_stream_s *stream);
// exec_osd_command_internal
// file xine/osd_manager.c line 833
static signed int exec_osd_command_internal(struct osd_manager_impl_s *this, struct osd_command_s *cmd);
// exec_osd_flush
// file xine/osd_manager.c line 356
static signed int exec_osd_flush(struct osd_manager_impl_s *this, struct osd_command_s *cmd);
// exec_osd_move
// file xine/osd_manager.c line 798
static signed int exec_osd_move(struct osd_manager_impl_s *this, struct osd_command_s *cmd);
// exec_osd_nop
// file xine/osd_manager.c line 345
static signed int exec_osd_nop(struct osd_manager_impl_s *this, struct osd_command_s *cmd);
// exec_osd_set_argb
// file xine/osd_manager.c line 599
static signed int exec_osd_set_argb(struct osd_manager_impl_s *this, struct osd_command_s *cmd);
// exec_osd_set_lut8
// file xine/osd_manager.c line 586
static signed int exec_osd_set_lut8(struct osd_manager_impl_s *this, struct osd_command_s *cmd);
// exec_osd_set_palette
// file xine/osd_manager.c line 758
static signed int exec_osd_set_palette(struct osd_manager_impl_s *this, struct osd_command_s *cmd);
// exec_osd_set_rle
// file xine/osd_manager.c line 419
static signed int exec_osd_set_rle(struct osd_manager_impl_s *this, struct osd_command_s *cmd);
// exec_osd_size
// file xine/osd_manager.c line 297
static signed int exec_osd_size(struct osd_manager_impl_s *this, struct osd_command_s *cmd);
// exec_osd_video_window
// file xine/osd_manager.c line 328
static signed int exec_osd_video_window(struct osd_manager_impl_s *this, struct osd_command_s *cmd);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fifo_buffer_new
// file xine_input_vdr.c line 1287
static struct fifo_buffer_s * fifo_buffer_new(struct xine_stream_s *stream, signed int num_buffers, unsigned int buf_size);
// fifo_buffer_timed_get
// file xine_input_vdr.c line 1242
static struct buf_element_s * fifo_buffer_timed_get(struct fifo_buffer_s *fifo, signed int timeout);
// fifo_buffer_timed_get::1::1::2::1::__cancel_routine$object
//
void __cancel_routine$object(void *);
// fifo_buffer_try_get
// file xine_input_vdr.c line 1213
static struct buf_element_s * fifo_buffer_try_get(struct fifo_buffer_s *fifo);
// fifo_class_get_instance
// file xine_input_vdr.c line 1896
static struct input_plugin_s$0 * fifo_class_get_instance(struct input_class_s$1 *class_gen, struct xine_stream_s *stream, const char *data);
// fifo_dispose
// file xine_input_vdr.c line 1884
static void fifo_dispose(struct input_plugin_s$0 *this_gen);
// fifo_get_blocksize
// file xine_input_vdr.c line 1832
static unsigned int fifo_get_blocksize(struct input_plugin_s$0 *this_gen);
// fifo_get_capabilities
// file xine_input_vdr.c line 1830
static unsigned int fifo_get_capabilities(struct input_plugin_s$0 *this_gen);
// fifo_get_current_pos
// file xine_input_vdr.c line 1834
static signed long int fifo_get_current_pos(struct input_plugin_s$0 *this_gen);
// fifo_get_length
// file xine_input_vdr.c line 1836
static signed long int fifo_get_length(struct input_plugin_s$0 *this_gen);
// fifo_get_mrl
// file xine_input_vdr.c line 1843
static const char * fifo_get_mrl(struct input_plugin_s$0 *this_gen);
// fifo_get_optional_data
// file xine_input_vdr.c line 1840
static signed int fifo_get_optional_data(struct input_plugin_s$0 *this_gen, void *data, signed int data_type);
// fifo_open
// file xine_input_vdr.c line 1828
static signed int fifo_open(struct input_plugin_s$0 *this_gen);
// fifo_read
// file xine_input_vdr.c line 1852
static signed long int fifo_read(struct input_plugin_s$0 *this_gen, void *buf, signed long int len);
// fifo_read_block
// file xine_input_vdr.c line 1861
static struct buf_element_s * fifo_read_block(struct input_plugin_s$0 *this_gen, struct fifo_buffer_s *fifo, signed long int todo);
// fifo_seek
// file xine_input_vdr.c line 1838
static signed long int fifo_seek(struct input_plugin_s$0 *this_gen, signed long int offset, signed int origin);
// find_audio_track
// file tools/ts.c line 212
static signed int find_audio_track(struct anonymous$10 *pmt, unsigned int pid);
// flush_all_fifos
// file xine_input_vdr.c line 1352
static void flush_all_fifos(struct vdr_input_plugin_s *this, signed int full);
// fprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 95
static inline signed int fprintf(struct _IO_FILE * restrict __stream, const char * restrict __fmt, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_udp_data
// file xine_input_vdr.c line 443
static void free_udp_data(struct udp_data_s *data);
// get_buf_element
// file xine_input_vdr.c line 1403
static struct buf_element_s * get_buf_element(struct vdr_input_plugin_s *this, signed int size, signed int force);
// get_buf_element_timed
// file xine_input_vdr.c line 1451
static struct buf_element_s * get_buf_element_timed(struct vdr_input_plugin_s *this, signed int size, signed int timeout);
// get_buf_element_timed::1::1::1::2::1::__cancel_routine$object
//
void __cancel_routine$object(void *);
// get_decoder_name
// file xine/demux_xvdr.c line 117
static const char * get_decoder_name(struct xine_s$1 *xine, signed int buf_type);
// get_option
// file xine/xvdr_metronom.c line 281
static signed long int get_option(struct metronom_s *metronom, signed int option);
// get_ovl_manager
// file xine/osd_manager.c line 141
struct video_overlay_manager_s$1 * get_ovl_manager(struct osd_manager_impl_s *this);
// getpeername
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 141
extern signed int getpeername(signed int, union anonymous$55, unsigned int *);
// getsockname
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 127
extern signed int getsockname(signed int, union anonymous$55, unsigned int *);
// getsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 219
extern signed int getsockopt(signed int, signed int, signed int, void *, unsigned int *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// got_audio_samples
// file xine/xvdr_metronom.c line 143
static signed long int got_audio_samples(struct metronom_s *metronom, signed long int pts, signed int nsamples);
// got_spu_packet
// file xine/xvdr_metronom.c line 186
static signed long int got_spu_packet(struct metronom_s *metronom, signed long int pts);
// got_video_frame
// file xine/xvdr_metronom.c line 79
static void got_video_frame(struct metronom_s *metronom, struct vo_frame_s$0 *frame);
// h264_get_picture_type
// file tools/h264.h line 55
signed int h264_get_picture_type(const unsigned char *buf, signed int len);
// h264_get_video_size
// file tools/h264.h line 60
signed int h264_get_video_size(const unsigned char *buf, signed int len, struct video_size_s *size);
// h264_nal_unescape
// file tools/h264.c line 145
static signed int h264_nal_unescape(unsigned char *dst, const unsigned char *src, signed int len);
// h264_parse_sps
// file tools/h264.c line 26
signed int h264_parse_sps(const unsigned char *buf, signed int len, struct anonymous$16 *sps);
// handle_audio_discontinuity
// file xine/xvdr_metronom.c line 216
static void handle_audio_discontinuity(struct metronom_s *metronom, signed int type, signed long int disc_off);
// handle_control_grab
// file xine_input_vdr.c line 2646
static signed int handle_control_grab(struct vdr_input_plugin_s *this, const char *cmd);
// handle_control_grab::1::2::1::3::2::1::__cancel_routine$object
//
void __cancel_routine$object(void *);
// handle_control_osdcmd
// file xine_input_vdr.c line 2734
static signed int handle_control_osdcmd(struct vdr_input_plugin_s *this);
// handle_control_playfile
// file xine_input_vdr.c line 2395
static signed int handle_control_playfile(struct vdr_input_plugin_s *this, const char *cmd);
// handle_control_substream
// file xine_input_vdr.c line 2696
static signed int handle_control_substream(struct vdr_input_plugin_s *this, const char *cmd);
// handle_disconnect
// file xine_input_vdr.c line 4901
static void handle_disconnect(struct vdr_input_plugin_s *this);
// handle_video_discontinuity
// file xine/xvdr_metronom.c line 225
static void handle_video_discontinuity(struct metronom_s *metronom, signed int type, signed long int disc_off);
// init_osd_manager
// file xine/osd_manager.h line 35
struct osd_manager_s * init_osd_manager(void);
// init_udp_data
// file xine_input_vdr.c line 434
static struct udp_data_s * init_udp_data(void);
// input_xvdr_init_class
// file xine_input_vdr.c line 6055
static void * input_xvdr_init_class(struct xine_s$0 *xine, void *data);
// io_select_rd
// file xine_input_vdr.c line 890
static signed int io_select_rd(signed int fd);
// ioctl
// file /usr/include/x86_64-linux-gnu/sys/ioctl.h line 41
extern signed int ioctl(signed int, unsigned long int, ...);
// is_audio_descriptor
// file tools/ts.c line 222
static inline signed int is_audio_descriptor(const unsigned char descriptor_tag);
// is_lang_code
// file xine_input_vdr.c line 3054
static signed int is_lang_code(const char *s, signed int len);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 50
static inline void * memcpy(void * restrict __dest, const void * restrict __src, unsigned long int __len);
// memcpy$link1
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 50
static inline void * memcpy$link1(void * restrict __dest$link1, const void * restrict __src$link1, unsigned long int __len$link1);
// memcpy$link2
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 50
static inline void * memcpy$link2(void * restrict __dest$link2, const void * restrict __src$link2, unsigned long int __len$link2);
// memcpy$link3
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 50
static inline void * memcpy$link3(void * restrict __dest$link3, const void * restrict __src$link3, unsigned long int __len$link3);
// memcpy$link4
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 50
static inline void * memcpy$link4(void * restrict __dest$link4, const void * restrict __src$link4, unsigned long int __len$link4);
// memcpy$link5
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 50
static inline void * memcpy$link5(void * restrict __dest$link5, const void * restrict __src$link5, unsigned long int __len$link5);
// memcpy$link6
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 50
static inline void * memcpy$link6(void * restrict __dest$link6, const void * restrict __src$link6, unsigned long int __len$link6);
// memmove
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 57
static inline void * memmove(void *__dest, const void *__src, unsigned long int __len);
// memmove$link1
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 57
static inline void * memmove$link1(void *__dest$link1, const void *__src$link1, unsigned long int __len$link1);
// memset
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 78
static inline void * memset(void *__dest, signed int __ch, unsigned long int __len);
// memset$link1
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 78
static inline void * memset$link1(void *__dest$link1, signed int __ch$link1, unsigned long int __len$link1);
// memset$link2
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 78
static inline void * memset$link2(void *__dest$link2, signed int __ch$link2, unsigned long int __len$link2);
// memset$link3
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 78
static inline void * memset$link3(void *__dest$link3, signed int __ch$link3, unsigned long int __len$link3);
// metronom_exit
// file xine/xvdr_metronom.c line 311
static void metronom_exit(struct metronom_s *metronom);
// min64
// file xine/xvdr_metronom.c line 30
static signed long int min64(signed long int a, signed long int b);
// mpeg2_get_picture_type
// file tools/mpeg.h line 54
signed int mpeg2_get_picture_type(const unsigned char *buf, signed int len);
// mpeg2_get_video_size
// file tools/mpeg.h line 59
signed int mpeg2_get_video_size(const unsigned char *buf, signed int len, struct video_size_s *size);
// mpeg2_is_sequence_header
// file tools/mpeg.c line 34
signed int mpeg2_is_sequence_header(const unsigned char *buf, signed int len);
// mutex_cleanup
// file xine_input_vdr.c line 462
static void mutex_cleanup(void *arg);
// open
// file /usr/include/x86_64-linux-gnu/bits/fcntl2.h line 41
static inline signed int open(const char *__path, signed int __oflag, ...);
// osd_exec_vpts
// file xine/osd_manager.c line 263
static signed long int osd_exec_vpts(struct osd_manager_impl_s *this, struct osd_command_s *cmd);
// osd_manager_dispose
// file xine/osd_manager.c line 968
static void osd_manager_dispose(struct osd_manager_s *this_gen, struct xine_stream_s *stream);
// osdcmd_scale
// file xine/osd_manager.c line 227
static void osdcmd_scale(struct osd_manager_impl_s *this, struct osd_command_s *cmd, struct anonymous$4 *osd, signed int output_width, signed int output_height);
// osdcmd_to_overlay
// file xine/osd_manager.c line 195
static void osdcmd_to_overlay(struct vo_overlay_s *ovl, struct osd_command_s *cmd);
// palette_argb_to_ayuv
// file xine/osd_manager.c line 159
static void palette_argb_to_ayuv(struct osd_clut_s *clut, signed int colors);
// parse_audio_stream
// file xine/demux_xvdr.c line 1048
static signed int parse_audio_stream(struct demux_xvdr_s *this, unsigned char *p, struct buf_element_s *buf);
// parse_dvb_spu
// file xine/demux_xvdr.c line 762
static signed int parse_dvb_spu(struct demux_xvdr_s *this, unsigned char *p, struct buf_element_s *buf, signed int substream_header_len);
// parse_pes_for_pts
// file xine/demux_xvdr.c line 648
static signed int parse_pes_for_pts(struct demux_xvdr_s *this, unsigned char *p, struct buf_element_s *buf);
// parse_private_stream_1
// file xine/demux_xvdr.c line 853
static signed int parse_private_stream_1(struct demux_xvdr_s *this, unsigned char *p, struct buf_element_s *buf);
// parse_timestamp
// file tools/pes.c line 21
static signed long int parse_timestamp(const unsigned char *buf);
// parse_video_stream
// file xine/demux_xvdr.c line 976
static signed int parse_video_stream(struct demux_xvdr_s *this, unsigned char *p, struct buf_element_s *buf);
// pes_change_pts
// file tools/pes.c line 65
void pes_change_pts(unsigned char *buf, signed int len, signed long int new_pts);
// pes_get_dts
// file xine/../tools/pes.h line 71
signed long int pes_get_dts(const unsigned char *buf, signed int len);
// pes_get_picture_type
// file tools/pes.h line 82
unsigned char pes_get_picture_type(const unsigned char *buf, signed int len);
// pes_get_pts
// file tools/pes.h line 70
signed long int pes_get_pts(const unsigned char *buf, signed int len);
// pes_get_video_size
// file xine/../tools/pes.h line 83
signed int pes_get_video_size(const unsigned char *buf, signed int len, struct video_size_s *size, signed int h264);
// pes_is_frame_h264
// file tools/pes.c line 108
signed int pes_is_frame_h264(const unsigned char *buf, signed int len);
// pes_strip_pts_dts
// file tools/pes.c line 85
signed int pes_strip_pts_dts(unsigned char *buf, signed int size);
// post_frame_end
// file xine/demux_xvdr.c line 297
static void post_frame_end(struct demux_xvdr_s *this, struct buf_element_s *vid_buf);
// post_sequence_end
// file xine/demux_xvdr.c line 272
static void post_sequence_end(struct fifo_buffer_s *fifo, unsigned int video_type);
// post_vdr_event
// file xine_input_vdr.c line 4724
static signed int post_vdr_event(struct vdr_input_plugin_if_s *this_if, const char *msg);
// postprocess_buf
// file xine_input_vdr.c line 4867
static void postprocess_buf(struct vdr_input_plugin_s *this, struct buf_element_s *buf, signed int need_pause);
// preprocess_buf
// file xine_input_vdr.c line 4776
static struct buf_element_s * preprocess_buf(struct vdr_input_plugin_s *this, struct buf_element_s *buf);
// printf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 102
static inline signed int printf(const char * restrict __fmt, ...);
// printf_control
// file xine_input_vdr.c line 1017
static signed long int printf_control(struct vdr_input_plugin_s *this, const char *fmt, ...);
// printf_vdr
// file xine_input_vdr.c line 1176
static void printf_vdr(struct vdr_input_plugin_s *this, const char *fmt, ...);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous$17 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous$17 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$17 *, const union anonymous$37 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$17 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous$17 *, union anonymous$6 *, struct timespec *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$6 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$6 *, const union anonymous$37 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$6 *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_trylock(union anonymous$6 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$6 *);
// pthread_testcancel
// file /usr/include/pthread.h line 520
extern void pthread_testcancel(void);
// pts_wrap_workaround
// file xine/demux_xvdr.c line 182
static void pts_wrap_workaround(struct demux_xvdr_s *this, struct buf_element_s *buf, signed int video);
// put_control_buf
// file xine_input_vdr.c line 1508
static void put_control_buf(struct fifo_buffer_s *buffer, struct fifo_buffer_s *pool, signed int cmd);
// put_control_buf$link1
// file xine/demux_xvdr.c line 258
static void put_control_buf$link1(struct fifo_buffer_s *buffer$link1, struct fifo_buffer_s *pool$link1, signed int cmd$link1);
// puts_vdr
// file xine_input_vdr.c line 1165
static void puts_vdr(struct vdr_input_plugin_s *this, const char *s);
// queue_blank_yv12
// file xine_input_vdr.c line 1696
static void queue_blank_yv12(struct vdr_input_plugin_s *this);
// queue_nosignal
// file xine_input_vdr.c line 1746
static void queue_nosignal(struct vdr_input_plugin_s *this);
// read
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 34
static inline signed long int read(signed int __fd, void *__buf, unsigned long int __nbytes);
// read_control
// file xine_input_vdr.c line 1120
static signed long int read_control(struct vdr_input_plugin_s *this, unsigned char *buf, unsigned long int len);
// read_socket_udp
// file xine_input_vdr.c line 4159
static struct buf_element_s * read_socket_udp(struct vdr_input_plugin_s *this);
// readline_control
// file xine_input_vdr.c line 1043
static signed long int readline_control(struct vdr_input_plugin_s *this, char *buf, unsigned long int maxlen, signed int timeout);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// recvfrom
// file /usr/include/x86_64-linux-gnu/bits/socket2.h line 64
static inline signed long int recvfrom(signed int __fd, void * restrict __buf, unsigned long int __n, signed int __flags, union anonymous$55 __addr, unsigned int * restrict __addr_len);
// release_ticket
// file xine/osd_manager.c line 130
static void release_ticket(struct osd_manager_impl_s *this);
// reset_scr_tuning
// file xine_input_vdr.c line 594
static void reset_scr_tuning(struct vdr_input_plugin_s *this);
// reset_trick_speed
// file xine_input_vdr.c line 1687
static void reset_trick_speed(struct vdr_input_plugin_s *this);
// resume_demuxer
// file xine_input_vdr.c line 2024
static void resume_demuxer(struct vdr_input_plugin_s *this);
// rle_compress
// file xine/../tools/rle.h line 28
unsigned int rle_compress(struct osd_rle_elem_s **rle_data, const unsigned char *data, unsigned int w, unsigned int h);
// rle_compress_hdmv
// file tools/rle.c line 248
unsigned long int rle_compress_hdmv(unsigned char **rle_data, const unsigned char *data, unsigned int w, unsigned int h, signed int *num_rle);
// rle_compress_net
// file tools/rle.c line 67
unsigned int rle_compress_net(unsigned char **rle_data, unsigned int *elems, const unsigned char *data, unsigned int w, unsigned int h);
// rle_palette_to_argb
// file tools/rle.c line 398
void rle_palette_to_argb(unsigned int *argb, struct osd_clut_s *palette, unsigned int entries);
// rle_palette_to_rgba
// file tools/rle.c line 409
void rle_palette_to_rgba(unsigned int *rgba, struct osd_clut_s *palette, unsigned int entries);
// rle_recompress_net
// file tools/rle.c line 78
unsigned int rle_recompress_net(unsigned char *raw, struct osd_rle_elem_s *data, unsigned int elems);
// rle_scale_nearest
// file xine/../tools/rle.h line 53
struct osd_rle_elem_s * rle_scale_nearest(const struct osd_rle_elem_s *old_rle, signed int *rle_elems, unsigned int w, unsigned int h, unsigned int new_w, unsigned int new_h);
// rle_uncompress_argb
// file tools/rle.c line 447
void rle_uncompress_argb(unsigned int *dst, unsigned int w, unsigned int h, unsigned int stride, struct osd_rle_elem_s *rle_data, unsigned int num_rle, struct osd_clut_s *palette, unsigned int palette_entries);
// rle_uncompress_hdmv
// file tools/rle.h line 63
signed int rle_uncompress_hdmv(struct osd_rle_elem_s **data, unsigned int w, unsigned int h, const unsigned char *rle_data, unsigned int num_rle, unsigned long int rle_size);
// rle_uncompress_lut8
// file tools/rle.c line 372
void rle_uncompress_lut8(unsigned char *dst, unsigned int w, unsigned int h, unsigned int stride, struct osd_rle_elem_s *rle_data, unsigned int num_rle);
// rle_uncompress_rgba
// file tools/rle.c line 462
void rle_uncompress_rgba(unsigned int *dst, unsigned int w, unsigned int h, unsigned int stride, struct osd_rle_elem_s *rle_data, unsigned int num_rle, struct osd_clut_s *palette, unsigned int palette_entries);
// rle_uncompress_u32
// file tools/rle.c line 420
static void rle_uncompress_u32(unsigned int *dst, unsigned int w, unsigned int h, unsigned int stride, struct osd_rle_elem_s *rle_data, unsigned int num_rle, unsigned int *lut);
// scr_adjust
// file xine/adjustable_scr.c line 125
static void scr_adjust(struct scr_plugin_s *scr, signed long int vpts);
// scr_exit
// file xine/adjustable_scr.c line 183
static void scr_exit(struct scr_plugin_s *scr);
// scr_get_current
// file xine/adjustable_scr.c line 154
static signed long int scr_get_current(struct scr_plugin_s *scr);
// scr_get_priority
// file xine/adjustable_scr.c line 103
static signed int scr_get_priority(struct scr_plugin_s *scr);
// scr_set_fine_speed
// file xine/adjustable_scr.c line 108
static signed int scr_set_fine_speed(struct scr_plugin_s *scr, signed int speed);
// scr_start
// file xine/adjustable_scr.c line 140
static void scr_start(struct scr_plugin_s *scr, signed long int start_vpts);
// scr_tuning_set_paused
// file xine_input_vdr.c line 571
static void scr_tuning_set_paused(struct vdr_input_plugin_s *this);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$9 *, struct anonymous$9 *, struct anonymous$9 *, struct timeval *);
// select_spu_channel
// file xine_input_vdr.c line 2324
static void select_spu_channel(struct xine_stream_s *stream, signed int channel);
// send_meta_info
// file xine_input_vdr.c line 2217
static void send_meta_info(struct vdr_input_plugin_s *this);
// set_argb_layer
// file xine/osd_manager.c line 95
static void set_argb_layer(struct argb_layer_s **dst, struct argb_layer_s *src);
// set_audio_rate
// file xine/xvdr_metronom.c line 234
static void set_audio_rate(struct metronom_s *metronom, signed long int pts_per_smpls);
// set_buffer_limits
// file xine_input_vdr.c line 1523
static void set_buffer_limits(struct vdr_input_plugin_s *this);
// set_deinterlace_method
// file xine_input_vdr.c line 2121
static signed int set_deinterlace_method(struct vdr_input_plugin_s *this, const char *method_name);
// set_live_mode
// file xine_input_vdr.c line 1595
static void set_live_mode(struct vdr_input_plugin_s *this, signed int onoff);
// set_master
// file xine/xvdr_metronom.c line 305
static void set_master(struct metronom_s *metronom, struct metronom_s *master);
// set_option
// file xine/xvdr_metronom.c line 240
static void set_option(struct metronom_s *metronom, signed int option, signed long int value);
// set_pivot
// file xine/adjustable_scr.c line 74
static void set_pivot(struct scr_impl_s *this);
// set_recv_buffer_size
// file xine_input_vdr.c line 5294
static void set_recv_buffer_size(signed int fd, unsigned int max_buf);
// set_still_mode
// file xine_input_vdr.c line 1569
static void set_still_mode(struct vdr_input_plugin_s *this, signed int still_mode);
// set_trick_speed
// file xine_input_vdr.c line 1634
static void set_trick_speed(struct vdr_input_plugin_s *this, signed int speed, signed int backwards);
// set_video_properties
// file xine_input_vdr.c line 2146
static signed int set_video_properties(struct vdr_input_plugin_s *this, signed int hue, signed int saturation, signed int brightness, signed int sharpness, signed int noise_reduction, signed int contrast, signed int vo_aspect_ratio);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// signal_buffer_not_empty
// file xine_input_vdr.c line 1275
static void signal_buffer_not_empty(struct vdr_input_plugin_s *this);
// signal_buffer_pool_not_empty
// file xine_input_vdr.c line 1261
static void signal_buffer_pool_not_empty(struct vdr_input_plugin_s *this);
// slave_track_maps_changed
// file xine_input_vdr.c line 3686
static void slave_track_maps_changed(struct vdr_input_plugin_s *this);
// snprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 61
static inline signed int snprintf(char * restrict __s, unsigned long int __n, const char * restrict __fmt, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 31
static inline signed int sprintf(char * restrict __s, const char * restrict __fmt, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// start_buffering
// file xine/xvdr_metronom.c line 192
static void start_buffering(struct xvdr_metronom_s$0 *this, signed long int disc_off);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcat
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 146
static inline char * strcat(char * restrict __dest, const char * restrict __src);
// strcpy
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 108
static inline char * strcpy(char * restrict __dest, const char * restrict __src);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strip_network_headers
// file xine_input_vdr.c line 1477
static void strip_network_headers(struct vdr_input_plugin_s *this, struct buf_element_s *buf);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strn0cpy
// file xine_input_vdr.c line 842
static char * strn0cpy(char *dest, const char *src, signed int n);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// suspend_demuxer
// file xine_input_vdr.c line 1998
static void suspend_demuxer(struct vdr_input_plugin_s *this);
// syscall
// file /usr/include/unistd.h line 1058
extern signed long int syscall(signed long int, ...);
// syslog
// file /usr/include/x86_64-linux-gnu/bits/syslog.h line 29
static inline void syslog(signed int __pri, const char *__fmt, ...);
// time_ms
// file xine/../tools/time_ms.h line 16
static unsigned long int time_ms(void);
// time_ms$link1
// file xine/../tools/time_ms.h line 16
static unsigned long int time_ms$link1(void);
// track_audio_stream_change
// file xine/demux_xvdr.c line 375
static void track_audio_stream_change(struct demux_xvdr_s *this, struct buf_element_s *buf);
// trim_str
// file xine_input_vdr.c line 3679
static const char * trim_str(const char *s);
// ts2es_dispose
// file xine/ts2es.c line 276
void ts2es_dispose(struct ts2es_s *data);
// ts2es_flush
// file xine/ts2es.c line 262
void ts2es_flush(struct ts2es_s *this);
// ts2es_init
// file xine/ts2es.c line 285
struct ts2es_s * ts2es_init(struct fifo_buffer_s *dst_fifo, enum anonymous$11 stream_type, unsigned int stream_index);
// ts2es_parse_pes
// file xine/ts2es.c line 38
static void ts2es_parse_pes(struct ts2es_s *this);
// ts2es_put
// file xine/ts2es.h line 17
struct buf_element_s * ts2es_put(struct ts2es_s *this, unsigned char *data, struct fifo_buffer_s *src_fifo);
// ts_add_payload
// file tools/ts.c line 672
static unsigned long int ts_add_payload(struct ts_state_s *ts, const unsigned char *data);
// ts_compute_crc32
// file tools/ts.c line 49
static unsigned int ts_compute_crc32(const unsigned char *data, unsigned int length, unsigned int crc32);
// ts_data_dispose
// file xine/demux_xvdr_tsdata.h line 31
void ts_data_dispose(struct ts_data_s **ts_data);
// ts_data_flush
// file xine/demux_xvdr_tsdata.h line 30
void ts_data_flush(struct ts_data_s *ts_data);
// ts_data_reset_audio
// file xine/demux_xvdr_tsdata.h line 33
void ts_data_reset_audio(struct ts_data_s *ts_data, struct fifo_buffer_s *audio_fifo, signed int keep_channel);
// ts_data_ts2es_init
// file xine/demux_xvdr_tsdata.h line 29
void ts_data_ts2es_init(struct ts_data_s **ts_data, struct fifo_buffer_s *video_fifo, struct fifo_buffer_s *audio_fifo);
// ts_data_ts2es_reset
// file xine/demux_xvdr_tsdata.c line 24
static void ts_data_ts2es_reset(struct ts_data_s *ts_data);
// ts_get_pcr
// file tools/ts.c line 599
signed long int ts_get_pcr(const unsigned char *pkt);
// ts_get_pcr_1
// file tools/ts.c line 568
static signed int ts_get_pcr_1(const unsigned char *pkt, signed long int *ppcr);
// ts_get_pcr_n
// file tools/ts.h line 187
signed int ts_get_pcr_n(const unsigned char *pkt, signed int npkt, signed long int *pcr);
// ts_get_pes
// file tools/ts.c line 745
static signed int ts_get_pes(struct ts_state_s *ts, const unsigned char *data);
// ts_get_picture_type
// file tools/ts.c line 775
signed int ts_get_picture_type(struct ts_state_s *ts, const unsigned char *data, signed int h264);
// ts_get_pts
// file tools/ts.c line 756
signed long int ts_get_pts(struct ts_state_s *ts, const unsigned char *data);
// ts_get_reg_desc
// file tools/ts.c line 196
static void ts_get_reg_desc(unsigned int *dest, const unsigned char *data, signed int length);
// ts_get_video_size
// file tools/ts.c line 788
signed int ts_get_video_size(struct ts_state_s *ts, const unsigned char *data, struct video_size_s *size, signed int h264);
// ts_parse_pat
// file xine/../tools/ts.h line 136
signed int ts_parse_pat(struct anonymous$8 *pat, const unsigned char *pkt);
// ts_parse_pmt
// file xine/../tools/ts.h line 180
signed int ts_parse_pmt(struct anonymous$10 *pmt, unsigned int program_no, const unsigned char *pkt);
// ts_scan_startcode
// file tools/ts.c line 716
static unsigned long int ts_scan_startcode(struct ts_state_s *ts);
// ts_skip_payload
// file tools/ts.c line 700
static void ts_skip_payload(struct ts_state_s *ts, unsigned long int n);
// ts_state_dispose
// file tools/ts.c line 660
void ts_state_dispose(struct ts_state_s *ts);
// ts_state_init
// file tools/ts.c line 634
struct ts_state_s * ts_state_init(unsigned long int buffer_size);
// ts_state_reset
// file tools/ts.c line 651
void ts_state_reset(struct ts_state_s *ts);
// udp_check_packet
// file xine_input_vdr.c line 4311
static struct buf_element_s * udp_check_packet(struct buf_element_s *read_buffer);
// udp_parse_control
// file xine_input_vdr.c line 4335
static struct buf_element_s * udp_parse_control(struct vdr_input_plugin_s *this, struct buf_element_s *read_buffer);
// udp_parse_header
// file xine_input_vdr.c line 4285
static struct buf_element_s * udp_parse_header(struct buf_element_s *read_buffer, signed int rtp);
// udp_process_queue
// file xine_input_vdr.c line 4388
static struct buf_element_s * udp_process_queue(struct vdr_input_plugin_s *this);
// udp_process_resend
// file xine_input_vdr.c line 4458
static void udp_process_resend(struct vdr_input_plugin_s *this);
// uncompress_osd_net
// file xine_input_vdr.c line 1931
static struct osd_rle_elem_s * uncompress_osd_net(unsigned char *raw, signed int elems, signed int datalen);
// unescape_filename
// file xine_input_vdr.c line 850
static char * unescape_filename(const char *fn);
// update_dvd_title_number
// file xine_input_vdr.c line 3662
static void update_dvd_title_number(struct vdr_input_plugin_s *this);
// update_frames
// file xine_input_vdr.c line 4754
static unsigned char update_frames(struct vdr_input_plugin_s *this, const unsigned char *data, signed int len);
// vdr_adjust_realtime_speed
// file xine_input_vdr.c line 618
static void vdr_adjust_realtime_speed(struct vdr_input_plugin_s *this);
// vdr_class_default_mrl_change_cb
// file xine_input_vdr.c line 5893
static void vdr_class_default_mrl_change_cb(void *data, struct xine_cfg_entry_s *cfg);
// vdr_class_dispose
// file xine_input_vdr.c line 6043
static void vdr_class_dispose(struct input_class_s$1 *this_gen);
// vdr_class_fast_osd_scaling_cb
// file xine_input_vdr.c line 5917
static void vdr_class_fast_osd_scaling_cb(void *data, struct xine_cfg_entry_s *cfg);
// vdr_class_get_instance
// file xine_input_vdr.c line 5924
static struct input_plugin_s$0 * vdr_class_get_instance(struct input_class_s$1 *class_gen, struct xine_stream_s *stream, const char *data);
// vdr_class_scr_tuning_step_cb
// file xine_input_vdr.c line 5901
static void vdr_class_scr_tuning_step_cb(void *data, struct xine_cfg_entry_s *cfg);
// vdr_class_smooth_scr_tuning_cb
// file xine_input_vdr.c line 5909
static void vdr_class_smooth_scr_tuning_cb(void *data, struct xine_cfg_entry_s *cfg);
// vdr_control_thread
// file xine_input_vdr.c line 3588
static void * vdr_control_thread(void *this_gen);
// vdr_event_cb
// file xine_input_vdr.c line 3819
static void vdr_event_cb(void *user_data, const struct anonymous$22 *event);
// vdr_flush_engine
// file xine_input_vdr.c line 2062
static void vdr_flush_engine(struct vdr_input_plugin_s *this, unsigned long int discard_index);
// vdr_plugin_dispose
// file xine_input_vdr.c line 5063
static void vdr_plugin_dispose(struct input_plugin_s$0 *this_gen);
// vdr_plugin_exec_osd_command
// file xine_input_vdr.c line 1964
static signed int vdr_plugin_exec_osd_command(struct vdr_input_plugin_if_s *this_if, struct osd_command_s *cmd);
// vdr_plugin_flush
// file xine_input_vdr.c line 2936
static signed int vdr_plugin_flush(struct vdr_input_plugin_s *this, signed int timeout_ms);
// vdr_plugin_flush_remote
// file xine_input_vdr.c line 3010
static signed int vdr_plugin_flush_remote(struct vdr_input_plugin_s *this, signed int timeout_ms, unsigned long int offset, signed int frame);
// vdr_plugin_get_autoplay_list
// file xine_input_vdr.c line 6026
static const char * const * vdr_plugin_get_autoplay_list(struct input_class_s$1 *this_gen, signed int *num_files);
// vdr_plugin_get_blocksize
// file xine_input_vdr.c line 5052
static unsigned int vdr_plugin_get_blocksize(struct input_plugin_s$0 *this_gen);
// vdr_plugin_get_capabilities
// file xine_input_vdr.c line 5043
static unsigned int vdr_plugin_get_capabilities(struct input_plugin_s$0 *this_gen);
// vdr_plugin_get_current_pos
// file xine_input_vdr.c line 5057
static signed long int vdr_plugin_get_current_pos(struct input_plugin_s$0 *this_gen);
// vdr_plugin_get_length
// file xine_input_vdr.c line 5038
static signed long int vdr_plugin_get_length(struct input_plugin_s$0 *this_gen);
// vdr_plugin_get_mrl
// file xine_input_vdr.c line 5210
static const char * vdr_plugin_get_mrl(struct input_plugin_s$0 *this_gen);
// vdr_plugin_get_optional_data
// file xine_input_vdr.c line 5219
static signed int vdr_plugin_get_optional_data(struct input_plugin_s$0 *this_gen, void *data, signed int data_type);
// vdr_plugin_open
// file xine_input_vdr.c line 5232
static signed int vdr_plugin_open(struct input_plugin_s$0 *this_gen);
// vdr_plugin_open_local
// file xine_input_vdr.c line 5288
static signed int vdr_plugin_open_local(struct input_plugin_s$0 *this_gen);
// vdr_plugin_open_net
// file xine_input_vdr.c line 5755
static signed int vdr_plugin_open_net(struct input_plugin_s$0 *this_gen);
// vdr_plugin_parse_control
// file xine_input_vdr.c line 3062
static signed int vdr_plugin_parse_control(struct vdr_input_plugin_if_s *this_if, const char *cmd);
// vdr_plugin_poll
// file xine_input_vdr.c line 2867
static signed int vdr_plugin_poll(struct vdr_input_plugin_s *this, signed int timeout_ms);
// vdr_plugin_read
// file xine_input_vdr.c line 4741
static signed long int vdr_plugin_read(struct input_plugin_s$0 *this_gen, void *buf_gen, signed long int len);
// vdr_plugin_read_block
// file xine_input_vdr.c line 4948
static struct buf_element_s * vdr_plugin_read_block(struct input_plugin_s$0 *this_gen, struct fifo_buffer_s *fifo, signed long int todo);
// vdr_plugin_read_block_tcp
// file xine_input_vdr.c line 4045
static struct buf_element_s * vdr_plugin_read_block_tcp(struct vdr_input_plugin_s *this);
// vdr_plugin_read_block_udp
// file xine_input_vdr.c line 4495
static struct buf_element_s * vdr_plugin_read_block_udp(struct vdr_input_plugin_s *this);
// vdr_plugin_seek
// file xine_input_vdr.c line 5033
static signed long int vdr_plugin_seek(struct input_plugin_s$0 *this_gen, signed long int offset, signed int origin);
// vdr_plugin_write
// file xine_input_vdr.c line 4658
static signed int vdr_plugin_write(struct vdr_input_plugin_if_s *this_if, signed int stream, unsigned long int pos, const char *data, signed int len);
// vdr_x_demux_control_newpts
// file xine_input_vdr.c line 2032
static void vdr_x_demux_control_newpts(struct xine_stream_s *stream, signed long int pts, unsigned int flags);
// video_size_changed
// file xine/osd_manager.c line 904
static void video_size_changed(struct osd_manager_s *this_gen, struct xine_stream_s *stream, signed int width, signed int height);
// vsnprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 74
static inline signed int vsnprintf(char * restrict __s, unsigned long int __n, const char * restrict __fmt, void **__ap);
// wait_fifos_empty
// file xine_input_vdr.c line 1383
static void wait_fifos_empty(struct xine_stream_s *stream, signed int timeout_ms);
// wait_stream_sync
// file xine_input_vdr.c line 3955
static signed int wait_stream_sync(struct vdr_input_plugin_s *this);
// wait_stream_sync::1::2::1::__cancel_routine$object
//
void __cancel_routine$object(void *);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// write_control
// file xine_input_vdr.c line 1001
static signed long int write_control(struct vdr_input_plugin_s *this, const char *str);
// write_control::1::2::1::__cancel_routine$object
//
void __cancel_routine$object(void *);
// write_control_data
// file xine_input_vdr.c line 933
static signed long int write_control_data(struct vdr_input_plugin_s *this, const void *str, unsigned long int len);
// write_rle_hdmv
// file tools/rle.c line 210
static unsigned char * write_rle_hdmv(unsigned char *rle_data, unsigned int color, unsigned int len);
// x_syslog
// file xine_input_vdr.c line 150
void x_syslog(signed int level, const char *module, const char *fmt, ...);
// xine_close
// file /usr/include/xine.h line 255
void xine_close(struct xine_stream_s *);
// xine_config_lookup_entry
// file /usr/include/xine.h line 1687
signed int xine_config_lookup_entry(struct xine_s$0 *, const char *, struct xine_cfg_entry_s *);
// xine_dispose
// file /usr/include/xine.h line 267
void xine_dispose(struct xine_stream_s *);
// xine_event_create_listener_thread
// file /usr/include/xine.h line 2164
void xine_event_create_listener_thread(struct xine_event_queue_s *, void (*)(void *, const struct anonymous$22 *), void *);
// xine_event_dispose_queue
// file /usr/include/xine.h line 2142
void xine_event_dispose_queue(struct xine_event_queue_s *);
// xine_event_new_queue
// file /usr/include/xine.h line 2141
struct xine_event_queue_s * xine_event_new_queue(struct xine_stream_s *);
// xine_event_send
// file /usr/include/xine.h line 2174
void xine_event_send(struct xine_stream_s *, const struct anonymous$22 *);
// xine_fast_memcpy$object
//
void * xine_fast_memcpy$object(void *, const void *, unsigned long int);
// xine_get_audio_lang
// file /usr/include/xine.h line 933
signed int xine_get_audio_lang(struct xine_stream_s *, signed int, char *);
// xine_get_autoplay_mrls
// file /usr/include/xine.h line 1115
const char * const * xine_get_autoplay_mrls(struct xine_s$0 *, const char *, signed int *);
// xine_get_browse_mrls
// file /usr/include/xine.h line 1106
struct anonymous$30 ** xine_get_browse_mrls(struct xine_s$0 *, const char *, const char *, signed int *);
// xine_get_current_vpts
// file /usr/include/xine.h line 467
signed long int xine_get_current_vpts(struct xine_stream_s *);
// xine_get_homedir
// file /usr/include/xine/xineutils.h line 164
const char * xine_get_homedir(void);
// xine_get_log
// file /usr/include/xine.h line 890
char * const * xine_get_log(struct xine_s$0 *, signed int);
// xine_get_log_names
// file /usr/include/xine.h line 881
const char * const * xine_get_log_names(struct xine_s$0 *);
// xine_get_log_section_count
// file /usr/include/xine.h line 878
signed int xine_get_log_section_count(struct xine_s$0 *);
// xine_get_meta_info
// file /usr/include/xine.h line 964
const char * xine_get_meta_info(struct xine_stream_s *, signed int);
// xine_get_param
// file /usr/include/xine.h line 282
signed int xine_get_param(struct xine_stream_s *, signed int);
// xine_get_pos_length
// file /usr/include/xine.h line 950
signed int xine_get_pos_length(struct xine_stream_s *, signed int *, signed int *, signed int *);
// xine_get_spu_lang
// file /usr/include/xine.h line 935
signed int xine_get_spu_lang(struct xine_stream_s *, signed int, char *);
// xine_get_stream_info
// file /usr/include/xine.h line 963
unsigned int xine_get_stream_info(struct xine_stream_s *, signed int);
// xine_monotonic_clock
// file /usr/include/xine/xineutils.h line 528
signed int xine_monotonic_clock(struct timeval *, struct timezone *);
// xine_open
// file /usr/include/xine.h line 231
signed int xine_open(struct xine_stream_s *, const char *);
// xine_play
// file /usr/include/xine.h line 243
signed int xine_play(struct xine_stream_s *, signed int, signed int);
// xine_set_param
// file /usr/include/xine.h line 281
void xine_set_param(struct xine_stream_s *, signed int, signed int);
// xine_stop
// file /usr/include/xine.h line 249
void xine_stop(struct xine_stream_s *);
// xine_stream_new
// file /usr/include/xine.h line 191
struct xine_stream_s * xine_stream_new(struct xine_s$0 *, struct xine_audio_port_s$1 *, struct xine_video_port_s$1 *);
// xine_usec_sleep
// file /usr/include/xine/xineutils.h line 185
void xine_usec_sleep(unsigned int);
// xvdr_metronom_dispose
// file xine/xvdr_metronom.c line 363
static void xvdr_metronom_dispose(struct xvdr_metronom_s$0 *this);
// xvdr_metronom_init
// file xine/xvdr_metronom.c line 376
struct xvdr_metronom_s$0 * xvdr_metronom_init(struct xine_stream_s$0 *stream);
// xvdr_metronom_unwire
// file xine/xvdr_metronom.c line 353
static void xvdr_metronom_unwire(struct xvdr_metronom_s$0 *this);
// xvdr_metronom_wire
// file xine/xvdr_metronom.c line 333
static void xvdr_metronom_wire(struct xvdr_metronom_s$0 *this);

struct anonymous$12
{
  // filename
  char *filename;
  // filesize
  signed long int filesize;
  // filemtime
  signed long int filemtime;
  // lib_handle
  void *lib_handle;
  // ref
  signed int ref;
  // no_unload
  signed int no_unload;
};

struct anonymous$30
{
  // origin
  char *origin;
  // mrl
  char *mrl;
  // link
  char *link;
  // size
  signed long int size;
  // type
  unsigned int type;
};

struct anonymous$14
{
  // file
  struct anonymous$12 *file;
  // info
  struct anonymous$13 *info;
  // plugin_class
  void *plugin_class;
  // config_entry_list
  struct xine_list_s *config_entry_list;
  // ref
  signed int ref;
  // priority
  signed int priority;
};

struct anonymous$60
{
  // file
  struct anonymous$12 *file;
  // info
  struct anonymous$61 *info;
  // plugin_class
  void *plugin_class;
  // config_entry_list
  struct xine_list_s *config_entry_list;
  // ref
  signed int ref;
  // priority
  signed int priority;
};

struct anonymous$1
{
  // file
  struct anonymous$12 *file;
  // info
  struct anonymous$0 *info;
  // plugin_class
  void *plugin_class;
  // config_entry_list
  struct xine_list_s *config_entry_list;
  // ref
  signed int ref;
  // priority
  signed int priority;
};

struct anonymous$3
{
  // file
  struct anonymous$12 *file;
  // info
  struct anonymous$2 *info;
  // plugin_class
  void *plugin_class;
  // config_entry_list
  struct xine_list_s *config_entry_list;
  // ref
  signed int ref;
  // priority
  signed int priority;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct anonymous$22
{
  // stream
  struct xine_stream_s *stream;
  // data
  void *data;
  // data_length
  signed int data_length;
  // type
  signed int type;
  // tv
  struct timeval tv;
};

struct anonymous$54
{
  // stream
  struct xine_stream_s$1 *stream;
  // data
  void *data;
  // data_length
  signed int data_length;
  // type
  signed int type;
  // tv
  struct timeval tv;
};

struct anonymous$57
{
  // pid
  unsigned short int pid;
  // type
  enum anonymous$11 type;
};

struct anonymous$58
{
  // pid
  unsigned short int pid;
  // lang
  unsigned char lang[8l];
  // comp_page_id
  unsigned short int comp_page_id;
  // aux_page_id
  unsigned short int aux_page_id;
};

struct anonymous$10
{
  // pmt
  unsigned char *pmt;
  // pmt_write_ptr
  unsigned char *pmt_write_ptr;
  // crc32
  unsigned int crc32;
  // version_number
  unsigned int version_number;
  // pcr_pid
  unsigned short int pcr_pid;
  // video_pid
  unsigned short int video_pid;
  // video_type
  enum anonymous$11 video_type;
  // audio_tracks_count
  unsigned char audio_tracks_count;
  // spu_tracks_count
  unsigned char spu_tracks_count;
  // audio_tracks
  struct anonymous$57 audio_tracks[32l];
  // spu_tracks
  struct anonymous$58 spu_tracks[32l];
};

struct anonymous$43
{
  // reserved
  void *reserved;
};

struct anonymous$15
{
  // data
  const unsigned char *data;
  // count
  signed int count;
  // index
  signed int index;
};

struct anonymous$9
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous$40
{
  // __cancel_jmp_buf
  signed long int __cancel_jmp_buf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
};

struct anonymous$39
{
  // __cancel_jmp_buf
  struct anonymous$40 __cancel_jmp_buf[1l];
  // __pad
  void *__pad[4l];
};

struct anonymous$8
{
  // program_number
  unsigned short int program_number[64l];
  // pmt_pid
  unsigned short int pmt_pid[64l];
  // version
  unsigned char version;
  // crc32
  unsigned int crc32;
  // pat_changed_flag
  unsigned char pat_changed_flag;
};

struct anonymous$25
{
  // cc
  unsigned int cc : 4;
  // ext
  unsigned int ext : 1;
  // padding
  unsigned int padding : 1;
  // version
  unsigned int version : 2;
  // paytype
  unsigned int paytype : 7;
  // marker
  unsigned int marker : 1;
  // seq
  unsigned short int seq;
  // ts
  unsigned int ts;
  // ssrc
  unsigned int ssrc;
} __attribute__ ((__packed__));

struct anonymous$38
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$53
{
  // biSize
  signed int biSize;
  // biWidth
  signed int biWidth;
  // biHeight
  signed int biHeight;
  // biPlanes
  signed short int biPlanes;
  // biBitCount
  signed short int biBitCount;
  // biCompression
  unsigned int biCompression;
  // biSizeImage
  signed int biSizeImage;
  // biXPelsPerMeter
  signed int biXPelsPerMeter;
  // biYPelsPerMeter
  signed int biYPelsPerMeter;
  // biClrUsed
  signed int biClrUsed;
  // biClrImportant
  signed int biClrImportant;
} __attribute__ ((__packed__));

struct anonymous$21
{
  // count
  signed int count;
  // holder
  unsigned long int holder;
};

union anonymous$19
{
  // data
  struct osd_rle_elem_s *data;
  // raw_data
  unsigned char *raw_data;
  // dummy01
  unsigned long int dummy01;
};

union anonymous$20
{
  // palette
  struct osd_clut_s *palette;
  // dummy02
  unsigned long int dummy02;
};

struct osd_rect_s
{
  // x1
  unsigned short int x1;
  // y1
  unsigned short int y1;
  // x2
  unsigned short int x2;
  // y2
  unsigned short int y2;
};

struct osd_command_s
{
  // size
  unsigned char size;
  // cmd
  unsigned char cmd;
  // wnd
  unsigned char wnd;
  // layer
  unsigned char layer;
  // pts
  signed long int pts;
  // delay_ms
  unsigned int delay_ms;
  // x
  unsigned short int x;
  // y
  unsigned short int y;
  // w
  unsigned short int w;
  // h
  unsigned short int h;
  // datalen
  unsigned int datalen;
  // num_rle
  unsigned int num_rle;
  // $anon0
  union anonymous$19 $anon0;
  // colors
  unsigned int colors;
  // $anon1
  union anonymous$20 $anon1;
  // dirty_area
  struct osd_rect_s dirty_area;
  // flags
  unsigned char flags;
  // scaling
  unsigned char scaling;
} __attribute__ ((__packed__));

struct anonymous$4
{
  // handle
  signed int handle;
  // cmd
  struct osd_command_s cmd;
  // extent_width
  unsigned short int extent_width;
  // extent_height
  unsigned short int extent_height;
  // video_window_x
  unsigned short int video_window_x;
  // video_window_y
  unsigned short int video_window_y;
  // video_window_w
  unsigned short int video_window_w;
  // video_window_h
  unsigned short int video_window_h;
  // last_changed_vpts
  signed long int last_changed_vpts;
  // argb_layer
  struct argb_layer_s *argb_layer;
  // argb_buffer
  unsigned int *argb_buffer;
};

struct anonymous$45
{
  // num_buttons
  signed int num_buttons;
  // str_len
  signed int str_len;
  // str
  char str[256l];
};

struct anonymous$33
{
  // priority
  signed int priority;
};

struct anonymous$46
{
  // width
  signed int width;
  // height
  signed int height;
  // aspect
  signed int aspect;
  // pan_scan
  signed int pan_scan;
};

struct anonymous$62
{
  // width
  signed int width;
  // height
  signed int height;
  // crop_left
  signed int crop_left;
  // crop_right
  signed int crop_right;
  // crop_top
  signed int crop_top;
  // crop_bottom
  signed int crop_bottom;
  // ratio_code
  signed int ratio_code;
  // interlaced
  signed int interlaced;
  // format
  signed int format;
  // img_size
  signed int img_size;
  // img
  unsigned char *img;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$6
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous$18
{
  // lock
  union anonymous$6 lock;
  // object
  void *object;
  // destructor
  void (*destructor)(void *);
  // count
  signed int count;
};

struct demux_class_s
{
  // open_plugin
  struct demux_plugin_s$0 * (*open_plugin)(struct demux_class_s *, struct xine_stream_s$1 *, struct input_plugin_s$1 *);
  // identifier
  const char *identifier;
  // description
  const char *description;
  // text_domain
  const char *text_domain;
  // mimetypes
  const char *mimetypes;
  // extensions
  const char *extensions;
  // dispose
  void (*dispose)(struct demux_class_s *);
};

struct anonymous$59
{
  // demux_class
  struct demux_class_s demux_class;
  // xine
  struct xine_s$1 *xine;
  // config
  struct config_values_s *config;
};

struct input_plugin_s$0
{
  // open
  signed int (*open)(struct input_plugin_s$0 *);
  // get_capabilities
  unsigned int (*get_capabilities)(struct input_plugin_s$0 *);
  // read
  signed long int (*read)(struct input_plugin_s$0 *, void *, signed long int);
  // read_block
  struct buf_element_s * (*read_block)(struct input_plugin_s$0 *, struct fifo_buffer_s *, signed long int);
  // seek
  signed long int (*seek)(struct input_plugin_s$0 *, signed long int, signed int);
  // seek_time
  signed long int (*seek_time)(struct input_plugin_s$0 *, signed int, signed int);
  // get_current_pos
  signed long int (*get_current_pos)(struct input_plugin_s$0 *);
  // get_current_time
  signed int (*get_current_time)(struct input_plugin_s$0 *);
  // get_length
  signed long int (*get_length)(struct input_plugin_s$0 *);
  // get_blocksize
  unsigned int (*get_blocksize)(struct input_plugin_s$0 *);
  // get_mrl
  const char * (*get_mrl)(struct input_plugin_s$0 *);
  // get_optional_data
  signed int (*get_optional_data)(struct input_plugin_s$0 *, void *, signed int);
  // dispose
  void (*dispose)(struct input_plugin_s$0 *);
  // input_class
  struct input_class_s$1 *input_class;
  // node
  void *node;
};

struct vdr_input_plugin_funcs_s
{
  // push_input_write
  signed int (*push_input_write)(struct vdr_input_plugin_if_s *, signed int, unsigned long int, const char *, signed int);
  // push_input_control
  signed int (*push_input_control)(struct vdr_input_plugin_if_s *, const char *);
  // push_input_osd
  signed int (*push_input_osd)(struct vdr_input_plugin_if_s *, struct osd_command_s *);
  // xine_input_event
  void (*xine_input_event)(struct frontend_s *, const char *, const char *);
  // intercept_osd
  signed int (*intercept_osd)(struct frontend_s *, struct osd_command_s *);
  // fe_control
  void * (*fe_control)(struct frontend_s *, const char *);
  // fe_handle
  struct frontend_s *fe_handle;
  // post_vdr_event
  signed int (*post_vdr_event)(struct vdr_input_plugin_if_s *, const char *);
};

struct anonymous$51
{
  // input_plugin
  struct input_plugin_s$0 input_plugin;
  // funcs
  struct vdr_input_plugin_funcs_s funcs;
};

struct anonymous$23
{
  // type
  unsigned short int type;
  // size
  unsigned short int size;
} __attribute__ ((__packed__));

union anonymous$24
{
  // raw
  unsigned char raw[4l];
  // rawd
  unsigned int rawd;
  // $anon0
  struct anonymous$23 $anon0;
} __attribute__ ((__packed__));

struct stream_rtp_header_ext
{
  // $anon0
  union anonymous$24 $anon0;
  // ext_data
  unsigned char ext_data[0l];
} __attribute__ ((__packed__));

struct anonymous$7
{
  // pos
  unsigned long int pos;
  // seq
  unsigned short int seq;
  // stream
  unsigned char stream;
  // payload
  unsigned char payload[0l];
} __attribute__ ((__packed__));

struct anonymous$48
{
  // padding0
  unsigned char padding0;
  // udphdr
  struct anonymous$7 udphdr;
} __attribute__ ((__packed__));

struct anonymous$49
{
  // padding1
  unsigned char padding1;
  // pos
  unsigned long int pos;
  // seq
  unsigned short int seq;
  // stream
  unsigned char stream;
} __attribute__ ((__packed__));

union anonymous$50
{
  // $anon0
  struct anonymous$48 $anon0;
  // $anon1
  struct anonymous$49 $anon1;
} __attribute__ ((__packed__));

union anonymous$31
{
  // raw
  unsigned char raw[12l];
  // rawd
  unsigned int rawd[3l];
  // $anon0
  union anonymous$50 $anon0;
} __attribute__ ((__packed__));

struct anonymous$32
{
  // hdr
  struct stream_rtp_header_ext hdr;
  // $anon0
  union anonymous$31 $anon0;
  // payload
  unsigned char payload[0l];
} __attribute__ ((__packed__));

struct anonymous$5
{
  // extent_width
  unsigned short int extent_width;
  // extent_height
  unsigned short int extent_height;
  // layer
  unsigned int layer;
  // scaling
  unsigned char scaling;
};

struct mpeg_rational_s
{
  // num
  signed int num;
  // den
  signed int den;
};

struct anonymous$16
{
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // pixel_aspect
  struct mpeg_rational_s pixel_aspect;
};

struct anonymous$29
{
  // cnt
  unsigned int cnt;
  // fill_avg
  unsigned int fill_avg;
  // fill_min
  unsigned int fill_min;
  // fill_max
  unsigned int fill_max;
};

struct anonymous$41
{
  // pos
  unsigned long int pos;
  // payload
  unsigned char payload[0l];
};

struct anonymous$56
{
  // pos
  unsigned long int pos;
  // len
  unsigned int len;
  // stream
  unsigned char stream;
  // payload
  unsigned char payload[0l];
} __attribute__ ((__packed__));

struct anonymous$13
{
  // type
  unsigned char type;
  // API
  unsigned char API;
  // id
  const char *id;
  // version
  unsigned int version;
  // special_info
  const void *special_info;
  // init
  void * (*init)(struct xine_s$0 *, void *);
};

struct anonymous$61
{
  // type
  unsigned char type;
  // API
  unsigned char API;
  // id
  const char *id;
  // version
  unsigned int version;
  // special_info
  const void *special_info;
  // init
  void * (*init)(struct xine_s$1 *, void *);
};

struct anonymous$0
{
  // type
  unsigned char type;
  // API
  unsigned char API;
  // id
  const char *id;
  // version
  unsigned int version;
  // special_info
  const void *special_info;
  // init
  void * (*init)(struct xine_s$2 *, void *);
};

struct anonymous$2
{
  // type
  unsigned char type;
  // API
  unsigned char API;
  // id
  const char *id;
  // version
  unsigned int version;
  // special_info
  const void *special_info;
  // init
  void * (*init)(struct xine_s *, void *);
};

union anonymous$27
{
  // hdr_ext
  struct stream_rtp_header_ext hdr_ext[0l];
  // payload
  unsigned char payload[0l];
} __attribute__ ((__packed__));

union anonymous$26
{
  // raw
  unsigned char raw[12l];
  // $anon0
  struct anonymous$25 $anon0;
} __attribute__ ((__packed__));

union anonymous$44
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous$37
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$17
{
  // __data
  struct anonymous$38 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct scr_plugin_s
{
  // get_priority
  signed int (*get_priority)(struct scr_plugin_s *);
  // set_fine_speed
  signed int (*set_fine_speed)(struct scr_plugin_s *, signed int);
  // adjust
  void (*adjust)(struct scr_plugin_s *, signed long int);
  // start
  void (*start)(struct scr_plugin_s *, signed long int);
  // get_current
  signed long int (*get_current)(struct scr_plugin_s *);
  // exit
  void (*exit)(struct scr_plugin_s *);
  // clock
  struct metronom_clock_s *clock;
  // interface_version
  signed int interface_version;
};

struct adjustable_scr_s
{
  // scr
  struct scr_plugin_s scr;
  // set_speed_tuning
  void (*set_speed_tuning)(struct adjustable_scr_s *, double);
  // set_speed_base
  void (*set_speed_base)(struct adjustable_scr_s *, signed int);
  // jump
  void (*jump)(struct adjustable_scr_s *, signed int);
  // set_buffering
  void (*set_buffering)(struct adjustable_scr_s *, signed int);
  // got_pcr
  void (*got_pcr)(struct adjustable_scr_s *, signed long int);
  // dispose
  void (*dispose)(struct adjustable_scr_s *);
};

union anonymous
{
  // scr
  struct scr_plugin_s scr;
  // ascr
  struct adjustable_scr_s ascr;
};

struct vdr_input_plugin_if_s
{
  // input_plugin
  struct input_plugin_s$0 input_plugin;
  // f
  struct vdr_input_plugin_funcs_s f;
};

union anonymous$28
{
  // iface
  struct vdr_input_plugin_if_s iface;
  // $anon0
  struct anonymous$51 $anon0;
};

union anonymous$34
{
  // cb
  unsigned char cb;
  // g
  unsigned char g;
};

union anonymous$35
{
  // cr
  unsigned char cr;
  // b
  unsigned char b;
};

union anonymous$36
{
  // y
  unsigned char y;
  // r
  unsigned char r;
};

union anonymous$47
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous$55
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct anonymous$52
{
  // event
  const unsigned int event;
  // name
  const char name[12l];
};

struct anonymous$42
{
  // type
  const unsigned int type;
  // name
  const char name[28l];
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct ao_format_s
{
  // bits
  unsigned int bits;
  // rate
  unsigned int rate;
  // mode
  signed int mode;
};

struct argb_layer_s
{
  // mutex
  union anonymous$6 mutex;
  // buffer
  unsigned int *buffer;
  // x1
  signed int x1;
  // y1
  signed int y1;
  // x2
  signed int x2;
  // y2
  signed int y2;
  // ref_count
  signed int ref_count;
};

struct audio_buffer_s$1
{
  // next
  struct audio_buffer_s$1 *next;
  // mem
  signed short int *mem;
  // mem_size
  signed int mem_size;
  // num_frames
  signed int num_frames;
  // vpts
  signed long int vpts;
  // frame_header_count
  unsigned int frame_header_count;
  // first_access_unit
  unsigned int first_access_unit;
  // extra_info
  struct extra_info_s *extra_info;
  // stream
  struct xine_stream_s *stream;
  // format
  struct ao_format_s format;
};

struct audio_buffer_s
{
  // next
  struct audio_buffer_s *next;
  // mem
  signed short int *mem;
  // mem_size
  signed int mem_size;
  // num_frames
  signed int num_frames;
  // vpts
  signed long int vpts;
  // frame_header_count
  unsigned int frame_header_count;
  // first_access_unit
  unsigned int first_access_unit;
  // extra_info
  struct extra_info_s *extra_info;
  // stream
  struct xine_stream_s$1 *stream;
  // format
  struct ao_format_s format;
};

struct audio_buffer_s$0
{
  // next
  struct audio_buffer_s$0 *next;
  // mem
  signed short int *mem;
  // mem_size
  signed int mem_size;
  // num_frames
  signed int num_frames;
  // vpts
  signed long int vpts;
  // frame_header_count
  unsigned int frame_header_count;
  // first_access_unit
  unsigned int first_access_unit;
  // extra_info
  struct extra_info_s *extra_info;
  // stream
  struct xine_stream_s$0 *stream;
  // format
  struct ao_format_s format;
};

struct audio_decoder_s
{
  // decode_data
  void (*decode_data)(struct audio_decoder_s *, struct buf_element_s *);
  // reset
  void (*reset)(struct audio_decoder_s *);
  // discontinuity
  void (*discontinuity)(struct audio_decoder_s *);
  // dispose
  void (*dispose)(struct audio_decoder_s *);
  // node
  void *node;
};

struct buf_element_s
{
  // next
  struct buf_element_s *next;
  // mem
  unsigned char *mem;
  // content
  unsigned char *content;
  // size
  signed int size;
  // max_size
  signed int max_size;
  // pts
  signed long int pts;
  // disc_off
  signed long int disc_off;
  // extra_info
  struct extra_info_s *extra_info;
  // decoder_flags
  unsigned int decoder_flags;
  // decoder_info
  unsigned int decoder_info[5l];
  // decoder_info_ptr
  void *decoder_info_ptr[5l];
  // free_buffer
  void (*free_buffer)(struct buf_element_s *);
  // source
  void *source;
  // type
  unsigned int type;
};

struct cfg_entry_s
{
  // next
  struct cfg_entry_s *next;
  // config
  struct config_values_s *config;
  // key
  char *key;
  // type
  signed int type;
  // exp_level
  signed int exp_level;
  // unknown_value
  char *unknown_value;
  // str_value
  char *str_value;
  // str_default
  char *str_default;
  // num_value
  signed int num_value;
  // num_default
  signed int num_default;
  // range_min
  signed int range_min;
  // range_max
  signed int range_max;
  // enum_values
  char **enum_values;
  // description
  char *description;
  // help
  char *help;
  // callback
  void (*callback)(void *, struct xine_cfg_entry_s *);
  // callback_data
  void *callback_data;
};

struct config_values_s
{
  // register_string
  char * (*register_string)(struct config_values_s *, const char *, const char *, const char *, const char *, signed int, void (*)(void *, struct xine_cfg_entry_s *), void *);
  // register_filename
  char * (*register_filename)(struct config_values_s *, const char *, const char *, signed int, const char *, const char *, signed int, void (*)(void *, struct xine_cfg_entry_s *), void *);
  // register_range
  signed int (*register_range)(struct config_values_s *, const char *, signed int, signed int, signed int, const char *, const char *, signed int, void (*)(void *, struct xine_cfg_entry_s *), void *);
  // register_enum
  signed int (*register_enum)(struct config_values_s *, const char *, signed int, char **, const char *, const char *, signed int, void (*)(void *, struct xine_cfg_entry_s *), void *);
  // register_num
  signed int (*register_num)(struct config_values_s *, const char *, signed int, const char *, const char *, signed int, void (*)(void *, struct xine_cfg_entry_s *), void *);
  // register_bool
  signed int (*register_bool)(struct config_values_s *, const char *, signed int, const char *, const char *, signed int, void (*)(void *, struct xine_cfg_entry_s *), void *);
  // register_entry
  void (*register_entry)(struct config_values_s *, struct cfg_entry_s *);
  // update_num
  void (*update_num)(struct config_values_s *, const char *, signed int);
  // update_string
  void (*update_string)(struct config_values_s *, const char *, const char *);
  // parse_enum
  signed int (*parse_enum)(const char *, const char **);
  // lookup_entry
  struct cfg_entry_s * (*lookup_entry)(struct config_values_s *, const char *);
  // unregister_callback
  void (*unregister_callback)(struct config_values_s *, const char *);
  // dispose
  void (*dispose)(struct config_values_s *);
  // set_new_entry_callback
  void (*set_new_entry_callback)(struct config_values_s *, void (*)(void *, struct xine_cfg_entry_s *), void *);
  // unset_new_entry_callback
  void (*unset_new_entry_callback)(struct config_values_s *);
  // get_serialized_entry
  char * (*get_serialized_entry)(struct config_values_s *, const char *);
  // register_serialized_entry
  char * (*register_serialized_entry)(struct config_values_s *, const char *);
  // first
  struct cfg_entry_s *first;
  // last
  struct cfg_entry_s *last;
  // cur
  struct cfg_entry_s *cur;
  // new_entry_cb
  void (*new_entry_cb)(void *, struct xine_cfg_entry_s *);
  // new_entry_cbdata
  void *new_entry_cbdata;
  // config_lock
  union anonymous$6 config_lock;
  // current_version
  signed int current_version;
};

struct demux_class_s$0
{
  // open_plugin
  struct demux_plugin_s * (*open_plugin)(struct demux_class_s$0 *, struct xine_stream_s *, struct input_plugin_s$0 *);
  // identifier
  const char *identifier;
  // description
  const char *description;
  // text_domain
  const char *text_domain;
  // mimetypes
  const char *mimetypes;
  // extensions
  const char *extensions;
  // dispose
  void (*dispose)(struct demux_class_s$0 *);
};

struct demux_plugin_s
{
  // send_headers
  void (*send_headers)(struct demux_plugin_s *);
  // seek
  signed int (*seek)(struct demux_plugin_s *, signed long int, signed int, signed int);
  // send_chunk
  signed int (*send_chunk)(struct demux_plugin_s *);
  // dispose
  void (*dispose)(struct demux_plugin_s *);
  // get_status
  signed int (*get_status)(struct demux_plugin_s *);
  // get_stream_length
  signed int (*get_stream_length)(struct demux_plugin_s *);
  // get_capabilities
  unsigned int (*get_capabilities)(struct demux_plugin_s *);
  // get_optional_data
  signed int (*get_optional_data)(struct demux_plugin_s *, void *, signed int);
  // demux_class
  struct demux_class_s$0 *demux_class;
  // node
  void *node;
};

struct demux_plugin_s$0
{
  // send_headers
  void (*send_headers)(struct demux_plugin_s$0 *);
  // seek
  signed int (*seek)(struct demux_plugin_s$0 *, signed long int, signed int, signed int);
  // send_chunk
  signed int (*send_chunk)(struct demux_plugin_s$0 *);
  // dispose
  void (*dispose)(struct demux_plugin_s$0 *);
  // get_status
  signed int (*get_status)(struct demux_plugin_s$0 *);
  // get_stream_length
  signed int (*get_stream_length)(struct demux_plugin_s$0 *);
  // get_capabilities
  unsigned int (*get_capabilities)(struct demux_plugin_s$0 *);
  // get_optional_data
  signed int (*get_optional_data)(struct demux_plugin_s$0 *, void *, signed int);
  // demux_class
  struct demux_class_s *demux_class;
  // node
  void *node;
};

struct demux_xvdr_s
{
  // demux_plugin
  struct demux_plugin_s$0 demux_plugin;
  // stream
  struct xine_stream_s$1 *stream;
  // audio_fifo
  struct fifo_buffer_s *audio_fifo;
  // video_fifo
  struct fifo_buffer_s *video_fifo;
  // input
  struct input_plugin_s$1 *input;
  // ts_data
  struct ts_data_s *ts_data;
  // last_pts
  signed long int last_pts[2l];
  // last_vpts
  signed long int last_vpts;
  // status
  signed int status;
  // video_type
  unsigned int video_type;
  // audio_type
  unsigned int audio_type;
  // subtitle_type
  unsigned int subtitle_type;
  // pts
  signed long int pts;
  // dts
  signed long int dts;
  // packet_len
  unsigned int packet_len;
  // stream_id
  unsigned char stream_id;
  // send_newpts
  unsigned char send_newpts : 1;
  // buf_flag_seek
  unsigned char buf_flag_seek : 1;
  // ffmpeg_mpeg2_decoder
  unsigned char ffmpeg_mpeg2_decoder : 1;
  // coreavc_h264_decoder
  unsigned char coreavc_h264_decoder : 1;
  // bih_posted
  unsigned char bih_posted : 1;
};

struct extra_info_s
{
  // input_normpos
  signed int input_normpos;
  // input_time
  signed int input_time;
  // frame_number
  unsigned int frame_number;
  // seek_count
  signed int seek_count;
  // vpts
  signed long int vpts;
  // invalid
  signed int invalid;
  // total_time
  signed int total_time;
};

struct fifo_buffer_s
{
  // first
  struct buf_element_s *first;
  // last
  struct buf_element_s *last;
  // fifo_size
  signed int fifo_size;
  // fifo_data_size
  unsigned int fifo_data_size;
  // fifo_empty_cb_data
  void *fifo_empty_cb_data;
  // mutex
  union anonymous$6 mutex;
  // not_empty
  union anonymous$17 not_empty;
  // put
  void (*put)(struct fifo_buffer_s *, struct buf_element_s *);
  // get
  struct buf_element_s * (*get)(struct fifo_buffer_s *);
  // clear
  void (*clear)(struct fifo_buffer_s *);
  // size
  signed int (*size)(struct fifo_buffer_s *);
  // num_free
  signed int (*num_free)(struct fifo_buffer_s *);
  // data_size
  unsigned int (*data_size)(struct fifo_buffer_s *);
  // dispose
  void (*dispose)(struct fifo_buffer_s *);
  // buffer_pool_alloc
  struct buf_element_s * (*buffer_pool_alloc)(struct fifo_buffer_s *);
  // buffer_pool_try_alloc
  struct buf_element_s * (*buffer_pool_try_alloc)(struct fifo_buffer_s *);
  // insert
  void (*insert)(struct fifo_buffer_s *, struct buf_element_s *);
  // register_alloc_cb
  void (*register_alloc_cb)(struct fifo_buffer_s *, void (*)(struct fifo_buffer_s *, void *), void *);
  // register_put_cb
  void (*register_put_cb)(struct fifo_buffer_s *, void (*)(struct fifo_buffer_s *, struct buf_element_s *, void *), void *);
  // register_get_cb
  void (*register_get_cb)(struct fifo_buffer_s *, void (*)(struct fifo_buffer_s *, struct buf_element_s *, void *), void *);
  // unregister_alloc_cb
  void (*unregister_alloc_cb)(struct fifo_buffer_s *, void (*)(struct fifo_buffer_s *, void *));
  // unregister_put_cb
  void (*unregister_put_cb)(struct fifo_buffer_s *, void (*)(struct fifo_buffer_s *, struct buf_element_s *, void *));
  // unregister_get_cb
  void (*unregister_get_cb)(struct fifo_buffer_s *, void (*)(struct fifo_buffer_s *, struct buf_element_s *, void *));
  // buffer_pool_top
  struct buf_element_s *buffer_pool_top;
  // buffer_pool_mutex
  union anonymous$6 buffer_pool_mutex;
  // buffer_pool_cond_not_empty
  union anonymous$17 buffer_pool_cond_not_empty;
  // buffer_pool_num_free
  signed int buffer_pool_num_free;
  // buffer_pool_capacity
  signed int buffer_pool_capacity;
  // buffer_pool_buf_size
  signed int buffer_pool_buf_size;
  // buffer_pool_base
  void *buffer_pool_base;
  // alloc_cb
  void (*alloc_cb[5l])(struct fifo_buffer_s *, void *);
  // put_cb
  void (*put_cb[5l])(struct fifo_buffer_s *, struct buf_element_s *, void *);
  // get_cb
  void (*get_cb[5l])(struct fifo_buffer_s *, struct buf_element_s *, void *);
  // alloc_cb_data
  void *alloc_cb_data[5l];
  // put_cb_data
  void *put_cb_data[5l];
  // get_cb_data
  void *get_cb_data[5l];
};

struct fifo_input_plugin_s
{
  // i
  struct input_plugin_s$0 i;
  // master
  struct vdr_input_plugin_s *master;
  // stream
  struct xine_stream_s *stream;
  // buffer
  struct fifo_buffer_s *buffer;
  // buffer_pool
  struct fifo_buffer_s *buffer_pool;
  // pos
  signed long int pos;
};

struct grab_data_s
{
  // size
  unsigned long int size;
  // data
  char *data;
};

struct in6_addr
{
  // __in6_u
  union anonymous$44 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct input_class_s$1
{
  // get_instance
  struct input_plugin_s$0 * (*get_instance)(struct input_class_s$1 *, struct xine_stream_s *, const char *);
  // identifier
  const char *identifier;
  // description
  const char *description;
  // text_domain
  const char *text_domain;
  // get_dir
  struct anonymous$30 ** (*get_dir)(struct input_class_s$1 *, const char *, signed int *);
  // get_autoplay_list
  const char * const * (*get_autoplay_list)(struct input_class_s$1 *, signed int *);
  // dispose
  void (*dispose)(struct input_class_s$1 *);
  // eject_media
  signed int (*eject_media)(struct input_class_s$1 *);
};

struct input_class_s
{
  // get_instance
  struct input_plugin_s$1 * (*get_instance)(struct input_class_s *, struct xine_stream_s$1 *, const char *);
  // identifier
  const char *identifier;
  // description
  const char *description;
  // text_domain
  const char *text_domain;
  // get_dir
  struct anonymous$30 ** (*get_dir)(struct input_class_s *, const char *, signed int *);
  // get_autoplay_list
  const char * const * (*get_autoplay_list)(struct input_class_s *, signed int *);
  // dispose
  void (*dispose)(struct input_class_s *);
  // eject_media
  signed int (*eject_media)(struct input_class_s *);
};

struct input_class_s$0
{
  // get_instance
  struct input_plugin_s * (*get_instance)(struct input_class_s$0 *, struct xine_stream_s$0 *, const char *);
  // identifier
  const char *identifier;
  // description
  const char *description;
  // text_domain
  const char *text_domain;
  // get_dir
  struct anonymous$30 ** (*get_dir)(struct input_class_s$0 *, const char *, signed int *);
  // get_autoplay_list
  const char * const * (*get_autoplay_list)(struct input_class_s$0 *, signed int *);
  // dispose
  void (*dispose)(struct input_class_s$0 *);
  // eject_media
  signed int (*eject_media)(struct input_class_s$0 *);
};

struct input_plugin_s$1
{
  // open
  signed int (*open)(struct input_plugin_s$1 *);
  // get_capabilities
  unsigned int (*get_capabilities)(struct input_plugin_s$1 *);
  // read
  signed long int (*read)(struct input_plugin_s$1 *, void *, signed long int);
  // read_block
  struct buf_element_s * (*read_block)(struct input_plugin_s$1 *, struct fifo_buffer_s *, signed long int);
  // seek
  signed long int (*seek)(struct input_plugin_s$1 *, signed long int, signed int);
  // seek_time
  signed long int (*seek_time)(struct input_plugin_s$1 *, signed int, signed int);
  // get_current_pos
  signed long int (*get_current_pos)(struct input_plugin_s$1 *);
  // get_current_time
  signed int (*get_current_time)(struct input_plugin_s$1 *);
  // get_length
  signed long int (*get_length)(struct input_plugin_s$1 *);
  // get_blocksize
  unsigned int (*get_blocksize)(struct input_plugin_s$1 *);
  // get_mrl
  const char * (*get_mrl)(struct input_plugin_s$1 *);
  // get_optional_data
  signed int (*get_optional_data)(struct input_plugin_s$1 *, void *, signed int);
  // dispose
  void (*dispose)(struct input_plugin_s$1 *);
  // input_class
  struct input_class_s *input_class;
  // node
  void *node;
};

struct input_plugin_s
{
  // open
  signed int (*open)(struct input_plugin_s *);
  // get_capabilities
  unsigned int (*get_capabilities)(struct input_plugin_s *);
  // read
  signed long int (*read)(struct input_plugin_s *, void *, signed long int);
  // read_block
  struct buf_element_s * (*read_block)(struct input_plugin_s *, struct fifo_buffer_s *, signed long int);
  // seek
  signed long int (*seek)(struct input_plugin_s *, signed long int, signed int);
  // seek_time
  signed long int (*seek_time)(struct input_plugin_s *, signed int, signed int);
  // get_current_pos
  signed long int (*get_current_pos)(struct input_plugin_s *);
  // get_current_time
  signed int (*get_current_time)(struct input_plugin_s *);
  // get_length
  signed long int (*get_length)(struct input_plugin_s *);
  // get_blocksize
  unsigned int (*get_blocksize)(struct input_plugin_s *);
  // get_mrl
  const char * (*get_mrl)(struct input_plugin_s *);
  // get_optional_data
  signed int (*get_optional_data)(struct input_plugin_s *, void *, signed int);
  // dispose
  void (*dispose)(struct input_plugin_s *);
  // input_class
  struct input_class_s$0 *input_class;
  // node
  void *node;
};

struct ip_mreq
{
  // imr_multiaddr
  struct in_addr imr_multiaddr;
  // imr_interface
  struct in_addr imr_interface;
};

struct metronom_clock_s
{
  // set_option
  void (*set_option)(struct metronom_clock_s *, signed int, signed long int);
  // get_option
  signed long int (*get_option)(struct metronom_clock_s *, signed int);
  // dummy1
  void *dummy1;
  // dummy2
  void *dummy2;
  // dummy3
  void *dummy3;
  // get_current_time
  signed long int (*get_current_time)(struct metronom_clock_s *);
  // adjust_clock
  void (*adjust_clock)(struct metronom_clock_s *, signed long int);
  // dummy4
  void *dummy4;
  // register_scr
  signed int (*register_scr)(struct metronom_clock_s *, struct scr_plugin_s *);
  // unregister_scr
  void (*unregister_scr)(struct metronom_clock_s *, struct scr_plugin_s *);
  // dummy5
  void *dummy5;
  // dummy6
  void *dummy6;
  // dummy7
  void *dummy7;
  // dummy8
  void *dummy8;
  // dummy9
  unsigned long int dummy9;
  // dummy10
  signed int dummy10;
  // dummy11
  signed int dummy11;
  // speed
  signed int speed;
};

struct metronom_s$0
{
  // set_audio_rate
  void (*set_audio_rate)(struct metronom_s$0 *, signed long int);
  // got_video_frame
  void (*got_video_frame)(struct metronom_s$0 *, struct vo_frame_s$1 *);
  // got_audio_samples
  signed long int (*got_audio_samples)(struct metronom_s$0 *, signed long int, signed int);
  // got_spu_packet
  signed long int (*got_spu_packet)(struct metronom_s$0 *, signed long int);
  // handle_audio_discontinuity
  void (*handle_audio_discontinuity)(struct metronom_s$0 *, signed int, signed long int);
  // handle_video_discontinuity
  void (*handle_video_discontinuity)(struct metronom_s$0 *, signed int, signed long int);
  // set_option
  void (*set_option)(struct metronom_s$0 *, signed int, signed long int);
  // get_option
  signed long int (*get_option)(struct metronom_s$0 *, signed int);
  // set_master
  void (*set_master)(struct metronom_s$0 *, struct metronom_s$0 *);
  // exit
  void (*exit)(struct metronom_s$0 *);
};

struct metronom_s$1
{
  // set_audio_rate
  void (*set_audio_rate)(struct metronom_s$1 *, signed long int);
  // got_video_frame
  void (*got_video_frame)(struct metronom_s$1 *, struct vo_frame_s *);
  // got_audio_samples
  signed long int (*got_audio_samples)(struct metronom_s$1 *, signed long int, signed int);
  // got_spu_packet
  signed long int (*got_spu_packet)(struct metronom_s$1 *, signed long int);
  // handle_audio_discontinuity
  void (*handle_audio_discontinuity)(struct metronom_s$1 *, signed int, signed long int);
  // handle_video_discontinuity
  void (*handle_video_discontinuity)(struct metronom_s$1 *, signed int, signed long int);
  // set_option
  void (*set_option)(struct metronom_s$1 *, signed int, signed long int);
  // get_option
  signed long int (*get_option)(struct metronom_s$1 *, signed int);
  // set_master
  void (*set_master)(struct metronom_s$1 *, struct metronom_s$1 *);
  // exit
  void (*exit)(struct metronom_s$1 *);
};

struct metronom_s
{
  // set_audio_rate
  void (*set_audio_rate)(struct metronom_s *, signed long int);
  // got_video_frame
  void (*got_video_frame)(struct metronom_s *, struct vo_frame_s$0 *);
  // got_audio_samples
  signed long int (*got_audio_samples)(struct metronom_s *, signed long int, signed int);
  // got_spu_packet
  signed long int (*got_spu_packet)(struct metronom_s *, signed long int);
  // handle_audio_discontinuity
  void (*handle_audio_discontinuity)(struct metronom_s *, signed int, signed long int);
  // handle_video_discontinuity
  void (*handle_video_discontinuity)(struct metronom_s *, signed int, signed long int);
  // set_option
  void (*set_option)(struct metronom_s *, signed int, signed long int);
  // get_option
  signed long int (*get_option)(struct metronom_s *, signed int);
  // set_master
  void (*set_master)(struct metronom_s *, struct metronom_s *);
  // exit
  void (*exit)(struct metronom_s *);
};

struct osd_clut_s
{
  // $anon0
  union anonymous$34 $anon0;
  // $anon1
  union anonymous$35 $anon1;
  // $anon2
  union anonymous$36 $anon2;
  // alpha
  unsigned char alpha;
} __attribute__ ((__packed__));

struct osd_manager_s
{
  // command
  signed int (*command)(struct osd_manager_s *, struct osd_command_s *, struct xine_stream_s *);
  // dispose
  void (*dispose)(struct osd_manager_s *, struct xine_stream_s *);
  // video_size_changed
  void (*video_size_changed)(struct osd_manager_s *, struct xine_stream_s *, signed int, signed int);
  // argb_supported
  signed int (*argb_supported)(struct xine_stream_s *);
};

struct osd_manager_impl_s
{
  // mgr
  struct osd_manager_s mgr;
  // lock
  union anonymous$6 lock;
  // ticket_acquired
  unsigned char ticket_acquired;
  // stream
  struct xine_stream_s *stream;
  // video_width
  unsigned short int video_width;
  // video_height
  unsigned short int video_height;
  // win_width
  unsigned short int win_width;
  // win_height
  unsigned short int win_height;
  // vo_scaling
  unsigned char vo_scaling;
  // osd
  struct anonymous$4 osd[50l];
};

struct osd_object_s$1
{
  // next
  struct osd_object_s$1 *next;
  // renderer
  struct osd_renderer_s$1 *renderer;
  // width
  signed int width;
  // height
  signed int height;
  // area
  unsigned char *area;
  // area_touched
  signed int area_touched;
  // display_x
  signed int display_x;
  // display_y
  signed int display_y;
  // video_window_x
  signed int video_window_x;
  // video_window_y
  signed int video_window_y;
  // video_window_width
  signed int video_window_width;
  // video_window_height
  signed int video_window_height;
  // extent_width
  signed int extent_width;
  // extent_height
  signed int extent_height;
  // x1
  signed int x1;
  // y1
  signed int y1;
  // x2
  signed int x2;
  // y2
  signed int y2;
  // color
  unsigned int color[256l];
  // trans
  unsigned char trans[256l];
  // font
  struct osd_font_s *font;
  // ft2
  struct osd_ft2context_s *ft2;
  // argb_layer
  struct argb_layer_s *argb_layer;
  // handle
  signed int handle;
};

struct osd_object_s
{
  // next
  struct osd_object_s *next;
  // renderer
  struct osd_renderer_s *renderer;
  // width
  signed int width;
  // height
  signed int height;
  // area
  unsigned char *area;
  // area_touched
  signed int area_touched;
  // display_x
  signed int display_x;
  // display_y
  signed int display_y;
  // video_window_x
  signed int video_window_x;
  // video_window_y
  signed int video_window_y;
  // video_window_width
  signed int video_window_width;
  // video_window_height
  signed int video_window_height;
  // extent_width
  signed int extent_width;
  // extent_height
  signed int extent_height;
  // x1
  signed int x1;
  // y1
  signed int y1;
  // x2
  signed int x2;
  // y2
  signed int y2;
  // color
  unsigned int color[256l];
  // trans
  unsigned char trans[256l];
  // font
  struct osd_font_s *font;
  // ft2
  struct osd_ft2context_s *ft2;
  // argb_layer
  struct argb_layer_s *argb_layer;
  // handle
  signed int handle;
};

struct osd_object_s$0
{
  // next
  struct osd_object_s$0 *next;
  // renderer
  struct osd_renderer_s$0 *renderer;
  // width
  signed int width;
  // height
  signed int height;
  // area
  unsigned char *area;
  // area_touched
  signed int area_touched;
  // display_x
  signed int display_x;
  // display_y
  signed int display_y;
  // video_window_x
  signed int video_window_x;
  // video_window_y
  signed int video_window_y;
  // video_window_width
  signed int video_window_width;
  // video_window_height
  signed int video_window_height;
  // extent_width
  signed int extent_width;
  // extent_height
  signed int extent_height;
  // x1
  signed int x1;
  // y1
  signed int y1;
  // x2
  signed int x2;
  // y2
  signed int y2;
  // color
  unsigned int color[256l];
  // trans
  unsigned char trans[256l];
  // font
  struct osd_font_s *font;
  // ft2
  struct osd_ft2context_s *ft2;
  // argb_layer
  struct argb_layer_s *argb_layer;
  // handle
  signed int handle;
};

struct video_overlay_object_s
{
  // handle
  signed int handle;
  // object_type
  unsigned int object_type;
  // pts
  signed long int pts;
  // overlay
  struct vo_overlay_s *overlay;
  // palette
  unsigned int *palette;
  // palette_type
  unsigned int palette_type;
};

struct video_overlay_event_s
{
  // vpts
  signed long int vpts;
  // event_type
  unsigned int event_type;
  // object
  struct video_overlay_object_s object;
};

struct osd_renderer_s$1
{
  // stream
  struct xine_stream_s *stream;
  // new_object
  struct osd_object_s$1 * (*new_object)(struct osd_renderer_s$1 *, signed int, signed int);
  // free_object
  void (*free_object)(struct osd_object_s$1 *);
  // show
  signed int (*show)(struct osd_object_s$1 *, signed long int);
  // hide
  signed int (*hide)(struct osd_object_s$1 *, signed long int);
  // point
  void (*point)(struct osd_object_s$1 *, signed int, signed int, signed int);
  // line
  void (*line)(struct osd_object_s$1 *, signed int, signed int, signed int, signed int, signed int);
  // filled_rect
  void (*filled_rect)(struct osd_object_s$1 *, signed int, signed int, signed int, signed int, signed int);
  // set_palette
  void (*set_palette)(struct osd_object_s$1 *, const unsigned int *, const unsigned char *);
  // set_text_palette
  void (*set_text_palette)(struct osd_object_s$1 *, signed int, signed int);
  // get_palette
  void (*get_palette)(struct osd_object_s$1 *, unsigned int *, unsigned char *);
  // set_position
  void (*set_position)(struct osd_object_s$1 *, signed int, signed int);
  // set_font
  signed int (*set_font)(struct osd_object_s$1 *, const char *, signed int);
  // set_encoding
  signed int (*set_encoding)(struct osd_object_s$1 *, const char *);
  // render_text
  signed int (*render_text)(struct osd_object_s$1 *, signed int, signed int, const char *, signed int);
  // get_text_size
  signed int (*get_text_size)(struct osd_object_s$1 *, const char *, signed int *, signed int *);
  // close
  void (*close)(struct osd_renderer_s$1 *);
  // clear
  void (*clear)(struct osd_object_s$1 *);
  // draw_bitmap
  void (*draw_bitmap)(struct osd_object_s$1 *, unsigned char *, signed int, signed int, signed int, signed int, unsigned char *);
  // show_unscaled
  signed int (*show_unscaled)(struct osd_object_s$1 *, signed long int);
  // get_capabilities
  unsigned int (*get_capabilities)(struct osd_object_s$1 *);
  // set_extent
  void (*set_extent)(struct osd_object_s$1 *, signed int, signed int);
  // set_argb_buffer
  void (*set_argb_buffer)(struct osd_object_s$1 *, unsigned int *, signed int, signed int, signed int, signed int);
  // set_video_window
  void (*set_video_window)(struct osd_object_s$1 *, signed int, signed int, signed int, signed int);
  // osd_mutex
  union anonymous$6 osd_mutex;
  // event
  struct video_overlay_event_s event;
  // osds
  struct osd_object_s$1 *osds;
  // fonts
  struct osd_font_s *fonts;
  // textpalette
  signed int textpalette;
};

struct osd_renderer_s
{
  // stream
  struct xine_stream_s$1 *stream;
  // new_object
  struct osd_object_s * (*new_object)(struct osd_renderer_s *, signed int, signed int);
  // free_object
  void (*free_object)(struct osd_object_s *);
  // show
  signed int (*show)(struct osd_object_s *, signed long int);
  // hide
  signed int (*hide)(struct osd_object_s *, signed long int);
  // point
  void (*point)(struct osd_object_s *, signed int, signed int, signed int);
  // line
  void (*line)(struct osd_object_s *, signed int, signed int, signed int, signed int, signed int);
  // filled_rect
  void (*filled_rect)(struct osd_object_s *, signed int, signed int, signed int, signed int, signed int);
  // set_palette
  void (*set_palette)(struct osd_object_s *, const unsigned int *, const unsigned char *);
  // set_text_palette
  void (*set_text_palette)(struct osd_object_s *, signed int, signed int);
  // get_palette
  void (*get_palette)(struct osd_object_s *, unsigned int *, unsigned char *);
  // set_position
  void (*set_position)(struct osd_object_s *, signed int, signed int);
  // set_font
  signed int (*set_font)(struct osd_object_s *, const char *, signed int);
  // set_encoding
  signed int (*set_encoding)(struct osd_object_s *, const char *);
  // render_text
  signed int (*render_text)(struct osd_object_s *, signed int, signed int, const char *, signed int);
  // get_text_size
  signed int (*get_text_size)(struct osd_object_s *, const char *, signed int *, signed int *);
  // close
  void (*close)(struct osd_renderer_s *);
  // clear
  void (*clear)(struct osd_object_s *);
  // draw_bitmap
  void (*draw_bitmap)(struct osd_object_s *, unsigned char *, signed int, signed int, signed int, signed int, unsigned char *);
  // show_unscaled
  signed int (*show_unscaled)(struct osd_object_s *, signed long int);
  // get_capabilities
  unsigned int (*get_capabilities)(struct osd_object_s *);
  // set_extent
  void (*set_extent)(struct osd_object_s *, signed int, signed int);
  // set_argb_buffer
  void (*set_argb_buffer)(struct osd_object_s *, unsigned int *, signed int, signed int, signed int, signed int);
  // set_video_window
  void (*set_video_window)(struct osd_object_s *, signed int, signed int, signed int, signed int);
  // osd_mutex
  union anonymous$6 osd_mutex;
  // event
  struct video_overlay_event_s event;
  // osds
  struct osd_object_s *osds;
  // fonts
  struct osd_font_s *fonts;
  // textpalette
  signed int textpalette;
};

struct osd_renderer_s$0
{
  // stream
  struct xine_stream_s$0 *stream;
  // new_object
  struct osd_object_s$0 * (*new_object)(struct osd_renderer_s$0 *, signed int, signed int);
  // free_object
  void (*free_object)(struct osd_object_s$0 *);
  // show
  signed int (*show)(struct osd_object_s$0 *, signed long int);
  // hide
  signed int (*hide)(struct osd_object_s$0 *, signed long int);
  // point
  void (*point)(struct osd_object_s$0 *, signed int, signed int, signed int);
  // line
  void (*line)(struct osd_object_s$0 *, signed int, signed int, signed int, signed int, signed int);
  // filled_rect
  void (*filled_rect)(struct osd_object_s$0 *, signed int, signed int, signed int, signed int, signed int);
  // set_palette
  void (*set_palette)(struct osd_object_s$0 *, const unsigned int *, const unsigned char *);
  // set_text_palette
  void (*set_text_palette)(struct osd_object_s$0 *, signed int, signed int);
  // get_palette
  void (*get_palette)(struct osd_object_s$0 *, unsigned int *, unsigned char *);
  // set_position
  void (*set_position)(struct osd_object_s$0 *, signed int, signed int);
  // set_font
  signed int (*set_font)(struct osd_object_s$0 *, const char *, signed int);
  // set_encoding
  signed int (*set_encoding)(struct osd_object_s$0 *, const char *);
  // render_text
  signed int (*render_text)(struct osd_object_s$0 *, signed int, signed int, const char *, signed int);
  // get_text_size
  signed int (*get_text_size)(struct osd_object_s$0 *, const char *, signed int *, signed int *);
  // close
  void (*close)(struct osd_renderer_s$0 *);
  // clear
  void (*clear)(struct osd_object_s$0 *);
  // draw_bitmap
  void (*draw_bitmap)(struct osd_object_s$0 *, unsigned char *, signed int, signed int, signed int, signed int, unsigned char *);
  // show_unscaled
  signed int (*show_unscaled)(struct osd_object_s$0 *, signed long int);
  // get_capabilities
  unsigned int (*get_capabilities)(struct osd_object_s$0 *);
  // set_extent
  void (*set_extent)(struct osd_object_s$0 *, signed int, signed int);
  // set_argb_buffer
  void (*set_argb_buffer)(struct osd_object_s$0 *, unsigned int *, signed int, signed int, signed int, signed int);
  // set_video_window
  void (*set_video_window)(struct osd_object_s$0 *, signed int, signed int, signed int, signed int);
  // osd_mutex
  union anonymous$6 osd_mutex;
  // event
  struct video_overlay_event_s event;
  // osds
  struct osd_object_s$0 *osds;
  // fonts
  struct osd_font_s *fonts;
  // textpalette
  signed int textpalette;
};

struct osd_rle_elem_s
{
  // len
  unsigned short int len;
  // color
  unsigned short int color;
} __attribute__ ((__packed__));

struct plugin_catalog_s$2
{
  // plugin_lists
  struct xine_sarray_s *plugin_lists[8l];
  // cache_list
  struct xine_sarray_s *cache_list;
  // file_list
  struct xine_list_s *file_list;
  // audio_decoder_map
  struct anonymous$14 *audio_decoder_map[128l][10l];
  // video_decoder_map
  struct anonymous$14 *video_decoder_map[128l][10l];
  // spu_decoder_map
  struct anonymous$14 *spu_decoder_map[128l][10l];
  // ids
  const char *ids[256l];
  // prio_desc
  char *prio_desc[128l];
  // lock
  union anonymous$6 lock;
  // plugin_count
  signed int plugin_count;
  // decoder_count
  signed int decoder_count;
};

struct plugin_catalog_s
{
  // plugin_lists
  struct xine_sarray_s *plugin_lists[8l];
  // cache_list
  struct xine_sarray_s *cache_list;
  // file_list
  struct xine_list_s *file_list;
  // audio_decoder_map
  struct anonymous$60 *audio_decoder_map[128l][10l];
  // video_decoder_map
  struct anonymous$60 *video_decoder_map[128l][10l];
  // spu_decoder_map
  struct anonymous$60 *spu_decoder_map[128l][10l];
  // ids
  const char *ids[256l];
  // prio_desc
  char *prio_desc[128l];
  // lock
  union anonymous$6 lock;
  // plugin_count
  signed int plugin_count;
  // decoder_count
  signed int decoder_count;
};

struct plugin_catalog_s$0
{
  // plugin_lists
  struct xine_sarray_s *plugin_lists[8l];
  // cache_list
  struct xine_sarray_s *cache_list;
  // file_list
  struct xine_list_s *file_list;
  // audio_decoder_map
  struct anonymous$1 *audio_decoder_map[128l][10l];
  // video_decoder_map
  struct anonymous$1 *video_decoder_map[128l][10l];
  // spu_decoder_map
  struct anonymous$1 *spu_decoder_map[128l][10l];
  // ids
  const char *ids[256l];
  // prio_desc
  char *prio_desc[128l];
  // lock
  union anonymous$6 lock;
  // plugin_count
  signed int plugin_count;
  // decoder_count
  signed int decoder_count;
};

struct plugin_catalog_s$1
{
  // plugin_lists
  struct xine_sarray_s *plugin_lists[8l];
  // cache_list
  struct xine_sarray_s *cache_list;
  // file_list
  struct xine_list_s *file_list;
  // audio_decoder_map
  struct anonymous$3 *audio_decoder_map[128l][10l];
  // video_decoder_map
  struct anonymous$3 *video_decoder_map[128l][10l];
  // spu_decoder_map
  struct anonymous$3 *spu_decoder_map[128l][10l];
  // ids
  const char *ids[256l];
  // prio_desc
  char *prio_desc[128l];
  // lock
  union anonymous$6 lock;
  // plugin_count
  signed int plugin_count;
  // decoder_count
  signed int decoder_count;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rle_elem_s
{
  // len
  unsigned short int len;
  // color
  unsigned short int color;
};

struct scr_impl_s
{
  // $anon0
  union anonymous $anon0;
  // xine
  struct xine_s$2 *xine;
  // cur_time
  struct timeval cur_time;
  // cur_pts
  signed long int cur_pts;
  // xine_speed
  signed int xine_speed;
  // scr_speed_base
  signed int scr_speed_base;
  // speed_factor
  double speed_factor;
  // speed_tuning
  double speed_tuning;
  // buffering
  signed int buffering;
  // buffering_start_time
  unsigned long int buffering_start_time;
  // lock
  union anonymous$6 lock;
};

struct scratch_buffer_s
{
  // scratch_printf
  void (*scratch_printf)(struct scratch_buffer_s *, const char *, void **);
  // get_content
  char ** (*get_content)(struct scratch_buffer_s *);
  // dispose
  void (*dispose)(struct scratch_buffer_s *);
  // lines
  char **lines;
  // ordered
  char **ordered;
  // num_lines
  signed int num_lines;
  // cur
  signed int cur;
  // lock
  union anonymous$6 lock;
};

struct sg_io_hdr
{
  // interface_id
  signed int interface_id;
  // dxfer_direction
  signed int dxfer_direction;
  // cmd_len
  unsigned char cmd_len;
  // mx_sb_len
  unsigned char mx_sb_len;
  // iovec_count
  unsigned short int iovec_count;
  // dxfer_len
  unsigned int dxfer_len;
  // dxferp
  void *dxferp;
  // cmdp
  unsigned char *cmdp;
  // sbp
  unsigned char *sbp;
  // timeout
  unsigned int timeout;
  // flags
  unsigned int flags;
  // pack_id
  signed int pack_id;
  // usr_ptr
  void *usr_ptr;
  // status
  unsigned char status;
  // masked_status
  unsigned char masked_status;
  // msg_status
  unsigned char msg_status;
  // sb_len_wr
  unsigned char sb_len_wr;
  // host_status
  unsigned short int host_status;
  // driver_status
  unsigned short int driver_status;
  // resid
  signed int resid;
  // duration
  unsigned int duration;
  // info
  unsigned int info;
};

struct slave_stream_s
{
  // stream
  struct xine_stream_s *stream;
  // event_queue
  struct xine_event_queue_s *event_queue;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct spu_decoder_s
{
  // decode_data
  void (*decode_data)(struct spu_decoder_s *, struct buf_element_s *);
  // reset
  void (*reset)(struct spu_decoder_s *);
  // discontinuity
  void (*discontinuity)(struct spu_decoder_s *);
  // dispose
  void (*dispose)(struct spu_decoder_s *);
  // get_interact_info
  signed int (*get_interact_info)(struct spu_decoder_s *, void *);
  // set_button
  void (*set_button)(struct spu_decoder_s *, signed int, signed int);
  // node
  void *node;
};

struct spu_dvb_descriptor_s
{
  // lang
  char lang[4l];
  // comp_page_id
  signed long int comp_page_id;
  // aux_page_id
  signed long int aux_page_id;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct stream_rtp_header
{
  // $anon0
  union anonymous$26 $anon0;
  // $anon1
  union anonymous$27 $anon1;
} __attribute__ ((__packed__));

struct stream_rtp_header_impl
{
  // rtp_hdr
  struct stream_rtp_header rtp_hdr;
  // hdr_ext
  struct anonymous$32 hdr_ext;
  // payload
  unsigned char payload[0l];
} __attribute__ ((__packed__));

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct ts2es_s
{
  // fifo
  struct fifo_buffer_s *fifo;
  // stream_type
  unsigned int stream_type;
  // xine_buf_type
  unsigned int xine_buf_type;
  // buf
  struct buf_element_s *buf;
  // pes_len
  signed int pes_len;
  // first_pusi_seen
  unsigned char first_pusi_seen;
  // video
  unsigned char video;
  // pes_error
  unsigned char pes_error;
};

struct ts_data_s
{
  // pmt_pid
  unsigned short int pmt_pid;
  // program_number
  unsigned short int program_number;
  // pmt
  struct anonymous$10 pmt;
  // video
  struct ts2es_s *video;
  // audio
  struct ts2es_s *audio[32l];
  // spu
  struct ts2es_s *spu[32l];
};

struct ts_state_s
{
  // pusi_seen
  unsigned char pusi_seen;
  // inside_pes
  unsigned char inside_pes;
  // buf_len
  unsigned long int buf_len;
  // buf_size
  unsigned long int buf_size;
  // buf
  unsigned char buf[0l];
};

struct udp_data_s
{
  // server_address
  struct sockaddr_in server_address;
  // ssrc
  unsigned int ssrc;
  // queue
  struct buf_element_s *queue[256l];
  // queue_input_pos
  unsigned long int queue_input_pos;
  // queued
  unsigned short int queued;
  // next_seq
  unsigned short int next_seq;
  // current_seq
  unsigned short int current_seq;
  // is_padding
  unsigned char is_padding;
  // missed_frames
  signed short int missed_frames;
  // received_frames
  signed short int received_frames;
  // scr_jump_done
  unsigned char scr_jump_done;
  // resend_requested
  signed int resend_requested;
};

struct vdr_input_class_s
{
  // input_class
  struct input_class_s$1 input_class;
  // xine
  struct xine_s$0 *xine;
  // mrls
  char *mrls[2l];
  // fast_osd_scaling
  signed int fast_osd_scaling;
  // smooth_scr_tuning
  signed int smooth_scr_tuning;
  // scr_tuning_step
  double scr_tuning_step;
  // num_buffers_hd
  signed int num_buffers_hd;
  // scr_treshold_sd
  unsigned int scr_treshold_sd;
  // scr_treshold_hd
  unsigned int scr_treshold_hd;
};

struct vdr_input_plugin_s
{
  // $anon0
  union anonymous$28 $anon0;
  // class
  struct vdr_input_class_s *class;
  // stream
  struct xine_stream_s *stream;
  // event_queue
  struct xine_event_queue_s *event_queue;
  // osd_manager
  struct osd_manager_s *osd_manager;
  // mrl
  char *mrl;
  // pip_stream
  struct xine_stream_s *pip_stream;
  // lock
  union anonymous$6 lock;
  // vdr_entry_lock
  union anonymous$6 vdr_entry_lock;
  // engine_flushed
  union anonymous$17 engine_flushed;
  // read_timeouts
  unsigned char read_timeouts;
  // write_overflows
  unsigned char write_overflows;
  // no_video
  unsigned char no_video : 1;
  // live_mode
  unsigned char live_mode : 1;
  // still_mode
  unsigned char still_mode : 1;
  // stream_start
  unsigned char stream_start : 1;
  // hd_stream
  unsigned char hd_stream : 1;
  // sw_volume_control
  unsigned char sw_volume_control : 1;
  // config_ok
  unsigned char config_ok : 1;
  // metronom
  struct xvdr_metronom_s *metronom;
  // scr
  struct adjustable_scr_s *scr;
  // scr_tuning
  signed short int scr_tuning;
  // fixed_scr
  unsigned char fixed_scr : 1;
  // scr_live_sync
  unsigned char scr_live_sync : 1;
  // is_paused
  unsigned char is_paused : 1;
  // is_trickspeed
  unsigned char is_trickspeed : 1;
  // scr_buf
  struct anonymous$29 scr_buf;
  // I_frames
  unsigned int I_frames;
  // B_frames
  unsigned int B_frames;
  // P_frames
  unsigned int P_frames;
  // control_thread
  unsigned long int control_thread;
  // fd_control_lock
  union anonymous$6 fd_control_lock;
  // read_buffer
  struct buf_element_s *read_buffer;
  // threads_initialized
  unsigned char threads_initialized;
  // tcp
  unsigned char tcp;
  // udp
  unsigned char udp;
  // rtp
  unsigned char rtp;
  // control_running
  volatile signed int control_running;
  // fd_data
  volatile signed int fd_data;
  // fd_control
  volatile signed int fd_control;
  // udp_data
  struct udp_data_s *udp_data;
  // client_id
  signed int client_id;
  // token
  signed int token;
  // block_buffer
  struct fifo_buffer_s *block_buffer;
  // buffer_pool
  struct fifo_buffer_s *buffer_pool;
  // hd_buffer
  struct fifo_buffer_s *hd_buffer;
  // discard_index
  unsigned long int discard_index;
  // discard_index_ds
  unsigned long int discard_index_ds;
  // discard_frame
  unsigned int discard_frame;
  // guard_index
  unsigned long int guard_index;
  // guard_frame
  unsigned int guard_frame;
  // curpos
  unsigned long int curpos;
  // curframe
  unsigned int curframe;
  // reserved_buffers
  unsigned int reserved_buffers;
  // slave
  struct slave_stream_s slave;
  // bg_stream
  struct slave_stream_s bg_stream;
  // autoplay_size
  signed int autoplay_size;
  // loop_play
  unsigned char loop_play : 1;
  // dvd_menu
  unsigned char dvd_menu : 1;
  // video_properties_saved
  unsigned char video_properties_saved;
  // orig_hue
  signed int orig_hue;
  // orig_brightness
  signed int orig_brightness;
  // orig_saturation
  signed int orig_saturation;
  // orig_sharpness
  signed int orig_sharpness;
  // orig_noise_reduction
  signed int orig_noise_reduction;
  // orig_contrast
  signed int orig_contrast;
  // orig_vo_aspect_ratio
  signed int orig_vo_aspect_ratio;
};

struct video_decoder_s
{
  // decode_data
  void (*decode_data)(struct video_decoder_s *, struct buf_element_s *);
  // reset
  void (*reset)(struct video_decoder_s *);
  // discontinuity
  void (*discontinuity)(struct video_decoder_s *);
  // flush
  void (*flush)(struct video_decoder_s *);
  // dispose
  void (*dispose)(struct video_decoder_s *);
  // node
  void *node;
};

struct video_overlay_manager_s$1
{
  // init
  void (*init)(struct video_overlay_manager_s$1 *);
  // dispose
  void (*dispose)(struct video_overlay_manager_s$1 *);
  // get_handle
  signed int (*get_handle)(struct video_overlay_manager_s$1 *, signed int);
  // free_handle
  void (*free_handle)(struct video_overlay_manager_s$1 *, signed int);
  // add_event
  signed int (*add_event)(struct video_overlay_manager_s$1 *, void *);
  // flush_events
  void (*flush_events)(struct video_overlay_manager_s$1 *);
  // redraw_needed
  signed int (*redraw_needed)(struct video_overlay_manager_s$1 *, signed long int);
  // multiple_overlay_blend
  void (*multiple_overlay_blend)(struct video_overlay_manager_s$1 *, signed long int, struct vo_driver_s$1 *, struct vo_frame_s$1 *, signed int);
};

struct video_overlay_manager_s
{
  // init
  void (*init)(struct video_overlay_manager_s *);
  // dispose
  void (*dispose)(struct video_overlay_manager_s *);
  // get_handle
  signed int (*get_handle)(struct video_overlay_manager_s *, signed int);
  // free_handle
  void (*free_handle)(struct video_overlay_manager_s *, signed int);
  // add_event
  signed int (*add_event)(struct video_overlay_manager_s *, void *);
  // flush_events
  void (*flush_events)(struct video_overlay_manager_s *);
  // redraw_needed
  signed int (*redraw_needed)(struct video_overlay_manager_s *, signed long int);
  // multiple_overlay_blend
  void (*multiple_overlay_blend)(struct video_overlay_manager_s *, signed long int, struct vo_driver_s *, struct vo_frame_s *, signed int);
};

struct video_overlay_manager_s$0
{
  // init
  void (*init)(struct video_overlay_manager_s$0 *);
  // dispose
  void (*dispose)(struct video_overlay_manager_s$0 *);
  // get_handle
  signed int (*get_handle)(struct video_overlay_manager_s$0 *, signed int);
  // free_handle
  void (*free_handle)(struct video_overlay_manager_s$0 *, signed int);
  // add_event
  signed int (*add_event)(struct video_overlay_manager_s$0 *, void *);
  // flush_events
  void (*flush_events)(struct video_overlay_manager_s$0 *);
  // redraw_needed
  signed int (*redraw_needed)(struct video_overlay_manager_s$0 *, signed long int);
  // multiple_overlay_blend
  void (*multiple_overlay_blend)(struct video_overlay_manager_s$0 *, signed long int, struct vo_driver_s$0 *, struct vo_frame_s$0 *, signed int);
};

struct video_size_s
{
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // pixel_aspect
  struct mpeg_rational_s pixel_aspect;
};

struct vo_driver_s$1
{
  // get_capabilities
  unsigned int (*get_capabilities)(struct vo_driver_s$1 *);
  // alloc_frame
  struct vo_frame_s$1 * (*alloc_frame)(struct vo_driver_s$1 *);
  // update_frame_format
  void (*update_frame_format)(struct vo_driver_s$1 *, struct vo_frame_s$1 *, unsigned int, unsigned int, double, signed int, signed int);
  // display_frame
  void (*display_frame)(struct vo_driver_s$1 *, struct vo_frame_s$1 *);
  // overlay_begin
  void (*overlay_begin)(struct vo_driver_s$1 *, struct vo_frame_s$1 *, signed int);
  // overlay_blend
  void (*overlay_blend)(struct vo_driver_s$1 *, struct vo_frame_s$1 *, struct vo_overlay_s *);
  // overlay_end
  void (*overlay_end)(struct vo_driver_s$1 *, struct vo_frame_s$1 *);
  // get_property
  signed int (*get_property)(struct vo_driver_s$1 *, signed int);
  // set_property
  signed int (*set_property)(struct vo_driver_s$1 *, signed int, signed int);
  // get_property_min_max
  void (*get_property_min_max)(struct vo_driver_s$1 *, signed int, signed int *, signed int *);
  // gui_data_exchange
  signed int (*gui_data_exchange)(struct vo_driver_s$1 *, signed int, void *);
  // redraw_needed
  signed int (*redraw_needed)(struct vo_driver_s$1 *);
  // new_grab_video_frame
  struct xine_grab_video_frame_s * (*new_grab_video_frame)(struct vo_driver_s$1 *);
  // dispose
  void (*dispose)(struct vo_driver_s$1 *);
  // node
  void *node;
};

struct vo_driver_s
{
  // get_capabilities
  unsigned int (*get_capabilities)(struct vo_driver_s *);
  // alloc_frame
  struct vo_frame_s * (*alloc_frame)(struct vo_driver_s *);
  // update_frame_format
  void (*update_frame_format)(struct vo_driver_s *, struct vo_frame_s *, unsigned int, unsigned int, double, signed int, signed int);
  // display_frame
  void (*display_frame)(struct vo_driver_s *, struct vo_frame_s *);
  // overlay_begin
  void (*overlay_begin)(struct vo_driver_s *, struct vo_frame_s *, signed int);
  // overlay_blend
  void (*overlay_blend)(struct vo_driver_s *, struct vo_frame_s *, struct vo_overlay_s *);
  // overlay_end
  void (*overlay_end)(struct vo_driver_s *, struct vo_frame_s *);
  // get_property
  signed int (*get_property)(struct vo_driver_s *, signed int);
  // set_property
  signed int (*set_property)(struct vo_driver_s *, signed int, signed int);
  // get_property_min_max
  void (*get_property_min_max)(struct vo_driver_s *, signed int, signed int *, signed int *);
  // gui_data_exchange
  signed int (*gui_data_exchange)(struct vo_driver_s *, signed int, void *);
  // redraw_needed
  signed int (*redraw_needed)(struct vo_driver_s *);
  // new_grab_video_frame
  struct xine_grab_video_frame_s * (*new_grab_video_frame)(struct vo_driver_s *);
  // dispose
  void (*dispose)(struct vo_driver_s *);
  // node
  void *node;
};

struct vo_driver_s$0
{
  // get_capabilities
  unsigned int (*get_capabilities)(struct vo_driver_s$0 *);
  // alloc_frame
  struct vo_frame_s$0 * (*alloc_frame)(struct vo_driver_s$0 *);
  // update_frame_format
  void (*update_frame_format)(struct vo_driver_s$0 *, struct vo_frame_s$0 *, unsigned int, unsigned int, double, signed int, signed int);
  // display_frame
  void (*display_frame)(struct vo_driver_s$0 *, struct vo_frame_s$0 *);
  // overlay_begin
  void (*overlay_begin)(struct vo_driver_s$0 *, struct vo_frame_s$0 *, signed int);
  // overlay_blend
  void (*overlay_blend)(struct vo_driver_s$0 *, struct vo_frame_s$0 *, struct vo_overlay_s *);
  // overlay_end
  void (*overlay_end)(struct vo_driver_s$0 *, struct vo_frame_s$0 *);
  // get_property
  signed int (*get_property)(struct vo_driver_s$0 *, signed int);
  // set_property
  signed int (*set_property)(struct vo_driver_s$0 *, signed int, signed int);
  // get_property_min_max
  void (*get_property_min_max)(struct vo_driver_s$0 *, signed int, signed int *, signed int *);
  // gui_data_exchange
  signed int (*gui_data_exchange)(struct vo_driver_s$0 *, signed int, void *);
  // redraw_needed
  signed int (*redraw_needed)(struct vo_driver_s$0 *);
  // new_grab_video_frame
  struct xine_grab_video_frame_s * (*new_grab_video_frame)(struct vo_driver_s$0 *);
  // dispose
  void (*dispose)(struct vo_driver_s$0 *);
  // node
  void *node;
};

struct vo_frame_s$1
{
  // proc_provide_standard_frame_data
  void (*proc_provide_standard_frame_data)(struct vo_frame_s$1 *, struct anonymous$62 *);
  // proc_duplicate_frame_data
  void (*proc_duplicate_frame_data)(struct vo_frame_s$1 *, struct vo_frame_s$1 *);
  // proc_frame
  void (*proc_frame)(struct vo_frame_s$1 *);
  // proc_slice
  void (*proc_slice)(struct vo_frame_s$1 *, unsigned char **);
  // field
  void (*field)(struct vo_frame_s$1 *, signed int);
  // draw
  signed int (*draw)(struct vo_frame_s$1 *, struct xine_stream_s *);
  // lock
  void (*lock)(struct vo_frame_s$1 *);
  // free
  void (*free)(struct vo_frame_s$1 *);
  // dispose
  void (*dispose)(struct vo_frame_s$1 *);
  // pts
  signed long int pts;
  // vpts
  signed long int vpts;
  // bad_frame
  signed int bad_frame;
  // duration
  signed int duration;
  // base
  unsigned char *base[3l];
  // pitches
  signed int pitches[3l];
  // top_field_first
  signed int top_field_first;
  // repeat_first_field
  signed int repeat_first_field;
  // progressive_frame
  signed int progressive_frame;
  // picture_coding_type
  signed int picture_coding_type;
  // crop_left
  signed int crop_left;
  // crop_right
  signed int crop_right;
  // crop_top
  signed int crop_top;
  // crop_bottom
  signed int crop_bottom;
  // lock_counter
  signed int lock_counter;
  // mutex
  union anonymous$6 mutex;
  // extra_info
  struct extra_info_s *extra_info;
  // width
  signed int width;
  // height
  signed int height;
  // ratio
  double ratio;
  // format
  signed int format;
  // drawn
  signed int drawn;
  // flags
  signed int flags;
  // proc_called
  signed int proc_called;
  // accel_data
  void *accel_data;
  // port
  struct xine_video_port_s$1 *port;
  // driver
  struct vo_driver_s$1 *driver;
  // stream
  struct xine_stream_s *stream;
  // overlay_offset_x
  signed int overlay_offset_x;
  // overlay_offset_y
  signed int overlay_offset_y;
  // future_frame
  struct vo_frame_s$1 *future_frame;
  // next
  struct vo_frame_s$1 *next;
  // id
  signed int id;
  // is_first
  signed int is_first;
};

struct vo_frame_s
{
  // proc_provide_standard_frame_data
  void (*proc_provide_standard_frame_data)(struct vo_frame_s *, struct anonymous$62 *);
  // proc_duplicate_frame_data
  void (*proc_duplicate_frame_data)(struct vo_frame_s *, struct vo_frame_s *);
  // proc_frame
  void (*proc_frame)(struct vo_frame_s *);
  // proc_slice
  void (*proc_slice)(struct vo_frame_s *, unsigned char **);
  // field
  void (*field)(struct vo_frame_s *, signed int);
  // draw
  signed int (*draw)(struct vo_frame_s *, struct xine_stream_s$1 *);
  // lock
  void (*lock)(struct vo_frame_s *);
  // free
  void (*free)(struct vo_frame_s *);
  // dispose
  void (*dispose)(struct vo_frame_s *);
  // pts
  signed long int pts;
  // vpts
  signed long int vpts;
  // bad_frame
  signed int bad_frame;
  // duration
  signed int duration;
  // base
  unsigned char *base[3l];
  // pitches
  signed int pitches[3l];
  // top_field_first
  signed int top_field_first;
  // repeat_first_field
  signed int repeat_first_field;
  // progressive_frame
  signed int progressive_frame;
  // picture_coding_type
  signed int picture_coding_type;
  // crop_left
  signed int crop_left;
  // crop_right
  signed int crop_right;
  // crop_top
  signed int crop_top;
  // crop_bottom
  signed int crop_bottom;
  // lock_counter
  signed int lock_counter;
  // mutex
  union anonymous$6 mutex;
  // extra_info
  struct extra_info_s *extra_info;
  // width
  signed int width;
  // height
  signed int height;
  // ratio
  double ratio;
  // format
  signed int format;
  // drawn
  signed int drawn;
  // flags
  signed int flags;
  // proc_called
  signed int proc_called;
  // accel_data
  void *accel_data;
  // port
  struct xine_video_port_s *port;
  // driver
  struct vo_driver_s *driver;
  // stream
  struct xine_stream_s$1 *stream;
  // overlay_offset_x
  signed int overlay_offset_x;
  // overlay_offset_y
  signed int overlay_offset_y;
  // future_frame
  struct vo_frame_s *future_frame;
  // next
  struct vo_frame_s *next;
  // id
  signed int id;
  // is_first
  signed int is_first;
};

struct vo_frame_s$0
{
  // proc_provide_standard_frame_data
  void (*proc_provide_standard_frame_data)(struct vo_frame_s$0 *, struct anonymous$62 *);
  // proc_duplicate_frame_data
  void (*proc_duplicate_frame_data)(struct vo_frame_s$0 *, struct vo_frame_s$0 *);
  // proc_frame
  void (*proc_frame)(struct vo_frame_s$0 *);
  // proc_slice
  void (*proc_slice)(struct vo_frame_s$0 *, unsigned char **);
  // field
  void (*field)(struct vo_frame_s$0 *, signed int);
  // draw
  signed int (*draw)(struct vo_frame_s$0 *, struct xine_stream_s$0 *);
  // lock
  void (*lock)(struct vo_frame_s$0 *);
  // free
  void (*free)(struct vo_frame_s$0 *);
  // dispose
  void (*dispose)(struct vo_frame_s$0 *);
  // pts
  signed long int pts;
  // vpts
  signed long int vpts;
  // bad_frame
  signed int bad_frame;
  // duration
  signed int duration;
  // base
  unsigned char *base[3l];
  // pitches
  signed int pitches[3l];
  // top_field_first
  signed int top_field_first;
  // repeat_first_field
  signed int repeat_first_field;
  // progressive_frame
  signed int progressive_frame;
  // picture_coding_type
  signed int picture_coding_type;
  // crop_left
  signed int crop_left;
  // crop_right
  signed int crop_right;
  // crop_top
  signed int crop_top;
  // crop_bottom
  signed int crop_bottom;
  // lock_counter
  signed int lock_counter;
  // mutex
  union anonymous$6 mutex;
  // extra_info
  struct extra_info_s *extra_info;
  // width
  signed int width;
  // height
  signed int height;
  // ratio
  double ratio;
  // format
  signed int format;
  // drawn
  signed int drawn;
  // flags
  signed int flags;
  // proc_called
  signed int proc_called;
  // accel_data
  void *accel_data;
  // port
  struct xine_video_port_s$0 *port;
  // driver
  struct vo_driver_s$0 *driver;
  // stream
  struct xine_stream_s$0 *stream;
  // overlay_offset_x
  signed int overlay_offset_x;
  // overlay_offset_y
  signed int overlay_offset_y;
  // future_frame
  struct vo_frame_s$0 *future_frame;
  // next
  struct vo_frame_s$0 *next;
  // id
  signed int id;
  // is_first
  signed int is_first;
};

struct vo_overlay_s
{
  // rle
  struct rle_elem_s *rle;
  // data_size
  signed int data_size;
  // num_rle
  signed int num_rle;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // video_window_x
  signed int video_window_x;
  // video_window_y
  signed int video_window_y;
  // video_window_width
  signed int video_window_width;
  // video_window_height
  signed int video_window_height;
  // extent_width
  signed int extent_width;
  // extent_height
  signed int extent_height;
  // color
  unsigned int color[256l];
  // trans
  unsigned char trans[256l];
  // rgb_clut
  signed int rgb_clut;
  // hili_top
  signed int hili_top;
  // hili_bottom
  signed int hili_bottom;
  // hili_left
  signed int hili_left;
  // hili_right
  signed int hili_right;
  // hili_color
  unsigned int hili_color[256l];
  // hili_trans
  unsigned char hili_trans[256l];
  // hili_rgb_clut
  signed int hili_rgb_clut;
  // unscaled
  signed int unscaled;
  // argb_layer
  struct argb_layer_s *argb_layer;
};

struct xine_audio_port_s$1
{
  // get_capabilities
  unsigned int (*get_capabilities)(struct xine_audio_port_s$1 *);
  // get_property
  signed int (*get_property)(struct xine_audio_port_s$1 *, signed int);
  // set_property
  signed int (*set_property)(struct xine_audio_port_s$1 *, signed int, signed int);
  // open
  signed int (*open)(struct xine_audio_port_s$1 *, struct xine_stream_s *, unsigned int, unsigned int, signed int);
  // get_buffer
  struct audio_buffer_s$1 * (*get_buffer)(struct xine_audio_port_s$1 *);
  // put_buffer
  void (*put_buffer)(struct xine_audio_port_s$1 *, struct audio_buffer_s$1 *, struct xine_stream_s *);
  // close
  void (*close)(struct xine_audio_port_s$1 *, struct xine_stream_s *);
  // exit
  void (*exit)(struct xine_audio_port_s$1 *);
  // control
  signed int (*control)(struct xine_audio_port_s$1 *, signed int, ...);
  // flush
  void (*flush)(struct xine_audio_port_s$1 *);
  // status
  signed int (*status)(struct xine_audio_port_s$1 *, struct xine_stream_s *, unsigned int *, unsigned int *, signed int *);
};

struct xine_audio_port_s
{
  // get_capabilities
  unsigned int (*get_capabilities)(struct xine_audio_port_s *);
  // get_property
  signed int (*get_property)(struct xine_audio_port_s *, signed int);
  // set_property
  signed int (*set_property)(struct xine_audio_port_s *, signed int, signed int);
  // open
  signed int (*open)(struct xine_audio_port_s *, struct xine_stream_s$1 *, unsigned int, unsigned int, signed int);
  // get_buffer
  struct audio_buffer_s * (*get_buffer)(struct xine_audio_port_s *);
  // put_buffer
  void (*put_buffer)(struct xine_audio_port_s *, struct audio_buffer_s *, struct xine_stream_s$1 *);
  // close
  void (*close)(struct xine_audio_port_s *, struct xine_stream_s$1 *);
  // exit
  void (*exit)(struct xine_audio_port_s *);
  // control
  signed int (*control)(struct xine_audio_port_s *, signed int, ...);
  // flush
  void (*flush)(struct xine_audio_port_s *);
  // status
  signed int (*status)(struct xine_audio_port_s *, struct xine_stream_s$1 *, unsigned int *, unsigned int *, signed int *);
};

struct xine_audio_port_s$0
{
  // get_capabilities
  unsigned int (*get_capabilities)(struct xine_audio_port_s$0 *);
  // get_property
  signed int (*get_property)(struct xine_audio_port_s$0 *, signed int);
  // set_property
  signed int (*set_property)(struct xine_audio_port_s$0 *, signed int, signed int);
  // open
  signed int (*open)(struct xine_audio_port_s$0 *, struct xine_stream_s$0 *, unsigned int, unsigned int, signed int);
  // get_buffer
  struct audio_buffer_s$0 * (*get_buffer)(struct xine_audio_port_s$0 *);
  // put_buffer
  void (*put_buffer)(struct xine_audio_port_s$0 *, struct audio_buffer_s$0 *, struct xine_stream_s$0 *);
  // close
  void (*close)(struct xine_audio_port_s$0 *, struct xine_stream_s$0 *);
  // exit
  void (*exit)(struct xine_audio_port_s$0 *);
  // control
  signed int (*control)(struct xine_audio_port_s$0 *, signed int, ...);
  // flush
  void (*flush)(struct xine_audio_port_s$0 *);
  // status
  signed int (*status)(struct xine_audio_port_s$0 *, struct xine_stream_s$0 *, unsigned int *, unsigned int *, signed int *);
};

struct xine_cfg_entry_s
{
  // key
  const char *key;
  // type
  signed int type;
  // exp_level
  signed int exp_level;
  // unknown_value
  char *unknown_value;
  // str_value
  char *str_value;
  // str_default
  char *str_default;
  // num_value
  signed int num_value;
  // num_default
  signed int num_default;
  // range_min
  signed int range_min;
  // range_max
  signed int range_max;
  // enum_values
  char **enum_values;
  // description
  const char *description;
  // help
  const char *help;
  // callback
  void (*callback)(void *, struct xine_cfg_entry_s *);
  // callback_data
  void *callback_data;
};

struct xine_event_queue_s
{
  // events
  struct xine_list_s *events;
  // lock
  union anonymous$6 lock;
  // new_event
  union anonymous$17 new_event;
  // events_processed
  union anonymous$17 events_processed;
  // stream
  struct xine_stream_s *stream;
  // listener_thread
  unsigned long int *listener_thread;
  // user_data
  void *user_data;
  // callback
  void (*callback)(void *, const struct anonymous$22 *);
  // callback_running
  signed int callback_running;
};

struct xine_grab_video_frame_s
{
  // grab
  signed int (*grab)(struct xine_grab_video_frame_s *);
  // dispose
  void (*dispose)(struct xine_grab_video_frame_s *);
  // crop_left
  signed int crop_left;
  // crop_right
  signed int crop_right;
  // crop_top
  signed int crop_top;
  // crop_bottom
  signed int crop_bottom;
  // width
  signed int width;
  // height
  signed int height;
  // img
  unsigned char *img;
  // vpts
  signed long int vpts;
  // timeout
  signed int timeout;
  // flags
  signed int flags;
};

struct xine_post_out_s
{
  // name
  const char *name;
  // data
  void *data;
  // rewire
  signed int (*rewire)(struct xine_post_out_s *, void *);
  // type
  signed int type;
};

struct xine_s$0
{
  // config
  struct config_values_s *config;
  // plugin_catalog
  struct plugin_catalog_s$2 *plugin_catalog;
  // verbosity
  signed int verbosity;
  // demux_strategy
  signed int demux_strategy;
  // save_path
  char *save_path;
  // log_buffers
  struct scratch_buffer_s *log_buffers[3l];
  // streams
  struct xine_list_s *streams;
  // streams_lock
  union anonymous$6 streams_lock;
  // clock
  struct metronom_clock_s *clock;
  // basedir_handle
  struct anonymous$43 basedir_handle;
  // port_ticket
  struct xine_ticket_s *port_ticket;
  // log_lock
  union anonymous$6 log_lock;
  // log_cb
  void (*log_cb)(void *, signed int);
  // log_cb_user_data
  void *log_cb_user_data;
};

struct xine_s$1
{
  // config
  struct config_values_s *config;
  // plugin_catalog
  struct plugin_catalog_s *plugin_catalog;
  // verbosity
  signed int verbosity;
  // demux_strategy
  signed int demux_strategy;
  // save_path
  char *save_path;
  // log_buffers
  struct scratch_buffer_s *log_buffers[3l];
  // streams
  struct xine_list_s *streams;
  // streams_lock
  union anonymous$6 streams_lock;
  // clock
  struct metronom_clock_s *clock;
  // basedir_handle
  struct anonymous$43 basedir_handle;
};

struct xine_s$2
{
  // config
  struct config_values_s *config;
  // plugin_catalog
  struct plugin_catalog_s$0 *plugin_catalog;
  // verbosity
  signed int verbosity;
  // demux_strategy
  signed int demux_strategy;
  // save_path
  char *save_path;
  // log_buffers
  struct scratch_buffer_s *log_buffers[3l];
  // streams
  struct xine_list_s *streams;
  // streams_lock
  union anonymous$6 streams_lock;
  // clock
  struct metronom_clock_s *clock;
  // basedir_handle
  struct anonymous$43 basedir_handle;
};

struct xine_s
{
  // config
  struct config_values_s *config;
  // plugin_catalog
  struct plugin_catalog_s$1 *plugin_catalog;
  // verbosity
  signed int verbosity;
  // demux_strategy
  signed int demux_strategy;
  // save_path
  char *save_path;
  // log_buffers
  struct scratch_buffer_s *log_buffers[3l];
  // streams
  struct xine_list_s *streams;
  // streams_lock
  union anonymous$6 streams_lock;
  // clock
  struct metronom_clock_s *clock;
  // basedir_handle
  struct anonymous$43 basedir_handle;
};

struct xine_stream_s
{
  // xine
  struct xine_s$0 *xine;
  // metronom
  struct metronom_s$0 *metronom;
  // input_plugin
  struct input_plugin_s$0 *input_plugin;
  // video_out
  struct xine_video_port_s$1 *video_out;
  // video_fifo
  struct fifo_buffer_s *video_fifo;
  // audio_out
  struct xine_audio_port_s$1 *audio_out;
  // audio_fifo
  struct fifo_buffer_s *audio_fifo;
  // osd_renderer
  struct osd_renderer_s$1 *osd_renderer;
  // master
  struct xine_stream_s *master;
  // slave
  struct xine_stream_s *slave;
  // spu_decoder_plugin
  struct spu_decoder_s *spu_decoder_plugin;
  // video_driver
  struct vo_driver_s$1 *video_driver;
  // audio_channel_auto
  signed int audio_channel_auto;
  // spu_decoder_streamtype
  signed int spu_decoder_streamtype;
  // spu_channel_user
  signed int spu_channel_user;
  // spu_channel_auto
  signed int spu_channel_auto;
  // spu_channel_letterbox
  signed int spu_channel_letterbox;
  // spu_channel
  signed int spu_channel;
  // content_detection_method
  signed int content_detection_method;
  // status
  signed int status;
  // speed_change_lock
  union anonymous$6 speed_change_lock;
  // ignore_speed_change
  unsigned int ignore_speed_change : 1;
  // video_thread_created
  unsigned int video_thread_created : 1;
  // audio_thread_created
  unsigned int audio_thread_created : 1;
  // first_frame_flag
  unsigned int first_frame_flag : 2;
  // demux_action_pending
  unsigned int demux_action_pending : 1;
  // demux_thread_created
  unsigned int demux_thread_created : 1;
  // demux_thread_running
  unsigned int demux_thread_running : 1;
  // slave_is_subtitle
  unsigned int slave_is_subtitle : 1;
  // emergency_brake
  unsigned int emergency_brake : 1;
  // early_finish_event
  unsigned int early_finish_event : 1;
  // gapless_switch
  unsigned int gapless_switch : 1;
  // keep_ao_driver_open
  unsigned int keep_ao_driver_open : 1;
  // eject_class
  struct input_class_s$1 *eject_class;
  // demux_plugin
  struct demux_plugin_s *demux_plugin;
  // video_thread
  unsigned long int video_thread;
  // video_decoder_plugin
  struct video_decoder_s *video_decoder_plugin;
  // video_decoder_extra_info
  struct extra_info_s *video_decoder_extra_info;
  // video_decoder_streamtype
  signed int video_decoder_streamtype;
  // video_channel
  signed int video_channel;
  // audio_track_map
  unsigned int audio_track_map[50l];
  // audio_track_map_entries
  signed int audio_track_map_entries;
  // audio_decoder_streamtype
  signed int audio_decoder_streamtype;
  // audio_thread
  unsigned long int audio_thread;
  // audio_decoder_plugin
  struct audio_decoder_s *audio_decoder_plugin;
  // audio_decoder_extra_info
  struct extra_info_s *audio_decoder_extra_info;
  // audio_type
  unsigned int audio_type;
  // audio_channel_user
  signed int audio_channel_user;
  // spu_track_map
  unsigned int spu_track_map[50l];
  // spu_track_map_entries
  signed int spu_track_map_entries;
  // spu_channel_pan_scan
  signed int spu_channel_pan_scan;
  // frontend_lock
  union anonymous$6 frontend_lock;
  // info_mutex
  union anonymous$6 info_mutex;
  // stream_info_public
  signed int stream_info_public[99l];
  // stream_info
  signed int stream_info[99l];
  // meta_mutex
  union anonymous$6 meta_mutex;
  // meta_info_public
  char *meta_info_public[99l];
  // meta_info
  char *meta_info[99l];
  // first_frame_lock
  union anonymous$6 first_frame_lock;
  // first_frame_reached
  union anonymous$17 first_frame_reached;
  // counter_lock
  union anonymous$6 counter_lock;
  // counter_changed
  union anonymous$17 counter_changed;
  // header_count_audio
  signed int header_count_audio;
  // header_count_video
  signed int header_count_video;
  // finished_count_audio
  signed int finished_count_audio;
  // finished_count_video
  signed int finished_count_video;
  // event_queues
  struct xine_list_s *event_queues;
  // event_queues_lock
  union anonymous$6 event_queues_lock;
  // demux_thread
  unsigned long int demux_thread;
  // demux_lock
  union anonymous$6 demux_lock;
  // demux_action_lock
  union anonymous$6 demux_action_lock;
  // demux_resume
  union anonymous$17 demux_resume;
  // demux_mutex
  union anonymous$6 demux_mutex;
  // current_extra_info
  struct extra_info_s *current_extra_info;
  // current_extra_info_lock
  union anonymous$6 current_extra_info_lock;
  // video_seek_count
  signed int video_seek_count;
  // delay_finish_event
  signed int delay_finish_event;
  // slave_affection
  signed int slave_affection;
  // err
  signed int err;
  // video_source
  struct xine_post_out_s video_source;
  // audio_source
  struct xine_post_out_s audio_source;
  // broadcaster
  struct broadcaster_s *broadcaster;
  // refcounter
  struct anonymous$18 *refcounter;
};

struct xine_stream_s$1
{
  // xine
  struct xine_s$1 *xine;
  // metronom
  struct metronom_s$1 *metronom;
  // input_plugin
  struct input_plugin_s$1 *input_plugin;
  // video_out
  struct xine_video_port_s *video_out;
  // video_fifo
  struct fifo_buffer_s *video_fifo;
  // audio_out
  struct xine_audio_port_s *audio_out;
  // audio_fifo
  struct fifo_buffer_s *audio_fifo;
  // osd_renderer
  struct osd_renderer_s *osd_renderer;
  // master
  struct xine_stream_s$1 *master;
  // slave
  struct xine_stream_s$1 *slave;
  // spu_decoder_plugin
  struct spu_decoder_s *spu_decoder_plugin;
  // video_driver
  struct vo_driver_s *video_driver;
  // audio_channel_auto
  signed int audio_channel_auto;
  // spu_decoder_streamtype
  signed int spu_decoder_streamtype;
  // spu_channel_user
  signed int spu_channel_user;
  // spu_channel_auto
  signed int spu_channel_auto;
  // spu_channel_letterbox
  signed int spu_channel_letterbox;
  // spu_channel
  signed int spu_channel;
  // content_detection_method
  signed int content_detection_method;
};

struct xine_stream_s$0
{
  // xine
  struct xine_s *xine;
  // metronom
  struct metronom_s *metronom;
  // input_plugin
  struct input_plugin_s *input_plugin;
  // video_out
  struct xine_video_port_s$0 *video_out;
  // video_fifo
  struct fifo_buffer_s *video_fifo;
  // audio_out
  struct xine_audio_port_s$0 *audio_out;
  // audio_fifo
  struct fifo_buffer_s *audio_fifo;
  // osd_renderer
  struct osd_renderer_s$0 *osd_renderer;
  // master
  struct xine_stream_s$0 *master;
  // slave
  struct xine_stream_s$0 *slave;
  // spu_decoder_plugin
  struct spu_decoder_s *spu_decoder_plugin;
  // video_driver
  struct vo_driver_s$0 *video_driver;
  // audio_channel_auto
  signed int audio_channel_auto;
  // spu_decoder_streamtype
  signed int spu_decoder_streamtype;
  // spu_channel_user
  signed int spu_channel_user;
  // spu_channel_auto
  signed int spu_channel_auto;
  // spu_channel_letterbox
  signed int spu_channel_letterbox;
  // spu_channel
  signed int spu_channel;
  // content_detection_method
  signed int content_detection_method;
};

struct xine_ticket_s
{
  // ticket_revoked
  signed int ticket_revoked;
  // acquire
  void (*acquire)(struct xine_ticket_s *, signed int);
  // release
  void (*release)(struct xine_ticket_s *, signed int);
  // renew
  void (*renew)(struct xine_ticket_s *, signed int);
  // issue
  void (*issue)(struct xine_ticket_s *, signed int);
  // revoke
  void (*revoke)(struct xine_ticket_s *, signed int);
  // acquire_nonblocking
  signed int (*acquire_nonblocking)(struct xine_ticket_s *, signed int);
  // release_nonblocking
  void (*release_nonblocking)(struct xine_ticket_s *, signed int);
  // lock_port_rewiring
  signed int (*lock_port_rewiring)(struct xine_ticket_s *, signed int);
  // unlock_port_rewiring
  void (*unlock_port_rewiring)(struct xine_ticket_s *);
  // dispose
  void (*dispose)(struct xine_ticket_s *);
  // lock
  union anonymous$6 lock;
  // revoke_lock
  union anonymous$6 revoke_lock;
  // issued
  union anonymous$17 issued;
  // revoked
  union anonymous$17 revoked;
  // tickets_granted
  signed int tickets_granted;
  // irrevocable_tickets
  signed int irrevocable_tickets;
  // pending_revocations
  signed int pending_revocations;
  // atomic_revoke
  signed int atomic_revoke;
  // atomic_revoker_thread
  unsigned long int atomic_revoker_thread;
  // port_rewiring_lock
  union anonymous$6 port_rewiring_lock;
  // holder_threads
  struct anonymous$21 *holder_threads;
  // holder_thread_count
  unsigned int holder_thread_count;
};

struct xine_video_port_s$1
{
  // get_capabilities
  unsigned int (*get_capabilities)(struct xine_video_port_s$1 *);
  // open
  void (*open)(struct xine_video_port_s$1 *, struct xine_stream_s *);
  // get_frame
  struct vo_frame_s$1 * (*get_frame)(struct xine_video_port_s$1 *, unsigned int, unsigned int, double, signed int, signed int);
  // new_grab_video_frame
  struct xine_grab_video_frame_s * (*new_grab_video_frame)(struct xine_video_port_s$1 *);
  // get_last_frame
  struct vo_frame_s$1 * (*get_last_frame)(struct xine_video_port_s$1 *);
  // enable_ovl
  void (*enable_ovl)(struct xine_video_port_s$1 *, signed int);
  // get_overlay_manager
  struct video_overlay_manager_s$1 * (*get_overlay_manager)(struct xine_video_port_s$1 *);
  // flush
  void (*flush)(struct xine_video_port_s$1 *);
  // trigger_drawing
  void (*trigger_drawing)(struct xine_video_port_s$1 *);
  // get_property
  signed int (*get_property)(struct xine_video_port_s$1 *, signed int);
  // set_property
  signed int (*set_property)(struct xine_video_port_s$1 *, signed int, signed int);
  // status
  signed int (*status)(struct xine_video_port_s$1 *, struct xine_stream_s *, signed int *, signed int *, signed long int *);
  // close
  void (*close)(struct xine_video_port_s$1 *, struct xine_stream_s *);
  // exit
  void (*exit)(struct xine_video_port_s$1 *);
  // driver
  struct vo_driver_s$1 *driver;
};

struct xine_video_port_s
{
  // get_capabilities
  unsigned int (*get_capabilities)(struct xine_video_port_s *);
  // open
  void (*open)(struct xine_video_port_s *, struct xine_stream_s$1 *);
  // get_frame
  struct vo_frame_s * (*get_frame)(struct xine_video_port_s *, unsigned int, unsigned int, double, signed int, signed int);
  // new_grab_video_frame
  struct xine_grab_video_frame_s * (*new_grab_video_frame)(struct xine_video_port_s *);
  // get_last_frame
  struct vo_frame_s * (*get_last_frame)(struct xine_video_port_s *);
  // enable_ovl
  void (*enable_ovl)(struct xine_video_port_s *, signed int);
  // get_overlay_manager
  struct video_overlay_manager_s * (*get_overlay_manager)(struct xine_video_port_s *);
  // flush
  void (*flush)(struct xine_video_port_s *);
  // trigger_drawing
  void (*trigger_drawing)(struct xine_video_port_s *);
  // get_property
  signed int (*get_property)(struct xine_video_port_s *, signed int);
  // set_property
  signed int (*set_property)(struct xine_video_port_s *, signed int, signed int);
  // status
  signed int (*status)(struct xine_video_port_s *, struct xine_stream_s$1 *, signed int *, signed int *, signed long int *);
  // close
  void (*close)(struct xine_video_port_s *, struct xine_stream_s$1 *);
  // exit
  void (*exit)(struct xine_video_port_s *);
  // driver
  struct vo_driver_s *driver;
};

struct xine_video_port_s$0
{
  // get_capabilities
  unsigned int (*get_capabilities)(struct xine_video_port_s$0 *);
  // open
  void (*open)(struct xine_video_port_s$0 *, struct xine_stream_s$0 *);
  // get_frame
  struct vo_frame_s$0 * (*get_frame)(struct xine_video_port_s$0 *, unsigned int, unsigned int, double, signed int, signed int);
  // new_grab_video_frame
  struct xine_grab_video_frame_s * (*new_grab_video_frame)(struct xine_video_port_s$0 *);
  // get_last_frame
  struct vo_frame_s$0 * (*get_last_frame)(struct xine_video_port_s$0 *);
  // enable_ovl
  void (*enable_ovl)(struct xine_video_port_s$0 *, signed int);
  // get_overlay_manager
  struct video_overlay_manager_s$0 * (*get_overlay_manager)(struct xine_video_port_s$0 *);
  // flush
  void (*flush)(struct xine_video_port_s$0 *);
  // trigger_drawing
  void (*trigger_drawing)(struct xine_video_port_s$0 *);
  // get_property
  signed int (*get_property)(struct xine_video_port_s$0 *, signed int);
  // set_property
  signed int (*set_property)(struct xine_video_port_s$0 *, signed int, signed int);
  // status
  signed int (*status)(struct xine_video_port_s$0 *, struct xine_stream_s$0 *, signed int *, signed int *, signed long int *);
  // close
  void (*close)(struct xine_video_port_s$0 *, struct xine_stream_s$0 *);
  // exit
  void (*exit)(struct xine_video_port_s$0 *);
  // driver
  struct vo_driver_s$0 *driver;
};

struct xvdr_metronom_s
{
  // metronom
  struct metronom_s$0 metronom;
  // dispose
  void (*dispose)(struct xvdr_metronom_s *);
  // wire
  void (*wire)(struct xvdr_metronom_s *);
  // unwire
  void (*unwire)(struct xvdr_metronom_s *);
  // scr
  struct adjustable_scr_s *scr;
};

struct xvdr_metronom_s$0
{
  // metronom
  struct metronom_s metronom;
  // dispose
  void (*dispose)(struct xvdr_metronom_s$0 *);
  // wire
  void (*wire)(struct xvdr_metronom_s$0 *);
  // unwire
  void (*unwire)(struct xvdr_metronom_s$0 *);
  // scr
  struct adjustable_scr_s *scr;
  // orig_metronom
  struct metronom_s *orig_metronom;
  // stream
  struct xine_stream_s$0 *stream;
  // trickspeed
  signed int trickspeed;
  // still_mode
  signed int still_mode;
  // last_vo_pts
  signed long int last_vo_pts;
  // wired
  signed int wired;
  // buffering
  unsigned char buffering;
  // live_buffering
  unsigned char live_buffering;
  // stream_start
  unsigned char stream_start;
  // vid_pts
  signed long int vid_pts;
  // aud_pts
  signed long int aud_pts;
  // disc_pts
  signed long int disc_pts;
  // buffering_start_time
  unsigned long int buffering_start_time;
  // first_frame_seen_time
  unsigned long int first_frame_seen_time;
  // mutex
  union anonymous$6 mutex;
};


// bLogToSysLog
// file xine_input_vdr.c line 147
signed int bLogToSysLog = 0;
// bSymbolsFound
// file xine_input_vdr.c line 148
signed int bSymbolsFound = 0;
// demux_info_xvdr
// file xine_input_vdr.c line 6153
static const struct anonymous$33 demux_info_xvdr = { .priority=100 };
// eventmap
// file xine_input_vdr.c line 2846
static struct anonymous$42 eventmap[12l] = { { .type=(const unsigned int)110, .name={ 'X', 'I', 'N', 'E', '_', 'E', 'V', 'E', 'N', 'T', '_', 'I', 'N', 'P', 'U', 'T', '_', 'U', 'P', 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .type=(const unsigned int)111, .name={ 'X', 'I', 'N', 'E', '_', 'E', 'V', 'E', 'N', 'T', '_', 'I', 'N', 'P', 'U', 'T', '_', 'D', 'O', 'W', 'N', 0, 0, 0, 0, 0, 0, 0 } },
    { .type=(const unsigned int)112, .name={ 'X', 'I', 'N', 'E', '_', 'E', 'V', 'E', 'N', 'T', '_', 'I', 'N', 'P', 'U', 'T', '_', 'L', 'E', 'F', 'T', 0, 0, 0, 0, 0, 0, 0 } },
    { .type=(const unsigned int)113, .name={ 'X', 'I', 'N', 'E', '_', 'E', 'V', 'E', 'N', 'T', '_', 'I', 'N', 'P', 'U', 'T', '_', 'R', 'I', 'G', 'H', 'T', 0, 0, 0, 0, 0, 0 } },
    { .type=(const unsigned int)114, .name={ 'X', 'I', 'N', 'E', '_', 'E', 'V', 'E', 'N', 'T', '_', 'I', 'N', 'P', 'U', 'T', '_', 'S', 'E', 'L', 'E', 'C', 'T', 0, 0, 0, 0, 0 } },
    { .type=(const unsigned int)103, .name={ 'X', 'I', 'N', 'E', '_', 'E', 'V', 'E', 'N', 'T', '_', 'I', 'N', 'P', 'U', 'T', '_', 'M', 'E', 'N', 'U', '1', 0, 0, 0, 0, 0, 0 } },
    { .type=(const unsigned int)104, .name={ 'X', 'I', 'N', 'E', '_', 'E', 'V', 'E', 'N', 'T', '_', 'I', 'N', 'P', 'U', 'T', '_', 'M', 'E', 'N', 'U', '2', 0, 0, 0, 0, 0, 0 } },
    { .type=(const unsigned int)105, .name={ 'X', 'I', 'N', 'E', '_', 'E', 'V', 'E', 'N', 'T', '_', 'I', 'N', 'P', 'U', 'T', '_', 'M', 'E', 'N', 'U', '3', 0, 0, 0, 0, 0, 0 } },
    { .type=(const unsigned int)106, .name={ 'X', 'I', 'N', 'E', '_', 'E', 'V', 'E', 'N', 'T', '_', 'I', 'N', 'P', 'U', 'T', '_', 'M', 'E', 'N', 'U', '4', 0, 0, 0, 0, 0, 0 } },
    { .type=(const unsigned int)107, .name={ 'X', 'I', 'N', 'E', '_', 'E', 'V', 'E', 'N', 'T', '_', 'I', 'N', 'P', 'U', 'T', '_', 'M', 'E', 'N', 'U', '5', 0, 0, 0, 0, 0, 0 } },
    { .type=(const unsigned int)115, .name={ 'X', 'I', 'N', 'E', '_', 'E', 'V', 'E', 'N', 'T', '_', 'I', 'N', 'P', 'U', 'T', '_', 'N', 'E', 'X', 'T', 0, 0, 0, 0, 0, 0, 0 } },
    { .type=(const unsigned int)116, .name={ 'X', 'I', 'N', 'E', '_', 'E', 'V', 'E', 'N', 'T', '_', 'I', 'N', 'P', 'U', 'T', '_', 'P', 'R', 'E', 'V', 'I', 'O', 'U', 'S', 0, 0, 0 } } };
// iSysLogLevel
// file xine_input_vdr.c line 146
signed int iSysLogLevel = 1;
// log_module_demux_xvdr
// file xine/demux_xvdr.c line 54
static const char log_module_demux_xvdr[13l] = { '[', 'd', 'e', 'm', 'u', 'x', '_', 'v', 'd', 'r', ']', ' ', 0 };
// log_module_input_osd
// file xine/osd_manager.c line 29
static const char log_module_input_osd[13l] = { '[', 'i', 'n', 'p', 'u', 't', '_', 'o', 's', 'd', ']', ' ', 0 };
// log_module_input_vdr
// file xine_input_vdr.c line 140
static const char log_module_input_vdr[13l] = { '[', 'i', 'n', 'p', 'u', 't', '_', 'v', 'd', 'r', ']', ' ', 0 };
// module_revision
// file xine_input_vdr.c line 139
static const char module_revision[65l] = { '$', 'I', 'd', ':', ' ', 'x', 'i', 'n', 'e', '_', 'i', 'n', 'p', 'u', 't', '_', 'v', 'd', 'r', '.', 'c', ',', 'v', ' ', '1', '.', '3', '6', '6', ' ', '2', '0', '1', '4', '/', '0', '6', '/', '2', '3', ' ', '1', '2', ':', '2', '0', ':', '2', '8', ' ', 'p', 'h', 'i', 'n', 't', 'u', 'k', 'a', ' ', 'E', 'x', 'p', ' ', '$', 0 };
// picture_type_str
// file tools/mpeg.c line 17
const char * const picture_type_str[4l] = { "(none)", "I-Frame", "B-Frame", "P-Frame" };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// vdr_keymap
// file xine_input_vdr.c line 3750
static struct anonymous$52 vdr_keymap[57l] = { { .event=(const unsigned int)115, .name={ 'N', 'e', 'x', 't', 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)116, .name={ 'P', 'r', 'e', 'v', 'i', 'o', 'u', 's', 0, 0, 0, 0 } },
    { .event=(const unsigned int)111, .name={ 'D', 'o', 'w', 'n', 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)110, .name={ 'U', 'p', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)112, .name={ 'L', 'e', 'f', 't', 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)113, .name={ 'R', 'i', 'g', 'h', 't', 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)114, .name={ 'O', 'k', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)103, .name={ 'M', 'e', 'n', 'u', 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)104, .name={ 'R', 'e', 'd', 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)105, .name={ 'G', 'r', 'e', 'e', 'n', 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)106, .name={ 'Y', 'e', 'l', 'l', 'o', 'w', 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)107, .name={ 'B', 'l', 'u', 'e', 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)120, .name={ '0', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)121, .name={ '1', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)122, .name={ '2', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)123, .name={ '3', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)124, .name={ '4', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)125, .name={ '5', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)126, .name={ '6', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)127, .name={ '7', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)128, .name={ '8', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)129, .name={ '9', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)319, .name={ 'B', 'a', 'c', 'k', 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)311, .name={ 'C', 'h', 'a', 'n', 'n', 'e', 'l', '+', 0, 0, 0, 0 } },
    { .event=(const unsigned int)312, .name={ 'C', 'h', 'a', 'n', 'n', 'e', 'l', '-', 0, 0, 0, 0 } },
    { .event=(const unsigned int)300, .name={ 'R', 'e', 'd', 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)301, .name={ 'G', 'r', 'e', 'e', 'n', 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)302, .name={ 'Y', 'e', 'l', 'l', 'o', 'w', 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)303, .name={ 'B', 'l', 'u', 'e', 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)304, .name={ 'P', 'l', 'a', 'y', 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)305, .name={ 'P', 'a', 'u', 's', 'e', 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)306, .name={ 'S', 't', 'o', 'p', 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)307, .name={ 'R', 'e', 'c', 'o', 'r', 'd', 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)308, .name={ 'F', 'a', 's', 't', 'F', 'w', 'd', 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)309, .name={ 'F', 'a', 's', 't', 'R', 'e', 'w', 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)310, .name={ 'P', 'o', 'w', 'e', 'r', 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)313, .name={ 'S', 'c', 'h', 'e', 'd', 'u', 'l', 'e', 0, 0, 0, 0 } },
    { .event=(const unsigned int)314, .name={ 'C', 'h', 'a', 'n', 'n', 'e', 'l', 's', 0, 0, 0, 0 } },
    { .event=(const unsigned int)315, .name={ 'T', 'i', 'm', 'e', 'r', 's', 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)316, .name={ 'R', 'e', 'c', 'o', 'r', 'd', 'i', 'n', 'g', 's', 0, 0 } },
    { .event=(const unsigned int)317, .name={ 'S', 'e', 't', 'u', 'p', 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)318, .name={ 'C', 'o', 'm', 'm', 'a', 'n', 'd', 's', 0, 0, 0, 0 } },
    { .event=(const unsigned int)320, .name={ 'U', 's', 'e', 'r', '1', 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)321, .name={ 'U', 's', 'e', 'r', '2', 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)322, .name={ 'U', 's', 'e', 'r', '3', 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)323, .name={ 'U', 's', 'e', 'r', '4', 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)324, .name={ 'U', 's', 'e', 'r', '5', 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)325, .name={ 'U', 's', 'e', 'r', '6', 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)326, .name={ 'U', 's', 'e', 'r', '7', 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)327, .name={ 'U', 's', 'e', 'r', '8', 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)328, .name={ 'U', 's', 'e', 'r', '9', 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)329, .name={ 'V', 'o', 'l', 'u', 'm', 'e', '+', 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)330, .name={ 'V', 'o', 'l', 'u', 'm', 'e', '-', 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)331, .name={ 'M', 'u', 't', 'e', 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)332, .name={ 'A', 'u', 'd', 'i', 'o', 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)333, .name={ 'I', 'n', 'f', 'o', 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .event=(const unsigned int)335, .name={ 'S', 'u', 'b', 't', 'i', 't', 'l', 'e', 's', 0, 0, 0 } } };
// warnings
// file xine/xvdr_metronom.c line 27
static signed int warnings = 0;
// xine_fast_memcpy
// file /usr/include/xine/xineutils.h line 123
extern void * (*xine_fast_memcpy)(void *, const void *, unsigned long int);
// xine_plugin_info
// file xine_input_vdr.c line 6161
const struct anonymous$13 xine_plugin_info[3l];
// xine_plugin_info
// file xine_input_vdr.c line 6161
const struct anonymous$13 xine_plugin_info[3l] = { { .type=(unsigned char)1, .API=(unsigned char)18, .id="xvdr",
    .version=(unsigned int)(1 * 10000 + 2 * 100 + 6), .special_info=(void *)0,
    .init=input_xvdr_init_class },
    { .type=(unsigned char)2, .API=(unsigned char)27, .id="xvdr",
    .version=(unsigned int)(1 * 10000 + 2 * 100 + 6), .special_info=(const void *)&demux_info_xvdr,
    .init=demux_xvdr_init_class },
    { .type=(unsigned char)0, .API=(unsigned char)0, .id="",
    .version=(unsigned int)0, .special_info=(void *)0, .init=(void * (*)(struct xine_s$0 *, void *))(void *)0 } };
// xine_plugin_info_xvdr
// file xine_input_vdr.c line 6170
const struct anonymous$13 *xine_plugin_info_xvdr;
// xine_plugin_info_xvdr
// file xine_input_vdr.c line 6170
const struct anonymous$13 *xine_plugin_info_xvdr = xine_plugin_info;

// SetupLogLevel
// file xine_input_vdr.c line 173
static void SetupLogLevel(void)
{
  void *lib = (void *)0;
  lib=dlopen((const char *)(void *)0, 0x00001 | 0x00100);
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  _Bool tmp_if_expr$7;
  signed int tmp_if_expr$8;
  if(lib == NULL)
    do
      if(iSysLogLevel >= 1)
      {
        char *return_value_dlerror$1;
        return_value_dlerror$1=dlerror();
        x_syslog(3, log_module_input_vdr, "Can't dlopen self: %s", return_value_dlerror$1);
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        if(!(*return_value___errno_location$4 == 0))
        {
          return_value___errno_location$2=__errno_location();
          return_value_strerror$3=strerror(*return_value___errno_location$2);
          x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 177, return_value_strerror$3);
        }

      }

    while((_Bool)0);

  else
  {
    signed int *pLogToSyslog;
    void *return_value_dlsym$5;
    return_value_dlsym$5=dlsym(lib, "LogToSysLog");
    pLogToSyslog = (signed int *)return_value_dlsym$5;
    signed int *pSysLogLevel;
    void *return_value_dlsym$6;
    return_value_dlsym$6=dlsym(lib, "SysLogLevel");
    pSysLogLevel = (signed int *)return_value_dlsym$6;
    if(!(pLogToSyslog == ((signed int *)NULL)))
      tmp_if_expr$7 = *pLogToSyslog != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$7 = (_Bool)0;
    bLogToSysLog = (signed int)tmp_if_expr$7;
    if(!(pSysLogLevel == ((signed int *)NULL)))
      tmp_if_expr$8 = *pSysLogLevel;

    else
      tmp_if_expr$8 = iSysLogLevel;
    iSysLogLevel = tmp_if_expr$8;
    do
      if(iSysLogLevel >= 3)
        x_syslog(7, log_module_input_vdr, "Symbol SysLogLevel %s : value %d", pSysLogLevel != ((signed int *)NULL) ? "found" : "not found", iSysLogLevel);

    while((_Bool)0);
    do
      if(iSysLogLevel >= 3)
        x_syslog(7, log_module_input_vdr, "Symbol LogToSysLog %s : value %s", pLogToSyslog != ((signed int *)NULL) ? "found" : "not found", bLogToSysLog != 0 ? "yes" : "no");

    while((_Bool)0);
    bSymbolsFound = (signed int)(pSysLogLevel != ((signed int *)NULL) && pLogToSyslog != ((signed int *)NULL));
    dlclose(lib);
  }
}

// __bswap_32
// file /usr/include/x86_64-linux-gnu/bits/byteswap.h line 45
static inline unsigned int __bswap_32(unsigned int __bsx)
{
  signed long int return_value___builtin_bswap32$1;
  return_value___builtin_bswap32$1=__builtin_bswap32((signed long int)__bsx);
  return (unsigned int)return_value___builtin_bswap32$1;
}

// absdiff
// file xine/xvdr_metronom.c line 29
static signed long int absdiff(signed long int a, signed long int b)
{
  signed long int diff = a - b;
  if(!(diff >= 0l))
    diff = -diff;

  return diff;
}

// acquire_ticket
// file xine/osd_manager.c line 122
static void acquire_ticket(struct osd_manager_impl_s *this)
{
  if(this->ticket_acquired == 0)
  {
    this->stream->xine->port_ticket->acquire(this->stream->xine->port_ticket, 1);
    this->ticket_acquired = (unsigned char)1;
  }

}

// adjust_scr_speed
// file xine_input_vdr.c line 4920
static signed int adjust_scr_speed(struct vdr_input_plugin_s *this)
{
  signed int need_pause = 0;
  signed int return_value_pthread_mutex_lock$4;
  return_value_pthread_mutex_lock$4=pthread_mutex_lock(&this->lock);
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$7;
  if(!(return_value_pthread_mutex_lock$4 == 0))
  {
    do
      if(iSysLogLevel >= 1)
      {
        x_syslog(3, log_module_input_vdr, "adjust_scr_speed: pthread_mutex_lock failed");
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        if(!(*return_value___errno_location$3 == 0))
        {
          return_value___errno_location$1=__errno_location();
          return_value_strerror$2=strerror(*return_value___errno_location$1);
          x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 4925, return_value_strerror$2);
        }

      }

    while((_Bool)0);
    return 0;
  }

  else
  {
    if(this->live_mode == 0)
    {
      if(!(this->fd_control >= 0))
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = this->fixed_scr != 0 ? (_Bool)1 : (_Bool)0;
      tmp_if_expr$6 = tmp_if_expr$5 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$6 = (_Bool)0;
    if(tmp_if_expr$6)
      tmp_if_expr$7 = (_Bool)1;

    else
      tmp_if_expr$7 = this->slave.stream != ((struct xine_stream_s *)NULL) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$7)
    {
      if(!(this->scr_tuning == 0))
        reset_scr_tuning(this);

    }

    else
      if(!(this->stream_start == 0))
      {
        reset_scr_tuning(this);
        need_pause = 1;
      }

      else
        vdr_adjust_realtime_speed(this);
    pthread_mutex_unlock(&this->lock);
    return need_pause;
  }
}

// adjustable_scr_dispose
// file xine/adjustable_scr.c line 296
static void adjustable_scr_dispose(struct adjustable_scr_s *scr)
{
  struct scr_impl_s *this = (struct scr_impl_s *)scr;
  if(!(this->xine == ((struct xine_s$2 *)NULL)))
    this->xine->clock->unregister_scr(this->xine->clock, &this->$anon0.scr);

  this->$anon0.scr.exit(&this->$anon0.scr);
}

// adjustable_scr_got_pcr
// file xine/adjustable_scr.c line 257
static void adjustable_scr_got_pcr(struct adjustable_scr_s *scr, signed long int pcr)
{
  ;
}

// adjustable_scr_jump
// file xine/adjustable_scr.c line 240
static void adjustable_scr_jump(struct adjustable_scr_s *scr, signed int pts)
{
  struct scr_impl_s *this = (struct scr_impl_s *)scr;
  pthread_mutex_lock(&this->lock);
  set_pivot(this);
  this->cur_pts = this->cur_pts + (signed long int)pts;
  pthread_mutex_unlock(&this->lock);
}

// adjustable_scr_set_buffering
// file xine/adjustable_scr.c line 266
static void adjustable_scr_set_buffering(struct adjustable_scr_s *scr, signed int buffering)
{
  struct scr_impl_s *this = (struct scr_impl_s *)scr;
  pthread_mutex_lock(&this->lock);
  unsigned long int return_value_elapsed$1;
  if(!(buffering == 0))
  {
    if(this->buffering == 0)
    {
      set_pivot(this);
      this->buffering = 1;
      this->buffering_start_time=time_ms();
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, "[scr      ] ", "start buffering at %ld", this->cur_pts);

      while((_Bool)0);
    }

  }

  else
    if(!(this->buffering == 0))
    {
      set_pivot(this);
      this->buffering = 0;
      do
        if(iSysLogLevel >= 2)
        {
          return_value_elapsed$1=elapsed(this->buffering_start_time);
          x_syslog(6, "[scr      ] ", "stop buffering at %ld (buffering took %lu ms)", this->cur_pts, return_value_elapsed$1);
        }

      while((_Bool)0);
    }

  pthread_mutex_unlock(&this->lock);
}

// adjustable_scr_speed_base
// file xine/adjustable_scr.c line 220
static void adjustable_scr_speed_base(struct adjustable_scr_s *scr, signed int hz)
{
  struct scr_impl_s *this = (struct scr_impl_s *)scr;
  pthread_mutex_lock(&this->lock);
  set_pivot(this);
  this->scr_speed_base = hz;
  this->speed_factor = (((double)this->xine_speed * (double)this->scr_speed_base) / (1.0 * (double)1000000)) * this->speed_tuning;
  pthread_mutex_unlock(&this->lock);
}

// adjustable_scr_speed_tuning
// file xine/adjustable_scr.c line 200
static void adjustable_scr_speed_tuning(struct adjustable_scr_s *scr, double factor)
{
  struct scr_impl_s *this = (struct scr_impl_s *)scr;
  pthread_mutex_lock(&this->lock);
  set_pivot(this);
  this->speed_tuning = factor;
  this->speed_factor = (((double)this->xine_speed * (double)this->scr_speed_base) / (1.0 * (double)1000000)) * this->speed_tuning;
  pthread_mutex_unlock(&this->lock);
}

// adjustable_scr_start
// file xine/adjustable_scr.c line 312
struct adjustable_scr_s * adjustable_scr_start(struct xine_s$2 *xine)
{
  struct scr_impl_s *this;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct scr_impl_s) /*224ul*/ );
  this = (struct scr_impl_s *)return_value_calloc$1;
  this->$anon0.scr.interface_version = 3;
  this->$anon0.scr.set_fine_speed = scr_set_fine_speed;
  this->$anon0.scr.get_priority = scr_get_priority;
  this->$anon0.scr.adjust = scr_adjust;
  this->$anon0.scr.start = scr_start;
  this->$anon0.scr.get_current = scr_get_current;
  this->$anon0.scr.exit = scr_exit;
  this->$anon0.ascr.set_speed_tuning = adjustable_scr_speed_tuning;
  this->$anon0.ascr.set_speed_base = adjustable_scr_speed_base;
  this->$anon0.ascr.jump = adjustable_scr_jump;
  this->$anon0.ascr.got_pcr = adjustable_scr_got_pcr;
  this->$anon0.ascr.set_buffering = adjustable_scr_set_buffering;
  this->$anon0.ascr.dispose = adjustable_scr_dispose;
  pthread_mutex_init(&this->lock, (const union anonymous$37 *)(void *)0);
  this->xine = xine;
  this->scr_speed_base = 90000;
  adjustable_scr_speed_tuning(&this->$anon0.ascr, 1.0);
  scr_set_fine_speed(&this->$anon0.scr, 0);
  unsigned long int time;
  signed long int return_value;
  return_value=xine->clock->get_current_time(xine->clock);
  time = (unsigned long int)return_value;
  this->$anon0.scr.start(&this->$anon0.scr, (signed long int)time);
  signed int return_value_1;
  return_value_1=xine->clock->register_scr(xine->clock, &this->$anon0.scr);
  if(!(return_value_1 == 0))
  {
    scr_exit(&this->$anon0.scr);
    return (struct adjustable_scr_s *)(void *)0;
  }

  else
    return &this->$anon0.ascr;
}

// alloc_udp_data_socket
// file xine_input_vdr.c line 5318
static signed int alloc_udp_data_socket(signed int firstport, signed int trycount, signed int *port)
{
  signed int fd;
  signed int one = 1;
  struct sockaddr_in name;
  name.sin_family = (unsigned short int)2;
  unsigned short int tmp_statement_expression$1;
  unsigned short int __v;
  unsigned short int alloc_udp_data_socket$$1$$1$$__x = (unsigned short int)firstport;
  asm("rorw $8, %w0" : "=r"(__v) : "0"(alloc_udp_data_socket$$1$$1$$__x) : "cc");
  tmp_statement_expression$1 = __v;
  name.sin_port = tmp_statement_expression$1;
  name.sin_addr.s_addr=__bswap_32((unsigned int)0x00000000);
  fd=socket(2, 2, 0);
  set_recv_buffer_size(fd, (unsigned int)(1024 * 512));
  signed int return_value_setsockopt$5;
  return_value_setsockopt$5=setsockopt(fd, 1, 2, (const void *)&one, (unsigned int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  if(!(return_value_setsockopt$5 >= 0))
    do
      if(iSysLogLevel >= 1)
      {
        x_syslog(3, log_module_input_vdr, "UDP data stream: setsockopt(SO_REUSEADDR) failed");
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        if(!(*return_value___errno_location$4 == 0))
        {
          return_value___errno_location$2=__errno_location();
          return_value_strerror$3=strerror(*return_value___errno_location$2);
          x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 5332, return_value_strerror$3);
        }

      }

    while((_Bool)0);

  signed int return_value_bind$6;
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  unsigned short int tmp_statement_expression$12;
  do
  {
    return_value_bind$6=bind(fd, (struct sockaddr *)&name, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    if(return_value_bind$6 >= 0)
      break;

    trycount = trycount - 1;
    if(trycount == 0)
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "UDP Data stream: bind error, no free port found");

      while((_Bool)0);
      close(fd);
      return -1;
    }

    do
      if(iSysLogLevel >= 1)
      {
        signed int *return_value___errno_location$7;
        return_value___errno_location$7=__errno_location();
        char *return_value_strerror$8;
        return_value_strerror$8=strerror(*return_value___errno_location$7);
        x_syslog(3, log_module_input_vdr, "UDP Data stream: bind error, port %d: %s", name.sin_port, return_value_strerror$8);
        signed int *return_value___errno_location$11;
        return_value___errno_location$11=__errno_location();
        if(!(*return_value___errno_location$11 == 0))
        {
          return_value___errno_location$9=__errno_location();
          return_value_strerror$10=strerror(*return_value___errno_location$9);
          x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 5341, return_value_strerror$10);
        }

      }

    while((_Bool)0);
    unsigned short int alloc_udp_data_socket$$1$$3$$3$$__v;
    unsigned short int alloc_udp_data_socket$$1$$3$$3$$__x;
    firstport = firstport + 1;
    alloc_udp_data_socket$$1$$3$$3$$__x = (unsigned short int)firstport;
    asm("rorw $8, %w0" : "=r"(alloc_udp_data_socket$$1$$3$$3$$__v) : "0"(alloc_udp_data_socket$$1$$3$$3$$__x) : "cc");
    tmp_statement_expression$12 = alloc_udp_data_socket$$1$$3$$3$$__v;
    name.sin_port = tmp_statement_expression$12;
  }
  while((_Bool)1);
  unsigned short int tmp_statement_expression$13;
  unsigned short int alloc_udp_data_socket$$1$$4$$__v;
  unsigned short int __x = (unsigned short int)name.sin_port;
  asm("rorw $8, %w0" : "=r"(alloc_udp_data_socket$$1$$4$$__v) : "0"(__x) : "cc");
  tmp_statement_expression$13 = alloc_udp_data_socket$$1$$4$$__v;
  *port = (signed int)tmp_statement_expression$13;
  return fd;
}

// argb_layer_create
// file xine/osd_manager.c line 80
static struct argb_layer_s * argb_layer_create()
{
  struct argb_layer_s *argb_layer;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct argb_layer_s) /*72ul*/ );
  argb_layer = (struct argb_layer_s *)return_value_calloc$1;
  pthread_mutex_init(&argb_layer->mutex, (const union anonymous$37 *)(void *)0);
  return argb_layer;
}

// argb_layer_destroy
// file xine/osd_manager.c line 89
static void argb_layer_destroy(struct argb_layer_s *argb_layer)
{
  pthread_mutex_destroy(&argb_layer->mutex);
  free((void *)argb_layer);
}

// argb_supported
// file xine/osd_manager.c line 955
static signed int argb_supported(struct xine_stream_s *stream)
{
  struct xine_video_port_s$1 *video_out = stream->video_out;
  unsigned int return_value;
  return_value=video_out->get_capabilities(video_out);
  return (signed int)!(!((return_value & (unsigned int)0x02000000) != 0u));
}

// asprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 176
static inline signed int asprintf(char ** restrict __ptr, const char * restrict __fmt, ...)
{
  void *return_value___builtin_va_arg_pack$1;
  return_value___builtin_va_arg_pack$1=__builtin_va_arg_pack();
  signed int return_value___asprintf_chk$2;
  return_value___asprintf_chk$2=__asprintf_chk(__ptr, 2 - 1, __fmt, return_value___builtin_va_arg_pack$1);
  return return_value___asprintf_chk$2;
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol$1;
  return_value_strtol$1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol$1;
}

// br_get_bit
// file tools/bitstream.h line 34
static inline signed int br_get_bit(struct anonymous$15 *br)
{
  if(br->index >= br->count)
    return 1;

  else
  {
    signed int r = (signed int)br->data[(signed long int)(br->index >> 3)] >> 7 - (br->index & 7) & 1;
    br->index = br->index + 1;
    return r;
  }
}

// br_get_bits
// file tools/bitstream.h line 44
static inline unsigned int br_get_bits(struct anonymous$15 *br, unsigned int n)
{
  unsigned int r = (unsigned int)0;
  unsigned int tmp_post$1;
  signed int return_value_br_get_bit$2;
  do
  {
    tmp_post$1 = n;
    n = n - 1u;
    if(tmp_post$1 == 0u)
      break;

    return_value_br_get_bit$2=br_get_bit(br);
    r = r | (unsigned int)(return_value_br_get_bit$2 << n);
  }
  while((_Bool)1);
  return r;
}

// br_get_se_golomb
// file tools/bitstream.h line 157
static inline signed int br_get_se_golomb(struct anonymous$15 *br)
{
  unsigned int r;
  unsigned int return_value_br_get_ue_golomb$1;
  return_value_br_get_ue_golomb$1=br_get_ue_golomb(br);
  r = return_value_br_get_ue_golomb$1 + (unsigned int)1;
  return (signed int)((r & (unsigned int)1) != 0u ? -(r >> 1) : r >> 1);
}

// br_get_ue_golomb
// file tools/bitstream.h line 149
static inline unsigned int br_get_ue_golomb(struct anonymous$15 *br)
{
  signed int n = 0;
  signed int return_value_br_get_bit$1;
  do
  {
    return_value_br_get_bit$1=br_get_bit(br);
    if(!(return_value_br_get_bit$1 == 0))
      break;

    if(n >= 32)
      break;

    n = n + 1;
  }
  while((_Bool)1);
  unsigned int tmp_if_expr$3;
  unsigned int return_value_br_get_bits$2;
  if(!(n == 0))
  {
    return_value_br_get_bits$2=br_get_bits(br, (unsigned int)n);
    tmp_if_expr$3 = (unsigned int)((1 << n) - 1) + return_value_br_get_bits$2;
  }

  else
    tmp_if_expr$3 = (unsigned int)0;
  return tmp_if_expr$3;
}

// br_skip_bits
// file tools/bitstream.h line 54
static inline void br_skip_bits(struct anonymous$15 *br, signed int n)
{
  br->index = br->index + n;
}

// br_skip_golomb
// file tools/bitstream.h line 163
static inline void br_skip_golomb(struct anonymous$15 *br)
{
  signed int n = 0;
  signed int return_value_br_get_bit$1;
  do
  {
    return_value_br_get_bit$1=br_get_bit(br);
    if(!(return_value_br_get_bit$1 == 0))
      break;

    if(n >= 32)
      break;

    n = n + 1;
  }
  while((_Bool)1);
  br_skip_bits(br, n);
}

// buffer_pool_free
// file xine_input_vdr.c line 1192
static void buffer_pool_free(struct buf_element_s *element)
{
  struct fifo_buffer_s *this = (struct fifo_buffer_s *)element->source;
  pthread_mutex_lock(&this->buffer_pool_mutex);
  element->next = this->buffer_pool_top;
  this->buffer_pool_top = element;
  this->buffer_pool_num_free = this->buffer_pool_num_free + 1;
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  if(!(this->buffer_pool_capacity >= this->buffer_pool_num_free))
  {
    do
      if(iSysLogLevel >= 1)
      {
        x_syslog(3, log_module_input_vdr, "xine-lib:buffer: There has been a fatal error: TOO MANY FREE's");
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        if(!(*return_value___errno_location$3 == 0))
        {
          return_value___errno_location$1=__errno_location();
          return_value_strerror$2=strerror(*return_value___errno_location$1);
          x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 1203, return_value_strerror$2);
        }

      }

    while((_Bool)0);
    do
    {
      fprintf(stderr, "abort: %s:%d: %s: Aborting.\n", (const void *)"xine_input_vdr.c", 1204, (const void *)"buffer_pool_free");
      abort();
    }
    while((_Bool)0);
  }

  if(this->buffer_pool_num_free >= 21)
    pthread_cond_signal(&this->buffer_pool_cond_not_empty);

  pthread_mutex_unlock(&this->buffer_pool_mutex);
}

// check_buffering_done
// file xine/xvdr_metronom.c line 32
static void check_buffering_done(struct xvdr_metronom_s$0 *this)
{
  if(!(this->vid_pts == 0l))
  {
    if(!(this->aud_pts == 0l))
    {
      signed long int da = this->aud_pts - this->disc_pts;
      signed long int dv = this->vid_pts - this->disc_pts;
      signed long int d_min;
      d_min=min64(da, dv);
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, "[metronom ] ", "  stream A-V diff %d ms", (signed int)(this->vid_pts - this->aud_pts) / 90);

      while((_Bool)0);
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, "[metronom ] ", "  reported stream start at pts %ld", this->disc_pts);

      while((_Bool)0);
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, "[metronom ] ", "  output fifo end at: audio %ld video %ld", this->aud_pts, this->vid_pts);

      while((_Bool)0);
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, "[metronom ] ", "  dA %ld dV %ld", da, dv);

      while((_Bool)0);
      if(d_min >= -899999l && !(d_min >= 0l))
      {
        do
          if(iSysLogLevel >= 2)
            x_syslog(6, "[metronom ] ", "  *** output is late %ld ticks (%ld ms) ***", d_min, -d_min / (signed long int)90);

        while((_Bool)0);
        this->scr->jump(this->scr, (signed int)d_min);
      }

      this->buffering = (unsigned char)0;
      this->stream_start = (unsigned char)0;
      this->scr->set_buffering(this->scr, 0);
    }

  }

  if(!(this->first_frame_seen_time == 0ul))
  {
    signed long int ms_since_first_frame;
    unsigned long int return_value_elapsed$1;
    return_value_elapsed$1=elapsed$link1(this->first_frame_seen_time);
    ms_since_first_frame = (signed long int)return_value_elapsed$1;
    if(ms_since_first_frame >= 1001l)
    {
      this->stream_start = (unsigned char)0;
      if(!(this->vid_pts == 0l))
      {
        if(this->aud_pts == 0l)
        {
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, "[metronom ] ", "buffering stopped: NO AUDIO ? elapsed time %d ms", (signed int)ms_since_first_frame);

          while((_Bool)0);
          this->buffering = (unsigned char)0;
          this->scr->set_buffering(this->scr, 0);
        }

      }

      if(!(this->vid_pts == 0l))
        goto __CPROVER_DUMP_L18;

      if(this->aud_pts == 0l)
        goto __CPROVER_DUMP_L18;

      do
        if(iSysLogLevel >= 2)
          x_syslog(6, "[metronom ] ", "buffering stopped: NO VIDEO ? elapsed time %d ms", (signed int)ms_since_first_frame);

      while((_Bool)0);
      this->buffering = (unsigned char)0;
      this->scr->set_buffering(this->scr, 0);
    }

    else

      __CPROVER_DUMP_L18:
        ;
  }

}

// check_newpts
// file xine/demux_xvdr.c line 221
static void check_newpts(struct demux_xvdr_s *this, struct buf_element_s *buf, signed int video)
{
  _Bool tmp_if_expr$1;
  if(buf->pts >= 1l)
  {
    if(!(video == 0))
    {
      signed int still_mode;
      signed long int return_value;
      return_value=this->stream->metronom->get_option(this->stream->metronom, 0x1001 + 2);
      still_mode = (signed int)return_value;
      signed int trick_speed;
      signed long int return_value_1;
      return_value_1=this->stream->metronom->get_option(this->stream->metronom, 0x1001 + 1);
      trick_speed = (signed int)return_value_1;
      if(still_mode >= 1 || trick_speed >= 1)
      {
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_demux_xvdr, "Skipping new pts %ld (still=%d trickspeed=%d)", buf->pts, still_mode, trick_speed);

      }

    }

    pts_wrap_workaround(this, buf, video);
    if(!(buf->pts == 0l))
    {
      signed long int diff = buf->pts - this->last_pts[(signed long int)video];
      if(!(this->send_newpts == 0))
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (this->last_pts[(signed long int)video] != 0l ? ((diff < (signed long int)0 ? -diff : diff) > (signed long int)360000 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
      {
        do
          if(iSysLogLevel >= 4)
            x_syslog(7, log_module_demux_xvdr, "New PTS: %ld (%s)", buf->pts, video != 0 ? "VIDEO" : "AUDIO");

        while((_Bool)0);
        if(!(this->buf_flag_seek == 0))
        {
          _x_demux_control_newpts(this->stream, buf->pts, (unsigned int)0x0100);
          this->buf_flag_seek = (unsigned char)0;
        }

        else
          _x_demux_control_newpts(this->stream, buf->pts, (unsigned int)0);
        this->send_newpts = (unsigned char)0;
      }

      this->last_pts[(signed long int)video] = buf->pts;
      this->last_pts[(signed long int)(1 - video)] = buf->pts;
    }

  }

}

// clear_osdcmd
// file xine/osd_manager.c line 182
static void clear_osdcmd(struct osd_command_s *cmd)
{
  free((void *)cmd->$anon0.data);
  cmd->$anon0.data = (struct osd_rle_elem_s *)(void *)0;
  free((void *)cmd->$anon1.palette);
  cmd->$anon1.palette = (struct osd_clut_s *)(void *)0;
}

// close_slave_stream
// file xine_input_vdr.c line 2354
static void close_slave_stream(struct vdr_input_plugin_s *this)
{
  if(!(this->slave.stream == ((struct xine_stream_s *)NULL)))
  {
    if(!(this->bg_stream.stream == ((struct xine_stream_s *)NULL)))
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "Closing background stream");

      while((_Bool)0);
      xine_stop(this->bg_stream.stream);
      if(!(this->bg_stream.event_queue == ((struct xine_event_queue_s *)NULL)))
      {
        xine_event_dispose_queue(this->bg_stream.event_queue);
        this->bg_stream.event_queue = (struct xine_event_queue_s *)(void *)0;
      }

      xine_close(this->bg_stream.stream);
      xine_dispose(this->bg_stream.stream);
      this->bg_stream.stream = (struct xine_stream_s *)(void *)0;
    }

    if(!(this->slave.event_queue == ((struct xine_event_queue_s *)NULL)))
    {
      xine_event_dispose_queue(this->slave.event_queue);
      this->slave.event_queue = (struct xine_event_queue_s *)(void *)0;
    }

    xine_stop(this->slave.stream);
    if(!(this->$anon0.$anon0.funcs.fe_control == ((void * (*)(struct frontend_s *, const char *))NULL)))
    {
      this->$anon0.$anon0.funcs.fe_control(this->$anon0.$anon0.funcs.fe_handle, "POST 0 Off\r\n");
      this->$anon0.$anon0.funcs.fe_control(this->$anon0.$anon0.funcs.fe_handle, "SLAVE 0x0\r\n");
    }

    xine_close(this->slave.stream);
    xine_dispose(this->slave.stream);
    pthread_mutex_lock(&this->lock);
    this->slave.stream = (struct xine_stream_s *)(void *)0;
    pthread_mutex_unlock(&this->lock);
    if(!(this->$anon0.$anon0.funcs.fe_control == ((void * (*)(struct frontend_s *, const char *))NULL)))
      this->$anon0.$anon0.funcs.fe_control(this->$anon0.$anon0.funcs.fe_handle, "SLAVE CLOSED\r\n");

  }

}

// connect_control_stream
// file xine_input_vdr.c line 5349
static signed int connect_control_stream(struct vdr_input_plugin_s *this, const char *host, signed int port, signed int *client_id)
{
  char tmpbuf[256l];
  signed int fd_control;
  signed int saved_fd = this->fd_control;
  signed int one = 1;
  fd_control=_x_io_tcp_connect(this->stream, host, port);
  this->fd_control = fd_control;
  _Bool tmp_if_expr$5;
  signed int return_value__x_io_tcp_connect_finish$4;
  if(!(fd_control >= 0))
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value__x_io_tcp_connect_finish$4=_x_io_tcp_connect_finish(this->stream, this->fd_control, 3000);
    tmp_if_expr$5 = 0 != return_value__x_io_tcp_connect_finish$4 ? (_Bool)1 : (_Bool)0;
  }
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  signed int *return_value___errno_location$6;
  char *return_value_strerror$7;
  _Bool tmp_if_expr$14;
  char *return_value_strstr$13;
  _Bool tmp_if_expr$16;
  char *return_value_strstr$15;
  _Bool tmp_if_expr$21;
  signed int return_value_strncmp$20;
  signed int return_value_sscanf$18;
  if(tmp_if_expr$5)
  {
    do
      if(iSysLogLevel >= 1)
      {
        x_syslog(3, log_module_input_vdr, "Can't connect to tcp://%s:%d", host, port);
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        if(!(*return_value___errno_location$3 == 0))
        {
          return_value___errno_location$1=__errno_location();
          return_value_strerror$2=strerror(*return_value___errno_location$1);
          x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 5362, return_value_strerror$2);
        }

      }

    while((_Bool)0);
    close(fd_control);
    this->fd_control = saved_fd;
    return -1;
  }

  else
  {
    set_recv_buffer_size(fd_control, (unsigned int)(1024 * 128));
    signed long int return_value__x_io_tcp_write$9;
    return_value__x_io_tcp_write$9=_x_io_tcp_write(this->stream, fd_control, (void *)"CONTROL\r\n", (signed long int)9);
    if(!(return_value__x_io_tcp_write$9 >= 0l))
    {
      do
        if(iSysLogLevel >= 1)
        {
          x_syslog(3, log_module_input_vdr, "Control stream write error");
          signed int *return_value___errno_location$8;
          return_value___errno_location$8=__errno_location();
          if(!(*return_value___errno_location$8 == 0))
          {
            return_value___errno_location$6=__errno_location();
            return_value_strerror$7=strerror(*return_value___errno_location$6);
            x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 5372, return_value_strerror$7);
          }

        }

      while((_Bool)0);
      return -1;
    }

    else
    {
      signed long int return_value_readline_control$10;
      return_value_readline_control$10=readline_control(this, tmpbuf, sizeof(char [256l]) /*256ul*/  - (unsigned long int)1, 4);
      if(!(return_value_readline_control$10 >= 1l))
      {
        do
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "Server not replying");

        while((_Bool)0);
        close(fd_control);
        this->fd_control = saved_fd;
        return -1;
      }

      else
      {
        do
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "Server greeting: %s", (const void *)tmpbuf);

        while((_Bool)0);
        signed int return_value_strncmp$11;
        return_value_strncmp$11=strncmp(tmpbuf, "Access denied", (unsigned long int)13);
        if(return_value_strncmp$11 == 0)
        {
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_input_vdr, "Maybe host address is missing from server-side plugins/xineliboutput/allowed_hosts.conf ?");

          while((_Bool)0);
          close(fd_control);
          this->fd_control = saved_fd;
          return -1;
        }

        else
        {
          char *return_value_strstr$12;
          return_value_strstr$12=strstr(tmpbuf, "VDR-");
          if(return_value_strstr$12 == ((char *)NULL))
            tmp_if_expr$14 = (_Bool)1;

          else
          {
            return_value_strstr$13=strstr(tmpbuf, "xineliboutput-");
            tmp_if_expr$14 = !(return_value_strstr$13 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$14)
            tmp_if_expr$16 = (_Bool)1;

          else
          {
            return_value_strstr$15=strstr(tmpbuf, "READY");
            tmp_if_expr$16 = !(return_value_strstr$15 != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$16)
          {
            do
              if(iSysLogLevel >= 2)
                x_syslog(6, log_module_input_vdr, "Unregonized greeting !");

            while((_Bool)0);
            close(fd_control);
            this->fd_control = saved_fd;
            return -1;
          }

          else
          {
            char *return_value_strstr$17;
            return_value_strstr$17=strstr(tmpbuf, "xineliboutput-2.0.0-cvs ");
            if(return_value_strstr$17 == ((char *)NULL))
            {
              do
                if(iSysLogLevel >= 2)
                  x_syslog(6, log_module_input_vdr, "-----------------------------------------------------------------");

              while((_Bool)0);
              do
                if(iSysLogLevel >= 2)
                  x_syslog(6, log_module_input_vdr, "WARNING: Client and server versions of xinelibout are different !");

              while((_Bool)0);
              do
                if(iSysLogLevel >= 2)
                  x_syslog(6, log_module_input_vdr, "         Client version (xine_input_vdr.so) is 2.0.0-cvs");

              while((_Bool)0);
              do
                if(iSysLogLevel >= 2)
                  x_syslog(6, log_module_input_vdr, "-----------------------------------------------------------------");

              while((_Bool)0);
            }

            signed long int return_value_readline_control$19;
            return_value_readline_control$19=readline_control(this, tmpbuf, sizeof(char [256l]) /*256ul*/  - (unsigned long int)1, 4);
            if(return_value_readline_control$19 >= 1l)
            {
              return_value_strncmp$20=strncmp(tmpbuf, "CLIENT-ID ", (unsigned long int)10);
              tmp_if_expr$21 = !(return_value_strncmp$20 != 0) ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$21 = (_Bool)0;
            if(tmp_if_expr$21)
            {
              do
                if(iSysLogLevel >= 3)
                  x_syslog(7, log_module_input_vdr, "Got Client-ID: %s", tmpbuf + (signed long int)10);

              while((_Bool)0);
              if(!(client_id == ((signed int *)NULL)))
              {
                return_value_sscanf$18=sscanf(tmpbuf + (signed long int)10, "%d", client_id);
                if(!(return_value_sscanf$18 == 1))
                  *client_id = -1;

              }

            }

            else
            {
              do
                if(iSysLogLevel >= 2)
                  x_syslog(6, log_module_input_vdr, "Warning: No Client-ID !");

              while((_Bool)0);
              if(!(*client_id == 0))
                *client_id = -1;

            }
            signed int return_value_fcntl$22;
            return_value_fcntl$22=fcntl(fd_control, 3);
            fcntl(fd_control, 4, return_value_fcntl$22 | 04000);
            setsockopt(fd_control, 6, 1, (const void *)&one, (unsigned int)sizeof(signed int) /*4ul*/ );
            this->fd_control = saved_fd;
            return fd_control;
          }
        }
      }
    }
  }
}

// connect_pipe_data_stream
// file xine_input_vdr.c line 5705
static signed int connect_pipe_data_stream(struct vdr_input_plugin_s *this)
{
  char tmpbuf[256l];
  signed int fd_data = -1;
  char *return_value_strstr$1;
  return_value_strstr$1=strstr(this->mrl, "127.0.0.1");
  if(return_value_strstr$1 == ((char *)NULL))
  {
    struct sockaddr_in sinc;
    struct sockaddr_in sins;
    unsigned int len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
    getsockname(this->fd_control, &sinc, &len);
    getpeername(this->fd_control, &sins, &len);
    if(!(sinc.sin_addr.s_addr == sins.sin_addr.s_addr))
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "connect_pipe_data_stream: client ip=0x%x != server ip=0x%x !", (unsigned int)sinc.sin_addr.s_addr, (unsigned int)sins.sin_addr.s_addr);

      while((_Bool)0);

  }

  _x_io_tcp_write(this->stream, this->fd_control, (void *)"PIPE\r\n", (signed long int)6);
  signed long int return_value_readline_control$10;
  return_value_readline_control$10=readline_control(this, tmpbuf, sizeof(char [256l]) /*256ul*/ , 4);
  signed int return_value_strncmp$9;
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  signed int return_value_strncmp$7;
  if(!(return_value_readline_control$10 >= 1l))
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_vdr, "Pipe request failed");

    while((_Bool)0);

  else
  {
    return_value_strncmp$9=strncmp(tmpbuf, "PIPE /", (unsigned long int)6);
    if(!(return_value_strncmp$9 == 0))
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "Server does not support pipes ? (%s)", (const void *)tmpbuf);

      while((_Bool)0);

    else
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "Connecting (data) to pipe://%s", tmpbuf + (signed long int)5);

      while((_Bool)0);
      fd_data=open(tmpbuf + (signed long int)5, 00 | 04000);
      if(!(fd_data >= 0))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        if(*return_value___errno_location$5 == 2)
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_input_vdr, "Pipe not found");

          while((_Bool)0);

        else
          do
            if(iSysLogLevel >= 1)
            {
              x_syslog(3, log_module_input_vdr, "Pipe opening failed");
              signed int *return_value___errno_location$4;
              return_value___errno_location$4=__errno_location();
              if(!(*return_value___errno_location$4 == 0))
              {
                return_value___errno_location$2=__errno_location();
                return_value_strerror$3=strerror(*return_value___errno_location$2);
                x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 5739, return_value_strerror$3);
              }

            }

          while((_Bool)0);
      }

      else
      {
        _x_io_tcp_write(this->stream, this->fd_control, (void *)"PIPE OPEN\r\n", (signed long int)11);
        signed long int return_value_readline_control$8;
        return_value_readline_control$8=readline_control(this, tmpbuf, sizeof(char [256l]) /*256ul*/  - (unsigned long int)1, 4);
        if(return_value_readline_control$8 >= 7l)
        {
          return_value_strncmp$7=strncmp(tmpbuf, "PIPE OK", (unsigned long int)7);
          if(return_value_strncmp$7 == 0)
          {
            signed int return_value_fcntl$6;
            return_value_fcntl$6=fcntl(fd_data, 3);
            fcntl(fd_data, 4, return_value_fcntl$6 | 04000);
            return fd_data;
          }

        }

        do
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "Data stream connection failed (PIPE)");

        while((_Bool)0);
      }
    }
  }
  close(fd_data);
  return -1;
}

// connect_rtp_data_stream
// file xine_input_vdr.c line 5429
static signed int connect_rtp_data_stream(struct vdr_input_plugin_s *this)
{
  char cmd[256l];
  unsigned int ip0;
  unsigned int ip1;
  unsigned int ip2;
  unsigned int ip3;
  unsigned int port;
  signed int fd = -1;
  signed int one = 1;
  signed int retries = 0;
  struct sockaddr_in multicastAddress;
  struct ip_mreq mreq;
  struct sockaddr_in server_address;
  struct sockaddr_in sin;
  unsigned int len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  struct stream_rtp_header_impl tmp_rtp;
  signed int return_value_getpeername$4;
  return_value_getpeername$4=getpeername(this->fd_control, (struct sockaddr *)&server_address, &len);
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  signed int *return_value___errno_location$5;
  char *return_value_strerror$6;
  _Bool tmp_if_expr$11;
  signed int return_value_strncmp$10;
  unsigned short int tmp_statement_expression$13;
  signed int *return_value___errno_location$14;
  char *return_value_strerror$15;
  signed int *return_value___errno_location$17;
  char *return_value_strerror$18;
  signed int *return_value___errno_location$21;
  char *return_value_strerror$22;
  signed int *return_value___errno_location$25;
  char *return_value_strerror$26;
  signed int return_value_io_select_rd$33;
  signed int *return_value___errno_location$29;
  char *return_value_strerror$30;
  signed long int return_value_recvfrom$37;
  signed int *return_value___errno_location$34;
  char *return_value_strerror$35;
  unsigned int tmp_ip;
  signed int return_value__x_io_select$38;
  if(!(return_value_getpeername$4 == 0))
  {
    do
      if(iSysLogLevel >= 1)
      {
        x_syslog(3, log_module_input_vdr, "getpeername(fd_control) failed");
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        if(!(*return_value___errno_location$3 == 0))
        {
          return_value___errno_location$1=__errno_location();
          return_value_strerror$2=strerror(*return_value___errno_location$1);
          x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 5442, return_value_strerror$2);
        }

      }

    while((_Bool)0);
    return -1;
  }

  else
  {
    do
      if(iSysLogLevel >= 3)
        x_syslog(7, log_module_input_vdr, "Requesting RTP transport");

    while((_Bool)0);
    signed long int return_value__x_io_tcp_write$8;
    return_value__x_io_tcp_write$8=_x_io_tcp_write(this->stream, this->fd_control, (void *)"RTP\r\n", (signed long int)5);
    if(!(return_value__x_io_tcp_write$8 >= 0l))
    {
      do
        if(iSysLogLevel >= 1)
        {
          x_syslog(3, log_module_input_vdr, "Control stream write error");
          signed int *return_value___errno_location$7;
          return_value___errno_location$7=__errno_location();
          if(!(*return_value___errno_location$7 == 0))
          {
            return_value___errno_location$5=__errno_location();
            return_value_strerror$6=strerror(*return_value___errno_location$5);
            x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 5451, return_value_strerror$6);
          }

        }

      while((_Bool)0);
      return -1;
    }

    else
    {
      cmd[(signed long int)0] = (char)0;
      signed long int return_value_readline_control$9;
      return_value_readline_control$9=readline_control(this, cmd, sizeof(char [256l]) /*256ul*/  - (unsigned long int)1, 4);
      if(!(return_value_readline_control$9 >= 8l))
        tmp_if_expr$11 = (_Bool)1;

      else
      {
        return_value_strncmp$10=strncmp(cmd, "RTP ", (unsigned long int)4);
        tmp_if_expr$11 = return_value_strncmp$10 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$11)
      {
        do
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "Server does not support RTP ? (%s)", (const void *)cmd);

        while((_Bool)0);
        return -1;
      }

      else
      {
        do
          if(iSysLogLevel >= 3)
            x_syslog(7, log_module_input_vdr, "Got: %s", (const void *)cmd);

        while((_Bool)0);
        signed int return_value_sscanf$12;
        return_value_sscanf$12=sscanf(cmd, "RTP %u.%u.%u.%u:%u", &ip0, &ip1, &ip2, &ip3, &port);
        if(ip0 >= 256u || ip1 >= 256u || ip2 >= 256u || ip3 >= 256u || port >= 65536u || !(return_value_sscanf$12 == 5))
        {
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_input_vdr, "Server does not support RTP ? (%s)", (const void *)cmd);

          while((_Bool)0);
          return -1;
        }

        else
        {
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_input_vdr, "Connecting (data) to rtp://@%u.%u.%u.%u:%u ...", ip0, ip1, ip2, ip3, port);

          while((_Bool)0);
          multicastAddress.sin_family = (unsigned short int)2;
          unsigned short int __v;
          unsigned short int __x = (unsigned short int)port;
          asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
          tmp_statement_expression$13 = __v;
          multicastAddress.sin_port = tmp_statement_expression$13;
          multicastAddress.sin_addr.s_addr=__bswap_32(ip0 << 24 | ip1 << 16 | ip2 << 8 | ip3);
          fd=socket(2, 2, 0);
          if(!(fd >= 0))
          {
            do
              if(iSysLogLevel >= 1)
              {
                x_syslog(3, log_module_input_vdr, "socket() failed");
                signed int *return_value___errno_location$16;
                return_value___errno_location$16=__errno_location();
                if(!(*return_value___errno_location$16 == 0))
                {
                  return_value___errno_location$14=__errno_location();
                  return_value_strerror$15=strerror(*return_value___errno_location$14);
                  x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 5476, return_value_strerror$15);
                }

              }

            while((_Bool)0);
            return -1;
          }

          else
          {
            set_recv_buffer_size(fd, (unsigned int)(1024 * 512));
            signed int return_value_setsockopt$20;
            return_value_setsockopt$20=setsockopt(fd, 1, 2, (const void *)&one, (unsigned int)sizeof(signed int) /*4ul*/ );
            if(!(return_value_setsockopt$20 >= 0))
            {
              do
                if(iSysLogLevel >= 1)
                {
                  x_syslog(3, log_module_input_vdr, "setsockopt(SO_REUSEADDR) failed");
                  signed int *return_value___errno_location$19;
                  return_value___errno_location$19=__errno_location();
                  if(!(*return_value___errno_location$19 == 0))
                  {
                    return_value___errno_location$17=__errno_location();
                    return_value_strerror$18=strerror(*return_value___errno_location$17);
                    x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 5482, return_value_strerror$18);
                  }

                }

              while((_Bool)0);
              close(fd);
              return -1;
            }

            else
            {
              signed int return_value_bind$24;
              return_value_bind$24=bind(fd, (struct sockaddr *)&multicastAddress, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
              if(!(return_value_bind$24 >= 0))
              {
                do
                  if(iSysLogLevel >= 1)
                  {
                    x_syslog(3, log_module_input_vdr, "bind() to multicast address failed");
                    signed int *return_value___errno_location$23;
                    return_value___errno_location$23=__errno_location();
                    if(!(*return_value___errno_location$23 == 0))
                    {
                      return_value___errno_location$21=__errno_location();
                      return_value_strerror$22=strerror(*return_value___errno_location$21);
                      x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 5489, return_value_strerror$22);
                    }

                  }

                while((_Bool)0);
                close(fd);
                return -1;
              }

              else
              {
                memset((void *)&mreq, 0, sizeof(struct ip_mreq) /*8ul*/ );
                mreq.imr_multiaddr.s_addr = multicastAddress.sin_addr.s_addr;
                mreq.imr_interface.s_addr=__bswap_32((unsigned int)0x00000000);
                signed int return_value_setsockopt$28;
                return_value_setsockopt$28=setsockopt(fd, 0, 35, (const void *)&mreq, (unsigned int)sizeof(struct ip_mreq) /*8ul*/ );
                if(!(return_value_setsockopt$28 == 0))
                {
                  do
                    if(iSysLogLevel >= 1)
                    {
                      x_syslog(3, log_module_input_vdr, "setsockopt(IP_ADD_MEMBERSHIP) failed. No multicast in kernel?");
                      signed int *return_value___errno_location$27;
                      return_value___errno_location$27=__errno_location();
                      if(!(*return_value___errno_location$27 == 0))
                      {
                        return_value___errno_location$25=__errno_location();
                        return_value_strerror$26=strerror(*return_value___errno_location$25);
                        x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 5501, return_value_strerror$26);
                      }

                    }

                  while((_Bool)0);
                  close(fd);
                  return -1;
                }

                else
                {
                  do
                  {

                  retry_select:
                    ;
                    return_value_io_select_rd$33=io_select_rd(fd);
                    if(!(return_value_io_select_rd$33 == 0))
                    {
                      do
                        if(iSysLogLevel >= 3)
                          x_syslog(7, log_module_input_vdr, "Requesting RTP transport: RTP poll timeout");

                      while((_Bool)0);
                      retries = retries + 1;
                      if(!(retries >= 10))
                      {
                        do
                          if(iSysLogLevel >= 3)
                            x_syslog(7, log_module_input_vdr, "Requesting RTP transport");

                        while((_Bool)0);
                        signed long int return_value__x_io_tcp_write$32;
                        return_value__x_io_tcp_write$32=_x_io_tcp_write(this->stream, this->fd_control, (void *)"RTP\r\n", (signed long int)5);
                        if(!(return_value__x_io_tcp_write$32 >= 0l))
                        {
                          do
                            if(iSysLogLevel >= 1)
                            {
                              x_syslog(3, log_module_input_vdr, "Control stream write error");
                              signed int *return_value___errno_location$31;
                              return_value___errno_location$31=__errno_location();
                              if(!(*return_value___errno_location$31 == 0))
                              {
                                return_value___errno_location$29=__errno_location();
                                return_value_strerror$30=strerror(*return_value___errno_location$29);
                                x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 5515, return_value_strerror$30);
                              }

                            }

                          while((_Bool)0);
                          close(fd);
                          return -1;
                        }

                        goto retry_select;
                      }

                      do
                        if(iSysLogLevel >= 2)
                          x_syslog(6, log_module_input_vdr, "Data stream connection timed out (RTP)");

                      while((_Bool)0);
                      close(fd);
                      return -1;
                    }

                    do
                    {

                    retry_recvfrom:
                      ;
                      return_value_recvfrom$37=recvfrom(fd, (void *)&tmp_rtp, sizeof(struct stream_rtp_header_impl) /*28ul*/ , 0, &sin, &len);
                      if(!(return_value_recvfrom$37 >= 0l))
                      {
                        do
                          if(iSysLogLevel >= 1)
                          {
                            x_syslog(3, log_module_input_vdr, "RTP recvrom() failed");
                            signed int *return_value___errno_location$36;
                            return_value___errno_location$36=__errno_location();
                            if(!(*return_value___errno_location$36 == 0))
                            {
                              return_value___errno_location$34=__errno_location();
                              return_value_strerror$35=strerror(*return_value___errno_location$34);
                              x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 5531, return_value_strerror$35);
                            }

                          }

                        while((_Bool)0);
                        return -1;
                      }

                      if(sin.sin_addr.s_addr == server_address.sin_addr.s_addr)
                        goto __CPROVER_DUMP_L55;

                      tmp_ip=__bswap_32(sin.sin_addr.s_addr);
                      do
                        if(iSysLogLevel >= 2)
                          x_syslog(6, log_module_input_vdr, "Received UDP/RTP multicast from unknown sender: %d.%d.%d.%d:%d", tmp_ip >> 24 & (unsigned int)0xff, tmp_ip >> 16 & (unsigned int)0xff, tmp_ip >> 8 & (unsigned int)0xff, tmp_ip & (unsigned int)0xff, sin.sin_port);

                      while((_Bool)0);
                      return_value__x_io_select$38=_x_io_select(this->stream, fd, 1, 0);
                    }
                    while(return_value__x_io_select$38 == 0);
                    retries = retries + 1;
                  }
                  while(!(retries >= 4));
                  close(fd);
                  return -1;

                __CPROVER_DUMP_L55:
                  ;
                  this->udp_data=init_udp_data();
                  memcpy((void *)&this->udp_data->server_address, (const void *)&sin, sizeof(struct sockaddr_in) /*16ul*/ );
                  this->udp_data->ssrc = tmp_rtp.rtp_hdr.$anon0.$anon0.ssrc;
                  return fd;
                }
              }
            }
          }
        }
      }
    }
  }
}

// connect_tcp_data_stream
// file xine_input_vdr.c line 5652
static signed int connect_tcp_data_stream(struct vdr_input_plugin_s *this, const char *host, signed int port)
{
  struct sockaddr_in sinc;
  unsigned int len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  unsigned int ipc;
  char tmpbuf[256l];
  signed int fd_data;
  signed int n;
  fd_data=_x_io_tcp_connect(this->stream, host, port);
  _Bool tmp_if_expr$5;
  signed int return_value__x_io_tcp_connect_finish$4;
  if(!(fd_data >= 0))
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value__x_io_tcp_connect_finish$4=_x_io_tcp_connect_finish(this->stream, fd_data, 3000);
    tmp_if_expr$5 = 0 != return_value__x_io_tcp_connect_finish$4 ? (_Bool)1 : (_Bool)0;
  }
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  unsigned short int tmp_statement_expression$6;
  signed int *return_value___errno_location$7;
  char *return_value_strerror$8;
  signed int return_value_io_select_rd$20;
  signed int *return_value___errno_location$10;
  char *return_value_strerror$11;
  signed long int return_value_read$19;
  signed int *return_value___errno_location$13;
  char *return_value_strerror$14;
  _Bool tmp_if_expr$18;
  signed int return_value_strncmp$17;
  if(tmp_if_expr$5)
  {
    do
      if(iSysLogLevel >= 1)
      {
        x_syslog(3, log_module_input_vdr, "Can't connect to tcp://%s:%d", host, port);
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        if(!(*return_value___errno_location$3 == 0))
        {
          return_value___errno_location$1=__errno_location();
          return_value_strerror$2=strerror(*return_value___errno_location$1);
          x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 5667, return_value_strerror$2);
        }

      }

    while((_Bool)0);
    close(fd_data);
    return -1;
  }

  else
  {
    set_recv_buffer_size(fd_data, (unsigned int)(1024 * 128));
    getsockname(this->fd_control, (struct sockaddr *)&sinc, &len);
    ipc=__bswap_32(sinc.sin_addr.s_addr);
    unsigned short int __v;
    unsigned short int __x = (unsigned short int)sinc.sin_port;
    asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
    tmp_statement_expression$6 = __v;
    sprintf(tmpbuf, "DATA %d 0x%x:%u %d.%d.%d.%d\r\n", this->client_id, (unsigned int)ipc, (unsigned int)tmp_statement_expression$6, ipc >> 24 & (unsigned int)0xff, ipc >> 16 & (unsigned int)0xff, ipc >> 8 & (unsigned int)0xff, ipc & (unsigned int)0xff);
    unsigned long int return_value_strlen$21;
    return_value_strlen$21=strlen(tmpbuf);
    signed long int return_value__x_io_tcp_write$22;
    return_value__x_io_tcp_write$22=_x_io_tcp_write(this->stream, fd_data, (void *)tmpbuf, (signed long int)return_value_strlen$21);
    if(!(return_value__x_io_tcp_write$22 >= 0l))
      do
        if(iSysLogLevel >= 1)
        {
          x_syslog(3, log_module_input_vdr, "Data stream write error (TCP)");
          signed int *return_value___errno_location$9;
          return_value___errno_location$9=__errno_location();
          if(!(*return_value___errno_location$9 == 0))
          {
            return_value___errno_location$7=__errno_location();
            return_value_strerror$8=strerror(*return_value___errno_location$7);
            x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 5686, return_value_strerror$8);
          }

        }

      while((_Bool)0);

    else
    {
      return_value_io_select_rd$20=io_select_rd(fd_data);
      if(!(return_value_io_select_rd$20 == 0))
        do
          if(iSysLogLevel >= 1)
          {
            x_syslog(3, log_module_input_vdr, "Data stream poll failed (TCP)");
            signed int *return_value___errno_location$12;
            return_value___errno_location$12=__errno_location();
            if(!(*return_value___errno_location$12 == 0))
            {
              return_value___errno_location$10=__errno_location();
              return_value_strerror$11=strerror(*return_value___errno_location$10);
              x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 5688, return_value_strerror$11);
            }

          }

        while((_Bool)0);

      else
      {
        return_value_read$19=read(fd_data, (void *)tmpbuf, sizeof(const char [6l]) /*6ul*/ );
        n = (signed int)return_value_read$19;
        if(!(n >= 1))
          do
            if(iSysLogLevel >= 1)
            {
              x_syslog(3, log_module_input_vdr, "Data stream read failed (TCP)");
              signed int *return_value___errno_location$15;
              return_value___errno_location$15=__errno_location();
              if(!(*return_value___errno_location$15 == 0))
              {
                return_value___errno_location$13=__errno_location();
                return_value_strerror$14=strerror(*return_value___errno_location$13);
                x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 5690, return_value_strerror$14);
              }

            }

          while((_Bool)0);

        else
        {
          if(!((unsigned long int)n >= sizeof(const char [6l]) /*6ul*/ ))
            tmp_if_expr$18 = (_Bool)1;

          else
          {
            static const char ackmsg[6l] = { (const char)68, (const char)65, (const char)84, (const char)65, (const char)13, (const char)10 };
            return_value_strncmp$17=strncmp(tmpbuf, ackmsg, sizeof(const char [6l]) /*6ul*/ );
            tmp_if_expr$18 = return_value_strncmp$17 != 0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$18)
          {
            tmpbuf[(signed long int)n] = (char)0;
            do
              if(iSysLogLevel >= 2)
                x_syslog(6, log_module_input_vdr, "Server does not support TCP ? (%s)", (const void *)tmpbuf);

            while((_Bool)0);
          }

          else
          {
            signed int return_value_fcntl$16;
            return_value_fcntl$16=fcntl(fd_data, 3);
            fcntl(fd_data, 4, return_value_fcntl$16 | 04000);
            return fd_data;
          }
        }
      }
    }
    close(fd_data);
    return -1;
  }
}

// connect_udp_data_stream
// file xine_input_vdr.c line 5561
static signed int connect_udp_data_stream(struct vdr_input_plugin_s *this)
{
  char cmd[256l];
  struct sockaddr_in server_address;
  struct sockaddr_in sin;
  unsigned int len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  unsigned int tmp_ip;
  struct anonymous$7 tmp_udp;
  signed int retries = 0;
  signed int port = -1;
  signed int fd = -1;
  signed int return_value_getpeername$4;
  return_value_getpeername$4=getpeername(this->fd_control, (struct sockaddr *)&server_address, &len);
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  unsigned long int return_value_strlen$8;
  signed long int return_value__x_io_tcp_write$9;
  signed int *return_value___errno_location$5;
  char *return_value_strerror$6;
  signed long int return_value_readline_control$10;
  _Bool tmp_if_expr$12;
  signed int return_value_strncmp$11;
  signed int return_value_io_select_rd$13;
  signed long int return_value_recvfrom$17;
  signed int *return_value___errno_location$14;
  char *return_value_strerror$15;
  signed int return_value__x_io_select$18;
  if(!(return_value_getpeername$4 == 0))
  {
    do
      if(iSysLogLevel >= 1)
      {
        x_syslog(3, log_module_input_vdr, "getpeername(fd_control) failed");
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        if(!(*return_value___errno_location$3 == 0))
        {
          return_value___errno_location$1=__errno_location();
          return_value_strerror$2=strerror(*return_value___errno_location$1);
          x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 5572, return_value_strerror$2);
        }

      }

    while((_Bool)0);
    return -1;
  }

  else
  {
    tmp_ip=__bswap_32(server_address.sin_addr.s_addr);
    do
      if(iSysLogLevel >= 3)
        x_syslog(7, log_module_input_vdr, "VDR server address: %d.%d.%d.%d", tmp_ip >> 24 & (unsigned int)0xff, tmp_ip >> 16 & (unsigned int)0xff, tmp_ip >> 8 & (unsigned int)0xff, tmp_ip & (unsigned int)0xff);

    while((_Bool)0);
    fd=alloc_udp_data_socket(37890, 20, &port);
    if(!(fd >= 0))
      return -1;

    else
    {

    retry_request:
      ;
      while((_Bool)1)
      {
        if(iSysLogLevel >= 3)
          x_syslog(7, log_module_input_vdr, "Requesting UDP transport");

        sprintf(cmd, "UDP %d\r\n", port);
        return_value_strlen$8=strlen(cmd);
        return_value__x_io_tcp_write$9=_x_io_tcp_write(this->stream, this->fd_control, (void *)cmd, (signed long int)return_value_strlen$8);
        if(!(return_value__x_io_tcp_write$9 >= 0l))
        {
          do
            if(iSysLogLevel >= 1)
            {
              x_syslog(3, log_module_input_vdr, "Control stream write error");
              signed int *return_value___errno_location$7;
              return_value___errno_location$7=__errno_location();
              if(!(*return_value___errno_location$7 == 0))
              {
                return_value___errno_location$5=__errno_location();
                return_value_strerror$6=strerror(*return_value___errno_location$5);
                x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 5594, return_value_strerror$6);
              }

            }

          while((_Bool)0);
          close(fd);
          return -1;
        }

        cmd[(signed long int)0] = (char)0;
        return_value_readline_control$10=readline_control(this, cmd, sizeof(char [256l]) /*256ul*/  - (unsigned long int)1, 4);
        if(!(return_value_readline_control$10 >= 6l))
          tmp_if_expr$12 = (_Bool)1;

        else
        {
          return_value_strncmp$11=strncmp(cmd, "UDP OK", (unsigned long int)6);
          tmp_if_expr$12 = return_value_strncmp$11 != 0 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$12)
        {
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_input_vdr, "Server does not support UDP ? (%s)", (const void *)cmd);

          while((_Bool)0);
          return -1;
        }


      retry_select:
        ;
        return_value_io_select_rd$13=io_select_rd(fd);
        if(return_value_io_select_rd$13 == 0)
          goto retry_recvfrom;

        do
          if(iSysLogLevel >= 3)
            x_syslog(7, log_module_input_vdr, "Requesting UDP transport: UDP poll timeout");

        while((_Bool)0);
        retries = retries + 1;
        if(retries >= 4)
          break;

      }
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "Data stream connection timed out (UDP)");

      while((_Bool)0);
      close(fd);
      return -1;
      do
      {

      retry_recvfrom:
        ;
        return_value_recvfrom$17=recvfrom(fd, (void *)&tmp_udp, sizeof(struct anonymous$7) /*11ul*/ , 0, &sin, &len);
        if(!(return_value_recvfrom$17 >= 0l))
        {
          do
            if(iSysLogLevel >= 1)
            {
              x_syslog(3, log_module_input_vdr, "UDP recvrom() failed");
              signed int *return_value___errno_location$16;
              return_value___errno_location$16=__errno_location();
              if(!(*return_value___errno_location$16 == 0))
              {
                return_value___errno_location$14=__errno_location();
                return_value_strerror$15=strerror(*return_value___errno_location$14);
                x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 5624, return_value_strerror$15);
              }

            }

          while((_Bool)0);
          return -1;
        }

        if(sin.sin_addr.s_addr == server_address.sin_addr.s_addr)
          goto __CPROVER_DUMP_L29;

        tmp_ip=__bswap_32(sin.sin_addr.s_addr);
        do
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "Received UDP packet from unknown sender: %d.%d.%d.%d:%d", tmp_ip >> 24 & (unsigned int)0xff, tmp_ip >> 16 & (unsigned int)0xff, tmp_ip >> 8 & (unsigned int)0xff, tmp_ip & (unsigned int)0xff, sin.sin_port);

        while((_Bool)0);
        return_value__x_io_select$18=_x_io_select(this->stream, fd, 1, 0);
      }
      while(return_value__x_io_select$18 == 0);
      retries = retries + 1;
      if(!(retries >= 4))
        goto retry_select;

      close(fd);
      return -1;

    __CPROVER_DUMP_L29:
      ;
      this->udp_data=init_udp_data();
      memcpy((void *)&this->udp_data->server_address, (const void *)&sin, sizeof(struct sockaddr_in) /*16ul*/ );
      return fd;
    }
  }
}

// create_timeout_time
// file xine_input_vdr.c line 868
static void create_timeout_time(struct timespec *abstime, signed int timeout_ms)
{
  struct timeval now;
  gettimeofday(&now, (struct timezone *)(void *)0);
  now.tv_usec = now.tv_usec + (signed long int)(timeout_ms * 1000);
  for( ; now.tv_usec >= 1000000l; now.tv_usec = now.tv_usec - (signed long int)1000000)
    now.tv_sec = now.tv_sec + 1l;
  abstime->tv_sec = now.tv_sec;
  abstime->tv_nsec = now.tv_usec * (signed long int)1000;
}

// data_stream_parse_control
// file xine_input_vdr.c line 4003
static void data_stream_parse_control(struct vdr_input_plugin_s *this, char *cmd)
{
  char *tmp;
  cmd[(signed long int)64] = (char)0;
  char *return_value___builtin_strchr$1;
  return_value___builtin_strchr$1=__builtin_strchr(cmd, 13);
  tmp = return_value___builtin_strchr$1;
  if(!(tmp == ((char *)NULL)))
    *tmp = (char)0;

  char *return_value___builtin_strchr$2;
  return_value___builtin_strchr$2=__builtin_strchr(cmd, 10);
  tmp = return_value___builtin_strchr$2;
  if(!(tmp == ((char *)NULL)))
    *tmp = (char)0;

  do
    if(iSysLogLevel >= 4)
      x_syslog(7, log_module_input_vdr, "<control> <data> %s", cmd);

  while((_Bool)0);
  signed int return_value_strncasecmp$5;
  return_value_strncasecmp$5=strncasecmp(cmd, "DISCARD ", (unsigned long int)8);
  signed int return_value_strncasecmp$4;
  if(return_value_strncasecmp$5 == 0)
  {
    unsigned long int index;
    signed int return_value_sscanf$3;
    return_value_sscanf$3=sscanf(cmd + (signed long int)8, "%lu", &index);
    if(return_value_sscanf$3 == 1)
    {
      this->discard_index_ds = index;
      this->block_buffer->clear(this->block_buffer);
      wait_stream_sync(this);
    }

    goto __CPROVER_DUMP_L8;
  }

  else
  {
    return_value_strncasecmp$4=strncasecmp(cmd, "BLANK", (unsigned long int)5);
    if(return_value_strncasecmp$4 == 0)
    {
      put_control_buf(this->block_buffer, this->buffer_pool, 0x0f000000 | 0x00010000);
      goto __CPROVER_DUMP_L8;
    }

  }
  do
    if(iSysLogLevel >= 2)
      x_syslog(6, log_module_input_vdr, "Unexpected data_stream_parse_control(%s)", cmd);

  while((_Bool)0);
  vdr_plugin_parse_control(&this->$anon0.iface, cmd);

__CPROVER_DUMP_L8:
  ;
}

// demux_xvdr_dispose
// file xine/demux_xvdr.c line 1089
static void demux_xvdr_dispose(struct demux_plugin_s$0 *this_gen)
{
  struct demux_xvdr_s *this = (struct demux_xvdr_s *)this_gen;
  do
    if(iSysLogLevel >= 3)
      x_syslog(7, log_module_demux_xvdr, "demux_xvdr_dispose()");

  while((_Bool)0);
  ts_data_dispose(&this->ts_data);
  free((void *)this);
}

// demux_xvdr_fwd_buf
// file xine/demux_xvdr.c line 403
static void demux_xvdr_fwd_buf(struct demux_xvdr_s *this, struct buf_element_s *buf)
{
  if((0xFF000000 & buf->type) == 33554432u)
  {
    this->video_type = buf->type;
    check_newpts(this, buf, 1);
    this->video_fifo->put(this->video_fifo, buf);
  }

  else
    if((0xFF000000 & buf->type) == 50331648u)
    {
      if(!(this->audio_fifo == ((struct fifo_buffer_s *)NULL)))
      {
        check_newpts(this, buf, 0);
        track_audio_stream_change(this, buf);
        this->audio_fifo->put(this->audio_fifo, buf);
      }

      else
        buf->free_buffer(buf);
    }

    else
      if(buf->type == 17432576u)
      {
        post_sequence_end(this->video_fifo, this->video_type);
        this->video_fifo->put(this->video_fifo, buf);
      }

      else
        if((0xFF000000 & buf->type) == 16777216u)
        {
          if(!(this->audio_fifo == ((struct fifo_buffer_s *)NULL)))
          {
            struct buf_element_s *cbuf;
            cbuf=this->audio_fifo->buffer_pool_alloc(this->audio_fifo);
            cbuf->type = buf->type;
            cbuf->decoder_flags = buf->decoder_flags;
            memcpy$link1((void *)cbuf->decoder_info, (const void *)buf->decoder_info, sizeof(unsigned int [5l]) /*20ul*/ );
            memcpy$link1((void *)cbuf->decoder_info_ptr, (const void *)buf->decoder_info_ptr, sizeof(void *[5l]) /*40ul*/ );
            this->audio_fifo->put(this->audio_fifo, cbuf);
          }

          this->video_fifo->put(this->video_fifo, buf);
        }

        else
        {
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_demux_xvdr, "Unhandled buffer type %08x", buf->type);

          while((_Bool)0);
          buf->free_buffer(buf);
        }
}

// demux_xvdr_get_capabilities
// file xine/demux_xvdr.c line 1174
static unsigned int demux_xvdr_get_capabilities(struct demux_plugin_s$0 *this_gen)
{
  return (unsigned int)0x00000000;
}

// demux_xvdr_get_optional_data
// file xine/demux_xvdr.c line 1179
static signed int demux_xvdr_get_optional_data(struct demux_plugin_s$0 *this_gen, void *data, signed int data_type)
{
  return 0;
}

// demux_xvdr_get_status
// file xine/demux_xvdr.c line 1100
static signed int demux_xvdr_get_status(struct demux_plugin_s$0 *this_gen)
{
  struct demux_xvdr_s *this = (struct demux_xvdr_s *)this_gen;
  if(!(this->status == 0))
  {
    if(!(this->ts_data == ((struct ts_data_s *)NULL)))
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_demux_xvdr, "demux_xvdr_get_status(): status != DEMUX_OK. -> freeing ts_data");

      while((_Bool)0);
      ts_data_dispose(&this->ts_data);
    }

  }

  return this->status;
}

// demux_xvdr_get_stream_length
// file xine/demux_xvdr.c line 1169
static signed int demux_xvdr_get_stream_length(struct demux_plugin_s$0 *this_gen)
{
  return 0;
}

// demux_xvdr_init_class
// file xine/demux_xvdr.c line 1251
void * demux_xvdr_init_class(struct xine_s$1 *xine, void *data)
{
  struct anonymous$59 *this;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct anonymous$59) /*72ul*/ );
  this = (struct anonymous$59 *)return_value_calloc$1;
  this->config = xine->config;
  this->xine = xine;
  this->demux_class.open_plugin = demux_xvdr_open_plugin;
  this->demux_class.description = "XVDR demux plugin";
  this->demux_class.identifier = "xvdr";
  this->demux_class.mimetypes = (const char *)(void *)0;
  this->demux_class.extensions = "xvdr:/ xvdr+pipe:/ xvdr+tcp:/ xvdr+udp:/ xvdr+rtp:/ xvdr+slave:/";
  this->demux_class.dispose = (void (*)(struct demux_class_s *))free;
  return (void *)this;
}

// demux_xvdr_open_plugin
// file xine/demux_xvdr.c line 1185
static struct demux_plugin_s$0 * demux_xvdr_open_plugin(struct demux_class_s *class_gen, struct xine_stream_s$1 *stream, struct input_plugin_s$1 *input_gen)
{
  struct input_plugin_s$1 *input = (struct input_plugin_s$1 *)input_gen;
  struct demux_xvdr_s *this;
  const char *mrl;
  mrl=input->get_mrl(input);
  signed int return_value_strncmp$5;
  return_value_strncmp$5=strncmp(mrl, "xvdr:/", (unsigned long int)(4 + 2));
  signed int return_value_strncmp$4;
  signed int return_value_strncmp$3;
  signed int return_value_strncmp$2;
  signed int return_value_strncmp$1;
  if(!(return_value_strncmp$5 == 0))
  {
    return_value_strncmp$4=strncmp(mrl, "xvdr+pipe://", (unsigned long int)(4 + 8));
    return_value_strncmp$3=strncmp(mrl, "xvdr+tcp://", (unsigned long int)(4 + 7));
    return_value_strncmp$2=strncmp(mrl, "xvdr+udp://", (unsigned long int)(4 + 7));
    return_value_strncmp$1=strncmp(mrl, "xvdr+rtp://", (unsigned long int)(4 + 7));
    return (struct demux_plugin_s$0 *)(void *)0;
  }

  else
  {
    void *return_value_calloc$6;
    return_value_calloc$6=calloc((unsigned long int)1, sizeof(struct demux_xvdr_s) /*184ul*/ );
    this = (struct demux_xvdr_s *)return_value_calloc$6;
    this->stream = stream;
    this->input = input;
    this->demux_plugin.send_headers = demux_xvdr_send_headers;
    this->demux_plugin.send_chunk = demux_xvdr_send_chunk;
    this->demux_plugin.seek = demux_xvdr_seek;
    this->demux_plugin.dispose = demux_xvdr_dispose;
    this->demux_plugin.get_status = demux_xvdr_get_status;
    this->demux_plugin.get_stream_length = demux_xvdr_get_stream_length;
    this->demux_plugin.get_capabilities = demux_xvdr_get_capabilities;
    this->demux_plugin.get_optional_data = demux_xvdr_get_optional_data;
    this->demux_plugin.demux_class = class_gen;
    this->status = 1;
    detect_video_decoders(this);
    detect_audio_decoders(this);
    return &this->demux_plugin;
  }
}

// demux_xvdr_parse_pack
// file xine/demux_xvdr.c line 453
static void demux_xvdr_parse_pack(struct demux_xvdr_s *this)
{
  struct buf_element_s *buf = (struct buf_element_s *)(void *)0;
  unsigned char *p;
  buf=this->input->read_block(this->input, this->video_fifo, (signed long int)8128);
  signed int *return_value___errno_location$1;
  if(buf == ((struct buf_element_s *)NULL))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    if(*return_value___errno_location$2 == 4)
    {
      if(iSysLogLevel >= 4)
        x_syslog(7, log_module_demux_xvdr, "input->read_block() was interrupted");

      ts_data_flush(this->ts_data);
    }

    else
    {
      return_value___errno_location$1=__errno_location();
      if(!(*return_value___errno_location$1 == 11))
      {
        if(iSysLogLevel >= 3)
          x_syslog(7, log_module_demux_xvdr, "DEMUX_FINISHED (input returns NULL with error)");

        this->status = 1;
        ts_data_dispose(&this->ts_data);
      }

    }
  }

  if(!(buf->type == 83886080u))
  {
    ts_data_flush(this->ts_data);
    demux_xvdr_fwd_buf(this, buf);
  }

  else
  {
    p = buf->content;
    buf->decoder_flags = (unsigned int)0;
    if((signed int)*p == 0x47)
      demux_xvdr_parse_ts(this, buf);

    else
      if(*p == 0)
        demux_xvdr_parse_pes(this, buf);

      else
      {
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_demux_xvdr, "Header %02x %02x %02x (should be 0x000001 or 0x47)", p[(signed long int)0], p[(signed long int)1], p[(signed long int)2]);

        buf->free_buffer(buf);
      }
  }
}

// demux_xvdr_parse_pes
// file xine/demux_xvdr.c line 497
static void demux_xvdr_parse_pes(struct demux_xvdr_s *this, struct buf_element_s *buf)
{
  unsigned char *p = buf->content;
  signed int result;
  if((signed int)p[3l] == 0xBE)
    buf->free_buffer(buf);

  else
  {
    this->stream_id = p[(signed long int)3];
    if(!(this->ts_data == ((struct ts_data_s *)NULL)))
    {
      ts_data_flush(this->ts_data);
      ts_data_dispose(&this->ts_data);
    }

    if((-16 & (signed int)p[3l]) == 0xE0)
      result=parse_video_stream(this, p, buf);

    else
      if((-32 & (signed int)p[3l]) == 0xC0)
        result=parse_audio_stream(this, p, buf);

      else
        if((signed int)p[3l] == 0xBD)
          result=parse_private_stream_1(this, p, buf);

        else
        {
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_demux_xvdr, "Unrecognised PES stream 0x%02x", this->stream_id);

          while((_Bool)0);
          buf->free_buffer(buf);
        }
    if(result >= 0)
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_demux_xvdr, "error! freeing buffer.");

      while((_Bool)0);
      buf->free_buffer(buf);
    }

  }
}

// demux_xvdr_parse_ts
// file xine/demux_xvdr.c line 539
static void demux_xvdr_parse_ts(struct demux_xvdr_s *this, struct buf_element_s *buf)
{
  void *return_value_calloc$1;
  if(this->ts_data == ((struct ts_data_s *)NULL))
  {
    return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct ts_data_s) /*1272ul*/ );
    this->ts_data = (struct ts_data_s *)return_value_calloc$1;
  }

  struct ts_data_s *ts_data = this->ts_data;
  struct fifo_buffer_s *src_fifo = (struct fifo_buffer_s *)buf->source;
  _Bool tmp_if_expr$2;
  while(buf->size >= 188)
  {
    unsigned int ts_pid = (unsigned int)((((signed int)buf->content[(signed long int)1] & 0x1F) << 8) + (signed int)buf->content[(signed long int)2]);
    if(ts_pid == 0u)
    {
      struct anonymous$8 pat;
      signed int return_value_ts_parse_pat$3;
      return_value_ts_parse_pat$3=ts_parse_pat(&pat, buf->content);
      if(!(return_value_ts_parse_pat$3 == 0))
      {
        if(!(ts_data->pmt_pid == pat.pmt_pid[0l]))
          tmp_if_expr$2 = (_Bool)1;

        else
          tmp_if_expr$2 = ts_data->program_number != pat.program_number[(signed long int)0] ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$2)
        {
          do
            if(iSysLogLevel >= 4)
              x_syslog(7, log_module_demux_xvdr, "PAT: program changed, flushing demuxer");

          while((_Bool)0);
          ts_data_flush(ts_data);
          ts_data->pmt_pid = pat.pmt_pid[(signed long int)0];
          ts_data->program_number = pat.program_number[(signed long int)0];
        }

        else
          do
            if(iSysLogLevel >= 4)
              x_syslog(7, log_module_demux_xvdr, "Got PAT, PMT pid = %d, program = %d", ts_data->pmt_pid, ts_data->program_number);

          while((_Bool)0);
      }

    }

    else
      if(ts_pid == (unsigned int)ts_data->pmt_pid)
      {
        signed int return_value_ts_parse_pmt$4;
        return_value_ts_parse_pmt$4=ts_parse_pmt(&ts_data->pmt, (unsigned int)ts_data->program_number, buf->content);
        if(!(return_value_ts_parse_pmt$4 == 0))
        {
          do
            if(iSysLogLevel >= 3)
              x_syslog(7, log_module_demux_xvdr, "PMT changed, resetting demuxer");

          while((_Bool)0);
          ts_data_ts2es_init(&ts_data, this->stream->video_fifo, this->stream->audio_fifo);
          this->video_type = (unsigned int)((signed int)ts_data->pmt.video_type == ISO_14496_PART10_VIDEO ? 0x024D0000 : 0x02000000);
          struct anonymous$54 event;
          event.type = 2;
          event.data_length = 0;
          xine_event_send(this->stream, &event);
        }

      }

      else
        if(ts_pid == (unsigned int)ts_data->pmt.video_pid)
        {
          if(!(ts_data->video == ((struct ts2es_s *)NULL)))
          {
            struct buf_element_s *vbuf;
            vbuf=ts2es_put(ts_data->video, buf->content, src_fifo);
            if(!(vbuf == ((struct buf_element_s *)NULL)))
            {
              check_newpts(this, vbuf, 1);
              this->stream->video_fifo->put(this->stream->video_fifo, vbuf);
            }

          }

        }

        else
        {
          signed int i = 0;
          for( ; !(i >= (signed int)ts_data->pmt.audio_tracks_count); i = i + 1)
            if(ts_pid == (unsigned int)ts_data->pmt.audio_tracks[(signed long int)i].pid)
            {
              if(!(ts_data->audio[(signed long int)i] == ((struct ts2es_s *)NULL)))
              {
                struct buf_element_s *abuf;
                abuf=ts2es_put(ts_data->audio[(signed long int)i], buf->content, src_fifo);
                if(!(abuf == ((struct buf_element_s *)NULL)))
                {
                  check_newpts(this, abuf, 0);
                  track_audio_stream_change(this, abuf);
                  this->stream->audio_fifo->put(this->stream->audio_fifo, abuf);
                }

              }

              break;
            }

        }
    buf->content = buf->content + (signed long int)188;
    buf->size = buf->size - 188;
  }
  buf->free_buffer(buf);
}

// demux_xvdr_seek
// file xine/demux_xvdr.c line 1135
static signed int demux_xvdr_seek(struct demux_plugin_s$0 *this_gen, signed long int start_pos, signed int start_time, signed int playing)
{
  struct demux_xvdr_s *this = (struct demux_xvdr_s *)this_gen;
  this->send_newpts = (unsigned char)1;
  this->video_type = (unsigned int)0;
  this->audio_type = (unsigned int)0;
  this->subtitle_type = (unsigned int)0;
  this->bih_posted = (unsigned char)0;
  ts_data_dispose(&this->ts_data);
  if(playing == 0)
  {
    this->buf_flag_seek = (unsigned char)0;
    this->status = 0;
    this->last_pts[(signed long int)0] = (signed long int)0;
    this->last_pts[(signed long int)1] = (signed long int)0;
  }

  else
  {
    this->buf_flag_seek = (unsigned char)1;
    this->last_vpts = -1L;
    _x_demux_flush_engine(this->stream);
  }
  return this->status;
}

// demux_xvdr_send_chunk
// file xine/demux_xvdr.c line 1080
static signed int demux_xvdr_send_chunk(struct demux_plugin_s$0 *this_gen)
{
  struct demux_xvdr_s *this = (struct demux_xvdr_s *)this_gen;
  demux_xvdr_parse_pack(this);
  return this->status;
}

// demux_xvdr_send_headers
// file xine/demux_xvdr.c line 1114
static void demux_xvdr_send_headers(struct demux_plugin_s$0 *this_gen)
{
  struct demux_xvdr_s *this = (struct demux_xvdr_s *)this_gen;
  this->video_fifo = this->stream->video_fifo;
  this->audio_fifo = this->stream->audio_fifo;
  _x_demux_control_start(this->stream);
  this->status = 0;
  _x_stream_info_set(this->stream, 18, 1);
  _x_stream_info_set(this->stream, 19, 1);
  _x_stream_info_set(this->stream, 0, 5000000);
}

// descriptor_to_stream_type
// file tools/ts.c line 235
static enum anonymous$11 descriptor_to_stream_type(const unsigned char descriptor_tag)
{
  switch((signed int)descriptor_tag)
  {
    case 0x59:
      return (enum anonymous$11)STREAM_DVBSUB;
    case 0x6a:
      return (enum anonymous$11)STREAM_AUDIO_AC3;
    case 0x7a:
      return (enum anonymous$11)STREAM_AUDIO_EAC3;
    case 0x7b:
      return (enum anonymous$11)STREAM_AUDIO_DTS;
    case 0x7c:
      return (enum anonymous$11)STREAM_AUDIO_AAC;
    default:
      return (enum anonymous$11)0;
  }
}

// detect_audio_decoders
// file xine/demux_xvdr.c line 160
static void detect_audio_decoders(struct demux_xvdr_s *this)
{
  const char *return_value_get_decoder_name$1;
  do
    if(iSysLogLevel >= 3)
    {
      return_value_get_decoder_name$1=get_decoder_name(this->stream->xine, 0x03010000);
      x_syslog(7, log_module_demux_xvdr, "Using %-10s decoder \"%s\"", (const void *)"MPEG audio", return_value_get_decoder_name$1);
    }

  while((_Bool)0);
  const char *return_value_get_decoder_name$2;
  do
    if(iSysLogLevel >= 3)
    {
      return_value_get_decoder_name$2=get_decoder_name(this->stream->xine, 0x03000000);
      x_syslog(7, log_module_demux_xvdr, "Using %-10s decoder \"%s\"", (const void *)"AC-3", return_value_get_decoder_name$2);
    }

  while((_Bool)0);
  const char *return_value_get_decoder_name$3;
  do
    if(iSysLogLevel >= 3)
    {
      return_value_get_decoder_name$3=get_decoder_name(this->stream->xine, 0x030e0000);
      x_syslog(7, log_module_demux_xvdr, "Using %-10s decoder \"%s\"", (const void *)"AAC", return_value_get_decoder_name$3);
    }

  while((_Bool)0);
  const char *return_value_get_decoder_name$4;
  do
    if(iSysLogLevel >= 3)
    {
      return_value_get_decoder_name$4=get_decoder_name(this->stream->xine, 0x03050000);
      x_syslog(7, log_module_demux_xvdr, "Using %-10s decoder \"%s\"", (const void *)"DTS", return_value_get_decoder_name$4);
    }

  while((_Bool)0);
  const char *return_value_get_decoder_name$5;
  do
    if(iSysLogLevel >= 3)
    {
      return_value_get_decoder_name$5=get_decoder_name(this->stream->xine, 0x03020000);
      x_syslog(7, log_module_demux_xvdr, "Using %-10s decoder \"%s\"", (const void *)"LPCM", return_value_get_decoder_name$5);
    }

  while((_Bool)0);
  const char *return_value_get_decoder_name$6;
  do
    if(iSysLogLevel >= 3)
    {
      return_value_get_decoder_name$6=get_decoder_name(this->stream->xine, 0x03420000);
      x_syslog(7, log_module_demux_xvdr, "Using %-10s decoder \"%s\"", (const void *)"AAC LATM", return_value_get_decoder_name$6);
    }

  while((_Bool)0);
}

// detect_dvb_spu
// file xine/demux_xvdr.c line 807
signed int detect_dvb_spu(struct demux_xvdr_s *this, unsigned char *p, struct buf_element_s *buf)
{
  if(this->pts >= 1l)
    this->subtitle_type = (unsigned int)0;

  if(!(this->subtitle_type == 67108864u))
  {
    if(!((0x01 & (signed int)buf->content[7l]) == 0))
    {
      if((0x81 & (signed int)p[-3l]) == 0x01)
      {
        if((signed int)p[-2l] == 0x81)
        {
          do
            if(iSysLogLevel >= 3)
              x_syslog(7, log_module_demux_xvdr, "DVB SPU: Old vdr-subtitles compability mode");

          while((_Bool)0);
          signed int return_value_parse_dvb_spu$1;
          return_value_parse_dvb_spu$1=parse_dvb_spu(this, p, buf, 1);
          return return_value_parse_dvb_spu$1;
        }

      }

    }

  }

  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$2;
  if(this->pts >= 1l)
  {
    if((signed int)p[4l] == 0x20)
      tmp_if_expr$3 = (signed int)p[(signed long int)5] == 0x00 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$3 = (_Bool)0;
    if(tmp_if_expr$3)
    {
      if((signed int)p[6l] == 0x0f)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)p[(signed long int)4] == 0x0f ? (_Bool)1 : (_Bool)0;
      tmp_if_expr$5 = tmp_if_expr$4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$5 = (_Bool)0;
    if(tmp_if_expr$5)
      this->subtitle_type = (unsigned int)0x04030000;

    else
    {
      if(!(p[2l] == 0))
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = ((signed int)p[(signed long int)3] & 0xfe) != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        this->subtitle_type = (unsigned int)0x04000000;

      else
      {
        this->subtitle_type = (unsigned int)0x04000000;
        do
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_demux_xvdr, " -> DV? SPU -> DVD");

        while((_Bool)0);
      }
    }
  }

  if(this->subtitle_type == 67108864u)
    return (signed int)this->packet_len;

  else
  {
    signed int return_value_parse_dvb_spu$6;
    return_value_parse_dvb_spu$6=parse_dvb_spu(this, p, buf, 4);
    return return_value_parse_dvb_spu$6;
  }
}

// detect_h264
// file xine/demux_xvdr.c line 954
static signed int detect_h264(unsigned char *data)
{
  if((signed int)*data == 0)
  {
    if((signed int)data[1l] == 0)
    {
      if((signed int)data[2l] == 1)
      {
        if((signed int)data[3l] == 0x09)
        {
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_demux_xvdr, "H.264 scanner: Possible H.264 NAL AUD");

          while((_Bool)0);
          return 0x024D0000;
        }

        if((signed int)data[3l] == 0)
        {
          do
            if(iSysLogLevel >= 3)
              x_syslog(7, log_module_demux_xvdr, "H.264 scanner: Possible MPEG2 start code PICTURE (0x00)");

          while((_Bool)0);
          return 0x02000000;
        }

        if((signed int)data[3l] >= 0x80)
        {
          do
            if(iSysLogLevel >= 3)
              x_syslog(7, log_module_demux_xvdr, "H.264 scanner: Possible MPEG2 start code (0x%02x)", data[(signed long int)3]);

          while((_Bool)0);
          return 0x02000000;
        }

        do
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_demux_xvdr, "H.264 scanner: Unregonized header 00 00 01 %02x", data[(signed long int)3]);

        while((_Bool)0);
      }

    }

  }

  return 0;
}

// detect_video_decoders
// file xine/demux_xvdr.c line 141
static void detect_video_decoders(struct demux_xvdr_s *this)
{
  const char *name;
  name=get_decoder_name(this->stream->xine, 0x02000000);
  signed int tmp_statement_expression$1;
  unsigned long int detect_video_decoders$$1$$1$$__s1_len;
  unsigned long int detect_video_decoders$$1$$1$$__s2_len;
  signed int return_value___builtin_strcmp$2;
  return_value___builtin_strcmp$2=__builtin_strcmp(name, "ffmpegvideo");
  tmp_statement_expression$1 = return_value___builtin_strcmp$2;
  if(tmp_statement_expression$1 == 0)
    this->ffmpeg_mpeg2_decoder = (unsigned char)1;

  do
    if(iSysLogLevel >= 3)
      x_syslog(7, log_module_demux_xvdr, "Using MPEG video decoder \"%s\"%s", name, this->ffmpeg_mpeg2_decoder != 0 ? " (FFmpeg)" : "");

  while((_Bool)0);
  name=get_decoder_name(this->stream->xine, 0x024D0000);
  signed int tmp_statement_expression$3;
  unsigned long int __s1_len;
  unsigned long int __s2_len;
  signed int return_value___builtin_strcmp$4;
  return_value___builtin_strcmp$4=__builtin_strcmp(name, "dshowserver");
  tmp_statement_expression$3 = return_value___builtin_strcmp$4;
  if(tmp_statement_expression$3 == 0)
    this->coreavc_h264_decoder = (unsigned char)1;

  do
    if(iSysLogLevel >= 3)
      x_syslog(7, log_module_demux_xvdr, "Using H.264      decoder \"%s\"%s", name, this->coreavc_h264_decoder != 0 ? " (dshowserver (CoreAVC))" : "");

  while((_Bool)0);
  const char *return_value_get_decoder_name$5;
  do
    if(iSysLogLevel >= 3)
    {
      return_value_get_decoder_name$5=get_decoder_name(this->stream->xine, 0x02650000);
      x_syslog(7, log_module_demux_xvdr, "Using %-10s decoder \"%s\"", (const void *)"VC-1", return_value_get_decoder_name$5);
    }

  while((_Bool)0);
}

// dvd_menu_domain
// file xine_input_vdr.c line 2341
static void dvd_menu_domain(struct vdr_input_plugin_s *this, signed int value)
{
  if(!(value == 0))
  {
    do
      if(iSysLogLevel >= 3)
        x_syslog(7, log_module_input_vdr, "dvd_menu_domain(1)");

    while((_Bool)0);
    this->dvd_menu = (unsigned char)1;
    this->slave.stream->spu_channel_user = -1;
    this->slave.stream->spu_channel = this->slave.stream->spu_channel_auto;
  }

  else
  {
    do
      if(iSysLogLevel >= 3)
        x_syslog(7, log_module_input_vdr, "dvd_menu_domain(0)");

    while((_Bool)0);
    this->dvd_menu = (unsigned char)0;
  }
}

// dvd_set_speed
// file xine_input_vdr.c line 2233
static void dvd_set_speed(const char *device, signed int speed)
{
  unsigned char buffer[28l];
  unsigned char cmd[16l];
  unsigned char sense[16l];
  struct sg_io_hdr sghdr;
  struct stat st;
  signed int fd;
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  static signed int dvd_speed = 0;
  if(!(dvd_speed == 0) || speed >= 0)
  {
    static const char *dvd_dev = (const char *)(void *)0;
    if(device == ((const char *)NULL))
      device = dvd_dev;

    if(!(device == ((const char *)NULL)))
    {
      if(!(speed == 0))
      {
        signed int return_value_stat$1;
        return_value_stat$1=stat(device, &st);
        if(!(return_value_stat$1 == -1))
        {
          if((61440u & st.st_mode) == 24576u)
          {
            fd=open(device, 02 | 04000);
            if(fd == -1)
              do
                if(iSysLogLevel >= 2)
                  x_syslog(6, log_module_input_vdr, "set_dvd_speed: error opening DVD device %s for read/write", device);

              while((_Bool)0);

            else
            {
              memset((void *)&sghdr, 0, sizeof(struct sg_io_hdr) /*88ul*/ );
              memset((void *)buffer, 0, sizeof(unsigned char [28l]) /*28ul*/ );
              memset((void *)sense, 0, sizeof(unsigned char [16l]) /*16ul*/ );
              memset((void *)cmd, 0, sizeof(unsigned char [16l]) /*16ul*/ );
              if(!(speed >= 0))
              {
                speed = 0;
                buffer[(signed long int)0] = (unsigned char)4;
                do
                  if(iSysLogLevel >= 2)
                    x_syslog(6, log_module_input_vdr, "Setting DVD streaming speed to <default>");

                while((_Bool)0);
              }

              else
                do
                  if(iSysLogLevel >= 2)
                    x_syslog(6, log_module_input_vdr, "Setting DVD streaming speed to %d", speed);

                while((_Bool)0);
              sghdr.interface_id = 83;
              sghdr.timeout = (unsigned int)5000;
              sghdr.dxfer_direction = -2;
              sghdr.mx_sb_len = (unsigned char)sizeof(unsigned char [16l]) /*16ul*/ ;
              sghdr.dxfer_len = (unsigned int)sizeof(unsigned char [28l]) /*28ul*/ ;
              sghdr.cmd_len = (unsigned char)sizeof(unsigned char [16l]) /*16ul*/ ;
              sghdr.sbp = sense;
              sghdr.dxferp = (void *)buffer;
              sghdr.cmdp = cmd;
              cmd[(signed long int)0] = (unsigned char)0xb6;
              cmd[(signed long int)10] = (unsigned char)28;
              buffer[(signed long int)8] = (unsigned char)0xff;
              buffer[(signed long int)9] = (unsigned char)0xff;
              buffer[(signed long int)10] = (unsigned char)0xff;
              buffer[(signed long int)11] = (unsigned char)0xff;
              buffer[(signed long int)20] = (unsigned char)(speed >> 24 & 0xff);
              buffer[(signed long int)12] = buffer[(signed long int)20];
              buffer[(signed long int)21] = (unsigned char)(speed >> 16 & 0xff);
              buffer[(signed long int)13] = buffer[(signed long int)21];
              buffer[(signed long int)22] = (unsigned char)(speed >> 8 & 0xff);
              buffer[(signed long int)14] = buffer[(signed long int)22];
              buffer[(signed long int)23] = (unsigned char)(speed & 0xff);
              buffer[(signed long int)15] = buffer[(signed long int)23];
              buffer[(signed long int)26] = (unsigned char)0x03;
              buffer[(signed long int)18] = buffer[(signed long int)26];
              buffer[(signed long int)27] = (unsigned char)0xe8;
              buffer[(signed long int)19] = buffer[(signed long int)27];
              signed int return_value_ioctl$5;
              return_value_ioctl$5=ioctl(fd, (unsigned long int)0x2285, &sghdr);
              if(!(return_value_ioctl$5 >= 0))
                do
                  if(iSysLogLevel >= 1)
                  {
                    x_syslog(3, log_module_input_vdr, "Failed setting DVD streaming speed to %d", speed);
                    signed int *return_value___errno_location$4;
                    return_value___errno_location$4=__errno_location();
                    if(!(*return_value___errno_location$4 == 0))
                    {
                      return_value___errno_location$2=__errno_location();
                      return_value_strerror$3=strerror(*return_value___errno_location$2);
                      x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 2307, return_value_strerror$3);
                    }

                  }

                while((_Bool)0);

              else
                if(speed >= 1)
                  do
                    if(iSysLogLevel >= 2)
                      x_syslog(6, log_module_input_vdr, "DVD streaming speed set to %d", speed);

                  while((_Bool)0);

                else
                  do
                    if(iSysLogLevel >= 2)
                      x_syslog(6, log_module_input_vdr, "DVD streaming speed set to <default>");

                  while((_Bool)0);
              dvd_speed = speed;
              dvd_dev = device;
              close(fd);
            }
          }

        }

      }

    }

  }

}

// elapsed
// file xine/../tools/time_ms.h line 28
static unsigned long int elapsed(unsigned long int t)
{
  unsigned long int return_value_time_ms$1;
  return_value_time_ms$1=time_ms();
  return return_value_time_ms$1 - t;
}

// elapsed$link1
// file xine/../tools/time_ms.h line 28
static unsigned long int elapsed$link1(unsigned long int t$link1)
{
  unsigned long int return_value_time_ms$1$link1;
  return_value_time_ms$1$link1=time_ms$link1();
  return return_value_time_ms$1$link1 - t$link1;
}

// exec_osd_close
// file xine/osd_manager.c line 371
static signed int exec_osd_close(struct osd_manager_impl_s *this, struct osd_command_s *cmd)
{
  struct video_overlay_manager_s$1 *ovl_manager;
  ovl_manager=get_ovl_manager(this);
  struct anonymous$4 *osd = &this->osd[(signed long int)cmd->wnd];
  signed int handle = osd->handle;
  if(!((0x02 & (signed int)cmd->flags) == 0))
  {
    do
      if(iSysLogLevel >= 3)
        x_syslog(7, log_module_input_osd, "Ignoring OSD_Close(OSDFLAG_REFRESH)");

    while((_Bool)0);
    return 0;
  }

  else
    if(!(handle >= 0))
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_osd, "OSD_Close(%d): non-existing OSD !", cmd->wnd);

      while((_Bool)0);
      return -2;
    }

    else
      if(ovl_manager == ((struct video_overlay_manager_s$1 *)NULL))
        return -2;

      else
      {
        struct video_overlay_event_s ov_event = { .vpts=(signed long int)0, .event_type=0u, .object={ .handle=0, .object_type=0u, .pts=0l, .overlay=((struct vo_overlay_s *)NULL), .palette=((unsigned int *)NULL),
    .palette_type=0u } };
        ov_event.event_type = (unsigned int)8;
        ov_event.vpts=osd_exec_vpts(this, cmd);
        ov_event.object.handle = handle;
        signed int return_value;
        return_value=ovl_manager->add_event(ovl_manager, (void *)&ov_event);
        if(!(return_value >= 0))
        {
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_osd, "OSD_Close(%d): overlay manager queue full !", cmd->wnd);

          ovl_manager->flush_events(ovl_manager);
        }

        clear_osdcmd(&osd->cmd);
        osd->handle = -1;
        osd->extent_width = (unsigned short int)720;
        osd->extent_height = (unsigned short int)576;
        osd->last_changed_vpts = (signed long int)0;
        set_argb_layer(&osd->argb_layer, (struct argb_layer_s *)(void *)0);
        free((void *)osd->argb_buffer);
        osd->argb_buffer = (unsigned int *)(void *)0;
        return 0;
      }
}

// exec_osd_command
// file xine/osd_manager.c line 871
static signed int exec_osd_command(struct osd_manager_s *this_gen, struct osd_command_s *cmd, struct xine_stream_s *stream)
{
  struct osd_manager_impl_s *this = (struct osd_manager_impl_s *)this_gen;
  signed int result;
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  if(cmd == ((struct osd_command_s *)NULL) || stream == ((struct xine_stream_s *)NULL))
  {
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_osd, "exec_osd_command: Stream not initialized !");

    while((_Bool)0);
    return -3;
  }

  else
    if((signed int)cmd->wnd >= 50)
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_osd, "exec_osd_command: OSD window handle %d out of range !", cmd->wnd);

      while((_Bool)0);
      return -2;
    }

    else
    {
      signed int return_value_pthread_mutex_lock$4;
      return_value_pthread_mutex_lock$4=pthread_mutex_lock(&this->lock);
      if(!(return_value_pthread_mutex_lock$4 == 0))
      {
        do
          if(iSysLogLevel >= 1)
          {
            x_syslog(3, log_module_input_osd, "exec_osd_command: mutex lock failed");
            signed int *return_value___errno_location$3;
            return_value___errno_location$3=__errno_location();
            if(!(*return_value___errno_location$3 == 0))
            {
              return_value___errno_location$1=__errno_location();
              return_value_strerror$2=strerror(*return_value___errno_location$1);
              x_syslog(3, log_module_input_osd, "   (ERROR (%s,%d): %s)", (const void *)"xine/osd_manager.c", 887, return_value_strerror$2);
            }

          }

        while((_Bool)0);
        return -3;
      }

      else
      {
        this->stream = stream;
        result=exec_osd_command_internal(this, cmd);
        release_ticket(this);
        pthread_mutex_unlock(&this->lock);
        return result;
      }
    }
}

// exec_osd_command_internal
// file xine/osd_manager.c line 833
static signed int exec_osd_command_internal(struct osd_manager_impl_s *this, struct osd_command_s *cmd)
{

__CPROVER_DUMP_L1:
  ;
  signed int return_value_exec_osd_nop$1;
  signed int return_value_exec_osd_size$2;
  signed int return_value_exec_osd_set_palette$3;
  signed int return_value_exec_osd_move$4;
  signed int return_value_exec_osd_flush$5;
  signed int return_value_exec_osd_set_rle$6;
  signed int return_value_exec_osd_set_lut8$7;
  signed int return_value_exec_osd_set_argb$8;
  signed int return_value_exec_osd_close$9;
  signed int return_value_exec_osd_video_window$10;
  switch((signed int)cmd->cmd)
  {
    case 0:
    {
      return_value_exec_osd_nop$1=exec_osd_nop(this, cmd);
      return return_value_exec_osd_nop$1;
    }
    case 1:
    {
      return_value_exec_osd_size$2=exec_osd_size(this, cmd);
      return return_value_exec_osd_size$2;
    }
    case 3:
    {
      return_value_exec_osd_set_palette$3=exec_osd_set_palette(this, cmd);
      return return_value_exec_osd_set_palette$3;
    }
    case 4:
    {
      return_value_exec_osd_move$4=exec_osd_move(this, cmd);
      return return_value_exec_osd_move$4;
    }
    case 8:
    {
      return_value_exec_osd_flush$5=exec_osd_flush(this, cmd);
      return return_value_exec_osd_flush$5;
    }
    case 2:
    {
      return_value_exec_osd_set_rle$6=exec_osd_set_rle(this, cmd);
      return return_value_exec_osd_set_rle$6;
    }
    case 11:
    {
      return_value_exec_osd_set_lut8$7=exec_osd_set_lut8(this, cmd);
      return return_value_exec_osd_set_lut8$7;
    }
    case 12:
    {
      return_value_exec_osd_set_argb$8=exec_osd_set_argb(this, cmd);
      return return_value_exec_osd_set_argb$8;
    }
    case 5:
    {
      return_value_exec_osd_close$9=exec_osd_close(this, cmd);
      return return_value_exec_osd_close$9;
    }
    case 9:
    {
      return_value_exec_osd_video_window$10=exec_osd_video_window(this, cmd);
      return return_value_exec_osd_video_window$10;
    }
    case 7:
      return 0;
    case 6:
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_osd, "OSD_Set_YUV not implemented !");

      while((_Bool)0);
      return -2;
    }
    default:
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_osd, "Unknown OSD command %d", cmd->cmd);

      while((_Bool)0);
      return -2;
    }
  }
  return -2;
}

// exec_osd_flush
// file xine/osd_manager.c line 356
static signed int exec_osd_flush(struct osd_manager_impl_s *this, struct osd_command_s *cmd)
{
  struct video_overlay_manager_s$1 *ovl_manager;
  ovl_manager=get_ovl_manager(this);
  if(ovl_manager == ((struct video_overlay_manager_s$1 *)NULL))
    return -2;

  else
  {
    ovl_manager->flush_events(ovl_manager);
    return 0;
  }
}

// exec_osd_move
// file xine/osd_manager.c line 798
static signed int exec_osd_move(struct osd_manager_impl_s *this, struct osd_command_s *cmd)
{
  struct anonymous$4 *osd = &this->osd[(signed long int)cmd->wnd];
  if(osd->cmd.$anon0.data == ((struct osd_rle_elem_s *)NULL))
  {
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_osd, "OSD_Move(%d): old RLE data missing !", cmd->wnd);

    while((_Bool)0);
    return -2;
  }

  else
    if(osd->cmd.$anon1.palette == ((struct osd_clut_s *)NULL))
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_osd, "OSD_Move(%d): old palette missing !", cmd->wnd);

      while((_Bool)0);
      return -2;
    }

    else
    {
      struct osd_command_s tmp;
      memcpy$link3((void *)&tmp, (const void *)&osd->cmd, sizeof(struct osd_command_s) /*62ul*/ );
      memset$link2((void *)&osd->cmd, 0, sizeof(struct osd_command_s) /*62ul*/ );
      tmp.cmd = (unsigned char)2;
      tmp.x = cmd->x;
      tmp.y = cmd->y;
      tmp.pts = cmd->pts;
      tmp.delay_ms = cmd->delay_ms;
      signed int r;
      r=exec_osd_set_rle(this, &tmp);
      clear_osdcmd(&tmp);
      return r;
    }
}

// exec_osd_nop
// file xine/osd_manager.c line 345
static signed int exec_osd_nop(struct osd_manager_impl_s *this, struct osd_command_s *cmd)
{
  this->osd[(signed long int)cmd->wnd].last_changed_vpts=xine_get_current_vpts(this->stream);
  return 0;
}

// exec_osd_set_argb
// file xine/osd_manager.c line 599
static signed int exec_osd_set_argb(struct osd_manager_impl_s *this, struct osd_command_s *cmd)
{
  struct video_overlay_manager_s$1 *ovl_manager;
  ovl_manager=get_ovl_manager(this);
  struct video_overlay_event_s ov_event = { .vpts=(signed long int)0, .event_type=0u, .object={ .handle=0, .object_type=0u, .pts=0l, .overlay=((struct vo_overlay_s *)NULL), .palette=((unsigned int *)NULL),
    .palette_type=0u } };
  struct vo_overlay_s ov_overlay = { .rle=((struct rle_elem_s *)NULL), .data_size=0, .num_rle=0,
    .x=0, .y=0, .width=0, .height=0, .video_window_x=0,
    .video_window_y=0, .video_window_width=0,
    .video_window_height=0, .extent_width=0,
    .extent_height=0, .color={ 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }, .trans={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .rgb_clut=0,
    .hili_top=0, .hili_bottom=0, .hili_left=0,
    .hili_right=0, .hili_color={ 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }, .hili_trans={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .hili_rgb_clut=0,
    .unscaled=0, .argb_layer=((struct argb_layer_s *)NULL) };
  struct anonymous$4 *osd = &this->osd[(signed long int)cmd->wnd];
  signed int handle = osd->handle;
  _Bool tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$3;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$5;
  signed int tmp_if_expr$6;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$10;
  signed int tmp_if_expr$11;
  signed int tmp_if_expr$12;
  signed int tmp_if_expr$13;
  signed long int tmp_if_expr$15;
  signed long int return_value_xine_get_current_vpts$14;
  if(ovl_manager == ((struct video_overlay_manager_s$1 *)NULL))
    return -2;

  else
  {
    signed int return_value;
    return_value=this->mgr.argb_supported(this->stream);
    if(return_value == 0)
    {
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_osd, "ARGB overlay not supported by video driver");

      return -2;
    }

    else
    {
      if(!((signed int)osd->extent_width >= 32))
        tmp_if_expr$1 = (_Bool)1;

      else
        tmp_if_expr$1 = (signed int)osd->extent_height < 32 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$1)
      {
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_osd, "ARGB overlay: incorrect extent");

        return -2;
      }

      else
      {
        this->stream->video_out->enable_ovl(this->stream->video_out, 1);
        if(!(handle >= 0))
        {
          handle=ovl_manager->get_handle(ovl_manager, 0);
          osd->handle = handle;
          if(!((signed int)osd->extent_width == 0))
            tmp_if_expr$2 = (signed int)osd->extent_width;

          else
            tmp_if_expr$2 = 720;
          osd->extent_width = (unsigned short int)tmp_if_expr$2;
          if(!((signed int)osd->extent_height == 0))
            tmp_if_expr$3 = (signed int)osd->extent_height;

          else
            tmp_if_expr$3 = 576;
          osd->extent_height = (unsigned short int)tmp_if_expr$3;
          osd->last_changed_vpts = (signed long int)0;
        }

        ov_event.event_type = (unsigned int)1;
        ov_event.vpts=osd_exec_vpts(this, cmd);
        ov_event.object.handle = handle;
        ov_event.object.overlay = &ov_overlay;
        ov_event.object.object_type = (unsigned int)1;
        clear_osdcmd(&osd->cmd);
        ov_overlay.x = 0;
        ov_overlay.y = 0;
        ov_overlay.width = (signed int)osd->extent_width;
        ov_overlay.height = (signed int)osd->extent_height;
        ov_overlay.hili_rgb_clut = -9999;
        const struct anonymous$5 extra_data = { .extent_width=osd->extent_width, .extent_height=osd->extent_height, .layer=(unsigned int)cmd->layer,
    .scaling=cmd->scaling };
        memcpy$link3((void *)ov_overlay.hili_color, (const void *)&extra_data, sizeof(const struct anonymous$5) /*12ul*/ );
        ov_overlay.extent_width = (signed int)osd->extent_width;
        ov_overlay.extent_height = (signed int)osd->extent_height;
        if(!((signed int)osd->video_window_x == 0))
          tmp_if_expr$4 = (signed int)osd->video_window_x;

        else
          tmp_if_expr$4 = -1;
        ov_overlay.video_window_x = tmp_if_expr$4;
        if(!((signed int)osd->video_window_y == 0))
          tmp_if_expr$5 = (signed int)osd->video_window_y;

        else
          tmp_if_expr$5 = -1;
        ov_overlay.video_window_y = tmp_if_expr$5;
        if(!((signed int)osd->video_window_w == 0))
          tmp_if_expr$6 = (signed int)osd->video_window_w;

        else
          tmp_if_expr$6 = -1;
        ov_overlay.video_window_width = tmp_if_expr$6;
        if(!((signed int)osd->video_window_h == 0))
          tmp_if_expr$7 = (signed int)osd->video_window_h;

        else
          tmp_if_expr$7 = -1;
        ov_overlay.video_window_height = tmp_if_expr$7;
        ov_overlay.unscaled = ((signed int)cmd->flags & 0x04) != 0 ? 1 : 0;
        if(osd->argb_buffer == ((unsigned int *)NULL))
        {
          void *return_value_calloc$8;
          return_value_calloc$8=calloc(sizeof(unsigned int) /*4ul*/ , (unsigned long int)((signed int)osd->extent_width * (signed int)osd->extent_height));
          osd->argb_buffer = (unsigned int *)return_value_calloc$8;
        }

        if(osd->argb_layer == ((struct argb_layer_s *)NULL))
        {
          struct argb_layer_s *return_value_argb_layer_create$9;
          return_value_argb_layer_create$9=argb_layer_create();
          set_argb_layer(&osd->argb_layer, return_value_argb_layer_create$9);
          osd->argb_layer->buffer = osd->argb_buffer;
          osd->argb_layer->x1 = 0;
          osd->argb_layer->x2 = (signed int)osd->extent_width - 1;
          osd->argb_layer->y1 = 0;
          osd->argb_layer->y2 = (signed int)osd->extent_height - 1;
        }

        unsigned int *src = (unsigned int *)cmd->$anon0.raw_data;
        unsigned int *dst = osd->argb_buffer;
        signed int stride = (signed int)cmd->w;
        signed int lines = (signed int)cmd->h;
        if(!((signed int)osd->extent_width >= (signed int)cmd->w + (signed int)cmd->x))
        {
          stride = (signed int)osd->extent_width - (signed int)cmd->x;
          if(!(stride >= 0))
            stride = 0;

          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_osd, "ARGB overlay: incorrect extent, cropping right side");

        }

        if(!((signed int)osd->extent_height >= (signed int)cmd->h + (signed int)cmd->y))
        {
          lines = (signed int)osd->extent_height - (signed int)cmd->y;
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_osd, "ARGB overlay: incorrect extent, cropping bottom");

        }

        dst = dst + (signed long int)((signed int)cmd->y * (signed int)osd->extent_width + (signed int)cmd->x);
        if(lines >= 1)
        {
          memcpy$link3((void *)dst, (const void *)src, (unsigned long int)stride * sizeof(unsigned int) /*4ul*/ );
          src = src + (signed long int)cmd->w;
          dst = dst + (signed long int)osd->extent_width;
          lines = lines - 1;
        }

        if(!(osd->argb_layer->x1 >= (signed int)cmd->x))
          tmp_if_expr$10 = osd->argb_layer->x1;

        else
          tmp_if_expr$10 = (signed int)cmd->x;
        osd->argb_layer->x1 = tmp_if_expr$10;
        if(!((signed int)cmd->w + (signed int)cmd->x + -1 >= osd->argb_layer->x2))
          tmp_if_expr$11 = osd->argb_layer->x2;

        else
          tmp_if_expr$11 = ((signed int)cmd->x + (signed int)cmd->w) - 1;
        osd->argb_layer->x2 = tmp_if_expr$11;
        if(!(osd->argb_layer->y1 >= (signed int)cmd->y))
          tmp_if_expr$12 = osd->argb_layer->y1;

        else
          tmp_if_expr$12 = (signed int)cmd->y;
        osd->argb_layer->y1 = tmp_if_expr$12;
        if(!((signed int)cmd->h + (signed int)cmd->y + -1 >= osd->argb_layer->y2))
          tmp_if_expr$13 = osd->argb_layer->y2;

        else
          tmp_if_expr$13 = ((signed int)cmd->y + (signed int)cmd->h) - 1;
        osd->argb_layer->y2 = tmp_if_expr$13;
        set_argb_layer(&ov_overlay.argb_layer, osd->argb_layer);
        signed int return_value_1;
        return_value_1=ovl_manager->add_event(ovl_manager, (void *)&ov_event);
        if(!(return_value_1 >= 0))
        {
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_osd, "OSD_Set_ARGB(%d): overlay manager queue full !", cmd->wnd);

          ovl_manager->flush_events(ovl_manager);
        }

        set_argb_layer(&ov_overlay.argb_layer, (struct argb_layer_s *)(void *)0);
        if(!(ov_event.vpts == 0l))
          tmp_if_expr$15 = ov_event.vpts;

        else
        {
          return_value_xine_get_current_vpts$14=xine_get_current_vpts(this->stream);
          tmp_if_expr$15 = return_value_xine_get_current_vpts$14;
        }
        osd->last_changed_vpts = tmp_if_expr$15;
        return 0;
      }
    }
  }
}

// exec_osd_set_lut8
// file xine/osd_manager.c line 586
static signed int exec_osd_set_lut8(struct osd_manager_impl_s *this, struct osd_command_s *cmd)
{
  struct osd_command_s cmdrle;
  memcpy$link3((void *)&cmdrle, (const void *)cmd, sizeof(struct osd_command_s) /*62ul*/ );
  if(!(cmd->$anon0.data == ((struct osd_rle_elem_s *)NULL)))
  {
    cmdrle.num_rle=rle_compress(&cmdrle.$anon0.data, cmdrle.$anon0.raw_data, (unsigned int)cmdrle.w, (unsigned int)cmdrle.h);
    cmdrle.datalen = (unsigned int)4 * cmdrle.num_rle;
    cmdrle.cmd = (unsigned char)2;
  }

  signed int return_value_exec_osd_set_rle$1;
  return_value_exec_osd_set_rle$1=exec_osd_set_rle(this, &cmdrle);
  return return_value_exec_osd_set_rle$1;
}

// exec_osd_set_palette
// file xine/osd_manager.c line 758
static signed int exec_osd_set_palette(struct osd_manager_impl_s *this, struct osd_command_s *cmd)
{
  struct anonymous$4 *osd = &this->osd[(signed long int)cmd->wnd];
  if(osd->cmd.$anon0.data == ((struct osd_rle_elem_s *)NULL))
  {
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_osd, "OSD_SetPalette(%d): old RLE data missing !", cmd->wnd);

    while((_Bool)0);
    return -2;
  }

  else
    if(cmd->$anon1.palette == ((struct osd_clut_s *)NULL))
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_osd, "OSD_SetPalette(%d): new palette missing !", cmd->wnd);

      while((_Bool)0);
      return -2;
    }

    else
    {
      struct osd_command_s tmp;
      memcpy$link3((void *)&tmp, (const void *)&osd->cmd, sizeof(struct osd_command_s) /*62ul*/ );
      memset$link2((void *)&osd->cmd, 0, sizeof(struct osd_command_s) /*62ul*/ );
      tmp.cmd = (unsigned char)2;
      free((void *)tmp.$anon1.palette);
      void *return_value_malloc$1;
      return_value_malloc$1=malloc((unsigned long int)cmd->colors * sizeof(struct osd_rle_elem_s) /*4ul*/ );
      tmp.$anon1.palette = (struct osd_clut_s *)return_value_malloc$1;
      memcpy$link3((void *)tmp.$anon1.palette, (const void *)cmd->$anon1.palette, (unsigned long int)cmd->colors * sizeof(struct osd_rle_elem_s) /*4ul*/ );
      tmp.colors = cmd->colors;
      tmp.pts = cmd->pts;
      tmp.delay_ms = cmd->delay_ms;
      tmp.flags = tmp.flags | (unsigned char)((signed int)cmd->flags & 0x01);
      signed int r;
      r=exec_osd_set_rle(this, &tmp);
      clear_osdcmd(&tmp);
      return r;
    }
}

// exec_osd_set_rle
// file xine/osd_manager.c line 419
static signed int exec_osd_set_rle(struct osd_manager_impl_s *this, struct osd_command_s *cmd)
{
  struct video_overlay_manager_s$1 *ovl_manager;
  ovl_manager=get_ovl_manager(this);
  struct video_overlay_event_s ov_event = { .vpts=(signed long int)0, .event_type=0u, .object={ .handle=0, .object_type=0u, .pts=0l, .overlay=((struct vo_overlay_s *)NULL), .palette=((unsigned int *)NULL),
    .palette_type=0u } };
  struct vo_overlay_s ov_overlay = { .rle=((struct rle_elem_s *)NULL), .data_size=0, .num_rle=0,
    .x=0, .y=0, .width=0, .height=0, .video_window_x=0,
    .video_window_y=0, .video_window_width=0,
    .video_window_height=0, .extent_width=0,
    .extent_height=0, .color={ 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }, .trans={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .rgb_clut=0,
    .hili_top=0, .hili_bottom=0, .hili_left=0,
    .hili_right=0, .hili_color={ 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }, .hili_trans={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .hili_rgb_clut=0,
    .unscaled=0, .argb_layer=((struct argb_layer_s *)NULL) };
  struct anonymous$4 *osd = &this->osd[(signed long int)cmd->wnd];
  signed int use_unscaled = 0;
  signed int rle_scaled = 0;
  signed int unscaled_supported;
  signed int handle = osd->handle;
  signed int tmp_if_expr$1;
  signed int tmp_if_expr$2;
  signed int tmp_if_expr$4;
  signed int tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  signed int tmp_if_expr$7;
  signed int tmp_if_expr$8;
  signed int tmp_if_expr$9;
  signed int tmp_if_expr$10;
  signed long int tmp_if_expr$13;
  signed long int return_value_xine_get_current_vpts$12;
  if(ovl_manager == ((struct video_overlay_manager_s$1 *)NULL))
    return -2;

  else
  {
    this->stream->video_out->enable_ovl(this->stream->video_out, 1);
    if(!(handle >= 0))
    {
      handle=ovl_manager->get_handle(ovl_manager, 0);
      osd->handle = handle;
      if(!((signed int)osd->extent_width == 0))
        tmp_if_expr$1 = (signed int)osd->extent_width;

      else
        tmp_if_expr$1 = 720;
      osd->extent_width = (unsigned short int)tmp_if_expr$1;
      if(!((signed int)osd->extent_height == 0))
        tmp_if_expr$2 = (signed int)osd->extent_height;

      else
        tmp_if_expr$2 = 576;
      osd->extent_height = (unsigned short int)tmp_if_expr$2;
      osd->last_changed_vpts = (signed long int)0;
    }

    ov_event.event_type = (unsigned int)1;
    ov_event.vpts=osd_exec_vpts(this, cmd);
    ov_event.object.handle = handle;
    ov_event.object.overlay = &ov_overlay;
    ov_event.object.object_type = (unsigned int)1;
    struct xine_video_port_s$1 *video_out = this->stream->video_out;
    unsigned int return_value;
    return_value=video_out->get_capabilities(video_out);
    unscaled_supported = (signed int)!(!((return_value & (unsigned int)0x00000010) != 0u));
    if(!(unscaled_supported == 0))
    {
      if(!((0x04 & (signed int)cmd->flags) == 0))
        use_unscaled = 1;

      if(!((12 & (signed int)cmd->flags) == 0))
      {
        signed int return_value_1;
        return_value_1=video_out->get_property(video_out, 15);
        this->win_width = (unsigned short int)return_value_1;
        signed int return_value_2;
        return_value_2=video_out->get_property(video_out, 16);
        this->win_height = (unsigned short int)return_value_2;
      }

    }

    clear_osdcmd(&osd->cmd);
    memcpy$link3((void *)&osd->cmd, (const void *)cmd, sizeof(struct osd_command_s) /*62ul*/ );
    osd->cmd.$anon0.data = (struct osd_rle_elem_s *)(void *)0;
    if(!(cmd->$anon1.palette == ((struct osd_clut_s *)NULL)))
    {
      if((0x01 & (signed int)cmd->flags) == 0)
        palette_argb_to_ayuv(cmd->$anon1.palette, (signed int)cmd->colors);

      cmd->flags = cmd->flags | (unsigned char)0x01;
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(sizeof(struct osd_clut_s) /*4ul*/  * (unsigned long int)cmd->colors);
      osd->cmd.$anon1.palette = (struct osd_clut_s *)return_value_malloc$3;
      memcpy$link3((void *)osd->cmd.$anon1.palette, (const void *)cmd->$anon1.palette, (unsigned long int)((unsigned int)4 * cmd->colors));
      osd->cmd.flags = osd->cmd.flags | (unsigned char)0x01;
    }

    unsigned int return_value_3;
    return_value_3=video_out->get_capabilities(video_out);
    this->vo_scaling = (unsigned char)!(!((return_value_3 & (unsigned int)0x01000000) != 0u));
    if(!(this->vo_scaling == 0))
      video_out->set_property(video_out, 0x1001, cmd->scaling != 0 ? 1 : 0);

    if(this->vo_scaling == 0)
    {
      if(use_unscaled == 0)
      {
        signed int w_diff;
        if(!((signed int)this->video_width >= 242 * (signed int)osd->extent_width >> 8))
          tmp_if_expr$4 = -1;

        else
          tmp_if_expr$4 = (signed int)this->video_width > (signed int)osd->extent_width * 280 >> 8 ? 1 : 0;
        w_diff = tmp_if_expr$4;
        signed int h_diff;
        if(!((signed int)this->video_height >= 242 * (signed int)osd->extent_height >> 8))
          tmp_if_expr$5 = -1;

        else
          tmp_if_expr$5 = (signed int)this->video_height > (signed int)osd->extent_height * 280 >> 8 ? 1 : 0;
        h_diff = tmp_if_expr$5;
        if(!(h_diff == 0) || !(w_diff == 0))
        {
          if(!(h_diff >= 0) || !(w_diff >= 0))
          {
            if(!((0x08 & (signed int)cmd->flags) == 0))
              use_unscaled = unscaled_supported;

          }

          if(use_unscaled == 0)
          {
            if((signed int)cmd->scaling >= 1)
            {
              osdcmd_scale(this, cmd, osd, (signed int)this->video_width, (signed int)this->video_height);
              rle_scaled = 1;
            }

          }

        }

      }

    }

    if(this->vo_scaling == 0)
    {
      if(!(use_unscaled == 0))
      {
        if((signed int)cmd->scaling >= 1)
        {
          if((signed int)this->win_width >= 360)
          {
            if((signed int)this->win_height >= 288)
            {
              if(!(this->win_width == osd->extent_width))
                tmp_if_expr$6 = (_Bool)1;

              else
                tmp_if_expr$6 = this->win_height != osd->extent_height ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$6)
              {
                osdcmd_scale(this, cmd, osd, (signed int)this->win_width, (signed int)this->win_height);
                rle_scaled = 1;
              }

            }

          }

        }

      }

    }

    osdcmd_to_overlay(&ov_overlay, cmd);
    ov_overlay.unscaled = use_unscaled;
    ov_overlay.hili_rgb_clut = -9999;
    const struct anonymous$5 extra_data = { .extent_width=osd->extent_width, .extent_height=osd->extent_height, .layer=(unsigned int)cmd->layer,
    .scaling=cmd->scaling };
    memcpy$link3((void *)ov_overlay.hili_color, (const void *)&extra_data, sizeof(const struct anonymous$5) /*12ul*/ );
    if(!(cmd->scaling == 0))
    {
      if(rle_scaled == 0)
      {
        ov_overlay.extent_width = (signed int)osd->extent_width;
        ov_overlay.extent_height = (signed int)osd->extent_height;
      }

    }

    if(!((signed int)osd->video_window_x == 0))
      tmp_if_expr$7 = (signed int)osd->video_window_x;

    else
      tmp_if_expr$7 = -1;
    ov_overlay.video_window_x = tmp_if_expr$7;
    if(!((signed int)osd->video_window_y == 0))
      tmp_if_expr$8 = (signed int)osd->video_window_y;

    else
      tmp_if_expr$8 = -1;
    ov_overlay.video_window_y = tmp_if_expr$8;
    if(!((signed int)osd->video_window_w == 0))
      tmp_if_expr$9 = (signed int)osd->video_window_w;

    else
      tmp_if_expr$9 = -1;
    ov_overlay.video_window_width = tmp_if_expr$9;
    if(!((signed int)osd->video_window_h == 0))
      tmp_if_expr$10 = (signed int)osd->video_window_h;

    else
      tmp_if_expr$10 = -1;
    ov_overlay.video_window_height = tmp_if_expr$10;
    if(this->vo_scaling == 0)
    {
      if(rle_scaled == 0)
      {
        if(use_unscaled == 0)
        {
          if(!(this->video_width == osd->extent_width))
            ov_overlay.x = ov_overlay.x + ((signed int)this->video_width - (signed int)osd->extent_width) / 2;

          if(!(this->video_height == osd->extent_height))
            ov_overlay.y = ov_overlay.y + ((signed int)this->video_height - (signed int)osd->extent_height) / 2;

        }

        else
          if((signed int)this->win_width >= 360)
          {
            if((signed int)this->win_height >= 288)
            {
              if(!(this->win_width == osd->extent_width))
                ov_overlay.x = ov_overlay.x + ((signed int)this->win_width - (signed int)osd->extent_width) / 2;

              if(!(this->win_height == osd->extent_height))
                ov_overlay.y = ov_overlay.y + ((signed int)this->win_height - (signed int)osd->extent_height) / 2;

            }

          }

      }

    }

    if(rle_scaled == 0)
    {
      void *return_value_malloc$11;
      return_value_malloc$11=malloc((unsigned long int)cmd->datalen);
      osd->cmd.$anon0.data = (struct osd_rle_elem_s *)return_value_malloc$11;
      memcpy$link3((void *)osd->cmd.$anon0.data, (const void *)cmd->$anon0.data, (unsigned long int)cmd->datalen);
    }

    cmd->$anon0.data = (struct osd_rle_elem_s *)(void *)0;
    signed int return_value_4;
    return_value_4=ovl_manager->add_event(ovl_manager, (void *)&ov_event);
    if(!(return_value_4 >= 0))
    {
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_osd, "OSD_Set_RLE(%d): overlay manager queue full !", cmd->wnd);

      ovl_manager->flush_events(ovl_manager);
    }

    if(!(ov_event.vpts == 0l))
      tmp_if_expr$13 = ov_event.vpts;

    else
    {
      return_value_xine_get_current_vpts$12=xine_get_current_vpts(this->stream);
      tmp_if_expr$13 = return_value_xine_get_current_vpts$12;
    }
    osd->last_changed_vpts = tmp_if_expr$13;
    return 0;
  }
}

// exec_osd_size
// file xine/osd_manager.c line 297
static signed int exec_osd_size(struct osd_manager_impl_s *this, struct osd_command_s *cmd)
{
  struct anonymous$4 *osd = &this->osd[(signed long int)cmd->wnd];
  osd->extent_width = cmd->w;
  osd->extent_height = cmd->h;
  osd->video_window_x = (unsigned short int)0;
  osd->video_window_y = (unsigned short int)0;
  osd->video_window_w = (unsigned short int)0;
  osd->video_window_h = (unsigned short int)0;
  acquire_ticket(this);
  set_argb_layer(&osd->argb_layer, (struct argb_layer_s *)(void *)0);
  free((void *)osd->argb_buffer);
  osd->argb_buffer = (unsigned int *)(void *)0;
  struct xine_video_port_s$1 *video_out = this->stream->video_out;
  unsigned int return_value;
  return_value=video_out->get_capabilities(video_out);
  this->vo_scaling = (unsigned char)!(!((return_value & (unsigned int)0x01000000) != 0u));
  return 0;
}

// exec_osd_video_window
// file xine/osd_manager.c line 328
static signed int exec_osd_video_window(struct osd_manager_impl_s *this, struct osd_command_s *cmd)
{
  struct anonymous$4 *osd = &this->osd[(signed long int)cmd->wnd];
  osd->video_window_x = cmd->x;
  osd->video_window_y = cmd->y;
  osd->video_window_w = cmd->w;
  osd->video_window_h = cmd->h;
  return 0;
}

// fifo_buffer_new
// file xine_input_vdr.c line 1287
static struct fifo_buffer_s * fifo_buffer_new(struct xine_stream_s *stream, signed int num_buffers, unsigned int buf_size)
{
  struct fifo_buffer_s *ref = stream->video_fifo;
  struct fifo_buffer_s *this;
  signed int i;
  unsigned char *multi_buffer;
  do
    if(iSysLogLevel >= 3)
      x_syslog(7, log_module_input_vdr, "fifo_buffer_new...");

  while((_Bool)0);
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct fifo_buffer_s) /*608ul*/ );
  this = (struct fifo_buffer_s *)return_value_calloc$1;
  this->first = (struct buf_element_s *)(void *)0;
  this->last = (struct buf_element_s *)(void *)0;
  this->fifo_size = 0;
  this->put = ref->put;
  this->insert = ref->insert;
  this->get = ref->get;
  this->clear = ref->clear;
  this->size = ref->size;
  this->num_free = ref->num_free;
  this->data_size = ref->data_size;
  this->dispose = ref->dispose;
  this->register_alloc_cb = ref->register_alloc_cb;
  this->register_get_cb = ref->register_get_cb;
  this->register_put_cb = ref->register_put_cb;
  this->unregister_alloc_cb = ref->unregister_alloc_cb;
  this->unregister_get_cb = ref->unregister_get_cb;
  this->unregister_put_cb = ref->unregister_put_cb;
  pthread_mutex_init(&this->mutex, (const union anonymous$37 *)(void *)0);
  pthread_cond_init(&this->not_empty, (const union anonymous$37 *)(void *)0);
  this->buffer_pool_base=av_mallocz((unsigned long int)((unsigned int)num_buffers * buf_size));
  multi_buffer = (unsigned char *)this->buffer_pool_base;
  pthread_mutex_init(&this->buffer_pool_mutex, (const union anonymous$37 *)(void *)0);
  pthread_cond_init(&this->buffer_pool_cond_not_empty, (const union anonymous$37 *)(void *)0);
  this->buffer_pool_capacity = num_buffers;
  this->buffer_pool_buf_size = (signed int)buf_size;
  this->buffer_pool_alloc = ref->buffer_pool_alloc;
  this->buffer_pool_try_alloc = ref->buffer_pool_try_alloc;
  i = 0;
  for( ; !(i >= num_buffers); i = i + 1)
  {
    struct buf_element_s *buf;
    void *return_value_calloc$2;
    return_value_calloc$2=calloc((unsigned long int)1, sizeof(struct buf_element_s) /*144ul*/ );
    buf = (struct buf_element_s *)return_value_calloc$2;
    buf->mem = multi_buffer;
    multi_buffer = multi_buffer + (signed long int)buf_size;
    buf->max_size = (signed int)buf_size;
    buf->free_buffer = buffer_pool_free;
    buf->source = (void *)this;
    void *return_value_malloc$3;
    return_value_malloc$3=malloc(sizeof(struct extra_info_s) /*32ul*/ );
    buf->extra_info = (struct extra_info_s *)return_value_malloc$3;
    buffer_pool_free(buf);
  }
  do
    if(iSysLogLevel >= 3)
      x_syslog(7, log_module_input_vdr, "fifo_buffer_new done.");

  while((_Bool)0);
  return this;
}

// fifo_buffer_timed_get
// file xine_input_vdr.c line 1242
static struct buf_element_s * fifo_buffer_timed_get(struct fifo_buffer_s *fifo, signed int timeout)
{
  struct buf_element_s *buf;
  buf=fifo_buffer_try_get(fifo);
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  if(buf == ((struct buf_element_s *)NULL))
  {
    struct timespec abstime;
    signed int result = 0;
    create_timeout_time(&abstime, timeout);
    signed int return_value_pthread_mutex_lock$8;
    return_value_pthread_mutex_lock$8=pthread_mutex_lock(&fifo->mutex);
    if(!(return_value_pthread_mutex_lock$8 == 0))
      do
        if(iSysLogLevel >= 1)
        {
          x_syslog(3, log_module_input_vdr, "pthread_mutex_lock (%s) failed, skipping locked block !", (const void *)"&fifo->mutex");
          signed int *return_value___errno_location$3;
          return_value___errno_location$3=__errno_location();
          if(!(*return_value___errno_location$3 == 0))
          {
            return_value___errno_location$1=__errno_location();
            return_value_strerror$2=strerror(*return_value___errno_location$1);
            x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 1251, return_value_strerror$2);
          }

        }

      while((_Bool)0);

    else
      do
      {
        struct anonymous$39 __cancel_buf;
        void (*__cancel_routine)(void *) = mutex_cleanup;
        void *__cancel_arg = (void *)&fifo->mutex;
        signed int __not_first_call;
        __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
        if(!((signed long int)__not_first_call == 0l))
        {
          __cancel_routine(__cancel_arg);
          __pthread_unwind_next(&__cancel_buf);
        }

        __pthread_register_cancel(&__cancel_buf);

      __CPROVER_DUMP_L6:
        ;
        do
        {
          if(fifo->first == ((struct buf_element_s *)NULL))
          {
            if(result == 0)
            {
              result=pthread_cond_timedwait(&fifo->not_empty, &fifo->mutex, &abstime);
              goto __CPROVER_DUMP_L6;
            }

          }

          signed int return_value_pthread_mutex_unlock$7;
          return_value_pthread_mutex_unlock$7=pthread_mutex_unlock(&fifo->mutex);
          if(!(return_value_pthread_mutex_unlock$7 == 0))
            do
              if(iSysLogLevel >= 1)
              {
                x_syslog(3, log_module_input_vdr, "pthread_mutex_unlock (%s) failed !", (const void *)"&fifo->mutex");
                signed int *return_value___errno_location$6;
                return_value___errno_location$6=__errno_location();
                if(!(*return_value___errno_location$6 == 0))
                {
                  return_value___errno_location$4=__errno_location();
                  return_value_strerror$5=strerror(*return_value___errno_location$4);
                  x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 1254, return_value_strerror$5);
                }

              }

            while((_Bool)0);


        __CPROVER_DUMP_L11:
          ;
        }
        while((_Bool)0);
        __pthread_unregister_cancel(&__cancel_buf);
      }
      while((_Bool)0);
    buf=fifo_buffer_try_get(fifo);
  }

  return buf;
}

// fifo_buffer_try_get
// file xine_input_vdr.c line 1213
static struct buf_element_s * fifo_buffer_try_get(struct fifo_buffer_s *fifo)
{
  signed int i;
  struct buf_element_s *buf;
  pthread_mutex_lock(&fifo->mutex);
  if(fifo->first == ((struct buf_element_s *)NULL))
  {
    pthread_mutex_unlock(&fifo->mutex);
    return (struct buf_element_s *)(void *)0;
  }

  else
  {
    buf = fifo->first;
    fifo->first = fifo->first->next;
    if(fifo->first == ((struct buf_element_s *)NULL))
      fifo->last = (struct buf_element_s *)(void *)0;

    fifo->fifo_size = fifo->fifo_size - 1;
    fifo->fifo_data_size = fifo->fifo_data_size - (unsigned int)buf->size;
    i = 0;
    if(!(fifo->get_cb[(signed long int)i] == ((void (*)(struct fifo_buffer_s *, struct buf_element_s *, void *))NULL)))
    {
      fifo->get_cb[(signed long int)i](fifo, buf, fifo->get_cb_data[(signed long int)i]);
      i = i + 1;
    }

    pthread_mutex_unlock(&fifo->mutex);
    return buf;
  }
}

// fifo_class_get_instance
// file xine_input_vdr.c line 1896
static struct input_plugin_s$0 * fifo_class_get_instance(struct input_class_s$1 *class_gen, struct xine_stream_s *stream, const char *data)
{
  struct fifo_input_plugin_s *slave;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct fifo_input_plugin_s) /*160ul*/ );
  slave = (struct fifo_input_plugin_s *)return_value_calloc$1;
  unsigned long int imaster;
  struct vdr_input_plugin_s *master;
  do
    if(iSysLogLevel >= 3)
      x_syslog(7, log_module_input_vdr, "fifo_class_get_instance");

  while((_Bool)0);
  sscanf(data + (signed long int)15, "%lx", &imaster);
  master = (struct vdr_input_plugin_s *)imaster;
  slave->master = (struct vdr_input_plugin_s *)master;
  slave->stream = stream;
  slave->buffer_pool = stream->video_fifo;
  slave->buffer=fifo_buffer_new(stream, 4, (unsigned int)4096);
  slave->i.open = fifo_open;
  slave->i.get_mrl = fifo_get_mrl;
  slave->i.dispose = fifo_dispose;
  slave->i.input_class = class_gen;
  slave->i.get_capabilities = fifo_get_capabilities;
  slave->i.read = fifo_read;
  slave->i.read_block = fifo_read_block;
  slave->i.seek = fifo_seek;
  slave->i.get_current_pos = fifo_get_current_pos;
  slave->i.get_length = fifo_get_length;
  slave->i.get_blocksize = fifo_get_blocksize;
  slave->i.get_optional_data = fifo_get_optional_data;
  return (struct input_plugin_s$0 *)slave;
}

// fifo_dispose
// file xine_input_vdr.c line 1884
static void fifo_dispose(struct input_plugin_s$0 *this_gen)
{
  struct fifo_input_plugin_s *this = (struct fifo_input_plugin_s *)this_gen;
  do
    if(iSysLogLevel >= 3)
      x_syslog(7, log_module_input_vdr, "fifo_dispose");

  while((_Bool)0);
  if(!(this == ((struct fifo_input_plugin_s *)NULL)))
  {
    if(!(this->buffer == ((struct fifo_buffer_s *)NULL)))
      this->buffer->dispose(this->buffer);

    free((void *)this);
  }

}

// fifo_get_blocksize
// file xine_input_vdr.c line 1832
static unsigned int fifo_get_blocksize(struct input_plugin_s$0 *this_gen)
{
  return (unsigned int)(2 * 2048);
}

// fifo_get_capabilities
// file xine_input_vdr.c line 1830
static unsigned int fifo_get_capabilities(struct input_plugin_s$0 *this_gen)
{
  return (unsigned int)0x00000002;
}

// fifo_get_current_pos
// file xine_input_vdr.c line 1834
static signed long int fifo_get_current_pos(struct input_plugin_s$0 *this_gen)
{
  return (signed long int)-1;
}

// fifo_get_length
// file xine_input_vdr.c line 1836
static signed long int fifo_get_length(struct input_plugin_s$0 *this_gen)
{
  return (signed long int)-1;
}

// fifo_get_mrl
// file xine_input_vdr.c line 1843
static const char * fifo_get_mrl(struct input_plugin_s$0 *this_gen)
{
  return "xvdr+slave:";
}

// fifo_get_optional_data
// file xine_input_vdr.c line 1840
static signed int fifo_get_optional_data(struct input_plugin_s$0 *this_gen, void *data, signed int data_type)
{
  return 0;
}

// fifo_open
// file xine_input_vdr.c line 1828
static signed int fifo_open(struct input_plugin_s$0 *this_gen)
{
  return 1;
}

// fifo_read
// file xine_input_vdr.c line 1852
static signed long int fifo_read(struct input_plugin_s$0 *this_gen, void *buf, signed long int len)
{
  signed int got = 0;
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  do
    if(iSysLogLevel >= 1)
    {
      x_syslog(3, log_module_input_vdr, "fifo_input_plugin::fifo_read() not implemented !");
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      if(!(*return_value___errno_location$3 == 0))
      {
        return_value___errno_location$1=__errno_location();
        return_value_strerror$2=strerror(*return_value___errno_location$1);
        x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 1856, return_value_strerror$2);
      }

    }

  while((_Bool)0);
  exit(-1);
  return (signed long int)got;
}

// fifo_read_block
// file xine_input_vdr.c line 1861
static struct buf_element_s * fifo_read_block(struct input_plugin_s$0 *this_gen, struct fifo_buffer_s *fifo, signed long int todo)
{
  struct fifo_input_plugin_s *this = (struct fifo_input_plugin_s *)this_gen;
  signed int return_value__x_action_pending$1;
  do
  {
    return_value__x_action_pending$1=_x_action_pending(this->stream);
    if(!(return_value__x_action_pending$1 == 0))
      break;

    struct buf_element_s *buf;
    buf=fifo_buffer_try_get(this->buffer);
    if(!(buf == ((struct buf_element_s *)NULL)))
      return buf;

    xine_usec_sleep((unsigned int)(5 * 1000));
  }
  while((_Bool)1);
  do
    if(iSysLogLevel >= 3)
      x_syslog(7, log_module_input_vdr, "fifo_read_block: return NULL !");

  while((_Bool)0);
  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  *return_value___errno_location$2 = 11;
  return (struct buf_element_s *)(void *)0;
}

// fifo_seek
// file xine_input_vdr.c line 1838
static signed long int fifo_seek(struct input_plugin_s$0 *this_gen, signed long int offset, signed int origin)
{
  return offset;
}

// find_audio_track
// file tools/ts.c line 212
static signed int find_audio_track(struct anonymous$10 *pmt, unsigned int pid)
{
  signed int i = 0;
  for( ; !(i >= (signed int)pmt->audio_tracks_count); i = i + 1)
    if((unsigned int)pmt->audio_tracks[(signed long int)i].pid == pid)
      return i;

  return -1;
}

// flush_all_fifos
// file xine_input_vdr.c line 1352
static void flush_all_fifos(struct vdr_input_plugin_s *this, signed int full)
{
  do
    if(iSysLogLevel >= 3)
      x_syslog(7, log_module_input_vdr, "flush_all_fifos(%s)", full != 0 ? "full" : "");

  while((_Bool)0);
  if(!(this->read_buffer == ((struct buf_element_s *)NULL)))
  {
    this->read_buffer->free_buffer(this->read_buffer);
    this->read_buffer = (struct buf_element_s *)(void *)0;
  }

  if(!(this->udp_data == ((struct udp_data_s *)NULL)))
  {
    signed int i = 0;
    for( ; !(i >= 256); i = i + 1)
      if(!(this->udp_data->queue[(signed long int)i] == ((struct buf_element_s *)NULL)))
      {
        this->udp_data->queue[(signed long int)i]->free_buffer(this->udp_data->queue[(signed long int)i]);
        this->udp_data->queue[(signed long int)i] = (struct buf_element_s *)(void *)0;
      }

  }

  if(!(full == 0))
  {
    if(!(this->stream == ((struct xine_stream_s *)NULL)))
    {
      if(!(this->stream->audio_fifo == ((struct fifo_buffer_s *)NULL)))
        this->stream->audio_fifo->clear(this->stream->audio_fifo);

    }

    if(!(this->stream == ((struct xine_stream_s *)NULL)))
    {
      if(!(this->stream->video_fifo == ((struct fifo_buffer_s *)NULL)))
        this->stream->video_fifo->clear(this->stream->video_fifo);

    }

  }

  if(!(this->block_buffer == ((struct fifo_buffer_s *)NULL)))
    this->block_buffer->clear(this->block_buffer);

  if(!(this->hd_buffer == ((struct fifo_buffer_s *)NULL)))
    this->hd_buffer->clear(this->hd_buffer);

}

// fprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 95
static inline signed int fprintf(struct _IO_FILE * restrict __stream, const char * restrict __fmt, ...)
{
  void *return_value___builtin_va_arg_pack$1;
  return_value___builtin_va_arg_pack$1=__builtin_va_arg_pack();
  signed int return_value___fprintf_chk$2;
  return_value___fprintf_chk$2=__fprintf_chk(__stream, 2 - 1, __fmt, return_value___builtin_va_arg_pack$1);
  return return_value___fprintf_chk$2;
}

// free_udp_data
// file xine_input_vdr.c line 443
static void free_udp_data(struct udp_data_s *data)
{
  signed int i = 0;
  for( ; !(i >= 256); i = i + 1)
    if(!(data->queue[(signed long int)i] == ((struct buf_element_s *)NULL)))
    {
      data->queue[(signed long int)i]->free_buffer(data->queue[(signed long int)i]);
      data->queue[(signed long int)i] = (struct buf_element_s *)(void *)0;
    }

  free((void *)data);
}

// get_buf_element
// file xine_input_vdr.c line 1403
static struct buf_element_s * get_buf_element(struct vdr_input_plugin_s *this, signed int size, signed int force)
{
  struct buf_element_s *buf = (struct buf_element_s *)(void *)0;
  if(!(this->hd_stream == 0))
  {
    if(size >= 2113)
      goto __CPROVER_DUMP_L2;

    if(!((signed int)this->reserved_buffers >= this->hd_buffer->buffer_pool_num_free))
      buf=this->hd_buffer->buffer_pool_try_alloc(this->hd_buffer);

    if(!(buf == ((struct buf_element_s *)NULL)) || !(force == 0))
      goto __CPROVER_DUMP_L2;

    return (struct buf_element_s *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    if(buf == ((struct buf_element_s *)NULL) && force == 0)
    {
      if(this->buffer_pool->buffer_pool_num_free >= (signed int)this->reserved_buffers)
        goto __CPROVER_DUMP_L3;

      return (struct buf_element_s *)(void *)0;
    }

    else
    {

    __CPROVER_DUMP_L3:
      ;
      if(buf == ((struct buf_element_s *)NULL))
      {
        if(!(size >= 8000))
          buf=this->buffer_pool->buffer_pool_try_alloc(this->buffer_pool);

        else
          if(!(size >= 0xffff))
          {
            buf=this->block_buffer->buffer_pool_try_alloc(this->block_buffer);
            if(iSysLogLevel >= 3)
              x_syslog(7, log_module_input_vdr, "get_buf_element: big PES (%d bytes) !", size);

          }

          else
            do
              if(iSysLogLevel >= 3)
                x_syslog(7, log_module_input_vdr, "get_buf_element: jumbo PES (%d bytes) !", size);

            while((_Bool)0);
      }

      if(buf == ((struct buf_element_s *)NULL))
        buf=this->stream->audio_fifo->buffer_pool_try_alloc(this->stream->audio_fifo);

      if(!(buf == ((struct buf_element_s *)NULL)))
      {
        buf->content = buf->mem;
        buf->size = 0;
        buf->type = (unsigned int)0x05000000;
        buf->pts = (signed long int)0;
        buf->free_buffer = buffer_pool_free;
      }

      return buf;
    }
  }
}

// get_buf_element_timed
// file xine_input_vdr.c line 1451
static struct buf_element_s * get_buf_element_timed(struct vdr_input_plugin_s *this, signed int size, signed int timeout)
{
  struct buf_element_s *buf;
  buf=get_buf_element(this, size, 0);
  struct fifo_buffer_s *tmp_if_expr$1;
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  signed int *return_value___errno_location$5;
  char *return_value_strerror$6;
  if(buf == ((struct buf_element_s *)NULL))
  {
    signed int result = 0;
    struct fifo_buffer_s *fifo;
    if(!(this->hd_stream == 0))
      tmp_if_expr$1 = this->hd_buffer;

    else
      tmp_if_expr$1 = this->buffer_pool;
    fifo = tmp_if_expr$1;
    struct timespec abstime;
    create_timeout_time(&abstime, timeout);
    do
    {
      signed int return_value_pthread_mutex_lock$9;
      return_value_pthread_mutex_lock$9=pthread_mutex_lock(&fifo->buffer_pool_mutex);
      if(!(return_value_pthread_mutex_lock$9 == 0))
        do
          if(iSysLogLevel >= 1)
          {
            x_syslog(3, log_module_input_vdr, "pthread_mutex_lock (%s) failed, skipping locked block !", (const void *)"&fifo->buffer_pool_mutex");
            signed int *return_value___errno_location$4;
            return_value___errno_location$4=__errno_location();
            if(!(*return_value___errno_location$4 == 0))
            {
              return_value___errno_location$2=__errno_location();
              return_value_strerror$3=strerror(*return_value___errno_location$2);
              x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 1461, return_value_strerror$3);
            }

          }

        while((_Bool)0);

      else
        do
        {
          struct anonymous$39 __cancel_buf;
          void (*__cancel_routine)(void *) = mutex_cleanup;
          void *__cancel_arg = (void *)&fifo->buffer_pool_mutex;
          signed int __not_first_call;
          __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
          if(!((signed long int)__not_first_call == 0l))
          {
            __cancel_routine(__cancel_arg);
            __pthread_unwind_next(&__cancel_buf);
          }

          __pthread_register_cancel(&__cancel_buf);
          do
          {
            result=pthread_cond_timedwait(&fifo->buffer_pool_cond_not_empty, &fifo->buffer_pool_mutex, &abstime);
            signed int return_value_pthread_mutex_unlock$8;
            return_value_pthread_mutex_unlock$8=pthread_mutex_unlock(&fifo->buffer_pool_mutex);
            if(!(return_value_pthread_mutex_unlock$8 == 0))
              do
                if(iSysLogLevel >= 1)
                {
                  x_syslog(3, log_module_input_vdr, "pthread_mutex_unlock (%s) failed !", (const void *)"&fifo->buffer_pool_mutex");
                  signed int *return_value___errno_location$7;
                  return_value___errno_location$7=__errno_location();
                  if(!(*return_value___errno_location$7 == 0))
                  {
                    return_value___errno_location$5=__errno_location();
                    return_value_strerror$6=strerror(*return_value___errno_location$5);
                    x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 1463, return_value_strerror$6);
                  }

                }

              while((_Bool)0);


          __CPROVER_DUMP_L13:
            ;
          }
          while((_Bool)0);
          __pthread_unregister_cancel(&__cancel_buf);
        }
        while((_Bool)0);
      buf=get_buf_element(this, size, 0);
    }
    while(buf == ((struct buf_element_s *)NULL) && result == 0);
  }

  return buf;
}

// get_decoder_name
// file xine/demux_xvdr.c line 117
static const char * get_decoder_name(struct xine_s$1 *xine, signed int buf_type)
{
  unsigned int base = (unsigned int)buf_type & 0xFF000000;
  unsigned int type = (unsigned int)(buf_type >> 16 & 0xFF);
  struct anonymous$60 *node = (struct anonymous$60 *)(void *)0;
  if(base == 33554432u)
    node = xine->plugin_catalog->video_decoder_map[(signed long int)type][(signed long int)0];

  else
    if(base == 50331648u)
      node = xine->plugin_catalog->audio_decoder_map[(signed long int)type][(signed long int)0];

  if(!(node == ((struct anonymous$60 *)NULL)))
  {
    struct anonymous$61 *info = node->info;
    if(!(info == ((struct anonymous$61 *)NULL)))
      return info->id;

  }

  return "<none>";
}

// get_option
// file xine/xvdr_metronom.c line 281
static signed long int get_option(struct metronom_s *metronom, signed int option)
{
  struct xvdr_metronom_s$0 *this = (struct xvdr_metronom_s$0 *)metronom;
  if(option == 0x1001)
  {
    signed long int pts;
    pthread_mutex_lock(&this->mutex);
    pts = this->last_vo_pts;
    pthread_mutex_unlock(&this->mutex);
    return pts;
  }

  if(option == 1)
    return (signed long int)this->trickspeed;

  else
    if(option == 2)
      return (signed long int)this->still_mode;

    else
      if(option == 3)
        return (signed long int)(0x1001 + 3);

      else
      {
        signed long int return_value;
        return_value=this->orig_metronom->get_option(this->orig_metronom, option);
        return return_value;
      }
}

// get_ovl_manager
// file xine/osd_manager.c line 141
struct video_overlay_manager_s$1 * get_ovl_manager(struct osd_manager_impl_s *this)
{
  acquire_ticket(this);
  struct video_overlay_manager_s$1 *ovl_manager;
  ovl_manager=this->stream->video_out->get_overlay_manager(this->stream->video_out);
  if(ovl_manager == ((struct video_overlay_manager_s$1 *)NULL))
  {
    if(iSysLogLevel >= 2)
      x_syslog(6, log_module_input_osd, "Stream has no overlay manager !");

    return (struct video_overlay_manager_s$1 *)(void *)0;
  }

  else
    return ovl_manager;
}

// got_audio_samples
// file xine/xvdr_metronom.c line 143
static signed long int got_audio_samples(struct metronom_s *metronom, signed long int pts, signed int nsamples)
{
  struct xvdr_metronom_s$0 *this = (struct xvdr_metronom_s$0 *)metronom;
  pthread_mutex_lock(&this->mutex);
  _Bool tmp_if_expr$2;
  signed long int return_value_absdiff$1;
  signed long int return_value_absdiff$3;
  unsigned long int return_value_elapsed$4;
  if(!(this->buffering == 0))
  {
    if(!(pts == 0l))
    {
      if(!(this->aud_pts == 0l))
      {
        if(!(pts >= this->aud_pts))
          tmp_if_expr$2 = (_Bool)1;

        else
        {
          return_value_absdiff$1=absdiff(pts, this->aud_pts);
          tmp_if_expr$2 = return_value_absdiff$1 > (signed long int)(5 * 90000) ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$2)
        {
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, "[metronom ] ", "audio jump resetted video pts");

          while((_Bool)0);
          this->vid_pts = (signed long int)0;
        }

      }

      if(!(this->aud_pts == 0l))
      {
        if(!(this->vid_pts == 0l))
        {
          return_value_absdiff$3=absdiff(this->vid_pts, this->aud_pts);
          if(return_value_absdiff$3 >= 450001l)
          {
            do
              if(iSysLogLevel >= 2)
                x_syslog(6, "[metronom ] ", "buffering: A-V diff resetted video pts");

            while((_Bool)0);
            this->vid_pts = (signed long int)0;
          }

        }

      }

      if(this->aud_pts == 0l)
      {
        do
          if(iSysLogLevel >= 2)
          {
            return_value_elapsed$4=elapsed$link1(this->buffering_start_time);
            x_syslog(6, "[metronom ] ", "got audio pts (@%d ms)", (signed int)return_value_elapsed$4);
          }

        while((_Bool)0);
        this->first_frame_seen_time=time_ms$link1();
      }

      this->aud_pts = pts;
    }

    if(pts == 0l)
    {
      if(this->aud_pts == 0l)
        do
          if(iSysLogLevel >= 2)
            x_syslog(6, "[metronom ] ", "got audio, pts 0, buffering");

        while((_Bool)0);

    }

    check_buffering_done(this);
  }

  pthread_mutex_unlock(&this->mutex);
  signed long int return_value;
  return_value=this->orig_metronom->got_audio_samples(this->orig_metronom, pts, nsamples);
  return return_value;
}

// got_spu_packet
// file xine/xvdr_metronom.c line 186
static signed long int got_spu_packet(struct metronom_s *metronom, signed long int pts)
{
  struct xvdr_metronom_s$0 *this = (struct xvdr_metronom_s$0 *)metronom;
  signed long int return_value;
  return_value=this->orig_metronom->got_spu_packet(this->orig_metronom, pts);
  return return_value;
}

// got_video_frame
// file xine/xvdr_metronom.c line 79
static void got_video_frame(struct metronom_s *metronom, struct vo_frame_s$0 *frame)
{
  struct xvdr_metronom_s$0 *this = (struct xvdr_metronom_s$0 *)metronom;
  signed long int pts = frame->pts;
  signed int tmp_post$1;
  signed long int return_value_absdiff$2;
  signed long int return_value_absdiff$3;
  unsigned long int return_value_elapsed$4;
  if(!(metronom->got_video_frame == got_video_frame))
  {
    tmp_post$1 = warnings;
    warnings = warnings + 1;
    if(tmp_post$1 == 0)
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, "[metronom ] ", "got_video_frame: invalid object");

      while((_Bool)0);

  }

  else
  {
    warnings = 0;
    if(!(this->still_mode == 0))
    {
      do
        if(iSysLogLevel >= 4)
          x_syslog(7, "[metronom ] ", "Still frame, type %d", frame->picture_coding_type);

      while((_Bool)0);
      frame->pts = (signed long int)0;
    }

    if(!(this->trickspeed == 0))
    {
      frame->pts = (signed long int)0;
      frame->duration = frame->duration * 12;
    }

    pthread_mutex_lock(&this->mutex);
    if(!(this->buffering == 0))
    {
      if(frame->bad_frame == 0)
      {
        if(!(pts == 0l))
        {
          if(!(this->vid_pts == 0l))
          {
            return_value_absdiff$2=absdiff(this->vid_pts, pts);
            if(return_value_absdiff$2 >= 450001l)
            {
              do
                if(iSysLogLevel >= 2)
                  x_syslog(6, "[metronom ] ", "buffering: video jump resetted audio pts");

              while((_Bool)0);
              this->aud_pts = (signed long int)0;
            }

          }

          if(!(this->vid_pts == 0l))
          {
            if(!(this->aud_pts == 0l))
            {
              return_value_absdiff$3=absdiff(this->vid_pts, this->aud_pts);
              if(return_value_absdiff$3 >= 450001l)
              {
                do
                  if(iSysLogLevel >= 2)
                    x_syslog(6, "[metronom ] ", "buffering: A-V diff resetted audio pts");

                while((_Bool)0);
                this->aud_pts = (signed long int)0;
              }

            }

          }

          if(this->vid_pts == 0l)
          {
            do
              if(iSysLogLevel >= 2)
              {
                return_value_elapsed$4=elapsed$link1(this->buffering_start_time);
                x_syslog(6, "[metronom ] ", "got video pts, frame type %d (@%d ms)", frame->picture_coding_type, (signed int)return_value_elapsed$4);
              }

            while((_Bool)0);
            this->first_frame_seen_time=time_ms$link1();
          }

          this->vid_pts = pts;
        }

        if(pts == 0l)
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, "[metronom ] ", "got video, pts 0, buffering, frame type %d, bad_frame %d", frame->picture_coding_type, frame->bad_frame);

          while((_Bool)0);

        if(!(pts == 0l))
        {
          if(frame->pts == 0l)
            do
              if(iSysLogLevel >= 2)
                x_syslog(6, "[metronom ] ", "*** ERROR: hiding video pts while buffering ***");

            while((_Bool)0);

        }

        check_buffering_done(this);
      }

    }

    pthread_mutex_unlock(&this->mutex);
    if(!(this->orig_metronom == ((struct metronom_s *)NULL)))
      this->orig_metronom->got_video_frame(this->orig_metronom, frame);

    frame->pts = pts;
  }
}

// h264_get_picture_type
// file tools/h264.h line 55
signed int h264_get_picture_type(const unsigned char *buf, signed int len)
{
  signed int i = 0;
  for( ; !(i >= len + -5); i = i + 1)
    if(*((const unsigned int *)(buf + (signed long int)i)) == 0x09010000U)
    {
      unsigned char type = (unsigned char)((signed int)buf[(signed long int)(i + 4)] >> 5);
      switch((signed int)type)
      {
        case 0:

        case 3:

        case 5:
          return 1;
        case 1:

        case 4:

        case 6:
          return 2;
        case 2:

        case 7:
          return 3;
        default:
          ;
      }
    }

  return 0;
}

// h264_get_video_size
// file tools/h264.h line 60
signed int h264_get_video_size(const unsigned char *buf, signed int len, struct video_size_s *size)
{
  signed int i;
  signed int return_value_h264_get_picture_type$1;
  return_value_h264_get_picture_type$1=h264_get_picture_type(buf, len);
  if(!(return_value_h264_get_picture_type$1 == 1))
    return 0;

  else
  {
    i = 5;
    for( ; !(i >= len + -4); i = i + 1)
      if((signed int)buf[(signed long int)i] == 0)
      {
        if((signed int)buf[(signed long int)(1 + i)] == 0)
        {
          if((signed int)buf[(signed long int)(2 + i)] == 1)
          {
            if((0x1f & (signed int)buf[(signed long int)(3 + i)]) == 0x07)
            {
              const signed long int i$array_size0 = (signed long int)len;
              unsigned char nal_data[i$array_size0];
              signed int nal_len;
              do
                if(iSysLogLevel >= 3)
                  x_syslog(7, "[h264     ] ", "H.264: Found NAL SPS at offset %d/%d", i, len);

              while((_Bool)0);
              nal_len=h264_nal_unescape(nal_data, buf + (signed long int)i + (signed long int)4, (len - i) - 4);
              if(nal_len >= 1)
              {
                struct anonymous$16 sps = { .width=(unsigned short int)0, .height=0, .pixel_aspect={ .num=0, .den=0 } };
                signed int return_value_h264_parse_sps$2;
                return_value_h264_parse_sps$2=h264_parse_sps(nal_data, nal_len, &sps);
                if(!(return_value_h264_parse_sps$2 == 0))
                {
                  size->width = sps.width;
                  size->height = sps.height;
                  memcpy$link6((void *)&size->pixel_aspect, (const void *)&sps.pixel_aspect, sizeof(struct mpeg_rational_s) /*8ul*/ );
                  return 1;
                }

                do
                  if(iSysLogLevel >= 2)
                    x_syslog(6, "[h264     ] ", "h264_get_video_size: not enough data ?");

                while((_Bool)0);
              }

            }

          }

        }

      }

    return 0;
  }
}

// h264_nal_unescape
// file tools/h264.c line 145
static signed int h264_nal_unescape(unsigned char *dst, const unsigned char *src, signed int len)
{
  signed int s = 0;
  signed int d = 0;
  signed int tmp_post$1;
  signed int tmp_post$2;
  for( ; !(s >= len); dst[(signed long int)tmp_post$1] = src[(signed long int)tmp_post$2])
  {
    if(src[(signed long int)s] == 0)
    {
      if(src[(signed long int)(1 + s)] == 0)
      {
        dst[(signed long int)(d + 1)] = (unsigned char)0;
        dst[(signed long int)d] = dst[(signed long int)(d + 1)];
        s = s + 2;
        d = d + 2;
        if((signed int)src[(signed long int)s] == 3)
        {
          s = s + 1;
          if(s >= len)
            return d;

        }

      }

    }

    tmp_post$1 = d;
    d = d + 1;
    tmp_post$2 = s;
    s = s + 1;
  }
  return d;
}

// h264_parse_sps
// file tools/h264.c line 26
signed int h264_parse_sps(const unsigned char *buf, signed int len, struct anonymous$16 *sps)
{
  struct anonymous$15 br = { .data=buf, .count=8 * len, .index=0 };
  signed int profile_idc;
  signed int pic_order_cnt_type;
  signed int frame_mbs_only;
  signed int i;
  signed int j;
  unsigned int return_value_br_get_bits$1;
  return_value_br_get_bits$1=br_get_bits(&br, (unsigned int)8);
  profile_idc = (signed int)return_value_br_get_bits$1;
  do
    if(iSysLogLevel >= 3)
      x_syslog(7, "[h264     ] ", "H.264 SPS: profile_idc %d", profile_idc);

  while((_Bool)0);
  br_skip_bits(&br, 16);
  br_skip_golomb(&br);
  signed int return_value_br_get_bit$4;
  signed int return_value_br_get_se_golomb$3;
  if(profile_idc >= 100)
  {
    unsigned int return_value_br_get_ue_golomb$2;
    return_value_br_get_ue_golomb$2=br_get_ue_golomb(&br);
    if(return_value_br_get_ue_golomb$2 == 3u)
      br_skip_bits(&br, 1);

    br_skip_golomb(&br);
    br_skip_golomb(&br);
    br_skip_bits(&br, 1);
    signed int return_value_br_get_bit$5;
    return_value_br_get_bit$5=br_get_bit(&br);
    if(!(return_value_br_get_bit$5 == 0))
    {
      i = 0;
      for( ; !(i >= 8); i = i + 1)
      {
        return_value_br_get_bit$4=br_get_bit(&br);
        if(!(return_value_br_get_bit$4 == 0))
        {
          signed int last = 8;
          signed int next = 8;
          signed int size = i < 6 ? 16 : 64;
          j = 0;
          for( ; !(j >= size); j = j + 1)
          {
            if(!(next == 0))
            {
              return_value_br_get_se_golomb$3=br_get_se_golomb(&br);
              next = last + return_value_br_get_se_golomb$3 & 0xff;
            }

            last = (_Bool)next ? next : last;
          }
        }

      }
    }

  }

  br_skip_golomb(&br);
  unsigned int return_value_br_get_ue_golomb$6;
  return_value_br_get_ue_golomb$6=br_get_ue_golomb(&br);
  pic_order_cnt_type = (signed int)return_value_br_get_ue_golomb$6;
  if(pic_order_cnt_type == 0)
    br_skip_golomb(&br);

  else
    if(pic_order_cnt_type == 1)
    {
      br_skip_bits(&br, 1);
      br_skip_golomb(&br);
      br_skip_golomb(&br);
      unsigned int return_value_br_get_ue_golomb$7;
      return_value_br_get_ue_golomb$7=br_get_ue_golomb(&br);
      j = (signed int)return_value_br_get_ue_golomb$7;
      i = 0;
      for( ; !(i >= j); i = i + 1)
        br_skip_golomb(&br);
    }

  br_skip_golomb(&br);
  br_skip_bits(&br, 1);
  unsigned int return_value_br_get_ue_golomb$8;
  return_value_br_get_ue_golomb$8=br_get_ue_golomb(&br);
  sps->width = (unsigned short int)(return_value_br_get_ue_golomb$8 + (unsigned int)1);
  unsigned int return_value_br_get_ue_golomb$9;
  return_value_br_get_ue_golomb$9=br_get_ue_golomb(&br);
  sps->height = (unsigned short int)(return_value_br_get_ue_golomb$9 + (unsigned int)1);
  frame_mbs_only=br_get_bit(&br);
  do
    if(iSysLogLevel >= 3)
      x_syslog(7, "[h264     ] ", "H.264 SPS: pic_width:  %u mbs", (unsigned int)sps->width);

  while((_Bool)0);
  do
    if(iSysLogLevel >= 3)
      x_syslog(7, "[h264     ] ", "H.264 SPS: pic_height: %u mbs", (unsigned int)sps->height);

  while((_Bool)0);
  do
    if(iSysLogLevel >= 3)
      x_syslog(7, "[h264     ] ", "H.264 SPS: frame only flag: %d", frame_mbs_only);

  while((_Bool)0);
  sps->width = sps->width * (unsigned short int)16;
  sps->height = sps->height * (unsigned short int)(16 * (2 - frame_mbs_only));
  signed int return_value_br_get_bit$10;
  if(frame_mbs_only == 0)
  {
    return_value_br_get_bit$10=br_get_bit(&br);
    if(!(return_value_br_get_bit$10 == 0))
      do
        if(iSysLogLevel >= 3)
          x_syslog(7, "[h264     ] ", "H.264 SPS: MBAFF");

      while((_Bool)0);

  }

  br_skip_bits(&br, 1);
  signed int return_value_br_get_bit$11;
  return_value_br_get_bit$11=br_get_bit(&br);
  if(!(return_value_br_get_bit$11 == 0))
  {
    unsigned int crop_left;
    crop_left=br_get_ue_golomb(&br);
    unsigned int crop_right;
    crop_right=br_get_ue_golomb(&br);
    unsigned int crop_top;
    crop_top=br_get_ue_golomb(&br);
    unsigned int crop_bottom;
    crop_bottom=br_get_ue_golomb(&br);
    do
      if(iSysLogLevel >= 3)
        x_syslog(7, "[h264     ] ", "H.264 SPS: cropping %d %d %d %d", crop_left, crop_top, crop_right, crop_bottom);

    while((_Bool)0);
    sps->width = sps->width - (unsigned short int)((unsigned int)2 * (crop_left + crop_right));
    if(!(frame_mbs_only == 0))
      sps->height = sps->height - (unsigned short int)((unsigned int)2 * (crop_top + crop_bottom));

    else
      sps->height = sps->height - (unsigned short int)((unsigned int)4 * (crop_top + crop_bottom));
  }

  sps->pixel_aspect.num = 0;
  signed int return_value_br_get_bit$17;
  return_value_br_get_bit$17=br_get_bit(&br);
  if(!(return_value_br_get_bit$17 == 0))
  {
    signed int return_value_br_get_bit$16;
    return_value_br_get_bit$16=br_get_bit(&br);
    if(!(return_value_br_get_bit$16 == 0))
    {
      unsigned int aspect_ratio_idc;
      aspect_ratio_idc=br_get_bits(&br, (unsigned int)8);
      do
        if(iSysLogLevel >= 3)
          x_syslog(7, "[h264     ] ", "H.264 SPS: aspect_ratio_idc %d", aspect_ratio_idc);

      while((_Bool)0);
      if(aspect_ratio_idc == 255u)
      {
        unsigned int return_value_br_get_bits$12;
        return_value_br_get_bits$12=br_get_bits(&br, (unsigned int)8);
        unsigned int return_value_br_get_bits$13;
        return_value_br_get_bits$13=br_get_bits(&br, (unsigned int)8);
        sps->pixel_aspect.num = (signed int)(return_value_br_get_bits$12 << 8 | return_value_br_get_bits$13);
        unsigned int return_value_br_get_bits$14;
        return_value_br_get_bits$14=br_get_bits(&br, (unsigned int)8);
        unsigned int return_value_br_get_bits$15;
        return_value_br_get_bits$15=br_get_bits(&br, (unsigned int)8);
        sps->pixel_aspect.den = (signed int)(return_value_br_get_bits$14 << 8 | return_value_br_get_bits$15);
        do
          if(iSysLogLevel >= 3)
            x_syslog(7, "[h264     ] ", "H.264 SPS: -> sar %dx%d", sps->pixel_aspect.num, sps->pixel_aspect.den);

        while((_Bool)0);
      }

      else
        if(!((unsigned long int)aspect_ratio_idc >= 17ul))
        {
          static const struct mpeg_rational_s aspect_ratios[17l] = { { .num=0, .den=1 }, { .num=1, .den=1 }, { .num=12, .den=11 }, { .num=10, .den=11 }, { .num=16, .den=11 }, { .num=40, .den=33 }, { .num=24, .den=11 }, { .num=20, .den=11 }, { .num=32, .den=11 }, { .num=80, .den=33 }, { .num=18, .den=11 }, { .num=15, .den=11 }, { .num=64, .den=33 }, { .num=160, .den=99 }, { .num=4, .den=3 }, { .num=3, .den=2 }, { .num=2, .den=1 } };
          memcpy$link6((void *)&sps->pixel_aspect, (const void *)&aspect_ratios[(signed long int)aspect_ratio_idc], sizeof(struct mpeg_rational_s) /*8ul*/ );
          do
            if(iSysLogLevel >= 3)
              x_syslog(7, "[h264     ] ", "H.264 SPS: -> aspect ratio %d / %d", sps->pixel_aspect.num, sps->pixel_aspect.den);

          while((_Bool)0);
        }

        else
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, "[h264     ] ", "H.264 SPS: aspect_ratio_idc out of range !");

          while((_Bool)0);
    }

  }

  do
    if(iSysLogLevel >= 3)
      x_syslog(7, "[h264     ] ", "H.264 SPS: -> video size %dx%d, aspect %d:%d", sps->width, sps->height, sps->pixel_aspect.num, sps->pixel_aspect.den);

  while((_Bool)0);
  if(br.index >= br.count)
  {
    do
      if(iSysLogLevel >= 3)
        x_syslog(7, "[h264     ] ", "H.264 SPS: not enough data ?");

    while((_Bool)0);
    return 0;
  }

  else
    return 1;
}

// handle_audio_discontinuity
// file xine/xvdr_metronom.c line 216
static void handle_audio_discontinuity(struct metronom_s *metronom, signed int type, signed long int disc_off)
{
  struct xvdr_metronom_s$0 *this = (struct xvdr_metronom_s$0 *)metronom;
  start_buffering(this, disc_off);
  this->orig_metronom->handle_audio_discontinuity(this->orig_metronom, type, disc_off);
}

// handle_control_grab
// file xine_input_vdr.c line 2646
static signed int handle_control_grab(struct vdr_input_plugin_s *this, const char *cmd)
{
  signed int quality;
  signed int width;
  signed int height;
  signed int jpeg;
  signed int tmp_statement_expression$1;
  unsigned long int __s1_len;
  unsigned long int __s2_len;
  signed int return_value___builtin_strcmp$2;
  return_value___builtin_strcmp$2=__builtin_strcmp(cmd + (signed long int)5, "JPEG");
  tmp_statement_expression$1 = return_value___builtin_strcmp$2;
  jpeg = (signed int)!(tmp_statement_expression$1 != 0);
  signed int return_value_sscanf$18;
  return_value_sscanf$18=sscanf(cmd + (signed long int)5 + (signed long int)4, "%d %d %d", &quality, &width, &height);
  signed int *return_value___errno_location$3;
  char *return_value_strerror$4;
  void *return_value;
  _Bool tmp_if_expr$16;
  _Bool tmp_if_expr$17;
  signed int *return_value___errno_location$7;
  char *return_value_strerror$8;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  if(return_value_sscanf$18 == 3)
  {
    if(this->fd_control >= 0)
    {
      struct grab_data_s *data = (struct grab_data_s *)(void *)0;
      do
        if(iSysLogLevel >= 3)
          x_syslog(7, log_module_input_vdr, "GRAB: jpeg=%d quality=%d w=%d h=%d", jpeg, quality, width, height);

      while((_Bool)0);
      signed int return_value_pthread_mutex_unlock$6;
      return_value_pthread_mutex_unlock$6=pthread_mutex_unlock(&this->vdr_entry_lock);
      if(!(return_value_pthread_mutex_unlock$6 == 0))
        do
          if(iSysLogLevel >= 1)
          {
            x_syslog(3, log_module_input_vdr, "pthread_mutex_unlock failed");
            signed int *return_value___errno_location$5;
            return_value___errno_location$5=__errno_location();
            if(!(*return_value___errno_location$5 == 0))
            {
              return_value___errno_location$3=__errno_location();
              return_value_strerror$4=strerror(*return_value___errno_location$3);
              x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 2661, return_value_strerror$4);
            }

          }

        while((_Bool)0);

      if(!(this->$anon0.$anon0.funcs.fe_control == ((void * (*)(struct frontend_s *, const char *))NULL)))
      {
        return_value=this->$anon0.$anon0.funcs.fe_control(this->$anon0.$anon0.funcs.fe_handle, cmd);
        data = (struct grab_data_s *)return_value;
      }

      if(!(data == ((struct grab_data_s *)NULL)))
        tmp_if_expr$16 = data->size > (unsigned long int)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$16 = (_Bool)0;
      if(tmp_if_expr$16)
        tmp_if_expr$17 = data->data != ((char *)NULL) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$17 = (_Bool)0;
      if(tmp_if_expr$17)
      {
        char s[128l];
        sprintf(s, "GRAB %d %lu\r\n", this->token, (unsigned long int)data->size);
        signed int return_value_pthread_mutex_lock$15;
        return_value_pthread_mutex_lock$15=pthread_mutex_lock(&this->fd_control_lock);
        if(!(return_value_pthread_mutex_lock$15 == 0))
          do
            if(iSysLogLevel >= 1)
            {
              x_syslog(3, log_module_input_vdr, "pthread_mutex_lock (%s) failed, skipping locked block !", (const void *)"&this->fd_control_lock");
              signed int *return_value___errno_location$9;
              return_value___errno_location$9=__errno_location();
              if(!(*return_value___errno_location$9 == 0))
              {
                return_value___errno_location$7=__errno_location();
                return_value_strerror$8=strerror(*return_value___errno_location$7);
                x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 2669, return_value_strerror$8);
              }

            }

          while((_Bool)0);

        else
          do
          {
            struct anonymous$39 __cancel_buf;
            void (*__cancel_routine)(void *) = mutex_cleanup;
            void *__cancel_arg = (void *)&this->fd_control_lock;
            signed int __not_first_call;
            __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
            if(!((signed long int)__not_first_call == 0l))
            {
              __cancel_routine(__cancel_arg);
              __pthread_unwind_next(&__cancel_buf);
            }

            __pthread_register_cancel(&__cancel_buf);
            do
            {
              unsigned long int return_value_strlen$10;
              return_value_strlen$10=strlen(s);
              write_control_data(this, (const void *)s, return_value_strlen$10);
              write_control_data(this, (const void *)data->data, data->size);
              signed int return_value_pthread_mutex_unlock$14;
              return_value_pthread_mutex_unlock$14=pthread_mutex_unlock(&this->fd_control_lock);
              if(!(return_value_pthread_mutex_unlock$14 == 0))
                do
                  if(iSysLogLevel >= 1)
                  {
                    x_syslog(3, log_module_input_vdr, "pthread_mutex_unlock (%s) failed !", (const void *)"&this->fd_control_lock");
                    signed int *return_value___errno_location$13;
                    return_value___errno_location$13=__errno_location();
                    if(!(*return_value___errno_location$13 == 0))
                    {
                      return_value___errno_location$11=__errno_location();
                      return_value_strerror$12=strerror(*return_value___errno_location$11);
                      x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 2672, return_value_strerror$12);
                    }

                  }

                while((_Bool)0);


            __CPROVER_DUMP_L21:
              ;
            }
            while((_Bool)0);
            __pthread_unregister_cancel(&__cancel_buf);
          }
          while((_Bool)0);
      }

      else
        printf_control(this, "GRAB %d 0\r\n", this->token);
      pthread_mutex_lock(&this->vdr_entry_lock);
      if(!(data == ((struct grab_data_s *)NULL)))
      {
        free((void *)data->data);
        free((void *)data);
      }

      return 0;
    }

  }

  return -2;
}

// handle_control_osdcmd
// file xine_input_vdr.c line 2734
static signed int handle_control_osdcmd(struct vdr_input_plugin_s *this)
{
  struct osd_command_s osdcmd = { .size=(unsigned char)0, .cmd=0, .wnd=0, .layer=0,
    .pts=0l, .delay_ms=0u, .x=0, .y=0,
    .w=0, .h=0, .datalen=0u, .num_rle=0u, .$anon0={ .data=((struct osd_rle_elem_s *)NULL) },
    .colors=0u,
    .$anon1={ .palette=((struct osd_clut_s *)NULL) }, .dirty_area={ .x1=0, .y1=0, .x2=0, .y2=0 },
    .flags=0,
    .scaling=0 };
  signed int err = 0;
  unsigned short int tmp_statement_expression$6;
  unsigned short int tmp_statement_expression$7;
  unsigned short int tmp_statement_expression$8;
  unsigned short int tmp_statement_expression$9;
  unsigned short int tmp_statement_expression$10;
  unsigned short int tmp_statement_expression$11;
  unsigned short int tmp_statement_expression$12;
  unsigned short int tmp_statement_expression$13;
  if(this->control_running == 0)
    return -3;

  else
  {
    unsigned long int todo;
    unsigned long int expect = sizeof(struct osd_command_s) /*62ul*/ ;
    unsigned char *pt = (unsigned char *)&osdcmd;
    signed long int return_value_read_control$1;
    return_value_read_control$1=read_control(this, pt, sizeof(unsigned char) /*1ul*/ );
    if(!((unsigned long int)return_value_read_control$1 == sizeof(unsigned char) /*1ul*/ ))
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "control: error reading OSDCMD data length");

      while((_Bool)0);
      return -3;
    }

    else
    {
      pt = pt + (signed long int)sizeof(unsigned char) /*1ul*/ ;
      expect = expect - sizeof(unsigned char) /*1ul*/ ;
      todo = (unsigned long int)osdcmd.size - sizeof(unsigned char) /*1ul*/ ;
      signed long int bytes = (signed long int)(todo < expect ? todo : expect);
      signed long int return_value_read_control$2;
      return_value_read_control$2=read_control(this, pt, (unsigned long int)bytes);
      if(!(return_value_read_control$2 == bytes))
      {
        do
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "control: error reading OSDCMD data");

        while((_Bool)0);
        return -3;
      }

      else
      {
        if(!(expect >= todo))
        {
          signed long int skip = (signed long int)(todo - expect);
          const signed long int skip$array_size0 = skip;
          unsigned char dummy[skip$array_size0];
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_input_vdr, "osd_command_t size %d, expected %zu", osdcmd.size, expect);

          while((_Bool)0);
          signed long int return_value_read_control$3;
          return_value_read_control$3=read_control(this, dummy, (unsigned long int)skip);
          if(!(return_value_read_control$3 == skip))
          {
            do
              if(iSysLogLevel >= 2)
                x_syslog(6, log_module_input_vdr, "control: error reading OSDCMD data (unknown part)");

            while((_Bool)0);
            return -3;
          }

        }

        do
        {
          unsigned int return_value___bswap_32$4;
          return_value___bswap_32$4=__bswap_32((unsigned int)((unsigned long int)osdcmd.pts >> 32));
          unsigned int return_value___bswap_32$5;
          return_value___bswap_32$5=__bswap_32((unsigned int)(unsigned long int)osdcmd.pts);
          osdcmd.pts = (signed long int)((unsigned long int)return_value___bswap_32$4 | (unsigned long int)return_value___bswap_32$5 << 32);
          osdcmd.delay_ms=__bswap_32(osdcmd.delay_ms);
          unsigned short int __v;
          unsigned short int __x = (unsigned short int)osdcmd.x;
          asm("rorw $8, %w0" : "=r"(__v) : "0"(__x) : "cc");
          tmp_statement_expression$6 = __v;
          osdcmd.x = tmp_statement_expression$6;
          unsigned short int handle_control_osdcmd$$1$$4$$2$$__v;
          unsigned short int handle_control_osdcmd$$1$$4$$2$$__x = (unsigned short int)osdcmd.y;
          asm("rorw $8, %w0" : "=r"(handle_control_osdcmd$$1$$4$$2$$__v) : "0"(handle_control_osdcmd$$1$$4$$2$$__x) : "cc");
          tmp_statement_expression$7 = handle_control_osdcmd$$1$$4$$2$$__v;
          osdcmd.y = tmp_statement_expression$7;
          unsigned short int handle_control_osdcmd$$1$$4$$3$$__v;
          unsigned short int handle_control_osdcmd$$1$$4$$3$$__x = (unsigned short int)osdcmd.w;
          asm("rorw $8, %w0" : "=r"(handle_control_osdcmd$$1$$4$$3$$__v) : "0"(handle_control_osdcmd$$1$$4$$3$$__x) : "cc");
          tmp_statement_expression$8 = handle_control_osdcmd$$1$$4$$3$$__v;
          osdcmd.w = tmp_statement_expression$8;
          unsigned short int handle_control_osdcmd$$1$$4$$4$$__v;
          unsigned short int handle_control_osdcmd$$1$$4$$4$$__x = (unsigned short int)osdcmd.h;
          asm("rorw $8, %w0" : "=r"(handle_control_osdcmd$$1$$4$$4$$__v) : "0"(handle_control_osdcmd$$1$$4$$4$$__x) : "cc");
          tmp_statement_expression$9 = handle_control_osdcmd$$1$$4$$4$$__v;
          osdcmd.h = tmp_statement_expression$9;
          osdcmd.datalen=__bswap_32(osdcmd.datalen);
          osdcmd.num_rle=__bswap_32(osdcmd.num_rle);
          osdcmd.colors=__bswap_32(osdcmd.colors);
          unsigned short int handle_control_osdcmd$$1$$4$$5$$__v;
          unsigned short int handle_control_osdcmd$$1$$4$$5$$__x = (unsigned short int)osdcmd.dirty_area.x1;
          asm("rorw $8, %w0" : "=r"(handle_control_osdcmd$$1$$4$$5$$__v) : "0"(handle_control_osdcmd$$1$$4$$5$$__x) : "cc");
          tmp_statement_expression$10 = handle_control_osdcmd$$1$$4$$5$$__v;
          osdcmd.dirty_area.x1 = tmp_statement_expression$10;
          unsigned short int handle_control_osdcmd$$1$$4$$6$$__v;
          unsigned short int handle_control_osdcmd$$1$$4$$6$$__x = (unsigned short int)osdcmd.dirty_area.y1;
          asm("rorw $8, %w0" : "=r"(handle_control_osdcmd$$1$$4$$6$$__v) : "0"(handle_control_osdcmd$$1$$4$$6$$__x) : "cc");
          tmp_statement_expression$11 = handle_control_osdcmd$$1$$4$$6$$__v;
          osdcmd.dirty_area.y1 = tmp_statement_expression$11;
          unsigned short int handle_control_osdcmd$$1$$4$$7$$__v;
          unsigned short int handle_control_osdcmd$$1$$4$$7$$__x = (unsigned short int)osdcmd.dirty_area.x2;
          asm("rorw $8, %w0" : "=r"(handle_control_osdcmd$$1$$4$$7$$__v) : "0"(handle_control_osdcmd$$1$$4$$7$$__x) : "cc");
          tmp_statement_expression$12 = handle_control_osdcmd$$1$$4$$7$$__v;
          osdcmd.dirty_area.x2 = tmp_statement_expression$12;
          unsigned short int handle_control_osdcmd$$1$$4$$8$$__v;
          unsigned short int handle_control_osdcmd$$1$$4$$8$$__x = (unsigned short int)osdcmd.dirty_area.y2;
          asm("rorw $8, %w0" : "=r"(handle_control_osdcmd$$1$$4$$8$$__v) : "0"(handle_control_osdcmd$$1$$4$$8$$__x) : "cc");
          tmp_statement_expression$13 = handle_control_osdcmd$$1$$4$$8$$__v;
          osdcmd.dirty_area.y2 = tmp_statement_expression$13;
        }
        while((_Bool)0);
        if(osdcmd.colors >= 1u && !(osdcmd.$anon1.palette == ((struct osd_clut_s *)NULL)))
        {
          signed long int handle_control_osdcmd$$1$$5$$bytes = (signed long int)(sizeof(struct osd_clut_s) /*4ul*/  * (unsigned long int)osdcmd.colors);
          void *return_value_malloc$14;
          return_value_malloc$14=malloc((unsigned long int)handle_control_osdcmd$$1$$5$$bytes);
          osdcmd.$anon1.palette = (struct osd_clut_s *)return_value_malloc$14;
          signed long int return_value_read_control$15;
          return_value_read_control$15=read_control(this, (unsigned char *)osdcmd.$anon1.palette, (unsigned long int)handle_control_osdcmd$$1$$5$$bytes);
          if(!(return_value_read_control$15 == handle_control_osdcmd$$1$$5$$bytes))
          {
            do
              if(iSysLogLevel >= 2)
                x_syslog(6, log_module_input_vdr, "control: error reading OSDCMD palette");

            while((_Bool)0);
            err = -3;
          }

        }

        else
          osdcmd.$anon1.palette = (struct osd_clut_s *)(void *)0;
        if(err == 0 && osdcmd.datalen >= 1u && !(osdcmd.$anon0.data == ((struct osd_rle_elem_s *)NULL)))
        {
          void *return_value_malloc$16;
          return_value_malloc$16=malloc((unsigned long int)osdcmd.datalen);
          osdcmd.$anon0.data = (struct osd_rle_elem_s *)return_value_malloc$16;
          signed long int return_value_read_control$17;
          return_value_read_control$17=read_control(this, (unsigned char *)osdcmd.$anon0.data, (unsigned long int)osdcmd.datalen);
          if(!(return_value_read_control$17 == (signed long int)osdcmd.datalen))
          {
            do
              if(iSysLogLevel >= 2)
                x_syslog(6, log_module_input_vdr, "control: error reading OSDCMD bitmap");

            while((_Bool)0);
            err = -3;
          }

          else
            if((signed int)osdcmd.cmd == 10)
            {
              unsigned char *handle_control_osdcmd$$1$$7$$2$$1$$raw = osdcmd.$anon0.raw_data;
              signed int n;
              n=rle_uncompress_hdmv(&osdcmd.$anon0.data, (unsigned int)osdcmd.w, (unsigned int)osdcmd.h, handle_control_osdcmd$$1$$7$$2$$1$$raw, osdcmd.num_rle, (unsigned long int)osdcmd.datalen);
              if(!(n >= 1))
              {
                do
                  if(iSysLogLevel >= 2)
                    x_syslog(6, log_module_input_vdr, "HDMV mode OSD uncompress error");

                while((_Bool)0);
                osdcmd.$anon0.raw_data = handle_control_osdcmd$$1$$7$$2$$1$$raw;
              }

              else
              {
                osdcmd.cmd = (unsigned char)2;
                osdcmd.datalen = osdcmd.num_rle * (unsigned int)4;
                free((void *)handle_control_osdcmd$$1$$7$$2$$1$$raw);
              }
            }

            else
              if((signed int)osdcmd.cmd == 2)
              {
                unsigned char *raw = osdcmd.$anon0.raw_data;
                osdcmd.$anon0.data=uncompress_osd_net(raw, (signed int)osdcmd.num_rle, (signed int)osdcmd.datalen);
                osdcmd.datalen = osdcmd.num_rle * (unsigned int)4;
                free((void *)raw);
              }

        }

        else
          osdcmd.$anon0.data = (struct osd_rle_elem_s *)(void *)0;
        if(err == 0)
          err=vdr_plugin_exec_osd_command(&this->$anon0.iface, &osdcmd);

        free((void *)osdcmd.$anon0.data);
        free((void *)osdcmd.$anon1.palette);
        return err;
      }
    }
  }
}

// handle_control_playfile
// file xine_input_vdr.c line 2395
static signed int handle_control_playfile(struct vdr_input_plugin_s *this, const char *cmd)
{
  const char *pt = cmd + (signed long int)9;
  char filename[4096l];
  char av[4352l];
  char *pav = av;
  signed int loop = 0;
  signed int pos = 0;
  signed int err = 0;
  signed int avsize = (signed int)(sizeof(char [4352l]) /*4352ul*/  - (unsigned long int)2);
  signed int mix_streams = 0;
  for( ; (signed int)*pt == 32; pt = pt + 1l)
    ;
  signed int return_value_strncmp$1;
  return_value_strncmp$1=strncmp(pt, "Loop ", (unsigned long int)5);
  if(return_value_strncmp$1 == 0)
  {
    loop = 1;
    pt = pt + (signed long int)5;
    for( ; (signed int)*pt == 32; pt = pt + 1l)
      ;
  }

  pos=atoi(pt);
  for( ; !(*pt == 0); pt = pt + 1l)
    if((signed int)*pt == 32)
      break;

  for( ; (signed int)*pt == 32; pt = pt + 1l)
    ;
  char *tmp_post$2;
  const char *tmp_post$3;
  for( ; !(*pt == 0); *tmp_post$2 = *tmp_post$3)
  {
    if((signed int)*pt == 32)
      break;

    avsize = avsize - 1;
    if(avsize == 0)
      break;

    tmp_post$2 = pav;
    pav = pav + 1l;
    tmp_post$3 = pt;
    pt = pt + 1l;
  }
  *pav = (char)0;
  for( ; (signed int)*pt == 32; pt = pt + 1l)
    ;
  signed int tmp_statement_expression$4;
  unsigned long int handle_control_playfile$$1$$3$$__s1_len;
  unsigned long int handle_control_playfile$$1$$3$$__s2_len;
  signed int return_value___builtin_strcmp$5;
  return_value___builtin_strcmp$5=__builtin_strcmp(av, "Audio");
  tmp_statement_expression$4 = return_value___builtin_strcmp$5;
  _Bool tmp_if_expr$8;
  signed int tmp_statement_expression$6;
  if(tmp_statement_expression$4 == 0)
    tmp_if_expr$8 = (_Bool)1;

  else
  {
    unsigned long int handle_control_playfile$$1$$4$$__s1_len;
    unsigned long int handle_control_playfile$$1$$4$$__s2_len;
    signed int return_value___builtin_strcmp$7;
    return_value___builtin_strcmp$7=__builtin_strcmp(av, "Video");
    tmp_statement_expression$6 = return_value___builtin_strcmp$7;
    tmp_if_expr$8 = !(tmp_statement_expression$6 != 0) ? (_Bool)1 : (_Bool)0;
  }
  mix_streams = (signed int)tmp_if_expr$8;
  strn0cpy(filename, pt, (signed int)sizeof(char [4096l]) /*4096ul*/ );
  this->autoplay_size = -1;
  signed int tmp_if_expr$14;
  signed int return_value_atoi$13;
  _Bool tmp_if_expr$29;
  _Bool tmp_if_expr$21;
  signed int *return_value___errno_location$20;
  signed int *return_value___errno_location$16;
  char *return_value_strerror$17;
  _Bool tmp_if_expr$27;
  signed int *return_value___errno_location$26;
  signed int *return_value___errno_location$22;
  char *return_value_strerror$23;
  signed int tmp_statement_expression$31;
  signed int tmp_if_expr$33;
  signed int *return_value___errno_location$36;
  char *return_value_strerror$37;
  signed int return_value;
  char *tmp_if_expr$40;
  signed int return_value_strncmp$49;
  _Bool tmp_if_expr$48;
  signed int return_value_xine_play$47;
  _Bool tmp_if_expr$45;
  signed int return_value_xine_play$44;
  _Bool tmp_if_expr$52;
  _Bool tmp_if_expr$55;
  signed int tmp_statement_expression$53;
  char *tmp_post$50;
  if(!(filename[0l] == 0))
  {
    signed int is_file_mrl;
    signed int return_value_strncmp$9;
    return_value_strncmp$9=strncmp(filename, "file:/", (unsigned long int)6);
    is_file_mrl = !(return_value_strncmp$9 != 0) ? 5 : 0;
    this->loop_play = (unsigned char)0;
    char mrlbase[256l];
    if(this->fd_control >= 0)
    {
      char *host;
      char *return_value_strstr$10;
      return_value_strstr$10=strstr(this->mrl, "//");
      char *return_value___strdup$11;
      return_value___strdup$11=__strdup(return_value_strstr$10 + (signed long int)2);
      host = return_value___strdup$11;
      char *port;
      char *return_value___builtin_strchr$12;
      return_value___builtin_strchr$12=__builtin_strchr(host, 58);
      port = return_value___builtin_strchr$12;
      signed int iport;
      if(!(port == ((char *)NULL)))
      {
        return_value_atoi$13=atoi(port + (signed long int)1);
        tmp_if_expr$14 = return_value_atoi$13;
      }

      else
        tmp_if_expr$14 = 37890;
      iport = tmp_if_expr$14;
      if(!(port == ((char *)NULL)))
        *port = (char)0;

      snprintf(mrlbase, sizeof(char [256l]) /*256ul*/ , "http://%s:%d/PLAYFILE", (_Bool)host ? host : "127.0.0.1", iport);
      free((void *)host);
    }

    if(!(this->slave.stream == ((struct xine_stream_s *)NULL)))
      handle_control_playfile(this, "PLAYFILE 0");

    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_vdr, "PLAYFILE  (Loop: %d, Offset: %ds, File: %s %s)", loop, pos, (const void *)av, (const void *)filename);

    while((_Bool)0);
    if(!(is_file_mrl == 0))
      tmp_if_expr$29 = (_Bool)1;

    else
      tmp_if_expr$29 = (signed int)filename[(signed long int)0] == 47 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$29)
    {
      struct stat st;
      char *f;
      f=unescape_filename(filename);
      signed int *return_value___errno_location$15;
      return_value___errno_location$15=__errno_location();
      *return_value___errno_location$15 = 0;
      signed int return_value_stat$28;
      return_value_stat$28=stat(f + (signed long int)is_file_mrl, &st);
      if(!(return_value_stat$28 == 0))
      {
        signed int *return_value___errno_location$19;
        return_value___errno_location$19=__errno_location();
        if(*return_value___errno_location$19 == 13)
          tmp_if_expr$21 = (_Bool)1;

        else
        {
          return_value___errno_location$20=__errno_location();
          tmp_if_expr$21 = *return_value___errno_location$20 == 40 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$21)
          do
            if(iSysLogLevel >= 1)
            {
              x_syslog(3, log_module_input_vdr, "Can't access file !");
              signed int *return_value___errno_location$18;
              return_value___errno_location$18=__errno_location();
              if(!(*return_value___errno_location$18 == 0))
              {
                return_value___errno_location$16=__errno_location();
                return_value_strerror$17=strerror(*return_value___errno_location$16);
                x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 2454, return_value_strerror$17);
              }

            }

          while((_Bool)0);

        signed int *return_value___errno_location$25;
        return_value___errno_location$25=__errno_location();
        if(*return_value___errno_location$25 == 2)
          tmp_if_expr$27 = (_Bool)1;

        else
        {
          return_value___errno_location$26=__errno_location();
          tmp_if_expr$27 = *return_value___errno_location$26 == 20 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$27)
          do
            if(iSysLogLevel >= 1)
            {
              x_syslog(3, log_module_input_vdr, "File not found !");
              signed int *return_value___errno_location$24;
              return_value___errno_location$24=__errno_location();
              if(!(*return_value___errno_location$24 == 0))
              {
                return_value___errno_location$22=__errno_location();
                return_value_strerror$23=strerror(*return_value___errno_location$22);
                x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 2456, return_value_strerror$23);
              }

            }

          while((_Bool)0);

        if(this->fd_control >= 0)
        {
          char mrl[4352l];
          char *sub;
          sub=strstr(filename, "#subtitle:");
          if(!(sub == ((char *)NULL)))
            *sub = (char)0;

          sprintf(mrl, "%s%s", (const void *)mrlbase, filename + (signed long int)is_file_mrl);
          if(!(sub == ((char *)NULL)))
          {
            sub = sub + (signed long int)10;
            strcat(mrl, "#subtitle:");
            strcat(mrl, mrlbase);
            strcat(mrl, sub);
          }

          do
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_input_vdr, "  -> trying to stream from server (%s) ...", (const void *)mrl);

          while((_Bool)0);
          strn0cpy(filename, mrl, (signed int)sizeof(char [4096l]) /*4096ul*/ );
        }

      }

      free((void *)f);
    }

    unsigned long int handle_control_playfile$$1$$5$$5$$__s1_len;
    unsigned long int handle_control_playfile$$1$$5$$5$$__s2_len;
    signed int return_value___builtin_strcmp$32;
    return_value___builtin_strcmp$32=__builtin_strcmp(filename, "dvd:/");
    tmp_statement_expression$31 = return_value___builtin_strcmp$32;
    if(tmp_statement_expression$31 == 0)
    {
      struct xine_cfg_entry_s device;
      signed int return_value_xine_config_lookup_entry$30;
      return_value_xine_config_lookup_entry$30=xine_config_lookup_entry(this->class->xine, "media.dvd.device", &device);
      if(!(return_value_xine_config_lookup_entry$30 == 0))
        dvd_set_speed(device.str_value, 2700);

    }

    if(this->slave.stream == ((struct xine_stream_s *)NULL))
    {
      struct cfg_entry_s *e;
      e=this->class->xine->config->lookup_entry(this->class->xine->config, "engine.buffers.video_num_buffers");
      signed int vbufs;
      if(!(e == ((struct cfg_entry_s *)NULL)))
        tmp_if_expr$33 = e->num_value;

      else
        tmp_if_expr$33 = 250;
      vbufs = tmp_if_expr$33;
      this->class->xine->config->update_num(this->class->xine->config, "engine.buffers.video_num_buffers", 1000);
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_vdr, "xine_stream_new(slave_stream): using %dMB video fifo", (1000 * 8) / 1024);

      this->slave.stream=xine_stream_new(this->class->xine, this->stream->audio_out, this->stream->video_out);
      this->class->xine->config->update_num(this->class->xine->config, "engine.buffers.video_num_buffers", vbufs);
    }

    if(this->slave.event_queue == ((struct xine_event_queue_s *)NULL))
    {
      this->slave.event_queue=xine_event_new_queue(this->slave.stream);
      xine_event_create_listener_thread(this->slave.event_queue, vdr_event_cb, (void *)this);
    }

    select_spu_channel(this->slave.stream, -1);
    this->dvd_menu = (unsigned char)0;
    signed int *return_value___errno_location$34;
    return_value___errno_location$34=__errno_location();
    *return_value___errno_location$34 = 0;
    signed int return_value_xine_open$35;
    return_value_xine_open$35=xine_open(this->slave.stream, filename);
    err = (signed int)!(return_value_xine_open$35 != 0);
    if(!(err == 0))
    {
      do
        if(iSysLogLevel >= 1)
        {
          x_syslog(3, log_module_input_vdr, "Error opening file ! (File not found ? Unknown format ?)");
          signed int *return_value___errno_location$38;
          return_value___errno_location$38=__errno_location();
          if(!(*return_value___errno_location$38 == 0))
          {
            return_value___errno_location$36=__errno_location();
            return_value_strerror$37=strerror(*return_value___errno_location$36);
            x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 2522, return_value_strerror$37);
          }

        }

      while((_Bool)0);
      filename[0l] = (char)0;
    }

    else
    {
      signed int return_value_1;
      return_value_1=this->stream->video_fifo->size(this->stream->video_fifo);
      if(!(return_value_1 == 0))
      {
        if(iSysLogLevel >= 2)
        {
          return_value=this->stream->video_fifo->size(this->stream->video_fifo);
          x_syslog(6, log_module_input_vdr, "playfile: main stream video_fifo not empty ! (%d)", return_value);
        }

      }

      _x_demux_control_start(this->stream);
      xine_usec_sleep((unsigned int)(50 * 1000));
      pthread_mutex_lock(&this->lock);
      reset_trick_speed(this);
      this->live_mode = (unsigned char)1;
      set_live_mode(this, 0);
      reset_trick_speed(this);
      reset_scr_tuning(this);
      pthread_mutex_unlock(&this->lock);
      this->slave.stream->metronom->set_option(this->slave.stream->metronom, 7, (signed long int)90000);
      this->loop_play = (unsigned char)loop;
      signed int return_value_xine_play$39;
      return_value_xine_play$39=xine_play(this->slave.stream, 0, 1000 * pos);
      err = (signed int)!(return_value_xine_play$39 != 0);
      if(!(err == 0))
      {
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "Error playing file");

        filename[0l] = (char)0;
      }

      else
      {
        send_meta_info(this);
        if(!(this->$anon0.$anon0.funcs.fe_control == ((void * (*)(struct frontend_s *, const char *))NULL)))
        {
          char tmp[128l];
          signed int has_video;
          if(!(mix_streams == 0))
            tmp_if_expr$40 = av;

          else
            tmp_if_expr$40 = "";
          sprintf(tmp, "SLAVE 0x%lx %s\r\n", (unsigned long int)this->slave.stream, tmp_if_expr$40);
          this->$anon0.$anon0.funcs.fe_control(this->$anon0.$anon0.funcs.fe_handle, tmp);
          unsigned int return_value__x_stream_info_get$41;
          return_value__x_stream_info_get$41=_x_stream_info_get(this->slave.stream, 18);
          has_video = (signed int)return_value__x_stream_info_get$41;
          if(has_video == 0 && mix_streams == 0)
          {
            if(!(av[0l] == 0))
            {
              return_value_strncmp$49=strncmp(av, "image:", (unsigned long int)6);
              if(return_value_strncmp$49 == 0)
              {
                const char *bgimage = av + (signed long int)6;
                if(this->bg_stream.stream == ((struct xine_stream_s *)NULL))
                {
                  if(iSysLogLevel >= 3)
                    x_syslog(7, log_module_input_vdr, "handle_control_playfile: Background stream init");

                  this->bg_stream.stream=xine_stream_new(this->class->xine, (struct xine_audio_port_s$1 *)(void *)0, this->slave.stream->video_out);
                  xine_set_param(this->bg_stream.stream, 14, 1);
                  xine_set_param(this->bg_stream.stream, 3, -2);
                  xine_set_param(this->bg_stream.stream, 4, -2);
                  xine_set_param(this->bg_stream.stream, 10, 0);
                }

                if(this->bg_stream.event_queue == ((struct xine_event_queue_s *)NULL))
                {
                  if(iSysLogLevel >= 3)
                    x_syslog(7, log_module_input_vdr, "handle_control_playfile: Background event queue init");

                  this->bg_stream.event_queue=xine_event_new_queue(this->bg_stream.stream);
                  xine_event_create_listener_thread(this->bg_stream.event_queue, vdr_event_cb, (void *)this);
                }

                signed int return_value_xine_open$46;
                return_value_xine_open$46=xine_open(this->bg_stream.stream, bgimage);
                if(return_value_xine_open$46 == 0)
                  tmp_if_expr$48 = (_Bool)1;

                else
                {
                  return_value_xine_play$47=xine_play(this->bg_stream.stream, 0, 0);
                  tmp_if_expr$48 = !(return_value_xine_play$47 != 0) ? (_Bool)1 : (_Bool)0;
                }
                if(tmp_if_expr$48)
                {
                  if(iSysLogLevel >= 2)
                    x_syslog(6, log_module_input_vdr, "Error opening background image %s (File not found ? Unknown format ?)", bgimage);

                  signed int is_bg_file_mrl;
                  signed int return_value_strncmp$42;
                  return_value_strncmp$42=strncmp(bgimage, "file:/", (unsigned long int)6);
                  is_bg_file_mrl = !(return_value_strncmp$42 != 0) ? 5 : 0;
                  if(this->fd_control >= 0)
                  {
                    if((signed int)*bgimage == 47 || !(is_bg_file_mrl == 0))
                    {
                      char bgmrl[4352l];
                      snprintf(bgmrl, sizeof(char [4352l]) /*4352ul*/ , "%s%s", (const void *)mrlbase, bgimage + (signed long int)is_bg_file_mrl);
                      bgmrl[(signed long int)(sizeof(char [4352l]) /*4352ul*/  - (unsigned long int)1)] = (char)0;
                      if(iSysLogLevel >= 2)
                        x_syslog(6, log_module_input_vdr, "  -> trying to stream background image from server (%s) ...", (const void *)bgmrl);

                      signed int return_value_xine_open$43;
                      return_value_xine_open$43=xine_open(this->bg_stream.stream, bgmrl);
                      if(return_value_xine_open$43 == 0)
                        tmp_if_expr$45 = (_Bool)1;

                      else
                      {
                        return_value_xine_play$44=xine_play(this->bg_stream.stream, 0, 0);
                        tmp_if_expr$45 = !(return_value_xine_play$44 != 0) ? (_Bool)1 : (_Bool)0;
                      }
                      if(tmp_if_expr$45)
                      {
                        if(iSysLogLevel >= 2)
                          x_syslog(6, log_module_input_vdr, "Error streaming background image from server!");

                      }

                    }

                  }

                }

                has_video = 1;
              }

            }

          }

          this->$anon0.$anon0.funcs.fe_control(this->$anon0.$anon0.funcs.fe_handle, has_video != 0 ? "NOVIDEO 1\r\n" : "NOVIDEO 0\r\n");
          if(has_video == 0 && mix_streams == 0)
            tmp_if_expr$52 = av[0l] != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$52 = (_Bool)0;
          if(tmp_if_expr$52)
          {
            unsigned long int __s1_len;
            unsigned long int __s2_len;
            signed int return_value___builtin_strcmp$54;
            return_value___builtin_strcmp$54=__builtin_strcmp(av, "none");
            tmp_statement_expression$53 = return_value___builtin_strcmp$54;
            tmp_if_expr$55 = tmp_statement_expression$53 != 0 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$55 = (_Bool)0;
          if(tmp_if_expr$55)
          {
            char str[128l];
            char *avopts;
            char *return_value___builtin_strchr$51;
            return_value___builtin_strchr$51=__builtin_strchr(av, 58);
            avopts = return_value___builtin_strchr$51;
            if(!(avopts == ((char *)NULL)))
            {
              tmp_post$50 = avopts;
              avopts = avopts + 1l;
              *tmp_post$50 = (char)0;
            }

            else
              avopts = "";
            snprintf(str, sizeof(char [128l]) /*128ul*/ , "POST %s On %s\r\n", (const void *)av, avopts);
            str[(signed long int)(sizeof(char [128l]) /*128ul*/  - (unsigned long int)1)] = (char)0;
            this->$anon0.$anon0.funcs.fe_control(this->$anon0.$anon0.funcs.fe_handle, str);
          }

          else
            this->$anon0.$anon0.funcs.fe_control(this->$anon0.$anon0.funcs.fe_handle, "POST 0 Off\r\n");
        }

      }
    }
  }

  if(filename[0l] == 0)
  {
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_vdr, "PLAYFILE <STOP>: Closing slave stream");

    while((_Bool)0);
    this->loop_play = (unsigned char)0;
    if(!(this->slave.stream == ((struct xine_stream_s *)NULL)))
    {
      close_slave_stream(this);
      _x_demux_control_start(this->stream);
      dvd_set_speed((const char *)(void *)0, -1);
    }

  }

  return err != 0 ? -2 : 0;
}

// handle_control_substream
// file xine_input_vdr.c line 2696
static signed int handle_control_substream(struct vdr_input_plugin_s *this, const char *cmd)
{
  unsigned int pid;
  signed int return_value_sscanf$5;
  return_value_sscanf$5=sscanf(cmd, "SUBSTREAM 0x%x", &pid);
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  _Bool tmp_if_expr$4;
  if(return_value_sscanf$5 == 1)
  {
    pthread_mutex_lock(&this->lock);
    if(this->$anon0.$anon0.funcs.fe_control == ((void * (*)(struct frontend_s *, const char *))NULL))
      do
        if(iSysLogLevel >= 1)
        {
          x_syslog(3, log_module_input_vdr, "ERROR - no fe_control set !");
          signed int *return_value___errno_location$3;
          return_value___errno_location$3=__errno_location();
          if(!(*return_value___errno_location$3 == 0))
          {
            return_value___errno_location$1=__errno_location();
            return_value_strerror$2=strerror(*return_value___errno_location$1);
            x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 2703, return_value_strerror$2);
          }

        }

      while((_Bool)0);

    if((240u & pid) == 224u)
      tmp_if_expr$4 = this->$anon0.$anon0.funcs.fe_control != ((void * (*)(struct frontend_s *, const char *))NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$4 = (_Bool)0;
    if(tmp_if_expr$4)
    {
      if(this->pip_stream == ((struct xine_stream_s *)NULL))
      {
        do
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "create pip stream %s", cmd);

        while((_Bool)0);
        void *return_value;
        return_value=this->$anon0.$anon0.funcs.fe_control(this->$anon0.$anon0.funcs.fe_handle, cmd);
        this->pip_stream = (struct xine_stream_s *)return_value;
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "  pip stream created");

      }

    }

    else
      if(!(this->pip_stream == ((struct xine_stream_s *)NULL)))
      {
        if(!(this->$anon0.$anon0.funcs.fe_control == ((void * (*)(struct frontend_s *, const char *))NULL)))
        {
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_input_vdr, "close pip stream");

          while((_Bool)0);
          this->pip_stream = (struct xine_stream_s *)(void *)0;
          this->$anon0.$anon0.funcs.fe_control(this->$anon0.$anon0.funcs.fe_handle, cmd);
        }

      }

    pthread_mutex_unlock(&this->lock);
    return 0;
  }

  else
    return -2;
}

// handle_disconnect
// file xine_input_vdr.c line 4901
static void handle_disconnect(struct vdr_input_plugin_s *this)
{
  do
    if(iSysLogLevel >= 2)
      x_syslog(6, log_module_input_vdr, "read_block: no data source, returning NULL");

  while((_Bool)0);
  flush_all_fifos(this, 0);
  pthread_mutex_lock(&this->lock);
  reset_trick_speed(this);
  this->live_mode = (unsigned char)0;
  reset_scr_tuning(this);
  this->stream->emergency_brake = (unsigned int)1;
  this->control_running = 0;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  *return_value___errno_location$1 = 107;
  pthread_mutex_unlock(&this->lock);
}

// handle_video_discontinuity
// file xine/xvdr_metronom.c line 225
static void handle_video_discontinuity(struct metronom_s *metronom, signed int type, signed long int disc_off)
{
  struct xvdr_metronom_s$0 *this = (struct xvdr_metronom_s$0 *)metronom;
  start_buffering(this, disc_off);
  this->orig_metronom->handle_video_discontinuity(this->orig_metronom, type, disc_off);
}

// init_osd_manager
// file xine/osd_manager.h line 35
struct osd_manager_s * init_osd_manager(void)
{
  struct osd_manager_impl_s *this;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct osd_manager_impl_s) /*5304ul*/ );
  this = (struct osd_manager_impl_s *)return_value_calloc$1;
  signed int i;
  this->mgr.command = exec_osd_command;
  this->mgr.dispose = osd_manager_dispose;
  this->mgr.video_size_changed = video_size_changed;
  this->mgr.argb_supported = argb_supported;
  pthread_mutex_init(&this->lock, (const union anonymous$37 *)(void *)0);
  this->video_width = (unsigned short int)720;
  this->video_height = (unsigned short int)576;
  i = 0;
  for( ; !(i >= 50); i = i + 1)
    this->osd[(signed long int)i].handle = -1;
  return &this->mgr;
}

// init_udp_data
// file xine_input_vdr.c line 434
static struct udp_data_s * init_udp_data(void)
{
  struct udp_data_s *data;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct udp_data_s) /*2104ul*/ );
  data = (struct udp_data_s *)return_value_calloc$1;
  data->received_frames = (signed short int)-1;
  return data;
}

// input_xvdr_init_class
// file xine_input_vdr.c line 6055
static void * input_xvdr_init_class(struct xine_s$0 *xine, void *data)
{
  struct vdr_input_class_s *this;
  struct config_values_s *config = xine->config;
  SetupLogLevel();
  if(bSymbolsFound == 0)
  {
    if(xine->verbosity >= 1)
    {
      iSysLogLevel = xine->verbosity + 1;
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "detected verbose logging xine->verbosity=%d, setting log level to %d:%s", xine->verbosity, iSysLogLevel, iSysLogLevel < 1 ? "NONE" : (iSysLogLevel < 2 ? "ERRORS" : (iSysLogLevel < 3 ? "INFO" : (iSysLogLevel < 4 ? "DEBUG" : "VERBOSE DEBUG"))));

      while((_Bool)0);
    }

  }

  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct vdr_input_class_s) /*120ul*/ );
  this = (struct vdr_input_class_s *)return_value_calloc$1;
  this->xine = xine;
  this->mrls[(signed long int)0]=config->register_string(config, "media.xvdr.default_mrl", "xvdr://127.0.0.1#nocache;demux:mpeg_block", "default VDR host", "The default VDR host", 10, vdr_class_default_mrl_change_cb, (void *)this);
  this->mrls[(signed long int)1] = ((char *)NULL);
  this->fast_osd_scaling=config->register_bool(config, "media.xvdr.fast_osd_scaling", 0, "Fast (low-quality) OSD scaling", "Enable fast (lower quality) OSD scaling.\nDefault is to use (slow) linear interpolation to calculate pixels and full palette re-allocation to optimize color palette.\nFast method only duplicates/removes rows and columns and does not modify palette.", 10, vdr_class_fast_osd_scaling_cb, (void *)this);
  signed int return_value;
  return_value=config->register_num(config, "media.xvdr.scr_tuning_step", 5000, "SRC tuning step", "SCR tuning step width unit %1000000.", 10, vdr_class_scr_tuning_step_cb, (void *)this);
  this->scr_tuning_step = (double)return_value / 1000000.0;
  this->smooth_scr_tuning=config->register_bool(config, "media.xvdr.smooth_scr_tuning", 0, "Smoother SRC tuning", "Smoother SCR tuning", 10, vdr_class_smooth_scr_tuning_cb, (void *)this);
  this->num_buffers_hd=config->register_num(config, "media.xvdr.num_buffers_hd", 2500, "number of buffers for HD content", "number of buffers for HD content", 10, (void (*)(void *, struct xine_cfg_entry_s *))(void *)0, (void *)0);
  signed int return_value_1;
  return_value_1=config->register_num(config, "media.xvdr.scr_treshold_sd", 50, "SCR-Treshold for SD-Playback (%)", "SCR-Treshold for starting SD-Playback (%)", 10, (void (*)(void *, struct xine_cfg_entry_s *))(void *)0, (void *)0);
  this->scr_treshold_sd = (unsigned int)return_value_1;
  signed int return_value_2;
  return_value_2=config->register_num(config, "media.xvdr.scr_treshold_hd", 40, "SCR-Treshold for HD-Playback (%)", "SCR-Treshold for starting HD-Playback (%)", 10, (void (*)(void *, struct xine_cfg_entry_s *))(void *)0, (void *)0);
  this->scr_treshold_hd = (unsigned int)return_value_2;
  this->input_class.get_instance = vdr_class_get_instance;
  this->input_class.identifier = "xvdr";
  this->input_class.description = "VDR (Video Disk Recorder) input plugin";
  this->input_class.get_autoplay_list = vdr_plugin_get_autoplay_list;
  this->input_class.dispose = vdr_class_dispose;
  if(iSysLogLevel >= 3)
    x_syslog(7, log_module_input_vdr, "init class succeeded");

  return (void *)this;
}

// io_select_rd
// file xine_input_vdr.c line 890
static signed int io_select_rd(signed int fd)
{
  struct anonymous$9 fdset;
  struct anonymous$9 eset;
  signed int ret;
  struct timeval select_timeout;
  signed long int tmp_statement_expression$1;
  signed long int tmp_statement_expression$3;
  _Bool tmp_if_expr$8;
  signed int *return_value___errno_location$7;
  signed long int tmp_statement_expression$9;
  signed long int tmp_statement_expression$11;
  if(!(fd >= 0))
    return 1;

  else
  {
    do
    {
      signed int io_select_rd$$1$$1$$__d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(io_select_rd$$1$$1$$__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$9) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fdset)->fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    do
    {
      signed int __d0;
      signed int io_select_rd$$1$$2$$__d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(io_select_rd$$1$$2$$__d1) : "a"(0), "0"(sizeof(struct anonymous$9) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&eset)->fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    signed long int io_select_rd$$1$$3$$__d = (signed long int)fd;
    signed long int return_value___fdelt_chk$2;
    return_value___fdelt_chk$2=__fdelt_chk(io_select_rd$$1$$3$$__d);
    tmp_statement_expression$1 = return_value___fdelt_chk$2;
    (&fdset)->fds_bits[tmp_statement_expression$1] = (&fdset)->fds_bits[tmp_statement_expression$1] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    signed long int __d = (signed long int)fd;
    signed long int return_value___fdelt_chk$4;
    return_value___fdelt_chk$4=__fdelt_chk(__d);
    tmp_statement_expression$3 = return_value___fdelt_chk$4;
    (&eset)->fds_bits[tmp_statement_expression$3] = (&eset)->fds_bits[tmp_statement_expression$3] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    select_timeout.tv_sec = (signed long int)0;
    select_timeout.tv_usec = (signed long int)(500 * 1000);
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    *return_value___errno_location$5 = 0;
    ret=select(fd + 1, &fdset, (struct anonymous$9 *)(void *)0, &eset, &select_timeout);
    if(ret == 0)
      return 3;

    else
    {
      if(!(ret >= 0))
      {
        signed int *return_value___errno_location$6;
        return_value___errno_location$6=__errno_location();
        if(*return_value___errno_location$6 == 4)
          tmp_if_expr$8 = (_Bool)1;

        else
        {
          return_value___errno_location$7=__errno_location();
          tmp_if_expr$8 = *return_value___errno_location$7 == 11 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$8)
          return 3;

        return 1;
      }

      signed long int io_select_rd$$1$$6$$__d = (signed long int)fd;
      signed long int return_value___fdelt_chk$10;
      return_value___fdelt_chk$10=__fdelt_chk(io_select_rd$$1$$6$$__d);
      tmp_statement_expression$9 = return_value___fdelt_chk$10;
      if(!((eset.fds_bits[tmp_statement_expression$9] & (signed long int)(1UL << fd % 8)) == 0l))
        return 1;

      else
      {
        signed long int io_select_rd$$1$$7$$__d = (signed long int)fd;
        signed long int return_value___fdelt_chk$12;
        return_value___fdelt_chk$12=__fdelt_chk(io_select_rd$$1$$7$$__d);
        tmp_statement_expression$11 = return_value___fdelt_chk$12;
        if(!((fdset.fds_bits[tmp_statement_expression$11] & (signed long int)(1UL << fd % 8)) == 0l))
          return 0;

        else
          return 3;
      }
    }
  }
}

// is_audio_descriptor
// file tools/ts.c line 222
static inline signed int is_audio_descriptor(const unsigned char descriptor_tag)
{
  if((signed int)descriptor_tag == 0x6a || (signed int)descriptor_tag == 0x7a || (signed int)descriptor_tag == 0x7b || (signed int)descriptor_tag == 0x7c)
    return 1;

  return 0;
}

// is_lang_code
// file xine_input_vdr.c line 3054
static signed int is_lang_code(const char *s, signed int len)
{
  signed int tmp_post$1;
  const unsigned short int **return_value___ctype_b_loc$2;
  const char *tmp_post$3;
  do
  {
    tmp_post$1 = len;
    len = len - 1;
    if(tmp_post$1 == 0)
      break;

    return_value___ctype_b_loc$2=__ctype_b_loc();
    tmp_post$3 = s;
    s = s + 1l;
    if((512 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)*tmp_post$3]) == 0)
      return 0;

  }
  while((_Bool)1);
  const unsigned short int **return_value___ctype_b_loc$4;
  return_value___ctype_b_loc$4=__ctype_b_loc();
  return (signed int)!(((signed int)(*return_value___ctype_b_loc$4)[(signed long int)(signed int)*s] & (signed int)(unsigned short int)1024) != 0);
}

// memcpy
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 50
static inline void * memcpy(void * restrict __dest, const void * restrict __src, unsigned long int __len)
{
  void *return_value___builtin___memcpy_chk$1;
  return_value___builtin___memcpy_chk$1=__builtin___memcpy_chk(__dest, __src, __len, 18446744073709551615ul);
  return return_value___builtin___memcpy_chk$1;
}

// memcpy$link1
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 50
static inline void * memcpy$link1(void * restrict __dest$link1, const void * restrict __src$link1, unsigned long int __len$link1)
{
  void *return_value___builtin___memcpy_chk$1$link1;
  return_value___builtin___memcpy_chk$1$link1=__builtin___memcpy_chk(__dest$link1, __src$link1, __len$link1, 18446744073709551615ul);
  return return_value___builtin___memcpy_chk$1$link1;
}

// memcpy$link2
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 50
static inline void * memcpy$link2(void * restrict __dest$link2, const void * restrict __src$link2, unsigned long int __len$link2)
{
  void *return_value___builtin___memcpy_chk$1$link2;
  return_value___builtin___memcpy_chk$1$link2=__builtin___memcpy_chk(__dest$link2, __src$link2, __len$link2, 18446744073709551615ul);
  return return_value___builtin___memcpy_chk$1$link2;
}

// memcpy$link3
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 50
static inline void * memcpy$link3(void * restrict __dest$link3, const void * restrict __src$link3, unsigned long int __len$link3)
{
  void *return_value___builtin___memcpy_chk$1$link3;
  return_value___builtin___memcpy_chk$1$link3=__builtin___memcpy_chk(__dest$link3, __src$link3, __len$link3, 18446744073709551615ul);
  return return_value___builtin___memcpy_chk$1$link3;
}

// memcpy$link4
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 50
static inline void * memcpy$link4(void * restrict __dest$link4, const void * restrict __src$link4, unsigned long int __len$link4)
{
  void *return_value___builtin___memcpy_chk$1$link4;
  return_value___builtin___memcpy_chk$1$link4=__builtin___memcpy_chk(__dest$link4, __src$link4, __len$link4, 18446744073709551615ul);
  return return_value___builtin___memcpy_chk$1$link4;
}

// memcpy$link5
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 50
static inline void * memcpy$link5(void * restrict __dest$link5, const void * restrict __src$link5, unsigned long int __len$link5)
{
  void *return_value___builtin___memcpy_chk$1$link5;
  return_value___builtin___memcpy_chk$1$link5=__builtin___memcpy_chk(__dest$link5, __src$link5, __len$link5, 18446744073709551615ul);
  return return_value___builtin___memcpy_chk$1$link5;
}

// memcpy$link6
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 50
static inline void * memcpy$link6(void * restrict __dest$link6, const void * restrict __src$link6, unsigned long int __len$link6)
{
  void *return_value___builtin___memcpy_chk$1$link6;
  return_value___builtin___memcpy_chk$1$link6=__builtin___memcpy_chk(__dest$link6, __src$link6, __len$link6, 18446744073709551615ul);
  return return_value___builtin___memcpy_chk$1$link6;
}

// memmove
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 57
static inline void * memmove(void *__dest, const void *__src, unsigned long int __len)
{
  char *return_value___builtin___memmove_chk$1;
  return_value___builtin___memmove_chk$1=__builtin___memmove_chk(__dest, __src, __len, 18446744073709551615ul);
  return (void *)return_value___builtin___memmove_chk$1;
}

// memmove$link1
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 57
static inline void * memmove$link1(void *__dest$link1, const void *__src$link1, unsigned long int __len$link1)
{
  char *return_value___builtin___memmove_chk$1$link1;
  return_value___builtin___memmove_chk$1$link1=__builtin___memmove_chk(__dest$link1, __src$link1, __len$link1, 18446744073709551615ul);
  return (void *)return_value___builtin___memmove_chk$1$link1;
}

// memset
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 78
static inline void * memset(void *__dest, signed int __ch, unsigned long int __len)
{
  void *return_value___builtin___memset_chk$1;
  return_value___builtin___memset_chk$1=__builtin___memset_chk(__dest, __ch, __len, 18446744073709551615ul);
  return return_value___builtin___memset_chk$1;
}

// memset$link1
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 78
static inline void * memset$link1(void *__dest$link1, signed int __ch$link1, unsigned long int __len$link1)
{
  void *return_value___builtin___memset_chk$1$link1;
  return_value___builtin___memset_chk$1$link1=__builtin___memset_chk(__dest$link1, __ch$link1, __len$link1, 18446744073709551615ul);
  return return_value___builtin___memset_chk$1$link1;
}

// memset$link2
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 78
static inline void * memset$link2(void *__dest$link2, signed int __ch$link2, unsigned long int __len$link2)
{
  void *return_value___builtin___memset_chk$1$link2;
  return_value___builtin___memset_chk$1$link2=__builtin___memset_chk(__dest$link2, __ch$link2, __len$link2, 18446744073709551615ul);
  return return_value___builtin___memset_chk$1$link2;
}

// memset$link3
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 78
static inline void * memset$link3(void *__dest$link3, signed int __ch$link3, unsigned long int __len$link3)
{
  void *return_value___builtin___memset_chk$1$link3;
  return_value___builtin___memset_chk$1$link3=__builtin___memset_chk(__dest$link3, __ch$link3, __len$link3, 18446744073709551615ul);
  return return_value___builtin___memset_chk$1$link3;
}

// metronom_exit
// file xine/xvdr_metronom.c line 311
static void metronom_exit(struct metronom_s *metronom)
{
  struct xvdr_metronom_s$0 *this = (struct xvdr_metronom_s$0 *)metronom;
  do
    if(iSysLogLevel >= 2)
      x_syslog(6, "[metronom ] ", "xvdr_metronom: metronom_exit() called !");

  while((_Bool)0);
  this->unwire(this);
  this->stream = (struct xine_stream_s$0 *)(void *)0;
  if(!(this->orig_metronom == ((struct metronom_s *)NULL)))
  {
    struct metronom_s *orig_metronom = this->orig_metronom;
    this->orig_metronom = (struct metronom_s *)(void *)0;
    orig_metronom->exit(orig_metronom);
  }

}

// min64
// file xine/xvdr_metronom.c line 30
static signed long int min64(signed long int a, signed long int b)
{
  return a < b ? a : b;
}

// mpeg2_get_picture_type
// file tools/mpeg.h line 54
signed int mpeg2_get_picture_type(const unsigned char *buf, signed int len)
{
  signed int i = 0;
  for( ; !(i >= len + -5); i = i + 1)
    if(*((const unsigned int *)(buf + (signed long int)i)) == 0x00010000U)
      return (signed int)buf[(signed long int)(i + 5)] >> 3 & 0x07;

  return 0;
}

// mpeg2_get_video_size
// file tools/mpeg.h line 59
signed int mpeg2_get_video_size(const unsigned char *buf, signed int len, struct video_size_s *size)
{
  signed int i = 0;
  for( ; !(i >= len + -6); i = i + 1)
    if(*((const unsigned int *)(buf + (signed long int)i)) == 0xb3010000U)
    {
      signed int d = (signed int)buf[(signed long int)(i + 4)] << 16 | (signed int)buf[(signed long int)(i + 5)] << 8 | (signed int)buf[(signed long int)(i + 6)];
      signed int a = (signed int)buf[(signed long int)(i + 7)] >> 4;
      size->width = (unsigned short int)(d >> 12);
      size->height = (unsigned short int)(d & 0xfff);
      static const struct mpeg_rational_s mpeg2_aspect[16l] = { { .num=0, .den=1 }, { .num=1, .den=1 }, { .num=4, .den=3 }, { .num=16, .den=9 }, { .num=221, .den=100 }, { .num=0, .den=1 }, { .num=0, .den=1 }, { .num=0, .den=1 }, { .num=0, .den=1 }, { .num=0, .den=1 }, { .num=0, .den=1 }, { .num=0, .den=1 }, { .num=0, .den=1 }, { .num=0, .den=1 }, { .num=0, .den=1 }, { .num=0, .den=1 } };
      memcpy$link5((void *)&size->pixel_aspect, (const void *)&mpeg2_aspect[(signed long int)a], sizeof(struct mpeg_rational_s) /*8ul*/ );
      size->pixel_aspect.num = size->pixel_aspect.num * (signed int)size->height;
      size->pixel_aspect.den = size->pixel_aspect.den * (signed int)size->width;
      return 1;
    }

  return 0;
}

// mpeg2_is_sequence_header
// file tools/mpeg.c line 34
signed int mpeg2_is_sequence_header(const unsigned char *buf, signed int len)
{
  signed int i = 0;
  for( ; !(i >= len + -6); i = i + 1)
    if(*((const unsigned int *)(buf + (signed long int)i)) == 0xb3010000U)
      return 1;

  return 0;
}

// mutex_cleanup
// file xine_input_vdr.c line 462
static void mutex_cleanup(void *arg)
{
  pthread_mutex_unlock((union anonymous$6 *)arg);
}

// open
// file /usr/include/x86_64-linux-gnu/bits/fcntl2.h line 41
static inline signed int open(const char *__path, signed int __oflag, ...)
{
  signed int return_value___builtin_va_arg_pack_len$1;
  return_value___builtin_va_arg_pack_len$1=__builtin_va_arg_pack_len();
  if(return_value___builtin_va_arg_pack_len$1 >= 2)
    __open_too_many_args();

  signed int return_value___builtin_va_arg_pack_len$3;
  signed int return_value___builtin_va_arg_pack_len$7;
  return_value___builtin_va_arg_pack_len$7=__builtin_va_arg_pack_len();
  signed int return_value___open_2$6;
  if(!(return_value___builtin_va_arg_pack_len$7 >= 1))
  {
    return_value___open_2$6=__open_2(__path, __oflag);
    return return_value___open_2$6;
  }

  else
  {
    void *return_value___builtin_va_arg_pack$8;
    return_value___builtin_va_arg_pack$8=__builtin_va_arg_pack();
    signed int return_value___open_alias$9;
    return_value___open_alias$9=__open_alias(__path, __oflag, return_value___builtin_va_arg_pack$8);
    return return_value___open_alias$9;
  }
}

// osd_exec_vpts
// file xine/osd_manager.c line 263
static signed long int osd_exec_vpts(struct osd_manager_impl_s *this, struct osd_command_s *cmd)
{
  signed long int vpts = (signed long int)0;
  _Bool tmp_if_expr$1;
  if(!(cmd->pts == 0l))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = cmd->delay_ms != 0u ? (_Bool)1 : (_Bool)0;
  signed long int return_value;
  if(tmp_if_expr$1)
  {
    signed long int now;
    now=xine_get_current_vpts(this->stream);
    if(!(cmd->pts == 0l))
    {
      return_value=this->stream->metronom->get_option(this->stream->metronom, 6);
      vpts = cmd->pts + return_value;
    }

    else
      vpts = this->osd[(signed long int)cmd->wnd].last_changed_vpts + (signed long int)(cmd->delay_ms * (unsigned int)90);
    if(!(vpts >= now))
      vpts = (signed long int)0;

    if(!(450000l + now >= vpts))
      vpts = vpts + (signed long int)(5 * 90000);

  }


__CPROVER_DUMP_L6:
  ;
  return vpts;
}

// osd_manager_dispose
// file xine/osd_manager.c line 968
static void osd_manager_dispose(struct osd_manager_s *this_gen, struct xine_stream_s *stream)
{
  struct osd_manager_impl_s *this = (struct osd_manager_impl_s *)this_gen;
  signed int i;
  signed int return_value_pthread_mutex_destroy$1;
  do
  {
    return_value_pthread_mutex_destroy$1=pthread_mutex_destroy(&this->lock);
    if(!(return_value_pthread_mutex_destroy$1 == 16))
      break;

    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_osd, "osd_manager_dispose: lock busy ...");

    while((_Bool)0);
    pthread_mutex_lock(&this->lock);
    pthread_mutex_unlock(&this->lock);
  }
  while((_Bool)1);
  i = 0;
  for( ; !(i >= 50); i = i + 1)
    if(this->osd[(signed long int)i].handle >= 0)
    {
      struct osd_command_s cmd = { .size=0, .cmd=(unsigned char)5, .wnd=(unsigned char)i, .layer=0,
    .pts=0l, .delay_ms=0u, .x=0, .y=0,
    .w=0, .h=0, .datalen=0u, .num_rle=0u, .$anon0={ .data=((struct osd_rle_elem_s *)NULL) },
    .colors=0u,
    .$anon1={ .palette=((struct osd_clut_s *)NULL) }, .dirty_area={ .x1=0, .y1=0, .x2=0, .y2=0 },
    .flags=0,
    .scaling=0 };

    __CPROVER_DUMP_L6:
      ;
      exec_osd_close(this, &cmd);
    }

  release_ticket(this);
  free((void *)this);
}

// osdcmd_scale
// file xine/osd_manager.c line 227
static void osdcmd_scale(struct osd_manager_impl_s *this, struct osd_command_s *cmd, struct anonymous$4 *osd, signed int output_width, signed int output_height)
{

__CPROVER_DUMP_L1:
  ;
  signed int new_x = ((signed int)cmd->x * (signed int)this->video_width) / (signed int)osd->extent_width;
  signed int new_y = ((signed int)cmd->y * (signed int)this->video_height) / (signed int)osd->extent_height;
  signed int x2 = (signed int)cmd->x + (signed int)cmd->w + 1;
  signed int y2 = (signed int)cmd->y + (signed int)cmd->h + 1;
  x2 = ((x2 + 1) * (signed int)this->video_width - 1) / (signed int)osd->extent_width;
  y2 = ((y2 + 1) * (signed int)this->video_height - 1) / (signed int)osd->extent_height;
  signed int new_w = (x2 - new_x) - 1;
  signed int new_h = (y2 - new_y) - 1;
  osd->cmd.$anon0.data = cmd->$anon0.data;
  osd->cmd.datalen = cmd->datalen;
  signed int rle_elems = (signed int)((unsigned long int)cmd->datalen / sizeof(struct osd_rle_elem_s) /*4ul*/ );
  cmd->$anon0.data=rle_scale_nearest(cmd->$anon0.data, &rle_elems, (unsigned int)cmd->w, (unsigned int)cmd->h, (unsigned int)new_w, (unsigned int)new_h);
  cmd->datalen = (unsigned int)((unsigned long int)rle_elems * sizeof(struct osd_rle_elem_s) /*4ul*/ );
  cmd->x = (unsigned short int)new_x;
  cmd->y = (unsigned short int)new_y;
  cmd->w = (unsigned short int)new_w;
  cmd->h = (unsigned short int)new_h;
}

// osdcmd_to_overlay
// file xine/osd_manager.c line 195
static void osdcmd_to_overlay(struct vo_overlay_s *ovl, struct osd_command_s *cmd)
{
  unsigned int i;
  ovl->rle = (struct rle_elem_s *)cmd->$anon0.data;
  ovl->data_size = (signed int)cmd->datalen;
  ovl->num_rle = (signed int)(cmd->datalen / (unsigned int)4);
  ovl->x = (signed int)cmd->x;
  ovl->y = (signed int)cmd->y;
  ovl->width = (signed int)cmd->w;
  ovl->height = (signed int)cmd->h;
  i = (unsigned int)0;
  for( ; !(i >= cmd->colors); i = i + 1u)
  {
    ovl->color[(signed long int)i] = *((unsigned int *)(cmd->$anon1.palette + (signed long int)i)) & (unsigned int)0x00ffffff;
    ovl->trans[(signed long int)i] = (unsigned char)(((signed int)(cmd->$anon1.palette + (signed long int)i)->alpha + 0x7) / 0xf);
  }
  ovl->rgb_clut = ((signed int)cmd->flags & 0x01) != 0 ? 0 : 1;
  ovl->unscaled = ((signed int)cmd->flags & 0x04) != 0 ? 1 : 0;
  ovl->hili_right = -1;
  ovl->hili_left = ovl->hili_right;
  ovl->hili_bottom = ovl->hili_left;
  ovl->hili_top = ovl->hili_bottom;
}

// palette_argb_to_ayuv
// file xine/osd_manager.c line 159
static void palette_argb_to_ayuv(struct osd_clut_s *clut, signed int colors)
{
  if(colors >= 1 && !(clut == ((struct osd_clut_s *)NULL)))
  {
    signed int c = 0;
    for( ; !(c >= colors); c = c + 1)
    {
      signed int R = (signed int)(clut + (signed long int)c)->$anon2.r;
      signed int G = (signed int)(clut + (signed long int)c)->$anon0.g;
      signed int B = (signed int)(clut + (signed long int)c)->$anon1.b;
      signed int Y = (+66 * R + 129 * G + 25 * B + 0x80 >> 8) + 16;
      signed int CR = (((+112 * R - 94 * G) - 18 * B) + 0x80 >> 8) + 128;
      signed int CB = ((-38 * R - 74 * G) + 112 * B + 0x80 >> 8) + 128;
      (clut + (signed long int)c)->$anon2.y = (unsigned char)(Y < 16 ? 16 : (Y > 235 ? 235 : Y));
      (clut + (signed long int)c)->$anon0.cb = (unsigned char)(CB < 16 ? 16 : (CB > 240 ? 240 : CB));
      (clut + (signed long int)c)->$anon1.cr = (unsigned char)(CR < 16 ? 16 : (CR > 240 ? 240 : CR));
    }
  }

}

// parse_audio_stream
// file xine/demux_xvdr.c line 1048
static signed int parse_audio_stream(struct demux_xvdr_s *this, unsigned char *p, struct buf_element_s *buf)
{
  signed int track;
  signed int result;
  result=parse_pes_for_pts(this, p, buf);
  if(!(result >= 0))
    return -1;

  else
  {
    p = p + (signed long int)result;
    track = (signed int)this->stream_id & 0x1f;
    buf->content = p;
    buf->size = (signed int)this->packet_len;
    buf->type = (unsigned int)(0x03010000 + track);
    buf->pts = this->pts;
    if(!(this->audio_fifo == ((struct fifo_buffer_s *)NULL)))
    {
      check_newpts(this, buf, 0);
      track_audio_stream_change(this, buf);
      this->audio_fifo->put(this->audio_fifo, buf);
    }

    else
      buf->free_buffer(buf);
    return -1;
  }
}

// parse_dvb_spu
// file xine/demux_xvdr.c line 762
static signed int parse_dvb_spu(struct demux_xvdr_s *this, unsigned char *p, struct buf_element_s *buf, signed int substream_header_len)
{
  unsigned int spu_id = (unsigned int)((signed int)p[(signed long int)0] & 0x1f);
  _x_select_spu_channel(this->stream, (signed int)spu_id);
  if(substream_header_len == 1)
  {
    p = p - 1l;
    this->packet_len = this->packet_len + 1u;
  }

  p = p + (signed long int)substream_header_len;
  buf->content = p;
  buf->size = (signed int)(this->packet_len - (unsigned int)substream_header_len);
  if(this->pts >= 1l)
  {
    struct buf_element_s *cbuf;
    cbuf=this->video_fifo->buffer_pool_alloc(this->video_fifo);
    signed int page_id = (signed int)p[(signed long int)4] << 8 | (signed int)p[(signed long int)5];
    struct spu_dvb_descriptor_s *spu_descriptor = (struct spu_dvb_descriptor_s *)cbuf->content;
    memset$link1((void *)spu_descriptor, 0, sizeof(struct spu_dvb_descriptor_s) /*24ul*/ );
    spu_descriptor->comp_page_id = (signed long int)page_id;
    cbuf->type = (unsigned int)0x04030000 + spu_id;
    cbuf->size = 0;
    cbuf->decoder_flags = (unsigned int)0x0200;
    cbuf->decoder_info[(signed long int)1] = (unsigned int)9;
    cbuf->decoder_info[(signed long int)2] = (unsigned int)sizeof(struct spu_dvb_descriptor_s) /*24ul*/ ;
    cbuf->decoder_info_ptr[(signed long int)2] = (void *)spu_descriptor;
    this->video_fifo->put(this->video_fifo, cbuf);
  }

  buf->type = (unsigned int)0x04030000 + spu_id;
  buf->pts = this->pts;
  buf->decoder_info[(signed long int)2] = (unsigned int)(this->pts > (signed long int)0 ? 0xffff : 0);
  this->video_fifo->put(this->video_fifo, buf);
  return -1;
}

// parse_pes_for_pts
// file xine/demux_xvdr.c line 648
static signed int parse_pes_for_pts(struct demux_xvdr_s *this, unsigned char *p, struct buf_element_s *buf)
{
  signed int header_len;
  this->packet_len = (unsigned int)((signed int)p[(signed long int)4] << 8 | (signed int)p[(signed long int)5]);
  if(!((0xC0 & (signed int)p[6l]) == 0x80))
  {
    header_len = 6;
    p = p + (signed long int)6;
    for( ; (0x80 & (signed int)*p) == 0x80; this->packet_len = this->packet_len - 1u)
    {
      p = p + 1l;
      header_len = header_len + 1;
    }
    if((0xc0 & (signed int)*p) == 0x40)
    {
      p = p + (signed long int)2;
      header_len = header_len + 2;
      this->packet_len = this->packet_len - (unsigned int)2;
    }

    this->pts = (signed long int)0;
    this->dts = (signed long int)0;
    if((0xf0 & (signed int)*p) == 0x20)
    {
      this->pts = (signed long int)((signed int)p[(signed long int)0] & 0x0E) << 29;
      this->pts = this->pts | (signed long int)((signed int)p[(signed long int)1] << 22);
      this->pts = this->pts | (signed long int)(((signed int)p[(signed long int)2] & 0xFE) << 14);
      this->pts = this->pts | (signed long int)((signed int)p[(signed long int)3] << 7);
      this->pts = this->pts | (signed long int)(((signed int)p[(signed long int)4] & 0xFE) >> 1);
      p = p + (signed long int)5;
      header_len = header_len + 5;
      this->packet_len = this->packet_len - (unsigned int)5;
      return header_len;
    }

    else
      if((0xf0 & (signed int)*p) == 0x30)
      {
        this->pts = (signed long int)((signed int)p[(signed long int)0] & 0x0E) << 29;
        this->pts = this->pts | (signed long int)((signed int)p[(signed long int)1] << 22);
        this->pts = this->pts | (signed long int)(((signed int)p[(signed long int)2] & 0xFE) << 14);
        this->pts = this->pts | (signed long int)((signed int)p[(signed long int)3] << 7);
        this->pts = this->pts | (signed long int)(((signed int)p[(signed long int)4] & 0xFE) >> 1);
        this->dts = (signed long int)((signed int)p[(signed long int)5] & 0x0E) << 29;
        this->dts = this->dts | (signed long int)((signed int)p[(signed long int)6] << 22);
        this->dts = this->dts | (signed long int)(((signed int)p[(signed long int)7] & 0xFE) << 14);
        this->dts = this->dts | (signed long int)((signed int)p[(signed long int)8] << 7);
        this->dts = this->dts | (signed long int)(((signed int)p[(signed long int)9] & 0xFE) >> 1);
        p = p + (signed long int)10;
        header_len = header_len + 10;
        this->packet_len = this->packet_len - (unsigned int)10;
        return header_len;
      }

      else
      {
        p = p + 1l;
        header_len = header_len + 1;
        this->packet_len = this->packet_len - 1u;
        return header_len;
      }
  }

  else
  {
    if(!((0xC0 & (signed int)p[6l]) == 0x80))
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_demux_xvdr, "warning: PES header reserved 10 bits not found");

      while((_Bool)0);
      buf->free_buffer(buf);
      return -1;
    }

    if(!((0x30 & (signed int)p[6l]) == 0))
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_demux_xvdr, "encrypted PES ?");

      while((_Bool)0);
      buf->free_buffer(buf);
      return -1;
    }

    if(!((0x80 & (signed int)p[7l]) == 0))
    {
      this->pts = (signed long int)((signed int)p[(signed long int)9] & 0x0E) << 29;
      this->pts = this->pts | (signed long int)((signed int)p[(signed long int)10] << 22);
      this->pts = this->pts | (signed long int)(((signed int)p[(signed long int)11] & 0xFE) << 14);
      this->pts = this->pts | (signed long int)((signed int)p[(signed long int)12] << 7);
      this->pts = this->pts | (signed long int)(((signed int)p[(signed long int)13] & 0xFE) >> 1);
    }

    else
      this->pts = (signed long int)0;
    if(!((0x40 & (signed int)p[7l]) == 0))
    {
      this->dts = (signed long int)((signed int)p[(signed long int)14] & 0x0E) << 29;
      this->dts = this->dts | (signed long int)((signed int)p[(signed long int)15] << 22);
      this->dts = this->dts | (signed long int)(((signed int)p[(signed long int)16] & 0xFE) << 14);
      this->dts = this->dts | (signed long int)((signed int)p[(signed long int)17] << 7);
      this->dts = this->dts | (signed long int)(((signed int)p[(signed long int)18] & 0xFE) >> 1);
    }

    else
      this->dts = (signed long int)0;
    header_len = (signed int)p[(signed long int)8];
    this->packet_len = this->packet_len - (unsigned int)(header_len + 3);
    return header_len + 9;
  }
  return 0;
}

// parse_private_stream_1
// file xine/demux_xvdr.c line 853
static signed int parse_private_stream_1(struct demux_xvdr_s *this, unsigned char *p, struct buf_element_s *buf)
{
  signed int track;
  signed int spu_id;
  signed int result;
  result=parse_pes_for_pts(this, p, buf);
  if(!(result >= 0))
    return -1;

  else
  {
    p = p + (signed long int)result;
    if((0xE0 & (signed int)*p) == 0x20)
    {
      spu_id = (signed int)p[(signed long int)0] & 0x1f;
      if(!(this->pts >= 1l))
      {
        if(this->subtitle_type == 0u)
        {
          buf->free_buffer(buf);
          return -1;
        }

      }

      signed int return_value_detect_dvb_spu$1;
      return_value_detect_dvb_spu$1=detect_dvb_spu(this, p, buf);
      if(!(return_value_detect_dvb_spu$1 >= 0))
        return -1;

      this->subtitle_type = (unsigned int)0x04000000;
      buf->content = p + (signed long int)1;
      buf->size = (signed int)(this->packet_len - (unsigned int)1);
      buf->type = (unsigned int)(0x04000000 + spu_id);
      buf->decoder_flags = buf->decoder_flags | (unsigned int)0x0200;
      buf->decoder_info[(signed long int)1] = (unsigned int)8;
      buf->decoder_info[(signed long int)2] = (unsigned int)2;
      buf->pts = this->pts;
      this->video_fifo->put(this->video_fifo, buf);
      return -1;
    }

    if((0xF0 & (signed int)*p) == 0x80)
    {
      track = (signed int)p[(signed long int)0] & 0x0F;
      buf->decoder_info[(signed long int)1] = (unsigned int)p[(signed long int)1];
      buf->decoder_info[(signed long int)2] = (unsigned int)((signed int)p[(signed long int)2] << 8 | (signed int)p[(signed long int)3]);
      buf->content = p + (signed long int)4;
      buf->size = (signed int)(this->packet_len - (unsigned int)4);
      if(!((0x8 & track) == 0))
        buf->type = (unsigned int)(0x03050000 + (track & 0x07));

      else
        buf->type = (unsigned int)(0x03000000 + track);
      buf->pts = this->pts;
      if(!(this->audio_fifo == ((struct fifo_buffer_s *)NULL)))
      {
        check_newpts(this, buf, 0);
        track_audio_stream_change(this, buf);
        this->audio_fifo->put(this->audio_fifo, buf);
        return -1;
      }

      else
      {
        buf->free_buffer(buf);
        return -1;
      }
    }

    else
      if((0xf0 & (signed int)*p) == 0xa0)
      {
        track = (signed int)p[(signed long int)0] & 0x0F;
        buf->decoder_flags = buf->decoder_flags | (unsigned int)0x0200;
        buf->decoder_info[(signed long int)1] = (unsigned int)6;
        buf->decoder_info[(signed long int)2] = (unsigned int)p[(signed long int)5];
        buf->content = p + (signed long int)7;
        buf->size = (signed int)(this->packet_len - (unsigned int)7);
        buf->type = (unsigned int)(0x03020000 + track);
        buf->pts = this->pts;
        if(!(this->audio_fifo == ((struct fifo_buffer_s *)NULL)))
        {
          check_newpts(this, buf, 0);
          track_audio_stream_change(this, buf);
          this->audio_fifo->put(this->audio_fifo, buf);
          return -1;
        }

        else
        {
          buf->free_buffer(buf);
          return -1;
        }
      }

    buf->free_buffer(buf);
    return -1;
  }
}

// parse_timestamp
// file tools/pes.c line 21
static signed long int parse_timestamp(const unsigned char *buf)
{
  signed long int ts = (signed long int)((signed int)buf[(signed long int)0] & 0x0E) << 29;
  ts = ts | (signed long int)((signed int)buf[(signed long int)1] << 22);
  ts = ts | (signed long int)(((signed int)buf[(signed long int)2] & 0xFE) << 14);
  ts = ts | (signed long int)((signed int)buf[(signed long int)3] << 7);
  ts = ts | (signed long int)(((signed int)buf[(signed long int)4] & 0xFE) >> 1);
  return ts;
}

// parse_video_stream
// file xine/demux_xvdr.c line 976
static signed int parse_video_stream(struct demux_xvdr_s *this, unsigned char *p, struct buf_element_s *buf)
{
  signed int result;
  result=parse_pes_for_pts(this, p, buf);
  unsigned int tmp_if_expr$2;
  if(!(result >= 0))
    return -1;

  else
    if(buf->size == 14)
    {
      if(!(result == 14))
        goto __CPROVER_DUMP_L4;

      if(!(this->pts == 0l))
        goto __CPROVER_DUMP_L4;

      do
        if(iSysLogLevel >= 3)
          x_syslog(7, log_module_demux_xvdr, "video fifo flush and decoder reset after still image");

      while((_Bool)0);
      put_control_buf$link1(this->video_fifo, this->video_fifo, 0x010a0000);
      put_control_buf$link1(this->video_fifo, this->video_fifo, 0x01080000);
      buf->free_buffer(buf);
      return -1;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      p = p + (signed long int)result;
      if(this->video_type == 0u)
      {
        if(buf->size >= 4 + result)
        {
          signed int return_value_detect_h264$1;
          return_value_detect_h264$1=detect_h264(p);
          this->video_type = (unsigned int)return_value_detect_h264$1;
        }

      }

      if(!(this->video_type == 0u))
        tmp_if_expr$2 = this->video_type;

      else
        tmp_if_expr$2 = (unsigned int)0x02000000;
      buf->type = tmp_if_expr$2;
      buf->pts = this->pts;
      buf->decoder_info[(signed long int)0] = (unsigned int)(this->pts - this->dts);
      if(this->video_type == 33554432u)
      {
        if(!(this->ffmpeg_mpeg2_decoder == 0))
        {
          unsigned char type;
          type=pes_get_picture_type(buf->content, buf->size);
          if(!(type == 0))
          {
            post_frame_end(this, buf);
            if((signed int)type == 3)
              buf->pts = (signed long int)0;

          }

        }

      }

      else
        if(this->video_type == 38600704u)
        {
          if(buf->size >= 4)
          {
            if(*((const unsigned int *)p) == 0x09010000U)
              post_frame_end(this, buf);

            unsigned char *end = buf->content + (signed long int)buf->size;
            if(*((const unsigned int *)(end + -4l)) == 0x0a010000U)
            {
              do
                if(iSysLogLevel >= 2)
                  x_syslog(6, log_module_demux_xvdr, "post_frame_h264: Still frame ? (frame ends with end of sequence NAL unit)");

              while((_Bool)0);
              buf->decoder_flags = buf->decoder_flags | (unsigned int)0x0004;
            }

          }

        }

      buf->content = p;
      buf->size = (signed int)this->packet_len;
      check_newpts(this, buf, 1);
      this->video_fifo->put(this->video_fifo, buf);
      return -1;
    }
}

// pes_change_pts
// file tools/pes.c line 65
void pes_change_pts(unsigned char *buf, signed int len, signed long int new_pts)
{
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$1;
  if((-16 & (signed int)buf[3l]) == 0xE0)
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    if((-32 & (signed int)buf[3l]) == 0xC0)
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = 0xBD == (signed int)buf[(signed long int)3] ? (_Bool)1 : (_Bool)0;
    tmp_if_expr$2 = tmp_if_expr$1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$2)
  {
    if((0xC0 & (signed int)buf[6l]) == 0x80)
    {
      if((0x30 & (signed int)buf[6l]) == 0)
      {
        if(len >= 14)
        {
          if(!((0x80 & (signed int)buf[7l]) == 0))
          {
            buf[(signed long int)9] = (unsigned char)(new_pts >> 29 & (signed long int)0x0E | (signed long int)((signed int)buf[(signed long int)9] & 0xf1));
            buf[(signed long int)10] = (unsigned char)(new_pts >> 22 & (signed long int)0xFF);
            buf[(signed long int)11] = (unsigned char)(new_pts >> 14 & (signed long int)0xFE | (signed long int)((signed int)buf[(signed long int)11] & 0x01));
            buf[(signed long int)12] = (unsigned char)(new_pts >> 7 & (signed long int)0xFF);
            buf[(signed long int)13] = (unsigned char)(new_pts << 1 & (signed long int)0xFE | (signed long int)((signed int)buf[(signed long int)13] & 0x01));
          }

        }

      }

    }

  }

}

// pes_get_dts
// file xine/../tools/pes.h line 71
signed long int pes_get_dts(const unsigned char *buf, signed int len)
{
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  if((-16 & (signed int)buf[3l]) == 0xE0)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    if((-32 & (signed int)buf[3l]) == 0xC0)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = 0xBD == (signed int)buf[(signed long int)3] ? (_Bool)1 : (_Bool)0;
    tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3)
  {
    if(!((0xC0 & (signed int)buf[6l]) == 0x80))
      return -1L;

    if(!((0x30 & (signed int)buf[6l]) == 0))
      return -1L;

    if(len >= 19)
    {
      if(!((0x40 & (signed int)buf[7l]) == 0))
      {
        signed long int return_value_parse_timestamp$1;
        return_value_parse_timestamp$1=parse_timestamp(buf + (signed long int)14);
        return return_value_parse_timestamp$1;
      }

    }

  }

  return -1L;
}

// pes_get_picture_type
// file tools/pes.h line 82
unsigned char pes_get_picture_type(const unsigned char *buf, signed int len)
{
  signed int i = 8 + (signed int)buf[(signed long int)8] + 1;
  buf = buf + (signed long int)i;
  len = len - i;
  signed int return_value_h264_get_picture_type$1;
  if((signed int)*buf == 0x00)
  {
    if((signed int)buf[1l] == 0x00)
    {
      if((signed int)buf[2l] == 0x01)
      {
        if((signed int)buf[3l] == 0x09)
        {
          return_value_h264_get_picture_type$1=h264_get_picture_type(buf, len);
          return (unsigned char)return_value_h264_get_picture_type$1;
        }

        signed int return_value_mpeg2_get_picture_type$2;
        return_value_mpeg2_get_picture_type$2=mpeg2_get_picture_type(buf, len);
        return (unsigned char)return_value_mpeg2_get_picture_type$2;
      }

    }

  }

  return (unsigned char)0;
}

// pes_get_pts
// file tools/pes.h line 70
signed long int pes_get_pts(const unsigned char *buf, signed int len)
{
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  if((-16 & (signed int)buf[3l]) == 0xE0)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    if((-32 & (signed int)buf[3l]) == 0xC0)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = 0xBD == (signed int)buf[(signed long int)3] ? (_Bool)1 : (_Bool)0;
    tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$3)
  {
    if(!((0xC0 & (signed int)buf[6l]) == 0x80))
      return -1L;

    if(!((0x30 & (signed int)buf[6l]) == 0))
      return -1L;

    if(len >= 14)
    {
      if(!((0x80 & (signed int)buf[7l]) == 0))
      {
        signed long int return_value_parse_timestamp$1;
        return_value_parse_timestamp$1=parse_timestamp(buf + (signed long int)9);
        return return_value_parse_timestamp$1;
      }

    }

  }

  return -1L;
}

// pes_get_video_size
// file xine/../tools/pes.h line 83
signed int pes_get_video_size(const unsigned char *buf, signed int len, struct video_size_s *size, signed int h264)
{
  signed int i = 8 + (signed int)buf[(signed long int)8] + 1;
  buf = buf + (signed long int)i;
  len = len - i;
  _Bool tmp_if_expr$2;
  if(!(h264 == 0))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = *((const unsigned int *)buf) == 0x09010000U ? (_Bool)1 : (_Bool)0;
  signed int return_value_h264_get_video_size$1;
  if(tmp_if_expr$2)
  {
    return_value_h264_get_video_size$1=h264_get_video_size(buf, len, size);
    return return_value_h264_get_video_size$1;
  }

  else
  {
    signed int return_value_mpeg2_get_video_size$3;
    return_value_mpeg2_get_video_size$3=mpeg2_get_video_size(buf, len, size);
    return return_value_mpeg2_get_video_size$3;
  }
}

// pes_is_frame_h264
// file tools/pes.c line 108
signed int pes_is_frame_h264(const unsigned char *buf, signed int len)
{
  _Bool tmp_if_expr$1;
  if(!(len >= 9))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = len < 9 + (signed int)buf[(signed long int)8] ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$1)
    return 0;

  else
    if(!((0xC0 & (signed int)buf[6l]) == 0x80))
      return 0;

    else
    {
      buf = buf + (signed long int)(9 + (signed int)buf[(signed long int)8]);
      if(*((const unsigned int *)buf) == 0x09010000U)
        return 1;

      else
        return 0;
    }
}

// pes_strip_pts_dts
// file tools/pes.c line 85
signed int pes_strip_pts_dts(unsigned char *buf, signed int size)
{
  if(size >= 14)
  {
    if(!((0x80 & (signed int)buf[7l]) == 0))
    {
      signed int n = 5;
      signed int pes_len = (signed int)buf[(signed long int)4] << 8 | (signed int)buf[(signed long int)5];
      if(!((0xC0 & (signed int)buf[6l]) == 0x80))
        return size;

      if(!((0x30 & (signed int)buf[6l]) == 0))
        return size;

      if(size >= 19)
      {
        if(!((0x40 & (signed int)buf[7l]) == 0))
          n = n + 5;

      }

      pes_len = pes_len - n;
      buf[(signed long int)4] = (unsigned char)(pes_len >> 8);
      buf[(signed long int)5] = (unsigned char)(pes_len & 0xff);
      buf[(signed long int)7] = buf[(signed long int)7] & (unsigned char)0x3f;
      buf[(signed long int)8] = buf[(signed long int)8] - (unsigned char)n;
      memmove$link1((void *)(buf + (signed long int)4 + (signed long int)n), (const void *)(buf + (signed long int)9 + (signed long int)n), (unsigned long int)((size - 9) - n));
      return size - n;
    }

  }

  return size;
}

// post_frame_end
// file xine/demux_xvdr.c line 297
static void post_frame_end(struct demux_xvdr_s *this, struct buf_element_s *vid_buf)
{
  struct buf_element_s *cbuf;
  struct buf_element_s *return_value;
  return_value=this->video_fifo->buffer_pool_try_alloc(this->video_fifo);
  struct buf_element_s *tmp_if_expr$1;
  struct buf_element_s *return_value_1;
  if(!(return_value == ((struct buf_element_s *)NULL)))
    tmp_if_expr$1 = return_value;

  else
  {
    return_value_1=this->audio_fifo->buffer_pool_try_alloc(this->audio_fifo);
    tmp_if_expr$1 = return_value_1;
  }
  cbuf = tmp_if_expr$1;
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  _Bool tmp_if_expr$5;
  if(cbuf == ((struct buf_element_s *)NULL))
  {
    if(iSysLogLevel >= 2)
      x_syslog(6, log_module_demux_xvdr, "post_frame_end(): buffer_pool_try_alloc() failed, retrying");

    xine_usec_sleep((unsigned int)(10 * 1000));
    cbuf=this->video_fifo->buffer_pool_try_alloc(this->video_fifo);
    if(iSysLogLevel >= 1)
    {
      x_syslog(3, log_module_demux_xvdr, "post_frame_end(): get_buf_element() failed !");
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      if(!(*return_value___errno_location$4 == 0))
      {
        return_value___errno_location$2=__errno_location();
        return_value_strerror$3=strerror(*return_value___errno_location$2);
        x_syslog(3, log_module_demux_xvdr, "   (ERROR (%s,%d): %s)", (const void *)"xine/demux_xvdr.c", 307, return_value_strerror$3);
      }

    }

  }

  else
  {
    cbuf->type = this->video_type;
    cbuf->decoder_flags = (unsigned int)0x0004;
    if(this->bih_posted == 0)
    {
      struct video_size_s size = { .width=(unsigned short int)0, .height=0, .pixel_aspect={ .num=0, .den=0 } };
      signed int return_value_pes_get_video_size$6;
      return_value_pes_get_video_size$6=pes_get_video_size(vid_buf->content, vid_buf->size, &size, (signed int)(this->video_type == (unsigned int)0x024D0000));
      if(!(return_value_pes_get_video_size$6 == 0))
      {
        cbuf->decoder_flags = cbuf->decoder_flags | (unsigned int)0x0002;
        if(this->video_type == 38600704u)
        {
          if(!(this->coreavc_h264_decoder == 0))
          {
            struct anonymous$53 *bmi = (struct anonymous$53 *)cbuf->content;
            cbuf->decoder_flags = cbuf->decoder_flags | (unsigned int)0x0008;
            cbuf->decoder_flags = cbuf->decoder_flags | (unsigned int)0x0400;
            cbuf->size = (signed int)sizeof(struct anonymous$53) /*40ul*/ ;
            memset$link1((void *)bmi, 0, sizeof(struct anonymous$53) /*40ul*/ );
            bmi->biSize = (signed int)sizeof(struct anonymous$53) /*40ul*/ ;
            bmi->biWidth = (signed int)size.width;
            bmi->biHeight = (signed int)size.height;
            bmi->biPlanes = (signed short int)1;
            bmi->biBitCount = (signed short int)24;
            bmi->biCompression = (unsigned int)0x34363248;
            bmi->biSizeImage = 0;
            bmi->biXPelsPerMeter = size.pixel_aspect.num;
            bmi->biYPelsPerMeter = size.pixel_aspect.den;
            bmi->biClrUsed = 0;
            bmi->biClrImportant = 0;
          }

        }

        if(!(size.pixel_aspect.num == 0))
        {
          if(!(this->video_type == 38600704u))
            tmp_if_expr$5 = (_Bool)1;

          else
            tmp_if_expr$5 = this->coreavc_h264_decoder != 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$5)
          {
            cbuf->decoder_flags = cbuf->decoder_flags | (unsigned int)0x0008;
            cbuf->decoder_flags = cbuf->decoder_flags | (unsigned int)0x0800;
            if(!((signed int)size.height >= size.pixel_aspect.num))
            {
              cbuf->decoder_info[(signed long int)1] = (unsigned int)(size.pixel_aspect.num / (signed int)size.height);
              cbuf->decoder_info[(signed long int)2] = (unsigned int)(size.pixel_aspect.den / (signed int)size.width);
            }

            else
            {
              cbuf->decoder_info[(signed long int)1] = (unsigned int)(size.pixel_aspect.num * (signed int)size.width);
              cbuf->decoder_info[(signed long int)2] = (unsigned int)(size.pixel_aspect.den * (signed int)size.height);
            }
          }

        }

        if(iSysLogLevel >= 3)
          x_syslog(7, log_module_demux_xvdr, "post_frame_end: video width %d, height %d, pixel aspect %d:%d", size.width, size.height, size.pixel_aspect.num, size.pixel_aspect.den);

        this->bih_posted = (unsigned char)1;
      }

    }

    this->video_fifo->put(this->video_fifo, cbuf);
  }
}

// post_sequence_end
// file xine/demux_xvdr.c line 272
static void post_sequence_end(struct fifo_buffer_s *fifo, unsigned int video_type)
{
  struct buf_element_s *buf;
  buf=fifo->buffer_pool_try_alloc(fifo);
  if(!(buf == ((struct buf_element_s *)NULL)))
  {
    buf->type = video_type;
    buf->size = 4;
    buf->decoder_flags = (unsigned int)0x0004;
    buf->content[(signed long int)0] = (unsigned char)0x00;
    buf->content[(signed long int)1] = (unsigned char)0x00;
    buf->content[(signed long int)2] = (unsigned char)0x01;
    buf->content[(signed long int)3] = (unsigned char)(video_type == (unsigned int)0x024D0000 ? 0x0a : 0xb7);
    fifo->put(fifo, buf);
  }

}

// post_vdr_event
// file xine_input_vdr.c line 4724
static signed int post_vdr_event(struct vdr_input_plugin_if_s *this_if, const char *msg)
{
  struct vdr_input_plugin_s *this = (struct vdr_input_plugin_s *)this_if;
  signed long int return_value_write_control$1;
  if(!(msg == ((const char *)NULL)))
  {
    if(!(this->fd_control >= 0))
      goto __CPROVER_DUMP_L1;

    return_value_write_control$1=write_control(this, msg);
    return (signed int)return_value_write_control$1;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_vdr, "post_vdr_event: error ! \"%s\" not delivered.", (_Bool)msg ? msg : "<null>");

    while((_Bool)0);
    return -1;
  }
}

// postprocess_buf
// file xine_input_vdr.c line 4867
static void postprocess_buf(struct vdr_input_plugin_s *this, struct buf_element_s *buf, signed int need_pause)
{
  if(!(need_pause == 0))
  {
    pthread_mutex_lock(&this->lock);
    scr_tuning_set_paused(this);
    pthread_mutex_unlock(&this->lock);
  }

  _Bool tmp_if_expr$1;
  if(!(buf->type == 83886080u))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = (signed int)buf->content[(signed long int)0] == 0x47 ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr$1)
  {
    if(!(this->live_mode == 0))
    {
      if(!(this->I_frames >= 4u))
      {
        if((-16 & (signed int)buf->content[3l]) == 0xE0)
        {
          if(buf->size >= 33)
            update_frames(this, buf->content, buf->size);

        }

      }

    }

  }

}

// preprocess_buf
// file xine_input_vdr.c line 4776
static struct buf_element_s * preprocess_buf(struct vdr_input_plugin_s *this, struct buf_element_s *buf)
{
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$3;
  signed int return_value_ts_get_pcr_n$1;
  _Bool tmp_if_expr$2;
  if(buf->type == 251723776u)
  {
    pthread_mutex_lock(&this->lock);
    if(this->stream_start == 0)
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "BLANK in middle of stream! bufs queue %d , video_fifo %d", this->block_buffer->fifo_size, this->stream->video_fifo->fifo_size);

      while((_Bool)0);

    else
    {
      vdr_x_demux_control_newpts(this->stream, (signed long int)0, (unsigned int)0x0100);
      queue_blank_yv12(this);
    }
    pthread_mutex_unlock(&this->lock);
    buf->free_buffer(buf);
    return (struct buf_element_s *)(void *)0;
  }

  else
    if(!(buf->type == 83951616u))
    {
      if(buf->type == 84017152u)
        goto __CPROVER_DUMP_L6;

      if(buf->type == 83886080u)
        goto __CPROVER_DUMP_L6;

      return buf;
    }

    else
    {

    __CPROVER_DUMP_L6:
      ;
      pthread_mutex_lock(&this->lock);
      strip_network_headers(this, buf);
      if(!(this->curpos >= this->discard_index))
      {
        if(this->guard_index >= this->curpos)
          goto __CPROVER_DUMP_L7;

        pthread_mutex_unlock(&this->lock);
        buf->free_buffer(buf);
        return (struct buf_element_s *)(void *)0;
      }

      else
      {

      __CPROVER_DUMP_L7:
        ;
        this->curpos = this->curpos + (unsigned long int)buf->size;
        this->curframe = this->curframe + 1u;
        if(!((signed int)*buf->content == 0x47))
        {
          if(!((signed int)buf->content[3l] == 0xBE))
            goto __CPROVER_DUMP_L8;

          pthread_mutex_unlock(&this->lock);
          return buf;
        }

        else
        {

        __CPROVER_DUMP_L8:
          ;
          if(!(this->stream_start == 0))
          {
            this->stream_start = (unsigned char)0;
            pthread_mutex_lock(&this->stream->first_frame_lock);
            this->stream->first_frame_flag = (unsigned int)2;
            pthread_mutex_unlock(&this->stream->first_frame_lock);
            memset((void *)&this->scr_buf, 0, sizeof(struct anonymous$29) /*16ul*/ );
            this->scr->got_pcr(this->scr, (signed long int)-1);
          }

          if(!(this->live_mode == 0))
            tmp_if_expr$4 = (_Bool)1;

          else
          {
            if(this->fd_control >= 0)
              tmp_if_expr$3 = !(this->fixed_scr != 0) ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$3 = (_Bool)0;
            tmp_if_expr$4 = tmp_if_expr$3 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr$4)
          {
            signed long int pcr = (signed long int)-1;
            if((signed int)*buf->content == 0x47)
            {
              return_value_ts_get_pcr_n$1=ts_get_pcr_n(buf->content, buf->size / 188, &pcr);
              if(!(return_value_ts_get_pcr_n$1 == 0))
              {
                if(pcr >= 0l)
                  this->scr->got_pcr(this->scr, pcr);

              }

            }

            if((-32 & (signed int)buf->content[3l]) == 0xC0)
              tmp_if_expr$2 = (_Bool)1;

            else
              tmp_if_expr$2 = 0xBD == (signed int)buf->content[(signed long int)3] ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$2)
            {
              pcr=pes_get_pts(buf->content, buf->size);
              if(pcr >= 1l)
                this->scr->got_pcr(this->scr, pcr);

            }

          }

          pthread_mutex_unlock(&this->lock);
          return buf;
        }
      }
    }
}

// printf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 102
static inline signed int printf(const char * restrict __fmt, ...)
{
  void *return_value___builtin_va_arg_pack$1;
  return_value___builtin_va_arg_pack$1=__builtin_va_arg_pack();
  signed int return_value___printf_chk$2;
  return_value___printf_chk$2=__printf_chk(2 - 1, __fmt, return_value___builtin_va_arg_pack$1);
  return return_value___printf_chk$2;
}

// printf_control
// file xine_input_vdr.c line 1017
static signed long int printf_control(struct vdr_input_plugin_s *this, const char *fmt, ...)
{
  void **argp;
  char buf[512l];
  signed long int result;
  argp = (void **)&fmt;
  vsnprintf(buf, sizeof(char [512l]) /*512ul*/ , fmt, argp);
  buf[(signed long int)(sizeof(char [512l]) /*512ul*/  - (unsigned long int)1)] = (char)0;
  result=write_control(this, buf);
  argp = ((void **)NULL);
  return result;
}

// printf_vdr
// file xine_input_vdr.c line 1176
static void printf_vdr(struct vdr_input_plugin_s *this, const char *fmt, ...)
{
  void **argp;
  char buf[512l];
  argp = (void **)&fmt;
  vsnprintf(buf, sizeof(char [512l]) /*512ul*/ , fmt, argp);
  buf[(signed long int)(sizeof(char [512l]) /*512ul*/  - (unsigned long int)1)] = (char)0;
  puts_vdr(this, buf);
  argp = ((void **)NULL);
}

// pts_wrap_workaround
// file xine/demux_xvdr.c line 182
static void pts_wrap_workaround(struct demux_xvdr_s *this, struct buf_element_s *buf, signed int video)
{
  if(buf->pts >= 1l)
  {
    if(!(video == 0))
    {
      if(!(this->last_vpts >= 14400l))
      {
        if(this->last_vpts >= 1l)
        {
          if(buf->pts >= 8589920192l)
          {
            if(this->send_newpts == 0)
            {
              do
                if(iSysLogLevel >= 2)
                  x_syslog(6, log_module_demux_xvdr, "VIDEO pts wrap in middle of GOP, ignoring video pts %ld", buf->pts);

              while((_Bool)0);
              buf->pts = 0L;
              goto __CPROVER_DUMP_L7;
            }

          }

        }

      }

      this->last_vpts = buf->pts;
      goto __CPROVER_DUMP_L7;
    }

    else
      if(buf->pts >= 1077936129l)
      {
        if(!(this->last_vpts >= 0x40000000L))
        {
          if(this->last_vpts >= 1l)
          {
            do
              if(iSysLogLevel >= 2)
                x_syslog(6, log_module_demux_xvdr, "VIDEO pts wrap before AUDIO, ignoring audio pts %ld", buf->pts);

            while((_Bool)0);
            buf->pts = 0L;
          }

        }

      }

  }


__CPROVER_DUMP_L7:
  ;
}

// put_control_buf
// file xine_input_vdr.c line 1508
static void put_control_buf(struct fifo_buffer_s *buffer, struct fifo_buffer_s *pool, signed int cmd)
{
  struct buf_element_s *buf;
  buf=pool->buffer_pool_try_alloc(pool);
  if(!(buf == ((struct buf_element_s *)NULL)))
  {
    buf->type = (unsigned int)cmd;
    buffer->put(buffer, buf);
  }

}

// put_control_buf$link1
// file xine/demux_xvdr.c line 258
static void put_control_buf$link1(struct fifo_buffer_s *buffer$link1, struct fifo_buffer_s *pool$link1, signed int cmd$link1)
{
  struct buf_element_s *buf$link1;
  buf$link1=pool$link1->buffer_pool_try_alloc(pool$link1);
  if(!(buf$link1 == ((struct buf_element_s *)NULL)))
  {
    buf$link1->type = (unsigned int)cmd$link1;
    buffer$link1->put(buffer$link1, buf$link1);
  }

}

// puts_vdr
// file xine_input_vdr.c line 1165
static void puts_vdr(struct vdr_input_plugin_s *this, const char *s)
{
  if(!(this->fd_control >= 0))
  {
    if(!(this->$anon0.$anon0.funcs.xine_input_event == ((void (*)(struct frontend_s *, const char *, const char *))NULL)))
      this->$anon0.$anon0.funcs.xine_input_event(this->$anon0.$anon0.funcs.fe_handle, s, (const char *)(void *)0);

  }

  else
    write_control(this, s);
}

// queue_blank_yv12
// file xine_input_vdr.c line 1696
static void queue_blank_yv12(struct vdr_input_plugin_s *this)
{
  _Bool tmp_if_expr$1;
  if(this == ((struct vdr_input_plugin_s *)NULL))
    tmp_if_expr$1 = (_Bool)1;

  else
    tmp_if_expr$1 = !(this->stream != ((struct xine_stream_s *)NULL)) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !(this->stream->video_out != ((struct xine_video_port_s$1 *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr$2)
  {
    struct vo_frame_s$1 *img = (struct vo_frame_s$1 *)(void *)0;
    signed int width;
    unsigned int return_value__x_stream_info_get$3;
    return_value__x_stream_info_get$3=_x_stream_info_get(this->stream, 2);
    width = (signed int)return_value__x_stream_info_get$3;
    signed int height;
    unsigned int return_value__x_stream_info_get$4;
    return_value__x_stream_info_get$4=_x_stream_info_get(this->stream, 3);
    height = (signed int)return_value__x_stream_info_get$4;
    signed int ratio;
    unsigned int return_value__x_stream_info_get$5;
    return_value__x_stream_info_get$5=_x_stream_info_get(this->stream, 4);
    ratio = (signed int)return_value__x_stream_info_get$5;
    double dratio;
    if(height >= 1201 || width >= 1921 || !(height >= 288) || !(width >= 360))
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "queue_blank_yv12: invalid dimensions %dx%d in stream_info !", width, height);

      while((_Bool)0);

    else
    {
      if(ratio >= 13301 && !(ratio >= 13400))
        dratio = 4.0 / 3.0;

      else
        if(ratio >= 17701 && !(ratio >= 17800))
          dratio = 16.0 / 9.0;

        else
          if(ratio >= 21001 && !(ratio >= 22000))
            dratio = 2.11 / 1.0;

          else
            dratio = (double)ratio / 10000.0;
      set_still_mode(this, 0);
      reset_scr_tuning(this);
      _x_demux_control_newpts(this->stream, (signed long int)0, (unsigned int)0x0100);
      this->class->xine->port_ticket->acquire(this->class->xine->port_ticket, 1);
      img=this->stream->video_out->get_frame(this->stream->video_out, (unsigned int)width, (unsigned int)height, dratio, 50 << 24 | 49 << 16 | 86 << 8 | 89, 1 | 2);
      this->class->xine->port_ticket->release(this->class->xine->port_ticket, 1);
      if(!(img == ((struct vo_frame_s$1 *)NULL)))
      {
        if(img->format == 842094169)
        {
          if(!(img->base[0l] == ((unsigned char *)NULL)))
          {
            if(!(img->base[1l] == ((unsigned char *)NULL)))
            {
              if(!(img->base[2l] == ((unsigned char *)NULL)))
              {
                memset((void *)img->base[(signed long int)0], 0x00, (unsigned long int)(img->pitches[(signed long int)0] * img->height));
                memset((void *)img->base[(signed long int)1], 0x80, (unsigned long int)((img->pitches[(signed long int)1] * img->height) / 2));
                memset((void *)img->base[(signed long int)2], 0x80, (unsigned long int)((img->pitches[(signed long int)2] * img->height) / 2));
                img->duration = 0;
                img->pts = (signed long int)0;
                img->bad_frame = 0;
                wait_fifos_empty(this->stream, 100);
                this->stream->metronom->set_option(this->stream->metronom, 7, (signed long int)2000);
                img->draw(img, this->stream);
                this->stream->metronom->set_option(this->stream->metronom, 7, (signed long int)((4 * 90000) / 25));
              }

            }

          }

        }

        img->free(img);
      }

    }
  }

}

// queue_nosignal
// file xine_input_vdr.c line 1746
static void queue_nosignal(struct vdr_input_plugin_s *this)
{
  char *data = (char *)(void *)0;
  char *tmp = (char *)(void *)0;
  signed int datalen = 0;
  signed int pos = 0;
  struct buf_element_s *buf = (struct buf_element_s *)(void *)0;
  struct fifo_buffer_s *fifo = this->stream->video_fifo;
  char *path;
  char *home;
  signed int return_value_1;
  return_value_1=fifo->num_free(fifo);
  signed int return_value;
  signed int *return_value___errno_location$5;
  char *return_value_strerror$6;
  signed int tmp_if_expr$8;
  if(!(return_value_1 >= 10))
  {
    if(iSysLogLevel >= 2)
    {
      return_value=fifo->num_free(fifo);
      x_syslog(6, log_module_input_vdr, "queue_nosignal: not enough free buffers (%d) !", return_value);
    }

  }

  else
  {
    const char *return_value_xine_get_homedir$1;
    return_value_xine_get_homedir$1=xine_get_homedir();
    signed int return_value_asprintf$2;
    return_value_asprintf$2=asprintf(&home, "%s/.xine/nosignal.mpg", return_value_xine_get_homedir$1);
    if(return_value_asprintf$2 >= 0)
    {
      signed int fd;
      path = home;
      fd=open(path, 00);
      if(!(fd >= 0))
      {
        path = "/etc/vdr/plugins/xineliboutput/nosignal.mpg";
        fd=open(path, 00);
      }

      if(!(fd >= 0))
      {
        path = "/etc/vdr/plugins/xine/noSignal.mpg";
        fd=open(path, 00);
      }

      if(!(fd >= 0))
      {
        path = "/video/plugins/xineliboutput/nosignal.mpg";
        fd=open(path, 00);
      }

      if(!(fd >= 0))
      {
        path = "/video/plugins/xine/noSignal.mpg";
        fd=open(path, 00);
      }

      if(!(fd >= 0))
      {
        path = "/usr/share/vdr/xineliboutput/nosignal.mpv";
        fd=open(path, 00);
      }

      if(fd >= 0)
      {
        void *return_value_malloc$3;
        return_value_malloc$3=malloc((unsigned long int)0x10000);
        data = (char *)return_value_malloc$3;
        tmp = data;
        signed long int return_value_read$4;
        return_value_read$4=read(fd, (void *)data, (unsigned long int)0x10000);
        datalen = (signed int)return_value_read$4;
        if(datalen == 0x10000)
        {
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "WARNING: custom \"no signal\" image %s too large", path);

        }

        else
          if(!(datalen >= 1))
          {
            if(iSysLogLevel >= 1)
            {
              x_syslog(3, log_module_input_vdr, "error reading %s", path);
              signed int *return_value___errno_location$7;
              return_value___errno_location$7=__errno_location();
              if(!(*return_value___errno_location$7 == 0))
              {
                return_value___errno_location$5=__errno_location();
                return_value_strerror$6=strerror(*return_value___errno_location$5);
                x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 1777, return_value_strerror$6);
              }

            }

          }

          else
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_input_vdr, "using custom \"no signal\" image %s", path);

        close(fd);
      }

      free((void *)home);
      if(!(datalen >= 1))
      {
        static const unsigned char v_mpg_nosignal[13196l] = { 0, 0, 1, 179, ',', 2, '@', '3', 6, 26, 163, 'p', 0, 0, 1, 181, 20, 130, 0, 1, 0, 0, 0, 0, 1, 181, '#', 5, 5, 5, 11, 2, 18, 0, 0, 0, 1, 184, 0, 8, 0, '@', 0, 0, 1, 0, 0, 15, 255, 248, 0, 0, 1, 181, 143, 255, 247, 156, 0, 0, 0, 1, 1, '3', 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'k', ',', 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 'd', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '5', 142, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 214, '(', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 26, 195, 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, '`', 0, 0, 1, 2, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, 3, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, 4, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, 5, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, 6, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 17, '}', 's', 207, 'R', 242, 231, 'l', '/', '4', 246, '%', 146, 217, '-', 'c', 'r', 235, 178, 236, 131, 173, 150, 12, 'n', 26, '4', '~', '\\', 217, 'e', 148, 'u', 140, 'D', 138, 229, '5', 214, 'q', 184, 4, 'l', 191, 185, 'X', 203, 22, 201, 'o', 140, 'f', 252, 219, '%', 179, '(', 'U', '*', 140, 13, ')', 184, 'h', 210, 202, 24, 210, 202, 24, 196, 'e', 27, 198, 141, ',', 161, 141, '.', '[', '%', 178, 'x', 198, 3, 9, ',', 6, 146, 27, 198, 140, 223, 223, 167, 205, 150, 'X', '#', 190, '4', 'e', 'F', 28, 185, 238, 230, 'W', '?', '6', 21, 'q', 25, ';', 'r', 226, 217, 'c', '1', '"', 185, 'w', ';', 28, 254, '7', 10, 185, '-', 131, '[', 134, 140, 'E', 245, 204, 186, 233, 'x', 216, 4, 'm', 159, 185, 'X', 'Y', 'C', 25, 229, 136, '\\', 190, 172, 'n', '\\', 217, 'e', 129, 133, 196, 190, '-', 227, 'F', 150, 'P', 198, 150, 'P', 198, 25, 'A', 205, 227, 'F', 150, 'P', 207, 24, 211, 'r', 216, 150, 'O', 'F', ' ', 230, '#', 'x', 209, 165, 150, 'U', 150, '1', 23, 215, '<', 245, '/', '.', 'v', 194, 243, 'X', 150, 'K', 'd', 181, 158, 229, 215, 'e', 178, 'Q', 150, 203, 6, '7', 13, 26, '%', 149, 'e', '!', 180, 'a', 147, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 0, 0, 1, 7, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'b', '<', 144, 'k', '{', '{', 'h', ' ', 'y', '`', ' ', 129, 140, ',', 18, '@', 128, 16, 127, 160, 19, 192, 'H', 19, 127, 193, 188, '@', 242, 'A', 173, 237, 193, 15, 203, 1, 4, 12, 1, '4', 8, 1, 7, 250, 1, '<', 4, 129, '7', 252, 27, 140, 200, 8, 0, 134, 8, '?', 171, 'm', 129, '@', 11, 167, 't', 148, 0, '-', 'o', 164, 199, 242, 8, 30, 137, 160, 128, 15, '8', 238, 159, 'i', 'S', '9', 208, '@', 251, 189, 0, 'e', 152, 237, 161, 223, 189, 221, 137, 227, 141, 168, 4, 15, 193, 250, 130, 8, 'L', 255, 192, 28, 2, 0, 23, 128, '\'', 'w', 152, 'u', 222, 'p', 1, 'i', 20, 0, 177, 254, 218, '/', 'p', '8', 191, 'm', 235, 'e', 204, 200, 'T', 168, '+', '5', '&', 129, 139, 27, 'I', '`', 129, 250, '=', 2, 7, 173, 'T', 160, 146, 6, 212, 1, 165, 'O', 3, '~', 134, 148, 26, 8, '?', 206, 172, '@', 17, 9, 16, 8, 31, 26, 8, 0, 'z', 0, 'Z', 8, 31, 'X', 0, ']', 'y', 201, '2', 128, 31, '{', 'h', 2, 130, '\'', '?', 0, 8, 200, 254, 'G', 175, 216, 0, 235, '@', ',', 'q', '<', 235, 'P', 'R', 228, '}', 4, ' ', 7, 198, 210, 0, '[', 236, 240, 'A', 253, '`', '@', 247, '0', 5, 228, 'n', 224, 'g', 'd', '`', '@', 3, 239, 184, 2, 231, 138, '@', 131, '@', 14, ',', 4, 191, 233, 214, 225, '"', '|', 'u', 236, 'G', 249, 0, 'O', 240, 224, 211, 8, 223, 255, 248, 3, 'H', 254, '%', 4, 'o', 241, 'p', 3, 144, 3, 'C', 'R', 254, ',', ']', '>', '7', 213, 0, 20, 128, '7', 251, 128, '1', 0, ',', 0, '\\', 8, 0, 162, 0, 'W', 245, 231, 'C', 139, 0, 'z', 0, 172, 16, 0, 176, 16, 0, 172, 16, '>', 220, 0, '@', 0, 207, 'I', 180, 16, 128, 147, 254, 8, 0, 'w', 200, 2, 'P', 3, 'I', 'A', 15, 253, 'U', '>', 157, 'P', 10, 132, 141, 'm', 227, 'A', 3, 241, 192, 11, 128, 30, 130, 7, 231, 130, 0, 28, '}', 191, 160, 8, '@', 31, 8, 211, 136, ' ', 7, 214, 153, 158, 247, 217, 224, 7, 194, 229, 220, 14, 182, 'S', 228, ':', 150, 219, 'A', 3, 225, 129, 0, 16, 128, 11, 193, 0, 12, 129, 3, 243, 128, 30, 255, 0, 26, 11, 21, 236, '&', 'a', 31, 233, 216, 143, 158, 4, 194, 'p', 186, 'h', 1, 245, 202, 'Y', 135, 1, 'M', 233, '@', 11, 132, 'r', 0, 'R', 8, 31, '\\', 8, 30, 230, 0, '`', 0, '_', 238, 'O', 212, 206, 0, 13, 128, 28, '}', 192, 22, '}', '9', 'w', 185, 'f', 149, 215, 148, 254, 'w', 16, 17, 255, 228, 2, 207, 237, 141, 'P', ' ', 3, '8', 1, 23, 208, 16, '=', 200, 16, 0, 164, 16, 0, 192, 0, 132, 0, 160, 1, '@', 171, 'K', 17, 246, 223, 187, 192, 25, '|', 175, '`', 136, 0, 170, '@', 'w', 250, 145, 196, '`', 5, 'g', '@', 239, ')', 212, 184, 'S', 'n', 8, 0, 'V', 0, 131, 235, 246, '7', 249, 247, 'p', 3, '|', 226, 170, 'h', 3, 240, 6, '@', 14, 'z', '~', ';', 237, '6', 'Z', 134, 'O', 184, '!', 0, 'P', 'x', '|', 129, 168, 222, '`', ' ', '|', '0', ' ', '|', 208, 1, 'p', 1, 143, 'x', 8, 31, 164, 8, 0, 'R', 8, ' ', '`', 240, 7, 186, '@', 4, 31, 237, 255, 2, 0, 26, 130, 7, 227, 2, 0, 30, 128, '/', 0, 'l', 0, 220, 1, 200, 1, 'n', 255, '\'', 240, 141, 187, 159, 255, 248, 2, 'J', 8, '?', 209, '3', '(', 1, 230, 211, 215, 27, 'x', '^', 'K', 'T', 212, 24, '{', 139, '!', 'V', 244, 192, 129, 248, 160, 12, 'y', 4, 15, '`', 4, 0, '<', 4, 0, '-', 228, 1, 'w', 194, ' ', '"', 127, 184, 158, 128, 28, 253, '@', 31, 16, 5, 130, 24, 4, '_', 198, 224, 191, 'a', 'v', 'l', 136, 't', 18, ')', 20, 184, 220, '`', 2, 177, '0', 16, 1, '$', 0, 156, 16, 0, 196, 1, 191, 214, '`', '$', 127, 176, 1, 135, 220, 1, 215, 203, 236, 4, 127, 253, 223, 231, 'b', 13, 161, 'f', ']', 'm', 31, '`', '@', 3, 'B', '(', ' ', '}', 'x', 1, 'X', 3, 192, 2, 128, 2, 17, 31, 'a', '>', 198, 'h', 162, '?', 0, 21, 0, '-', 'x', 175, 183, '}', 168, 1, 213, 226, 251, 238, 216, 8, 127, 238, 'i', 'P', 254, 'O', '*', 183, 'S', 132, '}', 0, 20, 0, ':', 0, '1', 0, '7', 251, 162, 7, 153, 8, 223, 206, 252, 244, 229, 253, 185, '7', 213, 27, 231, 185, 254, 128, '3', 4, 15, 176, 4, 15, 203, 4, 0, ']', 'x', 1, 128, 2, ')', 205, 4, '0', 14, 231, 255, 245, 0, 'b', 0, 148, 1, 'u', 0, 'u', 132, 253, 183, '!', 185, '?', 238, 0, ':', 219, 180, 7, 134, 202, 219, 212, 130, 0, '[', 0, '0', 4, 15, 209, 0, 'D', 0, '^', 0, 216, 1, 255, 255, 250, 0, 246, 138, 211, '_', 208, 144, 6, 249, 242, '!', 240, 0, 243, '@', 31, 253, '{', 19, 'u', 246, 25, 'C', 150, 173, 'l', 'o', 4, 15, 195, 20, 8, 0, 244, 8, 0, 'd', 0, 'B', 8, 0, 't', 0, '[', 255, 0, 'g', 209, 31, 243, 4, 128, '1', 255, 0, '!', 248, 227, 220, 1, 214, 251, 17, 's', 223, 226, 203, 198, '+', 222, 160, 7, 155, '`', 136, 0, '}', 154, '$', 'P', 141, 'J', '-', 27, '@', ' ', 3, 224, ' ', '}', 'X', ' ', '~', '@', 160, '@', 3, 235, 200, ' ', 1, 204, '~', 249, 17, '_', 191, 127, 243, 166, 'O', ',', 20, '(', 141, 133, 'd', 'u', 'K', 232, 217, 1, 3, 231, 'A', 3, 245, '@', 28, 2, 0, '*', 242, 8, 31, 156, 8, 0, 'z', 8, 31, 128, 'F', 232, 204, 204, 132, 'b', '8', 2, 187, 'x', 236, 137, 222, 'f', 7, 252, '?', '\'', 224, ']', ':', 162, 'E', 'o', '4', 139, 247, 0, '^', 0, 212, 1, 152, 3, '@', 11, 0, 11, 192, 25, 'I', 153, 'z', 157, '}', 0, 25, 220, 208, 1, 16, 3, 188, '~', 185, '/', 156, 'u', 14, 146, 'M', 'R', 162, 'X', 223, 'h', 0, 184, 16, 0, 196, 16, 0, 228, 16, 1, 8, 16, 1, '(', 16, '?', '7', 0, 28, 130, 0, '/', 2, 7, 230, 247, 127, 255, 'W', 0, '7', 4, 31, 234, 0, '-', 4, 0, '>', 208, 7, 224, 14, 1, 7, 246, 0, 9, 191, 243, 227, 255, 'H', 249, 207, 248, 0, 215, '0', 0, 212, 139, '_', 'H', 200, 'n', 219, 'e', 'm', 148, 1, 224, ' ', 1, 232, 2, '0', 4, 'B', 1, 3, 228, 254, 252, '{', 253, 'E', 'R', '!', 153, 200, 3, ' ', '@', 253, '0', 3, 17, ' ', 13, 184, '#', 138, 254, 'h', 1, 190, '>', 'R', '\'', '}', 'y', 'm', 's', 242, 'b', 'S', 0, 4, 128, 7, 194, 226, 154, 'S', '`', 4, 15, 149, 4, 0, '@', 0, 'F', 8, 31, 158, 8, 0, 'n', 'E', 0, '|', 0, 156, 136, '(', 'Q', 29, 207, 250, 11, 158, 196, '|', '\'', 'v', 1, 'L', '|', '_', 192, 242, 17, 237, 232, '9', 208, 'A', 2, 'Q', '@', 129, 236, 28, 200, 26, 'X', ' ', '~', '+', 128, 24, 'l', 0, 26, 128, 26, ' ', '%', 128, 195, 'm', 4, 0, 'B', 0, 'D', ' ', 16, 2, 'H', 16, '>', 187, 'A', 3, 244, 0, 9, '@', 26, 241, 133, 'W', 145, 196, '}', '@', 9, '{', 0, 'r', '+', 175, 142, 4, 'K', 152, 6, 'H', ';', '=', 197, 210, 192, 156, 'x', 182, 216, 0, 144, 1, 241, 28, 'N', 8, 0, 'z', 0, 220, 0, 'G', 229, 144, 12, 'a', 25, 255, '`', 6, 154, 'n', 152, 'd', 190, 'x', 0, 227, 255, 151, '#', 182, 161, 213, '4', 182, 224, 4, 15, 159, 4, 15, 203, 0, '.', 0, 'm', 199, 220, 16, 0, 192, 16, 0, 255, 232, 8, 0, 'W', '?', 255, '_', ' ', 'A', 254, 206, 192, 21, 240, 0, 132, 16, '?', 19, 169, 192, 3, 128, 3, 144, 3, '_', 151, '@', 7, 159, 240, '@', 251, 208, 2, 192, 7, 243, 235, 245, 251, 227, 166, 21, 'h', 1, 238, '*', '6', 242, 128, 129, 241, 224, 128, 8, '`', 9, '@', 20, 0, 18, 128, '1', 0, '\\', 0, 219, 234, 238, 189, 205, 190, 'B', 0, 31, 253, 128, 31, 227, 253, 159, 'n', 'P', 10, 183, '<', 237, 'u', 'R', 199, 'O', 127, 129, '9', 'c', 0, '@', 249, '`', '@', 3, 240, 4, 224, 13, '@', 11, 128, 23, 128, '.', 0, 'o', 244, 21, 215, 206, 27, 199, '}', 127, 192, 30, 128, '6', 16, '$', 138, '(', 0, 255, 141, 209, 'n', 222, 185, 204, 227, 'u', ')', 'f', 160, 5, 'B', 'D', 'T', 'o', '^', 8, 0, 'v', 0, 243, 143, 240, ' ', 1, 208, ' ', '{', 'H', 3, 192, 6, 222, 202, ';', 219, 232, 0, 'P', 'G', 207, 191, 176, 140, '&', 19, '}', 189, 193, 4, 5, 4, 'T', '8', 153, 191, 241, 17, 128, ' ', 1, 200, 3, 1, 31, 'P', '@', 252, '`', '@', 246, 'P', 7, 192, 11, 254, 252, 'r', 8, 191, 249, 241, 244, 0, '+', '#', 10, 251, 188, '\\', 200, 4, 249, 2, 8, 9, 251, '$', 8, 128, 14, 189, 245, 164, 16, 0, 224, 0, 139, 235, '@', 14, 'h', '!', 127, 'Q', ';', 1, 20, 3, 'T', 0, 160, 1, 175, 230, 'f', 254, 220, 8, '_', 232, 227, 237, 28, '5', 27, 'P', '@', 247, 0, '@', 249, 16, 4, 222, 212, 0, 192, 'P', 176, 'A', 3, 16, 1, '?', 222, 128, 224, 0, 134, 2, 15, 214, 2, 0, 31, 2, 16, 10, 210, '(', 4, 128, 15, 193, 8, 7, 190, 225, 203, 213, '&', 232, '"', 0, 'D', 229, 183, 149, 4, 15, 128, 4, 0, 'L', 0, 'B', 0, 128, 16, '?', 'T', 1, 200, 3, 160, 7, 28, 187, 233, 239, 237, 132, 'R', '7', '}', '}', 'p', 138, 'g', ']', 232, 211, 140, 138, 220, 240, '@', 252, 240, 2, ' ', 7, ' ', 129, 250, '`', 128, 6, 159, 'O', 232, 2, '0', 7, 132, 'n', 230, 224, '!', 127, 200, 5, 155, 179, '7', 146, 224, 171, 10, 134, '\\', '*', 150, '{', '{', 128, '@', 4, '0', '@', 2, 192, 7, 0, 129, 235, 0, 128, 7, '@', 11, 0, 25, 128, '$', 0, 'a', 214, 'n', 237, 'q', 27, 144, 7, 224, 9, 168, 3, 177, 'Y', 189, '{', 'a', 181, '0', 156, 239, 'o', 147, 144, 17, 191, 232, 'E', 28, 173, 206, 255, 2, 0, '$', 128, '9', 4, 15, '{', 248, 0, 'n', 0, 164, 16, '?', '3', 176, 6, 253, 158, 0, 't', 0, 'a', 200, 2, 'B', '7', 182, 17, 0, 30, 138, 224, 0, 247, 'e', 17, 164, 219, 206, 'Z', 30, 133, 225, 130, 162, '$', 173, 160, ' ', 1, 'P', 2, 'J', 0, 'v', '/', 223, 237, '@', 22, 230, '#', 185, 199, '}', 128, 22, 0, '=', '2', 128, 9, 'P', 197, '+', 235, 252, '.', 230, 194, 170, 'y', 'l', 'K', 27, 144, 16, '>', ',', 16, '>', 163, 28, 0, 'X', 0, 248, 1, 160, ' ', '~', 167, 0, 128, 9, 31, 240, 7, 247, 127, 224, 15, 176, 1, 168, 2, 144, '@', 251, 'p', '@', 2, 221, 'x', 141, 0, ',', 132, ']', 254, 249, '_', 182, 128, 24, 0, '!', 14, '#', '?', 226, 130, 23, 252, 't', 8, 127, 235, 240, 183, 162, 155, 's', 'A', 3, 219, 1, 0, 20, 128, 10, '@', 24, 0, '9', 19, 244, 21, 28, 'D', 247, 246, 193, '$', 'A', '7', 158, 159, 207, ']', 'o', 183, 187, 181, 'W', 'r', 250, 248, '7', 'P', 'N', '<', 16, '<', 196, 'X', ' ', 1, 146, 'r', 16, 240, 'A', 1, 250, 0, 183, 'M', 196, 28, '`', ' ', 128, 152, '&', 255, 133, 'o', 'N', 8, 31, 152, 8, 0, 130, 8, 0, 130, 8, 31, 't', 0, 'F', 0, 152, 'P', 1, 16, 3, 129, 's', 142, 'p', 136, 'F', 192, 5, '`', 21, 138, 186, 225, 'F', 187, 238, '$', 'K', 141, 0, '>', '&', 'c', 157, '-', 173, 203, 19, 243, 'A', 3, 229, ';', 4, 0, '|', 222, 249, 4, 143, 252, 208, '@', 4, 'n', 249, 178, 128, 'D', 0, 248, 16, '@', 'T', 19, 127, 226, 163, 'r', 2, 0, 23, 17, 156, 0, 240, 1, '`', 2, '_', 184, 143, 176, 3, 187, 199, 226, 128, '=', 224, 16, '@', 139, 176, 7, 188, 'j', 209, 161, 251, 29, 179, 240, '1', 11, 'V', 247, 129, 3, 219, 192, 21, 255, '@', 17, 130, 7, 216, 2, 0, 31, 2, 0, 21, 0, '7', 0, 'R', 8, 0, 'S', 254, 0, 'k', 160, 131, 253, 160, 15, 0, 8, 128, 24, 208, '@', 250, '@', 6, 128, 4, 192, 14, 240, 0, 'M', 31, '|', 254, '(', 1, 160, 173, 254, 145, '6', 0, 28, 136, 185, 'K', 166, 20, 219, 230, 197, 255, 128, 13, 150, 130, 'P', 4, 128, 'T', 9, 160, 11, 228, 'H', 'd', 'g', 'K', 254, 0, '4', 'J', 9, '@', 18, 1, 'P', '&', 128, '/', 145, '!', 145, 189, 208, 'C', 255, 178, 'x', '&', 255, 233, 160, 3, 21, 'o', 202, 129, 12, 3, 0, 15, 1, '4', 1, 200, 0, 154, 0, 158, 'D', 134, 241, 163, 'F', 140, 218, '[', 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 128, 0, 0, 1, 8, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 'F', 144, 187, '!', '.', 180, 'h', 195, 13, 173, 202, 189, 'j', '[', 226, 236, 'B', 'X', 30, 222, 180, 1, 16, 3, 16, 7, 128, 129, 232, '`', 8, 193, 0, 12, 'x', 0, 'l', 0, 255, 239, 236, 'G', 'O', 160, 191, 224, 174, '@', 24, 't', 0, 164, 'X', 176, 3, 252, 228, 192, 'C', 0, 'm', 246, 0, 178, '<', 188, '<', 175, '{', 149, '*', '7', 143, 146, '\\', 146, 223, 'J', 204, 236, 157, 139, 174, 175, 152, 'y', 184, 176, 'a', 205, 136, 3, '}', 128, 10, 0, 23, 127, 255, 162, 172, 1, 31, 193, 18, 162, 'z', 'F', 239, 4, 0, ':', 246, '#', 130, 7, 217, 130, 7, 218, 2, 0, 23, 130, 0, 21, '}', '~', 218, 3, 205, 248, 0, 'b', 0, 183, 237, 244, 217, 167, 13, 15, 210, 253, '#', 'm', ' ', 12, 190, 157, 0, '1', 0, 'Z', 0, 192, 1, 224, 3, 254, 220, 3, 222, '>', '9', 247, '#', '{', 11, 220, '<', 7, 4, 30, 'x', 203, 232, 170, '5', 190, 138, 8, 0, 160, 0, 'G', 244, 4, 0, 'O', 4, 0, '/', 4, 15, 142, 250, '|', 139, 0, 'f', 'D', '#', 161, 152, 0, 252, 1, 176, 2, 192, 6, ']', 240, 'F', 223, 225, 31, 236, 'A', 219, 8, 152, 0, 247, 220, 136, 'E', 246, '&', 199, 130, 31, 252, '`', 3, 177, '8', 0, 'v', 'r', '7', 204, 'D', 'q', 'E', 191, 28, 248, 'B', '0', 147, 180, 149, 24, 241, '|', 188, 175, '6', '@', '$', 159, '(', 243, 137, 154, 164, '&', 200, 16, '?', '_', 234, 8, ' ', '6', 0, 195, 237, 244, 234, 192, 30, 207, '`', 6, 224, 15, 243, '5', 208, 7, 18, '+', 215, '!', 'g', 157, '6', 237, 141, 232, 2, 0, '?', 0, ' ', '"', 130, 7, 215, 130, 7, 216, 0, '#', 0, 'C', 245, 255, 'v', '`', '"', 0, '.', 253, 193, 0, 13, 129, 0, 12, 128, 27, 128, '=', 232, 1, 232, '"', 127, 150, 135, 0, '>', 255, 10, '#', 252, 169, 25, 'R', 'B', '~', 241, 240, '"', 'Z', 219, 219, 2, 0, 31, 2, 7, 229, '}', 1, 3, 231, '@', 9, 129, 3, 240, 'A', 3, 237, 129, 0, 13, '@', 27, 203, 182, 16, 's', 236, '\'', 172, 227, 128, 7, 250, '/', 217, 'q', 21, 238, 'A', 'T', '$', 0, 250, 224, 5, 152, 219, 255, 224, 129, 244, 224, 128, 5, ' ', 4, '`', 129, 239, ']', 128, 22, 'P', 2, 2, '/', 30, 249, 8, 226, '>', 254, 224, 13, '>', 153, 201, 20, 139, 'c', 191, 'i', '}', 165, 212, 164, 'E', 217, 'B', '#', '|', 233, 31, '3', '$', 145, 'K', 27, 11, '%', 176, 'w', 150, 'j', '[', '4', 'q', 't', 249, 14, 0, 225, 178, 4, 15, 194, 18, 0, 248, 1, 247, 199, 198, 246, 'E', 0, 'p', 'n', 128, 228, 1, 239, 215, 236, 0, 251, 142, 128, 31, '9', 238, 'w', 228, 215, 21, 248, 195, 242, 'C', 237, 'F', 239, 4, 0, 176, 0, 't', 8, 31, 156, 8, 31, 174, 0, 132, 1, 239, '_', '`', 4, '@', 129, 250, 155, 246, 250, 'Z', 0, ' ', 0, '"', 0, '*', 0, '+', 4, 15, 209, 0, 'n', 0, 212, 0, 156, 1, 200, 3, 226, '/', 215, 'p', 141, 128, 6, 180, 208, 'B', 255, 'R', '.', '@', 'B', 255, 'w', 210, 'f', 'J', '5', 27, 'i', 0, 'E', 241, 0, 16, 0, 22, 0, ',', 0, 'e', 236, 160, 144, 0, 192, 15, 8, 159, 4, 'G', 'E', '(', 16, 192, 20, 0, 251, 216, '8', '4', 232, 221, 160, '@', 5, '/', 168, 144, '@', 247, 160, '@', 251, 128, 4, 223, ' ', 12, '=', 166, 19, '<', 224, 2, 255, 160, 2, 142, 255, 191, 225, 'b', 128, 'r', 138, '(', 205, 203, 'e', 165, 6, 22, 222, 'l', 183, 212, 'O', 'P', 25, 180, 153, '6', 21, 226, 146, 0, 213, 186, 128, 25, 145, 'h', 3, 160, 7, 31, 240, 7, 189, 'Q', 224, 135, 254, 206, 143, 'y', 176, 241, 138, 31, 'a', 231, 'K', 'k', 'x', 0, 128, 8, 160, 5, 159, 0, 129, 249, 192, 129, 249, '`', 128, 5, 224, 128, 6, ' ', 15, 's', 't', 236, 224, 16, '@', 'X', 138, 'G', 0, '|', 0, 251, ':', '~', 129, 136, 'V', 187, 132, '"', 17, 182, 254, 15, 217, 145, '[', '{', 208, '@', 248, 128, '@', 250, 0, '@', 4, 177, '@', 8, 189, 190, 192, 12, 254, 191, 222, 136, 255, 'o', 239, 216, 0, 243, 223, 251, '~', 8, 15, ' ', 27, 0, 14, 254, '9', 'x', 191, 193, 'j', 'u', 9, 141, 'X', ' ', 1, 240, ' ', '~', '\'', 208, 16, 1, 'X', 16, '?', 'D', 16, '>', 232, 16, '>', 216, 16, '?', '(', 1, '`', 173, 253, 128, 9, '(', 175, 143, 'a', '@', 15, 13, 246, 'P', 3, 195, 'q', 248, 239, 'o', 'k', 135, 205, 166, 'O', 'q', '"', 'E', 187, 10, 198, 240, 248, 'N', 161, 241, 238, 'B', 233, 224, '8', 171, 'U', 139, 177, ';', 234, 'D', '8', 172, '[', 250, 0, 129, '[', 156, 16, '?', 'P', '@', 2, 207, 'x', '#', 143, 176, 3, 224, 6, 222, 'o', 215, 239, 28, 243, 245, 255, 187, 142, 'f', 230, 'N', 29, ',', 134, 174, 211, 233, 233, 14, 'o', 'p', 16, 2, 'D', 1, 216, ' ', '}', 191, 251, 228, 1, 175, 212, 16, '?', 'D', 16, '?', '<', 16, '?', 'D', 0, 'E', 244, 227, 249, 246, 0, '~', 0, 211, 252, 0, 152, 0, 168, 1, 200, 3, 'P', 6, 153, 199, '$', '}', 254, 253, 222, 0, '\'', '"', 241, 252, 4, ' ', 13, '#', 12, 167, 169, 't', 166, 222, 204, 0, 144, 1, 'X', 3, 192, 2, 225, '@', 129, 237, 192, 14, 'I', 223, 'q', 29, 135, 231, '?', 'p', 7, '@', 129, 250, 'D', 'p', 6, 220, 'A', 127, 'b', '>', 'y', 'o', 230, 'N', '~', 217, 29, 184, 'Y', '6', 0, ',', 20, '&', 13, 'n', 147, 129, 3, 239, 128, 11, 128, 27, 2, 0, 'D', 128, 19, 145, 0, 21, 0, 16, 251, 240, '$', 136, 255, 231, 191, 182, 0, '$', 0, 'F', 0, 228, 143, 243, 237, 214, 246, 0, 'm', 201, 26, 'k', 221, 166, 0, 'Y', 29, 147, 'L', 'T', 198, 249, 223, 'X', 255, '~', 'x', 150, 249, '@', 155, 249, 209, 193, 216, 'j', 31, 'J', '9', 189, 224, ' ', 3, 248, ' ', '}', 'p', 1, '/', 176, ' ', 1, 247, 247, 'A', 0, 16, '~', '>', 148, 0, 203, 251, '@', 13, 253, 128, 29, 127, 255, 253, 139, 215, 2, 16, 4, 'q', 9, 185, 'P', 219, '~', 'v', 'm', 180, '!', '[', 156, 0, 167, 173, 0, '@', 0, 222, 8, 0, '{', 192, 3, 'i', 216, 24, 0, 18, 245, 193, 28, 16, '@', 'P', 1, 224, 0, 157, 220, 233, 142, '&', 253, 191, 129, 216, 250, 'Q', 215, '"', 183, 170, 8, 0, 198, 0, 199, 236, 8, 31, '@', 8, 0, 'c', 160, 13, 193, 0, 11, 0, 30, 130, 7, 231, 188, 1, 160, '!', 127, 'l', 0, '"', 0, 'c', 247, 0, 'P', 224, '@', 253, '`', 2, 144, 'A', 2, 0, 7, '?', 239, 160, 156, 251, 238, '_', 224, 1, '8', 2, 19, 'y', '"', 253, 162, 'l', 182, 195, '@', '*', 'R', 155, 'o', 0, 'r', 0, 'G', 254, 4, 0, ';', 0, 'R', 8, 30, 242, 0, 220, 0, 164, 1, 192, 223, '0', 1, '7', 212, 0, 184, 139, 192, 184, 'D', 4, 'P', 10, 4, ' ', 7, 0, '=', 'x', 3, 129, 'B', 159, 'I', 180, 239, 145, 'V', 216, '[', 'q', '@', 9, 0, 24, 128, ':', 4, 0, ')', 248, 4, 15, 'j', 0, 'k', 207, 31, 127, 'n', 213, '9', 251, 128, ':', 4, 15, 211, 22, 0, 224, 157, 223, 243, 231, '&', 'l', ' ', 152, 242, '$', 199, 'n', 22, '|', 0, 'X', '(', 'L', 27, 27, '0', ' ', 3, 216, 3, '0', 6, '`', 128, 12, ' ', 128, 5, 160, 5, 224, 129, 250, ' ', 129, 250, '@', 9, 248, 228, 142, 240, 3, 210, 7, '`', 9, '~', '{', 246, 233, 221, '|', ':', 206, 22, 'd', '-', '@', 170, 222, '[', 218, 220, 139, 'h', 10, 183, 205, 244, 241, 163, 7, '5', 2, 7, 234, 252, 'P', 2, '7', 253, 'x', 254, 19, 141, 'S', 29, 229, ' ', 3, 0, 7, 23, 200, 7, 10, 1, '6', 'n', 164, 'i', 4, 0, 130, 0, 'C', 'A', 0, ' ', 248, 0, '&', 251, 130, 7, 232, '}', 128, 25, 239, 250, 'O', 183, 244, 1, 222, 127, 254, ' ', ' ', '}', 128, ' ', '~', '#', 158, 0, 238, 145, 0, 4, 179, 226, 152, 0, 253, 255, 239, 228, '#', 216, 166, 2, 31, 252, ']', 181, 10, 'm', 235, '@', 11, 128, 23, 128, '>', 4, 15, 'B', 0, 'F', 8, 0, '\\', 224, 6, 192, 15, '~', 254, 196, 'Z', 0, 'l', '\'', 252, '+', 144, 5, 194, 0, 22, 246, '$', 0, 255, '9', 178, 2, 16, 3, 'Q', '@', 22, ')', 'p', 242, 189, 204, 169, 'Q', 183, 130, 0, 26, 2, 7, 231, 0, '2', 4, 15, 127, 20, 8, 31, 162, 8, 31, 146, 0, 224, 1, 8, 5, 'X', '_', 215, '?', 223, 0, 9, 191, 223, 'O', 142, 243, 'E', 'O', ' ', 9, 232, 172, 230, 'Z', 'o', 230, 31, 200, 154, '"', 'F', 240, 'O', 21, '/', '7', '-', 176, 'm', 201, 143, 167, 5, 235, 24, 236, 222, 'U', 'p', 5, 'y', 'h', 'z', 'b', 'V', 220, 16, '?', '4', 142, 'F', 0, '`', 0, 184, '@', 172, 222, 11, '&', 153, 252, 251, '\'', 154, 143, 't', 255, 255, 204, 'z', 149, 20, 236, '-', 188, 'p', '@', 9, 'P', 5, '@', 11, 'A', 3, 238, 1, 3, 238, 190, 255, 'q', ' ', 15, 0, 26, 249, 'M', 'x', 0, 145, 228, 'p', '@', 253, ' ', 2, 243, '@', 4, 198, 'a', 155, 160, 6, 188, 128, 21, 0, 21, 'o', '?', 'b', 161, 180, 176, 3, 191, 148, 'm', 244, 160, 5, '`', 129, 243, 160, 128, 6, 160, 129, 247, 128, 129, 244, 224, 5, 29, 't', 0, 179, 250, 'F', 247, 0, 19, 'y', 'Q', 0, 13, '>', 255, 25, 164, 'R', '9', 23, 'E', 252, 'u', 243, 244, 229, '>', 29, '<', 204, 197, 209, 163, 'b', 20, 212, 0, '"', 0, '%', 0, 'T', 8, 31, 'h', 0, 172, 16, 1, 223, 252, 'D', 228, 1, 159, 248, 'M', '/', 128, 7, 223, 'p', '@', 4, 31, 247, 206, 'w', 215, 191, 198, 128, 30, 128, 'M', 'H', 220, 127, 132, 'l', 204, 138, 139, '>', 'i', 180, 152, 223, ';', 201, 177, 'd', 147, 2, '%', 134, '"', 160, 'U', 'c', 196, 243, 'z', 'D', 2, 'V', 'R', 208, 193, 135, '6', '@', 129, 247, 239, 0, 'e', 130, '3', 8, 223, '@', 7, 132, 253, '{', 204, '3', 252, 0, 248, 1, 255, 255, 133, 218, 'O', 'y', '3', 241, 135, 214, 236, 4, 0, 185, 20, 8, 31, 141, 159, '=', 145, '@', 24, 128, '!', 4, 15, 215, 192, 7, 157, 17, '?', 128, 2, 29, '"', 130, 7, 235, 2, 7, 235, 128, 22, 0, 24, 0, '9', '1', 206, 159, 'o', 133, 205, 's', 190, 228, '\\', 204, 246, 150, '-', 178, 'K', 'T', 182, 200, 234, 0, 'i', 193, 25, 212, 18, 192, '#', ':', 192, 'L', 0, 'H', 226, 'C', '+', 'H', 29, '2', 18, 154, '7', 163, 127, ';', 180, 151, 'm', 'o', 142, 226, 16, ':', 227, 136, 9, '`', 8, 236, 192, 1, 150, 'H', 222, '4', 'h', 209, 155, '&', 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, '`', 0, 0, 1, 9, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 210, '@', 134, 141, 24, 'a', 188, 146, 6, '4', 146, 6, '4', 'h', 195, 13, 230, 'H', 24, 210, '@', 134, 141, 24, 12, '$', '1', 'U', 188, 146, 6, '4', 144, '!', 163, 'F', 24, 'o', '$', 129, 141, '2', 'I', 10, 145, 163, 'F', 24, 13, 'o', '$', 129, 141, '$', 'H', 'T', 141, 26, '0', 195, 'y', ' ', 'C', 'I', 2, 26, '4', 'a', 134, 243, '2', 6, 'z', '4', 146, 6, '4', 'h', 197, 180, '5', 130, 192, '~', 222, 'I', 3, 26, 'I', 3, 26, '4', 'a', 130, 219, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 0, 0, 1, 10, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, 11, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, 12, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, 13, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, 14, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, 15, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, 16, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, 17, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, 18, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, 19, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, 20, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, 21, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, 22, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, 23, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, 24, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, 25, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, 26, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, 27, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, 28, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, 29, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, 30, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, 31, 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, ' ', 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, '!', 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, '"', 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, '#', 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, '$', 11, 254, 31, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 27, 198, 141, 26, '0', 195, 'x', 209, 163, 'F', 24, 'o', 26, '4', 'h', 195, 13, 227, 'F', 141, 24, 'a', 188, 'h', 209, 163, 12, '7', 141, 26, '4', 'a', 134, 241, 163, 'F', 140, '0', 222, '4', 'h', 209, 134, 24, 0, 0, 1, 183, 0 };
        data = (char *)&v_mpg_nosignal[(signed long int)0];
        static const signed int v_mpg_nosignal_length = (const signed int)sizeof(const unsigned char [13196l]) /*13196ul*/ ;
        datalen = v_mpg_nosignal_length;
      }

      _x_demux_control_start(this->stream);
      if(!(pos >= datalen))
      {
        buf=fifo->buffer_pool_try_alloc(fifo);
        if(!(buf == ((struct buf_element_s *)NULL)))
        {
          buf->content = buf->mem;
          if(!(datalen + -pos >= buf->max_size))
            tmp_if_expr$8 = datalen - pos;

          else
            tmp_if_expr$8 = buf->max_size;
          buf->size = tmp_if_expr$8;
          buf->type = (unsigned int)0x02000000;
          xine_fast_memcpy((void *)buf->content, (const void *)&data[(signed long int)pos], (unsigned long int)buf->size);
          pos = pos + buf->size;
          if(pos >= datalen)
            buf->decoder_flags = buf->decoder_flags | (unsigned int)0x0004;

          fifo->put(fifo, buf);
        }

        else
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "Error: queue_nosignal: no buffers !");

      }

      put_control_buf(fifo, fifo, 0x010a0000);
      put_control_buf(fifo, fifo, 0x01040000);
      free((void *)tmp);
    }

  }
}

// read
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 34
static inline signed long int read(signed int __fd, void *__buf, unsigned long int __nbytes)
{
  signed long int return_value___read_chk$1;
  signed long int return_value___read_chk_warn$2;
  signed long int return_value___read_alias$3;
  return_value___read_alias$3=__read_alias(__fd, __buf, __nbytes);
  return return_value___read_alias$3;
}

// read_control
// file xine_input_vdr.c line 1120
static signed long int read_control(struct vdr_input_plugin_s *this, unsigned char *buf, unsigned long int len)
{
  signed int poll_result;
  signed long int num_bytes;
  unsigned long int total_bytes = (unsigned long int)0;
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  signed int *return_value___errno_location$8;
  char *return_value_strerror$9;
  while(!(total_bytes >= len))
  {
    if(this->control_running == 0)
      return (signed long int)-1;

    pthread_testcancel();
    poll_result=io_select_rd(this->fd_control);
    pthread_testcancel();
    if(this->control_running == 0)
      return (signed long int)-1;

    if(!(poll_result == 3))
    {
      if(poll_result == 2)
        do
          if(iSysLogLevel >= 1)
          {
            x_syslog(3, log_module_input_vdr, "read_control: XIO_ABORTED");
            signed int *return_value___errno_location$3;
            return_value___errno_location$3=__errno_location();
            if(!(*return_value___errno_location$3 == 0))
            {
              return_value___errno_location$1=__errno_location();
              return_value_strerror$2=strerror(*return_value___errno_location$1);
              x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 1142, return_value_strerror$2);
            }

          }

        while((_Bool)0);

      else
      {
        if(poll_result == 1)
        {
          do
            if(iSysLogLevel >= 1)
            {
              x_syslog(3, log_module_input_vdr, "read_control: poll error");
              signed int *return_value___errno_location$6;
              return_value___errno_location$6=__errno_location();
              if(!(*return_value___errno_location$6 == 0))
              {
                return_value___errno_location$4=__errno_location();
                return_value_strerror$5=strerror(*return_value___errno_location$4);
                x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 1146, return_value_strerror$5);
              }

            }

          while((_Bool)0);
          return (signed long int)-1;
        }

        signed int *return_value___errno_location$7;
        return_value___errno_location$7=__errno_location();
        *return_value___errno_location$7 = 0;
        num_bytes=read(this->fd_control, (void *)(buf + (signed long int)total_bytes), len - total_bytes);
        pthread_testcancel();
        if(!(num_bytes >= 1l))
        {
          if(!(this->control_running == 0))
          {
            if(!(num_bytes >= 0l))
              do
                if(iSysLogLevel >= 1)
                {
                  x_syslog(3, log_module_input_vdr, "read_control read() error");
                  signed int *return_value___errno_location$10;
                  return_value___errno_location$10=__errno_location();
                  if(!(*return_value___errno_location$10 == 0))
                  {
                    return_value___errno_location$8=__errno_location();
                    return_value_strerror$9=strerror(*return_value___errno_location$8);
                    x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 1156, return_value_strerror$9);
                  }

                }

              while((_Bool)0);

          }

          return (signed long int)-1;
        }

        total_bytes = total_bytes + (unsigned long int)num_bytes;
      }
    }

  }
  return (signed long int)total_bytes;
}

// read_socket_udp
// file xine_input_vdr.c line 4159
static struct buf_element_s * read_socket_udp(struct vdr_input_plugin_s *this)
{
  signed int result;
  result=_x_io_select(this->stream, this->fd_data, 1, 100);
  if(this->control_running == 0)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 107;
    return (struct buf_element_s *)(void *)0;
  }

  signed int return_value__x_action_pending$3;
  return_value__x_action_pending$3=_x_action_pending(this->stream);
  if(!(return_value__x_action_pending$3 == 0))
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 4;
    return (struct buf_element_s *)(void *)0;
  }

  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  if(!(result == 0))
  {
    if(result == 1)
      do
        if(iSysLogLevel >= 1)
        {
          x_syslog(3, log_module_input_vdr, "read_socket_udp(): select() failed");
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          if(!(*return_value___errno_location$6 == 0))
          {
            return_value___errno_location$4=__errno_location();
            return_value_strerror$5=strerror(*return_value___errno_location$4);
            x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 4177, return_value_strerror$5);
          }

        }

      while((_Bool)0);

    signed int *return_value___errno_location$7;
    return_value___errno_location$7=__errno_location();
    *return_value___errno_location$7 = result == 3 ? 11 : (result == 2 ? 4 : 107);
    return (struct buf_element_s *)(void *)0;
  }

  struct udp_data_s *udp = this->udp_data;
  struct buf_element_s *read_buffer;
  read_buffer=get_buf_element_timed(this, (signed int)((unsigned long int)2048 + sizeof(struct stream_rtp_header_impl) /*28ul*/ ), 100);
  if(read_buffer == ((struct buf_element_s *)NULL))
  {
    if(this->is_paused == 0)
    {
      do
        if(iSysLogLevel >= 3)
          x_syslog(7, log_module_input_vdr, "UDP Fifo buffer full !");

      while((_Bool)0);
      if(!(this->scr == ((struct adjustable_scr_s *)NULL)))
      {
        if(udp->scr_jump_done == 0)
        {
          this->scr->jump(this->scr, 40 * 90);
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "SCR jump: +40 ms (live=%d, tuning=%d)", this->live_mode, this->scr_tuning);

          udp->scr_jump_done = (unsigned char)50;
        }

      }

    }

    signed int *return_value___errno_location$8;
    return_value___errno_location$8=__errno_location();
    *return_value___errno_location$8 = 11;
    return (struct buf_element_s *)(void *)0;
  }

  if(!(udp->scr_jump_done == 0))
    udp->scr_jump_done = udp->scr_jump_done - 1;

  struct sockaddr_in server_address;
  unsigned int address_len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  signed long int n;
  n=recvfrom(this->fd_data, (void *)read_buffer->mem, (unsigned long int)read_buffer->max_size, 32, &server_address, &address_len);
  _Bool tmp_if_expr$16;
  signed int *return_value___errno_location$13;
  _Bool tmp_if_expr$15;
  signed int *return_value___errno_location$14;
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  if(!(n >= 1l))
  {
    if(n == 0l)
      tmp_if_expr$16 = (_Bool)1;

    else
    {
      return_value___errno_location$13=__errno_location();
      if(!(*return_value___errno_location$13 == 4))
      {
        return_value___errno_location$14=__errno_location();
        tmp_if_expr$15 = *return_value___errno_location$14 != 11 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$15 = (_Bool)0;
      tmp_if_expr$16 = tmp_if_expr$15 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$16)
    {
      do
        if(iSysLogLevel >= 1)
        {
          x_syslog(3, log_module_input_vdr, "read_socket_udp(): recvfrom() failed");
          signed int *return_value___errno_location$11;
          return_value___errno_location$11=__errno_location();
          if(!(*return_value___errno_location$11 == 0))
          {
            return_value___errno_location$9=__errno_location();
            return_value_strerror$10=strerror(*return_value___errno_location$9);
            x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 4222, return_value_strerror$10);
          }

        }

      while((_Bool)0);
      signed int *return_value___errno_location$12;
      return_value___errno_location$12=__errno_location();
      *return_value___errno_location$12 = 107;
    }

    read_buffer->free_buffer(read_buffer);
    return (struct buf_element_s *)(void *)0;
  }

  _Bool tmp_if_expr$18;
  if(!(server_address.sin_addr.s_addr == udp->server_address.sin_addr.s_addr))
    tmp_if_expr$18 = (_Bool)1;

  else
    tmp_if_expr$18 = server_address.sin_port != udp->server_address.sin_port ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$18)
  {
    read_buffer->free_buffer(read_buffer);
    signed int *return_value___errno_location$17;
    return_value___errno_location$17=__errno_location();
    *return_value___errno_location$17 = 11;
    return (struct buf_element_s *)(void *)0;
  }

  if(!(this->rtp == 0))
  {
    if(!(n >= (signed long int)sizeof(struct stream_rtp_header_impl) /*28l*/ ))
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "received invalid RTP packet (too short)");

      while((_Bool)0);
      read_buffer->free_buffer(read_buffer);
      signed int *return_value___errno_location$19;
      return_value___errno_location$19=__errno_location();
      *return_value___errno_location$19 = 11;
      return (struct buf_element_s *)(void *)0;
    }

  }

  else
    if(!(n >= (signed long int)sizeof(struct anonymous$7) /*11l*/ ))
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "received invalid UDP packet (too short)");

      while((_Bool)0);
      read_buffer->free_buffer(read_buffer);
      signed int *return_value___errno_location$20;
      return_value___errno_location$20=__errno_location();
      *return_value___errno_location$20 = 11;
      return (struct buf_element_s *)(void *)0;
    }

  if(!((signed long int)read_buffer->max_size >= n))
  {
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_vdr, "received too large UDP packet (%zd bytes, buffer is %d bytes)", n, read_buffer->max_size);

    while((_Bool)0);
    read_buffer->free_buffer(read_buffer);
    signed int *return_value___errno_location$21;
    return_value___errno_location$21=__errno_location();
    *return_value___errno_location$21 = 11;
    return (struct buf_element_s *)(void *)0;
  }

  read_buffer->size = (signed int)n;
  read_buffer->type = (unsigned int)(0x05000000 | 0x00010000);
  return read_buffer;
}

// readline_control
// file xine_input_vdr.c line 1043
static signed long int readline_control(struct vdr_input_plugin_s *this, char *buf, unsigned long int maxlen, signed int timeout)
{
  signed int poll_result;
  signed long int read_result;
  unsigned long int total_bytes = (unsigned long int)0;
  *buf = (char)0;
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  signed int *return_value___errno_location$8;
  char *return_value_strerror$9;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  signed int *return_value___errno_location$14;
  _Bool tmp_if_expr$16;
  signed int *return_value___errno_location$15;
  while(!(total_bytes >= maxlen + 18446744073709551615ul))
  {
    if(this->control_running == 0)
    {
      if(!(timeout >= 0))
        return (signed long int)-1;

    }

    pthread_testcancel();
    poll_result=io_select_rd(this->fd_control);
    pthread_testcancel();
    if(this->control_running == 0)
    {
      if(!(timeout >= 0))
        return (signed long int)-1;

    }

    if(poll_result == 3)
    {
      if(timeout == 0)
        return (signed long int)0;

      if(timeout >= 1)
        timeout = timeout - 1;

    }

    else
      if(poll_result == 2)
        do
          if(iSysLogLevel >= 1)
          {
            x_syslog(3, log_module_input_vdr, "readline_control: XIO_ABORTED at [%u]", (unsigned int)total_bytes);
            signed int *return_value___errno_location$3;
            return_value___errno_location$3=__errno_location();
            if(!(*return_value___errno_location$3 == 0))
            {
              return_value___errno_location$1=__errno_location();
              return_value_strerror$2=strerror(*return_value___errno_location$1);
              x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 1070, return_value_strerror$2);
            }

          }

        while((_Bool)0);

      else
      {
        if(!(poll_result == 0))
        {
          do
            if(iSysLogLevel >= 1)
            {
              x_syslog(3, log_module_input_vdr, "readline_control: poll error at [%u]", (unsigned int)total_bytes);
              signed int *return_value___errno_location$6;
              return_value___errno_location$6=__errno_location();
              if(!(*return_value___errno_location$6 == 0))
              {
                return_value___errno_location$4=__errno_location();
                return_value_strerror$5=strerror(*return_value___errno_location$4);
                x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 1074, return_value_strerror$5);
              }

            }

          while((_Bool)0);
          return (signed long int)-1;
        }

        signed int *return_value___errno_location$7;
        return_value___errno_location$7=__errno_location();
        *return_value___errno_location$7 = 0;
        read_result=read(this->fd_control, (void *)(buf + (signed long int)total_bytes), (unsigned long int)1);
        pthread_testcancel();
        if(this->control_running == 0)
        {
          if(!(timeout >= 0))
            return (signed long int)-1;

        }

        if(!(read_result >= 1l))
        {
          if(read_result == 0l)
            do
              if(iSysLogLevel >= 1)
              {
                x_syslog(3, log_module_input_vdr, "Control stream disconnected");
                signed int *return_value___errno_location$10;
                return_value___errno_location$10=__errno_location();
                if(!(*return_value___errno_location$10 == 0))
                {
                  return_value___errno_location$8=__errno_location();
                  return_value_strerror$9=strerror(*return_value___errno_location$8);
                  x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 1087, return_value_strerror$9);
                }

              }

            while((_Bool)0);

          else
            do
              if(iSysLogLevel >= 1)
              {
                x_syslog(3, log_module_input_vdr, "readline_control: read error at [%u]", (unsigned int)total_bytes);
                signed int *return_value___errno_location$13;
                return_value___errno_location$13=__errno_location();
                if(!(*return_value___errno_location$13 == 0))
                {
                  return_value___errno_location$11=__errno_location();
                  return_value_strerror$12=strerror(*return_value___errno_location$11);
                  x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 1089, return_value_strerror$12);
                }

              }

            while((_Bool)0);
          if(!(read_result >= 0l))
          {
            return_value___errno_location$14=__errno_location();
            if(*return_value___errno_location$14 == 4)
              tmp_if_expr$16 = (_Bool)1;

            else
            {
              return_value___errno_location$15=__errno_location();
              tmp_if_expr$16 = *return_value___errno_location$15 == 11 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$16)
              continue;

          }

          return (signed long int)-1;
        }

        if(!(buf[(signed long int)total_bytes] == 0))
        {
          if((signed int)buf[(signed long int)total_bytes] == 13)
            buf[(signed long int)total_bytes] = (char)0;

          else
            if((signed int)buf[(signed long int)total_bytes] == 10)
            {
              buf[(signed long int)total_bytes] = (char)0;
              break;
            }

            else
            {
              total_bytes = total_bytes + 1ul;
              buf[(signed long int)total_bytes] = (char)0;
            }
        }

      }
  }
  return (signed long int)total_bytes;
}

// recvfrom
// file /usr/include/x86_64-linux-gnu/bits/socket2.h line 64
static inline signed long int recvfrom(signed int __fd, void * restrict __buf, unsigned long int __n, signed int __flags, union anonymous$55 __addr, unsigned int * restrict __addr_len)
{
  signed long int return_value___recvfrom_chk$1;
  signed long int return_value___recvfrom_chk_warn$2;
  signed long int return_value___recvfrom_alias$3;
  return_value___recvfrom_alias$3=__recvfrom_alias(__fd, __buf, __n, __flags, __addr, __addr_len);
  return return_value___recvfrom_alias$3;
}

// release_ticket
// file xine/osd_manager.c line 130
static void release_ticket(struct osd_manager_impl_s *this)
{
  if(!(this->ticket_acquired == 0))
  {
    this->stream->xine->port_ticket->release(this->stream->xine->port_ticket, 1);
    this->ticket_acquired = (unsigned char)0;
  }

}

// reset_scr_tuning
// file xine_input_vdr.c line 594
static void reset_scr_tuning(struct vdr_input_plugin_s *this)
{
  signed int return_value_pthread_mutex_trylock$1;
  return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&this->lock);
  if(return_value_pthread_mutex_trylock$1 == 0)
  {
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_vdr, "%s: assertion failed: lock %s unlocked !", (const void *)"reset_scr_tuning", (const void *)"this->lock");

    while((_Bool)0);
    pthread_mutex_unlock(&this->lock);
  }

  else
    if(!((signed int)this->scr_tuning == 0))
    {
      if(!(this->is_trickspeed == 0))
      {
        do
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "%s: assertion failed: %s is true !", (const void *)"reset_scr_tuning", (const void *)"this->is_trickspeed");

        while((_Bool)0);
        goto __CPROVER_DUMP_L14;
      }

      if(!(this->is_paused == 0))
      {
        do
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "%s: assertion failed: %s is true !", (const void *)"reset_scr_tuning", (const void *)"this->is_paused");

        while((_Bool)0);
        goto __CPROVER_DUMP_L14;
      }

      this->scr_tuning = (signed short int)0;
      this->scr->set_speed_tuning(this->scr, 1.0);
      signed int return_value__x_get_fine_speed$2;
      return_value__x_get_fine_speed$2=_x_get_fine_speed(this->stream);
      if(!(return_value__x_get_fine_speed$2 == 1000000))
      {
        if(this->is_paused == 0)
          _x_set_fine_speed(this->stream, 1000000);

        else
          if(iSysLogLevel >= 3)
            x_syslog(7, log_module_input_vdr, "reset_scr_tuning: playback is paused");

      }

      this->scr->scr.set_fine_speed(&this->scr->scr, 1000000);
    }


__CPROVER_DUMP_L14:
  ;
}

// reset_trick_speed
// file xine_input_vdr.c line 1687
static void reset_trick_speed(struct vdr_input_plugin_s *this)
{
  set_trick_speed(this, 1, 0);
}

// resume_demuxer
// file xine_input_vdr.c line 2024
static void resume_demuxer(struct vdr_input_plugin_s *this)
{
  pthread_cond_signal(&this->stream->demux_resume);
  pthread_mutex_unlock(&this->stream->demux_lock);
}

// rle_compress
// file xine/../tools/rle.h line 28
unsigned int rle_compress(struct osd_rle_elem_s **rle_data, const unsigned char *data, unsigned int w, unsigned int h)
{
  struct osd_rle_elem_s rle;
  struct osd_rle_elem_s *rle_p = ((struct osd_rle_elem_s *)NULL);
  struct osd_rle_elem_s *rle_base;
  unsigned int x;
  unsigned int y;
  unsigned int num_rle = (unsigned int)0;
  unsigned int rle_size = (unsigned int)8128;
  const unsigned char *c;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)((unsigned int)4 * rle_size));
  rle_p = (struct osd_rle_elem_s *)return_value_malloc$1;
  rle_base = rle_p;
  y = (unsigned int)0;
  struct osd_rle_elem_s *tmp_post$3;
  struct osd_rle_elem_s *tmp_post$4;
  for( ; !(y >= h); y = y + 1u)
  {
    rle.len = (unsigned short int)0;
    rle.color = (unsigned short int)0;
    c = data + (signed long int)(y * w);
    x = (unsigned int)0;
    for( ; !(x >= w); c = c + 1l)
    {
      if(!((signed int)rle.color == (signed int)*c))
      {
        if(!(rle.len == 0))
        {
          if(!(rle_size >= num_rle + h + 1u + -y))
          {
            rle_size = rle_size * (unsigned int)2;
            void *return_value_realloc$2;
            return_value_realloc$2=realloc((void *)rle_base, (unsigned long int)((unsigned int)4 * rle_size));
            rle_base = (struct osd_rle_elem_s *)return_value_realloc$2;
            rle_p = rle_base + (signed long int)num_rle;
          }

          tmp_post$3 = rle_p;
          rle_p = rle_p + 1l;
          *tmp_post$3 = rle;
          num_rle = num_rle + 1u;
        }

        rle.color = (unsigned short int)*c;
        rle.len = (unsigned short int)1;
      }

      else
        rle.len = rle.len + 1;
      x = x + 1u;
    }
    tmp_post$4 = rle_p;
    rle_p = rle_p + 1l;
    *tmp_post$4 = rle;
    num_rle = num_rle + 1u;
  }
  *rle_data = rle_base;
  return num_rle;
}

// rle_compress_hdmv
// file tools/rle.c line 248
unsigned long int rle_compress_hdmv(unsigned char **rle_data, const unsigned char *data, unsigned int w, unsigned int h, signed int *num_rle)
{
  unsigned int y;
  unsigned long int rle_size = (unsigned long int)0;
  unsigned char *rle = (unsigned char *)(void *)0;
  *rle_data = (unsigned char *)(void *)0;
  *num_rle = 0;
  y = (unsigned int)0;
  for( ; !(y >= h); y = y + 1u)
  {
    if(!((signed long int)rle_size + -((signed long int)(unsigned long int)(rle - *rle_data)) >= (signed long int)(4u * w)))
    {
      unsigned long int used = (unsigned long int)(rle - *rle_data);
      rle_size = rle_size < (unsigned long int)1 ? (unsigned long int)((w * h) / (unsigned int)16) : rle_size * (unsigned long int)2;
      void *return_value_realloc$1;
      return_value_realloc$1=realloc((void *)*rle_data, rle_size);
      *rle_data = (unsigned char *)return_value_realloc$1;
      rle = *rle_data + (signed long int)used;
    }

    unsigned int color = (unsigned int)*data;
    unsigned int len = (unsigned int)1;
    unsigned int x = (unsigned int)1;
    x = (unsigned int)1;
    for( ; !(x >= w); x = x + 1u)
      if((unsigned int)data[(signed long int)x] == color)
        len = len + 1u;

      else
      {
        rle=write_rle_hdmv(rle, color, len);
        *num_rle = *num_rle + 1;
        color = (unsigned int)data[(signed long int)x];
        len = (unsigned int)1;
      }
    if(!(len == 0u))
    {
      rle=write_rle_hdmv(rle, color, len);
      *num_rle = *num_rle + 1;
    }

    rle=write_rle_hdmv(rle, (unsigned int)0, (unsigned int)0);
    *num_rle = *num_rle + 1;
    data = data + (signed long int)w;
  }
  return (unsigned long int)(rle - *rle_data);
}

// rle_compress_net
// file tools/rle.c line 67
unsigned int rle_compress_net(unsigned char **rle_data, unsigned int *elems, const unsigned char *data, unsigned int w, unsigned int h)
{
  *elems=rle_compress((struct osd_rle_elem_s **)rle_data, data, w, h);
  unsigned int return_value_rle_recompress_net$1;
  return_value_rle_recompress_net$1=rle_recompress_net(*rle_data, *((struct osd_rle_elem_s **)rle_data), *elems);
  return return_value_rle_recompress_net$1;
}

// rle_palette_to_argb
// file tools/rle.c line 398
void rle_palette_to_argb(unsigned int *argb, struct osd_clut_s *palette, unsigned int entries)
{
  unsigned int i = (unsigned int)0;
  for( ; !(i >= entries); i = i + 1u)
    argb[(signed long int)i] = (unsigned int)((signed int)(palette + (signed long int)i)->alpha << 24 | (signed int)(palette + (signed long int)i)->$anon2.r << 16 | (signed int)(palette + (signed long int)i)->$anon0.g << 8 | (signed int)(palette + (signed long int)i)->$anon1.b);
}

// rle_palette_to_rgba
// file tools/rle.c line 409
void rle_palette_to_rgba(unsigned int *rgba, struct osd_clut_s *palette, unsigned int entries)
{
  unsigned int i = (unsigned int)0;
  for( ; !(i >= entries); i = i + 1u)
    rgba[(signed long int)i] = (unsigned int)((signed int)(palette + (signed long int)i)->$anon2.r << 24 | (signed int)(palette + (signed long int)i)->$anon0.g << 16 | (signed int)(palette + (signed long int)i)->$anon1.b << 8 | (signed int)(palette + (signed long int)i)->alpha);
}

// rle_recompress_net
// file tools/rle.c line 78
unsigned int rle_recompress_net(unsigned char *raw, struct osd_rle_elem_s *data, unsigned int elems)
{
  unsigned char *raw0 = raw;
  unsigned int i = (unsigned int)0;
  unsigned char *tmp_post$1;
  unsigned char *tmp_post$2;
  unsigned char *tmp_post$3;
  unsigned char *tmp_post$4;
  for( ; !(i >= elems); i = i + 1u)
  {
    unsigned short int len = (data + (signed long int)i)->len;
    unsigned short int color = (data + (signed long int)i)->color;
    if((signed int)len >= 0x80)
    {
      tmp_post$1 = raw;
      raw = raw + 1l;
      *tmp_post$1 = (unsigned char)((signed int)len >> 8 | 0x80);
      tmp_post$2 = raw;
      raw = raw + 1l;
      *tmp_post$2 = (unsigned char)((signed int)len & 0xff);
    }

    else
    {
      tmp_post$3 = raw;
      raw = raw + 1l;
      *tmp_post$3 = (unsigned char)((signed int)len & 0x7f);
    }
    tmp_post$4 = raw;
    raw = raw + 1l;
    *tmp_post$4 = (unsigned char)color;
  }
  return (unsigned int)(raw - raw0);
}

// rle_scale_nearest
// file xine/../tools/rle.h line 53
struct osd_rle_elem_s * rle_scale_nearest(const struct osd_rle_elem_s *old_rle, signed int *rle_elems, unsigned int w, unsigned int h, unsigned int new_w, unsigned int new_h)
{
  unsigned int old_w = w;
  unsigned int old_h = h;
  unsigned int old_y = (unsigned int)0;
  unsigned int new_y = (unsigned int)0;
  unsigned int factor_x = ((unsigned int)0x100 * new_w) / old_w;
  unsigned int factor_y = ((unsigned int)0x100 * new_h) / old_h;
  unsigned int rle_size;
  unsigned int tmp_if_expr$1;
  if(!((new_h * (unsigned int)*rle_elems) / h >= 8128u))
    tmp_if_expr$1 = (unsigned int)8128;

  else
    tmp_if_expr$1 = ((unsigned int)*rle_elems * new_h) / h;
  rle_size = tmp_if_expr$1;
  unsigned int num_rle = (unsigned int)0;
  struct osd_rle_elem_s *new_rle;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(sizeof(struct osd_rle_elem_s) /*4ul*/  * (unsigned long int)rle_size);
  new_rle = (struct osd_rle_elem_s *)return_value_malloc$2;
  struct osd_rle_elem_s *new_rle_start = new_rle;
  signed int tmp_post$4;
  struct osd_rle_elem_s *tmp_post$6;
  struct osd_rle_elem_s *tmp_post$7;
  unsigned int tmp_post$8;
  while(!(old_y >= old_h))
  {
    unsigned int elems_current_line = (unsigned int)0;
    unsigned int old_x = (unsigned int)0;
    unsigned int new_x = (unsigned int)0;
    while(!(old_x >= old_w))
    {
      unsigned int new_x_end = factor_x * (old_x + (unsigned int)old_rle->len) >> 8;
      if(!(new_w >= new_x_end))
        new_x_end = new_w;

      new_rle->len = (unsigned short int)(new_x_end - new_x);
      new_rle->color = old_rle->color;
      old_x = old_x + (unsigned int)old_rle->len;
      old_rle = old_rle + 1l;
      if((signed int)new_rle->len >= 1)
      {
        new_x = new_x + (unsigned int)new_rle->len;
        new_rle = new_rle + 1l;
        num_rle = num_rle + 1u;
        elems_current_line = elems_current_line + 1u;
        if(1u + num_rle >= rle_size)
        {
          rle_size = rle_size * (unsigned int)2;
          void *return_value_realloc$3;
          return_value_realloc$3=realloc((void *)new_rle_start, (unsigned long int)((unsigned int)4 * rle_size));
          new_rle_start = (struct osd_rle_elem_s *)return_value_realloc$3;
          new_rle = new_rle_start + (signed long int)num_rle;
        }

      }

    }
    if(!(new_x >= new_w))
      (new_rle - (signed long int)1)->len = (new_rle - (signed long int)1)->len + (unsigned short int)(new_w - new_x);

    old_y = old_y + 1u;
    new_y = new_y + 1u;
    if(factor_y >= 257u)
    {
      signed int dup = (signed int)((factor_y * old_y >> 8) - new_y);
      if(old_y == old_h)
        dup = (signed int)((new_h - new_y) - (unsigned int)1);

      do
      {
        tmp_post$4 = dup;
        dup = dup - 1;
        if(tmp_post$4 == 0)
          break;

        if(1u + new_y >= new_h)
          break;

        struct osd_rle_elem_s *prevline;
        unsigned int n;
        if(1u + elems_current_line + num_rle >= rle_size)
        {
          rle_size = rle_size * (unsigned int)2;
          void *return_value_realloc$5;
          return_value_realloc$5=realloc((void *)new_rle_start, (unsigned long int)((unsigned int)4 * rle_size));
          new_rle_start = (struct osd_rle_elem_s *)return_value_realloc$5;
          new_rle = new_rle_start + (signed long int)num_rle;
        }

        prevline = new_rle - (signed long int)elems_current_line;
        n = (unsigned int)0;
        for( ; !(n >= elems_current_line); n = n + 1u)
        {
          tmp_post$6 = new_rle;
          new_rle = new_rle + 1l;
          tmp_post$7 = prevline;
          prevline = prevline + 1l;
          *tmp_post$6 = *tmp_post$7;
          num_rle = num_rle + 1u;
        }
        new_y = new_y + 1u;
      }
      while((_Bool)1);
    }

    else
      if(!(factor_y >= 256u))
      {
        unsigned int skip = new_y - (factor_y * old_y >> 8);
        if(old_y == old_h + 4294967295u)
        {
          if(!(new_y >= new_h))
            skip = (unsigned int)0;

        }

        do
        {
          tmp_post$8 = skip;
          skip = skip - 1u;
          if(tmp_post$8 == 0u)
            break;

          if(old_y >= old_h)
            break;

          old_x = (unsigned int)0;
          for( ; !(old_x >= old_w); old_rle = old_rle + 1l)
            old_x = old_x + (unsigned int)old_rle->len;
          old_y = old_y + 1u;
        }
        while((_Bool)1);
      }

  }
  *rle_elems = (signed int)num_rle;
  return new_rle_start;
}

// rle_uncompress_argb
// file tools/rle.c line 447
void rle_uncompress_argb(unsigned int *dst, unsigned int w, unsigned int h, unsigned int stride, struct osd_rle_elem_s *rle_data, unsigned int num_rle, struct osd_clut_s *palette, unsigned int palette_entries)
{
  unsigned int lut[256l] = { (unsigned int)0, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u };
  if(!(palette_entries >= 257u))
  {
    rle_palette_to_argb(lut, palette, palette_entries);
    rle_uncompress_u32(dst, w, h, stride, rle_data, num_rle, lut);
  }

}

// rle_uncompress_hdmv
// file tools/rle.h line 63
signed int rle_uncompress_hdmv(struct osd_rle_elem_s **data, unsigned int w, unsigned int h, const unsigned char *rle_data, unsigned int num_rle, unsigned long int rle_size)
{
  unsigned int rle_count = (unsigned int)0;
  unsigned int x = (unsigned int)0;
  unsigned int y = (unsigned int)0;
  struct osd_rle_elem_s *rlep;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)((unsigned int)2 * num_rle), sizeof(struct osd_rle_elem_s) /*4ul*/ );
  rlep = (struct osd_rle_elem_s *)return_value_calloc$1;
  const unsigned char *end = rle_data + (signed long int)rle_size;
  *data = rlep;
  const unsigned char *tmp_post$2;
  const unsigned char *tmp_post$3;
  const unsigned char *tmp_post$4;
  const unsigned char *tmp_post$5;
  const unsigned char *tmp_post$6;
  _Bool tmp_if_expr$7;
  while(!(y >= h))
  {
    if(rle_data >= end || rle_count >= 2u * num_rle)
    {
      free((void *)*data);
      *data = (struct osd_rle_elem_s *)(void *)0;
      return -1 - (signed int)(rle_data >= end);
    }

    unsigned int byte;
    tmp_post$2 = rle_data;
    rle_data = rle_data + 1l;
    byte = (unsigned int)*tmp_post$2;
    if(!(byte == 0u))
    {
      rlep->color = (unsigned short int)byte;
      rlep->len = (unsigned short int)1;
    }

    else
    {
      tmp_post$3 = rle_data;
      rle_data = rle_data + 1l;
      byte = (unsigned int)*tmp_post$3;
      if((128u & byte) == 0u)
      {
        rlep->color = (unsigned short int)0;
        if((64u & byte) == 0u)
          rlep->len = (unsigned short int)(byte & (unsigned int)0x3f);

        else
        {
          tmp_post$4 = rle_data;
          rle_data = rle_data + 1l;
          rlep->len = (unsigned short int)((byte & (unsigned int)0x3f) << 8 | (unsigned int)*tmp_post$4);
        }
      }

      else
      {
        if((64u & byte) == 0u)
          rlep->len = (unsigned short int)(byte & (unsigned int)0x3f);

        else
        {
          tmp_post$5 = rle_data;
          rle_data = rle_data + 1l;
          rlep->len = (unsigned short int)((byte & (unsigned int)0x3f) << 8 | (unsigned int)*tmp_post$5);
        }
        tmp_post$6 = rle_data;
        rle_data = rle_data + 1l;
        rlep->color = (unsigned short int)*tmp_post$6;
      }
    }
    if((signed int)rlep->len >= 1)
    {
      if((signed int)rlep->len == 1 && !(x == 0u))
        tmp_if_expr$7 = (rlep + (signed long int)-1)->color == rlep->color ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$7 = (_Bool)0;
      if(tmp_if_expr$7)
      {
        (rlep + (signed long int)-1)->len = (rlep + (signed long int)-1)->len + 1;
        x = x + 1u;
      }

      else
      {
        x = x + (unsigned int)rlep->len;
        rlep = rlep + 1l;
        rle_count = rle_count + 1u;
      }
      if(!(w >= x))
        return -9999;

    }

    else
    {
      if(!(x >= w + 4294967295u))
      {
        rlep->len = (unsigned short int)(w - x);
        rlep->color = (unsigned short int)0xff;
        rlep = rlep + 1l;
        rle_count = rle_count + 1u;
      }

      x = (unsigned int)0;
      y = y + 1u;
    }
  }
  return (signed int)rle_count;
}

// rle_uncompress_lut8
// file tools/rle.c line 372
void rle_uncompress_lut8(unsigned char *dst, unsigned int w, unsigned int h, unsigned int stride, struct osd_rle_elem_s *rle_data, unsigned int num_rle)
{
  unsigned int i;
  unsigned int pixelcounter = (unsigned int)0;
  unsigned int idx = (unsigned int)0;
  unsigned int line = (unsigned int)0;
  i = (unsigned int)0;
  for( ; !(i >= num_rle); i = i + 1u)
  {
    unsigned char color = (unsigned char)(rle_data + (signed long int)i)->color;
    unsigned int len = (unsigned int)(rle_data + (signed long int)i)->len;
    unsigned int j = (unsigned int)0;
    for( ; !(j >= len); j = j + 1u)
    {
      if(pixelcounter >= w)
      {
        idx = idx + (stride - pixelcounter);
        pixelcounter = (unsigned int)0;
        line = line + 1u;
        if(line >= h)
          goto __CPROVER_DUMP_L6;

      }

      dst[(signed long int)idx] = color;
      idx = idx + 1u;
      pixelcounter = pixelcounter + 1u;
    }
  }

__CPROVER_DUMP_L6:
  ;
}

// rle_uncompress_rgba
// file tools/rle.c line 462
void rle_uncompress_rgba(unsigned int *dst, unsigned int w, unsigned int h, unsigned int stride, struct osd_rle_elem_s *rle_data, unsigned int num_rle, struct osd_clut_s *palette, unsigned int palette_entries)
{
  unsigned int lut[256l] = { (unsigned int)0, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u };
  if(!(palette_entries >= 257u))
  {
    rle_palette_to_rgba(lut, palette, palette_entries);
    rle_uncompress_u32(dst, w, h, stride, rle_data, num_rle, lut);
  }

}

// rle_uncompress_u32
// file tools/rle.c line 420
static void rle_uncompress_u32(unsigned int *dst, unsigned int w, unsigned int h, unsigned int stride, struct osd_rle_elem_s *rle_data, unsigned int num_rle, unsigned int *lut)
{
  unsigned int i;
  unsigned int pixelcounter = (unsigned int)0;
  unsigned int idx = (unsigned int)0;
  unsigned int line = (unsigned int)0;
  i = (unsigned int)0;
  for( ; !(i >= num_rle); i = i + 1u)
  {
    unsigned int color = lut[(signed long int)(rle_data + (signed long int)i)->color];
    unsigned int len = (unsigned int)(rle_data + (signed long int)i)->len;
    unsigned int j = (unsigned int)0;
    for( ; !(j >= len); j = j + 1u)
    {
      if(pixelcounter >= w)
      {
        idx = idx + (stride - pixelcounter);
        pixelcounter = (unsigned int)0;
        line = line + 1u;
        if(line >= h)
          goto __CPROVER_DUMP_L6;

      }

      dst[(signed long int)idx] = color;
      idx = idx + 1u;
      pixelcounter = pixelcounter + 1u;
    }
  }

__CPROVER_DUMP_L6:
  ;
}

// scr_adjust
// file xine/adjustable_scr.c line 125
static void scr_adjust(struct scr_plugin_s *scr, signed long int vpts)
{
  struct scr_impl_s *this = (struct scr_impl_s *)scr;
  struct timeval tv;
  pthread_mutex_lock(&this->lock);
  xine_monotonic_clock(&tv, (struct timezone *)(void *)0);
  this->cur_time.tv_sec = tv.tv_sec;
  this->cur_time.tv_usec = tv.tv_usec;
  this->cur_pts = vpts;
  pthread_mutex_unlock(&this->lock);
}

// scr_exit
// file xine/adjustable_scr.c line 183
static void scr_exit(struct scr_plugin_s *scr)
{
  struct scr_impl_s *this = (struct scr_impl_s *)scr;
  pthread_mutex_destroy(&this->lock);
  free((void *)this);
}

// scr_get_current
// file xine/adjustable_scr.c line 154
static signed long int scr_get_current(struct scr_plugin_s *scr)
{
  struct scr_impl_s *this = (struct scr_impl_s *)scr;
  struct timeval tv;
  signed long int pts;
  double pts_calc;
  pthread_mutex_lock(&this->lock);
  pts = this->cur_pts;
  if(!(this->buffering == 0))
  {
    pthread_mutex_unlock(&this->lock);
    return pts;
  }

  else
  {
    xine_monotonic_clock(&tv, (struct timezone *)(void *)0);
    pts_calc = (double)(tv.tv_sec - this->cur_time.tv_sec) * this->speed_factor;
    pts_calc = pts_calc + ((double)(tv.tv_usec - this->cur_time.tv_usec) * this->speed_factor) / 1e6;
    pts = pts + (signed long int)pts_calc;
    pthread_mutex_unlock(&this->lock);
    return pts;
  }
}

// scr_get_priority
// file xine/adjustable_scr.c line 103
static signed int scr_get_priority(struct scr_plugin_s *scr)
{
  return 50;
}

// scr_set_fine_speed
// file xine/adjustable_scr.c line 108
static signed int scr_set_fine_speed(struct scr_plugin_s *scr, signed int speed)
{
  struct scr_impl_s *this = (struct scr_impl_s *)scr;
  pthread_mutex_lock(&this->lock);
  set_pivot(this);
  this->xine_speed = speed;
  this->speed_factor = (((double)speed * (double)this->scr_speed_base) / (1.0 * (double)1000000)) * this->speed_tuning;
  pthread_mutex_unlock(&this->lock);
  return speed;
}

// scr_start
// file xine/adjustable_scr.c line 140
static void scr_start(struct scr_plugin_s *scr, signed long int start_vpts)
{
  struct scr_impl_s *this = (struct scr_impl_s *)scr;
  pthread_mutex_lock(&this->lock);
  xine_monotonic_clock(&this->cur_time, (struct timezone *)(void *)0);
  this->cur_pts = start_vpts;
  pthread_mutex_unlock(&this->lock);
  scr_set_fine_speed(&this->$anon0.scr, 1000000);
}

// scr_tuning_set_paused
// file xine_input_vdr.c line 571
static void scr_tuning_set_paused(struct vdr_input_plugin_s *this)
{
  signed int return_value_pthread_mutex_trylock$1;
  return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&this->lock);
  if(return_value_pthread_mutex_trylock$1 == 0)
  {
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_vdr, "%s: assertion failed: lock %s unlocked !", (const void *)"scr_tuning_set_paused", (const void *)"this->lock");

    while((_Bool)0);
    pthread_mutex_unlock(&this->lock);
  }

  else
    if(!(this->is_trickspeed == 0))
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "%s: assertion failed: %s is true !", (const void *)"scr_tuning_set_paused", (const void *)"this->is_trickspeed");

      while((_Bool)0);

    else
      if(!(this->is_paused == 0))
        do
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "%s: assertion failed: %s is true !", (const void *)"scr_tuning_set_paused", (const void *)"this->is_paused");

        while((_Bool)0);

      else
        if(!(this->slave.stream == ((struct xine_stream_s *)NULL)))
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_input_vdr, "%s: assertion failed: %s is true !", (const void *)"scr_tuning_set_paused", (const void *)"this->slave.stream");

          while((_Bool)0);

        else
          if(this->still_mode == 0)
          {
            if(!((signed int)this->scr_tuning == -10000))
            {
              this->scr_tuning = (signed short int)-10000;
              this->scr->set_speed_tuning(this->scr, 1.0);
              signed int return_value__x_get_fine_speed$2;
              return_value__x_get_fine_speed$2=_x_get_fine_speed(this->stream);
              if(!(return_value__x_get_fine_speed$2 == 0))
                _x_set_fine_speed(this->stream, 0);

              this->B_frames = (unsigned int)0;
              this->P_frames = this->B_frames;
              this->I_frames = this->P_frames;
            }

          }

}

// select_spu_channel
// file xine_input_vdr.c line 2324
static void select_spu_channel(struct xine_stream_s *stream, signed int channel)
{
  _x_select_spu_channel(stream, channel);
  if(channel == -2)
  {
    if(!(stream->video_out == ((struct xine_video_port_s$1 *)NULL)))
    {
      pthread_mutex_lock(&stream->frontend_lock);
      stream->xine->port_ticket->acquire(stream->xine->port_ticket, 0);
      stream->video_out->enable_ovl(stream->video_out, 1);
      stream->xine->port_ticket->release(stream->xine->port_ticket, 0);
      pthread_mutex_unlock(&stream->frontend_lock);
    }

  }

}

// send_meta_info
// file xine_input_vdr.c line 2217
static void send_meta_info(struct vdr_input_plugin_s *this)
{
  if(!(this->slave.stream == ((struct xine_stream_s *)NULL)))
  {
    const char *title;
    title=xine_get_meta_info(this->slave.stream, 0);
    const char *artist;
    artist=xine_get_meta_info(this->slave.stream, 2);
    const char *album;
    album=xine_get_meta_info(this->slave.stream, 4);
    const char *tracknumber;
    tracknumber=xine_get_meta_info(this->slave.stream, 11);
    printf_vdr(this, "INFO METAINFO title=@%s@ artist=@%s@ album=@%s@ tracknumber=@%s@\r\n", (_Bool)title ? title : "", (_Bool)artist ? artist : "", (_Bool)album ? album : "", (_Bool)tracknumber ? tracknumber : "");
  }

}

// set_argb_layer
// file xine/osd_manager.c line 95
static void set_argb_layer(struct argb_layer_s **dst, struct argb_layer_s *src)
{
  if(!(src == ((struct argb_layer_s *)NULL)))
  {
    pthread_mutex_lock(&src->mutex);
    src->ref_count = src->ref_count + 1;
    pthread_mutex_unlock(&src->mutex);
  }

  if(!(*dst == ((struct argb_layer_s *)NULL)))
  {
    signed int free_argb_layer;
    pthread_mutex_lock(&(*dst)->mutex);
    (*dst)->ref_count = (*dst)->ref_count - 1;
    free_argb_layer = (signed int)(0 == (*dst)->ref_count);
    pthread_mutex_unlock(&(*dst)->mutex);
    if(!(free_argb_layer == 0))
      argb_layer_destroy(*dst);

  }

  *dst = src;
}

// set_audio_rate
// file xine/xvdr_metronom.c line 234
static void set_audio_rate(struct metronom_s *metronom, signed long int pts_per_smpls)
{
  struct xvdr_metronom_s$0 *this = (struct xvdr_metronom_s$0 *)metronom;
  this->orig_metronom->set_audio_rate(this->orig_metronom, pts_per_smpls);
}

// set_buffer_limits
// file xine_input_vdr.c line 1523
static void set_buffer_limits(struct vdr_input_plugin_s *this)
{
  signed int return_value_pthread_mutex_trylock$1;
  return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&this->lock);
  struct fifo_buffer_s *tmp_if_expr$2;
  if(return_value_pthread_mutex_trylock$1 == 0)
  {
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_vdr, "%s: assertion failed: lock %s unlocked !", (const void *)"set_buffer_limits", (const void *)"this->lock");

    while((_Bool)0);
    pthread_mutex_unlock(&this->lock);
  }

  else
  {
    signed int capacity;
    if(!(this->hd_stream == 0))
      tmp_if_expr$2 = this->hd_buffer;

    else
      tmp_if_expr$2 = this->buffer_pool;
    capacity = tmp_if_expr$2->buffer_pool_capacity;
    signed int max_buffers;
    if(!(this->no_video == 0))
      max_buffers = 10;

    else
    {
      max_buffers = capacity;
      if(this->live_mode == 0)
      {
        if(!(this->fd_control >= 0))
          max_buffers = max_buffers - (capacity >> 2);

      }

      max_buffers = max_buffers - 10;
    }
    this->reserved_buffers = (unsigned int)(capacity - max_buffers);
    if(!(capacity >= max_buffers))
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "set_buffer_limits(): internal error: max=%d, capacity=%d", max_buffers, capacity);

      while((_Bool)0);
      this->reserved_buffers = (unsigned int)10;
    }

    if(!(this->reserved_buffers >= 2u))
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "set_buffer_limits(): internal error: reserved=%d", this->reserved_buffers);

      while((_Bool)0);
      this->reserved_buffers = (unsigned int)2;
    }

  }
}

// set_deinterlace_method
// file xine_input_vdr.c line 2121
static signed int set_deinterlace_method(struct vdr_input_plugin_s *this, const char *method_name)
{
  signed int method = 0;
  signed int return_value_strncasecmp$8;
  return_value_strncasecmp$8=strncasecmp(method_name, "bob", (unsigned long int)3);
  signed int return_value_strncasecmp$7;
  signed int return_value_strncasecmp$6;
  signed int return_value_strncasecmp$5;
  signed int return_value_strncasecmp$4;
  signed int return_value_strncasecmp$3;
  signed int return_value_strncasecmp$2;
  signed int return_value_strncasecmp$1;
  if(return_value_strncasecmp$8 == 0)
    method = 1;

  else
  {
    return_value_strncasecmp$7=strncasecmp(method_name, "weave", (unsigned long int)5);
    if(return_value_strncasecmp$7 == 0)
      method = 2;

    else
    {
      return_value_strncasecmp$6=strncasecmp(method_name, "greedy", (unsigned long int)6);
      if(return_value_strncasecmp$6 == 0)
        method = 3;

      else
      {
        return_value_strncasecmp$5=strncasecmp(method_name, "onefield", (unsigned long int)8);
        if(return_value_strncasecmp$5 == 0)
          method = 4;

        else
        {
          return_value_strncasecmp$4=strncasecmp(method_name, "onefield_xv", (unsigned long int)11);
          if(return_value_strncasecmp$4 == 0)
            method = 5;

          else
          {
            return_value_strncasecmp$3=strncasecmp(method_name, "linearblend", (unsigned long int)11);
            if(return_value_strncasecmp$3 == 0)
              method = 6;

            else
            {
              return_value_strncasecmp$2=strncasecmp(method_name, "none", (unsigned long int)4);
              if(return_value_strncasecmp$2 == 0)
                method = 0;

              else
                if(*method_name == 0)
                  method = 0;

                else
                {
                  return_value_strncasecmp$1=strncasecmp(method_name, "tvtime", (unsigned long int)6);
                  if(return_value_strncasecmp$1 == 0)
                    method = -1;

                  else
                    return -2;
                }
            }
          }
        }
      }
    }
  }
  this->class->xine->config->update_num(this->class->xine->config, "video.output.xv_deinterlace_method", method >= 0 ? method : 0);
  xine_set_param(this->stream, 0x01000000, (signed int)!(!(method != 0)));
  return 0;
}

// set_live_mode
// file xine_input_vdr.c line 1595
static void set_live_mode(struct vdr_input_plugin_s *this, signed int onoff)
{
  signed int return_value_pthread_mutex_trylock$1;
  return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&this->lock);
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$2;
  if(return_value_pthread_mutex_trylock$1 == 0)
  {
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_vdr, "%s: assertion failed: lock %s unlocked !", (const void *)"set_live_mode", (const void *)"this->lock");

    while((_Bool)0);
    pthread_mutex_unlock(&this->lock);
  }

  else
  {
    if(!((signed int)this->live_mode == onoff))
    {
      struct config_values_s *config = this->class->xine->config;
      this->live_mode = (unsigned char)onoff;
      this->stream->metronom->set_option(this->stream->metronom, 7, (signed long int)((4 * 90000) / 25));
      if(!(this->live_mode == 0))
        tmp_if_expr$3 = (_Bool)1;

      else
      {
        if(this->fd_control >= 0)
          tmp_if_expr$2 = !(this->slave.stream != ((struct xine_stream_s *)NULL)) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$2 = (_Bool)0;
        tmp_if_expr$3 = tmp_if_expr$2 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$3)
        config->update_num(config, "audio.synchronization.av_sync_method", 1);

    }

    set_buffer_limits(this);
    set_still_mode(this, 0);
    if(this->live_mode == 0)
      reset_scr_tuning(this);

    signal_buffer_pool_not_empty(this);
  }
}

// set_master
// file xine/xvdr_metronom.c line 305
static void set_master(struct metronom_s *metronom, struct metronom_s *master)
{
  struct xvdr_metronom_s$0 *this = (struct xvdr_metronom_s$0 *)metronom;
  this->orig_metronom->set_master(this->orig_metronom, master);
}

// set_option
// file xine/xvdr_metronom.c line 240
static void set_option(struct metronom_s *metronom, signed int option, signed long int value)
{
  struct xvdr_metronom_s$0 *this = (struct xvdr_metronom_s$0 *)metronom;
  if(option == 0x1001)
  {
    if(value >= 1l)
    {
      pthread_mutex_lock(&this->mutex);
      this->last_vo_pts = value;
      pthread_mutex_unlock(&this->mutex);
    }

  }

  else
    if(option == 4)
    {
      pthread_mutex_lock(&this->mutex);
      this->live_buffering = (unsigned char)value;
      pthread_mutex_unlock(&this->mutex);
    }

    else
      if(option == 5)
      {
        pthread_mutex_lock(&this->mutex);
        this->stream_start = (unsigned char)1;
        this->buffering_start_time=time_ms$link1();
        pthread_mutex_unlock(&this->mutex);
      }

      else
        if(option == 1)
          this->trickspeed = (signed int)value;

        else
          if(option == 2)
            this->still_mode = (signed int)value;

          else
            this->orig_metronom->set_option(this->orig_metronom, option, value);
}

// set_pivot
// file xine/adjustable_scr.c line 74
static void set_pivot(struct scr_impl_s *this)
{
  struct timeval tv;
  signed long int pts;
  double pts_calc;
  if(!(this->buffering == 0))
    xine_monotonic_clock(&this->cur_time, (struct timezone *)(void *)0);

  else
  {
    xine_monotonic_clock(&tv, (struct timezone *)(void *)0);
    pts_calc = (double)(tv.tv_sec - this->cur_time.tv_sec) * this->speed_factor;
    pts_calc = pts_calc + ((double)(tv.tv_usec - this->cur_time.tv_usec) * this->speed_factor) / 1e6;
    pts = (signed long int)((double)this->cur_pts + pts_calc);
    this->cur_time.tv_sec = tv.tv_sec;
    this->cur_time.tv_usec = tv.tv_usec;
    this->cur_pts = pts;
  }
}

// set_recv_buffer_size
// file xine_input_vdr.c line 5294
static void set_recv_buffer_size(signed int fd, unsigned int max_buf)
{
  signed int return_value_setsockopt$8;
  return_value_setsockopt$8=setsockopt(fd, 1, 8, (const void *)&max_buf, (unsigned int)sizeof(signed int) /*4ul*/ );
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  signed int *return_value___errno_location$4;
  char *return_value_strerror$5;
  if(!(return_value_setsockopt$8 >= 0))
    do
      if(iSysLogLevel >= 1)
      {
        x_syslog(3, log_module_input_vdr, "setsockopt(SO_RCVBUF,%d) failed", max_buf);
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        if(!(*return_value___errno_location$3 == 0))
        {
          return_value___errno_location$1=__errno_location();
          return_value_strerror$2=strerror(*return_value___errno_location$1);
          x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 5300, return_value_strerror$2);
        }

      }

    while((_Bool)0);

  else
  {
    unsigned int tmp = (unsigned int)0;
    unsigned int len = (unsigned int)sizeof(signed int) /*4ul*/ ;
    signed int return_value_getsockopt$7;
    return_value_getsockopt$7=getsockopt(fd, 1, 8, (void *)&tmp, &len);
    if(!(return_value_getsockopt$7 >= 0))
      do
        if(iSysLogLevel >= 1)
        {
          x_syslog(3, log_module_input_vdr, "getsockopt(SO_RCVBUF,%d) failed", max_buf);
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          if(!(*return_value___errno_location$6 == 0))
          {
            return_value___errno_location$4=__errno_location();
            return_value_strerror$5=strerror(*return_value___errno_location$4);
            x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 5305, return_value_strerror$5);
          }

        }

      while((_Bool)0);

    else
      if(!(tmp == 2u * max_buf))
        do
          if(iSysLogLevel >= 3)
            x_syslog(7, log_module_input_vdr, "setsockopt(SO_RCVBUF): got %d bytes", tmp);

        while((_Bool)0);

  }
  max_buf = (unsigned int)256;
  setsockopt(fd, 1, 7, (const void *)&max_buf, (unsigned int)sizeof(signed int) /*4ul*/ );
}

// set_still_mode
// file xine_input_vdr.c line 1569
static void set_still_mode(struct vdr_input_plugin_s *this, signed int still_mode)
{
  signed int return_value_pthread_mutex_trylock$1;
  return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&this->lock);
  _Bool tmp_if_expr$2;
  if(return_value_pthread_mutex_trylock$1 == 0)
  {
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_vdr, "%s: assertion failed: lock %s unlocked !", (const void *)"set_still_mode", (const void *)"this->lock");

    while((_Bool)0);
    pthread_mutex_unlock(&this->lock);
  }

  else
  {
    if(!(still_mode == 0))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = this->still_mode != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      if(this->live_mode == 0)
        goto __CPROVER_DUMP_L8;

      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "%s: assertion failed: %s is true !", (const void *)"set_still_mode", (const void *)"this->live_mode");

      while((_Bool)0);
    }

    else
    {

    __CPROVER_DUMP_L8:
      ;
      pthread_mutex_lock(&this->stream->first_frame_lock);
      this->stream->first_frame_flag = (unsigned int)2;
      pthread_mutex_unlock(&this->stream->first_frame_lock);
      this->still_mode = (unsigned char)!(!(still_mode != 0));
      _x_stream_info_set(this->stream, 23, (signed int)this->still_mode);
      if(!(this->still_mode == 0))
        reset_scr_tuning(this);

      this->stream->metronom->set_option(this->stream->metronom, 0x1001 + 2, (signed long int)still_mode);
    }
  }
}

// set_trick_speed
// file xine_input_vdr.c line 1634
static void set_trick_speed(struct vdr_input_plugin_s *this, signed int speed, signed int backwards)
{
  signed int return_value_pthread_mutex_trylock$1;
  return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&this->lock);
  signed int return_value__x_get_fine_speed$2;
  if(return_value_pthread_mutex_trylock$1 == 0)
  {
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_vdr, "%s: assertion failed: lock %s unlocked !", (const void *)"set_trick_speed", (const void *)"this->lock");

    while((_Bool)0);
    pthread_mutex_unlock(&this->lock);
  }

  else
    if(!(speed >= 65) && speed >= -64)
    {
      this->is_paused = (unsigned char)!(!(speed == 0));
      if(this->is_paused == 0)
        set_still_mode(this, 0);

      if(!(this->slave.stream == ((struct xine_stream_s *)NULL)))
        backwards = 0;

      this->stream->metronom->set_option(this->stream->metronom, 0x1001 + 1, (signed long int)(backwards != 0 ? speed : 0));
      if(speed >= 2 || !(speed >= -1))
      {
        if(!(this->live_mode == 0))
        {
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "%s: assertion failed: %s is true !", (const void *)"set_trick_speed", (const void *)"this->live_mode");

        }

        reset_scr_tuning(this);
        this->is_trickspeed = (unsigned char)1;
      }

      else
        this->is_trickspeed = (unsigned char)0;
      _x_stream_info_set(this->stream, 23, (signed int)(this->still_mode != 0 ? (_Bool)1 : (speed == 0 ? (_Bool)1 : (_Bool)0)));
      if(speed >= 1)
        speed = 1000000 / speed;

      else
        speed = 1000000 * -speed;
      if(!((signed int)this->scr_tuning == -10000))
      {
        return_value__x_get_fine_speed$2=_x_get_fine_speed(this->stream);
        if(!(return_value__x_get_fine_speed$2 == speed))
          _x_set_fine_speed(this->stream, speed);

      }

      if(!(this->slave.stream == ((struct xine_stream_s *)NULL)))
        _x_set_fine_speed(this->slave.stream, speed);

    }

}

// set_video_properties
// file xine_input_vdr.c line 2146
static signed int set_video_properties(struct vdr_input_plugin_s *this, signed int hue, signed int saturation, signed int brightness, signed int sharpness, signed int noise_reduction, signed int contrast, signed int vo_aspect_ratio)
{
  pthread_mutex_lock(&this->lock);
  if(this->video_properties_saved == 0)
  {
    if(brightness >= 0 || contrast >= 0 || hue >= 0 || noise_reduction >= 0 || saturation >= 0 || sharpness >= 0 || vo_aspect_ratio >= 0)
    {
      this->video_properties_saved = (unsigned char)1;
      this->orig_hue=xine_get_param(this->stream, 0x01000002);
      this->orig_saturation=xine_get_param(this->stream, 0x01000003);
      this->orig_brightness=xine_get_param(this->stream, 0x01000005);
      this->orig_sharpness=xine_get_param(this->stream, 0x01000018);
      this->orig_noise_reduction=xine_get_param(this->stream, 0x01000019);
      this->orig_contrast=xine_get_param(this->stream, 0x01000004);
      this->orig_vo_aspect_ratio=xine_get_param(this->stream, 0x01000001);
    }

  }

  _Bool tmp_if_expr$2;
  if(hue >= 0)
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = this->video_properties_saved != 0 ? (_Bool)1 : (_Bool)0;
  signed int tmp_if_expr$1;
  if(tmp_if_expr$2)
  {
    if(hue >= 0)
      tmp_if_expr$1 = hue;

    else
      tmp_if_expr$1 = this->orig_hue;
    xine_set_param(this->stream, 0x01000002, tmp_if_expr$1);
  }

  _Bool tmp_if_expr$4;
  if(saturation >= 0)
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = this->video_properties_saved != 0 ? (_Bool)1 : (_Bool)0;
  signed int tmp_if_expr$3;
  if(tmp_if_expr$4)
  {
    if(saturation >= 1)
      tmp_if_expr$3 = saturation;

    else
      tmp_if_expr$3 = this->orig_saturation;
    xine_set_param(this->stream, 0x01000003, tmp_if_expr$3);
  }

  _Bool tmp_if_expr$6;
  if(brightness >= 0)
    tmp_if_expr$6 = (_Bool)1;

  else
    tmp_if_expr$6 = this->video_properties_saved != 0 ? (_Bool)1 : (_Bool)0;
  signed int tmp_if_expr$5;
  if(tmp_if_expr$6)
  {
    if(brightness >= 0)
      tmp_if_expr$5 = brightness;

    else
      tmp_if_expr$5 = this->orig_brightness;
    xine_set_param(this->stream, 0x01000005, tmp_if_expr$5);
  }

  _Bool tmp_if_expr$8;
  if(sharpness >= 0)
    tmp_if_expr$8 = (_Bool)1;

  else
    tmp_if_expr$8 = this->video_properties_saved != 0 ? (_Bool)1 : (_Bool)0;
  signed int tmp_if_expr$7;
  if(tmp_if_expr$8)
  {
    if(sharpness >= 0)
      tmp_if_expr$7 = sharpness;

    else
      tmp_if_expr$7 = this->orig_sharpness;
    xine_set_param(this->stream, 0x01000018, tmp_if_expr$7);
  }

  _Bool tmp_if_expr$10;
  if(noise_reduction >= 0)
    tmp_if_expr$10 = (_Bool)1;

  else
    tmp_if_expr$10 = this->video_properties_saved != 0 ? (_Bool)1 : (_Bool)0;
  signed int tmp_if_expr$9;
  if(tmp_if_expr$10)
  {
    if(noise_reduction >= 0)
      tmp_if_expr$9 = noise_reduction;

    else
      tmp_if_expr$9 = this->orig_noise_reduction;
    xine_set_param(this->stream, 0x01000019, tmp_if_expr$9);
  }

  _Bool tmp_if_expr$12;
  if(contrast >= 0)
    tmp_if_expr$12 = (_Bool)1;

  else
    tmp_if_expr$12 = this->video_properties_saved != 0 ? (_Bool)1 : (_Bool)0;
  signed int tmp_if_expr$11;
  if(tmp_if_expr$12)
  {
    if(contrast >= 0)
      tmp_if_expr$11 = contrast;

    else
      tmp_if_expr$11 = this->orig_contrast;
    xine_set_param(this->stream, 0x01000004, tmp_if_expr$11);
  }

  _Bool tmp_if_expr$14;
  if(vo_aspect_ratio >= 0)
    tmp_if_expr$14 = (_Bool)1;

  else
    tmp_if_expr$14 = this->video_properties_saved != 0 ? (_Bool)1 : (_Bool)0;
  signed int tmp_if_expr$13;
  if(tmp_if_expr$14)
  {
    if(vo_aspect_ratio >= 0)
      tmp_if_expr$13 = vo_aspect_ratio;

    else
      tmp_if_expr$13 = this->orig_vo_aspect_ratio;
    xine_set_param(this->stream, 0x01000001, tmp_if_expr$13);
  }

  if(!(brightness >= 0) && !(contrast >= 0) && !(hue >= 0) && !(noise_reduction >= 0) && !(saturation >= 0) && !(sharpness >= 0) && !(vo_aspect_ratio >= 0))
    this->video_properties_saved = (unsigned char)0;

  pthread_mutex_unlock(&this->lock);
  return 0;
}

// signal_buffer_not_empty
// file xine_input_vdr.c line 1275
static void signal_buffer_not_empty(struct vdr_input_plugin_s *this)
{
  if(!(this->block_buffer == ((struct fifo_buffer_s *)NULL)))
  {
    pthread_mutex_lock(&this->block_buffer->mutex);
    pthread_cond_broadcast(&this->block_buffer->not_empty);
    pthread_mutex_unlock(&this->block_buffer->mutex);
  }

}

// signal_buffer_pool_not_empty
// file xine_input_vdr.c line 1261
static void signal_buffer_pool_not_empty(struct vdr_input_plugin_s *this)
{
  if(!(this->buffer_pool == ((struct fifo_buffer_s *)NULL)))
  {
    pthread_mutex_lock(&this->buffer_pool->buffer_pool_mutex);
    pthread_cond_broadcast(&this->buffer_pool->buffer_pool_cond_not_empty);
    pthread_mutex_unlock(&this->buffer_pool->buffer_pool_mutex);
  }

  if(!(this->hd_buffer == ((struct fifo_buffer_s *)NULL)))
  {
    pthread_mutex_lock(&this->hd_buffer->buffer_pool_mutex);
    pthread_cond_broadcast(&this->hd_buffer->buffer_pool_cond_not_empty);
    pthread_mutex_unlock(&this->hd_buffer->buffer_pool_mutex);
  }

}

// slave_track_maps_changed
// file xine_input_vdr.c line 3686
static void slave_track_maps_changed(struct vdr_input_plugin_s *this)
{
  char tracks[1024l];
  char lang[128l];
  signed int i;
  signed int current;
  signed int n = 0;
  unsigned long int cnt;
  update_dvd_title_number(this);
  strcpy(tracks, "INFO TRACKMAP AUDIO ");
  cnt=strlen(tracks);
  current=xine_get_param(this->slave.stream, 3);
  i = 0;
  signed int return_value_xine_get_audio_lang$4;
  for( ; !(i >= 32) && !(cnt >= 992ul); i = i + 1)
  {
    return_value_xine_get_audio_lang$4=xine_get_audio_lang(this->slave.stream, i, lang);
    if(!(return_value_xine_get_audio_lang$4 == 0))
    {
      const char *return_value_trim_str$1;
      return_value_trim_str$1=trim_str(lang);
      signed int return_value_snprintf$2;
      return_value_snprintf$2=snprintf(tracks + (signed long int)cnt, (sizeof(char [1024l]) /*1024ul*/  - cnt) - (unsigned long int)32, "%s%d:%s ", i == current ? "*" : "", i, return_value_trim_str$1);
      cnt = cnt + (unsigned long int)return_value_snprintf$2;
      n = n + 1;
    }

    else
      if(!(i >= this->slave.stream->audio_track_map_entries))
      {
        signed int return_value_snprintf$3;
        return_value_snprintf$3=snprintf(tracks + (signed long int)cnt, (sizeof(char [1024l]) /*1024ul*/  - cnt) - (unsigned long int)32, "%s%d:%d ", i == current ? "*" : "", i, i);
        cnt = cnt + (unsigned long int)return_value_snprintf$3;
        n = n + 1;
      }

  }
  tracks[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
  if(n >= 2)
    do
      if(iSysLogLevel >= 3)
        x_syslog(7, log_module_input_vdr, "%s", (const void *)tracks);

    while((_Bool)0);

  strcpy(tracks + (signed long int)cnt, "\r\n");
  puts_vdr(this, tracks);
  n = 0;
  strcpy(tracks, "INFO TRACKMAP SPU ");
  cnt=strlen(tracks);
  current=_x_get_spu_channel(this->slave.stream);
  if(!(current >= 0))
  {
    signed int return_value_snprintf$5;
    return_value_snprintf$5=snprintf(tracks + (signed long int)cnt, (sizeof(char [1024l]) /*1024ul*/  - cnt) - (unsigned long int)32, "*%d:%s ", current, current == -2 ? "none" : "auto");
    cnt = cnt + (unsigned long int)return_value_snprintf$5;
    n = n + 1;
    if(current == -1)
      current = this->slave.stream->spu_channel_auto;

  }

  i = 0;
  signed int return_value_xine_get_spu_lang$8;
  for( ; !(i >= 32) && !(cnt >= 992ul); i = i + 1)
  {
    return_value_xine_get_spu_lang$8=xine_get_spu_lang(this->slave.stream, i, lang);
    if(!(return_value_xine_get_spu_lang$8 == 0))
    {
      const char *return_value_trim_str$6;
      return_value_trim_str$6=trim_str(lang);
      signed int return_value_snprintf$7;
      return_value_snprintf$7=snprintf(tracks + (signed long int)cnt, (sizeof(char [1024l]) /*1024ul*/  - cnt) - (unsigned long int)32, "%s%d:%s ", i == current ? "*" : "", i, return_value_trim_str$6);
      cnt = cnt + (unsigned long int)return_value_snprintf$7;
      n = n + 1;
    }

  }
  tracks[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
  if(n >= 2)
    do
      if(iSysLogLevel >= 3)
        x_syslog(7, log_module_input_vdr, "%s", (const void *)tracks);

    while((_Bool)0);

  strcpy(tracks + (signed long int)cnt, "\r\n");
  puts_vdr(this, tracks);
}

// snprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 61
static inline signed int snprintf(char * restrict __s, unsigned long int __n, const char * restrict __fmt, ...)
{
  void *return_value___builtin_va_arg_pack$1;
  return_value___builtin_va_arg_pack$1=__builtin_va_arg_pack();
  signed int return_value___builtin___snprintf_chk$2;
  return_value___builtin___snprintf_chk$2=__builtin___snprintf_chk(__s, __n, 2 - 1, 18446744073709551615ul, __fmt, return_value___builtin_va_arg_pack$1);
  return return_value___builtin___snprintf_chk$2;
}

// sprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 31
static inline signed int sprintf(char * restrict __s, const char * restrict __fmt, ...)
{
  void *return_value___builtin_va_arg_pack$1;
  return_value___builtin_va_arg_pack$1=__builtin_va_arg_pack();
  signed int return_value___builtin___sprintf_chk$2;
  return_value___builtin___sprintf_chk$2=__builtin___sprintf_chk(__s, 2 - 1, 18446744073709551615ul, __fmt, return_value___builtin_va_arg_pack$1);
  return return_value___builtin___sprintf_chk$2;
}

// start_buffering
// file xine/xvdr_metronom.c line 192
static void start_buffering(struct xvdr_metronom_s$0 *this, signed long int disc_off)
{
  _Bool tmp_if_expr$3;
  if(!(this->live_buffering == 0))
    tmp_if_expr$3 = this->stream_start != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$3 = (_Bool)0;
  unsigned long int return_value_elapsed$1;
  unsigned long int return_value_elapsed$2;
  if(!(disc_off == 0l) && tmp_if_expr$3)
  {
    if(this->buffering == 0)
    {
      do
        if(iSysLogLevel >= 2)
        {
          return_value_elapsed$1=elapsed$link1(this->buffering_start_time);
          x_syslog(6, "[metronom ] ", "live mode buffering started (@%d ms)", (signed int)return_value_elapsed$1);
        }

      while((_Bool)0);
      this->aud_pts = (signed long int)0;
      this->vid_pts = (signed long int)0;
      this->disc_pts = disc_off;
      this->first_frame_seen_time = (unsigned long int)0;
      this->buffering = (unsigned char)1;
      this->scr->set_buffering(this->scr, 1);
    }

  }

  else
    if(!(this->buffering == 0))
    {
      do
        if(iSysLogLevel >= 2)
        {
          return_value_elapsed$2=elapsed$link1(this->buffering_start_time);
          x_syslog(6, "[metronom ] ", "live mode buffering aborted (@%d ms)", (signed int)return_value_elapsed$2);
        }

      while((_Bool)0);
      this->buffering = (unsigned char)0;
      this->scr->set_buffering(this->scr, 0);
    }

}

// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 452
static inline signed int stat(const char *__path, struct stat *__statbuf)
{
  signed int return_value___xstat$1;
  return_value___xstat$1=__xstat(1, __path, __statbuf);
  return return_value___xstat$1;
}

// strcat
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 146
static inline char * strcat(char * restrict __dest, const char * restrict __src)
{
  char *return_value___builtin___strcat_chk$1;
  return_value___builtin___strcat_chk$1=__builtin___strcat_chk(__dest, __src, 18446744073709551615ul);
  return return_value___builtin___strcat_chk$1;
}

// strcpy
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 108
static inline char * strcpy(char * restrict __dest, const char * restrict __src)
{
  char *return_value___builtin___strcpy_chk$1;
  return_value___builtin___strcpy_chk$1=__builtin___strcpy_chk(__dest, __src, 18446744073709551615ul);
  return return_value___builtin___strcpy_chk$1;
}

// strip_network_headers
// file xine_input_vdr.c line 1477
static void strip_network_headers(struct vdr_input_plugin_s *this, struct buf_element_s *buf)
{
  signed int return_value_pthread_mutex_trylock$1;
  return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&this->lock);
  _Bool tmp_if_expr$2;
  if(return_value_pthread_mutex_trylock$1 == 0)
  {
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_vdr, "%s: assertion failed: lock %s unlocked !", (const void *)"strip_network_headers", (const void *)"this->lock");

    while((_Bool)0);
    pthread_mutex_unlock(&this->lock);
  }

  else
  {
    if(buf->type == 84017152u)
    {
      struct anonymous$41 *header = (struct anonymous$41 *)buf->content;
      this->curpos = header->pos;
      buf->content = buf->content + (signed long int)sizeof(struct anonymous$41) /*8ul*/ ;
      buf->size = buf->size - (signed int)sizeof(struct anonymous$41) /*8ul*/ ;
      buf->type = (unsigned int)0x05000000;
      goto __CPROVER_DUMP_L10;
    }

    if(buf->type == 83951616u)
    {
      if(!(this->udp == 0))
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = this->rtp != 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
      {
        struct anonymous$7 *strip_network_headers$$1$$3$$1$$header = (struct anonymous$7 *)buf->content;
        this->curpos = strip_network_headers$$1$$3$$1$$header->pos;
        buf->content = buf->content + (signed long int)sizeof(struct anonymous$7) /*11ul*/ ;
        buf->size = buf->size - (signed int)sizeof(struct anonymous$7) /*11ul*/ ;
      }

      else
      {
        struct anonymous$56 *strip_network_headers$$1$$3$$2$$header = (struct anonymous$56 *)buf->content;
        this->curpos = strip_network_headers$$1$$3$$2$$header->pos;
        buf->content = buf->content + (signed long int)sizeof(struct anonymous$56) /*13ul*/ ;
        buf->size = buf->size - (signed int)sizeof(struct anonymous$56) /*13ul*/ ;
      }
      buf->type = (unsigned int)0x05000000;
    }

  }

__CPROVER_DUMP_L10:
  ;
}

// strn0cpy
// file xine_input_vdr.c line 842
static char * strn0cpy(char *dest, const char *src, signed int n)
{
  char *s = dest;
  _Bool tmp_if_expr$1;
  do
  {
    n = n - 1;
    if(!(n == 0))
    {
      *dest = *src;
      tmp_if_expr$1 = (signed int)*dest != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    dest = dest + 1l;
    src = src + 1l;
  }
  while((_Bool)1);
  *dest = (char)0;
  return s;
}

// suspend_demuxer
// file xine_input_vdr.c line 1998
static void suspend_demuxer(struct vdr_input_plugin_s *this)
{
  if(!(this->is_paused == 0))
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_vdr, "WARNING: called suspend_demuxer in paused mode !");

    while((_Bool)0);

  _x_action_raise(this->stream);
  pthread_cond_broadcast(&this->engine_flushed);
  signal_buffer_not_empty(this);
  signed int return_value_pthread_mutex_unlock$4;
  return_value_pthread_mutex_unlock$4=pthread_mutex_unlock(&this->lock);
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  if(!(return_value_pthread_mutex_unlock$4 == 0))
    do
      if(iSysLogLevel >= 1)
      {
        x_syslog(3, log_module_input_vdr, "pthread_mutex_unlock failed !");
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        if(!(*return_value___errno_location$3 == 0))
        {
          return_value___errno_location$1=__errno_location();
          return_value_strerror$2=strerror(*return_value___errno_location$1);
          x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 2012, return_value_strerror$2);
        }

      }

    while((_Bool)0);

  pthread_mutex_lock(&this->stream->demux_lock);
  _x_action_lower(this->stream);
  pthread_mutex_lock(&this->lock);
}

// syslog
// file /usr/include/x86_64-linux-gnu/bits/syslog.h line 29
static inline void syslog(signed int __pri, const char *__fmt, ...)
{
  void *return_value___builtin_va_arg_pack$1;
  return_value___builtin_va_arg_pack$1=__builtin_va_arg_pack();
  __syslog_chk(__pri, 2 - 1, __fmt, return_value___builtin_va_arg_pack$1);
}

// time_ms
// file xine/../tools/time_ms.h line 16
static unsigned long int time_ms(void)
{
  struct timeval t;
  signed int return_value_xine_monotonic_clock$1;
  return_value_xine_monotonic_clock$1=xine_monotonic_clock(&t, (struct timezone *)(void *)0);
  if(return_value_xine_monotonic_clock$1 == 0)
    return (unsigned long int)t.tv_sec * 1000ULL + (unsigned long int)t.tv_usec / 1000ULL;

  else
    return (unsigned long int)0;
}

// time_ms$link1
// file xine/../tools/time_ms.h line 16
static unsigned long int time_ms$link1(void)
{
  struct timeval t$link1;
  signed int return_value_xine_monotonic_clock$1$link1;
  return_value_xine_monotonic_clock$1$link1=xine_monotonic_clock(&t$link1, (struct timezone *)(void *)0);
  if(return_value_xine_monotonic_clock$1$link1 == 0)
    return (unsigned long int)t$link1.tv_sec * 1000ULL + (unsigned long int)t$link1.tv_usec / 1000ULL;

  else
    return (unsigned long int)0;
}

// track_audio_stream_change
// file xine/demux_xvdr.c line 375
static void track_audio_stream_change(struct demux_xvdr_s *this, struct buf_element_s *buf)
{
  if(!(this->audio_type == buf->type))
  {
    do
      if(iSysLogLevel >= 3)
        x_syslog(7, log_module_demux_xvdr, "audio stream changed: %08x -> %08x", this->audio_type, buf->type);

    while((_Bool)0);
    ts_data_reset_audio(this->ts_data, this->audio_fifo, (signed int)(buf->type & (unsigned int)0xff));
    put_control_buf$link1(this->audio_fifo, this->audio_fifo, 0x010b0000);
    if(!(this->audio_type == 0u))
    {
      struct buf_element_s *b;
      b=this->audio_fifo->buffer_pool_try_alloc(this->audio_fifo);
      if(!(b == ((struct buf_element_s *)NULL)))
      {
        b->type = (unsigned int)0x01000000;
        b->decoder_flags = (unsigned int)0x1000;
        this->audio_fifo->put(this->audio_fifo, b);
      }

    }

    this->audio_type = buf->type;
  }

}

// trim_str
// file xine_input_vdr.c line 3679
static const char * trim_str(const char *s)
{
  for( ; (_Bool)1; s = s + 1l)
    if(!((signed int)*s == 32))
    {
      if(!((signed int)*s == 13))
      {
        if(!((signed int)*s == 10))
          goto __CPROVER_DUMP_L3;

      }

    }


__CPROVER_DUMP_L3:
  ;
  return s;
}

// ts2es_dispose
// file xine/ts2es.c line 276
void ts2es_dispose(struct ts2es_s *data)
{
  if(!(data == ((struct ts2es_s *)NULL)))
  {
    if(!(data->buf == ((struct buf_element_s *)NULL)))
      data->buf->free_buffer(data->buf);

    free((void *)data);
  }

}

// ts2es_flush
// file xine/ts2es.c line 262
void ts2es_flush(struct ts2es_s *this)
{
  if(!(this->buf == ((struct buf_element_s *)NULL)))
  {
    this->buf->decoder_flags = this->buf->decoder_flags | (unsigned int)0x0004;
    this->buf->pts = (signed long int)0;
    this->fifo->put(this->fifo, this->buf);
    this->buf = (struct buf_element_s *)(void *)0;
  }

}

// ts2es_init
// file xine/ts2es.c line 285
struct ts2es_s * ts2es_init(struct fifo_buffer_s *dst_fifo, enum anonymous$11 stream_type, unsigned int stream_index)
{
  struct ts2es_s *data;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct ts2es_s) /*32ul*/ );
  data = (struct ts2es_s *)return_value_calloc$1;
  data->fifo = dst_fifo;
  data->stream_type = (unsigned int)stream_type;
  switch((signed int)stream_type)
  {
    case ISO_11172_VIDEO:

    case ISO_13818_VIDEO:

    case STREAM_VIDEO_MPEG:
    {
      data->xine_buf_type = (unsigned int)0x02000000;
      break;
    }
    case ISO_14496_PART2_VIDEO:
    {
      data->xine_buf_type = (unsigned int)0x02010000;
      break;
    }
    case ISO_14496_PART10_VIDEO:
    {
      data->xine_buf_type = (unsigned int)0x024D0000;
      break;
    }
    case STREAM_VIDEO_VC1:
    {
      data->xine_buf_type = (unsigned int)0x02650000;
      break;
    }
    case ISO_11172_AUDIO:

    case ISO_13818_AUDIO:
    {
      data->xine_buf_type = (unsigned int)0x03010000;
      break;
    }
    case ISO_14496_PART3_AUDIO:
    {
      data->xine_buf_type = (unsigned int)0x03420000;
      break;
    }
    case ISO_13818_PART7_AUDIO:
    {
      data->xine_buf_type = (unsigned int)0x030e0000;
      break;
    }
    case ISO_13818_PES_PRIVATE:
    {
      data->xine_buf_type = (unsigned int)0;
      break;
    }
    case STREAM_DVBSUB:
    {
      data->xine_buf_type = (unsigned int)0x04030000;
      break;
    }
    case STREAM_AUDIO_AC3:

    case HDMV_AUDIO_83_TRUEHD:
    {
      data->xine_buf_type = (unsigned int)0x03000000;
      break;
    }
    case STREAM_AUDIO_EAC3:

    case HDMV_AUDIO_84_EAC3:
    {
      data->xine_buf_type = (unsigned int)0x03410000;
      break;
    }
    case HDMV_AUDIO_80_PCM:
    {
      data->xine_buf_type = (unsigned int)0x03020000;
      break;
    }
    case STREAM_AUDIO_DTS:

    case HDMV_AUDIO_82_DTS:

    case HDMV_AUDIO_85_DTS_HRA:

    case HDMV_AUDIO_86_DTS_HD_MA:
    {
      data->xine_buf_type = (unsigned int)0x03050000;
      break;
    }
    case STREAM_AUDIO_AAC:
    {
      data->xine_buf_type = (unsigned int)0x030e0000;
      break;
    }
    default:
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, "[demux_vdr] ", "ts2es: unknown stream type 0x%x", stream_type);

      while((_Bool)0);
  }
  data->xine_buf_type = data->xine_buf_type | stream_index;
  if((0xFF000000 & data->xine_buf_type) == 33554432u)
    data->video = (unsigned char)1;

  return data;
}

// ts2es_parse_pes
// file xine/ts2es.c line 38
static void ts2es_parse_pes(struct ts2es_s *this)
{
  _Bool tmp_if_expr$1;
  if(*this->buf->content == 0)
    tmp_if_expr$1 = !(this->buf->content[(signed long int)1] != 0) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$1 = (_Bool)0;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = (signed int)this->buf->content[(signed long int)2] == 1 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr$2 = (_Bool)0;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(!tmp_if_expr$2)
  {
    do
      if(iSysLogLevel >= 3)
        x_syslog(7, "[demux_vdr] ", "ts2es: payload not PES ?");

    while((_Bool)0);
    this->pes_error = (unsigned char)1;
  }

  else
  {
    this->pes_error = (unsigned char)0;
    unsigned int hdr_len = (unsigned int)(8 + (signed int)this->buf->content[(signed long int)8] + 1);
    unsigned char pes_pid = this->buf->content[(signed long int)3];
    if(!(this->buf->size >= 9))
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (unsigned int)this->buf->size < hdr_len ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, "[demux_vdr] ", "ts2es: PES header not in first TS fragment");

      while((_Bool)0);
      this->pes_error = (unsigned char)1;
    }

    else
    {
      this->pes_len = (signed int)this->buf->content[(signed long int)4] << 8 | (signed int)this->buf->content[(signed long int)5];
      if(!(6u + hdr_len >= (unsigned int)this->pes_len))
        this->pes_len = this->pes_len + 6;

      else
        this->pes_len = 0;
      this->buf->pts=pes_get_pts(this->buf->content, this->buf->size);
      if(!(this->buf->pts >= 0l))
        this->buf->pts = (signed long int)0;

      if(!(this->video == 0))
      {
        if(this->buf->pts >= 1l)
        {
          signed long int dts;
          dts=pes_get_dts(this->buf->content, this->buf->size);
          if(dts >= 1l)
            this->buf->decoder_info[(signed long int)0] = (unsigned int)(this->buf->pts - dts);

        }

      }

      this->buf->content = this->buf->content + (signed long int)hdr_len;
      this->buf->size = this->buf->size - (signed int)hdr_len;
      if(this->stream_type == 65408u)
      {
        this->buf->decoder_flags = this->buf->decoder_flags | (unsigned int)0x0200;
        this->buf->decoder_info[(signed long int)1] = (unsigned int)6;
        this->buf->decoder_info[(signed long int)2] = (unsigned int)((signed int)this->buf->content[(signed long int)3] << 24 | (signed int)this->buf->content[(signed long int)2] << 16 | (signed int)this->buf->content[(signed long int)1] << 8 | (signed int)this->buf->content[(signed long int)0]);
        this->buf->content = this->buf->content + (signed long int)4;
        this->buf->size = this->buf->size - 4;
      }

      else
        if((signed int)pes_pid == 0xBD)
        {
          if(this->stream_type == 129u || this->stream_type == 31238u || this->stream_type == 31494u || this->stream_type == 31750u)
            goto __CPROVER_DUMP_L37;

          if((signed int)*this->buf->content == 0x0B)
          {
            if(!((signed int)this->buf->content[1l] == 0x77))
              goto __CPROVER_DUMP_L22;

            this->xine_buf_type = this->xine_buf_type | (unsigned int)0x03000000;
            this->buf->type = this->xine_buf_type;
          }

          else
          {

          __CPROVER_DUMP_L22:
            ;
            if(this->stream_type == 6u)
            {
              if((0xf0 & (signed int)*this->buf->content) == 0x80)
              {
                this->buf->content = this->buf->content + (signed long int)4;
                this->buf->size = this->buf->size - 4;
                this->xine_buf_type = this->xine_buf_type | (unsigned int)0x03000000;
                this->buf->type = this->xine_buf_type;
                goto __CPROVER_DUMP_L37;
              }

              if((0xf0 & (signed int)*this->buf->content) == 0xa0)
              {
                signed int pcm_offset = 0;
                do
                {
                  pcm_offset = pcm_offset + 1;
                  if(pcm_offset >= this->buf->size + -1)
                    break;

                  if((signed int)this->buf->content[(signed long int)pcm_offset] == 0x01)
                  {
                    if((signed int)this->buf->content[(signed long int)(1 + pcm_offset)] == 0x80)
                    {
                      pcm_offset = pcm_offset + 2;
                      break;
                    }

                  }

                }
                while((_Bool)1);
                this->buf->content = this->buf->content + (signed long int)pcm_offset;
                this->buf->size = this->buf->size - pcm_offset;
                this->xine_buf_type = this->xine_buf_type | (unsigned int)0x03020000;
                this->buf->type = this->xine_buf_type;
                goto __CPROVER_DUMP_L37;
              }

              do
                if(iSysLogLevel >= 2)
                  x_syslog(6, "[demux_vdr] ", "ts2es: unhandled PS1 substream 0x%x", this->buf->content[(signed long int)0]);

              while((_Bool)0);
            }

            else
              if(this->stream_type == 22790u)
              {
                if(!((signed int)*this->buf->content == 0x20))
                  tmp_if_expr$4 = (_Bool)1;

                else
                  tmp_if_expr$4 = (signed int)this->buf->content[(signed long int)1] != 0x00 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr$4)
                  do
                    if(iSysLogLevel >= 2)
                      x_syslog(6, "[demux_vdr] ", "ts2es: DVB SPU, invalid PES substream header");

                  while((_Bool)0);

                if(!(hdr_len >= (unsigned int)this->pes_len))
                  this->buf->decoder_info[(signed long int)2] = (unsigned int)this->pes_len - hdr_len;

              }

          }
        }

    }
  }

__CPROVER_DUMP_L37:
  ;
}

// ts2es_put
// file xine/ts2es.h line 17
struct buf_element_s * ts2es_put(struct ts2es_s *this, unsigned char *data, struct fifo_buffer_s *src_fifo)
{
  struct buf_element_s *result = (struct buf_element_s *)(void *)0;
  signed int bytes;
  signed int tmp_if_expr$1;
  if(!((0x20 & (signed int)data[3l]) == 0))
    tmp_if_expr$1 = (signed int)data[(signed long int)4] + 5;

  else
    tmp_if_expr$1 = 4;
  bytes = 188 - tmp_if_expr$1;
  signed int pusi = (signed int)data[(signed long int)1] & 0x40;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$4;
  if(!((0x80 & (signed int)data[1l]) == 0))
  {
    do
      if(iSysLogLevel >= 3)
        x_syslog(7, "[demux_vdr] ", "ts2es: transport error");

    while((_Bool)0);
    return (struct buf_element_s *)(void *)0;
  }

  else
    if((0x10 & (signed int)data[3l]) == 0)
    {
      do
        if(iSysLogLevel >= 4)
          x_syslog(7, "[demux_vdr] ", "ts2es: no payload, size %d", bytes);

      while((_Bool)0);
      return (struct buf_element_s *)(void *)0;
    }

    else
      if(!(this->pes_error == 0))
      {
        if(!(pusi == 0))
          goto __CPROVER_DUMP_L12;

        if(!(this->buf == ((struct buf_element_s *)NULL)))
        {
          do
            if(iSysLogLevel >= 3)
              x_syslog(7, "[demux_vdr] ", "ts2es: dropping broken PES packet");

          while((_Bool)0);
          this->buf->free_buffer(this->buf);
          this->buf = (struct buf_element_s *)(void *)0;
        }

        return (struct buf_element_s *)(void *)0;
      }

      else
      {

      __CPROVER_DUMP_L12:
        ;
        if(!(pusi == 0))
        {
          if(!(this->first_pusi_seen == 0))
          {
            if(this->buf == ((struct buf_element_s *)NULL))
            {
              this->buf=this->fifo->buffer_pool_alloc(this->fifo);
              this->buf->type = this->xine_buf_type;
            }

          }

          if(!(this->buf == ((struct buf_element_s *)NULL)))
          {
            this->buf->decoder_flags = this->buf->decoder_flags | (unsigned int)0x0004;
            result = this->buf;
            this->buf = (struct buf_element_s *)(void *)0;
          }

          this->first_pusi_seen = (unsigned char)1;
        }

        if(!(this->buf == ((struct buf_element_s *)NULL)))
        {
          if(!(this->video == 0))
            tmp_if_expr$2 = this->buf->size >= 2048 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$2 = (_Bool)0;
          if(tmp_if_expr$2)
            tmp_if_expr$3 = (_Bool)1;

          else
            tmp_if_expr$3 = this->buf->size >= this->buf->max_size - 2 * 188 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr$3)
          {
            result = this->buf;
            this->buf = (struct buf_element_s *)(void *)0;
          }

        }

        if(this->buf == ((struct buf_element_s *)NULL))
        {
          if(this->first_pusi_seen == 0)
            return (struct buf_element_s *)(void *)0;

          if(!(src_fifo == ((struct fifo_buffer_s *)NULL)))
            tmp_if_expr$4 = src_fifo != this->fifo ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$4 = (_Bool)0;
          if(tmp_if_expr$4)
          {
            if(this->video == 0)
              this->buf=this->fifo->buffer_pool_try_alloc(this->fifo);

            if(this->buf == ((struct buf_element_s *)NULL))
              this->buf=src_fifo->buffer_pool_try_alloc(src_fifo);

            if(this->buf == ((struct buf_element_s *)NULL))
              this->buf=this->fifo->buffer_pool_alloc(this->fifo);

          }

          else
            this->buf=this->fifo->buffer_pool_alloc(this->fifo);
          this->buf->type = this->xine_buf_type;
        }

        data = data + (signed long int)(188 - bytes);
        memcpy$link2((void *)(this->buf->content + (signed long int)this->buf->size), (const void *)data, (unsigned long int)bytes);
        this->buf->size = this->buf->size + bytes;
        if(!(pusi == 0))
          ts2es_parse_pes(this);

        if(this->pes_len >= 1)
        {
          if(bytes >= this->pes_len)
          {
            this->buf->decoder_flags = this->buf->decoder_flags | (unsigned int)0x0004;
            result = this->buf;
            this->buf = (struct buf_element_s *)(void *)0;
            this->pes_error = (unsigned char)1;
          }

          else
            this->pes_len = this->pes_len - bytes;
        }

        return result;
      }
}

// ts_add_payload
// file tools/ts.c line 672
static unsigned long int ts_add_payload(struct ts_state_s *ts, const unsigned char *data)
{
  if(ts->pusi_seen == 0)
  {
    if((0x40 & (signed int)data[1l]) == 0)
      return (unsigned long int)0;

    ts->pusi_seen = (unsigned char)1;
    ts->buf_len = (unsigned long int)0;
  }

  if(ts->buf_len >= ts->buf_size + 18446744073709551428ul)
  {
    do
      if(iSysLogLevel >= 3)
        x_syslog(7, "[mpeg-ts  ] ", "ts_add_payload: buffer full");

    while((_Bool)0);
    ts->buf_len = ts->buf_len - (unsigned long int)188;
    memmove((void *)ts->buf, (const void *)(ts->buf + (signed long int)188), ts->buf_len);
  }

  signed long int len;
  signed int tmp_if_expr$1;
  if(!((0x20 & (signed int)data[3l]) == 0))
    tmp_if_expr$1 = (signed int)data[(signed long int)4] + 5;

  else
    tmp_if_expr$1 = 4;
  len = (signed long int)(188 - tmp_if_expr$1);
  signed int tmp_if_expr$2;
  if(len >= 1l)
  {
    if(!((0x20 & (signed int)data[3l]) == 0))
      tmp_if_expr$2 = (signed int)data[(signed long int)4] + 5;

    else
      tmp_if_expr$2 = 4;
    memcpy$link4((void *)(ts->buf + (signed long int)ts->buf_len), (const void *)(data + (signed long int)tmp_if_expr$2), (unsigned long int)len);
    ts->buf_len = ts->buf_len + (unsigned long int)len;
  }

  return ts->buf_len;
}

// ts_compute_crc32
// file tools/ts.c line 49
static unsigned int ts_compute_crc32(const unsigned char *data, unsigned int length, unsigned int crc32)
{
  static unsigned int crc32_table[256l];
  static unsigned int init_done = (unsigned int)0;
  if(init_done == 0u)
  {
    unsigned int ts_compute_crc32$$1$$1$$i;
    unsigned int j;
    unsigned int k;
    init_done = (unsigned int)1;
    ts_compute_crc32$$1$$1$$i = (unsigned int)0;
    for( ; !(ts_compute_crc32$$1$$1$$i >= 256u); ts_compute_crc32$$1$$1$$i = ts_compute_crc32$$1$$1$$i + 1u)
    {
      k = (unsigned int)0;
      j = ts_compute_crc32$$1$$1$$i << 24 | (unsigned int)0x800000;
      for( ; !(j == 0x80000000); j = j << 1)
        k = k << 1 ^ (unsigned int)(((k ^ j) & 0x80000000) != 0u ? 0x04c11db7 : 0);
      crc32_table[(signed long int)ts_compute_crc32$$1$$1$$i] = k;
    }
  }

  unsigned int i = (unsigned int)0;
  for( ; !(i >= length); i = i + 1u)
    crc32 = crc32 << 8 ^ crc32_table[(signed long int)(crc32 >> 24 ^ (unsigned int)data[(signed long int)i])];
  return crc32;
}

// ts_data_dispose
// file xine/demux_xvdr_tsdata.h line 31
void ts_data_dispose(struct ts_data_s **ts_data)
{
  if(!(*ts_data == ((struct ts_data_s *)NULL)))
  {
    ts_data_ts2es_reset(*ts_data);
    free((void *)*ts_data);
    *ts_data = (struct ts_data_s *)(void *)0;
  }

}

// ts_data_flush
// file xine/demux_xvdr_tsdata.h line 30
void ts_data_flush(struct ts_data_s *ts_data)
{
  if(!(ts_data == ((struct ts_data_s *)NULL)))
  {
    signed int i;
    if(!(ts_data->video == ((struct ts2es_s *)NULL)))
      ts2es_flush(ts_data->video);

    i = 0;
    for( ; !(ts_data->audio[(signed long int)i] == ((struct ts2es_s *)NULL)); i = i + 1)
      ts2es_flush(ts_data->audio[(signed long int)i]);
    i = 0;
    for( ; !(ts_data->spu[(signed long int)i] == ((struct ts2es_s *)NULL)); i = i + 1)
      ts2es_flush(ts_data->spu[(signed long int)i]);
  }

}

// ts_data_reset_audio
// file xine/demux_xvdr_tsdata.h line 33
void ts_data_reset_audio(struct ts_data_s *ts_data, struct fifo_buffer_s *audio_fifo, signed int keep_channel)
{
  if(!(ts_data == ((struct ts_data_s *)NULL)))
  {
    signed int i = 0;
    for( ; !(ts_data->audio[(signed long int)i] == ((struct ts2es_s *)NULL)); i = i + 1)
      if(!(i == keep_channel))
      {
        ts2es_dispose(ts_data->audio[(signed long int)i]);
        ts_data->audio[(signed long int)i] = (struct ts2es_s *)(void *)0;
      }

    if(!(audio_fifo == ((struct fifo_buffer_s *)NULL)))
    {
      i = 0;
      for( ; !(i >= (signed int)ts_data->pmt.audio_tracks_count); i = i + 1)
        if(ts_data->audio[(signed long int)i] == ((struct ts2es_s *)NULL))
          ts_data->audio[(signed long int)i]=ts2es_init(audio_fifo, ts_data->pmt.audio_tracks[(signed long int)i].type, (unsigned int)i);

    }

  }

}

// ts_data_ts2es_init
// file xine/demux_xvdr_tsdata.h line 29
void ts_data_ts2es_init(struct ts_data_s **ts_data, struct fifo_buffer_s *video_fifo, struct fifo_buffer_s *audio_fifo)
{
  void *return_value_calloc$1;
  if(!(*ts_data == ((struct ts_data_s *)NULL)))
    ts_data_ts2es_reset(*ts_data);

  else
  {
    return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct ts_data_s) /*1272ul*/ );
    *ts_data = (struct ts_data_s *)return_value_calloc$1;
  }
  struct ts_data_s *this = *ts_data;
  signed int i;
  if(!(video_fifo == ((struct fifo_buffer_s *)NULL)))
  {
    if(!((signed int)this->pmt.video_pid == 0xffff))
      this->video=ts2es_init(video_fifo, this->pmt.video_type, (unsigned int)0);

    i = 0;
    for( ; !(i >= (signed int)this->pmt.spu_tracks_count); i = i + 1)
      this->spu[(signed long int)i]=ts2es_init(video_fifo, (enum anonymous$11)STREAM_DVBSUB, (unsigned int)i);
  }

  if(!(audio_fifo == ((struct fifo_buffer_s *)NULL)))
  {
    i = 0;
    for( ; !(i >= (signed int)this->pmt.audio_tracks_count); i = i + 1)
      this->audio[(signed long int)i]=ts2es_init(audio_fifo, this->pmt.audio_tracks[(signed long int)i].type, (unsigned int)i);
  }

}

// ts_data_ts2es_reset
// file xine/demux_xvdr_tsdata.c line 24
static void ts_data_ts2es_reset(struct ts_data_s *ts_data)
{
  signed int i;
  ts2es_dispose(ts_data->video);
  ts_data->video = (struct ts2es_s *)(void *)0;
  i = 0;
  for( ; !(ts_data->audio[(signed long int)i] == ((struct ts2es_s *)NULL)); i = i + 1)
  {
    ts2es_dispose(ts_data->audio[(signed long int)i]);
    ts_data->audio[(signed long int)i] = (struct ts2es_s *)(void *)0;
  }
  i = 0;
  for( ; !(ts_data->spu[(signed long int)i] == ((struct ts2es_s *)NULL)); i = i + 1)
  {
    ts2es_dispose(ts_data->spu[(signed long int)i]);
    ts_data->spu[(signed long int)i] = (struct ts2es_s *)(void *)0;
  }
}

// ts_get_pcr
// file tools/ts.c line 599
signed long int ts_get_pcr(const unsigned char *pkt)
{
  signed long int pcr = -1L;
  ts_get_pcr_1(pkt, &pcr);
  return pcr;
}

// ts_get_pcr_1
// file tools/ts.c line 568
static signed int ts_get_pcr_1(const unsigned char *pkt, signed long int *ppcr)
{
  if((0x20 & (signed int)pkt[3l]) == 0)
    return 0;

  else
    if(!((0x80 & (signed int)pkt[1l]) == 0))
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, "[mpeg-ts  ] ", "ts_get_pcr: transport error");

      while((_Bool)0);
      return 0;
    }

    else
      if((0x10 & (signed int)pkt[5l]) == 0)
        return 0;

      else
      {
        signed long int pcr = (signed long int)pkt[(signed long int)6] << 25;
        pcr = pcr + (signed long int)((signed int)pkt[(signed long int)7] << 17);
        pcr = pcr + (signed long int)((signed int)pkt[(signed long int)8] << 9);
        pcr = pcr + (signed long int)((signed int)pkt[(signed long int)9] << 1);
        pcr = pcr + (signed long int)(((signed int)pkt[(signed long int)10] & 0x80) >> 7);
        *ppcr = pcr;
        return 1;
      }
}

// ts_get_pcr_n
// file tools/ts.h line 187
signed int ts_get_pcr_n(const unsigned char *pkt, signed int npkt, signed long int *pcr)
{
  pkt = pkt + (signed long int)(188 * npkt);
  while(npkt >= 1)
  {
    npkt = npkt - 1;
    pkt = pkt - (signed long int)188;
    signed int return_value_ts_get_pcr_1$1;
    return_value_ts_get_pcr_1$1=ts_get_pcr_1(pkt, pcr);
    if(!(return_value_ts_get_pcr_1$1 == 0))
      return 1;

  }
  return 0;
}

// ts_get_pes
// file tools/ts.c line 745
static signed int ts_get_pes(struct ts_state_s *ts, const unsigned char *data)
{
  unsigned long int return_value_ts_add_payload$2;
  return_value_ts_add_payload$2=ts_add_payload(ts, data);
  unsigned long int return_value_ts_scan_startcode$1;
  if(return_value_ts_add_payload$2 >= 1ul)
  {
    return_value_ts_scan_startcode$1=ts_scan_startcode(ts);
    return (signed int)return_value_ts_scan_startcode$1;
  }

  else
    return 0;
}

// ts_get_picture_type
// file tools/ts.c line 775
signed int ts_get_picture_type(struct ts_state_s *ts, const unsigned char *data, signed int h264)
{
  signed int pic = 0;
  return pic;
}

// ts_get_pts
// file tools/ts.c line 756
signed long int ts_get_pts(struct ts_state_s *ts, const unsigned char *data)
{
  signed long int pts = -1L;
  unsigned long int cnt;
  signed int return_value_ts_get_pes$1;
  return_value_ts_get_pes$1=ts_get_pes(ts, data);
  cnt = (unsigned long int)return_value_ts_get_pes$1;
  if(cnt >= 15ul)
  {
    pts=pes_get_pts(ts->buf, (signed int)ts->buf_len);
    if(cnt >= 377ul && !(pts >= 0l))
      ts_state_reset(ts);

  }

  return pts;
}

// ts_get_reg_desc
// file tools/ts.c line 196
static void ts_get_reg_desc(unsigned int *dest, const unsigned char *data, signed int length)
{
  const unsigned char *d = data;
  for( ; !(d >= data + (signed long int)length); d = d + (signed long int)(2 + (signed int)d[(signed long int)1]))
    if((signed int)*d == 5)
    {
      if((signed int)d[1l] >= 4)
      {
        *dest = (unsigned int)((signed int)d[(signed long int)2] << 24 | (signed int)d[(signed long int)3] << 16 | (signed int)d[(signed long int)4] << 8 | (signed int)d[(signed long int)5]);

      __CPROVER_DUMP_L2:
        ;
        goto __CPROVER_DUMP_L5;
      }

    }


__CPROVER_DUMP_L4:
  ;
  *dest = (unsigned int)0;

__CPROVER_DUMP_L5:
  ;
}

// ts_get_video_size
// file tools/ts.c line 788
signed int ts_get_video_size(struct ts_state_s *ts, const unsigned char *data, struct video_size_s *size, signed int h264)
{
  signed int return_value_ts_get_pes$1;
  return_value_ts_get_pes$1=ts_get_pes(ts, data);
  if(!(return_value_ts_get_pes$1 >= 9))
    return 0;

  else
  {
    if(ts->inside_pes == 0)
    {
      ts_skip_payload(ts, (unsigned long int)(8 + (signed int)ts->buf[(signed long int)8] + 1));
      ts->inside_pes = (unsigned char)1;
      ts_scan_startcode(ts);
    }

    while(ts->buf_len >= 10ul)
    {
      unsigned char *buf = ts->buf;
      if(!(h264 == 1))
      {
        if(*((const unsigned int *)buf) == 0xb3010000U)
        {
          signed int return_value_mpeg2_get_video_size$2;
          return_value_mpeg2_get_video_size$2=mpeg2_get_video_size(ts->buf, (signed int)ts->buf_len, size);
          if(!(return_value_mpeg2_get_video_size$2 == 0))
          {
            ts_state_reset(ts);
            return 1;
          }

          if(!(ts->buf_len >= ts->buf_size + 18446744073709551428ul))
            return 0;

        }

      }

      if(!(h264 == 0))
      {
        if(*((const unsigned int *)buf) == 0x09010000U)
        {
          signed int return_value_h264_get_video_size$3;
          return_value_h264_get_video_size$3=h264_get_video_size(ts->buf, (signed int)ts->buf_len, size);
          if(!(return_value_h264_get_video_size$3 == 0))
          {
            ts_state_reset(ts);
            return 1;
          }

          if(!(ts->buf_len >= ts->buf_size + 18446744073709551428ul))
            return 0;

        }

      }

      ts_skip_payload(ts, (unsigned long int)4);
      ts_scan_startcode(ts);
    }
    return 0;
  }
}

// ts_parse_pat
// file xine/../tools/ts.h line 136
signed int ts_parse_pat(struct anonymous$8 *pat, const unsigned char *pkt)
{
  const unsigned char *original_pkt = pkt;
  unsigned int pat_changed = (unsigned int)0;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  if((0x40 & (signed int)pkt[1l]) == 0)
  {
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, "[mpeg-ts  ] ", "parse_pat: PAT without payload unit start indicator");

    while((_Bool)0);
    return 0;
  }

  else
  {
    pkt = pkt + (signed long int)pkt[(signed long int)4];
    if(pkt - original_pkt >= 189l)
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, "[mpeg-ts  ] ", "parse_pat: PAT with invalid pointer");

      while((_Bool)0);
      return 0;
    }

    else
    {
      unsigned int section_syntax_indicator = (unsigned int)((signed int)pkt[(signed long int)6] >> 7 & 0x01);
      unsigned int section_length = (unsigned int)(((signed int)pkt[(signed long int)6] & 0x03) << 8 | (signed int)pkt[(signed long int)7]);
      unsigned int version_number = (unsigned int)((signed int)pkt[(signed long int)10] >> 1 & 0x1f);
      unsigned int current_next_indicator = (unsigned int)((signed int)pkt[(signed long int)10] & 0x01);
      unsigned int section_number = (unsigned int)pkt[(signed long int)11];
      unsigned int last_section_number = (unsigned int)pkt[(signed long int)12];
      unsigned int crc32;
      unsigned int calc_crc32;
      crc32 = (unsigned int)((signed int)pkt[(signed long int)(section_length + (unsigned int)4)] << 24);
      crc32 = crc32 | (unsigned int)((signed int)pkt[(signed long int)(section_length + (unsigned int)5)] << 16);
      crc32 = crc32 | (unsigned int)((signed int)pkt[(signed long int)(section_length + (unsigned int)6)] << 8);
      crc32 = crc32 | (unsigned int)pkt[(signed long int)(section_length + (unsigned int)7)];
      if(current_next_indicator == 0u || !(section_syntax_indicator == 1u))
      {
        do
          if(iSysLogLevel >= 2)
            x_syslog(6, "[mpeg-ts  ] ", "parse_pat: ssi error");

        while((_Bool)0);
        return 0;
      }

      else
        if(!((signed long int)(188 + -((signed int)section_length)) >= pkt - original_pkt))
        {
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, "[mpeg-ts  ] ", "parse_pat: unsupported PAT does not fit to single TS packet");

          while((_Bool)0);
          return 0;
        }

        else
          if(!(last_section_number == 0u) || !(section_number == 0u))
          {
            do
              if(iSysLogLevel >= 2)
                x_syslog(6, "[mpeg-ts  ] ", "parse_pat: unsoupported PAT consists of multiple (%d) sections", last_section_number);

            while((_Bool)0);
            return 0;
          }

          else
          {
            calc_crc32=ts_compute_crc32(pkt + (signed long int)5, (section_length + (unsigned int)3) - (unsigned int)4, 0xffffffff);
            if(!(crc32 == calc_crc32))
            {
              do
                if(iSysLogLevel >= 2)
                  x_syslog(6, "[mpeg-ts  ] ", "parse_pat: invalid CRC");

              while((_Bool)0);
              return 0;
            }

            else
            {
              if(!(pat->crc32 == crc32))
                tmp_if_expr$1 = (_Bool)1;

              else
                tmp_if_expr$1 = (unsigned int)pat->version != version_number ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr$1)
              {

              __CPROVER_DUMP_L21:
                ;
                pat->crc32 = crc32;
                pat->version = (unsigned char)version_number;
                pat_changed = pat_changed + 1u;
              }

              const unsigned char *program;
              unsigned int program_count = (unsigned int)0;
              program = pkt + (signed long int)13;
              for( ; !(program >= pkt + 4l + (signed long int)section_length); program = program + (signed long int)4)
              {
                unsigned int program_number = (unsigned int)((signed int)program[(signed long int)0] << 8 | (signed int)program[(signed long int)1]);
                unsigned int pmt_pid = (unsigned int)(((signed int)program[(signed long int)2] & 0x1f) << 8 | (signed int)program[(signed long int)3]);
                if(!(program_number == 0u))
                {
                  if(!((unsigned int)pat->program_number[(signed long int)program_count] == program_number))
                    tmp_if_expr$2 = (_Bool)1;

                  else
                    tmp_if_expr$2 = (unsigned int)pat->pmt_pid[(signed long int)program_count] != pmt_pid ? (_Bool)1 : (_Bool)0;
                  if(tmp_if_expr$2)
                  {

                  __CPROVER_DUMP_L27:
                    ;
                    pat->program_number[(signed long int)program_count] = (unsigned short int)program_number;
                    pat->pmt_pid[(signed long int)program_count] = (unsigned short int)pmt_pid;
                    pat_changed = pat_changed + 1u;
                  }


                __CPROVER_DUMP_L28:
                  ;
                  program_count = program_count + 1u;
                }

              }
              pat->program_number[(signed long int)program_count] = (unsigned short int)0;
              pat->pat_changed_flag = (unsigned char)!(!(pat_changed != 0u));
              return (signed int)program_count;
            }
          }
    }
  }
}

// ts_parse_pmt
// file xine/../tools/ts.h line 180
signed int ts_parse_pmt(struct anonymous$10 *pmt, unsigned int program_no, const unsigned char *pkt)
{
  const unsigned char *originalPkt = pkt;
  const unsigned char *ptr = (const unsigned char *)(void *)0;
  unsigned int pusi = (unsigned int)((signed int)pkt[(signed long int)1] & 0x40);
  unsigned int section_syntax_indicator;
  unsigned int section_length = (unsigned int)0;
  unsigned int program_number;
  unsigned int version_number;
  unsigned int current_next_indicator;
  unsigned int section_number;
  unsigned int last_section_number;
  unsigned int program_info_length;
  unsigned int crc32;
  unsigned int calc_crc32;
  unsigned int coded_length;
  unsigned int pid;
  unsigned char *stream;
  unsigned int i;
  signed int count;
  unsigned char len;
  unsigned int offset = (unsigned int)0;
  unsigned int program_info_format_identifier = (unsigned int)0;
  unsigned char hdmv_pmt = (unsigned char)0;
  if(!(pusi == 0u))
  {
    pkt = pkt + (signed long int)pkt[(signed long int)4];
    offset = (unsigned int)1;
    if(!(pmt->pmt == ((unsigned char *)NULL)))
      free((void *)pmt->pmt);

    void *return_value_calloc$1;
    return_value_calloc$1=calloc((unsigned long int)4096, sizeof(unsigned char) /*1ul*/ );
    pmt->pmt = (unsigned char *)return_value_calloc$1;
    pmt->pmt_write_ptr = pmt->pmt;
    section_syntax_indicator = (unsigned int)((signed int)pkt[(signed long int)6] >> 7 & 0x01);
    section_length = (unsigned int)(((signed int)pkt[(signed long int)6] << 8 | (signed int)pkt[(signed long int)7]) & 0x03ff);
    program_number = (unsigned int)((signed int)pkt[(signed long int)8] << 8 | (signed int)pkt[(signed long int)9]);
    version_number = (unsigned int)((signed int)pkt[(signed long int)10] >> 1 & 0x1f);
    current_next_indicator = (unsigned int)((signed int)pkt[(signed long int)10] & 0x01);
    section_number = (unsigned int)pkt[(signed long int)11];
    last_section_number = (unsigned int)pkt[(signed long int)12];

  __CPROVER_DUMP_L2:
    ;

  __CPROVER_DUMP_L3:
    ;

  __CPROVER_DUMP_L4:
    ;

  __CPROVER_DUMP_L5:
    ;

  __CPROVER_DUMP_L6:
    ;

  __CPROVER_DUMP_L7:
    ;

  __CPROVER_DUMP_L8:
    ;
    if(current_next_indicator == 0u || !(section_syntax_indicator == 1u))
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, "[mpeg-ts  ] ", "parse_pmt: ssi error");

      while((_Bool)0);
      return 0;
    }

    if(!(program_number == program_no))
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, "[mpeg-ts  ] ", "parse_pmt: program number %i, looking for %i", program_number, program_no);

      while((_Bool)0);
      return 0;
    }

    if(!(last_section_number == 0u) || !(section_number == 0u))
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, "[mpeg-ts  ] ", "parse_pmt: unsupported PMT (%d sections)", last_section_number);

      while((_Bool)0);
      return 0;
    }

  }

  signed int tmp_if_expr$2;
  signed int return_value_find_audio_track$4;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$9;
  if(pmt->pmt == ((unsigned char *)NULL))
  {
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, "[mpeg-ts  ] ", "parse_pmt: dropping PMT packet without PUSI");

    while((_Bool)0);
    return 0;
  }

  else
  {
    if(pusi == 0u)
    {
      section_length = (unsigned int)(((signed int)pmt->pmt[(signed long int)1] << 8 | (signed int)pmt->pmt[(signed long int)2]) & 0x03ff);
      version_number = (unsigned int)((signed int)pkt[(signed long int)10] >> 1 & 0x1f);
    }

    if(!((0x20 & (signed int)originalPkt[3l]) == 0))
      tmp_if_expr$2 = (signed int)originalPkt[(signed long int)4] + 5;

    else
      tmp_if_expr$2 = 4;
    count = 188 - tmp_if_expr$2;
    ptr = originalPkt + (signed long int)offset + (signed long int)(188 - count);
    len = (unsigned char)((unsigned int)count - offset);
    memcpy$link4((void *)pmt->pmt_write_ptr, (const void *)ptr, (unsigned long int)len);
    pmt->pmt_write_ptr = pmt->pmt_write_ptr + (signed long int)len;
    if(!(pmt->pmt_write_ptr >= pmt->pmt + (signed long int)section_length))
    {

    __CPROVER_DUMP_L25:
      ;
      return 0;
    }

    else
      if(section_length == 0u)
      {
        free((void *)pmt->pmt);
        pmt->pmt = (unsigned char *)(void *)0;
        do
          if(iSysLogLevel >= 2)
            x_syslog(6, "[mpeg-ts  ] ", "parse_pmt: zero-length section");

        while((_Bool)0);
        return 0;
      }

      else
      {

      __CPROVER_DUMP_L29:
        ;
        crc32 = (unsigned int)pmt->pmt[(signed long int)((section_length + (unsigned int)3) - (unsigned int)4)] << 24;
        crc32 = crc32 | (unsigned int)pmt->pmt[(signed long int)((section_length + (unsigned int)3) - (unsigned int)3)] << 16;
        crc32 = crc32 | (unsigned int)pmt->pmt[(signed long int)((section_length + (unsigned int)3) - (unsigned int)2)] << 8;
        crc32 = crc32 | (unsigned int)pmt->pmt[(signed long int)((section_length + (unsigned int)3) - (unsigned int)1)];
        calc_crc32=ts_compute_crc32(pmt->pmt, (section_length + (unsigned int)3) - (unsigned int)4, 0xffffffff);
        if(!(crc32 == calc_crc32))
        {
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, "[mpeg-ts  ] ", "parse_pmt: invalid CRC32");

          while((_Bool)0);
          return 0;
        }

        else
          if(crc32 == pmt->crc32)
          {
            if(!(version_number == pmt->version_number))
              goto __CPROVER_DUMP_L34;


          __CPROVER_DUMP_L33:
            ;
            return 0;
          }

          else
          {

          __CPROVER_DUMP_L34:
            ;
            pmt->crc32 = crc32;
            pmt->version_number = version_number;
            pmt->audio_tracks_count = (unsigned char)0;
            pmt->spu_tracks_count = (unsigned char)0;
            pmt->video_pid = (unsigned short int)0xffff;
            program_info_length = (unsigned int)(((signed int)pmt->pmt[(signed long int)10] << 8 | (signed int)pmt->pmt[(signed long int)11]) & 0x0fff);
            ts_get_reg_desc(&program_info_format_identifier, &pmt->pmt[(signed long int)12], (signed int)program_info_length);
            if(!(program_info_format_identifier == 0u))
            {
              if(program_info_format_identifier == 1212435798u)
              {
                do
                  if(iSysLogLevel >= 2)
                    x_syslog(6, "[mpeg-ts  ] ", "PMT program info has tag 0x05 (format_identifier), content HDMV (0x%x)\n", program_info_format_identifier);

                while((_Bool)0);
                hdmv_pmt = (unsigned char)1;
              }

              else
                do
                  if(iSysLogLevel >= 2)
                    x_syslog(6, "[mpeg-ts  ] ", "PMT program info has tag 0x05 (format_identifier), content 0x%x\n", program_info_format_identifier);

                while((_Bool)0);
            }

            stream = &pmt->pmt[(signed long int)12] + (signed long int)program_info_length;
            coded_length = (unsigned int)13 + program_info_length;
            if(!(section_length >= coded_length))
            {
              do
                if(iSysLogLevel >= 2)
                  x_syslog(6, "[mpeg-ts  ] ", "parse_pmt: PMT with inconsistent progInfo length");

              while((_Bool)0);
              return 0;
            }

            else
            {
              section_length = section_length - coded_length;
              while(section_length >= 1u)
              {
                unsigned int stream_info_length;
                pid = (unsigned int)(((signed int)stream[(signed long int)1] << 8 | (signed int)stream[(signed long int)2]) & 0x1fff);
                stream_info_length = (unsigned int)(((signed int)stream[(signed long int)3] << 8 | (signed int)stream[(signed long int)4]) & 0x0fff);
                coded_length = (unsigned int)5 + stream_info_length;
                if(!(section_length >= coded_length))
                {
                  do
                    if(iSysLogLevel >= 2)
                      x_syslog(6, "[mpeg-ts  ] ", "parse_pmt: PMT with inconsistent streamInfo length");

                  while((_Bool)0);
                  return 0;
                }

                if(!((signed int)*stream == ISO_11172_VIDEO) && !((signed int)*stream == ISO_13818_VIDEO) && !((signed int)*stream == ISO_14496_PART2_VIDEO) && !((signed int)*stream == ISO_14496_PART10_VIDEO) && !((signed int)*stream == STREAM_VIDEO_VC1))
                {
                  if((signed int)*stream == ISO_11172_AUDIO || (signed int)*stream == ISO_13818_AUDIO || (signed int)*stream == ISO_13818_PART7_AUDIO || (signed int)*stream == ISO_14496_PART3_AUDIO)
                    goto __CPROVER_DUMP_L49;

                  if((signed int)*stream == ISO_13818_PRIVATE || (signed int)*stream == ISO_13818_TYPE_C)
                    goto __CPROVER_DUMP_L53;

                  if((signed int)*stream == ISO_13818_PES_PRIVATE)
                    goto __CPROVER_DUMP_L54;

                  if((signed int)*stream == 144 || (signed int)*stream == 145 || (signed int)*stream == 146)
                    goto __CPROVER_DUMP_L66;

                  if((signed int)*stream == 128 || (signed int)*stream == 130 || (signed int)*stream == 131 || (signed int)*stream == 132 || (signed int)*stream == 133 || (signed int)*stream == 134)
                    goto __CPROVER_DUMP_L67;

                }

                else
                {

                __CPROVER_DUMP_L47:
                  ;
                  if((signed int)pmt->video_pid == 0xffff)
                  {
                    pmt->video_pid = (unsigned short int)pid;
                    pmt->video_type = (enum anonymous$11)stream[(signed long int)0];
                  }

                  goto __CPROVER_DUMP_L76;

                __CPROVER_DUMP_L49:
                  ;
                  if(!((signed int)pmt->audio_tracks_count >= 32))
                  {
                    signed int return_value_find_audio_track$3;
                    return_value_find_audio_track$3=find_audio_track(pmt, pid);
                    if(!(return_value_find_audio_track$3 >= 0))
                    {

                    __CPROVER_DUMP_L50:
                      ;
                      pmt->audio_tracks[(signed long int)pmt->audio_tracks_count].pid = (unsigned short int)pid;
                      pmt->audio_tracks[(signed long int)pmt->audio_tracks_count].type = (enum anonymous$11)stream[(signed long int)0];
                      pmt->audio_tracks_count = pmt->audio_tracks_count + 1;
                    }

                  }

                  goto __CPROVER_DUMP_L76;

                __CPROVER_DUMP_L53:
                  ;
                  goto __CPROVER_DUMP_L76;

                __CPROVER_DUMP_L54:
                  ;
                  i = (unsigned int)5;
                  for( ; !(i >= coded_length); i = i + (unsigned int)((signed int)stream[(signed long int)(i + (unsigned int)1)] + 2))
                  {
                    signed int return_value_is_audio_descriptor$6;
                    return_value_is_audio_descriptor$6=is_audio_descriptor(stream[(signed long int)i]);
                    if(!(return_value_is_audio_descriptor$6 == 0))
                    {
                      if(!((signed int)pmt->audio_tracks_count >= 32))
                      {
                        return_value_find_audio_track$4=find_audio_track(pmt, pid);
                        if(!(return_value_find_audio_track$4 >= 0))
                        {

                        __CPROVER_DUMP_L56:
                          ;
                          pmt->audio_tracks[(signed long int)pmt->audio_tracks_count].pid = (unsigned short int)pid;
                          pmt->audio_tracks[(signed long int)pmt->audio_tracks_count].type=descriptor_to_stream_type(stream[(signed long int)i]);
                          pmt->audio_tracks_count = pmt->audio_tracks_count + 1;
                          break;
                        }

                      }

                    }

                    else
                      if((signed int)stream[(signed long int)i] == 0x59)
                      {
                        unsigned int pos = i + (unsigned int)2;
                        do
                        {
                          if(2u + i + (unsigned int)stream[(signed long int)(1u + i)] >= 8u + pos)
                            tmp_if_expr$5 = (signed int)pmt->spu_tracks_count < 32 ? (_Bool)1 : (_Bool)0;

                          else
                            tmp_if_expr$5 = (_Bool)0;
                          if(!tmp_if_expr$5)
                            break;

                          signed int no = (signed int)pmt->spu_tracks_count;
                          pmt->spu_tracks_count = pmt->spu_tracks_count + 1;
                          memcpy$link4((void *)pmt->spu_tracks[(signed long int)no].lang, (const void *)&stream[(signed long int)pos], (unsigned long int)3);
                          pmt->spu_tracks[(signed long int)no].lang[(signed long int)3] = (unsigned char)0;
                          pmt->spu_tracks[(signed long int)no].comp_page_id = (unsigned short int)((signed int)stream[(signed long int)(pos + (unsigned int)4)] << 8 | (signed int)stream[(signed long int)(pos + (unsigned int)5)]);
                          pmt->spu_tracks[(signed long int)no].aux_page_id = (unsigned short int)((signed int)stream[(signed long int)(pos + (unsigned int)6)] << 8 | (signed int)stream[(signed long int)(pos + (unsigned int)7)]);
                          pmt->spu_tracks[(signed long int)no].pid = (unsigned short int)pid;

                        __CPROVER_DUMP_L62:
                          ;
                          pos = pos + (unsigned int)8;
                        }
                        while((_Bool)1);
                      }

                  }
                  goto __CPROVER_DUMP_L76;

                __CPROVER_DUMP_L66:
                  ;
                  if(!(hdmv_pmt == 0))
                    goto __CPROVER_DUMP_L76;


                __CPROVER_DUMP_L67:
                  ;
                  if(!(hdmv_pmt == 0))
                  {
                    if(!((signed int)pmt->audio_tracks_count >= 32))
                    {
                      signed int return_value_find_audio_track$7;
                      return_value_find_audio_track$7=find_audio_track(pmt, pid);
                      if(!(return_value_find_audio_track$7 >= 0))
                      {
                        pmt->audio_tracks[(signed long int)pmt->audio_tracks_count].pid = (unsigned short int)pid;
                        pmt->audio_tracks[(signed long int)pmt->audio_tracks_count].type = (enum anonymous$11)((signed int)stream[(signed long int)0] | STREAM_HDMV);
                        pmt->audio_tracks_count = pmt->audio_tracks_count + 1;
                        goto __CPROVER_DUMP_L76;
                      }

                    }

                    goto __CPROVER_DUMP_L76;
                  }

                }
                if(!((signed int)pmt->audio_tracks_count >= 32))
                  tmp_if_expr$9 = (signed int)stream[(signed long int)0] >= 0x80 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$9 = (_Bool)0;
                if(tmp_if_expr$9)
                {
                  signed int return_value_find_audio_track$8;
                  return_value_find_audio_track$8=find_audio_track(pmt, pid);
                  if(!(return_value_find_audio_track$8 >= 0))
                  {
                    unsigned int format_identifier = (unsigned int)0;
                    ts_get_reg_desc(&format_identifier, stream + (signed long int)5, (signed int)stream_info_length);
                    if(format_identifier == 0u || format_identifier == 1094921523u)
                    {
                      pmt->audio_tracks[(signed long int)pmt->audio_tracks_count].pid = (unsigned short int)pid;
                      pmt->audio_tracks[(signed long int)pmt->audio_tracks_count].type = (enum anonymous$11)stream[(signed long int)0];
                      pmt->audio_tracks_count = pmt->audio_tracks_count + 1;
                      goto __CPROVER_DUMP_L76;
                    }

                  }

                }

                else

                  __CPROVER_DUMP_L75:
                    ;

              __CPROVER_DUMP_L76:
                ;
                stream = stream + (signed long int)coded_length;
                section_length = section_length - coded_length;
              }
              pid = (unsigned int)(((signed int)pmt->pmt[(signed long int)8] << 8 | (signed int)pmt->pmt[(signed long int)9]) & 0x1fff);
              if(!((unsigned int)pmt->pcr_pid == pid))
              {
                if((signed int)pmt->pcr_pid == 0xffff)

                  __CPROVER_DUMP_L78:
                    ;

                else

                  __CPROVER_DUMP_L79:
                    ;
                pmt->pcr_pid = (unsigned short int)pid;
              }

              return 1;
            }
          }
      }
  }
}

// ts_scan_startcode
// file tools/ts.c line 716
static unsigned long int ts_scan_startcode(struct ts_state_s *ts)
{
  if(ts->buf_len >= 3ul)
  {
    unsigned long int i = (unsigned long int)0;
    unsigned long int n = ts->buf_len - (unsigned long int)2;
    while(!(i >= n))
      if(!(ts->buf[1l + (signed long int)i] == 0))
        i = i + (unsigned long int)2;

      else
        if(!(ts->buf[(signed long int)i] == 0))
          i = i + 1ul;

        else
          if(!((signed int)ts->buf[2l + (signed long int)i] == 1))
            i = i + 1ul;

          else
            break;
    ts_skip_payload(ts, i);
  }

  return ts->buf_len;
}

// ts_skip_payload
// file tools/ts.c line 700
static void ts_skip_payload(struct ts_state_s *ts, unsigned long int n)
{
  if(!(n >= ts->buf_len))
  {
    ts->buf_len = ts->buf_len - n;
    memmove((void *)ts->buf, (const void *)(ts->buf + (signed long int)n), ts->buf_len);
  }

  else
    ts->buf_len = (unsigned long int)0;
}

// ts_state_dispose
// file tools/ts.c line 660
void ts_state_dispose(struct ts_state_s *ts)
{
  free((void *)ts);
}

// ts_state_init
// file tools/ts.c line 634
struct ts_state_s * ts_state_init(unsigned long int buffer_size)
{
  if(!(buffer_size >= 1504ul))
    buffer_size = (unsigned long int)(8 * 188);

  if(buffer_size >= 4194305ul)
  {
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, "[mpeg-ts  ] ", "ERROR: ts_state_init(%zd)", buffer_size);

    while((_Bool)0);
    buffer_size = (unsigned long int)(4 * 1024 * 1024);
  }

  struct ts_state_s *ts;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct ts_state_s) /*24ul*/  + buffer_size);
  ts = (struct ts_state_s *)return_value_calloc$1;
  if(!(ts == ((struct ts_state_s *)NULL)))
    ts->buf_size = buffer_size;

  return ts;
}

// ts_state_reset
// file tools/ts.c line 651
void ts_state_reset(struct ts_state_s *ts)
{
  if(!(ts == ((struct ts_state_s *)NULL)))
  {
    unsigned long int buf_size = ts->buf_size;
    memset$link3((void *)ts, 0, sizeof(struct ts_state_s) /*24ul*/ );
    ts->buf_size = buf_size;
  }

}

// udp_check_packet
// file xine_input_vdr.c line 4311
static struct buf_element_s * udp_check_packet(struct buf_element_s *read_buffer)
{
  struct anonymous$7 *pkt = (struct anonymous$7 *)read_buffer->content;
  unsigned char *pkt_data = read_buffer->content + (signed long int)sizeof(struct anonymous$7) /*11ul*/ ;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  if((signed long int)read_buffer->size >= 12l)
  {
    if((signed int)*pkt_data == 0x47)
      goto __CPROVER_DUMP_L7;

    if(!(*pkt_data == 0))
      tmp_if_expr$1 = (_Bool)1;

    else
      tmp_if_expr$1 = pkt_data[(signed long int)1] != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = (signed int)pkt_data[(signed long int)2] != 1 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$2)
      goto __CPROVER_DUMP_L7;

    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_vdr, "received invalid UDP packet (TS sync byte or PES header missing)");

    while((_Bool)0);
    read_buffer->free_buffer(read_buffer);
    return (struct buf_element_s *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L7:
    ;
    if((signed int)pkt->seq >= 256)
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "received invalid UDP packet (sequence number too big)");

      while((_Bool)0);
      read_buffer->free_buffer(read_buffer);
      return (struct buf_element_s *)(void *)0;
    }

    else
      return read_buffer;
  }
}

// udp_parse_control
// file xine_input_vdr.c line 4335
static struct buf_element_s * udp_parse_control(struct vdr_input_plugin_s *this, struct buf_element_s *read_buffer)
{
  struct anonymous$7 *pkt = (struct anonymous$7 *)read_buffer->content;
  unsigned char *pkt_data = (unsigned char *)read_buffer->content + (signed long int)sizeof(struct anonymous$7) /*11ul*/ ;
  if(pkt->pos == 18446744073709551615ull)
  {
    if(!(*pkt_data == 0))
    {
      pkt_data[(signed long int)64] = (unsigned char)0;
      signed int return_value_strncmp$1;
      return_value_strncmp$1=strncmp((char *)pkt_data, "UDP MISSING", (unsigned long int)11);
      if(return_value_strncmp$1 == 0)
      {
        signed int seq1 = 0;
        signed int seq2 = 0;
        unsigned long int rpos = 0UL;
        struct udp_data_s *udp = this->udp_data;
        sscanf((char *)pkt_data + (signed long int)12, "%d-%d %lu", &seq1, &seq2, &rpos);
        read_buffer->size = (signed int)sizeof(struct anonymous$7) /*11ul*/ ;
        read_buffer->type = (unsigned int)(0x05000000 | 0x00010000);
        pkt->pos = rpos;
        if(seq1 == (signed int)udp->next_seq)
        {
          signed int n = seq2 + 1 + 0xff + 1 + -seq1 & 0xff;
          udp->missed_frames = udp->missed_frames + (signed short int)n;
          seq2 = seq2 & 0xff;
          pkt->seq = (unsigned short int)seq2;
          udp->next_seq = (unsigned short int)seq2;
        }

        else
        {
          read_buffer->free_buffer(read_buffer);
          return (struct buf_element_s *)(void *)0;
        }
      }

      else
      {
        data_stream_parse_control(this, (char *)pkt_data);
        read_buffer->free_buffer(read_buffer);
        return (struct buf_element_s *)(void *)0;
      }
    }

  }

  return read_buffer;
}

// udp_parse_header
// file xine_input_vdr.c line 4285
static struct buf_element_s * udp_parse_header(struct buf_element_s *read_buffer, signed int rtp)
{
  _Bool tmp_if_expr$3;
  unsigned short int tmp_statement_expression$2;
  unsigned short int tmp_statement_expression$1;
  if(!(rtp == 0))
  {
    struct stream_rtp_header_impl *rtp_pkt = (struct stream_rtp_header_impl *)read_buffer->content;
    if((signed int)rtp_pkt->rtp_hdr.$anon0.raw[0l] == 144)
    {
      if((signed int)rtp_pkt->rtp_hdr.$anon0.raw[1l] == 96)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = (signed int)rtp_pkt->rtp_hdr.$anon0.raw[(signed long int)1] == 33 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
      {
        unsigned short int udp_parse_header$$1$$1$$1$$__v;
        unsigned short int udp_parse_header$$1$$1$$1$$__x = (unsigned short int)3;
        asm("rorw $8, %w0" : "=r"(udp_parse_header$$1$$1$$1$$__v) : "0"(udp_parse_header$$1$$1$$1$$__x) : "cc");
        tmp_statement_expression$2 = udp_parse_header$$1$$1$$1$$__v;
        if(rtp_pkt->hdr_ext.hdr.$anon0.$anon0.size == tmp_statement_expression$2)
        {
          unsigned short int udp_parse_header$$1$$1$$2$$__v;
          unsigned short int __x = (unsigned short int)0x54d3;
          asm("rorw $8, %w0" : "=r"(udp_parse_header$$1$$1$$2$$__v) : "0"(__x) : "cc");
          tmp_statement_expression$1 = udp_parse_header$$1$$1$$2$$__v;
          if(rtp_pkt->hdr_ext.hdr.$anon0.$anon0.type == tmp_statement_expression$1)
          {
            read_buffer->content = read_buffer->content + (signed long int)(sizeof(struct stream_rtp_header_impl) /*28ul*/  - sizeof(struct anonymous$7) /*11ul*/ );
            read_buffer->size = read_buffer->size - (signed int)(sizeof(struct stream_rtp_header_impl) /*28ul*/  - sizeof(struct anonymous$7) /*11ul*/ );
          }

        }

      }

    }

  }

  struct anonymous$7 *pkt = (struct anonymous$7 *)read_buffer->content;
  unsigned short int tmp_statement_expression$4;
  unsigned short int __v;
  unsigned short int udp_parse_header$$1$$2$$__x = (unsigned short int)pkt->seq;
  asm("rorw $8, %w0" : "=r"(__v) : "0"(udp_parse_header$$1$$2$$__x) : "cc");
  tmp_statement_expression$4 = __v;
  pkt->seq = tmp_statement_expression$4;
  unsigned int return_value___bswap_32$5;
  return_value___bswap_32$5=__bswap_32((unsigned int)(pkt->pos >> 32));
  unsigned int return_value___bswap_32$6;
  return_value___bswap_32$6=__bswap_32((unsigned int)pkt->pos);
  pkt->pos = (unsigned long int)return_value___bswap_32$5 | (unsigned long int)return_value___bswap_32$6 << 32;
  return read_buffer;
}

// udp_process_queue
// file xine_input_vdr.c line 4388
static struct buf_element_s * udp_process_queue(struct vdr_input_plugin_s *this)
{
  struct udp_data_s *udp = this->udp_data;
  if(!((signed int)udp->queued >= 1))
    return (struct buf_element_s *)(void *)0;

  else
  {
    if((signed int)udp->queued >= 65)
    {
      for( ; udp->queue[(signed long int)udp->next_seq] == ((struct buf_element_s *)NULL); udp->missed_frames = udp->missed_frames + 1)
        udp->next_seq = (unsigned short int)((signed int)udp->next_seq + 1 & 0xff);
      udp->resend_requested = 0;
    }

    if(!(udp->is_padding == 0))
    {
      if((signed int)udp->queued >= 1)
        for( ; udp->queue[(signed long int)udp->next_seq] == ((struct buf_element_s *)NULL); udp->missed_frames = udp->missed_frames + 1)
          udp->next_seq = (unsigned short int)((signed int)udp->next_seq + 1 & 0xff);

    }

    while((signed int)udp->queued >= 1)
    {
      if(udp->queue[(signed long int)udp->next_seq] == ((struct buf_element_s *)NULL))
        break;

      struct buf_element_s *buf = (struct buf_element_s *)(void *)0;
      struct anonymous$7 *pkt = (struct anonymous$7 *)udp->queue[(signed long int)udp->next_seq]->content;
      udp->queue_input_pos = (pkt->pos + (unsigned long int)udp->queue[(signed long int)udp->next_seq]->size) - sizeof(struct anonymous$7) /*11ul*/ ;
      if((signed long int)udp->queue[(signed long int)udp->next_seq]->size >= 12l)
        buf = udp->queue[(signed long int)udp->next_seq];

      else
        udp->queue[(signed long int)udp->next_seq]->free_buffer(udp->queue[(signed long int)udp->next_seq]);
      udp->queue[(signed long int)udp->next_seq] = (struct buf_element_s *)(void *)0;
      udp->queued = udp->queued - 1;
      udp->next_seq = (unsigned short int)((signed int)udp->next_seq + 1 & 0xff);
      if(!(udp->resend_requested == 0))
        udp->resend_requested = udp->resend_requested - 1;

      if(!(udp->is_padding == 0))
      {
        if((signed int)udp->queued >= 1)
          for( ; udp->queue[(signed long int)udp->next_seq] == ((struct buf_element_s *)NULL); udp->missed_frames = udp->missed_frames + 1)
            udp->next_seq = (unsigned short int)((signed int)udp->next_seq + 1 & 0xff);

      }

      if(!(buf == ((struct buf_element_s *)NULL)))
        return buf;

    }
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 11;
    return (struct buf_element_s *)(void *)0;
  }
}

// udp_process_resend
// file xine_input_vdr.c line 4458
static void udp_process_resend(struct vdr_input_plugin_s *this)
{
  struct udp_data_s *udp = this->udp_data;
  if(udp->resend_requested == 0)
  {
    if(!((1 + (signed int)udp->current_seq & 0xff) == (signed int)udp->next_seq))
    {
      if(!(udp->queued == 0))
      {
        signed int max_req = 20;
        for( ; udp->queue[(signed long int)udp->current_seq] == ((struct buf_element_s *)NULL); udp->current_seq = (unsigned short int)((signed int)udp->current_seq + 1 & 0xff))
        {
          max_req = max_req - 1;
          if(!(max_req >= 1))
            break;

        }
        printf_control(this, "UDP RESEND %d-%d %lu\r\n", udp->next_seq, (signed int)udp->current_seq + 0xff & 0xff, udp->queue_input_pos);
        udp->resend_requested = ((signed int)udp->current_seq + 0xff + 1) - (signed int)udp->next_seq & 0xff;
      }

    }

  }

}

// uncompress_osd_net
// file xine_input_vdr.c line 1931
static struct osd_rle_elem_s * uncompress_osd_net(unsigned char *raw, signed int elems, signed int datalen)
{
  struct osd_rle_elem_s *data;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)elems * sizeof(struct osd_rle_elem_s) /*4ul*/ );
  data = (struct osd_rle_elem_s *)return_value_malloc$1;
  signed int i = 0;
  unsigned char *tmp_post$2;
  unsigned char *tmp_post$3;
  unsigned char *tmp_post$4;
  unsigned char *tmp_post$5;
  for( ; !(i >= elems); i = i + 1)
  {
    if(!((0x80 & (signed int)*raw) == 0))
    {
      tmp_post$2 = raw;
      raw = raw + 1l;
      (data + (signed long int)i)->len = (unsigned short int)(((signed int)*tmp_post$2 & 0x7f) << 8);
      tmp_post$3 = raw;
      raw = raw + 1l;
      (data + (signed long int)i)->len = (data + (signed long int)i)->len | (unsigned short int)*tmp_post$3;
    }

    else
    {
      tmp_post$4 = raw;
      raw = raw + 1l;
      (data + (signed long int)i)->len = (unsigned short int)*tmp_post$4;
    }
    tmp_post$5 = raw;
    raw = raw + 1l;
    (data + (signed long int)i)->color = (unsigned short int)*tmp_post$5;
  }
  return data;
}

// unescape_filename
// file xine_input_vdr.c line 850
static char * unescape_filename(const char *fn)
{
  char *d;
  char *return_value___strdup$1;
  return_value___strdup$1=__strdup(fn);
  d = return_value___strdup$1;
  char *s = d;
  char *result = d;
  char *tmp_post$2;
  char *tmp_post$4;
  char *tmp_post$5;
  while(!(*s == 0))
  {
    if((signed int)*s == 35)
      break;

    if((signed int)*s == 37)
    {
      if(!(s[1l] == 0))
      {
        if(!(s[2l] == 0))
        {
          unsigned int c;
          signed int return_value_sscanf$3;
          return_value_sscanf$3=sscanf(s + (signed long int)1, "%02x", &c);
          if(return_value_sscanf$3 == 1)
          {
            tmp_post$2 = d;
            d = d + 1l;
            *tmp_post$2 = (char)c;
            s = s + (signed long int)3;
            continue;
          }

        }

      }

    }

    tmp_post$4 = d;
    d = d + 1l;
    tmp_post$5 = s;
    s = s + 1l;
    *tmp_post$4 = *tmp_post$5;
  }
  *d = (char)0;
  return result;
}

// update_dvd_title_number
// file xine_input_vdr.c line 3662
static void update_dvd_title_number(struct vdr_input_plugin_s *this)
{
  signed int tn;
  unsigned int return_value__x_stream_info_get$1;
  return_value__x_stream_info_get$1=_x_stream_info_get(this->slave.stream, 30);
  tn = (signed int)return_value__x_stream_info_get$1;
  signed int tc;
  unsigned int return_value__x_stream_info_get$2;
  return_value__x_stream_info_get$2=_x_stream_info_get(this->slave.stream, 31);
  tc = (signed int)return_value__x_stream_info_get$2;
  if(tc >= 1 && tn >= 0)
  {
    if(tn == 0)
      dvd_menu_domain(this, 1);

    printf_vdr(this, "INFO DVDTITLE %d/%d\r\n", tn, tc);
  }

}

// update_frames
// file xine_input_vdr.c line 4754
static unsigned char update_frames(struct vdr_input_plugin_s *this, const unsigned char *data, signed int len)
{
  unsigned char type;
  type=pes_get_picture_type(data, len);
  if(this->I_frames == 0u)
  {
    this->B_frames = (unsigned int)0;
    this->P_frames = this->B_frames;
  }

  switch((signed int)type)
  {
    case 1:
    {
      this->I_frames = this->I_frames + 1u;
      break;
    }
    case 2:
    {
      this->P_frames = this->P_frames + 1u;
      break;
    }
    case 3:
      this->B_frames = this->B_frames + 1u;
  }
  return type;
}

// vdr_adjust_realtime_speed
// file xine_input_vdr.c line 618
static void vdr_adjust_realtime_speed(struct vdr_input_plugin_s *this)
{
  signed int return_value_pthread_mutex_trylock$1;
  return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&this->lock);
  signed int return_value;
  signed int return_value_1;
  signed int return_value_4;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$8;
  signed int return_value__x_get_fine_speed$13;
  unsigned int tmp_if_expr$11;
  unsigned int tmp_if_expr$12;
  if(return_value_pthread_mutex_trylock$1 == 0)
  {
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_vdr, "%s: assertion failed: lock %s unlocked !", (const void *)"vdr_adjust_realtime_speed", (const void *)"this->lock");

    while((_Bool)0);
    pthread_mutex_unlock(&this->lock);
  }

  else
    if(!(this->still_mode == 0))
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "%s: assertion failed: %s is true !", (const void *)"vdr_adjust_realtime_speed", (const void *)"this->still_mode");

      while((_Bool)0);

    else
      if(!(this->is_trickspeed == 0))
        do
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "%s: assertion failed: %s is true !", (const void *)"vdr_adjust_realtime_speed", (const void *)"this->is_trickspeed");

        while((_Bool)0);

      else
        if(!(this->is_paused == 0))
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_input_vdr, "%s: assertion failed: %s is true !", (const void *)"vdr_adjust_realtime_speed", (const void *)"this->is_paused");

          while((_Bool)0);

        else
        {
          unsigned int num_used;
          unsigned int num_free;
          unsigned int fill_level;
          if(!(this->hd_stream == 0))
          {
            return_value=this->hd_buffer->num_free(this->hd_buffer);
            num_free = (unsigned int)return_value;
          }

          else
          {
            return_value_1=this->buffer_pool->num_free(this->buffer_pool);
            num_free = (unsigned int)return_value_1;
          }
          if(!(num_free >= this->reserved_buffers))
            num_free = (unsigned int)0;

          else
            num_free = num_free - this->reserved_buffers;
          signed int return_value_2;
          return_value_2=this->buffer_pool->size(this->buffer_pool);
          signed int return_value_3;
          return_value_3=this->block_buffer->size(this->block_buffer);
          num_used = (unsigned int)(return_value_2 + return_value_3);
          if(!(this->stream->audio_fifo == ((struct fifo_buffer_s *)NULL)))
          {
            return_value_4=this->stream->audio_fifo->size(this->stream->audio_fifo);
            num_used = num_used + (unsigned int)return_value_4;
          }

          fill_level = ((unsigned int)100 * num_used) / (num_used + num_free);
          signed int scr_tuning = (signed int)this->scr_tuning;
          if(!(scr_tuning == -10000) && !(num_used >= 1u))
          {
            if(this->no_video == 0)
            {
              if(this->still_mode == 0)
              {
                if(this->is_trickspeed == 0)
                {
                  signed int num_frames;
                  num_frames=this->stream->video_out->get_property(this->stream->video_out, 17);
                  if(!(num_frames >= 5))
                    scr_tuning_set_paused(this);

                }

              }

            }

          }

          if(scr_tuning == -10000)
          {
            unsigned int scr_treshold = ((unsigned int)100 * num_used) / (num_used + num_free);
            unsigned int audio_treshold;
            signed int return_value_5;
            return_value_5=this->stream->audio_fifo->size(this->stream->audio_fifo);
            signed int return_value_6;
            return_value_6=this->stream->audio_fifo->size(this->stream->audio_fifo);
            audio_treshold = (unsigned int)((100 * return_value_5) / (return_value_6 + 500));
            if(!(this->hd_stream == 0))
              tmp_if_expr$2 = scr_treshold > this->class->scr_treshold_hd ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr$2 = (_Bool)0;
            if((audio_treshold >= 1u || scr_treshold >= 66u) && tmp_if_expr$2)
              tmp_if_expr$4 = (_Bool)1;

            else
            {
              if(this->hd_stream == 0)
                tmp_if_expr$3 = scr_treshold > this->class->scr_treshold_sd ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr$3 = (_Bool)0;
              tmp_if_expr$4 = (tmp_if_expr$3 ? (audio_treshold > (unsigned int)0 || scr_treshold > (unsigned int)65 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$4)
              tmp_if_expr$5 = (_Bool)1;

            else
              tmp_if_expr$5 = (this->no_video != 0 ? (num_used > (unsigned int)5 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$5)
              tmp_if_expr$6 = (_Bool)1;

            else
              tmp_if_expr$6 = this->still_mode != 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$6)
              tmp_if_expr$7 = (_Bool)1;

            else
              tmp_if_expr$7 = this->is_trickspeed != 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$7)
              tmp_if_expr$10 = (_Bool)1;

            else
            {
              if(this->I_frames >= 1u)
              {
                if(this->I_frames >= 3u)
                  tmp_if_expr$8 = (_Bool)1;

                else
                  tmp_if_expr$8 = this->P_frames > (unsigned int)6 ? (_Bool)1 : (_Bool)0;
                tmp_if_expr$9 = tmp_if_expr$8 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr$9 = (_Bool)0;
              tmp_if_expr$10 = tmp_if_expr$9 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$10)
            {
              this->I_frames = (unsigned int)0;
              reset_scr_tuning(this);
            }

          }

          else
          {
            return_value__x_get_fine_speed$13=_x_get_fine_speed(this->stream);
            if(return_value__x_get_fine_speed$13 == 1000000)
            {
              if(this->scr_live_sync == 0)
                scr_tuning = 0;

              else
                if(!(this->no_video == 0))
                {
                  if(num_used >= 9u)
                    scr_tuning = +1;

                  else
                    if(!(num_used >= 4u))
                      scr_tuning = -1;

                    else
                      scr_tuning = 0;
                }

                else
                  if(!(this->class->smooth_scr_tuning == 0))
                  {
                    signed int trim_rel;
                    signed int trim_act = scr_tuning - 0;
                    this->scr_buf.fill_avg = this->scr_buf.fill_avg + fill_level;
                    if(!(this->scr_buf.fill_min >= fill_level))
                      tmp_if_expr$11 = this->scr_buf.fill_min;

                    else
                      tmp_if_expr$11 = fill_level;
                    this->scr_buf.fill_min = tmp_if_expr$11;
                    if(!(fill_level >= this->scr_buf.fill_max))
                      tmp_if_expr$12 = this->scr_buf.fill_max;

                    else
                      tmp_if_expr$12 = fill_level;
                    this->scr_buf.fill_max = tmp_if_expr$12;
                    this->scr_buf.cnt = this->scr_buf.cnt + 1u;
                    if(this->scr_buf.cnt % 8000u == 0u)
                    {
                      this->scr_buf.fill_avg = this->scr_buf.fill_avg / (unsigned int)8000;
                      trim_rel = (signed int)((this->scr_buf.fill_avg - (unsigned int)50) / (unsigned int)2);
                      trim_rel = trim_rel < 1 ? trim_rel : 1;
                      trim_rel = trim_rel > -1 ? trim_rel : -1;
                      this->scr_buf.fill_avg = (unsigned int)0;
                      this->scr_buf.fill_min = (unsigned int)100;
                      this->scr_buf.fill_max = (unsigned int)0;
                      if(!(trim_rel == 0))
                      {
                        trim_act = trim_act + trim_rel;
                        trim_act = trim_act < 2 ? trim_act : 2;
                        trim_act = trim_act > -2 ? trim_act : -2;
                        scr_tuning = trim_act + 0;
                      }

                    }

                  }

                  else
                    if(fill_level >= 86u)
                      scr_tuning = +2;

                    else
                      if(fill_level >= 71u)
                        scr_tuning = +1;

                      else
                        if(!(fill_level >= 15u))
                          scr_tuning = -2;

                        else
                          if(!(fill_level >= 30u))
                            scr_tuning = -1;

                          else
                            if(scr_tuning >= 1 && !(num_used >= num_free) || !(scr_tuning >= 0) && !(num_free >= num_used))
                              scr_tuning = 0;

              if(!(scr_tuning == (signed int)this->scr_tuning))
              {
                this->scr_tuning = (signed short int)scr_tuning;
                if(!(this->scr == ((struct adjustable_scr_s *)NULL)))
                  this->scr->set_speed_tuning(this->scr, 1.0 + this->class->scr_tuning_step * (double)scr_tuning);

              }

            }

            else
              if(!(this->scr_tuning == 0))
                reset_scr_tuning(this);

          }
        }
}

// vdr_class_default_mrl_change_cb
// file xine_input_vdr.c line 5893
static void vdr_class_default_mrl_change_cb(void *data, struct xine_cfg_entry_s *cfg)
{
  struct vdr_input_class_s *class = (struct vdr_input_class_s *)data;
  class->mrls[(signed long int)0] = cfg->str_value;
}

// vdr_class_dispose
// file xine_input_vdr.c line 6043
static void vdr_class_dispose(struct input_class_s$1 *this_gen)
{
  struct vdr_input_class_s *this = (struct vdr_input_class_s *)this_gen;
  struct config_values_s *config = this->xine->config;
  config->unregister_callback(config, "media.xvdr.default_mrl");
  config->unregister_callback(config, "media.xvdr.osd.fast_scaling");
  config->unregister_callback(config, "media.xvdr.scr_tuning_step");
  config->unregister_callback(config, "media.xvdr.smooth_scr_tuning");
  free((void *)this);
}

// vdr_class_fast_osd_scaling_cb
// file xine_input_vdr.c line 5917
static void vdr_class_fast_osd_scaling_cb(void *data, struct xine_cfg_entry_s *cfg)
{
  struct vdr_input_class_s *class = (struct vdr_input_class_s *)data;
  class->fast_osd_scaling = cfg->num_value;
}

// vdr_class_get_instance
// file xine_input_vdr.c line 5924
static struct input_plugin_s$0 * vdr_class_get_instance(struct input_class_s$1 *class_gen, struct xine_stream_s *stream, const char *data)
{
  struct vdr_input_class_s *class = (struct vdr_input_class_s *)class_gen;
  struct vdr_input_plugin_s *this;
  char *mrl = (char *)data;
  signed int local_mode;
  do
    if(iSysLogLevel >= 3)
      x_syslog(7, log_module_input_vdr, "vdr_class_get_instance");

  while((_Bool)0);
  signed int return_value_strncasecmp$2;
  return_value_strncasecmp$2=strncasecmp(mrl, "xvdr:", (unsigned long int)(4 + 1));
  signed int return_value_strncasecmp$1;
  _Bool tmp_if_expr$9;
  unsigned long int return_value_strlen$8;
  _Bool tmp_if_expr$11;
  signed int return_value_strncasecmp$10;
  _Bool tmp_if_expr$15;
  signed int return_value_strcasecmp$14;
  _Bool tmp_if_expr$17;
  signed int return_value_strcasecmp$16;
  _Bool tmp_if_expr$19;
  signed int return_value_strcasecmp$18;
  if(!(return_value_strncasecmp$2 == 0))
  {
    return_value_strncasecmp$1=strncasecmp(mrl, "xvdr+", (unsigned long int)(4 + 1));
    if(return_value_strncasecmp$1 == 0)
      goto __CPROVER_DUMP_L3;

    return (struct input_plugin_s$0 *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    signed int return_value_strncasecmp$4;
    return_value_strncasecmp$4=strncasecmp(mrl, "xvdr+slave://0x", (unsigned long int)(4 + 11));
    if(return_value_strncasecmp$4 == 0)
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "vdr_class_get_instance: slave stream requested");

      while((_Bool)0);
      struct input_plugin_s$0 *return_value_fifo_class_get_instance$3;
      return_value_fifo_class_get_instance$3=fifo_class_get_instance(class_gen, stream, data);
      return return_value_fifo_class_get_instance$3;
    }

    void *return_value_calloc$5;
    return_value_calloc$5=calloc((unsigned long int)1, sizeof(struct vdr_input_plugin_s) /*656ul*/ );
    this = (struct vdr_input_plugin_s *)return_value_calloc$5;
    this->stream = stream;
    char *return_value___strdup$6;
    return_value___strdup$6=__strdup(mrl);
    this->mrl = return_value___strdup$6;
    this->class = class;
    this->fd_data = -1;
    this->fd_control = -1;
    this->stream_start = (unsigned char)1;
    this->autoplay_size = -1;
    signed int return_value_strncasecmp$7;
    return_value_strncasecmp$7=strncasecmp(mrl, "xvdr://", (unsigned long int)(4 + 3));
    if(return_value_strncasecmp$7 == 0)
    {
      return_value_strlen$8=strlen(mrl);
      tmp_if_expr$9 = return_value_strlen$8 == (unsigned long int)7 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$9 = (_Bool)0;
    if(tmp_if_expr$9)
      tmp_if_expr$11 = (_Bool)1;

    else
    {
      return_value_strncasecmp$10=strncasecmp(mrl, "xvdr:///", (unsigned long int)(4 + 4));
      tmp_if_expr$11 = !(return_value_strncasecmp$10 != 0) ? (_Bool)1 : (_Bool)0;
    }
    local_mode = (signed int)tmp_if_expr$11;
    if(bSymbolsFound == 0)
    {
      if(!(local_mode == 0))
      {
        do
          if(iSysLogLevel >= 3)
            x_syslog(7, log_module_input_vdr, "vdr or vdr-??fe not detected, forcing remote mode");

        while((_Bool)0);
        local_mode = 0;
      }

      signed int return_value_strcasecmp$13;
      return_value_strcasecmp$13=strcasecmp(mrl, "xvdr:");
      if(return_value_strcasecmp$13 == 0)
        tmp_if_expr$15 = (_Bool)1;

      else
      {
        return_value_strcasecmp$14=strcasecmp(mrl, "xvdr:/");
        tmp_if_expr$15 = !(return_value_strcasecmp$14 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$15)
        tmp_if_expr$17 = (_Bool)1;

      else
      {
        return_value_strcasecmp$16=strcasecmp(mrl, "xvdr://");
        tmp_if_expr$17 = !(return_value_strcasecmp$16 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$17)
        tmp_if_expr$19 = (_Bool)1;

      else
      {
        return_value_strcasecmp$18=strcasecmp(mrl, "xvdr:///");
        tmp_if_expr$19 = !(return_value_strcasecmp$18 != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$19)
      {
        free((void *)this->mrl);
        char *return_value___strdup$12;
        return_value___strdup$12=__strdup("xvdr://127.0.0.1");
        this->mrl = return_value___strdup$12;
        do
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "Changed mrl from %s to %s", mrl, this->mrl);

        while((_Bool)0);
      }

    }

    this->$anon0.$anon0.input_plugin.open = local_mode != 0 ? vdr_plugin_open_local : vdr_plugin_open_net;
    this->$anon0.$anon0.input_plugin.get_mrl = vdr_plugin_get_mrl;
    this->$anon0.$anon0.input_plugin.dispose = vdr_plugin_dispose;
    this->$anon0.$anon0.input_plugin.input_class = class_gen;
    this->$anon0.$anon0.input_plugin.get_capabilities = vdr_plugin_get_capabilities;
    this->$anon0.$anon0.input_plugin.read = vdr_plugin_read;
    this->$anon0.$anon0.input_plugin.read_block = vdr_plugin_read_block;
    this->$anon0.$anon0.input_plugin.seek = vdr_plugin_seek;
    this->$anon0.$anon0.input_plugin.get_current_pos = vdr_plugin_get_current_pos;
    this->$anon0.$anon0.input_plugin.get_length = vdr_plugin_get_length;
    this->$anon0.$anon0.input_plugin.get_blocksize = vdr_plugin_get_blocksize;
    this->$anon0.$anon0.input_plugin.get_optional_data = vdr_plugin_get_optional_data;
    if(!(local_mode == 0))
    {
      this->$anon0.$anon0.funcs.push_input_write = vdr_plugin_write;
      this->$anon0.$anon0.funcs.push_input_control = vdr_plugin_parse_control;
      this->$anon0.$anon0.funcs.push_input_osd = vdr_plugin_exec_osd_command;
    }

    else
      this->$anon0.$anon0.funcs.post_vdr_event = post_vdr_event;
    do
      if(iSysLogLevel >= 3)
        x_syslog(7, log_module_input_vdr, "vdr_class_get_instance done.");

    while((_Bool)0);
    return &this->$anon0.$anon0.input_plugin;
  }
}

// vdr_class_scr_tuning_step_cb
// file xine_input_vdr.c line 5901
static void vdr_class_scr_tuning_step_cb(void *data, struct xine_cfg_entry_s *cfg)
{
  struct vdr_input_class_s *class = (struct vdr_input_class_s *)data;
  class->scr_tuning_step = (double)cfg->num_value / 1000000.0;
}

// vdr_class_smooth_scr_tuning_cb
// file xine_input_vdr.c line 5909
static void vdr_class_smooth_scr_tuning_cb(void *data, struct xine_cfg_entry_s *cfg)
{
  struct vdr_input_class_s *class = (struct vdr_input_class_s *)data;
  class->smooth_scr_tuning = cfg->num_value;
}

// vdr_control_thread
// file xine_input_vdr.c line 3588
static void * vdr_control_thread(void *this_gen)
{
  struct vdr_input_plugin_s *this = (struct vdr_input_plugin_s *)this_gen;
  char line[8128l];
  signed int err;
  signed int counter = 100;
  do
    if(iSysLogLevel >= 3)
      x_syslog(7, log_module_input_vdr, "Control thread started");

  while((_Bool)0);
  for( ; !(bSymbolsFound == 0); counter = counter - 1)
  {
    if(!(counter >= 1))
      break;

    if(!(this->$anon0.$anon0.funcs.fe_control == ((void * (*)(struct frontend_s *, const char *))NULL)))
      break;

    xine_usec_sleep((unsigned int)(50 * 1000));
  }
  signed int return_value;
  if(!(this->osd_manager == ((struct osd_manager_s *)NULL)))
  {
    return_value=this->osd_manager->argb_supported(this->stream);
    if(!(return_value == 0))
    {
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_vdr, "ARGB OSD supported by video driver");

      puts_vdr(this, "INFO ARGBOSD\r\n");
    }

  }

  write_control(this, "CONFIG\r\n");
  while(!(this->control_running == 0))
  {
    line[(signed long int)0] = (char)0;
    pthread_testcancel();
    signed long int return_value_readline_control$1;
    return_value_readline_control$1=readline_control(this, line, sizeof(char [8128l]) /*8128ul*/  - (unsigned long int)1, -1);
    err = (signed int)return_value_readline_control$1;
    if(!(err >= 1))
    {
      if(!(err >= 0))
        break;

    }

    else
    {
      pthread_testcancel();
      if(this->control_running == 0)
        break;

      err=vdr_plugin_parse_control(&this->$anon0.iface, line);
      if(!(err == 0))
      {
        if(err == -1)
          goto __CPROVER_DUMP_L12;

        if(err == -2)
          goto __CPROVER_DUMP_L14;

        if(err == -3)
          goto __CPROVER_DUMP_L16;

      }

      else
      {
        goto __CPROVER_DUMP_L20;

      __CPROVER_DUMP_L12:
        ;
        do
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "unknown control message %s", (const void *)line);

        while((_Bool)0);
        goto __CPROVER_DUMP_L20;

      __CPROVER_DUMP_L14:
        ;
        do
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "invalid parameter in control message %s", (const void *)line);

        while((_Bool)0);
        goto __CPROVER_DUMP_L20;

      __CPROVER_DUMP_L16:
        ;
        do
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "control stream read error - disconnected ?");

        while((_Bool)0);
        this->control_running = 0;
        goto __CPROVER_DUMP_L20;
      }
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "parse_control failed with result: %d", err);

      while((_Bool)0);
    }

  __CPROVER_DUMP_L20:
    ;
  }
  if(!(this->control_running == 0))
    write_control(this, "CLOSE\r\n");

  this->control_running = 0;
  if(!(this->slave.stream == ((struct xine_stream_s *)NULL)))
    xine_stop(this->slave.stream);

  do
    if(iSysLogLevel >= 3)
      x_syslog(7, log_module_input_vdr, "Control thread terminated");

  while((_Bool)0);
  pthread_exit((void *)0);
}

// vdr_event_cb
// file xine_input_vdr.c line 3819
static void vdr_event_cb(void *user_data, const struct anonymous$22 *event)
{
  struct vdr_input_plugin_s *this = (struct vdr_input_plugin_s *)user_data;
  unsigned int i = (unsigned int)0;
  signed int return_value_strncmp$1;
  for( ; !((unsigned long int)i >= 57ul); i = i + 1u)
    if((unsigned int)event->type == vdr_keymap[(signed long int)i].event)
    {
      if(!(event->data == NULL))
      {
        if(event->data_length == 4)
        {
          return_value_strncmp$1=strncmp((const char *)event->data, "VDR", (unsigned long int)4);
          if(return_value_strncmp$1 == 0)
            goto __CPROVER_DUMP_L35;

        }

      }

      do
        if(iSysLogLevel >= 3)
          x_syslog(7, log_module_input_vdr, "XINE_EVENT (input) %d --> %s", event->type, (const void *)vdr_keymap[(signed long int)i].name);

      while((_Bool)0);
      if(this->fd_control >= 0)
        printf_control(this, "KEY %s\r\n", (const void *)vdr_keymap[(signed long int)i].name);

      if(!(this->$anon0.$anon0.funcs.xine_input_event == ((void (*)(struct frontend_s *, const char *, const char *))NULL)))
        this->$anon0.$anon0.funcs.xine_input_event(this->$anon0.$anon0.funcs.fe_handle, (const char *)(void *)0, vdr_keymap[(signed long int)i].name);

      goto __CPROVER_DUMP_L35;
    }

  struct anonymous$45 *data;
  struct anonymous$45 *vdr_event_cb$$1$$2$$2$$data;
  _Bool tmp_if_expr$2;
  switch(event->type)
  {
    case 3:
    {
      if(!(event->stream == this->slave.stream))
        goto __CPROVER_DUMP_L11;

      data = (struct anonymous$45 *)event->data;
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "XINE_EVENT_UI_SET_TITLE: %s", (const void *)data->str);

      while((_Bool)0);
      update_dvd_title_number(this);
      printf_vdr(this, "INFO TITLE %s\r\n", (const void *)data->str);
      break;
    }
    case 10:
    {

    __CPROVER_DUMP_L11:
      ;
      if(!(event->stream == this->slave.stream))
        goto __CPROVER_DUMP_L12;

      vdr_event_cb$$1$$2$$2$$data = (struct anonymous$45 *)event->data;
      dvd_menu_domain(this, (signed int)(vdr_event_cb$$1$$2$$2$$data->num_buttons > 0));
      printf_vdr(this, "INFO DVDBUTTONS %d\r\n", vdr_event_cb$$1$$2$$2$$data->num_buttons);
      break;
    }
    case 2:
    {

    __CPROVER_DUMP_L12:
      ;
      if(event->stream == this->slave.stream)
        slave_track_maps_changed(this);

      break;
    }
    case 5:
    {
      struct anonymous$46 *frame_change = (struct anonymous$46 *)event->data;
      if(frame_change->aspect == 0)
        this->osd_manager->video_size_changed(this->osd_manager, event->stream, frame_change->width, frame_change->height);

      break;
    }
    case 1:
    {
      if(event->stream == this->stream)
      {
        do
          if(iSysLogLevel >= 3)
            x_syslog(7, log_module_input_vdr, "XINE_EVENT_UI_PLAYBACK_FINISHED");

        while((_Bool)0);
        this->control_running = 0;
        if(iSysLogLevel >= 3)
        {
          struct xine_s$0 *xine = this->class->xine;
          signed int vdr_event_cb$$1$$2$$5$$2$$i;
          signed int j;
          signed int logs;
          logs=xine_get_log_section_count(xine);
          const char * const *names;
          names=xine_get_log_names(xine);
          vdr_event_cb$$1$$2$$5$$2$$i = 0;
          for( ; !(vdr_event_cb$$1$$2$$5$$2$$i >= logs); vdr_event_cb$$1$$2$$5$$2$$i = vdr_event_cb$$1$$2$$5$$2$$i + 1)
          {
            char * const *lines;
            lines=xine_get_log(xine, vdr_event_cb$$1$$2$$5$$2$$i);
            if(!(*lines == ((char *)NULL)))
            {
              printf("\nLOG: %s\n", names[(signed long int)vdr_event_cb$$1$$2$$5$$2$$i]);
              j = 0;
              do
              {
                if(!(lines[(signed long int)j] == ((char *)NULL)))
                  tmp_if_expr$2 = *lines[(signed long int)j] != 0 ? (_Bool)1 : (_Bool)0;

                else
                  tmp_if_expr$2 = (_Bool)0;
                if(!tmp_if_expr$2)
                  break;

                printf("  %2d: %s", j, lines[(signed long int)j]);
                j = j + 1;
              }
              while((_Bool)1);
            }

          }
        }

      }

      pthread_mutex_lock(&this->lock);
      if(event->stream == this->slave.stream)
      {
        do
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "XINE_EVENT_UI_PLAYBACK_FINISHED (slave stream)");

        while((_Bool)0);
        if(this->fd_control >= 0)
          write_control(this, "ENDOFSTREAM\r\n");

        else
          if(!(this->$anon0.$anon0.funcs.fe_control == ((void * (*)(struct frontend_s *, const char *))NULL)))
            this->$anon0.$anon0.funcs.fe_control(this->$anon0.$anon0.funcs.fe_handle, "ENDOFSTREAM\r\n");

      }

      else
        if(event->stream == this->bg_stream.stream)
        {
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_input_vdr, "XINE_EVENT_UI_PLAYBACK_FINISHED (background stream)");

          while((_Bool)0);
          xine_play(this->bg_stream.stream, 0, 0);
        }

      pthread_mutex_unlock(&this->lock);
    }
  }

__CPROVER_DUMP_L35:
  ;
}

// vdr_flush_engine
// file xine_input_vdr.c line 2062
static void vdr_flush_engine(struct vdr_input_plugin_s *this, unsigned long int discard_index)
{
  signed int return_value_pthread_mutex_trylock$1;
  return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&this->lock);
  if(return_value_pthread_mutex_trylock$1 == 0)
  {
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_vdr, "%s: assertion failed: lock %s unlocked !", (const void *)"vdr_flush_engine", (const void *)"this->lock");

    while((_Bool)0);
    pthread_mutex_unlock(&this->lock);
  }

  else
    if(!(this->stream_start == 0))
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "vdr_flush_engine: stream_start, flush skipped");

      while((_Bool)0);

    else
      if(!(discard_index >= this->curpos))
      {
        if(!(this->curpos >= this->guard_index))
        {
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_input_vdr, "vdr_flush_engine: guard > curpos, flush skipped");

          while((_Bool)0);
          goto __CPROVER_DUMP_L18;
        }

        do
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "vdr_flush_engine: %lu < current position %lu, flush skipped", discard_index, this->curpos);

        while((_Bool)0);
      }

      else
      {
        signed int return_value_xine_get_param$2;
        return_value_xine_get_param$2=xine_get_param(this->stream, 30);
        if(!(return_value_xine_get_param$2 >= 1))
        {
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_input_vdr, "vdr_flush_engine: playback is paused <0>");

          while((_Bool)0);
          xine_set_param(this->stream, 30, 1000000);
        }

        suspend_demuxer(this);
        reset_scr_tuning(this);
        signed int return_value_xine_get_param$3;
        return_value_xine_get_param$3=xine_get_param(this->stream, 30);
        if(!(return_value_xine_get_param$3 >= 1))
        {
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_input_vdr, "vdr_flush_engine: playback is paused <1>");

          while((_Bool)0);
          xine_set_param(this->stream, 30, 1000000);
        }

        this->stream->demux_plugin->seek(this->stream->demux_plugin, (signed long int)0, 0, (signed int)this->stream->demux_thread_running);
        _x_demux_control_start(this->stream);
        this->stream_start = (unsigned char)1;
        this->P_frames = (unsigned int)0;
        this->B_frames = this->P_frames;
        this->I_frames = this->B_frames;
        this->discard_index = discard_index;
        resume_demuxer(this);
      }

__CPROVER_DUMP_L18:
  ;
}

// vdr_plugin_dispose
// file xine_input_vdr.c line 5063
static void vdr_plugin_dispose(struct input_plugin_s$0 *this_gen)
{
  struct vdr_input_plugin_s *this = (struct vdr_input_plugin_s *)this_gen;
  signed int local;
  signed int fd = -1;
  signed int fc = -1;
  signed int return_value_pthread_cond_destroy$1;
  signed int return_value_pthread_mutex_destroy$2;
  signed int return_value_pthread_mutex_destroy$3;
  signed int return_value_pthread_mutex_destroy$4;
  signed int return_value_close$8;
  signed int *return_value___errno_location$5;
  char *return_value_strerror$6;
  signed int return_value_close$12;
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  if(!(this_gen == ((struct input_plugin_s$0 *)NULL)))
  {
    do
      if(iSysLogLevel >= 3)
        x_syslog(7, log_module_input_vdr, "vdr_plugin_dispose");

    while((_Bool)0);
    if(!(this->slave.stream == ((struct xine_stream_s *)NULL)))
      close_slave_stream(this);

    if(this->fd_control >= 0)
      write_control(this, "CLOSE\r\n");

    this->control_running = 0;
    local = (signed int)!(!(this->$anon0.$anon0.funcs.push_input_write != ((signed int (*)(struct vdr_input_plugin_if_s *, signed int, unsigned long int, const char *, signed int))NULL)));
    memset((void *)&this->$anon0.$anon0.funcs, 0, sizeof(struct vdr_input_plugin_funcs_s) /*64ul*/ );
    if(local == 0)
    {
      /* vdr_plugin_dispose::1::3::tag-linger */
struct linger
{
  // l_onoff
  signed int l_onoff;
  // l_linger
  signed int l_linger;
};

/* */
      ;
      struct linger l = { .l_onoff=0, .l_linger=0 };
      fd = this->fd_data;
      fc = this->fd_control;
      if(fc >= 0)
      {
        do
          if(iSysLogLevel >= 3)
            x_syslog(7, log_module_input_vdr, "Shutdown control");

        while((_Bool)0);
        setsockopt(fc, 1, 13, (const void *)&l, (unsigned int)sizeof(struct linger) /*8ul*/ );
        shutdown(fc, 2);
      }

      if(fd >= 0)
      {
        if(!(this->tcp == 0))
        {
          do
            if(iSysLogLevel >= 3)
              x_syslog(7, log_module_input_vdr, "Shutdown data");

          while((_Bool)0);
          setsockopt(fc, 1, 13, (const void *)&l, (unsigned int)sizeof(struct linger) /*8ul*/ );
          shutdown(fd, 2);
        }

      }

    }

    if(local == 0)
    {
      if(!(this->threads_initialized == 0))
      {
        void *p;
        do
          if(iSysLogLevel >= 3)
            x_syslog(7, log_module_input_vdr, "Cancel control thread ...");

        while((_Bool)0);
        pthread_join(this->control_thread, &p);
        do
          if(iSysLogLevel >= 3)
            x_syslog(7, log_module_input_vdr, "Threads joined");

        while((_Bool)0);
      }

    }

    do
      if(iSysLogLevel >= 3)
        x_syslog(7, log_module_input_vdr, "Disposing event queues");

    while((_Bool)0);
    if(!(this->event_queue == ((struct xine_event_queue_s *)NULL)))
    {
      xine_event_dispose_queue(this->event_queue);
      this->event_queue = (struct xine_event_queue_s *)(void *)0;
    }

    pthread_cond_broadcast(&this->engine_flushed);
    do
    {
      return_value_pthread_cond_destroy$1=pthread_cond_destroy(&this->engine_flushed);
      if(!(return_value_pthread_cond_destroy$1 == 16))
        break;

      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "engine_flushed signal busy !");

      while((_Bool)0);
      pthread_cond_broadcast(&this->engine_flushed);
      xine_usec_sleep((unsigned int)10);
    }
    while((_Bool)1);
    do
      if(iSysLogLevel >= 3)
        x_syslog(7, log_module_input_vdr, "Destroying mutexes");

    while((_Bool)0);
    do
    {
      return_value_pthread_mutex_destroy$2=pthread_mutex_destroy(&this->vdr_entry_lock);
      if(!(return_value_pthread_mutex_destroy$2 == 16))
        break;

      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "vdr_entry_lock busy ...");

      while((_Bool)0);
      pthread_mutex_lock(&this->vdr_entry_lock);
      pthread_mutex_unlock(&this->vdr_entry_lock);
    }
    while((_Bool)1);
    do
    {
      return_value_pthread_mutex_destroy$3=pthread_mutex_destroy(&this->lock);
      if(!(return_value_pthread_mutex_destroy$3 == 16))
        break;

      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "lock busy ...");

      while((_Bool)0);
      pthread_mutex_lock(&this->lock);
      pthread_mutex_unlock(&this->lock);
    }
    while((_Bool)1);
    do
    {
      return_value_pthread_mutex_destroy$4=pthread_mutex_destroy(&this->fd_control_lock);
      if(!(return_value_pthread_mutex_destroy$4 == 16))
        break;

      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "fd_control_lock busy ...");

      while((_Bool)0);
      pthread_mutex_lock(&this->fd_control_lock);
      pthread_mutex_unlock(&this->fd_control_lock);
    }
    while((_Bool)1);
    signal_buffer_pool_not_empty(this);
    signal_buffer_not_empty(this);
    if(local == 0)
    {
      do
        if(iSysLogLevel >= 3)
          x_syslog(7, log_module_input_vdr, "Closing data connection");

      while((_Bool)0);
      if(fd >= 0)
      {
        return_value_close$8=close(fd);
        if(!(return_value_close$8 == 0))
          do
            if(iSysLogLevel >= 1)
            {
              x_syslog(3, log_module_input_vdr, "close(fd_data) failed");
              signed int *return_value___errno_location$7;
              return_value___errno_location$7=__errno_location();
              if(!(*return_value___errno_location$7 == 0))
              {
                return_value___errno_location$5=__errno_location();
                return_value_strerror$6=strerror(*return_value___errno_location$5);
                x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 5159, return_value_strerror$6);
              }

            }

          while((_Bool)0);

      }

      do
        if(iSysLogLevel >= 3)
          x_syslog(7, log_module_input_vdr, "Closing control connection");

      while((_Bool)0);
      if(fc >= 0)
      {
        return_value_close$12=close(fc);
        if(!(return_value_close$12 == 0))
          do
            if(iSysLogLevel >= 1)
            {
              x_syslog(3, log_module_input_vdr, "close(fd_control) failed");
              signed int *return_value___errno_location$11;
              return_value___errno_location$11=__errno_location();
              if(!(*return_value___errno_location$11 == 0))
              {
                return_value___errno_location$9=__errno_location();
                return_value_strerror$10=strerror(*return_value___errno_location$9);
                x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 5163, return_value_strerror$10);
              }

            }

          while((_Bool)0);

      }

      this->fd_control = -1;
      this->fd_data = this->fd_control;
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "Connections closed.");

      while((_Bool)0);
    }

    if(!(this->osd_manager == ((struct osd_manager_s *)NULL)))
    {
      this->osd_manager->dispose(this->osd_manager, this->stream);
      this->osd_manager = (struct osd_manager_s *)(void *)0;
    }

    if(!(this->video_properties_saved == 0))
      set_video_properties(this, -1, -1, -1, -1, -1, -1, -1);

    signal_buffer_pool_not_empty(this);
    signal_buffer_not_empty(this);
    if(!(this->scr == ((struct adjustable_scr_s *)NULL)))
      this->scr->dispose(this->scr);

    if(!(this->metronom == ((struct xvdr_metronom_s *)NULL)))
      this->metronom->dispose(this->metronom);

    free((void *)this->mrl);
    if(!(this->udp_data == ((struct udp_data_s *)NULL)))
      free_udp_data(this->udp_data);

    do
      if(iSysLogLevel >= 3)
        x_syslog(7, log_module_input_vdr, "Disposing fifos");

    while((_Bool)0);
    flush_all_fifos(this, 1);
    if(!(this->block_buffer == ((struct fifo_buffer_s *)NULL)))
      this->block_buffer->dispose(this->block_buffer);

    if(!(this->hd_buffer == ((struct fifo_buffer_s *)NULL)))
      this->hd_buffer->dispose(this->hd_buffer);

    free((void *)this);
    do
      if(iSysLogLevel >= 3)
        x_syslog(7, log_module_input_vdr, "dispose done.");

    while((_Bool)0);
  }

}

// vdr_plugin_exec_osd_command
// file xine_input_vdr.c line 1964
static signed int vdr_plugin_exec_osd_command(struct vdr_input_plugin_if_s *this_if, struct osd_command_s *cmd)
{
  struct vdr_input_plugin_s *this = (struct vdr_input_plugin_s *)this_if;
  if(this->fd_control >= 0)
  {
    if(!(this->$anon0.$anon0.funcs.intercept_osd == ((signed int (*)(struct frontend_s *, struct osd_command_s *))NULL)))
    {
      signed int return_value;
      return_value=this->$anon0.$anon0.funcs.intercept_osd(this->$anon0.$anon0.funcs.fe_handle, cmd);
      return return_value != 0 ? 0 : -3;
    }

  }

  struct xine_stream_s *tmp_if_expr$1;
  if(!(this->slave.stream == ((struct xine_stream_s *)NULL)))
    tmp_if_expr$1 = this->slave.stream;

  else
    tmp_if_expr$1 = this->stream;
  signed int return_value_1;
  return_value_1=this->osd_manager->command(this->osd_manager, cmd, tmp_if_expr$1);
  return return_value_1;
}

// vdr_plugin_flush
// file xine_input_vdr.c line 2936
static signed int vdr_plugin_flush(struct vdr_input_plugin_s *this, signed int timeout_ms)
{
  struct timespec abstime;
  struct fifo_buffer_s *pool = this->buffer_pool;
  struct fifo_buffer_s *buffer = this->block_buffer;
  signed int result = 0;
  signed int waitresult = 0;
  signed int tmp_if_expr$1;
  signed int return_value_1;
  signed int tmp_if_expr$2;
  signed int return_value_3;
  signed int tmp_if_expr$3;
  signed int return_value_6;
  signed int tmp_if_expr$4;
  signed int return_value_8;
  if(!(this->slave.stream == ((struct xine_stream_s *)NULL)))
  {
    do
      if(iSysLogLevel >= 3)
        x_syslog(7, log_module_input_vdr, "vdr_plugin_flush: called while playing slave stream !");

    while((_Bool)0);
    return 0;
  }

  else
    if(!(this->live_mode == 0))
      return 1;

    else
    {
      this->class->xine->port_ticket->acquire(this->class->xine->port_ticket, 1);
      signed int return_value;
      return_value=pool->size(pool);
      if(!(return_value >= 0))
        tmp_if_expr$1 = 0;

      else
      {
        return_value_1=pool->size(pool);
        tmp_if_expr$1 = return_value_1;
      }
      signed int return_value_2;
      return_value_2=buffer->size(buffer);
      if(!(return_value_2 >= 0))
        tmp_if_expr$2 = 0;

      else
      {
        return_value_3=buffer->size(buffer);
        tmp_if_expr$2 = return_value_3;
      }
      signed int return_value_4;
      return_value_4=this->stream->video_out->get_property(this->stream->video_out, 17);
      result = tmp_if_expr$1 + tmp_if_expr$2 + return_value_4;
      this->class->xine->port_ticket->release(this->class->xine->port_ticket, 1);
      put_control_buf(buffer, pool, 0x010a0000);
      put_control_buf(buffer, pool, 0x01040000);
      if(!(result >= 1))
        return 0;

      else
      {
        create_timeout_time(&abstime, timeout_ms);
        if(result >= 1 && !(waitresult == 110))
        {
          pthread_mutex_lock(&pool->buffer_pool_mutex);
          waitresult=pthread_cond_timedwait(&pool->buffer_pool_cond_not_empty, &pool->buffer_pool_mutex, &abstime);
          pthread_mutex_unlock(&pool->buffer_pool_mutex);
          this->class->xine->port_ticket->acquire(this->class->xine->port_ticket, 1);
          signed int return_value_5;
          return_value_5=pool->size(pool);
          if(!(return_value_5 >= 0))
            tmp_if_expr$3 = 0;

          else
          {
            return_value_6=pool->size(pool);
            tmp_if_expr$3 = return_value_6;
          }
          signed int return_value_7;
          return_value_7=buffer->size(buffer);
          if(!(return_value_7 >= 0))
            tmp_if_expr$4 = 0;

          else
          {
            return_value_8=buffer->size(buffer);
            tmp_if_expr$4 = return_value_8;
          }
          signed int return_value_9;
          return_value_9=this->stream->video_out->get_property(this->stream->video_out, 17);
          result = tmp_if_expr$3 + tmp_if_expr$4 + return_value_9;
          this->class->xine->port_ticket->release(this->class->xine->port_ticket, 1);
        }

        return result;
      }
    }
}

// vdr_plugin_flush_remote
// file xine_input_vdr.c line 3010
static signed int vdr_plugin_flush_remote(struct vdr_input_plugin_s *this, signed int timeout_ms, unsigned long int offset, signed int frame)
{
  signed int r;
  signed int live_mode;
  pthread_mutex_lock(&this->lock);
  live_mode = (signed int)this->live_mode;
  this->live_mode = (unsigned char)0;
  reset_scr_tuning(this);
  for( ; !(this->curpos >= offset); timeout_ms = timeout_ms - 3)
  {
    if(!(timeout_ms >= 1))
      break;

    pthread_mutex_unlock(&this->lock);
    xine_usec_sleep((unsigned int)(3 * 1000));
    pthread_mutex_lock(&this->lock);
  }
  reset_scr_tuning(this);
  pthread_mutex_unlock(&this->lock);
  r=vdr_plugin_flush(this, 5 > timeout_ms ? 5 : timeout_ms);
  printf_control(this, "RESULT %d %d\r\n", this->token, r);
  pthread_mutex_lock(&this->lock);
  this->live_mode = (unsigned char)live_mode;
  this->stream->metronom->set_option(this->stream->metronom, 7, (signed long int)((4 * 90000) / 25));
  this->guard_index = offset;
  pthread_mutex_unlock(&this->lock);
  return 0;
}

// vdr_plugin_get_autoplay_list
// file xine_input_vdr.c line 6026
static const char * const * vdr_plugin_get_autoplay_list(struct input_class_s$1 *this_gen, signed int *num_files)
{
  struct vdr_input_class_s *this = (struct vdr_input_class_s *)this_gen;
  *num_files = 1;
  return (const char * const *)this->mrls;
}

// vdr_plugin_get_blocksize
// file xine_input_vdr.c line 5052
static unsigned int vdr_plugin_get_blocksize(struct input_plugin_s$0 *this_gen)
{
  return (unsigned int)2048;
}

// vdr_plugin_get_capabilities
// file xine_input_vdr.c line 5043
static unsigned int vdr_plugin_get_capabilities(struct input_plugin_s$0 *this_gen)
{
  return (unsigned int)0x00000002;
}

// vdr_plugin_get_current_pos
// file xine_input_vdr.c line 5057
static signed long int vdr_plugin_get_current_pos(struct input_plugin_s$0 *this_gen)
{
  struct vdr_input_plugin_s *this = (struct vdr_input_plugin_s *)this_gen;
  unsigned long int tmp_if_expr$1;
  if(!(this->curpos >= this->discard_index))
    tmp_if_expr$1 = this->discard_index;

  else
    tmp_if_expr$1 = this->curpos;
  return (signed long int)tmp_if_expr$1;
}

// vdr_plugin_get_length
// file xine_input_vdr.c line 5038
static signed long int vdr_plugin_get_length(struct input_plugin_s$0 *this_gen)
{
  return (signed long int)-1;
}

// vdr_plugin_get_mrl
// file xine_input_vdr.c line 5210
static const char * vdr_plugin_get_mrl(struct input_plugin_s$0 *this_gen)
{
  struct vdr_input_plugin_s *this = (struct vdr_input_plugin_s *)this_gen;
  return this->mrl;
}

// vdr_plugin_get_optional_data
// file xine_input_vdr.c line 5219
static signed int vdr_plugin_get_optional_data(struct input_plugin_s$0 *this_gen, void *data, signed int data_type)
{
  if(data_type == 10)
  {
    static const char demux_name[5l] = { 'x', 'v', 'd', 'r', 0 };
    *((const char **)data) = demux_name;
    return 1;
  }

  else
    return 0;
}

// vdr_plugin_open
// file xine_input_vdr.c line 5232
static signed int vdr_plugin_open(struct input_plugin_s$0 *this_gen)
{
  struct vdr_input_plugin_s *this = (struct vdr_input_plugin_s *)this_gen;
  struct xine_s$0 *xine = this->class->xine;
  struct cfg_entry_s *e;
  this->event_queue=xine_event_new_queue(this->stream);
  xine_event_create_listener_thread(this->event_queue, vdr_event_cb, (void *)this);
  this->buffer_pool = this->stream->video_fifo;
  this->reserved_buffers = (unsigned int)(this->buffer_pool->buffer_pool_capacity - 10);
  xine->config->update_num(xine->config, "audio.synchronization.av_sync_method", 1);
  this->scr=adjustable_scr_start(this->class->xine);
  if(this->scr == ((struct adjustable_scr_s *)NULL))
  {
    if(iSysLogLevel >= 2)
      x_syslog(6, log_module_input_vdr, "adjustable_scr_start() FAILED !");

  }

  this->scr_live_sync = (unsigned char)1;
  this->scr_tuning = (signed short int)0;
  this->curpos = (unsigned long int)0;
  this->metronom=xvdr_metronom_init(this->stream);
  this->block_buffer=fifo_buffer_new(this->stream, 4, (unsigned int)(0x10000 + 64));
  this->osd_manager=init_osd_manager();
  pthread_mutex_init(&this->lock, (const union anonymous$37 *)(void *)0);
  pthread_mutex_init(&this->vdr_entry_lock, (const union anonymous$37 *)(void *)0);
  pthread_mutex_init(&this->fd_control_lock, (const union anonymous$37 *)(void *)0);
  pthread_cond_init(&this->engine_flushed, (const union anonymous$37 *)(void *)0);
  if(iSysLogLevel >= 3)
    x_syslog(7, log_module_input_vdr, "xine_input_xvdr: revision %s", (const void *)module_revision);

  if(!(this->class->num_buffers_hd == 2500))
  {
    if(iSysLogLevel >= 2)
      x_syslog(6, log_module_input_vdr, "Using non-default \"media.xvdr.num_buffers_hd:%d\"", this->class->num_buffers_hd);

  }

  e=this->class->xine->config->lookup_entry(this->class->xine->config, "engine.buffers.audio_num_buffers");
  if(!(e == ((struct cfg_entry_s *)NULL)))
  {
    if(!(e->num_value >= 500))
    {
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_vdr, "WARNING: xine-engine setting \"engine.buffers.audio_num_buffers\":%d is too low for HD-playback! Please use values between 500-1000!", e->num_value);

    }

  }

  return 1;
}

// vdr_plugin_open_local
// file xine_input_vdr.c line 5288
static signed int vdr_plugin_open_local(struct input_plugin_s$0 *this_gen)
{
  do
    if(iSysLogLevel >= 3)
      x_syslog(7, log_module_input_vdr, "vdr_plugin_open_local");

  while((_Bool)0);
  signed int return_value_vdr_plugin_open$1;
  return_value_vdr_plugin_open$1=vdr_plugin_open(this_gen);
  return return_value_vdr_plugin_open$1;
}

// vdr_plugin_open_net
// file xine_input_vdr.c line 5755
static signed int vdr_plugin_open_net(struct input_plugin_s$0 *this_gen)
{
  struct vdr_input_plugin_s *this = (struct vdr_input_plugin_s *)this_gen;
  char tmpbuf[256l];
  signed int err;
  do
    if(iSysLogLevel >= 3)
      x_syslog(7, log_module_input_vdr, "vdr_plugin_open_net %s", this->mrl);

  while((_Bool)0);
  char *return_value___builtin_strchr$2;
  return_value___builtin_strchr$2=__builtin_strchr(this->mrl, 35);
  char *return_value___builtin_strchr$1;
  if(!(return_value___builtin_strchr$2 == ((char *)NULL)))
  {
    return_value___builtin_strchr$1=__builtin_strchr(this->mrl, 35);
    *return_value___builtin_strchr$1 = (char)0;
  }

  signed int return_value_strncasecmp$14;
  return_value_strncasecmp$14=strncasecmp(this->mrl, "xvdr+tcp://", (unsigned long int)(4 + 7));
  _Bool tmp_if_expr$15;
  if(return_value_strncasecmp$14 == 0)
  {
    this->tcp = (unsigned char)1;
    tmp_if_expr$15 = this->tcp != 0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr$15 = (_Bool)0;
  _Bool tmp_if_expr$18;
  signed int return_value_strncasecmp$16;
  _Bool tmp_if_expr$17;
  if(tmp_if_expr$15)
    tmp_if_expr$18 = (_Bool)1;

  else
  {
    return_value_strncasecmp$16=strncasecmp(this->mrl, "xvdr+udp://", (unsigned long int)(4 + 7));
    if(return_value_strncasecmp$16 == 0)
    {
      this->udp = (unsigned char)1;
      tmp_if_expr$17 = this->udp != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$17 = (_Bool)0;
    tmp_if_expr$18 = tmp_if_expr$17 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$21;
  signed int return_value_strncasecmp$19;
  _Bool tmp_if_expr$20;
  if(tmp_if_expr$18)
    tmp_if_expr$21 = (_Bool)1;

  else
  {
    return_value_strncasecmp$19=strncasecmp(this->mrl, "xvdr+rtp://", (unsigned long int)(4 + 7));
    if(return_value_strncasecmp$19 == 0)
    {
      this->rtp = (unsigned char)1;
      tmp_if_expr$20 = this->rtp != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$20 = (_Bool)0;
    tmp_if_expr$21 = tmp_if_expr$20 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$23;
  signed int return_value_strncasecmp$22;
  if(tmp_if_expr$21)
    tmp_if_expr$23 = (_Bool)1;

  else
  {
    return_value_strncasecmp$22=strncasecmp(this->mrl, "xvdr+pipe://", (unsigned long int)(4 + 8));
    tmp_if_expr$23 = !(return_value_strncasecmp$22 != 0) ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$25;
  signed int return_value_strncasecmp$24;
  if(tmp_if_expr$23)
    tmp_if_expr$25 = (_Bool)1;

  else
  {
    return_value_strncasecmp$24=strncasecmp(this->mrl, "xvdr://", (unsigned long int)(4 + 3));
    tmp_if_expr$25 = !(return_value_strncasecmp$24 != 0) ? (_Bool)1 : (_Bool)0;
  }
  char *tmp_post$6;
  signed int tmp_if_expr$8;
  signed int return_value_atoi$7;
  signed int *return_value___errno_location$9;
  char *return_value_strerror$10;
  signed long int return_value_read$12;
  signed long int return_value_read$13;
  if(tmp_if_expr$25)
  {
    char *phost;
    char *return_value_strstr$3;
    return_value_strstr$3=strstr(this->mrl, "//");
    char *return_value___strdup$4;
    return_value___strdup$4=__strdup(return_value_strstr$3 + (signed long int)2);
    phost = return_value___strdup$4;
    char host[256l];
    char *port;
    char *return_value___builtin_strchr$5;
    return_value___builtin_strchr$5=__builtin_strchr(phost, 58);
    port = return_value___builtin_strchr$5;
    signed int iport;
    signed int one = 1;
    if(!(port == ((char *)NULL)))
    {
      tmp_post$6 = port;
      port = port + 1l;
      *tmp_post$6 = (char)0;
    }

    if(!(port == ((char *)NULL)))
    {
      return_value_atoi$7=atoi(port);
      tmp_if_expr$8 = return_value_atoi$7;
    }

    else
      tmp_if_expr$8 = 37890;
    iport = tmp_if_expr$8;
    strn0cpy(host, phost, 254);
    free((void *)phost);
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_vdr, "Connecting (control) to tcp://%s:%d ...", (const void *)host, iport);

    while((_Bool)0);
    this->fd_control=connect_control_stream(this, host, iport, &this->client_id);
    if(!(this->fd_control >= 0))
    {
      do
        if(iSysLogLevel >= 1)
        {
          x_syslog(3, log_module_input_vdr, "Can't connect to tcp://%s:%d", (const void *)host, iport);
          signed int *return_value___errno_location$11;
          return_value___errno_location$11=__errno_location();
          if(!(*return_value___errno_location$11 == 0))
          {
            return_value___errno_location$9=__errno_location();
            return_value_strerror$10=strerror(*return_value___errno_location$9);
            x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 5789, return_value_strerror$10);
          }

        }

      while((_Bool)0);
      return 0;
    }

    setsockopt(this->fd_control, 6, 1, (const void *)&one, (unsigned int)sizeof(signed int) /*4ul*/ );
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_vdr, "Connected (control) to tcp://%s:%d", (const void *)host, iport);

    while((_Bool)0);
    if(this->tcp == 0)
    {
      if(this->udp == 0)
      {
        if(this->rtp == 0)
        {
          this->fd_data=connect_pipe_data_stream(this);
          if(!(this->fd_data >= 0))
            do
              if(iSysLogLevel >= 2)
                x_syslog(6, log_module_input_vdr, "Data stream connection failed (PIPE)");

            while((_Bool)0);

          else
          {
            this->rtp = (unsigned char)0;
            this->udp = this->rtp;
            this->tcp = this->udp;
            do
              if(iSysLogLevel >= 2)
                x_syslog(6, log_module_input_vdr, "Data stream connected (PIPE)");

            while((_Bool)0);
          }
        }

      }

    }

    if(!(this->fd_data >= 0))
    {
      if(!(this->rtp == 0))
      {
        do
        {
          return_value_read$12=read(this->fd_control, (void *)tmpbuf, (unsigned long int)255);
          if(!(return_value_read$12 >= 1l))
            break;

        }
        while((_Bool)1);
        this->fd_data=connect_rtp_data_stream(this);
        if(!(this->fd_data >= 0))
        {
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_input_vdr, "Data stream connection failed (RTP)");

          while((_Bool)0);
          this->rtp = (unsigned char)0;
        }

        else
        {
          this->rtp = (unsigned char)1;
          this->udp = (unsigned char)0;
          this->tcp = this->udp;
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_input_vdr, "Data stream connected (RTP)");

          while((_Bool)0);
        }
      }

    }

    if(!(this->fd_data >= 0))
    {
      if(this->tcp == 0)
      {
        do
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "Connecting (data) to udp://%s ...", (const void *)host);

        while((_Bool)0);
        do
        {
          return_value_read$13=read(this->fd_control, (void *)tmpbuf, (unsigned long int)255);
          if(!(return_value_read$13 >= 1l))
            break;

        }
        while((_Bool)1);
        this->fd_data=connect_udp_data_stream(this);
        if(!(this->fd_data >= 0))
        {
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_input_vdr, "Data stream connection failed (UDP)");

          while((_Bool)0);
          this->udp = (unsigned char)0;
        }

        else
        {
          this->udp = (unsigned char)1;
          this->rtp = (unsigned char)0;
          this->tcp = this->rtp;
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_input_vdr, "Data stream connected (UDP)");

          while((_Bool)0);
        }
      }

    }

    if(!(this->fd_data >= 0))
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "Connecting (data) to tcp://%s:%d ...", (const void *)host, iport);

      while((_Bool)0);
      this->tcp = (unsigned char)0;
      this->fd_data=connect_tcp_data_stream(this, host, iport);
      if(!(this->fd_data >= 0))
      {
        do
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "Data stream connection failed (TCP)");

        while((_Bool)0);
        this->tcp = (unsigned char)0;
      }

      else
        this->tcp = (unsigned char)1;
      if(!(this->tcp == 0))
      {
        this->udp = (unsigned char)0;
        this->rtp = this->udp;
        do
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "Data stream connected (TCP)");

        while((_Bool)0);
      }

      else
      {
        close(this->fd_data);
        close(this->fd_control);
        this->fd_data = -1;
        this->fd_control = this->fd_data;
        return 0;
      }
    }

  }

  else
  {
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_vdr, "Unknown mrl (%s)", this->mrl);

    while((_Bool)0);
    return 0;
  }
  signed int return_value_vdr_plugin_open$26;
  return_value_vdr_plugin_open$26=vdr_plugin_open(this_gen);
  signed int *return_value___errno_location$27;
  char *return_value_strerror$28;
  if(return_value_vdr_plugin_open$26 == 0)
    return 0;

  else
  {
    queue_nosignal(this);
    this->control_running = 1;
    err=pthread_create(&this->control_thread, (const union pthread_attr_t *)(void *)0, vdr_control_thread, (void *)this);
    if(!(err == 0))
    {
      do
        if(iSysLogLevel >= 1)
        {
          x_syslog(3, log_module_input_vdr, "Can't create new thread");
          signed int *return_value___errno_location$29;
          return_value___errno_location$29=__errno_location();
          if(!(*return_value___errno_location$29 == 0))
          {
            return_value___errno_location$27=__errno_location();
            return_value_strerror$28=strerror(*return_value___errno_location$27);
            x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 5877, return_value_strerror$28);
          }

        }

      while((_Bool)0);
      return 0;
    }

    else
    {
      this->class->xine->port_ticket->acquire(this->class->xine->port_ticket, 1);
      unsigned int return_value;
      return_value=this->stream->video_out->get_capabilities(this->stream->video_out);
      if((16u & return_value) == 0u)
      {
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "WARNING: Video output driver reports it does not support unscaled overlays !");

      }

      this->class->xine->port_ticket->release(this->class->xine->port_ticket, 1);
      this->threads_initialized = (unsigned char)1;
      return 1;
    }
  }
}

// vdr_plugin_parse_control
// file xine_input_vdr.c line 3062
static signed int vdr_plugin_parse_control(struct vdr_input_plugin_if_s *this_if, const char *cmd)
{
  struct vdr_input_plugin_s *this = (struct vdr_input_plugin_s *)this_if;
  signed int err = 0;
  signed int tmp32 = 0;
  unsigned long int tmp64 = 0ULL;
  struct xine_stream_s *stream = this->stream;
  char *pt;
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  do
  {
    signed int return_value_pthread_mutex_lock$4;
    return_value_pthread_mutex_lock$4=pthread_mutex_lock(&this->vdr_entry_lock);
    if(!(return_value_pthread_mutex_lock$4 == 0))
    {
      do
        if(iSysLogLevel >= 1)
        {
          x_syslog(3, log_module_input_vdr, "%s:%d: pthread_mutex_lock failed", (const void *)"vdr_plugin_parse_control", 3072);
          signed int *return_value___errno_location$3;
          return_value___errno_location$3=__errno_location();
          if(!(*return_value___errno_location$3 == 0))
          {
            return_value___errno_location$1=__errno_location();
            return_value_strerror$2=strerror(*return_value___errno_location$1);
            x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 3072, return_value_strerror$2);
          }

        }

      while((_Bool)0);
      return -3;
    }

  }
  while((_Bool)0);
  signed int return_value_memcmp$10;
  static const char str_poll[5l] = { 'P', 'O', 'L', 'L', 0 };
  return_value_memcmp$10=memcmp((const void *)cmd, (const void *)str_poll, (unsigned long int)4);
  _Bool tmp_if_expr$12;
  signed int return_value_strncasecmp$11;
  if(return_value_memcmp$10 == 0)
    tmp_if_expr$12 = (_Bool)1;

  else
  {
    return_value_strncasecmp$11=strncasecmp(cmd, "POLL ", (unsigned long int)5);
    tmp_if_expr$12 = !(return_value_strncasecmp$11 != 0) ? (_Bool)1 : (_Bool)0;
  }
  signed int *return_value___errno_location$6;
  char *return_value_strerror$7;
  signed int return_value_strncasecmp$102;
  signed int return_value_strncasecmp$101;
  signed int return_value_strncasecmp$100;
  signed int return_value_strncasecmp$99;
  signed int return_value_strncasecmp$98;
  signed int tmp_statement_expression$17;
  struct xine_stream_s *tmp_if_expr$16;
  signed int return_value_strncasecmp$97;
  signed int return_value_strncasecmp$96;
  signed int return_value_strncasecmp$95;
  signed int return_value_strncasecmp$94;
  signed int return_value_strncasecmp$93;
  signed int return_value_strncasecmp$92;
  signed int return_value_strncasecmp$91;
  signed int return_value_strncasecmp$90;
  signed int return_value_sscanf$28;
  signed int return_value_strncasecmp$89;
  signed int return_value_strncasecmp$88;
  signed int return_value_strncasecmp$87;
  signed int return_value_strncasecmp$86;
  signed int return_value_strncasecmp$85;
  signed int return_value_strncasecmp$84;
  signed int return_value_strncasecmp$83;
  signed int return_value_strncasecmp$82;
  signed int return_value__x_get_audio_channel$38;
  signed int return_value_strncasecmp$81;
  _Bool tmp_if_expr$43;
  signed int return_value_strncmp$42;
  _Bool tmp_if_expr$45;
  signed int return_value_strncmp$44;
  char *return_value_strstr$49;
  signed int return_value_sscanf$48;
  signed int return_value_is_lang_code$47;
  signed int return_value_is_lang_code$46;
  _Bool tmp_if_expr$51;
  signed int return_value__x_get_spu_channel$52;
  signed int return_value_strncasecmp$80;
  signed int return_value_strncasecmp$79;
  signed int return_value_strncasecmp$78;
  signed int return_value_strncasecmp$77;
  signed int return_value_strncasecmp$76;
  signed int return_value_strncasecmp$75;
  signed int return_value_strncasecmp$74;
  signed int return_value_strncasecmp$73;
  signed int return_value_strncasecmp$72;
  signed int return_value_atoi$57;
  signed int return_value_atoi$58;
  signed int return_value_atoi$59;
  signed int return_value_strncasecmp$71;
  signed int return_value_strncasecmp$70;
  signed int return_value_strncasecmp$69;
  signed int return_value_strncasecmp$68;
  signed int return_value_strncasecmp$67;
  signed int return_value_strncasecmp$66;
  signed int return_value_strncasecmp$65;
  signed int return_value_strncasecmp$64;
  signed int return_value_strncasecmp$63;
  signed int *return_value___errno_location$104;
  char *return_value_strerror$105;
  if(tmp_if_expr$12)
  {
    tmp32=atoi(cmd + (signed long int)5);
    if(tmp32 >= 0 && !(tmp32 >= 1000))
    {
      if(this->fd_control >= 0)
      {
        signed int return_value_vdr_plugin_poll$5;
        return_value_vdr_plugin_poll$5=vdr_plugin_poll(this, tmp32);
        printf_control(this, "POLL %d\r\n", return_value_vdr_plugin_poll$5);
      }

      else
        err=vdr_plugin_poll(this, tmp32);
    }

    else
      err = -2;
    do
    {
      signed int return_value_pthread_mutex_unlock$9;
      return_value_pthread_mutex_unlock$9=pthread_mutex_unlock(&this->vdr_entry_lock);
      if(!(return_value_pthread_mutex_unlock$9 == 0))
        do
          if(iSysLogLevel >= 1)
          {
            x_syslog(3, log_module_input_vdr, "%s:%d: pthread_mutex_unlock failed", (const void *)"vdr_plugin_parse_control", 3088);
            signed int *return_value___errno_location$8;
            return_value___errno_location$8=__errno_location();
            if(!(*return_value___errno_location$8 == 0))
            {
              return_value___errno_location$6=__errno_location();
              return_value_strerror$7=strerror(*return_value___errno_location$6);
              x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 3088, return_value_strerror$7);
            }

          }

        while((_Bool)0);

    }
    while((_Bool)0);
    return err;
  }

  else
  {
    if(!(this->slave.stream == ((struct xine_stream_s *)NULL)))
      stream = this->slave.stream;

    pt=strstr(cmd, "\r\n");
    if(!(pt == ((char *)NULL)))
      *((char *)pt) = (char)0;

    do
      if(iSysLogLevel >= 4)
        x_syslog(7, log_module_input_vdr, "<control> %s", cmd);

    while((_Bool)0);
    signed int return_value_strncasecmp$103;
    return_value_strncasecmp$103=strncasecmp(cmd, "OSDCMD", (unsigned long int)6);
    if(return_value_strncasecmp$103 == 0)
      err=handle_control_osdcmd(this);

    else
    {
      return_value_strncasecmp$102=strncasecmp(cmd, "VIDEO_PROPERTIES ", (unsigned long int)17);
      if(return_value_strncasecmp$102 == 0)
      {
        signed int hue;
        signed int saturation;
        signed int brightness;
        signed int sharpness;
        signed int noise_reduction;
        signed int contrast;
        signed int vo_aspect_ratio;
        signed int return_value_sscanf$13;
        return_value_sscanf$13=sscanf(cmd + (signed long int)17, "%d %d %d %d %d %d %d", &hue, &saturation, &brightness, &sharpness, &noise_reduction, &contrast, &vo_aspect_ratio);
        if(return_value_sscanf$13 == 7)
          err=set_video_properties(this, hue, saturation, brightness, sharpness, noise_reduction, contrast, vo_aspect_ratio);

        else
          err = -2;
      }

      else
      {
        return_value_strncasecmp$101=strncasecmp(cmd, "OVERSCAN ", (unsigned long int)9);
        if(return_value_strncasecmp$101 == 0)
        {
          if(this->$anon0.$anon0.funcs.fe_control == ((void * (*)(struct frontend_s *, const char *))NULL))
            do
              if(iSysLogLevel >= 2)
                x_syslog(6, log_module_input_vdr, "No fe_control function! %s failed.", cmd);

            while((_Bool)0);

          else
            this->$anon0.$anon0.funcs.fe_control(this->$anon0.$anon0.funcs.fe_handle, cmd);
        }

        else
        {
          return_value_strncasecmp$100=strncasecmp(cmd, "VO_ASPECT ", (unsigned long int)10);
          if(return_value_strncasecmp$100 == 0)
          {
            signed int return_value_sscanf$14;
            return_value_sscanf$14=sscanf(cmd + (signed long int)10, "%d", &tmp32);
            if(return_value_sscanf$14 == 1)
              xine_set_param(stream, 0x01000001, tmp32);

            else
              err = -2;
          }

          else
          {
            return_value_strncasecmp$99=strncasecmp(cmd, "DEINTERLACE ", (unsigned long int)12);
            if(return_value_strncasecmp$99 == 0)
            {
              if(!(this->fd_control >= 0))
                err=set_deinterlace_method(this, cmd + (signed long int)12);

            }

            else
            {
              return_value_strncasecmp$98=strncasecmp(cmd, "EVENT ", (unsigned long int)6);
              if(return_value_strncasecmp$98 == 0)
              {
                unsigned int vdr_plugin_parse_control$$1$$9$$i;
                char *vdr_plugin_parse_control$$1$$9$$pt;
                char *return_value___builtin_strchr$15;
                return_value___builtin_strchr$15=__builtin_strchr(cmd, 10);
                vdr_plugin_parse_control$$1$$9$$pt = return_value___builtin_strchr$15;
                if(!(vdr_plugin_parse_control$$1$$9$$pt == ((char *)NULL)))
                  *vdr_plugin_parse_control$$1$$9$$pt = (char)0;

                vdr_plugin_parse_control$$1$$9$$pt=strstr(cmd + (signed long int)6, " CHAPTER");
                if(!(vdr_plugin_parse_control$$1$$9$$pt == ((char *)NULL)))
                {
                  *vdr_plugin_parse_control$$1$$9$$pt = (char)0;
                  this->class->xine->config->update_num(this->class->xine->config, "media.dvd.skip_behaviour", 1);
                  this->class->xine->config->update_num(this->class->xine->config, "media.bluray.skip_behaviour", 0);
                }

                vdr_plugin_parse_control$$1$$9$$pt=strstr(cmd + (signed long int)6, " TITLE");
                if(!(vdr_plugin_parse_control$$1$$9$$pt == ((char *)NULL)))
                {
                  *vdr_plugin_parse_control$$1$$9$$pt = (char)0;
                  this->class->xine->config->update_num(this->class->xine->config, "media.dvd.skip_behaviour", 2);
                  this->class->xine->config->update_num(this->class->xine->config, "media.bluray.skip_behaviour", 1);
                }

                vdr_plugin_parse_control$$1$$9$$i = (unsigned int)0;
                for( ; !((unsigned long int)vdr_plugin_parse_control$$1$$9$$i >= 12ul); vdr_plugin_parse_control$$1$$9$$i = vdr_plugin_parse_control$$1$$9$$i + 1u)
                {
                  unsigned long int __s1_len;
                  unsigned long int __s2_len;
                  signed int return_value___builtin_strcmp$18;
                  return_value___builtin_strcmp$18=__builtin_strcmp(cmd + (signed long int)6, eventmap[(signed long int)vdr_plugin_parse_control$$1$$9$$i].name);
                  tmp_statement_expression$17 = return_value___builtin_strcmp$18;
                  if(tmp_statement_expression$17 == 0)
                  {
                    struct anonymous$22 ev;
                    if(!(this->slave.stream == ((struct xine_stream_s *)NULL)))
                      tmp_if_expr$16 = this->slave.stream;

                    else
                      tmp_if_expr$16 = this->stream;
                    ev = (struct anonymous$22){ .stream=tmp_if_expr$16, .data=(void *)"VDR", .data_length=4,
    .type=(signed int)eventmap[(signed long int)vdr_plugin_parse_control$$1$$9$$i].type, .tv={ .tv_sec=0l, .tv_usec=0l } };
                    xine_event_send(ev.stream, &ev);
                    break;
                  }

                }
              }

              else
              {
                return_value_strncasecmp$97=strncasecmp(cmd, "VERSION ", (unsigned long int)7);
                if(return_value_strncasecmp$97 == 0)
                {
                  unsigned long int return_value_strlen$19;
                  return_value_strlen$19=strlen("2.0.0-cvs");
                  signed int return_value_strncmp$20;
                  return_value_strncmp$20=strncmp("2.0.0-cvs ", cmd + (signed long int)8, return_value_strlen$19 + (unsigned long int)1);
                  if(!(return_value_strncmp$20 == 0))
                  {
                    if(!(this->fd_control >= 0))
                    {
                      do
                        if(iSysLogLevel >= 2)
                          x_syslog(6, log_module_input_vdr, "WARNING! xineplug_inp_xvdr.so and libvdr-xineliboutput.so are from different version (%s and %s)", (const void *)"2.0.0-cvs", cmd + (signed long int)8);

                      while((_Bool)0);
                      do
                        if(iSysLogLevel >= 2)
                          x_syslog(6, log_module_input_vdr, "Re-install plugin !");

                      while((_Bool)0);
                    }

                  }

                }

                else
                {
                  return_value_strncasecmp$96=strncasecmp(cmd, "HDMODE ", (unsigned long int)7);
                  if(return_value_strncasecmp$96 == 0)
                  {
                    signed int return_value_sscanf$21;
                    return_value_sscanf$21=sscanf(cmd + (signed long int)7, "%d", &tmp32);
                    if(return_value_sscanf$21 == 1)
                    {
                      pthread_mutex_lock(&this->lock);
                      if(!(tmp32 == 0))
                      {
                        if(this->hd_stream == 0)
                        {
                          struct cfg_entry_s *e;
                          e=this->class->xine->config->lookup_entry(this->class->xine->config, "engine.buffers.video_num_frames");
                          if(!(e == ((struct cfg_entry_s *)NULL)))
                          {
                            if(!(e->num_value >= 32))
                            {
                              if(iSysLogLevel >= 2)
                                x_syslog(6, log_module_input_vdr, "WARNING: xine-engine setting \"engine.buffers.video_num_frames\":%d is too small for some HD channels", e->num_value);

                            }

                          }

                        }

                      }

                      if(!(tmp32 == 0))
                      {
                        if(this->hd_buffer == ((struct fifo_buffer_s *)NULL))
                          this->hd_buffer=fifo_buffer_new(this->stream, this->class->num_buffers_hd, (unsigned int)(2048 + 64));

                        this->hd_stream = (unsigned char)1;
                      }

                      else
                        this->hd_stream = (unsigned char)0;
                      set_buffer_limits(this);
                      pthread_mutex_unlock(&this->lock);
                    }

                  }

                  else
                  {
                    return_value_strncasecmp$95=strncasecmp(cmd, "NOVIDEO ", (unsigned long int)8);
                    if(return_value_strncasecmp$95 == 0)
                    {
                      signed int return_value_sscanf$22;
                      return_value_sscanf$22=sscanf(cmd + (signed long int)8, "%d", &tmp32);
                      if(return_value_sscanf$22 == 1)
                      {
                        pthread_mutex_lock(&this->lock);
                        this->no_video = (unsigned char)tmp32;
                        set_buffer_limits(this);
                        pthread_mutex_unlock(&this->lock);
                      }

                      else
                        err = -2;
                      signal_buffer_pool_not_empty(this);
                    }

                    else
                    {
                      return_value_strncasecmp$94=strncasecmp(cmd, "DISCARD ", (unsigned long int)8);
                      if(return_value_strncasecmp$94 == 0)
                      {
                        signed int return_value_sscanf$23;
                        return_value_sscanf$23=sscanf(cmd + (signed long int)8, "%lu %d", &tmp64, &tmp32);
                        if(return_value_sscanf$23 == 2)
                        {
                          pthread_mutex_lock(&this->lock);
                          if(!(this->discard_index >= tmp64))
                          {
                            this->discard_frame = (unsigned int)tmp32;
                            vdr_flush_engine(this, tmp64);
                            this->discard_index = tmp64;
                          }

                          else
                            if(!(this->discard_index == tmp64))
                              do
                                if(iSysLogLevel >= 2)
                                  x_syslog(6, log_module_input_vdr, "Ignoring delayed control message %s", cmd);

                              while((_Bool)0);

                          pthread_cond_broadcast(&this->engine_flushed);
                          pthread_mutex_unlock(&this->lock);
                        }

                        else
                          err = -2;
                      }

                      else
                      {
                        return_value_strncasecmp$93=strncasecmp(cmd, "STREAMPOS ", (unsigned long int)10);
                        if(return_value_strncasecmp$93 == 0)
                        {
                          signed int return_value_sscanf$24;
                          return_value_sscanf$24=sscanf(cmd + (signed long int)10, "%lu", &tmp64);
                          if(return_value_sscanf$24 == 1)
                          {
                            pthread_mutex_lock(&this->lock);
                            vdr_flush_engine(this, tmp64);
                            this->curpos = tmp64;
                            this->discard_index = this->curpos;
                            this->guard_index = (unsigned long int)0;
                            pthread_mutex_unlock(&this->lock);
                          }

                          else
                            err = -2;
                        }

                        else
                        {
                          return_value_strncasecmp$92=strncasecmp(cmd, "TRICKSPEED ", (unsigned long int)11);
                          if(return_value_strncasecmp$92 == 0)
                          {
                            signed int return_value_sscanf$26;
                            return_value_sscanf$26=sscanf(cmd + (signed long int)11, "%d", &tmp32);
                            if(return_value_sscanf$26 == 1)
                            {
                              pthread_mutex_lock(&this->lock);
                              char *return_value_strstr$25;
                              return_value_strstr$25=strstr(cmd + (signed long int)11, "Back");
                              set_trick_speed(this, tmp32, (signed int)!(!(return_value_strstr$25 != ((char *)NULL))));
                              pthread_mutex_unlock(&this->lock);
                            }

                            else
                              err = -2;
                          }

                          else
                          {
                            return_value_strncasecmp$91=strncasecmp(cmd, "STILL ", (unsigned long int)6);
                            if(return_value_strncasecmp$91 == 0)
                            {
                              signed int return_value_sscanf$27;
                              return_value_sscanf$27=sscanf(cmd + (signed long int)6, "%d", &tmp32);
                              if(return_value_sscanf$27 == 1)
                              {
                                pthread_mutex_lock(&this->lock);
                                set_still_mode(this, tmp32);
                                pthread_mutex_unlock(&this->lock);
                              }

                              else
                                err = -2;
                            }

                            else
                            {
                              return_value_strncasecmp$90=strncasecmp(cmd, "SCR ", (unsigned long int)4);
                              if(return_value_strncasecmp$90 == 0)
                              {
                                pthread_mutex_lock(&this->lock);
                                signed int return_value_sscanf$29;
                                return_value_sscanf$29=sscanf(cmd, "SCR Sync %d", &tmp32);
                                if(return_value_sscanf$29 == 1)
                                {
                                  this->scr_live_sync = (unsigned char)1;
                                  this->scr->set_speed_base(this->scr, tmp32);
                                }

                                else
                                {
                                  return_value_sscanf$28=sscanf(cmd, "SCR NoSync %d", &tmp32);
                                  if(return_value_sscanf$28 == 1)
                                  {
                                    this->scr_live_sync = (unsigned char)0;
                                    this->scr->set_speed_base(this->scr, tmp32);
                                    reset_scr_tuning(this);
                                  }

                                }
                                pthread_mutex_unlock(&this->lock);
                              }

                              else
                              {
                                return_value_strncasecmp$89=strncasecmp(cmd, "LIVE ", (unsigned long int)5);
                                if(return_value_strncasecmp$89 == 0)
                                {
                                  signed int return_value_sscanf$30;
                                  return_value_sscanf$30=sscanf(cmd + (signed long int)5, "%d", &tmp32);
                                  if(return_value_sscanf$30 == 1)
                                  {
                                    pthread_mutex_lock(&this->lock);
                                    set_live_mode(this, tmp32);
                                    pthread_mutex_unlock(&this->lock);
                                  }

                                  else
                                    err = -2;
                                }

                                else
                                {
                                  return_value_strncasecmp$88=strncasecmp(cmd, "MASTER ", (unsigned long int)7);
                                  if(return_value_strncasecmp$88 == 0)
                                  {
                                    signed int return_value_sscanf$31;
                                    return_value_sscanf$31=sscanf(cmd + (signed long int)7, "%d", &tmp32);
                                    if(return_value_sscanf$31 == 1)
                                      this->fixed_scr = (unsigned char)!(!(tmp32 != 0));

                                    else
                                      err = -2;
                                  }

                                  else
                                  {
                                    return_value_strncasecmp$87=strncasecmp(cmd, "VOLUME ", (unsigned long int)7);
                                    if(return_value_strncasecmp$87 == 0)
                                    {
                                      signed int return_value_sscanf$33;
                                      return_value_sscanf$33=sscanf(cmd + (signed long int)7, "%d", &tmp32);
                                      if(return_value_sscanf$33 == 1)
                                      {
                                        signed int sw;
                                        char *return_value_strstr$32;
                                        return_value_strstr$32=strstr(cmd, "SW");
                                        sw = (signed int)!(!(return_value_strstr$32 != ((char *)NULL)));
                                        if(sw == 0)
                                        {
                                          xine_set_param(stream, 6, tmp32);
                                          xine_set_param(stream, 7, tmp32 <= 0 ? 1 : 0);
                                        }

                                        else
                                        {
                                          xine_set_param(stream, 9, tmp32);
                                          xine_set_param(stream, 29, tmp32 <= 0 ? 1 : 0);
                                        }
                                        if(!(sw == (signed int)this->sw_volume_control))
                                        {
                                          this->sw_volume_control = (unsigned char)sw;
                                          if(!(sw == 0))
                                          {
                                            tmp32=xine_get_param(stream, 6);
                                            xine_set_param(stream, 6, tmp32);
                                            xine_set_param(stream, 7, 0);
                                          }

                                          else
                                          {
                                            xine_set_param(stream, 9, 100);
                                            xine_set_param(stream, 29, 0);
                                          }
                                        }

                                      }

                                      else
                                        err = -2;
                                    }

                                    else
                                    {
                                      return_value_strncasecmp$86=strncasecmp(cmd, "AUDIOCOMPRESSION ", (unsigned long int)17);
                                      if(return_value_strncasecmp$86 == 0)
                                      {
                                        signed int return_value_sscanf$34;
                                        return_value_sscanf$34=sscanf(cmd + (signed long int)17, "%d", &tmp32);
                                        if(return_value_sscanf$34 == 1)
                                          xine_set_param(stream, 8, tmp32);

                                        else
                                          err = -2;
                                      }

                                      else
                                      {
                                        return_value_strncasecmp$85=strncasecmp(cmd, "AUDIOSURROUND ", (unsigned long int)14);
                                        if(return_value_strncasecmp$85 == 0)
                                        {
                                          signed int return_value_sscanf$35;
                                          return_value_sscanf$35=sscanf(cmd + (signed long int)14, "%d", &tmp32);
                                          if(return_value_sscanf$35 == 1)
                                            this->class->xine->config->update_num(this->class->xine->config, "audio.a52.surround_downmix", tmp32 != 0 ? 1 : 0);

                                          else
                                            err = -2;
                                        }

                                        else
                                        {
                                          return_value_strncasecmp$84=strncasecmp(cmd, "SPEAKERS ", (unsigned long int)9);
                                          if(return_value_strncasecmp$84 == 0)
                                          {
                                            signed int return_value_sscanf$36;
                                            return_value_sscanf$36=sscanf(cmd + (signed long int)9, "%d", &tmp32);
                                            if(return_value_sscanf$36 == 1)
                                            {
                                              if(!(this->fd_control >= 0))
                                                this->class->xine->config->update_num(this->class->xine->config, "audio.output.speaker_arrangement", tmp32);

                                            }

                                            else
                                              err = -2;
                                          }

                                          else
                                          {
                                            return_value_strncasecmp$83=strncasecmp(cmd, "EQUALIZER ", (unsigned long int)10);
                                            if(return_value_strncasecmp$83 == 0)
                                            {
                                              signed int eqs[11l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
                                              signed int i;
                                              signed int j;
                                              sscanf(cmd + (signed long int)10, "%d %d %d %d %d %d %d %d %d %d", (const void *)eqs, eqs + (signed long int)1, eqs + (signed long int)2, eqs + (signed long int)3, eqs + (signed long int)4, eqs + (signed long int)5, eqs + (signed long int)6, eqs + (signed long int)7, eqs + (signed long int)8, eqs + (signed long int)9);
                                              i = 18;
                                              j = 0;
                                              for( ; !(i >= 28); j = j + 1)
                                              {
                                                xine_set_param(stream, i, eqs[(signed long int)j]);
                                                i = i + 1;
                                              }
                                            }

                                            else
                                            {
                                              return_value_strncasecmp$82=strncasecmp(cmd, "AUDIOSTREAM ", (unsigned long int)12);
                                              if(return_value_strncasecmp$82 == 0)
                                              {
                                                if(!(this->slave.stream == ((struct xine_stream_s *)NULL)))
                                                {
                                                  signed int return_value_sscanf$37;
                                                  return_value_sscanf$37=sscanf(cmd + (signed long int)12, "AC3 %d", &tmp32);
                                                  if(return_value_sscanf$37 == 1)
                                                  {
                                                    tmp32 = tmp32 & 0xff;
                                                    do
                                                      if(iSysLogLevel >= 3)
                                                        x_syslog(7, log_module_input_vdr, "Audio channel -> [%d]", tmp32);

                                                    while((_Bool)0);
                                                    xine_set_param(stream, 3, tmp32);
                                                  }

                                                  do
                                                    if(iSysLogLevel >= 3)
                                                    {
                                                      return_value__x_get_audio_channel$38=_x_get_audio_channel(stream);
                                                      x_syslog(7, log_module_input_vdr, "Audio channel selected: [%d]", return_value__x_get_audio_channel$38);
                                                    }

                                                  while((_Bool)0);
                                                }

                                              }

                                              else
                                              {
                                                return_value_strncasecmp$81=strncasecmp(cmd, "SPUSTREAM ", (unsigned long int)10);
                                                if(return_value_strncasecmp$81 == 0)
                                                {
                                                  signed int old_ch;
                                                  old_ch=_x_get_spu_channel(stream);
                                                  signed int max_ch;
                                                  unsigned int return_value_xine_get_stream_info$39;
                                                  return_value_xine_get_stream_info$39=xine_get_stream_info(stream, 25);
                                                  max_ch = (signed int)return_value_xine_get_stream_info$39;
                                                  signed int ch = old_ch;
                                                  signed int ch_auto;
                                                  char *return_value_strstr$40;
                                                  return_value_strstr$40=strstr(cmd + (signed long int)10, "auto");
                                                  ch_auto = (signed int)!(!(return_value_strstr$40 != ((char *)NULL)));
                                                  signed int is_dvd = 0;
                                                  if(!(this->slave.stream == ((struct xine_stream_s *)NULL)))
                                                  {
                                                    if(!(this->slave.stream->input_plugin == ((struct input_plugin_s$0 *)NULL)))
                                                    {
                                                      const char *mrl;
                                                      mrl=this->slave.stream->input_plugin->get_mrl(this->slave.stream->input_plugin);
                                                      signed int return_value_strncmp$41;
                                                      return_value_strncmp$41=strncmp(mrl, "dvd:/", (unsigned long int)5);
                                                      if(return_value_strncmp$41 == 0)
                                                        tmp_if_expr$43 = (_Bool)1;

                                                      else
                                                      {
                                                        return_value_strncmp$42=strncmp(mrl, "bd:/", (unsigned long int)4);
                                                        tmp_if_expr$43 = !(return_value_strncmp$42 != 0) ? (_Bool)1 : (_Bool)0;
                                                      }
                                                      if(tmp_if_expr$43)
                                                        tmp_if_expr$45 = (_Bool)1;

                                                      else
                                                      {
                                                        return_value_strncmp$44=strncmp(mrl, "bluray:/", (unsigned long int)8);
                                                        tmp_if_expr$45 = !(return_value_strncmp$44 != 0) ? (_Bool)1 : (_Bool)0;
                                                      }
                                                      is_dvd = (signed int)tmp_if_expr$45;
                                                    }

                                                  }

                                                  char *return_value_strstr$50;
                                                  return_value_strstr$50=strstr(cmd + (signed long int)10, "NEXT");
                                                  if(!(return_value_strstr$50 == ((char *)NULL)))
                                                    ch = ch < max_ch ? ch + 1 : -2;

                                                  else
                                                  {
                                                    return_value_strstr$49=strstr(cmd + (signed long int)10, "PREV");
                                                    if(!(return_value_strstr$49 == ((char *)NULL)))
                                                      ch = ch > -2 ? ch - 1 : max_ch - 1;

                                                    else
                                                    {
                                                      return_value_sscanf$48=sscanf(cmd + (signed long int)10, "%d", &tmp32);
                                                      if(return_value_sscanf$48 == 1)
                                                        ch = tmp32;

                                                      else
                                                      {
                                                        return_value_is_lang_code$47=is_lang_code(cmd + (signed long int)10, 2);
                                                        if(!(return_value_is_lang_code$47 == 0))
                                                        {
                                                          const char spu_lang[3l] = { cmd[(signed long int)10], cmd[(signed long int)11], (const char)0 };
                                                          do
                                                            if(iSysLogLevel >= 2)
                                                              x_syslog(6, log_module_input_vdr, "Preferred SPU language: %s", (const void *)spu_lang);

                                                          while((_Bool)0);
                                                          this->class->xine->config->update_string(this->class->xine->config, "media.dvd.language", spu_lang);
                                                          old_ch = 0;
                                                          ch = old_ch;
                                                        }

                                                        else
                                                        {
                                                          return_value_is_lang_code$46=is_lang_code(cmd + (signed long int)10, 3);
                                                          if(!(return_value_is_lang_code$46 == 0))
                                                          {
                                                            const char vdr_plugin_parse_control$$1$$26$$4$$spu_lang[4l] = { cmd[(signed long int)10], cmd[(signed long int)11], cmd[(signed long int)12], (const char)0 };
                                                            do
                                                              if(iSysLogLevel >= 2)
                                                                x_syslog(6, log_module_input_vdr, "Preferred SPU language: %s", (const void *)vdr_plugin_parse_control$$1$$26$$4$$spu_lang);

                                                            while((_Bool)0);
                                                            this->class->xine->config->update_string(this->class->xine->config, "media.bluray.language", vdr_plugin_parse_control$$1$$26$$4$$spu_lang);
                                                            old_ch = 0;
                                                            ch = old_ch;
                                                          }

                                                          else
                                                            err = -2;
                                                        }
                                                      }
                                                    }
                                                  }
                                                  if(old_ch == -1)
                                                    old_ch = stream->spu_channel_auto;

                                                  if(!(ch == old_ch))
                                                  {
                                                    if(!(ch_auto == 0) && !(is_dvd == 0))
                                                      tmp_if_expr$51 = stream->spu_channel_user == -1 ? (_Bool)1 : (_Bool)0;

                                                    else
                                                      tmp_if_expr$51 = (_Bool)0;
                                                    if(tmp_if_expr$51)
                                                      do
                                                        if(iSysLogLevel >= 3)
                                                          x_syslog(7, log_module_input_vdr, "Automatic SPU channel %d->%d ignored", old_ch, ch);

                                                      while((_Bool)0);

                                                    else
                                                    {
                                                      do
                                                        if(iSysLogLevel >= 3)
                                                          x_syslog(7, log_module_input_vdr, "Forced SPU channel %d->%d", old_ch, ch);

                                                      while((_Bool)0);
                                                      select_spu_channel(stream, ch);
                                                    }
                                                    do
                                                      if(iSysLogLevel >= 3)
                                                      {
                                                        return_value__x_get_spu_channel$52=_x_get_spu_channel(stream);
                                                        x_syslog(7, log_module_input_vdr, "SPU channel selected: [%d]", return_value__x_get_spu_channel$52);
                                                      }

                                                    while((_Bool)0);
                                                  }

                                                }

                                                else
                                                {
                                                  return_value_strncasecmp$80=strncasecmp(cmd, "AUDIODELAY ", (unsigned long int)11);
                                                  if(return_value_strncasecmp$80 == 0)
                                                  {
                                                    signed int return_value_sscanf$53;
                                                    return_value_sscanf$53=sscanf(cmd + (signed long int)11, "%d", &tmp32);
                                                    if(return_value_sscanf$53 == 1)
                                                      xine_set_param(stream, 2, (tmp32 * 90000) / 1000);

                                                    else
                                                      err = -2;
                                                  }

                                                  else
                                                  {
                                                    return_value_strncasecmp$79=strncasecmp(cmd, "SYNC", (unsigned long int)4);
                                                    if(return_value_strncasecmp$79 == 0)
                                                    {
                                                      if(this->fd_control >= 0)
                                                        printf_control(this, "RESULT %d 1\r\n", this->token);

                                                    }

                                                    else
                                                    {
                                                      return_value_strncasecmp$78=strncasecmp(cmd, "GETSTC", (unsigned long int)6);
                                                      if(return_value_strncasecmp$78 == 0)
                                                      {
                                                        signed long int pts = (signed long int)-1;
                                                        pts=stream->metronom->get_option(stream->metronom, 0x1001);
                                                        if(!(pts >= 1l))
                                                        {
                                                          signed long int return_value_xine_get_current_vpts$54;
                                                          return_value_xine_get_current_vpts$54=xine_get_current_vpts(stream);
                                                          signed long int return_value;
                                                          return_value=stream->metronom->get_option(stream->metronom, 6);
                                                          pts = return_value_xine_get_current_vpts$54 - return_value;
                                                        }

                                                        if(this->fd_control >= 0)
                                                          printf_control(this, "STC %ld\r\n", pts);

                                                        else
                                                          *((signed long int *)cmd) = pts;
                                                      }

                                                      else
                                                      {
                                                        return_value_strncasecmp$77=strncasecmp(cmd, "FLUSH ", (unsigned long int)6);
                                                        if(return_value_strncasecmp$77 == 0)
                                                        {
                                                          signed int return_value_sscanf$55;
                                                          return_value_sscanf$55=sscanf(cmd + (signed long int)6, "%d", &tmp32);
                                                          if(return_value_sscanf$55 == 1)
                                                          {
                                                            if(this->fd_control >= 0)
                                                            {
                                                              unsigned int frame = (unsigned int)0;
                                                              tmp64 = 0ULL;
                                                              tmp32 = 0;
                                                              sscanf(cmd + (signed long int)6, "%d %lu %d", &tmp32, &tmp64, &frame);
                                                              err=vdr_plugin_flush_remote(this, tmp32, tmp64, (signed int)frame);
                                                            }

                                                            else
                                                              err=vdr_plugin_flush(this, tmp32);
                                                          }

                                                          else
                                                            err = -2;
                                                        }

                                                        else
                                                        {
                                                          return_value_strncasecmp$76=strncasecmp(cmd, "TOKEN ", (unsigned long int)6);
                                                          if(return_value_strncasecmp$76 == 0)
                                                          {
                                                            signed int return_value_sscanf$56;
                                                            return_value_sscanf$56=sscanf(cmd + (signed long int)6, "%d", &tmp32);
                                                            if(return_value_sscanf$56 == 1)
                                                              this->token = tmp32;

                                                            else
                                                              err = -2;
                                                          }

                                                          else
                                                          {
                                                            return_value_strncasecmp$75=strncasecmp(cmd, "SUBSTREAM ", (unsigned long int)9);
                                                            if(return_value_strncasecmp$75 == 0)
                                                              err=handle_control_substream(this, cmd);

                                                            else
                                                            {
                                                              return_value_strncasecmp$74=strncasecmp(cmd, "POST ", (unsigned long int)5);
                                                              if(return_value_strncasecmp$74 == 0)
                                                              {
                                                                pthread_mutex_lock(&this->lock);
                                                                if(this->$anon0.$anon0.funcs.fe_control == ((void * (*)(struct frontend_s *, const char *))NULL))
                                                                  do
                                                                    if(iSysLogLevel >= 2)
                                                                      x_syslog(6, log_module_input_vdr, "No fe_control function! %s failed.", cmd);

                                                                  while((_Bool)0);

                                                                else
                                                                  this->$anon0.$anon0.funcs.fe_control(this->$anon0.$anon0.funcs.fe_handle, cmd);
                                                                pthread_mutex_unlock(&this->lock);
                                                              }

                                                              else
                                                              {
                                                                return_value_strncasecmp$73=strncasecmp(cmd, "PLAYFILE ", (unsigned long int)9);
                                                                if(return_value_strncasecmp$73 == 0)
                                                                {
                                                                  err=handle_control_playfile(this, cmd);
                                                                  if(this->fd_control >= 0)
                                                                  {
                                                                    printf_control(this, "RESULT %d %d\r\n", this->token, err);
                                                                    err = 0;
                                                                  }

                                                                }

                                                                else
                                                                {
                                                                  return_value_strncasecmp$72=strncasecmp(cmd, "SEEK ", (unsigned long int)5);
                                                                  if(return_value_strncasecmp$72 == 0)
                                                                  {
                                                                    if(!(this->slave.stream == ((struct xine_stream_s *)NULL)))
                                                                    {
                                                                      signed int pos_stream = 0;
                                                                      signed int pos_time = 0;
                                                                      signed int length_time = 0;
                                                                      xine_get_pos_length(this->slave.stream, &pos_stream, &pos_time, &length_time);
                                                                      if((signed int)cmd[5l] == 43)
                                                                      {
                                                                        return_value_atoi$57=atoi(cmd + (signed long int)6);
                                                                        pos_time = pos_time + return_value_atoi$57 * 1000;
                                                                      }

                                                                      else
                                                                        if((signed int)cmd[5l] == 45)
                                                                        {
                                                                          return_value_atoi$58=atoi(cmd + (signed long int)6);
                                                                          pos_time = pos_time - return_value_atoi$58 * 1000;
                                                                        }

                                                                        else
                                                                        {
                                                                          return_value_atoi$59=atoi(cmd + (signed long int)5);
                                                                          pos_time = return_value_atoi$59 * 1000;
                                                                        }
                                                                      err=xine_play(this->slave.stream, 0, pos_time);
                                                                      if(this->fd_control >= 0)
                                                                        err = 0;

                                                                    }

                                                                  }

                                                                  else
                                                                  {
                                                                    return_value_strncasecmp$71=strncasecmp(cmd, "GETLENGTH", (unsigned long int)9);
                                                                    if(return_value_strncasecmp$71 == 0)
                                                                    {
                                                                      signed int vdr_plugin_parse_control$$1$$36$$pos_stream = 0;
                                                                      signed int vdr_plugin_parse_control$$1$$36$$pos_time = 0;
                                                                      signed int vdr_plugin_parse_control$$1$$36$$length_time = 0;
                                                                      xine_get_pos_length(stream, &vdr_plugin_parse_control$$1$$36$$pos_stream, &vdr_plugin_parse_control$$1$$36$$pos_time, &vdr_plugin_parse_control$$1$$36$$length_time);
                                                                      err = vdr_plugin_parse_control$$1$$36$$length_time;
                                                                      if(this->fd_control >= 0)
                                                                      {
                                                                        printf_control(this, "RESULT %d %d\r\n", this->token, err);
                                                                        err = 0;
                                                                      }

                                                                    }

                                                                    else
                                                                    {
                                                                      return_value_strncasecmp$70=strncasecmp(cmd, "GETAUTOPLAYSIZE", (unsigned long int)15);
                                                                      if(return_value_strncasecmp$70 == 0)
                                                                      {
                                                                        if((signed int)cmd[15l] == 32)
                                                                        {
                                                                          if(!(cmd[16l] == 0))
                                                                          {
                                                                            const char *cls_name = cmd + (signed long int)16;
                                                                            this->autoplay_size = 0;
                                                                            struct anonymous$30 **return_value_xine_get_browse_mrls$60;
                                                                            return_value_xine_get_browse_mrls$60=xine_get_browse_mrls(stream->xine, cls_name, (const char *)(void *)0, &this->autoplay_size);
                                                                            if(return_value_xine_get_browse_mrls$60 == ((struct anonymous$30 **)NULL))
                                                                              xine_get_autoplay_mrls(stream->xine, cls_name, &this->autoplay_size);

                                                                          }

                                                                        }

                                                                        if(!(this->autoplay_size >= 0))
                                                                        {
                                                                          if(!(this->slave.stream == ((struct xine_stream_s *)NULL)))
                                                                          {
                                                                            if(!(this->slave.stream->input_plugin == ((struct input_plugin_s$0 *)NULL)))
                                                                            {
                                                                              if(!(this->slave.stream->input_plugin->input_class == ((struct input_class_s$1 *)NULL)))
                                                                                this->slave.stream->input_plugin->input_class->get_autoplay_list(this->slave.stream->input_plugin->input_class, &this->autoplay_size);

                                                                            }

                                                                          }

                                                                        }

                                                                        err = this->autoplay_size;
                                                                        if(this->fd_control >= 0)
                                                                        {
                                                                          printf_control(this, "RESULT %d %d\r\n", this->token, err);
                                                                          err = 0;
                                                                        }

                                                                      }

                                                                      else
                                                                      {
                                                                        return_value_strncasecmp$69=strncasecmp(cmd, "GETPOS", (unsigned long int)6);
                                                                        if(return_value_strncasecmp$69 == 0)
                                                                        {
                                                                          signed int vdr_plugin_parse_control$$1$$38$$pos_stream = 0;
                                                                          signed int vdr_plugin_parse_control$$1$$38$$pos_time = 0;
                                                                          signed int vdr_plugin_parse_control$$1$$38$$length_time = 0;
                                                                          xine_get_pos_length(stream, &vdr_plugin_parse_control$$1$$38$$pos_stream, &vdr_plugin_parse_control$$1$$38$$pos_time, &vdr_plugin_parse_control$$1$$38$$length_time);
                                                                          err = vdr_plugin_parse_control$$1$$38$$pos_time;
                                                                          if(this->fd_control >= 0)
                                                                          {
                                                                            printf_control(this, "RESULT %d %d\r\n", this->token, err);
                                                                            err = 0;
                                                                          }

                                                                        }

                                                                        else
                                                                        {
                                                                          return_value_strncasecmp$68=strncasecmp(cmd, "SUBTITLES ", (unsigned long int)10);
                                                                          if(return_value_strncasecmp$68 == 0)
                                                                          {
                                                                            if(!(this->slave.stream == ((struct xine_stream_s *)NULL)))
                                                                            {
                                                                              signed int vpos = 0;
                                                                              signed int return_value_sscanf$61;
                                                                              return_value_sscanf$61=sscanf(cmd + (signed long int)10, "%d", &vpos);
                                                                              if(return_value_sscanf$61 == 1)
                                                                                this->class->xine->config->update_num(this->class->xine->config, "subtitles.separate.vertical_offset", vpos);

                                                                              else
                                                                                err = -2;
                                                                            }

                                                                          }

                                                                          else
                                                                          {
                                                                            return_value_strncasecmp$67=strncasecmp(cmd, "EXTSUBSIZE ", (unsigned long int)11);
                                                                            if(return_value_strncasecmp$67 == 0)
                                                                            {
                                                                              signed int size = 0;
                                                                              signed int return_value_sscanf$62;
                                                                              return_value_sscanf$62=sscanf(cmd + (signed long int)11, "%d", &size);
                                                                              if(return_value_sscanf$62 == 1)
                                                                                this->class->xine->config->update_num(this->class->xine->config, "subtitles.separate.subtitle_size", size);

                                                                              else
                                                                                err = -2;
                                                                            }

                                                                            else
                                                                            {
                                                                              return_value_strncasecmp$66=strncasecmp(cmd, "CONFIG END", (unsigned long int)10);
                                                                              if(return_value_strncasecmp$66 == 0)
                                                                                this->config_ok = (unsigned char)1;

                                                                              else
                                                                              {
                                                                                return_value_strncasecmp$65=strncasecmp(cmd, "GRAB ", (unsigned long int)5);
                                                                                if(return_value_strncasecmp$65 == 0)
                                                                                  handle_control_grab(this, cmd);

                                                                                else
                                                                                {
                                                                                  return_value_strncasecmp$64=strncasecmp(cmd, "BLANK", (unsigned long int)5);
                                                                                  if(return_value_strncasecmp$64 == 0)
                                                                                    put_control_buf(this->block_buffer, this->buffer_pool, 0x0f000000 | 0x00010000);

                                                                                  else
                                                                                  {
                                                                                    return_value_strncasecmp$63=strncasecmp(cmd, "CLEAR", (unsigned long int)5);
                                                                                    if(!(return_value_strncasecmp$63 == 0))
                                                                                    {
                                                                                      do
                                                                                        if(iSysLogLevel >= 2)
                                                                                          x_syslog(6, log_module_input_vdr, "vdr_plugin_parse_control(): unknown control %s", cmd);

                                                                                      while((_Bool)0);
                                                                                      err = -1;
                                                                                    }

                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    do
    {
      signed int return_value_pthread_mutex_unlock$107;
      return_value_pthread_mutex_unlock$107=pthread_mutex_unlock(&this->vdr_entry_lock);
      if(!(return_value_pthread_mutex_unlock$107 == 0))
        do
          if(iSysLogLevel >= 1)
          {
            x_syslog(3, log_module_input_vdr, "%s:%d: pthread_mutex_unlock failed", (const void *)"vdr_plugin_parse_control", 3583);
            signed int *return_value___errno_location$106;
            return_value___errno_location$106=__errno_location();
            if(!(*return_value___errno_location$106 == 0))
            {
              return_value___errno_location$104=__errno_location();
              return_value_strerror$105=strerror(*return_value___errno_location$104);
              x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 3583, return_value_strerror$105);
            }

          }

        while((_Bool)0);

    }
    while((_Bool)0);
    return err;
  }
}

// vdr_plugin_poll
// file xine_input_vdr.c line 2867
static signed int vdr_plugin_poll(struct vdr_input_plugin_s *this, signed int timeout_ms)
{
  struct timespec abstime;
  struct fifo_buffer_s *fifo;
  struct fifo_buffer_s *tmp_if_expr$1;
  if(!(this->hd_stream == 0))
    tmp_if_expr$1 = this->hd_buffer;

  else
    tmp_if_expr$1 = this->buffer_pool;
  fifo = tmp_if_expr$1;
  signed int reserved_bufs = (signed int)this->reserved_buffers;
  signed int result = 0;
  signed int *return_value___errno_location$2;
  char *return_value_strerror$3;
  signed int *return_value___errno_location$7;
  char *return_value_strerror$8;
  if(!(this->slave.stream == ((struct xine_stream_s *)NULL)))
  {
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_vdr, "vdr_plugin_poll: called while playing slave stream !");

    while((_Bool)0);
    return 1;
  }

  else
  {
    pthread_mutex_lock(&fifo->buffer_pool_mutex);
    result = fifo->buffer_pool_num_free - reserved_bufs;
    pthread_mutex_unlock(&fifo->buffer_pool_mutex);
    if(timeout_ms >= 1 && !(result >= 1))
    {
      if(timeout_ms >= 251)
      {
        do
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "vdr_plugin_poll: timeout too large (%d ms), forced to 250ms", timeout_ms);

        while((_Bool)0);
        timeout_ms = 250;
      }

      create_timeout_time(&abstime, timeout_ms);
      pthread_mutex_lock(&this->lock);
      if((signed int)this->scr_tuning == -10000)
        reset_scr_tuning(this);

      pthread_mutex_unlock(&this->lock);
      signal_buffer_not_empty(this);
      do
      {
        signed int return_value_pthread_mutex_unlock$5;
        return_value_pthread_mutex_unlock$5=pthread_mutex_unlock(&this->vdr_entry_lock);
        if(!(return_value_pthread_mutex_unlock$5 == 0))
          do
            if(iSysLogLevel >= 1)
            {
              x_syslog(3, log_module_input_vdr, "%s:%d: pthread_mutex_unlock failed", (const void *)"vdr_plugin_poll", 2903);
              signed int *return_value___errno_location$4;
              return_value___errno_location$4=__errno_location();
              if(!(*return_value___errno_location$4 == 0))
              {
                return_value___errno_location$2=__errno_location();
                return_value_strerror$3=strerror(*return_value___errno_location$2);
                x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 2903, return_value_strerror$3);
              }

            }

          while((_Bool)0);

      }
      while((_Bool)0);
      pthread_mutex_lock(&fifo->buffer_pool_mutex);
      while(!(result >= 6))
      {
        signed int return_value_pthread_cond_timedwait$6;
        return_value_pthread_cond_timedwait$6=pthread_cond_timedwait(&fifo->buffer_pool_cond_not_empty, &fifo->buffer_pool_mutex, &abstime);
        if(return_value_pthread_cond_timedwait$6 == 110)
          break;

        result = fifo->buffer_pool_num_free - reserved_bufs;
      }
      pthread_mutex_unlock(&fifo->buffer_pool_mutex);
      do
      {
        signed int return_value_pthread_mutex_lock$10;
        return_value_pthread_mutex_lock$10=pthread_mutex_lock(&this->vdr_entry_lock);
        if(!(return_value_pthread_mutex_lock$10 == 0))
        {
          do
            if(iSysLogLevel >= 1)
            {
              x_syslog(3, log_module_input_vdr, "%s:%d: pthread_mutex_lock failed", (const void *)"vdr_plugin_poll", 2914);
              signed int *return_value___errno_location$9;
              return_value___errno_location$9=__errno_location();
              if(!(*return_value___errno_location$9 == 0))
              {
                return_value___errno_location$7=__errno_location();
                return_value_strerror$8=strerror(*return_value___errno_location$7);
                x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 2914, return_value_strerror$8);
              }

            }

          while((_Bool)0);
          return 0;
        }

      }
      while((_Bool)0);
    }

    if(!(result >= 1))
    {
      result = 0;
      xine_usec_sleep((unsigned int)(3 * 1000));
    }

    return result;
  }
}

// vdr_plugin_read
// file xine_input_vdr.c line 4741
static signed long int vdr_plugin_read(struct input_plugin_s$0 *this_gen, void *buf_gen, signed long int len)
{
  memset(buf_gen, 0, (unsigned long int)len);
  return (signed long int)0;
}

// vdr_plugin_read_block
// file xine_input_vdr.c line 4948
static struct buf_element_s * vdr_plugin_read_block(struct input_plugin_s$0 *this_gen, struct fifo_buffer_s *fifo, signed long int todo)
{
  struct vdr_input_plugin_s *this = (struct vdr_input_plugin_s *)this_gen;
  struct buf_element_s *buf = (struct buf_element_s *)(void *)0;
  signed int need_pause = 0;
  _Bool tmp_if_expr$2;
  if(!(this->slave.stream == ((struct xine_stream_s *)NULL)))
    tmp_if_expr$2 = (_Bool)1;

  else
    tmp_if_expr$2 = !(this->config_ok != 0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$2)
  {
    if(this->config_ok == 0)
    {
      do
        if(iSysLogLevel >= 3)
          x_syslog(7, log_module_input_vdr, "read_block waiting for configuration data");

      while((_Bool)0);
      xine_usec_sleep((unsigned int)(100 * 1000));
    }

    xine_usec_sleep((unsigned int)(50 * 1000));
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 11;
    return (struct buf_element_s *)(void *)0;
  }

  _Bool tmp_if_expr$5;
  signed int *return_value___errno_location$7;
  signed int *return_value___errno_location$6;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$11;
  while((_Bool)1)
  {
    if(this->$anon0.$anon0.funcs.push_input_write == ((signed int (*)(struct vdr_input_plugin_if_s *, signed int, unsigned long int, const char *, signed int))NULL))
    {
      if(this->control_running == 0)
      {
        handle_disconnect(this);
        return (struct buf_element_s *)(void *)0;
      }

    }

    signed int return_value__x_action_pending$4;
    return_value__x_action_pending$4=_x_action_pending(this->stream);
    if(!(return_value__x_action_pending$4 == 0))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      *return_value___errno_location$3 = 4;
      return (struct buf_element_s *)(void *)0;
    }

    need_pause=adjust_scr_speed(this);
    if(!(this->$anon0.$anon0.funcs.push_input_write == ((signed int (*)(struct vdr_input_plugin_if_s *, signed int, unsigned long int, const char *, signed int))NULL)))
      buf=fifo_buffer_timed_get(this->block_buffer, 100);

    else
    {
      buf=fifo_buffer_try_get(this->block_buffer);
      if(buf == ((struct buf_element_s *)NULL))
      {
        if(!(this->udp == 0))
          tmp_if_expr$5 = (_Bool)1;

        else
          tmp_if_expr$5 = this->rtp != 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$5)
          buf=vdr_plugin_read_block_udp(this);

        else
          buf=vdr_plugin_read_block_tcp(this);
        if(buf == ((struct buf_element_s *)NULL))
        {
          return_value___errno_location$7=__errno_location();
          if(!(*return_value___errno_location$7 == 11))
          {
            return_value___errno_location$6=__errno_location();
            if(!(*return_value___errno_location$6 == 4))
            {
              handle_disconnect(this);
              return (struct buf_element_s *)(void *)0;
            }

          }

        }

      }

    }
    if(buf == ((struct buf_element_s *)NULL))
    {
      if(this->is_paused == 0)
        tmp_if_expr$8 = !(this->still_mode != 0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$8 = (_Bool)0;
      if(tmp_if_expr$8)
        tmp_if_expr$9 = !(this->is_trickspeed != 0) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$9 = (_Bool)0;
      if(tmp_if_expr$9)
        tmp_if_expr$10 = !(this->slave.stream != ((struct xine_stream_s *)NULL)) ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$10 = (_Bool)0;
      if(tmp_if_expr$10)
        tmp_if_expr$11 = this->stream->video_fifo->fifo_size <= 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$11 = (_Bool)0;
      if(tmp_if_expr$11)
      {
        this->read_timeouts = this->read_timeouts + 1;
        if((signed int)this->read_timeouts >= 81)
        {
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_input_vdr, "No data in 8 seconds, queuing no signal image");

          while((_Bool)0);
          queue_nosignal(this);
          this->read_timeouts = (unsigned char)0;
        }

      }

      else
        this->read_timeouts = (unsigned char)0;
      signed int *return_value___errno_location$12;
      return_value___errno_location$12=__errno_location();
      signed int return_value__x_action_pending$13;
      return_value__x_action_pending$13=_x_action_pending(this->stream);
      *return_value___errno_location$12 = return_value__x_action_pending$13 != 0 ? 4 : 11;
      return (struct buf_element_s *)(void *)0;
    }

    this->read_timeouts = (unsigned char)0;
    buf=preprocess_buf(this, buf);
    if(!(buf == ((struct buf_element_s *)NULL)))
      break;

  }
  postprocess_buf(this, buf, need_pause);
  return buf;
}

// vdr_plugin_read_block_tcp
// file xine_input_vdr.c line 4045
static struct buf_element_s * vdr_plugin_read_block_tcp(struct vdr_input_plugin_s *this)
{
  struct buf_element_s *read_buffer = this->read_buffer;
  signed int todo = (signed int)sizeof(struct anonymous$56) /*13ul*/ ;
  signed int vdr_plugin_read_block_tcp$$1$$warnings = 0;
  signed int result;
  signed int n;
  signed int return_value_wait_stream_sync$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$15;
  signed int *return_value___errno_location$12;
  _Bool tmp_if_expr$14;
  signed int *return_value___errno_location$13;
  signed int *return_value___errno_location$8;
  char *return_value_strerror$9;
  if(!(this->discard_index >= this->discard_index_ds))
  {
    return_value_wait_stream_sync$1=wait_stream_sync(this);
    if(return_value_wait_stream_sync$1 == 0)
      goto __CPROVER_DUMP_L1;

    return (struct buf_element_s *)(void *)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(read_buffer == ((struct buf_element_s *)NULL)))
    {
      if((signed long int)read_buffer->size >= (signed long int)sizeof(struct anonymous$56) /*13l*/ )
        todo = todo + (signed int)((struct anonymous$56 *)read_buffer->content)->len;

    }

    do
    {
      result=_x_io_select(this->stream, this->fd_data, 1, 100);
      if(!(result == 0))
        break;

      if(this->control_running == 0)
        tmp_if_expr$3 = (_Bool)1;

      else
        tmp_if_expr$3 = this->fd_data < 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$3)
      {
        signed int *return_value___errno_location$2;
        return_value___errno_location$2=__errno_location();
        *return_value___errno_location$2 = 107;
        return (struct buf_element_s *)(void *)0;
      }

      signed int return_value__x_action_pending$5;
      return_value__x_action_pending$5=_x_action_pending(this->stream);
      if(!(return_value__x_action_pending$5 == 0))
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        *return_value___errno_location$4 = 4;
        return (struct buf_element_s *)(void *)0;
      }

      if(read_buffer == ((struct buf_element_s *)NULL))
      {
        read_buffer=get_buf_element_timed(this, (signed int)((unsigned long int)2048 + sizeof(struct anonymous$56) /*13ul*/ ), 100);
        this->read_buffer = read_buffer;
        if(read_buffer == ((struct buf_element_s *)NULL))
        {
          if(this->is_paused == 0)
          {
            if(vdr_plugin_read_block_tcp$$1$$warnings == 0)
              do
                if(iSysLogLevel >= 3)
                  x_syslog(7, log_module_input_vdr, "TCP: fifo buffer full");

              while((_Bool)0);

          }

          vdr_plugin_read_block_tcp$$1$$warnings = vdr_plugin_read_block_tcp$$1$$warnings + 1;
          continue;
        }

        todo = (signed int)sizeof(struct anonymous$56) /*13ul*/ ;
        read_buffer->size = 0;
        vdr_plugin_read_block_tcp$$1$$warnings = 0;
      }

      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      *return_value___errno_location$6 = 0;
      signed long int return_value_read$7;
      return_value_read$7=read(this->fd_data, (void *)(read_buffer->content + (signed long int)read_buffer->size), (unsigned long int)(todo - read_buffer->size));
      n = (signed int)return_value_read$7;
      if(!(n >= 1))
      {
        if(n == 0)
          tmp_if_expr$15 = (_Bool)1;

        else
        {
          return_value___errno_location$12=__errno_location();
          if(!(*return_value___errno_location$12 == 4))
          {
            return_value___errno_location$13=__errno_location();
            tmp_if_expr$14 = *return_value___errno_location$13 != 11 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr$14 = (_Bool)0;
          tmp_if_expr$15 = tmp_if_expr$14 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$15)
        {
          if(!(n >= 0))
          {
            if(this->fd_data >= 0)
              do
                if(iSysLogLevel >= 1)
                {
                  x_syslog(3, log_module_input_vdr, "TCP read error (data stream %d : %d)", this->fd_data, n);
                  signed int *return_value___errno_location$10;
                  return_value___errno_location$10=__errno_location();
                  if(!(*return_value___errno_location$10 == 0))
                  {
                    return_value___errno_location$8=__errno_location();
                    return_value_strerror$9=strerror(*return_value___errno_location$8);
                    x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 4093, return_value_strerror$9);
                  }

                }

              while((_Bool)0);

          }

          if(n == 0)
            do
              if(iSysLogLevel >= 2)
                x_syslog(6, log_module_input_vdr, "Data stream disconnected");

            while((_Bool)0);

          signed int *return_value___errno_location$11;
          return_value___errno_location$11=__errno_location();
          *return_value___errno_location$11 = 107;
        }

        return (struct buf_element_s *)(void *)0;
      }

      read_buffer->size = read_buffer->size + n;
      if((unsigned long int)read_buffer->size == sizeof(struct anonymous$56) /*13ul*/ )
      {
        struct anonymous$56 *hdr = (struct anonymous$56 *)read_buffer->content;
        hdr->len=__bswap_32(hdr->len);
        unsigned int return_value___bswap_32$16;
        return_value___bswap_32$16=__bswap_32((unsigned int)(hdr->pos >> 32));
        unsigned int return_value___bswap_32$17;
        return_value___bswap_32$17=__bswap_32((unsigned int)hdr->pos);
        hdr->pos = (unsigned long int)return_value___bswap_32$16 | (unsigned long int)return_value___bswap_32$17 << 32;
        todo = todo + (signed int)hdr->len;
        if(read_buffer->size + todo >= read_buffer->max_size)
        {
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_input_vdr, "TCP: Buffer too small (%d ; incoming frame %d bytes)", read_buffer->max_size, todo + read_buffer->size);

          while((_Bool)0);
          signed int *return_value___errno_location$18;
          return_value___errno_location$18=__errno_location();
          *return_value___errno_location$18 = 107;
          return (struct buf_element_s *)(void *)0;
        }

      }

      if(read_buffer->size >= todo)
      {
        struct anonymous$56 *vdr_plugin_read_block_tcp$$1$$1$$6$$hdr = (struct anonymous$56 *)read_buffer->content;
        if(vdr_plugin_read_block_tcp$$1$$1$$6$$hdr->pos == 18446744073709551615ull)
        {
          unsigned char *pkt_data = read_buffer->content + (signed long int)sizeof(struct anonymous$56) /*13ul*/ ;
          if(!((signed int)*pkt_data == 0x47))
          {
            if(!(*pkt_data == 0))
            {
              data_stream_parse_control(this, (char *)pkt_data);
              read_buffer->free_buffer(read_buffer);
              this->read_buffer = (struct buf_element_s *)(void *)0;
              signed int *return_value___errno_location$19;
              return_value___errno_location$19=__errno_location();
              *return_value___errno_location$19 = 11;
              return (struct buf_element_s *)(void *)0;
            }

          }

        }

        read_buffer->type = (unsigned int)(0x05000000 | 0x00010000);
        this->read_buffer = (struct buf_element_s *)(void *)0;
        return read_buffer;
      }

    }
    while((_Bool)1);
    signed int *return_value___errno_location$20;
    return_value___errno_location$20=__errno_location();
    *return_value___errno_location$20 = result == 3 ? 11 : (result == 2 ? 4 : 107);
    return (struct buf_element_s *)(void *)0;
  }
}

// vdr_plugin_read_block_udp
// file xine_input_vdr.c line 4495
static struct buf_element_s * vdr_plugin_read_block_udp(struct vdr_input_plugin_s *this)
{
  struct udp_data_s *udp = this->udp_data;
  signed int return_value_wait_stream_sync$1;
  _Bool tmp_if_expr$3;
  _Bool tmp_if_expr$7;
  _Bool tmp_if_expr$8;
  _Bool tmp_if_expr$9;
  _Bool tmp_if_expr$10;
  _Bool tmp_if_expr$11;
  signed int *return_value___errno_location$13;
  char *return_value_strerror$14;
  while(!(this->control_running == 0))
  {
    if(!(this->fd_data >= 0))
      break;

    if(!(this->discard_index >= this->discard_index_ds))
    {
      return_value_wait_stream_sync$1=wait_stream_sync(this);
      if(!(return_value_wait_stream_sync$1 == 0))
        return (struct buf_element_s *)(void *)0;

    }

    if(this->control_running == 0)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = this->fd_data < 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$3)
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      *return_value___errno_location$2 = 107;
      return (struct buf_element_s *)(void *)0;
    }

    struct buf_element_s *read_buffer;
    read_buffer=udp_process_queue(this);
    if(!(read_buffer == ((struct buf_element_s *)NULL)))
      return read_buffer;

    signed int return_value__x_action_pending$5;
    return_value__x_action_pending$5=_x_action_pending(this->stream);
    if(!(return_value__x_action_pending$5 == 0))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      *return_value___errno_location$4 = 4;
      return (struct buf_element_s *)(void *)0;
    }

    read_buffer=read_socket_udp(this);
    if(read_buffer == ((struct buf_element_s *)NULL))
      return (struct buf_element_s *)(void *)0;

    read_buffer=udp_parse_header(read_buffer, (signed int)this->rtp);
    if(read_buffer == ((struct buf_element_s *)NULL))
      tmp_if_expr$7 = (_Bool)1;

    else
    {
      read_buffer=udp_parse_control(this, read_buffer);
      tmp_if_expr$7 = !(read_buffer != ((struct buf_element_s *)NULL)) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$7)
      tmp_if_expr$8 = (_Bool)1;

    else
    {
      read_buffer=udp_check_packet(read_buffer);
      tmp_if_expr$8 = !(read_buffer != ((struct buf_element_s *)NULL)) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$8)
    {
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      *return_value___errno_location$6 = 11;
      return (struct buf_element_s *)(void *)0;
    }

    struct anonymous$7 *pkt = (struct anonymous$7 *)read_buffer->content;
    unsigned char *pkt_data = (unsigned char *)read_buffer->content + (signed long int)sizeof(struct anonymous$7) /*11ul*/ ;
    udp->current_seq = (unsigned short int)((signed int)pkt->seq & 0xff);
    if(*pkt_data == 0)
      tmp_if_expr$9 = !(pkt_data[(signed long int)1] != 0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$9 = (_Bool)0;
    if(tmp_if_expr$9)
      tmp_if_expr$10 = (signed int)pkt_data[(signed long int)2] == 1 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$10 = (_Bool)0;
    if(tmp_if_expr$10)
      tmp_if_expr$11 = 0xBE == (signed int)pkt_data[(signed long int)3] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$11 = (_Bool)0;
    udp->is_padding = (unsigned char)tmp_if_expr$11;
    if((signed int)udp->received_frames == -1)
    {
      udp->next_seq = udp->current_seq;
      udp->received_frames = (signed short int)0;
    }

    if((1 + (signed int)udp->current_seq + -((signed int)udp->next_seq) & 0xff) >= 129)
    {
      struct sockaddr_in sin;
      do
        if(iSysLogLevel >= 3)
          x_syslog(7, log_module_input_vdr, "UDP: resetting link");

      while((_Bool)0);
      memcpy((void *)&sin, (const void *)&udp->server_address, sizeof(struct sockaddr_in) /*16ul*/ );
      free_udp_data(udp);
      this->udp_data=init_udp_data();
      udp = this->udp_data;
      memcpy((void *)&udp->server_address, (const void *)&sin, sizeof(struct sockaddr_in) /*16ul*/ );
      read_buffer->free_buffer(read_buffer);
      signed int *return_value___errno_location$12;
      return_value___errno_location$12=__errno_location();
      *return_value___errno_location$12 = 11;
      return (struct buf_element_s *)(void *)0;
    }

    if(!(udp->queue[(signed long int)udp->current_seq] == ((struct buf_element_s *)NULL)))
    {
      udp->queue[(signed long int)udp->current_seq]->free_buffer(udp->queue[(signed long int)udp->current_seq]);
      udp->queue[(signed long int)udp->current_seq] = (struct buf_element_s *)(void *)0;
      if(udp->queued == 0)
      {
        if(iSysLogLevel >= 1)
        {
          x_syslog(3, log_module_input_vdr, "UDP queue corrupt !!!");
          signed int *return_value___errno_location$15;
          return_value___errno_location$15=__errno_location();
          if(!(*return_value___errno_location$15 == 0))
          {
            return_value___errno_location$13=__errno_location();
            return_value_strerror$14=strerror(*return_value___errno_location$13);
            x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 4575, return_value_strerror$14);
          }

        }

      }

      else
        udp->queued = udp->queued - 1;
    }

    udp->queue[(signed long int)udp->current_seq] = read_buffer;
    read_buffer = (struct buf_element_s *)(void *)0;
    udp->queued = udp->queued + 1;
    read_buffer=udp_process_queue(this);
    if(!(read_buffer == ((struct buf_element_s *)NULL)))
      return read_buffer;

    udp_process_resend(this);
  }
  signed int *return_value___errno_location$16;
  return_value___errno_location$16=__errno_location();
  *return_value___errno_location$16 = 107;
  return (struct buf_element_s *)(void *)0;
}

// vdr_plugin_seek
// file xine_input_vdr.c line 5033
static signed long int vdr_plugin_seek(struct input_plugin_s$0 *this_gen, signed long int offset, signed int origin)
{
  return (signed long int)-1;
}

// vdr_plugin_write
// file xine_input_vdr.c line 4658
static signed int vdr_plugin_write(struct vdr_input_plugin_if_s *this_if, signed int stream, unsigned long int pos, const char *data, signed int len)
{
  struct vdr_input_plugin_s *this = (struct vdr_input_plugin_s *)this_if;
  struct buf_element_s *buf = (struct buf_element_s *)(void *)0;
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  unsigned char tmp_post$5;
  signed int *return_value___errno_location$6;
  char *return_value_strerror$7;
  signed int *return_value___errno_location$11;
  char *return_value_strerror$12;
  signed int *return_value___errno_location$15;
  char *return_value_strerror$16;
  if(!(this->slave.stream == ((struct xine_stream_s *)NULL)))
    return len;

  else
    if(!(stream == 0))
      return len;

    else
    {
      do
      {
        signed int return_value_pthread_mutex_lock$4;
        return_value_pthread_mutex_lock$4=pthread_mutex_lock(&this->vdr_entry_lock);
        if(!(return_value_pthread_mutex_lock$4 == 0))
        {
          do
            if(iSysLogLevel >= 1)
            {
              x_syslog(3, log_module_input_vdr, "%s:%d: pthread_mutex_lock failed", (const void *)"vdr_plugin_write", 4676);
              signed int *return_value___errno_location$3;
              return_value___errno_location$3=__errno_location();
              if(!(*return_value___errno_location$3 == 0))
              {
                return_value___errno_location$1=__errno_location();
                return_value_strerror$2=strerror(*return_value___errno_location$1);
                x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 4676, return_value_strerror$2);
              }

            }

          while((_Bool)0);
          return 0;
        }

      }
      while((_Bool)0);
      buf=get_buf_element(this, len, 0);
      if(buf == ((struct buf_element_s *)NULL))
      {
        tmp_post$5 = this->write_overflows;
        this->write_overflows = this->write_overflows + 1;
        if((signed int)tmp_post$5 >= 2)
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_input_vdr, "vdr_plugin_write: buffer overflow ! (%d bytes)", len);

          while((_Bool)0);

        do
        {
          signed int return_value_pthread_mutex_unlock$9;
          return_value_pthread_mutex_unlock$9=pthread_mutex_unlock(&this->vdr_entry_lock);
          if(!(return_value_pthread_mutex_unlock$9 == 0))
            do
              if(iSysLogLevel >= 1)
              {
                x_syslog(3, log_module_input_vdr, "%s:%d: pthread_mutex_unlock failed", (const void *)"vdr_plugin_write", 4684);
                signed int *return_value___errno_location$8;
                return_value___errno_location$8=__errno_location();
                if(!(*return_value___errno_location$8 == 0))
                {
                  return_value___errno_location$6=__errno_location();
                  return_value_strerror$7=strerror(*return_value___errno_location$6);
                  x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 4684, return_value_strerror$7);
                }

              }

            while((_Bool)0);

        }
        while((_Bool)0);
        xine_usec_sleep((unsigned int)(5 * 1000));
        signed int *return_value___errno_location$10;
        return_value___errno_location$10=__errno_location();
        *return_value___errno_location$10 = 11;
        return 0;
      }

      this->write_overflows = (unsigned char)0;
      if(!(buf->max_size >= len))
      {
        do
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "vdr_plugin_write: PES too long (%d bytes, max size %d bytes), data ignored !", len, buf->max_size);

        while((_Bool)0);
        buf->free_buffer(buf);
        signed int return_value_pthread_mutex_unlock$14;
        return_value_pthread_mutex_unlock$14=pthread_mutex_unlock(&this->vdr_entry_lock);
        if(!(return_value_pthread_mutex_unlock$14 == 0))
        {
          if(iSysLogLevel >= 1)
          {
            x_syslog(3, log_module_input_vdr, "%s:%d: pthread_mutex_unlock failed", (const void *)"vdr_plugin_write", 4696);
            signed int *return_value___errno_location$13;
            return_value___errno_location$13=__errno_location();
            if(!(*return_value___errno_location$13 == 0))
            {
              return_value___errno_location$11=__errno_location();
              return_value_strerror$12=strerror(*return_value___errno_location$11);
              x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 4696, return_value_strerror$12);
            }

          }

        }

        return len;
      }

      else
      {
        struct anonymous$41 *hdr = (struct anonymous$41 *)buf->content;
        hdr->pos = pos;
        buf->type = (unsigned int)(0x05000000 | 0x00020000);
        buf->size = (signed int)((unsigned long int)len + sizeof(struct anonymous$41) /*8ul*/ );
        xine_fast_memcpy((void *)(buf->content + (signed long int)sizeof(struct anonymous$41) /*8ul*/ ), (const void *)data, (unsigned long int)len);
        this->block_buffer->put(this->block_buffer, buf);
        signed int return_value_pthread_mutex_unlock$18;
        return_value_pthread_mutex_unlock$18=pthread_mutex_unlock(&this->vdr_entry_lock);
        if(!(return_value_pthread_mutex_unlock$18 == 0))
        {
          if(iSysLogLevel >= 1)
          {
            x_syslog(3, log_module_input_vdr, "%s:%d: pthread_mutex_unlock failed", (const void *)"vdr_plugin_write", 4709);
            signed int *return_value___errno_location$17;
            return_value___errno_location$17=__errno_location();
            if(!(*return_value___errno_location$17 == 0))
            {
              return_value___errno_location$15=__errno_location();
              return_value_strerror$16=strerror(*return_value___errno_location$15);
              x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 4709, return_value_strerror$16);
            }

          }

        }

        return len;
      }
    }
}

// vdr_x_demux_control_newpts
// file xine_input_vdr.c line 2032
static void vdr_x_demux_control_newpts(struct xine_stream_s *stream, signed long int pts, unsigned int flags)
{
  struct buf_element_s *buf;
  pthread_mutex_lock(&stream->demux_mutex);
  struct buf_element_s *tmp_if_expr$1;
  struct buf_element_s *return_value;
  if(!(stream->video_fifo == ((struct fifo_buffer_s *)NULL)))
  {
    return_value=stream->video_fifo->buffer_pool_try_alloc(stream->video_fifo);
    tmp_if_expr$1 = return_value;
  }

  else
    tmp_if_expr$1 = (struct buf_element_s *)(void *)0;
  buf = tmp_if_expr$1;
  if(!(buf == ((struct buf_element_s *)NULL)))
  {
    buf->type = (unsigned int)0x01070000;
    buf->decoder_flags = flags;
    buf->disc_off = pts;
    stream->video_fifo->put(stream->video_fifo, buf);
  }

  else
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_vdr, "vdr_x_demux_control_newpts: video fifo full !");

    while((_Bool)0);
  struct buf_element_s *tmp_if_expr$2;
  struct buf_element_s *return_value_1;
  if(!(stream->audio_fifo == ((struct fifo_buffer_s *)NULL)))
  {
    return_value_1=stream->audio_fifo->buffer_pool_try_alloc(stream->audio_fifo);
    tmp_if_expr$2 = return_value_1;
  }

  else
    tmp_if_expr$2 = (struct buf_element_s *)(void *)0;
  buf = tmp_if_expr$2;
  if(!(buf == ((struct buf_element_s *)NULL)))
  {
    buf->type = (unsigned int)0x01070000;
    buf->decoder_flags = flags;
    buf->disc_off = pts;
    stream->audio_fifo->put(stream->audio_fifo, buf);
  }

  else
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_vdr, "vdr_x_demux_control_newpts: audio fifo full !");

    while((_Bool)0);
  pthread_mutex_unlock(&stream->demux_mutex);
}

// video_size_changed
// file xine/osd_manager.c line 904
static void video_size_changed(struct osd_manager_s *this_gen, struct xine_stream_s *stream, signed int width, signed int height)
{
  struct osd_manager_impl_s *this = (struct osd_manager_impl_s *)this_gen;
  signed int i;
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  if(stream == ((struct xine_stream_s *)NULL))
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, log_module_input_osd, "video_size_changed: Stream not initialized !");

    while((_Bool)0);

  else
    if(!(height >= 1) || !(width >= 1))
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_osd, "video_size_changed: Invalid video size %dx%d", width, height);

      while((_Bool)0);

    else
    {
      signed int return_value_pthread_mutex_lock$4;
      return_value_pthread_mutex_lock$4=pthread_mutex_lock(&this->lock);
      if(!(return_value_pthread_mutex_lock$4 == 0))
        do
          if(iSysLogLevel >= 1)
          {
            x_syslog(3, log_module_input_osd, "video_size_changed: mutex lock failed");
            signed int *return_value___errno_location$3;
            return_value___errno_location$3=__errno_location();
            if(!(*return_value___errno_location$3 == 0))
            {
              return_value___errno_location$1=__errno_location();
              return_value_strerror$2=strerror(*return_value___errno_location$1);
              x_syslog(3, log_module_input_osd, "   (ERROR (%s,%d): %s)", (const void *)"xine/osd_manager.c", 920, return_value_strerror$2);
            }

          }

        while((_Bool)0);

      else
        if((signed int)this->video_width == width)
        {
          if(!((signed int)this->video_height == height))
            goto __CPROVER_DUMP_L11;

          pthread_mutex_unlock(&this->lock);
        }

        else
        {

        __CPROVER_DUMP_L11:
          ;
          this->stream = stream;
          this->video_width = (unsigned short int)width;
          this->video_height = (unsigned short int)height;
          if(this->vo_scaling == 0)
          {
            i = 0;
            for( ; !(i >= 50); i = i + 1)
              if(this->osd[(signed long int)i].handle >= 0)
              {
                if(!(this->osd[(signed long int)i].cmd.$anon0.data == ((struct osd_rle_elem_s *)NULL)))
                {
                  if((signed int)this->osd[(signed long int)i].cmd.scaling >= 1)
                  {
                    struct osd_command_s tmp;
                    memcpy$link3((void *)&tmp, (const void *)&this->osd[(signed long int)i].cmd, sizeof(struct osd_command_s) /*62ul*/ );
                    memset$link2((void *)&this->osd[(signed long int)i].cmd, 0, sizeof(struct osd_command_s) /*62ul*/ );
                    exec_osd_command_internal(this, &tmp);
                    clear_osdcmd(&tmp);
                  }

                }

              }

          }

          release_ticket(this);
          pthread_mutex_unlock(&this->lock);
        }
    }
}

// vsnprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 74
static inline signed int vsnprintf(char * restrict __s, unsigned long int __n, const char * restrict __fmt, void **__ap)
{
  signed int return_value___builtin___vsnprintf_chk$1;
  return_value___builtin___vsnprintf_chk$1=__builtin___vsnprintf_chk(__s, __n, 2 - 1, 18446744073709551615ul, __fmt, __ap);
  return return_value___builtin___vsnprintf_chk$1;
}

// wait_fifos_empty
// file xine_input_vdr.c line 1383
static void wait_fifos_empty(struct xine_stream_s *stream, signed int timeout_ms)
{
  signed int V;
  signed int A;
  V=stream->video_fifo->size(stream->video_fifo);
  A=stream->audio_fifo->size(stream->audio_fifo);
  if(iSysLogLevel >= 4)
    x_syslog(7, log_module_input_vdr, "wait_fifos_empty: video %d, audio %d", V, A);

  if(A >= 1 || V >= 1)
  {
    xine_usec_sleep((unsigned int)(5 * 1000));
    timeout_ms = timeout_ms - 5;
    if(iSysLogLevel >= 2)
      x_syslog(6, log_module_input_vdr, "wait_fifos_empty: timeout! video=%d audio=%d", V, A);

  }

}

// wait_stream_sync
// file xine_input_vdr.c line 3955
static signed int wait_stream_sync(struct vdr_input_plugin_s *this)
{
  signed int counter = 100;
  signed int return_value_pthread_mutex_lock$9;
  return_value_pthread_mutex_lock$9=pthread_mutex_lock(&this->lock);
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  signed int return_value__x_action_pending$4;
  signed int *return_value___errno_location$5;
  char *return_value_strerror$6;
  if(!(return_value_pthread_mutex_lock$9 == 0))
    do
      if(iSysLogLevel >= 1)
      {
        x_syslog(3, log_module_input_vdr, "pthread_mutex_lock (%s) failed, skipping locked block !", (const void *)"&this->lock");
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        if(!(*return_value___errno_location$3 == 0))
        {
          return_value___errno_location$1=__errno_location();
          return_value_strerror$2=strerror(*return_value___errno_location$1);
          x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 3959, return_value_strerror$2);
        }

      }

    while((_Bool)0);

  else
    do
    {
      struct anonymous$39 __cancel_buf;
      void (*__cancel_routine)(void *) = mutex_cleanup;
      void *__cancel_arg = (void *)&this->lock;
      signed int __not_first_call;
      __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
      if(!((signed long int)__not_first_call == 0l))
      {
        __cancel_routine(__cancel_arg);
        __pthread_unwind_next(&__cancel_buf);
      }

      __pthread_register_cancel(&__cancel_buf);
      do
      {
        if(!(this->discard_index >= this->discard_index_ds))
          do
            if(iSysLogLevel >= 4)
              x_syslog(7, log_module_input_vdr, "wait_stream_sync: waiting for engine_flushed condition %lu<%lu", this->discard_index, this->discard_index_ds);

          while((_Bool)0);

        while(!(this->control_running == 0))
        {
          if(this->discard_index >= this->discard_index_ds)
            break;

          return_value__x_action_pending$4=_x_action_pending(this->stream);
          if(!(return_value__x_action_pending$4 == 0))
            break;

          counter = counter - 1;
          if(!(counter >= 1))
            break;

          struct timespec abstime;
          create_timeout_time(&abstime, 10);
          pthread_cond_timedwait(&this->engine_flushed, &this->lock, &abstime);
        }
        if(!(this->discard_index == this->curpos))
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_input_vdr, "wait_stream_sync: discard_index %lu != curpos %lu ! (diff %ld)", this->discard_index, this->curpos, (signed long int)(this->discard_index - this->curpos));

          while((_Bool)0);

        signed int return_value_pthread_mutex_unlock$8;
        return_value_pthread_mutex_unlock$8=pthread_mutex_unlock(&this->lock);
        if(!(return_value_pthread_mutex_unlock$8 == 0))
          do
            if(iSysLogLevel >= 1)
            {
              x_syslog(3, log_module_input_vdr, "pthread_mutex_unlock (%s) failed !", (const void *)"&this->lock");
              signed int *return_value___errno_location$7;
              return_value___errno_location$7=__errno_location();
              if(!(*return_value___errno_location$7 == 0))
              {
                return_value___errno_location$5=__errno_location();
                return_value_strerror$6=strerror(*return_value___errno_location$5);
                x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 3979, return_value_strerror$6);
              }

            }

          while((_Bool)0);


      __CPROVER_DUMP_L17:
        ;
      }
      while((_Bool)0);
      __pthread_unregister_cancel(&__cancel_buf);
    }
    while((_Bool)0);
  signed int return_value__x_action_pending$13;
  if(this->discard_index == this->discard_index_ds)
  {
    do
      if(iSysLogLevel >= 4)
        x_syslog(7, log_module_input_vdr, "wait_stream_sync: streams synced at %lu/%lu", this->discard_index_ds, this->discard_index);

    while((_Bool)0);
    return 0;
  }

  else
  {
    if(this->control_running == 0)
    {
      signed int *return_value___errno_location$10;
      return_value___errno_location$10=__errno_location();
      *return_value___errno_location$10 = 107;
    }

    else
    {
      return_value__x_action_pending$13=_x_action_pending(this->stream);
      if(!(return_value__x_action_pending$13 == 0))
      {
        do
          if(iSysLogLevel >= 4)
            x_syslog(7, log_module_input_vdr, "wait_stream_sync: demux_action_pending set");

        while((_Bool)0);
        signed int *return_value___errno_location$11;
        return_value___errno_location$11=__errno_location();
        *return_value___errno_location$11 = 4;
      }

      else
        if(!(counter >= 1))
        {
          do
            if(iSysLogLevel >= 2)
              x_syslog(6, log_module_input_vdr, "wait_stream_sync: Timed out ! diff %ld", (signed long int)(this->discard_index - this->discard_index_ds));

          while((_Bool)0);
          signed int *return_value___errno_location$12;
          return_value___errno_location$12=__errno_location();
          *return_value___errno_location$12 = 11;
        }

    }
    return 1;
  }
}

// write_control
// file xine_input_vdr.c line 1001
static signed long int write_control(struct vdr_input_plugin_s *this, const char *str)
{
  signed long int ret = (signed long int)-1;
  signed int return_value_pthread_mutex_lock$9;
  return_value_pthread_mutex_lock$9=pthread_mutex_lock(&this->fd_control_lock);
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  signed int *return_value___errno_location$5;
  char *return_value_strerror$6;
  if(!(return_value_pthread_mutex_lock$9 == 0))
    do
      if(iSysLogLevel >= 1)
      {
        x_syslog(3, log_module_input_vdr, "pthread_mutex_lock (%s) failed, skipping locked block !", (const void *)"&this->fd_control_lock");
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        if(!(*return_value___errno_location$3 == 0))
        {
          return_value___errno_location$1=__errno_location();
          return_value_strerror$2=strerror(*return_value___errno_location$1);
          x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 1004, return_value_strerror$2);
        }

      }

    while((_Bool)0);

  else
    do
    {
      struct anonymous$39 __cancel_buf;
      void (*__cancel_routine)(void *) = mutex_cleanup;
      void *__cancel_arg = (void *)&this->fd_control_lock;
      signed int __not_first_call;
      __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
      if(!((signed long int)__not_first_call == 0l))
      {
        __cancel_routine(__cancel_arg);
        __pthread_unwind_next(&__cancel_buf);
      }

      __pthread_register_cancel(&__cancel_buf);
      do
      {
        unsigned long int return_value_strlen$4;
        return_value_strlen$4=strlen(str);
        ret=write_control_data(this, (const void *)str, return_value_strlen$4);
        signed int return_value_pthread_mutex_unlock$8;
        return_value_pthread_mutex_unlock$8=pthread_mutex_unlock(&this->fd_control_lock);
        if(!(return_value_pthread_mutex_unlock$8 == 0))
          do
            if(iSysLogLevel >= 1)
            {
              x_syslog(3, log_module_input_vdr, "pthread_mutex_unlock (%s) failed !", (const void *)"&this->fd_control_lock");
              signed int *return_value___errno_location$7;
              return_value___errno_location$7=__errno_location();
              if(!(*return_value___errno_location$7 == 0))
              {
                return_value___errno_location$5=__errno_location();
                return_value_strerror$6=strerror(*return_value___errno_location$5);
                x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 1006, return_value_strerror$6);
              }

            }

          while((_Bool)0);


      __CPROVER_DUMP_L10:
        ;
      }
      while((_Bool)0);
      __pthread_unregister_cancel(&__cancel_buf);
    }
    while((_Bool)0);
  return ret;
}

// write_control_data
// file xine_input_vdr.c line 933
static signed long int write_control_data(struct vdr_input_plugin_s *this, const void *str, unsigned long int len)
{
  unsigned long int ret;
  unsigned long int result = len;
  signed long int tmp_statement_expression$1;
  signed long int tmp_statement_expression$3;
  _Bool tmp_if_expr$12;
  signed long int tmp_statement_expression$10;
  _Bool tmp_if_expr$15;
  signed long int tmp_statement_expression$13;
  signed int *return_value___errno_location$6;
  char *return_value_strerror$7;
  signed int *return_value___errno_location$16;
  char *return_value_strerror$17;
  signed int *return_value___errno_location$31;
  signed int *return_value___errno_location$21;
  char *return_value_strerror$22;
  signed int *return_value___errno_location$30;
  signed int *return_value___errno_location$24;
  char *return_value_strerror$25;
  signed int *return_value___errno_location$27;
  char *return_value_strerror$28;
  while(len >= 1ul)
  {
    if(this->control_running == 0)
    {
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, log_module_input_vdr, "write_control aborted");

      while((_Bool)0);
      return (signed long int)-1;
    }

    struct anonymous$9 fdset;
    struct anonymous$9 eset;
    struct timeval select_timeout;
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$9) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&fdset)->fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    do
    {
      signed int write_control_data$$1$$1$$3$$__d0;
      signed int write_control_data$$1$$1$$3$$__d1;
      asm("cld; rep; stosq" : "=c"(write_control_data$$1$$1$$3$$__d0), "=D"(write_control_data$$1$$1$$3$$__d1) : "a"(0), "0"(sizeof(struct anonymous$9) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&eset)->fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    signed long int write_control_data$$1$$1$$4$$__d = (signed long int)this->fd_control;
    signed long int return_value___fdelt_chk$2;
    return_value___fdelt_chk$2=__fdelt_chk(write_control_data$$1$$1$$4$$__d);
    tmp_statement_expression$1 = return_value___fdelt_chk$2;
    (&fdset)->fds_bits[tmp_statement_expression$1] = (&fdset)->fds_bits[tmp_statement_expression$1] | (signed long int)(1UL << this->fd_control % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    signed long int write_control_data$$1$$1$$5$$__d = (signed long int)this->fd_control;
    signed long int return_value___fdelt_chk$4;
    return_value___fdelt_chk$4=__fdelt_chk(write_control_data$$1$$1$$5$$__d);
    tmp_statement_expression$3 = return_value___fdelt_chk$4;
    (&eset)->fds_bits[tmp_statement_expression$3] = (&eset)->fds_bits[tmp_statement_expression$3] | (signed long int)(1UL << this->fd_control % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    select_timeout.tv_sec = (signed long int)0;
    select_timeout.tv_usec = (signed long int)(500 * 1000);
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    *return_value___errno_location$5 = 0;
    signed int return_value_select$9;
    return_value_select$9=select(this->fd_control + 1, (struct anonymous$9 *)(void *)0, &fdset, &eset, &select_timeout);
    if(!(return_value_select$9 == 1))
      tmp_if_expr$12 = (_Bool)1;

    else
    {
      signed long int __d = (signed long int)this->fd_control;
      signed long int return_value___fdelt_chk$11;
      return_value___fdelt_chk$11=__fdelt_chk(__d);
      tmp_statement_expression$10 = return_value___fdelt_chk$11;
      tmp_if_expr$12 = !(((&fdset)->fds_bits[tmp_statement_expression$10] & (signed long int)(1UL << this->fd_control % (8 * (signed int)sizeof(signed long int) /*8ul*/ ))) != (signed long int)0) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$12)
      tmp_if_expr$15 = (_Bool)1;

    else
    {
      signed long int write_control_data$$1$$1$$7$$__d = (signed long int)this->fd_control;
      signed long int return_value___fdelt_chk$14;
      return_value___fdelt_chk$14=__fdelt_chk(write_control_data$$1$$1$$7$$__d);
      tmp_statement_expression$13 = return_value___fdelt_chk$14;
      tmp_if_expr$15 = ((&eset)->fds_bits[tmp_statement_expression$13] & (signed long int)(1UL << this->fd_control % (8 * (signed int)sizeof(signed long int) /*8ul*/ ))) != (signed long int)0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$15)
    {
      do
        if(iSysLogLevel >= 1)
        {
          x_syslog(3, log_module_input_vdr, "write_control failed (poll timeout or error)");
          signed int *return_value___errno_location$8;
          return_value___errno_location$8=__errno_location();
          if(!(*return_value___errno_location$8 == 0))
          {
            return_value___errno_location$6=__errno_location();
            return_value_strerror$7=strerror(*return_value___errno_location$6);
            x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 957, return_value_strerror$7);
          }

        }

      while((_Bool)0);
      this->control_running = 0;
      return (signed long int)-1;
    }

    if(this->control_running == 0)
    {
      do
        if(iSysLogLevel >= 1)
        {
          x_syslog(3, log_module_input_vdr, "write_control aborted");
          signed int *return_value___errno_location$18;
          return_value___errno_location$18=__errno_location();
          if(!(*return_value___errno_location$18 == 0))
          {
            return_value___errno_location$16=__errno_location();
            return_value_strerror$17=strerror(*return_value___errno_location$16);
            x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 963, return_value_strerror$17);
          }

        }

      while((_Bool)0);
      return (signed long int)-1;
    }

    signed int *return_value___errno_location$19;
    return_value___errno_location$19=__errno_location();
    *return_value___errno_location$19 = 0;
    signed long int return_value_write$20;
    return_value_write$20=write(this->fd_control, str, len);
    ret = (unsigned long int)return_value_write$20;
    if(!(ret >= 1ul))
    {
      if(ret == 0ul)
        do
          if(iSysLogLevel >= 2)
            x_syslog(6, log_module_input_vdr, "write_control: disconnected");

        while((_Bool)0);

      else
      {
        return_value___errno_location$31=__errno_location();
        if(*return_value___errno_location$31 == 11)
        {
          do
            if(iSysLogLevel >= 1)
            {
              x_syslog(3, log_module_input_vdr, "write_control failed: EAGAIN");
              signed int *return_value___errno_location$23;
              return_value___errno_location$23=__errno_location();
              if(!(*return_value___errno_location$23 == 0))
              {
                return_value___errno_location$21=__errno_location();
                return_value_strerror$22=strerror(*return_value___errno_location$21);
                x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 974, return_value_strerror$22);
              }

            }

          while((_Bool)0);
          continue;
        }

        else
        {
          return_value___errno_location$30=__errno_location();
          if(*return_value___errno_location$30 == 4)
          {
            do
              if(iSysLogLevel >= 1)
              {
                x_syslog(3, log_module_input_vdr, "write_control failed: EINTR");
                signed int *return_value___errno_location$26;
                return_value___errno_location$26=__errno_location();
                if(!(*return_value___errno_location$26 == 0))
                {
                  return_value___errno_location$24=__errno_location();
                  return_value_strerror$25=strerror(*return_value___errno_location$24);
                  x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 977, return_value_strerror$25);
                }

              }

            while((_Bool)0);
            pthread_testcancel();
            continue;
          }

          else
            do
              if(iSysLogLevel >= 1)
              {
                x_syslog(3, log_module_input_vdr, "write_control failed");
                signed int *return_value___errno_location$29;
                return_value___errno_location$29=__errno_location();
                if(!(*return_value___errno_location$29 == 0))
                {
                  return_value___errno_location$27=__errno_location();
                  return_value_strerror$28=strerror(*return_value___errno_location$27);
                  x_syslog(3, log_module_input_vdr, "   (ERROR (%s,%d): %s)", (const void *)"xine_input_vdr.c", 981, return_value_strerror$28);
                }

              }

            while((_Bool)0);
        }
      }
      this->control_running = 0;
      return (signed long int)-1;
    }

    len = len - ret;
    str = (const void *)((unsigned char *)str + (signed long int)ret);
  }
  return (signed long int)result;
}

// write_rle_hdmv
// file tools/rle.c line 210
static unsigned char * write_rle_hdmv(unsigned char *rle_data, unsigned int color, unsigned int len)
{
  unsigned char *tmp_post$1;
  if(!(color == 0u) && !(len >= 4u))
  {
    unsigned int i = (unsigned int)0;
    for( ; !(i >= len); i = i + 1u)
    {
      tmp_post$1 = rle_data;
      rle_data = rle_data + 1l;
      *tmp_post$1 = (unsigned char)color;
    }
    return rle_data;
  }

  unsigned char *tmp_post$2 = rle_data;
  rle_data = rle_data + 1l;
  *tmp_post$2 = (unsigned char)0;
  unsigned char *tmp_post$3;
  unsigned char *tmp_post$4;
  unsigned char *tmp_post$5;
  unsigned char *tmp_post$6;
  unsigned char *tmp_post$7;
  unsigned char *tmp_post$8;
  unsigned char *tmp_post$9;
  if(color == 0u)
  {
    if(!(len >= 64u))
    {
      tmp_post$3 = rle_data;
      rle_data = rle_data + 1l;
      *tmp_post$3 = (unsigned char)len;
    }

    else
    {
      tmp_post$4 = rle_data;
      rle_data = rle_data + 1l;
      *tmp_post$4 = (unsigned char)((unsigned int)0x40 | len >> 8 & (unsigned int)0x3f);
      tmp_post$5 = rle_data;
      rle_data = rle_data + 1l;
      *tmp_post$5 = (unsigned char)(len & (unsigned int)0xff);
    }
  }

  else
  {
    if(!(len >= 64u))
    {
      tmp_post$6 = rle_data;
      rle_data = rle_data + 1l;
      *tmp_post$6 = (unsigned char)((unsigned int)0x80 | len);
    }

    else
    {
      tmp_post$7 = rle_data;
      rle_data = rle_data + 1l;
      *tmp_post$7 = (unsigned char)((unsigned int)(0x80 | 0x40) | len >> 8 & (unsigned int)0x3f);
      tmp_post$8 = rle_data;
      rle_data = rle_data + 1l;
      *tmp_post$8 = (unsigned char)(len & (unsigned int)0xff);
    }
    tmp_post$9 = rle_data;
    rle_data = rle_data + 1l;
    *tmp_post$9 = (unsigned char)color;
  }
  return rle_data;
}

// x_syslog
// file xine_input_vdr.c line 150
void x_syslog(signed int level, const char *module, const char *fmt, ...)
{
  void **argp;
  char buf[512l];
  argp = (void **)&fmt;
  vsnprintf(buf, sizeof(char [512l]) /*512ul*/ , fmt, argp);
  buf[(signed long int)(sizeof(char [512l]) /*512ul*/  - (unsigned long int)1)] = (char)0;
  if(bLogToSysLog == 0)
  {
    signed long int return_value_syscall$1;
    return_value_syscall$1=syscall((signed long int)186);
    fprintf(stderr, "[%ld] %s%s\n", return_value_syscall$1, module, (const void *)buf);
  }

  else
  {
    signed long int return_value_syscall$2;
    return_value_syscall$2=syscall((signed long int)186);
    syslog(level, "[%ld] %s%s", return_value_syscall$2, module, (const void *)buf);
  }
  argp = ((void **)NULL);
}

// xvdr_metronom_dispose
// file xine/xvdr_metronom.c line 363
static void xvdr_metronom_dispose(struct xvdr_metronom_s$0 *this)
{
  xvdr_metronom_unwire(this);
  pthread_mutex_destroy(&this->mutex);
  free((void *)this);
}

// xvdr_metronom_init
// file xine/xvdr_metronom.c line 376
struct xvdr_metronom_s$0 * xvdr_metronom_init(struct xine_stream_s$0 *stream)
{
  signed long int return_value;
  return_value=stream->metronom->get_option(stream->metronom, 0x1001 + 3);
  if(return_value == 4100l)
  {
    if(iSysLogLevel >= 2)
      x_syslog(6, "[metronom ] ", "xvdr_metronom_init(): stream already hooked !");

    return (struct xvdr_metronom_s$0 *)stream->metronom;
  }

  else
  {
    struct xvdr_metronom_s$0 *this;
    void *return_value_calloc$1;
    return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct xvdr_metronom_s$0) /*232ul*/ );
    this = (struct xvdr_metronom_s$0 *)return_value_calloc$1;
    this->stream = stream;
    this->orig_metronom = stream->metronom;
    this->wire = xvdr_metronom_wire;
    this->unwire = xvdr_metronom_unwire;
    this->dispose = xvdr_metronom_dispose;
    this->metronom.set_audio_rate = set_audio_rate;
    this->metronom.got_video_frame = got_video_frame;
    this->metronom.got_audio_samples = got_audio_samples;
    this->metronom.got_spu_packet = got_spu_packet;
    this->metronom.handle_audio_discontinuity = handle_audio_discontinuity;
    this->metronom.handle_video_discontinuity = handle_video_discontinuity;
    this->metronom.set_option = set_option;
    this->metronom.get_option = get_option;
    this->metronom.set_master = set_master;
    this->metronom.exit = metronom_exit;
    pthread_mutex_init(&this->mutex, (const union anonymous$37 *)(void *)0);
    xvdr_metronom_wire(this);
    return this;
  }
}

// xvdr_metronom_unwire
// file xine/xvdr_metronom.c line 353
static void xvdr_metronom_unwire(struct xvdr_metronom_s$0 *this)
{
  if(!(this->stream == ((struct xine_stream_s$0 *)NULL)))
  {
    if(!(this->wired == 0))
    {
      this->wired = 0;
      this->stream->metronom = this->orig_metronom;
    }

  }

}

// xvdr_metronom_wire
// file xine/xvdr_metronom.c line 333
static void xvdr_metronom_wire(struct xvdr_metronom_s$0 *this)
{
  if(this->stream == ((struct xine_stream_s$0 *)NULL))
    do
      if(iSysLogLevel >= 2)
        x_syslog(6, "[metronom ] ", "xvdr_metronom_wire(): stream == NULL !");

    while((_Bool)0);

  else
    if(this->stream->metronom == ((struct metronom_s *)NULL))
      do
        if(iSysLogLevel >= 2)
          x_syslog(6, "[metronom ] ", "xvdr_metronom_wire(): stream->metronom == NULL !");

      while((_Bool)0);

    else
      if(this->wired == 0)
      {
        this->wired = 1;
        this->orig_metronom = this->stream->metronom;
        this->stream->metronom = &this->metronom;
      }

}

