// #anon_enum$UPD_none=0$UPD_hide=1$UPD_show=2$UPD_timer=4$UPD_pos=8$UPD_lines=16$UPD_mask=32$UPD_size=64$UPD_content=48$UPD_font=120
// file intern.h line 126
enum anonymous$43 { UPD_none=0, UPD_hide=1, UPD_show=2, UPD_timer=4, UPD_pos=8, UPD_lines=16, UPD_mask=32, UPD_size=64, UPD_content=48, UPD_font=120 };

// #anon_enum$XOSD_left=0$XOSD_center=1$XOSD_right=2
// file ../../src/xosd.h line 44
enum anonymous$5 { XOSD_left=0, XOSD_center=1, XOSD_right=2 };

// #anon_enum$XOSD_percentage=0$XOSD_string=1$XOSD_printf=2$XOSD_slider=3
// file xosd.h line 27
enum anonymous$12 { XOSD_percentage=0, XOSD_string=1, XOSD_printf=2, XOSD_slider=3 };

// #anon_enum$XOSD_top=0$XOSD_bottom=1$XOSD_middle=2
// file ../../src/xosd.h line 36
enum anonymous$45 { XOSD_top=0, XOSD_bottom=1, XOSD_middle=2 };

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]
// file /usr/include/X11/Xlib.h line 257
struct anonymous$13;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private1'||S32'fd'||S32'private2'||S32'proto_major_version'||S32'proto_minor_version'||*{S8}$S8$'vendor'||U64'private3'||U64'private4'||U64'private5'||S32'private6'||U32'$pad0'||*{U64(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->U64}$U64(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->U64$'resource_alloc'||S32'byte_order'||S32'bitmap_unit'||S32'bitmap_pad'||S32'bitmap_bit_order'||S32'nformats'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]#$'pixmap_format'||S32'private8'||S32'release'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private9'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private10'||S32'qlen'||U32'$pad2'||U64'last_request_read'||U64'request'||*{S8}$S8$'private11'||*{S8}$S8$'private12'||*{S8}$S8$'private13'||*{S8}$S8$'private14'||U32'max_request_size'||U32'$pad3'||*{SYM#tag-_XrmHashBucketRec#}$SYM#tag-_XrmHashBucketRec#$'db'||*{S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->S32}$S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->S32$'private15'||*{S8}$S8$'display_name'||S32'default_screen'||S32'nscreens'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#$'screens'||U64'motion_buffer'||U64'private16'||S32'min_keycode'||S32'max_keycode'||*{S8}$S8$'private17'||*{S8}$S8$'private18'||S32'private19'||U32'$pad4'||*{S8}$S8$'xdefaults'|]
// file /usr/include/X11/Xlib.h line 493
struct anonymous$19;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]
// file /usr/include/X11/Xlib.h line 280
struct anonymous$17;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]
// file /usr/include/X11/Xlib.h line 227
struct anonymous$42;

// tag-#anon#ST[ARR16{S64}$S64$'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$7;

// tag-#anon#ST[S16'x'||S16'y'||U16'width'||U16'height'|]
// file /usr/include/X11/Xlib.h line 430
struct anonymous$1;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$15;

// tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]
// file /usr/include/X11/Xlib.h line 243
struct anonymous;

// tag-#anon#ST[S32'function'||U32'$pad0'||U64'plane_mask'||U64'foreground'||U64'background'||S32'line_width'||S32'line_style'||S32'cap_style'||S32'join_style'||S32'fill_style'||S32'fill_rule'||S32'arc_mode'||U32'$pad1'||U64'tile'||U64'stipple'||S32'ts_x_origin'||S32'ts_y_origin'||U64'font'||S32'subwindow_mode'||S32'graphics_exposures'||S32'clip_x_origin'||S32'clip_y_origin'||U64'clip_mask'||S32'dash_offset'||S8'dashes'||U24'$pad2'|]
// file /usr/include/X11/Xlib.h line 181
struct anonymous$46;

// tag-#anon#ST[S32'screen_number'||S16'x_org'||S16'y_org'||S16'width'||S16'height'|]
// file /usr/include/X11/extensions/Xinerama.h line 32
struct anonymous$11;

// tag-#anon#ST[S32'type'||U32'$pad0'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'resourceid'||U64'serial'||U8'error_code'||U8'request_code'||U8'minor_code'||U40'$pad1'|]
// file /usr/include/X11/Xlib.h line 924
struct anonymous$52;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||S32'extension'||S32'evtype'|]
// file /usr/include/X11/Xlib.h line 948
struct anonymous$6;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||S32'extension'||S32'evtype'||U32'cookie'||U32'$pad2'||*{V}$V$'data'|]
// file /usr/include/X11/Xlib.h line 958
struct anonymous$8;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'drawable'||S32'major_code'||S32'minor_code'|]
// file /usr/include/X11/Xlib.h line 686
struct anonymous$49;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'drawable'||S32'x'||S32'y'||S32'width'||S32'height'||S32'count'||S32'major_code'||S32'minor_code'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 673
struct anonymous$47;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'|]
// file /usr/include/X11/Xlib.h line 718
struct anonymous$25;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'from_configure'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 727
struct anonymous$26;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'override_redirect'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 737
struct anonymous$27;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'place'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 816
struct anonymous$35;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'x'||S32'y'|]
// file /usr/include/X11/Xlib.h line 782
struct anonymous$32;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||U32'$pad2'||U64'above'||S32'override_redirect'||U32'$pad3'|]
// file /usr/include/X11/Xlib.h line 768
struct anonymous$31;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||U64'parent'||S32'x'||S32'y'||S32'override_redirect'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 756
struct anonymous$30;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'owner'||U64'requestor'||U64'selection'||U64'target'||U64'property'||U64'time'|]
// file /usr/include/X11/Xlib.h line 857
struct anonymous$39;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'|]
// file /usr/include/X11/Xlib.h line 747
struct anonymous$28;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'||S32'place'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 826
struct anonymous$36;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||S32'override_redirect'|]
// file /usr/include/X11/Xlib.h line 705
struct anonymous$24;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||U32'$pad2'||U64'above'||S32'detail'||U32'$pad3'||U64'value_mask'|]
// file /usr/include/X11/Xlib.h line 801
struct anonymous$34;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'requestor'||U64'selection'||U64'target'||U64'property'||U64'time'|]
// file /usr/include/X11/Xlib.h line 870
struct anonymous$40;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'|]
// file /usr/include/X11/Xlib.h line 934
struct anonymous$0;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||ARR32{S8}$S8$'key_vector'|]
// file /usr/include/X11/Xlib.h line 653
struct anonymous$14;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'mode'||S32'detail'|]
// file /usr/include/X11/Xlib.h line 634
struct anonymous$9;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'request'||S32'first_keycode'||S32'count'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 912
struct anonymous$29;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'state'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 696
struct anonymous$23;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'width'||S32'height'|]
// file /usr/include/X11/Xlib.h line 792
struct anonymous$33;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'count'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 662
struct anonymous$22;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'atom'||U64'time'||S32'state'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 836
struct anonymous$37;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'colormap'||S32'new'||S32'state'|]
// file /usr/include/X11/Xlib.h line 882
struct anonymous$41;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'message_type'||S32'format'||U32'$pad2'||SYM#tag-#anon#UN[ARR20{S8}$S8$'b'||ARR10{S16}$S16$'s'||ARR5{S64}$S64$'l'|]#'data'|]
// file /usr/include/X11/Xlib.h line 897
struct anonymous$21;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||S32'mode'||S32'detail'||S32'same_screen'||S32'focus'||U32'state'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 610
struct anonymous$4;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||S8'is_hint'||U24'$pad2'||S32'same_screen'||U32'$pad3'|]
// file /usr/include/X11/Xlib.h line 593
struct anonymous$2;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||U32'button'||S32'same_screen'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 575
struct anonymous$50;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||U32'keycode'||S32'same_screen'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 557
struct anonymous$44;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'selection'||U64'time'|]
// file /usr/include/X11/Xlib.h line 847
struct anonymous$38;

// tag-#anon#ST[SYM#tag-#anon#ST[S16'x'||S16'y'||U16'width'||U16'height'|]#'max_ink_extent'||SYM#tag-#anon#ST[S16'x'||S16'y'||U16'width'||U16'height'|]#'max_logical_extent'|]
// file /usr/include/X11/Xlib.h line 1084
struct anonymous$10;

// tag-#anon#ST[U64'background_pixmap'||U64'background_pixel'||U64'border_pixmap'||U64'border_pixel'||S32'bit_gravity'||S32'win_gravity'||S32'backing_store'||U32'$pad0'||U64'backing_planes'||U64'backing_pixel'||S32'save_under'||U32'$pad1'||S64'event_mask'||S64'do_not_propagate_mask'||S32'override_redirect'||U32'$pad2'||U64'colormap'||U64'cursor'|]
// file /usr/include/X11/Xlib.h line 290
struct anonymous$3;

// tag-#anon#ST[U64'pixel'||U16'red'||U16'green'||U16'blue'||S8'flags'||S8'pad'|]
// file /usr/include/X11/Xlib.h line 410
struct anonymous$48;

// tag-#anon#UN[ARR20{S8}$S8$'b'||ARR10{S16}$S16$'s'||ARR5{S64}$S64$'l'|]
// file /usr/include/X11/Xlib.h line 905
union anonymous$51;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$18;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$16;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$20;

// tag-DEBUG_LEVEL
// file intern.h line 36
const enum DEBUG_LEVEL { Dnone=0, Dfunction=1, Dlocking=2, Dselect=4, Dtrace=8, Dvalue=16, Dupdate=32, Dall=-1 };

// tag-LINE
// file intern.h line 66
enum LINE { LINE_blank=0, LINE_text=1, LINE_percentage=2, LINE_slider=3 };

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_XDisplay
// file /usr/include/X11/Xlib.h line 255
struct _XDisplay;

// tag-_XEvent
// file /usr/include/X11/Xlib.h line 973
union _XEvent;

// tag-_XExtData
// file /usr/include/X11/Xlib.h line 148
struct _XExtData;

// tag-_XGC
// file /usr/include/X11/Xlib.h line 214
struct _XGC;

// tag-_XOC
// file /usr/include/X11/Xlib.h line 1094
struct _XOC;

// tag-_XPrivate
// file /usr/include/X11/Xlib.h line 490
struct _XPrivate;

// tag-_XrmHashBucketRec
// file /usr/include/X11/Xlib.h line 491
struct _XrmHashBucketRec;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-xosd
// file ../../src/xosd.h line 24
struct xosd;

// tag-xosd_bar
// file intern.h line 75
struct xosd_bar;

// tag-xosd_line
// file intern.h line 67
union xosd_line;

// tag-xosd_text
// file intern.h line 70
struct xosd_text;

#include <assert.h>
#include <stdarg.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// XAllocColor
// file /usr/include/X11/Xlib.h line 1958
extern signed int XAllocColor(struct _XDisplay *, unsigned long int, struct anonymous$48 *);
// XCloseDisplay
// file /usr/include/X11/Xlib.h line 2160
extern signed int XCloseDisplay(struct _XDisplay *);
// XCopyArea
// file /usr/include/X11/Xlib.h line 2184
extern signed int XCopyArea(struct _XDisplay *, unsigned long int, unsigned long int, struct _XGC *, signed int, signed int, unsigned int, unsigned int, signed int, signed int);
// XCreateFontSet
// file /usr/include/X11/Xlib.h line 3609
extern struct _XOC * XCreateFontSet(struct _XDisplay *, const char *, char ***, signed int *, char **);
// XCreateGC
// file /usr/include/X11/Xlib.h line 1584
extern struct _XGC * XCreateGC(struct _XDisplay *, unsigned long int, unsigned long int, struct anonymous$46 *);
// XCreatePixmap
// file /usr/include/X11/Xlib.h line 1597
extern unsigned long int XCreatePixmap(struct _XDisplay *, unsigned long int, unsigned int, unsigned int, unsigned int);
// XCreateWindow
// file /usr/include/X11/Xlib.h line 1636
extern unsigned long int XCreateWindow(struct _XDisplay *, unsigned long int, signed int, signed int, unsigned int, unsigned int, unsigned int, signed int, unsigned int, struct anonymous$42 *, unsigned long int, struct anonymous$3 *);
// XDefaultScreen
// file /usr/include/X11/Xlib.h line 2227
extern signed int XDefaultScreen(struct _XDisplay *);
// XDestroyWindow
// file /usr/include/X11/Xlib.h line 2243
extern signed int XDestroyWindow(struct _XDisplay *, unsigned long int);
// XDisplayHeight
// file /usr/include/X11/Xlib.h line 2271
extern signed int XDisplayHeight(struct _XDisplay *, signed int);
// XDisplayWidth
// file /usr/include/X11/Xlib.h line 2292
extern signed int XDisplayWidth(struct _XDisplay *, signed int);
// XExtentsOfFontSet
// file /usr/include/X11/Xlib.h line 3648
extern struct anonymous$10 * XExtentsOfFontSet(struct _XOC *);
// XFillRectangle
// file /usr/include/X11/Xlib.h line 2489
extern signed int XFillRectangle(struct _XDisplay *, unsigned long int, struct _XGC *, signed int, signed int, unsigned int, unsigned int);
// XFillRectangles
// file /usr/include/X11/Xlib.h line 2499
extern signed int XFillRectangles(struct _XDisplay *, unsigned long int, struct _XGC *, struct anonymous$1 *, signed int);
// XFlush
// file /usr/include/X11/Xlib.h line 2507
extern signed int XFlush(struct _XDisplay *);
// XFree
// file /usr/include/X11/Xlib.h line 2516
extern signed int XFree(void *);
// XFreeFontSet
// file /usr/include/X11/Xlib.h line 3617
extern void XFreeFontSet(struct _XDisplay *, struct _XOC *);
// XFreeGC
// file /usr/include/X11/Xlib.h line 2561
extern signed int XFreeGC(struct _XDisplay *, struct _XGC *);
// XFreePixmap
// file /usr/include/X11/Xlib.h line 2570
extern signed int XFreePixmap(struct _XDisplay *, unsigned long int);
// XFreeStringList
// file /usr/include/X11/Xlib.h line 1922
extern void XFreeStringList(char **);
// XGetWindowProperty
// file /usr/include/X11/Xlib.h line 2676
extern signed int XGetWindowProperty(struct _XDisplay *, unsigned long int, unsigned long int, signed long int, signed long int, signed int, unsigned long int, unsigned long int *, signed int *, unsigned long int *, unsigned long int *, unsigned char **);
// XInternAtom
// file /usr/include/X11/Xlib.h line 1536
extern unsigned long int XInternAtom(struct _XDisplay *, const char *, signed int);
// XMapRaised
// file /usr/include/X11/Xlib.h line 2796
extern signed int XMapRaised(struct _XDisplay *, unsigned long int);
// XMoveWindow
// file /usr/include/X11/Xlib.h line 2834
extern signed int XMoveWindow(struct _XDisplay *, unsigned long int, signed int, signed int);
// XNextEvent
// file /usr/include/X11/Xlib.h line 2841
extern signed int XNextEvent(struct _XDisplay *, union _XEvent *);
// XOpenDisplay
// file /usr/include/X11/Xlib.h line 1483
extern struct _XDisplay * XOpenDisplay(const char *);
// XParseColor
// file /usr/include/X11/Xlib.h line 2850
extern signed int XParseColor(struct _XDisplay *, unsigned long int, const char *, struct anonymous$48 *);
// XRaiseWindow
// file /usr/include/X11/Xlib.h line 3026
extern signed int XRaiseWindow(struct _XDisplay *, unsigned long int);
// XResizeWindow
// file /usr/include/X11/Xlib.h line 3099
extern signed int XResizeWindow(struct _XDisplay *, unsigned long int, unsigned int, unsigned int);
// XRootWindow
// file /usr/include/X11/Xlib.h line 1765
extern unsigned long int XRootWindow(struct _XDisplay *, signed int);
// XSelectInput
// file /usr/include/X11/Xlib.h line 3129
extern signed int XSelectInput(struct _XDisplay *, unsigned long int, signed long int);
// XSendEvent
// file /usr/include/X11/Xlib.h line 3135
extern signed int XSendEvent(struct _XDisplay *, unsigned long int, signed int, signed long int, union _XEvent *);
// XSetBackground
// file /usr/include/X11/Xlib.h line 3154
extern signed int XSetBackground(struct _XDisplay *, struct _XGC *, unsigned long int);
// XSetForeground
// file /usr/include/X11/Xlib.h line 3227
extern signed int XSetForeground(struct _XDisplay *, struct _XGC *, unsigned long int);
// XShapeCombineMask
// file /usr/include/X11/extensions/shape.h line 85
extern void XShapeCombineMask(struct _XDisplay *, unsigned long int, signed int, signed int, signed int, unsigned long int, signed int);
// XShapeQueryExtension
// file /usr/include/X11/extensions/shape.h line 51
extern signed int XShapeQueryExtension(struct _XDisplay *, signed int *, signed int *);
// XStoreName
// file /usr/include/X11/Xlib.h line 3395
extern signed int XStoreName(struct _XDisplay *, unsigned long int, const char *);
// XUnmapWindow
// file /usr/include/X11/Xlib.h line 3505
extern signed int XUnmapWindow(struct _XDisplay *, unsigned long int);
// XineramaIsActive
// file /usr/include/X11/extensions/Xinerama.h line 54
signed int XineramaIsActive(struct _XDisplay *);
// XineramaQueryExtension
// file /usr/include/X11/extensions/Xinerama.h line 42
signed int XineramaQueryExtension(struct _XDisplay *, signed int *, signed int *);
// XineramaQueryScreens
// file /usr/include/X11/extensions/Xinerama.h line 66
struct anonymous$11 * XineramaQueryScreens(struct _XDisplay *, signed int *);
// XmbDrawString
// file /usr/include/X11/Xlib.h line 3760
extern void XmbDrawString(struct _XDisplay *, unsigned long int, struct _XOC *, struct _XGC *, signed int, signed int, const char *, signed int);
// XmbTextExtents
// file /usr/include/X11/Xlib.h line 3670
extern signed int XmbTextExtents(struct _XOC *, const char *, signed int, struct anonymous$1 *, struct anonymous$1 *);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _draw_bar
// file xosd.c line 98
static void _draw_bar(struct xosd *osd, signed int nbars, signed int on, struct anonymous$1 *p, struct anonymous$1 *mod, signed int is_slider);
// _draw_text
// file xosd.c line 186
static void _draw_text(struct xosd *osd, char *string, signed int x, signed int y);
// _wait_until_update
// file xosd.c line 38
static void _wait_until_update(struct xosd *osd, signed int generation);
// _xosd_lock
// file xosd.c line 72
static void _xosd_lock(struct xosd *osd);
// _xosd_unlock
// file xosd.c line 81
static void _xosd_unlock(struct xosd *osd);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// draw_bar
// file xosd.c line 119
static void draw_bar(struct xosd *osd, signed int line);
// draw_text
// file xosd.c line 197
static void draw_text(struct xosd *osd, signed int line);
// event_loop
// file xosd.c line 258
static void * event_loop(void *osdv);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// parse_colour
// file xosd.c line 509
static signed int parse_colour(struct xosd *osd, struct anonymous$48 *col, unsigned long int *pixel, const char *colour);
// pipe
// file /usr/include/unistd.h line 417
extern signed int pipe(signed int *);
// printerror
// file testprog.c line 8
void printerror();
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous$16 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous$16 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$16 *, const union anonymous$18 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$16 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$16 *, union anonymous$20 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$20 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$20 *, const union anonymous$18 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$20 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$20 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$7 *, struct anonymous$7 *, struct anonymous$7 *, struct timeval *);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// stay_on_top
// file xosd.c line 543
void stay_on_top(struct _XDisplay *dpy, unsigned long int win);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// xosd_create
// file xosd.h line 59
struct xosd * xosd_create(signed int number_lines);
// xosd_destroy
// file xosd.h line 92
signed int xosd_destroy(struct xosd *osd);
// xosd_display
// file xosd.h line 134
signed int xosd_display(struct xosd *osd, signed int line, enum anonymous$12 command, ...);
// xosd_get_colour
// file xosd.c line 1242
signed int xosd_get_colour(struct xosd *osd, signed int *red, signed int *green, signed int *blue);
// xosd_get_number_lines
// file xosd.c line 1353
signed int xosd_get_number_lines(struct xosd *osd);
// xosd_hide
// file xosd.c line 1278
signed int xosd_hide(struct xosd *osd);
// xosd_init
// file xosd.c line 619
struct xosd * xosd_init(const char *font, const char *colour, signed int timeout, enum anonymous$45 pos, signed int voffset, signed int shadow_offset, signed int number_lines);
// xosd_is_onscreen
// file xosd.c line 1000
signed int xosd_is_onscreen(struct xosd *osd);
// xosd_scroll
// file xosd.h line 346
signed int xosd_scroll(struct xosd *osd, signed int lines);
// xosd_set_align
// file xosd.c line 1224
signed int xosd_set_align(struct xosd *osd, enum anonymous$5 align);
// xosd_set_bar_length
// file xosd.h line 115
signed int xosd_set_bar_length(struct xosd *osd, signed int length);
// xosd_set_colour
// file xosd.c line 1030
signed int xosd_set_colour(struct xosd *osd, const char *colour);
// xosd_set_font
// file xosd.h line 320
signed int xosd_set_font(struct xosd *osd, const char *font);
// xosd_set_horizontal_offset
// file xosd.c line 1188
signed int xosd_set_horizontal_offset(struct xosd *osd, signed int hoffset);
// xosd_set_outline_colour
// file xosd.c line 1070
signed int xosd_set_outline_colour(struct xosd *osd, const char *colour);
// xosd_set_outline_offset
// file xosd.h line 229
signed int xosd_set_outline_offset(struct xosd *osd, signed int outline_offset);
// xosd_set_pos
// file xosd.c line 1206
signed int xosd_set_pos(struct xosd *osd, enum anonymous$45 pos);
// xosd_set_shadow_colour
// file xosd.c line 1050
signed int xosd_set_shadow_colour(struct xosd *osd, const char *colour);
// xosd_set_shadow_offset
// file xosd.c line 1130
signed int xosd_set_shadow_offset(struct xosd *osd, signed int shadow_offset);
// xosd_set_timeout
// file xosd.h line 295
signed int xosd_set_timeout(struct xosd *osd, signed int timeout);
// xosd_set_vertical_offset
// file xosd.c line 1170
signed int xosd_set_vertical_offset(struct xosd *osd, signed int voffset);
// xosd_show
// file xosd.c line 1298
signed int xosd_show(struct xosd *osd);
// xosd_uninit
// file xosd.c line 834
signed int xosd_uninit(struct xosd *osd);
// xosd_wait_until_no_display
// file xosd.h line 157
signed int xosd_wait_until_no_display(struct xosd *osd);

struct anonymous$13
{
  // ext_data
  struct _XExtData *ext_data;
  // display
  struct _XDisplay *display;
  // root
  unsigned long int root;
  // width
  signed int width;
  // height
  signed int height;
  // mwidth
  signed int mwidth;
  // mheight
  signed int mheight;
  // ndepths
  signed int ndepths;
  // depths
  struct anonymous *depths;
  // root_depth
  signed int root_depth;
  // root_visual
  struct anonymous$42 *root_visual;
  // default_gc
  struct _XGC *default_gc;
  // cmap
  unsigned long int cmap;
  // white_pixel
  unsigned long int white_pixel;
  // black_pixel
  unsigned long int black_pixel;
  // max_maps
  signed int max_maps;
  // min_maps
  signed int min_maps;
  // backing_store
  signed int backing_store;
  // save_unders
  signed int save_unders;
  // root_input_mask
  signed long int root_input_mask;
};

struct anonymous$19
{
  // ext_data
  struct _XExtData *ext_data;
  // private1
  struct _XPrivate *private1;
  // fd
  signed int fd;
  // private2
  signed int private2;
  // proto_major_version
  signed int proto_major_version;
  // proto_minor_version
  signed int proto_minor_version;
  // vendor
  char *vendor;
  // private3
  unsigned long int private3;
  // private4
  unsigned long int private4;
  // private5
  unsigned long int private5;
  // private6
  signed int private6;
  // resource_alloc
  unsigned long int (*resource_alloc)(struct _XDisplay *);
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_pad
  signed int bitmap_pad;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // nformats
  signed int nformats;
  // pixmap_format
  struct anonymous$17 *pixmap_format;
  // private8
  signed int private8;
  // release
  signed int release;
  // private9
  struct _XPrivate *private9;
  // private10
  struct _XPrivate *private10;
  // qlen
  signed int qlen;
  // last_request_read
  unsigned long int last_request_read;
  // request
  unsigned long int request;
  // private11
  char *private11;
  // private12
  char *private12;
  // private13
  char *private13;
  // private14
  char *private14;
  // max_request_size
  unsigned int max_request_size;
  // db
  struct _XrmHashBucketRec *db;
  // private15
  signed int (*private15)(struct _XDisplay *);
  // display_name
  char *display_name;
  // default_screen
  signed int default_screen;
  // nscreens
  signed int nscreens;
  // screens
  struct anonymous$13 *screens;
  // motion_buffer
  unsigned long int motion_buffer;
  // private16
  unsigned long int private16;
  // min_keycode
  signed int min_keycode;
  // max_keycode
  signed int max_keycode;
  // private17
  char *private17;
  // private18
  char *private18;
  // private19
  signed int private19;
  // xdefaults
  char *xdefaults;
};

struct anonymous$17
{
  // ext_data
  struct _XExtData *ext_data;
  // depth
  signed int depth;
  // bits_per_pixel
  signed int bits_per_pixel;
  // scanline_pad
  signed int scanline_pad;
};

struct anonymous$42
{
  // ext_data
  struct _XExtData *ext_data;
  // visualid
  unsigned long int visualid;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // bits_per_rgb
  signed int bits_per_rgb;
  // map_entries
  signed int map_entries;
};

struct anonymous$7
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous$1
{
  // x
  signed short int x;
  // y
  signed short int y;
  // width
  unsigned short int width;
  // height
  unsigned short int height;
};

struct anonymous$15
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous
{
  // depth
  signed int depth;
  // nvisuals
  signed int nvisuals;
  // visuals
  struct anonymous$42 *visuals;
};

struct anonymous$46
{
  // function
  signed int function;
  // plane_mask
  unsigned long int plane_mask;
  // foreground
  unsigned long int foreground;
  // background
  unsigned long int background;
  // line_width
  signed int line_width;
  // line_style
  signed int line_style;
  // cap_style
  signed int cap_style;
  // join_style
  signed int join_style;
  // fill_style
  signed int fill_style;
  // fill_rule
  signed int fill_rule;
  // arc_mode
  signed int arc_mode;
  // tile
  unsigned long int tile;
  // stipple
  unsigned long int stipple;
  // ts_x_origin
  signed int ts_x_origin;
  // ts_y_origin
  signed int ts_y_origin;
  // font
  unsigned long int font;
  // subwindow_mode
  signed int subwindow_mode;
  // graphics_exposures
  signed int graphics_exposures;
  // clip_x_origin
  signed int clip_x_origin;
  // clip_y_origin
  signed int clip_y_origin;
  // clip_mask
  unsigned long int clip_mask;
  // dash_offset
  signed int dash_offset;
  // dashes
  char dashes;
};

struct anonymous$11
{
  // screen_number
  signed int screen_number;
  // x_org
  signed short int x_org;
  // y_org
  signed short int y_org;
  // width
  signed short int width;
  // height
  signed short int height;
};

struct anonymous$52
{
  // type
  signed int type;
  // display
  struct _XDisplay *display;
  // resourceid
  unsigned long int resourceid;
  // serial
  unsigned long int serial;
  // error_code
  unsigned char error_code;
  // request_code
  unsigned char request_code;
  // minor_code
  unsigned char minor_code;
};

struct anonymous$6
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
};

struct anonymous$8
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
  // cookie
  unsigned int cookie;
  // data
  void *data;
};

struct anonymous$49
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous$47
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous$25
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
};

struct anonymous$26
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // from_configure
  signed int from_configure;
};

struct anonymous$27
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$35
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous$32
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
};

struct anonymous$31
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$30
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // parent
  unsigned long int parent;
  // x
  signed int x;
  // y
  signed int y;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$39
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // owner
  unsigned long int owner;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous$28
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
};

struct anonymous$36
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous$24
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$34
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // detail
  signed int detail;
  // value_mask
  unsigned long int value_mask;
};

struct anonymous$40
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous$0
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
};

struct anonymous$14
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // key_vector
  char key_vector[32l];
};

struct anonymous$9
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // mode
  signed int mode;
  // detail
  signed int detail;
};

struct anonymous$29
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // request
  signed int request;
  // first_keycode
  signed int first_keycode;
  // count
  signed int count;
};

struct anonymous$23
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // state
  signed int state;
};

struct anonymous$33
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // width
  signed int width;
  // height
  signed int height;
};

struct anonymous$22
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
};

struct anonymous$37
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // atom
  unsigned long int atom;
  // time
  unsigned long int time;
  // state
  signed int state;
};

struct anonymous$41
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // colormap
  unsigned long int colormap;
  // new
  signed int new;
  // state
  signed int state;
};

union anonymous$51
{
  // b
  char b[20l];
  // s
  signed short int s[10l];
  // l
  signed long int l[5l];
};

struct anonymous$21
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // message_type
  unsigned long int message_type;
  // format
  signed int format;
  // data
  union anonymous$51 data;
};

struct anonymous$4
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // mode
  signed int mode;
  // detail
  signed int detail;
  // same_screen
  signed int same_screen;
  // focus
  signed int focus;
  // state
  unsigned int state;
};

struct anonymous$2
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // is_hint
  char is_hint;
  // same_screen
  signed int same_screen;
};

struct anonymous$50
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // same_screen
  signed int same_screen;
};

struct anonymous$44
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // keycode
  unsigned int keycode;
  // same_screen
  signed int same_screen;
};

struct anonymous$38
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // selection
  unsigned long int selection;
  // time
  unsigned long int time;
};

struct anonymous$10
{
  // max_ink_extent
  struct anonymous$1 max_ink_extent;
  // max_logical_extent
  struct anonymous$1 max_logical_extent;
};

struct anonymous$3
{
  // background_pixmap
  unsigned long int background_pixmap;
  // background_pixel
  unsigned long int background_pixel;
  // border_pixmap
  unsigned long int border_pixmap;
  // border_pixel
  unsigned long int border_pixel;
  // bit_gravity
  signed int bit_gravity;
  // win_gravity
  signed int win_gravity;
  // backing_store
  signed int backing_store;
  // backing_planes
  unsigned long int backing_planes;
  // backing_pixel
  unsigned long int backing_pixel;
  // save_under
  signed int save_under;
  // event_mask
  signed long int event_mask;
  // do_not_propagate_mask
  signed long int do_not_propagate_mask;
  // override_redirect
  signed int override_redirect;
  // colormap
  unsigned long int colormap;
  // cursor
  unsigned long int cursor;
};

struct anonymous$48
{
  // pixel
  unsigned long int pixel;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
  // flags
  char flags;
  // pad
  char pad;
};

union anonymous$18
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$16
{
  // __data
  struct anonymous$15 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$20
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

union _XEvent
{
  // type
  signed int type;
  // xany
  struct anonymous$0 xany;
  // xkey
  struct anonymous$44 xkey;
  // xbutton
  struct anonymous$50 xbutton;
  // xmotion
  struct anonymous$2 xmotion;
  // xcrossing
  struct anonymous$4 xcrossing;
  // xfocus
  struct anonymous$9 xfocus;
  // xexpose
  struct anonymous$22 xexpose;
  // xgraphicsexpose
  struct anonymous$47 xgraphicsexpose;
  // xnoexpose
  struct anonymous$49 xnoexpose;
  // xvisibility
  struct anonymous$23 xvisibility;
  // xcreatewindow
  struct anonymous$24 xcreatewindow;
  // xdestroywindow
  struct anonymous$25 xdestroywindow;
  // xunmap
  struct anonymous$26 xunmap;
  // xmap
  struct anonymous$27 xmap;
  // xmaprequest
  struct anonymous$28 xmaprequest;
  // xreparent
  struct anonymous$30 xreparent;
  // xconfigure
  struct anonymous$31 xconfigure;
  // xgravity
  struct anonymous$32 xgravity;
  // xresizerequest
  struct anonymous$33 xresizerequest;
  // xconfigurerequest
  struct anonymous$34 xconfigurerequest;
  // xcirculate
  struct anonymous$35 xcirculate;
  // xcirculaterequest
  struct anonymous$36 xcirculaterequest;
  // xproperty
  struct anonymous$37 xproperty;
  // xselectionclear
  struct anonymous$38 xselectionclear;
  // xselectionrequest
  struct anonymous$39 xselectionrequest;
  // xselection
  struct anonymous$40 xselection;
  // xcolormap
  struct anonymous$41 xcolormap;
  // xclient
  struct anonymous$21 xclient;
  // xmapping
  struct anonymous$29 xmapping;
  // xerror
  struct anonymous$52 xerror;
  // xkeymap
  struct anonymous$14 xkeymap;
  // xgeneric
  struct anonymous$6 xgeneric;
  // xcookie
  struct anonymous$8 xcookie;
  // pad
  signed long int pad[24l];
};

struct _XExtData
{
  // number
  signed int number;
  // next
  struct _XExtData *next;
  // free_private
  signed int (*free_private)(struct _XExtData *);
  // private_data
  char *private_data;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct xosd
{
  // event_thread
  unsigned long int event_thread;
  // mutex
  union anonymous$20 mutex;
  // cond_wait
  union anonymous$16 cond_wait;
  // pipefd
  signed int pipefd[2l];
  // mutex_sync
  union anonymous$20 mutex_sync;
  // cond_sync
  union anonymous$16 cond_sync;
  // display
  struct _XDisplay *display;
  // screen
  signed int screen;
  // window
  unsigned long int window;
  // depth
  unsigned int depth;
  // mask_bitmap
  unsigned long int mask_bitmap;
  // line_bitmap
  unsigned long int line_bitmap;
  // visual
  struct anonymous$42 *visual;
  // fontset
  struct _XOC *fontset;
  // extent
  struct anonymous$1 *extent;
  // gc
  struct _XGC *gc;
  // mask_gc
  struct _XGC *mask_gc;
  // mask_gc_back
  struct _XGC *mask_gc_back;
  // screen_width
  signed int screen_width;
  // screen_height
  signed int screen_height;
  // screen_xpos
  signed int screen_xpos;
  // height
  signed int height;
  // line_height
  signed int line_height;
  // pos
  enum anonymous$45 pos;
  // align
  enum anonymous$5 align;
  // hoffset
  signed int hoffset;
  // voffset
  signed int voffset;
  // shadow_offset
  signed int shadow_offset;
  // shadow_colour
  struct anonymous$48 shadow_colour;
  // shadow_pixel
  unsigned long int shadow_pixel;
  // outline_offset
  signed int outline_offset;
  // outline_colour
  struct anonymous$48 outline_colour;
  // outline_pixel
  unsigned long int outline_pixel;
  // bar_length
  signed int bar_length;
  // generation
  signed int generation;
  // done
  signed int done;
  // update
  enum anonymous$43 update;
  // pixel
  unsigned long int pixel;
  // colour
  struct anonymous$48 colour;
  // lines
  union xosd_line *lines;
  // number_lines
  signed int number_lines;
  // timeout
  signed int timeout;
  // timeout_start
  struct timeval timeout_start;
};

struct xosd_bar
{
  // type
  enum LINE type;
  // value
  signed int value;
};

struct xosd_text
{
  // type
  enum LINE type;
  // width
  signed int width;
  // string
  char *string;
};

union xosd_line
{
  // type
  enum LINE type;
  // text
  struct xosd_text text;
  // bar
  struct xosd_bar bar;
};


// XOSD_MAX_PRINTF_BUF_SIZE
// file intern.h line 149
static const signed int XOSD_MAX_PRINTF_BUF_SIZE = 2000;
// _xosd_debug_level
// file intern.h line 45
static const enum DEBUG_LEVEL _xosd_debug_level = (const enum DEBUG_LEVEL)0;
// osd_default_colour
// file xosd.c line 31
const char *osd_default_colour = "green";
// osd_default_font
// file xosd.c line 26
const char *osd_default_font = "-misc-fixed-medium-r-semicondensed--*-*-*-*-c-*-*-*";
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// xosd_error
// file xosd.c line 34
char *xosd_error;

// _draw_bar
// file xosd.c line 98
static void _draw_bar(struct xosd *osd, signed int nbars, signed int on, struct anonymous$1 *p, struct anonymous$1 *mod, signed int is_slider)
{
  signed int i;
  struct anonymous$1 rs[2l];
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 103, return_value_pthread_self$1, (const void *)"_draw_bar");
    }

  while((_Bool)0);
  rs[(signed long int)1].x = (signed short int)((signed int)mod->x + (signed int)p->x);
  rs[(signed long int)0].x = rs[(signed long int)1].x;
  rs[(signed long int)1].y = (signed short int)((signed int)mod->y + (signed int)p->y);
  rs[(signed long int)0].y = (signed short int)((signed int)rs[(signed long int)1].y + (signed int)p->height / 3);
  rs[(signed long int)0].width = (unsigned short int)((double)mod->width + (double)p->width * 0.8);
  rs[(signed long int)0].height = (unsigned short int)((signed int)mod->height + (signed int)p->height / 3);
  rs[(signed long int)1].width = (unsigned short int)((double)mod->width + (double)p->width * 0.7);
  rs[(signed long int)1].height = (unsigned short int)((signed int)mod->height + (signed int)p->height);
  i = 0;
  for( ; !(i >= nbars); rs[(signed long int)0].x = rs[(signed long int)1].x)
  {
    struct anonymous$1 *r = &rs[(signed long int)(is_slider != 0 ? (signed int)(i == on) : (signed int)(i < on))];
    XFillRectangles(osd->display, osd->mask_bitmap, osd->mask_gc, r, 1);
    XFillRectangles(osd->display, osd->line_bitmap, osd->gc, r, 1);
    i = i + 1;
    rs[(signed long int)1].x = rs[(signed long int)1].x + (signed short int)p->width;
  }
  unsigned long int return_value_pthread_self$2;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$2=pthread_self();
      fprintf(stderr, "%s:%-4d %ld>%s\n", (const void *)"xosd.c", 116, return_value_pthread_self$2, (const void *)"_draw_bar");
    }

  while((_Bool)0);
}

// _draw_text
// file xosd.c line 186
static void _draw_text(struct xosd *osd, char *string, signed int x, signed int y)
{
  signed int len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(string);
  len = (signed int)return_value_strlen$1;
  unsigned long int return_value_pthread_self$2;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$2=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 189, return_value_pthread_self$2, (const void *)"_draw_text");
    }

  while((_Bool)0);
  XmbDrawString(osd->display, osd->mask_bitmap, osd->fontset, osd->mask_gc, x, y, string, len);
  XmbDrawString(osd->display, osd->line_bitmap, osd->fontset, osd->gc, x, y, string, len);
  unsigned long int return_value_pthread_self$3;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$3=pthread_self();
      fprintf(stderr, "%s:%-4d %ld>%s\n", (const void *)"xosd.c", 194, return_value_pthread_self$3, (const void *)"_draw_text");
    }

  while((_Bool)0);
}

// _wait_until_update
// file xosd.c line 38
static void _wait_until_update(struct xosd *osd, signed int generation)
{
  pthread_mutex_lock(&osd->mutex_sync);
  unsigned long int return_value_pthread_self$1;
  while(osd->generation == generation)
  {
    do
      if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
      {
        return_value_pthread_self$1=pthread_self();
        fprintf(stderr, "%s:%-4d %ld@%s: waiting %d %d\n", (const void *)"xosd.c", 42, return_value_pthread_self$1, (const void *)"_wait_until_update", generation, osd->generation);
      }

    while((_Bool)0);
    pthread_cond_wait(&osd->cond_sync, &osd->mutex_sync);
  }
  pthread_mutex_unlock(&osd->mutex_sync);
}

// _xosd_lock
// file xosd.c line 72
static void _xosd_lock(struct xosd *osd)
{
  char c = (char)0;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0) && !((Dlocking & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 75, return_value_pthread_self$1, (const void *)"_xosd_lock");
    }

  while((_Bool)0);
  write(osd->pipefd[(signed long int)1], (const void *)&c, sizeof(char) /*1ul*/ );
  pthread_mutex_lock(&osd->mutex);
  unsigned long int return_value_pthread_self$2;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0) && !((Dlocking & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$2=pthread_self();
      fprintf(stderr, "%s:%-4d %ld>%s\n", (const void *)"xosd.c", 78, return_value_pthread_self$2, (const void *)"_xosd_lock");
    }

  while((_Bool)0);
}

// _xosd_unlock
// file xosd.c line 81
static void _xosd_unlock(struct xosd *osd)
{
  char c;
  signed int generation = osd->generation;
  signed int update = (signed int)osd->update;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0) && !((Dlocking & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 85, return_value_pthread_self$1, (const void *)"_xosd_unlock");
    }

  while((_Bool)0);
  read(osd->pipefd[(signed long int)0], (void *)&c, sizeof(char) /*1ul*/ );
  pthread_cond_signal(&osd->cond_wait);
  pthread_mutex_unlock(&osd->mutex);
  if(!((UPD_show & update) == 0))
    _wait_until_update(osd, generation & ~1);

  unsigned long int return_value_pthread_self$2;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0) && !((Dlocking & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$2=pthread_self();
      fprintf(stderr, "%s:%-4d %ld>%s\n", (const void *)"xosd.c", 91, return_value_pthread_self$2, (const void *)"_xosd_unlock");
    }

  while((_Bool)0);
}

// draw_bar
// file xosd.c line 119
static void draw_bar(struct xosd *osd, signed int line)
{
  struct xosd_bar *l = &(osd->lines + (signed long int)line)->bar;
  signed int is_slider = (signed int)((signed int)l->type == LINE_slider);
  signed int nbars;
  signed int on;
  struct anonymous$1 p;
  struct anonymous$1 m;
  p.x = (signed short int)10;
  p.y = (signed short int)(osd->line_height * line);
  p.width = (unsigned short int)(-((signed int)osd->extent->y) / 2);
  p.height = (unsigned short int)-((signed int)osd->extent->y);
  /* assertion osd */
  assert(osd != ((struct xosd *)NULL));
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 130, return_value_pthread_self$1, (const void *)"draw_bar");
    }

  while((_Bool)0);
  if(osd->bar_length == -1)
  {
    nbars = (signed int)(((double)osd->screen_width * 0.8) / (double)p.width);
    switch((signed int)osd->align)
    {
      case XOSD_center:
      {
        p.x = (signed short int)((double)osd->screen_width * (((double)1 - 0.8) / (double)2));
        break;
      }
      case XOSD_right:
        p.x = (signed short int)((double)osd->screen_width * ((double)1 - 0.8));
      case XOSD_left:

      default:
        ;
    }
  }

  else
  {
    nbars = osd->bar_length;
    switch((signed int)osd->align)
    {
      case XOSD_center:
      {
        p.x = (signed short int)((osd->screen_width - nbars * (signed int)p.width) / 2);
        break;
      }
      case XOSD_right:
        p.x = (signed short int)((osd->screen_width - nbars * (signed int)p.width) - (signed int)p.x);
      case XOSD_left:

      default:
        ;
    }
  }
  on = ((nbars - is_slider) * l->value) / 100;
  unsigned long int return_value_pthread_self$2;
  do
    if(!((Dvalue & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$2=pthread_self();
      fprintf(stderr, "%s:%-4d %ld@%s: percent=%d, nbars=%d, on=%d\n", (const void *)"xosd.c", 158, return_value_pthread_self$2, (const void *)"draw_bar", l->value, nbars, on);
    }

  while((_Bool)0);
  if(!(osd->outline_offset == 0))
  {
    m.y = (signed short int)-osd->outline_offset;
    m.x = m.y;
    m.height = (unsigned short int)(2 * osd->outline_offset);
    m.width = m.height;
    XSetForeground(osd->display, osd->gc, osd->outline_pixel);
    _draw_bar(osd, nbars, on, &p, &m, is_slider);
  }

  if(!(osd->shadow_offset == 0))
  {
    m.y = (signed short int)osd->shadow_offset;
    m.x = m.y;
    m.height = (unsigned short int)0;
    m.width = m.height;
    XSetForeground(osd->display, osd->gc, osd->shadow_pixel);
    _draw_bar(osd, nbars, on, &p, &m, is_slider);
  }

  m.height = (unsigned short int)0;
  m.width = m.height;
  m.y = (signed short int)m.width;
  m.x = m.y;
  XSetForeground(osd->display, osd->gc, osd->pixel);
  _draw_bar(osd, nbars, on, &p, &m, is_slider);
}

// draw_text
// file xosd.c line 197
static void draw_text(struct xosd *osd, signed int line)
{
  signed int x = 10;
  signed int y = osd->line_height * line - (signed int)osd->extent->y;
  struct xosd_text *l = &(osd->lines + (signed long int)line)->text;
  /* assertion osd */
  assert(osd != ((struct xosd *)NULL));
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 203, return_value_pthread_self$1, (const void *)"draw_text");
    }

  while((_Bool)0);
  if(!(l->string == ((char *)NULL)))
  {
    if(!(l->width >= 0))
    {
      struct anonymous$1 rect;
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(l->string);
      XmbTextExtents(osd->fontset, l->string, (signed int)return_value_strlen$2, (struct anonymous$1 *)(void *)0, &rect);
      l->width = (signed int)rect.width;
    }

    switch((signed int)osd->align)
    {
      case XOSD_center:
      {
        x = (osd->screen_width - l->width) / 2;
        goto __CPROVER_DUMP_L7;
      }
      case XOSD_right:
        x = (osd->screen_width - l->width) - x;
      case XOSD_left:

      default:
      {

      __CPROVER_DUMP_L7:
        ;
        if(!(osd->shadow_offset == 0))
        {
          XSetForeground(osd->display, osd->gc, osd->shadow_pixel);
          _draw_text(osd, l->string, x + osd->shadow_offset, y + osd->shadow_offset);
        }

        if(!(osd->outline_offset == 0))
        {
          signed int i;
          signed int j;
          XSetForeground(osd->display, osd->gc, osd->outline_pixel);
          i = 1;
          for( ; osd->outline_offset >= i; i = i + 1)
          {
            j = 0;
            for( ; !(j >= 9); j = j + 1)
              if(!(j == 4))
                _draw_text(osd, l->string, x + (j / 3 - 1) * i, y + (j % 3 - 1) * i);

          }
        }

        XSetForeground(osd->display, osd->gc, osd->pixel);
        _draw_text(osd, l->string, x, y);
      }
    }
  }

}

// event_loop
// file xosd.c line 258
static void * event_loop(void *osdv)
{
  struct xosd *osd = (struct xosd *)osdv;
  signed int xfd;
  signed int max;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 263, return_value_pthread_self$1, (const void *)"event_loop");
    }

  while((_Bool)0);
  unsigned long int return_value_pthread_self$2;
  do
    if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$2=pthread_self();
      fprintf(stderr, "%s:%-4d %ld@%s: event thread started\n", (const void *)"xosd.c", 264, return_value_pthread_self$2, (const void *)"event_loop");
    }

  while((_Bool)0);
  /* assertion osd */
  assert(osd != ((struct xosd *)NULL));
  xfd = ((struct anonymous$19 *)osd->display)->fd;
  signed int tmp_if_expr$3;
  if(!(xfd >= osd->pipefd[0l]))
    tmp_if_expr$3 = osd->pipefd[(signed long int)0];

  else
    tmp_if_expr$3 = xfd;
  max = tmp_if_expr$3;
  pthread_mutex_lock(&osd->mutex);
  unsigned long int return_value_pthread_self$4;
  do
    if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$4=pthread_self();
      fprintf(stderr, "%s:%-4d %ld@%s: Request exposure events\n", (const void *)"xosd.c", 271, return_value_pthread_self$4, (const void *)"event_loop");
    }

  while((_Bool)0);
  XSelectInput(osd->display, osd->window, 1L << 15);
  osd->update = osd->update | (enum anonymous$43)(UPD_size | UPD_pos | UPD_mask);
  unsigned long int return_value_pthread_self$5;
  unsigned long int return_value_pthread_self$6;
  unsigned long int return_value_pthread_self$7;
  unsigned long int return_value_pthread_self$8;
  unsigned long int return_value_pthread_self$9;
  unsigned long int return_value_pthread_self$10;
  unsigned long int return_value_pthread_self$11;
  unsigned long int return_value_pthread_self$12;
  _Bool tmp_if_expr$13;
  _Bool tmp_if_expr$15;
  signed int tmp_if_expr$14;
  unsigned long int return_value_pthread_self$16;
  _Bool tmp_if_expr$28;
  signed int *return_value___errno_location$27;
  unsigned long int return_value_pthread_self$17;
  unsigned long int return_value_pthread_self$18;
  signed int *return_value___errno_location$19;
  unsigned long int return_value_pthread_self$20;
  unsigned long int return_value_pthread_self$21;
  struct anonymous$22 *event_loop$$1$$4$$17$$1$$1$$XE;
  unsigned long int return_value_pthread_self$22;
  struct anonymous$47 *event_loop$$1$$4$$17$$1$$2$$XE;
  unsigned long int return_value_pthread_self$23;
  struct anonymous$49 *XE;
  unsigned long int return_value_pthread_self$24;
  unsigned long int return_value_pthread_self$25;
  unsigned long int return_value_pthread_self$26;
  while(osd->done == 0)
  {
    signed int retval;
    signed int line;
    struct anonymous$7 readfds;
    struct timeval tv;
    struct timeval *tvp = (struct timeval *)(void *)0;
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$7) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&readfds)->__fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&readfds)->__fds_bits[(signed long int)(xfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readfds)->__fds_bits[(signed long int)(xfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << xfd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    (&readfds)->__fds_bits[(signed long int)(osd->pipefd[(signed long int)0] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&readfds)->__fds_bits[(signed long int)(osd->pipefd[(signed long int)0] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << osd->pipefd[(signed long int)0] % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    if(!((UPD_hide & (signed int)osd->update) == 0))
    {
      do
        if(!((Dupdate & (signed int)_xosd_debug_level) == 0))
        {
          return_value_pthread_self$5=pthread_self();
          fprintf(stderr, "%s:%-4d %ld@%s: UPD_hide\n", (const void *)"xosd.c", 285, return_value_pthread_self$5, (const void *)"event_loop");
        }

      while((_Bool)0);
      if(!((1 & osd->generation) == 0))
      {
        XUnmapWindow(osd->display, osd->window);
        osd->generation = osd->generation + 1;
      }

    }

    if(!((UPD_size & (signed int)osd->update) == 0))
    {
      struct anonymous$10 *extents;
      extents=XExtentsOfFontSet(osd->fontset);
      do
        if(!((Dupdate & (signed int)_xosd_debug_level) == 0))
        {
          return_value_pthread_self$6=pthread_self();
          fprintf(stderr, "%s:%-4d %ld@%s: UPD_size\n", (const void *)"xosd.c", 295, return_value_pthread_self$6, (const void *)"event_loop");
        }

      while((_Bool)0);
      osd->extent = &extents->max_logical_extent;
      osd->line_height = (signed int)osd->extent->height + osd->shadow_offset + 2 * osd->outline_offset;
      osd->height = osd->line_height * osd->number_lines;
      line = 0;
      for( ; !(line >= osd->number_lines); line = line + 1)
        if((signed int)(osd->lines + (signed long int)line)->type == LINE_text)
          (osd->lines + (signed long int)line)->text.width = -1;

      XResizeWindow(osd->display, osd->window, (unsigned int)osd->screen_width, (unsigned int)osd->height);
      XFreePixmap(osd->display, osd->mask_bitmap);
      osd->mask_bitmap=XCreatePixmap(osd->display, osd->window, (unsigned int)osd->screen_width, (unsigned int)osd->height, (unsigned int)1);
      XFreePixmap(osd->display, osd->line_bitmap);
      osd->line_bitmap=XCreatePixmap(osd->display, osd->window, (unsigned int)osd->screen_width, (unsigned int)osd->height, osd->depth);
    }

    if(!((UPD_pos & (signed int)osd->update) == 0))
    {
      signed int x = 0;
      signed int y = 0;
      do
        if(!((Dupdate & (signed int)_xosd_debug_level) == 0))
        {
          return_value_pthread_self$7=pthread_self();
          fprintf(stderr, "%s:%-4d %ld@%s: UPD_pos\n", (const void *)"xosd.c", 318, return_value_pthread_self$7, (const void *)"event_loop");
        }

      while((_Bool)0);
      switch((signed int)osd->align)
      {
        case XOSD_left:

        case XOSD_center:
        {
          x = osd->screen_xpos + osd->hoffset;
          break;
        }
        case XOSD_right:
          x = osd->screen_xpos - osd->hoffset;
      }
      switch((signed int)osd->pos)
      {
        case XOSD_bottom:
        {
          y = (osd->screen_height - osd->height) - osd->voffset;
          break;
        }
        case XOSD_middle:
        {
          y = (osd->screen_height - osd->height) / 2 - osd->voffset;
          break;
        }
        case XOSD_top:
          y = osd->voffset;
      }
      XMoveWindow(osd->display, osd->window, x, y);
    }

    if(!((48 & (signed int)osd->update) == 0))
    {
      do
        if(!((Dupdate & (signed int)_xosd_debug_level) == 0))
        {
          return_value_pthread_self$8=pthread_self();
          fprintf(stderr, "%s:%-4d %ld@%s: UPD_lines\n", (const void *)"xosd.c", 342, return_value_pthread_self$8, (const void *)"event_loop");
        }

      while((_Bool)0);
      line = 0;
      while(!(line >= osd->number_lines))
      {
        signed int event_loop$$1$$4$$5$$2$$1$$y = osd->line_height * line;
        if(!((UPD_mask & (signed int)osd->update) == 0))
          XFillRectangle(osd->display, osd->mask_bitmap, osd->mask_gc_back, 0, event_loop$$1$$4$$5$$2$$1$$y, (unsigned int)osd->screen_width, (unsigned int)osd->line_height);

        switch((signed int)(osd->lines + (signed long int)line)->type)
        {
          case LINE_text:
          {
            draw_text(osd, line);
            goto __CPROVER_DUMP_L36;
          }
          case LINE_percentage:

          case LINE_slider:
            draw_bar(osd, line);
          case LINE_blank:

          default:
          {

          __CPROVER_DUMP_L36:
            ;
            line = line + 1;
          }
        }
      }
    }

    if(!((UPD_mask & (signed int)osd->update) == 0))
    {
      do
        if(!((Dupdate & (signed int)_xosd_debug_level) == 0))
        {
          return_value_pthread_self$9=pthread_self();
          fprintf(stderr, "%s:%-4d %ld@%s: UPD_mask\n", (const void *)"xosd.c", 369, return_value_pthread_self$9, (const void *)"event_loop");
        }

      while((_Bool)0);
      XShapeCombineMask(osd->display, osd->window, 0, 0, 0, osd->mask_bitmap, 0);
    }

    if(!((UPD_show & (signed int)osd->update) == 0))
    {
      do
        if(!((Dupdate & (signed int)_xosd_debug_level) == 0))
        {
          return_value_pthread_self$10=pthread_self();
          fprintf(stderr, "%s:%-4d %ld@%s: UPD_show\n", (const void *)"xosd.c", 376, return_value_pthread_self$10, (const void *)"event_loop");
        }

      while((_Bool)0);
      if(!((~osd->generation & 1) == 0))
      {
        osd->generation = osd->generation + 1;
        XMapRaised(osd->display, osd->window);
      }

    }

    if(!((1 & osd->generation) == 0))
    {
      if(!((90 & (signed int)osd->update) == 0))
      {
        do
          if(!((Dupdate & (signed int)_xosd_debug_level) == 0))
          {
            return_value_pthread_self$11=pthread_self();
            fprintf(stderr, "%s:%-4d %ld@%s: UPD_copy\n", (const void *)"xosd.c", 385, return_value_pthread_self$11, (const void *)"event_loop");
          }

        while((_Bool)0);
        XCopyArea(osd->display, osd->line_bitmap, osd->window, osd->gc, 0, 0, (unsigned int)osd->screen_width, (unsigned int)osd->height, 0, 0);
      }

    }

    if(!((-5 & (signed int)osd->update) == 0))
    {
      XFlush(osd->display);
      osd->update = osd->update & (enum anonymous$43)UPD_timer;
    }

    if(!((UPD_timer & (signed int)osd->update) == 0))
    {
      do
        if(!((Dupdate & (signed int)_xosd_debug_level) == 0))
        {
          return_value_pthread_self$12=pthread_self();
          fprintf(stderr, "%s:%-4d %ld@%s: UPD_timer\n", (const void *)"xosd.c", 396, return_value_pthread_self$12, (const void *)"event_loop");
        }

      while((_Bool)0);
      osd->update = (enum anonymous$43)UPD_none;
      if(!((1 & osd->generation) == 0))
        tmp_if_expr$13 = osd->timeout > 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr$13 = (_Bool)0;
      if(tmp_if_expr$13)
        gettimeofday(&osd->timeout_start, (struct timezone *)(void *)0);

      else
      {
        (&osd->timeout_start)->tv_usec = (signed long int)0;
        (&osd->timeout_start)->tv_sec = (&osd->timeout_start)->tv_usec;
      }
    }

    if(!(osd->timeout_start.tv_sec == 0l))
      tmp_if_expr$15 = (_Bool)1;

    else
      tmp_if_expr$15 = (&osd->timeout_start)->tv_usec != 0l ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$15)
    {
      gettimeofday(&tv, (struct timezone *)(void *)0);
      tv.tv_sec = tv.tv_sec - (signed long int)osd->timeout;
      if(tv.tv_sec == osd->timeout_start.tv_sec)
        tmp_if_expr$14 = (signed int)((&tv)->tv_usec < (&osd->timeout_start)->tv_usec);

      else
        tmp_if_expr$14 = (signed int)((&tv)->tv_sec < (&osd->timeout_start)->tv_sec);
      if(!(tmp_if_expr$14 == 0))
      {
        tv.tv_sec = osd->timeout_start.tv_sec - tv.tv_sec;
        tv.tv_usec = osd->timeout_start.tv_usec - tv.tv_usec;
        if(!(tv.tv_usec >= 0l))
        {
          tv.tv_usec = tv.tv_usec + (signed long int)1000000;
          tv.tv_sec = tv.tv_sec - (signed long int)1;
        }

        tvp = &tv;
        goto __CPROVER_DUMP_L61;
      }

      (&osd->timeout_start)->tv_usec = (signed long int)0;
      (&osd->timeout_start)->tv_sec = (&osd->timeout_start)->tv_usec;
      if(!((1 & osd->generation) == 0))
        osd->update = osd->update | (enum anonymous$43)UPD_hide;

    }

    else
    {

    __CPROVER_DUMP_L61:
      ;
      pthread_mutex_lock(&osd->mutex_sync);
      pthread_cond_broadcast(&osd->cond_sync);
      pthread_mutex_unlock(&osd->mutex_sync);
      retval=select(max + 1, &readfds, (struct anonymous$7 *)(void *)0, (struct anonymous$7 *)(void *)0, tvp);
      do
        if(!((Dvalue & (signed int)_xosd_debug_level) == 0))
        {
          return_value_pthread_self$16=pthread_self();
          fprintf(stderr, "%s:%-4d %ld@%s: SELECT=%d PIPE=%d X11=%d\n", (const void *)"xosd.c", 431, return_value_pthread_self$16, (const void *)"event_loop", retval, ((&readfds)->__fds_bits[(signed long int)(osd->pipefd[(signed long int)0] / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & (signed long int)(1UL << osd->pipefd[(signed long int)0] % (8 * (signed int)sizeof(signed long int) /*8ul*/ ))) != (signed long int)0, ((&readfds)->__fds_bits[(signed long int)(xfd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] & (signed long int)(1UL << xfd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ))) != (signed long int)0);
        }

      while((_Bool)0);
      if(retval == -1)
      {
        return_value___errno_location$27=__errno_location();
        tmp_if_expr$28 = *return_value___errno_location$27 == 4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr$28 = (_Bool)0;
      if(tmp_if_expr$28)
      {
        do
          if(!((Dselect & (signed int)_xosd_debug_level) == 0))
          {
            return_value_pthread_self$17=pthread_self();
            fprintf(stderr, "%s:%-4d %ld@%s: select() EINTR\n", (const void *)"xosd.c", 434, return_value_pthread_self$17, (const void *)"event_loop");
          }

        while((_Bool)0);
        continue;
      }

      else
        if(retval == -1)
        {
          do
            if(!((Dselect & (signed int)_xosd_debug_level) == 0))
            {
              return_value_pthread_self$18=pthread_self();
              return_value___errno_location$19=__errno_location();
              fprintf(stderr, "%s:%-4d %ld@%s: select() error %d\n", (const void *)"xosd.c", 437, return_value_pthread_self$18, (const void *)"event_loop", *return_value___errno_location$19);
            }

          while((_Bool)0);
          osd->done = 1;
          break;
        }

        else
          if(retval == 0)
          {
            do
              if(!((Dselect & (signed int)_xosd_debug_level) == 0))
              {
                return_value_pthread_self$20=pthread_self();
                fprintf(stderr, "%s:%-4d %ld@%s: select() timeout\n", (const void *)"xosd.c", 441, return_value_pthread_self$20, (const void *)"event_loop");
              }

            while((_Bool)0);
            continue;
          }

          else
            if(!((readfds.__fds_bits[(signed long int)(osd->pipefd[0l] / 8)] & (signed long int)(1UL << osd->pipefd[0l] % 8)) == 0l))
            {
              pthread_cond_wait(&osd->cond_wait, &osd->mutex);
              do
                if(!((Dselect & (signed int)_xosd_debug_level) == 0))
                {
                  return_value_pthread_self$21=pthread_self();
                  fprintf(stderr, "%s:%-4d %ld@%s: Resume exposure thread after X11 call\n", (const void *)"xosd.c", 446, return_value_pthread_self$21, (const void *)"event_loop");
                }

              while((_Bool)0);
              continue;
            }

            else
              if(!((readfds.__fds_bits[(signed long int)(xfd / 8)] & (signed long int)(1UL << xfd % 8)) == 0l))
              {
                union _XEvent report;
                XNextEvent(osd->display, &report);
                switch(report.type & 0x7f)
                {
                  case 12:
                  {
                    event_loop$$1$$4$$17$$1$$1$$XE = &report.xexpose;
                    do
                      if(!((Dvalue & (signed int)_xosd_debug_level) == 0))
                      {
                        return_value_pthread_self$22=pthread_self();
                        fprintf(stderr, "%s:%-4d %ld@%s: expose %d: x=%d y=%d w=%d h=%d\n", (const void *)"xosd.c", 460, return_value_pthread_self$22, (const void *)"event_loop", event_loop$$1$$4$$17$$1$$1$$XE->count, event_loop$$1$$4$$17$$1$$1$$XE->x, event_loop$$1$$4$$17$$1$$1$$XE->y, event_loop$$1$$4$$17$$1$$1$$XE->width, event_loop$$1$$4$$17$$1$$1$$XE->height);
                      }

                    while((_Bool)0);
                    XCopyArea(osd->display, osd->line_bitmap, osd->window, osd->gc, report.xexpose.x, report.xexpose.y, (unsigned int)report.xexpose.width, (unsigned int)report.xexpose.height, report.xexpose.x, report.xexpose.y);
                    break;
                  }
                  case 13:
                  {
                    event_loop$$1$$4$$17$$1$$2$$XE = &report.xgraphicsexpose;
                    do
                      if(!((Dvalue & (signed int)_xosd_debug_level) == 0))
                      {
                        return_value_pthread_self$23=pthread_self();
                        fprintf(stderr, "%s:%-4d %ld@%s: gfxexpose %d: x=%d y=%d w=%d h=%d code=%d\n", (const void *)"xosd.c", 481, return_value_pthread_self$23, (const void *)"event_loop", event_loop$$1$$4$$17$$1$$2$$XE->count, event_loop$$1$$4$$17$$1$$2$$XE->x, event_loop$$1$$4$$17$$1$$2$$XE->y, event_loop$$1$$4$$17$$1$$2$$XE->width, event_loop$$1$$4$$17$$1$$2$$XE->height, event_loop$$1$$4$$17$$1$$2$$XE->major_code);
                      }

                    while((_Bool)0);
                    break;
                  }
                  case 14:
                  {
                    XE = &report.xnoexpose;
                    do
                      if(!((Dvalue & (signed int)_xosd_debug_level) == 0))
                      {
                        return_value_pthread_self$24=pthread_self();
                        fprintf(stderr, "%s:%-4d %ld@%s: noexpose: code=%d\n", (const void *)"xosd.c", 487, return_value_pthread_self$24, (const void *)"event_loop", XE->major_code);
                      }

                    while((_Bool)0);
                    break;
                  }
                  default:
                    do
                      if(!((Dvalue & (signed int)_xosd_debug_level) == 0))
                      {
                        return_value_pthread_self$25=pthread_self();
                        fprintf(stderr, "%s:%-4d %ld@%s: XEvent=%d\n", (const void *)"xosd.c", 491, return_value_pthread_self$25, (const void *)"event_loop", report.type);
                      }

                    while((_Bool)0);
                }
                continue;
              }

              else
              {
                do
                  if(!((Dselect & (signed int)_xosd_debug_level) == 0))
                  {
                    return_value_pthread_self$26=pthread_self();
                    fprintf(stderr, "%s:%-4d %ld@%s: select() FATAL %d\n", (const void *)"xosd.c", 496, return_value_pthread_self$26, (const void *)"event_loop", retval);
                  }

                while((_Bool)0);
                exit(-1);
              }
    }
  }
  pthread_mutex_unlock(&osd->mutex);
  return (void *)0;
}

// main
// file testprog.c line 14
signed int main(signed int argc, char **argv)
{
  struct xosd *osd;
  signed int a;
  osd=xosd_create(2);
  if(osd == ((struct xosd *)NULL))
  {
    printerror();
    return 1;
  }

  else
  {
    signed int return_value_xosd_set_outline_offset$1;
    return_value_xosd_set_outline_offset$1=xosd_set_outline_offset(osd, 1);
    if(!(return_value_xosd_set_outline_offset$1 == 0))
      printerror();

    signed int return_value_xosd_set_font$2;
    return_value_xosd_set_font$2=xosd_set_font(osd, (char *)osd_default_font);
    if(!(return_value_xosd_set_font$2 == 0))
      printerror();

    signed int return_value_xosd_set_timeout$3;
    return_value_xosd_set_timeout$3=xosd_set_timeout(osd, 2);
    if(!(return_value_xosd_set_timeout$3 == 0))
      printerror();

    a = 0;
    for( ; !(a >= 101); a = a + 1)
    {
      signed int return_value_xosd_display$4;
      return_value_xosd_display$4=xosd_display(osd, 0, (enum anonymous$12)XOSD_percentage, a);
      if(return_value_xosd_display$4 == -1)
        printerror();

      signed int return_value_xosd_display$5;
      return_value_xosd_display$5=xosd_display(osd, 1, (enum anonymous$12)XOSD_percentage, 100 - a);
      if(return_value_xosd_display$5 == -1)
        printerror();

      usleep((unsigned int)100);
    }
    a = 100;
    for( ; a >= 0; a = a - 1)
    {
      signed int return_value_xosd_display$6;
      return_value_xosd_display$6=xosd_display(osd, 0, (enum anonymous$12)XOSD_percentage, a);
      if(return_value_xosd_display$6 == -1)
        printerror();

      signed int return_value_xosd_display$7;
      return_value_xosd_display$7=xosd_display(osd, 1, (enum anonymous$12)XOSD_percentage, 100 - a);
      if(return_value_xosd_display$7 == -1)
        printerror();

      usleep((unsigned int)100);
    }
    a = 0;
    for( ; !(a >= 101); a = a + 1)
    {
      signed int return_value_xosd_display$8;
      return_value_xosd_display$8=xosd_display(osd, 0, (enum anonymous$12)XOSD_slider, a);
      if(return_value_xosd_display$8 == -1)
        printerror();

      signed int return_value_xosd_display$9;
      return_value_xosd_display$9=xosd_display(osd, 1, (enum anonymous$12)XOSD_slider, 100 - a);
      if(return_value_xosd_display$9 == -1)
        printerror();

      usleep((unsigned int)100);
    }
    a = 100;
    for( ; a >= 0; a = a - 1)
    {
      signed int return_value_xosd_display$10;
      return_value_xosd_display$10=xosd_display(osd, 0, (enum anonymous$12)XOSD_slider, a);
      if(return_value_xosd_display$10 == -1)
        printerror();

      signed int return_value_xosd_display$11;
      return_value_xosd_display$11=xosd_display(osd, 1, (enum anonymous$12)XOSD_slider, 100 - a);
      if(return_value_xosd_display$11 == -1)
        printerror();

      usleep((unsigned int)100);
    }
    signed int return_value_xosd_display$12;
    return_value_xosd_display$12=xosd_display(osd, 1, (enum anonymous$12)XOSD_string, (const void *)"");
    if(return_value_xosd_display$12 == -1)
      printerror();

    xosd_set_bar_length(osd, 14);
    signed int return_value_xosd_display$13;
    return_value_xosd_display$13=xosd_display(osd, 0, (enum anonymous$12)XOSD_percentage, 80);
    if(return_value_xosd_display$13 == -1)
      printerror();

    signed int return_value_xosd_wait_until_no_display$14;
    return_value_xosd_wait_until_no_display$14=xosd_wait_until_no_display(osd);
    if(!(return_value_xosd_wait_until_no_display$14 == 0))
      printerror();

    signed int return_value_xosd_display$15;
    return_value_xosd_display$15=xosd_display(osd, 0, (enum anonymous$12)XOSD_slider, 36);
    if(return_value_xosd_display$15 == -1)
      printerror();

    signed int return_value_xosd_wait_until_no_display$16;
    return_value_xosd_wait_until_no_display$16=xosd_wait_until_no_display(osd);
    if(!(return_value_xosd_wait_until_no_display$16 == 0))
      printerror();

    signed int return_value_xosd_display$17;
    return_value_xosd_display$17=xosd_display(osd, 0, (enum anonymous$12)XOSD_string, (const void *)"Blah");
    if(return_value_xosd_display$17 == -1)
      printerror();

    signed int return_value_xosd_wait_until_no_display$18;
    return_value_xosd_wait_until_no_display$18=xosd_wait_until_no_display(osd);
    if(!(return_value_xosd_wait_until_no_display$18 == 0))
      printerror();

    sleep((unsigned int)2);
    signed int return_value_xosd_display$19;
    return_value_xosd_display$19=xosd_display(osd, 0, (enum anonymous$12)XOSD_string, (const void *)"blah2");
    if(return_value_xosd_display$19 == -1)
      printerror();

    sleep((unsigned int)1);
    signed int return_value_xosd_display$20;
    return_value_xosd_display$20=xosd_display(osd, 1, (enum anonymous$12)XOSD_string, (const void *)"wibble");
    if(return_value_xosd_display$20 == -1)
      printerror();

    sleep((unsigned int)1);
    signed int return_value_xosd_scroll$21;
    return_value_xosd_scroll$21=xosd_scroll(osd, 1);
    if(!(return_value_xosd_scroll$21 == 0))
      printerror();

    signed int return_value_xosd_display$22;
    return_value_xosd_display$22=xosd_display(osd, 1, (enum anonymous$12)XOSD_string, (const void *)"bloggy");
    if(return_value_xosd_display$22 == -1)
      printerror();

    sleep((unsigned int)1);
    signed int return_value_xosd_scroll$23;
    return_value_xosd_scroll$23=xosd_scroll(osd, 1);
    if(!(return_value_xosd_scroll$23 == 0))
      printerror();

    signed int return_value_xosd_scroll$24;
    return_value_xosd_scroll$24=xosd_scroll(osd, 1);
    if(!(return_value_xosd_scroll$24 == 0))
      printerror();

    signed int return_value_xosd_destroy$25;
    return_value_xosd_destroy$25=xosd_destroy(osd);
    if(!(return_value_xosd_destroy$25 == 0))
      printerror();

    return 0;
  }
}

// parse_colour
// file xosd.c line 509
static signed int parse_colour(struct xosd *osd, struct anonymous$48 *col, unsigned long int *pixel, const char *colour)
{
  unsigned long int colourmap;
  signed int retval = 0;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 515, return_value_pthread_self$1, (const void *)"parse_colour");
    }

  while((_Bool)0);
  unsigned long int return_value_pthread_self$2;
  do
    if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$2=pthread_self();
      fprintf(stderr, "%s:%-4d %ld@%s: getting colourmap\n", (const void *)"xosd.c", 516, return_value_pthread_self$2, (const void *)"parse_colour");
    }

  while((_Bool)0);
  colourmap = (&((struct anonymous$19 *)osd->display)->screens[(signed long int)osd->screen])->cmap;
  unsigned long int return_value_pthread_self$3;
  do
    if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$3=pthread_self();
      fprintf(stderr, "%s:%-4d %ld@%s: parsing colour\n", (const void *)"xosd.c", 519, return_value_pthread_self$3, (const void *)"parse_colour");
    }

  while((_Bool)0);
  signed int return_value_XParseColor$9;
  return_value_XParseColor$9=XParseColor(osd->display, colourmap, colour, col);
  unsigned long int return_value_pthread_self$4;
  unsigned long int return_value_pthread_self$5;
  unsigned long int return_value_pthread_self$6;
  unsigned long int return_value_pthread_self$8;
  if(!(return_value_XParseColor$9 == 0))
  {
    do
      if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
      {
        return_value_pthread_self$4=pthread_self();
        fprintf(stderr, "%s:%-4d %ld@%s: attempting to allocate colour\n", (const void *)"xosd.c", 521, return_value_pthread_self$4, (const void *)"parse_colour");
      }

    while((_Bool)0);
    signed int return_value_XAllocColor$7;
    return_value_XAllocColor$7=XAllocColor(osd->display, colourmap, col);
    if(!(return_value_XAllocColor$7 == 0))
    {
      do
        if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
        {
          return_value_pthread_self$5=pthread_self();
          fprintf(stderr, "%s:%-4d %ld@%s: allocation sucessful\n", (const void *)"xosd.c", 523, return_value_pthread_self$5, (const void *)"parse_colour");
        }

      while((_Bool)0);
      *pixel = col->pixel;
    }

    else
    {
      do
        if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
        {
          return_value_pthread_self$6=pthread_self();
          fprintf(stderr, "%s:%-4d %ld@%s: defaulting to white. could not allocate colour\n", (const void *)"xosd.c", 526, return_value_pthread_self$6, (const void *)"parse_colour");
        }

      while((_Bool)0);
      *pixel = (&((struct anonymous$19 *)osd->display)->screens[(signed long int)osd->screen])->white_pixel;
      retval = -1;
    }
  }

  else
  {
    do
      if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
      {
        return_value_pthread_self$8=pthread_self();
        fprintf(stderr, "%s:%-4d %ld@%s: could not poarse colour. defaulting to white\n", (const void *)"xosd.c", 531, return_value_pthread_self$8, (const void *)"parse_colour");
      }

    while((_Bool)0);
    *pixel = (&((struct anonymous$19 *)osd->display)->screens[(signed long int)osd->screen])->white_pixel;
    retval = -1;
  }
  return retval;
}

// printerror
// file testprog.c line 8
void printerror()
{
  fprintf(stderr, "ERROR: %s\n", xosd_error);
}

// stay_on_top
// file xosd.c line 543
void stay_on_top(struct _XDisplay *dpy, unsigned long int win)
{
  unsigned long int gnome;
  unsigned long int net_wm;
  unsigned long int type;
  signed int format;
  unsigned long int nitems;
  unsigned long int bytesafter;
  unsigned char *args = (unsigned char *)(void *)0;
  unsigned long int root = (&((struct anonymous$19 *)dpy)->screens[(signed long int)((struct anonymous$19 *)dpy)->default_screen])->root;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 551, return_value_pthread_self$1, (const void *)"stay_on_top");
    }

  while((_Bool)0);
  gnome=XInternAtom(dpy, "_WIN_SUPPORTING_WM_CHECK", 0);
  net_wm=XInternAtom(dpy, "_NET_SUPPORTED", 0);
  signed int return_value_XGetWindowProperty$3;
  return_value_XGetWindowProperty$3=XGetWindowProperty(dpy, root, gnome, (signed long int)0, (signed long int)((unsigned long int)65536 / sizeof(signed long int) /*8ul*/ ), 0, (unsigned long int)0L, &type, &format, &nitems, &bytesafter, &args);
  signed int return_value_XGetWindowProperty$2;
  if(return_value_XGetWindowProperty$3 == 0 && nitems >= 1ul)
  {
    struct anonymous$21 xev;
    unsigned long int gnome_layer;
    gnome_layer=XInternAtom(dpy, "_WIN_LAYER", 0);
    memset((void *)&xev, 0, sizeof(struct anonymous$21) /*96ul*/ );
    xev.type = 33;
    xev.window = win;
    xev.message_type = gnome_layer;
    xev.format = 32;
    xev.data.l[(signed long int)0] = (signed long int)6;
    XSendEvent(dpy, (&((struct anonymous$19 *)dpy)->screens[(signed long int)((struct anonymous$19 *)dpy)->default_screen])->root, 0, 1L << 19, (union _XEvent *)&xev);
    XFree((void *)args);
  }

  else
  {
    return_value_XGetWindowProperty$2=XGetWindowProperty(dpy, root, net_wm, (signed long int)0, (signed long int)((unsigned long int)65536 / sizeof(signed long int) /*8ul*/ ), 0, (unsigned long int)0L, &type, &format, &nitems, &bytesafter, &args);
    if(return_value_XGetWindowProperty$2 == 0)
    {
      if(nitems >= 1ul)
      {
        union _XEvent e;
        unsigned long int net_wm_state;
        net_wm_state=XInternAtom(dpy, "_NET_WM_STATE", 0);
        unsigned long int net_wm_top;
        net_wm_top=XInternAtom(dpy, "_NET_WM_STATE_STAYS_ON_TOP", 0);
        memset((void *)&e, 0, sizeof(union _XEvent) /*192ul*/ );
        e.xclient.type = 33;
        e.xclient.message_type = net_wm_state;
        e.xclient.display = dpy;
        e.xclient.window = win;
        e.xclient.format = 32;
        e.xclient.data.l[(signed long int)0] = (signed long int)1;
        e.xclient.data.l[(signed long int)1] = (signed long int)net_wm_top;
        e.xclient.data.l[(signed long int)2] = 0l;
        e.xclient.data.l[(signed long int)3] = 0l;
        e.xclient.data.l[(signed long int)4] = 0l;
        XSendEvent(dpy, (&((struct anonymous$19 *)dpy)->screens[(signed long int)((struct anonymous$19 *)dpy)->default_screen])->root, 0, 1L << 20, &e);
        XFree((void *)args);
      }

    }

  }
  XRaiseWindow(dpy, win);
}

// xosd_create
// file xosd.h line 59
struct xosd * xosd_create(signed int number_lines)
{
  struct xosd *osd;
  signed int event_basep;
  signed int error_basep;
  signed int i;
  char *display;
  struct anonymous$3 setwinattr;
  struct anonymous$46 xgcv = { .function=0, .plane_mask=0ul, .foreground=0ul, .background=0ul,
    .line_width=0, .line_style=0, .cap_style=0,
    .join_style=0, .fill_style=0, .fill_rule=0,
    .arc_mode=0, .tile=0ul, .stipple=0ul,
    .ts_x_origin=0, .ts_y_origin=0, .font=0ul,
    .subwindow_mode=0, .graphics_exposures=0, .clip_x_origin=0,
    .clip_y_origin=0, .clip_mask=0ul, .dash_offset=0,
    .dashes=0 };
  signed int screens;
  signed int dummy_a;
  signed int dummy_b;
  struct anonymous$11 *screeninfo = (struct anonymous$11 *)(void *)0;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 662, return_value_pthread_self$1, (const void *)"xosd_create");
    }

  while((_Bool)0);
  unsigned long int return_value_pthread_self$2;
  do
    if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$2=pthread_self();
      fprintf(stderr, "%s:%-4d %ld@%s: getting display\n", (const void *)"xosd.c", 663, return_value_pthread_self$2, (const void *)"xosd_create");
    }

  while((_Bool)0);
  display=getenv("DISPLAY");
  unsigned long int return_value_pthread_self$3;
  unsigned long int return_value_pthread_self$5;
  signed int return_value_pipe$6;
  unsigned long int return_value_pthread_self$7;
  unsigned long int return_value_pthread_self$8;
  unsigned long int return_value_pthread_self$9;
  void *return_value_malloc$10;
  unsigned long int return_value_pthread_self$11;
  unsigned long int return_value_pthread_self$12;
  unsigned long int return_value_pthread_self$13;
  signed int return_value_XShapeQueryExtension$14;
  unsigned long int return_value_pthread_self$15;
  unsigned long int return_value_pthread_self$16;
  signed int return_value_XineramaQueryExtension$17;
  _Bool tmp_if_expr$18;
  _Bool tmp_if_expr$20;
  signed int return_value_XineramaIsActive$19;
  unsigned long int return_value_pthread_self$21;
  unsigned long int return_value_XRootWindow$22;
  unsigned long int return_value_pthread_self$23;
  unsigned long int return_value_pthread_self$24;
  unsigned long int return_value_pthread_self$25;
  if(display == ((char *)NULL))
  {
    xosd_error = "No display";
    return (struct xosd *)(void *)0;
  }

  else
  {
    do
      if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
      {
        return_value_pthread_self$3=pthread_self();
        fprintf(stderr, "%s:%-4d %ld@%s: Mallocing osd\n", (const void *)"xosd.c", 670, return_value_pthread_self$3, (const void *)"xosd_create");
      }

    while((_Bool)0);
    void *return_value_malloc$4;
    return_value_malloc$4=malloc(sizeof(struct xosd) /*456ul*/ );
    osd = (struct xosd *)return_value_malloc$4;
    memset((void *)osd, 0, sizeof(struct xosd) /*456ul*/ );
    if(osd == ((struct xosd *)NULL))
      xosd_error = "Out of memory";

    else
    {
      do
        if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
        {
          return_value_pthread_self$5=pthread_self();
          fprintf(stderr, "%s:%-4d %ld@%s: Creating pipe\n", (const void *)"xosd.c", 678, return_value_pthread_self$5, (const void *)"xosd_create");
        }

      while((_Bool)0);
      return_value_pipe$6=pipe(osd->pipefd);
      if(return_value_pipe$6 == -1)
        xosd_error = "Error creating pipe";

      else
      {
        do
          if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
          {
            return_value_pthread_self$7=pthread_self();
            fprintf(stderr, "%s:%-4d %ld@%s: initializing mutex\n", (const void *)"xosd.c", 684, return_value_pthread_self$7, (const void *)"xosd_create");
          }

        while((_Bool)0);
        pthread_mutex_init(&osd->mutex, (const union anonymous$18 *)(void *)0);
        pthread_mutex_init(&osd->mutex_sync, (const union anonymous$18 *)(void *)0);
        do
          if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
          {
            return_value_pthread_self$8=pthread_self();
            fprintf(stderr, "%s:%-4d %ld@%s: initializing condition\n", (const void *)"xosd.c", 687, return_value_pthread_self$8, (const void *)"xosd_create");
          }

        while((_Bool)0);
        pthread_cond_init(&osd->cond_wait, (const union anonymous$18 *)(void *)0);
        pthread_cond_init(&osd->cond_sync, (const union anonymous$18 *)(void *)0);
        do
          if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
          {
            return_value_pthread_self$9=pthread_self();
            fprintf(stderr, "%s:%-4d %ld@%s: initializing number lines\n", (const void *)"xosd.c", 691, return_value_pthread_self$9, (const void *)"xosd_create");
          }

        while((_Bool)0);
        osd->number_lines = number_lines;
        return_value_malloc$10=malloc(sizeof(union xosd_line) /*16ul*/  * (unsigned long int)osd->number_lines);
        osd->lines = (union xosd_line *)return_value_malloc$10;
        if(osd->lines == ((union xosd_line *)NULL))
          xosd_error = "Out of memory";

        else
        {
          i = 0;
          for( ; !(i >= osd->number_lines); i = i + 1)
            memset((void *)&osd->lines[(signed long int)i], 0, sizeof(union xosd_line) /*16ul*/ );
          do
            if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
            {
              return_value_pthread_self$11=pthread_self();
              fprintf(stderr, "%s:%-4d %ld@%s: misc osd variable initialization\n", (const void *)"xosd.c", 702, return_value_pthread_self$11, (const void *)"xosd_create");
            }

          while((_Bool)0);
          osd->generation = 0;
          osd->done = 0;
          osd->pos = (enum anonymous$45)XOSD_top;
          osd->hoffset = 0;
          osd->align = (enum anonymous$5)XOSD_left;
          osd->voffset = 0;
          osd->timeout = -1;
          (&osd->timeout_start)->tv_usec = (signed long int)0;
          (&osd->timeout_start)->tv_sec = (&osd->timeout_start)->tv_usec;
          osd->fontset = (struct _XOC *)(void *)0;
          osd->bar_length = -1;
          do
            if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
            {
              return_value_pthread_self$12=pthread_self();
              fprintf(stderr, "%s:%-4d %ld@%s: Display query\n", (const void *)"xosd.c", 714, return_value_pthread_self$12, (const void *)"xosd_create");
            }

          while((_Bool)0);
          osd->display=XOpenDisplay(display);
          if(osd->display == ((struct _XDisplay *)NULL))
            xosd_error = "Cannot open display";

          else
          {
            osd->screen=XDefaultScreen(osd->display);
            do
              if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
              {
                return_value_pthread_self$13=pthread_self();
                fprintf(stderr, "%s:%-4d %ld@%s: x shape extension query\n", (const void *)"xosd.c", 722, return_value_pthread_self$13, (const void *)"xosd_create");
              }

            while((_Bool)0);
            return_value_XShapeQueryExtension$14=XShapeQueryExtension(osd->display, &event_basep, &error_basep);
            if(return_value_XShapeQueryExtension$14 == 0)
              xosd_error = "X-Server does not support shape extension";

            else
            {
              osd->visual = (&((struct anonymous$19 *)osd->display)->screens[(signed long int)osd->screen])->root_visual;
              osd->depth = (unsigned int)(&((struct anonymous$19 *)osd->display)->screens[(signed long int)osd->screen])->root_depth;
              do
                if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
                {
                  return_value_pthread_self$15=pthread_self();
                  fprintf(stderr, "%s:%-4d %ld@%s: font selection info\n", (const void *)"xosd.c", 731, return_value_pthread_self$15, (const void *)"xosd_create");
                }

              while((_Bool)0);
              xosd_set_font(osd, osd_default_font);
              if(osd->fontset == ((struct _XOC *)NULL))
                xosd_error = "Default font not found";

              else
              {
                do
                  if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
                  {
                    return_value_pthread_self$16=pthread_self();
                    fprintf(stderr, "%s:%-4d %ld@%s: width and height initialization\n", (const void *)"xosd.c", 741, return_value_pthread_self$16, (const void *)"xosd_create");
                  }

                while((_Bool)0);
                return_value_XineramaQueryExtension$17=XineramaQueryExtension(osd->display, &dummy_a, &dummy_b);
                if(!(return_value_XineramaQueryExtension$17 == 0))
                {
                  screeninfo=XineramaQueryScreens(osd->display, &screens);
                  tmp_if_expr$18 = screeninfo != ((struct anonymous$11 *)NULL) ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$18 = (_Bool)0;
                if(tmp_if_expr$18)
                {
                  return_value_XineramaIsActive$19=XineramaIsActive(osd->display);
                  tmp_if_expr$20 = return_value_XineramaIsActive$19 != 0 ? (_Bool)1 : (_Bool)0;
                }

                else
                  tmp_if_expr$20 = (_Bool)0;
                if(tmp_if_expr$20)
                {
                  osd->screen_width = (signed int)(screeninfo + (signed long int)0)->width;
                  osd->screen_height = (signed int)(screeninfo + (signed long int)0)->height;
                  osd->screen_xpos = (signed int)(screeninfo + (signed long int)0)->x_org;
                }

                else
                {
                  osd->screen_width=XDisplayWidth(osd->display, osd->screen);
                  osd->screen_height=XDisplayHeight(osd->display, osd->screen);
                  osd->screen_xpos = 0;
                }
                if(!(screeninfo == ((struct anonymous$11 *)NULL)))
                  XFree((void *)screeninfo);

                osd->line_height = 10;
                osd->height = osd->line_height * osd->number_lines;
                do
                  if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
                  {
                    return_value_pthread_self$21=pthread_self();
                    fprintf(stderr, "%s:%-4d %ld@%s: creating X Window\n", (const void *)"xosd.c", 763, return_value_pthread_self$21, (const void *)"xosd_create");
                  }

                while((_Bool)0);
                setwinattr.override_redirect = 1;
                return_value_XRootWindow$22=XRootWindow(osd->display, osd->screen);
                osd->window=XCreateWindow(osd->display, return_value_XRootWindow$22, 0, 0, (unsigned int)osd->screen_width, (unsigned int)osd->height, (unsigned int)0, (signed int)osd->depth, (unsigned int)0L, osd->visual, (unsigned long int)(1L << 9), &setwinattr);
                XStoreName(osd->display, osd->window, "XOSD");
                osd->mask_bitmap=XCreatePixmap(osd->display, osd->window, (unsigned int)osd->screen_width, (unsigned int)osd->height, (unsigned int)1);
                osd->line_bitmap=XCreatePixmap(osd->display, osd->window, (unsigned int)osd->screen_width, (unsigned int)osd->line_height, osd->depth);
                osd->gc=XCreateGC(osd->display, osd->window, (unsigned long int)(1L << 16), &xgcv);
                osd->mask_gc=XCreateGC(osd->display, osd->mask_bitmap, (unsigned long int)(1L << 16), &xgcv);
                osd->mask_gc_back=XCreateGC(osd->display, osd->mask_bitmap, (unsigned long int)(1L << 16), &xgcv);
                XSetBackground(osd->display, osd->gc, (&((struct anonymous$19 *)osd->display)->screens[(signed long int)osd->screen])->white_pixel);
                XSetForeground(osd->display, osd->mask_gc_back, (&((struct anonymous$19 *)osd->display)->screens[(signed long int)osd->screen])->black_pixel);
                XSetBackground(osd->display, osd->mask_gc_back, (&((struct anonymous$19 *)osd->display)->screens[(signed long int)osd->screen])->white_pixel);
                XSetForeground(osd->display, osd->mask_gc, (&((struct anonymous$19 *)osd->display)->screens[(signed long int)osd->screen])->white_pixel);
                XSetBackground(osd->display, osd->mask_gc, (&((struct anonymous$19 *)osd->display)->screens[(signed long int)osd->screen])->black_pixel);
                do
                  if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
                  {
                    return_value_pthread_self$23=pthread_self();
                    fprintf(stderr, "%s:%-4d %ld@%s: setting colour\n", (const void *)"xosd.c", 801, return_value_pthread_self$23, (const void *)"xosd_create");
                  }

                while((_Bool)0);
                xosd_set_colour(osd, osd_default_colour);
                do
                  if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
                  {
                    return_value_pthread_self$24=pthread_self();
                    fprintf(stderr, "%s:%-4d %ld@%s: stay on top\n", (const void *)"xosd.c", 804, return_value_pthread_self$24, (const void *)"xosd_create");
                  }

                while((_Bool)0);
                stay_on_top(osd->display, osd->window);
                do
                  if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
                  {
                    return_value_pthread_self$25=pthread_self();
                    fprintf(stderr, "%s:%-4d %ld@%s: initializing event thread\n", (const void *)"xosd.c", 807, return_value_pthread_self$25, (const void *)"xosd_create");
                  }

                while((_Bool)0);
                pthread_create(&osd->event_thread, (const union pthread_attr_t *)(void *)0, event_loop, (void *)osd);
                return osd;
              }
            }

          error3:
            ;
            XCloseDisplay(osd->display);
          }

        error2:
          ;
          free((void *)osd->lines);
        }

      error1:
        ;
        pthread_cond_destroy(&osd->cond_sync);
        pthread_cond_destroy(&osd->cond_wait);
        pthread_mutex_destroy(&osd->mutex_sync);
        pthread_mutex_destroy(&osd->mutex);
        close(osd->pipefd[(signed long int)0]);
        close(osd->pipefd[(signed long int)1]);
      }

    error0b:
      ;
      free((void *)osd);
    }

  error0:
    ;
    return (struct xosd *)(void *)0;
  }
}

// xosd_destroy
// file xosd.h line 92
signed int xosd_destroy(struct xosd *osd)
{
  signed int i;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 848, return_value_pthread_self$1, (const void *)"xosd_destroy");
    }

  while((_Bool)0);
  unsigned long int return_value_pthread_self$2;
  unsigned long int return_value_pthread_self$3;
  unsigned long int return_value_pthread_self$4;
  unsigned long int return_value_pthread_self$5;
  unsigned long int return_value_pthread_self$6;
  unsigned long int return_value_pthread_self$7;
  unsigned long int return_value_pthread_self$8;
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
  {
    do
      if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
      {
        return_value_pthread_self$2=pthread_self();
        fprintf(stderr, "%s:%-4d %ld@%s: waiting for threads to exit\n", (const void *)"xosd.c", 852, return_value_pthread_self$2, (const void *)"xosd_destroy");
      }

    while((_Bool)0);
    _xosd_lock(osd);
    osd->done = 1;
    _xosd_unlock(osd);
    do
      if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
      {
        return_value_pthread_self$3=pthread_self();
        fprintf(stderr, "%s:%-4d %ld@%s: join threads\n", (const void *)"xosd.c", 857, return_value_pthread_self$3, (const void *)"xosd_destroy");
      }

    while((_Bool)0);
    pthread_join(osd->event_thread, (void **)(void *)0);
    do
      if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
      {
        return_value_pthread_self$4=pthread_self();
        fprintf(stderr, "%s:%-4d %ld@%s: freeing X resources\n", (const void *)"xosd.c", 860, return_value_pthread_self$4, (const void *)"xosd_destroy");
      }

    while((_Bool)0);
    XFreeGC(osd->display, osd->gc);
    XFreeGC(osd->display, osd->mask_gc);
    XFreeGC(osd->display, osd->mask_gc_back);
    XFreePixmap(osd->display, osd->line_bitmap);
    XFreeFontSet(osd->display, osd->fontset);
    XFreePixmap(osd->display, osd->mask_bitmap);
    XDestroyWindow(osd->display, osd->window);
    XCloseDisplay(osd->display);
    do
      if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
      {
        return_value_pthread_self$5=pthread_self();
        fprintf(stderr, "%s:%-4d %ld@%s: freeing lines\n", (const void *)"xosd.c", 871, return_value_pthread_self$5, (const void *)"xosd_destroy");
      }

    while((_Bool)0);
    i = 0;
    for( ; !(i >= osd->number_lines); i = i + 1)
      if((signed int)(osd->lines + (signed long int)i)->type == LINE_text)
      {
        if(!((osd->lines + (signed long int)i)->text.string == ((char *)NULL)))
          free((void *)(osd->lines + (signed long int)i)->text.string);

      }

    free((void *)osd->lines);
    do
      if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
      {
        return_value_pthread_self$6=pthread_self();
        fprintf(stderr, "%s:%-4d %ld@%s: destroying condition and mutex\n", (const void *)"xosd.c", 877, return_value_pthread_self$6, (const void *)"xosd_destroy");
      }

    while((_Bool)0);
    pthread_cond_destroy(&osd->cond_sync);
    pthread_cond_destroy(&osd->cond_wait);
    pthread_mutex_destroy(&osd->mutex_sync);
    pthread_mutex_destroy(&osd->mutex);
    close(osd->pipefd[(signed long int)0]);
    close(osd->pipefd[(signed long int)1]);
    do
      if(!((Dtrace & (signed int)_xosd_debug_level) == 0))
      {
        return_value_pthread_self$7=pthread_self();
        fprintf(stderr, "%s:%-4d %ld@%s: freeing osd structure\n", (const void *)"xosd.c", 885, return_value_pthread_self$7, (const void *)"xosd_destroy");
      }

    while((_Bool)0);
    free((void *)osd);
    do
      if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
      {
        return_value_pthread_self$8=pthread_self();
        fprintf(stderr, "%s:%-4d %ld>%s\n", (const void *)"xosd.c", 888, return_value_pthread_self$8, (const void *)"xosd_destroy");
      }

    while((_Bool)0);
    return 0;
  }
}

// xosd_display
// file xosd.h line 134
signed int xosd_display(struct xosd *osd, signed int line, enum anonymous$12 command, ...)
{
  signed int ret = -1;
  union xosd_line newline = { .type=(enum LINE)LINE_blank };
  __builtin_va_list a;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 922, return_value_pthread_self$1, (const void *)"xosd_display");
    }

  while((_Bool)0);
  _Bool tmp_if_expr$2;
  signed long int a$array_size0;
  char buf[a$array_size0];
  struct xosd_text *xosd_display$$1$$3$$1$$l;
  char *string;
  _Bool tmp_if_expr$6;
  struct xosd_bar *l;
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
  {
    if(!(line >= 0))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = line >= osd->number_lines ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
    {
      xosd_error = "xosd_display: Invalid Line Number";
      return -1;
    }

    else
    {
      va_start(a, command);
      switch((signed int)command)
      {
        case XOSD_string:

        case XOSD_printf:
        {
          a$array_size0 = (signed long int)XOSD_MAX_PRINTF_BUF_SIZE;
          xosd_display$$1$$3$$1$$l = &newline.text;
          string=va_arg(a, __typeof__(string));
          if((signed int)command == XOSD_printf)
          {
            signed int return_value_vsnprintf$3;
            return_value_vsnprintf$3=vsnprintf(buf, (unsigned long int)a$array_size0, string, a);
            if((unsigned long int)return_value_vsnprintf$3 >= (unsigned long int)a$array_size0)
            {
              xosd_error = "xosd_display: Buffer too small";
              goto error;
            }

            string = buf;
          }

          if(!(string == ((char *)NULL)))
            tmp_if_expr$6 = *string != 0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$6 = (_Bool)0;
          if(tmp_if_expr$6)
          {
            unsigned long int return_value_strlen$4;
            return_value_strlen$4=strlen(string);
            ret = (signed int)return_value_strlen$4;
            xosd_display$$1$$3$$1$$l->type = (enum LINE)LINE_text;
            void *return_value_malloc$5;
            return_value_malloc$5=malloc((unsigned long int)(ret + 1));
            xosd_display$$1$$3$$1$$l->string = (char *)return_value_malloc$5;
            memcpy((void *)xosd_display$$1$$3$$1$$l->string, (const void *)string, (unsigned long int)(ret + 1));
          }

          else
          {
            ret = 0;
            xosd_display$$1$$3$$1$$l->type = (enum LINE)LINE_blank;
          }
          xosd_display$$1$$3$$1$$l->width = -1;
          break;
        }
        case XOSD_percentage:

        case XOSD_slider:
        {
          l = &newline.bar;
          ret=va_arg(a, __typeof__(ret));
          ret = ret < 0 ? 0 : (ret > 100 ? 100 : ret);
          l->type = (enum LINE)((signed int)command == XOSD_percentage ? LINE_percentage : LINE_slider);
          l->value = ret;
          break;
        }
        default:
        {
          xosd_error = "xosd_display: Unknown command";
          goto error;
        }
      }
      _xosd_lock(osd);
      if(!((signed int)(osd->lines + (signed long int)line)->type == LINE_text))
      {
        if((signed int)(osd->lines + (signed long int)line)->type == LINE_blank || (signed int)(osd->lines + (signed long int)line)->type == LINE_percentage || (signed int)(osd->lines + (signed long int)line)->type == LINE_slider)
          goto __CPROVER_DUMP_L18;

      }

      else
        free((void *)(osd->lines + (signed long int)line)->text.string);

    __CPROVER_DUMP_L18:
      ;
      osd->lines[(signed long int)line] = newline;
      osd->update = osd->update | (enum anonymous$43)(UPD_content | UPD_timer | UPD_show);
      _xosd_unlock(osd);

    error:
      ;
      va_end(a);
      return ret;
    }
  }
}

// xosd_get_colour
// file xosd.c line 1242
signed int xosd_get_colour(struct xosd *osd, signed int *red, signed int *green, signed int *blue)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1244, return_value_pthread_self$1, (const void *)"xosd_get_colour");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
  {
    if(!(red == ((signed int *)NULL)))
      *red = (signed int)osd->colour.red;

    if(!(blue == ((signed int *)NULL)))
      *blue = (signed int)osd->colour.blue;

    if(!(green == ((signed int *)NULL)))
      *green = (signed int)osd->colour.green;

    return 0;
  }
}

// xosd_get_number_lines
// file xosd.c line 1353
signed int xosd_get_number_lines(struct xosd *osd)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1355, return_value_pthread_self$1, (const void *)"xosd_get_number_lines");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
    return osd->number_lines;
}

// xosd_hide
// file xosd.c line 1278
signed int xosd_hide(struct xosd *osd)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1280, return_value_pthread_self$1, (const void *)"xosd_hide");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
    if(!((1 & osd->generation) == 0))
    {
      _xosd_lock(osd);
      osd->update = osd->update & (enum anonymous$43)~UPD_show;
      osd->update = osd->update | (enum anonymous$43)UPD_hide;
      _xosd_unlock(osd);
      return 0;
    }

    else
      return -1;
}

// xosd_init
// file xosd.c line 619
struct xosd * xosd_init(const char *font, const char *colour, signed int timeout, enum anonymous$45 pos, signed int voffset, signed int shadow_offset, signed int number_lines)
{
  struct xosd *osd;
  osd=xosd_create(number_lines);
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 624, return_value_pthread_self$1, (const void *)"xosd_init");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return (struct xosd *)(void *)0;

  else
  {
    signed int return_value_xosd_set_font$2;
    return_value_xosd_set_font$2=xosd_set_font(osd, font);
    if(return_value_xosd_set_font$2 == -1)
    {
      xosd_destroy(osd);
      return (struct xosd *)(void *)0;
    }

    else
    {
      xosd_set_colour(osd, colour);
      xosd_set_timeout(osd, timeout);
      xosd_set_pos(osd, pos);
      xosd_set_vertical_offset(osd, voffset);
      xosd_set_shadow_offset(osd, shadow_offset);
      return osd;
    }
  }
}

// xosd_is_onscreen
// file xosd.c line 1000
signed int xosd_is_onscreen(struct xosd *osd)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1002, return_value_pthread_self$1, (const void *)"xosd_is_onscreen");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
    return osd->generation & 1;
}

// xosd_scroll
// file xosd.h line 346
signed int xosd_scroll(struct xosd *osd, signed int lines)
{
  signed int i;
  union xosd_line *src;
  union xosd_line *dst;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1323, return_value_pthread_self$1, (const void *)"xosd_scroll");
    }

  while((_Bool)0);
  _Bool tmp_if_expr$2;
  union xosd_line *tmp_post$3;
  union xosd_line *tmp_post$4;
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
  {
    if(!(lines >= 1))
      tmp_if_expr$2 = (_Bool)1;

    else
      tmp_if_expr$2 = lines > osd->number_lines ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$2)
      return -1;

    else
    {
      _xosd_lock(osd);
      i = 0;
      src = osd->lines;
      for( ; !(i >= lines); src = src + 1l)
      {
        if((signed int)src->type == LINE_text)
        {
          if(!(src->text.string == ((char *)NULL)))
          {
            free((void *)src->text.string);
            src->text.string = (char *)(void *)0;
          }

        }

        i = i + 1;
      }
      dst = osd->lines;
      for( ; !(i >= osd->number_lines); i = i + 1)
      {
        tmp_post$3 = dst;
        dst = dst + 1l;
        tmp_post$4 = src;
        src = src + 1l;
        *tmp_post$3 = *tmp_post$4;
      }
      for( ; !(dst >= src); dst = dst + 1l)
      {
        dst->type = (enum LINE)LINE_blank;
        dst->text.string = (char *)(void *)0;
      }
      osd->update = osd->update | (enum anonymous$43)UPD_content;
      _xosd_unlock(osd);
      return 0;
    }
  }
}

// xosd_set_align
// file xosd.c line 1224
signed int xosd_set_align(struct xosd *osd, enum anonymous$5 align)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1226, return_value_pthread_self$1, (const void *)"xosd_set_align");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
  {
    _xosd_lock(osd);
    osd->align = align;
    osd->update = osd->update | (enum anonymous$43)UPD_content;
    _xosd_unlock(osd);
    return 0;
  }
}

// xosd_set_bar_length
// file xosd.h line 115
signed int xosd_set_bar_length(struct xosd *osd, signed int length)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 898, return_value_pthread_self$1, (const void *)"xosd_set_bar_length");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
    if(length == 0)
      return -1;

    else
      if(!(length >= -1))
        return -1;

      else
      {
        osd->bar_length = length;
        return 0;
      }
}

// xosd_set_colour
// file xosd.c line 1030
signed int xosd_set_colour(struct xosd *osd, const char *colour)
{
  signed int retval = 0;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1034, return_value_pthread_self$1, (const void *)"xosd_set_colour");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
  {
    _xosd_lock(osd);
    retval=parse_colour(osd, &osd->colour, &osd->pixel, colour);
    osd->update = osd->update | (enum anonymous$43)UPD_lines;
    _xosd_unlock(osd);
    return retval;
  }
}

// xosd_set_font
// file xosd.h line 320
signed int xosd_set_font(struct xosd *osd, const char *font)
{
  struct _XOC *fontset2;
  char **missing;
  signed int nmissing;
  char *defstr;
  signed int ret = 0;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1100, return_value_pthread_self$1, (const void *)"xosd_set_font");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
    if(font == ((const char *)NULL))
      return -1;

    else
    {
      _xosd_lock(osd);
      fontset2=XCreateFontSet(osd->display, font, &missing, &nmissing, &defstr);
      XFreeStringList(missing);
      if(fontset2 == ((struct _XOC *)NULL))
      {
        xosd_error = "Requested font not found";
        ret = -1;
      }

      else
      {
        if(!(osd->fontset == ((struct _XOC *)NULL)))
          XFreeFontSet(osd->display, osd->fontset);

        osd->fontset = fontset2;
        osd->update = osd->update | (enum anonymous$43)UPD_font;
      }
      _xosd_unlock(osd);
      return ret;
    }
}

// xosd_set_horizontal_offset
// file xosd.c line 1188
signed int xosd_set_horizontal_offset(struct xosd *osd, signed int hoffset)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1190, return_value_pthread_self$1, (const void *)"xosd_set_horizontal_offset");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
  {
    _xosd_lock(osd);
    osd->hoffset = hoffset;
    osd->update = osd->update | (enum anonymous$43)UPD_pos;
    _xosd_unlock(osd);
    return 0;
  }
}

// xosd_set_outline_colour
// file xosd.c line 1070
signed int xosd_set_outline_colour(struct xosd *osd, const char *colour)
{
  signed int retval = 0;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1074, return_value_pthread_self$1, (const void *)"xosd_set_outline_colour");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
  {
    _xosd_lock(osd);
    retval=parse_colour(osd, &osd->outline_colour, &osd->outline_pixel, colour);
    osd->update = osd->update | (enum anonymous$43)UPD_lines;
    _xosd_unlock(osd);
    return retval;
  }
}

// xosd_set_outline_offset
// file xosd.h line 229
signed int xosd_set_outline_offset(struct xosd *osd, signed int outline_offset)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1152, return_value_pthread_self$1, (const void *)"xosd_set_outline_offset");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
    if(!(outline_offset >= 0))
      return -1;

    else
    {
      _xosd_lock(osd);
      osd->outline_offset = outline_offset;
      osd->update = osd->update | (enum anonymous$43)UPD_font;
      _xosd_unlock(osd);
      return 0;
    }
}

// xosd_set_pos
// file xosd.c line 1206
signed int xosd_set_pos(struct xosd *osd, enum anonymous$45 pos)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1208, return_value_pthread_self$1, (const void *)"xosd_set_pos");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
  {
    _xosd_lock(osd);
    osd->pos = pos;
    osd->update = osd->update | (enum anonymous$43)UPD_pos;
    _xosd_unlock(osd);
    return 0;
  }
}

// xosd_set_shadow_colour
// file xosd.c line 1050
signed int xosd_set_shadow_colour(struct xosd *osd, const char *colour)
{
  signed int retval = 0;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1054, return_value_pthread_self$1, (const void *)"xosd_set_shadow_colour");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
  {
    _xosd_lock(osd);
    retval=parse_colour(osd, &osd->shadow_colour, &osd->shadow_pixel, colour);
    osd->update = osd->update | (enum anonymous$43)UPD_lines;
    _xosd_unlock(osd);
    return retval;
  }
}

// xosd_set_shadow_offset
// file xosd.c line 1130
signed int xosd_set_shadow_offset(struct xosd *osd, signed int shadow_offset)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1132, return_value_pthread_self$1, (const void *)"xosd_set_shadow_offset");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
    if(!(shadow_offset >= 0))
      return -1;

    else
    {
      _xosd_lock(osd);
      osd->shadow_offset = shadow_offset;
      osd->update = osd->update | (enum anonymous$43)UPD_font;
      _xosd_unlock(osd);
      return 0;
    }
}

// xosd_set_timeout
// file xosd.h line 295
signed int xosd_set_timeout(struct xosd *osd, signed int timeout)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1264, return_value_pthread_self$1, (const void *)"xosd_set_timeout");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
  {
    _xosd_lock(osd);
    osd->timeout = timeout;
    osd->update = osd->update | (enum anonymous$43)UPD_timer;
    _xosd_unlock(osd);
    return 0;
  }
}

// xosd_set_vertical_offset
// file xosd.c line 1170
signed int xosd_set_vertical_offset(struct xosd *osd, signed int voffset)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1172, return_value_pthread_self$1, (const void *)"xosd_set_vertical_offset");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
  {
    _xosd_lock(osd);
    osd->voffset = voffset;
    osd->update = osd->update | (enum anonymous$43)UPD_pos;
    _xosd_unlock(osd);
    return 0;
  }
}

// xosd_show
// file xosd.c line 1298
signed int xosd_show(struct xosd *osd)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1300, return_value_pthread_self$1, (const void *)"xosd_show");
    }

  while((_Bool)0);
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
    if(!((~osd->generation & 1) == 0))
    {
      _xosd_lock(osd);
      osd->update = osd->update & (enum anonymous$43)~UPD_hide;
      osd->update = osd->update | (enum anonymous$43)(UPD_show | UPD_timer);
      _xosd_unlock(osd);
      return 0;
    }

    else
      return -1;
}

// xosd_uninit
// file xosd.c line 834
signed int xosd_uninit(struct xosd *osd)
{
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 836, return_value_pthread_self$1, (const void *)"xosd_uninit");
    }

  while((_Bool)0);
  signed int return_value_xosd_destroy$2;
  return_value_xosd_destroy$2=xosd_destroy(osd);
  return return_value_xosd_destroy$2;
}

// xosd_wait_until_no_display
// file xosd.h line 157
signed int xosd_wait_until_no_display(struct xosd *osd)
{
  signed int generation;
  unsigned long int return_value_pthread_self$1;
  do
    if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
    {
      return_value_pthread_self$1=pthread_self();
      fprintf(stderr, "%s:%-4d %ld<%s\n", (const void *)"xosd.c", 1015, return_value_pthread_self$1, (const void *)"xosd_wait_until_no_display");
    }

  while((_Bool)0);
  unsigned long int return_value_pthread_self$2;
  if(osd == ((struct xosd *)NULL))
    return -1;

  else
  {
    generation = osd->generation;
    if(!((1 & generation) == 0))
      _wait_until_update(osd, generation);

    do
      if(!((Dfunction & (signed int)_xosd_debug_level) == 0))
      {
        return_value_pthread_self$2=pthread_self();
        fprintf(stderr, "%s:%-4d %ld>%s\n", (const void *)"xosd.c", 1022, return_value_pthread_self$2, (const void *)"xosd_wait_until_no_display");
      }

    while((_Bool)0);
    return 0;
  }
}

