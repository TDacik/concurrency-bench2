// tag-#anon#ST[*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visual'||U64'visualid'||S32'screen'||S32'depth'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'colormap_size'||S32'bits_per_rgb'|]
// file /usr/include/X11/Xutil.h line 287
struct anonymous_11;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visuals'|]#}_SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visuals'|]#_'depths'||S32'root_depth'||U32'_pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'root_visual'||*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]
// file /usr/include/X11/Xlib.h line 257
struct anonymous_1;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||*{SYM#tag-_XPrivate#}_SYM#tag-_XPrivate#_'private1'||S32'fd'||S32'private2'||S32'proto_major_version'||S32'proto_minor_version'||*{S8}_S8_'vendor'||U64'private3'||U64'private4'||U64'private5'||S32'private6'||U32'_pad0'||*{U64(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->U64}_U64(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->U64_'resource_alloc'||S32'byte_order'||S32'bitmap_unit'||S32'bitmap_pad'||S32'bitmap_bit_order'||S32'nformats'||U32'_pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'_pad0'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'_pad0'|]#_'pixmap_format'||S32'private8'||S32'release'||*{SYM#tag-_XPrivate#}_SYM#tag-_XPrivate#_'private9'||*{SYM#tag-_XPrivate#}_SYM#tag-_XPrivate#_'private10'||S32'qlen'||U32'_pad2'||U64'last_request_read'||U64'request'||*{S8}_S8_'private11'||*{S8}_S8_'private12'||*{S8}_S8_'private13'||*{S8}_S8_'private14'||U32'max_request_size'||U32'_pad3'||*{SYM#tag-_XrmHashBucketRec#}_SYM#tag-_XrmHashBucketRec#_'db'||*{S32(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->S32}_S32(*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_)->S32_'private15'||*{S8}_S8_'display_name'||S32'default_screen'||S32'nscreens'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visuals'|]#}_SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visuals'|]#_'depths'||S32'root_depth'||U32'_pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'root_visual'||*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visuals'|]#}_SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visuals'|]#_'depths'||S32'root_depth'||U32'_pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'root_visual'||*{SYM#tag-_XGC#}_SYM#tag-_XGC#_'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#_'screens'||U64'motion_buffer'||U64'private16'||S32'min_keycode'||S32'max_keycode'||*{S8}_S8_'private17'||*{S8}_S8_'private18'||S32'private19'||U32'_pad4'||*{S8}_S8_'xdefaults'|]
// file /usr/include/X11/Xlib.h line 493
struct anonymous_2;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'_pad0'|]
// file /usr/include/X11/Xlib.h line 280
struct anonymous;

// tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]
// file /usr/include/X11/Xlib.h line 227
struct anonymous_10;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_8;

// tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}_SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}_SYM#tag-_XExtData#_'ext_data'||U64'visualid'||S32'class'||U32'_pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#_'visuals'|]
// file /usr/include/X11/Xlib.h line 243
struct anonymous_0;

// tag-#anon#ST[S32'type'||U32'_pad0'||*{SYM#tag-_XDisplay#}_SYM#tag-_XDisplay#_'display'||U64'resourceid'||U64'serial'||U8'error_code'||U8'request_code'||U8'minor_code'||U40'_pad1'|]
// file /usr/include/X11/Xlib.h line 924
struct anonymous_12;

// tag-#anon#ST[U32'sequence'|]
// file /usr/include/xcb/xcb.h line 187
struct anonymous_3;

// tag-#anon#ST[U8'response_type'||U8'error_code'||U16'sequence'||U32'resource_id'||U16'minor_code'||U8'major_code'||U8'pad0'||ARR5{U32}_U32_'pad'||U32'full_sequence'|]
// file /usr/include/xcb/xcb.h line 170
struct anonymous_4;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_5;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_6;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_7;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_XDisplay
// file /usr/include/X11/Xlib.h line 255
struct _XDisplay;

// tag-_XExtData
// file /usr/include/X11/Xlib.h line 148
struct _XExtData;

// tag-_XGC
// file /usr/include/X11/Xlib.h line 214
struct _XGC;

// tag-_XPrivate
// file /usr/include/X11/Xlib.h line 490
struct _XPrivate;

// tag-_XrmHashBucketRec
// file /usr/include/X11/Xlib.h line 491
struct _XrmHashBucketRec;

// tag-__GLXFBConfigRec
// file /usr/include/GL/glx.h line 169
struct __GLXFBConfigRec;

// tag-__GLXcontextRec
// file /usr/include/GL/glx.h line 165
struct __GLXcontextRec;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-api_object
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/api_object.h line 33
struct api_object;

// tag-enum_map
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 260
struct enum_map;

// tag-gbm_bo
// file /usr/include/EGL/eglplatform.h line 95
struct gbm_bo;

// tag-gbm_device
// file /usr/include/gbm.h line 46
struct gbm_device;

// tag-gbm_surface
// file /usr/include/gbm.h line 48
struct gbm_surface;

// tag-glx_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.h line 40
struct glx_config;

// tag-glx_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.h line 38
struct glx_context;

// tag-glx_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.h line 43
struct glx_display;

// tag-glx_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.h line 36
struct glx_platform;

// tag-glx_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 37
struct glx_window;

// tag-impl_thrd_param
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 60
struct impl_thrd_param;

// tag-linux_dl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_dl.h line 34
struct linux_dl;

// tag-linux_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_platform.h line 31
struct linux_platform;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-options
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 238
struct options;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-udev
// file /usr/include/libudev.h line 36
struct udev;

// tag-udev_device
// file /usr/include/libudev.h line 76
struct udev_device;

// tag-udev_enumerate
// file /usr/include/libudev.h line 140
struct udev_enumerate;

// tag-udev_list_entry
// file /usr/include/libudev.h line 54
struct udev_list_entry;

// tag-waffle_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 40
struct waffle_config;

// tag-waffle_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 41
struct waffle_context;

// tag-waffle_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 39
struct waffle_display;

// tag-waffle_enum
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 87
enum waffle_enum { WAFFLE_DONT_CARE=-1, WAFFLE_NONE=0, WAFFLE_PLATFORM=16, WAFFLE_PLATFORM_ANDROID=17, WAFFLE_PLATFORM_CGL=18, WAFFLE_PLATFORM_GLX=19, WAFFLE_PLATFORM_WAYLAND=20, WAFFLE_PLATFORM_X11_EGL=21, WAFFLE_PLATFORM_GBM=22, WAFFLE_PLATFORM_WGL=23, WAFFLE_CONTEXT_API=522, WAFFLE_CONTEXT_OPENGL=523, WAFFLE_CONTEXT_OPENGL_ES1=524, WAFFLE_CONTEXT_OPENGL_ES2=525, WAFFLE_CONTEXT_OPENGL_ES3=532, WAFFLE_CONTEXT_MAJOR_VERSION=526, WAFFLE_CONTEXT_MINOR_VERSION=527, WAFFLE_CONTEXT_PROFILE=528, WAFFLE_CONTEXT_CORE_PROFILE=529, WAFFLE_CONTEXT_COMPATIBILITY_PROFILE=530, WAFFLE_CONTEXT_FORWARD_COMPATIBLE=533, WAFFLE_CONTEXT_DEBUG=534, WAFFLE_RED_SIZE=513, WAFFLE_GREEN_SIZE=514, WAFFLE_BLUE_SIZE=515, WAFFLE_ALPHA_SIZE=516, WAFFLE_DEPTH_SIZE=517, WAFFLE_STENCIL_SIZE=518, WAFFLE_SAMPLE_BUFFERS=519, WAFFLE_SAMPLES=520, WAFFLE_DOUBLE_BUFFERED=521, WAFFLE_ACCUM_BUFFER=531, WAFFLE_DL_OPENGL=769, WAFFLE_DL_OPENGL_ES1=770, WAFFLE_DL_OPENGL_ES2=771, WAFFLE_DL_OPENGL_ES3=772 };

// tag-waffle_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 53
enum waffle_error { WAFFLE_NO_ERROR=0, WAFFLE_ERROR_FATAL=1, WAFFLE_ERROR_UNKNOWN=2, WAFFLE_ERROR_INTERNAL=3, WAFFLE_ERROR_BAD_ALLOC=4, WAFFLE_ERROR_NOT_INITIALIZED=5, WAFFLE_ERROR_ALREADY_INITIALIZED=6, WAFFLE_ERROR_BAD_ATTRIBUTE=8, WAFFLE_ERROR_BAD_PARAMETER=16, WAFFLE_ERROR_BAD_DISPLAY_MATCH=17, WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM=18, WAFFLE_ERROR_BUILT_WITHOUT_SUPPORT=19 };

// tag-waffle_error_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 68
struct waffle_error_info;

// tag-waffle_gbm_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 264
struct waffle_gbm_config;

// tag-waffle_gbm_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 265
struct waffle_gbm_context;

// tag-waffle_gbm_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 266
struct waffle_gbm_display;

// tag-waffle_gbm_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 267
struct waffle_gbm_window;

// tag-waffle_glx_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 268
struct waffle_glx_config;

// tag-waffle_glx_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 269
struct waffle_glx_context;

// tag-waffle_glx_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 270
struct waffle_glx_display;

// tag-waffle_glx_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 271
struct waffle_glx_window;

// tag-waffle_native_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 45
union waffle_native_config;

// tag-waffle_native_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 46
union waffle_native_context;

// tag-waffle_native_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 44
union waffle_native_display;

// tag-waffle_native_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 47
union waffle_native_window;

// tag-waffle_wayland_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 272
struct waffle_wayland_config;

// tag-waffle_wayland_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 273
struct waffle_wayland_context;

// tag-waffle_wayland_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 274
struct waffle_wayland_display;

// tag-waffle_wayland_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 275
struct waffle_wayland_window;

// tag-waffle_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 42
struct waffle_window;

// tag-waffle_x11_egl_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 276
struct waffle_x11_egl_config;

// tag-waffle_x11_egl_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 277
struct waffle_x11_egl_context;

// tag-waffle_x11_egl_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 278
struct waffle_x11_egl_display;

// tag-waffle_x11_egl_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 279
struct waffle_x11_egl_window;

// tag-wayland_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.h line 43
struct wayland_display;

// tag-wayland_platform_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.h line 40
struct wayland_platform;

// tag-wayland_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 39
struct wayland_window;

// tag-wcore_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 39
struct wcore_config;

// tag-wcore_config_attrs
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.h line 32
struct wcore_config_attrs;

// tag-wcore_config_vtbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 85
struct wcore_config_vtbl;

// tag-wcore_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 37
struct wcore_context;

// tag-wcore_context_vtbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 99
struct wcore_context_vtbl;

// tag-wcore_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_display.h line 34
struct wcore_display;

// tag-wcore_display_vtbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 67
struct wcore_display_vtbl;

// tag-wcore_error_tinfo
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 33
struct wcore_error_tinfo;

// tag-wcore_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/api_priv.h line 51
struct wcore_platform;

// tag-wcore_platform_vtbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 40
struct wcore_platform_vtbl;

// tag-wcore_tinfo
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.h line 31
struct wcore_tinfo;

// tag-wcore_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 38
struct wcore_window;

// tag-wcore_window_vtbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 113
struct wcore_window_vtbl;

// tag-wegl_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 40
struct wegl_config;

// tag-wegl_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.h line 38
struct wegl_context;

// tag-wegl_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.h line 37
struct wegl_display;

// tag-wegl_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 33
struct wegl_platform_2;

// tag-wegl_platform_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 33
struct wegl_platform;

// tag-wegl_platform_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 33
struct wegl_platform_0;

// tag-wegl_platform_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 33
struct wegl_platform_1;

// tag-wegl_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_window.h line 38
struct wegl_window;

// tag-wflinfo_config_attrs
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 657
struct wflinfo_config_attrs;

// tag-wgbm_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.h line 38
struct wgbm_display;

// tag-wgbm_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.h line 39
struct wgbm_platform_0;

// tag-wgbm_platform_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.h line 39
struct wgbm_platform;

// tag-wgbm_platform_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.h line 39
struct wgbm_platform_1;

// tag-wgbm_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_window.h line 35
struct wgbm_window;

// tag-wl_compositor
// file /usr/include/wayland-client-protocol.h line 44
struct wl_compositor;

// tag-wl_display
// file /usr/include/wayland-client-core.h line 109
struct wl_display;

// tag-wl_egl_window
// file /usr/include/EGL/eglplatform.h line 90
struct wl_egl_window;

// tag-wl_interface
// file /usr/include/wayland-util.h line 67
struct wl_interface;

// tag-wl_message
// file /usr/include/wayland-util.h line 64
struct wl_message;

// tag-wl_proxy
// file /usr/include/wayland-client-core.h line 52
struct wl_proxy;

// tag-wl_registry
// file /usr/include/wayland-client-protocol.h line 54
struct wl_registry;

// tag-wl_registry_listener
// file /usr/include/wayland-client-protocol.h line 217
struct wl_registry_listener;

// tag-wl_shell
// file /usr/include/wayland-client-protocol.h line 56
struct wl_shell;

// tag-wl_shell_surface
// file /usr/include/wayland-client-protocol.h line 57
struct wl_shell_surface;

// tag-wl_shell_surface_listener
// file /usr/include/wayland-client-protocol.h line 1190
struct wl_shell_surface_listener;

// tag-wl_surface
// file /usr/include/wayland-client-protocol.h line 62
struct wl_surface;

// tag-x11_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_display.h line 32
struct x11_display;

// tag-x11_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_window.h line 34
struct x11_window;

// tag-xcb_connection_t
// file /usr/include/xcb/xcb.h line 104
struct xcb_connection_t;

// tag-xcb_depth_iterator_t
// file /usr/include/xcb/xproto.h line 313
struct xcb_depth_iterator_t;

// tag-xcb_depth_t
// file /usr/include/xcb/xproto.h line 303
struct xcb_depth_t;

// tag-xcb_screen_iterator_t
// file /usr/include/xcb/xproto.h line 379
struct xcb_screen_iterator_t;

// tag-xcb_screen_t
// file /usr/include/xcb/xproto.h line 357
struct xcb_screen_t;

// tag-xcb_setup_t
// file /usr/include/xcb/xproto.h line 453
struct xcb_setup_t;

// tag-xcb_visualtype_iterator_t
// file /usr/include/xcb/xproto.h line 294
struct xcb_visualtype_iterator_t;

// tag-xcb_visualtype_t
// file /usr/include/xcb/xproto.h line 280
struct xcb_visualtype_t;

// tag-xegl_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.h line 39
struct xegl_display;

// tag-xegl_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.h line 39
struct xegl_platform;

// tag-xegl_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_window.h line 39
struct xegl_window;

// tag-xtime
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 122
struct xtime;

#ifndef NULL
#define NULL ((void*)0)
#endif

// XCloseDisplay
// file /usr/include/X11/Xlib.h line 2160
extern signed int XCloseDisplay(struct _XDisplay *);
// XFree
// file /usr/include/X11/Xlib.h line 2516
extern signed int XFree(void *);
// XGetXCBConnection
// file /usr/include/X11/Xlib-xcb.h line 13
struct xcb_connection_t * XGetXCBConnection(struct _XDisplay *);
// XOpenDisplay
// file /usr/include/X11/Xlib.h line 1483
extern struct _XDisplay * XOpenDisplay(const char *);
// XSetErrorHandler
// file /usr/include/X11/Xlib.h line 1848
extern signed int (*XSetErrorHandler(signed int (*)(struct _XDisplay *, struct anonymous_12 *)))(struct _XDisplay *, struct anonymous_12 *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _wcore_error_disable
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.c line 78
void _wcore_error_disable(void);
// _wcore_error_enable
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.c line 72
void _wcore_error_enable(void);
// _wcore_error_internal
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 87
void _wcore_error_internal(const char *file, signed int line, const char *format, ...);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// api_check_entry
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/api_priv.c line 38
_Bool api_check_entry(struct api_object **obj_list, signed int length);
// bind_api
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.c line 38
static _Bool bind_api(struct wegl_platform_2 *plat, signed int waffle_context_api);
// call_once
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 147
void call_once(signed int *flag, void (*func)(void));

//

// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// check_context_attrs
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.c line 41
static _Bool check_context_attrs(struct wegl_display *dpy, struct wcore_config_attrs *attrs);
// check_final
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 456
static _Bool check_final(struct wcore_config_attrs *attrs);
// check_keys
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 42
static _Bool check_keys(const signed int *attrib_list);
// choose_real_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.c line 130
static void * choose_real_config(struct wegl_display *dpy, struct wcore_config_attrs *attrs);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// cnd_broadcast
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 83
signed int cnd_broadcast(union anonymous_6 *cond);
// cnd_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 91
void cnd_destroy(union anonymous_6 *cond);
// cnd_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 98
signed int cnd_init(union anonymous_6 *cond);
// cnd_signal
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 106
signed int cnd_signal(union anonymous_6 *cond);
// cnd_timedwait
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 114
signed int cnd_timedwait(union anonymous_6 *cond, union anonymous_7 *mtx, const struct xtime *xt);
// cnd_wait
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 126
signed int cnd_wait(union anonymous_6 *cond, union anonymous_7 *mtx);
// create_real_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.c line 64
static void * create_real_context(struct wegl_config *config, void *share_ctx);
// dlclose
// file /usr/include/dlfcn.h line 60
extern signed int dlclose(void *);
// dlerror
// file /usr/include/dlfcn.h line 82
extern char * dlerror(void);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// enum_map_to_str
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 306
static const char * enum_map_to_str(struct enum_map *self, signed int val);
// enum_map_translate_str
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 290
static _Bool enum_map_translate_str(struct enum_map *self, const char *s, signed int *result);
// error_get_gl_symbol
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 185
static void error_get_gl_symbol(const char *name);
// error_printf
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 135
static void error_printf(const char *module, const char *fmt, ...);
// error_waffle
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 173
static void error_waffle(void);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// get_extensions
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.c line 37
static _Bool get_extensions(struct wegl_display *dpy);
// get_xcb_screen
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_window.c line 57
static struct xcb_screen_t * get_xcb_screen(const struct xcb_setup_t *setup, signed int screen);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// glGetError_object
//
unsigned int glGetError_object(void);
// glGetIntegerv_object
//
void glGetIntegerv_object(unsigned int, unsigned int *);
// glGetString_object
//
const unsigned char * glGetString_object(unsigned int);
// glGetStringi_object
//
const unsigned char * glGetStringi_object(unsigned int, unsigned int);
// gl_get_profile
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 855
static enum waffle_enum gl_get_profile(void);
// gl_get_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 764
static signed int gl_get_version(void);
// gl_has_extension
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 834
static _Bool gl_has_extension(const char *name);
// gl_has_extension_GetString
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 783
static _Bool gl_has_extension_GetString(const char *name);
// gl_has_extension_GetStringi
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 810
static _Bool gl_has_extension_GetStringi(const char *name);
// glx_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.h line 48
static inline struct glx_config * glx_config(struct wcore_config *wcore_self);
// glx_config_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.h line 48
static inline struct glx_config * glx_config_link1(struct wcore_config *wcore_self_link1);
// glx_config_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.h line 48
static inline struct glx_config * glx_config_link2(struct wcore_config *wcore_self_link2);
// glx_config_check_context_attrs
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.c line 54
static _Bool glx_config_check_context_attrs(struct glx_display *dpy, struct wcore_config_attrs *attrs);
// glx_config_choose
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.c line 167
struct wcore_config * glx_config_choose(struct wcore_platform *wc_plat, struct wcore_display *wc_dpy, struct wcore_config_attrs *attrs);
// glx_config_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.c line 40
_Bool glx_config_destroy(struct wcore_config *wc_self);
// glx_config_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.c line 275
union waffle_native_config * glx_config_get_native(struct wcore_config *wc_self);
// glx_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.h line 43
static inline struct glx_context * glx_context(struct wcore_context *wcore_self);
// glx_context_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.h line 43
static inline struct glx_context * glx_context_link1(struct wcore_context *wcore_self_link1);
// glx_context_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.c line 203
struct wcore_context * glx_context_create(struct wcore_platform *wc_plat, struct wcore_config *wc_config, struct wcore_context *wc_share_ctx);
// glx_context_create_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.c line 156
static struct __GLXcontextRec * glx_context_create_native(struct glx_config *config, struct glx_context *share_ctx);
// glx_context_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.c line 44
_Bool glx_context_destroy(struct wcore_context *wc_self);
// glx_context_fill_attrib_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.c line 71
static _Bool glx_context_fill_attrib_list(struct glx_config *config, signed int *attrib_list);
// glx_context_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.c line 232
union waffle_native_context * glx_context_get_native(struct wcore_context *wc_self);
// glx_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.h line 53
static inline struct glx_display * glx_display(struct wcore_display *wcore_self);
// glx_display_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.h line 53
static inline struct glx_display * glx_display_link1(struct wcore_display *wcore_self_link1);
// glx_display_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.h line 53
static inline struct glx_display * glx_display_link2(struct wcore_display *wcore_self_link2);
// glx_display_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.h line 53
static inline struct glx_display * glx_display_link3(struct wcore_display *wcore_self_link3);
// glx_display_link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.h line 53
static inline struct glx_display * glx_display_link4(struct wcore_display *wcore_self_link4);
// glx_display_connect
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.c line 86
struct wcore_display * glx_display_connect(struct wcore_platform *wc_plat, const char *name);
// glx_display_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.c line 37
_Bool glx_display_destroy(struct wcore_display *wc_self);
// glx_display_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.c line 145
union waffle_native_display * glx_display_get_native(struct wcore_display *wc_self);
// glx_display_set_extensions
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.c line 52
static _Bool glx_display_set_extensions(struct glx_display *self);
// glx_display_supports_context_api
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.c line 116
_Bool glx_display_supports_context_api(struct wcore_display *wc_self, signed int context_api);
// glx_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.h line 64
static inline struct glx_platform * glx_platform(struct wcore_platform *wcore_self);
// glx_platform_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.h line 64
static inline struct glx_platform * glx_platform_link1(struct wcore_platform *wcore_self_link1);
// glx_platform_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.h line 64
static inline struct glx_platform * glx_platform_link2(struct wcore_platform *wcore_self_link2);
// glx_platform_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.h line 64
static inline struct glx_platform * glx_platform_link3(struct wcore_platform *wcore_self_link3);
// glx_platform_link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.h line 64
static inline struct glx_platform * glx_platform_link4(struct wcore_platform *wcore_self_link4);
// glx_platform_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_init.c line 33
struct wcore_platform * glx_platform_create(void);
// glx_platform_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.c line 45
static _Bool glx_platform_destroy(struct wcore_platform *wc_self);
// glx_platform_dl_can_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.c line 160
static _Bool glx_platform_dl_can_open(struct wcore_platform *wc_self, signed int waffle_dl);
// glx_platform_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.c line 168
static void * glx_platform_dl_sym(struct wcore_platform *wc_self, signed int waffle_dl, const char *name);
// glx_platform_get_proc_address
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.c line 152
static void * glx_platform_get_proc_address(struct wcore_platform *wc_self, const char *name);
// glx_platform_make_current
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.c line 132
static _Bool glx_platform_make_current(struct wcore_platform *wc_self, struct wcore_display *wc_dpy, struct wcore_window *wc_window, struct wcore_context *wc_ctx);
// glx_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 42
static inline struct glx_window * glx_window(struct wcore_window *wcore_self);
// glx_window_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 42
static inline struct glx_window * glx_window_link1(struct wcore_window *wcore_self_link1);
// glx_window_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 47
struct wcore_window * glx_window_create(struct wcore_platform *wc_plat, struct wcore_config *wc_config, signed int width, signed int height);
// glx_window_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 53
_Bool glx_window_destroy(struct wcore_window *wc_self);
// glx_window_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 66
union waffle_native_window * glx_window_get_native(struct wcore_window *wc_self);
// glx_window_resize
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 59
_Bool glx_window_resize(struct wcore_window *wc_self, signed int width, signed int height);
// glx_window_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 56
_Bool glx_window_show(struct wcore_window *wc_self);
// glx_window_swap_buffers
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 63
_Bool glx_window_swap_buffers(struct wcore_window *wc_self);
// impl_thrd_routine
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 65
static void * impl_thrd_routine(void *p);
// linux_dl_close
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_dl.c line 103
_Bool linux_dl_close(struct linux_dl *self);
// linux_dl_get_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_dl.c line 47
static const char * linux_dl_get_name(signed int waffle_dl);
// linux_dl_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_dl.c line 78
struct linux_dl * linux_dl_open(signed int waffle_dl);
// linux_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_dl.c line 124
void * linux_dl_sym(struct linux_dl *self, const char *symbol);
// linux_platform_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_platform.h line 34
struct linux_platform * linux_platform_create(void);
// linux_platform_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_platform.h line 37
_Bool linux_platform_destroy(struct linux_platform *self);
// linux_platform_dl_can_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_platform.h line 41
_Bool linux_platform_dl_can_open(struct linux_platform *self, signed int waffle_dl);
// linux_platform_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_platform.h line 46
void * linux_platform_dl_sym(struct linux_platform *self, signed int waffle_dl, const char *name);
// linux_platform_get_dl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_platform.c line 64
static struct linux_dl * linux_platform_get_dl(struct linux_platform *self, signed int waffle_dl);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mtx_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 136
void mtx_destroy(union anonymous_7 *mtx);
// mtx_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 143
signed int mtx_init(union anonymous_7 *mtx, signed int type);
// mtx_lock
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 158
signed int mtx_lock(union anonymous_7 *mtx);
// mtx_timedlock
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 174
signed int mtx_timedlock(union anonymous_7 *mtx, const struct xtime *xt);
// mtx_trylock
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 203
signed int mtx_trylock(union anonymous_7 *mtx);
// mtx_unlock
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 161
signed int mtx_unlock(union anonymous_7 *mtx);
// nanosleep
// file /usr/include/time.h line 334
extern signed int nanosleep(struct timespec *, struct timespec *);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// parse_args
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 320
static _Bool parse_args(signed int argc, char **argv, struct options *opts);
// parse_bool
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 80
static _Bool parse_bool(const signed int *attrib_list, signed int attrib_name, _Bool *value, _Bool default_value);
// parse_context_api
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 106
static _Bool parse_context_api(struct wcore_config_attrs *attrs, const signed int *attrib_list);
// parse_context_forward_compatible
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 307
static _Bool parse_context_forward_compatible(struct wcore_config_attrs *attrs, const signed int *attrib_list);
// parse_context_profile
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 260
static _Bool parse_context_profile(struct wcore_config_attrs *attrs, const signed int *attrib_list);
// parse_context_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 163
static _Bool parse_context_version(struct wcore_config_attrs *attrs, const signed int *attrib_list);
// parse_misc
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 365
static _Bool parse_misc(struct wcore_config_attrs *attrs, const signed int *attrib_list);
// parse_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 441
static signed int parse_version(const char *version);
// print_context_flags
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 491
static void print_context_flags(void);
// print_extensions
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 462
static void print_extensions(_Bool use_stringi);
// print_wflinfo
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 533
static _Bool print_wflinfo(struct options *opts);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous_6 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous_6 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_6 *, const union anonymous_5 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_6 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous_6 *, union anonymous_7 *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_6 *, union anonymous_7 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_equal
// file /usr/include/pthread.h line 1155
static inline signed int pthread_equal(unsigned long int __thread1, unsigned long int __thread2);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_getspecific
// file /usr/include/pthread.h line 1121
extern void * pthread_getspecific(unsigned int);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_key_create
// file /usr/include/pthread.h line 1113
extern signed int pthread_key_create(unsigned int *, void (*)(void *));
// pthread_key_delete
// file /usr/include/pthread.h line 1118
extern signed int pthread_key_delete(unsigned int);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_7 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_7 *, const union anonymous_5 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_7 *);
// pthread_mutex_timedlock
// file /usr/include/pthread.h line 769
extern signed int pthread_mutex_timedlock(union anonymous_7 *, struct timespec *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_trylock(union anonymous_7 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_7 *);
// pthread_mutexattr_destroy
// file /usr/include/pthread.h line 812
extern signed int pthread_mutexattr_destroy(union anonymous_5 *);
// pthread_mutexattr_init
// file /usr/include/pthread.h line 808
extern signed int pthread_mutexattr_init(union anonymous_5 *);
// pthread_mutexattr_settype
// file /usr/include/pthread.h line 835
extern signed int pthread_mutexattr_settype(union anonymous_5 *, signed int);
// pthread_once
// file /usr/include/pthread.h line 496
extern signed int pthread_once(signed int *, void (*)(void));
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pthread_setspecific
// file /usr/include/pthread.h line 1124
extern signed int pthread_setspecific(unsigned int, const void *);
// registry_listener_global
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 61
static void registry_listener_global(void *data, struct wl_registry *registry, unsigned int name, const char *interface, unsigned int version);
// registry_listener_global_remove
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 80
static void registry_listener_global_remove(void *data, struct wl_registry *registry, unsigned int name);
// sched_yield
// file /usr/include/sched.h line 65
extern signed int sched_yield(void);
// set_context_profile_default
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 235
static _Bool set_context_profile_default(struct wcore_config_attrs *attrs);
// set_context_version_default
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 136
static _Bool set_context_version_default(struct wcore_config_attrs *attrs);
// set_misc_defaults
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 339
static _Bool set_misc_defaults(struct wcore_config_attrs *attrs);
// setenv
// file /usr/include/stdlib.h line 584
extern signed int setenv(const char *, const char *, signed int);
// shell_surface_listener_configure
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.c line 76
static void shell_surface_listener_configure(void *data, struct wl_shell_surface *shell_surface, unsigned int edges, signed int width, signed int height);
// shell_surface_listener_ping
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.c line 68
static void shell_surface_listener_ping(void *data, struct wl_shell_surface *shell_surface, unsigned int serial);
// shell_surface_listener_popup_done
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.c line 85
static void shell_surface_listener_popup_done(void *data, struct wl_shell_surface *shell_surface);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// strerror_r
// file /usr/include/string.h line 426
extern signed int strerror_r(signed int, char *, unsigned long int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strneq
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 121
static _Bool strneq(const char *a, const char *b, unsigned long int n);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// thrd_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 220
signed int thrd_create(unsigned long int *thr, signed int (*func)(void *), void *arg);

//

// thrd_current
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 236
unsigned long int thrd_current(void);
// thrd_detach
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 242
signed int thrd_detach(unsigned long int thr);
// thrd_equal
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 248
signed int thrd_equal(unsigned long int thr0, unsigned long int thr1);
// thrd_exit
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 254
void thrd_exit(signed int res);
// thrd_join
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 260
signed int thrd_join(unsigned long int thr, signed int *res);
// thrd_sleep
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 271
void thrd_sleep(const struct xtime *xt);
// thrd_yield
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 281
void thrd_yield(void);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tss_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 172
signed int tss_create(unsigned int *key, void (*dtor)(void *));
// tss_create::dtor_object
//
void dtor_object(void *);
// tss_delete
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 296
void tss_delete(unsigned int key);
// tss_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 302
void * tss_get(unsigned int key);
// tss_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 175
signed int tss_set(unsigned int key, void *val);
// udev_device_get_devnode
// file /usr/include/libudev.h line 96
const char * udev_device_get_devnode(struct udev_device *);
// udev_device_new_from_syspath
// file /usr/include/libudev.h line 80
struct udev_device * udev_device_new_from_syspath(struct udev *, const char *);
// udev_device_unref
// file /usr/include/libudev.h line 78
struct udev_device * udev_device_unref(struct udev_device *);
// udev_enumerate_add_match_subsystem
// file /usr/include/libudev.h line 146
signed int udev_enumerate_add_match_subsystem(struct udev_enumerate *, const char *);
// udev_enumerate_add_match_sysname
// file /usr/include/libudev.h line 151
signed int udev_enumerate_add_match_sysname(struct udev_enumerate *, const char *);
// udev_enumerate_get_list_entry
// file /usr/include/libudev.h line 160
struct udev_list_entry * udev_enumerate_get_list_entry(struct udev_enumerate *);
// udev_enumerate_new
// file /usr/include/libudev.h line 144
struct udev_enumerate * udev_enumerate_new(struct udev *);
// udev_enumerate_scan_devices
// file /usr/include/libudev.h line 157
signed int udev_enumerate_scan_devices(struct udev_enumerate *);
// udev_enumerate_unref
// file /usr/include/libudev.h line 142
struct udev_enumerate * udev_enumerate_unref(struct udev_enumerate *);
// udev_list_entry_get_name
// file /usr/include/libudev.h line 57
const char * udev_list_entry_get_name(struct udev_list_entry *);
// udev_list_entry_get_next
// file /usr/include/libudev.h line 55
struct udev_list_entry * udev_list_entry_get_next(struct udev_list_entry *);
// udev_new
// file /usr/include/libudev.h line 39
struct udev * udev_new(void);
// udev_unref
// file /usr/include/libudev.h line 38
struct udev * udev_unref(struct udev *);
// unsetenv
// file /usr/include/stdlib.h line 588
extern signed int unsetenv(const char *);
// usage_error_printf
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 156
static void usage_error_printf(const char *fmt, ...);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// waffle_attrib_list_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_attrib_list.c line 40
_Bool waffle_attrib_list_get(const signed int *attrib_list, signed int key, signed int *value);
// waffle_attrib_list_get_with_default
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_attrib_list.c line 50
_Bool waffle_attrib_list_get_with_default(const signed int *attrib_list, signed int key, signed int *value, signed int default_value);
// waffle_attrib_list_length
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_attrib_list.c line 32
signed int waffle_attrib_list_length(const signed int *attrib_list);
// waffle_attrib_list_update
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_attrib_list.c line 62
_Bool waffle_attrib_list_update(signed int *attrib_list, signed int key, signed int value);
// waffle_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 49
static inline struct waffle_config * waffle_config(struct wcore_config *cfg);
// waffle_config_choose
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 197
struct waffle_config * waffle_config_choose(struct waffle_display *dpy, const signed int *attrib_list);
// waffle_config_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 201
_Bool waffle_config_destroy(struct waffle_config *self);
// waffle_config_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_config.c line 78
union waffle_native_config * waffle_config_get_native(struct waffle_config *self);
// waffle_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 47
static inline struct waffle_context * waffle_context(struct wcore_context *ctx);
// waffle_context_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 211
struct waffle_context * waffle_context_create(struct waffle_config *config, struct waffle_context *shared_ctx);
// waffle_context_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 215
_Bool waffle_context_destroy(struct waffle_context *self);
// waffle_context_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_context.c line 76
union waffle_native_context * waffle_context_get_native(struct waffle_context *self);
// waffle_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_display.h line 44
static inline struct waffle_display * waffle_display(struct wcore_display *dpy);
// waffle_display_connect
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 180
struct waffle_display * waffle_display_connect(const char *name);
// waffle_display_disconnect
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 183
_Bool waffle_display_disconnect(struct waffle_display *self);
// waffle_display_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_display.c line 94
union waffle_native_display * waffle_display_get_native(struct waffle_display *self);
// waffle_display_supports_context_api
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 186
_Bool waffle_display_supports_context_api(struct waffle_display *self, signed int context_api);
// waffle_dl_can_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_dl.c line 47
_Bool waffle_dl_can_open(signed int dl);
// waffle_dl_check_enum
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_dl.c line 32
static _Bool waffle_dl_check_enum(signed int dl);
// waffle_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 258
void * waffle_dl_sym(signed int dl, const char *name);
// waffle_enum_to_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 156
const char * waffle_enum_to_string(signed int e);
// waffle_error_get_code
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_error.c line 33
enum waffle_error waffle_error_get_code(void);
// waffle_error_get_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 78
struct waffle_error_info * waffle_error_get_info(void);
// waffle_error_to_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 81
const char * waffle_error_to_string(enum waffle_error e);
// waffle_get_proc_address
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 169
void * waffle_get_proc_address(const char *name);
// waffle_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 161
_Bool waffle_init(const signed int *attrib_list);
// waffle_init_create_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_init.c line 136
static struct wcore_platform * waffle_init_create_platform(signed int waffle_platform);
// waffle_init_parse_attrib_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_init.c line 40
static _Bool waffle_init_parse_attrib_list(const signed int *attrib_list, signed int *platform);
// waffle_is_extension_in_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_gl_misc.c line 39
_Bool waffle_is_extension_in_string(const char * restrict extension_string, const char * restrict extension_name);
// waffle_make_current
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 164
_Bool waffle_make_current(struct waffle_display *dpy, struct waffle_window *window, struct waffle_context *ctx);
// waffle_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 40
static inline struct waffle_window * waffle_window(struct wcore_window *win);
// waffle_window_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 225
struct waffle_window * waffle_window_create(struct waffle_config *config, signed int width, signed int height);
// waffle_window_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 231
_Bool waffle_window_destroy(struct waffle_window *self);
// waffle_window_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_window.c line 130
union waffle_native_window * waffle_window_get_native(struct waffle_window *self);
// waffle_window_resize
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_window.c line 91
_Bool waffle_window_resize(struct waffle_window *self, signed int width, signed int height);
// waffle_window_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_window.c line 76
_Bool waffle_window_show(struct waffle_window *self);
// waffle_window_swap_buffers
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_window.c line 115
_Bool waffle_window_swap_buffers(struct waffle_window *self);
// wayland_config_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.c line 113
static union waffle_native_config * wayland_config_get_native(struct wcore_config *wc_config);
// wayland_context_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.c line 130
static union waffle_native_context * wayland_context_get_native(struct wcore_context *wc_ctx);
// wayland_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.h line 53
static inline struct wayland_display * wayland_display(struct wcore_display *wc_self);
// wayland_display_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.h line 53
static inline struct wayland_display * wayland_display_link1(struct wcore_display *wc_self_link1);
// wayland_display_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.h line 53
static inline struct wayland_display * wayland_display_link2(struct wcore_display *wc_self_link2);
// wayland_display_connect
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 92
struct wcore_display * wayland_display_connect(struct wcore_platform *wc_plat, const char *name);
// wayland_display_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 43
_Bool wayland_display_destroy(struct wcore_display *wc_self);
// wayland_display_fill_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 155
void wayland_display_fill_native(struct wayland_display *self, struct waffle_wayland_display *n_dpy);
// wayland_display_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 165
union waffle_native_display * wayland_display_get_native(struct wcore_display *wc_self);
// wayland_display_sync
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 180
_Bool wayland_display_sync(struct wayland_display *dpy);
// wayland_dl_can_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.c line 96
static _Bool wayland_dl_can_open(struct wcore_platform *wc_self, signed int waffle_dl);
// wayland_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.c line 104
static void * wayland_dl_sym(struct wcore_platform *wc_self, signed int waffle_dl, const char *name);
// wayland_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.h line 45
static inline struct wayland_platform * wayland_platform(struct wegl_platform *wegl_self);
// wayland_platform_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_init.c line 34
struct wcore_platform * wayland_platform_create(void);
// wayland_platform_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.c line 49
static _Bool wayland_platform_destroy(struct wcore_platform *wc_self);
// wayland_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 48
static inline struct wayland_window * wayland_window(struct wcore_window *wc_self);
// wayland_window_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 60
struct wcore_window * wayland_window_create(struct wcore_platform *wc_plat, struct wcore_config *wc_config, signed int width, signed int height);
// wayland_window_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 66
_Bool wayland_window_destroy(struct wcore_window *wc_self);
// wayland_window_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 79
union waffle_native_window * wayland_window_get_native(struct wcore_window *wc_self);
// wayland_window_resize
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 75
_Bool wayland_window_resize(struct wcore_window *wc_self, signed int width, signed int height);
// wayland_window_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 69
_Bool wayland_window_show(struct wcore_window *wc_self);
// wayland_window_swap_buffers
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 72
_Bool wayland_window_swap_buffers(struct wcore_window *wc_self);
// wcore_attrib_list_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_attrib_list.h line 35
_Bool wcore_attrib_list_get(const signed int *attrib_list, signed int key, signed int *value);
// wcore_attrib_list_get_with_default
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_attrib_list.h line 41
_Bool wcore_attrib_list_get_with_default(const signed int *attrib_list, signed int key, signed int *value, signed int default_value);
// wcore_attrib_list_length
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_attrib_list.h line 32
signed int wcore_attrib_list_length(const signed int *attrib_list);
// wcore_attrib_list_update
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_attrib_list.h line 48
_Bool wcore_attrib_list_update(signed int *attrib_list, signed int key, signed int value);
// wcore_calloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_util.c line 41
void * wcore_calloc(unsigned long int size);
// wcore_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 54
static inline struct wcore_config * wcore_config(struct waffle_config *cfg);
// wcore_config_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 54
static inline struct wcore_config * wcore_config_link1(struct waffle_config *cfg_link1);
// wcore_config_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 54
static inline struct wcore_config * wcore_config_link2(struct waffle_config *cfg_link2);
// wcore_config_attrs_parse
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.h line 59
_Bool wcore_config_attrs_parse(const signed int *waffle_attrib_list, struct wcore_config_attrs *attrs);
// wcore_config_attrs_version_eq
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 512
_Bool wcore_config_attrs_version_eq(struct wcore_config_attrs *attrs, signed int merged_version);
// wcore_config_attrs_version_ge
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 533
_Bool wcore_config_attrs_version_ge(struct wcore_config_attrs *attrs, signed int merged_version);
// wcore_config_attrs_version_gt
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 522
_Bool wcore_config_attrs_version_gt(struct wcore_config_attrs *attrs, signed int merged_version);
// wcore_config_attrs_version_le
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 552
_Bool wcore_config_attrs_version_le(struct wcore_config_attrs *attrs, signed int merged_version);
// wcore_config_attrs_version_lt
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 544
_Bool wcore_config_attrs_version_lt(struct wcore_config_attrs *attrs, signed int merged_version);
// wcore_config_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 59
static inline _Bool wcore_config_init(struct wcore_config *self, struct wcore_display *display, struct wcore_config_attrs *attrs);
// wcore_config_init_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 59
static inline _Bool wcore_config_init_link1(struct wcore_config *self_link1, struct wcore_display *display_link1, struct wcore_config_attrs *attrs_link1);
// wcore_config_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 74
static inline _Bool wcore_config_teardown(struct wcore_config *self);
// wcore_config_teardown_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 74
static inline _Bool wcore_config_teardown_link1(struct wcore_config *self_link1);
// wcore_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 52
static inline struct wcore_context * wcore_context(struct waffle_context *ctx);
// wcore_context_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 52
static inline struct wcore_context * wcore_context_link1(struct waffle_context *ctx_link1);
// wcore_context_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 57
static inline _Bool wcore_context_init(struct wcore_context *self, struct wcore_config *config);
// wcore_context_init_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 57
static inline _Bool wcore_context_init_link1(struct wcore_context *self_link1, struct wcore_config *config_link1);
// wcore_context_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 70
static inline _Bool wcore_context_teardown(struct wcore_context *self);
// wcore_context_teardown_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 70
static inline _Bool wcore_context_teardown_link1(struct wcore_context *self_link1);
// wcore_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_display.h line 49
static inline struct wcore_display * wcore_display(struct waffle_display *dpy);
// wcore_display_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_display.h line 49
static inline struct wcore_display * wcore_display_link1(struct waffle_display *dpy_link1);
// wcore_display_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_display.h line 49
static inline struct wcore_display * wcore_display_link2(struct waffle_display *dpy_link2);
// wcore_display_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_display.c line 33
_Bool wcore_display_init(struct wcore_display *self, struct wcore_platform *platform);
// wcore_display_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_display.c line 57
_Bool wcore_display_teardown(struct wcore_display *self);
// wcore_enum_to_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_util.h line 82
const char * wcore_enum_to_string(signed int e);
// wcore_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 49
void wcore_error(enum waffle_error error);
// wcore_error_errno
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.c line 137
void wcore_error_errno(const char *format, ...);
// wcore_error_get_code
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 80
enum waffle_error wcore_error_get_code(void);
// wcore_error_get_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 84
struct waffle_error_info * wcore_error_get_info(void);
// wcore_error_reset
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 43
void wcore_error_reset(void);
// wcore_error_tinfo_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.c line 51
struct wcore_error_tinfo * wcore_error_tinfo_create(void);
// wcore_error_tinfo_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.c line 65
_Bool wcore_error_tinfo_destroy(struct wcore_error_tinfo *self);
// wcore_errorf
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 56
void wcore_errorf(enum waffle_error error, const char *format, ...);
// wcore_malloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_util.c line 32
void * wcore_malloc(unsigned long int size);
// wcore_platform_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 144
static inline _Bool wcore_platform_init(struct wcore_platform *self);
// wcore_platform_init_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 144
static inline _Bool wcore_platform_init_link1(struct wcore_platform *self_link1);
// wcore_platform_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 151
static inline _Bool wcore_platform_teardown(struct wcore_platform *self);
// wcore_platform_teardown_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 151
static inline _Bool wcore_platform_teardown_link1(struct wcore_platform *self_link1);
// wcore_tinfo_abort_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.c line 66
static void wcore_tinfo_abort_init(void);
// wcore_tinfo_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.h line 39
struct wcore_tinfo * wcore_tinfo_get(void);
// wcore_tinfo_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.c line 97
static void wcore_tinfo_init(struct wcore_tinfo *tinfo);
// wcore_tinfo_key_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.c line 87
static void wcore_tinfo_key_create(void);
// wcore_tinfo_key_dtor
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.c line 73
static void wcore_tinfo_key_dtor(void *args);
// wcore_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 45
static inline struct wcore_window * wcore_window(struct waffle_window *win);
// wcore_window_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 45
static inline struct wcore_window * wcore_window_link1(struct waffle_window *win_link1);
// wcore_window_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 50
static inline _Bool wcore_window_init(struct wcore_window *self, struct wcore_config *config);
// wcore_window_init_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 50
static inline _Bool wcore_window_init_link1(struct wcore_window *self_link1, struct wcore_config *config_link1);
// wcore_window_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 63
static inline _Bool wcore_window_teardown(struct wcore_window *self);
// wcore_window_teardown_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 63
static inline _Bool wcore_window_teardown_link1(struct wcore_window *self_link1);
// wegl_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config(struct wcore_config *wcore_self);
// wegl_config_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config_link1(struct wcore_config *wcore_self_link1);
// wegl_config_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config_link2(struct wcore_config *wcore_self_link2);
// wegl_config_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config_link3(struct wcore_config *wcore_self_link3);
// wegl_config_link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config_link4(struct wcore_config *wcore_self_link4);
// wegl_config_link5
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config_link5(struct wcore_config *wcore_self_link5);
// wegl_config_link6
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config_link6(struct wcore_config *wcore_self_link6);
// wegl_config_choose
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.c line 210
struct wcore_config * wegl_config_choose(struct wcore_platform *wc_plat, struct wcore_display *wc_dpy, struct wcore_config_attrs *attrs);
// wegl_config_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.c line 241
_Bool wegl_config_destroy(struct wcore_config *wc_config);
// wegl_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.h line 43
static inline struct wegl_context * wegl_context(struct wcore_context *wcore_self);
// wegl_context_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.h line 43
static inline struct wegl_context * wegl_context_link1(struct wcore_context *wcore_self_link1);
// wegl_context_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.h line 43
static inline struct wegl_context * wegl_context_link2(struct wcore_context *wcore_self_link2);
// wegl_context_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.h line 43
static inline struct wegl_context * wegl_context_link3(struct wcore_context *wcore_self_link3);
// wegl_context_link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.h line 43
static inline struct wegl_context * wegl_context_link4(struct wcore_context *wcore_self_link4);
// wegl_context_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.c line 160
struct wcore_context * wegl_context_create(struct wcore_platform *wc_plat, struct wcore_config *wc_config, struct wcore_context *wc_share_ctx);
// wegl_context_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.c line 192
_Bool wegl_context_destroy(struct wcore_context *wc_ctx);
// wegl_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.h line 43
static inline struct wegl_display * wegl_display(struct wcore_display *wcore_self);
// wegl_display_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.h line 43
static inline struct wegl_display * wegl_display_link1(struct wcore_display *wcore_self_link1);
// wegl_display_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.h line 43
static inline struct wegl_display * wegl_display_link2(struct wcore_display *wcore_self_link2);
// wegl_display_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.h line 43
static inline struct wegl_display * wegl_display_link3(struct wcore_display *wcore_self_link3);
// wegl_display_link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.h line 43
static inline struct wegl_display * wegl_display_link4(struct wcore_display *wcore_self_link4);
// wegl_display_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.c line 60
_Bool wegl_display_init(struct wegl_display *dpy, struct wcore_platform *wc_plat, signed long int native_display);
// wegl_display_supports_context_api
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.c line 111
_Bool wegl_display_supports_context_api(struct wcore_display *wc_dpy, signed int waffle_context_api);
// wegl_display_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.c line 96
_Bool wegl_display_teardown(struct wegl_display *dpy);
// wegl_emit_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_util.h line 42
void wegl_emit_error(struct wegl_platform_2 *plat, const char *egl_func_call);
// wegl_get_proc_address
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_util.c line 95
void * wegl_get_proc_address(struct wcore_platform *wc_self, const char *name);

//
void return_value_object(void);
// wegl_make_current
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_util.c line 73
_Bool wegl_make_current(struct wcore_platform *wc_plat, struct wcore_display *wc_dpy, struct wcore_window *wc_window, struct wcore_context *wc_ctx);
// wegl_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform_2 * wegl_platform(struct wcore_platform *wcore_self);
// wegl_platform_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform_2 * wegl_platform_link1(struct wcore_platform *wcore_self_link1);
// wegl_platform_link10
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform_2 * wegl_platform_link10(struct wcore_platform *wcore_self_link10);
// wegl_platform_link11
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform_1 * wegl_platform_link11(struct wcore_platform *wcore_self_link11);
// wegl_platform_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform_2 * wegl_platform_link2(struct wcore_platform *wcore_self_link2);
// wegl_platform_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform_2 * wegl_platform_link3(struct wcore_platform *wcore_self_link3);
// wegl_platform_link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform_2 * wegl_platform_link4(struct wcore_platform *wcore_self_link4);
// wegl_platform_link5
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform * wegl_platform_link5(struct wcore_platform *wcore_self_link5);
// wegl_platform_link6
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform_2 * wegl_platform_link6(struct wcore_platform *wcore_self_link6);
// wegl_platform_link7
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform_2 * wegl_platform_link7(struct wcore_platform *wcore_self_link7);
// wegl_platform_link8
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform_2 * wegl_platform_link8(struct wcore_platform *wcore_self_link8);
// wegl_platform_link9
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform_0 * wegl_platform_link9(struct wcore_platform *wcore_self_link9);
// wegl_platform_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.c line 58
_Bool wegl_platform_init(struct wegl_platform_2 *self);
// wegl_platform_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.c line 39
_Bool wegl_platform_teardown(struct wegl_platform_2 *self);
// wegl_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_window.h line 43
static inline struct wegl_window * wegl_window(struct wcore_window *wcore_self);
// wegl_window_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_window.h line 43
static inline struct wegl_window * wegl_window_link1(struct wcore_window *wcore_self_link1);
// wegl_window_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_window.c line 36
_Bool wegl_window_init(struct wegl_window *window, struct wcore_config *wc_config, signed long int native_window);
// wegl_window_swap_buffers
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_window.c line 97
_Bool wegl_window_swap_buffers(struct wcore_window *wc_window);
// wegl_window_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_window.c line 78
_Bool wegl_window_teardown(struct wegl_window *window);
// wflinfo_create_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 953
static void wflinfo_create_context(struct waffle_display *dpy, struct wflinfo_config_attrs attrs, struct waffle_context **out_ctx, struct waffle_config **out_config);
// wflinfo_try_create_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 678
static _Bool wflinfo_try_create_context(struct waffle_display *dpy, struct wflinfo_config_attrs attrs, struct waffle_context **out_ctx, struct waffle_config **out_config, _Bool exit_on_fail);
// wflinfo_try_create_context_gl31
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 899
static _Bool wflinfo_try_create_context_gl31(struct waffle_display *dpy, struct wflinfo_config_attrs attrs, struct waffle_context **out_ctx, struct waffle_config **out_config, _Bool exit_if_ctx_creation_fails);
// wgbm_config_choose
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_config.c line 34
struct wcore_config * wgbm_config_choose(struct wcore_platform *wc_plat, struct wcore_display *wc_dpy, struct wcore_config_attrs *attrs);
// wgbm_config_get_gbm_format
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_config.c line 53
unsigned int wgbm_config_get_gbm_format(struct wcore_platform *wc_plat, struct wcore_display *wc_display, struct wcore_config *wc_config);
// wgbm_config_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_config.c line 73
union waffle_native_config * wgbm_config_get_native(struct wcore_config *wc_config);
// wgbm_context_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.c line 153
static union waffle_native_context * wgbm_context_get_native(struct wcore_context *wc_ctx);
// wgbm_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.h line 44
static inline struct wgbm_display * wgbm_display(struct wcore_display *wc_self);
// wgbm_display_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.h line 44
static inline struct wgbm_display * wgbm_display_link1(struct wcore_display *wc_self_link1);
// wgbm_display_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.h line 44
static inline struct wgbm_display * wgbm_display_link2(struct wcore_display *wc_self_link2);
// wgbm_display_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.h line 44
static inline struct wgbm_display * wgbm_display_link3(struct wcore_display *wc_self_link3);
// wgbm_display_connect
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.c line 119
struct wcore_display * wgbm_display_connect(struct wcore_platform *wc_plat, const char *name);
// wgbm_display_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.c line 44
_Bool wgbm_display_destroy(struct wcore_display *wc_self);
// wgbm_display_fill_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.h line 66
void wgbm_display_fill_native(struct wgbm_display *self, struct waffle_gbm_display *n_dpy);
// wgbm_display_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.c line 177
union waffle_native_display * wgbm_display_get_native(struct wcore_display *wc_self);
// wgbm_dl_can_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.c line 136
static _Bool wgbm_dl_can_open(struct wcore_platform *wc_self, signed int waffle_dl);
// wgbm_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.c line 144
static void * wgbm_dl_sym(struct wcore_platform *wc_self, signed int waffle_dl, const char *name);
// wgbm_get_default_fd
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.c line 104
static signed int wgbm_get_default_fd(void);
// wgbm_get_default_fd_for_pattern
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.c line 69
static signed int wgbm_get_default_fd_for_pattern(const char *pattern);
// wgbm_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.h line 60
static inline struct wgbm_platform * wgbm_platform(struct wegl_platform_0 *wegl_self);
// wgbm_platform_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.h line 60
static inline struct wgbm_platform_0 * wgbm_platform_link1(struct wegl_platform_2 *wegl_self_link1);
// wgbm_platform_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.h line 60
static inline struct wgbm_platform_1 * wgbm_platform_link2(struct wegl_platform_1 *wegl_self_link2);
// wgbm_platform_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_init.c line 36
struct wcore_platform * wgbm_platform_create(void);
// wgbm_platform_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.c line 50
static _Bool wgbm_platform_destroy(struct wcore_platform *wc_self);
// wgbm_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_window.h line 41
static inline struct wgbm_window * wgbm_window(struct wcore_window *wc_self);
// wgbm_window_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_window.h line 53
struct wcore_window * wgbm_window_create(struct wcore_platform *wc_plat, struct wcore_config *wc_config, signed int width, signed int height);
// wgbm_window_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_window.h line 59
_Bool wgbm_window_destroy(struct wcore_window *wc_self);
// wgbm_window_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_window.h line 68
union waffle_native_window * wgbm_window_get_native(struct wcore_window *wc_self);
// wgbm_window_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_window.h line 62
_Bool wgbm_window_show(struct wcore_window *wc_self);
// wgbm_window_swap_buffers
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_window.h line 65
_Bool wgbm_window_swap_buffers(struct wcore_window *wc_self);
// wl_compositor_create_surface
// file /usr/include/wayland-client-protocol.h line 361
static inline struct wl_surface * wl_compositor_create_surface(struct wl_compositor *wl_compositor);
// wl_display_connect
// file /usr/include/wayland-client-core.h line 150
struct wl_display * wl_display_connect(const char *);
// wl_display_disconnect
// file /usr/include/wayland-client-core.h line 152
void wl_display_disconnect(struct wl_display *);
// wl_display_get_registry
// file /usr/include/wayland-client-protocol.h line 185
static inline struct wl_registry * wl_display_get_registry(struct wl_display *wl_display);
// wl_display_roundtrip
// file /usr/include/wayland-client-core.h line 168
signed int wl_display_roundtrip(struct wl_display *);
// wl_egl_window_create
// file /usr/include/wayland-egl-core.h line 40
struct wl_egl_window * wl_egl_window_create(struct wl_surface *, signed int, signed int);
// wl_egl_window_destroy
// file /usr/include/wayland-egl-core.h line 44
void wl_egl_window_destroy(struct wl_egl_window *);
// wl_egl_window_resize
// file /usr/include/wayland-egl-core.h line 47
void wl_egl_window_resize(struct wl_egl_window *, signed int, signed int, signed int, signed int);
// wl_proxy_add_listener
// file /usr/include/wayland-client-core.h line 138
signed int wl_proxy_add_listener(struct wl_proxy *, void (**)(void), void *);
// wl_proxy_destroy
// file /usr/include/wayland-client-core.h line 137
void wl_proxy_destroy(struct wl_proxy *);
// wl_proxy_marshal
// file /usr/include/wayland-client-core.h line 123
void wl_proxy_marshal(struct wl_proxy *, unsigned int, ...);
// wl_proxy_marshal_constructor
// file /usr/include/wayland-client-core.h line 128
struct wl_proxy * wl_proxy_marshal_constructor(struct wl_proxy *, unsigned int, struct wl_interface *, ...);
// wl_registry_add_listener
// file /usr/include/wayland-client-protocol.h line 256
static inline signed int wl_registry_add_listener(struct wl_registry *wl_registry, struct wl_registry_listener *listener, void *data);
// wl_registry_bind
// file /usr/include/wayland-client-protocol.h line 284
static inline void * wl_registry_bind(struct wl_registry *wl_registry, unsigned int name, struct wl_interface *interface, unsigned int version);
// wl_shell_get_shell_surface
// file /usr/include/wayland-client-protocol.h line 1090
static inline struct wl_shell_surface * wl_shell_get_shell_surface(struct wl_shell *wl_shell, struct wl_surface *surface);
// wl_shell_surface_add_listener
// file /usr/include/wayland-client-protocol.h line 1242
static inline signed int wl_shell_surface_add_listener(struct wl_shell_surface *wl_shell_surface, struct wl_shell_surface_listener *listener, void *data);
// wl_shell_surface_destroy
// file /usr/include/wayland-client-protocol.h line 1273
static inline void wl_shell_surface_destroy(struct wl_shell_surface *wl_shell_surface);
// wl_shell_surface_pong
// file /usr/include/wayland-client-protocol.h line 1279
static inline void wl_shell_surface_pong(struct wl_shell_surface *wl_shell_surface, unsigned int serial);
// wl_shell_surface_set_toplevel
// file /usr/include/wayland-client-protocol.h line 1300
static inline void wl_shell_surface_set_toplevel(struct wl_shell_surface *wl_shell_surface);
// wl_surface_destroy
// file /usr/include/wayland-client-protocol.h line 1463
static inline void wl_surface_destroy(struct wl_surface *wl_surface);
// wrapped_XCloseDisplay
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 64
static inline signed int wrapped_XCloseDisplay(struct _XDisplay *dpy);

//

// wrapped_XGetXCBConnection
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 73
static inline struct xcb_connection_t * wrapped_XGetXCBConnection(struct _XDisplay *dpy);

//

// wrapped_XOpenDisplay
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 55
static inline struct _XDisplay * wrapped_XOpenDisplay(const char *name);

//

// wrapped_glXChooseFBConfig
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 48
static inline struct __GLXFBConfigRec ** wrapped_glXChooseFBConfig(struct glx_platform *platform, struct _XDisplay *dpy, signed int screen, const signed int *attribList, signed int *nitems);

//

// wrapped_glXCreateContextAttribsARB
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 60
static inline struct __GLXcontextRec * wrapped_glXCreateContextAttribsARB(struct glx_platform *platform, struct _XDisplay *dpy, struct __GLXFBConfigRec *config, struct __GLXcontextRec *share_context, signed int direct, const signed int *attrib_list);

//

// wrapped_glXCreateNewContext
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 73
static inline struct __GLXcontextRec * wrapped_glXCreateNewContext(struct glx_platform *platform, struct _XDisplay *dpy, struct __GLXFBConfigRec *config, signed int renderType, struct __GLXcontextRec *shareList, signed int direct);

//

// wrapped_glXDestroyContext
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 106
static inline void wrapped_glXDestroyContext(struct glx_platform *platform, struct _XDisplay *dpy, struct __GLXcontextRec *ctx);

//

// wrapped_glXGetFBConfigAttrib
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 85
static inline signed int wrapped_glXGetFBConfigAttrib(struct glx_platform *platform, struct _XDisplay *dpy, struct __GLXFBConfigRec *config, signed int attribute, signed int *value);

//

// wrapped_glXGetVisualFromFBConfig
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 96
static inline struct anonymous_11 * wrapped_glXGetVisualFromFBConfig(struct glx_platform *platform, struct _XDisplay *dpy, struct __GLXFBConfigRec *config);

//

// wrapped_glXMakeCurrent
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 115
static inline signed int wrapped_glXMakeCurrent(struct glx_platform *platform, struct _XDisplay *dpy, unsigned long int drawable, struct __GLXcontextRec *ctx);

//

// wrapped_glXQueryExtensionsString
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 125
static inline const char * wrapped_glXQueryExtensionsString(struct glx_platform *platform, struct _XDisplay *dpy, signed int screen);

//

// wrapped_glXSwapBuffers
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 135
static inline void wrapped_glXSwapBuffers(struct glx_platform *platform, struct _XDisplay *dpy, unsigned long int drawable);

//

// write_usage_and_exit
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 149
static void write_usage_and_exit(struct _IO_FILE *f, signed int exit_code);
// x11_display_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_display.h line 39
_Bool x11_display_init(struct x11_display *self, const char *name);
// x11_display_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_display.h line 42
_Bool x11_display_teardown(struct x11_display *self);
// x11_dummy_error_handler
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 49
static inline signed int x11_dummy_error_handler(struct _XDisplay *dpy, struct anonymous_12 *err);
// x11_dummy_error_handler_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 49
static inline signed int x11_dummy_error_handler_link1(struct _XDisplay *dpy_link1, struct anonymous_12 *err_link1);
// x11_dummy_error_handler_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 49
static inline signed int x11_dummy_error_handler_link2(struct _XDisplay *dpy_link2, struct anonymous_12 *err_link2);
// x11_dummy_error_handler_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 49
static inline signed int x11_dummy_error_handler_link3(struct _XDisplay *dpy_link3, struct anonymous_12 *err_link3);
// x11_dummy_error_handler_link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 49
static inline signed int x11_dummy_error_handler_link4(struct _XDisplay *dpy_link4, struct anonymous_12 *err_link4);
// x11_dummy_error_handler_link5
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 49
static inline signed int x11_dummy_error_handler_link5(struct _XDisplay *dpy_link5, struct anonymous_12 *err_link5);
// x11_winddow_get_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_window.c line 34
static unsigned char x11_winddow_get_depth(struct xcb_connection_t *conn, const struct xcb_screen_t *screen, unsigned int id);
// x11_window_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_window.h line 40
_Bool x11_window_init(struct x11_window *self, struct x11_display *dpy, unsigned int visual_id, signed int width, signed int height);
// x11_window_resize
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_window.h line 53
_Bool x11_window_resize(struct x11_window *self, signed int width, signed int height);
// x11_window_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_window.h line 50
_Bool x11_window_show(struct x11_window *self);
// x11_window_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_window.h line 47
_Bool x11_window_teardown(struct x11_window *self);
// xcb_configure_window
// file /usr/include/xcb/xproto.h line 6040
struct anonymous_3 xcb_configure_window(struct xcb_connection_t *, unsigned int, unsigned short int, const unsigned int *);
// xcb_create_colormap_checked
// file /usr/include/xcb/xproto.h line 9866
struct anonymous_3 xcb_create_colormap_checked(struct xcb_connection_t *, unsigned char, unsigned int, unsigned int, unsigned int);
// xcb_create_window_checked
// file /usr/include/xcb/xproto.h line 5507
struct anonymous_3 xcb_create_window_checked(struct xcb_connection_t *, unsigned char, unsigned int, unsigned int, signed short int, signed short int, unsigned short int, unsigned short int, unsigned short int, unsigned short int, unsigned int, unsigned int, const unsigned int *);
// xcb_depth_next
// file /usr/include/xcb/xproto.h line 5224
void xcb_depth_next(struct xcb_depth_iterator_t *);
// xcb_depth_visuals_iterator
// file /usr/include/xcb/xproto.h line 5213
struct xcb_visualtype_iterator_t xcb_depth_visuals_iterator(const struct xcb_depth_t *);
// xcb_destroy_window
// file /usr/include/xcb/xproto.h line 5715
struct anonymous_3 xcb_destroy_window(struct xcb_connection_t *, unsigned int);
// xcb_destroy_window_checked
// file /usr/include/xcb/xproto.h line 5696
struct anonymous_3 xcb_destroy_window_checked(struct xcb_connection_t *, unsigned int);
// xcb_free_colormap
// file /usr/include/xcb/xproto.h line 9911
struct anonymous_3 xcb_free_colormap(struct xcb_connection_t *, unsigned int);
// xcb_generate_id
// file /usr/include/xcb/xcb.h line 587
unsigned int xcb_generate_id(struct xcb_connection_t *);
// xcb_get_setup
// file /usr/include/xcb/xcb.h line 456
struct xcb_setup_t * xcb_get_setup(struct xcb_connection_t *);
// xcb_map_window_checked
// file /usr/include/xcb/xproto.h line 5873
struct anonymous_3 xcb_map_window_checked(struct xcb_connection_t *, unsigned int);
// xcb_request_check
// file /usr/include/xcb/xcb.h line 363
struct anonymous_4 * xcb_request_check(struct xcb_connection_t *, struct anonymous_3);
// xcb_screen_allowed_depths_iterator
// file /usr/include/xcb/xproto.h line 5245
struct xcb_depth_iterator_t xcb_screen_allowed_depths_iterator(const struct xcb_screen_t *);
// xcb_screen_next
// file /usr/include/xcb/xproto.h line 5256
void xcb_screen_next(struct xcb_screen_iterator_t *);
// xcb_setup_roots_iterator
// file /usr/include/xcb/xproto.h line 5409
struct xcb_screen_iterator_t xcb_setup_roots_iterator(const struct xcb_setup_t *);
// xcb_visualtype_next
// file /usr/include/xcb/xproto.h line 5189
void xcb_visualtype_next(struct xcb_visualtype_iterator_t *);
// xegl_config_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.c line 110
static union waffle_native_config * xegl_config_get_native(struct wcore_config *wc_config);
// xegl_context_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.c line 127
static union waffle_native_context * xegl_context_get_native(struct wcore_context *wc_ctx);
// xegl_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.h line 45
static inline struct xegl_display * xegl_display(struct wcore_display *wc_self);
// xegl_display_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.h line 45
static inline struct xegl_display * xegl_display_link1(struct wcore_display *wc_self_link1);
// xegl_display_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.h line 45
static inline struct xegl_display * xegl_display_link2(struct wcore_display *wc_self_link2);
// xegl_display_connect
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.c line 50
struct wcore_display * xegl_display_connect(struct wcore_platform *wc_plat, const char *name);
// xegl_display_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.c line 35
_Bool xegl_display_destroy(struct wcore_display *wc_self);
// xegl_display_fill_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.c line 77
void xegl_display_fill_native(struct xegl_display *self, struct waffle_x11_egl_display *n_dpy);
// xegl_display_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.c line 85
union waffle_native_display * xegl_display_get_native(struct wcore_display *wc_self);
// xegl_dl_can_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.c line 93
static _Bool xegl_dl_can_open(struct wcore_platform *wc_self, signed int waffle_dl);
// xegl_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.c line 101
static void * xegl_dl_sym(struct wcore_platform *wc_self, signed int waffle_dl, const char *name);
// xegl_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.h line 44
static inline struct xegl_platform * xegl_platform(struct wegl_platform_2 *wegl_self);
// xegl_platform_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_init.c line 35
struct wcore_platform * xegl_platform_create(void);
// xegl_platform_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.c line 46
static _Bool xegl_platform_destroy(struct wcore_platform *wc_self);
// xegl_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_window.h line 45
static inline struct xegl_window * xegl_window(struct wcore_window *wc_self);
// xegl_window_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_window.h line 57
struct wcore_window * xegl_window_create(struct wcore_platform *wc_plat, struct wcore_config *wc_config, signed int width, signed int height);
// xegl_window_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_window.h line 63
_Bool xegl_window_destroy(struct wcore_window *wc_self);
// xegl_window_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_window.h line 73
union waffle_native_window * xegl_window_get_native(struct wcore_window *wc_self);
// xegl_window_resize
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_window.h line 69
_Bool xegl_window_resize(struct wcore_window *wc_self, signed int width, signed int height);
// xegl_window_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_window.h line 66
_Bool xegl_window_show(struct wcore_window *wc_self);
// xtime_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 316
signed int xtime_get(struct xtime *xt, signed int base);

struct anonymous_11
{
  // visual
  struct anonymous_10 *visual;
  // visualid
  unsigned long int visualid;
  // screen
  signed int screen;
  // depth
  signed int depth;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // colormap_size
  signed int colormap_size;
  // bits_per_rgb
  signed int bits_per_rgb;
};

struct anonymous_1
{
  // ext_data
  struct _XExtData *ext_data;
  // display
  struct _XDisplay *display;
  // root
  unsigned long int root;
  // width
  signed int width;
  // height
  signed int height;
  // mwidth
  signed int mwidth;
  // mheight
  signed int mheight;
  // ndepths
  signed int ndepths;
  // depths
  struct anonymous_0 *depths;
  // root_depth
  signed int root_depth;
  // root_visual
  struct anonymous_10 *root_visual;
  // default_gc
  struct _XGC *default_gc;
  // cmap
  unsigned long int cmap;
  // white_pixel
  unsigned long int white_pixel;
  // black_pixel
  unsigned long int black_pixel;
  // max_maps
  signed int max_maps;
  // min_maps
  signed int min_maps;
  // backing_store
  signed int backing_store;
  // save_unders
  signed int save_unders;
  // root_input_mask
  signed long int root_input_mask;
};

struct anonymous_2
{
  // ext_data
  struct _XExtData *ext_data;
  // private1
  struct _XPrivate *private1;
  // fd
  signed int fd;
  // private2
  signed int private2;
  // proto_major_version
  signed int proto_major_version;
  // proto_minor_version
  signed int proto_minor_version;
  // vendor
  char *vendor;
  // private3
  unsigned long int private3;
  // private4
  unsigned long int private4;
  // private5
  unsigned long int private5;
  // private6
  signed int private6;
  // resource_alloc
  unsigned long int (*resource_alloc)(struct _XDisplay *);
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_pad
  signed int bitmap_pad;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // nformats
  signed int nformats;
  // pixmap_format
  struct anonymous *pixmap_format;
  // private8
  signed int private8;
  // release
  signed int release;
  // private9
  struct _XPrivate *private9;
  // private10
  struct _XPrivate *private10;
  // qlen
  signed int qlen;
  // last_request_read
  unsigned long int last_request_read;
  // request
  unsigned long int request;
  // private11
  char *private11;
  // private12
  char *private12;
  // private13
  char *private13;
  // private14
  char *private14;
  // max_request_size
  unsigned int max_request_size;
  // db
  struct _XrmHashBucketRec *db;
  // private15
  signed int (*private15)(struct _XDisplay *);
  // display_name
  char *display_name;
  // default_screen
  signed int default_screen;
  // nscreens
  signed int nscreens;
  // screens
  struct anonymous_1 *screens;
  // motion_buffer
  unsigned long int motion_buffer;
  // private16
  unsigned long int private16;
  // min_keycode
  signed int min_keycode;
  // max_keycode
  signed int max_keycode;
  // private17
  char *private17;
  // private18
  char *private18;
  // private19
  signed int private19;
  // xdefaults
  char *xdefaults;
};

struct anonymous
{
  // ext_data
  struct _XExtData *ext_data;
  // depth
  signed int depth;
  // bits_per_pixel
  signed int bits_per_pixel;
  // scanline_pad
  signed int scanline_pad;
};

struct anonymous_10
{
  // ext_data
  struct _XExtData *ext_data;
  // visualid
  unsigned long int visualid;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // bits_per_rgb
  signed int bits_per_rgb;
  // map_entries
  signed int map_entries;
};

struct anonymous_8
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_0
{
  // depth
  signed int depth;
  // nvisuals
  signed int nvisuals;
  // visuals
  struct anonymous_10 *visuals;
};

struct anonymous_12
{
  // type
  signed int type;
  // display
  struct _XDisplay *display;
  // resourceid
  unsigned long int resourceid;
  // serial
  unsigned long int serial;
  // error_code
  unsigned char error_code;
  // request_code
  unsigned char request_code;
  // minor_code
  unsigned char minor_code;
};

struct anonymous_3
{
  // sequence
  unsigned int sequence;
};

struct anonymous_4
{
  // response_type
  unsigned char response_type;
  // error_code
  unsigned char error_code;
  // sequence
  unsigned short int sequence;
  // resource_id
  unsigned int resource_id;
  // minor_code
  unsigned short int minor_code;
  // major_code
  unsigned char major_code;
  // pad0
  unsigned char pad0;
  // pad
  unsigned int pad[5l];
  // full_sequence
  unsigned int full_sequence;
};

union anonymous_5
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_6
{
  // __data
  struct anonymous_8 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_7
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _XExtData
{
  // number
  signed int number;
  // next
  struct _XExtData *next;
  // free_private
  signed int (*free_private)(struct _XExtData *);
  // private_data
  char *private_data;
};

struct api_object
{
  // display_id
  unsigned long int display_id;
};

struct enum_map
{
  // i
  signed int i;
  // s
  const char *s;
};

struct wcore_config_attrs
{
  // context_api
  signed int context_api;
  // context_major_version
  signed int context_major_version;
  // context_minor_version
  signed int context_minor_version;
  // context_profile
  signed int context_profile;
  // rgb_size
  signed int rgb_size;
  // rgba_size
  signed int rgba_size;
  // red_size
  signed int red_size;
  // green_size
  signed int green_size;
  // blue_size
  signed int blue_size;
  // alpha_size
  signed int alpha_size;
  // depth_size
  signed int depth_size;
  // stencil_size
  signed int stencil_size;
  // samples
  signed int samples;
  // context_forward_compatible
  _Bool context_forward_compatible;
  // context_debug
  _Bool context_debug;
  // double_buffered
  _Bool double_buffered;
  // sample_buffers
  _Bool sample_buffers;
  // accum_buffer
  _Bool accum_buffer;
};

struct wcore_config
{
  // api
  struct api_object api;
  // attrs
  struct wcore_config_attrs attrs;
  // display
  struct wcore_display *display;
};

struct glx_config
{
  // wcore
  struct wcore_config wcore;
  // glx_fbconfig
  struct __GLXFBConfigRec *glx_fbconfig;
  // glx_fbconfig_id
  signed int glx_fbconfig_id;
  // xcb_visual_id
  unsigned int xcb_visual_id;
};

struct wcore_context
{
  // api
  struct api_object api;
  // display
  struct wcore_display *display;
};

struct glx_context
{
  // wcore
  struct wcore_context wcore;
  // glx
  struct __GLXcontextRec *glx;
};

struct wcore_display
{
  // api
  struct api_object api;
  // platform
  struct wcore_platform *platform;
};

struct x11_display
{
  // xlib
  struct _XDisplay *xlib;
  // xcb
  struct xcb_connection_t *xcb;
  // screen
  signed int screen;
};

struct glx_display
{
  // wcore
  struct wcore_display wcore;
  // x11
  struct x11_display x11;
  // ARB_create_context
  _Bool ARB_create_context;
  // ARB_create_context_profile
  _Bool ARB_create_context_profile;
  // EXT_create_context_es_profile
  _Bool EXT_create_context_es_profile;
  // EXT_create_context_es2_profile
  _Bool EXT_create_context_es2_profile;
};

struct wcore_platform
{
  // vtbl
  struct wcore_platform_vtbl *vtbl;
};

struct glx_platform
{
  // wcore
  struct wcore_platform wcore;
  // linux
  struct linux_platform *linux;
  // glxHandle
  void *glxHandle;
  // glXCreateNewContext
  struct __GLXcontextRec * (*glXCreateNewContext)(struct _XDisplay *, struct __GLXFBConfigRec *, signed int, struct __GLXcontextRec *, signed int);
  // glXDestroyContext
  void (*glXDestroyContext)(struct _XDisplay *, struct __GLXcontextRec *);
  // glXMakeCurrent
  signed int (*glXMakeCurrent)(struct _XDisplay *, unsigned long int, struct __GLXcontextRec *);
  // glXQueryExtensionsString
  const char * (*glXQueryExtensionsString)(struct _XDisplay *, signed int);
  // glXGetProcAddress
  void * (*glXGetProcAddress)(const unsigned char *);
  // glXGetVisualFromFBConfig
  struct anonymous_11 * (*glXGetVisualFromFBConfig)(struct _XDisplay *, struct __GLXFBConfigRec *);
  // glXGetFBConfigAttrib
  signed int (*glXGetFBConfigAttrib)(struct _XDisplay *, struct __GLXFBConfigRec *, signed int, signed int *);
  // glXChooseFBConfig
  struct __GLXFBConfigRec ** (*glXChooseFBConfig)(struct _XDisplay *, signed int, const signed int *, signed int *);
  // glXSwapBuffers
  void (*glXSwapBuffers)(struct _XDisplay *, unsigned long int);
  // glXCreateContextAttribsARB
  struct __GLXcontextRec * (*glXCreateContextAttribsARB)(struct _XDisplay *, struct __GLXFBConfigRec *, struct __GLXcontextRec *, signed int, const signed int *);
};

struct wcore_window
{
  // api
  struct api_object api;
  // display
  struct wcore_display *display;
};

struct x11_window
{
  // display
  struct x11_display *display;
  // xcb
  unsigned int xcb;
};

struct glx_window
{
  // wcore
  struct wcore_window wcore;
  // x11
  struct x11_window x11;
};

struct impl_thrd_param
{
  // func
  signed int (*func)(void *);
  // arg
  void *arg;
};

struct linux_dl
{
  // name
  const char *name;
  // dl
  void *dl;
};

struct linux_platform
{
  // libgl
  struct linux_dl *libgl;
  // libgles1
  struct linux_dl *libgles1;
  // libgles2
  struct linux_dl *libgles2;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct options
{
  // platform
  signed int platform;
  // context_api
  signed int context_api;
  // context_profile
  signed int context_profile;
  // context_major
  signed int context_major;
  // context_minor
  signed int context_minor;
  // verbose
  _Bool verbose;
  // context_forward_compatible
  _Bool context_forward_compatible;
  // context_debug
  _Bool context_debug;
  // dl
  signed int dl;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct waffle_error_info
{
  // code
  enum waffle_error code;
  // message
  const char *message;
  // message_length
  unsigned long int message_length;
};

struct waffle_gbm_display
{
  // gbm_device
  struct gbm_device *gbm_device;
  // egl_display
  void *egl_display;
};

struct waffle_gbm_config
{
  // display
  struct waffle_gbm_display display;
  // egl_config
  void *egl_config;
};

struct waffle_gbm_context
{
  // display
  struct waffle_gbm_display display;
  // egl_context
  void *egl_context;
};

struct waffle_gbm_window
{
  // display
  struct waffle_gbm_display display;
  // gbm_surface
  struct gbm_surface *gbm_surface;
  // egl_surface
  void *egl_surface;
};

struct waffle_glx_config
{
  // xlib_display
  struct _XDisplay *xlib_display;
  // glx_fbconfig
  struct __GLXFBConfigRec *glx_fbconfig;
};

struct waffle_glx_context
{
  // xlib_display
  struct _XDisplay *xlib_display;
  // glx_context
  struct __GLXcontextRec *glx_context;
};

struct waffle_glx_display
{
  // xlib_display
  struct _XDisplay *xlib_display;
};

struct waffle_glx_window
{
  // xlib_display
  struct _XDisplay *xlib_display;
  // xlib_window
  unsigned long int xlib_window;
};

union waffle_native_config
{
  // gbm
  struct waffle_gbm_config *gbm;
  // glx
  struct waffle_glx_config *glx;
  // x11_egl
  struct waffle_x11_egl_config *x11_egl;
  // wayland
  struct waffle_wayland_config *wayland;
};

union waffle_native_context
{
  // gbm
  struct waffle_gbm_context *gbm;
  // glx
  struct waffle_glx_context *glx;
  // x11_egl
  struct waffle_x11_egl_context *x11_egl;
  // wayland
  struct waffle_wayland_context *wayland;
};

union waffle_native_display
{
  // gbm
  struct waffle_gbm_display *gbm;
  // glx
  struct waffle_glx_display *glx;
  // x11_egl
  struct waffle_x11_egl_display *x11_egl;
  // wayland
  struct waffle_wayland_display *wayland;
};

union waffle_native_window
{
  // gbm
  struct waffle_gbm_window *gbm;
  // glx
  struct waffle_glx_window *glx;
  // x11_egl
  struct waffle_x11_egl_window *x11_egl;
  // wayland
  struct waffle_wayland_window *wayland;
};

struct waffle_wayland_display
{
  // wl_display
  struct wl_display *wl_display;
  // wl_compositor
  struct wl_compositor *wl_compositor;
  // wl_shell
  struct wl_shell *wl_shell;
  // egl_display
  void *egl_display;
};

struct waffle_wayland_config
{
  // display
  struct waffle_wayland_display display;
  // egl_config
  void *egl_config;
};

struct waffle_wayland_context
{
  // display
  struct waffle_wayland_display display;
  // egl_context
  void *egl_context;
};

struct waffle_wayland_window
{
  // display
  struct waffle_wayland_display display;
  // wl_surface
  struct wl_surface *wl_surface;
  // wl_shell_surface
  struct wl_shell_surface *wl_shell_surface;
  // wl_window
  struct wl_egl_window *wl_window;
  // egl_surface
  void *egl_surface;
};

struct waffle_x11_egl_display
{
  // xlib_display
  struct _XDisplay *xlib_display;
  // egl_display
  void *egl_display;
};

struct waffle_x11_egl_config
{
  // display
  struct waffle_x11_egl_display display;
  // egl_config
  void *egl_config;
};

struct waffle_x11_egl_context
{
  // display
  struct waffle_x11_egl_display display;
  // egl_context
  void *egl_context;
};

struct waffle_x11_egl_window
{
  // display
  struct waffle_x11_egl_display display;
  // xlib_window
  unsigned long int xlib_window;
  // egl_surface
  void *egl_surface;
};

struct wegl_display
{
  // wcore
  struct wcore_display wcore;
  // egl
  void *egl;
  // KHR_create_context
  _Bool KHR_create_context;
};

struct wayland_display
{
  // wl_display
  struct wl_display *wl_display;
  // wl_registry
  struct wl_registry *wl_registry;
  // wl_compositor
  struct wl_compositor *wl_compositor;
  // wl_shell
  struct wl_shell *wl_shell;
  // wegl
  struct wegl_display wegl;
};

struct wegl_platform
{
  // wcore
  struct wcore_platform wcore;
  // eglHandle
  void *eglHandle;
  // eglMakeCurrent
  unsigned int (*eglMakeCurrent)(void *, void *, void *, void *);
  // eglGetProcAddress
  void (*(*eglGetProcAddress)(const char *))(void);
  // eglGetDisplay
  void * (*eglGetDisplay)(struct wl_display *);
  // eglInitialize
  unsigned int (*eglInitialize)(void *, signed int *, signed int *);
  // eglQueryString
  const char * (*eglQueryString)(void *, signed int);
  // eglGetError
  signed int (*eglGetError)(void);
  // eglTerminate
  unsigned int (*eglTerminate)(void *);
  // eglChooseConfig
  unsigned int (*eglChooseConfig)(void *, const signed int *, void **, signed int, signed int *);
  // eglBindAPI
  unsigned int (*eglBindAPI)(unsigned int);
  // eglCreateContext
  void * (*eglCreateContext)(void *, void *, void *, const signed int *);
  // eglDestroyContext
  unsigned int (*eglDestroyContext)(void *, void *);
  // eglGetConfigAttrib
  unsigned int (*eglGetConfigAttrib)(void *, void *, signed int, signed int *);
  // eglCreateWindowSurface
  void * (*eglCreateWindowSurface)(void *, void *, struct wl_egl_window *, const signed int *);
  // eglDestroySurface
  unsigned int (*eglDestroySurface)(void *, void *);
  // eglSwapBuffers
  unsigned int (*eglSwapBuffers)(void *, void *);
};

struct wayland_platform
{
  // wegl
  struct wegl_platform wegl;
  // linux
  struct linux_platform *linux;
};

struct wegl_window
{
  // wcore
  struct wcore_window wcore;
  // egl
  void *egl;
};

struct wayland_window
{
  // wl_surface
  struct wl_surface *wl_surface;
  // wl_shell_surface
  struct wl_shell_surface *wl_shell_surface;
  // wl_window
  struct wl_egl_window *wl_window;
  // wegl
  struct wegl_window wegl;
};

struct wcore_config_vtbl
{
  // choose
  struct wcore_config * (*choose)(struct wcore_platform *, struct wcore_display *, struct wcore_config_attrs *);
  // destroy
  _Bool (*destroy)(struct wcore_config *);
  // get_native
  union waffle_native_config * (*get_native)(struct wcore_config *);
};

struct wcore_context_vtbl
{
  // create
  struct wcore_context * (*create)(struct wcore_platform *, struct wcore_config *, struct wcore_context *);
  // destroy
  _Bool (*destroy)(struct wcore_context *);
  // get_native
  union waffle_native_context * (*get_native)(struct wcore_context *);
};

struct wcore_display_vtbl
{
  // connect
  struct wcore_display * (*connect)(struct wcore_platform *, const char *);
  // destroy
  _Bool (*destroy)(struct wcore_display *);
  // supports_context_api
  _Bool (*supports_context_api)(struct wcore_display *, signed int);
  // get_native
  union waffle_native_display * (*get_native)(struct wcore_display *);
};

struct wcore_error_tinfo
{
  // is_enabled
  _Bool is_enabled;
  // code
  enum waffle_error code;
  // message
  char message[1024l];
  // user_info
  struct waffle_error_info user_info;
};

struct wcore_window_vtbl
{
  // create
  struct wcore_window * (*create)(struct wcore_platform *, struct wcore_config *, signed int, signed int);
  // destroy
  _Bool (*destroy)(struct wcore_window *);
  // show
  _Bool (*show)(struct wcore_window *);
  // swap_buffers
  _Bool (*swap_buffers)(struct wcore_window *);
  // resize
  _Bool (*resize)(struct wcore_window *, signed int, signed int);
  // get_native
  union waffle_native_window * (*get_native)(struct wcore_window *);
};

struct wcore_platform_vtbl
{
  // destroy
  _Bool (*destroy)(struct wcore_platform *);
  // make_current
  _Bool (*make_current)(struct wcore_platform *, struct wcore_display *, struct wcore_window *, struct wcore_context *);
  // get_proc_address
  void * (*get_proc_address)(struct wcore_platform *, const char *);
  // dl_can_open
  _Bool (*dl_can_open)(struct wcore_platform *, signed int);
  // dl_sym
  void * (*dl_sym)(struct wcore_platform *, signed int, const char *);
  // display
  struct wcore_display_vtbl display;
  // config
  struct wcore_config_vtbl config;
  // context
  struct wcore_context_vtbl context;
  // window
  struct wcore_window_vtbl window;
};

struct wcore_tinfo
{
  // error
  struct wcore_error_tinfo *error;
  // is_init
  _Bool is_init;
};

struct wegl_config
{
  // wcore
  struct wcore_config wcore;
  // egl
  void *egl;
};

struct wegl_context
{
  // wcore
  struct wcore_context wcore;
  // egl
  void *egl;
};

struct wegl_platform_2
{
  // wcore
  struct wcore_platform wcore;
  // eglHandle
  void *eglHandle;
  // eglMakeCurrent
  unsigned int (*eglMakeCurrent)(void *, void *, void *, void *);
  // eglGetProcAddress
  void (*(*eglGetProcAddress)(const char *))(void);
  // eglGetDisplay
  void * (*eglGetDisplay)(struct _XDisplay *);
  // eglInitialize
  unsigned int (*eglInitialize)(void *, signed int *, signed int *);
  // eglQueryString
  const char * (*eglQueryString)(void *, signed int);
  // eglGetError
  signed int (*eglGetError)(void);
  // eglTerminate
  unsigned int (*eglTerminate)(void *);
  // eglChooseConfig
  unsigned int (*eglChooseConfig)(void *, const signed int *, void **, signed int, signed int *);
  // eglBindAPI
  unsigned int (*eglBindAPI)(unsigned int);
  // eglCreateContext
  void * (*eglCreateContext)(void *, void *, void *, const signed int *);
  // eglDestroyContext
  unsigned int (*eglDestroyContext)(void *, void *);
  // eglGetConfigAttrib
  unsigned int (*eglGetConfigAttrib)(void *, void *, signed int, signed int *);
  // eglCreateWindowSurface
  void * (*eglCreateWindowSurface)(void *, void *, unsigned long int, const signed int *);
  // eglDestroySurface
  unsigned int (*eglDestroySurface)(void *, void *);
  // eglSwapBuffers
  unsigned int (*eglSwapBuffers)(void *, void *);
};

struct wegl_platform_0
{
  // wcore
  struct wcore_platform wcore;
  // eglHandle
  void *eglHandle;
  // eglMakeCurrent
  unsigned int (*eglMakeCurrent)(void *, void *, void *, void *);
  // eglGetProcAddress
  void (*(*eglGetProcAddress)(const char *))(void);
  // eglGetDisplay
  void * (*eglGetDisplay)(struct gbm_device *);
  // eglInitialize
  unsigned int (*eglInitialize)(void *, signed int *, signed int *);
  // eglQueryString
  const char * (*eglQueryString)(void *, signed int);
  // eglGetError
  signed int (*eglGetError)(void);
  // eglTerminate
  unsigned int (*eglTerminate)(void *);
  // eglChooseConfig
  unsigned int (*eglChooseConfig)(void *, const signed int *, void **, signed int, signed int *);
  // eglBindAPI
  unsigned int (*eglBindAPI)(unsigned int);
  // eglCreateContext
  void * (*eglCreateContext)(void *, void *, void *, const signed int *);
  // eglDestroyContext
  unsigned int (*eglDestroyContext)(void *, void *);
  // eglGetConfigAttrib
  unsigned int (*eglGetConfigAttrib)(void *, void *, signed int, signed int *);
  // eglCreateWindowSurface
  void * (*eglCreateWindowSurface)(void *, void *, void *, const signed int *);
  // eglDestroySurface
  unsigned int (*eglDestroySurface)(void *, void *);
  // eglSwapBuffers
  unsigned int (*eglSwapBuffers)(void *, void *);
};

struct wegl_platform_1
{
  // wcore
  struct wcore_platform wcore;
  // eglHandle
  void *eglHandle;
  // eglMakeCurrent
  unsigned int (*eglMakeCurrent)(void *, void *, void *, void *);
  // eglGetProcAddress
  void (*(*eglGetProcAddress)(const char *))(void);
  // eglGetDisplay
  void * (*eglGetDisplay)(struct gbm_device *);
  // eglInitialize
  unsigned int (*eglInitialize)(void *, signed int *, signed int *);
  // eglQueryString
  const char * (*eglQueryString)(void *, signed int);
  // eglGetError
  signed int (*eglGetError)(void);
  // eglTerminate
  unsigned int (*eglTerminate)(void *);
  // eglChooseConfig
  unsigned int (*eglChooseConfig)(void *, const signed int *, void **, signed int, signed int *);
  // eglBindAPI
  unsigned int (*eglBindAPI)(unsigned int);
  // eglCreateContext
  void * (*eglCreateContext)(void *, void *, void *, const signed int *);
  // eglDestroyContext
  unsigned int (*eglDestroyContext)(void *, void *);
  // eglGetConfigAttrib
  unsigned int (*eglGetConfigAttrib)(void *, void *, signed int, signed int *);
  // eglCreateWindowSurface
  void * (*eglCreateWindowSurface)(void *, void *, void *, const signed int *);
  // eglDestroySurface
  unsigned int (*eglDestroySurface)(void *, void *);
  // eglSwapBuffers
  unsigned int (*eglSwapBuffers)(void *, void *);
};

struct wflinfo_config_attrs
{
  // api
  enum waffle_enum api;
  // profile
  enum waffle_enum profile;
  // major
  signed int major;
  // minor
  signed int minor;
  // forward_compat
  _Bool forward_compat;
  // debug
  _Bool debug;
};

struct wgbm_display
{
  // gbm_device
  struct gbm_device *gbm_device;
  // wegl
  struct wegl_display wegl;
};

struct wgbm_platform_0
{
  // wegl
  struct wegl_platform_2 wegl;
  // linux
  struct linux_platform *linux;
  // gbmHandle
  void *gbmHandle;
  // gbm_create_device
  struct gbm_device * (*gbm_create_device)(signed int);
  // gbm_device_get_fd
  signed int (*gbm_device_get_fd)(struct gbm_device *);
  // gbm_device_destroy
  void (*gbm_device_destroy)(struct gbm_device *);
  // gbm_surface_create
  struct gbm_surface * (*gbm_surface_create)(struct gbm_device *, unsigned int, unsigned int, unsigned int, unsigned int);
  // gbm_surface_destroy
  void (*gbm_surface_destroy)(struct gbm_surface *);
  // gbm_surface_lock_front_buffer
  struct gbm_bo * (*gbm_surface_lock_front_buffer)(struct gbm_surface *);
  // gbm_surface_release_buffer
  void (*gbm_surface_release_buffer)(struct gbm_surface *, struct gbm_bo *);
};

struct wgbm_platform
{
  // wegl
  struct wegl_platform_0 wegl;
  // linux
  struct linux_platform *linux;
  // gbmHandle
  void *gbmHandle;
  // gbm_create_device
  struct gbm_device * (*gbm_create_device)(signed int);
  // gbm_device_get_fd
  signed int (*gbm_device_get_fd)(struct gbm_device *);
  // gbm_device_destroy
  void (*gbm_device_destroy)(struct gbm_device *);
  // gbm_surface_create
  struct gbm_surface * (*gbm_surface_create)(struct gbm_device *, unsigned int, unsigned int, unsigned int, unsigned int);
  // gbm_surface_destroy
  void (*gbm_surface_destroy)(struct gbm_surface *);
  // gbm_surface_lock_front_buffer
  struct gbm_bo * (*gbm_surface_lock_front_buffer)(struct gbm_surface *);
  // gbm_surface_release_buffer
  void (*gbm_surface_release_buffer)(struct gbm_surface *, struct gbm_bo *);
};

struct wgbm_platform_1
{
  // wegl
  struct wegl_platform_1 wegl;
  // linux
  struct linux_platform *linux;
  // gbmHandle
  void *gbmHandle;
  // gbm_create_device
  struct gbm_device * (*gbm_create_device)(signed int);
  // gbm_device_get_fd
  signed int (*gbm_device_get_fd)(struct gbm_device *);
  // gbm_device_destroy
  void (*gbm_device_destroy)(struct gbm_device *);
  // gbm_surface_create
  struct gbm_surface * (*gbm_surface_create)(struct gbm_device *, unsigned int, unsigned int, unsigned int, unsigned int);
  // gbm_surface_destroy
  void (*gbm_surface_destroy)(struct gbm_surface *);
  // gbm_surface_lock_front_buffer
  struct gbm_bo * (*gbm_surface_lock_front_buffer)(struct gbm_surface *);
  // gbm_surface_release_buffer
  void (*gbm_surface_release_buffer)(struct gbm_surface *, struct gbm_bo *);
};

struct wgbm_window
{
  // gbm_surface
  struct gbm_surface *gbm_surface;
  // wegl
  struct wegl_window wegl;
};

struct wl_interface
{
  // name
  const char *name;
  // version
  signed int version;
  // method_count
  signed int method_count;
  // methods
  struct wl_message *methods;
  // event_count
  signed int event_count;
  // events
  struct wl_message *events;
};

struct wl_message
{
  // name
  const char *name;
  // signature
  const char *signature;
  // types
  struct wl_interface **types;
};

struct wl_registry_listener
{
  // global
  void (*global)(void *, struct wl_registry *, unsigned int, const char *, unsigned int);
  // global_remove
  void (*global_remove)(void *, struct wl_registry *, unsigned int);
};

struct wl_shell_surface_listener
{
  // ping
  void (*ping)(void *, struct wl_shell_surface *, unsigned int);
  // configure
  void (*configure)(void *, struct wl_shell_surface *, unsigned int, signed int, signed int);
  // popup_done
  void (*popup_done)(void *, struct wl_shell_surface *);
};

struct xcb_depth_iterator_t
{
  // data
  struct xcb_depth_t *data;
  // rem
  signed int rem;
  // index
  signed int index;
};

struct xcb_depth_t
{
  // depth
  unsigned char depth;
  // pad0
  unsigned char pad0;
  // visuals_len
  unsigned short int visuals_len;
  // pad1
  unsigned char pad1[4l];
};

struct xcb_screen_iterator_t
{
  // data
  struct xcb_screen_t *data;
  // rem
  signed int rem;
  // index
  signed int index;
};

struct xcb_screen_t
{
  // root
  unsigned int root;
  // default_colormap
  unsigned int default_colormap;
  // white_pixel
  unsigned int white_pixel;
  // black_pixel
  unsigned int black_pixel;
  // current_input_masks
  unsigned int current_input_masks;
  // width_in_pixels
  unsigned short int width_in_pixels;
  // height_in_pixels
  unsigned short int height_in_pixels;
  // width_in_millimeters
  unsigned short int width_in_millimeters;
  // height_in_millimeters
  unsigned short int height_in_millimeters;
  // min_installed_maps
  unsigned short int min_installed_maps;
  // max_installed_maps
  unsigned short int max_installed_maps;
  // root_visual
  unsigned int root_visual;
  // backing_stores
  unsigned char backing_stores;
  // save_unders
  unsigned char save_unders;
  // root_depth
  unsigned char root_depth;
  // allowed_depths_len
  unsigned char allowed_depths_len;
};

struct xcb_setup_t
{
  // status
  unsigned char status;
  // pad0
  unsigned char pad0;
  // protocol_major_version
  unsigned short int protocol_major_version;
  // protocol_minor_version
  unsigned short int protocol_minor_version;
  // length
  unsigned short int length;
  // release_number
  unsigned int release_number;
  // resource_id_base
  unsigned int resource_id_base;
  // resource_id_mask
  unsigned int resource_id_mask;
  // motion_buffer_size
  unsigned int motion_buffer_size;
  // vendor_len
  unsigned short int vendor_len;
  // maximum_request_length
  unsigned short int maximum_request_length;
  // roots_len
  unsigned char roots_len;
  // pixmap_formats_len
  unsigned char pixmap_formats_len;
  // image_byte_order
  unsigned char image_byte_order;
  // bitmap_format_bit_order
  unsigned char bitmap_format_bit_order;
  // bitmap_format_scanline_unit
  unsigned char bitmap_format_scanline_unit;
  // bitmap_format_scanline_pad
  unsigned char bitmap_format_scanline_pad;
  // min_keycode
  unsigned char min_keycode;
  // max_keycode
  unsigned char max_keycode;
  // pad1
  unsigned char pad1[4l];
};

struct xcb_visualtype_iterator_t
{
  // data
  struct xcb_visualtype_t *data;
  // rem
  signed int rem;
  // index
  signed int index;
};

struct xcb_visualtype_t
{
  // visual_id
  unsigned int visual_id;
  // _class
  unsigned char _class;
  // bits_per_rgb_value
  unsigned char bits_per_rgb_value;
  // colormap_entries
  unsigned short int colormap_entries;
  // red_mask
  unsigned int red_mask;
  // green_mask
  unsigned int green_mask;
  // blue_mask
  unsigned int blue_mask;
  // pad0
  unsigned char pad0[4l];
};

struct xegl_display
{
  // x11
  struct x11_display x11;
  // wegl
  struct wegl_display wegl;
};

struct xegl_platform
{
  // wegl
  struct wegl_platform_2 wegl;
  // linux
  struct linux_platform *linux;
};

struct xegl_window
{
  // x11
  struct x11_window x11;
  // wegl
  struct wegl_window wegl;
};

struct xtime
{
  // sec
  signed long int sec;
  // nsec
  signed long int nsec;
};


// api_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/api_priv.c line 35
struct wcore_platform *api_platform = ((struct wcore_platform *)NULL);
// context_api_map
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 276
static struct enum_map context_api_map[5l] = { { .i=523, .s="gl" }, { .i=524, .s="gles1" }, { .i=525, .s="gles2" }, { .i=532, .s="gles3" }, { .i=0, .s=((const char *)NULL) } };
// get_opts
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 108
static struct option get_opts[9l] = { { .name="platform", .has_arg=1, .flag=((signed int *)NULL), .val=112 },
    { .name="api", .has_arg=1, .flag=((signed int *)NULL), .val=97 },
    { .name="version", .has_arg=1, .flag=((signed int *)NULL), .val=86 },
    { .name="profile", .has_arg=1, .flag=((signed int *)NULL), .val=87 },
    { .name="verbose", .has_arg=0, .flag=((signed int *)NULL), .val=118 },
    { .name="debug-context", .has_arg=0, .flag=((signed int *)NULL), .val=119 },
    { .name="forward-compatible", .has_arg=0, .flag=((signed int *)NULL),
    .val=120 },
    { .name="help", .has_arg=0, .flag=((signed int *)NULL), .val=104 },
    { .name=((const char *)NULL), .has_arg=0, .flag=((signed int *)NULL),
    .val=0 } };
// glGetError
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 232
static unsigned int (*glGetError)(void);
// glGetIntegerv
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 233
static void (*glGetIntegerv)(unsigned int, unsigned int *);
// glGetString
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 234
static const unsigned char * (*glGetString)(unsigned int);
// glGetStringi
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 235
static const unsigned char * (*glGetStringi)(unsigned int, unsigned int);
// glx_platform_vtbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.c line 42
static struct wcore_platform_vtbl glx_platform_vtbl;
// glx_platform_vtbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.c line 42
static struct wcore_platform_vtbl glx_platform_vtbl = { .destroy=glx_platform_destroy, .make_current=glx_platform_make_current, .get_proc_address=glx_platform_get_proc_address,
    .dl_can_open=glx_platform_dl_can_open,
    .dl_sym=glx_platform_dl_sym,
    .display={ .connect=glx_display_connect, .destroy=glx_display_destroy, .supports_context_api=glx_display_supports_context_api,
    .get_native=glx_display_get_native }, .config={ .choose=glx_config_choose, .destroy=glx_config_destroy, .get_native=glx_config_get_native },
    .context={ .create=glx_context_create, .destroy=glx_context_destroy, .get_native=glx_context_get_native },
    .window={ .create=glx_window_create, .destroy=glx_window_destroy, .show=glx_window_show,
    .swap_buffers=glx_window_swap_buffers, .resize=glx_window_resize,
    .get_native=glx_window_get_native } };
// libEGL_filename
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.c line 35
static const char *libEGL_filename = "libEGL.so.1";
// libGL_filename
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.c line 40
static const char *libGL_filename = "libGL.so.1";
// libgbm_filename
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.c line 45
static const char *libgbm_filename = "libgbm.so.1";
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// opterr
// file /usr/include/getopt.h line 76
extern signed int opterr;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// optopt
// file /usr/include/getopt.h line 80
extern signed int optopt;
// platform_map
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 265
static struct enum_map platform_map[8l] = { { .i=17, .s="android" }, { .i=18, .s="cgl" }, { .i=22, .s="gbm" }, { .i=19, .s="glx" }, { .i=20, .s="wayland" }, { .i=23, .s="wgl" }, { .i=21, .s="x11_egl" }, { .i=0, .s=((const char *)NULL) } };
// registry_listener
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 86
static struct wl_registry_listener registry_listener;
// registry_listener
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 86
static struct wl_registry_listener registry_listener = { .global=registry_listener_global, .global_remove=registry_listener_global_remove };
// shell_surface_listener
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.c line 90
static struct wl_shell_surface_listener shell_surface_listener;
// shell_surface_listener
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.c line 90
static struct wl_shell_surface_listener shell_surface_listener = { .ping=shell_surface_listener_ping, .configure=shell_surface_listener_configure, .popup_done=shell_surface_listener_popup_done };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// usage_message
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 56
static const char *usage_message = "Usage:\n    wflinfo <Required Parameters> [Options]\n\nDescription:\n    Create an OpenGL or OpenGL ES context and print information about it.\n\nRequired Parameters:\n    -p, --platform\n        One of: android, cgl, gbm, glx, wayland, wgl or x11_egl\n\n    -a, --api\n        One of: gl, gles1, gles2 or gles3\n\nOptions:\n    -V, --version\n        For example --api=gl --version=3.2 would request OpenGL 3.2.\n\n    --profile\n        One of: core, compat or none\n\n    -v, --verbose\n        Print more information.\n\n    --forward-compatible\n        Create a forward-compatible context.\n\n    --debug-context\n        Create a debug context.\n\n    -h, --help\n        Print wflinfo usage information.\n\nExamples:\n    wflinfo --platform=glx --api=gl\n    wflinfo --platform=x11_egl --api=gl --version=3.2 --profile=core\n    wflinfo --platform=wayland --api=gles3\n    wflinfo --platform=gbm --api=gl --version=3.2 --verbose\n    wflinfo -p gbm -a gl -V 3.2 -v\n";
// wayland_platform_vtbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.c line 46
static struct wcore_platform_vtbl wayland_platform_vtbl;
// wayland_platform_vtbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.c line 46
static struct wcore_platform_vtbl wayland_platform_vtbl = { .destroy=wayland_platform_destroy, .make_current=wegl_make_current, .get_proc_address=wegl_get_proc_address,
    .dl_can_open=wayland_dl_can_open,
    .dl_sym=wayland_dl_sym, .display={ .connect=wayland_display_connect, .destroy=wayland_display_destroy, .supports_context_api=wegl_display_supports_context_api,
    .get_native=wayland_display_get_native },
    .config={ .choose=wegl_config_choose, .destroy=wegl_config_destroy, .get_native=wayland_config_get_native },
    .context={ .create=wegl_context_create, .destroy=wegl_context_destroy, .get_native=wayland_context_get_native },
    .window={ .create=wayland_window_create, .destroy=wayland_window_destroy, .show=wayland_window_show,
    .swap_buffers=wayland_window_swap_buffers, .resize=wayland_window_resize,
    .get_native=wayland_window_get_native } };
// wcore_tinfo
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.c line 50
static struct wcore_tinfo wcore_tinfo;
// wcore_tinfo_key
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.c line 37
static unsigned int wcore_tinfo_key;
// wcore_tinfo_once
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.c line 36
static signed int wcore_tinfo_once = 0;
// wgbm_platform_vtbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.c line 47
static struct wcore_platform_vtbl wgbm_platform_vtbl;
// wgbm_platform_vtbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.c line 47
static struct wcore_platform_vtbl wgbm_platform_vtbl = { .destroy=wgbm_platform_destroy, .make_current=wegl_make_current, .get_proc_address=wegl_get_proc_address,
    .dl_can_open=wgbm_dl_can_open,
    .dl_sym=wgbm_dl_sym, .display={ .connect=wgbm_display_connect, .destroy=wgbm_display_destroy, .supports_context_api=wegl_display_supports_context_api,
    .get_native=wgbm_display_get_native },
    .config={ .choose=wgbm_config_choose, .destroy=wegl_config_destroy, .get_native=wgbm_config_get_native },
    .context={ .create=wegl_context_create, .destroy=wegl_context_destroy, .get_native=wgbm_context_get_native },
    .window={ .create=wgbm_window_create, .destroy=wgbm_window_destroy, .show=wgbm_window_show,
    .swap_buffers=wgbm_window_swap_buffers, .resize=((_Bool (*)(struct wcore_window *, signed int, signed int))NULL),
    .get_native=wgbm_window_get_native } };
// wl_compositor_interface
// file /usr/include/wayland-client-protocol.h line 68
extern struct wl_interface wl_compositor_interface;
// wl_registry_interface
// file /usr/include/wayland-client-protocol.h line 66
extern struct wl_interface wl_registry_interface;
// wl_shell_interface
// file /usr/include/wayland-client-protocol.h line 76
extern struct wl_interface wl_shell_interface;
// wl_shell_surface_interface
// file /usr/include/wayland-client-protocol.h line 77
extern struct wl_interface wl_shell_surface_interface;
// wl_surface_interface
// file /usr/include/wayland-client-protocol.h line 78
extern struct wl_interface wl_surface_interface;
// xegl_platform_vtbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.c line 43
static struct wcore_platform_vtbl xegl_platform_vtbl;
// xegl_platform_vtbl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.c line 43
static struct wcore_platform_vtbl xegl_platform_vtbl = { .destroy=xegl_platform_destroy, .make_current=wegl_make_current, .get_proc_address=wegl_get_proc_address,
    .dl_can_open=xegl_dl_can_open,
    .dl_sym=xegl_dl_sym, .display={ .connect=xegl_display_connect, .destroy=xegl_display_destroy, .supports_context_api=wegl_display_supports_context_api,
    .get_native=xegl_display_get_native },
    .config={ .choose=wegl_config_choose, .destroy=wegl_config_destroy, .get_native=xegl_config_get_native },
    .context={ .create=wegl_context_create, .destroy=wegl_context_destroy, .get_native=xegl_context_get_native },
    .window={ .create=xegl_window_create, .destroy=xegl_window_destroy, .show=xegl_window_show,
    .swap_buffers=wegl_window_swap_buffers, .resize=xegl_window_resize,
    .get_native=xegl_window_get_native } };

// _wcore_error_disable
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.c line 78
void _wcore_error_disable(void)
{
  struct wcore_tinfo *return_value_wcore_tinfo_get_1;
  return_value_wcore_tinfo_get_1=wcore_tinfo_get();
  return_value_wcore_tinfo_get_1->error->is_enabled = (_Bool)0;
}

// _wcore_error_enable
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.c line 72
void _wcore_error_enable(void)
{
  struct wcore_tinfo *return_value_wcore_tinfo_get_1;
  return_value_wcore_tinfo_get_1=wcore_tinfo_get();
  return_value_wcore_tinfo_get_1->error->is_enabled = (_Bool)1;
}

// _wcore_error_internal
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 87
void _wcore_error_internal(const char *file, signed int line, const char *format, ...)
{
  struct wcore_error_tinfo *t;
  struct wcore_tinfo *return_value_wcore_tinfo_get_1;
  return_value_wcore_tinfo_get_1=wcore_tinfo_get();
  t = return_value_wcore_tinfo_get_1->error;
  char *cur = t->message;
  char *end = t->message + (signed long int)1024;
  signed int printed;
  if(!(t->is_enabled == (_Bool)0))
  {
    t->code = (enum waffle_error)WAFFLE_ERROR_INTERNAL;
    printed=snprintf(cur, (unsigned long int)(end - cur), "waffle: internal error: %s:%d: ", file, line);
    cur = cur + (signed long int)printed;
    if(!(cur >= end) && printed >= 0)
    {
      if(!(format == ((const char *)NULL)))
      {
        void **ap = (void **)&format;
        printed=vsnprintf(cur, (unsigned long int)(end - cur), format, ap);
        cur = cur + (signed long int)printed;
        ap = ((void **)NULL);
        if(cur >= end || !(printed >= 0))
          goto __CPROVER_DUMP_L5;

      }

      snprintf(cur, (unsigned long int)(end - cur), " ; Please report bug at https://github.com/waffle-gl/waffle/issues");
    }

  }


__CPROVER_DUMP_L5:
  ;
}

// api_check_entry
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/api_priv.c line 38
_Bool api_check_entry(struct api_object **obj_list, signed int length)
{
  wcore_error_reset();
  if(api_platform == ((struct wcore_platform *)NULL))
  {
    wcore_error((enum waffle_error)WAFFLE_ERROR_NOT_INITIALIZED);
    return (_Bool)0;
  }

  else
  {
    signed int i = 0;
    for( ; !(i >= length); i = i + 1)
    {
      if(obj_list[(signed long int)i] == ((struct api_object *)NULL))
      {
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_PARAMETER, "null pointer");
        return (_Bool)0;
      }

      if(!(obj_list[(signed long int)i]->display_id == (*obj_list)->display_id))
      {
        wcore_error((enum waffle_error)WAFFLE_ERROR_BAD_DISPLAY_MATCH);
        return (_Bool)0;
      }

    }
    return (_Bool)1;
  }
}

// bind_api
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.c line 38
static _Bool bind_api(struct wegl_platform_2 *plat, signed int waffle_context_api)
{
  _Bool ok = (_Bool)1;
  unsigned int return_value;
  unsigned int return_value_1;
  switch(waffle_context_api)
  {
    case WAFFLE_CONTEXT_OPENGL:
      return_value=plat->eglBindAPI((unsigned int)0x30A2);
    case WAFFLE_CONTEXT_OPENGL_ES1:

    case WAFFLE_CONTEXT_OPENGL_ES2:

    case WAFFLE_CONTEXT_OPENGL_ES3:
      return_value_1=plat->eglBindAPI((unsigned int)0x30A0);
    default:
    {
      _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.c", 53, "waffle_context_api has bad value #x%x", waffle_context_api);
      return (_Bool)0;
    }
  }
  if(ok == (_Bool)0)
    wegl_emit_error(plat, "eglBindAPI");

  return ok;
}

// call_once
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 147
void call_once(signed int *flag, void (*func)(void))
{
  pthread_once(flag, func);
}

// check_context_attrs
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.c line 41
static _Bool check_context_attrs(struct wegl_display *dpy, struct wcore_config_attrs *attrs)
{
  struct wcore_platform *plat = dpy->wcore.platform;
  _Bool return_value_wcore_config_attrs_version_eq_1;
  _Bool return_value_wcore_config_attrs_version_ge_2;
  _Bool return_value;
  _Bool return_value_1;
  _Bool return_value_2;
  _Bool return_value_3;
  if(!(attrs->context_debug == (_Bool)0))
  {
    if(dpy->KHR_create_context != (_Bool)0)
      goto __CPROVER_DUMP_L1;

    wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "EGL_KHR_create_context is required in order to request a debug context");
    return (_Bool)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    switch(attrs->context_api)
    {
      case WAFFLE_CONTEXT_OPENGL:
      {
        return_value_wcore_config_attrs_version_eq_1=wcore_config_attrs_version_eq(attrs, 10);
        if(return_value_wcore_config_attrs_version_eq_1 == (_Bool)0)
        {
          if(dpy->KHR_create_context == (_Bool)0)
          {
            wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "KHR_EXT_create_context is required in order to request an OpenGL version not equal to the default value 1.0");
            return (_Bool)0;
          }

        }

        return_value_wcore_config_attrs_version_ge_2=wcore_config_attrs_version_ge(attrs, 32);
        if(!(attrs->context_forward_compatible == (_Bool)0))
        {
          if(dpy->KHR_create_context == (_Bool)0)
          {
            wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "EGL_KHR_create_context is required in order to request a forward-compatible context");
            return (_Bool)0;
          }

        }

        return_value=plat->vtbl->dl_can_open(plat, WAFFLE_DL_OPENGL);
      }
      case WAFFLE_CONTEXT_OPENGL_ES1:
        return_value_1=plat->vtbl->dl_can_open(plat, WAFFLE_DL_OPENGL_ES1);
      case WAFFLE_CONTEXT_OPENGL_ES2:
        return_value_2=plat->vtbl->dl_can_open(plat, WAFFLE_DL_OPENGL_ES2);
      case WAFFLE_CONTEXT_OPENGL_ES3:
      {
        if(dpy->KHR_create_context == (_Bool)0)
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "EGL_KHR_create_context is required to request an OpenGL ES3 context");
          return (_Bool)0;
        }

        return_value_3=plat->vtbl->dl_can_open(plat, WAFFLE_DL_OPENGL_ES3);
      }
    }
    if(return_value_3 == (_Bool)0)
    {
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "failed to open the OpenGL ES3 library");
      return (_Bool)0;
    }

    else
    {
      return (_Bool)1;
      _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.c", 124, "context_api has bad value %#x", attrs->context_api);
      return (_Bool)0;
    }
  }
}

// check_final
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 456
static _Bool check_final(struct wcore_config_attrs *attrs)
{
  _Bool return_value_wcore_config_attrs_version_ge_1;
  if(attrs->context_api == WAFFLE_CONTEXT_OPENGL)
  {
    if(!(attrs->context_profile == WAFFLE_CONTEXT_CORE_PROFILE))
      goto __CPROVER_DUMP_L1;

    return_value_wcore_config_attrs_version_ge_1=wcore_config_attrs_version_ge(attrs, 32);
    if(return_value_wcore_config_attrs_version_ge_1 == (_Bool)0)
      goto __CPROVER_DUMP_L1;

    if(attrs->accum_buffer == (_Bool)0)
      goto __CPROVER_DUMP_L1;

    wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "%s", (const void *)"WAFFLE_ACCUM_BUFFER must be false forOpenGL Core profile");
    return (_Bool)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return (_Bool)1;
  }
}

// check_keys
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 42
static _Bool check_keys(const signed int *attrib_list)
{
  if(attrib_list == ((const signed int *)NULL))
    return (_Bool)1;

  else
  {
    signed int i = 0;
    for( ; !(attrib_list[(signed long int)i] == 0); i = i + 2)
    {
      signed int key = attrib_list[(signed long int)i];
      if(key == WAFFLE_RED_SIZE || key == WAFFLE_GREEN_SIZE || key == WAFFLE_BLUE_SIZE || key == WAFFLE_ALPHA_SIZE || key == WAFFLE_DEPTH_SIZE || key == WAFFLE_STENCIL_SIZE || key == WAFFLE_SAMPLE_BUFFERS || key == WAFFLE_SAMPLES || key == WAFFLE_DOUBLE_BUFFERED || key == WAFFLE_CONTEXT_API || key == WAFFLE_CONTEXT_MAJOR_VERSION || key == WAFFLE_CONTEXT_MINOR_VERSION || key == WAFFLE_CONTEXT_PROFILE || key == WAFFLE_ACCUM_BUFFER || key == WAFFLE_CONTEXT_FORWARD_COMPATIBLE || key == WAFFLE_CONTEXT_DEBUG)
        goto __CPROVER_DUMP_L5;

      wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "unrecognized attribute 0x%x at attrib_list[%d]", key, i);
      return (_Bool)0;

    __CPROVER_DUMP_L5:
      ;
    }
    return (_Bool)1;
  }
}

// choose_real_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.c line 130
static void * choose_real_config(struct wegl_display *dpy, struct wcore_config_attrs *attrs)
{
  struct wegl_platform_2 *plat;
  plat=wegl_platform(dpy->wcore.platform);
  void *config = (void *)0;
  _Bool ok = (_Bool)1;
  if(!(attrs->accum_buffer == (_Bool)0))
  {
    wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "accum buffers do not exist on EGL");
    return (void *)0;
  }

  else
  {
    const signed int renderable_index = 19;
    signed int attrib_list[23l] = { 0x3020, attrs->rgba_size, 0x3024, attrs->red_size, 0x3023, attrs->green_size, 0x3022, attrs->blue_size, 0x3021, attrs->alpha_size, 0x3025, attrs->depth_size, 0x3026, attrs->stencil_size, 0x3032, (signed int)attrs->sample_buffers, 0x3031, attrs->samples, 0x3040, 31415926, 0x3033, 0x0004, 0x3038 };
    switch(attrs->context_api)
    {
      case WAFFLE_CONTEXT_OPENGL:
      {
        attrib_list[(signed long int)renderable_index] = 0x0008;
        break;
      }
      case WAFFLE_CONTEXT_OPENGL_ES1:
      {
        attrib_list[(signed long int)renderable_index] = 0x0001;
        break;
      }
      case WAFFLE_CONTEXT_OPENGL_ES2:
      {
        attrib_list[(signed long int)renderable_index] = 0x0004;
        break;
      }
      case WAFFLE_CONTEXT_OPENGL_ES3:
      {
        attrib_list[(signed long int)renderable_index] = 0x00000040;
        break;
      }
      default:
      {
        _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.c", 189, "waffle_context_api has bad value %#x", attrs->context_api);
        return (void *)0;
      }
    }
    signed int num_configs = 0;
    unsigned int return_value;
    return_value=plat->eglChooseConfig(dpy->egl, attrib_list, &config, 1, &num_configs);
    ok = ((unsigned int)ok & return_value) != 0u;
    if(ok == (_Bool)0)
    {
      wegl_emit_error(plat, "eglChooseConfig");
      return (void *)0;
    }

    else
      if(num_configs == 0)
      {
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "eglChooseConfig found no matching configs");
        return (void *)0;
      }

    return config;
  }
}

// cnd_broadcast
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 83
signed int cnd_broadcast(union anonymous_6 *cond)
{
  if(cond == ((union anonymous_6 *)NULL))
    return 2;

  else
  {
    pthread_cond_broadcast(cond);
    return 0;
  }
}

// cnd_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 91
void cnd_destroy(union anonymous_6 *cond)
{
  pthread_cond_destroy(cond);
}

// cnd_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 98
signed int cnd_init(union anonymous_6 *cond)
{
  if(cond == ((union anonymous_6 *)NULL))
    return 2;

  else
  {
    pthread_cond_init(cond, (const union anonymous_5 *)(void *)0);
    return 0;
  }
}

// cnd_signal
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 106
signed int cnd_signal(union anonymous_6 *cond)
{
  if(cond == ((union anonymous_6 *)NULL))
    return 2;

  else
  {
    pthread_cond_signal(cond);
    return 0;
  }
}

// cnd_timedwait
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 114
signed int cnd_timedwait(union anonymous_6 *cond, union anonymous_7 *mtx, const struct xtime *xt)
{
  struct timespec abs_time;
  signed int rt;
  if(cond == ((union anonymous_6 *)NULL) || mtx == ((union anonymous_7 *)NULL) || xt == ((const struct xtime *)NULL))
    return 2;

  else
  {
    rt=pthread_cond_timedwait(cond, mtx, &abs_time);
    if(rt == 110)
      return 3;

    else
      return rt == 0 ? 0 : 2;
  }
}

// cnd_wait
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 126
signed int cnd_wait(union anonymous_6 *cond, union anonymous_7 *mtx)
{
  if(cond == ((union anonymous_6 *)NULL) || mtx == ((union anonymous_7 *)NULL))
    return 2;

  else
  {
    pthread_cond_wait(cond, mtx);
    return 0;
  }
}

// create_real_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.c line 64
static void * create_real_context(struct wegl_config *config, void *share_ctx)
{
  struct wegl_display *dpy;
  dpy=wegl_display_link1(config->wcore.display);
  struct wegl_platform_2 *plat;
  plat=wegl_platform_link1(dpy->wcore.platform);
  struct wcore_config_attrs *attrs = &config->wcore.attrs;
  _Bool ok = (_Bool)1;
  signed int waffle_context_api = attrs->context_api;
  signed int attrib_list[64l];
  signed int context_flags = 0;
  signed int i = 0;
  if(!(attrs->context_debug == (_Bool)0))
    context_flags = context_flags | 0x00000001;

  signed int tmp_post_1;
  signed int tmp_post_2;
  signed int tmp_post_3;
  signed int tmp_post_4;
  _Bool return_value_wcore_config_attrs_version_ge_9;
  signed int tmp_post_5;
  signed int tmp_post_6;
  signed int tmp_post_7;
  signed int tmp_post_8;
  signed int tmp_post_10;
  signed int tmp_post_11;
  signed int tmp_post_12;
  signed int tmp_post_13;
  switch(waffle_context_api)
  {
    case WAFFLE_CONTEXT_OPENGL:
    {
      if(!(dpy->KHR_create_context == (_Bool)0))
      {
        tmp_post_1 = i;
        i = i + 1;
        attrib_list[(signed long int)tmp_post_1] = 0x3098;
        tmp_post_2 = i;
        i = i + 1;
        attrib_list[(signed long int)tmp_post_2] = attrs->context_major_version;
        tmp_post_3 = i;
        i = i + 1;
        attrib_list[(signed long int)tmp_post_3] = 0x30FB;
        tmp_post_4 = i;
        i = i + 1;
        attrib_list[(signed long int)tmp_post_4] = attrs->context_minor_version;
      }

      if(!(attrs->context_forward_compatible == (_Bool)0))
        context_flags = context_flags | 0x00000002;

      return_value_wcore_config_attrs_version_ge_9=wcore_config_attrs_version_ge(attrs, 32);
      if(!(return_value_wcore_config_attrs_version_ge_9 == (_Bool)0))
        switch(attrs->context_profile)
        {
          case WAFFLE_CONTEXT_CORE_PROFILE:
          {
            tmp_post_5 = i;
            i = i + 1;
            attrib_list[(signed long int)tmp_post_5] = 0x30FD;
            tmp_post_6 = i;
            i = i + 1;
            attrib_list[(signed long int)tmp_post_6] = 0x00000001;
            break;
          }
          case WAFFLE_CONTEXT_COMPATIBILITY_PROFILE:
          {
            tmp_post_7 = i;
            i = i + 1;
            attrib_list[(signed long int)tmp_post_7] = 0x30FD;
            tmp_post_8 = i;
            i = i + 1;
            attrib_list[(signed long int)tmp_post_8] = 0x00000002;
            break;
          }
          default:
          {
            _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.c", 112, "attrs->context_profile has bad value %#x", attrs->context_profile);
            return (void *)0;
          }
        }

      break;
    }
    case WAFFLE_CONTEXT_OPENGL_ES1:

    case WAFFLE_CONTEXT_OPENGL_ES2:

    case WAFFLE_CONTEXT_OPENGL_ES3:
    {
      tmp_post_10 = i;
      i = i + 1;
      attrib_list[(signed long int)tmp_post_10] = 0x3098;
      tmp_post_11 = i;
      i = i + 1;
      attrib_list[(signed long int)tmp_post_11] = attrs->context_major_version;
      if(!(dpy->KHR_create_context == (_Bool)0))
      {
        tmp_post_12 = i;
        i = i + 1;
        attrib_list[(signed long int)tmp_post_12] = 0x30FB;
        tmp_post_13 = i;
        i = i + 1;
        attrib_list[(signed long int)tmp_post_13] = attrs->context_minor_version;
      }

      break;
    }
    default:
    {
      _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.c", 136, "waffle_context_api has bad value %#x", waffle_context_api);
      return (void *)0;
    }
  }
  signed int tmp_post_14;
  signed int tmp_post_15;
  if(!(context_flags == 0))
  {
    tmp_post_14 = i;
    i = i + 1;
    attrib_list[(signed long int)tmp_post_14] = 0x30FC;
    tmp_post_15 = i;
    i = i + 1;
    attrib_list[(signed long int)tmp_post_15] = context_flags;
  }

  signed int tmp_post_16 = i;
  i = i + 1;
  attrib_list[(signed long int)tmp_post_16] = 0x3038;
  ok=bind_api(plat, waffle_context_api);
  if(ok == (_Bool)0)
    return NULL;

  else
  {
    void *ctx;
    ctx=plat->eglCreateContext(dpy->egl, config->egl, share_ctx, attrib_list);
    if(ctx == NULL)
      wegl_emit_error(plat, "eglCreateContext");

    return ctx;
  }
}

// enum_map_to_str
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 306
static const char * enum_map_to_str(struct enum_map *self, signed int val)
{
  struct enum_map *i = self;
  for( ; !(i->i == 0); i = i + 1l)
    if(i->i == val)
      return i->s;

  return (const char *)(void *)0;
}

// enum_map_translate_str
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 290
static _Bool enum_map_translate_str(struct enum_map *self, const char *s, signed int *result)
{
  struct enum_map *i = self;
  for( ; !(i->i == 0); i = i + 1l)
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(i->s);
    signed int return_value_strncmp_2;
    return_value_strncmp_2=strncmp(s, i->s, return_value_strlen_1 + (unsigned long int)1);
    if(return_value_strncmp_2 == 0)
    {
      *result = i->i;
      return (_Bool)1;
    }

  }
  return (_Bool)0;
}

// error_get_gl_symbol
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 185
static void error_get_gl_symbol(const char *name)
{
  error_printf("Wflinfo", "failed to get function pointer for %s", name);
}

// error_printf
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 135
static void error_printf(const char *module, const char *fmt, ...)
{
  void **ap = (void **)&fmt;
  fprintf(stderr, "%s error: ", module);
  vfprintf(stderr, fmt, ap);
  fprintf(stderr, "\n");
  ap = ((void **)NULL);
  exit(1);
}

// error_waffle
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 173
static void error_waffle(void)
{
  struct waffle_error_info *info;
  info=waffle_error_get_info();
  const char *code;
  code=waffle_error_to_string(info->code);
  if(info->message_length >= 1ul)
    error_printf("Waffle", "0x%x %s: %s", info->code, code, info->message);

  else
    error_printf("Waffle", "0x%x %s", info->code, code);
}

// get_extensions
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.c line 37
static _Bool get_extensions(struct wegl_display *dpy)
{
  struct wegl_platform_2 *plat;
  plat=wegl_platform_link2(dpy->wcore.platform);
  const char *extensions;
  extensions=plat->eglQueryString(dpy->egl, 0x3055);
  if(extensions == ((const char *)NULL))
  {
    wegl_emit_error(plat, "eglQueryString(EGL_EXTENSIONS");
    return (_Bool)0;
  }

  else
  {
    dpy->KHR_create_context=waffle_is_extension_in_string(extensions, "EGL_KHR_create_context");
    return (_Bool)1;
  }
}

// get_xcb_screen
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_window.c line 57
static struct xcb_screen_t * get_xcb_screen(const struct xcb_setup_t *setup, signed int screen)
{
  struct xcb_screen_iterator_t iter;
  iter=xcb_setup_roots_iterator(setup);
  while(!(iter.rem == 0))
  {
    if(screen == 0)
      return iter.data;

    screen = screen - 1;
    xcb_screen_next(&iter);
  }
  return (struct xcb_screen_t *)(void *)0;
}

// gl_get_profile
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 855
static enum waffle_enum gl_get_profile(void)
{
  signed int version;
  version=gl_get_version();
  if(version >= 32)
  {
    unsigned int profile_mask = (unsigned int)0;
    glGetIntegerv((unsigned int)0x9126, &profile_mask);
    unsigned int return_value;
    return_value=glGetError();
    if(!(return_value == 0u))
      error_printf("Wflinfo", "glGetIntegerv(GL_CONTEXT_PROFILE_MASK) failed");

    else
      if(!((1u & profile_mask) == 0u))
        return (enum waffle_enum)WAFFLE_CONTEXT_CORE_PROFILE;

      else
        if(!((2u & profile_mask) == 0u))
          return (enum waffle_enum)WAFFLE_CONTEXT_COMPATIBILITY_PROFILE;

        else
          error_printf("Wflinfo", "glGetIntegerv(GL_CONTEXT_PROFILE_MASK) return a mask with no profile bit: 0x%x", profile_mask);
  }

  else
    if(version == 31)
    {
      _Bool return_value_gl_has_extension_1;
      return_value_gl_has_extension_1=gl_has_extension("GL_ARB_compatibility");
      if(!(return_value_gl_has_extension_1 == (_Bool)0))
        return (enum waffle_enum)WAFFLE_CONTEXT_CORE_PROFILE;

      else
        return (enum waffle_enum)WAFFLE_CONTEXT_COMPATIBILITY_PROFILE;
    }

    else
      return (enum waffle_enum)WAFFLE_NONE;
}

// gl_get_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 764
static signed int gl_get_version(void)
{
  unsigned int major_version = (unsigned int)0;
  unsigned int minor_version = (unsigned int)0;
  glGetIntegerv((unsigned int)0x821B, &major_version);
  unsigned int return_value;
  return_value=glGetError();
  if(!(return_value == 0u))
    error_printf("Wflinfo", "glGetIntegerv(GL_MAJOR_VERSION) failed");

  glGetIntegerv((unsigned int)0x821C, &minor_version);
  unsigned int return_value_1;
  return_value_1=glGetError();
  if(!(return_value_1 == 0u))
    error_printf("Wflinfo", "glGetIntegerv(GL_MINOR_VERSION) failed");

  return (signed int)((unsigned int)10 * major_version + minor_version);
}

// gl_has_extension
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 834
static _Bool gl_has_extension(const char *name)
{
  signed int return_value_gl_get_version_3;
  return_value_gl_get_version_3=gl_get_version();
  if(return_value_gl_get_version_3 >= 30)
  {
    _Bool return_value_gl_has_extension_GetStringi_1;
    return_value_gl_has_extension_GetStringi_1=gl_has_extension_GetStringi(name);
    return return_value_gl_has_extension_GetStringi_1;
  }

  else
  {
    _Bool return_value_gl_has_extension_GetString_2;
    return_value_gl_has_extension_GetString_2=gl_has_extension_GetString(name);
    return return_value_gl_has_extension_GetString_2;
  }
}

// gl_has_extension_GetString
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 783
static _Bool gl_has_extension_GetString(const char *name)
{
  char exts[4096l];
  const unsigned char *exts_orig;
  exts_orig=glGetString((unsigned int)7939);
  unsigned int return_value;
  return_value=glGetError();
  if(!(return_value == 0u))
    error_printf("Wflinfo", "glGetInteger(GL_EXTENSIONS) failed");

  memcpy((void *)exts, (const void *)exts_orig, (unsigned long int)4096);
  exts[(signed long int)(4096 - 1)] = (char)0;
  char *ext;
  ext=strtok(exts, " ");
  _Bool return_value_strneq_1;
  return_value_strneq_1=strneq(ext, name, (unsigned long int)4096);
  if(!(return_value_strneq_1 == (_Bool)0))
    return (_Bool)1;

  else
  {
    ext=strtok((char *)(void *)0, " ");
    return (_Bool)0;
  }
}

// gl_has_extension_GetStringi
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 810
static _Bool gl_has_extension_GetStringi(const char *name)
{
  const unsigned long int max_ext_len = (const unsigned long int)128;
  unsigned int num_exts = (unsigned int)0;
  glGetIntegerv((unsigned int)33309, &num_exts);
  unsigned int return_value;
  return_value=glGetError();
  if(!(return_value == 0u))
    error_printf("Wflinfo", "glGetIntegerv(GL_NUM_EXTENSIONS) failed");

  unsigned int i = (unsigned int)0;
  _Bool tmp_if_expr_2;
  unsigned int return_value_1;
  _Bool return_value_strneq_1;
  if(!(i >= num_exts))
  {
    const unsigned char *ext;
    ext=glGetStringi((unsigned int)7939, i);
    if(ext == ((const unsigned char *)NULL))
      tmp_if_expr_2 = (_Bool)1;

    else
    {
      return_value_1=glGetError();
      tmp_if_expr_2 = return_value_1 != 0u ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_2)
      error_printf("Wflinfo", "glGetStringi(GL_EXTENSIONS) failed");

    else
    {
      return_value_strneq_1=strneq((const char *)ext, name, max_ext_len);
      if(!(return_value_strneq_1 == (_Bool)0))
        return (_Bool)1;

    }
    i = i + 1u;
  }

  return (_Bool)0;
}

// glx_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.h line 48
static inline struct glx_config * glx_config(struct wcore_config *wcore_self)
{
  struct glx_config *tmp_statement_expression_1;
  if(!(wcore_self == ((struct wcore_config *)NULL)))
  {
    const struct wcore_config *__mptr = wcore_self;
    tmp_statement_expression_1 = (struct glx_config *)((void *)__mptr - (signed long int)0ul);
    return tmp_statement_expression_1;
  }

  else
    return ((struct glx_config *)NULL);
}

// glx_config_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.h line 48
static inline struct glx_config * glx_config_link1(struct wcore_config *wcore_self_link1)
{
  struct glx_config *tmp_statement_expression_1_link1;
  if(!(wcore_self_link1 == ((struct wcore_config *)NULL)))
  {
    const struct wcore_config *__mptr_link1 = wcore_self_link1;
    tmp_statement_expression_1_link1 = (struct glx_config *)((void *)__mptr_link1 - (signed long int)0ul);
    return tmp_statement_expression_1_link1;
  }

  else
    return ((struct glx_config *)NULL);
}

// glx_config_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.h line 48
static inline struct glx_config * glx_config_link2(struct wcore_config *wcore_self_link2)
{
  struct glx_config *tmp_statement_expression_1_link2;
  if(!(wcore_self_link2 == ((struct wcore_config *)NULL)))
  {
    const struct wcore_config *__mptr_link2 = wcore_self_link2;
    tmp_statement_expression_1_link2 = (struct glx_config *)((void *)__mptr_link2 - (signed long int)0ul);
    return tmp_statement_expression_1_link2;
  }

  else
    return ((struct glx_config *)NULL);
}

// glx_config_check_context_attrs
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.c line 54
static _Bool glx_config_check_context_attrs(struct glx_display *dpy, struct wcore_config_attrs *attrs)
{
  struct glx_platform *plat;
  plat=glx_platform(dpy->wcore.platform);
  _Bool return_value_wcore_config_attrs_version_eq_4;
  _Bool tmp_if_expr_5;
  _Bool return_value_wcore_config_attrs_version_ge_2;
  _Bool tmp_if_expr_3;
  _Bool return_value_wcore_config_attrs_version_ge_1;
  _Bool return_value_linux_platform_dl_can_open_6;
  _Bool return_value_linux_platform_dl_can_open_7;
  _Bool return_value_linux_platform_dl_can_open_8;
  if(!(attrs->context_debug == (_Bool)0))
  {
    if(dpy->ARB_create_context != (_Bool)0)
      goto __CPROVER_DUMP_L1;

    wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "GLX_ARB_create_context is required in order to request a debug context");
    return (_Bool)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    switch(attrs->context_api)
    {
      case WAFFLE_CONTEXT_OPENGL:
      {
        return_value_wcore_config_attrs_version_eq_4=wcore_config_attrs_version_eq(attrs, 10);
        if(return_value_wcore_config_attrs_version_eq_4 == (_Bool)0)
          tmp_if_expr_5 = !(dpy->ARB_create_context != (_Bool)0) ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_5 = (_Bool)0;
        if(tmp_if_expr_5)
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "GLX_ARB_create_context is required in order to request an OpenGL version not equal to the default value 1.0");
          return (_Bool)0;
        }

        else
        {
          return_value_wcore_config_attrs_version_ge_2=wcore_config_attrs_version_ge(attrs, 32);
          if(!(return_value_wcore_config_attrs_version_ge_2 == (_Bool)0))
            tmp_if_expr_3 = !(dpy->ARB_create_context_profile != (_Bool)0) ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_3 = (_Bool)0;
          if(tmp_if_expr_3)
          {
            wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "GLX_ARB_create_context_profile is required to create a context with version >= 3.2");
            return (_Bool)0;
          }

          else
            return_value_wcore_config_attrs_version_ge_1=wcore_config_attrs_version_ge(attrs, 32);
        }
        if(!(attrs->context_forward_compatible == (_Bool)0))
        {
          if(dpy->ARB_create_context == (_Bool)0)
          {
            wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "GLX_ARB_create_context is required in order to request a forward-compatible context");
            return (_Bool)0;
          }

        }

        return (_Bool)1;
      }
      case WAFFLE_CONTEXT_OPENGL_ES1:
      {
        if(dpy->EXT_create_context_es_profile == (_Bool)0)
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "GLX_EXT_create_context_es_profile is required to create an OpenGL ES1 context");
          return (_Bool)0;
        }

        else
        {
          return_value_linux_platform_dl_can_open_6=linux_platform_dl_can_open(plat->linux, WAFFLE_DL_OPENGL_ES1);
          if(return_value_linux_platform_dl_can_open_6 == (_Bool)0)
          {
            wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "failed to open the OpenGL ES1 library");
            return (_Bool)0;
          }

        }
        return (_Bool)1;
      }
      case WAFFLE_CONTEXT_OPENGL_ES2:
      {
        if(dpy->EXT_create_context_es_profile == (_Bool)0)
        {
          if(dpy->EXT_create_context_es2_profile == (_Bool)0)
          {
            wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "GLX_EXT_create_context_es_profile or GLX_EXT_create_context_es2_profile is required to create an OpenGL ES2 context");
            return (_Bool)0;
          }

        }

        return_value_linux_platform_dl_can_open_7=linux_platform_dl_can_open(plat->linux, WAFFLE_DL_OPENGL_ES2);
        if(return_value_linux_platform_dl_can_open_7 == (_Bool)0)
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "failed to open the OpenGL ES2 library");
          return (_Bool)0;
        }

        return (_Bool)1;
      }
      case WAFFLE_CONTEXT_OPENGL_ES3:
      {
        if(dpy->EXT_create_context_es_profile == (_Bool)0)
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "GLX_EXT_create_context_es_profile is required to create an OpenGL ES3 context");
          return (_Bool)0;
        }

        return_value_linux_platform_dl_can_open_8=linux_platform_dl_can_open(plat->linux, WAFFLE_DL_OPENGL_ES3);
        if(return_value_linux_platform_dl_can_open_8 == (_Bool)0)
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "failed to open the OpenGL ES3 library");
          return (_Bool)0;
        }

        return (_Bool)1;
      }
      default:
      {
        _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.c", 161, "context_api has bad value %#x", attrs->context_api);
        return (_Bool)0;
      }
    }
  }
}

// glx_config_choose
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.c line 167
struct wcore_config * glx_config_choose(struct wcore_platform *wc_plat, struct wcore_display *wc_dpy, struct wcore_config_attrs *attrs)
{
  struct glx_config *self;
  struct glx_display *dpy;
  dpy=glx_display(wc_dpy);
  struct glx_platform *plat;
  plat=glx_platform(wc_plat);
  struct __GLXFBConfigRec **configs = (struct __GLXFBConfigRec **)(void *)0;
  signed int num_configs = 0;
  struct anonymous_11 *vi = (struct anonymous_11 *)(void *)0;
  _Bool ok = (_Bool)1;
  _Bool return_value_glx_config_check_context_attrs_1;
  return_value_glx_config_check_context_attrs_1=glx_config_check_context_attrs(dpy, attrs);
  signed int attrib_list[31l];
  signed int return_value_wrapped_glXGetFBConfigAttrib_3;
  if(return_value_glx_config_check_context_attrs_1 == (_Bool)0)
    return (struct wcore_config *)(void *)0;

  else
  {
    void *return_value_wcore_calloc_2;
    return_value_wcore_calloc_2=wcore_calloc(sizeof(struct glx_config) /*96ul*/ );
    self = (struct glx_config *)return_value_wcore_calloc_2;
    if(self == ((struct glx_config *)NULL))
      return (struct wcore_config *)(void *)0;

    else
    {
      ok=wcore_config_init_link1(&self->wcore, wc_dpy, attrs);
      if(!(ok == (_Bool)0))
      {
        attrib_list[0] = 2;
        attrib_list[1] = attrs->rgba_size;
        attrib_list[2] = 8;
        attrib_list[3] = attrs->red_size;
        attrib_list[4] = 9;
        attrib_list[5] = attrs->green_size;
        attrib_list[6] = 10;
        attrib_list[7] = attrs->blue_size;
        attrib_list[8] = 11;
        attrib_list[9] = attrs->alpha_size;
        attrib_list[10] = 12;
        attrib_list[11] = attrs->depth_size;
        attrib_list[12] = 13;
        attrib_list[13] = attrs->stencil_size;
        attrib_list[14] = 0x186a0;
        attrib_list[15] = (signed int)attrs->sample_buffers;
        attrib_list[16] = 0x186a1;
        attrib_list[17] = attrs->samples;
        attrib_list[18] = 5;
        attrib_list[19] = (signed int)attrs->double_buffered;
        attrib_list[20] = 14;
        attrib_list[21] = (signed int)attrs->accum_buffer;
        attrib_list[22] = 15;
        attrib_list[23] = (signed int)attrs->accum_buffer;
        attrib_list[24] = 16;
        attrib_list[25] = (signed int)attrs->accum_buffer;
        attrib_list[26] = 17;
        attrib_list[27] = (signed int)attrs->accum_buffer;
        attrib_list[28] = 0x8010;
        attrib_list[29] = 0x00000001;
        attrib_list[30] = 0;
        configs=wrapped_glXChooseFBConfig(plat, dpy->x11.xlib, dpy->x11.screen, attrib_list, &num_configs);
        if(configs == ((struct __GLXFBConfigRec **)NULL) || num_configs == 0)
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "glXChooseFBConfig returned no matching configs");
          goto error;
        }

        self->glx_fbconfig = configs[(signed long int)0];
        return_value_wrapped_glXGetFBConfigAttrib_3=wrapped_glXGetFBConfigAttrib(plat, dpy->x11.xlib, self->glx_fbconfig, 0x8013, &self->glx_fbconfig_id);
        ok = !(return_value_wrapped_glXGetFBConfigAttrib_3 != 0);
        if(ok == (_Bool)0)
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "glxGetFBConfigAttrib failed");
          goto error;
        }

        vi=wrapped_glXGetVisualFromFBConfig(plat, dpy->x11.xlib, self->glx_fbconfig);
        if(vi == ((struct anonymous_11 *)NULL))
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "glXGetVisualInfoFromFBConfig failed with GLXFBConfigID=0x%x\n", self->glx_fbconfig_id);
          goto error;
        }

        self->xcb_visual_id = (unsigned int)vi->visualid;
      }

      else
      {

      error:
        ;
        glx_config_destroy(&self->wcore);
        self = (struct glx_config *)(void *)0;
      }

    cleanup:
      ;
      if(!(configs == ((struct __GLXFBConfigRec **)NULL)))
        XFree((void *)configs);

      if(!(vi == ((struct anonymous_11 *)NULL)))
        XFree((void *)vi);

      return &self->wcore;
    }
  }
}

// glx_config_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.c line 40
_Bool glx_config_destroy(struct wcore_config *wc_self)
{
  _Bool ok = (_Bool)1;
  if(wc_self == ((struct wcore_config *)NULL))
    return ok;

  else
  {
    _Bool return_value_wcore_config_teardown_1;
    return_value_wcore_config_teardown_1=wcore_config_teardown_link1(wc_self);
    ok = ((signed int)ok & (signed int)return_value_wcore_config_teardown_1) != 0;
    struct glx_config *return_value_glx_config_2;
    return_value_glx_config_2=glx_config(wc_self);
    free((void *)return_value_glx_config_2);
    return ok;
  }
}

// glx_config_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_config.c line 275
union waffle_native_config * glx_config_get_native(struct wcore_config *wc_self)
{
  struct glx_config *self;
  self=glx_config(wc_self);
  struct glx_display *dpy;
  dpy=glx_display(wc_self->display);
  union waffle_native_config *n_config;
  do
  {
    void *return_value_wcore_malloc_1;
    return_value_wcore_malloc_1=wcore_malloc(sizeof(union waffle_native_config) /*8ul*/  + sizeof(struct waffle_glx_config) /*16ul*/ );
    n_config = (union waffle_native_config *)return_value_wcore_malloc_1;
    if(!(n_config == ((union waffle_native_config *)NULL)))
      n_config->glx = (struct waffle_glx_config *)(void *)(n_config + (signed long int)1);

  }
  while((_Bool)0);
  if(n_config == ((union waffle_native_config *)NULL))
    return (union waffle_native_config *)(void *)0;

  else
  {
    n_config->glx->xlib_display = dpy->x11.xlib;
    n_config->glx->glx_fbconfig = self->glx_fbconfig;
    return n_config;
  }
}

// glx_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.h line 43
static inline struct glx_context * glx_context(struct wcore_context *wcore_self)
{
  struct glx_context *tmp_statement_expression_1;
  if(!(wcore_self == ((struct wcore_context *)NULL)))
  {
    const struct wcore_context *__mptr = wcore_self;
    tmp_statement_expression_1 = (struct glx_context *)((void *)__mptr - (signed long int)0ul);
    return tmp_statement_expression_1;
  }

  else
    return ((struct glx_context *)NULL);
}

// glx_context_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.h line 43
static inline struct glx_context * glx_context_link1(struct wcore_context *wcore_self_link1)
{
  struct glx_context *tmp_statement_expression_1_link1;
  if(!(wcore_self_link1 == ((struct wcore_context *)NULL)))
  {
    const struct wcore_context *__mptr_link1 = wcore_self_link1;
    tmp_statement_expression_1_link1 = (struct glx_context *)((void *)__mptr_link1 - (signed long int)0ul);
    return tmp_statement_expression_1_link1;
  }

  else
    return ((struct glx_context *)NULL);
}

// glx_context_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.c line 203
struct wcore_context * glx_context_create(struct wcore_platform *wc_plat, struct wcore_config *wc_config, struct wcore_context *wc_share_ctx)
{
  struct glx_context *self;
  struct glx_config *config;
  config=glx_config_link1(wc_config);
  struct glx_context *share_ctx;
  share_ctx=glx_context(wc_share_ctx);
  _Bool ok = (_Bool)1;
  void *return_value_wcore_calloc_1;
  return_value_wcore_calloc_1=wcore_calloc(sizeof(struct glx_context) /*24ul*/ );
  self = (struct glx_context *)return_value_wcore_calloc_1;
  if(self == ((struct glx_context *)NULL))
    return (struct wcore_context *)(void *)0;

  else
  {
    ok=wcore_context_init_link1(&self->wcore, wc_config);
    if(!(ok == (_Bool)0))
    {
      self->glx=glx_context_create_native(config, share_ctx);
      if(self->glx == ((struct __GLXcontextRec *)NULL))
        goto error;

      return &self->wcore;
    }

    else
    {

    error:
      ;
      glx_context_destroy(&self->wcore);
      return (struct wcore_context *)(void *)0;
    }
  }
}

// glx_context_create_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.c line 156
static struct __GLXcontextRec * glx_context_create_native(struct glx_config *config, struct glx_context *share_ctx)
{
  struct __GLXcontextRec *ctx;
  struct __GLXcontextRec *real_share_ctx;
  struct __GLXcontextRec *tmp_if_expr_1;
  if(!(share_ctx == ((struct glx_context *)NULL)))
    tmp_if_expr_1 = share_ctx->glx;

  else
    tmp_if_expr_1 = (struct __GLXcontextRec *)(void *)0;
  real_share_ctx = tmp_if_expr_1;
  struct glx_display *dpy;
  dpy=glx_display_link1(config->wcore.display);
  struct glx_platform *platform;
  platform=glx_platform_link1(dpy->wcore.platform);
  if(!(dpy->ARB_create_context == (_Bool)0))
  {
    _Bool ok;
    signed int attrib_list[64l];
    ok=glx_context_fill_attrib_list(config, attrib_list);
    if(ok == (_Bool)0)
      return (struct __GLXcontextRec *)(void *)0;

    ctx=wrapped_glXCreateContextAttribsARB(platform, dpy->x11.xlib, config->glx_fbconfig, real_share_ctx, 1, attrib_list);
    if(ctx == ((struct __GLXcontextRec *)NULL))
    {
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "glXCreateContextAttribsARB failed");
      return (struct __GLXcontextRec *)(void *)0;
    }

  }

  else
  {
    ctx=wrapped_glXCreateNewContext(platform, dpy->x11.xlib, config->glx_fbconfig, 0x8014, real_share_ctx, 1);
    if(ctx == ((struct __GLXcontextRec *)NULL))
    {
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "glXCreateContext failed");
      return (struct __GLXcontextRec *)(void *)0;
    }

  }
  return ctx;
}

// glx_context_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.c line 44
_Bool glx_context_destroy(struct wcore_context *wc_self)
{
  struct glx_context *self;
  struct glx_display *dpy;
  struct glx_platform *platform;
  _Bool ok = (_Bool)1;
  if(wc_self == ((struct wcore_context *)NULL))
    return ok;

  else
  {
    self=glx_context(wc_self);
    dpy=glx_display_link1(wc_self->display);
    platform=glx_platform_link1(wc_self->display->platform);
    if(!(self->glx == ((struct __GLXcontextRec *)NULL)))
      wrapped_glXDestroyContext(platform, dpy->x11.xlib, self->glx);

    _Bool return_value_wcore_context_teardown_1;
    return_value_wcore_context_teardown_1=wcore_context_teardown_link1(wc_self);
    ok = ((signed int)ok & (signed int)return_value_wcore_context_teardown_1) != 0;
    free((void *)self);
    return ok;
  }
}

// glx_context_fill_attrib_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.c line 71
static _Bool glx_context_fill_attrib_list(struct glx_config *config, signed int *attrib_list)
{
  struct wcore_config_attrs *attrs = &config->wcore.attrs;
  signed int i = 0;
  signed int context_flags = 0;
  _Bool return_value_wcore_config_attrs_version_eq_5;
  return_value_wcore_config_attrs_version_eq_5=wcore_config_attrs_version_eq(attrs, 10);
  _Bool tmp_if_expr_6;
  if(!(return_value_wcore_config_attrs_version_eq_5 == (_Bool)0))
    tmp_if_expr_6 = attrs->context_api == WAFFLE_CONTEXT_OPENGL ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_6 = (_Bool)0;
  signed int tmp_post_1;
  signed int tmp_post_2;
  signed int tmp_post_3;
  signed int tmp_post_4;
  if(!tmp_if_expr_6)
  {
    tmp_post_1 = i;
    i = i + 1;
    attrib_list[(signed long int)tmp_post_1] = 0x2091;
    tmp_post_2 = i;
    i = i + 1;
    attrib_list[(signed long int)tmp_post_2] = attrs->context_major_version;
    tmp_post_3 = i;
    i = i + 1;
    attrib_list[(signed long int)tmp_post_3] = 0x2092;
    tmp_post_4 = i;
    i = i + 1;
    attrib_list[(signed long int)tmp_post_4] = attrs->context_minor_version;
  }

  _Bool return_value_wcore_config_attrs_version_ge_11;
  signed int tmp_post_7;
  signed int tmp_post_8;
  signed int tmp_post_9;
  signed int tmp_post_10;
  signed int tmp_post_12;
  signed int tmp_post_13;
  signed int tmp_post_14;
  signed int tmp_post_15;
  signed int tmp_post_16;
  switch(attrs->context_api)
  {
    case WAFFLE_CONTEXT_OPENGL:
    {
      return_value_wcore_config_attrs_version_ge_11=wcore_config_attrs_version_ge(attrs, 32);
      if(!(return_value_wcore_config_attrs_version_ge_11 == (_Bool)0))
        switch(attrs->context_profile)
        {
          case WAFFLE_CONTEXT_CORE_PROFILE:
          {
            tmp_post_7 = i;
            i = i + 1;
            attrib_list[(signed long int)tmp_post_7] = 0x9126;
            tmp_post_8 = i;
            i = i + 1;
            attrib_list[(signed long int)tmp_post_8] = 0x00000001;
            break;
          }
          case WAFFLE_CONTEXT_COMPATIBILITY_PROFILE:
          {
            tmp_post_9 = i;
            i = i + 1;
            attrib_list[(signed long int)tmp_post_9] = 0x9126;
            tmp_post_10 = i;
            i = i + 1;
            attrib_list[(signed long int)tmp_post_10] = 0x00000002;
          }
        }

      if(!(attrs->context_forward_compatible == (_Bool)0))
        context_flags = context_flags | 0x00000002;

      goto __CPROVER_DUMP_L10;
    }
    case WAFFLE_CONTEXT_OPENGL_ES1:

    case WAFFLE_CONTEXT_OPENGL_ES2:

    case WAFFLE_CONTEXT_OPENGL_ES3:
    {
      tmp_post_12 = i;
      i = i + 1;
      attrib_list[(signed long int)tmp_post_12] = 0x9126;
      tmp_post_13 = i;
      i = i + 1;
      attrib_list[(signed long int)tmp_post_13] = 0x00000004;
    }
    default:
    {

    __CPROVER_DUMP_L10:
      ;
      if(!(attrs->context_debug == (_Bool)0))
        context_flags = context_flags | 0x00000001;

      if(!(context_flags == 0))
      {
        tmp_post_14 = i;
        i = i + 1;
        attrib_list[(signed long int)tmp_post_14] = 0x2094;
        tmp_post_15 = i;
        i = i + 1;
        attrib_list[(signed long int)tmp_post_15] = context_flags;
      }

      tmp_post_16 = i;
      i = i + 1;
      attrib_list[(signed long int)tmp_post_16] = 0;
      return (_Bool)1;
    }
  }
}

// glx_context_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_context.c line 232
union waffle_native_context * glx_context_get_native(struct wcore_context *wc_self)
{
  struct glx_context *self;
  self=glx_context(wc_self);
  struct glx_display *dpy;
  dpy=glx_display_link1(wc_self->display);
  union waffle_native_context *n_ctx;
  do
  {
    void *return_value_wcore_malloc_1;
    return_value_wcore_malloc_1=wcore_malloc(sizeof(union waffle_native_context) /*8ul*/  + sizeof(struct waffle_glx_context) /*16ul*/ );
    n_ctx = (union waffle_native_context *)return_value_wcore_malloc_1;
    if(!(n_ctx == ((union waffle_native_context *)NULL)))
      n_ctx->glx = (struct waffle_glx_context *)(void *)(n_ctx + (signed long int)1);

  }
  while((_Bool)0);
  if(n_ctx == ((union waffle_native_context *)NULL))
    return (union waffle_native_context *)(void *)0;

  else
  {
    n_ctx->glx->xlib_display = dpy->x11.xlib;
    n_ctx->glx->glx_context = self->glx;
    return n_ctx;
  }
}

// glx_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.h line 53
static inline struct glx_display * glx_display(struct wcore_display *wcore_self)
{
  struct glx_display *tmp_statement_expression_1;
  if(!(wcore_self == ((struct wcore_display *)NULL)))
  {
    const struct wcore_display *__mptr = wcore_self;
    tmp_statement_expression_1 = (struct glx_display *)((void *)__mptr - (signed long int)0ul);
    return tmp_statement_expression_1;
  }

  else
    return ((struct glx_display *)NULL);
}

// glx_display_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.h line 53
static inline struct glx_display * glx_display_link1(struct wcore_display *wcore_self_link1)
{
  struct glx_display *tmp_statement_expression_1_link1;
  if(!(wcore_self_link1 == ((struct wcore_display *)NULL)))
  {
    const struct wcore_display *__mptr_link1 = wcore_self_link1;
    tmp_statement_expression_1_link1 = (struct glx_display *)((void *)__mptr_link1 - (signed long int)0ul);
    return tmp_statement_expression_1_link1;
  }

  else
    return ((struct glx_display *)NULL);
}

// glx_display_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.h line 53
static inline struct glx_display * glx_display_link2(struct wcore_display *wcore_self_link2)
{
  struct glx_display *tmp_statement_expression_1_link2;
  if(!(wcore_self_link2 == ((struct wcore_display *)NULL)))
  {
    const struct wcore_display *__mptr_link2 = wcore_self_link2;
    tmp_statement_expression_1_link2 = (struct glx_display *)((void *)__mptr_link2 - (signed long int)0ul);
    return tmp_statement_expression_1_link2;
  }

  else
    return ((struct glx_display *)NULL);
}

// glx_display_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.h line 53
static inline struct glx_display * glx_display_link3(struct wcore_display *wcore_self_link3)
{
  struct glx_display *tmp_statement_expression_1_link3;
  if(!(wcore_self_link3 == ((struct wcore_display *)NULL)))
  {
    const struct wcore_display *__mptr_link3 = wcore_self_link3;
    tmp_statement_expression_1_link3 = (struct glx_display *)((void *)__mptr_link3 - (signed long int)0ul);
    return tmp_statement_expression_1_link3;
  }

  else
    return ((struct glx_display *)NULL);
}

// glx_display_link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.h line 53
static inline struct glx_display * glx_display_link4(struct wcore_display *wcore_self_link4)
{
  struct glx_display *tmp_statement_expression_1_link4;
  if(!(wcore_self_link4 == ((struct wcore_display *)NULL)))
  {
    const struct wcore_display *__mptr_link4 = wcore_self_link4;
    tmp_statement_expression_1_link4 = (struct glx_display *)((void *)__mptr_link4 - (signed long int)0ul);
    return tmp_statement_expression_1_link4;
  }

  else
    return ((struct glx_display *)NULL);
}

// glx_display_connect
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.c line 86
struct wcore_display * glx_display_connect(struct wcore_platform *wc_plat, const char *name)
{
  struct glx_display *self;
  _Bool ok = (_Bool)1;
  void *return_value_wcore_calloc_1;
  return_value_wcore_calloc_1=wcore_calloc(sizeof(struct glx_display) /*48ul*/ );
  self = (struct glx_display *)return_value_wcore_calloc_1;
  if(self == ((struct glx_display *)NULL))
    return (struct wcore_display *)(void *)0;

  else
  {
    ok=wcore_display_init(&self->wcore, wc_plat);
    if(!(ok == (_Bool)0))
    {
      ok=x11_display_init(&self->x11, name);
      if(ok == (_Bool)0)
        goto error;

      ok=glx_display_set_extensions(self);
      if(ok == (_Bool)0)
        goto error;

      return &self->wcore;
    }

    else
    {

    error:
      ;
      glx_display_destroy(&self->wcore);
      return (struct wcore_display *)(void *)0;
    }
  }
}

// glx_display_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.c line 37
_Bool glx_display_destroy(struct wcore_display *wc_self)
{
  struct glx_display *self;
  self=glx_display_link2(wc_self);
  _Bool ok = (_Bool)1;
  if(self == ((struct glx_display *)NULL))
    return ok;

  else
  {
    _Bool return_value_x11_display_teardown_1;
    return_value_x11_display_teardown_1=x11_display_teardown(&self->x11);
    ok = ((signed int)ok & (signed int)return_value_x11_display_teardown_1) != 0;
    _Bool return_value_wcore_display_teardown_2;
    return_value_wcore_display_teardown_2=wcore_display_teardown(&self->wcore);
    ok = ((signed int)ok & (signed int)return_value_wcore_display_teardown_2) != 0;
    free((void *)self);
    return ok;
  }
}

// glx_display_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.c line 145
union waffle_native_display * glx_display_get_native(struct wcore_display *wc_self)
{
  struct glx_display *self;
  self=glx_display_link2(wc_self);
  union waffle_native_display *n_dpy;
  do
  {
    void *return_value_wcore_malloc_1;
    return_value_wcore_malloc_1=wcore_malloc(sizeof(union waffle_native_display) /*8ul*/  + sizeof(struct waffle_glx_display) /*8ul*/ );
    n_dpy = (union waffle_native_display *)return_value_wcore_malloc_1;
    if(!(n_dpy == ((union waffle_native_display *)NULL)))
      n_dpy->glx = (struct waffle_glx_display *)(void *)(n_dpy + (signed long int)1);

  }
  while((_Bool)0);
  if(n_dpy == ((union waffle_native_display *)NULL))
    return (union waffle_native_display *)(void *)0;

  else
  {
    n_dpy->glx->xlib_display = self->x11.xlib;
    return n_dpy;
  }
}

// glx_display_set_extensions
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.c line 52
static _Bool glx_display_set_extensions(struct glx_display *self)
{
  struct glx_platform *platform;
  platform=glx_platform_link2(self->wcore.platform);
  const char *s;
  s=wrapped_glXQueryExtensionsString(platform, self->x11.xlib, self->x11.screen);
  if(s == ((const char *)NULL))
  {
    wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "glXQueryExtensionsString failed");
    return (_Bool)0;
  }

  else
  {
    self->ARB_create_context=waffle_is_extension_in_string(s, "GLX_ARB_create_context");
    self->ARB_create_context_profile=waffle_is_extension_in_string(s, "GLX_ARB_create_context_profile");
    self->EXT_create_context_es_profile=waffle_is_extension_in_string(s, "GLX_EXT_create_context_es_profile");
    if(!(self->EXT_create_context_es_profile == (_Bool)0))
      self->EXT_create_context_es2_profile = (_Bool)1;

    else
      self->EXT_create_context_es2_profile=waffle_is_extension_in_string(s, "GLX_EXT_create_context_es2_profile");
    return (_Bool)1;
  }
}

// glx_display_supports_context_api
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.c line 116
_Bool glx_display_supports_context_api(struct wcore_display *wc_self, signed int context_api)
{
  struct glx_display *self;
  self=glx_display_link2(wc_self);
  struct glx_platform *plat;
  plat=glx_platform_link2(wc_self->platform);
  _Bool tmp_if_expr_2;
  _Bool return_value_linux_platform_dl_can_open_1;
  _Bool tmp_if_expr_4;
  _Bool return_value_linux_platform_dl_can_open_3;
  _Bool tmp_if_expr_6;
  _Bool return_value_linux_platform_dl_can_open_5;
  switch(context_api)
  {
    case WAFFLE_CONTEXT_OPENGL:
      return (_Bool)1;
    case WAFFLE_CONTEXT_OPENGL_ES1:
    {
      if(!(self->EXT_create_context_es_profile == (_Bool)0))
      {
        return_value_linux_platform_dl_can_open_1=linux_platform_dl_can_open(plat->linux, WAFFLE_DL_OPENGL_ES1);
        tmp_if_expr_2 = return_value_linux_platform_dl_can_open_1 != (_Bool)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_2 = (_Bool)0;
      return tmp_if_expr_2;
    }
    case WAFFLE_CONTEXT_OPENGL_ES2:
    {
      if(!(self->EXT_create_context_es2_profile == (_Bool)0))
      {
        return_value_linux_platform_dl_can_open_3=linux_platform_dl_can_open(plat->linux, WAFFLE_DL_OPENGL_ES2);
        tmp_if_expr_4 = return_value_linux_platform_dl_can_open_3 != (_Bool)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_4 = (_Bool)0;
      return tmp_if_expr_4;
    }
    case WAFFLE_CONTEXT_OPENGL_ES3:
    {
      if(!(self->EXT_create_context_es_profile == (_Bool)0))
      {
        return_value_linux_platform_dl_can_open_5=linux_platform_dl_can_open(plat->linux, WAFFLE_DL_OPENGL_ES3);
        tmp_if_expr_6 = return_value_linux_platform_dl_can_open_5 != (_Bool)0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_6 = (_Bool)0;
      return tmp_if_expr_6;
    }
    default:
    {
      _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_display.c", 139, "waffle_context_api has bad value %#x", context_api);
      return (_Bool)0;
    }
  }
}

// glx_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.h line 64
static inline struct glx_platform * glx_platform(struct wcore_platform *wcore_self)
{
  struct glx_platform *tmp_statement_expression_1;
  if(!(wcore_self == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr = wcore_self;
    tmp_statement_expression_1 = (struct glx_platform *)((void *)__mptr - (signed long int)0ul);
    return tmp_statement_expression_1;
  }

  else
    return ((struct glx_platform *)NULL);
}

// glx_platform_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.h line 64
static inline struct glx_platform * glx_platform_link1(struct wcore_platform *wcore_self_link1)
{
  struct glx_platform *tmp_statement_expression_1_link1;
  if(!(wcore_self_link1 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr_link1 = wcore_self_link1;
    tmp_statement_expression_1_link1 = (struct glx_platform *)((void *)__mptr_link1 - (signed long int)0ul);
    return tmp_statement_expression_1_link1;
  }

  else
    return ((struct glx_platform *)NULL);
}

// glx_platform_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.h line 64
static inline struct glx_platform * glx_platform_link2(struct wcore_platform *wcore_self_link2)
{
  struct glx_platform *tmp_statement_expression_1_link2;
  if(!(wcore_self_link2 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr_link2 = wcore_self_link2;
    tmp_statement_expression_1_link2 = (struct glx_platform *)((void *)__mptr_link2 - (signed long int)0ul);
    return tmp_statement_expression_1_link2;
  }

  else
    return ((struct glx_platform *)NULL);
}

// glx_platform_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.h line 64
static inline struct glx_platform * glx_platform_link3(struct wcore_platform *wcore_self_link3)
{
  struct glx_platform *tmp_statement_expression_1_link3;
  if(!(wcore_self_link3 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr_link3 = wcore_self_link3;
    tmp_statement_expression_1_link3 = (struct glx_platform *)((void *)__mptr_link3 - (signed long int)0ul);
    return tmp_statement_expression_1_link3;
  }

  else
    return ((struct glx_platform *)NULL);
}

// glx_platform_link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.h line 64
static inline struct glx_platform * glx_platform_link4(struct wcore_platform *wcore_self_link4)
{
  struct glx_platform *tmp_statement_expression_1_link4;
  if(!(wcore_self_link4 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr_link4 = wcore_self_link4;
    tmp_statement_expression_1_link4 = (struct glx_platform *)((void *)__mptr_link4 - (signed long int)0ul);
    return tmp_statement_expression_1_link4;
  }

  else
    return ((struct glx_platform *)NULL);
}

// glx_platform_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_init.c line 33
struct wcore_platform * glx_platform_create(void)
{
  struct glx_platform *self;
  _Bool ok = (_Bool)1;
  void *return_value_wcore_calloc_1;
  return_value_wcore_calloc_1=wcore_calloc(sizeof(struct glx_platform) /*104ul*/ );
  self = (struct glx_platform *)return_value_wcore_calloc_1;
  void *return_value_dlsym_3;
  void *return_value_dlsym_5;
  void *return_value_dlsym_7;
  void *return_value_dlsym_9;
  void *return_value_dlsym_11;
  void *return_value_dlsym_13;
  void *return_value_dlsym_15;
  void *return_value_dlsym_17;
  void *return_value_dlsym_19;
  void *return_value;
  if(self == ((struct glx_platform *)NULL))
    return (struct wcore_platform *)(void *)0;

  else
  {
    ok=wcore_platform_init_link1(&self->wcore);
    if(!(ok == (_Bool)0))
    {
      self->glxHandle=dlopen(libGL_filename, 0x00001 | 0);
      if(self->glxHandle == NULL)
      {
        char *return_value_dlerror_2;
        return_value_dlerror_2=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlopen(\"%s\") failed: %s", libGL_filename, return_value_dlerror_2);
        goto error;
      }

      return_value_dlsym_3=dlsym(self->glxHandle, "glXCreateNewContext");
      self->glXCreateNewContext = (struct __GLXcontextRec * (*)(struct _XDisplay *, struct __GLXFBConfigRec *, signed int, struct __GLXcontextRec *, signed int))return_value_dlsym_3;
      if(self->glXCreateNewContext == ((struct __GLXcontextRec * (*)(struct _XDisplay *, struct __GLXFBConfigRec *, signed int, struct __GLXcontextRec *, signed int))NULL))
      {
        char *return_value_dlerror_4;
        return_value_dlerror_4=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"glXCreateNewContext\") failed: %s", libGL_filename, return_value_dlerror_4);
        goto error;
      }

      return_value_dlsym_5=dlsym(self->glxHandle, "glXDestroyContext");
      self->glXDestroyContext = (void (*)(struct _XDisplay *, struct __GLXcontextRec *))return_value_dlsym_5;
      if(self->glXDestroyContext == ((void (*)(struct _XDisplay *, struct __GLXcontextRec *))NULL))
      {
        char *return_value_dlerror_6;
        return_value_dlerror_6=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"glXDestroyContext\") failed: %s", libGL_filename, return_value_dlerror_6);
        goto error;
      }

      return_value_dlsym_7=dlsym(self->glxHandle, "glXMakeCurrent");
      self->glXMakeCurrent = (signed int (*)(struct _XDisplay *, unsigned long int, struct __GLXcontextRec *))return_value_dlsym_7;
      if(self->glXMakeCurrent == ((signed int (*)(struct _XDisplay *, unsigned long int, struct __GLXcontextRec *))NULL))
      {
        char *return_value_dlerror_8;
        return_value_dlerror_8=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"glXMakeCurrent\") failed: %s", libGL_filename, return_value_dlerror_8);
        goto error;
      }

      return_value_dlsym_9=dlsym(self->glxHandle, "glXQueryExtensionsString");
      self->glXQueryExtensionsString = (const char * (*)(struct _XDisplay *, signed int))return_value_dlsym_9;
      if(self->glXQueryExtensionsString == ((const char * (*)(struct _XDisplay *, signed int))NULL))
      {
        char *return_value_dlerror_10;
        return_value_dlerror_10=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"glXQueryExtensionsString\") failed: %s", libGL_filename, return_value_dlerror_10);
        goto error;
      }

      return_value_dlsym_11=dlsym(self->glxHandle, "glXGetProcAddress");
      self->glXGetProcAddress = (void * (*)(const unsigned char *))return_value_dlsym_11;
      if(self->glXGetProcAddress == ((void * (*)(const unsigned char *))NULL))
      {
        char *return_value_dlerror_12;
        return_value_dlerror_12=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"glXGetProcAddress\") failed: %s", libGL_filename, return_value_dlerror_12);
        goto error;
      }

      return_value_dlsym_13=dlsym(self->glxHandle, "glXGetVisualFromFBConfig");
      self->glXGetVisualFromFBConfig = (struct anonymous_11 * (*)(struct _XDisplay *, struct __GLXFBConfigRec *))return_value_dlsym_13;
      if(self->glXGetVisualFromFBConfig == ((struct anonymous_11 * (*)(struct _XDisplay *, struct __GLXFBConfigRec *))NULL))
      {
        char *return_value_dlerror_14;
        return_value_dlerror_14=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"glXGetVisualFromFBConfig\") failed: %s", libGL_filename, return_value_dlerror_14);
        goto error;
      }

      return_value_dlsym_15=dlsym(self->glxHandle, "glXGetFBConfigAttrib");
      self->glXGetFBConfigAttrib = (signed int (*)(struct _XDisplay *, struct __GLXFBConfigRec *, signed int, signed int *))return_value_dlsym_15;
      if(self->glXGetFBConfigAttrib == ((signed int (*)(struct _XDisplay *, struct __GLXFBConfigRec *, signed int, signed int *))NULL))
      {
        char *return_value_dlerror_16;
        return_value_dlerror_16=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"glXGetFBConfigAttrib\") failed: %s", libGL_filename, return_value_dlerror_16);
        goto error;
      }

      return_value_dlsym_17=dlsym(self->glxHandle, "glXChooseFBConfig");
      self->glXChooseFBConfig = (struct __GLXFBConfigRec ** (*)(struct _XDisplay *, signed int, const signed int *, signed int *))return_value_dlsym_17;
      if(self->glXChooseFBConfig == ((struct __GLXFBConfigRec ** (*)(struct _XDisplay *, signed int, const signed int *, signed int *))NULL))
      {
        char *return_value_dlerror_18;
        return_value_dlerror_18=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"glXChooseFBConfig\") failed: %s", libGL_filename, return_value_dlerror_18);
        goto error;
      }

      return_value_dlsym_19=dlsym(self->glxHandle, "glXSwapBuffers");
      self->glXSwapBuffers = (void (*)(struct _XDisplay *, unsigned long int))return_value_dlsym_19;
      if(self->glXSwapBuffers == ((void (*)(struct _XDisplay *, unsigned long int))NULL))
      {
        char *return_value_dlerror_20;
        return_value_dlerror_20=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"glXSwapBuffers\") failed: %s", libGL_filename, return_value_dlerror_20);
        goto error;
      }

      self->linux=linux_platform_create();
      if(self->linux == ((struct linux_platform *)NULL))
        goto error;

      return_value=self->glXGetProcAddress((const unsigned char *)"glXCreateContextAttribsARB");
      self->glXCreateContextAttribsARB = (struct __GLXcontextRec * (*)(struct _XDisplay *, struct __GLXFBConfigRec *, struct __GLXcontextRec *, signed int, const signed int *))return_value;
      self->wcore.vtbl = &glx_platform_vtbl;
      return &self->wcore;
    }

    else
    {

    error:
      ;
      glx_platform_destroy(&self->wcore);
      return (struct wcore_platform *)(void *)0;
    }
  }
}

// glx_platform_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.c line 45
static _Bool glx_platform_destroy(struct wcore_platform *wc_self)
{
  struct glx_platform *self;
  self=glx_platform_link3(wc_self);
  _Bool ok = (_Bool)1;
  signed int error = 0;
  _Bool return_value_linux_platform_destroy_1;
  if(self == ((struct glx_platform *)NULL))
    return (_Bool)1;

  else
  {
    if(!(self->linux == ((struct linux_platform *)NULL)))
    {
      return_value_linux_platform_destroy_1=linux_platform_destroy(self->linux);
      ok = ((signed int)ok & (signed int)return_value_linux_platform_destroy_1) != 0;
    }

    if(!(self->glxHandle == NULL))
    {
      error=dlclose(self->glxHandle);
      if(!(error == 0))
      {
        ok = ((signed int)ok & 0) != 0;
        char *return_value_dlerror_2;
        return_value_dlerror_2=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "dlclose(\"%s\") failed: %s", libGL_filename, return_value_dlerror_2);
      }

    }

    _Bool return_value_wcore_platform_teardown_3;
    return_value_wcore_platform_teardown_3=wcore_platform_teardown_link1(wc_self);
    ok = ((signed int)ok & (signed int)return_value_wcore_platform_teardown_3) != 0;
    free((void *)self);
    return ok;
  }
}

// glx_platform_dl_can_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.c line 160
static _Bool glx_platform_dl_can_open(struct wcore_platform *wc_self, signed int waffle_dl)
{
  struct glx_platform *return_value_glx_platform_1;
  return_value_glx_platform_1=glx_platform_link3(wc_self);
  _Bool return_value_linux_platform_dl_can_open_2;
  return_value_linux_platform_dl_can_open_2=linux_platform_dl_can_open(return_value_glx_platform_1->linux, waffle_dl);
  return return_value_linux_platform_dl_can_open_2;
}

// glx_platform_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.c line 168
static void * glx_platform_dl_sym(struct wcore_platform *wc_self, signed int waffle_dl, const char *name)
{
  struct glx_platform *return_value_glx_platform_1;
  return_value_glx_platform_1=glx_platform_link3(wc_self);
  void *return_value_linux_platform_dl_sym_2;
  return_value_linux_platform_dl_sym_2=linux_platform_dl_sym(return_value_glx_platform_1->linux, waffle_dl, name);
  return return_value_linux_platform_dl_sym_2;
}

// glx_platform_get_proc_address
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.c line 152
static void * glx_platform_get_proc_address(struct wcore_platform *wc_self, const char *name)
{
  struct glx_platform *self;
  self=glx_platform_link3(wc_self);
  void *return_value;
  return_value=self->glXGetProcAddress((const unsigned char *)name);
  return return_value;
}

// glx_platform_make_current
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_platform.c line 132
static _Bool glx_platform_make_current(struct wcore_platform *wc_self, struct wcore_display *wc_dpy, struct wcore_window *wc_window, struct wcore_context *wc_ctx)
{
  struct glx_platform *self;
  self=glx_platform_link3(wc_self);
  struct _XDisplay *dpy;
  struct glx_display *return_value_glx_display_1;
  return_value_glx_display_1=glx_display_link3(wc_dpy);
  dpy = return_value_glx_display_1->x11.xlib;
  unsigned long int win;
  unsigned int tmp_if_expr_3;
  struct glx_window *return_value_glx_window_2;
  if(!(wc_window == ((struct wcore_window *)NULL)))
  {
    return_value_glx_window_2=glx_window(wc_window);
    tmp_if_expr_3 = return_value_glx_window_2->x11.xcb;
  }

  else
    tmp_if_expr_3 = (unsigned int)0;
  win = (unsigned long int)tmp_if_expr_3;
  struct __GLXcontextRec *ctx;
  struct __GLXcontextRec *tmp_if_expr_5;
  struct glx_context *return_value_glx_context_4;
  if(!(wc_ctx == ((struct wcore_context *)NULL)))
  {
    return_value_glx_context_4=glx_context_link1(wc_ctx);
    tmp_if_expr_5 = return_value_glx_context_4->glx;
  }

  else
    tmp_if_expr_5 = (struct __GLXcontextRec *)(void *)0;
  ctx = tmp_if_expr_5;
  _Bool ok;
  signed int return_value_wrapped_glXMakeCurrent_6;
  return_value_wrapped_glXMakeCurrent_6=wrapped_glXMakeCurrent(self, dpy, win, ctx);
  ok = (_Bool)return_value_wrapped_glXMakeCurrent_6;
  if(ok == (_Bool)0)
    wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "glXMakeCurrent failed");

  return ok;
}

// glx_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 42
static inline struct glx_window * glx_window(struct wcore_window *wcore_self)
{
  struct glx_window *tmp_statement_expression_1;
  if(!(wcore_self == ((struct wcore_window *)NULL)))
  {
    const struct wcore_window *__mptr = wcore_self;
    tmp_statement_expression_1 = (struct glx_window *)((void *)__mptr - (signed long int)0ul);
    return tmp_statement_expression_1;
  }

  else
    return ((struct glx_window *)NULL);
}

// glx_window_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 42
static inline struct glx_window * glx_window_link1(struct wcore_window *wcore_self_link1)
{
  struct glx_window *tmp_statement_expression_1_link1;
  if(!(wcore_self_link1 == ((struct wcore_window *)NULL)))
  {
    const struct wcore_window *__mptr_link1 = wcore_self_link1;
    tmp_statement_expression_1_link1 = (struct glx_window *)((void *)__mptr_link1 - (signed long int)0ul);
    return tmp_statement_expression_1_link1;
  }

  else
    return ((struct glx_window *)NULL);
}

// glx_window_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 47
struct wcore_window * glx_window_create(struct wcore_platform *wc_plat, struct wcore_config *wc_config, signed int width, signed int height)
{
  struct glx_window *self;
  struct glx_display *dpy;
  dpy=glx_display_link4(wc_config->display);
  struct glx_config *config;
  config=glx_config_link2(wc_config);
  _Bool ok = (_Bool)1;
  void *return_value_wcore_calloc_1;
  return_value_wcore_calloc_1=wcore_calloc(sizeof(struct glx_window) /*32ul*/ );
  self = (struct glx_window *)return_value_wcore_calloc_1;
  if(self == ((struct glx_window *)NULL))
    return (struct wcore_window *)(void *)0;

  else
  {
    ok=wcore_window_init_link1(&self->wcore, wc_config);
    if(!(ok == (_Bool)0))
    {
      ok=x11_window_init(&self->x11, &dpy->x11, config->xcb_visual_id, width, height);
      if(ok == (_Bool)0)
        goto error;

      return &self->wcore;
    }

    else
    {

    error:
      ;
      glx_window_destroy(&self->wcore);
      return (struct wcore_window *)(void *)0;
    }
  }
}

// glx_window_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 53
_Bool glx_window_destroy(struct wcore_window *wc_self)
{
  struct glx_window *self;
  self=glx_window_link1(wc_self);
  _Bool ok = (_Bool)1;
  if(wc_self == ((struct wcore_window *)NULL))
    return ok;

  else
  {
    _Bool return_value_x11_window_teardown_1;
    return_value_x11_window_teardown_1=x11_window_teardown(&self->x11);
    ok = ((signed int)ok & (signed int)return_value_x11_window_teardown_1) != 0;
    _Bool return_value_wcore_window_teardown_2;
    return_value_wcore_window_teardown_2=wcore_window_teardown_link1(wc_self);
    ok = ((signed int)ok & (signed int)return_value_wcore_window_teardown_2) != 0;
    free((void *)self);
    return ok;
  }
}

// glx_window_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 66
union waffle_native_window * glx_window_get_native(struct wcore_window *wc_self)
{
  struct glx_window *self;
  self=glx_window_link1(wc_self);
  struct glx_display *dpy;
  dpy=glx_display_link4(wc_self->display);
  union waffle_native_window *n_window;
  do
  {
    void *return_value_wcore_malloc_1;
    return_value_wcore_malloc_1=wcore_malloc(sizeof(union waffle_native_window) /*8ul*/  + sizeof(struct waffle_glx_window) /*16ul*/ );
    n_window = (union waffle_native_window *)return_value_wcore_malloc_1;
    if(!(n_window == ((union waffle_native_window *)NULL)))
      n_window->glx = (struct waffle_glx_window *)(void *)(n_window + (signed long int)1);

  }
  while((_Bool)0);
  if(n_window == ((union waffle_native_window *)NULL))
    return (union waffle_native_window *)(void *)0;

  else
  {
    n_window->glx->xlib_display = dpy->x11.xlib;
    n_window->glx->xlib_window = (unsigned long int)self->x11.xcb;
    return n_window;
  }
}

// glx_window_resize
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 59
_Bool glx_window_resize(struct wcore_window *wc_self, signed int width, signed int height)
{
  struct glx_window *return_value_glx_window_1;
  return_value_glx_window_1=glx_window_link1(wc_self);
  _Bool return_value_x11_window_resize_2;
  return_value_x11_window_resize_2=x11_window_resize(&return_value_glx_window_1->x11, width, height);
  return return_value_x11_window_resize_2;
}

// glx_window_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 56
_Bool glx_window_show(struct wcore_window *wc_self)
{
  struct glx_window *return_value_glx_window_1;
  return_value_glx_window_1=glx_window_link1(wc_self);
  _Bool return_value_x11_window_show_2;
  return_value_x11_window_show_2=x11_window_show(&return_value_glx_window_1->x11);
  return return_value_x11_window_show_2;
}

// glx_window_swap_buffers
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_window.h line 63
_Bool glx_window_swap_buffers(struct wcore_window *wc_self)
{
  struct glx_window *self;
  self=glx_window_link1(wc_self);
  struct glx_display *dpy;
  dpy=glx_display_link4(wc_self->display);
  struct glx_platform *plat;
  plat=glx_platform_link4(wc_self->display->platform);
  wrapped_glXSwapBuffers(plat, dpy->x11.xlib, (unsigned long int)self->x11.xcb);
  return (_Bool)1;
}

// impl_thrd_routine
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 65
static void * impl_thrd_routine(void *p)
{
  struct impl_thrd_param pack = *((struct impl_thrd_param *)p);
  free(p);
  signed int return_value;
  return_value=pack.func(pack.arg);
  return (void *)(signed long int)return_value;
}

// linux_dl_close
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_dl.c line 103
_Bool linux_dl_close(struct linux_dl *self)
{
  signed int error = 0;
  if(self == ((struct linux_dl *)NULL))
    return (_Bool)1;

  else
  {
    if(!(self->dl == NULL))
    {
      error=dlclose(self->dl);
      if(!(error == 0))
      {
        char *return_value_dlerror_1;
        return_value_dlerror_1=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "dlclose(libname=\"%s\") failed: %s", self->name, return_value_dlerror_1);
      }

    }

    free((void *)self);
    return error == 0;
  }
}

// linux_dl_get_name
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_dl.c line 47
static const char * linux_dl_get_name(signed int waffle_dl)
{
  switch(waffle_dl)
  {
    case WAFFLE_DL_OPENGL:
      return "libGL.so.1";
    case WAFFLE_DL_OPENGL_ES1:
      return "libGLESv1_CM.so.1";
    case WAFFLE_DL_OPENGL_ES2:

    case WAFFLE_DL_OPENGL_ES3:
      return "libGLESv2.so.2";
    default:
    {
      _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_dl.c", 72, "waffle_dl has bad value %#x", waffle_dl);
      return (const char *)(void *)0;
    }
  }
}

// linux_dl_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_dl.c line 78
struct linux_dl * linux_dl_open(signed int waffle_dl)
{
  struct linux_dl *self;
  void *return_value_wcore_calloc_1;
  return_value_wcore_calloc_1=wcore_calloc(sizeof(struct linux_dl) /*16ul*/ );
  self = (struct linux_dl *)return_value_wcore_calloc_1;
  if(self == ((struct linux_dl *)NULL))
    return (struct linux_dl *)(void *)0;

  else
  {
    self->name=linux_dl_get_name(waffle_dl);
    if(!(self->name == ((const char *)NULL)))
    {
      self->dl=dlopen(self->name, 0x00001);
      if(self->dl == NULL)
      {
        char *return_value_dlerror_2;
        return_value_dlerror_2=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "dlopen(\"%s\") failed: %s", self->name, return_value_dlerror_2);
        goto error;
      }

      return self;
    }

    else
    {

    error:
      ;
      free((void *)self);
      return (struct linux_dl *)(void *)0;
    }
  }
}

// linux_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_dl.c line 124
void * linux_dl_sym(struct linux_dl *self, const char *symbol)
{
  dlerror();
  void *sym;
  sym=dlsym(self->dl, symbol);
  const char *error;
  error=dlerror();
  if(!(error == ((const char *)NULL)))
  {
    wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "dlsym(libname=\"%s\", \"%s\") failed: %s", self->name, symbol, error);
    return (void *)0;
  }

  else
    return sym;
}

// linux_platform_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_platform.h line 34
struct linux_platform * linux_platform_create(void)
{
  void *return_value_wcore_calloc_1;
  return_value_wcore_calloc_1=wcore_calloc(sizeof(struct linux_platform) /*24ul*/ );
  return (struct linux_platform *)return_value_wcore_calloc_1;
}

// linux_platform_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_platform.h line 37
_Bool linux_platform_destroy(struct linux_platform *self)
{
  _Bool ok = (_Bool)1;
  if(self == ((struct linux_platform *)NULL))
    return (_Bool)1;

  else
  {
    _Bool return_value_linux_dl_close_1;
    return_value_linux_dl_close_1=linux_dl_close(self->libgl);
    ok = ((signed int)ok & (signed int)return_value_linux_dl_close_1) != 0;
    _Bool return_value_linux_dl_close_2;
    return_value_linux_dl_close_2=linux_dl_close(self->libgles1);
    ok = ((signed int)ok & (signed int)return_value_linux_dl_close_2) != 0;
    _Bool return_value_linux_dl_close_3;
    return_value_linux_dl_close_3=linux_dl_close(self->libgles2);
    ok = ((signed int)ok & (signed int)return_value_linux_dl_close_3) != 0;
    free((void *)self);
    return ok;
  }
}

// linux_platform_dl_can_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_platform.h line 41
_Bool linux_platform_dl_can_open(struct linux_platform *self, signed int waffle_dl)
{
  struct linux_dl *dl = (struct linux_dl *)(void *)0;
  do
  {
    _wcore_error_disable();
    dl=linux_platform_get_dl(self, waffle_dl);
    _wcore_error_enable();
  }
  while((_Bool)0);
  return dl != (struct linux_dl *)(void *)0;
}

// linux_platform_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_platform.h line 46
void * linux_platform_dl_sym(struct linux_platform *self, signed int waffle_dl, const char *name)
{
  struct linux_dl *dl;
  dl=linux_platform_get_dl(self, waffle_dl);
  if(dl == ((struct linux_dl *)NULL))
    return (void *)0;

  else
  {
    void *return_value_linux_dl_sym_1;
    return_value_linux_dl_sym_1=linux_dl_sym(dl, name);
    return return_value_linux_dl_sym_1;
  }
}

// linux_platform_get_dl
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_platform.c line 64
static struct linux_dl * linux_platform_get_dl(struct linux_platform *self, signed int waffle_dl)
{
  struct linux_dl **dl;
  switch(waffle_dl)
  {
    case WAFFLE_DL_OPENGL:
    {
      dl = &self->libgl;
      break;
    }
    case WAFFLE_DL_OPENGL_ES1:
    {
      dl = &self->libgles1;
      break;
    }
    case WAFFLE_DL_OPENGL_ES2:
    {
      dl = &self->libgles2;
      break;
    }
    case WAFFLE_DL_OPENGL_ES3:
    {
      dl = &self->libgles2;
      break;
    }
    default:
    {
      _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/linux/linux_platform.c", 76, "waffle_dl has bad value %#x", waffle_dl);
      return (struct linux_dl *)(void *)0;
    }
  }
  if(*dl == ((struct linux_dl *)NULL))
    *dl=linux_dl_open(waffle_dl);

  return *dl;
}

// main
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 1027
signed int main(signed int argc, char **argv)
{
  _Bool ok;
  signed int i;
  struct options opts = { .platform=0, .context_api=0, .context_profile=0, .context_major=0,
    .context_minor=0, .verbose=(_Bool)0, .context_forward_compatible=(_Bool)0,
    .context_debug=(_Bool)0,
    .dl=0 };
  signed int init_attrib_list[3l];
  struct waffle_display *dpy;
  struct waffle_config *config;
  struct waffle_context *ctx;
  struct waffle_window *window;
  ok=parse_args(argc, argv, &opts);
  if(ok == (_Bool)0)
    exit(1);

  i = 0;
  signed int tmp_post_1 = i;
  i = i + 1;
  init_attrib_list[(signed long int)tmp_post_1] = WAFFLE_PLATFORM;
  signed int tmp_post_2 = i;
  i = i + 1;
  init_attrib_list[(signed long int)tmp_post_2] = opts.platform;
  signed int tmp_post_3 = i;
  i = i + 1;
  init_attrib_list[(signed long int)tmp_post_3] = WAFFLE_NONE;
  ok=waffle_init(init_attrib_list);
  if(ok == (_Bool)0)
    error_waffle();

  dpy=waffle_display_connect((const char *)(void *)0);
  if(dpy == ((struct waffle_display *)NULL))
    error_waffle();

  _Bool return_value_waffle_display_supports_context_api_5;
  return_value_waffle_display_supports_context_api_5=waffle_display_supports_context_api(dpy, opts.context_api);
  if(return_value_waffle_display_supports_context_api_5 == (_Bool)0)
  {
    const char *return_value_waffle_enum_to_string_4;
    return_value_waffle_enum_to_string_4=waffle_enum_to_string(opts.context_api);
    error_printf("Wflinfo", "Display does not support %s", return_value_waffle_enum_to_string_4);
  }

  void *return_value_waffle_dl_sym_6;
  return_value_waffle_dl_sym_6=waffle_dl_sym(opts.dl, "glGetError");
  glGetError = (unsigned int (*)(void))return_value_waffle_dl_sym_6;
  if(glGetError == ((unsigned int (*)(void))NULL))
    error_get_gl_symbol("glGetError");

  void *return_value_waffle_dl_sym_7;
  return_value_waffle_dl_sym_7=waffle_dl_sym(opts.dl, "glGetIntegerv");
  glGetIntegerv = (void (*)(unsigned int, unsigned int *))return_value_waffle_dl_sym_7;
  if(glGetIntegerv == ((void (*)(unsigned int, unsigned int *))NULL))
    error_get_gl_symbol("glGetIntegerv");

  void *return_value_waffle_dl_sym_8;
  return_value_waffle_dl_sym_8=waffle_dl_sym(opts.dl, "glGetString");
  glGetString = (const unsigned char * (*)(unsigned int))return_value_waffle_dl_sym_8;
  if(glGetString == ((const unsigned char * (*)(unsigned int))NULL))
    error_get_gl_symbol("glGetString");

  struct wflinfo_config_attrs config_attrs = { .api=(enum waffle_enum)opts.context_api, .profile=(enum waffle_enum)opts.context_profile,
    .major=opts.context_major,
    .minor=opts.context_minor, .forward_compat=opts.context_forward_compatible,
    .debug=opts.context_debug };
  wflinfo_create_context(dpy, config_attrs, &ctx, &config);
  window=waffle_window_create(config, 320, 240);
  if(window == ((struct waffle_window *)NULL))
    error_waffle();

  ok=waffle_make_current(dpy, window, ctx);
  if(ok == (_Bool)0)
    error_waffle();

  void *return_value_waffle_dl_sym_9;
  return_value_waffle_dl_sym_9=waffle_dl_sym(opts.dl, "glGetStringi");
  glGetStringi = (const unsigned char * (*)(unsigned int, unsigned int))return_value_waffle_dl_sym_9;
  if(glGetStringi == ((const unsigned char * (*)(unsigned int, unsigned int))NULL))
  {
    void *return_value_waffle_get_proc_address_10;
    return_value_waffle_get_proc_address_10=waffle_get_proc_address("glGetStringi");
    glGetStringi = (const unsigned char * (*)(unsigned int, unsigned int))return_value_waffle_get_proc_address_10;
  }

  ok=print_wflinfo(&opts);
  if(ok == (_Bool)0)
    error_waffle();

  ok=waffle_make_current(dpy, (struct waffle_window *)(void *)0, (struct waffle_context *)(void *)0);
  if(ok == (_Bool)0)
    error_waffle();

  ok=waffle_window_destroy(window);
  if(ok == (_Bool)0)
    error_waffle();

  ok=waffle_context_destroy(ctx);
  if(ok == (_Bool)0)
    error_waffle();

  ok=waffle_config_destroy(config);
  if(ok == (_Bool)0)
    error_waffle();

  ok=waffle_display_disconnect(dpy);
  if(ok == (_Bool)0)
    error_waffle();

  return 0;
}

// mtx_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 136
void mtx_destroy(union anonymous_7 *mtx)
{
  pthread_mutex_destroy(mtx);
}

// mtx_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 143
signed int mtx_init(union anonymous_7 *mtx, signed int type)
{
  union anonymous_5 attr;
  if(mtx == ((union anonymous_7 *)NULL))
    return 2;

  else
    if(!(type == 0) && !(type == 1) && !(type == 2) && !(type == 4) && !(type == 5) && !(type == 6))
      return 2;

    else
    {
      pthread_mutexattr_init(&attr);
      if(!((4 & type) == 0))
        pthread_mutexattr_settype(&attr, 1);

      pthread_mutex_init(mtx, &attr);
      pthread_mutexattr_destroy(&attr);
      return 0;
    }
}

// mtx_lock
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 158
signed int mtx_lock(union anonymous_7 *mtx)
{
  if(mtx == ((union anonymous_7 *)NULL))
    return 2;

  else
  {
    pthread_mutex_lock(mtx);
    return 0;
  }
}

// mtx_timedlock
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 174
signed int mtx_timedlock(union anonymous_7 *mtx, const struct xtime *xt)
{
  if(mtx == ((union anonymous_7 *)NULL) || xt == ((const struct xtime *)NULL))
    return 2;

  else
  {
    struct timespec ts;
    signed int rt;
    ts.tv_sec = xt->sec;
    ts.tv_nsec = xt->nsec;
    rt=pthread_mutex_timedlock(mtx, &ts);
    if(rt == 0)
      return 0;

    else
      return rt == 110 ? 3 : 2;
  }
}

// mtx_trylock
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 203
signed int mtx_trylock(union anonymous_7 *mtx)
{
  if(mtx == ((union anonymous_7 *)NULL))
    return 2;

  else
  {
    signed int return_value_pthread_mutex_trylock_1;
    return_value_pthread_mutex_trylock_1=pthread_mutex_trylock(mtx);
    return return_value_pthread_mutex_trylock_1 == 0 ? 0 : 3;
  }
}

// mtx_unlock
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 161
signed int mtx_unlock(union anonymous_7 *mtx)
{
  if(mtx == ((union anonymous_7 *)NULL))
    return 2;

  else
  {
    pthread_mutex_unlock(mtx);
    return 0;
  }
}

// parse_args
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 320
static _Bool parse_args(signed int argc, char **argv, struct options *opts)
{
  _Bool ok;
  _Bool loop_get_opt = (_Bool)1;
  opts->context_profile = WAFFLE_NONE;
  opts->context_major = WAFFLE_DONT_CARE;
  opts->context_minor = WAFFLE_DONT_CARE;
  opterr = 0;
  signed int tmp_statement_expression_5;
  signed int tmp_statement_expression_3;
  signed int tmp_statement_expression_1;
  while(!(loop_get_opt == (_Bool)0))
  {
    signed int opt;
    opt=getopt_long(argc, argv, "a:hp:vV:", get_opts, (signed int *)(void *)0);
    if(!(opt == -1))
    {
      if(opt == 63)
        goto __CPROVER_DUMP_L3;

      if(opt == 112)
        goto __CPROVER_DUMP_L4;

      if(opt == 97)
        goto __CPROVER_DUMP_L6;

      if(opt == 86)
        goto __CPROVER_DUMP_L8;

      if(opt == 87)
        goto __CPROVER_DUMP_L10;

      if(opt == 118)
        goto __CPROVER_DUMP_L15;

      if(opt == 120)
        goto __CPROVER_DUMP_L16;

      if(opt == 119)
        goto __CPROVER_DUMP_L17;

      if(opt == 104)
        goto __CPROVER_DUMP_L18;

    }

    else
    {
      loop_get_opt = (_Bool)0;
      goto __CPROVER_DUMP_L20;

    __CPROVER_DUMP_L3:
      ;
      goto error_unrecognized_arg;

    __CPROVER_DUMP_L4:
      ;
      ok=enum_map_translate_str(platform_map, optarg, &opts->platform);
      if(ok == (_Bool)0)
        usage_error_printf("'%s' is not a valid platform", optarg);

      goto __CPROVER_DUMP_L20;

    __CPROVER_DUMP_L6:
      ;
      ok=enum_map_translate_str(context_api_map, optarg, &opts->context_api);
      if(ok == (_Bool)0)
        usage_error_printf("'%s' is not a valid API for an OpenGL context", optarg);

      goto __CPROVER_DUMP_L20;

    __CPROVER_DUMP_L8:
      ;
      signed int major;
      signed int minor;
      signed int match_count;
      match_count=sscanf(optarg, "%d.%d", &major, &minor);
      if(!(match_count == 2) || !(major >= 0) || !(minor >= 0))
        usage_error_printf("'%s' is not a valid OpenGL version", optarg);

      opts->context_major = major;
      opts->context_minor = minor;
      goto __CPROVER_DUMP_L20;

    __CPROVER_DUMP_L10:
      ;
      unsigned long int __s1_len;
      unsigned long int parse_args__1__1__1__4____s2_len;
      signed int return_value___builtin_strcmp_6;
      return_value___builtin_strcmp_6=__builtin_strcmp(optarg, "none");
      tmp_statement_expression_5 = return_value___builtin_strcmp_6;
      if(tmp_statement_expression_5 == 0)
        opts->context_profile = WAFFLE_NONE;

      else
      {
        unsigned long int parse_args__1__1__1__6____s1_len;
        unsigned long int __s2_len;
        signed int return_value___builtin_strcmp_4;
        return_value___builtin_strcmp_4=__builtin_strcmp(optarg, "core");
        tmp_statement_expression_3 = return_value___builtin_strcmp_4;
        if(tmp_statement_expression_3 == 0)
          opts->context_profile = WAFFLE_CONTEXT_CORE_PROFILE;

        else
        {
          unsigned long int parse_args__1__1__1__8____s1_len;
          unsigned long int parse_args__1__1__1__8____s2_len;
          signed int return_value___builtin_strcmp_2;
          return_value___builtin_strcmp_2=__builtin_strcmp(optarg, "compat");
          tmp_statement_expression_1 = return_value___builtin_strcmp_2;
          if(tmp_statement_expression_1 == 0)
            opts->context_profile = WAFFLE_CONTEXT_COMPATIBILITY_PROFILE;

          else
            usage_error_printf("'%s' is not a valid OpenGL profile", optarg);
        }
      }
      goto __CPROVER_DUMP_L20;

    __CPROVER_DUMP_L15:
      ;
      opts->verbose = (_Bool)1;
      goto __CPROVER_DUMP_L20;

    __CPROVER_DUMP_L16:
      ;
      opts->context_forward_compatible = (_Bool)1;
      goto __CPROVER_DUMP_L20;

    __CPROVER_DUMP_L17:
      ;
      opts->context_debug = (_Bool)1;
      goto __CPROVER_DUMP_L20;

    __CPROVER_DUMP_L18:
      ;
      write_usage_and_exit(stdout, 0);
      goto __CPROVER_DUMP_L20;
    }
    abort();
    loop_get_opt = (_Bool)0;

  __CPROVER_DUMP_L20:
    ;
  }
  if(optind >= argc)
  {
    if(opts->platform == 0)
      usage_error_printf("--platform is required");

    if(opts->context_api == 0)
      usage_error_printf("--api is required");

    switch(opts->context_api)
    {
      case WAFFLE_CONTEXT_OPENGL:
      {
        opts->dl = WAFFLE_DL_OPENGL;
        break;
      }
      case WAFFLE_CONTEXT_OPENGL_ES1:
      {
        opts->dl = WAFFLE_DL_OPENGL_ES1;
        break;
      }
      case WAFFLE_CONTEXT_OPENGL_ES2:
      {
        opts->dl = WAFFLE_DL_OPENGL_ES2;
        break;
      }
      case WAFFLE_CONTEXT_OPENGL_ES3:
      {
        opts->dl = WAFFLE_DL_OPENGL_ES3;
        break;
      }
      default:
        abort();
    }
    return (_Bool)1;
  }

  else
  {

  error_unrecognized_arg:
    ;
    if(!(optarg == ((char *)NULL)))
      usage_error_printf("unrecognized option '%s'", optarg);

    else
      if(!(optopt == 0))
        usage_error_printf("unrecognized option '-%c'", optopt);

      else
        usage_error_printf("unrecognized option");
  }
}

// parse_bool
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 80
static _Bool parse_bool(const signed int *attrib_list, signed int attrib_name, _Bool *value, _Bool default_value)
{
  signed int raw_value;
  wcore_attrib_list_get_with_default(attrib_list, attrib_name, &raw_value, (signed int)default_value);
  if(raw_value == WAFFLE_DONT_CARE)
    *value = default_value;

  else
    if(raw_value == 0 || raw_value == 1)
      *value = (_Bool)raw_value;

    else
    {
      const char *return_value_wcore_enum_to_string_1;
      return_value_wcore_enum_to_string_1=wcore_enum_to_string(attrib_name);
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "%s has bad value 0x%x. Must be true(1), false(0), or WAFFLE_DONT_CARE(-1)", return_value_wcore_enum_to_string_1, raw_value);
      return (_Bool)0;
    }
  return (_Bool)1;
}

// parse_context_api
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 106
static _Bool parse_context_api(struct wcore_config_attrs *attrs, const signed int *attrib_list)
{
  _Bool found;
  found=wcore_attrib_list_get(attrib_list, WAFFLE_CONTEXT_API, &attrs->context_api);
  if(found == (_Bool)0)
  {
    wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "required attribute WAFFLE_CONTEXT_API is missing");
    return (_Bool)0;
  }

  else
  {
    if(attrs->context_api == WAFFLE_CONTEXT_OPENGL || attrs->context_api == WAFFLE_CONTEXT_OPENGL_ES1 || attrs->context_api == WAFFLE_CONTEXT_OPENGL_ES2 || attrs->context_api == WAFFLE_CONTEXT_OPENGL_ES3)
      goto __CPROVER_DUMP_L4;

    wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "WAFFLE_CONTEXT_API has bad value %#x", attrs->context_api);
    return (_Bool)0;

  __CPROVER_DUMP_L4:
    ;
    return (_Bool)1;
  }
}

// parse_context_forward_compatible
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 307
static _Bool parse_context_forward_compatible(struct wcore_config_attrs *attrs, const signed int *attrib_list)
{
  _Bool return_value_parse_bool_1;
  return_value_parse_bool_1=parse_bool(attrib_list, WAFFLE_CONTEXT_FORWARD_COMPATIBLE, &attrs->context_forward_compatible, (_Bool)0);
  if(return_value_parse_bool_1 == (_Bool)0)
    return (_Bool)0;

  else
    if(attrs->context_forward_compatible == (_Bool)0)
      return (_Bool)1;

    else
      if(!(attrs->context_api == WAFFLE_CONTEXT_OPENGL))
      {
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "To request a forward-compatible context, the context API must be WAFFLE_CONTEXT_OPENGL");
        return (_Bool)0;
      }

      else
      {
        _Bool return_value_wcore_config_attrs_version_lt_2;
        return_value_wcore_config_attrs_version_lt_2=wcore_config_attrs_version_lt(attrs, 30);
        if(!(return_value_wcore_config_attrs_version_lt_2 == (_Bool)0))
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "To request a forward-compatible context, the context version must be at least 3.0");
          return (_Bool)0;
        }

        else
          return (_Bool)1;
      }
}

// parse_context_profile
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 260
static _Bool parse_context_profile(struct wcore_config_attrs *attrs, const signed int *attrib_list)
{
  wcore_attrib_list_get_with_default(attrib_list, WAFFLE_CONTEXT_PROFILE, &attrs->context_profile, attrs->context_profile);
  _Bool return_value_wcore_config_attrs_version_ge_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool return_value_wcore_config_attrs_version_lt_1;
  switch(attrs->context_api)
  {
    case WAFFLE_CONTEXT_OPENGL:
    {
      return_value_wcore_config_attrs_version_ge_2=wcore_config_attrs_version_ge(attrs, 32);
      if(!(return_value_wcore_config_attrs_version_ge_2 == (_Bool)0))
        tmp_if_expr_3 = attrs->context_profile != WAFFLE_CONTEXT_CORE_PROFILE ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(tmp_if_expr_3)
        tmp_if_expr_4 = attrs->context_profile != WAFFLE_CONTEXT_COMPATIBILITY_PROFILE ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_4 = (_Bool)0;
      if(tmp_if_expr_4)
      {
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "for OpenGL >= 3.2, WAFFLE_CONTEXT_PROFILE must be either WAFFLE_CONTEXT_CORE_PROFILE or WAFFLE_CONTEXT_COMPATIBILITY_PROFILE");
        return (_Bool)0;
      }

      else
      {
        return_value_wcore_config_attrs_version_lt_1=wcore_config_attrs_version_lt(attrs, 32);
        if(!(return_value_wcore_config_attrs_version_lt_1 == (_Bool)0))
        {
          if(!(attrs->context_profile == WAFFLE_NONE))
          {
            wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "for OpenGL < 3.2, WAFFLE_CONTEXT_PROFILE must be WAFFLE_NONE");
            return (_Bool)0;
          }

        }

      }
      break;
    }
    case WAFFLE_CONTEXT_OPENGL_ES1:

    case WAFFLE_CONTEXT_OPENGL_ES2:

    case WAFFLE_CONTEXT_OPENGL_ES3:
    {
      if(!(attrs->context_profile == WAFFLE_NONE))
      {
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "for OpenGL ES, WAFFLE_CONTEXT_PROFILE must be WAFFLE_NONE");
        return (_Bool)0;
      }

      break;
    }
    default:
      return (_Bool)0;
  }
  return (_Bool)1;
}

// parse_context_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 163
static _Bool parse_context_version(struct wcore_config_attrs *attrs, const signed int *attrib_list)
{
  wcore_attrib_list_get_with_default(attrib_list, WAFFLE_CONTEXT_MAJOR_VERSION, &attrs->context_major_version, attrs->context_major_version);
  wcore_attrib_list_get_with_default(attrib_list, WAFFLE_CONTEXT_MINOR_VERSION, &attrs->context_minor_version, attrs->context_minor_version);
  _Bool return_value_wcore_config_attrs_version_lt_1;
  _Bool return_value_wcore_config_attrs_version_eq_3;
  _Bool return_value_wcore_config_attrs_version_eq_2;
  if(!(attrs->context_major_version >= 1))
  {
    wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "WAFFLE_CONTEXT_MAJOR_VERSION must be >= 1");
    return (_Bool)0;
  }

  else
    if(!(attrs->context_minor_version >= 0))
    {
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "WAFFLE_CONTEXT_MINOR_VERSION must be >= 0");
      return (_Bool)0;
    }

    else
    {
      switch(attrs->context_api)
      {
        case WAFFLE_CONTEXT_OPENGL:
        {
          return_value_wcore_config_attrs_version_lt_1=wcore_config_attrs_version_lt(attrs, 10);
          if(!(return_value_wcore_config_attrs_version_lt_1 == (_Bool)0))
          {
            wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "for OpenGL, the requested context version must be >= 1.0");
            return (_Bool)0;
          }

          break;
        }
        case WAFFLE_CONTEXT_OPENGL_ES1:
        {
          return_value_wcore_config_attrs_version_eq_3=wcore_config_attrs_version_eq(attrs, 10);
          if(return_value_wcore_config_attrs_version_eq_3 == (_Bool)0)
          {
            return_value_wcore_config_attrs_version_eq_2=wcore_config_attrs_version_eq(attrs, 11);
            if(return_value_wcore_config_attrs_version_eq_2 == (_Bool)0)
            {
              wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "for OpenGL ES1, the requested context version must be 1.0 or 1.1");
              return (_Bool)0;
            }

          }

          break;
        }
        case WAFFLE_CONTEXT_OPENGL_ES2:
        {
          if(!(attrs->context_major_version == 2))
          {
            wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "for OpenGL ES2, the requested major context version must be 2");
            return (_Bool)0;
          }

          break;
        }
        case WAFFLE_CONTEXT_OPENGL_ES3:
        {
          if(!(attrs->context_major_version == 3))
          {
            wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "for OpenGL ES3, the requested major context version must be 3");
            return (_Bool)0;
          }

          break;
        }
        default:
        {
          _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c", 227, "attrs->context_api has bad value 0x%x", attrs->context_api);
          return (_Bool)0;
        }
      }
      return (_Bool)1;
    }
}

// parse_misc
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 365
static _Bool parse_misc(struct wcore_config_attrs *attrs, const signed int *attrib_list)
{
  signed int i = 0;
  _Bool return_value_parse_bool_1;
  _Bool return_value_parse_bool_2;
  _Bool return_value_parse_bool_3;
  _Bool return_value_parse_bool_4;
  for( ; !(attrib_list[(signed long int)i] == 0); i = i + 2)
  {
    signed int key = attrib_list[(signed long int)(i + 0)];
    signed int value = attrib_list[(signed long int)(i + 1)];
    switch(key)
    {
      case WAFFLE_CONTEXT_API:

      case WAFFLE_CONTEXT_MAJOR_VERSION:

      case WAFFLE_CONTEXT_MINOR_VERSION:

      case WAFFLE_CONTEXT_PROFILE:

      case WAFFLE_CONTEXT_FORWARD_COMPATIBLE:
        break;
      case WAFFLE_RED_SIZE:
      {
        if(!(value >= -1))
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "WAFFLE_RED_SIZE has bad value %d", value);
          return (_Bool)0;
        }

        else
          attrs->red_size = value;
        break;
      }
      case WAFFLE_GREEN_SIZE:
      {
        if(!(value >= -1))
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "WAFFLE_GREEN_SIZE has bad value %d", value);
          return (_Bool)0;
        }

        else
          attrs->green_size = value;
        break;
      }
      case WAFFLE_BLUE_SIZE:
      {
        if(!(value >= -1))
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "WAFFLE_BLUE_SIZE has bad value %d", value);
          return (_Bool)0;
        }

        else
          attrs->blue_size = value;
        break;
      }
      case WAFFLE_ALPHA_SIZE:
      {
        if(!(value >= -1))
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "WAFFLE_ALPHA_SIZE has bad value %d", value);
          return (_Bool)0;
        }

        else
          attrs->alpha_size = value;
        break;
      }
      case WAFFLE_DEPTH_SIZE:
      {
        if(!(value >= -1))
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "WAFFLE_DEPTH_SIZE has bad value %d", value);
          return (_Bool)0;
        }

        else
          attrs->depth_size = value;
        break;
      }
      case WAFFLE_STENCIL_SIZE:
      {
        if(!(value >= -1))
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "WAFFLE_STENCIL_SIZE has bad value %d", value);
          return (_Bool)0;
        }

        else
          attrs->stencil_size = value;
        break;
      }
      case WAFFLE_SAMPLES:
      {
        if(!(value >= -1))
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "WAFFLE_SAMPLES has bad value %d", value);
          return (_Bool)0;
        }

        else
          attrs->samples = value;
        break;
      }
      case WAFFLE_CONTEXT_DEBUG:
      {
        return_value_parse_bool_1=parse_bool(attrib_list, WAFFLE_CONTEXT_DEBUG, &attrs->context_debug, (_Bool)0);
        if(return_value_parse_bool_1 == (_Bool)0)
          return (_Bool)0;

        break;
      }
      case WAFFLE_SAMPLE_BUFFERS:
      {
        return_value_parse_bool_2=parse_bool(attrib_list, WAFFLE_SAMPLE_BUFFERS, &attrs->sample_buffers, (_Bool)0);
        if(return_value_parse_bool_2 == (_Bool)0)
          return (_Bool)0;

        break;
      }
      case WAFFLE_DOUBLE_BUFFERED:
      {
        return_value_parse_bool_3=parse_bool(attrib_list, WAFFLE_DOUBLE_BUFFERED, &attrs->double_buffered, (_Bool)1);
        if(return_value_parse_bool_3 == (_Bool)0)
          return (_Bool)0;

        break;
      }
      case WAFFLE_ACCUM_BUFFER:
      {
        return_value_parse_bool_4=parse_bool(attrib_list, WAFFLE_ACCUM_BUFFER, &attrs->accum_buffer, (_Bool)0);
        if(return_value_parse_bool_4 == (_Bool)0)
          return (_Bool)0;

        break;
      }
      default:
      {
        _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c", 429, "%s", (const void *)"bad attribute key should have been found by check_keys()");
        return (_Bool)0;
      }
    }
  }
  attrs->rgb_size = 0;
  if(!(attrs->red_size == WAFFLE_DONT_CARE))
    attrs->rgb_size = attrs->rgb_size + attrs->red_size;

  if(!(attrs->green_size == WAFFLE_DONT_CARE))
    attrs->rgb_size = attrs->rgb_size + attrs->green_size;

  if(!(attrs->blue_size == WAFFLE_DONT_CARE))
    attrs->rgb_size = attrs->rgb_size + attrs->blue_size;

  attrs->rgba_size = attrs->rgb_size;
  if(!(attrs->alpha_size == WAFFLE_DONT_CARE))
    attrs->rgba_size = attrs->rgba_size + attrs->alpha_size;

  return (_Bool)1;
}

// parse_version
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 441
static signed int parse_version(const char *version)
{
  signed int count;
  signed int major;
  signed int minor;
  const unsigned short int **return_value___ctype_b_loc_1;
  if(version == ((const char *)NULL))
    return 0;

  else
  {
    for( ; !((signed int)*version == 0); version = version + 1l)
    {
      return_value___ctype_b_loc_1=__ctype_b_loc();
      if(!((2048 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*version]) == 0))
        break;

    }
    count=sscanf(version, "%d.%d", &major, &minor);
    if(!(count == 2))
      return 0;

    else
      if(minor >= 10)
        return 0;

      else
        return major * 10 + minor;
  }
}

// print_context_flags
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 491
static void print_context_flags(void)
{
  /* tag-#anon#lST[U32'flag'||U32'_pad0'||l*{S8}_S8_'str'|] */
struct anonymous_9
{
  // flag
  unsigned int flag;
  // str
  char *str;
};

/* */
  ;
  signed int flag_count = (signed int)(sizeof(struct anonymous_9 [3l]) /*48ul*/  / sizeof(struct anonymous_9) /*16ul*/ );
  unsigned int context_flags = (unsigned int)0;
  printf("OpenGL context flags:");
  glGetIntegerv((unsigned int)33310, &context_flags);
  unsigned int return_value;
  return_value=glGetError();
  if(!(return_value == 0u))
    printf(" WFLINFO_GL_ERROR\n");

  else
    if(context_flags == 0u)
      printf(" 0x0\n");

    else
    {
      signed int i = 0;
      if(!(i >= flag_count))
      {
        static struct anonymous_9 flags[3l] = { { .flag=(unsigned int)1, .str="FORWARD_COMPATIBLE" },
    { .flag=(unsigned int)2, .str="DEBUG" },
    { .flag=(unsigned int)4, .str="ROBUST_ACCESS" } };
        if(!((flags[(signed long int)i].flag & context_flags) == 0u))
        {
          printf(" %s", flags[(signed long int)i].str);
          context_flags = context_flags & ~flags[(signed long int)i].flag;
        }

        i = i + 1;
      }

      signed int print_context_flags__1__4__i = 0;
      if(!(context_flags == 0u))
      {
        if(!((1u & context_flags) == 0u))
          printf(" 0x%x", 1 << print_context_flags__1__4__i);

        context_flags = context_flags >> 1;
        print_context_flags__1__4__i = print_context_flags__1__4__i + 1;
      }

      printf("\n");
    }
}

// print_extensions
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 462
static void print_extensions(_Bool use_stringi)
{
  unsigned int count = (unsigned int)0;
  unsigned int i;
  const char *ext;
  printf("OpenGL extensions: ");
  if(!(use_stringi == (_Bool)0))
  {
    glGetIntegerv((unsigned int)33309, &count);
    unsigned int return_value_2;
    return_value_2=glGetError();
    if(!(return_value_2 == 0u))
      printf("WFLINFO_GL_ERROR");

    else
    {
      i = (unsigned int)0;
      if(!(i >= count))
      {
        const unsigned char *return_value;
        return_value=glGetStringi((unsigned int)7939, i);
        ext = (const char *)return_value;
        unsigned int return_value_1;
        return_value_1=glGetError();
        if(!(return_value_1 == 0u))
          ext = "WFLINFO_GL_ERROR";

        printf("%s%s", ext, i + (unsigned int)1 < count ? " " : "");
        i = i + 1u;
      }

    }
  }

  else
  {
    const char *extensions;
    const unsigned char *return_value_3;
    return_value_3=glGetString((unsigned int)7939);
    extensions = (const char *)return_value_3;
    unsigned int return_value_4;
    return_value_4=glGetError();
    if(!(return_value_4 == 0u))
      printf("WFLINFO_GL_ERROR");

    else
      printf("%s", extensions);
  }
  printf("\n");
}

// print_wflinfo
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 533
static _Bool print_wflinfo(struct options *opts)
{
  unsigned int return_value;
  return_value=glGetError();
  const char *vendor;
  const unsigned char *return_value_1;
  return_value_1=glGetString((unsigned int)7936);
  vendor = (const char *)return_value_1;
  unsigned int return_value_2;
  return_value_2=glGetError();
  if(vendor == ((const char *)NULL) || !(return_value_2 == 0u))
    vendor = "WFLINFO_GL_ERROR";

  const char *renderer;
  const unsigned char *return_value_3;
  return_value_3=glGetString((unsigned int)7937);
  renderer = (const char *)return_value_3;
  unsigned int return_value_4;
  return_value_4=glGetError();
  if(renderer == ((const char *)NULL) || !(return_value_4 == 0u))
    renderer = "WFLINFO_GL_ERROR";

  const char *version_str;
  const unsigned char *return_value_5;
  return_value_5=glGetString((unsigned int)7938);
  version_str = (const char *)return_value_5;
  unsigned int return_value_6;
  return_value_6=glGetError();
  if(version_str == ((const char *)NULL) || !(return_value_6 == 0u))
    version_str = "WFLINFO_GL_ERROR";

  const char *platform;
  platform=enum_map_to_str(platform_map, opts->platform);
  printf("Waffle platform: %s\n", platform);
  const char *api;
  api=enum_map_to_str(context_api_map, opts->context_api);
  printf("Waffle api: %s\n", api);
  printf("OpenGL vendor string: %s\n", vendor);
  printf("OpenGL renderer string: %s\n", renderer);
  printf("OpenGL version string: %s\n", version_str);
  signed int version;
  version=parse_version(version_str);
  if(opts->context_api == WAFFLE_CONTEXT_OPENGL)
  {
    if(version >= 31)
      print_context_flags();

  }

  const _Bool use_getstringi = version >= 30;
  if(glGetStringi == ((const unsigned char * (*)(unsigned int, unsigned int))NULL) && !(use_getstringi == (_Bool)0))
    error_get_gl_symbol("glGetStringi");

  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if(!(opts->verbose == (_Bool)0))
  {
    const char *language_str = "None";
    if(opts->context_api == WAFFLE_CONTEXT_OPENGL && version >= 20)
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = opts->context_api == WAFFLE_CONTEXT_OPENGL_ES2 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = opts->context_api == WAFFLE_CONTEXT_OPENGL_ES3 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      const unsigned char *return_value_7;
      return_value_7=glGetString((unsigned int)35724);
      language_str = (const char *)return_value_7;
      unsigned int return_value_8;
      return_value_8=glGetError();
      if(language_str == ((const char *)NULL) || !(return_value_8 == 0u))
        language_str = "WFLINFO_GL_ERROR";

    }

    printf("OpenGL shading language version string: %s\n", language_str);
    print_extensions(use_getstringi);
  }

  return (_Bool)1;
}

// pthread_equal
// file /usr/include/pthread.h line 1155
static inline signed int pthread_equal(unsigned long int __thread1, unsigned long int __thread2)
{
  return (signed int)(__thread1 == __thread2);
}

// registry_listener_global
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 61
static void registry_listener_global(void *data, struct wl_registry *registry, unsigned int name, const char *interface, unsigned int version)
{
  struct wayland_display *self = (struct wayland_display *)data;
  signed int return_value_strncmp_4;
  return_value_strncmp_4=strncmp(interface, "wl_compositor", (unsigned long int)14);
  signed int return_value_strncmp_3;
  if(return_value_strncmp_4 == 0)
  {
    void *return_value_wl_registry_bind_1;
    return_value_wl_registry_bind_1=wl_registry_bind(self->wl_registry, name, &wl_compositor_interface, (unsigned int)1);
    self->wl_compositor = (struct wl_compositor *)return_value_wl_registry_bind_1;
  }

  else
  {
    return_value_strncmp_3=strncmp(interface, "wl_shell", (unsigned long int)9);
    if(return_value_strncmp_3 == 0)
    {
      void *return_value_wl_registry_bind_2;
      return_value_wl_registry_bind_2=wl_registry_bind(self->wl_registry, name, &wl_shell_interface, (unsigned int)1);
      self->wl_shell = (struct wl_shell *)return_value_wl_registry_bind_2;
    }

  }
}

// registry_listener_global_remove
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 80
static void registry_listener_global_remove(void *data, struct wl_registry *registry, unsigned int name)
{
  ;
}

// set_context_profile_default
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 235
static _Bool set_context_profile_default(struct wcore_config_attrs *attrs)
{
  _Bool return_value_wcore_config_attrs_version_ge_1;
  switch(attrs->context_api)
  {
    case WAFFLE_CONTEXT_OPENGL:
    {
      return_value_wcore_config_attrs_version_ge_1=wcore_config_attrs_version_ge(attrs, 32);
      if(!(return_value_wcore_config_attrs_version_ge_1 == (_Bool)0))
        attrs->context_profile = WAFFLE_CONTEXT_CORE_PROFILE;

      else
        attrs->context_profile = WAFFLE_NONE;
      break;
    }
    case WAFFLE_CONTEXT_OPENGL_ES1:

    case WAFFLE_CONTEXT_OPENGL_ES2:

    case WAFFLE_CONTEXT_OPENGL_ES3:
    {
      attrs->context_profile = WAFFLE_NONE;
      break;
    }
    default:
      return (_Bool)0;
  }
  return (_Bool)1;
}

// set_context_version_default
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 136
static _Bool set_context_version_default(struct wcore_config_attrs *attrs)
{
  switch(attrs->context_api)
  {
    case WAFFLE_CONTEXT_OPENGL:
    {
      attrs->context_major_version = 1;
      attrs->context_minor_version = 0;
      return (_Bool)1;
    }
    case WAFFLE_CONTEXT_OPENGL_ES1:
    {
      attrs->context_major_version = 1;
      attrs->context_minor_version = 0;
      return (_Bool)1;
    }
    case WAFFLE_CONTEXT_OPENGL_ES2:
    {
      attrs->context_major_version = 2;
      attrs->context_minor_version = 0;
      return (_Bool)1;
    }
    case WAFFLE_CONTEXT_OPENGL_ES3:
    {
      attrs->context_major_version = 3;
      attrs->context_minor_version = 0;
      return (_Bool)1;
    }
    default:
    {
      _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c", 157, "attrs->context_api has bad value 0x%x", attrs->context_api);
      return (_Bool)0;
    }
  }
}

// set_misc_defaults
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 339
static _Bool set_misc_defaults(struct wcore_config_attrs *attrs)
{
  attrs->context_debug = (_Bool)0;
  attrs->rgba_size = 0;
  attrs->red_size = 0;
  attrs->green_size = 0;
  attrs->blue_size = 0;
  attrs->alpha_size = 0;
  attrs->depth_size = 0;
  attrs->stencil_size = 0;
  attrs->sample_buffers = (_Bool)0;
  attrs->samples = 0;
  attrs->double_buffered = (_Bool)1;
  attrs->accum_buffer = (_Bool)0;
  return (_Bool)1;
}

// shell_surface_listener_configure
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.c line 76
static void shell_surface_listener_configure(void *data, struct wl_shell_surface *shell_surface, unsigned int edges, signed int width, signed int height)
{
  ;
}

// shell_surface_listener_ping
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.c line 68
static void shell_surface_listener_ping(void *data, struct wl_shell_surface *shell_surface, unsigned int serial)
{
  wl_shell_surface_pong(shell_surface, serial);
}

// shell_surface_listener_popup_done
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.c line 85
static void shell_surface_listener_popup_done(void *data, struct wl_shell_surface *shell_surface)
{
  ;
}

// strneq
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 121
static _Bool strneq(const char *a, const char *b, unsigned long int n)
{
  signed int return_value_strncmp_1;
  return_value_strncmp_1=strncmp(a, b, n);
  return return_value_strncmp_1 == 0;
}

// thrd_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 220
signed int thrd_create(unsigned long int *thr, signed int (*func)(void *), void *arg)
{
  struct impl_thrd_param *pack;
  if(thr == ((unsigned long int *)NULL))
    return 2;

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct impl_thrd_param) /*16ul*/ );
    pack = (struct impl_thrd_param *)return_value_malloc_1;
    if(pack == ((struct impl_thrd_param *)NULL))
      return 4;

    else
    {
      pack->func = func;
      pack->arg = arg;
      signed int return_value_pthread_create_2;
      return_value_pthread_create_2=pthread_create(thr, (const union pthread_attr_t *)(void *)0, impl_thrd_routine, (void *)pack);
      if(!(return_value_pthread_create_2 == 0))
      {
        free((void *)pack);
        return 2;
      }

      else
        return 0;
    }
  }
}

// thrd_current
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 236
unsigned long int thrd_current(void)
{
  unsigned long int return_value_pthread_self_1;
  return_value_pthread_self_1=pthread_self();
  return return_value_pthread_self_1;
}

// thrd_detach
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 242
signed int thrd_detach(unsigned long int thr)
{
  signed int return_value_pthread_detach_1;
  return_value_pthread_detach_1=pthread_detach(thr);
  return return_value_pthread_detach_1 == 0 ? 0 : 2;
}

// thrd_equal
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 248
signed int thrd_equal(unsigned long int thr0, unsigned long int thr1)
{
  signed int return_value_pthread_equal_1;
  return_value_pthread_equal_1=pthread_equal(thr0, thr1);
  return return_value_pthread_equal_1;
}

// thrd_exit
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 254
void thrd_exit(signed int res)
{
  pthread_exit((void *)(signed long int)res);
}

// thrd_join
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 260
signed int thrd_join(unsigned long int thr, signed int *res)
{
  void *code;
  signed int return_value_pthread_join_1;
  return_value_pthread_join_1=pthread_join(thr, &code);
  if(!(return_value_pthread_join_1 == 0))
    return 2;

  else
  {
    if(!(res == ((signed int *)NULL)))
      *res = (signed int)(signed long int)code;

    return 0;
  }
}

// thrd_sleep
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 271
void thrd_sleep(const struct xtime *xt)
{
  struct timespec req;
  req.tv_sec = xt->sec;
  req.tv_nsec = xt->nsec;
  nanosleep(&req, (struct timespec *)(void *)0);
}

// thrd_yield
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 281
void thrd_yield(void)
{
  sched_yield();
}

// tss_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 172
signed int tss_create(unsigned int *key, void (*dtor)(void *))
{
  if(key == ((unsigned int *)NULL))
    return 2;

  else
  {
    signed int return_value_pthread_key_create_1;
    return_value_pthread_key_create_1=pthread_key_create(key, dtor);
    return return_value_pthread_key_create_1 == 0 ? 0 : 2;
  }
}

// tss_delete
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 296
void tss_delete(unsigned int key)
{
  pthread_key_delete(key);
}

// tss_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 302
void * tss_get(unsigned int key)
{
  void *return_value_pthread_getspecific_1;
  return_value_pthread_getspecific_1=pthread_getspecific(key);
  return return_value_pthread_getspecific_1;
}

// tss_set
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads.h line 175
signed int tss_set(unsigned int key, void *val)
{
  signed int return_value_pthread_setspecific_1;
  return_value_pthread_setspecific_1=pthread_setspecific(key, val);
  return return_value_pthread_setspecific_1 == 0 ? 0 : 2;
}

// usage_error_printf
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 156
static void usage_error_printf(const char *fmt, ...)
{
  fprintf(stderr, "Wflinfo usage error: ");
  if(!(fmt == ((const char *)NULL)))
  {
    void **ap = (void **)&fmt;
    vfprintf(stderr, fmt, ap);
    ap = ((void **)NULL);
    fprintf(stderr, " ");
  }

  fprintf(stderr, "(see wflinfo --help)\n");
  exit(1);
}

// waffle_attrib_list_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_attrib_list.c line 40
_Bool waffle_attrib_list_get(const signed int *attrib_list, signed int key, signed int *value)
{
  wcore_error_reset();
  _Bool return_value_wcore_attrib_list_get_1;
  return_value_wcore_attrib_list_get_1=wcore_attrib_list_get(attrib_list, key, value);
  return return_value_wcore_attrib_list_get_1;
}

// waffle_attrib_list_get_with_default
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_attrib_list.c line 50
_Bool waffle_attrib_list_get_with_default(const signed int *attrib_list, signed int key, signed int *value, signed int default_value)
{
  wcore_error_reset();
  _Bool return_value_wcore_attrib_list_get_with_default_1;
  return_value_wcore_attrib_list_get_with_default_1=wcore_attrib_list_get_with_default(attrib_list, key, value, default_value);
  return return_value_wcore_attrib_list_get_with_default_1;
}

// waffle_attrib_list_length
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_attrib_list.c line 32
signed int waffle_attrib_list_length(const signed int *attrib_list)
{
  wcore_error_reset();
  signed int return_value_wcore_attrib_list_length_1;
  return_value_wcore_attrib_list_length_1=wcore_attrib_list_length(attrib_list);
  return return_value_wcore_attrib_list_length_1;
}

// waffle_attrib_list_update
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_attrib_list.c line 62
_Bool waffle_attrib_list_update(signed int *attrib_list, signed int key, signed int value)
{
  wcore_error_reset();
  _Bool return_value_wcore_attrib_list_update_1;
  return_value_wcore_attrib_list_update_1=wcore_attrib_list_update(attrib_list, key, value);
  return return_value_wcore_attrib_list_update_1;
}

// waffle_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 49
static inline struct waffle_config * waffle_config(struct wcore_config *cfg)
{
  return (struct waffle_config *)cfg;
}

// waffle_config_choose
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 197
struct waffle_config * waffle_config_choose(struct waffle_display *dpy, const signed int *attrib_list)
{
  struct wcore_config *wc_self;
  struct wcore_display *wc_dpy;
  wc_dpy=wcore_display(dpy);
  struct wcore_config_attrs attrs;
  _Bool ok = (_Bool)1;
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr_1;
  if(!(wc_dpy == ((struct wcore_display *)NULL)))
    tmp_if_expr_1 = &wc_dpy->api;

  else

  obj_list[0] = tmp_if_expr_1;
  _Bool return_value_api_check_entry_2;
  return_value_api_check_entry_2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry_2 == (_Bool)0)
    return (struct waffle_config *)(void *)0;

  else
  {
    ok=wcore_config_attrs_parse(attrib_list, &attrs);
    if(ok == (_Bool)0)
      return (struct waffle_config *)(void *)0;

    else
    {
      wc_self=api_platform->vtbl->config.choose(api_platform, wc_dpy, &attrs);
      if(wc_self == ((struct wcore_config *)NULL))
        return (struct waffle_config *)(void *)0;

      else
      {
        struct waffle_config *return_value_waffle_config_3;
        return_value_waffle_config_3=waffle_config(wc_self);
        return return_value_waffle_config_3;
      }
    }
  }
}

// waffle_config_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 201
_Bool waffle_config_destroy(struct waffle_config *self)
{
  struct wcore_config *wc_self;
  wc_self=wcore_config(self);
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr_1;
  if(!(wc_self == ((struct wcore_config *)NULL)))
    tmp_if_expr_1 = &wc_self->api;

  else

  obj_list[0] = tmp_if_expr_1;
  _Bool return_value_api_check_entry_2;
  return_value_api_check_entry_2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry_2 == (_Bool)0)
    return (_Bool)0;

  else
  {
    _Bool return_value;
    return_value=api_platform->vtbl->config.destroy(wc_self);
    return return_value;
  }
}

// waffle_config_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_config.c line 78
union waffle_native_config * waffle_config_get_native(struct waffle_config *self)
{
  struct wcore_config *wc_self;
  wc_self=wcore_config(self);
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr_1;
  if(!(wc_self == ((struct wcore_config *)NULL)))
    tmp_if_expr_1 = &wc_self->api;

  else

  obj_list[0] = tmp_if_expr_1;
  _Bool return_value_api_check_entry_2;
  return_value_api_check_entry_2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry_2 == (_Bool)0)
    return (union waffle_native_config *)(void *)0;

  else
    if(!(api_platform->vtbl->config.get_native == ((union waffle_native_config * (*)(struct wcore_config *))NULL)))
    {
      union waffle_native_config *return_value;
      return_value=api_platform->vtbl->config.get_native(wc_self);
      return return_value;
    }

    else
    {
      wcore_error((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM);
      return (union waffle_native_config *)(void *)0;
    }
}

// waffle_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 47
static inline struct waffle_context * waffle_context(struct wcore_context *ctx)
{
  return (struct waffle_context *)ctx;
}

// waffle_context_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 211
struct waffle_context * waffle_context_create(struct waffle_config *config, struct waffle_context *shared_ctx)
{
  struct wcore_context *wc_self;
  struct wcore_config *wc_config;
  wc_config=wcore_config_link1(config);
  struct wcore_context *wc_shared_ctx;
  wc_shared_ctx=wcore_context(shared_ctx);
  struct api_object *obj_list[2l];
  signed int len = 0;
  signed int tmp_post_1 = len;
  len = len + 1;
  struct api_object *tmp_if_expr_2;
  if(!(wc_config == ((struct wcore_config *)NULL)))
    tmp_if_expr_2 = &wc_config->api;

  else

  obj_list[(signed long int)tmp_post_1] = tmp_if_expr_2;
  signed int tmp_post_3;
  if(!(wc_shared_ctx == ((struct wcore_context *)NULL)))
  {
    tmp_post_3 = len;
    len = len + 1;
    obj_list[(signed long int)tmp_post_3] = &wc_shared_ctx->api;
  }

  _Bool return_value_api_check_entry_4;
  return_value_api_check_entry_4=api_check_entry(obj_list, len);
  if(return_value_api_check_entry_4 == (_Bool)0)
    return (struct waffle_context *)(void *)0;

  else
  {
    wc_self=api_platform->vtbl->context.create(api_platform, wc_config, wc_shared_ctx);
    if(wc_self == ((struct wcore_context *)NULL))
      return (struct waffle_context *)(void *)0;

    else
    {
      struct waffle_context *return_value_waffle_context_5;
      return_value_waffle_context_5=waffle_context(wc_self);
      return return_value_waffle_context_5;
    }
  }
}

// waffle_context_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 215
_Bool waffle_context_destroy(struct waffle_context *self)
{
  struct wcore_context *wc_self;
  wc_self=wcore_context(self);
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr_1;
  if(!(wc_self == ((struct wcore_context *)NULL)))
    tmp_if_expr_1 = &wc_self->api;

  else

  obj_list[0] = tmp_if_expr_1;
  _Bool return_value_api_check_entry_2;
  return_value_api_check_entry_2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry_2 == (_Bool)0)
    return (_Bool)0;

  else
  {
    _Bool return_value;
    return_value=api_platform->vtbl->context.destroy(wc_self);
    return return_value;
  }
}

// waffle_context_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_context.c line 76
union waffle_native_context * waffle_context_get_native(struct waffle_context *self)
{
  struct wcore_context *wc_self;
  wc_self=wcore_context(self);
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr_1;
  if(!(wc_self == ((struct wcore_context *)NULL)))
    tmp_if_expr_1 = &wc_self->api;

  else

  obj_list[0] = tmp_if_expr_1;
  _Bool return_value_api_check_entry_2;
  return_value_api_check_entry_2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry_2 == (_Bool)0)
    return (union waffle_native_context *)(void *)0;

  else
    if(!(api_platform->vtbl->context.get_native == ((union waffle_native_context * (*)(struct wcore_context *))NULL)))
    {
      union waffle_native_context *return_value;
      return_value=api_platform->vtbl->context.get_native(wc_self);
      return return_value;
    }

    else
    {
      wcore_error((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM);
      return (union waffle_native_context *)(void *)0;
    }
}

// waffle_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_display.h line 44
static inline struct waffle_display * waffle_display(struct wcore_display *dpy)
{
  return (struct waffle_display *)dpy;
}

// waffle_display_connect
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 180
struct waffle_display * waffle_display_connect(const char *name)
{
  struct wcore_display *wc_self;
  _Bool return_value_api_check_entry_1;
  return_value_api_check_entry_1=api_check_entry((struct api_object **)(void *)0, 0);
  if(return_value_api_check_entry_1 == (_Bool)0)
    return (struct waffle_display *)(void *)0;

  else
  {
    wc_self=api_platform->vtbl->display.connect(api_platform, name);
    if(wc_self == ((struct wcore_display *)NULL))
      return (struct waffle_display *)(void *)0;

    else
    {
      struct waffle_display *return_value_waffle_display_2;
      return_value_waffle_display_2=waffle_display(wc_self);
      return return_value_waffle_display_2;
    }
  }
}

// waffle_display_disconnect
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 183
_Bool waffle_display_disconnect(struct waffle_display *self)
{
  struct wcore_display *wc_self;
  wc_self=wcore_display_link1(self);
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr_1;
  if(!(wc_self == ((struct wcore_display *)NULL)))
    tmp_if_expr_1 = &wc_self->api;

  else

  obj_list[0] = tmp_if_expr_1;
  _Bool return_value_api_check_entry_2;
  return_value_api_check_entry_2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry_2 == (_Bool)0)
    return (_Bool)0;

  else
  {
    _Bool return_value;
    return_value=api_platform->vtbl->display.destroy(wc_self);
    return return_value;
  }
}

// waffle_display_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_display.c line 94
union waffle_native_display * waffle_display_get_native(struct waffle_display *self)
{
  struct wcore_display *wc_self;
  wc_self=wcore_display_link1(self);
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr_1;
  if(!(wc_self == ((struct wcore_display *)NULL)))
    tmp_if_expr_1 = &wc_self->api;

  else

  obj_list[0] = tmp_if_expr_1;
  _Bool return_value_api_check_entry_2;
  return_value_api_check_entry_2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry_2 == (_Bool)0)
    return (union waffle_native_display *)(void *)0;

  else
    if(!(api_platform->vtbl->display.get_native == ((union waffle_native_display * (*)(struct wcore_display *))NULL)))
    {
      union waffle_native_display *return_value;
      return_value=api_platform->vtbl->display.get_native(wc_self);
      return return_value;
    }

    else
    {
      wcore_error((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM);
      return (union waffle_native_display *)(void *)0;
    }
}

// waffle_display_supports_context_api
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 186
_Bool waffle_display_supports_context_api(struct waffle_display *self, signed int context_api)
{
  struct wcore_display *wc_self;
  wc_self=wcore_display_link1(self);
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr_1;
  if(!(wc_self == ((struct wcore_display *)NULL)))
    tmp_if_expr_1 = &wc_self->api;

  else

  obj_list[0] = tmp_if_expr_1;
  _Bool return_value_api_check_entry_2;
  return_value_api_check_entry_2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry_2 == (_Bool)0)
    return (_Bool)0;

  else
  {
    if(context_api == WAFFLE_CONTEXT_OPENGL || context_api == WAFFLE_CONTEXT_OPENGL_ES1 || context_api == WAFFLE_CONTEXT_OPENGL_ES2 || context_api == WAFFLE_CONTEXT_OPENGL_ES3)
      goto __CPROVER_DUMP_L6;

    wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_PARAMETER, "context_api has bad value %#x", context_api);
    return (_Bool)0;

  __CPROVER_DUMP_L6:
    ;
    _Bool return_value;
    return_value=api_platform->vtbl->display.supports_context_api(wc_self, context_api);
    return return_value;
  }
}

// waffle_dl_can_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_dl.c line 47
_Bool waffle_dl_can_open(signed int dl)
{
  _Bool return_value_api_check_entry_1;
  return_value_api_check_entry_1=api_check_entry((struct api_object **)(void *)0, 0);
  if(return_value_api_check_entry_1 == (_Bool)0)
    return (_Bool)0;

  else
  {
    _Bool return_value_waffle_dl_check_enum_2;
    return_value_waffle_dl_check_enum_2=waffle_dl_check_enum(dl);
    if(return_value_waffle_dl_check_enum_2 == (_Bool)0)
      return (_Bool)0;

    else
    {
      _Bool return_value;
      return_value=api_platform->vtbl->dl_can_open(api_platform, dl);
      return return_value;
    }
  }
}

// waffle_dl_check_enum
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_dl.c line 32
static _Bool waffle_dl_check_enum(signed int dl)
{
  if(dl == WAFFLE_DL_OPENGL || dl == WAFFLE_DL_OPENGL_ES1 || dl == WAFFLE_DL_OPENGL_ES2 || dl == WAFFLE_DL_OPENGL_ES3)
    return (_Bool)1;

  wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_PARAMETER, "dl has bad value %#x");
  return (_Bool)0;
}

// waffle_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 258
void * waffle_dl_sym(signed int dl, const char *name)
{
  _Bool return_value_api_check_entry_1;
  return_value_api_check_entry_1=api_check_entry((struct api_object **)(void *)0, 0);
  if(return_value_api_check_entry_1 == (_Bool)0)
    return (void *)0;

  else
  {
    _Bool return_value_waffle_dl_check_enum_2;
    return_value_waffle_dl_check_enum_2=waffle_dl_check_enum(dl);
    if(return_value_waffle_dl_check_enum_2 == (_Bool)0)
      return (void *)0;

    else
    {
      void *return_value;
      return_value=api_platform->vtbl->dl_sym(api_platform, dl, name);
      return return_value;
    }
  }
}

// waffle_enum_to_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 156
const char * waffle_enum_to_string(signed int e)
{
  wcore_error_reset();
  const char *return_value_wcore_enum_to_string_1;
  return_value_wcore_enum_to_string_1=wcore_enum_to_string(e);
  return return_value_wcore_enum_to_string_1;
}

// waffle_error_get_code
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_error.c line 33
enum waffle_error waffle_error_get_code(void)
{
  enum waffle_error return_value_wcore_error_get_code_1;
  return_value_wcore_error_get_code_1=wcore_error_get_code();
  return return_value_wcore_error_get_code_1;
}

// waffle_error_get_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 78
struct waffle_error_info * waffle_error_get_info(void)
{
  struct waffle_error_info *return_value_wcore_error_get_info_1;
  return_value_wcore_error_get_info_1=wcore_error_get_info();
  return return_value_wcore_error_get_info_1;
}

// waffle_error_to_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 81
const char * waffle_error_to_string(enum waffle_error e)
{
  switch((signed int)e)
  {
    case WAFFLE_NO_ERROR:
      return "WAFFLE_NO_ERROR";
    case WAFFLE_ERROR_FATAL:
      return "WAFFLE_ERROR_FATAL";
    case WAFFLE_ERROR_UNKNOWN:
      return "WAFFLE_ERROR_UNKNOWN";
    case WAFFLE_ERROR_INTERNAL:
      return "WAFFLE_ERROR_INTERNAL";
    case WAFFLE_ERROR_BAD_ALLOC:
      return "WAFFLE_ERROR_BAD_ALLOC";
    case WAFFLE_ERROR_NOT_INITIALIZED:
      return "WAFFLE_ERROR_NOT_INITIALIZED";
    case WAFFLE_ERROR_ALREADY_INITIALIZED:
      return "WAFFLE_ERROR_ALREADY_INITIALIZED";
    case WAFFLE_ERROR_BAD_ATTRIBUTE:
      return "WAFFLE_ERROR_BAD_ATTRIBUTE";
    case WAFFLE_ERROR_BAD_PARAMETER:
      return "WAFFLE_ERROR_BAD_PARAMETER";
    case WAFFLE_ERROR_BAD_DISPLAY_MATCH:
      return "WAFFLE_ERROR_BAD_DISPLAY_MATCH";
    case WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM:
      return "WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM";
    case WAFFLE_ERROR_BUILT_WITHOUT_SUPPORT:
      return "WAFFLE_ERROR_BUILT_WITHOUT_SUPPORT";
    default:
      return ((const char *)NULL);
  }
}

// waffle_get_proc_address
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 169
void * waffle_get_proc_address(const char *name)
{
  _Bool return_value_api_check_entry_1;
  return_value_api_check_entry_1=api_check_entry((struct api_object **)(void *)0, 0);
  if(return_value_api_check_entry_1 == (_Bool)0)
    return (void *)0;

  else
  {
    void *return_value;
    return_value=api_platform->vtbl->get_proc_address(api_platform, name);
    return return_value;
  }
}

// waffle_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 161
_Bool waffle_init(const signed int *attrib_list)
{
  _Bool ok = (_Bool)1;
  signed int platform;
  wcore_error_reset();
  if(!(api_platform == ((struct wcore_platform *)NULL)))
  {
    wcore_error((enum waffle_error)WAFFLE_ERROR_ALREADY_INITIALIZED);
    return (_Bool)0;
  }

  else
  {
    _Bool return_value_waffle_init_parse_attrib_list_1;
    return_value_waffle_init_parse_attrib_list_1=waffle_init_parse_attrib_list(attrib_list, &platform);
    ok = ((signed int)ok & (signed int)return_value_waffle_init_parse_attrib_list_1) != 0;
    if(ok == (_Bool)0)
      return (_Bool)0;

    else
    {
      api_platform=waffle_init_create_platform(platform);
      if(api_platform == ((struct wcore_platform *)NULL))
        return (_Bool)0;

      else
        return (_Bool)1;
    }
  }
}

// waffle_init_create_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_init.c line 136
static struct wcore_platform * waffle_init_create_platform(signed int waffle_platform)
{
  struct wcore_platform *return_value_glx_platform_create_1;
  struct wcore_platform *return_value_wayland_platform_create_2;
  struct wcore_platform *return_value_xegl_platform_create_3;
  struct wcore_platform *return_value_wgbm_platform_create_4;
  switch(waffle_platform)
  {
    case WAFFLE_PLATFORM_GLX:
    {
      return_value_glx_platform_create_1=glx_platform_create();
      return return_value_glx_platform_create_1;
    }
    case WAFFLE_PLATFORM_WAYLAND:
    {
      return_value_wayland_platform_create_2=wayland_platform_create();
      return return_value_wayland_platform_create_2;
    }
    case WAFFLE_PLATFORM_X11_EGL:
    {
      return_value_xegl_platform_create_3=xegl_platform_create();
      return return_value_xegl_platform_create_3;
    }
    case WAFFLE_PLATFORM_GBM:
    {
      return_value_wgbm_platform_create_4=wgbm_platform_create();
      return return_value_wgbm_platform_create_4;
    }
    default:
      return (struct wcore_platform *)(void *)0;
  }
}

// waffle_init_parse_attrib_list
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_init.c line 40
static _Bool waffle_init_parse_attrib_list(const signed int *attrib_list, signed int *platform)
{
  _Bool found_platform = (_Bool)0;
  const signed int *i = attrib_list;
  for( ; !(*i == 0); i = i + (signed long int)2)
  {
    const signed int attr = i[(signed long int)0];
    const signed int value = i[(signed long int)1];
    if(attr == WAFFLE_PLATFORM)
    {
      switch(value)
      {
        case WAFFLE_PLATFORM_ANDROID:
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_BUILT_WITHOUT_SUPPORT, "waffle was built without support for WAFFLE_PLATFORM_ANDROID");
          return (_Bool)0;
        }
        case WAFFLE_PLATFORM_CGL:
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_BUILT_WITHOUT_SUPPORT, "waffle was built without support for WAFFLE_PLATFORM_CGL");
          return (_Bool)0;
        }
        case WAFFLE_PLATFORM_GLX:
        {
          found_platform = (_Bool)1;
          *platform = value;
          break;
        }
        case WAFFLE_PLATFORM_WAYLAND:
        {
          found_platform = (_Bool)1;
          *platform = value;
          break;
        }
        case WAFFLE_PLATFORM_X11_EGL:
        {
          found_platform = (_Bool)1;
          *platform = value;
          break;
        }
        case WAFFLE_PLATFORM_GBM:
        {
          found_platform = (_Bool)1;
          *platform = value;
          break;
        }
        case WAFFLE_PLATFORM_WGL:
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_BUILT_WITHOUT_SUPPORT, "waffle was built without support for WAFFLE_PLATFORM_WGL");
          return (_Bool)0;
        }
        default:
        {
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "WAFFLE_PLATFORM has bad value 0x%x", value);
          return (_Bool)0;
        }
      }
      goto __CPROVER_DUMP_L13;
    }

    wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "bad attribute name %#x", attr);
    return (_Bool)0;

  __CPROVER_DUMP_L13:
    ;
  }
  if(found_platform == (_Bool)0)
  {
    wcore_errorf((enum waffle_error)WAFFLE_ERROR_BAD_ATTRIBUTE, "attribute list is missing WAFFLE_PLATFORM");
    return (_Bool)0;
  }

  else
    return (_Bool)1;
}

// waffle_is_extension_in_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_gl_misc.c line 39
_Bool waffle_is_extension_in_string(const char * restrict extension_string, const char * restrict extension_name)
{
  unsigned long int name_length;
  const char * restrict search_start;
  wcore_error_reset();
  _Bool tmp_if_expr_1;
  if(extension_name == ((const char *)NULL) || extension_string == ((const char *)NULL))
    return (_Bool)0;

  else
  {
    name_length=strlen(extension_name);
    search_start = extension_string;
    if(name_length == 0ul)
      return (_Bool)0;

    else
      while((_Bool)1)
      {
        const char * restrict s;
        const char * restrict next_char;
        s=strstr(search_start, extension_name);
        if(s == ((const char *)NULL))
          return (_Bool)0;

        next_char = s + (signed long int)name_length;
        if((signed int)*next_char == 32)
          tmp_if_expr_1 = (_Bool)1;

        else
          tmp_if_expr_1 = (signed int)*next_char == 0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_1)
          return (_Bool)1;

        search_start = next_char;
      }
  }
}

// waffle_make_current
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 164
_Bool waffle_make_current(struct waffle_display *dpy, struct waffle_window *window, struct waffle_context *ctx)
{
  struct wcore_display *wc_dpy;
  wc_dpy=wcore_display_link2(dpy);
  struct wcore_window *wc_window;
  wc_window=wcore_window(window);
  struct wcore_context *wc_ctx;
  wc_ctx=wcore_context_link1(ctx);
  struct api_object *obj_list[3l];
  signed int len = 0;
  signed int tmp_post_1 = len;
  len = len + 1;
  struct api_object *tmp_if_expr_2;
  if(!(wc_dpy == ((struct wcore_display *)NULL)))
    tmp_if_expr_2 = &wc_dpy->api;

  else

  obj_list[(signed long int)tmp_post_1] = tmp_if_expr_2;
  signed int tmp_post_3;
  if(!(wc_window == ((struct wcore_window *)NULL)))
  {
    tmp_post_3 = len;
    len = len + 1;
    obj_list[(signed long int)tmp_post_3] = &wc_window->api;
  }

  signed int tmp_post_4;
  if(!(wc_ctx == ((struct wcore_context *)NULL)))
  {
    tmp_post_4 = len;
    len = len + 1;
    obj_list[(signed long int)tmp_post_4] = &wc_ctx->api;
  }

  _Bool return_value_api_check_entry_5;
  return_value_api_check_entry_5=api_check_entry(obj_list, len);
  if(return_value_api_check_entry_5 == (_Bool)0)
    return (_Bool)0;

  else
  {
    _Bool return_value;
    return_value=api_platform->vtbl->make_current(api_platform, wc_dpy, wc_window, wc_ctx);
    return return_value;
  }
}

// waffle_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 40
static inline struct waffle_window * waffle_window(struct wcore_window *win)
{
  return (struct waffle_window *)win;
}

// waffle_window_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 225
struct waffle_window * waffle_window_create(struct waffle_config *config, signed int width, signed int height)
{
  struct wcore_window *wc_self;
  struct wcore_config *wc_config;
  wc_config=wcore_config_link2(config);
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr_1;
  if(!(wc_config == ((struct wcore_config *)NULL)))
    tmp_if_expr_1 = &wc_config->api;

  else

  obj_list[0] = tmp_if_expr_1;
  _Bool return_value_api_check_entry_2;
  return_value_api_check_entry_2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry_2 == (_Bool)0)
    return (struct waffle_window *)(void *)0;

  else
  {
    wc_self=api_platform->vtbl->window.create(api_platform, wc_config, width, height);
    if(wc_self == ((struct wcore_window *)NULL))
      return (struct waffle_window *)(void *)0;

    else
    {
      struct waffle_window *return_value_waffle_window_3;
      return_value_waffle_window_3=waffle_window(wc_self);
      return return_value_waffle_window_3;
    }
  }
}

// waffle_window_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/include/waffle/waffle.h line 231
_Bool waffle_window_destroy(struct waffle_window *self)
{
  struct wcore_window *wc_self;
  wc_self=wcore_window_link1(self);
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr_1;
  if(!(wc_self == ((struct wcore_window *)NULL)))
    tmp_if_expr_1 = &wc_self->api;

  else

  obj_list[0] = tmp_if_expr_1;
  _Bool return_value_api_check_entry_2;
  return_value_api_check_entry_2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry_2 == (_Bool)0)
    return (_Bool)0;

  else
  {
    _Bool return_value;
    return_value=api_platform->vtbl->window.destroy(wc_self);
    return return_value;
  }
}

// waffle_window_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_window.c line 130
union waffle_native_window * waffle_window_get_native(struct waffle_window *self)
{
  struct wcore_window *wc_self;
  wc_self=wcore_window_link1(self);
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr_1;
  if(!(wc_self == ((struct wcore_window *)NULL)))
    tmp_if_expr_1 = &wc_self->api;

  else

  obj_list[0] = tmp_if_expr_1;
  _Bool return_value_api_check_entry_2;
  return_value_api_check_entry_2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry_2 == (_Bool)0)
    return (union waffle_native_window *)(void *)0;

  else
    if(!(api_platform->vtbl->window.get_native == ((union waffle_native_window * (*)(struct wcore_window *))NULL)))
    {
      union waffle_native_window *return_value;
      return_value=api_platform->vtbl->window.get_native(wc_self);
      return return_value;
    }

    else
    {
      wcore_error((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM);
      return (union waffle_native_window *)(void *)0;
    }
}

// waffle_window_resize
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_window.c line 91
_Bool waffle_window_resize(struct waffle_window *self, signed int width, signed int height)
{
  struct wcore_window *wc_self;
  wc_self=wcore_window_link1(self);
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr_1;
  if(!(wc_self == ((struct wcore_window *)NULL)))
    tmp_if_expr_1 = &wc_self->api;

  else

  obj_list[0] = tmp_if_expr_1;
  _Bool return_value_api_check_entry_2;
  return_value_api_check_entry_2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry_2 == (_Bool)0)
    return (_Bool)0;

  else
    if(!(api_platform->vtbl->window.resize == ((_Bool (*)(struct wcore_window *, signed int, signed int))NULL)))
    {
      _Bool return_value;
      return_value=api_platform->vtbl->window.resize(wc_self, width, height);
      return return_value;
    }

    else
    {
      wcore_error((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM);
      return (_Bool)0;
    }
}

// waffle_window_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_window.c line 76
_Bool waffle_window_show(struct waffle_window *self)
{
  struct wcore_window *wc_self;
  wc_self=wcore_window_link1(self);
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr_1;
  if(!(wc_self == ((struct wcore_window *)NULL)))
    tmp_if_expr_1 = &wc_self->api;

  else

  obj_list[0] = tmp_if_expr_1;
  _Bool return_value_api_check_entry_2;
  return_value_api_check_entry_2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry_2 == (_Bool)0)
    return (_Bool)0;

  else
  {
    _Bool return_value;
    return_value=api_platform->vtbl->window.show(wc_self);
    return return_value;
  }
}

// waffle_window_swap_buffers
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_window.c line 115
_Bool waffle_window_swap_buffers(struct waffle_window *self)
{
  struct wcore_window *wc_self;
  wc_self=wcore_window_link1(self);
  struct api_object *obj_list[1l];
  struct api_object *tmp_if_expr_1;
  if(!(wc_self == ((struct wcore_window *)NULL)))
    tmp_if_expr_1 = &wc_self->api;

  else

  obj_list[0] = tmp_if_expr_1;
  _Bool return_value_api_check_entry_2;
  return_value_api_check_entry_2=api_check_entry(obj_list, 1);
  if(return_value_api_check_entry_2 == (_Bool)0)
    return (_Bool)0;

  else
  {
    _Bool return_value;
    return_value=api_platform->vtbl->window.swap_buffers(wc_self);
    return return_value;
  }
}

// wayland_config_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.c line 113
static union waffle_native_config * wayland_config_get_native(struct wcore_config *wc_config)
{
  struct wegl_config *config;
  config=wegl_config_link3(wc_config);
  struct wayland_display *dpy;
  dpy=wayland_display_link1(wc_config->display);
  union waffle_native_config *n_config;
  do
  {
    void *return_value_wcore_malloc_1;
    return_value_wcore_malloc_1=wcore_malloc(sizeof(union waffle_native_config) /*8ul*/  + sizeof(struct waffle_wayland_config) /*40ul*/ );
    n_config = (union waffle_native_config *)return_value_wcore_malloc_1;
    if(!(n_config == ((union waffle_native_config *)NULL)))
      n_config->wayland = (struct waffle_wayland_config *)(void *)(n_config + (signed long int)1);

  }
  while((_Bool)0);
  if(n_config == ((union waffle_native_config *)NULL))
    return (union waffle_native_config *)(void *)0;

  else
  {
    wayland_display_fill_native(dpy, &n_config->wayland->display);
    n_config->wayland->egl_config = config->egl;
    return n_config;
  }
}

// wayland_context_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.c line 130
static union waffle_native_context * wayland_context_get_native(struct wcore_context *wc_ctx)
{
  struct wayland_display *dpy;
  dpy=wayland_display_link1(wc_ctx->display);
  struct wegl_context *ctx;
  ctx=wegl_context_link2(wc_ctx);
  union waffle_native_context *n_ctx;
  do
  {
    void *return_value_wcore_malloc_1;
    return_value_wcore_malloc_1=wcore_malloc(sizeof(union waffle_native_context) /*8ul*/  + sizeof(struct waffle_wayland_context) /*40ul*/ );
    n_ctx = (union waffle_native_context *)return_value_wcore_malloc_1;
    if(!(n_ctx == ((union waffle_native_context *)NULL)))
      n_ctx->wayland = (struct waffle_wayland_context *)(void *)(n_ctx + (signed long int)1);

  }
  while((_Bool)0);
  if(n_ctx == ((union waffle_native_context *)NULL))
    return (union waffle_native_context *)(void *)0;

  else
  {
    wayland_display_fill_native(dpy, &n_ctx->wayland->display);
    n_ctx->wayland->egl_context = ctx->egl;
    return n_ctx;
  }
}

// wayland_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.h line 53
static inline struct wayland_display * wayland_display(struct wcore_display *wc_self)
{
  struct wegl_display *tmp_statement_expression_1;
  struct wayland_display *tmp_statement_expression_2;
  if(!(wc_self == ((struct wcore_display *)NULL)))
  {
    struct wegl_display *wegl_self;
    const struct wcore_display *wayland_display__1__1__1____mptr = wc_self;
    tmp_statement_expression_1 = (struct wegl_display *)((void *)wayland_display__1__1__1____mptr - (signed long int)0ul);
    wegl_self = tmp_statement_expression_1;
    const struct wegl_display *__mptr = wegl_self;
    tmp_statement_expression_2 = (struct wayland_display *)((void *)__mptr - (signed long int)32ul);
    return tmp_statement_expression_2;
  }

  else
    return (struct wayland_display *)(void *)0;
}

// wayland_display_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.h line 53
static inline struct wayland_display * wayland_display_link1(struct wcore_display *wc_self_link1)
{
  struct wegl_display *tmp_statement_expression_1_link1;
  struct wayland_display *tmp_statement_expression_2_link1;
  if(!(wc_self_link1 == ((struct wcore_display *)NULL)))
  {
    struct wegl_display *wegl_self_link1;
    const struct wcore_display *wayland_display__1__1__1____mptr_link1 = wc_self_link1;
    tmp_statement_expression_1_link1 = (struct wegl_display *)((void *)wayland_display__1__1__1____mptr_link1 - (signed long int)0ul);
    wegl_self_link1 = tmp_statement_expression_1_link1;
    const struct wegl_display *__mptr_link1 = wegl_self_link1;
    tmp_statement_expression_2_link1 = (struct wayland_display *)((void *)__mptr_link1 - (signed long int)32ul);
    return tmp_statement_expression_2_link1;
  }

  else
    return (struct wayland_display *)(void *)0;
}

// wayland_display_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.h line 53
static inline struct wayland_display * wayland_display_link2(struct wcore_display *wc_self_link2)
{
  struct wegl_display *tmp_statement_expression_1_link2;
  struct wayland_display *tmp_statement_expression_2_link2;
  if(!(wc_self_link2 == ((struct wcore_display *)NULL)))
  {
    struct wegl_display *wegl_self_link2;
    const struct wcore_display *__mptr_link2 = wc_self_link2;
    tmp_statement_expression_1_link2 = (struct wegl_display *)((void *)__mptr_link2 - (signed long int)0ul);
    wegl_self_link2 = tmp_statement_expression_1_link2;
    const struct wegl_display *wayland_display__1__1__2____mptr_link2 = wegl_self_link2;
    tmp_statement_expression_2_link2 = (struct wayland_display *)((void *)wayland_display__1__1__2____mptr_link2 - (signed long int)32ul);
    return tmp_statement_expression_2_link2;
  }

  else
    return (struct wayland_display *)(void *)0;
}

// wayland_display_connect
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 92
struct wcore_display * wayland_display_connect(struct wcore_platform *wc_plat, const char *name)
{
  struct wayland_display *self;
  _Bool ok = (_Bool)1;
  signed int error = 0;
  void *return_value_wcore_calloc_1;
  return_value_wcore_calloc_1=wcore_calloc(sizeof(struct wayland_display) /*64ul*/ );
  self = (struct wayland_display *)return_value_wcore_calloc_1;
  if(self == ((struct wayland_display *)NULL))
    return (struct wcore_display *)(void *)0;

  else
  {
    self->wl_display=wl_display_connect(name);
    if(self->wl_display == ((struct wl_display *)NULL))
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "wl_display_connect failed");

    else
    {
      self->wl_registry=wl_display_get_registry(self->wl_display);
      if(self->wl_registry == ((struct wl_registry *)NULL))
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "wl_display_get_registry failed");

      else
      {
        error=wl_registry_add_listener(self->wl_registry, &registry_listener, (void *)self);
        if(!(error >= 0))
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "wl_registry_add_listener failed");

        else
        {
          ok=wayland_display_sync(self);
          if(!(ok == (_Bool)0))
          {
            if(self->wl_compositor == ((struct wl_compositor *)NULL))
              wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "failed to bind to the wayland compositor");

            else
              if(self->wl_shell == ((struct wl_shell *)NULL))
                wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "failed to bind to the wayland shell");

              else
              {
                ok=wegl_display_init(&self->wegl, wc_plat, (signed long int)self->wl_display);
                if(!(ok == (_Bool)0))
                  return &self->wegl.wcore;

              }
          }

        }
      }
    }

  error:
    ;
    wayland_display_destroy(&self->wegl.wcore);
    return (struct wcore_display *)(void *)0;
  }
}

// wayland_display_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 43
_Bool wayland_display_destroy(struct wcore_display *wc_self)
{
  struct wayland_display *self;
  self=wayland_display(wc_self);
  _Bool ok = (_Bool)1;
  if(self == ((struct wayland_display *)NULL))
    return ok;

  else
  {
    _Bool return_value_wegl_display_teardown_1;
    return_value_wegl_display_teardown_1=wegl_display_teardown(&self->wegl);
    ok = ((signed int)ok & (signed int)return_value_wegl_display_teardown_1) != 0;
    if(!(self->wl_display == ((struct wl_display *)NULL)))
      wl_display_disconnect(self->wl_display);

    free((void *)self);
    return ok;
  }
}

// wayland_display_fill_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 155
void wayland_display_fill_native(struct wayland_display *self, struct waffle_wayland_display *n_dpy)
{
  n_dpy->wl_display = self->wl_display;
  n_dpy->wl_compositor = self->wl_compositor;
  n_dpy->wl_shell = self->wl_shell;
  n_dpy->egl_display = self->wegl.egl;
}

// wayland_display_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 165
union waffle_native_display * wayland_display_get_native(struct wcore_display *wc_self)
{
  struct wayland_display *self;
  self=wayland_display(wc_self);
  union waffle_native_display *n_dpy;
  do
  {
    void *return_value_wcore_malloc_1;
    return_value_wcore_malloc_1=wcore_malloc(sizeof(union waffle_native_display) /*8ul*/  + sizeof(struct waffle_wayland_display) /*32ul*/ );
    n_dpy = (union waffle_native_display *)return_value_wcore_malloc_1;
    if(!(n_dpy == ((union waffle_native_display *)NULL)))
      n_dpy->wayland = (struct waffle_wayland_display *)(void *)(n_dpy + (signed long int)1);

  }
  while((_Bool)0);
  if(n_dpy == ((union waffle_native_display *)NULL))
    return (union waffle_native_display *)(void *)0;

  else
  {
    wayland_display_fill_native(self, n_dpy->wayland);
    return n_dpy;
  }
}

// wayland_display_sync
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_display.c line 180
_Bool wayland_display_sync(struct wayland_display *dpy)
{
  signed int return_value_wl_display_roundtrip_1;
  return_value_wl_display_roundtrip_1=wl_display_roundtrip(dpy->wl_display);
  if(return_value_wl_display_roundtrip_1 == -1)
  {
    wcore_error_errno("error on wl_display");
    return (_Bool)0;
  }

  else
    return (_Bool)1;
}

// wayland_dl_can_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.c line 96
static _Bool wayland_dl_can_open(struct wcore_platform *wc_self, signed int waffle_dl)
{
  struct wayland_platform *self;
  struct wegl_platform *return_value_wegl_platform_1;
  return_value_wegl_platform_1=wegl_platform_link5(wc_self);
  self=wayland_platform(return_value_wegl_platform_1);
  _Bool return_value_linux_platform_dl_can_open_2;
  return_value_linux_platform_dl_can_open_2=linux_platform_dl_can_open(self->linux, waffle_dl);
  return return_value_linux_platform_dl_can_open_2;
}

// wayland_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.c line 104
static void * wayland_dl_sym(struct wcore_platform *wc_self, signed int waffle_dl, const char *name)
{
  struct wayland_platform *self;
  struct wegl_platform *return_value_wegl_platform_1;
  return_value_wegl_platform_1=wegl_platform_link5(wc_self);
  self=wayland_platform(return_value_wegl_platform_1);
  void *return_value_linux_platform_dl_sym_2;
  return_value_linux_platform_dl_sym_2=linux_platform_dl_sym(self->linux, waffle_dl, name);
  return return_value_linux_platform_dl_sym_2;
}

// wayland_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.h line 45
static inline struct wayland_platform * wayland_platform(struct wegl_platform *wegl_self)
{
  struct wayland_platform *tmp_statement_expression_1;
  if(!(wegl_self == ((struct wegl_platform *)NULL)))
  {
    const struct wegl_platform *__mptr = wegl_self;
    tmp_statement_expression_1 = (struct wayland_platform *)((void *)__mptr - (signed long int)0ul);
    return tmp_statement_expression_1;
  }

  else
    return ((struct wayland_platform *)NULL);
}

// wayland_platform_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_init.c line 34
struct wcore_platform * wayland_platform_create(void)
{
  struct wayland_platform *self;
  _Bool ok = (_Bool)1;
  void *return_value_wcore_calloc_1;
  return_value_wcore_calloc_1=wcore_calloc(sizeof(struct wayland_platform) /*144ul*/ );
  self = (struct wayland_platform *)return_value_wcore_calloc_1;
  if(self == ((struct wayland_platform *)NULL))
    return (struct wcore_platform *)(void *)0;

  else
  {
    ok=wegl_platform_init(&self->wegl);
    if(!(ok == (_Bool)0))
    {
      self->linux=linux_platform_create();
      if(self->linux == ((struct linux_platform *)NULL))
        goto error;

      setenv("EGL_PLATFORM", "wayland", 1);
      self->wegl.wcore.vtbl = &wayland_platform_vtbl;
      return &self->wegl.wcore;
    }

    else
    {

    error:
      ;
      wayland_platform_destroy(&self->wegl.wcore);
      return (struct wcore_platform *)(void *)0;
    }
  }
}

// wayland_platform_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_platform.c line 49
static _Bool wayland_platform_destroy(struct wcore_platform *wc_self)
{
  struct wayland_platform *self;
  struct wegl_platform *return_value_wegl_platform_1;
  return_value_wegl_platform_1=wegl_platform_link5(wc_self);
  self=wayland_platform(return_value_wegl_platform_1);
  _Bool ok = (_Bool)1;
  _Bool return_value_linux_platform_destroy_2;
  if(self == ((struct wayland_platform *)NULL))
    return (_Bool)1;

  else
  {
    unsetenv("EGL_PLATFORM");
    if(!(self->linux == ((struct linux_platform *)NULL)))
    {
      return_value_linux_platform_destroy_2=linux_platform_destroy(self->linux);
      ok = ((signed int)ok & (signed int)return_value_linux_platform_destroy_2) != 0;
    }

    _Bool return_value_wegl_platform_teardown_3;
    return_value_wegl_platform_teardown_3=wegl_platform_teardown(&self->wegl);
    ok = ((signed int)ok & (signed int)return_value_wegl_platform_teardown_3) != 0;
    free((void *)self);
    return ok;
  }
}

// wayland_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 48
static inline struct wayland_window * wayland_window(struct wcore_window *wc_self)
{
  struct wegl_window *tmp_statement_expression_1;
  struct wayland_window *tmp_statement_expression_2;
  if(!(wc_self == ((struct wcore_window *)NULL)))
  {
    struct wegl_window *wegl_self;
    const struct wcore_window *__mptr = wc_self;
    tmp_statement_expression_1 = (struct wegl_window *)((void *)__mptr - (signed long int)0ul);
    wegl_self = tmp_statement_expression_1;
    const struct wegl_window *wayland_window__1__1__2____mptr = wegl_self;
    tmp_statement_expression_2 = (struct wayland_window *)((void *)wayland_window__1__1__2____mptr - (signed long int)24ul);
    return tmp_statement_expression_2;
  }

  else
    return (struct wayland_window *)(void *)0;
}

// wayland_window_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 60
struct wcore_window * wayland_window_create(struct wcore_platform *wc_plat, struct wcore_config *wc_config, signed int width, signed int height)
{
  struct wayland_window *self;
  struct wayland_display *dpy;
  dpy=wayland_display_link2(wc_config->display);
  _Bool ok = (_Bool)1;
  void *return_value_wcore_calloc_1;
  return_value_wcore_calloc_1=wcore_calloc(sizeof(struct wayland_window) /*48ul*/ );
  self = (struct wayland_window *)return_value_wcore_calloc_1;
  if(self == ((struct wayland_window *)NULL))
    return (struct wcore_window *)(void *)0;

  else
  {
    if(dpy->wl_compositor == ((struct wl_compositor *)NULL))
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "wayland compositor not found");

    else
      if(dpy->wl_shell == ((struct wl_shell *)NULL))
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "wayland shell not found");

      else
      {
        self->wl_surface=wl_compositor_create_surface(dpy->wl_compositor);
        if(self->wl_surface == ((struct wl_surface *)NULL))
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "wl_compositor_create_surface failed");

        else
        {
          self->wl_shell_surface=wl_shell_get_shell_surface(dpy->wl_shell, self->wl_surface);
          if(self->wl_shell_surface == ((struct wl_shell_surface *)NULL))
            wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "wl_shell_get_shell_surface failed");

          else
          {
            wl_shell_surface_add_listener(self->wl_shell_surface, &shell_surface_listener, (void *)0);
            self->wl_window=wl_egl_window_create(self->wl_surface, width, height);
            if(self->wl_window == ((struct wl_egl_window *)NULL))
              wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "wl_egl_window_create failed");

            else
            {
              ok=wegl_window_init(&self->wegl, wc_config, (signed long int)self->wl_window);
              if(!(ok == (_Bool)0))
              {
                ok=wayland_display_sync(dpy);
                if(!(ok == (_Bool)0))
                  return &self->wegl.wcore;

              }

            }
          }
        }
      }

  error:
    ;
    wayland_window_destroy(&self->wegl.wcore);
    return (struct wcore_window *)(void *)0;
  }
}

// wayland_window_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 66
_Bool wayland_window_destroy(struct wcore_window *wc_self)
{
  struct wayland_window *self;
  self=wayland_window(wc_self);
  _Bool ok = (_Bool)1;
  if(self == ((struct wayland_window *)NULL))
    return ok;

  else
  {
    _Bool return_value_wegl_window_teardown_1;
    return_value_wegl_window_teardown_1=wegl_window_teardown(&self->wegl);
    ok = ((signed int)ok & (signed int)return_value_wegl_window_teardown_1) != 0;
    if(!(self->wl_window == ((struct wl_egl_window *)NULL)))
      wl_egl_window_destroy(self->wl_window);

    if(!(self->wl_shell_surface == ((struct wl_shell_surface *)NULL)))
      wl_shell_surface_destroy(self->wl_shell_surface);

    if(!(self->wl_surface == ((struct wl_surface *)NULL)))
      wl_surface_destroy(self->wl_surface);

    free((void *)self);
    return ok;
  }
}

// wayland_window_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 79
union waffle_native_window * wayland_window_get_native(struct wcore_window *wc_self)
{
  struct wayland_window *self;
  self=wayland_window(wc_self);
  struct wayland_display *dpy;
  dpy=wayland_display_link2(wc_self->display);
  union waffle_native_window *n_window;
  do
  {
    void *return_value_wcore_malloc_1;
    return_value_wcore_malloc_1=wcore_malloc(sizeof(union waffle_native_window) /*8ul*/  + sizeof(struct waffle_wayland_window) /*64ul*/ );
    n_window = (union waffle_native_window *)return_value_wcore_malloc_1;
    if(!(n_window == ((union waffle_native_window *)NULL)))
      n_window->wayland = (struct waffle_wayland_window *)(void *)(n_window + (signed long int)1);

  }
  while((_Bool)0);
  if(n_window == ((union waffle_native_window *)NULL))
    return (union waffle_native_window *)(void *)0;

  else
  {
    wayland_display_fill_native(dpy, &n_window->wayland->display);
    n_window->wayland->wl_surface = self->wl_surface;
    n_window->wayland->wl_shell_surface = self->wl_shell_surface;
    n_window->wayland->wl_window = self->wl_window;
    n_window->wayland->egl_surface = self->wegl.egl;
    return n_window;
  }
}

// wayland_window_resize
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 75
_Bool wayland_window_resize(struct wcore_window *wc_self, signed int width, signed int height)
{
  struct wayland_window *self;
  self=wayland_window(wc_self);
  struct wayland_display *dpy;
  dpy=wayland_display_link2(self->wegl.wcore.display);
  struct wayland_window *return_value_wayland_window_1;
  return_value_wayland_window_1=wayland_window(wc_self);
  wl_egl_window_resize(return_value_wayland_window_1->wl_window, width, height, 0, 0);
  _Bool return_value_wayland_display_sync_2;
  return_value_wayland_display_sync_2=wayland_display_sync(dpy);
  if(return_value_wayland_display_sync_2 == (_Bool)0)
    return (_Bool)0;

  else
    return (_Bool)1;
}

// wayland_window_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 69
_Bool wayland_window_show(struct wcore_window *wc_self)
{
  struct wayland_window *self;
  self=wayland_window(wc_self);
  struct wayland_display *dpy;
  dpy=wayland_display_link2(wc_self->display);
  _Bool ok = (_Bool)1;
  wl_shell_surface_set_toplevel(self->wl_shell_surface);
  ok=wayland_display_sync(dpy);
  if(ok == (_Bool)0)
    return (_Bool)0;

  else
    return (_Bool)1;
}

// wayland_window_swap_buffers
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/wayland/wayland_window.h line 72
_Bool wayland_window_swap_buffers(struct wcore_window *wc_self)
{
  struct wayland_display *dpy;
  dpy=wayland_display_link2(wc_self->display);
  _Bool ok;
  ok=wegl_window_swap_buffers(wc_self);
  if(ok == (_Bool)0)
    return (_Bool)0;

  else
  {
    ok=wayland_display_sync(dpy);
    if(ok == (_Bool)0)
      return (_Bool)0;

    else
      return (_Bool)1;
  }
}

// wcore_attrib_list_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_attrib_list.h line 35
_Bool wcore_attrib_list_get(const signed int *attrib_list, signed int key, signed int *value)
{
  if(attrib_list == ((const signed int *)NULL))
    return (_Bool)0;

  else
  {
    signed int i = 0;
    for( ; !(attrib_list[(signed long int)i] == 0); i = i + 2)
      if(attrib_list[(signed long int)i] == key)
      {
        *value = attrib_list[(signed long int)(i + 1)];
        return (_Bool)1;
      }

    return (_Bool)0;
  }
}

// wcore_attrib_list_get_with_default
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_attrib_list.h line 41
_Bool wcore_attrib_list_get_with_default(const signed int *attrib_list, signed int key, signed int *value, signed int default_value)
{
  _Bool return_value_wcore_attrib_list_get_1;
  return_value_wcore_attrib_list_get_1=wcore_attrib_list_get(attrib_list, key, value);
  if(!(return_value_wcore_attrib_list_get_1 == (_Bool)0))
    return (_Bool)1;

  else
  {
    *value = default_value;
    return (_Bool)0;
  }
}

// wcore_attrib_list_length
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_attrib_list.h line 32
signed int wcore_attrib_list_length(const signed int *attrib_list)
{
  const signed int *i = attrib_list;
  if(attrib_list == ((const signed int *)NULL))
    return 0;

  else
  {
    for( ; !(*i == 0); i = i + (signed long int)2)
      ;
    return (signed int)(i - attrib_list) / 2;
  }
}

// wcore_attrib_list_update
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_attrib_list.h line 48
_Bool wcore_attrib_list_update(signed int *attrib_list, signed int key, signed int value)
{
  signed int *i = attrib_list;
  if(attrib_list == ((signed int *)NULL))
    return (_Bool)0;

  else
  {
    for( ; !(*i == 0); i = i + (signed long int)2)
      if(*i == key)
        break;

    if(*i == key)
    {
      i[(signed long int)1] = value;
      return (_Bool)1;
    }

    else
      return (_Bool)0;
  }
}

// wcore_calloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_util.c line 41
void * wcore_calloc(unsigned long int size)
{
  void *p;
  p=calloc((unsigned long int)1, size);
  if(p == NULL)
    wcore_error((enum waffle_error)WAFFLE_ERROR_BAD_ALLOC);

  return p;
}

// wcore_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 54
static inline struct wcore_config * wcore_config(struct waffle_config *cfg)
{
  return (struct wcore_config *)cfg;
}

// wcore_config_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 54
static inline struct wcore_config * wcore_config_link1(struct waffle_config *cfg_link1)
{
  return (struct wcore_config *)cfg_link1;
}

// wcore_config_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 54
static inline struct wcore_config * wcore_config_link2(struct waffle_config *cfg_link2)
{
  return (struct wcore_config *)cfg_link2;
}

// wcore_config_attrs_parse
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.h line 59
_Bool wcore_config_attrs_parse(const signed int *waffle_attrib_list, struct wcore_config_attrs *attrs)
{
  memset((void *)attrs, 0, sizeof(struct wcore_config_attrs) /*60ul*/ );
  _Bool return_value_check_keys_1;
  return_value_check_keys_1=check_keys(waffle_attrib_list);
  if(return_value_check_keys_1 == (_Bool)0)
    return (_Bool)0;

  else
  {
    _Bool return_value_parse_context_api_2;
    return_value_parse_context_api_2=parse_context_api(attrs, waffle_attrib_list);
    if(return_value_parse_context_api_2 == (_Bool)0)
      return (_Bool)0;

    else
    {
      _Bool return_value_set_context_version_default_3;
      return_value_set_context_version_default_3=set_context_version_default(attrs);
      if(return_value_set_context_version_default_3 == (_Bool)0)
        return (_Bool)0;

      else
      {
        _Bool return_value_parse_context_version_4;
        return_value_parse_context_version_4=parse_context_version(attrs, waffle_attrib_list);
        if(return_value_parse_context_version_4 == (_Bool)0)
          return (_Bool)0;

        else
        {
          _Bool return_value_set_context_profile_default_5;
          return_value_set_context_profile_default_5=set_context_profile_default(attrs);
          if(return_value_set_context_profile_default_5 == (_Bool)0)
            return (_Bool)0;

          else
          {
            _Bool return_value_parse_context_profile_6;
            return_value_parse_context_profile_6=parse_context_profile(attrs, waffle_attrib_list);
            if(return_value_parse_context_profile_6 == (_Bool)0)
              return (_Bool)0;

            else
            {
              _Bool return_value_parse_context_forward_compatible_7;
              return_value_parse_context_forward_compatible_7=parse_context_forward_compatible(attrs, waffle_attrib_list);
              if(return_value_parse_context_forward_compatible_7 == (_Bool)0)
                return (_Bool)0;

              else
              {
                _Bool return_value_set_misc_defaults_8;
                return_value_set_misc_defaults_8=set_misc_defaults(attrs);
                if(return_value_set_misc_defaults_8 == (_Bool)0)
                  return (_Bool)0;

                else
                {
                  _Bool return_value_parse_misc_9;
                  return_value_parse_misc_9=parse_misc(attrs, waffle_attrib_list);
                  if(return_value_parse_misc_9 == (_Bool)0)
                    return (_Bool)0;

                  else
                  {
                    _Bool return_value_check_final_10;
                    return_value_check_final_10=check_final(attrs);
                    if(return_value_check_final_10 == (_Bool)0)
                      return (_Bool)0;

                    else
                      return (_Bool)1;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

// wcore_config_attrs_version_eq
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 512
_Bool wcore_config_attrs_version_eq(struct wcore_config_attrs *attrs, signed int merged_version)
{
  _Bool tmp_if_expr_1;
  if(attrs->context_major_version == merged_version / 10)
    tmp_if_expr_1 = attrs->context_minor_version == merged_version % 10 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  return tmp_if_expr_1;
}

// wcore_config_attrs_version_ge
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 533
_Bool wcore_config_attrs_version_ge(struct wcore_config_attrs *attrs, signed int merged_version)
{
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  if(!(merged_version / 10 >= attrs->context_major_version))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    if(attrs->context_major_version == merged_version / 10)
      tmp_if_expr_1 = attrs->context_minor_version >= merged_version % 10 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
  }
  return tmp_if_expr_2;
}

// wcore_config_attrs_version_gt
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 522
_Bool wcore_config_attrs_version_gt(struct wcore_config_attrs *attrs, signed int merged_version)
{
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_1;
  if(!(merged_version / 10 >= attrs->context_major_version))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    if(attrs->context_major_version == merged_version / 10)
      tmp_if_expr_1 = attrs->context_minor_version > merged_version % 10 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
  }
  return tmp_if_expr_2;
}

// wcore_config_attrs_version_le
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 552
_Bool wcore_config_attrs_version_le(struct wcore_config_attrs *attrs, signed int merged_version)
{
  _Bool return_value_wcore_config_attrs_version_gt_1;
  return_value_wcore_config_attrs_version_gt_1=wcore_config_attrs_version_gt(attrs, merged_version);
  return !(return_value_wcore_config_attrs_version_gt_1 != (_Bool)0);
}

// wcore_config_attrs_version_lt
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config_attrs.c line 544
_Bool wcore_config_attrs_version_lt(struct wcore_config_attrs *attrs, signed int merged_version)
{
  _Bool return_value_wcore_config_attrs_version_ge_1;
  return_value_wcore_config_attrs_version_ge_1=wcore_config_attrs_version_ge(attrs, merged_version);
  return !(return_value_wcore_config_attrs_version_ge_1 != (_Bool)0);
}

// wcore_config_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 59
static inline _Bool wcore_config_init(struct wcore_config *self, struct wcore_display *display, struct wcore_config_attrs *attrs)
{
  self->api.display_id = display->api.display_id;
  self->display = display;
  memcpy((void *)&self->attrs, (const void *)attrs, sizeof(struct wcore_config_attrs) /*60ul*/ );
  return (_Bool)1;
}

// wcore_config_init_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 59
static inline _Bool wcore_config_init_link1(struct wcore_config *self_link1, struct wcore_display *display_link1, struct wcore_config_attrs *attrs_link1)
{
  self_link1->api.display_id = display_link1->api.display_id;
  self_link1->display = display_link1;
  memcpy((void *)&self_link1->attrs, (const void *)attrs_link1, sizeof(struct wcore_config_attrs) /*60ul*/ );
  return (_Bool)1;
}

// wcore_config_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 74
static inline _Bool wcore_config_teardown(struct wcore_config *self)
{
  return (_Bool)1;
}

// wcore_config_teardown_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_config.h line 74
static inline _Bool wcore_config_teardown_link1(struct wcore_config *self_link1)
{
  return (_Bool)1;
}

// wcore_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 52
static inline struct wcore_context * wcore_context(struct waffle_context *ctx)
{
  return (struct wcore_context *)ctx;
}

// wcore_context_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 52
static inline struct wcore_context * wcore_context_link1(struct waffle_context *ctx_link1)
{
  return (struct wcore_context *)ctx_link1;
}

// wcore_context_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 57
static inline _Bool wcore_context_init(struct wcore_context *self, struct wcore_config *config)
{
  self->api.display_id = config->display->api.display_id;
  self->display = config->display;
  return (_Bool)1;
}

// wcore_context_init_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 57
static inline _Bool wcore_context_init_link1(struct wcore_context *self_link1, struct wcore_config *config_link1)
{
  self_link1->api.display_id = config_link1->display->api.display_id;
  self_link1->display = config_link1->display;
  return (_Bool)1;
}

// wcore_context_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 70
static inline _Bool wcore_context_teardown(struct wcore_context *self)
{
  return (_Bool)1;
}

// wcore_context_teardown_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_context.h line 70
static inline _Bool wcore_context_teardown_link1(struct wcore_context *self_link1)
{
  return (_Bool)1;
}

// wcore_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_display.h line 49
static inline struct wcore_display * wcore_display(struct waffle_display *dpy)
{
  return (struct wcore_display *)dpy;
}

// wcore_display_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_display.h line 49
static inline struct wcore_display * wcore_display_link1(struct waffle_display *dpy_link1)
{
  return (struct wcore_display *)dpy_link1;
}

// wcore_display_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_display.h line 49
static inline struct wcore_display * wcore_display_link2(struct waffle_display *dpy_link2)
{
  return (struct wcore_display *)dpy_link2;
}

// wcore_display_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_display.c line 33
_Bool wcore_display_init(struct wcore_display *self, struct wcore_platform *platform)
{
  static union anonymous_7 mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
  mtx_lock(&mutex);
  static unsigned long int id_counter = (unsigned long int)0;
  id_counter = id_counter + 1ul;
  self->api.display_id = id_counter;
  mtx_unlock(&mutex);
  self->platform = platform;
  if(self->api.display_id == 0ul)
  {
    fprintf(stderr, "waffle: error: internal counter wrapped to 0\n");
    abort();
  }

  return (_Bool)1;
}

// wcore_display_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_display.c line 57
_Bool wcore_display_teardown(struct wcore_display *self)
{
  return (_Bool)1;
}

// wcore_enum_to_string
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_util.h line 82
const char * wcore_enum_to_string(signed int e)
{
  switch(e)
  {
    case WAFFLE_DONT_CARE:
      return "WAFFLE_DONT_CARE";
    case WAFFLE_NONE:
      return "WAFFLE_NONE";
    case WAFFLE_PLATFORM:
      return "WAFFLE_PLATFORM";
    case WAFFLE_PLATFORM_ANDROID:
      return "WAFFLE_PLATFORM_ANDROID";
    case WAFFLE_PLATFORM_CGL:
      return "WAFFLE_PLATFORM_CGL";
    case WAFFLE_PLATFORM_GLX:
      return "WAFFLE_PLATFORM_GLX";
    case WAFFLE_PLATFORM_WAYLAND:
      return "WAFFLE_PLATFORM_WAYLAND";
    case WAFFLE_PLATFORM_X11_EGL:
      return "WAFFLE_PLATFORM_X11_EGL";
    case WAFFLE_PLATFORM_GBM:
      return "WAFFLE_PLATFORM_GBM";
    case WAFFLE_PLATFORM_WGL:
      return "WAFFLE_PLATFORM_WGL";
    case WAFFLE_CONTEXT_API:
      return "WAFFLE_CONTEXT_API";
    case WAFFLE_CONTEXT_OPENGL:
      return "WAFFLE_CONTEXT_OPENGL";
    case WAFFLE_CONTEXT_OPENGL_ES1:
      return "WAFFLE_CONTEXT_OPENGL_ES1";
    case WAFFLE_CONTEXT_OPENGL_ES2:
      return "WAFFLE_CONTEXT_OPENGL_ES2";
    case WAFFLE_CONTEXT_OPENGL_ES3:
      return "WAFFLE_CONTEXT_OPENGL_ES3";
    case WAFFLE_CONTEXT_MAJOR_VERSION:
      return "WAFFLE_CONTEXT_MAJOR_VERSION";
    case WAFFLE_CONTEXT_MINOR_VERSION:
      return "WAFFLE_CONTEXT_MINOR_VERSION";
    case WAFFLE_CONTEXT_PROFILE:
      return "WAFFLE_CONTEXT_PROFILE";
    case WAFFLE_CONTEXT_CORE_PROFILE:
      return "WAFFLE_CONTEXT_CORE_PROFILE";
    case WAFFLE_CONTEXT_COMPATIBILITY_PROFILE:
      return "WAFFLE_CONTEXT_COMPATIBILITY_PROFILE";
    case WAFFLE_CONTEXT_FORWARD_COMPATIBLE:
      return "WAFFLE_CONTEXT_FORWARD_COMPATIBLE";
    case WAFFLE_CONTEXT_DEBUG:
      return "WAFFLE_CONTEXT_DEBUG";
    case WAFFLE_RED_SIZE:
      return "WAFFLE_RED_SIZE";
    case WAFFLE_GREEN_SIZE:
      return "WAFFLE_GREEN_SIZE";
    case WAFFLE_BLUE_SIZE:
      return "WAFFLE_BLUE_SIZE";
    case WAFFLE_ALPHA_SIZE:
      return "WAFFLE_ALPHA_SIZE";
    case WAFFLE_DEPTH_SIZE:
      return "WAFFLE_DEPTH_SIZE";
    case WAFFLE_STENCIL_SIZE:
      return "WAFFLE_STENCIL_SIZE";
    case WAFFLE_SAMPLE_BUFFERS:
      return "WAFFLE_SAMPLE_BUFFERS";
    case WAFFLE_SAMPLES:
      return "WAFFLE_SAMPLES";
    case WAFFLE_DOUBLE_BUFFERED:
      return "WAFFLE_DOUBLE_BUFFERED";
    case WAFFLE_ACCUM_BUFFER:
      return "WAFFLE_ACCUM_BUFFER";
    case WAFFLE_DL_OPENGL:
      return "WAFFLE_DL_OPENGL";
    case WAFFLE_DL_OPENGL_ES1:
      return "WAFFLE_DL_OPENGL_ES1";
    case WAFFLE_DL_OPENGL_ES2:
      return "WAFFLE_DL_OPENGL_ES2";
    case WAFFLE_DL_OPENGL_ES3:
      return "WAFFLE_DL_OPENGL_ES3";
    default:
      return (const char *)(void *)0;
  }
}

// wcore_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 49
void wcore_error(enum waffle_error error)
{
  struct wcore_error_tinfo *t;
  struct wcore_tinfo *return_value_wcore_tinfo_get_1;
  return_value_wcore_tinfo_get_1=wcore_tinfo_get();
  t = return_value_wcore_tinfo_get_1->error;
  if(!(t->is_enabled == (_Bool)0))
  {
    if((signed int)t->code == WAFFLE_NO_ERROR)
    {
      t->code = error;
      t->message[(signed long int)0] = (char)0;
    }

  }

}

// wcore_error_errno
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.c line 137
void wcore_error_errno(const char *format, ...)
{
  signed int saved_errno;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  saved_errno = *return_value___errno_location_1;
  struct wcore_error_tinfo *t;
  struct wcore_tinfo *return_value_wcore_tinfo_get_2;
  return_value_wcore_tinfo_get_2=wcore_tinfo_get();
  t = return_value_wcore_tinfo_get_2->error;
  char *cur = t->message;
  char *end = t->message + (signed long int)1024;
  signed int printed;
  if(!(t->is_enabled == (_Bool)0))
  {
    t->code = (enum waffle_error)WAFFLE_ERROR_UNKNOWN;
    if(!(format == ((const char *)NULL)))
    {
      void **ap = (void **)&format;
      printed=vsnprintf(cur, (unsigned long int)(end - cur), format, ap);
      cur = cur + (signed long int)printed;
      ap = ((void **)NULL);
      if(cur >= end || !(printed >= 0))
        goto __CPROVER_DUMP_L5;

      printed=snprintf(cur, (unsigned long int)(end - cur), ": ");
      cur = cur + (signed long int)printed;
      if(cur >= end || !(printed >= 0))
        goto __CPROVER_DUMP_L5;

    }

    strerror_r(saved_errno, cur, (unsigned long int)(end - cur));
  }


__CPROVER_DUMP_L5:
  ;
}

// wcore_error_get_code
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 80
enum waffle_error wcore_error_get_code(void)
{
  struct wcore_tinfo *return_value_wcore_tinfo_get_1;
  return_value_wcore_tinfo_get_1=wcore_tinfo_get();
  return return_value_wcore_tinfo_get_1->error->code;
}

// wcore_error_get_info
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 84
struct waffle_error_info * wcore_error_get_info(void)
{
  struct wcore_error_tinfo *info;
  struct wcore_tinfo *return_value_wcore_tinfo_get_1;
  return_value_wcore_tinfo_get_1=wcore_tinfo_get();
  info = return_value_wcore_tinfo_get_1->error;
  info->user_info.code = info->code;
  info->user_info.message = info->message;
  info->user_info.message_length=strlen(info->message);
  return &info->user_info;
}

// wcore_error_reset
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 43
void wcore_error_reset(void)
{
  struct wcore_error_tinfo *t;
  struct wcore_tinfo *return_value_wcore_tinfo_get_1;
  return_value_wcore_tinfo_get_1=wcore_tinfo_get();
  t = return_value_wcore_tinfo_get_1->error;
  if(!(t->is_enabled == (_Bool)0))
  {
    t->code = (enum waffle_error)WAFFLE_NO_ERROR;
    t->message[(signed long int)0] = (char)0;
  }

}

// wcore_error_tinfo_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.c line 51
struct wcore_error_tinfo * wcore_error_tinfo_create(void)
{
  struct wcore_error_tinfo *self;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct wcore_error_tinfo) /*1056ul*/ );
  self = (struct wcore_error_tinfo *)return_value_malloc_1;
  if(self == ((struct wcore_error_tinfo *)NULL))
    return (struct wcore_error_tinfo *)(void *)0;

  else
  {
    self->is_enabled = (_Bool)1;
    self->code = (enum waffle_error)WAFFLE_NO_ERROR;
    self->message[(signed long int)0] = (char)0;
    return self;
  }
}

// wcore_error_tinfo_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.c line 65
_Bool wcore_error_tinfo_destroy(struct wcore_error_tinfo *self)
{
  free((void *)self);
  return (_Bool)1;
}

// wcore_errorf
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_error.h line 56
void wcore_errorf(enum waffle_error error, const char *format, ...)
{
  struct wcore_error_tinfo *t;
  struct wcore_tinfo *return_value_wcore_tinfo_get_1;
  return_value_wcore_tinfo_get_1=wcore_tinfo_get();
  t = return_value_wcore_tinfo_get_1->error;
  void **ap;
  if(!(t->is_enabled == (_Bool)0))
  {
    if((signed int)t->code == WAFFLE_NO_ERROR)
    {
      t->code = error;
      ap = (void **)&format;
      vsnprintf(t->message, (unsigned long int)(1024 - 1), format, ap);
      ap = ((void **)NULL);
    }

  }

}

// wcore_malloc
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_util.c line 32
void * wcore_malloc(unsigned long int size)
{
  void *p;
  p=malloc(size);
  if(p == NULL)
    wcore_error((enum waffle_error)WAFFLE_ERROR_BAD_ALLOC);

  return p;
}

// wcore_platform_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 144
static inline _Bool wcore_platform_init(struct wcore_platform *self)
{
  return (_Bool)1;
}

// wcore_platform_init_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 144
static inline _Bool wcore_platform_init_link1(struct wcore_platform *self_link1)
{
  return (_Bool)1;
}

// wcore_platform_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 151
static inline _Bool wcore_platform_teardown(struct wcore_platform *self)
{
  return (_Bool)1;
}

// wcore_platform_teardown_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_platform.h line 151
static inline _Bool wcore_platform_teardown_link1(struct wcore_platform *self_link1)
{
  return (_Bool)1;
}

// wcore_tinfo_abort_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.c line 66
static void wcore_tinfo_abort_init(void)
{
  printf("waffle: fatal-error: failed to initialize thread local info\n");
  abort();
}

// wcore_tinfo_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.h line 39
struct wcore_tinfo * wcore_tinfo_get(void)
{
  wcore_tinfo_init(&wcore_tinfo);
  return &wcore_tinfo;
}

// wcore_tinfo_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.c line 97
static void wcore_tinfo_init(struct wcore_tinfo *tinfo)
{
  signed int err;
  if(tinfo->is_init == (_Bool)0)
  {
    tinfo->error=wcore_error_tinfo_create();
    if(tinfo->error == ((struct wcore_error_tinfo *)NULL))
      wcore_tinfo_abort_init();

    tinfo->is_init = (_Bool)1;
    call_once(&wcore_tinfo_once, wcore_tinfo_key_create);
    err=tss_set(wcore_tinfo_key, (void *)tinfo);
    if(!(err == 0))
      wcore_tinfo_abort_init();

  }

}

// wcore_tinfo_key_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.c line 87
static void wcore_tinfo_key_create(void)
{
  signed int err;
  err=tss_create(&wcore_tinfo_key, wcore_tinfo_key_dtor);
  if(!(err == 0))
    wcore_tinfo_abort_init();

}

// wcore_tinfo_key_dtor
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_tinfo.c line 73
static void wcore_tinfo_key_dtor(void *args)
{
  struct wcore_tinfo *tinfo = (struct wcore_tinfo *)args;
  if(!(tinfo == ((struct wcore_tinfo *)NULL)))
    wcore_error_tinfo_destroy(tinfo->error);

}

// wcore_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 45
static inline struct wcore_window * wcore_window(struct waffle_window *win)
{
  return (struct wcore_window *)win;
}

// wcore_window_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 45
static inline struct wcore_window * wcore_window_link1(struct waffle_window *win_link1)
{
  return (struct wcore_window *)win_link1;
}

// wcore_window_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 50
static inline _Bool wcore_window_init(struct wcore_window *self, struct wcore_config *config)
{
  self->api.display_id = config->display->api.display_id;
  self->display = config->display;
  return (_Bool)1;
}

// wcore_window_init_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 50
static inline _Bool wcore_window_init_link1(struct wcore_window *self_link1, struct wcore_config *config_link1)
{
  self_link1->api.display_id = config_link1->display->api.display_id;
  self_link1->display = config_link1->display;
  return (_Bool)1;
}

// wcore_window_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 63
static inline _Bool wcore_window_teardown(struct wcore_window *self)
{
  return (_Bool)1;
}

// wcore_window_teardown_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/core/wcore_window.h line 63
static inline _Bool wcore_window_teardown_link1(struct wcore_window *self_link1)
{
  return (_Bool)1;
}

// wegl_config
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config(struct wcore_config *wcore_self)
{
  struct wegl_config *tmp_statement_expression_1;
  if(!(wcore_self == ((struct wcore_config *)NULL)))
  {
    const struct wcore_config *__mptr = wcore_self;
    tmp_statement_expression_1 = (struct wegl_config *)((void *)__mptr - (signed long int)0ul);
    return tmp_statement_expression_1;
  }

  else
    return ((struct wegl_config *)NULL);
}

// wegl_config_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config_link1(struct wcore_config *wcore_self_link1)
{
  struct wegl_config *tmp_statement_expression_1_link1;
  if(!(wcore_self_link1 == ((struct wcore_config *)NULL)))
  {
    const struct wcore_config *__mptr_link1 = wcore_self_link1;
    tmp_statement_expression_1_link1 = (struct wegl_config *)((void *)__mptr_link1 - (signed long int)0ul);
    return tmp_statement_expression_1_link1;
  }

  else
    return ((struct wegl_config *)NULL);
}

// wegl_config_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config_link2(struct wcore_config *wcore_self_link2)
{
  struct wegl_config *tmp_statement_expression_1_link2;
  if(!(wcore_self_link2 == ((struct wcore_config *)NULL)))
  {
    const struct wcore_config *__mptr_link2 = wcore_self_link2;
    tmp_statement_expression_1_link2 = (struct wegl_config *)((void *)__mptr_link2 - (signed long int)0ul);
    return tmp_statement_expression_1_link2;
  }

  else
    return ((struct wegl_config *)NULL);
}

// wegl_config_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config_link3(struct wcore_config *wcore_self_link3)
{
  struct wegl_config *tmp_statement_expression_1_link3;
  if(!(wcore_self_link3 == ((struct wcore_config *)NULL)))
  {
    const struct wcore_config *__mptr_link3 = wcore_self_link3;
    tmp_statement_expression_1_link3 = (struct wegl_config *)((void *)__mptr_link3 - (signed long int)0ul);
    return tmp_statement_expression_1_link3;
  }

  else
    return ((struct wegl_config *)NULL);
}

// wegl_config_link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config_link4(struct wcore_config *wcore_self_link4)
{
  struct wegl_config *tmp_statement_expression_1_link4;
  if(!(wcore_self_link4 == ((struct wcore_config *)NULL)))
  {
    const struct wcore_config *__mptr_link4 = wcore_self_link4;
    tmp_statement_expression_1_link4 = (struct wegl_config *)((void *)__mptr_link4 - (signed long int)0ul);
    return tmp_statement_expression_1_link4;
  }

  else
    return ((struct wegl_config *)NULL);
}

// wegl_config_link5
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config_link5(struct wcore_config *wcore_self_link5)
{
  struct wegl_config *tmp_statement_expression_1_link5;
  if(!(wcore_self_link5 == ((struct wcore_config *)NULL)))
  {
    const struct wcore_config *__mptr_link5 = wcore_self_link5;
    tmp_statement_expression_1_link5 = (struct wegl_config *)((void *)__mptr_link5 - (signed long int)0ul);
    return tmp_statement_expression_1_link5;
  }

  else
    return ((struct wegl_config *)NULL);
}

// wegl_config_link6
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.h line 45
static inline struct wegl_config * wegl_config_link6(struct wcore_config *wcore_self_link6)
{
  struct wegl_config *tmp_statement_expression_1_link6;
  if(!(wcore_self_link6 == ((struct wcore_config *)NULL)))
  {
    const struct wcore_config *__mptr_link6 = wcore_self_link6;
    tmp_statement_expression_1_link6 = (struct wegl_config *)((void *)__mptr_link6 - (signed long int)0ul);
    return tmp_statement_expression_1_link6;
  }

  else
    return ((struct wegl_config *)NULL);
}

// wegl_config_choose
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.c line 210
struct wcore_config * wegl_config_choose(struct wcore_platform *wc_plat, struct wcore_display *wc_dpy, struct wcore_config_attrs *attrs)
{
  struct wegl_display *dpy;
  dpy=wegl_display(wc_dpy);
  struct wegl_config *config;
  _Bool ok;
  void *return_value_wcore_calloc_1;
  return_value_wcore_calloc_1=wcore_calloc(sizeof(struct wegl_config) /*88ul*/ );
  config = (struct wegl_config *)return_value_wcore_calloc_1;
  _Bool return_value_check_context_attrs_2;
  if(config == ((struct wegl_config *)NULL))
    return (struct wcore_config *)(void *)0;

  else
  {
    ok=wcore_config_init(&config->wcore, wc_dpy, attrs);
    if(!(ok == (_Bool)0))
    {
      return_value_check_context_attrs_2=check_context_attrs(dpy, attrs);
      if(return_value_check_context_attrs_2 == (_Bool)0)
        goto fail;

      config->egl=choose_real_config(dpy, attrs);
      if(config->egl == NULL)
        goto fail;

      return &config->wcore;
    }

    else
    {

    fail:
      ;
      wegl_config_destroy(&config->wcore);
      return (struct wcore_config *)(void *)0;
    }
  }
}

// wegl_config_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_config.c line 241
_Bool wegl_config_destroy(struct wcore_config *wc_config)
{
  struct wegl_config *config;
  config=wegl_config(wc_config);
  _Bool result = (_Bool)1;
  if(config == ((struct wegl_config *)NULL))
    return (_Bool)1;

  else
  {
    _Bool return_value_wcore_config_teardown_1;
    return_value_wcore_config_teardown_1=wcore_config_teardown(wc_config);
    result = ((signed int)result & (signed int)return_value_wcore_config_teardown_1) != 0;
    free((void *)config);
    return result;
  }
}

// wegl_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.h line 43
static inline struct wegl_context * wegl_context(struct wcore_context *wcore_self)
{
  struct wegl_context *tmp_statement_expression_1;
  if(!(wcore_self == ((struct wcore_context *)NULL)))
  {
    const struct wcore_context *__mptr = wcore_self;
    tmp_statement_expression_1 = (struct wegl_context *)((void *)__mptr - (signed long int)0ul);
    return tmp_statement_expression_1;
  }

  else
    return ((struct wegl_context *)NULL);
}

// wegl_context_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.h line 43
static inline struct wegl_context * wegl_context_link1(struct wcore_context *wcore_self_link1)
{
  struct wegl_context *tmp_statement_expression_1_link1;
  if(!(wcore_self_link1 == ((struct wcore_context *)NULL)))
  {
    const struct wcore_context *__mptr_link1 = wcore_self_link1;
    tmp_statement_expression_1_link1 = (struct wegl_context *)((void *)__mptr_link1 - (signed long int)0ul);
    return tmp_statement_expression_1_link1;
  }

  else
    return ((struct wegl_context *)NULL);
}

// wegl_context_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.h line 43
static inline struct wegl_context * wegl_context_link2(struct wcore_context *wcore_self_link2)
{
  struct wegl_context *tmp_statement_expression_1_link2;
  if(!(wcore_self_link2 == ((struct wcore_context *)NULL)))
  {
    const struct wcore_context *__mptr_link2 = wcore_self_link2;
    tmp_statement_expression_1_link2 = (struct wegl_context *)((void *)__mptr_link2 - (signed long int)0ul);
    return tmp_statement_expression_1_link2;
  }

  else
    return ((struct wegl_context *)NULL);
}

// wegl_context_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.h line 43
static inline struct wegl_context * wegl_context_link3(struct wcore_context *wcore_self_link3)
{
  struct wegl_context *tmp_statement_expression_1_link3;
  if(!(wcore_self_link3 == ((struct wcore_context *)NULL)))
  {
    const struct wcore_context *__mptr_link3 = wcore_self_link3;
    tmp_statement_expression_1_link3 = (struct wegl_context *)((void *)__mptr_link3 - (signed long int)0ul);
    return tmp_statement_expression_1_link3;
  }

  else
    return ((struct wegl_context *)NULL);
}

// wegl_context_link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.h line 43
static inline struct wegl_context * wegl_context_link4(struct wcore_context *wcore_self_link4)
{
  struct wegl_context *tmp_statement_expression_1_link4;
  if(!(wcore_self_link4 == ((struct wcore_context *)NULL)))
  {
    const struct wcore_context *__mptr_link4 = wcore_self_link4;
    tmp_statement_expression_1_link4 = (struct wegl_context *)((void *)__mptr_link4 - (signed long int)0ul);
    return tmp_statement_expression_1_link4;
  }

  else
    return ((struct wegl_context *)NULL);
}

// wegl_context_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.c line 160
struct wcore_context * wegl_context_create(struct wcore_platform *wc_plat, struct wcore_config *wc_config, struct wcore_context *wc_share_ctx)
{
  struct wegl_context *ctx;
  struct wegl_config *config;
  config=wegl_config_link1(wc_config);
  struct wegl_context *share_ctx;
  share_ctx=wegl_context(wc_share_ctx);
  _Bool ok;
  void *return_value_wcore_calloc_1;
  return_value_wcore_calloc_1=wcore_calloc(sizeof(struct wegl_context) /*24ul*/ );
  ctx = (struct wegl_context *)return_value_wcore_calloc_1;
  void *tmp_if_expr_2;
  if(ctx == ((struct wegl_context *)NULL))
    return (struct wcore_context *)(void *)0;

  else
  {
    ok=wcore_context_init(&ctx->wcore, &config->wcore);
    if(!(ok == (_Bool)0))
    {
      if(!(share_ctx == ((struct wegl_context *)NULL)))
        tmp_if_expr_2 = share_ctx->egl;

      else
        tmp_if_expr_2 = (void *)0;
      ctx->egl=create_real_context(config, tmp_if_expr_2);
      if(ctx->egl == NULL)
        goto fail;

      return &ctx->wcore;
    }

    else
    {

    fail:
      ;
      wegl_context_destroy(&ctx->wcore);
      return (struct wcore_context *)(void *)0;
    }
  }
}

// wegl_context_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_context.c line 192
_Bool wegl_context_destroy(struct wcore_context *wc_ctx)
{
  struct wegl_display *dpy;
  dpy=wegl_display_link1(wc_ctx->display);
  struct wegl_platform_2 *plat;
  plat=wegl_platform_link1(dpy->wcore.platform);
  struct wegl_context *ctx;
  _Bool result = (_Bool)1;
  if(wc_ctx == ((struct wcore_context *)NULL))
    return result;

  else
  {
    ctx=wegl_context(wc_ctx);
    if(!(ctx->egl == NULL))
    {
      _Bool ok;
      struct wegl_display *return_value_wegl_display_1;
      return_value_wegl_display_1=wegl_display_link1(wc_ctx->display);
      unsigned int return_value;
      return_value=plat->eglDestroyContext(return_value_wegl_display_1->egl, ctx->egl);
      ok = (_Bool)return_value;
      if(ok == (_Bool)0)
      {
        wegl_emit_error(plat, "eglDestroyContext");
        result = (_Bool)0;
      }

    }

    _Bool return_value_wcore_context_teardown_2;
    return_value_wcore_context_teardown_2=wcore_context_teardown(wc_ctx);
    result = ((signed int)result & (signed int)return_value_wcore_context_teardown_2) != 0;
    free((void *)ctx);
    return result;
  }
}

// wegl_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.h line 43
static inline struct wegl_display * wegl_display(struct wcore_display *wcore_self)
{
  struct wegl_display *tmp_statement_expression_1;
  if(!(wcore_self == ((struct wcore_display *)NULL)))
  {
    const struct wcore_display *__mptr = wcore_self;
    tmp_statement_expression_1 = (struct wegl_display *)((void *)__mptr - (signed long int)0ul);
    return tmp_statement_expression_1;
  }

  else
    return ((struct wegl_display *)NULL);
}

// wegl_display_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.h line 43
static inline struct wegl_display * wegl_display_link1(struct wcore_display *wcore_self_link1)
{
  struct wegl_display *tmp_statement_expression_1_link1;
  if(!(wcore_self_link1 == ((struct wcore_display *)NULL)))
  {
    const struct wcore_display *__mptr_link1 = wcore_self_link1;
    tmp_statement_expression_1_link1 = (struct wegl_display *)((void *)__mptr_link1 - (signed long int)0ul);
    return tmp_statement_expression_1_link1;
  }

  else
    return ((struct wegl_display *)NULL);
}

// wegl_display_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.h line 43
static inline struct wegl_display * wegl_display_link2(struct wcore_display *wcore_self_link2)
{
  struct wegl_display *tmp_statement_expression_1_link2;
  if(!(wcore_self_link2 == ((struct wcore_display *)NULL)))
  {
    const struct wcore_display *__mptr_link2 = wcore_self_link2;
    tmp_statement_expression_1_link2 = (struct wegl_display *)((void *)__mptr_link2 - (signed long int)0ul);
    return tmp_statement_expression_1_link2;
  }

  else
    return ((struct wegl_display *)NULL);
}

// wegl_display_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.h line 43
static inline struct wegl_display * wegl_display_link3(struct wcore_display *wcore_self_link3)
{
  struct wegl_display *tmp_statement_expression_1_link3;
  if(!(wcore_self_link3 == ((struct wcore_display *)NULL)))
  {
    const struct wcore_display *__mptr_link3 = wcore_self_link3;
    tmp_statement_expression_1_link3 = (struct wegl_display *)((void *)__mptr_link3 - (signed long int)0ul);
    return tmp_statement_expression_1_link3;
  }

  else
    return ((struct wegl_display *)NULL);
}

// wegl_display_link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.h line 43
static inline struct wegl_display * wegl_display_link4(struct wcore_display *wcore_self_link4)
{
  struct wegl_display *tmp_statement_expression_1_link4;
  if(!(wcore_self_link4 == ((struct wcore_display *)NULL)))
  {
    const struct wcore_display *__mptr_link4 = wcore_self_link4;
    tmp_statement_expression_1_link4 = (struct wegl_display *)((void *)__mptr_link4 - (signed long int)0ul);
    return tmp_statement_expression_1_link4;
  }

  else
    return ((struct wegl_display *)NULL);
}

// wegl_display_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.c line 60
_Bool wegl_display_init(struct wegl_display *dpy, struct wcore_platform *wc_plat, signed long int native_display)
{
  struct wegl_platform_2 *plat;
  plat=wegl_platform_link2(wc_plat);
  _Bool ok;
  signed int major;
  signed int minor;
  ok=wcore_display_init(&dpy->wcore, wc_plat);
  unsigned int return_value;
  if(!(ok == (_Bool)0))
  {
    dpy->egl=plat->eglGetDisplay((struct _XDisplay *)native_display);
    if(dpy->egl == NULL)
      wegl_emit_error(plat, "eglGetDisplay");

    return_value=plat->eglInitialize(dpy->egl, &major, &minor);
    ok = (_Bool)return_value;
    if(ok == (_Bool)0)
      wegl_emit_error(plat, "eglInitialize");

    ok=get_extensions(dpy);
    return (_Bool)1;
  }

  else
  {

  fail:
    ;
    wegl_display_teardown(dpy);
    return (_Bool)0;
  }
}

// wegl_display_supports_context_api
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.c line 111
_Bool wegl_display_supports_context_api(struct wcore_display *wc_dpy, signed int waffle_context_api)
{
  struct wegl_display *dpy;
  dpy=wegl_display_link2(wc_dpy);
  struct wcore_platform *wc_plat = dpy->wcore.platform;
  signed int waffle_dl;
  switch(waffle_context_api)
  {
    case WAFFLE_CONTEXT_OPENGL:
    {
      waffle_dl = WAFFLE_DL_OPENGL;
      break;
    }
    case WAFFLE_CONTEXT_OPENGL_ES1:
    {
      waffle_dl = WAFFLE_DL_OPENGL_ES1;
      break;
    }
    case WAFFLE_CONTEXT_OPENGL_ES2:
    {
      waffle_dl = WAFFLE_DL_OPENGL_ES2;
      break;
    }
    case WAFFLE_CONTEXT_OPENGL_ES3:
    {
      if(dpy->KHR_create_context == (_Bool)0)
        return (_Bool)0;

      waffle_dl = WAFFLE_DL_OPENGL_ES3;
      break;
    }
    default:
    {
      _wcore_error_internal("/srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.c", 136, "waffle_context_api has bad value %#x", waffle_context_api);
      return (_Bool)0;
    }
  }
  _Bool return_value;
  return_value=wc_plat->vtbl->dl_can_open(wc_plat, waffle_dl);
  return return_value;
}

// wegl_display_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_display.c line 96
_Bool wegl_display_teardown(struct wegl_display *dpy)
{
  struct wegl_platform_2 *plat;
  plat=wegl_platform_link2(dpy->wcore.platform);
  _Bool ok = (_Bool)1;
  if(!(dpy->egl == NULL))
  {
    unsigned int return_value;
    return_value=plat->eglTerminate(dpy->egl);
    ok = (_Bool)return_value;
    if(ok == (_Bool)0)
      wegl_emit_error(plat, "eglTerminate");

  }

  return ok;
}

// wegl_emit_error
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_util.h line 42
void wegl_emit_error(struct wegl_platform_2 *plat, const char *egl_func_call)
{
  signed int egl_error_code;
  egl_error_code=plat->eglGetError();
  const char *egl_error_name;
  if(egl_error_code == 0)
  {
    egl_error_name = "EGL_FALSE";
    egl_error_name = "EGL_TRUE";
    egl_error_name = "EGL_DONT_CARE";
    egl_error_name = "EGL_SUCCESS";
    egl_error_name = "EGL_NOT_INITIALIZED";
    egl_error_name = "EGL_BAD_ACCESS";
    egl_error_name = "EGL_BAD_ALLOC";
    egl_error_name = "EGL_BAD_ATTRIBUTE";
    egl_error_name = "EGL_BAD_CONFIG";
    egl_error_name = "EGL_BAD_CONTEXT";
    egl_error_name = "EGL_BAD_CURRENT_SURFACE";
    egl_error_name = "EGL_BAD_DISPLAY";
    egl_error_name = "EGL_BAD_MATCH";
    egl_error_name = "EGL_BAD_NATIVE_PIXMAP";
    egl_error_name = "EGL_BAD_NATIVE_WINDOW";
    egl_error_name = "EGL_BAD_PARAMETER";
    egl_error_name = "EGL_BAD_SURFACE";
    egl_error_name = "EGL_CONTEXT_LOST";
  }

  egl_error_name = "";
  wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "%s failed with error %s(0x%x)", egl_func_call, egl_error_name, egl_error_code);
}

// wegl_get_proc_address
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_util.c line 95
void * wegl_get_proc_address(struct wcore_platform *wc_self, const char *name)
{
  struct wegl_platform_2 *self;
  self=wegl_platform_link3(wc_self);
  void (*return_value)(void);
  return_value=self->eglGetProcAddress(name);
  return (void *)return_value;
}

// wegl_make_current
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_util.c line 73
_Bool wegl_make_current(struct wcore_platform *wc_plat, struct wcore_display *wc_dpy, struct wcore_window *wc_window, struct wcore_context *wc_ctx)
{
  struct wegl_platform_2 *plat;
  plat=wegl_platform_link3(wc_plat);
  void *surface;
  void *tmp_if_expr_2;
  struct wegl_window *return_value_wegl_window_1;
  if(!(wc_window == ((struct wcore_window *)NULL)))
  {
    return_value_wegl_window_1=wegl_window(wc_window);
    tmp_if_expr_2 = return_value_wegl_window_1->egl;
  }

  else
    tmp_if_expr_2 = (void *)0;
  surface = tmp_if_expr_2;
  _Bool ok;
  struct wegl_display *return_value_wegl_display_3;
  return_value_wegl_display_3=wegl_display_link3(wc_dpy);
  void *tmp_if_expr_5;
  struct wegl_context *return_value_wegl_context_4;
  if(!(wc_ctx == ((struct wcore_context *)NULL)))
  {
    return_value_wegl_context_4=wegl_context_link1(wc_ctx);
    tmp_if_expr_5 = return_value_wegl_context_4->egl;
  }

  else
    tmp_if_expr_5 = (void *)0;
  unsigned int return_value;
  return_value=plat->eglMakeCurrent(return_value_wegl_display_3->egl, surface, surface, tmp_if_expr_5);
  ok = (_Bool)return_value;
  if(ok == (_Bool)0)
    wegl_emit_error(plat, "eglMakeCurrent");

  return ok;
}

// wegl_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform_2 * wegl_platform(struct wcore_platform *wcore_self)
{
  struct wegl_platform_2 *tmp_statement_expression_1;
  if(!(wcore_self == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr = wcore_self;
    tmp_statement_expression_1 = (struct wegl_platform_2 *)((void *)__mptr - (signed long int)0ul);
    return tmp_statement_expression_1;
  }

  else
    return ((struct wegl_platform_2 *)NULL);
}

// wegl_platform_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform_2 * wegl_platform_link1(struct wcore_platform *wcore_self_link1)
{
  struct wegl_platform_2 *tmp_statement_expression_1_link1;
  if(!(wcore_self_link1 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr_link1 = wcore_self_link1;
    tmp_statement_expression_1_link1 = (struct wegl_platform_2 *)((void *)__mptr_link1 - (signed long int)0ul);
    return tmp_statement_expression_1_link1;
  }

  else
    return ((struct wegl_platform_2 *)NULL);
}

// wegl_platform_link10
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform_2 * wegl_platform_link10(struct wcore_platform *wcore_self_link10)
{
  struct wegl_platform_2 *tmp_statement_expression_1_link10;
  if(!(wcore_self_link10 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr_link10 = wcore_self_link10;
    tmp_statement_expression_1_link10 = (struct wegl_platform_2 *)((void *)__mptr_link10 - (signed long int)0ul);
    return tmp_statement_expression_1_link10;
  }

  else
    return ((struct wegl_platform_2 *)NULL);
}

// wegl_platform_link11
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform_1 * wegl_platform_link11(struct wcore_platform *wcore_self_link11)
{
  struct wegl_platform_1 *tmp_statement_expression_1_link11;
  if(!(wcore_self_link11 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr_link11 = wcore_self_link11;
    tmp_statement_expression_1_link11 = (struct wegl_platform_1 *)((void *)__mptr_link11 - (signed long int)0ul);
    return tmp_statement_expression_1_link11;
  }

  else
    return ((struct wegl_platform_1 *)NULL);
}

// wegl_platform_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform_2 * wegl_platform_link2(struct wcore_platform *wcore_self_link2)
{
  struct wegl_platform_2 *tmp_statement_expression_1_link2;
  if(!(wcore_self_link2 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr_link2 = wcore_self_link2;
    tmp_statement_expression_1_link2 = (struct wegl_platform_2 *)((void *)__mptr_link2 - (signed long int)0ul);
    return tmp_statement_expression_1_link2;
  }

  else
    return ((struct wegl_platform_2 *)NULL);
}

// wegl_platform_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform_2 * wegl_platform_link3(struct wcore_platform *wcore_self_link3)
{
  struct wegl_platform_2 *tmp_statement_expression_1_link3;
  if(!(wcore_self_link3 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr_link3 = wcore_self_link3;
    tmp_statement_expression_1_link3 = (struct wegl_platform_2 *)((void *)__mptr_link3 - (signed long int)0ul);
    return tmp_statement_expression_1_link3;
  }

  else
    return ((struct wegl_platform_2 *)NULL);
}

// wegl_platform_link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform_2 * wegl_platform_link4(struct wcore_platform *wcore_self_link4)
{
  struct wegl_platform_2 *tmp_statement_expression_1_link4;
  if(!(wcore_self_link4 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr_link4 = wcore_self_link4;
    tmp_statement_expression_1_link4 = (struct wegl_platform_2 *)((void *)__mptr_link4 - (signed long int)0ul);
    return tmp_statement_expression_1_link4;
  }

  else
    return ((struct wegl_platform_2 *)NULL);
}

// wegl_platform_link5
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform * wegl_platform_link5(struct wcore_platform *wcore_self_link5)
{
  struct wegl_platform *tmp_statement_expression_1_link5;
  if(!(wcore_self_link5 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr_link5 = wcore_self_link5;
    tmp_statement_expression_1_link5 = (struct wegl_platform *)((void *)__mptr_link5 - (signed long int)0ul);
    return tmp_statement_expression_1_link5;
  }

  else
    return ((struct wegl_platform *)NULL);
}

// wegl_platform_link6
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform_2 * wegl_platform_link6(struct wcore_platform *wcore_self_link6)
{
  struct wegl_platform_2 *tmp_statement_expression_1_link6;
  if(!(wcore_self_link6 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr_link6 = wcore_self_link6;
    tmp_statement_expression_1_link6 = (struct wegl_platform_2 *)((void *)__mptr_link6 - (signed long int)0ul);
    return tmp_statement_expression_1_link6;
  }

  else
    return ((struct wegl_platform_2 *)NULL);
}

// wegl_platform_link7
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform_2 * wegl_platform_link7(struct wcore_platform *wcore_self_link7)
{
  struct wegl_platform_2 *tmp_statement_expression_1_link7;
  if(!(wcore_self_link7 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr_link7 = wcore_self_link7;
    tmp_statement_expression_1_link7 = (struct wegl_platform_2 *)((void *)__mptr_link7 - (signed long int)0ul);
    return tmp_statement_expression_1_link7;
  }

  else
    return ((struct wegl_platform_2 *)NULL);
}

// wegl_platform_link8
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform_2 * wegl_platform_link8(struct wcore_platform *wcore_self_link8)
{
  struct wegl_platform_2 *tmp_statement_expression_1_link8;
  if(!(wcore_self_link8 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr_link8 = wcore_self_link8;
    tmp_statement_expression_1_link8 = (struct wegl_platform_2 *)((void *)__mptr_link8 - (signed long int)0ul);
    return tmp_statement_expression_1_link8;
  }

  else
    return ((struct wegl_platform_2 *)NULL);
}

// wegl_platform_link9
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.h line 73
static inline struct wegl_platform_0 * wegl_platform_link9(struct wcore_platform *wcore_self_link9)
{
  struct wegl_platform_0 *tmp_statement_expression_1_link9;
  if(!(wcore_self_link9 == ((struct wcore_platform *)NULL)))
  {
    const struct wcore_platform *__mptr_link9 = wcore_self_link9;
    tmp_statement_expression_1_link9 = (struct wegl_platform_0 *)((void *)__mptr_link9 - (signed long int)0ul);
    return tmp_statement_expression_1_link9;
  }

  else
    return ((struct wegl_platform_0 *)NULL);
}

// wegl_platform_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.c line 58
_Bool wegl_platform_init(struct wegl_platform_2 *self)
{
  _Bool ok;
  ok=wcore_platform_init(&self->wcore);
  void *return_value_dlsym_2;
  void *return_value_dlsym_4;
  void *return_value_dlsym_6;
  void *return_value_dlsym_8;
  void *return_value_dlsym_10;
  void *return_value_dlsym_12;
  void *return_value_dlsym_14;
  void *return_value_dlsym_16;
  void *return_value_dlsym_18;
  void *return_value_dlsym_20;
  void *return_value_dlsym_22;
  void *return_value_dlsym_24;
  void *return_value_dlsym_26;
  void *return_value_dlsym_28;
  void *return_value_dlsym_30;
  if(!(ok == (_Bool)0))
  {
    self->eglHandle=dlopen(libEGL_filename, 0x00001 | 0);
    if(self->eglHandle == NULL)
    {
      char *return_value_dlerror_1;
      return_value_dlerror_1=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlopen(\"%s\") failed: %s", libEGL_filename, return_value_dlerror_1);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym_2=dlsym(self->eglHandle, "eglMakeCurrent");
    self->eglMakeCurrent = (unsigned int (*)(void *, void *, void *, void *))return_value_dlsym_2;
    if(self->eglMakeCurrent == ((unsigned int (*)(void *, void *, void *, void *))NULL))
    {
      char *return_value_dlerror_3;
      return_value_dlerror_3=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglMakeCurrent\") failed: %s", libEGL_filename, return_value_dlerror_3);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym_4=dlsym(self->eglHandle, "eglGetProcAddress");
    self->eglGetProcAddress = (void (*(*)(const char *))(void))return_value_dlsym_4;
    if(self->eglGetProcAddress == ((void (*(*)(const char *))(void))NULL))
    {
      char *return_value_dlerror_5;
      return_value_dlerror_5=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglGetProcAddress\") failed: %s", libEGL_filename, return_value_dlerror_5);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym_6=dlsym(self->eglHandle, "eglGetDisplay");
    self->eglGetDisplay = (void * (*)(struct _XDisplay *))return_value_dlsym_6;
    if(self->eglGetDisplay == ((void * (*)(struct _XDisplay *))NULL))
    {
      char *return_value_dlerror_7;
      return_value_dlerror_7=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglGetDisplay\") failed: %s", libEGL_filename, return_value_dlerror_7);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym_8=dlsym(self->eglHandle, "eglInitialize");
    self->eglInitialize = (unsigned int (*)(void *, signed int *, signed int *))return_value_dlsym_8;
    if(self->eglInitialize == ((unsigned int (*)(void *, signed int *, signed int *))NULL))
    {
      char *return_value_dlerror_9;
      return_value_dlerror_9=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglInitialize\") failed: %s", libEGL_filename, return_value_dlerror_9);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym_10=dlsym(self->eglHandle, "eglQueryString");
    self->eglQueryString = (const char * (*)(void *, signed int))return_value_dlsym_10;
    if(self->eglQueryString == ((const char * (*)(void *, signed int))NULL))
    {
      char *return_value_dlerror_11;
      return_value_dlerror_11=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglQueryString\") failed: %s", libEGL_filename, return_value_dlerror_11);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym_12=dlsym(self->eglHandle, "eglGetError");
    self->eglGetError = (signed int (*)(void))return_value_dlsym_12;
    if(self->eglGetError == ((signed int (*)(void))NULL))
    {
      char *return_value_dlerror_13;
      return_value_dlerror_13=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglGetError\") failed: %s", libEGL_filename, return_value_dlerror_13);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym_14=dlsym(self->eglHandle, "eglTerminate");
    self->eglTerminate = (unsigned int (*)(void *))return_value_dlsym_14;
    if(self->eglTerminate == ((unsigned int (*)(void *))NULL))
    {
      char *return_value_dlerror_15;
      return_value_dlerror_15=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglTerminate\") failed: %s", libEGL_filename, return_value_dlerror_15);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym_16=dlsym(self->eglHandle, "eglChooseConfig");
    self->eglChooseConfig = (unsigned int (*)(void *, const signed int *, void **, signed int, signed int *))return_value_dlsym_16;
    if(self->eglChooseConfig == ((unsigned int (*)(void *, const signed int *, void **, signed int, signed int *))NULL))
    {
      char *return_value_dlerror_17;
      return_value_dlerror_17=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglChooseConfig\") failed: %s", libEGL_filename, return_value_dlerror_17);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym_18=dlsym(self->eglHandle, "eglBindAPI");
    self->eglBindAPI = (unsigned int (*)(unsigned int))return_value_dlsym_18;
    if(self->eglBindAPI == ((unsigned int (*)(unsigned int))NULL))
    {
      char *return_value_dlerror_19;
      return_value_dlerror_19=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglBindAPI\") failed: %s", libEGL_filename, return_value_dlerror_19);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym_20=dlsym(self->eglHandle, "eglCreateContext");
    self->eglCreateContext = (void * (*)(void *, void *, void *, const signed int *))return_value_dlsym_20;
    if(self->eglCreateContext == ((void * (*)(void *, void *, void *, const signed int *))NULL))
    {
      char *return_value_dlerror_21;
      return_value_dlerror_21=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglCreateContext\") failed: %s", libEGL_filename, return_value_dlerror_21);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym_22=dlsym(self->eglHandle, "eglDestroyContext");
    self->eglDestroyContext = (unsigned int (*)(void *, void *))return_value_dlsym_22;
    if(self->eglDestroyContext == ((unsigned int (*)(void *, void *))NULL))
    {
      char *return_value_dlerror_23;
      return_value_dlerror_23=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglDestroyContext\") failed: %s", libEGL_filename, return_value_dlerror_23);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym_24=dlsym(self->eglHandle, "eglGetConfigAttrib");
    self->eglGetConfigAttrib = (unsigned int (*)(void *, void *, signed int, signed int *))return_value_dlsym_24;
    if(self->eglGetConfigAttrib == ((unsigned int (*)(void *, void *, signed int, signed int *))NULL))
    {
      char *return_value_dlerror_25;
      return_value_dlerror_25=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglGetConfigAttrib\") failed: %s", libEGL_filename, return_value_dlerror_25);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym_26=dlsym(self->eglHandle, "eglCreateWindowSurface");
    self->eglCreateWindowSurface = (void * (*)(void *, void *, unsigned long int, const signed int *))return_value_dlsym_26;
    if(self->eglCreateWindowSurface == ((void * (*)(void *, void *, unsigned long int, const signed int *))NULL))
    {
      char *return_value_dlerror_27;
      return_value_dlerror_27=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglCreateWindowSurface\") failed: %s", libEGL_filename, return_value_dlerror_27);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym_28=dlsym(self->eglHandle, "eglDestroySurface");
    self->eglDestroySurface = (unsigned int (*)(void *, void *))return_value_dlsym_28;
    if(self->eglDestroySurface == ((unsigned int (*)(void *, void *))NULL))
    {
      char *return_value_dlerror_29;
      return_value_dlerror_29=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglDestroySurface\") failed: %s", libEGL_filename, return_value_dlerror_29);
      ok = (_Bool)0;
      goto error;
    }

    return_value_dlsym_30=dlsym(self->eglHandle, "eglSwapBuffers");
    self->eglSwapBuffers = (unsigned int (*)(void *, void *))return_value_dlsym_30;
    if(self->eglSwapBuffers == ((unsigned int (*)(void *, void *))NULL))
    {
      char *return_value_dlerror_31;
      return_value_dlerror_31=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"eglSwapBuffers\") failed: %s", libEGL_filename, return_value_dlerror_31);
      ok = (_Bool)0;
      goto error;
    }

  }


error:
  ;
  return ok;
}

// wegl_platform_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_platform.c line 39
_Bool wegl_platform_teardown(struct wegl_platform_2 *self)
{
  _Bool ok = (_Bool)1;
  signed int error = 0;
  if(!(self->eglHandle == NULL))
  {
    error=dlclose(self->eglHandle);
    if(!(error == 0))
    {
      ok = (_Bool)0;
      char *return_value_dlerror_1;
      return_value_dlerror_1=dlerror();
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "dlclose(\"%s\") failed: %s", libEGL_filename, return_value_dlerror_1);
    }

  }

  _Bool return_value_wcore_platform_teardown_2;
  return_value_wcore_platform_teardown_2=wcore_platform_teardown(&self->wcore);
  ok = ((signed int)ok & (signed int)return_value_wcore_platform_teardown_2) != 0;
  return ok;
}

// wegl_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_window.h line 43
static inline struct wegl_window * wegl_window(struct wcore_window *wcore_self)
{
  struct wegl_window *tmp_statement_expression_1;
  if(!(wcore_self == ((struct wcore_window *)NULL)))
  {
    const struct wcore_window *__mptr = wcore_self;
    tmp_statement_expression_1 = (struct wegl_window *)((void *)__mptr - (signed long int)0ul);
    return tmp_statement_expression_1;
  }

  else
    return ((struct wegl_window *)NULL);
}

// wegl_window_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_window.h line 43
static inline struct wegl_window * wegl_window_link1(struct wcore_window *wcore_self_link1)
{
  struct wegl_window *tmp_statement_expression_1_link1;
  if(!(wcore_self_link1 == ((struct wcore_window *)NULL)))
  {
    const struct wcore_window *__mptr_link1 = wcore_self_link1;
    tmp_statement_expression_1_link1 = (struct wegl_window *)((void *)__mptr_link1 - (signed long int)0ul);
    return tmp_statement_expression_1_link1;
  }

  else
    return ((struct wegl_window *)NULL);
}

// wegl_window_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_window.c line 36
_Bool wegl_window_init(struct wegl_window *window, struct wcore_config *wc_config, signed long int native_window)
{
  struct wegl_config *config;
  config=wegl_config_link2(wc_config);
  struct wegl_display *dpy;
  dpy=wegl_display_link4(wc_config->display);
  struct wegl_platform_2 *plat;
  plat=wegl_platform_link4(dpy->wcore.platform);
  signed int egl_render_buffer;
  _Bool ok;
  ok=wcore_window_init(&window->wcore, wc_config);
  signed int attrib_list[3l];
  if(!(ok == (_Bool)0))
  {
    if(!(config->wcore.attrs.double_buffered == (_Bool)0))
      egl_render_buffer = 0x3084;

    else
      egl_render_buffer = 0x3085;
    attrib_list[0] = 0x3086;
    attrib_list[1] = egl_render_buffer;
    attrib_list[2] = 0x3038;
    window->egl=plat->eglCreateWindowSurface(dpy->egl, config->egl, (unsigned long int)native_window, attrib_list);
    if(window->egl == NULL)
      wegl_emit_error(plat, "eglCreateWindowSurface");

    return (_Bool)1;
  }

  else
  {

  fail:
    ;
    wegl_window_teardown(window);
    return (_Bool)0;
  }
}

// wegl_window_swap_buffers
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_window.c line 97
_Bool wegl_window_swap_buffers(struct wcore_window *wc_window)
{
  struct wegl_window *window;
  window=wegl_window_link1(wc_window);
  struct wegl_display *dpy;
  dpy=wegl_display_link4(window->wcore.display);
  struct wegl_platform_2 *plat;
  plat=wegl_platform_link4(dpy->wcore.platform);
  _Bool ok;
  unsigned int return_value;
  return_value=plat->eglSwapBuffers(dpy->egl, window->egl);
  ok = (_Bool)return_value;
  if(ok == (_Bool)0)
    wegl_emit_error(plat, "eglSwapBuffers");

  return ok;
}

// wegl_window_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/egl/wegl_window.c line 78
_Bool wegl_window_teardown(struct wegl_window *window)
{
  struct wegl_display *dpy;
  dpy=wegl_display_link4(window->wcore.display);
  struct wegl_platform_2 *plat;
  plat=wegl_platform_link4(dpy->wcore.platform);
  _Bool result = (_Bool)1;
  if(!(window->egl == NULL))
  {
    _Bool ok;
    unsigned int return_value;
    return_value=plat->eglDestroySurface(dpy->egl, window->egl);
    ok = (_Bool)return_value;
    if(ok == (_Bool)0)
    {
      wegl_emit_error(plat, "eglDestroySurface");
      result = (_Bool)0;
    }

  }

  _Bool return_value_wcore_window_teardown_1;
  return_value_wcore_window_teardown_1=wcore_window_teardown(&window->wcore);
  result = ((signed int)result & (signed int)return_value_wcore_window_teardown_1) != 0;
  return result;
}

// wflinfo_create_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 953
static void wflinfo_create_context(struct waffle_display *dpy, struct wflinfo_config_attrs attrs, struct waffle_context **out_ctx, struct waffle_config **out_config)
{
  _Bool ok = (_Bool)0;
  if(attrs.major == WAFFLE_DONT_CARE && (signed int)attrs.api == WAFFLE_CONTEXT_OPENGL && !((signed int)attrs.profile == WAFFLE_NONE))
  {
    signed int i = (signed int)(sizeof(signed int [7l]) /*28ul*/  / sizeof(signed int) /*4ul*/  - (unsigned long int)1);
    for( ; i >= 0; i = i - 1)
    {
      static signed int known_gl_profile_versions[7l] = { 32, 33, 40, 41, 42, 43, 44 };
      attrs.major = known_gl_profile_versions[(signed long int)i] / 10;
      attrs.minor = known_gl_profile_versions[(signed long int)i] % 10;
      ok=wflinfo_try_create_context(dpy, attrs, out_ctx, out_config, (_Bool)0);
      if(!(ok == (_Bool)0))
        goto __CPROVER_DUMP_L10;

    }
    ok=wflinfo_try_create_context_gl31(dpy, attrs, out_ctx, out_config, (_Bool)0);
    if(!(ok == (_Bool)0))
      goto __CPROVER_DUMP_L10;

    error_printf("Wflinfo", "Failed to create context; Try choosing a specific context version with --version");
  }

  else
    if(attrs.major == 3 && attrs.minor == 1 && (signed int)attrs.api == WAFFLE_CONTEXT_OPENGL)
    {
      ok=wflinfo_try_create_context_gl31(dpy, attrs, out_ctx, out_config, (_Bool)1);
      if(!(ok == (_Bool)0))
        goto __CPROVER_DUMP_L10;

      printf("Wflinfo warn: Succesfully requested an OpenGL 3.1 context, but returned\nWflinfo warn: context had the wrong profile.  Fallback to requesting an\nWflinfo warn: OpenGL 3.2 context, which is guaranteed to have the correct\nWflinfo warn: profile if context creation succeeds.\n");
      attrs.major = 3;
      attrs.minor = 2;
      ok=wflinfo_try_create_context(dpy, attrs, out_ctx, out_config, (_Bool)0);
      if(!(ok == (_Bool)0))
        goto __CPROVER_DUMP_L10;

      error_printf("Wflinfo", "Failed to create an OpenGL 3.1 or later context with requested profile");
    }

    else
      wflinfo_try_create_context(dpy, attrs, out_ctx, out_config, (_Bool)1);

__CPROVER_DUMP_L10:
  ;
}

// wflinfo_try_create_context
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 678
static _Bool wflinfo_try_create_context(struct waffle_display *dpy, struct wflinfo_config_attrs attrs, struct waffle_context **out_ctx, struct waffle_config **out_config, _Bool exit_on_fail)
{
  signed int i;
  signed int config_attrib_list[64l];
  struct waffle_context *ctx = (struct waffle_context *)(void *)0;
  struct waffle_config *config = (struct waffle_config *)(void *)0;
  i = 0;
  signed int tmp_post_1 = i;
  i = i + 1;
  config_attrib_list[(signed long int)tmp_post_1] = WAFFLE_CONTEXT_API;
  signed int tmp_post_2 = i;
  i = i + 1;
  config_attrib_list[(signed long int)tmp_post_2] = (signed int)attrs.api;
  signed int tmp_post_3;
  signed int tmp_post_4;
  if(!((signed int)attrs.profile == WAFFLE_DONT_CARE))
  {
    tmp_post_3 = i;
    i = i + 1;
    config_attrib_list[(signed long int)tmp_post_3] = WAFFLE_CONTEXT_PROFILE;
    tmp_post_4 = i;
    i = i + 1;
    config_attrib_list[(signed long int)tmp_post_4] = (signed int)attrs.profile;
  }

  signed int tmp_post_5;
  signed int tmp_post_6;
  signed int tmp_post_7;
  signed int tmp_post_8;
  if(!(attrs.major == WAFFLE_DONT_CARE) && !(attrs.minor == WAFFLE_DONT_CARE))
  {
    tmp_post_5 = i;
    i = i + 1;
    config_attrib_list[(signed long int)tmp_post_5] = WAFFLE_CONTEXT_MAJOR_VERSION;
    tmp_post_6 = i;
    i = i + 1;
    config_attrib_list[(signed long int)tmp_post_6] = attrs.major;
    tmp_post_7 = i;
    i = i + 1;
    config_attrib_list[(signed long int)tmp_post_7] = WAFFLE_CONTEXT_MINOR_VERSION;
    tmp_post_8 = i;
    i = i + 1;
    config_attrib_list[(signed long int)tmp_post_8] = attrs.minor;
  }

  signed int tmp_post_9;
  signed int tmp_post_10;
  if(!(attrs.forward_compat == (_Bool)0))
  {
    tmp_post_9 = i;
    i = i + 1;
    config_attrib_list[(signed long int)tmp_post_9] = WAFFLE_CONTEXT_FORWARD_COMPATIBLE;
    tmp_post_10 = i;
    i = i + 1;
    config_attrib_list[(signed long int)tmp_post_10] = 1;
  }

  signed int tmp_post_11;
  signed int tmp_post_12;
  if(!(attrs.debug == (_Bool)0))
  {
    tmp_post_11 = i;
    i = i + 1;
    config_attrib_list[(signed long int)tmp_post_11] = WAFFLE_CONTEXT_DEBUG;
    tmp_post_12 = i;
    i = i + 1;
    config_attrib_list[(signed long int)tmp_post_12] = 1;
  }

  signed int dont_care_attribs_count = (signed int)(sizeof(signed int [7l]) /*28ul*/  / sizeof(signed int) /*4ul*/ );
  signed int j = 0;
  signed int tmp_post_13;
  signed int tmp_post_14;
  for( ; !(j >= dont_care_attribs_count); j = j + 1)
  {
    tmp_post_13 = i;
    i = i + 1;
    static signed int dont_care_attribs[7l] = { WAFFLE_RED_SIZE, WAFFLE_GREEN_SIZE, WAFFLE_BLUE_SIZE, WAFFLE_ALPHA_SIZE, WAFFLE_DEPTH_SIZE, WAFFLE_STENCIL_SIZE, WAFFLE_DOUBLE_BUFFERED };
    config_attrib_list[(signed long int)tmp_post_13] = dont_care_attribs[(signed long int)j];
    tmp_post_14 = i;
    i = i + 1;
    config_attrib_list[(signed long int)tmp_post_14] = WAFFLE_DONT_CARE;
  }
  signed int tmp_post_15 = i;
  i = i + 1;
  config_attrib_list[(signed long int)tmp_post_15] = 0;
  config=waffle_config_choose(dpy, config_attrib_list);
  if(!(config == ((struct waffle_config *)NULL)))
  {
    ctx=waffle_context_create(config, (struct waffle_context *)(void *)0);
    if(ctx == ((struct waffle_context *)NULL))
      goto fail;

    *out_ctx = ctx;
    *out_config = config;
    return (_Bool)1;
  }

  else
  {

  fail:
    ;
    if(!(exit_on_fail == (_Bool)0))
      error_waffle();

    if(!(ctx == ((struct waffle_context *)NULL)))
      waffle_context_destroy(ctx);

    if(!(config == ((struct waffle_config *)NULL)))
      waffle_config_destroy(config);

    return (_Bool)0;
  }
}

// wflinfo_try_create_context_gl31
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 899
static _Bool wflinfo_try_create_context_gl31(struct waffle_display *dpy, struct wflinfo_config_attrs attrs, struct waffle_context **out_ctx, struct waffle_config **out_config, _Bool exit_if_ctx_creation_fails)
{
  struct waffle_config *config = (struct waffle_config *)(void *)0;
  struct waffle_context *ctx = (struct waffle_context *)(void *)0;
  _Bool ok;
  const enum waffle_enum desired_profile = attrs.profile;
  attrs.major = 3;
  attrs.minor = 1;
  attrs.profile = (enum waffle_enum)WAFFLE_NONE;
  wflinfo_try_create_context(dpy, attrs, &ctx, &config, exit_if_ctx_creation_fails);
  enum waffle_enum actual_profile;
  if(!((signed int)desired_profile == WAFFLE_NONE) && !((signed int)desired_profile == WAFFLE_DONT_CARE))
  {
    ok=waffle_make_current(dpy, (struct waffle_window *)(void *)0, ctx);
    if(ok == (_Bool)0)
      error_waffle();

    actual_profile=gl_get_profile();
    waffle_make_current(dpy, (struct waffle_window *)(void *)0, (struct waffle_context *)(void *)0);
    if(actual_profile == desired_profile)
      goto success;

    return (_Bool)0;
  }

  else
  {

  success:
    ;
    *out_ctx = ctx;
    *out_config = config;
    return (_Bool)1;
  }
}

// wgbm_config_choose
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_config.c line 34
struct wcore_config * wgbm_config_choose(struct wcore_platform *wc_plat, struct wcore_display *wc_dpy, struct wcore_config_attrs *attrs)
{
  struct wcore_config *wc_config;
  wc_config=wegl_config_choose(wc_plat, wc_dpy, attrs);
  if(wc_config == ((struct wcore_config *)NULL))
    return (struct wcore_config *)(void *)0;

  else
  {
    unsigned int return_value_wgbm_config_get_gbm_format_1;
    return_value_wgbm_config_get_gbm_format_1=wgbm_config_get_gbm_format(wc_plat, wc_dpy, wc_config);
    if(return_value_wgbm_config_get_gbm_format_1 == 0u)
    {
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNSUPPORTED_ON_PLATFORM, "requested config is unsupported on GBM");
      wegl_config_destroy(wc_config);
      return (struct wcore_config *)(void *)0;
    }

    else
      return wc_config;
  }
}

// wgbm_config_get_gbm_format
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_config.c line 53
unsigned int wgbm_config_get_gbm_format(struct wcore_platform *wc_plat, struct wcore_display *wc_display, struct wcore_config *wc_config)
{
  signed int gbm_format;
  struct wgbm_display *dpy;
  dpy=wgbm_display(wc_display);
  struct wegl_platform_2 *plat;
  plat=wegl_platform_link8(wc_plat);
  struct wegl_config *egl_config;
  egl_config=wegl_config_link6(wc_config);
  _Bool ok;
  unsigned int return_value;
  return_value=plat->eglGetConfigAttrib(dpy->wegl.egl, egl_config->egl, 0x302E, &gbm_format);
  ok = (_Bool)return_value;
  if(ok == (_Bool)0)
    return (unsigned int)0;

  else
    return (unsigned int)gbm_format;
}

// wgbm_config_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_config.c line 73
union waffle_native_config * wgbm_config_get_native(struct wcore_config *wc_config)
{
  struct wgbm_display *dpy;
  dpy=wgbm_display(wc_config->display);
  struct wegl_config *config;
  config=wegl_config_link6(wc_config);
  union waffle_native_config *n_config;
  do
  {
    void *return_value_wcore_malloc_1;
    return_value_wcore_malloc_1=wcore_malloc(sizeof(union waffle_native_config) /*8ul*/  + sizeof(struct waffle_gbm_config) /*24ul*/ );
    n_config = (union waffle_native_config *)return_value_wcore_malloc_1;
    if(!(n_config == ((union waffle_native_config *)NULL)))
      n_config->gbm = (struct waffle_gbm_config *)(void *)(n_config + (signed long int)1);

  }
  while((_Bool)0);
  if(n_config == ((union waffle_native_config *)NULL))
    return (union waffle_native_config *)(void *)0;

  else
  {
    wgbm_display_fill_native(dpy, &n_config->gbm->display);
    n_config->gbm->egl_config = config->egl;
    return n_config;
  }
}

// wgbm_context_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.c line 153
static union waffle_native_context * wgbm_context_get_native(struct wcore_context *wc_ctx)
{
  struct wgbm_display *dpy;
  dpy=wgbm_display_link2(wc_ctx->display);
  struct wegl_context *ctx;
  ctx=wegl_context_link4(wc_ctx);
  union waffle_native_context *n_ctx;
  do
  {
    void *return_value_wcore_malloc_1;
    return_value_wcore_malloc_1=wcore_malloc(sizeof(union waffle_native_context) /*8ul*/  + sizeof(struct waffle_gbm_context) /*24ul*/ );
    n_ctx = (union waffle_native_context *)return_value_wcore_malloc_1;
    if(!(n_ctx == ((union waffle_native_context *)NULL)))
      n_ctx->gbm = (struct waffle_gbm_context *)(void *)(n_ctx + (signed long int)1);

  }
  while((_Bool)0);
  if(n_ctx == ((union waffle_native_context *)NULL))
    return (union waffle_native_context *)(void *)0;

  else
  {
    wgbm_display_fill_native(dpy, &n_ctx->gbm->display);
    n_ctx->gbm->egl_context = ctx->egl;
    return n_ctx;
  }
}

// wgbm_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.h line 44
static inline struct wgbm_display * wgbm_display(struct wcore_display *wc_self)
{
  struct wegl_display *tmp_statement_expression_1;
  struct wgbm_display *tmp_statement_expression_2;
  if(!(wc_self == ((struct wcore_display *)NULL)))
  {
    struct wegl_display *wegl_self;
    const struct wcore_display *__mptr = wc_self;
    tmp_statement_expression_1 = (struct wegl_display *)((void *)__mptr - (signed long int)0ul);
    wegl_self = tmp_statement_expression_1;
    const struct wegl_display *wgbm_display__1__1__2____mptr = wegl_self;
    tmp_statement_expression_2 = (struct wgbm_display *)((void *)wgbm_display__1__1__2____mptr - (signed long int)8ul);
    return tmp_statement_expression_2;
  }

  else
    return (struct wgbm_display *)(void *)0;
}

// wgbm_display_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.h line 44
static inline struct wgbm_display * wgbm_display_link1(struct wcore_display *wc_self_link1)
{
  struct wegl_display *tmp_statement_expression_1_link1;
  struct wgbm_display *tmp_statement_expression_2_link1;
  if(!(wc_self_link1 == ((struct wcore_display *)NULL)))
  {
    struct wegl_display *wegl_self_link1;
    const struct wcore_display *wgbm_display__1__1__1____mptr_link1 = wc_self_link1;
    tmp_statement_expression_1_link1 = (struct wegl_display *)((void *)wgbm_display__1__1__1____mptr_link1 - (signed long int)0ul);
    wegl_self_link1 = tmp_statement_expression_1_link1;
    const struct wegl_display *__mptr_link1 = wegl_self_link1;
    tmp_statement_expression_2_link1 = (struct wgbm_display *)((void *)__mptr_link1 - (signed long int)8ul);
    return tmp_statement_expression_2_link1;
  }

  else
    return (struct wgbm_display *)(void *)0;
}

// wgbm_display_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.h line 44
static inline struct wgbm_display * wgbm_display_link2(struct wcore_display *wc_self_link2)
{
  struct wegl_display *tmp_statement_expression_1_link2;
  struct wgbm_display *tmp_statement_expression_2_link2;
  if(!(wc_self_link2 == ((struct wcore_display *)NULL)))
  {
    struct wegl_display *wegl_self_link2;
    const struct wcore_display *__mptr_link2 = wc_self_link2;
    tmp_statement_expression_1_link2 = (struct wegl_display *)((void *)__mptr_link2 - (signed long int)0ul);
    wegl_self_link2 = tmp_statement_expression_1_link2;
    const struct wegl_display *wgbm_display__1__1__2____mptr_link2 = wegl_self_link2;
    tmp_statement_expression_2_link2 = (struct wgbm_display *)((void *)wgbm_display__1__1__2____mptr_link2 - (signed long int)8ul);
    return tmp_statement_expression_2_link2;
  }

  else
    return (struct wgbm_display *)(void *)0;
}

// wgbm_display_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.h line 44
static inline struct wgbm_display * wgbm_display_link3(struct wcore_display *wc_self_link3)
{
  struct wegl_display *tmp_statement_expression_1_link3;
  struct wgbm_display *tmp_statement_expression_2_link3;
  if(!(wc_self_link3 == ((struct wcore_display *)NULL)))
  {
    struct wegl_display *wegl_self_link3;
    const struct wcore_display *wgbm_display__1__1__1____mptr_link3 = wc_self_link3;
    tmp_statement_expression_1_link3 = (struct wegl_display *)((void *)wgbm_display__1__1__1____mptr_link3 - (signed long int)0ul);
    wegl_self_link3 = tmp_statement_expression_1_link3;
    const struct wegl_display *__mptr_link3 = wegl_self_link3;
    tmp_statement_expression_2_link3 = (struct wgbm_display *)((void *)__mptr_link3 - (signed long int)8ul);
    return tmp_statement_expression_2_link3;
  }

  else
    return (struct wgbm_display *)(void *)0;
}

// wgbm_display_connect
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.c line 119
struct wcore_display * wgbm_display_connect(struct wcore_platform *wc_plat, const char *name)
{
  struct wgbm_display *self;
  struct wgbm_platform *plat;
  struct wegl_platform_0 *return_value_wegl_platform_1;
  return_value_wegl_platform_1=wegl_platform_link9(wc_plat);
  plat=wgbm_platform(return_value_wegl_platform_1);
  _Bool ok = (_Bool)1;
  signed int fd;
  void *return_value_wcore_calloc_2;
  return_value_wcore_calloc_2=wcore_calloc(sizeof(struct wgbm_display) /*40ul*/ );
  self = (struct wgbm_display *)return_value_wcore_calloc_2;
  if(self == ((struct wgbm_display *)NULL))
    return (struct wcore_display *)(void *)0;

  else
  {
    if(name == ((const char *)NULL))
      name=getenv("WAFFLE_GBM_DEVICE");

    if(!(name == ((const char *)NULL)))
    {
      fd=open(name, 02 | 02000000);
      if(!(fd >= 0))
      {
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "failed to open gbm device \"%s\"", name);
        goto error;
      }

    }

    else
    {
      fd=wgbm_get_default_fd();
      if(!(fd >= 0))
      {
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "open drm file for gbm failed");
        goto error;
      }

    }
    dlopen("libglapi.so.0", 0x00001 | 0x00100);
    self->gbm_device=plat->gbm_create_device(fd);
    if(self->gbm_device == ((struct gbm_device *)NULL))
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "gbm_create_device failed");

    else
    {
      ok=wegl_display_init(&self->wegl, wc_plat, (signed long int)self->gbm_device);
      if(!(ok == (_Bool)0))
        return &self->wegl.wcore;

    }

  error:
    ;
    wgbm_display_destroy(&self->wegl.wcore);
    return (struct wcore_display *)(void *)0;
  }
}

// wgbm_display_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.c line 44
_Bool wgbm_display_destroy(struct wcore_display *wc_self)
{
  struct wgbm_display *self;
  self=wgbm_display_link1(wc_self);
  struct wcore_platform *wc_plat = wc_self->platform;
  struct wgbm_platform *plat;
  struct wegl_platform_0 *return_value_wegl_platform_1;
  return_value_wegl_platform_1=wegl_platform_link9(wc_plat);
  plat=wgbm_platform(return_value_wegl_platform_1);
  _Bool ok = (_Bool)1;
  signed int fd;
  if(self == ((struct wgbm_display *)NULL))
    return ok;

  else
  {
    _Bool return_value_wegl_display_teardown_2;
    return_value_wegl_display_teardown_2=wegl_display_teardown(&self->wegl);
    ok = ((signed int)ok & (signed int)return_value_wegl_display_teardown_2) != 0;
    if(!(self->gbm_device == ((struct gbm_device *)NULL)))
    {
      fd=plat->gbm_device_get_fd(self->gbm_device);
      plat->gbm_device_destroy(self->gbm_device);
      close(fd);
    }

    free((void *)self);
    return ok;
  }
}

// wgbm_display_fill_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.h line 66
void wgbm_display_fill_native(struct wgbm_display *self, struct waffle_gbm_display *n_dpy)
{
  n_dpy->gbm_device = self->gbm_device;
  n_dpy->egl_display = self->wegl.egl;
}

// wgbm_display_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.c line 177
union waffle_native_display * wgbm_display_get_native(struct wcore_display *wc_self)
{
  struct wgbm_display *self;
  self=wgbm_display_link1(wc_self);
  union waffle_native_display *n_dpy;
  do
  {
    void *return_value_wcore_malloc_1;
    return_value_wcore_malloc_1=wcore_malloc(sizeof(union waffle_native_display) /*8ul*/  + sizeof(struct waffle_gbm_display) /*16ul*/ );
    n_dpy = (union waffle_native_display *)return_value_wcore_malloc_1;
    if(!(n_dpy == ((union waffle_native_display *)NULL)))
      n_dpy->gbm = (struct waffle_gbm_display *)(void *)(n_dpy + (signed long int)1);

  }
  while((_Bool)0);
  if(n_dpy == ((union waffle_native_display *)NULL))
    return (union waffle_native_display *)(void *)0;

  else
  {
    wgbm_display_fill_native(self, n_dpy->gbm);
    return n_dpy;
  }
}

// wgbm_dl_can_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.c line 136
static _Bool wgbm_dl_can_open(struct wcore_platform *wc_self, signed int waffle_dl)
{
  struct wgbm_platform_0 *self;
  struct wegl_platform_2 *return_value_wegl_platform_1;
  return_value_wegl_platform_1=wegl_platform_link10(wc_self);
  self=wgbm_platform_link1(return_value_wegl_platform_1);
  _Bool return_value_linux_platform_dl_can_open_2;
  return_value_linux_platform_dl_can_open_2=linux_platform_dl_can_open(self->linux, waffle_dl);
  return return_value_linux_platform_dl_can_open_2;
}

// wgbm_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.c line 144
static void * wgbm_dl_sym(struct wcore_platform *wc_self, signed int waffle_dl, const char *name)
{
  struct wgbm_platform_0 *self;
  struct wegl_platform_2 *return_value_wegl_platform_1;
  return_value_wegl_platform_1=wegl_platform_link10(wc_self);
  self=wgbm_platform_link1(return_value_wegl_platform_1);
  void *return_value_linux_platform_dl_sym_2;
  return_value_linux_platform_dl_sym_2=linux_platform_dl_sym(self->linux, waffle_dl, name);
  return return_value_linux_platform_dl_sym_2;
}

// wgbm_get_default_fd
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.c line 104
static signed int wgbm_get_default_fd(void)
{
  signed int fd;
  fd=wgbm_get_default_fd_for_pattern("renderD[0-9]*");
  if(fd >= 0)
    return fd;

  else
  {
    fd=wgbm_get_default_fd_for_pattern("card[0-9]*");
    return fd;
  }
}

// wgbm_get_default_fd_for_pattern
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_display.c line 69
static signed int wgbm_get_default_fd_for_pattern(const char *pattern)
{
  struct udev *ud;
  struct udev_enumerate *en;
  struct udev_list_entry *devices;
  struct udev_list_entry *entry;
  const char *path;
  const char *filename;
  struct udev_device *device;
  signed int fd;
  ud=udev_new();
  en=udev_enumerate_new(ud);
  udev_enumerate_add_match_subsystem(en, "drm");
  udev_enumerate_add_match_sysname(en, pattern);
  udev_enumerate_scan_devices(en);
  devices=udev_enumerate_get_list_entry(en);
  entry = devices;
  while(!(entry == ((struct udev_list_entry *)NULL)))
  {
    path=udev_list_entry_get_name(entry);
    device=udev_device_new_from_syspath(ud, path);
    filename=udev_device_get_devnode(device);
    fd=open(filename, 02 | 02000000);
    udev_device_unref(device);
    if(fd >= 0)
    {
      udev_enumerate_unref(en);
      udev_unref(ud);
      return fd;
    }

    entry=udev_list_entry_get_next(entry);
  }
  udev_enumerate_unref(en);
  udev_unref(ud);
  return -1;
}

// wgbm_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.h line 60
static inline struct wgbm_platform * wgbm_platform(struct wegl_platform_0 *wegl_self)
{
  struct wgbm_platform *tmp_statement_expression_1;
  if(!(wegl_self == ((struct wegl_platform_0 *)NULL)))
  {
    const struct wegl_platform_0 *__mptr = wegl_self;
    tmp_statement_expression_1 = (struct wgbm_platform *)((void *)__mptr - (signed long int)0ul);
    return tmp_statement_expression_1;
  }

  else
    return ((struct wgbm_platform *)NULL);
}

// wgbm_platform_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.h line 60
static inline struct wgbm_platform_0 * wgbm_platform_link1(struct wegl_platform_2 *wegl_self_link1)
{
  struct wgbm_platform_0 *tmp_statement_expression_1_link1;
  if(!(wegl_self_link1 == ((struct wegl_platform_2 *)NULL)))
  {
    const struct wegl_platform_2 *__mptr_link1 = wegl_self_link1;
    tmp_statement_expression_1_link1 = (struct wgbm_platform_0 *)((void *)__mptr_link1 - (signed long int)0ul);
    return tmp_statement_expression_1_link1;
  }

  else
    return ((struct wgbm_platform_0 *)NULL);
}

// wgbm_platform_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.h line 60
static inline struct wgbm_platform_1 * wgbm_platform_link2(struct wegl_platform_1 *wegl_self_link2)
{
  struct wgbm_platform_1 *tmp_statement_expression_1_link2;
  if(!(wegl_self_link2 == ((struct wegl_platform_1 *)NULL)))
  {
    const struct wegl_platform_1 *__mptr_link2 = wegl_self_link2;
    tmp_statement_expression_1_link2 = (struct wgbm_platform_1 *)((void *)__mptr_link2 - (signed long int)0ul);
    return tmp_statement_expression_1_link2;
  }

  else
    return ((struct wgbm_platform_1 *)NULL);
}

// wgbm_platform_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_init.c line 36
struct wcore_platform * wgbm_platform_create(void)
{
  struct wgbm_platform_0 *self;
  _Bool ok = (_Bool)1;
  void *return_value_wcore_calloc_1;
  return_value_wcore_calloc_1=wcore_calloc(sizeof(struct wgbm_platform_0) /*208ul*/ );
  self = (struct wgbm_platform_0 *)return_value_wcore_calloc_1;
  void *return_value_dlsym_3;
  void *return_value_dlsym_5;
  void *return_value_dlsym_7;
  void *return_value_dlsym_9;
  void *return_value_dlsym_11;
  void *return_value_dlsym_13;
  void *return_value_dlsym_15;
  if(self == ((struct wgbm_platform_0 *)NULL))
    return (struct wcore_platform *)(void *)0;

  else
  {
    ok=wegl_platform_init(&self->wegl);
    if(!(ok == (_Bool)0))
    {
      self->gbmHandle=dlopen(libgbm_filename, 0x00001 | 0);
      if(self->gbmHandle == NULL)
      {
        char *return_value_dlerror_2;
        return_value_dlerror_2=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlopen(\"%s\") failed: %s", libgbm_filename, return_value_dlerror_2);
        goto error;
      }

      return_value_dlsym_3=dlsym(self->gbmHandle, "gbm_create_device");
      self->gbm_create_device = (struct gbm_device * (*)(signed int))return_value_dlsym_3;
      if(self->gbm_create_device == ((struct gbm_device * (*)(signed int))NULL))
      {
        char *return_value_dlerror_4;
        return_value_dlerror_4=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"gbm_create_device\") failed: %s", libgbm_filename, return_value_dlerror_4);
        goto error;
      }

      return_value_dlsym_5=dlsym(self->gbmHandle, "gbm_device_get_fd");
      self->gbm_device_get_fd = (signed int (*)(struct gbm_device *))return_value_dlsym_5;
      if(self->gbm_device_get_fd == ((signed int (*)(struct gbm_device *))NULL))
      {
        char *return_value_dlerror_6;
        return_value_dlerror_6=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"gbm_device_get_fd\") failed: %s", libgbm_filename, return_value_dlerror_6);
        goto error;
      }

      return_value_dlsym_7=dlsym(self->gbmHandle, "gbm_device_destroy");
      self->gbm_device_destroy = (void (*)(struct gbm_device *))return_value_dlsym_7;
      if(self->gbm_device_destroy == ((void (*)(struct gbm_device *))NULL))
      {
        char *return_value_dlerror_8;
        return_value_dlerror_8=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"gbm_device_destroy\") failed: %s", libgbm_filename, return_value_dlerror_8);
        goto error;
      }

      return_value_dlsym_9=dlsym(self->gbmHandle, "gbm_surface_create");
      self->gbm_surface_create = (struct gbm_surface * (*)(struct gbm_device *, unsigned int, unsigned int, unsigned int, unsigned int))return_value_dlsym_9;
      if(self->gbm_surface_create == ((struct gbm_surface * (*)(struct gbm_device *, unsigned int, unsigned int, unsigned int, unsigned int))NULL))
      {
        char *return_value_dlerror_10;
        return_value_dlerror_10=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"gbm_surface_create\") failed: %s", libgbm_filename, return_value_dlerror_10);
        goto error;
      }

      return_value_dlsym_11=dlsym(self->gbmHandle, "gbm_surface_destroy");
      self->gbm_surface_destroy = (void (*)(struct gbm_surface *))return_value_dlsym_11;
      if(self->gbm_surface_destroy == ((void (*)(struct gbm_surface *))NULL))
      {
        char *return_value_dlerror_12;
        return_value_dlerror_12=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"gbm_surface_destroy\") failed: %s", libgbm_filename, return_value_dlerror_12);
        goto error;
      }

      return_value_dlsym_13=dlsym(self->gbmHandle, "gbm_surface_lock_front_buffer");
      self->gbm_surface_lock_front_buffer = (struct gbm_bo * (*)(struct gbm_surface *))return_value_dlsym_13;
      if(self->gbm_surface_lock_front_buffer == ((struct gbm_bo * (*)(struct gbm_surface *))NULL))
      {
        char *return_value_dlerror_14;
        return_value_dlerror_14=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"gbm_surface_lock_front_buffer\") failed: %s", libgbm_filename, return_value_dlerror_14);
        goto error;
      }

      return_value_dlsym_15=dlsym(self->gbmHandle, "gbm_surface_release_buffer");
      self->gbm_surface_release_buffer = (void (*)(struct gbm_surface *, struct gbm_bo *))return_value_dlsym_15;
      if(self->gbm_surface_release_buffer == ((void (*)(struct gbm_surface *, struct gbm_bo *))NULL))
      {
        char *return_value_dlerror_16;
        return_value_dlerror_16=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_FATAL, "dlsym(\"%s\", \"gbm_surface_release_buffer\") failed: %s", libgbm_filename, return_value_dlerror_16);
        goto error;
      }

      self->linux=linux_platform_create();
      if(self->linux == ((struct linux_platform *)NULL))
        goto error;

      setenv("EGL_PLATFORM", "drm", 1);
      self->wegl.wcore.vtbl = &wgbm_platform_vtbl;
      return &self->wegl.wcore;
    }

    else
    {

    error:
      ;
      wgbm_platform_destroy(&self->wegl.wcore);
      return (struct wcore_platform *)(void *)0;
    }
  }
}

// wgbm_platform_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_platform.c line 50
static _Bool wgbm_platform_destroy(struct wcore_platform *wc_self)
{
  struct wgbm_platform_0 *self;
  struct wegl_platform_2 *return_value_wegl_platform_1;
  return_value_wegl_platform_1=wegl_platform_link10(wc_self);
  self=wgbm_platform_link1(return_value_wegl_platform_1);
  _Bool ok = (_Bool)1;
  signed int error = 0;
  _Bool return_value_linux_platform_destroy_2;
  if(self == ((struct wgbm_platform_0 *)NULL))
    return (_Bool)1;

  else
  {
    unsetenv("EGL_PLATFORM");
    if(!(self->linux == ((struct linux_platform *)NULL)))
    {
      return_value_linux_platform_destroy_2=linux_platform_destroy(self->linux);
      ok = ((signed int)ok & (signed int)return_value_linux_platform_destroy_2) != 0;
    }

    if(!(self->gbmHandle == NULL))
    {
      error=dlclose(self->gbmHandle);
      if(!(error == 0))
      {
        ok = ((signed int)ok & 0) != 0;
        char *return_value_dlerror_3;
        return_value_dlerror_3=dlerror();
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "dlclose(\"%s\") failed: %s", libgbm_filename, return_value_dlerror_3);
      }

    }

    _Bool return_value_wegl_platform_teardown_4;
    return_value_wegl_platform_teardown_4=wegl_platform_teardown(&self->wegl);
    ok = ((signed int)ok & (signed int)return_value_wegl_platform_teardown_4) != 0;
    free((void *)self);
    return ok;
  }
}

// wgbm_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_window.h line 41
static inline struct wgbm_window * wgbm_window(struct wcore_window *wc_self)
{
  struct wegl_window *tmp_statement_expression_1;
  struct wgbm_window *tmp_statement_expression_2;
  if(!(wc_self == ((struct wcore_window *)NULL)))
  {
    struct wegl_window *wegl_self;
    const struct wcore_window *__mptr = wc_self;
    tmp_statement_expression_1 = (struct wegl_window *)((void *)__mptr - (signed long int)0ul);
    wegl_self = tmp_statement_expression_1;
    const struct wegl_window *wgbm_window__1__1__2____mptr = wegl_self;
    tmp_statement_expression_2 = (struct wgbm_window *)((void *)wgbm_window__1__1__2____mptr - (signed long int)8ul);
    return tmp_statement_expression_2;
  }

  else
    return (struct wgbm_window *)(void *)0;
}

// wgbm_window_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_window.h line 53
struct wcore_window * wgbm_window_create(struct wcore_platform *wc_plat, struct wcore_config *wc_config, signed int width, signed int height)
{
  struct wgbm_display *dpy;
  dpy=wgbm_display_link3(wc_config->display);
  struct wgbm_platform_1 *plat;
  struct wegl_platform_1 *return_value_wegl_platform_1;
  return_value_wegl_platform_1=wegl_platform_link11(wc_plat);
  plat=wgbm_platform_link2(return_value_wegl_platform_1);
  struct wgbm_window *self;
  unsigned int gbm_format;
  _Bool ok = (_Bool)1;
  void *return_value_wcore_calloc_2;
  return_value_wcore_calloc_2=wcore_calloc(sizeof(struct wgbm_window) /*32ul*/ );
  self = (struct wgbm_window *)return_value_wcore_calloc_2;
  if(self == ((struct wgbm_window *)NULL))
    return (struct wcore_window *)(void *)0;

  else
  {
    gbm_format=wgbm_config_get_gbm_format(wc_plat, wc_config->display, wc_config);
    self->gbm_surface=plat->gbm_surface_create(dpy->gbm_device, (unsigned int)width, (unsigned int)height, gbm_format, (unsigned int)4);
    if(self->gbm_surface == ((struct gbm_surface *)NULL))
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "gbm_surface_create failed");

    else
    {
      ok=wegl_window_init(&self->wegl, wc_config, (signed long int)self->gbm_surface);
      if(!(ok == (_Bool)0))
        return &self->wegl.wcore;

    }

  error:
    ;
    wgbm_window_destroy(&self->wegl.wcore);
    return (struct wcore_window *)(void *)0;
  }
}

// wgbm_window_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_window.h line 59
_Bool wgbm_window_destroy(struct wcore_window *wc_self)
{
  struct wcore_platform *wc_plat = wc_self->display->platform;
  struct wgbm_platform_1 *plat;
  struct wegl_platform_1 *return_value_wegl_platform_1;
  return_value_wegl_platform_1=wegl_platform_link11(wc_plat);
  plat=wgbm_platform_link2(return_value_wegl_platform_1);
  struct wgbm_window *self;
  self=wgbm_window(wc_self);
  _Bool ok = (_Bool)1;
  if(self == ((struct wgbm_window *)NULL))
    return ok;

  else
  {
    _Bool return_value_wegl_window_teardown_2;
    return_value_wegl_window_teardown_2=wegl_window_teardown(&self->wegl);
    ok = ((signed int)ok & (signed int)return_value_wegl_window_teardown_2) != 0;
    plat->gbm_surface_destroy(self->gbm_surface);
    free((void *)self);
    return ok;
  }
}

// wgbm_window_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_window.h line 68
union waffle_native_window * wgbm_window_get_native(struct wcore_window *wc_self)
{
  struct wgbm_window *self;
  self=wgbm_window(wc_self);
  struct wgbm_display *dpy;
  dpy=wgbm_display_link3(wc_self->display);
  union waffle_native_window *n_window;
  do
  {
    void *return_value_wcore_malloc_1;
    return_value_wcore_malloc_1=wcore_malloc(sizeof(union waffle_native_window) /*8ul*/  + sizeof(struct waffle_gbm_window) /*32ul*/ );
    n_window = (union waffle_native_window *)return_value_wcore_malloc_1;
    if(!(n_window == ((union waffle_native_window *)NULL)))
      n_window->gbm = (struct waffle_gbm_window *)(void *)(n_window + (signed long int)1);

  }
  while((_Bool)0);
  if(n_window == ((union waffle_native_window *)NULL))
    return (union waffle_native_window *)(void *)0;

  else
  {
    wgbm_display_fill_native(dpy, &n_window->gbm->display);
    n_window->gbm->egl_surface = self->wegl.egl;
    n_window->gbm->gbm_surface = self->gbm_surface;
    return n_window;
  }
}

// wgbm_window_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_window.h line 62
_Bool wgbm_window_show(struct wcore_window *wc_self)
{
  return (_Bool)1;
}

// wgbm_window_swap_buffers
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/gbm/wgbm_window.h line 65
_Bool wgbm_window_swap_buffers(struct wcore_window *wc_self)
{
  struct wcore_platform *wc_plat = wc_self->display->platform;
  struct wgbm_platform_1 *plat;
  struct wegl_platform_1 *return_value_wegl_platform_1;
  return_value_wegl_platform_1=wegl_platform_link11(wc_plat);
  plat=wgbm_platform_link2(return_value_wegl_platform_1);
  _Bool return_value_wegl_window_swap_buffers_2;
  return_value_wegl_window_swap_buffers_2=wegl_window_swap_buffers(wc_self);
  if(return_value_wegl_window_swap_buffers_2 == (_Bool)0)
    return (_Bool)0;

  else
  {
    struct wgbm_window *self;
    self=wgbm_window(wc_self);
    struct gbm_bo *bo;
    bo=plat->gbm_surface_lock_front_buffer(self->gbm_surface);
    if(bo == ((struct gbm_bo *)NULL))
      return (_Bool)0;

    else
    {
      plat->gbm_surface_release_buffer(self->gbm_surface, bo);
      return (_Bool)1;
    }
  }
}

// wl_compositor_create_surface
// file /usr/include/wayland-client-protocol.h line 361
static inline struct wl_surface * wl_compositor_create_surface(struct wl_compositor *wl_compositor)
{
  struct wl_proxy *id;
  id=wl_proxy_marshal_constructor((struct wl_proxy *)wl_compositor, (unsigned int)0, &wl_surface_interface, (void *)0);
  return (struct wl_surface *)id;
}

// wl_display_get_registry
// file /usr/include/wayland-client-protocol.h line 185
static inline struct wl_registry * wl_display_get_registry(struct wl_display *wl_display)
{
  struct wl_proxy *registry;
  registry=wl_proxy_marshal_constructor((struct wl_proxy *)wl_display, (unsigned int)1, &wl_registry_interface, (void *)0);
  return (struct wl_registry *)registry;
}

// wl_registry_add_listener
// file /usr/include/wayland-client-protocol.h line 256
static inline signed int wl_registry_add_listener(struct wl_registry *wl_registry, struct wl_registry_listener *listener, void *data)
{
  signed int return_value_wl_proxy_add_listener_1;
  return_value_wl_proxy_add_listener_1=wl_proxy_add_listener((struct wl_proxy *)wl_registry, (void (**)(void))listener, data);
  return return_value_wl_proxy_add_listener_1;
}

// wl_registry_bind
// file /usr/include/wayland-client-protocol.h line 284
static inline void * wl_registry_bind(struct wl_registry *wl_registry, unsigned int name, struct wl_interface *interface, unsigned int version)
{
  struct wl_proxy *id;
  id=wl_proxy_marshal_constructor((struct wl_proxy *)wl_registry, (unsigned int)0, interface, name, interface->name, version, (void *)0);
  return (void *)id;
}

// wl_shell_get_shell_surface
// file /usr/include/wayland-client-protocol.h line 1090
static inline struct wl_shell_surface * wl_shell_get_shell_surface(struct wl_shell *wl_shell, struct wl_surface *surface)
{
  struct wl_proxy *id;
  id=wl_proxy_marshal_constructor((struct wl_proxy *)wl_shell, (unsigned int)0, &wl_shell_surface_interface, (void *)0, surface);
  return (struct wl_shell_surface *)id;
}

// wl_shell_surface_add_listener
// file /usr/include/wayland-client-protocol.h line 1242
static inline signed int wl_shell_surface_add_listener(struct wl_shell_surface *wl_shell_surface, struct wl_shell_surface_listener *listener, void *data)
{
  signed int return_value_wl_proxy_add_listener_1;
  return_value_wl_proxy_add_listener_1=wl_proxy_add_listener((struct wl_proxy *)wl_shell_surface, (void (**)(void))listener, data);
  return return_value_wl_proxy_add_listener_1;
}

// wl_shell_surface_destroy
// file /usr/include/wayland-client-protocol.h line 1273
static inline void wl_shell_surface_destroy(struct wl_shell_surface *wl_shell_surface)
{
  wl_proxy_destroy((struct wl_proxy *)wl_shell_surface);
}

// wl_shell_surface_pong
// file /usr/include/wayland-client-protocol.h line 1279
static inline void wl_shell_surface_pong(struct wl_shell_surface *wl_shell_surface, unsigned int serial)
{
  wl_proxy_marshal((struct wl_proxy *)wl_shell_surface, (unsigned int)0, serial);
}

// wl_shell_surface_set_toplevel
// file /usr/include/wayland-client-protocol.h line 1300
static inline void wl_shell_surface_set_toplevel(struct wl_shell_surface *wl_shell_surface)
{
  wl_proxy_marshal((struct wl_proxy *)wl_shell_surface, (unsigned int)3);
}

// wl_surface_destroy
// file /usr/include/wayland-client-protocol.h line 1463
static inline void wl_surface_destroy(struct wl_surface *wl_surface)
{
  wl_proxy_marshal((struct wl_proxy *)wl_surface, (unsigned int)0);
  wl_proxy_destroy((struct wl_proxy *)wl_surface);
}

// wrapped_XCloseDisplay
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 64
static inline signed int wrapped_XCloseDisplay(struct _XDisplay *dpy)
{
  signed int (*old_handler)(struct _XDisplay *, struct anonymous_12 *);
  old_handler=XSetErrorHandler(x11_dummy_error_handler_link5);
  signed int error;
  error=XCloseDisplay(dpy);
  XSetErrorHandler(old_handler);
  return error;
}

// wrapped_XGetXCBConnection
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 73
static inline struct xcb_connection_t * wrapped_XGetXCBConnection(struct _XDisplay *dpy)
{
  signed int (*old_handler)(struct _XDisplay *, struct anonymous_12 *);
  old_handler=XSetErrorHandler(x11_dummy_error_handler_link5);
  struct xcb_connection_t *conn;
  conn=XGetXCBConnection(dpy);
  XSetErrorHandler(old_handler);
  return conn;
}

// wrapped_XOpenDisplay
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 55
static inline struct _XDisplay * wrapped_XOpenDisplay(const char *name)
{
  signed int (*old_handler)(struct _XDisplay *, struct anonymous_12 *);
  old_handler=XSetErrorHandler(x11_dummy_error_handler_link5);
  struct _XDisplay *dpy;
  dpy=XOpenDisplay(name);
  XSetErrorHandler(old_handler);
  return dpy;
}

// wrapped_glXChooseFBConfig
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 48
static inline struct __GLXFBConfigRec ** wrapped_glXChooseFBConfig(struct glx_platform *platform, struct _XDisplay *dpy, signed int screen, const signed int *attribList, signed int *nitems)
{
  signed int (*old_handler)(struct _XDisplay *, struct anonymous_12 *);
  old_handler=XSetErrorHandler(x11_dummy_error_handler);
  struct __GLXFBConfigRec **configs;
  configs=platform->glXChooseFBConfig(dpy, screen, attribList, nitems);
  XSetErrorHandler(old_handler);
  return configs;
}

// wrapped_glXCreateContextAttribsARB
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 60
static inline struct __GLXcontextRec * wrapped_glXCreateContextAttribsARB(struct glx_platform *platform, struct _XDisplay *dpy, struct __GLXFBConfigRec *config, struct __GLXcontextRec *share_context, signed int direct, const signed int *attrib_list)
{
  signed int (*old_handler)(struct _XDisplay *, struct anonymous_12 *);
  old_handler=XSetErrorHandler(x11_dummy_error_handler_link1);
  struct __GLXcontextRec *ctx;
  ctx=platform->glXCreateContextAttribsARB(dpy, config, share_context, direct, attrib_list);
  XSetErrorHandler(old_handler);
  return ctx;
}

// wrapped_glXCreateNewContext
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 73
static inline struct __GLXcontextRec * wrapped_glXCreateNewContext(struct glx_platform *platform, struct _XDisplay *dpy, struct __GLXFBConfigRec *config, signed int renderType, struct __GLXcontextRec *shareList, signed int direct)
{
  signed int (*old_handler)(struct _XDisplay *, struct anonymous_12 *);
  old_handler=XSetErrorHandler(x11_dummy_error_handler_link1);
  struct __GLXcontextRec *ctx;
  ctx=platform->glXCreateNewContext(dpy, config, renderType, shareList, direct);
  XSetErrorHandler(old_handler);
  return ctx;
}

// wrapped_glXDestroyContext
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 106
static inline void wrapped_glXDestroyContext(struct glx_platform *platform, struct _XDisplay *dpy, struct __GLXcontextRec *ctx)
{
  signed int (*old_handler)(struct _XDisplay *, struct anonymous_12 *);
  old_handler=XSetErrorHandler(x11_dummy_error_handler_link1);
  platform->glXDestroyContext(dpy, ctx);
  XSetErrorHandler(old_handler);
}

// wrapped_glXGetFBConfigAttrib
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 85
static inline signed int wrapped_glXGetFBConfigAttrib(struct glx_platform *platform, struct _XDisplay *dpy, struct __GLXFBConfigRec *config, signed int attribute, signed int *value)
{
  signed int (*old_handler)(struct _XDisplay *, struct anonymous_12 *);
  old_handler=XSetErrorHandler(x11_dummy_error_handler);
  signed int error;
  error=platform->glXGetFBConfigAttrib(dpy, config, attribute, value);
  XSetErrorHandler(old_handler);
  return error;
}

// wrapped_glXGetVisualFromFBConfig
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 96
static inline struct anonymous_11 * wrapped_glXGetVisualFromFBConfig(struct glx_platform *platform, struct _XDisplay *dpy, struct __GLXFBConfigRec *config)
{
  signed int (*old_handler)(struct _XDisplay *, struct anonymous_12 *);
  old_handler=XSetErrorHandler(x11_dummy_error_handler);
  struct anonymous_11 *vi;
  vi=platform->glXGetVisualFromFBConfig(dpy, config);
  XSetErrorHandler(old_handler);
  return vi;
}

// wrapped_glXMakeCurrent
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 115
static inline signed int wrapped_glXMakeCurrent(struct glx_platform *platform, struct _XDisplay *dpy, unsigned long int drawable, struct __GLXcontextRec *ctx)
{
  signed int (*old_handler)(struct _XDisplay *, struct anonymous_12 *);
  old_handler=XSetErrorHandler(x11_dummy_error_handler_link3);
  signed int ok;
  ok=platform->glXMakeCurrent(dpy, drawable, ctx);
  XSetErrorHandler(old_handler);
  return ok;
}

// wrapped_glXQueryExtensionsString
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 125
static inline const char * wrapped_glXQueryExtensionsString(struct glx_platform *platform, struct _XDisplay *dpy, signed int screen)
{
  signed int (*old_handler)(struct _XDisplay *, struct anonymous_12 *);
  old_handler=XSetErrorHandler(x11_dummy_error_handler_link2);
  const char *s;
  s=platform->glXQueryExtensionsString(dpy, screen);
  XSetErrorHandler(old_handler);
  return s;
}

// wrapped_glXSwapBuffers
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/glx/glx_wrappers.h line 135
static inline void wrapped_glXSwapBuffers(struct glx_platform *platform, struct _XDisplay *dpy, unsigned long int drawable)
{
  signed int (*old_handler)(struct _XDisplay *, struct anonymous_12 *);
  old_handler=XSetErrorHandler(x11_dummy_error_handler_link4);
  platform->glXSwapBuffers(dpy, drawable);
  XSetErrorHandler(old_handler);
}

// write_usage_and_exit
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/utils/wflinfo.c line 149
static void write_usage_and_exit(struct _IO_FILE *f, signed int exit_code)
{
  fprintf(f, "%s", usage_message);
  exit(exit_code);
}

// x11_display_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_display.h line 39
_Bool x11_display_init(struct x11_display *self, const char *name)
{
  self->xlib=wrapped_XOpenDisplay(name);
  if(self->xlib == ((struct _XDisplay *)NULL))
  {
    wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "XOpenDisplay failed");
    return (_Bool)0;
  }

  else
  {
    self->xcb=wrapped_XGetXCBConnection(self->xlib);
    if(self->xcb == ((struct xcb_connection_t *)NULL))
    {
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "XGetXCBConnection failed");
      wrapped_XCloseDisplay(self->xlib);
      return (_Bool)0;
    }

    else
    {
      self->screen = ((struct anonymous_2 *)self->xlib)->default_screen;
      return (_Bool)1;
    }
  }
}

// x11_display_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_display.h line 42
_Bool x11_display_teardown(struct x11_display *self)
{
  signed int error = 0;
  if(self->xlib == ((struct _XDisplay *)NULL))
    return !(error != 0);

  else
  {
    error=wrapped_XCloseDisplay(self->xlib);
    if(!(error == 0))
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "XCloseDisplay failed");

    return !(error != 0);
  }
}

// x11_dummy_error_handler
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 49
static inline signed int x11_dummy_error_handler(struct _XDisplay *dpy, struct anonymous_12 *err)
{
  return 0;
}

// x11_dummy_error_handler_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 49
static inline signed int x11_dummy_error_handler_link1(struct _XDisplay *dpy_link1, struct anonymous_12 *err_link1)
{
  return 0;
}

// x11_dummy_error_handler_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 49
static inline signed int x11_dummy_error_handler_link2(struct _XDisplay *dpy_link2, struct anonymous_12 *err_link2)
{
  return 0;
}

// x11_dummy_error_handler_link3
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 49
static inline signed int x11_dummy_error_handler_link3(struct _XDisplay *dpy_link3, struct anonymous_12 *err_link3)
{
  return 0;
}

// x11_dummy_error_handler_link4
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 49
static inline signed int x11_dummy_error_handler_link4(struct _XDisplay *dpy_link4, struct anonymous_12 *err_link4)
{
  return 0;
}

// x11_dummy_error_handler_link5
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_wrappers.h line 49
static inline signed int x11_dummy_error_handler_link5(struct _XDisplay *dpy_link5, struct anonymous_12 *err_link5)
{
  return 0;
}

// x11_winddow_get_depth
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_window.c line 34
static unsigned char x11_winddow_get_depth(struct xcb_connection_t *conn, const struct xcb_screen_t *screen, unsigned int id)
{
  struct xcb_depth_iterator_t depth;
  depth=xcb_screen_allowed_depths_iterator(screen);
  while(!(depth.rem == 0))
  {
    struct xcb_visualtype_iterator_t visual;
    visual=xcb_depth_visuals_iterator(depth.data);
    while(!(visual.rem == 0))
    {
      if(visual.data->visual_id == id)
        return depth.data->depth;

      xcb_visualtype_next(&visual);
    }
    xcb_depth_next(&depth);
  }
  return (unsigned char)0;
}

// x11_window_init
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_window.h line 40
_Bool x11_window_init(struct x11_window *self, struct x11_display *dpy, unsigned int visual_id, signed int width, signed int height)
{
  unsigned int colormap = (unsigned int)0;
  unsigned int window = (unsigned int)0;
  _Bool ok = (_Bool)1;
  struct xcb_connection_t *conn = dpy->xcb;
  const struct xcb_setup_t *setup;
  setup=xcb_get_setup(conn);
  const struct xcb_screen_t *screen;
  struct anonymous_3 colormap_cookie;
  unsigned int event_mask;
  unsigned int attrib_mask;
  unsigned int attrib_list[3l];
  struct anonymous_3 create_cookie;
  unsigned char return_value_x11_winddow_get_depth_1;
  struct anonymous_4 *error;
  if(setup == ((const struct xcb_setup_t *)NULL))
    wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "xcb_get_setup() failed");

  else
  {
    screen=get_xcb_screen(setup, dpy->screen);
    if(screen == ((const struct xcb_screen_t *)NULL))
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "failed to get xcb screen");

    else
    {
      colormap=xcb_generate_id(conn);
      window=xcb_generate_id(conn);
      if(!(colormap >= 1u) || !(window >= 1u))
        wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "xcb_generate_id() failed");

      else
      {
        colormap_cookie=xcb_create_colormap_checked(conn, (unsigned char)0, colormap, screen->root, visual_id);
        event_mask = (const unsigned int)(4 | 32768 | 1);
        attrib_mask = (const unsigned int)(8 | 2048 | 8192);
        attrib_list[0] = (const unsigned int)0;
        attrib_list[1] = event_mask;
        attrib_list[2] = colormap;
        return_value_x11_winddow_get_depth_1=x11_winddow_get_depth(conn, screen, visual_id);
        create_cookie=xcb_create_window_checked(conn, return_value_x11_winddow_get_depth_1, window, screen->root, (signed short int)0, (signed short int)0, (unsigned short int)width, (unsigned short int)height, (unsigned short int)0, (unsigned short int)1, visual_id, attrib_mask, attrib_list);
        error=xcb_request_check(conn, colormap_cookie);
        if(!(error == ((struct anonymous_4 *)NULL)))
          wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "xcb_create_colormap() failed on visual_id=0x%x with error=0x%x\n", visual_id, error->error_code);

        else
        {
          error=xcb_request_check(conn, create_cookie);
          if(!(error == ((struct anonymous_4 *)NULL)))
            wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "xcb_create_window_checked() failed: error=0x%x", error->error_code);

          else
          {
            self->display = dpy;
            self->xcb = window;
            goto end;
          }
        }
      }
    }
  }

error:
  ;
  ok = (_Bool)0;
  if(!(colormap == 0u))
    xcb_free_colormap(conn, colormap);

  if(!(window == 0u))
    xcb_destroy_window(conn, window);


end:
  ;
  return ok;
}

// x11_window_resize
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_window.h line 53
_Bool x11_window_resize(struct x11_window *self, signed int width, signed int height)
{
  struct anonymous_3 cookie;
  struct anonymous_4 *error;
  unsigned int literal_1[2l] = { (unsigned int)width, (unsigned int)height };
  cookie=xcb_configure_window(self->display->xcb, self->xcb, (unsigned short int)(4 | 8), literal_1);
  error=xcb_request_check(self->display->xcb, cookie);
  if(!(error == ((struct anonymous_4 *)NULL)))
  {
    wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "xcb_configure_window() failed to resize width, height: error=0x%x\n", error->error_code);
    return (_Bool)0;
  }

  else
    return (_Bool)1;
}

// x11_window_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_window.h line 50
_Bool x11_window_show(struct x11_window *self)
{
  struct anonymous_3 cookie;
  struct anonymous_4 *error;
  cookie=xcb_map_window_checked(self->display->xcb, self->xcb);
  error=xcb_request_check(self->display->xcb, cookie);
  if(!(error == ((struct anonymous_4 *)NULL)))
    wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "xcb_map_window_checked() failed: error=0x%x", error->error_code);

  return !(error != ((struct anonymous_4 *)NULL));
}

// x11_window_teardown
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/x11/x11_window.h line 47
_Bool x11_window_teardown(struct x11_window *self)
{
  struct anonymous_3 cookie;
  struct anonymous_4 *error;
  if(self->xcb == 0u)
    return (_Bool)1;

  else
  {
    cookie=xcb_destroy_window_checked(self->display->xcb, self->xcb);
    error=xcb_request_check(self->display->xcb, cookie);
    if(!(error == ((struct anonymous_4 *)NULL)))
      wcore_errorf((enum waffle_error)WAFFLE_ERROR_UNKNOWN, "xcb_destroy_window_checked() failed: error=0x%x", error->error_code);

    return !(error != ((struct anonymous_4 *)NULL));
  }
}

// xegl_config_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.c line 110
static union waffle_native_config * xegl_config_get_native(struct wcore_config *wc_config)
{
  struct xegl_display *dpy;
  dpy=xegl_display_link1(wc_config->display);
  struct wegl_config *config;
  config=wegl_config_link4(wc_config);
  union waffle_native_config *n_config;
  do
  {
    void *return_value_wcore_malloc_1;
    return_value_wcore_malloc_1=wcore_malloc(sizeof(union waffle_native_config) /*8ul*/  + sizeof(struct waffle_x11_egl_config) /*24ul*/ );
    n_config = (union waffle_native_config *)return_value_wcore_malloc_1;
    if(!(n_config == ((union waffle_native_config *)NULL)))
      n_config->x11_egl = (struct waffle_x11_egl_config *)(void *)(n_config + (signed long int)1);

  }
  while((_Bool)0);
  if(n_config == ((union waffle_native_config *)NULL))
    return (union waffle_native_config *)(void *)0;

  else
  {
    xegl_display_fill_native(dpy, &n_config->x11_egl->display);
    n_config->x11_egl->egl_config = config->egl;
    return n_config;
  }
}

// xegl_context_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.c line 127
static union waffle_native_context * xegl_context_get_native(struct wcore_context *wc_ctx)
{
  struct xegl_display *dpy;
  dpy=xegl_display_link1(wc_ctx->display);
  struct wegl_context *ctx;
  ctx=wegl_context_link3(wc_ctx);
  union waffle_native_context *n_ctx;
  do
  {
    void *return_value_wcore_malloc_1;
    return_value_wcore_malloc_1=wcore_malloc(sizeof(union waffle_native_context) /*8ul*/  + sizeof(struct waffle_x11_egl_context) /*24ul*/ );
    n_ctx = (union waffle_native_context *)return_value_wcore_malloc_1;
    if(!(n_ctx == ((union waffle_native_context *)NULL)))
      n_ctx->x11_egl = (struct waffle_x11_egl_context *)(void *)(n_ctx + (signed long int)1);

  }
  while((_Bool)0);
  if(n_ctx == ((union waffle_native_context *)NULL))
    return (union waffle_native_context *)(void *)0;

  else
  {
    xegl_display_fill_native(dpy, &n_ctx->x11_egl->display);
    n_ctx->x11_egl->egl_context = ctx->egl;
    return n_ctx;
  }
}

// xegl_display
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.h line 45
static inline struct xegl_display * xegl_display(struct wcore_display *wc_self)
{
  struct wegl_display *tmp_statement_expression_1;
  struct xegl_display *tmp_statement_expression_2;
  if(!(wc_self == ((struct wcore_display *)NULL)))
  {
    struct wegl_display *wegl_self;
    const struct wcore_display *__mptr = wc_self;
    tmp_statement_expression_1 = (struct wegl_display *)((void *)__mptr - (signed long int)0ul);
    wegl_self = tmp_statement_expression_1;
    const struct wegl_display *xegl_display__1__1__2____mptr = wegl_self;
    tmp_statement_expression_2 = (struct xegl_display *)((void *)xegl_display__1__1__2____mptr - (signed long int)24ul);
    return tmp_statement_expression_2;
  }

  else
    return (struct xegl_display *)(void *)0;
}

// xegl_display_link1
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.h line 45
static inline struct xegl_display * xegl_display_link1(struct wcore_display *wc_self_link1)
{
  struct wegl_display *tmp_statement_expression_1_link1;
  struct xegl_display *tmp_statement_expression_2_link1;
  if(!(wc_self_link1 == ((struct wcore_display *)NULL)))
  {
    struct wegl_display *wegl_self_link1;
    const struct wcore_display *__mptr_link1 = wc_self_link1;
    tmp_statement_expression_1_link1 = (struct wegl_display *)((void *)__mptr_link1 - (signed long int)0ul);
    wegl_self_link1 = tmp_statement_expression_1_link1;
    const struct wegl_display *xegl_display__1__1__2____mptr_link1 = wegl_self_link1;
    tmp_statement_expression_2_link1 = (struct xegl_display *)((void *)xegl_display__1__1__2____mptr_link1 - (signed long int)24ul);
    return tmp_statement_expression_2_link1;
  }

  else
    return (struct xegl_display *)(void *)0;
}

// xegl_display_link2
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.h line 45
static inline struct xegl_display * xegl_display_link2(struct wcore_display *wc_self_link2)
{
  struct wegl_display *tmp_statement_expression_1_link2;
  struct xegl_display *tmp_statement_expression_2_link2;
  if(!(wc_self_link2 == ((struct wcore_display *)NULL)))
  {
    struct wegl_display *wegl_self_link2;
    const struct wcore_display *xegl_display__1__1__1____mptr_link2 = wc_self_link2;
    tmp_statement_expression_1_link2 = (struct wegl_display *)((void *)xegl_display__1__1__1____mptr_link2 - (signed long int)0ul);
    wegl_self_link2 = tmp_statement_expression_1_link2;
    const struct wegl_display *__mptr_link2 = wegl_self_link2;
    tmp_statement_expression_2_link2 = (struct xegl_display *)((void *)__mptr_link2 - (signed long int)24ul);
    return tmp_statement_expression_2_link2;
  }

  else
    return (struct xegl_display *)(void *)0;
}

// xegl_display_connect
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.c line 50
struct wcore_display * xegl_display_connect(struct wcore_platform *wc_plat, const char *name)
{
  struct xegl_display *self;
  _Bool ok = (_Bool)1;
  void *return_value_wcore_calloc_1;
  return_value_wcore_calloc_1=wcore_calloc(sizeof(struct xegl_display) /*56ul*/ );
  self = (struct xegl_display *)return_value_wcore_calloc_1;
  if(self == ((struct xegl_display *)NULL))
    return (struct wcore_display *)(void *)0;

  else
  {
    ok=x11_display_init(&self->x11, name);
    if(!(ok == (_Bool)0))
    {
      ok=wegl_display_init(&self->wegl, wc_plat, (signed long int)self->x11.xlib);
      if(ok == (_Bool)0)
        goto error;

      return &self->wegl.wcore;
    }

    else
    {

    error:
      ;
      xegl_display_destroy(&self->wegl.wcore);
      return (struct wcore_display *)(void *)0;
    }
  }
}

// xegl_display_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.c line 35
_Bool xegl_display_destroy(struct wcore_display *wc_self)
{
  struct xegl_display *self;
  self=xegl_display(wc_self);
  _Bool ok = (_Bool)1;
  if(self == ((struct xegl_display *)NULL))
    return ok;

  else
  {
    _Bool return_value_wegl_display_teardown_1;
    return_value_wegl_display_teardown_1=wegl_display_teardown(&self->wegl);
    ok = ((signed int)ok & (signed int)return_value_wegl_display_teardown_1) != 0;
    _Bool return_value_x11_display_teardown_2;
    return_value_x11_display_teardown_2=x11_display_teardown(&self->x11);
    ok = ((signed int)ok & (signed int)return_value_x11_display_teardown_2) != 0;
    free((void *)self);
    return ok;
  }
}

// xegl_display_fill_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.c line 77
void xegl_display_fill_native(struct xegl_display *self, struct waffle_x11_egl_display *n_dpy)
{
  n_dpy->xlib_display = self->x11.xlib;
  n_dpy->egl_display = self->wegl.egl;
}

// xegl_display_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_display.c line 85
union waffle_native_display * xegl_display_get_native(struct wcore_display *wc_self)
{
  struct xegl_display *self;
  self=xegl_display(wc_self);
  union waffle_native_display *n_dpy;
  do
  {
    void *return_value_wcore_malloc_1;
    return_value_wcore_malloc_1=wcore_malloc(sizeof(union waffle_native_display) /*8ul*/  + sizeof(struct waffle_x11_egl_display) /*16ul*/ );
    n_dpy = (union waffle_native_display *)return_value_wcore_malloc_1;
    if(!(n_dpy == ((union waffle_native_display *)NULL)))
      n_dpy->x11_egl = (struct waffle_x11_egl_display *)(void *)(n_dpy + (signed long int)1);

  }
  while((_Bool)0);
  if(n_dpy == ((union waffle_native_display *)NULL))
    return (union waffle_native_display *)(void *)0;

  else
  {
    xegl_display_fill_native(self, n_dpy->x11_egl);
    return n_dpy;
  }
}

// xegl_dl_can_open
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.c line 93
static _Bool xegl_dl_can_open(struct wcore_platform *wc_self, signed int waffle_dl)
{
  struct xegl_platform *self;
  struct wegl_platform_2 *return_value_wegl_platform_1;
  return_value_wegl_platform_1=wegl_platform_link6(wc_self);
  self=xegl_platform(return_value_wegl_platform_1);
  _Bool return_value_linux_platform_dl_can_open_2;
  return_value_linux_platform_dl_can_open_2=linux_platform_dl_can_open(self->linux, waffle_dl);
  return return_value_linux_platform_dl_can_open_2;
}

// xegl_dl_sym
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.c line 101
static void * xegl_dl_sym(struct wcore_platform *wc_self, signed int waffle_dl, const char *name)
{
  struct xegl_platform *self;
  struct wegl_platform_2 *return_value_wegl_platform_1;
  return_value_wegl_platform_1=wegl_platform_link6(wc_self);
  self=xegl_platform(return_value_wegl_platform_1);
  void *return_value_linux_platform_dl_sym_2;
  return_value_linux_platform_dl_sym_2=linux_platform_dl_sym(self->linux, waffle_dl, name);
  return return_value_linux_platform_dl_sym_2;
}

// xegl_platform
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.h line 44
static inline struct xegl_platform * xegl_platform(struct wegl_platform_2 *wegl_self)
{
  struct xegl_platform *tmp_statement_expression_1;
  if(!(wegl_self == ((struct wegl_platform_2 *)NULL)))
  {
    const struct wegl_platform_2 *__mptr = wegl_self;
    tmp_statement_expression_1 = (struct xegl_platform *)((void *)__mptr - (signed long int)0ul);
    return tmp_statement_expression_1;
  }

  else
    return ((struct xegl_platform *)NULL);
}

// xegl_platform_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/api/waffle_init.c line 35
struct wcore_platform * xegl_platform_create(void)
{
  struct xegl_platform *self;
  _Bool ok = (_Bool)1;
  void *return_value_wcore_calloc_1;
  return_value_wcore_calloc_1=wcore_calloc(sizeof(struct xegl_platform) /*144ul*/ );
  self = (struct xegl_platform *)return_value_wcore_calloc_1;
  if(self == ((struct xegl_platform *)NULL))
    return (struct wcore_platform *)(void *)0;

  else
  {
    ok=wegl_platform_init(&self->wegl);
    if(!(ok == (_Bool)0))
    {
      self->linux=linux_platform_create();
      if(self->linux == ((struct linux_platform *)NULL))
        goto error;

      setenv("EGL_PLATFORM", "x11", 1);
      self->wegl.wcore.vtbl = &xegl_platform_vtbl;
      return &self->wegl.wcore;
    }

    else
    {

    error:
      ;
      xegl_platform_destroy(&self->wegl.wcore);
      return (struct wcore_platform *)(void *)0;
    }
  }
}

// xegl_platform_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_platform.c line 46
static _Bool xegl_platform_destroy(struct wcore_platform *wc_self)
{
  struct xegl_platform *self;
  struct wegl_platform_2 *return_value_wegl_platform_1;
  return_value_wegl_platform_1=wegl_platform_link6(wc_self);
  self=xegl_platform(return_value_wegl_platform_1);
  _Bool ok = (_Bool)1;
  _Bool return_value_linux_platform_destroy_2;
  if(self == ((struct xegl_platform *)NULL))
    return (_Bool)1;

  else
  {
    unsetenv("EGL_PLATFORM");
    if(!(self->linux == ((struct linux_platform *)NULL)))
    {
      return_value_linux_platform_destroy_2=linux_platform_destroy(self->linux);
      ok = ((signed int)ok & (signed int)return_value_linux_platform_destroy_2) != 0;
    }

    _Bool return_value_wegl_platform_teardown_3;
    return_value_wegl_platform_teardown_3=wegl_platform_teardown(&self->wegl);
    ok = ((signed int)ok & (signed int)return_value_wegl_platform_teardown_3) != 0;
    free((void *)self);
    return ok;
  }
}

// xegl_window
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_window.h line 45
static inline struct xegl_window * xegl_window(struct wcore_window *wc_self)
{
  struct wegl_window *tmp_statement_expression_1;
  struct xegl_window *tmp_statement_expression_2;
  if(!(wc_self == ((struct wcore_window *)NULL)))
  {
    struct wegl_window *wegl_self;
    const struct wcore_window *__mptr = wc_self;
    tmp_statement_expression_1 = (struct wegl_window *)((void *)__mptr - (signed long int)0ul);
    wegl_self = tmp_statement_expression_1;
    const struct wegl_window *xegl_window__1__1__2____mptr = wegl_self;
    tmp_statement_expression_2 = (struct xegl_window *)((void *)xegl_window__1__1__2____mptr - (signed long int)16ul);
    return tmp_statement_expression_2;
  }

  else
    return (struct xegl_window *)(void *)0;
}

// xegl_window_create
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_window.h line 57
struct wcore_window * xegl_window_create(struct wcore_platform *wc_plat, struct wcore_config *wc_config, signed int width, signed int height)
{
  struct xegl_window *self;
  struct xegl_display *dpy;
  dpy=xegl_display_link2(wc_config->display);
  struct wegl_config *config;
  config=wegl_config_link5(wc_config);
  struct wegl_platform_2 *plat;
  plat=wegl_platform_link7(wc_plat);
  unsigned int visual;
  _Bool ok = (_Bool)1;
  void *return_value_wcore_calloc_1;
  return_value_wcore_calloc_1=wcore_calloc(sizeof(struct xegl_window) /*40ul*/ );
  self = (struct xegl_window *)return_value_wcore_calloc_1;
  if(self == ((struct xegl_window *)NULL))
    return (struct wcore_window *)(void *)0;

  else
  {
    unsigned int return_value;
    return_value=plat->eglGetConfigAttrib(dpy->wegl.egl, config->egl, 0x302E, (signed int *)&visual);
    ok = (_Bool)return_value;
    if(ok == (_Bool)0)
      wegl_emit_error(plat, "eglGetConfigAttrib(EGL_NATIVE_VISUAL_ID)");

    else
    {
      ok=x11_window_init(&self->x11, &dpy->x11, visual, width, height);
      if(!(ok == (_Bool)0))
      {
        ok=wegl_window_init(&self->wegl, &config->wcore, (signed long int)self->x11.xcb);
        if(!(ok == (_Bool)0))
          return &self->wegl.wcore;

      }

    }

  error:
    ;
    xegl_window_destroy(&self->wegl.wcore);
    return (struct wcore_window *)(void *)0;
  }
}

// xegl_window_destroy
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_window.h line 63
_Bool xegl_window_destroy(struct wcore_window *wc_self)
{
  struct xegl_window *self;
  self=xegl_window(wc_self);
  _Bool ok = (_Bool)1;
  if(self == ((struct xegl_window *)NULL))
    return ok;

  else
  {
    _Bool return_value_wegl_window_teardown_1;
    return_value_wegl_window_teardown_1=wegl_window_teardown(&self->wegl);
    ok = ((signed int)ok & (signed int)return_value_wegl_window_teardown_1) != 0;
    _Bool return_value_x11_window_teardown_2;
    return_value_x11_window_teardown_2=x11_window_teardown(&self->x11);
    ok = ((signed int)ok & (signed int)return_value_x11_window_teardown_2) != 0;
    free((void *)self);
    return ok;
  }
}

// xegl_window_get_native
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_window.h line 73
union waffle_native_window * xegl_window_get_native(struct wcore_window *wc_self)
{
  struct xegl_window *self;
  self=xegl_window(wc_self);
  struct xegl_display *dpy;
  dpy=xegl_display_link2(wc_self->display);
  union waffle_native_window *n_window;
  do
  {
    void *return_value_wcore_malloc_1;
    return_value_wcore_malloc_1=wcore_malloc(sizeof(union waffle_native_window) /*8ul*/  + sizeof(struct waffle_x11_egl_window) /*32ul*/ );
    n_window = (union waffle_native_window *)return_value_wcore_malloc_1;
    if(!(n_window == ((union waffle_native_window *)NULL)))
      n_window->x11_egl = (struct waffle_x11_egl_window *)(void *)(n_window + (signed long int)1);

  }
  while((_Bool)0);
  if(n_window == ((union waffle_native_window *)NULL))
    return (union waffle_native_window *)(void *)0;

  else
  {
    xegl_display_fill_native(dpy, &n_window->x11_egl->display);
    n_window->x11_egl->xlib_window = (unsigned long int)self->x11.xcb;
    n_window->x11_egl->egl_surface = self->wegl.egl;
    return n_window;
  }
}

// xegl_window_resize
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_window.h line 69
_Bool xegl_window_resize(struct wcore_window *wc_self, signed int width, signed int height)
{
  struct xegl_window *return_value_xegl_window_1;
  return_value_xegl_window_1=xegl_window(wc_self);
  _Bool return_value_x11_window_resize_2;
  return_value_x11_window_resize_2=x11_window_resize(&return_value_xegl_window_1->x11, width, height);
  return return_value_x11_window_resize_2;
}

// xegl_window_show
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/src/waffle/xegl/xegl_window.h line 66
_Bool xegl_window_show(struct wcore_window *wc_self)
{
  struct xegl_window *return_value_xegl_window_1;
  return_value_xegl_window_1=xegl_window(wc_self);
  _Bool return_value_x11_window_show_2;
  return_value_x11_window_show_2=x11_window_show(&return_value_xegl_window_1->x11);
  return return_value_x11_window_show_2;
}

// xtime_get
// file /srv/jenkins-slave/workspace/sid-goto-cc-waffle/waffle-1.5.2/third_party/threads/threads_posix.c line 316
signed int xtime_get(struct xtime *xt, signed int base)
{
  if(xt == ((struct xtime *)NULL))
    return 0;

  else
    if(base == 1)
    {
      xt->sec=time((signed long int *)(void *)0);
      xt->nsec = (signed long int)0;
      return base;
    }

    else
      return 0;
}

