// tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_13;

// tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_11;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_8;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_5;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_0;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_9;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_2;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_4;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_1;

// tag-#anon#ST[S32'time'||S32'volume'||S32'pitch'|]
// file beepPA.c line 41
struct anonymous_10;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_12;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V_'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous_7;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_3;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_6;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-pa_buffer_attr
// file /usr/include/pulse/def.h line 387
struct pa_buffer_attr;

// tag-pa_channel_map
// file /usr/include/pulse/channelmap.h line 262
struct pa_channel_map;

// tag-pa_channel_position
// file /usr/include/pulse/channelmap.h line 74
enum pa_channel_position { PA_CHANNEL_POSITION_INVALID=-1, PA_CHANNEL_POSITION_MONO=0, PA_CHANNEL_POSITION_FRONT_LEFT=1, PA_CHANNEL_POSITION_FRONT_RIGHT=2, PA_CHANNEL_POSITION_FRONT_CENTER=3, PA_CHANNEL_POSITION_LEFT=1, PA_CHANNEL_POSITION_RIGHT=2, PA_CHANNEL_POSITION_CENTER=3, PA_CHANNEL_POSITION_REAR_CENTER=4, PA_CHANNEL_POSITION_REAR_LEFT=5, PA_CHANNEL_POSITION_REAR_RIGHT=6, PA_CHANNEL_POSITION_LFE=7, PA_CHANNEL_POSITION_SUBWOOFER=7, PA_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER=8, PA_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER=9, PA_CHANNEL_POSITION_SIDE_LEFT=10, PA_CHANNEL_POSITION_SIDE_RIGHT=11, PA_CHANNEL_POSITION_AUX0=12, PA_CHANNEL_POSITION_AUX1=13, PA_CHANNEL_POSITION_AUX2=14, PA_CHANNEL_POSITION_AUX3=15, PA_CHANNEL_POSITION_AUX4=16, PA_CHANNEL_POSITION_AUX5=17, PA_CHANNEL_POSITION_AUX6=18, PA_CHANNEL_POSITION_AUX7=19, PA_CHANNEL_POSITION_AUX8=20, PA_CHANNEL_POSITION_AUX9=21, PA_CHANNEL_POSITION_AUX10=22, PA_CHANNEL_POSITION_AUX11=23, PA_CHANNEL_POSITION_AUX12=24, PA_CHANNEL_POSITION_AUX13=25, PA_CHANNEL_POSITION_AUX14=26, PA_CHANNEL_POSITION_AUX15=27, PA_CHANNEL_POSITION_AUX16=28, PA_CHANNEL_POSITION_AUX17=29, PA_CHANNEL_POSITION_AUX18=30, PA_CHANNEL_POSITION_AUX19=31, PA_CHANNEL_POSITION_AUX20=32, PA_CHANNEL_POSITION_AUX21=33, PA_CHANNEL_POSITION_AUX22=34, PA_CHANNEL_POSITION_AUX23=35, PA_CHANNEL_POSITION_AUX24=36, PA_CHANNEL_POSITION_AUX25=37, PA_CHANNEL_POSITION_AUX26=38, PA_CHANNEL_POSITION_AUX27=39, PA_CHANNEL_POSITION_AUX28=40, PA_CHANNEL_POSITION_AUX29=41, PA_CHANNEL_POSITION_AUX30=42, PA_CHANNEL_POSITION_AUX31=43, PA_CHANNEL_POSITION_TOP_CENTER=44, PA_CHANNEL_POSITION_TOP_FRONT_LEFT=45, PA_CHANNEL_POSITION_TOP_FRONT_RIGHT=46, PA_CHANNEL_POSITION_TOP_FRONT_CENTER=47, PA_CHANNEL_POSITION_TOP_REAR_LEFT=48, PA_CHANNEL_POSITION_TOP_REAR_RIGHT=49, PA_CHANNEL_POSITION_TOP_REAR_CENTER=50, PA_CHANNEL_POSITION_MAX=51 };

// tag-pa_sample_format
// file /usr/include/pulse/sample.h line 134
enum pa_sample_format { PA_SAMPLE_U8=0, PA_SAMPLE_ALAW=1, PA_SAMPLE_ULAW=2, PA_SAMPLE_S16LE=3, PA_SAMPLE_S16BE=4, PA_SAMPLE_FLOAT32LE=5, PA_SAMPLE_FLOAT32BE=6, PA_SAMPLE_S32LE=7, PA_SAMPLE_S32BE=8, PA_SAMPLE_S24LE=9, PA_SAMPLE_S24BE=10, PA_SAMPLE_S24_32LE=11, PA_SAMPLE_S24_32BE=12, PA_SAMPLE_MAX=13, PA_SAMPLE_INVALID=-1 };

// tag-pa_sample_spec
// file /usr/include/pulse/sample.h line 248
struct pa_sample_spec;

// tag-pa_simple
// file /usr/include/pulse/simple.h line 115
struct pa_simple;

// tag-pa_stream_direction
// file /usr/include/pulse/def.h line 156
enum pa_stream_direction { PA_STREAM_NODIRECTION=0, PA_STREAM_PLAYBACK=1, PA_STREAM_RECORD=2, PA_STREAM_UPLOAD=3 };

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sched_param
// file /usr/include/x86_64-linux-gnu/bits/sched.h line 72
struct sched_param;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-termios
// file /usr/include/x86_64-linux-gnu/bits/termios.h line 28
struct termios;

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// Beep
// file beep.h line 35
signed int Beep(signed int time, signed int volume, signed int pitch);
// BeepCleanup
// file beep.h line 49
signed int BeepCleanup(void);
// BeepInit
// file beep.h line 15
signed int BeepInit(void);
// BeepResume
// file beep.h line 56
signed int BeepResume(void);
// BeepWait
// file beep.h line 42
signed int BeepWait(void);
// _IO_getc
// file /usr/include/libio.h line 434
extern signed int _IO_getc(struct _IO_FILE *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __ctype_tolower_loc
// file /usr/include/ctype.h line 81
extern const signed int ** __ctype_tolower_loc(void);
// __rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
extern void * __rawmemchr(const void *, signed int);
// atof
// file /usr/include/x86_64-linux-gnu/bits/stdlib-float.h line 26
static inline double atof(const char *__nptr);
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// beep_threadfunc
// file beepPA.c line 85
static void * beep_threadfunc(void *opaque);
// cleanup
// file morse.c line 1793
static void cleanup(void);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closeterminal
// file morse.c line 1779
static void closeterminal(void);
// die
// file morse.c line 1786
static void die(void);
// difftime
// file /usr/include/time.h line 195
extern double difftime(signed long int, signed long int);
// dowords
// file morse.c line 846
static void dowords(signed int c);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// getchar
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 44
static inline signed int getchar(void);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// isatty
// file /usr/include/unistd.h line 779
extern signed int isatty(signed int);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// lrand48
// file /usr/include/stdlib.h line 393
extern signed long int lrand48(void);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// morse
// file morse.c line 1234
static void morse(signed int c);
// new_words_per_minute
// file morse.c line 803
static void new_words_per_minute(void);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// openterminal
// file morse.c line 1742
static void openterminal(void);
// pa_simple_drain
// file /usr/include/pulse/simple.h line 137
signed int pa_simple_drain(struct pa_simple *, signed int *);
// pa_simple_free
// file /usr/include/pulse/simple.h line 131
void pa_simple_free(struct pa_simple *);
// pa_simple_new
// file /usr/include/pulse/simple.h line 118
struct pa_simple * pa_simple_new(const char *, const char *, enum pa_stream_direction, const char *, const char *, const struct pa_sample_spec *, const struct pa_channel_map *, const struct pa_buffer_attr *, signed int *);
// pa_simple_write
// file /usr/include/pulse/simple.h line 134
signed int pa_simple_write(struct pa_simple *, const void *, unsigned long int, signed int *);
// pa_strerror
// file /usr/include/pulse/error.h line 33
const char * pa_strerror(signed int);
// play_tone
// file beepPA.c line 47
static void play_tone();
// pollyou
// file morse.c line 1435
static void pollyou(void);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_attr_getschedparam
// file /usr/include/pthread.h line 318
extern signed int pthread_attr_getschedparam(const union pthread_attr_t *, struct sched_param *);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setschedparam
// file /usr/include/pthread.h line 323
extern signed int pthread_attr_setschedparam(union pthread_attr_t *, struct sched_param *);
// pthread_attr_setschedpolicy
// file /usr/include/pthread.h line 333
extern signed int pthread_attr_setschedpolicy(union pthread_attr_t *, signed int);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_6 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_6 *, union anonymous *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous *);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// rancomp
// file morse.c line 1881
static signed int rancomp(const void *elem1, const void *elem2);
// randomletter
// file morse.c line 1820
static signed int randomletter(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// readterminal
// file morse.c line 1759
static signed int readterminal(char **string);
// report
// file morse.c line 1900
static void report(void);
// sched_get_priority_max
// file /usr/include/sched.h line 68
extern signed int sched_get_priority_max(signed int);
// show
// file morse.c line 1351
static void show(char *s);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous_8 *);
// sin
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 65
extern double sin(double);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// srand48
// file /usr/include/stdlib.h line 403
extern void srand48(signed long int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// suspend
// file morse.c line 1801
static void suspend(signed int sig);
// tcgetattr
// file /usr/include/termios.h line 66
extern signed int tcgetattr(signed int, struct termios *);
// tcsetattr
// file /usr/include/termios.h line 70
extern signed int tcsetattr(signed int, signed int, struct termios *);
// testaddchar
// file morse.c line 1391
static void testaddchar(char c);
// testterminal
// file morse.c line 1447
static signed int testterminal(void);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tolower
// file /usr/include/ctype.h line 215
static inline signed int tolower(signed int __c);
// tone
// file morse.c line 1716
static void tone(float hertz, float duration, float amplitude);
// toneflush
// file morse.c line 1723
static void toneflush(void);
// youraddchar
// file morse.c line 1417
static void youraddchar(char c);

struct anonymous_13
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_11
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous_8
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_5
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_0
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_9
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_2
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_1
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_12
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_3
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_0 _kill;
  // _timer
  struct anonymous_1 _timer;
  // _rt
  struct anonymous_2 _rt;
  // _sigchld
  struct anonymous_9 _sigchld;
  // _sigfault
  struct anonymous_11 _sigfault;
  // _sigpoll
  struct anonymous_12 _sigpoll;
  // _sigsys
  struct anonymous_13 _sigsys;
};

struct anonymous_4
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_3 _sifields;
};

struct anonymous_10
{
  // time
  signed int time;
  // volume
  signed int volume;
  // pitch
  signed int pitch;
};

union anonymous_7
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_4 *, void *);
};

union anonymous_6
{
  // __data
  struct anonymous_5 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct pa_buffer_attr
{
  // maxlength
  unsigned int maxlength;
  // tlength
  unsigned int tlength;
  // prebuf
  unsigned int prebuf;
  // minreq
  unsigned int minreq;
  // fragsize
  unsigned int fragsize;
};

struct pa_channel_map
{
  // channels
  unsigned char channels;
  // map
  enum pa_channel_position map[32l];
};

struct pa_sample_spec
{
  // format
  enum pa_sample_format format;
  // rate
  unsigned int rate;
  // channels
  unsigned char channels;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sched_param
{
  // __sched_priority
  signed int __sched_priority;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous_7 __sigaction_handler;
  // sa_mask
  struct anonymous_8 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct termios
{
  // c_iflag
  unsigned int c_iflag;
  // c_oflag
  unsigned int c_oflag;
  // c_cflag
  unsigned int c_cflag;
  // c_lflag
  unsigned int c_lflag;
  // c_line
  unsigned char c_line;
  // c_cc
  unsigned char c_cc[32l];
  // c_ispeed
  unsigned int c_ispeed;
  // c_ospeed
  unsigned int c_ospeed;
};


// allprosigns
// file morse.c line 96
static _Bool allprosigns = (_Bool)0;
// allpunctuation
// file morse.c line 97
static _Bool allpunctuation = (_Bool)0;
// beep_cv
// file beepPA.c line 31
static union anonymous_6 beep_cv = { .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } };
// beep_info
// file beepPA.c line 45
static struct anonymous_10 beep_info = { .time=0, .volume=0, .pitch=0 };
// beep_mutex
// file beepPA.c line 30
static union anonymous beep_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// beep_thread
// file beepPA.c line 29
static unsigned long int beep_thread;
// behindness
// file morse.c line 119
static signed int behindness = 0;
// catchup_time
// file morse.c line 83
static float catchup_time;
// charbychar
// file morse.c line 94
static _Bool charbychar = (_Bool)0;
// code
// file morse.c line 135
static char *code[256l];
// dash_time
// file morse.c line 79
static float dash_time;
// dot_time
// file morse.c line 78
static float dot_time;
// dynamicspeed
// file morse.c line 93
static _Bool dynamicspeed = (_Bool)0;
// enter_standout_mode
// file morse.c line 148
static const char *enter_standout_mode = "\033[7m";
// error_floor
// file morse.c line 160
static signed int error_floor = -3;
// error_frequency
// file morse.c line 100
static float error_frequency = (float)2000.0;
// error_threshold
// file morse.c line 159
static signed int error_threshold = 1000;
// error_volume
// file morse.c line 101
static float error_volume = (float)0.5;
// errorlog
// file morse.c line 136
static signed int errorlog[256l];
// exit_standout_mode
// file morse.c line 149
static const char *exit_standout_mode = "\033[0m";
// fancyending
// file morse.c line 88
static _Bool fancyending = (_Bool)1;
// frequency
// file morse.c line 76
static float frequency;
// frequency1
// file morse.c line 74
static float frequency1 = (float)800.0;
// frequency2
// file morse.c line 75
static float frequency2 = (float)602.0;
// fwords_per_minute
// file morse.c line 102
static float fwords_per_minute;
// helpmeflag
// file morse.c line 109
static _Bool helpmeflag = (_Bool)0;
// inter_char_time
// file morse.c line 81
static float inter_char_time;
// inter_word_time
// file morse.c line 82
static float inter_word_time;
// international
// file morse.c line 95
static _Bool international = (_Bool)0;
// intra_char_time
// file morse.c line 80
static float intra_char_time;
// keepquiet
// file morse.c line 92
static signed int keepquiet = 0;
// linepos
// file morse.c line 125
static signed int linepos = 0;
// max_behindness
// file morse.c line 120
static signed int max_behindness = 0;
// noticebad
// file morse.c line 89
static _Bool noticebad = (_Bool)0;
// oldtermgtty
// file morse.c line 1734
struct termios oldtermgtty;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// randomfactor
// file morse.c line 137
static signed int randomfactor[256l];
// randomletters
// file morse.c line 103
static _Bool randomletters = (_Bool)0;
// randomripe
// file morse.c line 138
static signed int randomripe[256l];
// sample_format
// file beepPA.c line 33
static const struct pa_sample_spec sample_format = { .format=(enum pa_sample_format)3, .rate=(unsigned int)44100, .channels=(unsigned char)1 };
// showletters
// file morse.c line 84
static _Bool showletters = (_Bool)0;
// showmorse
// file morse.c line 85
static _Bool showmorse = (_Bool)0;
// showtesting
// file morse.c line 91
static _Bool showtesting = (_Bool)0;
// slowpoke
// file morse.c line 843
static signed int slowpoke = 0;
// snddev
// file beepPA.c line 39
static struct pa_simple *snddev;
// starttime
// file morse.c line 115
static signed long int starttime;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// termfd
// file morse.c line 1737
static signed int termfd;
// termgtty
// file morse.c line 1735
struct termios termgtty;
// terminal
// file morse.c line 1736
static char *terminal = "/dev/tty";
// termopen
// file morse.c line 1738
static signed int termopen = 0;
// testing
// file morse.c line 90
static _Bool testing = (_Bool)0;
// testlength
// file morse.c line 118
static signed int testlength = 0;
// testpointer
// file morse.c line 117
static signed int testpointer = -1;
// teststring
// file morse.c line 121
static char teststring[210l];
// timeout
// file morse.c line 116
static signed int timeout = -1;
// totalhitcount
// file morse.c line 107
static signed int totalhitcount = 0;
// totalmisscount
// file morse.c line 108
static signed int totalmisscount = 0;
// tryagaincount
// file morse.c line 98
static signed int tryagaincount = 1;
// tryingagain
// file morse.c line 843
static signed int tryingagain = 0;
// typeaway
// file morse.c line 105
static _Bool typeaway = (_Bool)0;
// user_charset
// file morse.c line 126
static char *user_charset = (char *)(void *)0;
// volume
// file morse.c line 77
static float volume = (float)0.5;
// whichfrequ
// file morse.c line 73
static signed int whichfrequ = 0;
// wordcount
// file morse.c line 114
static signed int wordcount = -1;
// wordlen
// file morse.c line 113
static signed int wordlen = 20;
// words_per_minute
// file morse.c line 99
static float words_per_minute = (float)20.0;
// wordsafter
// file morse.c line 87
static _Bool wordsafter = (_Bool)0;
// wordsbefore
// file morse.c line 86
static _Bool wordsbefore = (_Bool)0;
// yourlength
// file morse.c line 123
static signed int yourlength = 0;
// yourpointer
// file morse.c line 122
static signed int yourpointer = -1;
// yourstring
// file morse.c line 124
static char yourstring[210l];

// Beep
// file beep.h line 35
signed int Beep(signed int time, signed int volume, signed int pitch)
{
  pthread_mutex_lock(&beep_mutex);
  if(!(beep_info.time == 0))
    pthread_cond_wait(&beep_cv, &beep_mutex);

  beep_info.time = time;
  beep_info.volume = volume;
  beep_info.pitch = pitch;
  pthread_mutex_unlock(&beep_mutex);
  pthread_cond_signal(&beep_cv);
}

// BeepCleanup
// file beep.h line 49
signed int BeepCleanup(void)
{
  BeepWait();
  Beep(-1, 0, 0);
  pthread_join(beep_thread, (void **)(void *)0);
  pa_simple_drain(snddev, (signed int *)(void *)0);
  pa_simple_free(snddev);
  return 0;
}

// BeepInit
// file beep.h line 15
signed int BeepInit(void)
{
  signed int r;
  signed int error;
  union pthread_attr_t bt_attr;
  struct sched_param bt_sched_param;
  snddev=pa_simple_new((const char *)(void *)0, "Morse Code Trainer", (enum pa_stream_direction)PA_STREAM_PLAYBACK, (const char *)(void *)0, "beep", &sample_format, (const struct pa_channel_map *)(void *)0, (const struct pa_buffer_attr *)(void *)0, &error);
  if(snddev == ((struct pa_simple *)NULL))
  {
    const char *return_value_pa_strerror_1;
    return_value_pa_strerror_1=pa_strerror(error);
    fprintf(stderr, "Could not initialize audio: %s\n", return_value_pa_strerror_1);
    return 1;
  }

  pthread_attr_init(&bt_attr);
  pthread_attr_setschedpolicy(&bt_attr, 1);
  pthread_attr_getschedparam(&bt_attr, &bt_sched_param);
  bt_sched_param.__sched_priority=sched_get_priority_max(1);
  pthread_attr_setschedparam(&bt_attr, &bt_sched_param);
  pthread_mutex_lock(&beep_mutex);
  r=pthread_create(&beep_thread, &bt_attr, beep_threadfunc, (void *)0);
  if(!(r == 0))
  {
    fprintf(stderr, "Could not create audio thread: %d\n", r);
    return 1;
  }

  else
  {
    pthread_cond_wait(&beep_cv, &beep_mutex);
    pthread_mutex_unlock(&beep_mutex);
    return 0;
  }
}

// BeepResume
// file beep.h line 56
signed int BeepResume(void)
{
  return 0;
}

// BeepWait
// file beep.h line 42
signed int BeepWait(void)
{
  pthread_mutex_lock(&beep_mutex);
  if(!(beep_info.time == 0))
    pthread_cond_wait(&beep_cv, &beep_mutex);

  pthread_mutex_unlock(&beep_mutex);
}

// atof
// file /usr/include/x86_64-linux-gnu/bits/stdlib-float.h line 26
static inline double atof(const char *__nptr)
{
  double return_value_strtod_1;
  return_value_strtod_1=strtod(__nptr, (char **)(void *)0);
  return return_value_strtod_1;
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol_1;
  return_value_strtol_1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1;
}

// beep_threadfunc
// file beepPA.c line 85
static void * beep_threadfunc(void *opaque)
{
  pthread_cond_signal(&beep_cv);
  while((_Bool)1)
  {
    pthread_mutex_lock(&beep_mutex);
    if(beep_info.time == 0)
      pthread_cond_wait(&beep_cv, &beep_mutex);

    if(!(beep_info.time >= 0))
      break;

    play_tone();
    beep_info.time = 0;
    pthread_cond_signal(&beep_cv);
    pthread_mutex_unlock(&beep_mutex);
  }
  pthread_exit(NULL);
}

// cleanup
// file morse.c line 1793
static void cleanup(void)
{
  if(!(termopen == 0))
    closeterminal();

  BeepCleanup();
}

// closeterminal
// file morse.c line 1779
static void closeterminal(void)
{
  tcsetattr(termfd, 1, &oldtermgtty);
  close(termfd);
}

// die
// file morse.c line 1786
static void die(void)
{
  cleanup();
  exit(1);
}

// dowords
// file morse.c line 846
static void dowords(signed int c)
{
  char *wordp;
  if(!(c == 7) && !(c == -2) && !(c == -1))
    linepos = linepos + 1;

  const unsigned short int **return_value___ctype_b_loc_1;
  return_value___ctype_b_loc_1=__ctype_b_loc();
  if(!((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)c]) == 0))
  {
    if(linepos + wordlen >= 78)
      c = 10;

  }

  if(c == 10)
    linepos = 0;

  const unsigned short int **return_value___ctype_b_loc_7;
  return_value___ctype_b_loc_7=__ctype_b_loc();
  signed long int return_value_time_2;
  double return_value_difftime_3;
  _Bool tmp_if_expr_4;
  signed int tmp_post_6;
  static char word[21l];
  static signed int wordc = 0;
  if(c == 7 || c == -2 || c == -1 || !((8192 & (signed int)(*return_value___ctype_b_loc_7)[(signed long int)c]) == 0))
  {
    if(wordc >= 1)
    {
      signed int againcount;
      if(wordcount >= 1)
        wordcount = wordcount - 1;

      if(timeout >= 1)
      {
        return_value_time_2=time((signed long int *)(void *)0);
        return_value_difftime_3=difftime(return_value_time_2, starttime);
        if(return_value_difftime_3 > (double)timeout)
          timeout = 0;

      }

      word[(signed long int)wordc] = (char)0;
      if(charbychar == (_Bool)0 && !(dynamicspeed == (_Bool)0) && !(testing == (_Bool)0))
      {
        if(behindness == 0)
        {
          words_per_minute = words_per_minute * (float)1.02;
          new_words_per_minute();
        }

        else
          if(behindness >= 4)
          {
            words_per_minute = words_per_minute / (float)1.15;
            new_words_per_minute();
          }

          else
            if(behindness >= 2)
            {
              words_per_minute = words_per_minute / (float)1.02;
              new_words_per_minute();
            }

      }

      if(!(testing == (_Bool)0) && (behindness >= 7 || !(helpmeflag == (_Bool)0)))
      {
        if(!(helpmeflag == (_Bool)0))
          printf("\nOK, let's restart.\n");

        else
          printf("\nYou are too far behind! Let's restart.\n");
        fflush(stdout);
        toneflush();
        pollyou();
        helpmeflag = (_Bool)0;
        behindness = 0;
        testlength = 0;
        yourlength = 0;
        sleep((unsigned int)2);
        printf("\nWPM now %d\n", (signed int)((double)words_per_minute + .5));
        fflush(stdout);
        sleep((unsigned int)2);
        printf("\nREADY?\n");
        fflush(stdout);
        sleep((unsigned int)1);
        printf("\nSET\n");
        fflush(stdout);
        sleep((unsigned int)1);
        printf("\nGO!\n");
        fflush(stdout);
        linepos = 0;
      }

      if(!(wordsbefore == (_Bool)0))
      {
        if(!(showtesting == (_Bool)0))
        {
          printf("\n");
          linepos = 0;
        }

        printf("%s", (const void *)word);
        if(!(showletters == (_Bool)0) || !(showmorse == (_Bool)0) || !(showtesting == (_Bool)0) || !(wordsafter == (_Bool)0))
        {
          signed int ii;
          printf("  ");
          ii = 0;
          for( ; !(ii >= 16 + -(2 + wordc)); ii = ii + 1)
            printf(" ");
        }

        fflush(stdout);
      }

      if(!(charbychar == (_Bool)0) && !(testing == (_Bool)0))
        againcount = 0;

      wordp = word;
      for( ; !((signed int)*wordp == 0); wordp = wordp + 1l)
      {
        tryingagain = 0;
        do
        {

        tryagain:
          ;
          if(showletters == (_Bool)0 && tryingagain == 0 && !(error_threshold >= 1000) && !(testing == (_Bool)0))
            tmp_if_expr_4 = errorlog[(signed long int)(signed int)*wordp] > error_threshold ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4 = (_Bool)0;
          if(tmp_if_expr_4)
          {
            toneflush();
            printf("[%c]", *wordp);
            fflush(stdout);
            morse((signed int)*wordp);
            toneflush();
            if(showmorse == (_Bool)0)
            {
              printf("\b\b\b   \b\b\b");
              fflush(stdout);
            }

          }

          else
            morse((signed int)*wordp);
          if(testing == (_Bool)0)
            goto __CPROVER_DUMP_L37;

          if(charbychar == (_Bool)0)
            goto __CPROVER_DUMP_L32;

          toneflush();
          slowpoke = 0;
          while(behindness >= 1)
          {
            signed int return_value_testterminal_5;
            return_value_testterminal_5=testterminal();
            if(tryagaincount >= 1 && !(return_value_testterminal_5 == 0))
            {
              printf("Try again.\n");
              linepos = 0;
              againcount = tryagaincount - 1;
              tryingagain = 1;
              goto tryagain;
            }

            else
              if(behindness >= 1)
              {
                tone(frequency, catchup_time, (float)0.);
                if(!(slowpoke >= 10))
                  slowpoke = slowpoke + 1;

                toneflush();
              }

              else
                if(slowpoke == 0 && tryingagain == 0 && !(dynamicspeed == (_Bool)0))
                {
                  words_per_minute = words_per_minute * (float)1.02;
                  new_words_per_minute();
                }

          }
          if(!(againcount >= 1))
            break;

          againcount = againcount - 1;
        }
        while((_Bool)1);
        goto __CPROVER_DUMP_L37;

      __CPROVER_DUMP_L32:
        ;
        testterminal();
        if(max_behindness >= 1)
        {
          _Bool are_we_repeating = (_Bool)0;
          while(behindness >= max_behindness)
          {
            if(!(are_we_repeating == (_Bool)0))
              tone(frequency, catchup_time, (float)0.);

            else
              are_we_repeating = (_Bool)1;
            toneflush();
            testterminal();
          }
        }


      __CPROVER_DUMP_L37:
        ;
      }
      toneflush();
      if(!(testing == (_Bool)0))
        testterminal();

      if(!(wordsafter == (_Bool)0))
        printf(" (%s)", (const void *)word);

      if(!(showmorse == (_Bool)0) || !(wordsafter == (_Bool)0) || !(wordsbefore == (_Bool)0))
      {
        if(showmorse == (_Bool)0 && testing == (_Bool)0 && !(linepos == 0))
        {
          if(!(wordsafter == (_Bool)0))
            linepos = linepos + 3;

          else
            printf(" ");
        }

        else
        {
          printf("\n");
          linepos = 0;
        }
      }

      else
        if(!(showletters == (_Bool)0) || !(showtesting == (_Bool)0))
        {
          if(!(c == 7) && !(c == -2) && !(c == -1))
          {
            if(!(showletters == (_Bool)0))
              printf("%c", c);

            if(!(showtesting == (_Bool)0))
              testaddchar((char)c);

          }

        }

      fflush(stdout);
      tone(frequency, (float)(1.5 * (double)inter_char_time), (float)0.);
      toneflush();
      tone(frequency, (float)((double)inter_word_time - 1.5 * (double)inter_char_time), (float)0.);
      if(!(testing == (_Bool)0))
        testterminal();

      wordc = 0;
    }

    else
      if(showmorse == (_Bool)0 && wordsafter == (_Bool)0 && wordsbefore == (_Bool)0 && (!(showletters == (_Bool)0) || !(showtesting == (_Bool)0)))
      {
        if(!(c == 7) && !(c == -2) && !(c == -1))
        {
          if(!(showletters == (_Bool)0))
            printf("%c", c);

          if(!(showtesting == (_Bool)0))
            testaddchar((char)c);

        }

      }

    if(c == -1)
    {
      morse(-1);
      toneflush();
    }

    else
      if(c == -2)
        toneflush();

      else
        if(c == 7)
        {
          whichfrequ = 1 - whichfrequ;
          if(!(whichfrequ == 1))
          {
            if(whichfrequ == 0)
              goto __CPROVER_DUMP_L55;

          }

          else
          {
            frequency = frequency2;
            goto __CPROVER_DUMP_L56;
          }

        __CPROVER_DUMP_L55:
          ;
          frequency = frequency1;
        }

  }

  else
  {
    tmp_post_6 = wordc;
    wordc = wordc + 1;
    word[(signed long int)tmp_post_6] = (char)c;
  }

__CPROVER_DUMP_L56:
  ;
  const unsigned short int **return_value___ctype_b_loc_8;
  if(wordc == wordlen)
  {
    return_value___ctype_b_loc_8=__ctype_b_loc();
    if(!(c == 7) && !(c == -2) && !(c == -1) && (8192 & (signed int)(*return_value___ctype_b_loc_8)[(signed long int)c]) == 0)
      dowords((signed int)32);

  }

}

// getchar
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 44
static inline signed int getchar(void)
{
  signed int return_value__IO_getc_1;
  return_value__IO_getc_1=_IO_getc(stdin);
  return return_value__IO_getc_1;
}

// main
// file morse.c line 260
signed int main(signed int argc, char **argv)
{
  signed int ch;
  char *p;
  signed int ii;
  struct sigaction handler;
  signed int return_value_fileno_1;
  signed int return_value_isatty_2;
  if(argc == 1)
  {
    return_value_fileno_1=fileno(stdin);
    return_value_isatty_2=isatty(return_value_fileno_1);
    if(!(return_value_isatty_2 == 0))
    {
      printf("Usage:\n");
      printf("morse [options] < text_file\n");
      printf("morse [options] words words words\n");
      printf("morse [options] -r\n");
      printf("morse [options] -i\n");
      printf("Options:\n");
      printf("-i    Play what you type.\n");
      printf("-I    Like -i but don't turn off keyboard echoing.\n");
      printf("-r    Generate random text. Starts out slanted towards easy\n");
      printf("      letters, then slants towards ones you get wrong.\n");
      printf("-n NUM (default %d means random length)\n", 20);
      printf("      Make words (groups) NUM characters long.\n");
      printf("      Valid values are between %d and %d.\n", 1, 20);
      printf("-R NUM (default 0 means unlimited)\n");
      printf("      Set the total time (in minutes) to generate text.\n");
      printf("-N NUM (default 0 means unlimited)\n");
      printf("      Set the total number of words (groups) to generate.\n");
      printf("-C 'STRING' (default all available characters)\n");
      printf("      Select characters to send from this STRING only.\n");
      printf("-w words_per_minute (default %g)\n", 20.0);
      printf("      actual overall sending speed\n");
      printf("-F Farnsworth_character_words_per_minute\n");
      printf("      If specified, characters are sent at this speed, with extra\n");
      printf("      spaces inserted to bring the overall speed down to the -w\n");
      printf("      value. Ignored if not higher than -w.\n");
      printf("-f frequency_in_hertz (default %g)\n", 800.0);
      printf("-v volume (zero to one, rather nonlinear, default %g)\n", 0.5);
      printf("-g alternate_frequency (default %g)\n", 602.0);
      printf("      (toggles via control-G in input FILE at a word break)\n");
      printf("-e    leave off the <SK> sound at the end\n");
      printf("-c    complain about illegal characters instead of just ignoring them\n");
      printf("-b    print each word before doing it\n");
      printf("-a    print each word after doing it\n");
      printf("-l    print each letter just before doing it\n");
      printf("-m    print morse dots and dashes as they sound\n");
      printf("-t    Type along with the morse, but don't see what\n");
      printf("      you're typing (unless you make a mistake).\n");
      printf("      You are allowed to get ahead as much as you want.\n");
      printf("      If you get too far behind it will stop and resync with you.\n");
      printf("      You can force it to resync at the next word end by hitting control-H.\n");
      printf("      Hit ESC to see how you are doing, control-D to end.\n");
      printf("      (The rightmost space in the printout marks where the average is.\n");
      printf("      Farther left spaces separate off blocks of letters that are\n");
      printf("      about twice as probable as the average to occur, three times, etc.)\n");
      printf("-T    Like -t but see your characters (after they are played).\n");
      printf("-s    Stop after each character and make sure you get it right. (implies -t)\n");
      printf("-q    Quietly resyncs with your input (after you make a mistake).\n");
      printf("-p NUM (default 0)\n");
      printf("      Make you get it right NUM times, for penance. (implies -s)\n");
      printf("      (Yes, NUM = 0 means you can sin all you want.)\n");
      printf("-E NUM (default %d)\n", 1000);
      printf("      If your count of wrong answers minus right answers for a given character\n");
      printf("      exceeds this, the program will start prompting you.\n");
      printf("      If %d or above, it will never prompt. (implies -t)\n", 1000);
      printf("-M NUM (default %d)\n", 0);
      printf("      If you get more than this number of characters behind, pause until you\n");
      printf("      do your next letter. (1 behind is normal, 0 behind means never pause.)\n");
      printf("      (implies -t)\n");
      printf("-d    Dynamically speed up or slow down depending on how you are doing.\n");
      printf("      (if also -s, then -d _only speeds up_!)\n");
      printf("-A    Add ISO 8850-1 (Latin-1) signs to test set.\n");
      printf("-B    Add uncommon punctuation to test set.\n");
      printf("-S    Add uncommon prosigns to test set.\n");
      printf("-X    Set error volume. Defaults to %g.\n", 0.5);
      printf("      Error volume 0 means use console speaker.\n");
      printf("-x    Set frequency of error tone, default 2000.0Hz\n");
      exit(0);
    }

  }

  double return_value_atof_3;
  double return_value_atof_4;
  double return_value_atof_5;
  double return_value_atof_6;
  double return_value_atof_7;
  double return_value_atof_8;
  double return_value_atof_9;
  do
  {
    ch=getopt(argc, argv, "ABC:E:F:IM:N:R:STX:abcdef:g:ilmn:p:qrstv:w:x:");
    if(ch == -1)
      break;

    switch((signed int)(char)ch)
    {
      case 65:
      {
        international = (_Bool)1;
        break;
      }
      case 66:
      {
        allpunctuation = (_Bool)1;
        break;
      }
      case 67:
      {
        user_charset = optarg;
        break;
      }
      case 69:
      {
        testing = (_Bool)1;
        error_threshold=atoi(optarg);
        if(!(error_threshold >= error_floor))
          error_floor = error_threshold;

        break;
      }
      case 70:
      {
        return_value_atof_3=atof(optarg);
        fwords_per_minute = (float)return_value_atof_3;
        break;
      }
      case 73:
      {
        typeaway = (_Bool)2;
        break;
      }
      case 77:
      {
        testing = (_Bool)1;
        max_behindness=atoi(optarg);
        if(!(max_behindness >= 1))
          max_behindness = 0;

        break;
      }
      case 78:
      {
        wordcount=atoi(optarg);
        if(!(wordcount >= 1))
          wordcount = -1;

        break;
      }
      case 82:
      {
        timeout=atoi(optarg);
        timeout = timeout * 60;
        if(!(timeout >= 1))
          timeout = -1;

        break;
      }
      case 83:
      {
        allprosigns = (_Bool)1;
        break;
      }
      case 84:
      {
        testing = (_Bool)1;
        showtesting = (_Bool)1;
        break;
      }
      case 88:
      {
        return_value_atof_4=atof(optarg);
        error_volume = (float)return_value_atof_4;
        break;
      }
      case 97:
      {
        wordsafter = (_Bool)1;
        break;
      }
      case 98:
      {
        wordsbefore = (_Bool)1;
        break;
      }
      case 99:
      {
        noticebad = (_Bool)1;
        break;
      }
      case 100:
      {
        dynamicspeed = (_Bool)1;
        break;
      }
      case 101:
      {
        fancyending = (_Bool)0;
        break;
      }
      case 102:
      {
        return_value_atof_5=atof(optarg);
        frequency1 = (float)return_value_atof_5;
        break;
      }
      case 103:
      {
        return_value_atof_6=atof(optarg);
        frequency2 = (float)return_value_atof_6;
        break;
      }
      case 105:
      {
        typeaway = (_Bool)1;
        break;
      }
      case 108:
      {
        showletters = (_Bool)1;
        break;
      }
      case 109:
      {
        showmorse = (_Bool)1;
        break;
      }
      case 110:
      {
        wordlen=atoi(optarg);
        if(!(wordlen >= 1))
          wordlen = 1;

        if(wordlen >= 21)
          wordlen = 20;

        break;
      }
      case 112:
      {
        charbychar = (_Bool)1;
        testing = (_Bool)1;
        tryagaincount=atoi(optarg);
        break;
      }
      case 113:
      {
        keepquiet = 1;
        break;
      }
      case 114:
      {
        randomletters = (_Bool)1;
        break;
      }
      case 115:
      {
        charbychar = (_Bool)1;
        testing = (_Bool)1;
        break;
      }
      case 116:
      {
        testing = (_Bool)1;
        break;
      }
      case 118:
      {
        return_value_atof_7=atof(optarg);
        volume = (float)return_value_atof_7;
        if(volume < 0.000000f)
          volume = (float)0.;

        if(volume > 1.000000f)
          volume = (float)1.;

        break;
      }
      case 119:
      {
        return_value_atof_8=atof(optarg);
        words_per_minute = (float)return_value_atof_8;
        break;
      }
      case 120:
      {
        return_value_atof_9=atof(optarg);
        error_frequency = (float)return_value_atof_9;
        break;
      }
      default:
      {
        fprintf(stderr, "Type \"morse\" without arguments to get self-doc!\n");
        exit(1);
      }
    }
  }
  while((_Bool)1);
  argc = argc - optind;
  argv = argv + (signed long int)optind;
  if(fwords_per_minute <= 0.000000f)
    fwords_per_minute = words_per_minute;

  new_words_per_minute();
  frequency = frequency1;
  signed int return_value_BeepInit_10;
  return_value_BeepInit_10=BeepInit();
  if(!(return_value_BeepInit_10 == 0))
  {
    fprintf(stderr, "Can't access speaker.\n");
    exit(1);
  }

  ii = 0;
  for( ; !(ii >= 256); ii = ii + 1)
    code[(signed long int)ii] = (char *)(void *)0;
  code[(signed long int)(signed int)97] = ".-";
  code[(signed long int)(signed int)98] = "-...";
  code[(signed long int)(signed int)99] = "-.-.";
  code[(signed long int)(signed int)100] = "-..";
  code[(signed long int)(signed int)101] = ".";
  code[(signed long int)(signed int)102] = "..-.";
  code[(signed long int)(signed int)103] = "--.";
  code[(signed long int)(signed int)104] = "....";
  code[(signed long int)(signed int)105] = "..";
  code[(signed long int)(signed int)106] = ".---";
  code[(signed long int)(signed int)107] = "-.-";
  code[(signed long int)(signed int)108] = ".-..";
  code[(signed long int)(signed int)109] = "--";
  code[(signed long int)(signed int)110] = "-.";
  code[(signed long int)(signed int)111] = "---";
  code[(signed long int)(signed int)112] = ".--.";
  code[(signed long int)(signed int)113] = "--.-";
  code[(signed long int)(signed int)114] = ".-.";
  code[(signed long int)(signed int)115] = "...";
  code[(signed long int)(signed int)116] = "-";
  code[(signed long int)(signed int)117] = "..-";
  code[(signed long int)(signed int)118] = "...-";
  code[(signed long int)(signed int)119] = ".--";
  code[(signed long int)(signed int)120] = "-..-";
  code[(signed long int)(signed int)121] = "-.--";
  code[(signed long int)(signed int)122] = "--..";
  code[(signed long int)(signed int)49] = ".----";
  code[(signed long int)(signed int)50] = "..---";
  code[(signed long int)(signed int)51] = "...--";
  code[(signed long int)(signed int)52] = "....-";
  code[(signed long int)(signed int)53] = ".....";
  code[(signed long int)(signed int)54] = "-....";
  code[(signed long int)(signed int)55] = "--...";
  code[(signed long int)(signed int)56] = "---..";
  code[(signed long int)(signed int)57] = "----.";
  code[(signed long int)(signed int)48] = "-----";
  code[(signed long int)(signed int)46] = ".-.-.-";
  code[(signed long int)(signed int)44] = "--..--";
  code[(signed long int)(signed int)63] = "..--..";
  code[(signed long int)(signed int)47] = "-..-.";
  code[(signed long int)(signed int)45] = "-....-";
  if(!(allpunctuation == (_Bool)0))
  {
    code[(signed long int)(signed int)41] = "-.--.-";
    code[(signed long int)(signed int)34] = ".-..-.";
    code[(signed long int)(signed int)95] = "..--.-";
    code[(signed long int)(signed int)39] = ".----.";
    code[(signed long int)(signed int)58] = "---...";
    code[(signed long int)(signed int)59] = "-.-.-.";
    code[(signed long int)(signed int)36] = "...-..-";
    code[(signed long int)(signed int)33] = "-.-.--";
    code[(signed long int)(signed int)64] = ".--.-.";
  }

  if(!(allpunctuation == (_Bool)0))
  {
    code[(signed long int)(signed int)43] = ".-.-.";
    code[(signed long int)(signed int)42] = ".-...";
    code[(signed long int)(signed int)61] = "-...-";
    code[(signed long int)(signed int)40] = "-.--.";
    code[(signed long int)(signed int)37] = "...-.-";
  }

  if(!(allprosigns == (_Bool)0))
  {
    code[(signed long int)(signed int)94] = ".-.-";
    code[(signed long int)(signed int)35] = "-...-.-";
    code[(signed long int)(signed int)38] = "-.-.-";
    code[(signed long int)(signed int)126] = "...-.";
  }

  if(!(international == (_Bool)0))
  {
    code[(signed long int)(signed int)(unsigned char)-28] = ".-.-";
    if(!(code[94l] == ((char *)NULL)))
      code[(signed long int)(signed int)94] = (char *)(void *)0;

    code[(signed long int)(signed int)(unsigned char)-32] = ".--.-";
    code[(signed long int)(signed int)(unsigned char)-25] = "----";
    code[(signed long int)(signed int)(unsigned char)-16] = "..--.";
    code[(signed long int)(signed int)(unsigned char)-24] = "..-..";
    code[(signed long int)(signed int)(unsigned char)-15] = "--.--";
    code[(signed long int)(signed int)(unsigned char)-10] = "---.";
    code[(signed long int)(signed int)(unsigned char)-4] = "..--";
    code[(signed long int)(signed int)(unsigned char)-2] = ".--..";
    code[(signed long int)(signed int)(unsigned char)-89] = ".-.-..";
  }

  unsigned long int return_value_strlen_11;
  signed int tmp_statement_expression_12;
  signed int tmp_if_expr_14;
  const signed int **return_value___ctype_tolower_loc_13;
  const signed int **return_value___ctype_tolower_loc_15;
  if(!(user_charset == ((char *)NULL)))
  {
    ii = 0;
    do
    {
      return_value_strlen_11=strlen(user_charset);
      if((unsigned long int)ii >= return_value_strlen_11)
        break;

      signed int __res;
      return_value___ctype_tolower_loc_15=__ctype_tolower_loc();
      __res = (*return_value___ctype_tolower_loc_15)[(signed long int)(signed int)user_charset[(signed long int)ii]];
      tmp_statement_expression_12 = __res;
      user_charset[(signed long int)ii] = (char)tmp_statement_expression_12;
      ii = ii + 1;
    }
    while((_Bool)1);
    ii = 0;
    for( ; !(ii >= 256); ii = ii + 1)
      if(!(code[(signed long int)ii] == ((char *)NULL)))
      {
        char *return_value___builtin_strchr_16;
        return_value___builtin_strchr_16=__builtin_strchr(user_charset, ii);
        if(!(return_value___builtin_strchr_16 == ((char *)NULL)))
          randomfactor[(signed long int)ii] = 7 - 1;

        else
        {
          code[(signed long int)ii] = (char *)(void *)0;
          randomfactor[(signed long int)ii] = 0;
        }
      }

  }

  ii = 0;
  for( ; !(ii >= 256); ii = ii + 1)
  {
    randomripe[(signed long int)ii] = 0;
    errorlog[(signed long int)ii] = 0;
    if(code[(signed long int)ii] == ((char *)NULL))
      randomfactor[(signed long int)ii] = 0;

    else
    {
      unsigned long int return_value_strlen_17;
      return_value_strlen_17=strlen(code[(signed long int)ii]);
      randomfactor[(signed long int)ii] = (signed int)((unsigned long int)7 - return_value_strlen_17);
      if(!(randomfactor[(signed long int)ii] >= 1))
        randomfactor[(signed long int)ii] = 1;

    }
  }
  words_per_minute = (float)20.0;
  fwords_per_minute = (float)-1.;
  time(&starttime);
  handler.__sigaction_handler.sa_handler = (void (*)(signed int))die;
  sigemptyset(&handler.sa_mask);
  handler.sa_flags = 0;
  sigaction(2, &handler, (struct sigaction *)(void *)0);
  sigaction(15, &handler, (struct sigaction *)(void *)0);
  sigaction(3, &handler, (struct sigaction *)(void *)0);
  handler.__sigaction_handler.sa_handler = (void (*)(signed int))suspend;
  sigaction(20, &handler, (struct sigaction *)(void *)0);
  if(!(testing == (_Bool)0) || !(typeaway == (_Bool)0))
    openterminal();

  tone(frequency, (float)0.25, (float)0);
  toneflush();
  signed long int return_value_time_19;
  double return_value_difftime_20;
  if(!(typeaway == (_Bool)0))
  {
    _Bool notdoneyet;
    testing = (_Bool)0;
    showtesting = (_Bool)0;
    charbychar = (_Bool)0;
    wordsbefore = (_Bool)0;
    wordsafter = (_Bool)0;
    randomletters = (_Bool)0;
    notdoneyet = (_Bool)1;
    while(!(notdoneyet == (_Bool)0))
    {
      signed int jj;
      pollyou();
      jj = 0;
      for( ; !(jj >= yourlength); jj = jj + 1)
      {
        signed int yourchar = (signed int)yourstring[(signed long int)(((yourpointer - yourlength) + 1 + jj + (20 + 1) * 10) % ((20 + 1) * 10))];
        if(yourchar == 4)
        {
          toneflush();
          notdoneyet = (_Bool)0;
          break;
        }

        const unsigned short int **return_value___ctype_b_loc_18;
        return_value___ctype_b_loc_18=__ctype_b_loc();
        if(!((8192 & (signed int)(*return_value___ctype_b_loc_18)[(signed long int)yourchar]) == 0))
        {
          if(!(showletters == (_Bool)0))
          {
            toneflush();
            printf("%c", yourchar);
            fflush(stdout);
          }

          tone(frequency, inter_word_time, (float)0.);
        }

        else
          morse(yourchar);
      }
      yourlength = yourlength - jj;
      if(timeout >= 1)
      {
        return_value_time_19=time((signed long int *)(void *)0);
        return_value_difftime_20=difftime(return_value_time_19, starttime);
        if(return_value_difftime_20 > (double)timeout)
          break;

      }

    }
  }

  else
    if(!(randomletters == (_Bool)0))
    {
      float randexp;
      float randnum;
      signed long int return_value_time_21;
      return_value_time_21=time((signed long int *)(void *)0);
      srand48(return_value_time_21);
      randexp = (float)(1. / (1. - 1. / (double)(float)3.5));
      while((_Bool)1)
      {
        if(timeout == 0 || wordcount == 0)
          break;

        signed int return_value_randomletter_22;
        return_value_randomletter_22=randomletter();
        dowords(return_value_randomletter_22);
        if(wordlen == 20)
        {
          signed long int return_value_lrand48_23;
          return_value_lrand48_23=lrand48();
          signed long int return_value_time_24;
          return_value_time_24=time((signed long int *)(void *)0);
          randnum = (float)((return_value_lrand48_23 >> 9) + (signed long int)return_value_time_24 >> 4 & (signed long int)0x00FFFFFF);
          randnum = randnum - randexp * (float)(signed int)(randnum / randexp);
          if(randnum >= 1.000000f && !(linepos == 0))
            dowords((signed int)32);

        }

      }
    }

    else
      if(!(*argv == ((char *)NULL)))
      {
        _Bool firsttime = (_Bool)1;
        while((_Bool)1)
        {
          if(firsttime == (_Bool)0)
            dowords((signed int)32);

          else
            firsttime = (_Bool)0;
          if(timeout == 0 || wordcount == 0)
            break;

          p = *argv;
          for( ; !(*p == 0); p = p + 1l)
          {
            dowords((signed int)*p);
            if(timeout == 0 || wordcount == 0)
              break;

          }
          if(timeout == 0 || wordcount == 0)
            break;

          argv = argv + 1l;
          if(*argv == ((char *)NULL))
            break;

        }
      }

      else
        do
        {
          ch=getchar();
          if(ch == -1)
            break;

          dowords(ch);
          if(timeout == 0 || wordcount == 0)
            break;

        }
        while((_Bool)1);
  if(!(fancyending == (_Bool)0))
    dowords(-1);

  else
    dowords(-2);
  fflush(stdout);
  if(!(testing == (_Bool)0))
    while(testlength >= 1)
    {
      tone(frequency, catchup_time, (float)0.);
      toneflush();
      testterminal();
    }

  toneflush();
  if(!(showletters == (_Bool)0) || !(showmorse == (_Bool)0) || !(showtesting == (_Bool)0) || !(wordsafter == (_Bool)0) || !(wordsbefore == (_Bool)0))
    printf("\n");

  fflush(stdout);
  if(!(testing == (_Bool)0))
    report();

  cleanup();
  return (signed int)(totalmisscount > 0);
}

// morse
// file morse.c line 1234
static void morse(signed int c)
{
  const unsigned short int **return_value___ctype_b_loc_1;
  return_value___ctype_b_loc_1=__ctype_b_loc();
  _Bool tmp_if_expr_6;
  signed int tmp_statement_expression_2;
  signed int tmp_if_expr_4;
  const signed int **return_value___ctype_tolower_loc_3;
  const signed int **return_value___ctype_tolower_loc_5;
  if(!((1024 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)c]) == 0))
  {
    signed int __res;
    __res=tolower(c);
    tmp_statement_expression_2 = __res;
    tmp_if_expr_6 = code[(signed long int)tmp_statement_expression_2] == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_6 = (_Bool)0;
  _Bool tmp_if_expr_7;
  if(tmp_if_expr_6)
    tmp_if_expr_7 = (_Bool)1;

  else
    tmp_if_expr_7 = (code[(signed long int)(signed int)37] == (char *)(void *)0 ? (c == -1 || c == 4 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_7)
    c = 32;

  _Bool tmp_if_expr_8;
  if(!(showletters == (_Bool)0))
  {
    if(c == 4 || c == -1)
    {
      if(!(showmorse == (_Bool)0))
        printf("<SK>");

      else
        printf("%%");
    }

    else
      if(c == 46 && !(showmorse == (_Bool)0))
        printf("<DOT>");

      else
        if(c == 45 && !(showmorse == (_Bool)0))
          printf("<DASH>");

        else
          if(c == 43 && !(showmorse == (_Bool)0))
            printf("<AR>");

          else
            if(c == 42 && !(showmorse == (_Bool)0))
              printf("<AS>");

            else
              if(c == 61 && !(showmorse == (_Bool)0))
                printf("<BT>");

              else
                if(c == 40 && !(showmorse == (_Bool)0))
                  printf("<KN>");

                else
                  if(c == 37 && !(showmorse == (_Bool)0))
                    printf("<SK>");

                  else
                    if(!(allprosigns == (_Bool)0))
                    {
                      if(c == 94)
                        tmp_if_expr_8 = code[(signed long int)(signed int)94] != (char *)(void *)0 ? (_Bool)1 : (_Bool)0;

                      else
                        tmp_if_expr_8 = (_Bool)0;
                      if(!(showmorse == (_Bool)0) && tmp_if_expr_8)
                        printf("<AA>");

                      else
                        if(c == 35 && !(showmorse == (_Bool)0))
                          printf("<BK>");

                        else
                          if(c == 38 && !(showmorse == (_Bool)0))
                            printf("<KA>");

                          else
                            if(c == 126 && !(showmorse == (_Bool)0))
                              printf("<SN>");

                    }

                    else
                      printf("%c", c);
    fflush(stdout);
  }

  const unsigned short int **return_value___ctype_b_loc_11;
  return_value___ctype_b_loc_11=__ctype_b_loc();
  const unsigned short int **return_value___ctype_b_loc_9;
  if(!((1024 & (signed int)(*return_value___ctype_b_loc_11)[(signed long int)c]) == 0))
  {
    if(!(testing == (_Bool)0))
    {
      return_value___ctype_b_loc_9=__ctype_b_loc();
      testaddchar((char)((c - (((signed int)(*return_value___ctype_b_loc_9)[(signed long int)(signed int)c] & (signed int)(unsigned short int)256) != 0 ? 65 : 97)) + 97));
    }

    const unsigned short int **return_value___ctype_b_loc_10;
    return_value___ctype_b_loc_10=__ctype_b_loc();
    show(code[(signed long int)((c - (((signed int)(*return_value___ctype_b_loc_10)[(signed long int)(signed int)c] & (signed int)(unsigned short int)256) != 0 ? 65 : 97)) + 97)]);
  }

  else
    if(c == 4 || c == -1)
      show(code[(signed long int)(signed int)37]);

    else
      if(!(code[(signed long int)c] == ((char *)NULL)))
      {
        if(!(testing == (_Bool)0))
          testaddchar((char)c);

        show(code[(signed long int)c]);
      }

      else
      {
        if(!(noticebad == (_Bool)0))
        {
          if(!(showletters == (_Bool)0))
            fflush(stdout);

          tone(frequency, (float)(2. * (double)inter_word_time), (float)0.);
          toneflush();
        }

        if(!(showletters == (_Bool)0))
        {
          fflush(stdout);
          printf("\b");
          printf(" ");
          printf("\b");
          fflush(stdout);
        }

        if(!(noticebad == (_Bool)0))
        {
          if(!(showletters == (_Bool)0))
          {
            printf("<UNKNOWN_CHARACTER>");
            fflush(stdout);
          }

          show("........");
          tone(frequency, inter_word_time, (float)0.);
        }

      }
  if(!(showmorse == (_Bool)0))
    printf(" ");

  fflush(stdout);
  toneflush();
  tone(frequency, inter_char_time - intra_char_time, (float)0.);
}

// new_words_per_minute
// file morse.c line 803
static void new_words_per_minute(void)
{
  float wtick;
  float ftick;
  float tick = (float)(60. / (double)(words_per_minute * (float)50));
  if(fwords_per_minute <= words_per_minute)
    ftick = (float)(60. / (double)(words_per_minute * (float)50));

  else
    ftick = (float)(60. / (double)(fwords_per_minute * (float)50));
  wtick = (float)((50. * (double)tick - 31. * (double)ftick) / 19.);
  catchup_time = tick;
  inter_char_time = (float)((double)wtick * 3.);
  inter_word_time = (float)((double)wtick * 7.);
  intra_char_time = ftick;
  dot_time = ftick;
  dash_time = (float)((double)ftick * 3.);
}

// openterminal
// file morse.c line 1742
static void openterminal(void)
{
  termfd=open(terminal, 02 | 04000, 0);
  tcgetattr(termfd, &termgtty);
  oldtermgtty = termgtty;
  if(!((signed int)typeaway == 2))
    termgtty.c_lflag = termgtty.c_lflag & (unsigned int)~(0000010 | 0000020 | 0000040 | 0000100);

  termgtty.c_lflag = termgtty.c_lflag & (unsigned int)~0000002;
  termgtty.c_cc[(signed long int)6] = (unsigned char)1;
  termgtty.c_cc[(signed long int)5] = (unsigned char)0;
  tcsetattr(termfd, 1, &termgtty);
  termopen = 1;
}

// play_tone
// file beepPA.c line 47
static void play_tone()
{
  signed int len = (signed int)((double)(sample_format.rate * (unsigned int)beep_info.time) / 1000.0);
  signed short int *sample;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)len * sizeof(signed short int) /*2ul*/ );
  sample = (signed short int *)return_value_malloc_1;
  if(!(sample == ((signed short int *)NULL)))
  {
    if(beep_info.volume == 0)
      memset((void *)sample, 0, (unsigned long int)len * sizeof(signed short int) /*2ul*/ );

    else
    {
      double t;
      double tt;
      signed int c;
      double v;
      tt = (double)beep_info.time / 1000.0;
      c = 0;
      for( ; !(c >= len); c = c + 2)
      {
        t = (double)c / (double)sample_format.rate;
        double return_value_sin_2;
        return_value_sin_2=sin(3.14159265358979323846 * (double)2 * t * (double)beep_info.pitch);
        v = ((double)beep_info.volume / 100.0) * return_value_sin_2;
        if(t < 0.01)
          v = v * (t / 0.01);

        if(tt + -t < 0.005)
          v = v * ((tt - t) / 0.005);

        sample[(signed long int)(c + 1)] = (signed short int)(signed int)(v * 32768.0);
        sample[(signed long int)c] = sample[(signed long int)(c + 1)];
      }
    }
    signed int return_value_pa_simple_write_3;
    return_value_pa_simple_write_3=pa_simple_write(snddev, (const void *)(unsigned char *)sample, (unsigned long int)len * sizeof(signed short int) /*2ul*/ , (signed int *)(void *)0);
    if(!(return_value_pa_simple_write_3 >= 0))
    {
      fprintf(stderr, "pa_simple_Write failed\n");
      exit(1);
    }

    free((void *)sample);
  }

}

// pollyou
// file morse.c line 1435
static void pollyou(void)
{
  signed int ii;
  signed int num;
  char *string;
  num=readterminal(&string);
  ii = 0;
  for( ; !(ii >= num); ii = ii + 1)
    youraddchar(string[(signed long int)ii]);
}

// rancomp
// file morse.c line 1881
static signed int rancomp(const void *elem1, const void *elem2)
{
  signed int *e1 = (signed int *)elem1;
  signed int *e2 = (signed int *)elem2;
  float a;
  float b;
  a = (float)randomfactor[(signed long int)*e1] + (float)randomripe[(signed long int)*e1] / (float)64;
  b = (float)randomfactor[(signed long int)*e2] + (float)randomripe[(signed long int)*e2] / (float)64;
  if(IEEE_FLOAT_EQUAL(a, b))
    return 0;

  else
    if(a > b)
      return -1;

    else
      return 1;
}

// randomletter
// file morse.c line 1820
static signed int randomletter(void)
{
  signed int ii;
  signed int sum;
  signed int sum2;
  signed long int ranspot;
  signed long int return_value_time_1;
  return_value_time_1=time((signed long int *)(void *)0);
  static signed long int norepeat;
  norepeat = ((signed long int)return_value_time_1 / (signed long int)31) % (signed long int)17291;
  ii = 0;
  for( ; !(ii >= 256); ii = ii + 1)
    if(randomfactor[(signed long int)ii] >= 1)
      randomripe[(signed long int)ii] = randomripe[(signed long int)ii] + 1;

  sum = 0;
  ii = 0;
  for( ; !(ii >= 256); ii = ii + 1)
    sum = sum + randomfactor[(signed long int)ii] + (signed int)(randomripe[(signed long int)ii] / 64);
  static signed int lasttime = -1;
  do
  {
    signed long int return_value_lrand48_2;
    return_value_lrand48_2=lrand48();
    ranspot = ((return_value_lrand48_2 >> 4) % (signed long int)sum + norepeat) % (signed long int)sum;
    sum2 = 0;
    ii = 0;
    for( ; !(ii >= 256); ii = ii + 1)
    {
      sum2 = sum2 + randomfactor[(signed long int)ii] + (signed int)(randomripe[(signed long int)ii] / 64);
      if(!(ranspot >= (signed long int)sum2))
        break;

    }
  }
  while(ii == lasttime);
  randomripe[(signed long int)ii] = 0;
  lasttime = ii;
  return ii;
}

// readterminal
// file morse.c line 1759
static signed int readterminal(char **string)
{
  signed int n;
  signed long int return_value_read_1;
  static char line[210l];
  return_value_read_1=read(termfd, (void *)line, sizeof(char [210l]) /*210ul*/  - (unsigned long int)1);
  n = (signed int)return_value_read_1;
  if(n >= 1)
  {
    line[(signed long int)n] = (char)0;
    *string = line;
  }

  else
    *string = (char *)(void *)0;
  return n;
}

// report
// file morse.c line 1900
static void report(void)
{
  signed int randomstr[256l];
  printf("\nCurrent words per minute: %.1f\n", words_per_minute);
  printf("Total hits %d, misses %d", totalhitcount, totalmisscount);
  if(totalmisscount >= 1)
    printf(", hit per miss ratio %.1f\n", (float)totalhitcount / (float)totalmisscount);

  else
    printf("\n");
  if(!(randomletters == (_Bool)0))
  {
    signed int ii;
    signed int jj;
    signed int count;
    float sum;
    printf("Most to least frequent choices:\n");
    count = 0;
    sum = (float)0.;
    ii = 0;
    for( ; !(ii >= 256); ii = ii + 1)
      if(randomfactor[(signed long int)ii] >= 1)
      {
        sum = sum + (float)randomfactor[(signed long int)ii] + (float)randomripe[(signed long int)ii] / (float)64;
        randomstr[(signed long int)count] = ii;
        count = count + 1;
      }

    qsort((void *)(char *)randomstr, (unsigned long int)count, sizeof(signed int) /*4ul*/ , rancomp);
    ii = 0;
    for( ; !(ii >= count); ii = ii + 1)
    {
      if(ii >= 1)
      {
        jj = 0;
        for( ; !(jj >= (signed int)((((float)randomfactor[(signed long int)randomstr[(signed long int)(ii + -1)]] + (float)randomripe[(signed long int)randomstr[(signed long int)(ii + -1)]] / 64.000000f) * (float)count) / sum) + -((signed int)((((float)randomfactor[(signed long int)randomstr[(signed long int)ii]] + (float)randomripe[(signed long int)randomstr[(signed long int)ii]] / 64.000000f) * (float)count) / sum))); jj = jj + 1)
          printf(" ");
      }

      printf("%c", (char)randomstr[(signed long int)ii]);
    }
    printf("\n");
  }

  if(!(charbychar == (_Bool)0))
    slowpoke = 50 * 10 + 1;

  fflush(stdout);
}

// show
// file morse.c line 1351
static void show(char *s)
{
  char c;
  char *tmp_post_1;
  do
  {
    tmp_post_1 = s;
    s = s + 1l;
    c = *tmp_post_1;
    if((signed int)c == 0)
      break;

    tone(frequency, intra_char_time, (float)0.);
    switch((signed int)c)
    {
      case 46:
      {
        tone(frequency, dot_time, volume);
        break;
      }
      case 45:
        tone(frequency, dash_time, volume);
    }
    if(!(showmorse == (_Bool)0))
    {
      printf("%c", c);
      fflush(stdout);
    }

  }
  while((_Bool)1);
}

// suspend
// file morse.c line 1801
static void suspend(signed int sig)
{
  struct sigaction handler;
  sigemptyset(&handler.sa_mask);
  handler.sa_flags = 0;
  handler.__sigaction_handler.sa_handler = suspend;
  sigaction(20, &handler, (struct sigaction *)(void *)0);
  cleanup();
  signed int return_value_getpid_1;
  return_value_getpid_1=getpid();
  kill(return_value_getpid_1, 19);
  if(!(termopen == 0))
    openterminal();

  BeepResume();
}

// testaddchar
// file morse.c line 1391
static void testaddchar(char c)
{
  testpointer = (testpointer + 1) % ((20 + 1) * 10);
  teststring[(signed long int)testpointer] = c;
  testlength = testlength + 1;
  if(testlength >= 211)
  {
    fprintf(stderr, "\n\nInput buffer queue overflow! Make TESTBUFSZ bigger!\n");
    fprintf(stderr, "(Or don't fall so far behind)\n");
    die();
  }

  const unsigned short int **return_value___ctype_b_loc_1;
  return_value___ctype_b_loc_1=__ctype_b_loc();
  if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)c]) == 0)
    behindness = behindness + 1;

}

// testterminal
// file morse.c line 1447
static signed int testterminal(void)
{
  signed int errorcount;
  signed int resync;
  errorcount = 0;
  _Bool tmp_if_expr_2;
  const unsigned short int **return_value___ctype_b_loc_3;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_8;
  if(testlength == 0)
    return errorcount;

  else
  {
    pollyou();
    if(testlength >= 1 && yourlength >= 1)
    {
      signed int testinc;
      signed int yourinc;
      testinc = 0;
      yourinc = 0;
      for( ; !(testinc >= testlength) && !(yourinc >= yourlength); yourinc = yourinc + 1)
      {
        signed int correctchar;
        signed int yourchar;
        signed int yourcharnocase;
        correctchar = (signed int)teststring[(signed long int)(((testpointer - testlength) + 1 + testinc + (20 + 1) * 10) % ((20 + 1) * 10))];
        const unsigned short int **return_value___ctype_b_loc_1;
        return_value___ctype_b_loc_1=__ctype_b_loc();
        if(!((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)correctchar]) == 0))
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = code[(signed long int)correctchar] == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
        {
          if(!(showtesting == (_Bool)0))
          {
            printf("%c", correctchar);
            fflush(stdout);
          }

          behindness = behindness + 1;
          yourinc = yourinc - 1;
        }

        else
        {
          yourchar = (signed int)yourstring[(signed long int)(((yourpointer - yourlength) + 1 + yourinc + (20 + 1) * 10) % ((20 + 1) * 10))];
          const unsigned short int **return_value___ctype_b_loc_4;
          return_value___ctype_b_loc_4=__ctype_b_loc();
          if(!((1024 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)yourchar]) == 0))
          {
            return_value___ctype_b_loc_3=__ctype_b_loc();
            yourcharnocase = (yourchar - (((signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)yourchar] & (signed int)(unsigned short int)256) != 0 ? 65 : 97)) + 97;
          }

          else
            yourcharnocase = yourchar;
          const unsigned short int **return_value___ctype_b_loc_5;
          return_value___ctype_b_loc_5=__ctype_b_loc();
          if(!((8192 & (signed int)(*return_value___ctype_b_loc_5)[(signed long int)yourchar]) == 0))
            tmp_if_expr_6 = (_Bool)1;

          else
            tmp_if_expr_6 = code[(signed long int)yourcharnocase] == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_6)
          {
            if(yourchar == 4 || yourchar == 27)
            {
              report();
              if(yourchar == 4)
                die();

            }

            else
              if(yourchar == 8)
                helpmeflag = (_Bool)1;

            testinc = testinc - 1;
          }

          else
          {
            if(keepquiet >= 2)
            {
              resync = testinc;
              for( ; !(resync >= testlength); resync = resync + 1)
                if(yourcharnocase == (signed int)teststring[(signed long int)((1 + testpointer + resync + -testlength) % 10)])
                {
                  for( ; !(testinc >= resync); testinc = testinc + 1)
                  {
                    correctchar = (signed int)teststring[(signed long int)(((testpointer - testlength) + 1 + testinc + (20 + 1) * 10) % ((20 + 1) * 10))];
                    const unsigned short int **return_value___ctype_b_loc_7;
                    return_value___ctype_b_loc_7=__ctype_b_loc();
                    if(!((8192 & (signed int)(*return_value___ctype_b_loc_7)[(signed long int)correctchar]) == 0))
                      tmp_if_expr_8 = (_Bool)1;

                    else
                      tmp_if_expr_8 = code[(signed long int)correctchar] == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
                    if(tmp_if_expr_8)
                    {
                      if(!(showtesting == (_Bool)0))
                        printf("%c", correctchar);

                    }

                    else
                      printf("%s%c%s", enter_standout_mode, correctchar, exit_standout_mode);
                  }
                  fflush(stdout);
                  correctchar = (signed int)teststring[(signed long int)(((testpointer - testlength) + 1 + testinc + (20 + 1) * 10) % ((20 + 1) * 10))];
                  keepquiet = 1;
                  break;
                }

            }

            if(!(yourcharnocase == correctchar))
            {
              errorcount = errorcount + 1;
              totalmisscount = totalmisscount + 1;
              errorlog[(signed long int)correctchar] = errorlog[(signed long int)correctchar] + 1;
              if(!(code[(signed long int)yourcharnocase] == ((char *)NULL)))
              {
                if(!(errorlog[(signed long int)yourcharnocase] >= 1000))
                  errorlog[(signed long int)yourcharnocase] = errorlog[(signed long int)yourcharnocase] + 1;

              }

              if(keepquiet >= 1)
              {
                printf("%s%c%s", enter_standout_mode, correctchar, exit_standout_mode);
                fflush(stdout);
                keepquiet = keepquiet + 1;
              }

              else
              {
                printf("\n");
                if(IEEE_FLOAT_NOTEQUAL(error_volume, 0.000000f))
                {
                  toneflush();
                  tone(error_frequency, (float)0.1, error_volume);
                }

                else
                  printf("\a");
                printf("%c (%s) for %c (%s)\n", yourchar, code[(signed long int)yourcharnocase], correctchar, code[(signed long int)correctchar]);
                fflush(stdout);
                linepos = 0;
              }
              if(!(charbychar == (_Bool)0))
              {
                tone(frequency, inter_word_time, (float)0.);
                toneflush();
              }

              if(charbychar == (_Bool)0 && !(dynamicspeed == (_Bool)0))
              {
                words_per_minute = words_per_minute / (float)1.04;
                new_words_per_minute();
              }

              if(tryingagain == 0 && !(randomletters == (_Bool)0))
              {
                if(!(code[(signed long int)yourcharnocase] == ((char *)NULL)))
                {
                  randomfactor[(signed long int)yourcharnocase] = randomfactor[(signed long int)yourcharnocase] + (3 * 6) / 2;
                  if(randomfactor[(signed long int)yourcharnocase] >= 211)
                    randomfactor[(signed long int)yourcharnocase] = 30 * 7;

                }

                randomfactor[(signed long int)correctchar] = randomfactor[(signed long int)correctchar] + 6 * 2;
                if(randomfactor[(signed long int)correctchar] >= 211)
                  randomfactor[(signed long int)correctchar] = 30 * 7;

              }

            }

            else
            {
              if(tryingagain == 0)
              {
                totalhitcount = totalhitcount + 1;
                if(!(error_floor >= errorlog[(signed long int)correctchar]))
                  errorlog[(signed long int)correctchar] = errorlog[(signed long int)correctchar] - 1;

              }

              if(!(showtesting == (_Bool)0))
              {
                printf("%c", yourchar);
                fflush(stdout);
              }

              if(tryingagain == 0 && !(randomletters == (_Bool)0))
              {
                if(slowpoke == 10)
                {
                  printf("\nNice to have you back again, I was getting bored!\n");
                  linepos = 0;
                }

                else
                  if(slowpoke >= 3)
                  {
                    randomfactor[(signed long int)correctchar] = randomfactor[(signed long int)correctchar] + (3 * 6) / 2;
                    if(randomfactor[(signed long int)correctchar] >= 211)
                      randomfactor[(signed long int)correctchar] = 30 * 7;

                    totalhitcount = totalhitcount - 1;
                  }

                  else
                    if(slowpoke >= 5)
                    {
                      randomfactor[(signed long int)correctchar] = randomfactor[(signed long int)correctchar] + (slowpoke * 6) / (2 * 10);
                      if(randomfactor[(signed long int)correctchar] >= 211)
                        randomfactor[(signed long int)correctchar] = 30 * 7;

                    }

                    else
                      if(!(slowpoke >= 3))
                      {
                        randomfactor[(signed long int)correctchar] = randomfactor[(signed long int)correctchar] - (3 * 7) / 2;
                        if(!(randomfactor[(signed long int)correctchar] >= 1))
                          randomfactor[(signed long int)correctchar] = 1;

                      }

                      else
                        if(!(slowpoke >= 5))
                        {
                          randomfactor[(signed long int)correctchar] = randomfactor[(signed long int)correctchar] - 7 / 2;
                          if(!(randomfactor[(signed long int)correctchar] >= 1))
                            randomfactor[(signed long int)correctchar] = 1;

                        }

              }

            }
          }
        }
        testinc = testinc + 1;
      }
      testlength = testlength - testinc;
      behindness = behindness - testinc;
      yourlength = yourlength - yourinc;
    }

    return errorcount;
  }
}

// tolower
// file /usr/include/ctype.h line 215
static inline signed int tolower(signed int __c)
{
  signed int tmp_if_expr_2;
  const signed int **return_value___ctype_tolower_loc_1;
  if(__c >= -128 && !(__c >= 256))
  {
    return_value___ctype_tolower_loc_1=__ctype_tolower_loc();
    tmp_if_expr_2 = (*return_value___ctype_tolower_loc_1)[(signed long int)__c];
  }

  else
    tmp_if_expr_2 = __c;
  return tmp_if_expr_2;
}

// tone
// file morse.c line 1716
static void tone(float hertz, float duration, float amplitude)
{
  Beep((signed int)(duration * (float)1000), (signed int)(amplitude * (float)100), (signed int)hertz);
}

// toneflush
// file morse.c line 1723
static void toneflush(void)
{
  BeepWait();
}

// youraddchar
// file morse.c line 1417
static void youraddchar(char c)
{
  yourpointer = (yourpointer + 1) % ((20 + 1) * 10);
  yourstring[(signed long int)yourpointer] = c;
  yourlength = yourlength + 1;
  if(yourlength >= 211)
  {
    fprintf(stderr, "\n\nKeyboard typeahead buffer queue overflow! Make TESTBUFSZ bigger!\n");
    fprintf(stderr, "(Or don't type so far ahead... how did you expect to get them right anyway?)\n");
    die();
  }

}

