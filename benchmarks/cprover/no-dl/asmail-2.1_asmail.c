// tag-#anon#ST[*{S8}$S8$'chars'||S32'nchars'||S32'delta'||U64'font'|]
// file /usr/include/X11/Xlib.h line 1057
struct anonymous$14;

// tag-#anon#ST[*{S8}$S8$'name'||*{S8}$S8$'value'||U64'pixel'|]
// file /usr/include/X11/xpm.h line 100
struct anonymous$0;

// tag-#anon#ST[*{S8}$S8$'name'||U32'nlines'||U32'$pad0'||*{*{S8}$S8$}$*{S8}$S8$$'lines'|]
// file /usr/include/X11/xpm.h line 106
struct anonymous$2;

// tag-#anon#ST[*{S8}$S8$'res_name'||*{S8}$S8$'res_class'|]
// file /usr/include/X11/Xutil.h line 189
struct anonymous$57;

// tag-#anon#ST[*{S8}$S8$'string'||*{S8}$S8$'symbolic'||*{S8}$S8$'m_color'||*{S8}$S8$'g4_color'||*{S8}$S8$'g_color'||*{S8}$S8$'c_color'|]
// file /usr/include/X11/xpm.h line 112
struct anonymous$3;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]
// file /usr/include/X11/Xlib.h line 257
struct anonymous$9;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private1'||S32'fd'||S32'private2'||S32'proto_major_version'||S32'proto_minor_version'||*{S8}$S8$'vendor'||U64'private3'||U64'private4'||U64'private5'||S32'private6'||U32'$pad0'||*{U64(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->U64}$U64(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->U64$'resource_alloc'||S32'byte_order'||S32'bitmap_unit'||S32'bitmap_pad'||S32'bitmap_bit_order'||S32'nformats'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]#$'pixmap_format'||S32'private8'||S32'release'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private9'||*{SYM#tag-_XPrivate#}$SYM#tag-_XPrivate#$'private10'||S32'qlen'||U32'$pad2'||U64'last_request_read'||U64'request'||*{S8}$S8$'private11'||*{S8}$S8$'private12'||*{S8}$S8$'private13'||*{S8}$S8$'private14'||U32'max_request_size'||U32'$pad3'||*{SYM#tag-_XrmHashBucketRec#}$SYM#tag-_XrmHashBucketRec#$'db'||*{S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->S32}$S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$)->S32$'private15'||*{S8}$S8$'display_name'||S32'default_screen'||S32'nscreens'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#$'screens'||U64'motion_buffer'||U64'private16'||S32'min_keycode'||S32'max_keycode'||*{S8}$S8$'private17'||*{S8}$S8$'private18'||S32'private19'||U32'$pad4'||*{S8}$S8$'xdefaults'|]
// file /usr/include/X11/Xlib.h line 493
struct anonymous$55;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||S32'depth'||S32'bits_per_pixel'||S32'scanline_pad'||U32'$pad0'|]
// file /usr/include/X11/Xlib.h line 280
struct anonymous$15;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'fid'||U32'direction'||U32'min_char_or_byte2'||U32'max_char_or_byte2'||U32'min_byte1'||U32'max_byte1'||S32'all_chars_exist'||U32'default_char'||S32'n_properties'||*{SYM#tag-#anon#ST[U64'name'||U64'card32'|]#}$SYM#tag-#anon#ST[U64'name'||U64'card32'|]#$'properties'||SYM#tag-#anon#ST[S16'lbearing'||S16'rbearing'||S16'width'||S16'ascent'||S16'descent'||U16'attributes'|]#'min_bounds'||SYM#tag-#anon#ST[S16'lbearing'||S16'rbearing'||S16'width'||S16'ascent'||S16'descent'||U16'attributes'|]#'max_bounds'||*{SYM#tag-#anon#ST[S16'lbearing'||S16'rbearing'||S16'width'||S16'ascent'||S16'descent'||U16'attributes'|]#}$SYM#tag-#anon#ST[S16'lbearing'||S16'rbearing'||S16'width'||S16'ascent'||S16'descent'||U16'attributes'|]#$'per_char'||S32'ascent'||S32'descent'|]
// file /usr/include/X11/Xlib.h line 1035
struct anonymous$21;

// tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]
// file /usr/include/X11/Xlib.h line 227
struct anonymous$4;

// tag-#anon#ST[*{U8}$U8$'value'||U64'encoding'||S32'format'||U32'$pad0'||U64'nitems'|]
// file /usr/include/X11/Xutil.h line 163
struct anonymous$59;

// tag-#anon#ST[ARR16{S64}$S64$'__fds_bits'|]
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous$1;

// tag-#anon#ST[ARR4{U32}$U32$'state'||ARR2{U32}$U32$'count'||ARR64{U8}$U8$'buffer'|]
// file md5.h line 52
struct anonymous$17;

// tag-#anon#ST[S16'lbearing'||S16'rbearing'||S16'width'||S16'ascent'||S16'descent'||U16'attributes'|]
// file /usr/include/X11/Xlib.h line 1017
struct anonymous$19;

// tag-#anon#ST[S16'x'||S16'y'|]
// file /usr/include/X11/Xlib.h line 426
struct anonymous$12;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$56;

// tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]
// file /usr/include/X11/Xlib.h line 243
struct anonymous$11;

// tag-#anon#ST[S32'function'||U32'$pad0'||U64'plane_mask'||U64'foreground'||U64'background'||S32'line_width'||S32'line_style'||S32'cap_style'||S32'join_style'||S32'fill_style'||S32'fill_rule'||S32'arc_mode'||U32'$pad1'||U64'tile'||U64'stipple'||S32'ts_x_origin'||S32'ts_y_origin'||U64'font'||S32'subwindow_mode'||S32'graphics_exposures'||S32'clip_x_origin'||S32'clip_y_origin'||U64'clip_mask'||S32'dash_offset'||S8'dashes'||U24'$pad2'|]
// file /usr/include/X11/Xlib.h line 181
struct anonymous;

// tag-#anon#ST[S32'type'||U32'$pad0'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'resourceid'||U64'serial'||U8'error_code'||U8'request_code'||U8'minor_code'||U40'$pad1'|]
// file /usr/include/X11/Xlib.h line 924
struct anonymous$51;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||S32'extension'||S32'evtype'|]
// file /usr/include/X11/Xlib.h line 948
struct anonymous$53;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||S32'extension'||S32'evtype'||U32'cookie'||U32'$pad2'||*{V}$V$'data'|]
// file /usr/include/X11/Xlib.h line 958
struct anonymous$54;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'drawable'||S32'major_code'||S32'minor_code'|]
// file /usr/include/X11/Xlib.h line 686
struct anonymous$30;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'drawable'||S32'x'||S32'y'||S32'width'||S32'height'||S32'count'||S32'major_code'||S32'minor_code'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 673
struct anonymous$29;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'|]
// file /usr/include/X11/Xlib.h line 718
struct anonymous$33;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'from_configure'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 727
struct anonymous$34;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'override_redirect'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 737
struct anonymous$35;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'place'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 816
struct anonymous$42;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'x'||S32'y'|]
// file /usr/include/X11/Xlib.h line 782
struct anonymous$39;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||U32'$pad2'||U64'above'||S32'override_redirect'||U32'$pad3'|]
// file /usr/include/X11/Xlib.h line 768
struct anonymous$38;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'event'||U64'window'||U64'parent'||S32'x'||S32'y'||S32'override_redirect'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 756
struct anonymous$37;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'owner'||U64'requestor'||U64'selection'||U64'target'||U64'property'||U64'time'|]
// file /usr/include/X11/Xlib.h line 857
struct anonymous$46;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'|]
// file /usr/include/X11/Xlib.h line 747
struct anonymous$36;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'||S32'place'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 826
struct anonymous$43;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||S32'override_redirect'|]
// file /usr/include/X11/Xlib.h line 705
struct anonymous$32;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'parent'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||U32'$pad2'||U64'above'||S32'detail'||U32'$pad3'||U64'value_mask'|]
// file /usr/include/X11/Xlib.h line 801
struct anonymous$41;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'requestor'||U64'selection'||U64'target'||U64'property'||U64'time'|]
// file /usr/include/X11/Xlib.h line 870
struct anonymous$47;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'|]
// file /usr/include/X11/Xlib.h line 934
struct anonymous$22;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||ARR32{S8}$S8$'key_vector'|]
// file /usr/include/X11/Xlib.h line 653
struct anonymous$52;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'mode'||S32'detail'|]
// file /usr/include/X11/Xlib.h line 634
struct anonymous$27;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'request'||S32'first_keycode'||S32'count'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 912
struct anonymous$50;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'state'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 696
struct anonymous$31;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'width'||S32'height'|]
// file /usr/include/X11/Xlib.h line 792
struct anonymous$40;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||S32'x'||S32'y'||S32'width'||S32'height'||S32'count'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 662
struct anonymous$28;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'atom'||U64'time'||S32'state'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 836
struct anonymous$44;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'colormap'||S32'new'||S32'state'|]
// file /usr/include/X11/Xlib.h line 882
struct anonymous$48;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'message_type'||S32'format'||U32'$pad2'||SYM#tag-#anon#UN[ARR20{S8}$S8$'b'||ARR10{S16}$S16$'s'||ARR5{S64}$S64$'l'|]#'data'|]
// file /usr/include/X11/Xlib.h line 897
struct anonymous$49;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||S32'mode'||S32'detail'||S32'same_screen'||S32'focus'||U32'state'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 610
struct anonymous$26;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||S8'is_hint'||U24'$pad2'||S32'same_screen'||U32'$pad3'|]
// file /usr/include/X11/Xlib.h line 593
struct anonymous$25;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||U32'button'||S32'same_screen'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 575
struct anonymous$24;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'root'||U64'subwindow'||U64'time'||S32'x'||S32'y'||S32'x_root'||S32'y_root'||U32'state'||U32'keycode'||S32'same_screen'||U32'$pad2'|]
// file /usr/include/X11/Xlib.h line 557
struct anonymous$23;

// tag-#anon#ST[S32'type'||U32'$pad0'||U64'serial'||S32'send_event'||U32'$pad1'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'window'||U64'selection'||U64'time'|]
// file /usr/include/X11/Xlib.h line 847
struct anonymous$45;

// tag-#anon#ST[S32'x'||S32'y'|]
// file /usr/include/X11/Xutil.h line 88
struct anonymous$60;

// tag-#anon#ST[S32'x'||S32'y'||S32'width'||S32'height'||S32'border_width'||S32'depth'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visual'||U64'root'||S32'class'||S32'bit_gravity'||S32'win_gravity'||S32'backing_store'||U64'backing_planes'||U64'backing_pixel'||S32'save_under'||U32'$pad0'||U64'colormap'||S32'map_installed'||S32'map_state'||S64'all_event_masks'||S64'your_event_mask'||S64'do_not_propagate_mask'||S32'override_redirect'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$'display'||U64'root'||S32'width'||S32'height'||S32'mwidth'||S32'mheight'||S32'ndepths'||U32'$pad0'||*{SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#}$SYM#tag-#anon#ST[S32'depth'||S32'nvisuals'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visuals'|]#$'depths'||S32'root_depth'||U32'$pad1'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'root_visual'||*{SYM#tag-_XGC#}$SYM#tag-_XGC#$'default_gc'||U64'cmap'||U64'white_pixel'||U64'black_pixel'||S32'max_maps'||S32'min_maps'||S32'backing_store'||S32'save_unders'||S64'root_input_mask'|]#$'screen'|]
// file /usr/include/X11/Xlib.h line 308
struct anonymous$10;

// tag-#anon#ST[S64'flags'||S32'input'||S32'initial_state'||U64'icon_pixmap'||U64'icon_window'||S32'icon_x'||S32'icon_y'||U64'icon_mask'||U64'window_group'|]
// file /usr/include/X11/Xutil.h line 119
struct anonymous$58;

// tag-#anon#ST[S64'flags'||S32'x'||S32'y'||S32'width'||S32'height'||S32'min_width'||S32'min_height'||S32'max_width'||S32'max_height'||S32'width_inc'||S32'height_inc'||SYM#tag-#anon#ST[S32'x'||S32'y'|]#'min_aspect'||SYM#tag-#anon#ST[S32'x'||S32'y'|]#'max_aspect'||S32'base_width'||S32'base_height'||S32'win_gravity'||U32'$pad0'|]
// file /usr/include/X11/Xutil.h line 81
struct anonymous$61;

// tag-#anon#ST[SYM#tag-sockaddr_in#'sin'||U32'sinlen'||S32'bindflag'||S32'sd'|]
// file socklib.h line 35
struct anonymous$18;

// tag-#anon#ST[U64'name'||U64'card32'|]
// file /usr/include/X11/Xlib.h line 1030
struct anonymous$13;

// tag-#anon#ST[U64'pixel'||U16'red'||U16'green'||U16'blue'||S8'flags'||S8'pad'|]
// file /usr/include/X11/Xlib.h line 410
struct anonymous$5;

// tag-#anon#ST[U64'valuemask'||*{SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#}$SYM#tag-#anon#ST[*{SYM#tag-_XExtData#}$SYM#tag-_XExtData#$'ext_data'||U64'visualid'||S32'class'||U32'$pad0'||U64'red_mask'||U64'green_mask'||U64'blue_mask'||S32'bits_per_rgb'||S32'map_entries'|]#$'visual'||U64'colormap'||U32'depth'||U32'width'||U32'height'||U32'x_hotspot'||U32'y_hotspot'||U32'cpp'||*{U64}$U64$'pixels'||U32'npixels'||U32'$pad0'||*{SYM#tag-#anon#ST[*{S8}$S8$'name'||*{S8}$S8$'value'||U64'pixel'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'name'||*{S8}$S8$'value'||U64'pixel'|]#$'colorsymbols'||U32'numsymbols'||U32'$pad1'||*{S8}$S8$'rgb_fname'||U32'nextensions'||U32'$pad2'||*{SYM#tag-#anon#ST[*{S8}$S8$'name'||U32'nlines'||U32'$pad0'||*{*{S8}$S8$}$*{S8}$S8$$'lines'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'name'||U32'nlines'||U32'$pad0'||*{*{S8}$S8$}$*{S8}$S8$$'lines'|]#$'extensions'||U32'ncolors'||U32'$pad3'||*{SYM#tag-#anon#ST[*{S8}$S8$'string'||*{S8}$S8$'symbolic'||*{S8}$S8$'m_color'||*{S8}$S8$'g4_color'||*{S8}$S8$'g_color'||*{S8}$S8$'c_color'|]#}$SYM#tag-#anon#ST[*{S8}$S8$'string'||*{S8}$S8$'symbolic'||*{S8}$S8$'m_color'||*{S8}$S8$'g4_color'||*{S8}$S8$'g_color'||*{S8}$S8$'c_color'|]#$'colorTable'||*{S8}$S8$'hints_cmt'||*{S8}$S8$'colors_cmt'||*{S8}$S8$'pixels_cmt'||U32'mask_pixel'||S32'exactColors'||U32'closeness'||U32'red_closeness'||U32'green_closeness'||U32'blue_closeness'||S32'color_key'||U32'$pad4'||*{U64}$U64$'alloc_pixels'||S32'nalloc_pixels'||S32'alloc_close_colors'||S32'bitmap_format'||U32'$pad5'||*{S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$|U64|*{S8}$S8$|*{SYM#tag-#anon#ST[U64'pixel'||U16'red'||U16'green'||U16'blue'||S8'flags'||S8'pad'|]#}$SYM#tag-#anon#ST[U64'pixel'||U16'red'||U16'green'||U16'blue'||S8'flags'||S8'pad'|]#$|*{V}$V$)->S32}$S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$|U64|*{S8}$S8$|*{SYM#tag-#anon#ST[U64'pixel'||U16'red'||U16'green'||U16'blue'||S8'flags'||S8'pad'|]#}$SYM#tag-#anon#ST[U64'pixel'||U16'red'||U16'green'||U16'blue'||S8'flags'||S8'pad'|]#$|*{V}$V$)->S32$'alloc_color'||*{S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$|U64|*{U64}$U64$|S32|*{V}$V$)->S32}$S32(*{SYM#tag-_XDisplay#}$SYM#tag-_XDisplay#$|U64|*{U64}$U64$|S32|*{V}$V$)->S32$'free_colors'||*{V}$V$'color_closure'|]
// file /usr/include/X11/xpm.h line 157
struct anonymous$6;

// tag-#anon#UN[ARR20{S8}$S8$'b'||ARR10{S16}$S16$'s'||ARR5{S64}$S64$'l'|]
// file /usr/include/X11/Xlib.h line 905
union anonymous$20;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$16;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$7;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$8;

// tag-XpmIcon
// file gui.c line 60
struct XpmIcon;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-_XDisplay
// file /usr/include/X11/Xlib.h line 255
struct _XDisplay;

// tag-_XEvent
// file /usr/include/X11/Xlib.h line 973
union _XEvent;

// tag-_XExtData
// file /usr/include/X11/Xlib.h line 148
struct _XExtData;

// tag-_XGC
// file /usr/include/X11/Xlib.h line 214
struct _XGC;

// tag-_XPrivate
// file /usr/include/X11/Xlib.h line 490
struct _XPrivate;

// tag-_XrmHashBucketRec
// file /usr/include/X11/Xlib.h line 491
struct _XrmHashBucketRec;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-hostent
// file /usr/include/netdb.h line 100
struct hostent;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-mbox_struct
// file globals.h line 88
struct mbox_struct;

// tag-pixfile
// file globals.h line 22
struct pixfile;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_in
// file /usr/include/netinet/in.h line 237
struct sockaddr_in;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-x11_set_struct
// file globals.h line 27
struct x11_set_struct;

#ifndef NULL
#define NULL ((void*)0)
#endif

// ButtonHandler
// file gui.c line 426
void ButtonHandler(union _XEvent *E);
// DarkenCharColor
// file x_color.c line 64
char * DarkenCharColor(char *ColorName, float rate, struct _XDisplay *disp, unsigned long int win);
// DarkenColor
// file x_color.c line 90
unsigned long int DarkenColor(char *ColorName, float rate, struct _XDisplay *disp, unsigned long int win);
// Decode
// file md5c.c line 296
static void Decode(unsigned int *output, unsigned char *input, unsigned int len);
// Encode
// file md5c.c line 278
static void Encode(unsigned char *output, unsigned int *input, unsigned int len);
// GetColor
// file x_color.h line 18
unsigned long int GetColor(char *ColorName, struct _XDisplay *disp, unsigned long int win);
// GetXPM
// file gui.c line 151
struct XpmIcon * GetXPM(char **data);
// LightenCharColor
// file x_color.c line 99
char * LightenCharColor(char *ColorName, float rate, struct _XDisplay *disp, unsigned long int win);
// LightenColor
// file x_color.c line 131
unsigned long int LightenColor(char *ColorName, float rate, struct _XDisplay *disp, unsigned long int win);
// LoadXPM
// file gui.c line 130
void LoadXPM(struct pixfile *filelist, struct XpmIcon **destination);
// MD5Final
// file md5.h line 61
void MD5Final(unsigned char *digest, struct anonymous$17 *context);
// MD5Init
// file md5.h line 58
void MD5Init(struct anonymous$17 *context);
// MD5Transform
// file md5c.c line 185
static void MD5Transform(unsigned int *state, unsigned char *block);
// MD5Update
// file md5.h line 59
void MD5Update(struct anonymous$17 *context, unsigned char *input, unsigned int inputLen);
// MD5_memcpy
// file md5c.c line 311
static void MD5_memcpy(unsigned char *output, unsigned char *input, unsigned int len);
// MD5_memset
// file md5c.c line 327
static void MD5_memset(unsigned char *output, signed int value, unsigned int len);
// ParseColor
// file x_color.c line 43
struct anonymous$5 ParseColor(char *ColorName, struct _XDisplay *disp, unsigned long int win);
// Sclient
// file socklib.h line 50
signed int Sclient(struct anonymous$18 *sp, char *name, signed int port);
// Sclose
// file socklib.h line 48
signed int Sclose(struct anonymous$18 *sp);
// Sopen
// file socklib.h line 47
struct anonymous$18 * Sopen(void);
// Sread
// file socklib.h line 51
unsigned long int Sread(signed int sd, char *string, signed int n, signed int timeout);
// Sserver
// file socklib.c line 98
signed int Sserver(struct anonymous$18 *sp, signed int port, signed int sync);
// Swrite
// file socklib.h line 52
unsigned long int Swrite(signed int sd, char *string);
// XAllocColor
// file /usr/include/X11/Xlib.h line 1958
extern signed int XAllocColor(struct _XDisplay *, unsigned long int, struct anonymous$5 *);
// XBell
// file /usr/include/X11/Xlib.h line 2010
extern signed int XBell(struct _XDisplay *, signed int);
// XClearWindow
// file /usr/include/X11/Xlib.h line 2155
extern signed int XClearWindow(struct _XDisplay *, unsigned long int);
// XCloseDisplay
// file /usr/include/X11/Xlib.h line 2160
extern signed int XCloseDisplay(struct _XDisplay *);
// XCopyArea
// file /usr/include/X11/Xlib.h line 2184
extern signed int XCopyArea(struct _XDisplay *, unsigned long int, unsigned long int, struct _XGC *, signed int, signed int, unsigned int, unsigned int, signed int, signed int);
// XCreateGC
// file /usr/include/X11/Xlib.h line 1584
extern struct _XGC * XCreateGC(struct _XDisplay *, unsigned long int, unsigned long int, struct anonymous *);
// XCreatePixmap
// file /usr/include/X11/Xlib.h line 1597
extern unsigned long int XCreatePixmap(struct _XDisplay *, unsigned long int, unsigned int, unsigned int, unsigned int);
// XCreateSimpleWindow
// file /usr/include/X11/Xlib.h line 1621
extern unsigned long int XCreateSimpleWindow(struct _XDisplay *, unsigned long int, signed int, signed int, unsigned int, unsigned int, unsigned int, unsigned long int, unsigned long int);
// XDisplayName
// file /usr/include/X11/Xlib.h line 1515
extern char * XDisplayName(const char *);
// XDrawText
// file /usr/include/X11/Xlib.h line 2424
extern signed int XDrawText(struct _XDisplay *, unsigned long int, struct _XGC *, signed int, signed int, struct anonymous$14 *, signed int);
// XFlush
// file /usr/include/X11/Xlib.h line 2507
extern signed int XFlush(struct _XDisplay *);
// XFreeFont
// file /usr/include/X11/Xlib.h line 2542
extern signed int XFreeFont(struct _XDisplay *, struct anonymous$21 *);
// XGetWindowAttributes
// file /usr/include/X11/Xlib.h line 2691
extern signed int XGetWindowAttributes(struct _XDisplay *, unsigned long int, struct anonymous$10 *);
// XInternAtom
// file /usr/include/X11/Xlib.h line 1536
extern unsigned long int XInternAtom(struct _XDisplay *, const char *, signed int);
// XLoadFont
// file /usr/include/X11/Xlib.h line 1580
extern unsigned long int XLoadFont(struct _XDisplay *, const char *);
// XLoadQueryFont
// file /usr/include/X11/Xlib.h line 1394
extern struct anonymous$21 * XLoadQueryFont(struct _XDisplay *, const char *);
// XMapWindow
// file /usr/include/X11/Xlib.h line 2806
extern signed int XMapWindow(struct _XDisplay *, unsigned long int);
// XNextEvent
// file /usr/include/X11/Xlib.h line 2841
extern signed int XNextEvent(struct _XDisplay *, union _XEvent *);
// XOpenDisplay
// file /usr/include/X11/Xlib.h line 1483
extern struct _XDisplay * XOpenDisplay(const char *);
// XPMError
// file gui.c line 103
void XPMError(signed int Code, const char *info);
// XParseColor
// file /usr/include/X11/Xlib.h line 2850
extern signed int XParseColor(struct _XDisplay *, unsigned long int, const char *, struct anonymous$5 *);
// XParseGeometry
// file /usr/include/X11/Xlib.h line 2857
extern signed int XParseGeometry(const char *, signed int *, signed int *, unsigned int *, unsigned int *);
// XPending
// file /usr/include/X11/Xlib.h line 2881
extern signed int XPending(struct _XDisplay *);
// XSelectInput
// file /usr/include/X11/Xlib.h line 3129
extern signed int XSelectInput(struct _XDisplay *, unsigned long int, signed long int);
// XSetClassHint
// file /usr/include/X11/Xutil.h line 583
extern signed int XSetClassHint(struct _XDisplay *, unsigned long int, struct anonymous$57 *);
// XSetClipMask
// file /usr/include/X11/Xlib.h line 3160
extern signed int XSetClipMask(struct _XDisplay *, struct _XGC *, unsigned long int);
// XSetClipOrigin
// file /usr/include/X11/Xlib.h line 3166
extern signed int XSetClipOrigin(struct _XDisplay *, struct _XGC *, signed int, signed int);
// XSetCommand
// file /usr/include/X11/Xlib.h line 3188
extern signed int XSetCommand(struct _XDisplay *, unsigned long int, char **, signed int);
// XSetIconName
// file /usr/include/X11/Xlib.h line 3245
extern signed int XSetIconName(struct _XDisplay *, unsigned long int, const char *);
// XSetWMHints
// file /usr/include/X11/Xutil.h line 641
extern signed int XSetWMHints(struct _XDisplay *, unsigned long int, struct anonymous$58 *);
// XSetWMName
// file /usr/include/X11/Xutil.h line 653
extern void XSetWMName(struct _XDisplay *, unsigned long int, struct anonymous$59 *);
// XSetWMNormalHints
// file /usr/include/X11/Xutil.h line 659
extern void XSetWMNormalHints(struct _XDisplay *, unsigned long int, struct anonymous$61 *);
// XSetWMProtocols
// file /usr/include/X11/Xlib.h line 1888
extern signed int XSetWMProtocols(struct _XDisplay *, unsigned long int, unsigned long int *, signed int);
// XShapeCombineMask
// file /usr/include/X11/extensions/shape.h line 85
extern void XShapeCombineMask(struct _XDisplay *, unsigned long int, signed int, signed int, signed int, unsigned long int, signed int);
// XStoreName
// file /usr/include/X11/Xlib.h line 3395
extern signed int XStoreName(struct _XDisplay *, unsigned long int, const char *);
// XStringListToTextProperty
// file /usr/include/X11/Xutil.h line 733
extern signed int XStringListToTextProperty(char **, signed int, struct anonymous$59 *);
// XTextExtents
// file /usr/include/X11/Xlib.h line 3414
extern signed int XTextExtents(struct anonymous$21 *, const char *, signed int, signed int *, signed int *, signed int *, struct anonymous$19 *);
// XWMGeometry
// file /usr/include/X11/Xutil.h line 812
extern signed int XWMGeometry(struct _XDisplay *, signed int, const char *, const char *, unsigned int, struct anonymous$61 *, signed int *, signed int *, signed int *, signed int *, signed int *);
// XpmCreatePixmapFromData
// file /usr/include/X11/xpm.h line 292
extern signed int XpmCreatePixmapFromData(struct _XDisplay *, unsigned long int, char **, unsigned long int *, unsigned long int *, struct anonymous$6 *);
// XpmReadFileToPixmap
// file /usr/include/X11/xpm.h line 305
extern signed int XpmReadFileToPixmap(struct _XDisplay *, unsigned long int, const char *, unsigned long int *, unsigned long int *, struct anonymous$6 *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, struct sockaddr *, unsigned int *);
// add_status
// file gui.c line 183
void add_status(char *line, signed int s);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// check_mbox
// file gui.c line 389
signed int check_mbox();
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, struct sockaddr *, unsigned int);
// count
// file mbox.c line 10
signed int count(struct mbox_struct *mb);
// count_dir
// file maildir.c line 11
signed int count_dir(const char *dirname);
// count_mh
// file mh.c line 59
signed int count_mh(struct mbox_struct *mb, signed int *mod_time);
// count_mh_files
// file mh.c line 69
signed int count_mh_files(struct mbox_struct *mb);
// count_mh_sequences
// file mh.c line 139
signed int count_mh_sequences(struct mbox_struct *mb, signed int *mod_time);
// defaults
// file asmail.c line 72
void defaults();
// draw_window
// file gui.c line 225
void draw_window(unsigned long int win);
// err_printf
// file asmail.c line 56
static void err_printf(const char *tmpl, ...);
// execute_on_new
// file gui.c line 170
void execute_on_new();
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file socklib.c line 59 function Sopen
void free(void *);
// ftell
// file /usr/include/stdio.h line 754
extern signed long int ftell(struct _IO_FILE *);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// gethostbyname
// file /usr/include/netdb.h line 144
extern struct hostent * gethostbyname(const char *);
// gethostname
// file /usr/include/unistd.h line 879
extern signed int gethostname(char *, unsigned long int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// imap_checkmbox
// file imap.c line 151
signed int imap_checkmbox(struct mbox_struct *mb, struct anonymous$18 **sock);
// imap_goodbye
// file imap.c line 231
signed int imap_goodbye(struct mbox_struct *mb, struct anonymous$18 **sock);
// imap_handle
// file imap.h line 17
void imap_handle(struct mbox_struct *mb);
// imap_login
// file imap.c line 99
signed int imap_login(struct mbox_struct *mb, struct anonymous$18 **sock);
// init_mbox
// file asmail.c line 501
signed int init_mbox(struct mbox_struct **mb);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// maildir_handle
// file maildir.h line 6
void maildir_handle(struct mbox_struct *mb);
// main_loop
// file gui.c line 474
void main_loop();
// malloc
// file socklib.c line 50 function Sopen
void * malloc(unsigned long int);
// mbox_handle
// file mbox.h line 6
void mbox_handle(struct mbox_struct *mb);
// mbox_thread
// file asmail.c line 759
void mbox_thread(void *ptr);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mh_handle
// file mh.h line 7
void mh_handle(struct mbox_struct *mb);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// parse_cfg
// file asmail.c line 680
signed int parse_cfg(char *filename);
// parse_cfg_animate
// file asmail.c line 258
signed int parse_cfg_animate(struct _IO_FILE *f, signed int *line_counter, char *filename);
// parse_cfg_check
// file asmail.c line 240
signed int parse_cfg_check(char *line);
// parse_cfg_mbox
// file asmail.c line 538
signed int parse_cfg_mbox(struct _IO_FILE *f, signed int *line_counter, char *filename);
// parse_cfg_stat
// file asmail.c line 355
signed int parse_cfg_stat(struct _IO_FILE *f, signed int *line_counter, char *filename);
// parse_cfg_x11
// file asmail.c line 423
signed int parse_cfg_x11(struct _IO_FILE *f, signed int *line_counter, char *filename);
// parse_cmd
// file asmail.c line 124
signed int parse_cmd(signed int argc, char **argv);
// parse_sequence
// file mh.c line 333
signed int parse_sequence(char *sequence);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// pop3_handle
// file pop3.h line 15
void pop3_handle(struct mbox_struct *mb);
// pop3_mailcheck
// file pop3.c line 50
signed int pop3_mailcheck(struct mbox_struct *mb);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous$7 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$7 *, const union anonymous$16 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous$7 *, union anonymous$8 *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$7 *, union anonymous$8 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$8 *, const union anonymous$16 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$8 *);
// pthread_mutex_trylock
// file /usr/include/pthread.h line 760
extern signed int pthread_mutex_trylock(union anonymous$8 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$8 *);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// readLine
// file mh.c line 247
signed int readLine(struct _IO_FILE *stream, char **line, signed int *size);
// readdir
// file /usr/include/dirent.h line 162
extern struct dirent * readdir(struct __dirstream *);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// redraw
// file gui.c line 373
void redraw();
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous$1 *, struct anonymous$1 *, struct anonymous$1 *, struct timeval *);
// setup_pixmap
// file gui.c line 356
void setup_pixmap();
// setup_window
// file gui.c line 203
void setup_window(unsigned long int win);
// shorten
// file asmail.c line 187
void shorten(char *line);
// signal_check
// file globals.c line 60
void signal_check();
// signal_update
// file globals.h line 128
void signal_update();
// sleep_check
// file globals.h line 145
signed int sleep_check(const signed int sec);
// sleep_update
// file globals.h line 130
signed int sleep_update(const signed int centisec);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// startx
// file gui.h line 6
void startx(void *ptr);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strip_quotes
// file asmail.c line 213
void strip_quotes(char *line);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 132
extern char * strncpy(char *, const char *, unsigned long int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// system
// file /usr/include/stdlib.h line 716
extern signed int system(const char *);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tokenizeString
// file mh.c line 278
signed int tokenizeString(char *string, signed int size, char ***output);
// usage
// file asmail.c line 37
void usage();
// version
// file asmail.c line 33
void version();
// vprintf
// file /usr/include/stdio.h line 377
extern signed int vprintf(const char *, void **);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// x11_event
// file gui.c line 439
void x11_event();
// x_cleanup
// file gui.c line 177
void x_cleanup();

struct anonymous$14
{
  // chars
  char *chars;
  // nchars
  signed int nchars;
  // delta
  signed int delta;
  // font
  unsigned long int font;
};

struct anonymous$0
{
  // name
  char *name;
  // value
  char *value;
  // pixel
  unsigned long int pixel;
};

struct anonymous$2
{
  // name
  char *name;
  // nlines
  unsigned int nlines;
  // lines
  char **lines;
};

struct anonymous$57
{
  // res_name
  char *res_name;
  // res_class
  char *res_class;
};

struct anonymous$3
{
  // string
  char *string;
  // symbolic
  char *symbolic;
  // m_color
  char *m_color;
  // g4_color
  char *g4_color;
  // g_color
  char *g_color;
  // c_color
  char *c_color;
};

struct anonymous$9
{
  // ext_data
  struct _XExtData *ext_data;
  // display
  struct _XDisplay *display;
  // root
  unsigned long int root;
  // width
  signed int width;
  // height
  signed int height;
  // mwidth
  signed int mwidth;
  // mheight
  signed int mheight;
  // ndepths
  signed int ndepths;
  // depths
  struct anonymous$11 *depths;
  // root_depth
  signed int root_depth;
  // root_visual
  struct anonymous$4 *root_visual;
  // default_gc
  struct _XGC *default_gc;
  // cmap
  unsigned long int cmap;
  // white_pixel
  unsigned long int white_pixel;
  // black_pixel
  unsigned long int black_pixel;
  // max_maps
  signed int max_maps;
  // min_maps
  signed int min_maps;
  // backing_store
  signed int backing_store;
  // save_unders
  signed int save_unders;
  // root_input_mask
  signed long int root_input_mask;
};

struct anonymous$55
{
  // ext_data
  struct _XExtData *ext_data;
  // private1
  struct _XPrivate *private1;
  // fd
  signed int fd;
  // private2
  signed int private2;
  // proto_major_version
  signed int proto_major_version;
  // proto_minor_version
  signed int proto_minor_version;
  // vendor
  char *vendor;
  // private3
  unsigned long int private3;
  // private4
  unsigned long int private4;
  // private5
  unsigned long int private5;
  // private6
  signed int private6;
  // resource_alloc
  unsigned long int (*resource_alloc)(struct _XDisplay *);
  // byte_order
  signed int byte_order;
  // bitmap_unit
  signed int bitmap_unit;
  // bitmap_pad
  signed int bitmap_pad;
  // bitmap_bit_order
  signed int bitmap_bit_order;
  // nformats
  signed int nformats;
  // pixmap_format
  struct anonymous$15 *pixmap_format;
  // private8
  signed int private8;
  // release
  signed int release;
  // private9
  struct _XPrivate *private9;
  // private10
  struct _XPrivate *private10;
  // qlen
  signed int qlen;
  // last_request_read
  unsigned long int last_request_read;
  // request
  unsigned long int request;
  // private11
  char *private11;
  // private12
  char *private12;
  // private13
  char *private13;
  // private14
  char *private14;
  // max_request_size
  unsigned int max_request_size;
  // db
  struct _XrmHashBucketRec *db;
  // private15
  signed int (*private15)(struct _XDisplay *);
  // display_name
  char *display_name;
  // default_screen
  signed int default_screen;
  // nscreens
  signed int nscreens;
  // screens
  struct anonymous$9 *screens;
  // motion_buffer
  unsigned long int motion_buffer;
  // private16
  unsigned long int private16;
  // min_keycode
  signed int min_keycode;
  // max_keycode
  signed int max_keycode;
  // private17
  char *private17;
  // private18
  char *private18;
  // private19
  signed int private19;
  // xdefaults
  char *xdefaults;
};

struct anonymous$15
{
  // ext_data
  struct _XExtData *ext_data;
  // depth
  signed int depth;
  // bits_per_pixel
  signed int bits_per_pixel;
  // scanline_pad
  signed int scanline_pad;
};

struct anonymous$19
{
  // lbearing
  signed short int lbearing;
  // rbearing
  signed short int rbearing;
  // width
  signed short int width;
  // ascent
  signed short int ascent;
  // descent
  signed short int descent;
  // attributes
  unsigned short int attributes;
};

struct anonymous$21
{
  // ext_data
  struct _XExtData *ext_data;
  // fid
  unsigned long int fid;
  // direction
  unsigned int direction;
  // min_char_or_byte2
  unsigned int min_char_or_byte2;
  // max_char_or_byte2
  unsigned int max_char_or_byte2;
  // min_byte1
  unsigned int min_byte1;
  // max_byte1
  unsigned int max_byte1;
  // all_chars_exist
  signed int all_chars_exist;
  // default_char
  unsigned int default_char;
  // n_properties
  signed int n_properties;
  // properties
  struct anonymous$13 *properties;
  // min_bounds
  struct anonymous$19 min_bounds;
  // max_bounds
  struct anonymous$19 max_bounds;
  // per_char
  struct anonymous$19 *per_char;
  // ascent
  signed int ascent;
  // descent
  signed int descent;
};

struct anonymous$4
{
  // ext_data
  struct _XExtData *ext_data;
  // visualid
  unsigned long int visualid;
  // class
  signed int class;
  // red_mask
  unsigned long int red_mask;
  // green_mask
  unsigned long int green_mask;
  // blue_mask
  unsigned long int blue_mask;
  // bits_per_rgb
  signed int bits_per_rgb;
  // map_entries
  signed int map_entries;
};

struct anonymous$59
{
  // value
  unsigned char *value;
  // encoding
  unsigned long int encoding;
  // format
  signed int format;
  // nitems
  unsigned long int nitems;
};

struct anonymous$1
{
  // __fds_bits
  signed long int __fds_bits[16l];
};

struct anonymous$17
{
  // state
  unsigned int state[4l];
  // count
  unsigned int count[2l];
  // buffer
  unsigned char buffer[64l];
};

struct anonymous$12
{
  // x
  signed short int x;
  // y
  signed short int y;
};

struct anonymous$56
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$11
{
  // depth
  signed int depth;
  // nvisuals
  signed int nvisuals;
  // visuals
  struct anonymous$4 *visuals;
};

struct anonymous
{
  // function
  signed int function;
  // plane_mask
  unsigned long int plane_mask;
  // foreground
  unsigned long int foreground;
  // background
  unsigned long int background;
  // line_width
  signed int line_width;
  // line_style
  signed int line_style;
  // cap_style
  signed int cap_style;
  // join_style
  signed int join_style;
  // fill_style
  signed int fill_style;
  // fill_rule
  signed int fill_rule;
  // arc_mode
  signed int arc_mode;
  // tile
  unsigned long int tile;
  // stipple
  unsigned long int stipple;
  // ts_x_origin
  signed int ts_x_origin;
  // ts_y_origin
  signed int ts_y_origin;
  // font
  unsigned long int font;
  // subwindow_mode
  signed int subwindow_mode;
  // graphics_exposures
  signed int graphics_exposures;
  // clip_x_origin
  signed int clip_x_origin;
  // clip_y_origin
  signed int clip_y_origin;
  // clip_mask
  unsigned long int clip_mask;
  // dash_offset
  signed int dash_offset;
  // dashes
  char dashes;
};

struct anonymous$51
{
  // type
  signed int type;
  // display
  struct _XDisplay *display;
  // resourceid
  unsigned long int resourceid;
  // serial
  unsigned long int serial;
  // error_code
  unsigned char error_code;
  // request_code
  unsigned char request_code;
  // minor_code
  unsigned char minor_code;
};

struct anonymous$53
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
};

struct anonymous$54
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // extension
  signed int extension;
  // evtype
  signed int evtype;
  // cookie
  unsigned int cookie;
  // data
  void *data;
};

struct anonymous$30
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous$29
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // drawable
  unsigned long int drawable;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
  // major_code
  signed int major_code;
  // minor_code
  signed int minor_code;
};

struct anonymous$33
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
};

struct anonymous$34
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // from_configure
  signed int from_configure;
};

struct anonymous$35
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$42
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous$39
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
};

struct anonymous$38
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$37
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // event
  unsigned long int event;
  // window
  unsigned long int window;
  // parent
  unsigned long int parent;
  // x
  signed int x;
  // y
  signed int y;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$46
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // owner
  unsigned long int owner;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous$36
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
};

struct anonymous$43
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // place
  signed int place;
};

struct anonymous$32
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // override_redirect
  signed int override_redirect;
};

struct anonymous$41
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // parent
  unsigned long int parent;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // above
  unsigned long int above;
  // detail
  signed int detail;
  // value_mask
  unsigned long int value_mask;
};

struct anonymous$47
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // requestor
  unsigned long int requestor;
  // selection
  unsigned long int selection;
  // target
  unsigned long int target;
  // property
  unsigned long int property;
  // time
  unsigned long int time;
};

struct anonymous$22
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
};

struct anonymous$52
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // key_vector
  char key_vector[32l];
};

struct anonymous$27
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // mode
  signed int mode;
  // detail
  signed int detail;
};

struct anonymous$50
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // request
  signed int request;
  // first_keycode
  signed int first_keycode;
  // count
  signed int count;
};

struct anonymous$31
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // state
  signed int state;
};

struct anonymous$40
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // width
  signed int width;
  // height
  signed int height;
};

struct anonymous$28
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // count
  signed int count;
};

struct anonymous$44
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // atom
  unsigned long int atom;
  // time
  unsigned long int time;
  // state
  signed int state;
};

struct anonymous$48
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // colormap
  unsigned long int colormap;
  // new
  signed int new;
  // state
  signed int state;
};

union anonymous$20
{
  // b
  char b[20l];
  // s
  signed short int s[10l];
  // l
  signed long int l[5l];
};

struct anonymous$49
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // message_type
  unsigned long int message_type;
  // format
  signed int format;
  // data
  union anonymous$20 data;
};

struct anonymous$26
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // mode
  signed int mode;
  // detail
  signed int detail;
  // same_screen
  signed int same_screen;
  // focus
  signed int focus;
  // state
  unsigned int state;
};

struct anonymous$25
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // is_hint
  char is_hint;
  // same_screen
  signed int same_screen;
};

struct anonymous$24
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // button
  unsigned int button;
  // same_screen
  signed int same_screen;
};

struct anonymous$23
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // root
  unsigned long int root;
  // subwindow
  unsigned long int subwindow;
  // time
  unsigned long int time;
  // x
  signed int x;
  // y
  signed int y;
  // x_root
  signed int x_root;
  // y_root
  signed int y_root;
  // state
  unsigned int state;
  // keycode
  unsigned int keycode;
  // same_screen
  signed int same_screen;
};

struct anonymous$45
{
  // type
  signed int type;
  // serial
  unsigned long int serial;
  // send_event
  signed int send_event;
  // display
  struct _XDisplay *display;
  // window
  unsigned long int window;
  // selection
  unsigned long int selection;
  // time
  unsigned long int time;
};

struct anonymous$60
{
  // x
  signed int x;
  // y
  signed int y;
};

struct anonymous$10
{
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // border_width
  signed int border_width;
  // depth
  signed int depth;
  // visual
  struct anonymous$4 *visual;
  // root
  unsigned long int root;
  // class
  signed int class;
  // bit_gravity
  signed int bit_gravity;
  // win_gravity
  signed int win_gravity;
  // backing_store
  signed int backing_store;
  // backing_planes
  unsigned long int backing_planes;
  // backing_pixel
  unsigned long int backing_pixel;
  // save_under
  signed int save_under;
  // colormap
  unsigned long int colormap;
  // map_installed
  signed int map_installed;
  // map_state
  signed int map_state;
  // all_event_masks
  signed long int all_event_masks;
  // your_event_mask
  signed long int your_event_mask;
  // do_not_propagate_mask
  signed long int do_not_propagate_mask;
  // override_redirect
  signed int override_redirect;
  // screen
  struct anonymous$9 *screen;
};

struct anonymous$58
{
  // flags
  signed long int flags;
  // input
  signed int input;
  // initial_state
  signed int initial_state;
  // icon_pixmap
  unsigned long int icon_pixmap;
  // icon_window
  unsigned long int icon_window;
  // icon_x
  signed int icon_x;
  // icon_y
  signed int icon_y;
  // icon_mask
  unsigned long int icon_mask;
  // window_group
  unsigned long int window_group;
};

struct anonymous$61
{
  // flags
  signed long int flags;
  // x
  signed int x;
  // y
  signed int y;
  // width
  signed int width;
  // height
  signed int height;
  // min_width
  signed int min_width;
  // min_height
  signed int min_height;
  // max_width
  signed int max_width;
  // max_height
  signed int max_height;
  // width_inc
  signed int width_inc;
  // height_inc
  signed int height_inc;
  // min_aspect
  struct anonymous$60 min_aspect;
  // max_aspect
  struct anonymous$60 max_aspect;
  // base_width
  signed int base_width;
  // base_height
  signed int base_height;
  // win_gravity
  signed int win_gravity;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct anonymous$18
{
  // sin
  struct sockaddr_in sin;
  // sinlen
  unsigned int sinlen;
  // bindflag
  signed int bindflag;
  // sd
  signed int sd;
};

struct anonymous$13
{
  // name
  unsigned long int name;
  // card32
  unsigned long int card32;
};

struct anonymous$5
{
  // pixel
  unsigned long int pixel;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
  // flags
  char flags;
  // pad
  char pad;
};

struct anonymous$6
{
  // valuemask
  unsigned long int valuemask;
  // visual
  struct anonymous$4 *visual;
  // colormap
  unsigned long int colormap;
  // depth
  unsigned int depth;
  // width
  unsigned int width;
  // height
  unsigned int height;
  // x_hotspot
  unsigned int x_hotspot;
  // y_hotspot
  unsigned int y_hotspot;
  // cpp
  unsigned int cpp;
  // pixels
  unsigned long int *pixels;
  // npixels
  unsigned int npixels;
  // colorsymbols
  struct anonymous$0 *colorsymbols;
  // numsymbols
  unsigned int numsymbols;
  // rgb_fname
  char *rgb_fname;
  // nextensions
  unsigned int nextensions;
  // extensions
  struct anonymous$2 *extensions;
  // ncolors
  unsigned int ncolors;
  // colorTable
  struct anonymous$3 *colorTable;
  // hints_cmt
  char *hints_cmt;
  // colors_cmt
  char *colors_cmt;
  // pixels_cmt
  char *pixels_cmt;
  // mask_pixel
  unsigned int mask_pixel;
  // exactColors
  signed int exactColors;
  // closeness
  unsigned int closeness;
  // red_closeness
  unsigned int red_closeness;
  // green_closeness
  unsigned int green_closeness;
  // blue_closeness
  unsigned int blue_closeness;
  // color_key
  signed int color_key;
  // alloc_pixels
  unsigned long int *alloc_pixels;
  // nalloc_pixels
  signed int nalloc_pixels;
  // alloc_close_colors
  signed int alloc_close_colors;
  // bitmap_format
  signed int bitmap_format;
  // alloc_color
  signed int (*alloc_color)(struct _XDisplay *, unsigned long int, char *, struct anonymous$5 *, void *);
  // free_colors
  signed int (*free_colors)(struct _XDisplay *, unsigned long int, unsigned long int *, signed int, void *);
  // color_closure
  void *color_closure;
};

union anonymous$16
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$7
{
  // __data
  struct anonymous$56 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$8
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct XpmIcon
{
  // pixmap
  unsigned long int pixmap;
  // mask
  unsigned long int mask;
  // attributes
  struct anonymous$6 attributes;
  // next
  struct XpmIcon *next;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

union _XEvent
{
  // type
  signed int type;
  // xany
  struct anonymous$22 xany;
  // xkey
  struct anonymous$23 xkey;
  // xbutton
  struct anonymous$24 xbutton;
  // xmotion
  struct anonymous$25 xmotion;
  // xcrossing
  struct anonymous$26 xcrossing;
  // xfocus
  struct anonymous$27 xfocus;
  // xexpose
  struct anonymous$28 xexpose;
  // xgraphicsexpose
  struct anonymous$29 xgraphicsexpose;
  // xnoexpose
  struct anonymous$30 xnoexpose;
  // xvisibility
  struct anonymous$31 xvisibility;
  // xcreatewindow
  struct anonymous$32 xcreatewindow;
  // xdestroywindow
  struct anonymous$33 xdestroywindow;
  // xunmap
  struct anonymous$34 xunmap;
  // xmap
  struct anonymous$35 xmap;
  // xmaprequest
  struct anonymous$36 xmaprequest;
  // xreparent
  struct anonymous$37 xreparent;
  // xconfigure
  struct anonymous$38 xconfigure;
  // xgravity
  struct anonymous$39 xgravity;
  // xresizerequest
  struct anonymous$40 xresizerequest;
  // xconfigurerequest
  struct anonymous$41 xconfigurerequest;
  // xcirculate
  struct anonymous$42 xcirculate;
  // xcirculaterequest
  struct anonymous$43 xcirculaterequest;
  // xproperty
  struct anonymous$44 xproperty;
  // xselectionclear
  struct anonymous$45 xselectionclear;
  // xselectionrequest
  struct anonymous$46 xselectionrequest;
  // xselection
  struct anonymous$47 xselection;
  // xcolormap
  struct anonymous$48 xcolormap;
  // xclient
  struct anonymous$49 xclient;
  // xmapping
  struct anonymous$50 xmapping;
  // xerror
  struct anonymous$51 xerror;
  // xkeymap
  struct anonymous$52 xkeymap;
  // xgeneric
  struct anonymous$53 xgeneric;
  // xcookie
  struct anonymous$54 xcookie;
  // pad
  signed long int pad[24l];
};

struct _XExtData
{
  // number
  signed int number;
  // next
  struct _XExtData *next;
  // free_private
  signed int (*free_private)(struct _XExtData *);
  // private_data
  char *private_data;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct hostent
{
  // h_name
  char *h_name;
  // h_aliases
  char **h_aliases;
  // h_addrtype
  signed int h_addrtype;
  // h_length
  signed int h_length;
  // h_addr_list
  char **h_addr_list;
};

struct mbox_struct
{
  // thread
  unsigned long int thread;
  // mutex
  union anonymous$8 mutex;
  // type
  signed int type;
  // flags
  signed int flags;
  // file
  char file[256l];
  // server
  char server[256l];
  // user
  char user[256l];
  // pass
  char pass[256l];
  // mbox
  char mbox[256l];
  // auth
  signed int auth;
  // port
  signed int port;
  // timeout
  signed int timeout;
  // update
  signed int update;
  // status
  signed int status;
  // mail
  signed int mail;
  // ctotal
  signed int ctotal;
  // cnew
  signed int cnew;
  // next
  struct mbox_struct *next;
};

struct pixfile
{
  // name
  char name[256l];
  // next
  struct pixfile *next;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct x11_set_struct
{
  // thread
  unsigned long int thread;
  // argc
  signed int argc;
  // argv
  char **argv;
  // beep
  signed int beep;
  // shape
  signed int shape;
  // use_frame
  signed int use_frame;
  // withdrawn
  signed int withdrawn;
  // iconic
  signed int iconic;
  // geometry
  char geometry[256l];
  // title
  char title[256l];
  // on_left
  char on_left[256l];
  // on_middle
  char on_middle[256l];
  // on_right
  char on_right[256l];
  // on_new_mail
  char on_new_mail[256l];
  // each
  signed int each;
  // total
  signed int total;
  // status
  signed int status;
  // old
  signed int old;
  // new
  signed int new;
  // x
  signed int x;
  // y
  signed int y;
  // delimiter
  char delimiter[256l];
  // color
  char color[256l];
  // font
  char font[256l];
  // refresh
  signed int refresh;
  // nomail
  struct pixfile *nomail;
  // oldmail
  struct pixfile *oldmail;
  // newmail
  struct pixfile *newmail;
  // frame
  struct pixfile *frame;
};


// Current
// file gui.c line 70
struct XpmIcon *Current = (struct XpmIcon *)(void *)0;
// Frame
// file gui.c line 66
struct XpmIcon *Frame = (struct XpmIcon *)(void *)0;
// NewMail
// file gui.c line 69
struct XpmIcon *NewMail = (struct XpmIcon *)(void *)0;
// NoMail
// file gui.c line 67
struct XpmIcon *NoMail = (struct XpmIcon *)(void *)0;
// NumOfMsg
// file gui.c line 91
struct anonymous$14 NumOfMsg;
// NumOfMsgColor
// file gui.c line 93
unsigned long int NumOfMsgColor;
// NumOfMsgText
// file gui.c line 92
char NumOfMsgText[256l];
// OldMail
// file gui.c line 68
struct XpmIcon *OldMail = (struct XpmIcon *)(void *)0;
// PADDING
// file md5c.c line 56
static unsigned char PADDING[64l] = { (unsigned char)0x80, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 };
// Root
// file gui.c line 82
unsigned long int Root;
// back_pix
// file gui.c line 97
unsigned long int back_pix;
// check_count
// file globals.c line 58
signed int check_count = 0;
// check_cv
// file globals.c line 57
union anonymous$7 check_cv;
// check_lock
// file globals.c line 56
union anonymous$8 check_lock;
// config_file_name
// file globals.c line 13
char config_file_name[256l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// drawWindow
// file gui.c line 85
unsigned long int drawWindow;
// flag_allow_insecure
// file globals.c line 15
signed int flag_allow_insecure = 0;
// flag_config_specified
// file globals.c line 18
signed int flag_config_specified = 0;
// flag_no_config
// file globals.c line 17
signed int flag_no_config = 0;
// flag_no_x
// file globals.c line 16
signed int flag_no_x = 0;
// flag_verbose
// file globals.c line 14
signed int flag_verbose = 0;
// font_struct
// file gui.c line 94
struct anonymous$21 *font_struct;
// fore_pix
// file gui.c line 98
unsigned long int fore_pix;
// frame
// file pixmaps/frame.xpm line 2
static char *frame[119l] = { "    64    64       54            1", ". c #cfcfcf", "# c #000000", "a c #737373", "b c #b6b6b6", "c c #b4b4b4", "d c #afafaf", "e c #afafaf", "f c #adadad", "g c #a8a8a8", "h c #a6a6a6", "i c #a1a1a1", "j c #a1a1a1", "k c #9f9f9f", "l c #9a9a9a", "m c #989898", "n c #929292", "o c #717171", "p c #b1b1b1", "q c #aaaaaa", "r c #a3a3a3", "s c #9c9c9c", "t c #949494", "u c #929292", "v c #6c6c6c", "w c #6a6a6a", "x c #909090", "y c #636363", "z c #616161", "A c #8d8d8d", "B c #8a8a8a", "C c #888888", "D c #5b5b5b", "E c #838383", "F c #868686", "G c #616161", "H c #595959", "I c #838383", "J c #4f4f4f", "K c #535353", "L c #818181", "M c #7b7b7b", "N c #7e7e7e", "O c #474747", "P c #797979", "Q c #494949", "R c #767676", "S c #4f4f4f", "T c #737373", "U c #404040", "V c #3d3d3d", "W c #6f6f6f", "X c #363636", "Y c #343434", "Z c #535353", "...............................................................#",
    "..............................................................a#",
    "..bcbcdcdcdcdefgdefgfgfgggfgghihihihijijijklkjklklkllmlllmnmnmo#",
    "..bbebpbebebededeqegegegegegrgggjgjgjijijsjijsjljljllllltltlula#",
    "..bcdcbcfcdefefefgfefgfhfgghghghihijkhijkjkjklklkllmlmlmnmnmnmv#",
    "..pbbbededededeqefeqegggggggggjgrgjijijijijsjllljllllltlllununw#",
    "..dcdcdcdefgfefgfgfgghggghihihihijkjijklkjklllkllmlllmnmnunmnuv#",
    "..ebebebededeqegegegggegrgrgjgjgjijijsjkjsjljljlllllultlunulunw#",
    "..dcfcdefefefgfgfgfhfhghihghihijkjijkjkjklklkllmlmlmnmnmnmnuxuv#",
    "..ededededeqefegegggggggggjgjgjijijijijsjllljllllltlllununununy#",
    "..fcdefgfefgfgfgghggghihihihijkjijklklklllkllmnmlmnmnununuxunuz#",
    "..ebeqedeqegegegggggrgrgjgjgjijijsjkjsjljljlllllululununununuAy#",
    "..defefefgfgfgghfhghihghihijkjijkjkjklklkllmlmlmnmnmnmnuxuxuxBz#",
    "..ededeqegggegggggrgggjijgjijijijijsjllllllllltltlununununuAuBy#",
    "..fgfefgfgfgghggghihihihijklijklklklllkllmnmnmnmnununuxunuxBxBz#",
    "..efeqegegegggggjgrgjgjgjijijsjljsjljljltlllululununununuAuBuBy#",
    "..fefgfgfgghghghihghihijkjkjklkjklkmkllmlmlmnmnuxmnuxuxuxBxBxBz#",
    "..eqegggegggggrgggjijijijijijkjsjlllllllllultlununununuAuBBAuBy#",
    "..fgfgfgghghghihihihijklijklklkllllllmnmnmnmnununuxBxuxBBBxBBBz#",
    "..egegegggggjgrgjgjgjijijsjljljllljltltlululununununuAuBuBuBBBy#",
    "..fgfgghghghihihihijkjkjklklklkmkllmnmlmnmnuxunuxuxuxBxBxBBCBCz#",
    "..ggegggggjgggjijijijijsjkjsjlllllllllultlununununuAuBBBuBBBBBD#",
    "..fgghghghihijihijklijklklkllllllmnmnmnmnununuxBxBxBBBxBBCEBBCz#",
    "..egggggjgrgjijgjsjijsjljljllllltltlululununuAunuAuBuBuBBBBBFBG#",
    "..ghghghihihkhijkjkjklklkllmkllmnmlmnmnuxunuxuxuxBxBxBBCBCBCECD#",
    "..ggggjgrgjijijijijsjllsjllllltllluntlununununuAuBBBBBBBBBFBFBH#",
    "..ihghihijijijklkjklklkllmlllmnmnmnmnununuxBxBxBBBxBBCEBECECEIJ#",
    "..ggjgjgjijijsjijsjljljllllltltlululununuAuBuAuBuBuBFBBBIBFBIEH#",
    "..ghihijkhijkjkjklklkllmlmlmnmlmnmnuxunuxBxuxBxBxBBCBCBCECEIECH#",
    "..jgrgjijijijijsjllljllllltlllununununununuAuBBBBBBBBBFBFBIEIEK#",
    "..ihijkjijklkjklklkllmlllmnmnmnmnununuxBxBxBBBBBBCEBECECEIEIEIJ#",
    "..jgjijijsjijsjljljllllltltlululununuAuBuBuBBBuBFBFBIBIBIEIBIEK#",
    "..ijkjijkjkjklklkllmlmlmnmnmnmnuxunuxBxBxBxBxBBCECBCECEIECEILIJ#",
    "..jijijijijsjllljllllltlllununununuAunuAuBBBBBBBBBFBFBIEIEIEIEK#",
    "..kjijklkjklllkllmlllmnmnunmnuxunuxBxBxBBBBBBCECECECEIEIEILMEMJ#",
    "..jijsjkjsjljljlllllultlunulununuAuBuBuBBBBBFBFBIBIBIEIBINIEINK#",
    "..ijkjkjklklkllmlmlmnmnmnmnuxuxuxBxBxBBBxBBCECBCECEIECEILILILMJ#",
    "..jijijsjllljllllltltlununununuAuBBAuBBBBBFBBBIEFBIEIEIEIEINIMK#",
    "..klklklllkllmnmlmnmnununuxunuxBxBxBBBBBBCECECECEIEIEILMEMLMMMJ#",
    "..jkjsjljljlllllululununununuAuBuBuBBBBBFBFBIBIBIEIBINININIMIMK#",
    "..kjklklkllmlmlmnmnunmnuxuxuxBxBxBBCBCBCECBCECEIECEILMLILMLMLMJ#",
    "..jsjlllllllllultlununununuAuBBAuBBBBBFBBBIEIEIEIEIEIEINIMMMMMO#",
    "..klllkllmnmnmnmnununuxunuxBxBxBBBBBBCECECECEIEIEILMLMLMMMMMMPQ#",
    "..jllljltlllululununununuAuBuBuBBBBBFBFBIBIBIEIEINININIMMMIMRMS#",
    "..kmkllmnmlmnmnuxunuxuxuxBxBxBBCBCBCECECECEIECEILMLMLMLMLMMPTPQ#",
    "..llllllllultlununununuAuBBAuBBBBBFBBBIEIEIEIEINIEINIMMMMMMMMMU#",
    "..lllmnmnmnmnununuxBxuxBBBxBBCBBBCECEIECEIEIEILMLMLMMMMMMPTPTPV#",
    "..lltltlululununununuAuBuBuBBBBBFBFBIEIBIEIEINININIMMMMMRMRMaMU#",
    "..lmnmlmnmnuxunuxuxuxBxBxBBCBCBCECECECEILILILMLMLMMMLMMPTPMPTPO#",
    "..llllultlununununuAuBBBuBBBBBFBFBIEIEIEIEININMNIMMMMMRMMMRTRMU#",
    "..nmnmnmnununuxBxBxBBBxBBCEBBCECEIEIEIEIEILMLMLMMMMMMPTPTPTPTaV#",
    "..tlululununuAunuAuBuBuBBBBBFBFBIEIBIEIEINIMIMIMMMMMRMRMaMaMaTU#",
    "..lmnmnuxunuxBxuxBxBxBBCBCBCECEIECEILILILMLMLMMMMMMPTPMPTPTaTPV#",
    "..unulununununuAuBBBBBBBBBFBFBIEIEIEIEININMNIMMMMMRMMMRTRMaTaTU#",
    "..nmnununuxBxBxBBBxBBCEBECECEIEIEILIEILMLMLMMMMMMPTPTPTPTaTaTaV#",
    "..ulununuAuBuAuBBBuBFBBBIBFBIEIBIEIEINIMIMIMMMMMRMRMaMaMaTaTaWU#",
    "..nuxunuxBxBxBxBxBBCECBCECEIECEILILILMLMLMMMMMMPTPTPTPTaTPTaovV#",
    "..ununununuAuBBBBBBBBBFBFBIEIEIEIEINIMMNIMMMMMRMMMaTRMaTaTaWaTU#",
    "..nunuxBxBxBBBBBBCECECECEIEIEILMEILMMMLMMMMMMPTPTaTPTaTaTaovovV#",
    "..unuAuBuBuBBBBBFBFBIBIBIEIBIEIEINIMIMIMMMMMRMRMaTaMaTaTaWaWaWU#",
    "..nuxBxBxBxBxBBCECBCECEIECEILILILMLMLMMPMMMPTPTPTPTaTaTaovovovX#",
    "..uAunuAuBBBBBBBBBIBFBIEIEIEIEINIMMMIMMMMMRMRMaTRTaTaTaWaWvWavY#",
    "..owvwvwvwzwzyzyzGzDzHzHDHZHDHJHJKJKJSJOQOQOQOVOVOVOVUVXVYVYXYX#",
    ".###############################################################" };
// iconWindow
// file gui.c line 84
unsigned long int iconWindow;
// mainDisplay
// file gui.c line 81
struct _XDisplay *mainDisplay = ((struct _XDisplay *)NULL);
// mainGC
// file gui.c line 87
struct _XGC *mainGC;
// mainGCV
// file gui.c line 86
struct anonymous mainGCV;
// mainWindow
// file gui.c line 83
unsigned long int mainWindow;
// mbox
// file globals.c line 21
struct mbox_struct *mbox = (struct mbox_struct *)(void *)0;
// md5_lock
// file globals.c line 54
union anonymous$8 md5_lock;
// need_animation
// file gui.c line 73
signed int need_animation = 0;
// newmail
// file pixmaps/newmail.xpm line 2
static char *newmail[86l] = { "    48    48       37            1", ". c #9f9f9f", "# c #737373", "a c #adadad", "b c #949494", "c c #afafaf", "d c #a8a8a8", "e c #a6a6a6", "f c #a1a1a1", "g c #9a9a9a", "h c #989898", "i c #929292", "j c #aaaaaa", "k c #a3a3a3", "l c #9c9c9c", "m c #909090", "n c #8d8d8d", "o c #8a8a8a", "p c #888888", "q c #838383", "r c #868686", "s c #818181", "t c #7b7b7b", "u c #7e7e7e", "v c #797979", "w c #767676", "x c #ffffff", "y c #6f6f6f", "z c #636363", "A c #cccccc", "B c #dedede", "C c #424242", "D c #bdbdbd", "E c #212121", "F c #000000", "G c #8c8c8c", "H c #ff0000", "I c #00ff00", "acacadadadaeaedefedefeff.fff.xGf.g.g.gghghghihih",
    "cccjcacdcdddddddddfdfdffffffxBBGfgggfgggggbgggii",
    "acadadaddedddefefefeff.fff.xBIBBGg.gghihghihiiii",
    "cjcdcdcdddddkdkdfdfdffffflxBabaBBGfgggggigigiiii",
    "adadaddeaedefedefeff.fff.xBIbIbIBBGhghghihihihii",
    "cdddcdddddkdddfffdffffffxBHBabaBBBBGggbgbgiiiiii",
    "adaddedddefefefeff.gff.xBHBBbIBBBBBBGhihiiiiiimi",
    "cdcdddddfdkdfdfdffffflxBHBBHBBBBBBBBBGigiiiiiiii",
    "addededefedefeff.f.f.xBBBBHBBBBBBBBBBBGimhiimimi",
    "cdddddkdddffffffffffxBBBBHBBBBBBBBBBBBBGiiiiiiin",
    "dededefefefeff.gff.xBBBBBBBBBBBBBBBBBBBBGimomimo",
    "ddddfdBBBBBBBBBBBBxBBBBBBBBBBBBBBBBBBBBBBGiiinio",
    "dedefeBbbbbbbbbbbxBBBBBBBBBBBBBBBBBBBBBBBBmimomo",
    "ddfddBBBBBBBBBBBxBBBBBBBBBBBBBBBBBBBBBBBBBBGiooo",
    "defefBaaaaaaaaaxBBBBBBBBBBBBBBBBBBBBBBBBBBDaoomo",
    "fdkdxBBBBBBBBBxBBBBBBBBBBBBBBBBBBBBBBBBBBDaoioio",
    "fefexDDDDDDDDxBBBBBBBBBBBBBBBBBBBBBBBBBBDaGomoop",
    "kdffxDbDbbbDxBBBBBBBBBBBBBBBBaBBBBBBBBBDazGooooo",
    "ffffxDDDDDDxBBBBBBBBBBBBBBBBa#BBBBBBBBDaz#Goopqo",
    "ffffxDbbDDxBBBBBBBBBBBBBBBBa#BBaBBBBBDaz#bGorooo",
    ".effxDDDDxBBBBBBBBBBBBBBBBa#BBa#BBBBDaz#DbGpopop",
    "ffffxDDDxBBBBBBBBBBBBBBBBB#BBa#BBBBDaz#DabGoooro",
    "ff.gxDDxBB#B#BBBBBBBBBBBaBBBa#BBBBDaz#DaDbGoqpqp",
    "flffxBxBB#BBBBBBBBBBBBBa#BBB#BBBBDaz#DaDabGoqoqo",
    ".f.fBbBB#B#BBBBBBBBBBBa#BBBBBBBBDaz#DaDaDbGpqpqq",
    "fffbBabBB#BBBBBBBBBBBB#BBaBBBBBDaz#DaDaDaz#Groqq",
    ".fx#BDabBBBBBBBBBBBBBBBBa#BBBBDaz#DaDaDaDzbDGqqq",
    "fx#zBDDabBBBBBBBBBBBBBBB#BBBBDaz#DaDaDaDazFbDGqo",
    "xDbaabbbbbbDDBBBBBBBBBBBBBBBDaz#DaDa#########DAq",
    "xDBBBBBBBBBBaDBBBBBBBBBBBBBDaz#DaDaBBBBBBBBBBCAq",
    "xDDabbbbbbbbzDDBBBBBBBBBBBDaz#DaDaDBbbbbbb#zzCAt",
    "xDaaabbbbbbbzDDDBBBBBBBBBDaz#DaDaDaBbbbbb###zCAu",
    "xDDabbbbbbbbzbDDBBBBBBBBDaz#DaDaDaaBbbbbbb#zzCAq",
    "xDaaabbbbbbbzEbDDDDDDDDDaz#DaDaDaDaBbbbbb###zCAu",
    "xDDabbbbbbbbbzEbaaaaaaDazzzzz#####Bbbbbbbb#zzCAt",
    "xDaaabbbbbbbbbzzzzzzzzzzzzzzzzzzzBbbbbbbb###zCAt",
    "xDDabbbbbbbbbbBBBBBBBBBBBBBBBBBBBbbbbbbbbb#zzCAt",
    "xDaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb###zCAt",
    "xDDabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb#zzCAt",
    "xDaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb###zCAt",
    "DDDb#######################################zzCAv",
    "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzAt",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyv",
    "iiiiiniiinioioiooooororoqqqoqqqqquqtqtqtttttwtwt",
    "miiimomimomomoopopopqpqqqpqqsqsqstststtttttv#vtv",
    "iiiiiiiniooooooooororoqqqqqqqqququtuqtttttwtttw#",
    "iimomomooomoopqoqpqpqqqqqqsqqqstststtttttv#v#v#v",
    "inioinioooioroooqoroqqqoqqqqquqtqtqtttttwtwt#t#t" };
// newmail_s
// file pixmaps/newmail_s.xpm line 2
static char *newmail_s[64l] = { "    48    48       15            1", ". c None", "# c #ffffff", "a c #636363", "b c #cccccc", "c c #737373", "d c #dedede", "e c #424242", "f c #adadad", "g c #949494", "h c #bdbdbd", "i c #212121", "j c #000000", "k c #8c8c8c", "l c #ff0000", "m c #00ff00", ".............................#k.................",
    "............................#ddk................",
    "...........................#dmddk...............",
    "..........................#dfgfddk..............",
    ".........................#dmgmgmddk.............",
    "........................#dldfgfddddk............",
    ".......................#dlddgmddddddk...........",
    "......................#dlddldddddddddk..........",
    ".....................#ddddldddddddddddk.........",
    "....................#ddddldddddddddddddk........",
    "...................#ddddddddddddddddddddk.......",
    "......dddddddddddd#ddddddddddddddddddddddk......",
    "......dgggggggggg#ddddddddddddddddddddddddk.....",
    ".....ddddddddddd#ddddddddddddddddddddddddddk....",
    ".....dfffffffff#ddddddddddddddddddddddddddhfk...",
    "....#ddddddddd#ddddddddddddddddddddddddddhfk....",
    "....#hhhhhhhh#ddddddddddddddddddddddddddhfk.....",
    "....#hghgggh#ddddddddddddddddfdddddddddhfak.....",
    "....#hhhhhh#ddddddddddddddddfcddddddddhfack.....",
    "....#hgghh#ddddddddddddddddfcddfdddddhfacgk.....",
    "....#hhhh#ddddddddddddddddfcddfcddddhfachgk.....",
    "....#hhh#dddddddddddddddddcddfcddddhfachfgk.....",
    "....#hh#ddcdcdddddddddddfdddfcddddhfachfhgk.....",
    "....#d#ddcdddddddddddddfcdddcddddhfachfhfgk.....",
    "....dgddcdcdddddddddddfcddddddddhfachfhfhgk.....",
    "...gdfgddcddddddddddddcddfdddddhfachfhfhfack....",
    "..#cdhfgddddddddddddddddfcddddhfachfhfhfhaghk...",
    ".#cadhhfgdddddddddddddddcddddhfachfhfhfhfajghk..",
    "#hgffgggggghhdddddddddddddddhfachfhfccccccccchb.",
    "#hddddddddddfhdddddddddddddhfachfhfddddddddddeb.",
    "#hhfggggggggahhdddddddddddhfachfhfhdggggggcaaeb.",
    "#hfffgggggggahhhdddddddddhfachfhfhfdgggggcccaeb.",
    "#hhfggggggggaghhddddddddhfachfhfhffdggggggcaaeb.",
    "#hfffgggggggaighhhhhhhhhfachfhfhfhfdgggggcccaeb.",
    "#hhfgggggggggaigffffffhfaaaaacccccdgggggggcaaeb.",
    "#hfffgggggggggaaaaaaaaaaaaaaaaaaadgggggggcccaeb.",
    "#hhfggggggggggdddddddddddddddddddgggggggggcaaeb.",
    "#hfffggggggggggggggggggggggggggggggggggggcccaeb.",
    "#hhfggggggggggggggggggggggggggggggggggggggcaaeb.",
    "#hfffggggggggggggggggggggggggggggggggggggcccaeb.",
    "hhhgcccccccccccccccccccccccccccccccccccccccaaeb.",
    "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab.",
    "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb..",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................" };
// nomail
// file pixmaps/nomail.xpm line 2
static char *nomail[82l] = { "    48    48       33            1", ". c #9f9f9f", "# c #737373", "a c #adadad", "b c #949494", "c c #afafaf", "d c #a8a8a8", "e c #a6a6a6", "f c #a1a1a1", "g c #9a9a9a", "h c #989898", "i c #929292", "j c #aaaaaa", "k c #a3a3a3", "l c #9c9c9c", "m c #909090", "n c #8d8d8d", "o c #8a8a8a", "p c #888888", "q c #838383", "r c #868686", "s c #818181", "t c #7b7b7b", "u c #7e7e7e", "v c #797979", "w c #767676", "x c #ffffff", "y c #6f6f6f", "z c #636363", "A c #cccccc", "B c #dedede", "C c #424242", "D c #bdbdbd", "E c #8c8c8c", "acacadadadaeaedefedefeff.fff.f.f.g.g.gghghghihih",
    "cccjcacdcdddddddddfdfdffffffffflfgggfgggggbgggii",
    "acadadaddedddefefefeff.fff.g.g.ggg.gghihghihiiii",
    "cjcdcdcdddddkdkdfdfdffffflf.flfgfgfgggggigigiiii",
    "adadaddeaedefedefeff.fff.f.f.g.g.gghghghihihihii",
    "cdddcdddddkdddfffdffffffffflfgggggggggbgbgiiiiii",
    "adaddedddefefefeff.gff.g.g.ggg.gghihihihiiiiiimi",
    "cdcdddddfdkdfdfdffffflfgflfgfgfgbgggigigiiiiiiii",
    "addededefedefeff.f.f.g.f.g.h.gghghghihiimhiimimi",
    "cdddddkdddfffffffffff.flfgggggggggigbgiiiiiiiiin",
    "dededefefefeff.gff.g.g.gggggghihihihiiiiiimomimo",
    "ddddfdkdfdfdffffflfgfgfgggfgbgbgigigiiiiiiiiinio",
    "dedefefefeff.f.f.g.g.g.h.gghihghihiimiiimimimomo",
    "ddfdddffffffffflf.flfgggggggggigbgiiiiiiiiiniooo",
    "defefffeff.gff.g.g.gggggghihihihiiiiiimomomooomo",
    "fdkdfffdflffflfgfgfgggggbgbgigigiiiiiniiinioioio",
    "fefe.eff.f.f.g.g.ggh.gghihghihiimiiimimimomomoop",
    "kdffffffffflfgglfgggggbgggiibgiiiiiiiiiniooooooo",
    "ffffff.g.f.g.g.gghggghihihihiiiiiimomomooomoopqo",
    "ffffflffflfgfgfgggggbgbgigigiiiiinioinioioiorooo",
    ".eff.f.fEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEomoopopop",
    "fffffffxxxxxxxxxxBxBxBxBxBxBBBBBBBBBBBBEooooooro",
    "ff.g.fxbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaEpqoqpqp",
    "flfffxDbbbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaDaEroqoqo",
    ".f.fxD#bbbbaaaaaaaaaaaaaaaaaaaaaaaaaaaabDaEpqpqq",
    "fffxD##bbbbbbaaaaaaaaaaaaaaaaaaaaaaaaaabbDaEroqq",
    ".fxD###bbbbbbbbaaaaaaaaaaaaaaaaaaaaaaaabbbDaEqqq",
    "fxa####bbbbbbbbbaaaaaaaaaaaaaaaaaaaaaaabbbbDaEqo",
    "xBaaaaaaaabbbbbbbbaaaaaaaaaaaaaaaaaa#########bAq",
    "xBaDDDDDDD#bbbbbbbbaaaaaaaaaaaaaaaa#DDDDDDDDDCAq",
    "xBBabbbbbbb#DDDDDDDBBBBBBBBBBBBBBB#Dbbbbbb#zzCAt",
    "xBaaabbbbbb#DDDDDDDBBBBBBBBBBBBBBB#Dbbbbb###zCAu",
    "xBBabbbbbbb#DDDDDDBBBBBBBBBBBBBBBB#Dbbbbbb#zzCAq",
    "xBaaabbbbbb#DDDDDDBBBBBBBBBBBBBBBB#Dbbbbb###zCAu",
    "xBBabbbbbbbb#DDDDBBBBBBBBBBBBBBBB#Dbbbbbbb#zzCAt",
    "xBaaabbbbbbbb####################Dbbbbbbb###zCAt",
    "xBBabbbbbbbbbbDDDDDDDDDDDDDDDDDDDbbbbbbbbb#zzCAt",
    "xBaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb###zCAt",
    "xBBabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb#zzCAt",
    "xBaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb###zCAt",
    "Daa########################################zzCAv",
    "azzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzAt",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyv",
    "iiiiiniiinioioiooooororoqqqoqqqqquqtqtqtttttwtwt",
    "miiimomimomomoopopopqpqqqpqqsqsqstststtttttv#vtv",
    "iiiiiiiniooooooooororoqqqqqqqqququtuqtttttwtttw#",
    "iimomomooomoopqoqpqpqqqqqqsqqqstststtttttv#v#v#v",
    "inioinioooioroooqoroqqqoqqqqquqtqtqtttttwtwt#t#t" };
// nomail_s
// file pixmaps/nomail_s.xpm line 2
static char *nomail_s[60l] = { "    48    48       11            1", ". c None", "# c #ffffff", "a c #636363", "b c #cccccc", "c c #737373", "d c #dedede", "e c #424242", "f c #adadad", "g c #949494", "h c #bdbdbd", "i c #8c8c8c", "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "........iiiiiiiiiiiiiiiiiiiiiiiiiiiiiii.........",
    ".......##########d#d#d#d#d#ddddddddddddi........",
    "......#gffffffffffffffffffffffffffffffffi.......",
    ".....#hgggfffffffffffffffffffffffffffffhfi......",
    "....#hcggggffffffffffffffffffffffffffffghfi.....",
    "...#hccggggggffffffffffffffffffffffffffgghfi....",
    "..#hcccggggggggffffffffffffffffffffffffggghfi...",
    ".#fccccgggggggggfffffffffffffffffffffffgggghfi..",
    "#dffffffffggggggggffffffffffffffffffcccccccccgb.",
    "#dfhhhhhhhcggggggggffffffffffffffffchhhhhhhhheb.",
    "#ddfgggggggchhhhhhhdddddddddddddddchggggggcaaeb.",
    "#dfffggggggchhhhhhhdddddddddddddddchgggggcccaeb.",
    "#ddfgggggggchhhhhhddddddddddddddddchggggggcaaeb.",
    "#dfffggggggchhhhhhddddddddddddddddchgggggcccaeb.",
    "#ddfggggggggchhhhddddddddddddddddchgggggggcaaeb.",
    "#dfffggggggggcccccccccccccccccccchgggggggcccaeb.",
    "#ddfgggggggggghhhhhhhhhhhhhhhhhhhgggggggggcaaeb.",
    "#dfffggggggggggggggggggggggggggggggggggggcccaeb.",
    "#ddfggggggggggggggggggggggggggggggggggggggcaaeb.",
    "#dfffggggggggggggggggggggggggggggggggggggcccaeb.",
    "hffccccccccccccccccccccccccccccccccccccccccaaeb.",
    "faaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab.",
    "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb..",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................" };
// oldmail
// file pixmaps/oldmail.xpm line 2
static char *oldmail[85l] = { "    48    48       36            1", ". c #9f9f9f", "# c #737373", "a c #adadad", "b c #949494", "c c #afafaf", "d c #a8a8a8", "e c #a6a6a6", "f c #a1a1a1", "g c #9a9a9a", "h c #989898", "i c #929292", "j c #aaaaaa", "k c #a3a3a3", "l c #9c9c9c", "m c #909090", "n c #8d8d8d", "o c #8a8a8a", "p c #888888", "q c #838383", "r c #868686", "s c #818181", "t c #7b7b7b", "u c #7e7e7e", "v c #797979", "w c #767676", "x c #ffffff", "y c #6f6f6f", "z c #636363", "A c #cccccc", "B c #dedede", "C c #424242", "D c #bdbdbd", "E c #8c8c8c", "F c #f81440", "G c #3cf834", "H c #7d7d7d", "acacadadadaeaedefedefeff.fff.f.f.g.g.gghghghihih",
    "cccjcacdcdddddddddfdfdffffffffflfgggfgggggbgggii",
    "acadadaddedddefefefeff.fff.g.g.ggg.gghihghihiiii",
    "cjcdcdcdddddkdkdfdfdffffflf.flfgfgfgggggigigiiii",
    "adadaddeaedefedefeff.fff.f.f.g.g.gghghghihihihii",
    "cdddcdddddkdddfffdffffffffflfgggggggggbgbgiiiiii",
    "adaddedddefefefeff.gff.g.g.ggg.gghihihihiiiiiimi",
    "cdcdddddfdkdfdfdffffflfgflfgfgfgbgggigigiiiiiiii",
    "addededefedefeff.f.f.g.f.g.h.gghghghihiimhiimimi",
    "cdddddkdddfffffffffff.flfgggggggggigbgiiiiiiiiin",
    "dededefefefeff.gff.g.g.gggggghihihihiiiiiimomimo",
    "ddddfdbbbzbzbzbzbzbzbzzrzrzrzrzrzrzrrrrrrHiiinio",
    "dedefebBBBBBBBBBBBBBBBBBBBBBDBDBDDDDDDDDDrmimomo",
    "ddfddbbBaaaabbbbbbbbbbbbbb#########z#z#z#Hrniooo",
    "defefbBBBBBBBBBBBBBBBBBBBBDBDBDDDDDDDDDDDDHooomo",
    "fdkdbzBabbbbbbbbbbbbbb#############z#z#z#zroioio",
    "fefebxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxzomoop",
    "kdffbxBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBDBDBBzooooo",
    "ffffbxB##B#BBBBBBBBBBBBBBBBBBBBF#BBF#GaGDBzoopqo",
    "ffffbxBBBBBBBBBBBBBBBBBBBBBBBBBBBF#BD#G#BBzorooo",
    ".effzxB###BBBBBBBBBBBBBBBBBBBBBF#BBF##G#DBzpopop",
    "ffffbxBBBBBBBBBBBBBBBBBBBBBBBBBBBF#BDGaGBBzoooro",
    "ff.gzxBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBzoqpqp",
    "flffbxBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBzoqoqo",
    ".f.fzxBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBDB#pqpqq",
    "fffxbxBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBDzEroqq",
    ".fxD#xBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBDBDBzaEqqq",
    "fxa#zxBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBDDDzDaEqo",
    "xBaaaaaaaabbbBBBBBBBBBBBBBBBBBBBBBaa#########bAq",
    "xBaDDDDDDD#bbDBBB##B####B##BBBBBBBa#DDDDDDDDDCAq",
    "xBBabbbbbbb#DDDBBBBBBBBBBBBBBBBBBD#Dbbbbbb#zzCAt",
    "xBaaabbbbbb#DaDBB#####B####BBBBBBB#Dbbbbb###zCAu",
    "xBBabbbbbbb#DDaBBBBBBBBBBBBBBBDDBD#Dbbbbbb#zzCAq",
    "xBaaabbbbbb#DaDaDDDDDDDDDDDDDDDDDD#Dbbbbb###zCAu",
    "xBBabbbbbbbb#aaaaaaaaaaaaaaaaaaaa#Dbbbbbbb#zzCAt",
    "xBaaabbbbbbbb####################Dbbbbbbb###zCAt",
    "xBBabbbbbbbbbbDDDDDDDDDDDDDDDDDDDbbbbbbbbb#zzCAt",
    "xBaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb###zCAt",
    "xBBabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb#zzCAt",
    "xBaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb###zCAt",
    "Daa########################################zzCAv",
    "azzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzAt",
    "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyv",
    "iiiiiniiinioioiooooororoqqqoqqqqquqtqtqtttttwtwt",
    "miiimomimomomoopopopqpqqqpqqsqsqstststtttttv#vtv",
    "iiiiiiiniooooooooororoqqqqqqqqququtuqtttttwtttw#",
    "iimomomooomoopqoqpqpqqqqqqsqqqstststtttttv#v#v#v",
    "inioinioooioroooqoroqqqoqqqqquqtqtqtttttwtwt#t#t" };
// oldmail_s
// file pixmaps/oldmail_s.xpm line 2
static char *oldmail_s[64l] = { "    48    48       15            1", ". c None", "# c #ffffff", "a c #636363", "b c #cccccc", "c c #737373", "d c #dedede", "e c #424242", "f c #adadad", "g c #949494", "h c #bdbdbd", "i c #8c8c8c", "j c #868686", "k c #f81440", "l c #3cf834", "m c #7d7d7d", "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "......gggagagagagagagaajajajajajajajjjjjjm......",
    "......gdddddddddddddddddddddhdhdhhhhhhhhhj......",
    ".....ggdffffggggggggggggggcccccccccacacacmj.....",
    ".....gddddddddddddddddddddhdhdhhhhhhhhhhhhm.....",
    "....gadfggggggggggggggcccccccccccccacacacaj.....",
    "....g#####################################a.....",
    "....g#dddddddddddddddddddddddddddddddhdhdda.....",
    "....g#dccdcddddddddddddddddddddkcddkclflhda.....",
    "....g#dddddddddddddddddddddddddddkcdhclcdda.....",
    "....a#dcccdddddddddddddddddddddkcddkcclchda.....",
    "....g#dddddddddddddddddddddddddddkcdhlfldda.....",
    "....a#dddddddddddddddddddddddddddddddddddda.....",
    "....g#dddddddddddddddddddddddddddddddddddda.....",
    "....a#ddddddddddddddddddddddddddddddddddhdc.....",
    "...#g#dddddddddddddddddddddddddddddddddddhai....",
    "..#hc#ddddddddddddddddddddddddddddddddhdhdafi...",
    ".#fca#dddddddddddddddddddddddddddddddddhhhahfi..",
    "#dffffffffgggdddddddddddddddddddddffcccccccccgb.",
    "#dfhhhhhhhcgghdddccdccccdccdddddddfchhhhhhhhheb.",
    "#ddfgggggggchhhddddddddddddddddddhchggggggcaaeb.",
    "#dfffggggggchfhddcccccdccccdddddddchgggggcccaeb.",
    "#ddfgggggggchhfdddddddddddddddhhdhchggggggcaaeb.",
    "#dfffggggggchfhfhhhhhhhhhhhhhhhhhhchgggggcccaeb.",
    "#ddfggggggggcffffffffffffffffffffchgggggggcaaeb.",
    "#dfffggggggggcccccccccccccccccccchgggggggcccaeb.",
    "#ddfgggggggggghhhhhhhhhhhhhhhhhhhgggggggggcaaeb.",
    "#dfffggggggggggggggggggggggggggggggggggggcccaeb.",
    "#ddfggggggggggggggggggggggggggggggggggggggcaaeb.",
    "#dfffggggggggggggggggggggggggggggggggggggcccaeb.",
    "hffccccccccccccccccccccccccccccccccccccccccaaeb.",
    "faaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab.",
    "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb..",
    "................................................",
    "................................................",
    "................................................",
    "................................................",
    "................................................" };
// passwords_in_config
// file asmail.c line 31
signed int passwords_in_config = 0;
// saved_status
// file gui.c line 72
signed int saved_status = 0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// tmp_char
// file x_color.c line 59
static char tmp_char[50l];
// update_count
// file globals.c line 25
signed int update_count = 0;
// update_cv
// file globals.c line 24
union anonymous$7 update_cv;
// update_lock
// file globals.c line 23
union anonymous$8 update_lock;
// winsize
// file gui.c line 101
struct anonymous$12 winsize = { .x=(signed short int)64, .y=(signed short int)64 };
// wm_delete_window
// file gui.c line 88
unsigned long int wm_delete_window;
// wm_protocols
// file gui.c line 89
unsigned long int wm_protocols;
// x11_mutex
// file gui.c line 78
union anonymous$8 x11_mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// x11_set
// file globals.c line 19
struct x11_set_struct x11_set;

// ButtonHandler
// file gui.c line 426
void ButtonHandler(union _XEvent *E)
{
  if(E->xbutton.button == 1u)
  {
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(x11_set.on_left);
    if(!(return_value_strlen$1 == 0ul))
      system(x11_set.on_left);

  }

  else
    if(E->xbutton.button == 2u)
    {
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(x11_set.on_middle);
      if(!(return_value_strlen$2 == 0ul))
        system(x11_set.on_middle);

    }

    else
      if(E->xbutton.button == 3u)
      {
        unsigned long int return_value_strlen$3;
        return_value_strlen$3=strlen(x11_set.on_right);
        if(!(return_value_strlen$3 == 0ul))
          system(x11_set.on_right);

      }

}

// DarkenCharColor
// file x_color.c line 64
char * DarkenCharColor(char *ColorName, float rate, struct _XDisplay *disp, unsigned long int win)
{
  struct anonymous$5 tmp_color;
  tmp_color=ParseColor(ColorName, disp, win);
  tmp_color.red = (unsigned short int)((float)((signed int)tmp_color.red / 257) / rate);
  tmp_color.green = (unsigned short int)((float)((signed int)tmp_color.green / 257) / rate);
  tmp_color.blue = (unsigned short int)((float)((signed int)tmp_color.blue / 257) / rate);
  sprintf(tmp_char, "#%.2x%.2x%.2x", (signed int)tmp_color.red, (signed int)tmp_color.green, (signed int)tmp_color.blue);
  return tmp_char;
}

// DarkenColor
// file x_color.c line 90
unsigned long int DarkenColor(char *ColorName, float rate, struct _XDisplay *disp, unsigned long int win)
{
  char *return_value_DarkenCharColor$1;
  return_value_DarkenCharColor$1=DarkenCharColor(ColorName, rate, disp, win);
  unsigned long int return_value_GetColor$2;
  return_value_GetColor$2=GetColor(return_value_DarkenCharColor$1, disp, win);
  return return_value_GetColor$2;
}

// Decode
// file md5c.c line 296
static void Decode(unsigned int *output, unsigned char *input, unsigned int len)
{
  unsigned int i;
  unsigned int j;
  i = (unsigned int)0;
  j = (unsigned int)0;
  for( ; !(j >= len); j = j + (unsigned int)4)
  {
    output[(signed long int)i] = (unsigned int)input[(signed long int)j] | (unsigned int)input[(signed long int)(j + (unsigned int)1)] << 8 | (unsigned int)input[(signed long int)(j + (unsigned int)2)] << 16 | (unsigned int)input[(signed long int)(j + (unsigned int)3)] << 24;
    i = i + 1u;
  }
}

// Encode
// file md5c.c line 278
static void Encode(unsigned char *output, unsigned int *input, unsigned int len)
{
  unsigned int i;
  unsigned int j;
  i = (unsigned int)0;
  j = (unsigned int)0;
  for( ; !(j >= len); j = j + (unsigned int)4)
  {
    output[(signed long int)j] = (unsigned char)(input[(signed long int)i] & (unsigned int)0xff);
    output[(signed long int)(j + (unsigned int)1)] = (unsigned char)(input[(signed long int)i] >> 8 & (unsigned int)0xff);
    output[(signed long int)(j + (unsigned int)2)] = (unsigned char)(input[(signed long int)i] >> 16 & (unsigned int)0xff);
    output[(signed long int)(j + (unsigned int)3)] = (unsigned char)(input[(signed long int)i] >> 24 & (unsigned int)0xff);
    i = i + 1u;
  }
}

// GetColor
// file x_color.h line 18
unsigned long int GetColor(char *ColorName, struct _XDisplay *disp, unsigned long int win)
{
  struct anonymous$5 Color;
  struct anonymous$10 Attributes;
  XGetWindowAttributes(disp, win, &Attributes);
  Color.pixel = (unsigned long int)0;
  signed int return_value_XParseColor$2;
  return_value_XParseColor$2=XParseColor(disp, Attributes.colormap, ColorName, &Color);
  signed int return_value_XAllocColor$1;
  if(return_value_XParseColor$2 == 0)
    printf("asmail: can't parse %s\n", ColorName);

  else
  {
    return_value_XAllocColor$1=XAllocColor(disp, Attributes.colormap, &Color);
    if(return_value_XAllocColor$1 == 0)
      printf("asmail: can't allocate %s\n", ColorName);

  }
  return Color.pixel;
}

// GetXPM
// file gui.c line 151
struct XpmIcon * GetXPM(char **data)
{
  struct XpmIcon *icon;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct XpmIcon) /*248ul*/ );
  icon = (struct XpmIcon *)return_value_calloc$1;
  icon->attributes.valuemask = icon->attributes.valuemask | (unsigned long int)(1L << 12);
  icon->attributes.closeness = (unsigned int)40000;
  signed int return_value_XpmCreatePixmapFromData$2;
  return_value_XpmCreatePixmapFromData$2=XpmCreatePixmapFromData(mainDisplay, Root, data, &icon->pixmap, &icon->mask, &icon->attributes);
  XPMError(return_value_XpmCreatePixmapFromData$2, "built-in");
  icon->next = (struct XpmIcon *)icon;
  return icon;
}

// LightenCharColor
// file x_color.c line 99
char * LightenCharColor(char *ColorName, float rate, struct _XDisplay *disp, unsigned long int win)
{
  struct anonymous$5 tmp_color;
  tmp_color=ParseColor(ColorName, disp, win);
  tmp_color.red = (unsigned short int)((float)((signed int)tmp_color.red / 257) * rate);
  tmp_color.green = (unsigned short int)((float)((signed int)tmp_color.green / 257) * rate);
  tmp_color.blue = (unsigned short int)((float)((signed int)tmp_color.blue / 257) * rate);
  if((signed int)tmp_color.red >= 256)
    tmp_color.red = (unsigned short int)255;

  if((signed int)tmp_color.green >= 256)
    tmp_color.green = (unsigned short int)255;

  if((signed int)tmp_color.blue >= 256)
    tmp_color.blue = (unsigned short int)255;

  sprintf(tmp_char, "#%.2x%.2x%.2x", (signed int)tmp_color.red, (signed int)tmp_color.green, (signed int)tmp_color.blue);
  return tmp_char;
}

// LightenColor
// file x_color.c line 131
unsigned long int LightenColor(char *ColorName, float rate, struct _XDisplay *disp, unsigned long int win)
{
  char *return_value_LightenCharColor$1;
  return_value_LightenCharColor$1=LightenCharColor(ColorName, rate, disp, win);
  unsigned long int return_value_GetColor$2;
  return_value_GetColor$2=GetColor(return_value_LightenCharColor$1, disp, win);
  return return_value_GetColor$2;
}

// LoadXPM
// file gui.c line 130
void LoadXPM(struct pixfile *filelist, struct XpmIcon **destination)
{
  struct XpmIcon *icon;
  struct pixfile *file_ptr = filelist;
  while(!(file_ptr == ((struct pixfile *)NULL)))
  {
    void *return_value_calloc$1;
    return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct XpmIcon) /*248ul*/ );
    icon = (struct XpmIcon *)return_value_calloc$1;
    icon->attributes.valuemask = icon->attributes.valuemask | (unsigned long int)(1L << 12);
    icon->attributes.closeness = (unsigned int)40000;
    signed int return_value_XpmReadFileToPixmap$2;
    return_value_XpmReadFileToPixmap$2=XpmReadFileToPixmap(mainDisplay, Root, file_ptr->name, &icon->pixmap, &icon->mask, &icon->attributes);
    XPMError(return_value_XpmReadFileToPixmap$2, file_ptr->name);
    icon->next = *destination;
    *destination = icon;
    file_ptr = file_ptr->next;
  }
}

// MD5Final
// file md5.h line 61
void MD5Final(unsigned char *digest, struct anonymous$17 *context)
{
  unsigned char bits[8l];
  unsigned int index;
  unsigned int padLen;
  Encode(bits, context->count, (unsigned int)8);
  index = (unsigned int)(context->count[(signed long int)0] >> 3 & (unsigned int)0x3f);
  padLen = index < (unsigned int)56 ? (unsigned int)56 - index : (unsigned int)120 - index;
  MD5Update(context, PADDING, padLen);
  MD5Update(context, bits, (unsigned int)8);
  Encode(digest, context->state, (unsigned int)16);
  MD5_memset((unsigned char *)context, 0, (unsigned int)sizeof(struct anonymous$17) /*88ul*/ );
}

// MD5Init
// file md5.h line 58
void MD5Init(struct anonymous$17 *context)
{
  context->count[(signed long int)1] = (unsigned int)0;
  context->count[(signed long int)0] = context->count[(signed long int)1];
  context->state[(signed long int)0] = (unsigned int)0x67452301;
  context->state[(signed long int)1] = 0xefcdab89;
  context->state[(signed long int)2] = 0x98badcfe;
  context->state[(signed long int)3] = (unsigned int)0x10325476;
}

// MD5Transform
// file md5c.c line 185
static void MD5Transform(unsigned int *state, unsigned char *block)
{
  unsigned int a = state[(signed long int)0];
  unsigned int b = state[(signed long int)1];
  unsigned int c = state[(signed long int)2];
  unsigned int d = state[(signed long int)3];
  unsigned int x[16l];
  Decode(x, block, (unsigned int)64);
  a = a + (b & c | ~b & d) + x[(signed long int)0] + (unsigned int)0xd76aa478;
  a = a << 7 | a >> 32 - 7;
  a = a + b;
  d = d + (a & b | ~a & c) + x[(signed long int)1] + (unsigned int)0xe8c7b756;
  d = d << 12 | d >> 32 - 12;
  d = d + a;
  c = c + (d & a | ~d & b) + x[(signed long int)2] + (unsigned int)0x242070db;
  c = c << 17 | c >> 32 - 17;
  c = c + d;
  b = b + (c & d | ~c & a) + x[(signed long int)3] + (unsigned int)0xc1bdceee;
  b = b << 22 | b >> 32 - 22;
  b = b + c;
  a = a + (b & c | ~b & d) + x[(signed long int)4] + (unsigned int)0xf57c0faf;
  a = a << 7 | a >> 32 - 7;
  a = a + b;
  d = d + (a & b | ~a & c) + x[(signed long int)5] + (unsigned int)0x4787c62a;
  d = d << 12 | d >> 32 - 12;
  d = d + a;
  c = c + (d & a | ~d & b) + x[(signed long int)6] + (unsigned int)0xa8304613;
  c = c << 17 | c >> 32 - 17;
  c = c + d;
  b = b + (c & d | ~c & a) + x[(signed long int)7] + (unsigned int)0xfd469501;
  b = b << 22 | b >> 32 - 22;
  b = b + c;
  a = a + (b & c | ~b & d) + x[(signed long int)8] + (unsigned int)0x698098d8;
  a = a << 7 | a >> 32 - 7;
  a = a + b;
  d = d + (a & b | ~a & c) + x[(signed long int)9] + (unsigned int)0x8b44f7af;
  d = d << 12 | d >> 32 - 12;
  d = d + a;
  c = c + (d & a | ~d & b) + x[(signed long int)10] + (unsigned int)0xffff5bb1;
  c = c << 17 | c >> 32 - 17;
  c = c + d;
  b = b + (c & d | ~c & a) + x[(signed long int)11] + (unsigned int)0x895cd7be;
  b = b << 22 | b >> 32 - 22;
  b = b + c;
  a = a + (b & c | ~b & d) + x[(signed long int)12] + (unsigned int)0x6b901122;
  a = a << 7 | a >> 32 - 7;
  a = a + b;
  d = d + (a & b | ~a & c) + x[(signed long int)13] + (unsigned int)0xfd987193;
  d = d << 12 | d >> 32 - 12;
  d = d + a;
  c = c + (d & a | ~d & b) + x[(signed long int)14] + (unsigned int)0xa679438e;
  c = c << 17 | c >> 32 - 17;
  c = c + d;
  b = b + (c & d | ~c & a) + x[(signed long int)15] + (unsigned int)0x49b40821;
  b = b << 22 | b >> 32 - 22;
  b = b + c;
  a = a + (b & d | c & ~d) + x[(signed long int)1] + (unsigned int)0xf61e2562;
  a = a << 5 | a >> 32 - 5;
  a = a + b;
  d = d + (a & c | b & ~c) + x[(signed long int)6] + (unsigned int)0xc040b340;
  d = d << 9 | d >> 32 - 9;
  d = d + a;
  c = c + (d & b | a & ~b) + x[(signed long int)11] + (unsigned int)0x265e5a51;
  c = c << 14 | c >> 32 - 14;
  c = c + d;
  b = b + (c & a | d & ~a) + x[(signed long int)0] + (unsigned int)0xe9b6c7aa;
  b = b << 20 | b >> 32 - 20;
  b = b + c;
  a = a + (b & d | c & ~d) + x[(signed long int)5] + (unsigned int)0xd62f105d;
  a = a << 5 | a >> 32 - 5;
  a = a + b;
  d = d + (a & c | b & ~c) + x[(signed long int)10] + (unsigned int)0x2441453;
  d = d << 9 | d >> 32 - 9;
  d = d + a;
  c = c + (d & b | a & ~b) + x[(signed long int)15] + (unsigned int)0xd8a1e681;
  c = c << 14 | c >> 32 - 14;
  c = c + d;
  b = b + (c & a | d & ~a) + x[(signed long int)4] + (unsigned int)0xe7d3fbc8;
  b = b << 20 | b >> 32 - 20;
  b = b + c;
  a = a + (b & d | c & ~d) + x[(signed long int)9] + (unsigned int)0x21e1cde6;
  a = a << 5 | a >> 32 - 5;
  a = a + b;
  d = d + (a & c | b & ~c) + x[(signed long int)14] + (unsigned int)0xc33707d6;
  d = d << 9 | d >> 32 - 9;
  d = d + a;
  c = c + (d & b | a & ~b) + x[(signed long int)3] + (unsigned int)0xf4d50d87;
  c = c << 14 | c >> 32 - 14;
  c = c + d;
  b = b + (c & a | d & ~a) + x[(signed long int)8] + (unsigned int)0x455a14ed;
  b = b << 20 | b >> 32 - 20;
  b = b + c;
  a = a + (b & d | c & ~d) + x[(signed long int)13] + (unsigned int)0xa9e3e905;
  a = a << 5 | a >> 32 - 5;
  a = a + b;
  d = d + (a & c | b & ~c) + x[(signed long int)2] + (unsigned int)0xfcefa3f8;
  d = d << 9 | d >> 32 - 9;
  d = d + a;
  c = c + (d & b | a & ~b) + x[(signed long int)7] + (unsigned int)0x676f02d9;
  c = c << 14 | c >> 32 - 14;
  c = c + d;
  b = b + (c & a | d & ~a) + x[(signed long int)12] + (unsigned int)0x8d2a4c8a;
  b = b << 20 | b >> 32 - 20;
  b = b + c;
  a = a + (b ^ c ^ d) + x[(signed long int)5] + (unsigned int)0xfffa3942;
  a = a << 4 | a >> 32 - 4;
  a = a + b;
  d = d + (a ^ b ^ c) + x[(signed long int)8] + (unsigned int)0x8771f681;
  d = d << 11 | d >> 32 - 11;
  d = d + a;
  c = c + (d ^ a ^ b) + x[(signed long int)11] + (unsigned int)0x6d9d6122;
  c = c << 16 | c >> 32 - 16;
  c = c + d;
  b = b + (c ^ d ^ a) + x[(signed long int)14] + (unsigned int)0xfde5380c;
  b = b << 23 | b >> 32 - 23;
  b = b + c;
  a = a + (b ^ c ^ d) + x[(signed long int)1] + (unsigned int)0xa4beea44;
  a = a << 4 | a >> 32 - 4;
  a = a + b;
  d = d + (a ^ b ^ c) + x[(signed long int)4] + (unsigned int)0x4bdecfa9;
  d = d << 11 | d >> 32 - 11;
  d = d + a;
  c = c + (d ^ a ^ b) + x[(signed long int)7] + (unsigned int)0xf6bb4b60;
  c = c << 16 | c >> 32 - 16;
  c = c + d;
  b = b + (c ^ d ^ a) + x[(signed long int)10] + (unsigned int)0xbebfbc70;
  b = b << 23 | b >> 32 - 23;
  b = b + c;
  a = a + (b ^ c ^ d) + x[(signed long int)13] + (unsigned int)0x289b7ec6;
  a = a << 4 | a >> 32 - 4;
  a = a + b;
  d = d + (a ^ b ^ c) + x[(signed long int)0] + (unsigned int)0xeaa127fa;
  d = d << 11 | d >> 32 - 11;
  d = d + a;
  c = c + (d ^ a ^ b) + x[(signed long int)3] + (unsigned int)0xd4ef3085;
  c = c << 16 | c >> 32 - 16;
  c = c + d;
  b = b + (c ^ d ^ a) + x[(signed long int)6] + (unsigned int)0x4881d05;
  b = b << 23 | b >> 32 - 23;
  b = b + c;
  a = a + (b ^ c ^ d) + x[(signed long int)9] + (unsigned int)0xd9d4d039;
  a = a << 4 | a >> 32 - 4;
  a = a + b;
  d = d + (a ^ b ^ c) + x[(signed long int)12] + (unsigned int)0xe6db99e5;
  d = d << 11 | d >> 32 - 11;
  d = d + a;
  c = c + (d ^ a ^ b) + x[(signed long int)15] + (unsigned int)0x1fa27cf8;
  c = c << 16 | c >> 32 - 16;
  c = c + d;
  b = b + (c ^ d ^ a) + x[(signed long int)2] + (unsigned int)0xc4ac5665;
  b = b << 23 | b >> 32 - 23;
  b = b + c;
  a = a + (c ^ (b | ~d)) + x[(signed long int)0] + (unsigned int)0xf4292244;
  a = a << 6 | a >> 32 - 6;
  a = a + b;
  d = d + (b ^ (a | ~c)) + x[(signed long int)7] + (unsigned int)0x432aff97;
  d = d << 10 | d >> 32 - 10;
  d = d + a;
  c = c + (a ^ (d | ~b)) + x[(signed long int)14] + (unsigned int)0xab9423a7;
  c = c << 15 | c >> 32 - 15;
  c = c + d;
  b = b + (d ^ (c | ~a)) + x[(signed long int)5] + (unsigned int)0xfc93a039;
  b = b << 21 | b >> 32 - 21;
  b = b + c;
  a = a + (c ^ (b | ~d)) + x[(signed long int)12] + (unsigned int)0x655b59c3;
  a = a << 6 | a >> 32 - 6;
  a = a + b;
  d = d + (b ^ (a | ~c)) + x[(signed long int)3] + (unsigned int)0x8f0ccc92;
  d = d << 10 | d >> 32 - 10;
  d = d + a;
  c = c + (a ^ (d | ~b)) + x[(signed long int)10] + (unsigned int)0xffeff47d;
  c = c << 15 | c >> 32 - 15;
  c = c + d;
  b = b + (d ^ (c | ~a)) + x[(signed long int)1] + (unsigned int)0x85845dd1;
  b = b << 21 | b >> 32 - 21;
  b = b + c;
  a = a + (c ^ (b | ~d)) + x[(signed long int)8] + (unsigned int)0x6fa87e4f;
  a = a << 6 | a >> 32 - 6;
  a = a + b;
  d = d + (b ^ (a | ~c)) + x[(signed long int)15] + (unsigned int)0xfe2ce6e0;
  d = d << 10 | d >> 32 - 10;
  d = d + a;
  c = c + (a ^ (d | ~b)) + x[(signed long int)6] + (unsigned int)0xa3014314;
  c = c << 15 | c >> 32 - 15;
  c = c + d;
  b = b + (d ^ (c | ~a)) + x[(signed long int)13] + (unsigned int)0x4e0811a1;
  b = b << 21 | b >> 32 - 21;
  b = b + c;
  a = a + (c ^ (b | ~d)) + x[(signed long int)4] + (unsigned int)0xf7537e82;
  a = a << 6 | a >> 32 - 6;
  a = a + b;
  d = d + (b ^ (a | ~c)) + x[(signed long int)11] + (unsigned int)0xbd3af235;
  d = d << 10 | d >> 32 - 10;
  d = d + a;
  c = c + (a ^ (d | ~b)) + x[(signed long int)2] + (unsigned int)0x2ad7d2bb;
  c = c << 15 | c >> 32 - 15;
  c = c + d;
  b = b + (d ^ (c | ~a)) + x[(signed long int)9] + (unsigned int)0xeb86d391;
  b = b << 21 | b >> 32 - 21;
  b = b + c;
  state[(signed long int)0] = state[(signed long int)0] + a;
  state[(signed long int)1] = state[(signed long int)1] + b;
  state[(signed long int)2] = state[(signed long int)2] + c;
  state[(signed long int)3] = state[(signed long int)3] + d;
  MD5_memset((unsigned char *)x, 0, (unsigned int)sizeof(unsigned int [16l]) /*64ul*/ );
}

// MD5Update
// file md5.h line 59
void MD5Update(struct anonymous$17 *context, unsigned char *input, unsigned int inputLen)
{
  unsigned int i;
  unsigned int index;
  unsigned int partLen;
  index = (unsigned int)(context->count[(signed long int)0] >> 3 & (unsigned int)0x3F);
  context->count[(signed long int)0] = context->count[(signed long int)0] + ((unsigned int)inputLen << 3);
  if(!(context->count[0l] >= inputLen << 3))
    context->count[(signed long int)1] = context->count[(signed long int)1] + 1u;

  context->count[(signed long int)1] = context->count[(signed long int)1] + ((unsigned int)inputLen >> 29);
  partLen = (unsigned int)64 - index;
  if(inputLen >= partLen)
  {
    MD5_memcpy((unsigned char *)&context->buffer[(signed long int)index], (unsigned char *)input, partLen);
    MD5Transform(context->state, context->buffer);
    i = partLen;
    for( ; !(63u + i >= inputLen); i = i + (unsigned int)64)
      MD5Transform(context->state, &input[(signed long int)i]);
    index = (unsigned int)0;
  }

  else
    i = (unsigned int)0;
  MD5_memcpy((unsigned char *)&context->buffer[(signed long int)index], (unsigned char *)&input[(signed long int)i], inputLen - i);
}

// MD5_memcpy
// file md5c.c line 311
static void MD5_memcpy(unsigned char *output, unsigned char *input, unsigned int len)
{
  memcpy((void *)output, (const void *)input, (unsigned long int)len);
}

// MD5_memset
// file md5c.c line 327
static void MD5_memset(unsigned char *output, signed int value, unsigned int len)
{
  memset((void *)output, value, (unsigned long int)len);
}

// ParseColor
// file x_color.c line 43
struct anonymous$5 ParseColor(char *ColorName, struct _XDisplay *disp, unsigned long int win)
{
  struct anonymous$5 Color;
  struct anonymous$10 Attributes;
  XGetWindowAttributes(disp, win, &Attributes);
  Color.pixel = (unsigned long int)0;
  signed int return_value_XParseColor$2;
  return_value_XParseColor$2=XParseColor(disp, Attributes.colormap, ColorName, &Color);
  signed int return_value_XAllocColor$1;
  if(return_value_XParseColor$2 == 0)
    printf("asmail: can't parse %s\n", ColorName);

  else
  {
    return_value_XAllocColor$1=XAllocColor(disp, Attributes.colormap, &Color);
    if(return_value_XAllocColor$1 == 0)
      printf("asmail: can't allocate %s\n", ColorName);

  }
  return Color;
}

// Sclient
// file socklib.h line 50
signed int Sclient(struct anonymous$18 *sp, char *name, signed int port)
{
  struct hostent *hostent;
  hostent=gethostbyname(name);
  if(hostent == ((struct hostent *)NULL))
    return -1;

  else
  {
    sp->sin.sin_family = (unsigned short int)(signed short int)hostent->h_addrtype;
    sp->sin.sin_port=htons((unsigned short int)port);
    sp->sin.sin_addr.s_addr = (unsigned int)*((unsigned long int *)hostent->h_addr_list[(signed long int)0]);
    signed int return_value_connect$1;
    return_value_connect$1=connect(sp->sd, (struct sockaddr *)&sp->sin, sp->sinlen);
    if(return_value_connect$1 == -1)
      return -1;

    else
      return sp->sd;
  }
}

// Sclose
// file socklib.h line 48
signed int Sclose(struct anonymous$18 *sp)
{
  signed int sd;
  if(sp == ((struct anonymous$18 *)NULL))
    return -1;

  else
  {
    sd = sp->sd;
    free(sp);
    signed int return_value_close$1;
    return_value_close$1=close(sd);
    return return_value_close$1;
  }
}

// Sopen
// file socklib.h line 47
struct anonymous$18 * Sopen(void)
{
  struct anonymous$18 *sp;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct anonymous$18) /*28ul*/ );
  sp = (struct anonymous$18 *)return_value_malloc$1;
  if(sp == ((struct anonymous$18 *)NULL))
    return ((struct anonymous$18 *)NULL);

  else
  {
    sp->sd=socket(2, 1, 0);
    if(sp->sd == -1)
    {
      free(sp);
      return ((struct anonymous$18 *)NULL);
    }

    else
    {
      sp->sinlen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
      sp->bindflag = 0;
      return sp;
    }
  }
}

// Sread
// file socklib.h line 51
unsigned long int Sread(signed int sd, char *string, signed int n, signed int timeout)
{
  struct anonymous$1 rfds;
  struct timeval tv;
  signed int ret;
  signed int rcd;
  signed int i;
  do
  {
    signed int __d0;
    signed int __d1;
    asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous$1) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&rfds)->__fds_bits[(signed long int)0]) : "memory");
  }
  while((_Bool)0);
  (&rfds)->__fds_bits[(signed long int)(sd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfds)->__fds_bits[(signed long int)(sd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << sd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
  i = 0;
  n = n - 1;
  signed int tmp_post$3;
  signed long int return_value_read$4;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  do
  {
    tv.tv_sec = (signed long int)timeout;
    tv.tv_usec = (signed long int)0;
    ret=select(sd + 1, &rfds, (struct anonymous$1 *)(void *)0, (struct anonymous$1 *)(void *)0, &tv);
    if(ret >= 1)
    {
      tmp_post$3 = i;
      i = i + 1;
      return_value_read$4=read(sd, (void *)&string[(signed long int)tmp_post$3], (unsigned long int)1);
      rcd = (signed int)return_value_read$4;
      if(rcd == 0)
      {
        string[(signed long int)i] = (char)0;
        return (unsigned long int)0;
      }

    }

    if(rcd >= 1 && ret >= 1)
      tmp_if_expr$1 = (signed int)string[(signed long int)(i - 1)] != 13 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = string[(signed long int)(i - 1)] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
  }
  while(!(i >= n) && tmp_if_expr$2);
  if(!(rcd >= 0) || !(ret >= 0))
  {
    i = i - 1;
    string[(signed long int)i] = (char)0;
    return (unsigned long int)-1;
  }

  else
  {
    if((signed int)string[(signed long int)(i + -1)] == 13)
    {
      i = i - 1;
      read(sd, (void *)&string[(signed long int)i], (unsigned long int)1);
    }

    string[(signed long int)i] = (char)0;
    return (unsigned long int)i;
  }
}

// Sserver
// file socklib.c line 98
signed int Sserver(struct anonymous$18 *sp, signed int port, signed int sync)
{
  signed int flags;
  struct hostent *hostent;
  char localhost[65l];
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$5;
  signed int return_value_listen$4;
  if(sp->bindflag == 0)
  {
    signed int return_value_gethostname$1;
    return_value_gethostname$1=gethostname(localhost, (unsigned long int)64);
    if(return_value_gethostname$1 == -1)
      tmp_if_expr$2 = (_Bool)1;

    else
    {
      hostent=gethostbyname(localhost);
      tmp_if_expr$2 = hostent == ((struct hostent *)NULL) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$2)
      return -1;

    sp->sin.sin_family = (unsigned short int)(signed short int)hostent->h_addrtype;
    sp->sin.sin_port=htons((unsigned short int)port);
    sp->sin.sin_addr.s_addr = (unsigned int)*((unsigned long int *)hostent->h_addr_list[(signed long int)0]);
    signed int return_value_bind$3;
    return_value_bind$3=bind(sp->sd, (struct sockaddr *)&sp->sin, sp->sinlen);
    if(return_value_bind$3 == -1)
      tmp_if_expr$5 = (_Bool)1;

    else
    {
      return_value_listen$4=listen(sp->sd, 5);
      tmp_if_expr$5 = return_value_listen$4 == -1 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$5)
      return -1;

    sp->bindflag = 1;
  }

  _Bool tmp_if_expr$7;
  signed int return_value_fcntl$6;
  _Bool tmp_if_expr$9;
  signed int return_value_fcntl$8;
  switch(sync)
  {
    case 0:
    {
      flags=fcntl(sp->sd, 3);
      if(flags == -1)
        tmp_if_expr$7 = (_Bool)1;

      else
      {
        return_value_fcntl$6=fcntl(sp->sd, 4, flags & ~04000);
        tmp_if_expr$7 = return_value_fcntl$6 == -1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$7)
        return -1;

      break;
    }
    case 1:
    {
      flags=fcntl(sp->sd, 3);
      if(flags == -1)
        tmp_if_expr$9 = (_Bool)1;

      else
      {
        return_value_fcntl$8=fcntl(sp->sd, 4, flags | 04000);
        tmp_if_expr$9 = return_value_fcntl$8 == -1 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$9)
        return -1;

      break;
    }
    default:
      return -1;
  }
  signed int return_value_accept$10;
  return_value_accept$10=accept(sp->sd, (struct sockaddr *)&sp->sin, &sp->sinlen);
  return return_value_accept$10;
}

// Swrite
// file socklib.h line 52
unsigned long int Swrite(signed int sd, char *string)
{
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(string);
  signed long int return_value_write$2;
  return_value_write$2=write(sd, (const void *)string, return_value_strlen$1);
  return (unsigned long int)return_value_write$2;
}

// XPMError
// file gui.c line 103
void XPMError(signed int Code, const char *info)
{
  if(!(Code == 0))
  {
    if(Code == 1 || Code == -4)
      goto __CPROVER_DUMP_L2;

    if(Code == -2 || Code == -1)
      goto __CPROVER_DUMP_L3;

    if(Code == -3)
      goto __CPROVER_DUMP_L4;

  }

  else
  {
    goto __CPROVER_DUMP_L6;

  __CPROVER_DUMP_L2:
    ;
    printf("asmail: XPMError: %s: not enough free color cells\n", info);
    goto __CPROVER_DUMP_L6;

  __CPROVER_DUMP_L3:
    ;
    printf("asmail: XPMError: %s: could not load xpm\n", info);
    goto __CPROVER_DUMP_L6;

  __CPROVER_DUMP_L4:
    ;
    printf("asmail: XPMError: %s: not enough memory free\n", info);
    goto __CPROVER_DUMP_L6;
  }
  printf("asmail: XPMError: %s: unknown xpm-error\n", info);

__CPROVER_DUMP_L6:
  ;
  if(!(Code == 0))
    exit(1);

}

// add_status
// file gui.c line 183
void add_status(char *line, signed int s)
{
  unsigned long int return_value_strlen$1;
  unsigned long int return_value_strlen$2;
  if(!((1 & s) == 0))
  {
    return_value_strlen$1=strlen(line);
    sprintf(&line[(signed long int)return_value_strlen$1], "R");
  }

  else
  {
    return_value_strlen$2=strlen(line);
    sprintf(&line[(signed long int)return_value_strlen$2], " ");
  }
  unsigned long int return_value_strlen$3;
  unsigned long int return_value_strlen$4;
  unsigned long int return_value_strlen$5;
  unsigned long int return_value_strlen$6;
  unsigned long int return_value_strlen$7;
  if(!((2 & s) == 0))
  {
    return_value_strlen$3=strlen(line);
    sprintf(&line[(signed long int)return_value_strlen$3], "F");
  }

  else
    if(!((4 & s) == 0))
    {
      return_value_strlen$4=strlen(line);
      sprintf(&line[(signed long int)return_value_strlen$4], "C");
    }

    else
      if(!((8 & s) == 0))
      {
        return_value_strlen$5=strlen(line);
        sprintf(&line[(signed long int)return_value_strlen$5], "L");
      }

      else
        if(!((16 & s) == 0))
        {
          return_value_strlen$6=strlen(line);
          sprintf(&line[(signed long int)return_value_strlen$6], "T");
        }

        else
        {
          return_value_strlen$7=strlen(line);
          sprintf(&line[(signed long int)return_value_strlen$7], " ");
        }
}

// check_mbox
// file gui.c line 389
signed int check_mbox()
{
  struct mbox_struct *mb = mbox;
  x11_set.status = 0;
  for( ; !(mb == ((struct mbox_struct *)NULL)); mb = mb->next)
  {
    if(mb->mail == 2)
      x11_set.status = 2;

    else
      if(mb->mail == 1)
      {
        if(!(x11_set.status == 2))
          x11_set.status = 1;

      }

    if(!((2 & mb->flags) == 0))
    {
      pthread_mutex_lock(&mb->mutex);
      mb->flags = mb->flags & ~2;
      pthread_mutex_unlock(&mb->mutex);
      execute_on_new();
    }

  }
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  if(!(saved_status == x11_set.status))
  {
    setup_pixmap();
    saved_status = x11_set.status;
    if(!(Current == ((struct XpmIcon *)NULL)))
      tmp_if_expr$1 = Current->next != ((struct XpmIcon *)NULL) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = Current->next != Current ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$2 = (_Bool)0;
    if(tmp_if_expr$2)
      need_animation = 1;

    else
      need_animation = 0;
    return 1;
  }

  else
    return 0;
}

// count
// file mbox.c line 10
signed int count(struct mbox_struct *mb)
{
  struct _IO_FILE *f = ((struct _IO_FILE *)NULL);
  char line[81l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  signed int ctotal = 0;
  signed int cnew = 0;
  signed int status_line;
  f=fopen(mb->file, "r");
  char *return_value_fgets$1;
  signed int return_value_strncmp$3;
  char *return_value_strchr$6;
  char *return_value_fgets$7;
  if(f == ((struct _IO_FILE *)NULL))
    return -1;

  else
  {
    do
    {
      return_value_fgets$1=fgets(line, 80, f);
      if(return_value_fgets$1 == ((char *)NULL))
        break;

      signed int return_value_strncmp$5;
      return_value_strncmp$5=strncmp(line, "From ", (unsigned long int)5);
      if(return_value_strncmp$5 == 0)
      {
        ctotal = ctotal + 1;
        cnew = cnew + 1;
        status_line = 0;
      }

      else
        if(status_line == 0)
        {
          signed int return_value_strncmp$4;
          return_value_strncmp$4=strncmp(line, "Status: ", (unsigned long int)8);
          if(return_value_strncmp$4 == 0)
          {
            status_line = 1;
            if(!((1 & mb->flags) == 0))
            {
              signed int return_value_strncmp$2;
              return_value_strncmp$2=strncmp(line, "Status: RO", (unsigned long int)10);
              if(return_value_strncmp$2 == 0)
                cnew = cnew - 1;

            }

            else
            {
              return_value_strncmp$3=strncmp(line, "Status: R", (unsigned long int)9);
              if(return_value_strncmp$3 == 0)
                cnew = cnew - 1;

            }
          }

        }

      do
      {
        return_value_strchr$6=strchr(line, 10);
        if(!(return_value_strchr$6 == ((char *)NULL)))
          break;

        return_value_fgets$7=fgets(line, 80, f);
        if(return_value_fgets$7 == ((char *)NULL))
          break;

      }
      while((_Bool)1);
    }
    while((_Bool)1);
    fclose(f);
    if(!(mb->cnew == cnew))
    {
      if(!(cnew == 0))
      {
        pthread_mutex_lock(&mb->mutex);
        mb->flags = mb->flags | 2;
        pthread_mutex_unlock(&mb->mutex);
      }

    }

    mb->ctotal = ctotal;
    mb->cnew = cnew;
    return 0;
  }
}

// count_dir
// file maildir.c line 11
signed int count_dir(const char *dirname)
{
  struct __dirstream *d = (struct __dirstream *)(void *)0;
  struct dirent *f = (struct dirent *)(void *)0;
  signed int ctotal = 0;
  d=opendir(dirname);
  if(d == ((struct __dirstream *)NULL))
    return -1;

  else
  {
    do
    {
      f=readdir(d);
      if(f == ((struct dirent *)NULL))
        break;

      if(!((signed int)f->d_name[0l] == 46))
        ctotal = ctotal + 1;

    }
    while((_Bool)1);
    closedir(d);
    return ctotal;
  }
}

// count_mh
// file mh.c line 59
signed int count_mh(struct mbox_struct *mb, signed int *mod_time)
{
  if(!((4 & mb->flags) == 0))
  {
    signed int return_value_count_mh_sequences$1;
    return_value_count_mh_sequences$1=count_mh_sequences(mb, mod_time);
    return return_value_count_mh_sequences$1;
  }

  else
  {
    signed int return_value_count_mh_files$2;
    return_value_count_mh_files$2=count_mh_files(mb);
    return return_value_count_mh_files$2;
  }
}

// count_mh_files
// file mh.c line 69
signed int count_mh_files(struct mbox_struct *mb)
{
  struct __dirstream *dir = (struct __dirstream *)(void *)0;
  struct _IO_FILE *f = (struct _IO_FILE *)(void *)0;
  char line[256l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  char fname[256l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  signed int ctotal = 0;
  signed int cnew = 0;
  struct dirent *dir_entry = (struct dirent *)(void *)0;
  dir=opendir(mb->file);
  unsigned long int return_value_strlen$1;
  char *return_value_fgets$4;
  signed int return_value_strncmp$6;
  if(dir == ((struct __dirstream *)NULL))
    return -1;

  else
  {
    do
    {
      dir_entry=readdir(dir);
      if(dir_entry == ((struct dirent *)NULL))
        break;

      if(!((signed int)dir_entry->d_name[0l] == 46))
      {
        if(!((signed int)dir_entry->d_name[0l] == 44))
        {
          strcpy(fname, mb->file);
          unsigned long int return_value_strlen$2;
          return_value_strlen$2=strlen(fname);
          if(!((signed int)fname[-1l + (signed long int)return_value_strlen$2] == 47))
          {
            return_value_strlen$1=strlen(fname);
            strncat(fname, "/", (unsigned long int)255 - return_value_strlen$1);
          }

          unsigned long int return_value_strlen$3;
          return_value_strlen$3=strlen(fname);
          strncat(fname, dir_entry->d_name, (unsigned long int)255 - return_value_strlen$3);
          fname[(signed long int)255] = (char)0;
          f=fopen(fname, "r");
          if(f == ((struct _IO_FILE *)NULL))
            return -1;

          ctotal = ctotal + 1;
          cnew = cnew + 1;
          do
          {
            return_value_fgets$4=fgets(line, 255, f);
            if(return_value_fgets$4 == ((char *)NULL))
              break;

            if((signed int)line[0l] == 83)
            {
              signed int return_value_strncmp$7;
              return_value_strncmp$7=strncmp(line, "Status: ", (unsigned long int)8);
              if(return_value_strncmp$7 == 0)
              {
                if(!((1 & mb->flags) == 0))
                {
                  signed int return_value_strncmp$5;
                  return_value_strncmp$5=strncmp(line, "Status: RO", (unsigned long int)10);
                  if(return_value_strncmp$5 == 0)
                    cnew = cnew - 1;

                }

                else
                {
                  return_value_strncmp$6=strncmp(line, "Status: R", (unsigned long int)9);
                  if(return_value_strncmp$6 == 0)
                    cnew = cnew - 1;

                }
                break;
              }

            }

          }
          while((_Bool)1);

        close:
          ;
          fclose(f);
        }

      }

    }
    while((_Bool)1);
    closedir(dir);
    if(!(mb->cnew == cnew))
    {
      if(!(cnew == 0))
      {
        pthread_mutex_lock(&mb->mutex);
        mb->flags = mb->flags | 2;
        pthread_mutex_unlock(&mb->mutex);
      }

    }

    mb->ctotal = ctotal;
    mb->cnew = cnew;
    return cnew;
  }
}

// count_mh_sequences
// file mh.c line 139
signed int count_mh_sequences(struct mbox_struct *mb, signed int *mod_time)
{
  struct stat stat_buf;
  struct __dirstream *dir = (struct __dirstream *)(void *)0;
  struct _IO_FILE *f = (struct _IO_FILE *)(void *)0;
  signed int ctotal = 0;
  signed int cnew = 0;
  signed int lsize = 0;
  signed int i = 0;
  struct dirent *dir_entry = (struct dirent *)(void *)0;
  char *line = (char *)(void *)0;
  char **tokens = (char **)(void *)0;
  char fname[256l] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  strcpy(fname, mb->file);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(fname);
  unsigned long int return_value_strlen$1;
  if(!((signed int)fname[-1l + (signed long int)return_value_strlen$2] == 47))
  {
    return_value_strlen$1=strlen(fname);
    strncat(fname, "/", (unsigned long int)255 - return_value_strlen$1);
  }

  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(fname);
  strncat(fname, ".mh_sequences", (unsigned long int)255 - return_value_strlen$3);
  fname[(signed long int)255] = (char)0;
  signed int return_value_stat$4;
  return_value_stat$4=stat(mb->file, &stat_buf);
  if(!(return_value_stat$4 == 0))
  {
    fprintf(stderr, "asmail: mh_handle: stat (%s) failed.\n", (const void *)mb->file);
    return -1;
  }

  else
    if(stat_buf.st_ctim.tv_sec == (signed long int)*mod_time)
      return 0;

    else
      *mod_time = (signed int)stat_buf.st_ctim.tv_sec;
  dir=opendir(mb->file);
  signed int return_value_feof$6;
  if(dir == ((struct __dirstream *)NULL))
    return -1;

  else
  {
    do
    {
      dir_entry=readdir(dir);
      if(dir_entry == ((struct dirent *)NULL))
        break;

      if(!((signed int)dir_entry->d_name[0l] == 46))
      {
        if(!((signed int)dir_entry->d_name[0l] == 44))
          ctotal = ctotal + 1;

      }

    }
    while((_Bool)1);
    closedir(dir);
    f=fopen(fname, "r");
    if(f == ((struct _IO_FILE *)NULL))
    {
      fprintf(stderr, "asmail: count_mh_sequences: unable to open sequences file: %s\n", (const void *)fname);
      return -1;
    }

    else
    {
      lsize = 256;
      void *return_value_malloc$5;
      return_value_malloc$5=malloc(sizeof(char) /*1ul*/  * (unsigned long int)lsize);
      line = (char *)return_value_malloc$5;
      do
      {
        return_value_feof$6=feof(f);
        if(!(return_value_feof$6 == 0))
          break;

        readLine(f, &line, &lsize);
        signed int return_value_strncasecmp$8;
        return_value_strncasecmp$8=strncasecmp(line, "unseen:", (unsigned long int)7);
        if(return_value_strncasecmp$8 == 0)
        {
          tokenizeString(line, lsize, &tokens);
          i = 1;
          for( ; !(tokens[(signed long int)i] == ((char *)NULL)); i = i + 1)
          {
            signed int return_value_parse_sequence$7;
            return_value_parse_sequence$7=parse_sequence(tokens[(signed long int)i]);
            cnew = cnew + return_value_parse_sequence$7;
          }
          break;
        }

      }
      while((_Bool)1);
      fclose(f);
      free((void *)line);
      if(!(tokens == ((char **)NULL)))
      {
        i = 0;
        for( ; !(tokens[(signed long int)i] == ((char *)NULL)); i = i + 1)
          free((void *)tokens[(signed long int)i]);
        free((void *)tokens);
      }

      if(!(mb->cnew == cnew))
      {
        if(!(cnew == 0))
        {
          pthread_mutex_lock(&mb->mutex);
          mb->flags = mb->flags | 2;
          pthread_mutex_unlock(&mb->mutex);
        }

      }

      mb->ctotal = ctotal;
      mb->cnew = cnew;
      return cnew;
    }
  }
}

// defaults
// file asmail.c line 72
void defaults()
{
  char *return_value_getenv$1;
  return_value_getenv$1=getenv("HOME");
  if(return_value_getenv$1 == ((char *)NULL))
  {
    fprintf(stderr, "missing HOME variable\n");
    exit(1);
  }

  char *return_value_getenv$2;
  return_value_getenv$2=getenv("HOME");
  strncpy(config_file_name, (char *)return_value_getenv$2, (unsigned long int)255);
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(config_file_name);
  strncat(config_file_name, "/", (unsigned long int)255 - return_value_strlen$3);
  unsigned long int return_value_strlen$4;
  return_value_strlen$4=strlen(config_file_name);
  strncat(config_file_name, ".asmailrc", (unsigned long int)255 - return_value_strlen$4);
  config_file_name[(signed long int)255] = (char)0;
  x11_set.geometry[(signed long int)255] = (char)0;
  x11_set.title[(signed long int)255] = (char)0;
  x11_set.font[(signed long int)255] = (char)0;
  x11_set.on_left[(signed long int)255] = (char)0;
  x11_set.on_middle[(signed long int)255] = (char)0;
  x11_set.on_right[(signed long int)255] = (char)0;
  x11_set.on_new_mail[(signed long int)255] = (char)0;
  x11_set.beep = 1;
  x11_set.shape = 0;
  x11_set.use_frame = 1;
  x11_set.withdrawn = 0;
  x11_set.iconic = 0;
  strcpy(x11_set.geometry, "");
  strcpy(x11_set.title, "asmail");
  strcpy(x11_set.on_left, "");
  strcpy(x11_set.on_middle, "");
  strcpy(x11_set.on_right, "");
  strcpy(x11_set.on_new_mail, "");
  x11_set.each = 0;
  x11_set.total = 1;
  x11_set.status = 1;
  x11_set.old = 1;
  x11_set.new = 1;
  x11_set.x = 0;
  x11_set.y = 52;
  strcpy(x11_set.delimiter, "/");
  strcpy(x11_set.font, "-*-*-medium-r-normal--10-*-*-*-*-*-*-*");
  strcpy(x11_set.color, "black");
  x11_set.refresh = 10;
  x11_set.nomail = (struct pixfile *)(void *)0;
  x11_set.oldmail = (struct pixfile *)(void *)0;
  x11_set.newmail = (struct pixfile *)(void *)0;
  x11_set.frame = (struct pixfile *)(void *)0;
}

// draw_window
// file gui.c line 225
void draw_window(unsigned long int win)
{
  signed int x;
  signed int y;
  struct mbox_struct *mb;
  signed int o = 0;
  signed int n = 0;
  signed int s = 0;
  signed int direction_return;
  signed int ascent_return;
  signed int descent_return;
  struct anonymous$19 overall_return;
  x = (signed int)(((unsigned int)winsize.x - Current->attributes.width) / (unsigned int)2);
  y = (signed int)(((unsigned int)winsize.y - Current->attributes.height) / (unsigned int)2);
  if(!(x11_set.use_frame == 0))
    XCopyArea(mainDisplay, Frame->pixmap, drawWindow, mainGC, 0, 0, (unsigned int)winsize.x, (unsigned int)winsize.y, 0, 0);

  if(!(x11_set.shape == 0))
  {
    XSetClipOrigin(mainDisplay, mainGC, x, y);
    XSetClipMask(mainDisplay, mainGC, Current->mask);
  }

  XCopyArea(mainDisplay, Current->pixmap, drawWindow, mainGC, 0, 0, Current->attributes.width, Current->attributes.height, x, y);
  if(!(x11_set.shape == 0))
    XSetClipMask(mainDisplay, mainGC, (unsigned long int)0L);

  mb = mbox;
  for( ; !(mb == ((struct mbox_struct *)NULL)); mb = mb->next)
  {
    if(!(mb->ctotal == 0))
      o = o + mb->ctotal;

    if(!(mb->cnew == 0))
      n = n + mb->cnew;

    s = s | mb->status;
  }
  unsigned long int return_value_strlen$2;
  unsigned long int return_value_strlen$3;
  unsigned long int return_value_strlen$5;
  unsigned long int return_value_strlen$6;
  if(!(x11_set.total == 0))
  {
    NumOfMsg.chars[(signed long int)0] = (char)0;
    if(!(x11_set.status == 0))
    {
      add_status(NumOfMsg.chars, s);
      unsigned long int return_value_strlen$1;
      return_value_strlen$1=strlen(NumOfMsg.chars);
      sprintf(&NumOfMsg.chars[(signed long int)return_value_strlen$1], " ");
    }

    if(!(x11_set.new == 0))
    {
      if(!(n == 0))
      {
        return_value_strlen$2=strlen(NumOfMsg.chars);
        sprintf(&NumOfMsg.chars[(signed long int)return_value_strlen$2], "%d", n);
      }

      else
      {
        return_value_strlen$3=strlen(NumOfMsg.chars);
        sprintf(&NumOfMsg.chars[(signed long int)return_value_strlen$3], "-");
      }
    }

    if(!(x11_set.new == 0) && !(x11_set.old == 0))
    {
      unsigned long int return_value_strlen$4;
      return_value_strlen$4=strlen(NumOfMsg.chars);
      sprintf(&NumOfMsg.chars[(signed long int)return_value_strlen$4], "%s", (const void *)x11_set.delimiter);
    }

    if(!(x11_set.old == 0))
    {
      if(!(o == 0))
      {
        return_value_strlen$5=strlen(NumOfMsg.chars);
        sprintf(&NumOfMsg.chars[(signed long int)return_value_strlen$5], "%d", o);
      }

      else
      {
        return_value_strlen$6=strlen(NumOfMsg.chars);
        sprintf(&NumOfMsg.chars[(signed long int)return_value_strlen$6], "-");
      }
    }

    unsigned long int return_value_strlen$7;
    return_value_strlen$7=strlen(NumOfMsg.chars);
    NumOfMsg.nchars = (signed int)return_value_strlen$7;
    XDrawText(mainDisplay, drawWindow, mainGC, x + x11_set.x, y + x11_set.y, &NumOfMsg, 1);
    unsigned long int return_value_strlen$8;
    return_value_strlen$8=strlen(NumOfMsg.chars);
    XTextExtents(font_struct, NumOfMsg.chars, (signed int)return_value_strlen$8, &direction_return, &ascent_return, &descent_return, &overall_return);
    y = y + ascent_return + descent_return + 2;
  }

  unsigned long int return_value_strlen$10;
  unsigned long int return_value_strlen$11;
  unsigned long int return_value_strlen$13;
  unsigned long int return_value_strlen$14;
  if(!(x11_set.each == 0))
  {
    mb = mbox;
    while(!(mb == ((struct mbox_struct *)NULL)))
    {
      NumOfMsg.chars[(signed long int)0] = (char)0;
      if(!(x11_set.status == 0))
      {
        add_status(NumOfMsg.chars, mb->status);
        unsigned long int return_value_strlen$9;
        return_value_strlen$9=strlen(NumOfMsg.chars);
        sprintf(&NumOfMsg.chars[(signed long int)return_value_strlen$9], " ");
      }

      if(!(x11_set.new == 0))
      {
        if(!(mb->cnew == 0))
        {
          return_value_strlen$10=strlen(NumOfMsg.chars);
          sprintf(&NumOfMsg.chars[(signed long int)return_value_strlen$10], "%d", mb->cnew);
        }

        else
        {
          return_value_strlen$11=strlen(NumOfMsg.chars);
          sprintf(&NumOfMsg.chars[(signed long int)return_value_strlen$11], "-");
        }
      }

      if(!(x11_set.new == 0) && !(x11_set.old == 0))
      {
        unsigned long int return_value_strlen$12;
        return_value_strlen$12=strlen(NumOfMsg.chars);
        sprintf(&NumOfMsg.chars[(signed long int)return_value_strlen$12], "%s", (const void *)x11_set.delimiter);
      }

      if(!(x11_set.old == 0))
      {
        if(!(mb->ctotal == 0))
        {
          return_value_strlen$13=strlen(NumOfMsg.chars);
          sprintf(&NumOfMsg.chars[(signed long int)return_value_strlen$13], "%d", mb->ctotal);
        }

        else
        {
          return_value_strlen$14=strlen(NumOfMsg.chars);
          sprintf(&NumOfMsg.chars[(signed long int)return_value_strlen$14], "-");
        }
      }

      unsigned long int return_value_strlen$15;
      return_value_strlen$15=strlen(NumOfMsg.chars);
      NumOfMsg.nchars = (signed int)return_value_strlen$15;
      XDrawText(mainDisplay, drawWindow, mainGC, x + x11_set.x, y + x11_set.y, &NumOfMsg, 1);
      unsigned long int return_value_strlen$16;
      return_value_strlen$16=strlen(NumOfMsg.chars);
      XTextExtents(font_struct, NumOfMsg.chars, (signed int)return_value_strlen$16, &direction_return, &ascent_return, &descent_return, &overall_return);
      y = y + ascent_return + descent_return + 2;
      mb = mb->next;
    }
  }

  XCopyArea(mainDisplay, drawWindow, win, mainGC, 0, 0, (unsigned int)winsize.x, (unsigned int)winsize.y, 0, 0);
}

// err_printf
// file asmail.c line 56
static void err_printf(const char *tmpl, ...)
{
  void **val;
  signed int errno_;
  signed int *return_value___errno_location$1;
  return_value___errno_location$1=__errno_location();
  errno_ = *return_value___errno_location$1;
  val = (void **)&tmpl;
  vprintf(tmpl, val);
  val = ((void **)NULL);
  signed int *return_value___errno_location$2;
  return_value___errno_location$2=__errno_location();
  *return_value___errno_location$2 = errno_;
}

// execute_on_new
// file gui.c line 170
void execute_on_new()
{
  if(!(x11_set.beep == 0))
    XBell(mainDisplay, 0);

  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(x11_set.on_new_mail);
  if(!(return_value_strlen$1 == 0ul))
    system(x11_set.on_new_mail);

}

// imap_checkmbox
// file imap.c line 151
signed int imap_checkmbox(struct mbox_struct *mb, struct anonymous$18 **sock)
{
  signed int ret;
  signed int ctotal = 0;
  signed int cnew = 0;
  char input[256l];
  char output[256l];
  char *tmp_str;
  struct anonymous$18 *s = *sock;
  if(!(mb->status == 1))
    return mb->status;

  else
  {
    sprintf(output, "A001 STATUS %s (MESSAGES)\r\n", (const void *)mb->mbox);
    unsigned long int return_value_Swrite$1;
    return_value_Swrite$1=Swrite(s->sd, output);
    ret = (signed int)return_value_Swrite$1;
    if(ret == -1)
    {
      Sclose(s);
      *sock = (struct anonymous$18 *)(void *)0;
      return 4;
    }

    else
    {
      unsigned long int return_value_Sread$2;
      return_value_Sread$2=Sread(s->sd, input, 255, mb->timeout);
      ret = (signed int)return_value_Sread$2;
      if(!(ret == -1))
      {
        if(ret == 0)
          goto __CPROVER_DUMP_L4;

      }

      else
      {
        Sclose(s);
        *sock = (struct anonymous$18 *)(void *)0;
        return 4;

      __CPROVER_DUMP_L4:
        ;
        Sclose(s);
        *sock = (struct anonymous$18 *)(void *)0;
        return 16;
      }
      signed int return_value_strncmp$8;
      return_value_strncmp$8=strncmp(input, "* STATUS", (unsigned long int)8);
      if(!(return_value_strncmp$8 == 0))
      {
        signed int return_value_strncmp$3;
        return_value_strncmp$3=strncmp(input, "* ", (unsigned long int)2);
        if(!(return_value_strncmp$3 == 0))
        {
          Sclose(s);
          *sock = (struct anonymous$18 *)(void *)0;
          return 4;
        }

        unsigned long int return_value_Sread$4;
        return_value_Sread$4=Sread(s->sd, input, 255, mb->timeout);
        ret = (signed int)return_value_Sread$4;
        if(!(ret == -1))
        {
          if(ret == 0)
            goto __CPROVER_DUMP_L8;

        }

        else
        {
          Sclose(s);
          *sock = (struct anonymous$18 *)(void *)0;
          return 4;

        __CPROVER_DUMP_L8:
          ;
          Sclose(s);
          *sock = (struct anonymous$18 *)(void *)0;
          return 16;
        }
        signed int return_value_strncmp$5;
        return_value_strncmp$5=strncmp(input, "* ", (unsigned long int)2);
        if(!(return_value_strncmp$5 == 0))
        {
          Sclose(s);
          *sock = (struct anonymous$18 *)(void *)0;
          return 4;
        }

        unsigned long int return_value_Sread$6;
        return_value_Sread$6=Sread(s->sd, input, 255, mb->timeout);
        ret = (signed int)return_value_Sread$6;
        if(!(ret == -1))
        {
          if(ret == 0)
            goto __CPROVER_DUMP_L12;

        }

        else
        {
          Sclose(s);
          *sock = (struct anonymous$18 *)(void *)0;
          return 4;

        __CPROVER_DUMP_L12:
          ;
          Sclose(s);
          *sock = (struct anonymous$18 *)(void *)0;
          return 16;
        }
        signed int return_value_strncmp$7;
        return_value_strncmp$7=strncmp(input, "* STATUS", (unsigned long int)8);
        if(!(return_value_strncmp$7 == 0))
        {
          Sclose(s);
          *sock = (struct anonymous$18 *)(void *)0;
          return 4;
        }

      }

      tmp_str=strstr(input, "MESSAGES");
      if(!(tmp_str == ((char *)NULL)))
        sscanf(tmp_str, "MESSAGES %d", &ctotal);

      else
      {
        printf("asmail: imap_mailcheck: did not get MESSAGES in response to the STATUS.\n");
        Sclose(s);
        *sock = (struct anonymous$18 *)(void *)0;
        return 2;
      }
      unsigned long int return_value_Sread$9;
      return_value_Sread$9=Sread(s->sd, input, 255, mb->timeout);
      ret = (signed int)return_value_Sread$9;
      if(!(ret == -1))
      {
        if(ret == 0)
          goto __CPROVER_DUMP_L19;

      }

      else
      {
        Sclose(s);
        *sock = (struct anonymous$18 *)(void *)0;
        return 4;

      __CPROVER_DUMP_L19:
        ;
        Sclose(s);
        *sock = (struct anonymous$18 *)(void *)0;
        return 16;
      }
      signed int return_value_strncmp$10;
      return_value_strncmp$10=strncmp(input, "A001 OK", (unsigned long int)7);
      if(!(return_value_strncmp$10 == 0))
      {
        Sclose(s);
        *sock = (struct anonymous$18 *)(void *)0;
        return 4;
      }

      else
      {
        sprintf(output, "A002 STATUS %s (UNSEEN)\r\n", (const void *)mb->mbox);
        unsigned long int return_value_Swrite$11;
        return_value_Swrite$11=Swrite(s->sd, output);
        ret = (signed int)return_value_Swrite$11;
        if(ret == -1)
        {
          Sclose(s);
          *sock = (struct anonymous$18 *)(void *)0;
          return 4;
        }

        else
        {
          unsigned long int return_value_Sread$12;
          return_value_Sread$12=Sread(s->sd, input, 255, mb->timeout);
          ret = (signed int)return_value_Sread$12;
          if(!(ret == -1))
          {
            if(ret == 0)
              goto __CPROVER_DUMP_L24;

          }

          else
          {
            Sclose(s);
            *sock = (struct anonymous$18 *)(void *)0;
            return 4;

          __CPROVER_DUMP_L24:
            ;
            Sclose(s);
            *sock = (struct anonymous$18 *)(void *)0;
            return 16;
          }
          signed int return_value_strncmp$13;
          return_value_strncmp$13=strncmp(input, "* STATUS", (unsigned long int)8);
          if(!(return_value_strncmp$13 == 0))
          {
            Sclose(s);
            *sock = (struct anonymous$18 *)(void *)0;
            return 4;
          }

          else
          {
            tmp_str=strstr(input, "UNSEEN");
            if(!(tmp_str == ((char *)NULL)))
              sscanf(tmp_str, "UNSEEN %d", &cnew);

            else
            {
              printf("asmail: imap_mailcheck: did not get UNSEEN in response to the STATUS.\n");
              Sclose(s);
              *sock = (struct anonymous$18 *)(void *)0;
              return 2;
            }
            unsigned long int return_value_Sread$14;
            return_value_Sread$14=Sread(s->sd, input, 255, mb->timeout);
            ret = (signed int)return_value_Sread$14;
            if(!(ret == -1))
            {
              if(ret == 0)
                goto __CPROVER_DUMP_L30;

            }

            else
            {
              Sclose(s);
              *sock = (struct anonymous$18 *)(void *)0;
              return 4;

            __CPROVER_DUMP_L30:
              ;
              Sclose(s);
              *sock = (struct anonymous$18 *)(void *)0;
              return 16;
            }
            signed int return_value_strncmp$15;
            return_value_strncmp$15=strncmp(input, "A002 OK", (unsigned long int)7);
            if(!(return_value_strncmp$15 == 0))
            {
              Sclose(s);
              *sock = (struct anonymous$18 *)(void *)0;
              return 4;
            }

            else
            {
              if(!(mb->cnew == cnew))
              {
                if(!(cnew == 0))
                {
                  pthread_mutex_lock(&mb->mutex);
                  mb->flags = mb->flags | 2;
                  pthread_mutex_unlock(&mb->mutex);
                }

              }

              mb->cnew = cnew;
              mb->ctotal = ctotal;
              return 0;
            }
          }
        }
      }
    }
  }
}

// imap_goodbye
// file imap.c line 231
signed int imap_goodbye(struct mbox_struct *mb, struct anonymous$18 **sock)
{
  signed int ret;
  char input[256l];
  char output[256l];
  struct anonymous$18 *s = *sock;
  if(s == ((struct anonymous$18 *)NULL))
    return mb->status;

  else
  {
    sprintf(output, "A004 LOGOUT\r\n");
    unsigned long int return_value_Swrite$1;
    return_value_Swrite$1=Swrite(s->sd, output);
    ret = (signed int)return_value_Swrite$1;
    if(ret == -1)
    {
      Sclose(s);
      *sock = (struct anonymous$18 *)(void *)0;
      return 4;
    }

    else
    {
      unsigned long int return_value_Sread$2;
      return_value_Sread$2=Sread(s->sd, input, 255, mb->timeout);
      ret = (signed int)return_value_Sread$2;
      if(!(ret == -1))
      {
        if(ret == 0)
          goto __CPROVER_DUMP_L4;

      }

      else
      {
        Sclose(s);
        *sock = (struct anonymous$18 *)(void *)0;
        return 4;

      __CPROVER_DUMP_L4:
        ;
        Sclose(s);
        *sock = (struct anonymous$18 *)(void *)0;
        return 16;
      }
      signed int return_value_strncmp$3;
      return_value_strncmp$3=strncmp(input, "* BYE", (unsigned long int)5);
      if(!(return_value_strncmp$3 == 0))
      {
        Sclose(s);
        *sock = (struct anonymous$18 *)(void *)0;
        return 4;
      }

      else
      {
        Sclose(*sock);
        *sock = (struct anonymous$18 *)(void *)0;
        return 0;
      }
    }
  }
}

// imap_handle
// file imap.h line 17
void imap_handle(struct mbox_struct *mb)
{
  struct anonymous$18 *s;
  if(!(mb->type == 4))
  {
    printf("asmail: imap_handle: Cowardly refusing to work with a non-IMAP server.\n");
    mb->status = 2;
    pthread_exit((void *)0);
  }

  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(mb->server);
  if(return_value_strlen$1 == 0ul)
  {
    printf("asmail: imap_handle: no server name specified!\n");
    mb->status = 2;
    pthread_exit((void *)0);
  }

  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(mb->user);
  if(return_value_strlen$2 == 0ul)
  {
    printf("asmail: imap_handle: no user name specified!\n");
    mb->status = 2;
    pthread_exit((void *)0);
  }

  if(mb->port == 0)
    mb->port = (mb->flags & 16) != 0 ? 993 : 143;

  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(mb->mbox);
  if(return_value_strlen$3 == 0ul)
    strcpy(mb->mbox, "INBOX");

  if(!((8 & mb->flags) == 0))
    mb->status=imap_login(mb, &s);

  while((_Bool)1)
  {
    mb->status = mb->status | 1;
    signal_update();
    if(!((8 & mb->flags) == 0))
    {
      mb->status=imap_checkmbox(mb, &s);
      if(!(mb->status == 0))
      {
        mb->status=imap_goodbye(mb, &s);
        signed int return_value_imap_login$4;
        return_value_imap_login$4=imap_login(mb, &s);
        signed int return_value_imap_checkmbox$5;
        return_value_imap_checkmbox$5=imap_checkmbox(mb, &s);
        mb->status = return_value_imap_login$4 | return_value_imap_checkmbox$5;
      }

    }

    else
    {
      signed int return_value_imap_login$6;
      return_value_imap_login$6=imap_login(mb, &s);
      mb->status = mb->status | return_value_imap_login$6;
      signed int return_value_imap_checkmbox$7;
      return_value_imap_checkmbox$7=imap_checkmbox(mb, &s);
      mb->status = mb->status | return_value_imap_checkmbox$7;
      signed int return_value_imap_goodbye$8;
      return_value_imap_goodbye$8=imap_goodbye(mb, &s);
      mb->status = mb->status | return_value_imap_goodbye$8;
    }
    mb->status = mb->status & ~1;
    if(mb->status == 0)
    {
      mb->status = 0;
      if(mb->cnew >= 1)
        mb->mail = 2;

      else
        if(mb->ctotal >= 1)
          mb->mail = 1;

        else
          mb->mail = 0;
    }

    signal_update();
    sleep_check(mb->update);
  }
}

// imap_login
// file imap.c line 99
signed int imap_login(struct mbox_struct *mb, struct anonymous$18 **sock)
{
  signed int ret;
  char input[256l];
  char output[256l];
  struct anonymous$18 *s;
  *sock=Sopen();
  if(*sock == ((struct anonymous$18 *)NULL))
    return 2;

  else
  {
    s = *sock;
    signed int return_value_Sclient$1;
    return_value_Sclient$1=Sclient(s, mb->server, mb->port);
    if(return_value_Sclient$1 == -1)
    {
      Sclose(s);
      *sock = (struct anonymous$18 *)(void *)0;
      return 4;
    }

    else
    {
      unsigned long int return_value_Sread$2;
      return_value_Sread$2=Sread(s->sd, input, 255, mb->timeout);
      ret = (signed int)return_value_Sread$2;
      if(!(ret == -1))
      {
        if(ret == 0)
          goto __CPROVER_DUMP_L4;

      }

      else
      {
        Sclose(s);
        *sock = (struct anonymous$18 *)(void *)0;
        return 4;

      __CPROVER_DUMP_L4:
        ;
        Sclose(s);
        *sock = (struct anonymous$18 *)(void *)0;
        return 16;
      }
      signed int return_value_strncmp$3;
      return_value_strncmp$3=strncmp(input, "* OK", (unsigned long int)4);
      if(!(return_value_strncmp$3 == 0))
      {
        Sclose(s);
        *sock = (struct anonymous$18 *)(void *)0;
        return 4;
      }

      else
      {
        sprintf(output, "A000 LOGIN %s %s\r\n", (const void *)mb->user, (const void *)mb->pass);
        unsigned long int return_value_Swrite$4;
        return_value_Swrite$4=Swrite(s->sd, output);
        ret = (signed int)return_value_Swrite$4;
        if(ret == -1)
        {
          Sclose(s);
          *sock = (struct anonymous$18 *)(void *)0;
          return 4;
        }

        else
        {
          unsigned long int return_value_Sread$5;
          return_value_Sread$5=Sread(s->sd, input, 255, mb->timeout);
          ret = (signed int)return_value_Sread$5;
          if(!(ret == -1))
          {
            if(ret == 0)
              goto __CPROVER_DUMP_L9;

          }

          else
          {
            Sclose(s);
            *sock = (struct anonymous$18 *)(void *)0;
            return 4;

          __CPROVER_DUMP_L9:
            ;
            Sclose(s);
            *sock = (struct anonymous$18 *)(void *)0;
            return 16;
          }
          signed int return_value_strncmp$6;
          return_value_strncmp$6=strncmp(input, "A000 OK", (unsigned long int)7);
          if(!(return_value_strncmp$6 == 0))
          {
            Sclose(s);
            *sock = (struct anonymous$18 *)(void *)0;
            return 8;
          }

          else
            return 0;
        }
      }
    }
  }
}

// init_mbox
// file asmail.c line 501
signed int init_mbox(struct mbox_struct **mb)
{
  struct mbox_struct *new_mbox;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(sizeof(struct mbox_struct) /*1376ul*/ );
  new_mbox = (struct mbox_struct *)return_value_malloc$1;
  if(new_mbox == ((struct mbox_struct *)NULL))
  {
    printf("asmail: failed to allocate memory for the mailbox control structure.\n");
    return -1;
  }

  else
  {
    signed int return_value_pthread_mutex_init$2;
    return_value_pthread_mutex_init$2=pthread_mutex_init(&new_mbox->mutex, (const union anonymous$16 *)(void *)0);
    if(!(return_value_pthread_mutex_init$2 == 0))
    {
      printf("asmail: parse_cfg_mbox: failed to initialize mutex.\n");
      return -1;
    }

    else
    {
      new_mbox->type = 0;
      strcpy(new_mbox->file, "");
      strcpy(new_mbox->server, "");
      strcpy(new_mbox->user, "");
      strcpy(new_mbox->pass, "");
      strcpy(new_mbox->mbox, "");
      new_mbox->auth = 1 | 2;
      new_mbox->port = 0;
      new_mbox->timeout = 60;
      new_mbox->update = 10;
      new_mbox->flags = 0;
      new_mbox->status = 0;
      new_mbox->mail = 0;
      new_mbox->ctotal = 0;
      new_mbox->cnew = 0;
      new_mbox->next = (struct mbox_struct *)(void *)0;
      *mb = new_mbox;
      return 0;
    }
  }
}

// maildir_handle
// file maildir.h line 6
void maildir_handle(struct mbox_struct *mb)
{
  char dir_cur[256l];
  char dir_new[256l];
  signed int result;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(mb->file);
  if(return_value_strlen$1 == 0ul)
  {
    printf("asmail: maildir_handle: no mailbox directory specified.\n");
    mb->status = 2;
    signal_update();
    pthread_exit((void *)0);
  }

  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(mb->file);
  if(return_value_strlen$2 >= 252ul)
  {
    printf("asmail: maildir_handle: mailbox directory name is too long.\n");
    mb->status = 2;
    signal_update();
    pthread_exit((void *)0);
  }

  strcpy(dir_cur, mb->file);
  strcat(dir_cur, "/cur");
  strcpy(dir_new, mb->file);
  strcat(dir_new, "/new");
  while((_Bool)1)
  {
    mb->status = mb->status | 1;
    signal_update();
    result=count_dir(dir_cur);
    if(!(result >= 0))
    {
      mb->status = 2;
      signal_update();
    }

    else
    {
      if(!(result == 0))
        mb->mail = 1;

      else
        mb->mail = 0;
      mb->ctotal = result;
    }
    result=count_dir(dir_new);
    if(!(result >= 0))
    {
      mb->status = 2;
      signal_update();
    }

    else
    {
      if(!(result == 0))
      {
        if(!(mb->cnew == result))
        {
          pthread_mutex_lock(&mb->mutex);
          mb->flags = mb->flags | 2;
          pthread_mutex_unlock(&mb->mutex);
        }

        mb->mail = 2;
      }

      mb->cnew = result;
      if(mb->status == 1)
        mb->status = 0;

    }
    signal_update();
    sleep_check(mb->update);
  }
}

// main
// file asmail.c line 781
signed int main(signed int argc, char **argv)
{
  struct mbox_struct *tmp_mbox;
  char *tmp_ptr;
  x11_set.argc = argc;
  x11_set.argv = argv;
  signed int return_value_pthread_mutex_init$1;
  return_value_pthread_mutex_init$1=pthread_mutex_init(&update_lock, (const union anonymous$16 *)(void *)0);
  if(!(return_value_pthread_mutex_init$1 == 0))
  {
    printf("asmail: main: failed to initialize update mutex.\n");
    exit(-1);
  }

  signed int return_value_pthread_cond_init$2;
  return_value_pthread_cond_init$2=pthread_cond_init(&update_cv, (const union anonymous$16 *)(void *)0);
  if(!(return_value_pthread_cond_init$2 == 0))
  {
    printf("asmail: main: failed to initialize update condition variable.\n");
    exit(-1);
  }

  signed int return_value_pthread_mutex_init$3;
  return_value_pthread_mutex_init$3=pthread_mutex_init(&md5_lock, (const union anonymous$16 *)(void *)0);
  if(!(return_value_pthread_mutex_init$3 == 0))
  {
    printf("asmail: main: failed to initialize MD5 mutex.\n");
    exit(-1);
  }

  signed int return_value_pthread_mutex_init$4;
  return_value_pthread_mutex_init$4=pthread_mutex_init(&check_lock, (const union anonymous$16 *)(void *)0);
  if(!(return_value_pthread_mutex_init$4 == 0))
  {
    printf("asmail: main: failed to initialize check mutex.\n");
    exit(-1);
  }

  signed int return_value_pthread_cond_init$5;
  return_value_pthread_cond_init$5=pthread_cond_init(&check_cv, (const union anonymous$16 *)(void *)0);
  if(!(return_value_pthread_cond_init$5 == 0))
  {
    printf("asmail: main: failed to initialize check condition variable.\n");
    exit(-1);
  }

  defaults();
  signed int return_value_parse_cmd$6;
  return_value_parse_cmd$6=parse_cmd(argc, argv);
  if(!(return_value_parse_cmd$6 == 0))
    exit(-1);

  if(flag_no_config == 0)
  {
    signed int return_value_parse_cfg$7;
    return_value_parse_cfg$7=parse_cfg(config_file_name);
    if(return_value_parse_cfg$7 == -1)
      exit(-1);

  }

  if(mbox == ((struct mbox_struct *)NULL))
  {
    tmp_ptr=getenv("MAIL");
    if(!(tmp_ptr == ((char *)NULL)))
    {
      printf("asmail: no mailbox defnitions, using $MAIL (%s)\n", tmp_ptr);
      signed int return_value_init_mbox$8;
      return_value_init_mbox$8=init_mbox(&tmp_mbox);
      if(!(return_value_init_mbox$8 == 0))
        return -1;

      strncpy(tmp_mbox->file, tmp_ptr, (unsigned long int)255);
      tmp_mbox->type = 1;
      tmp_mbox->next = mbox;
      mbox = tmp_mbox;
    }

  }

  if(mbox == ((struct mbox_struct *)NULL))
  {
    printf("asmail: no mailboxes to check, cowardly quitting.\n");
    return -1;
  }

  else
  {
    tmp_mbox = mbox;
    for( ; !(tmp_mbox == ((struct mbox_struct *)NULL)); tmp_mbox = tmp_mbox->next)
    {
      pthread_create(&tmp_mbox->thread, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))(void *)mbox_thread, (void *)tmp_mbox);
      pthread_detach(tmp_mbox->thread);
    }
    if(flag_no_x == 0)
    {
      pthread_create(&x11_set.thread, (const union pthread_attr_t *)(void *)0, (void * (*)(void *))(void *)startx, (void *)&x11_set);
      pthread_detach(x11_set.thread);
    }

    while((_Bool)1)
    {
      pthread_mutex_lock(&update_lock);
      while(!(update_count >= 1))
        pthread_cond_wait(&update_cv, &update_lock);
      if(!(flag_verbose == 0))
        printf("%d > ", update_count);

      update_count = update_count - 1;
      pthread_mutex_unlock(&update_lock);
      tmp_mbox = mbox;
      for( ; !(tmp_mbox == ((struct mbox_struct *)NULL)); tmp_mbox = tmp_mbox->next)
        if(!(flag_verbose == 0))
        {
          printf("[%d] ", (unsigned int)tmp_mbox->thread);
          if(!((1 & tmp_mbox->status) == 0))
            printf("R");

          else
            printf(" ");
          if(!((2 & tmp_mbox->status) == 0))
            printf("F");

          else
            printf(" ");
          if(!((4 & tmp_mbox->status) == 0))
            printf("C");

          else
            printf(" ");
          if(!((8 & tmp_mbox->status) == 0))
            printf("L");

          else
            printf(" ");
          if(!((16 & tmp_mbox->status) == 0))
            printf("T");

          else
            printf(" ");
          printf(" ");
          switch(tmp_mbox->mail)
          {
            case 0:
            {
              printf(" ");
              break;
            }
            case 1:
            {
              printf("O");
              break;
            }
            case 2:
              printf("N");
          }
          printf(" %d/%d  ", tmp_mbox->cnew, tmp_mbox->ctotal);
        }

      if(!(flag_verbose == 0))
        printf("\n");

    }
    exit(0);
  }
}

// main_loop
// file gui.c line 474
void main_loop()
{
  signed int need_redraw;
  check_mbox();
  redraw();
  x11_event();
  while((_Bool)1)
  {
    need_redraw=sleep_update(x11_set.refresh);
    if(!(need_animation == 0))
    {
      if(!(Current == ((struct XpmIcon *)NULL)))
      {
        if(!(Current->next == ((struct XpmIcon *)NULL)))
          Current = Current->next;

        else
          setup_pixmap();
      }

      need_redraw = 1;
    }

    signed int return_value_check_mbox$1;
    return_value_check_mbox$1=check_mbox();
    if(!(return_value_check_mbox$1 == 0))
      need_redraw = 1;

    if(!(need_redraw == 0))
      redraw();

    x11_event();
  }
}

// mbox_handle
// file mbox.h line 6
void mbox_handle(struct mbox_struct *mb)
{
  struct stat stat_buf;
  signed long int mod_time = (signed long int)0;
  signed long int last_size = (signed long int)0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(mb->file);
  if(return_value_strlen$1 == 0ul)
  {
    printf("asmail: mbox_handle: no mailbox file specified.\n");
    mb->status = 2;
    signal_update();
    pthread_exit((void *)0);
  }

  while((_Bool)1)
  {
    mb->status = mb->status | 1;
    signal_update();
    signed int return_value_stat$3;
    return_value_stat$3=stat(mb->file, &stat_buf);
    if(!(return_value_stat$3 == 0))
    {
      printf("asmail: mbox_handle: stat (%s) failed.\n", (const void *)mb->file);
      mb->status = 2;
      signal_update();
    }

    else
      if(!(stat_buf.st_ctim.tv_sec == mod_time) || !(stat_buf.st_size == last_size))
      {
        mod_time = stat_buf.st_ctim.tv_sec;
        last_size = stat_buf.st_size;
        signed int return_value_count$2;
        return_value_count$2=count(mb);
        if(!(return_value_count$2 == 0))
        {
          mb->status = 2;
          signal_update();
        }

        else
        {
          mb->status = 0;
          if(mb->cnew >= 1)
            mb->mail = 2;

          else
            if(mb->ctotal >= 1)
              mb->mail = 1;

            else
              mb->mail = 0;
          signal_update();
        }
      }

      else
      {
        mb->status = 0;
        signal_update();
      }
    sleep_check(mb->update);
  }
}

// mbox_thread
// file asmail.c line 759
void mbox_thread(void *ptr)
{
  struct mbox_struct *mb = (struct mbox_struct *)ptr;
  if(mb->type == 1)
    mbox_handle(mb);

  else
    if(mb->type == 2)
      maildir_handle(mb);

    else
      if(mb->type == 5)
        mh_handle(mb);

      else
        if(mb->type == 3)
          pop3_handle(mb);

        else
          if(mb->type == 4)
            imap_handle(mb);

          else
          {
            printf("Don't know how to handle the mailbox of format '%d'\n", mb->type);
            mb->status = 2;
            signal_update();
          }
  pthread_exit((void *)0);
}

// mh_handle
// file mh.h line 7
void mh_handle(struct mbox_struct *mb)
{
  signed int mod_time = 0;
  signed int ret = 0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(mb->file);
  if(return_value_strlen$1 == 0ul)
  {
    fprintf(stderr, "asmail: mh_handle: no mailbox directory specified.\n");
    mb->status = 2;
    signal_update();
    pthread_exit((void *)0);
  }

  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(mb->file);
  if(return_value_strlen$2 >= 252ul)
  {
    fprintf(stderr, "asmail: mh_handle: mailbox directory name is too long.\n");
    mb->status = 2;
    signal_update();
    pthread_exit((void *)0);
  }

  while((_Bool)1)
  {
    mb->status = mb->status | 1;
    signal_update();
    ret=count_mh(mb, &mod_time);
    if(!(ret >= 0))
    {
      mb->status = 2;
      signal_update();
    }

    else
      if(mb->cnew >= 1)
        mb->mail = 2;

      else
        if(!(mb->ctotal == 0))
          mb->mail = 1;

        else
          mb->mail = 0;
    if(mb->status == 1)
      mb->status = 0;

    signal_update();
    sleep_check(mb->update);
  }
}

// parse_cfg
// file asmail.c line 680
signed int parse_cfg(char *filename)
{
  struct _IO_FILE *f;
  struct stat f_stat;
  signed int line_counter = 0;
  char line[256l];
  char key[256l];
  char rest[256l];
  signed int return_value_stat$2;
  return_value_stat$2=stat(filename, &f_stat);
  signed int *return_value___errno_location$1;
  if(!(return_value_stat$2 == 0))
  {
    err_printf("asmail: Cannot stat the config file (%s).\n", filename);
    if(flag_config_specified == 0)
    {
      return_value___errno_location$1=__errno_location();
      if(*return_value___errno_location$1 == 2)
        return -2;

    }

    perror("asmail: parse_cfg");
    return -1;
  }

  f=fopen(filename, "r");
  char *return_value_fgets$3;
  _Bool tmp_if_expr$5;
  signed int return_value_strcasecmp$10;
  if(f == ((struct _IO_FILE *)NULL))
  {
    err_printf("asmail: Cannot open the config file (%s).\n", filename);
    perror("asmail: parse_cfg");
    return -1;
  }

  else
  {
    do
    {
      return_value_fgets$3=fgets(line, 255, f);
      if(return_value_fgets$3 == ((char *)NULL))
        break;

      line_counter = line_counter + 1;
      signed int return_value_parse_cfg_check$4;
      return_value_parse_cfg_check$4=parse_cfg_check(line);
      if(!(return_value_parse_cfg_check$4 == 0))
        return -1;

      if((signed int)line[0l] == 35)
        tmp_if_expr$5 = (_Bool)1;

      else
        tmp_if_expr$5 = (signed int)line[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$5)
      {
        sscanf(line, "%s", (const void *)key);
        signed int return_value_strcasecmp$11;
        return_value_strcasecmp$11=strcasecmp(key, "x11");
        if(return_value_strcasecmp$11 == 0)
        {
          sscanf(line, "%s %s", (const void *)key, (const void *)rest);
          signed int return_value_strcmp$7;
          return_value_strcmp$7=strcmp(rest, "{");
          if(return_value_strcmp$7 == 0)
          {
            signed int return_value_parse_cfg_x11$6;
            return_value_parse_cfg_x11$6=parse_cfg_x11(f, &line_counter, filename);
            if(!(return_value_parse_cfg_x11$6 == 0))
              return -1;

          }

        }

        else
        {
          return_value_strcasecmp$10=strcasecmp(key, "mailbox");
          if(return_value_strcasecmp$10 == 0)
          {
            sscanf(line, "%s %s", (const void *)key, (const void *)rest);
            signed int return_value_strcmp$9;
            return_value_strcmp$9=strcmp(rest, "{");
            if(return_value_strcmp$9 == 0)
            {
              signed int return_value_parse_cfg_mbox$8;
              return_value_parse_cfg_mbox$8=parse_cfg_mbox(f, &line_counter, filename);
              if(!(return_value_parse_cfg_mbox$8 == 0))
                return -1;

            }

          }

          else
          {
            printf("asmail: cannot understand config file %s\n", filename);
            printf("asmail: Offending line (%d): %s\n", line_counter, (const void *)line);
            return -1;
          }
        }
      }

    }
    while((_Bool)1);
    signed int return_value_fclose$12;
    return_value_fclose$12=fclose(f);
    if(!(return_value_fclose$12 == 0))
    {
      err_printf("asmail: Cannot close the config file (%s).\n", filename);
      perror("asmail: parse_cfg");
      return -1;
    }

    else
      if(!(passwords_in_config == 0) && (!((7u & f_stat.st_mode) == 0u) || !((56u & f_stat.st_mode) == 0u)))
      {
        if(!(flag_allow_insecure == 0))
        {
          printf("asmail: configuration file mode is insecure but '-insecure' was given.\n");
          goto __CPROVER_DUMP_L19;
        }

        printf("asmail: The configuration file has permissions for group and/or others set.\n");
        printf("asmail: Configuration file : '%s'.\n", filename);
        printf("asmail: Make sure the permissions are set to 0600 before proceeding.\n");
        return -1;
      }

      else
      {

      __CPROVER_DUMP_L19:
        ;
        return 0;
      }
  }
}

// parse_cfg_animate
// file asmail.c line 258
signed int parse_cfg_animate(struct _IO_FILE *f, signed int *line_counter, char *filename)
{
  char line[256l];
  char key[256l];
  struct pixfile *tmp_pixfile;
  char *return_value_fgets$1;
  _Bool tmp_if_expr$3;
  signed int return_value_strcasecmp$26;
  signed int return_value_strcasecmp$25;
  signed int return_value_strcasecmp$24;
  signed int return_value_strcasecmp$23;
  signed int return_value_strcmp$22;
  do
  {
    return_value_fgets$1=fgets(line, 255, f);
    if(return_value_fgets$1 == ((char *)NULL))
      break;

    *line_counter = *line_counter + 1;
    signed int return_value_parse_cfg_check$2;
    return_value_parse_cfg_check$2=parse_cfg_check(line);
    if(!(return_value_parse_cfg_check$2 == 0))
      return -1;

    if((signed int)line[0l] == 35)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (signed int)line[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$3)
    {
      sscanf(line, "%s", (const void *)key);
      signed int return_value_strcasecmp$27;
      return_value_strcasecmp$27=strcasecmp(key, "refresh");
      if(return_value_strcasecmp$27 == 0)
        sscanf(line, "%s %d", (const void *)key, &x11_set.refresh);

      else
      {
        return_value_strcasecmp$26=strcasecmp(key, "nomail");
        if(return_value_strcasecmp$26 == 0)
        {
          unsigned long int return_value_strlen$6;
          return_value_strlen$6=strlen(line);
          unsigned long int return_value_strlen$7;
          return_value_strlen$7=strlen(key);
          if(!(1ul + return_value_strlen$7 >= return_value_strlen$6))
          {
            void *return_value_malloc$4;
            return_value_malloc$4=malloc(sizeof(struct pixfile) /*264ul*/ );
            tmp_pixfile = (struct pixfile *)return_value_malloc$4;
            if(tmp_pixfile == ((struct pixfile *)NULL))
            {
              err_printf("asmail: parse_cfg_animate: failed to allocate memory for the pixfile\n");
              perror("asmail: parse_cfg_animate: ");
              return -1;
            }

            unsigned long int return_value_strlen$5;
            return_value_strlen$5=strlen(key);
            strcpy(tmp_pixfile->name, &line[(signed long int)(return_value_strlen$5 + (unsigned long int)1)]);
            tmp_pixfile->next = x11_set.nomail;
            x11_set.nomail = tmp_pixfile;
          }

        }

        else
        {
          return_value_strcasecmp$25=strcasecmp(key, "old");
          if(return_value_strcasecmp$25 == 0)
          {
            unsigned long int return_value_strlen$10;
            return_value_strlen$10=strlen(line);
            unsigned long int return_value_strlen$11;
            return_value_strlen$11=strlen(key);
            if(!(1ul + return_value_strlen$11 >= return_value_strlen$10))
            {
              void *return_value_malloc$8;
              return_value_malloc$8=malloc(sizeof(struct pixfile) /*264ul*/ );
              tmp_pixfile = (struct pixfile *)return_value_malloc$8;
              if(tmp_pixfile == ((struct pixfile *)NULL))
              {
                err_printf("asmail: parse_cfg_animate: failed to allocate memory for the pixfile\n");
                perror("asmail: parse_cfg_animate: ");
                return -1;
              }

              unsigned long int return_value_strlen$9;
              return_value_strlen$9=strlen(key);
              strcpy(tmp_pixfile->name, &line[(signed long int)(return_value_strlen$9 + (unsigned long int)1)]);
              tmp_pixfile->next = x11_set.oldmail;
              x11_set.oldmail = tmp_pixfile;
            }

          }

          else
          {
            return_value_strcasecmp$24=strcasecmp(key, "new");
            if(return_value_strcasecmp$24 == 0)
            {
              unsigned long int return_value_strlen$14;
              return_value_strlen$14=strlen(line);
              unsigned long int return_value_strlen$15;
              return_value_strlen$15=strlen(key);
              if(!(1ul + return_value_strlen$15 >= return_value_strlen$14))
              {
                void *return_value_malloc$12;
                return_value_malloc$12=malloc(sizeof(struct pixfile) /*264ul*/ );
                tmp_pixfile = (struct pixfile *)return_value_malloc$12;
                if(tmp_pixfile == ((struct pixfile *)NULL))
                {
                  err_printf("asmail: parse_cfg_animate: failed to allocate memory for the pixfile\n");
                  perror("asmail: parse_cfg_animate: ");
                  return -1;
                }

                unsigned long int return_value_strlen$13;
                return_value_strlen$13=strlen(key);
                strcpy(tmp_pixfile->name, &line[(signed long int)(return_value_strlen$13 + (unsigned long int)1)]);
                tmp_pixfile->next = x11_set.newmail;
                x11_set.newmail = tmp_pixfile;
              }

            }

            else
            {
              return_value_strcasecmp$23=strcasecmp(key, "frame");
              if(return_value_strcasecmp$23 == 0)
              {
                unsigned long int return_value_strlen$20;
                return_value_strlen$20=strlen(line);
                unsigned long int return_value_strlen$21;
                return_value_strlen$21=strlen(key);
                if(!(1ul + return_value_strlen$21 >= return_value_strlen$20))
                {
                  unsigned long int return_value_strlen$18;
                  return_value_strlen$18=strlen(key);
                  signed int return_value_strcasecmp$19;
                  return_value_strcasecmp$19=strcasecmp(&line[(signed long int)(return_value_strlen$18 + (unsigned long int)1)], "none");
                  if(return_value_strcasecmp$19 == 0)
                    x11_set.use_frame = 0;

                  else
                  {
                    void *return_value_malloc$16;
                    return_value_malloc$16=malloc(sizeof(struct pixfile) /*264ul*/ );
                    tmp_pixfile = (struct pixfile *)return_value_malloc$16;
                    if(tmp_pixfile == ((struct pixfile *)NULL))
                    {
                      err_printf("asmail: parse_cfg_animate: failed to allocate memory for the pixfile\n");
                      perror("asmail: parse_cfg_animate: ");
                      return -1;
                    }

                    unsigned long int return_value_strlen$17;
                    return_value_strlen$17=strlen(key);
                    strcpy(tmp_pixfile->name, &line[(signed long int)(return_value_strlen$17 + (unsigned long int)1)]);
                    tmp_pixfile->next = x11_set.frame;
                    x11_set.frame = tmp_pixfile;
                    x11_set.use_frame = 1;
                  }
                }

              }

              else
              {
                return_value_strcmp$22=strcmp(key, "}");
                if(return_value_strcmp$22 == 0)
                  return 0;

                else
                {
                  printf("asmail: cannot understand config file %s\n", filename);
                  printf("asmail: Offending line (%d): %s\n", *line_counter, (const void *)line);
                  return -1;
                }
              }
            }
          }
        }
      }
    }

  }
  while((_Bool)1);
  printf("asmail: Did not find terminating '}' for animate configuration block.\n");
  return -1;
}

// parse_cfg_check
// file asmail.c line 240
signed int parse_cfg_check(char *line)
{
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(line);
  if(!((signed int)line[-1l + (signed long int)return_value_strlen$2] == 10))
  {
    printf("asmail: a line in configuration is too long, maximum length is %d.\n", 255);
    unsigned long int return_value_strlen$1;
    return_value_strlen$1=strlen(line);
    printf("asmail: Offending line (%d chars): %s\n", (unsigned int)return_value_strlen$1, line);
    return -1;
  }

  shorten(line);
  return 0;
}

// parse_cfg_mbox
// file asmail.c line 538
signed int parse_cfg_mbox(struct _IO_FILE *f, signed int *line_counter, char *filename)
{
  char line[256l];
  char key[256l];
  char rest[256l];
  struct mbox_struct *new_mbox;
  char *str_ptr;
  signed int return_value_init_mbox$1;
  return_value_init_mbox$1=init_mbox(&new_mbox);
  char *return_value_fgets$2;
  _Bool tmp_if_expr$4;
  signed int return_value_strcasecmp$8;
  signed int return_value_strcasecmp$7;
  signed int return_value_strcasecmp$6;
  signed int return_value_strcasecmp$5;
  signed int return_value_strcasecmp$32;
  signed int return_value_strcasecmp$31;
  signed int return_value_strcasecmp$30;
  signed int return_value_strcasecmp$29;
  signed int return_value_strcasecmp$28;
  signed int return_value_strcasecmp$27;
  signed int return_value_strcasecmp$11;
  signed int return_value_strcasecmp$26;
  signed int return_value_strcasecmp$25;
  signed int return_value_strcasecmp$24;
  signed int return_value_strcasecmp$23;
  signed int return_value_strcasecmp$22;
  signed int return_value_strcasecmp$21;
  signed int return_value_strcasecmp$20;
  signed int return_value_strcasecmp$19;
  signed int return_value_strcmp$18;
  if(!(return_value_init_mbox$1 == 0))
    return -1;

  else
  {
    do
    {
      return_value_fgets$2=fgets(line, 255, f);
      if(return_value_fgets$2 == ((char *)NULL))
        break;

      *line_counter = *line_counter + 1;
      signed int return_value_parse_cfg_check$3;
      return_value_parse_cfg_check$3=parse_cfg_check(line);
      if(!(return_value_parse_cfg_check$3 == 0))
        return -1;

      if((signed int)line[0l] == 35)
        tmp_if_expr$4 = (_Bool)1;

      else
        tmp_if_expr$4 = (signed int)line[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$4)
      {
        sscanf(line, "%s", (const void *)key);
        signed int return_value_strcasecmp$33;
        return_value_strcasecmp$33=strcasecmp(key, "type");
        if(return_value_strcasecmp$33 == 0)
        {
          sscanf(line, "%s %s", (const void *)key, (const void *)rest);
          signed int return_value_strcasecmp$9;
          return_value_strcasecmp$9=strcasecmp(rest, "mbox");
          if(return_value_strcasecmp$9 == 0)
            new_mbox->type = 1;

          else
          {
            return_value_strcasecmp$8=strcasecmp(rest, "maildir");
            if(return_value_strcasecmp$8 == 0)
              new_mbox->type = 2;

            else
            {
              return_value_strcasecmp$7=strcasecmp(rest, "mh");
              if(return_value_strcasecmp$7 == 0)
                new_mbox->type = 5;

              else
              {
                return_value_strcasecmp$6=strcasecmp(rest, "pop3");
                if(return_value_strcasecmp$6 == 0)
                  new_mbox->type = 3;

                else
                {
                  return_value_strcasecmp$5=strcasecmp(rest, "imap");
                  if(return_value_strcasecmp$5 == 0)
                    new_mbox->type = 4;

                  else
                  {
                    printf("asmail: don't know how to handle mailbox type '%s'\n", (const void *)rest);
                    printf("asmail: Offending line (%d): %s\n", *line_counter, (const void *)line);
                  }
                }
              }
            }
          }
        }

        else
        {
          return_value_strcasecmp$32=strcasecmp(key, "update");
          if(return_value_strcasecmp$32 == 0)
            sscanf(line, "%s %d", (const void *)key, &new_mbox->update);

          else
          {
            return_value_strcasecmp$31=strcasecmp(key, "file");
            if(return_value_strcasecmp$31 == 0)
              sscanf(line, "%s %s", (const void *)key, (const void *)new_mbox->file);

            else
            {
              return_value_strcasecmp$30=strcasecmp(key, "server");
              if(return_value_strcasecmp$30 == 0)
                sscanf(line, "%s %s", (const void *)key, (const void *)new_mbox->server);

              else
              {
                return_value_strcasecmp$29=strcasecmp(key, "user");
                if(return_value_strcasecmp$29 == 0)
                  sscanf(line, "%s %s", (const void *)key, (const void *)new_mbox->user);

                else
                {
                  return_value_strcasecmp$28=strcasecmp(key, "password");
                  if(return_value_strcasecmp$28 == 0)
                  {
                    sscanf(line, "%s %s", (const void *)key, (const void *)new_mbox->pass);
                    passwords_in_config = 1;
                  }

                  else
                  {
                    return_value_strcasecmp$27=strcasecmp(key, "auth");
                    if(return_value_strcasecmp$27 == 0)
                    {
                      new_mbox->auth = 0;
                      unsigned long int return_value_strlen$13;
                      return_value_strlen$13=strlen(line);
                      unsigned long int return_value_strlen$14;
                      return_value_strlen$14=strlen(key);
                      if(!(1ul + return_value_strlen$14 >= return_value_strlen$13))
                      {
                        new_mbox->auth = 0;
                        unsigned long int return_value_strlen$10;
                        return_value_strlen$10=strlen(key);
                        strcpy(rest, &line[(signed long int)(return_value_strlen$10 + (unsigned long int)1)]);
                        str_ptr=strtok(rest, " \t\n");
                        while(!(str_ptr == ((char *)NULL)))
                        {
                          sscanf(str_ptr, "%s", (const void *)key);
                          signed int return_value_strcasecmp$12;
                          return_value_strcasecmp$12=strcasecmp(key, "plain");
                          if(return_value_strcasecmp$12 == 0)
                            new_mbox->auth = new_mbox->auth | 1;

                          else
                          {
                            return_value_strcasecmp$11=strcasecmp(key, "md5");
                            if(return_value_strcasecmp$11 == 0)
                              new_mbox->auth = new_mbox->auth | 2;

                            else
                            {
                              printf("asmail: cannot understand authorisation scheme '%s'\n", (const void *)key);
                              printf("asmail: Offending configuration line (%d): %s\n", *line_counter, (const void *)line);
                              return -1;
                            }
                          }
                          str_ptr=strtok((char *)(void *)0, " \t\n");
                        }
                      }

                    }

                    else
                    {
                      return_value_strcasecmp$26=strcasecmp(key, "port");
                      if(return_value_strcasecmp$26 == 0)
                        sscanf(line, "%s %d", (const void *)key, &new_mbox->port);

                      else
                      {
                        return_value_strcasecmp$25=strcasecmp(key, "timeout");
                        if(return_value_strcasecmp$25 == 0)
                          sscanf(line, "%s %d", (const void *)key, &new_mbox->timeout);

                        else
                        {
                          return_value_strcasecmp$24=strcasecmp(key, "mailbox");
                          if(return_value_strcasecmp$24 == 0)
                            sscanf(line, "%s %s", (const void *)key, (const void *)new_mbox->mbox);

                          else
                          {
                            return_value_strcasecmp$23=strcasecmp(key, "unread-is-new");
                            if(return_value_strcasecmp$23 == 0)
                            {
                              sscanf(line, "%s %s", (const void *)key, (const void *)rest);
                              signed int return_value_strcasecmp$15;
                              return_value_strcasecmp$15=strcasecmp(rest, "yes");
                              if(return_value_strcasecmp$15 == 0)
                                new_mbox->flags = new_mbox->flags | 1;

                              else
                                new_mbox->flags = new_mbox->flags & ~1;
                            }

                            else
                            {
                              return_value_strcasecmp$22=strcasecmp(key, "use-mh-sequences");
                              if(return_value_strcasecmp$22 == 0)
                              {
                                sscanf(line, "%s %s", (const void *)key, (const void *)rest);
                                signed int return_value_strcasecmp$16;
                                return_value_strcasecmp$16=strcasecmp(rest, "yes");
                                if(return_value_strcasecmp$16 == 0)
                                  new_mbox->flags = new_mbox->flags | 4;

                                else
                                  new_mbox->flags = new_mbox->flags & ~4;
                              }

                              else
                              {
                                return_value_strcasecmp$21=strcasecmp(key, "persistent");
                                if(return_value_strcasecmp$21 == 0)
                                {
                                  sscanf(line, "%s %s", (const void *)key, (const void *)rest);
                                  signed int return_value_strcasecmp$17;
                                  return_value_strcasecmp$17=strcasecmp(rest, "yes");
                                  if(return_value_strcasecmp$17 == 0)
                                    new_mbox->flags = new_mbox->flags | 8;

                                  else
                                    new_mbox->flags = new_mbox->flags & ~8;
                                }

                                else
                                {
                                  return_value_strcasecmp$20=strcasecmp(key, "ssl");
                                  if(return_value_strcasecmp$20 == 0)
                                    printf("asmail: ssl support is not available, ignoring ssl statement\n");

                                  else
                                  {
                                    return_value_strcasecmp$19=strcasecmp(key, "trustedCaDir");
                                    if(return_value_strcasecmp$19 == 0)
                                      printf("asmail: ssl support is not available, ignoring trustedCaDir statement\n");

                                    else
                                    {
                                      return_value_strcmp$18=strcmp(key, "}");
                                      if(return_value_strcmp$18 == 0)
                                      {
                                        if(!((16 & new_mbox->flags) == 0))
                                        {
                                          if(!(new_mbox->type == 4))
                                            printf("asmail: ssl is only supported with imap mailboxes, ignoring ssl statement\n");

                                        }

                                        new_mbox->next = mbox;
                                        mbox = new_mbox;
                                        return 0;
                                      }

                                      else
                                      {
                                        printf("asmail: cannot understand config file %s\n", filename);
                                        printf("asmail: Offending line (%d): %s\n", *line_counter, (const void *)line);
                                        return -1;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

    }
    while((_Bool)1);
    printf("asmail: Did not find terminating '}' for mailbox configuration block.\n");
    return -1;
  }
}

// parse_cfg_stat
// file asmail.c line 355
signed int parse_cfg_stat(struct _IO_FILE *f, signed int *line_counter, char *filename)
{
  char line[256l];
  char key[256l];
  char rest[256l];
  char *return_value_fgets$1;
  _Bool tmp_if_expr$3;
  signed int return_value_strcasecmp$24;
  signed int return_value_strcasecmp$23;
  signed int return_value_strcasecmp$22;
  signed int return_value_strcasecmp$21;
  signed int return_value_strcasecmp$20;
  signed int return_value_strcasecmp$19;
  signed int return_value_strcasecmp$18;
  signed int return_value_strcasecmp$17;
  signed int return_value_strcasecmp$16;
  signed int return_value_strcmp$15;
  do
  {
    return_value_fgets$1=fgets(line, 255, f);
    if(return_value_fgets$1 == ((char *)NULL))
      break;

    *line_counter = *line_counter + 1;
    signed int return_value_parse_cfg_check$2;
    return_value_parse_cfg_check$2=parse_cfg_check(line);
    if(!(return_value_parse_cfg_check$2 == 0))
      return -1;

    if((signed int)line[0l] == 35)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (signed int)line[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$3)
    {
      sscanf(line, "%s", (const void *)key);
      signed int return_value_strcasecmp$25;
      return_value_strcasecmp$25=strcasecmp(key, "total");
      if(return_value_strcasecmp$25 == 0)
      {
        sscanf(line, "%s %s", (const void *)key, (const void *)rest);
        signed int return_value_strcasecmp$4;
        return_value_strcasecmp$4=strcasecmp(rest, "yes");
        x11_set.total = return_value_strcasecmp$4 != 0 ? 0 : 1;
      }

      else
      {
        return_value_strcasecmp$24=strcasecmp(key, "each");
        if(return_value_strcasecmp$24 == 0)
        {
          sscanf(line, "%s %s", (const void *)key, (const void *)rest);
          signed int return_value_strcasecmp$5;
          return_value_strcasecmp$5=strcasecmp(rest, "yes");
          x11_set.each = return_value_strcasecmp$5 != 0 ? 0 : 1;
        }

        else
        {
          return_value_strcasecmp$23=strcasecmp(key, "status");
          if(return_value_strcasecmp$23 == 0)
          {
            sscanf(line, "%s %s", (const void *)key, (const void *)rest);
            signed int return_value_strcasecmp$6;
            return_value_strcasecmp$6=strcasecmp(rest, "yes");
            x11_set.status = return_value_strcasecmp$6 != 0 ? 0 : 1;
          }

          else
          {
            return_value_strcasecmp$22=strcasecmp(key, "old");
            if(return_value_strcasecmp$22 == 0)
            {
              sscanf(line, "%s %s", (const void *)key, (const void *)rest);
              signed int return_value_strcasecmp$7;
              return_value_strcasecmp$7=strcasecmp(rest, "yes");
              x11_set.old = return_value_strcasecmp$7 != 0 ? 0 : 1;
            }

            else
            {
              return_value_strcasecmp$21=strcasecmp(key, "new");
              if(return_value_strcasecmp$21 == 0)
              {
                sscanf(line, "%s %s", (const void *)key, (const void *)rest);
                signed int return_value_strcasecmp$8;
                return_value_strcasecmp$8=strcasecmp(rest, "yes");
                x11_set.new = return_value_strcasecmp$8 != 0 ? 0 : 1;
              }

              else
              {
                return_value_strcasecmp$20=strcasecmp(key, "x");
                if(return_value_strcasecmp$20 == 0)
                  sscanf(line, "%s %d", (const void *)key, &x11_set.x);

                else
                {
                  return_value_strcasecmp$19=strcasecmp(key, "y");
                  if(return_value_strcasecmp$19 == 0)
                    sscanf(line, "%s %d", (const void *)key, &x11_set.y);

                  else
                  {
                    return_value_strcasecmp$18=strcasecmp(key, "delimiter");
                    if(return_value_strcasecmp$18 == 0)
                    {
                      unsigned long int return_value_strlen$10;
                      return_value_strlen$10=strlen(line);
                      unsigned long int return_value_strlen$11;
                      return_value_strlen$11=strlen(key);
                      if(!(1ul + return_value_strlen$11 >= return_value_strlen$10))
                      {
                        unsigned long int return_value_strlen$9;
                        return_value_strlen$9=strlen(key);
                        strcpy(x11_set.delimiter, &line[(signed long int)(return_value_strlen$9 + (unsigned long int)1)]);
                        strip_quotes(x11_set.delimiter);
                      }

                    }

                    else
                    {
                      return_value_strcasecmp$17=strcasecmp(key, "font");
                      if(return_value_strcasecmp$17 == 0)
                        sscanf(line, "%s %s", (const void *)key, (const void *)x11_set.font);

                      else
                      {
                        return_value_strcasecmp$16=strcasecmp(key, "color");
                        if(return_value_strcasecmp$16 == 0)
                        {
                          unsigned long int return_value_strlen$13;
                          return_value_strlen$13=strlen(line);
                          unsigned long int return_value_strlen$14;
                          return_value_strlen$14=strlen(key);
                          if(!(1ul + return_value_strlen$14 >= return_value_strlen$13))
                          {
                            unsigned long int return_value_strlen$12;
                            return_value_strlen$12=strlen(key);
                            strcpy(x11_set.color, &line[(signed long int)(return_value_strlen$12 + (unsigned long int)1)]);
                            strip_quotes(x11_set.color);
                          }

                        }

                        else
                        {
                          return_value_strcmp$15=strcmp(key, "}");
                          if(return_value_strcmp$15 == 0)
                            return 0;

                          else
                          {
                            printf("asmail: cannot understand config file %s\n", filename);
                            printf("asmail: Offending line (%d): %s\n", *line_counter, (const void *)line);
                            return -1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

  }
  while((_Bool)1);
  printf("asmail: Did not find terminating '}' for stat configuration block.\n");
  return -1;
}

// parse_cfg_x11
// file asmail.c line 423
signed int parse_cfg_x11(struct _IO_FILE *f, signed int *line_counter, char *filename)
{
  char line[256l];
  char key[256l];
  char rest[256l];
  char *return_value_fgets$1;
  _Bool tmp_if_expr$3;
  signed int return_value_strcasecmp$33;
  signed int return_value_strcasecmp$32;
  signed int return_value_strcasecmp$31;
  signed int return_value_strcasecmp$30;
  signed int return_value_strcasecmp$29;
  signed int return_value_strcasecmp$28;
  signed int return_value_strcasecmp$27;
  signed int return_value_strcasecmp$26;
  signed int return_value_strcmp$25;
  do
  {
    return_value_fgets$1=fgets(line, 255, f);
    if(return_value_fgets$1 == ((char *)NULL))
      break;

    *line_counter = *line_counter + 1;
    signed int return_value_parse_cfg_check$2;
    return_value_parse_cfg_check$2=parse_cfg_check(line);
    if(!(return_value_parse_cfg_check$2 == 0))
      return -1;

    if((signed int)line[0l] == 35)
      tmp_if_expr$3 = (_Bool)1;

    else
      tmp_if_expr$3 = (signed int)line[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr$3)
    {
      sscanf(line, "%s", (const void *)key);
      signed int return_value_strcasecmp$34;
      return_value_strcasecmp$34=strcasecmp(key, "beep");
      if(return_value_strcasecmp$34 == 0)
      {
        sscanf(line, "%s %s", (const void *)key, (const void *)rest);
        signed int return_value_strcasecmp$4;
        return_value_strcasecmp$4=strcasecmp(rest, "yes");
        x11_set.beep = return_value_strcasecmp$4 != 0 ? 0 : 1;
      }

      else
      {
        return_value_strcasecmp$33=strcasecmp(key, "shape");
        if(return_value_strcasecmp$33 == 0)
        {
          sscanf(line, "%s %s", (const void *)key, (const void *)rest);
          signed int return_value_strcasecmp$5;
          return_value_strcasecmp$5=strcasecmp(rest, "yes");
          x11_set.shape = return_value_strcasecmp$5 != 0 ? 0 : 1;
        }

        else
        {
          return_value_strcasecmp$32=strcasecmp(key, "on_mouse_left");
          if(return_value_strcasecmp$32 == 0)
          {
            unsigned long int return_value_strlen$7;
            return_value_strlen$7=strlen(line);
            unsigned long int return_value_strlen$8;
            return_value_strlen$8=strlen(key);
            if(!(1ul + return_value_strlen$8 >= return_value_strlen$7))
            {
              unsigned long int return_value_strlen$6;
              return_value_strlen$6=strlen(key);
              strcpy(x11_set.on_left, &line[(signed long int)(return_value_strlen$6 + (unsigned long int)1)]);
            }

          }

          else
          {
            return_value_strcasecmp$31=strcasecmp(key, "on_mouse_middle");
            if(return_value_strcasecmp$31 == 0)
            {
              unsigned long int return_value_strlen$10;
              return_value_strlen$10=strlen(line);
              unsigned long int return_value_strlen$11;
              return_value_strlen$11=strlen(key);
              if(!(1ul + return_value_strlen$11 >= return_value_strlen$10))
              {
                unsigned long int return_value_strlen$9;
                return_value_strlen$9=strlen(key);
                strcpy(x11_set.on_middle, &line[(signed long int)(return_value_strlen$9 + (unsigned long int)1)]);
              }

            }

            else
            {
              return_value_strcasecmp$30=strcasecmp(key, "on_mouse_right");
              if(return_value_strcasecmp$30 == 0)
              {
                unsigned long int return_value_strlen$13;
                return_value_strlen$13=strlen(line);
                unsigned long int return_value_strlen$14;
                return_value_strlen$14=strlen(key);
                if(!(1ul + return_value_strlen$14 >= return_value_strlen$13))
                {
                  unsigned long int return_value_strlen$12;
                  return_value_strlen$12=strlen(key);
                  strcpy(x11_set.on_right, &line[(signed long int)(return_value_strlen$12 + (unsigned long int)1)]);
                }

              }

              else
              {
                return_value_strcasecmp$29=strcasecmp(key, "on_new_mail");
                if(return_value_strcasecmp$29 == 0)
                {
                  unsigned long int return_value_strlen$16;
                  return_value_strlen$16=strlen(line);
                  unsigned long int return_value_strlen$17;
                  return_value_strlen$17=strlen(key);
                  if(!(1ul + return_value_strlen$17 >= return_value_strlen$16))
                  {
                    unsigned long int return_value_strlen$15;
                    return_value_strlen$15=strlen(key);
                    strcpy(x11_set.on_new_mail, &line[(signed long int)(return_value_strlen$15 + (unsigned long int)1)]);
                  }

                }

                else
                {
                  return_value_strcasecmp$28=strcasecmp(key, "font");
                  if(return_value_strcasecmp$28 == 0)
                  {
                    unsigned long int return_value_strlen$19;
                    return_value_strlen$19=strlen(line);
                    unsigned long int return_value_strlen$20;
                    return_value_strlen$20=strlen(key);
                    if(!(1ul + return_value_strlen$20 >= return_value_strlen$19))
                    {
                      unsigned long int return_value_strlen$18;
                      return_value_strlen$18=strlen(key);
                      strcpy(x11_set.font, &line[(signed long int)(return_value_strlen$18 + (unsigned long int)1)]);
                    }

                  }

                  else
                  {
                    return_value_strcasecmp$27=strcasecmp(key, "stat");
                    if(return_value_strcasecmp$27 == 0)
                    {
                      sscanf(line, "%s %s", (const void *)key, (const void *)rest);
                      signed int return_value_strcmp$22;
                      return_value_strcmp$22=strcmp(rest, "{");
                      if(return_value_strcmp$22 == 0)
                      {
                        signed int return_value_parse_cfg_stat$21;
                        return_value_parse_cfg_stat$21=parse_cfg_stat(f, line_counter, filename);
                        if(!(return_value_parse_cfg_stat$21 == 0))
                          return -1;

                      }

                    }

                    else
                    {
                      return_value_strcasecmp$26=strcasecmp(key, "animate");
                      if(return_value_strcasecmp$26 == 0)
                      {
                        sscanf(line, "%s %s", (const void *)key, (const void *)rest);
                        signed int return_value_strcmp$24;
                        return_value_strcmp$24=strcmp(rest, "{");
                        if(return_value_strcmp$24 == 0)
                        {
                          signed int return_value_parse_cfg_animate$23;
                          return_value_parse_cfg_animate$23=parse_cfg_animate(f, line_counter, filename);
                          if(!(return_value_parse_cfg_animate$23 == 0))
                            return -1;

                        }

                      }

                      else
                      {
                        return_value_strcmp$25=strcmp(key, "}");
                        if(return_value_strcmp$25 == 0)
                          return 0;

                        else
                        {
                          printf("asmail: cannot understand config file %s\n", filename);
                          printf("asmail: Offending line (%d): %s\n", *line_counter, (const void *)line);
                          return -1;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

  }
  while((_Bool)1);
  printf("asmail: Did not find terminating '}' for X11 configuration block.\n");
  return -1;
}

// parse_cmd
// file asmail.c line 124
signed int parse_cmd(signed int argc, char **argv)
{
  signed int i = 1;
  signed int return_value_strcmp$10;
  signed int return_value_strcmp$9;
  signed int return_value_strcmp$8;
  signed int return_value_strcmp$7;
  signed int return_value_strcmp$6;
  signed int return_value_strcmp$5;
  signed int return_value_strcmp$4;
  signed int return_value_strcmp$3;
  signed int return_value_strcmp$2;
  signed int return_value_strcmp$1;
  for( ; !(i >= argc); i = i + 1)
  {
    signed int return_value_strcmp$11;
    return_value_strcmp$11=strcmp(argv[(signed long int)i], "-geometry");
    if(return_value_strcmp$11 == 0)
    {
      i = i + 1;
      if(i >= argc)
      {
        usage();
        return -1;
      }

      strncpy(x11_set.geometry, argv[(signed long int)i], (unsigned long int)255);
    }

    else
    {
      return_value_strcmp$10=strcmp(argv[(signed long int)i], "-title");
      if(return_value_strcmp$10 == 0)
      {
        i = i + 1;
        if(i >= argc)
        {
          usage();
          return -1;
        }

        strncpy(x11_set.title, argv[(signed long int)i], (unsigned long int)255);
      }

      else
      {
        return_value_strcmp$9=strcmp(argv[(signed long int)i], "-f");
        if(return_value_strcmp$9 == 0)
        {
          i = i + 1;
          if(i >= argc)
          {
            usage();
            return -1;
          }

          strncpy(config_file_name, argv[(signed long int)i], (unsigned long int)255);
          flag_config_specified = 1;
        }

        else
        {
          return_value_strcmp$8=strcmp(argv[(signed long int)i], "-V");
          if(return_value_strcmp$8 == 0)
          {
            version();
            return -1;
          }

          else
          {
            return_value_strcmp$7=strcmp(argv[(signed long int)i], "-h");
            if(return_value_strcmp$7 == 0)
            {
              usage();
              return -1;
            }

            else
            {
              return_value_strcmp$6=strcmp(argv[(signed long int)i], "-v");
              if(return_value_strcmp$6 == 0)
                flag_verbose = 1;

              else
              {
                return_value_strcmp$5=strcmp(argv[(signed long int)i], "-nox");
                if(return_value_strcmp$5 == 0)
                {
                  flag_verbose = 1;
                  flag_no_x = 1;
                }

                else
                {
                  return_value_strcmp$4=strcmp(argv[(signed long int)i], "-noconfig");
                  if(return_value_strcmp$4 == 0)
                    flag_no_config = 1;

                  else
                  {
                    return_value_strcmp$3=strcmp(argv[(signed long int)i], "-iconic");
                    if(return_value_strcmp$3 == 0)
                      x11_set.iconic = 1;

                    else
                    {
                      return_value_strcmp$2=strcmp(argv[(signed long int)i], "-withdrawn");
                      if(return_value_strcmp$2 == 0)
                        x11_set.withdrawn = 1;

                      else
                      {
                        return_value_strcmp$1=strcmp(argv[(signed long int)i], "-insecure");
                        if(return_value_strcmp$1 == 0)
                          flag_allow_insecure = 1;

                        else
                          if((signed int)*argv[(signed long int)i] == 45)
                          {
                            printf("asmail: Unknown option: %s\n", argv[(signed long int)i]);
                            usage();
                            return -1;
                          }

                          else
                          {
                            strncpy(config_file_name, argv[(signed long int)i], (unsigned long int)255);
                            flag_config_specified = 1;
                          }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

// parse_sequence
// file mh.c line 333
signed int parse_sequence(char *sequence)
{
  char *p;
  signed int a;
  signed int b;
  p = sequence;
  for( ; !((signed int)*p == 0); p = p + 1l)
    if((signed int)*p == 45)
    {
      *p = (char)0;
      p = p + 1l;
      a=atoi(sequence);
      b=atoi(p);
      return (b - a) + 1;
    }

  return 1;
}

// pop3_handle
// file pop3.h line 15
void pop3_handle(struct mbox_struct *mb)
{
  if(!(mb->type == 3))
  {
    printf("asmail: pop3_handle: Cowardly refusing to work with a non-POP3 server.\n");
    mb->status = 2;
    pthread_exit((void *)0);
  }

  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(mb->server);
  if(return_value_strlen$1 == 0ul)
  {
    printf("asmail: pop3_handle: no server name specified!\n");
    mb->status = 2;
    pthread_exit((void *)0);
  }

  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(mb->user);
  if(return_value_strlen$2 == 0ul)
  {
    printf("asmail: pop3_handle: no user name specified!\n");
    mb->status = 2;
    pthread_exit((void *)0);
  }

  if(mb->port == 0)
    mb->port = 110;

  while((_Bool)1)
  {
    mb->status = mb->status | 1;
    signal_update();
    mb->status=pop3_mailcheck(mb);
    if(mb->status == 0)
    {
      mb->status = 0;
      if(mb->cnew >= 1)
        mb->mail = 2;

      else
        if(mb->ctotal >= 1)
          mb->mail = 1;

        else
          mb->mail = 0;
    }

    signal_update();
    sleep_check(mb->update);
  }
}

// pop3_mailcheck
// file pop3.c line 50
signed int pop3_mailcheck(struct mbox_struct *mb)
{
  struct anonymous$18 *s;
  char input[256l];
  char output[256l];
  char key[256l];
  signed int ctotal;
  char md5_digest[16l];
  char *str_ptr;
  char *str_end;
  char *str_target;
  signed int i;
  struct anonymous$17 mdc;
  s=Sopen();
  _Bool tmp_if_expr$20;
  _Bool tmp_if_expr$22;
  char *return_value_strchr$21;
  _Bool tmp_if_expr$23;
  char *tmp_post$4;
  char *tmp_post$5;
  if(s == ((struct anonymous$18 *)NULL))
    return 2;

  else
  {
    signed int return_value_Sclient$1;
    return_value_Sclient$1=Sclient(s, mb->server, mb->port);
    if(return_value_Sclient$1 == -1)
    {
      Sclose(s);
      return 4;
    }

    else
    {
      unsigned long int return_value_Sread$2;
      return_value_Sread$2=Sread(s->sd, input, 255, mb->timeout);
      if(!(return_value_Sread$2 == 18446744073709551615ul))
      {
        if(return_value_Sread$2 == 0ul)
          goto __CPROVER_DUMP_L4;

      }

      else
      {
        Sclose(s);
        return 4;

      __CPROVER_DUMP_L4:
        ;
        Sclose(s);
        return 16;
      }
      sscanf(input, "%5s", (const void *)key);
      signed int return_value_strcmp$3;
      return_value_strcmp$3=strcmp(key, "+OK");
      if(!(return_value_strcmp$3 == 0))
      {
        Sclose(s);
        return 4;
      }

      else
      {
        if(!((2 & mb->auth) == 0))
        {
          str_ptr=strchr(input, 60);
          tmp_if_expr$20 = str_ptr != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$20 = (_Bool)0;
        if(tmp_if_expr$20)
        {
          return_value_strchr$21=strchr(input, 64);
          tmp_if_expr$22 = return_value_strchr$21 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$22 = (_Bool)0;
        if(tmp_if_expr$22)
        {
          str_end=strchr(input, 62);
          tmp_if_expr$23 = str_end != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr$23 = (_Bool)0;
        if(!(str_ptr >= str_end) && tmp_if_expr$23)
        {
          str_target = key;
          for( ; str_end >= str_ptr; *tmp_post$4 = *tmp_post$5)
          {
            tmp_post$4 = str_target;
            str_target = str_target + 1l;
            tmp_post$5 = str_ptr;
            str_ptr = str_ptr + 1l;
          }
          *str_target = (char)0;
          strcat(key, mb->pass);
          pthread_mutex_lock(&md5_lock);
          MD5Init(&mdc);
          unsigned long int return_value_strlen$6;
          return_value_strlen$6=strlen(key);
          MD5Update(&mdc, (unsigned char *)key, (unsigned int)return_value_strlen$6);
          MD5Final((unsigned char *)md5_digest, &mdc);
          pthread_mutex_unlock(&md5_lock);
          str_target = key;
          i = 0;
          for( ; !(i >= 16); i = i + 1)
          {
            sprintf(str_target, "%02x", (unsigned char)md5_digest[(signed long int)i]);
            str_target = str_target + (signed long int)2;
          }
          str_target[(signed long int)(16 * 2)] = (char)0;
          sprintf(output, "APOP %s %s\r\n", (const void *)mb->user, (const void *)key);
          unsigned long int return_value_Swrite$7;
          return_value_Swrite$7=Swrite(s->sd, output);
          if(return_value_Swrite$7 == 18446744073709551615ul)
          {
            Sclose(s);
            return 4;
          }

          unsigned long int return_value_Sread$8;
          return_value_Sread$8=Sread(s->sd, input, 255, mb->timeout);
          if(!(return_value_Sread$8 == 18446744073709551615ul))
          {
            if(return_value_Sread$8 == 0ul)
              goto __CPROVER_DUMP_L19;

          }

          else
          {
            Sclose(s);
            return 4;

          __CPROVER_DUMP_L19:
            ;
            Sclose(s);
            return 16;
          }
          sscanf(input, "%5s", (const void *)key);
          signed int return_value_strcmp$10;
          return_value_strcmp$10=strcmp(key, "+OK");
          if(!(return_value_strcmp$10 == 0))
          {
            sprintf(output, "QUIT\r\n");
            unsigned long int return_value_Swrite$9;
            return_value_Swrite$9=Swrite(s->sd, output);
            if(return_value_Swrite$9 == 18446744073709551615ul)
            {
              Sclose(s);
              return 4;
            }

            Sclose(s);
            return 8;
          }

        }

        else
          if(!((1 & mb->auth) == 0))
          {
            sprintf(output, "USER %s\r\n", (const void *)mb->user);
            unsigned long int return_value_Swrite$11;
            return_value_Swrite$11=Swrite(s->sd, output);
            if(return_value_Swrite$11 == 18446744073709551615ul)
            {
              Sclose(s);
              return 4;
            }

            unsigned long int return_value_Sread$12;
            return_value_Sread$12=Sread(s->sd, input, 255, mb->timeout);
            if(!(return_value_Sread$12 == 18446744073709551615ul))
            {
              if(return_value_Sread$12 == 0ul)
                goto __CPROVER_DUMP_L26;

            }

            else
            {
              Sclose(s);
              return 4;

            __CPROVER_DUMP_L26:
              ;
              Sclose(s);
              return 16;
            }
            sscanf(input, "%5s", (const void *)key);
            signed int return_value_strcmp$14;
            return_value_strcmp$14=strcmp(key, "+OK");
            if(!(return_value_strcmp$14 == 0))
            {
              sprintf(output, "QUIT\r\n");
              unsigned long int return_value_Swrite$13;
              return_value_Swrite$13=Swrite(s->sd, output);
              if(return_value_Swrite$13 == 18446744073709551615ul)
              {
                Sclose(s);
                return 4;
              }

              Sclose(s);
              return 8;
            }

            sprintf(output, "PASS %s\r\n", (const void *)mb->pass);
            unsigned long int return_value_Swrite$15;
            return_value_Swrite$15=Swrite(s->sd, output);
            if(return_value_Swrite$15 == 18446744073709551615ul)
            {
              Sclose(s);
              return 4;
            }

            unsigned long int return_value_Sread$16;
            return_value_Sread$16=Sread(s->sd, input, 255, mb->timeout);
            if(!(return_value_Sread$16 == 18446744073709551615ul))
            {
              if(return_value_Sread$16 == 0ul)
                goto __CPROVER_DUMP_L32;

            }

            else
            {
              Sclose(s);
              return 4;

            __CPROVER_DUMP_L32:
              ;
              Sclose(s);
              return 16;
            }
            sscanf(input, "%5s", (const void *)key);
            signed int return_value_strcmp$18;
            return_value_strcmp$18=strcmp(key, "+OK");
            if(!(return_value_strcmp$18 == 0))
            {
              sprintf(output, "QUIT\r\n");
              unsigned long int return_value_Swrite$17;
              return_value_Swrite$17=Swrite(s->sd, output);
              if(return_value_Swrite$17 == 18446744073709551615ul)
              {
                Sclose(s);
                return 4;
              }

              Sclose(s);
              return 8;
            }

          }

          else
          {
            printf("asmail: pop3_mailcheck: specified login method is unsupported by POP server.\n");
            sprintf(output, "QUIT\r\n");
            unsigned long int return_value_Swrite$19;
            return_value_Swrite$19=Swrite(s->sd, output);
            if(return_value_Swrite$19 == 18446744073709551615ul)
            {
              Sclose(s);
              return 4;
            }

            Sclose(s);
            return 8;
          }
        sprintf(output, "STAT\r\n");
        unsigned long int return_value_Swrite$24;
        return_value_Swrite$24=Swrite(s->sd, output);
        if(return_value_Swrite$24 == 18446744073709551615ul)
        {
          Sclose(s);
          return 4;
        }

        else
        {
          unsigned long int return_value_Sread$25;
          return_value_Sread$25=Sread(s->sd, input, 255, mb->timeout);
          if(!(return_value_Sread$25 == 18446744073709551615ul))
          {
            if(return_value_Sread$25 == 0ul)
              goto __CPROVER_DUMP_L41;

          }

          else
          {
            Sclose(s);
            return 4;

          __CPROVER_DUMP_L41:
            ;
            Sclose(s);
            return 16;
          }
          sscanf(input, "%5s", (const void *)key);
          signed int return_value_strcmp$26;
          return_value_strcmp$26=strcmp(key, "+OK");
          if(!(return_value_strcmp$26 == 0))
          {
            Sclose(s);
            return 4;
          }

          else
          {
            sprintf(output, "%s %s", (const void *)"+OK", (const void *)"%d");
            sscanf(input, output, &ctotal);
            sprintf(output, "QUIT\r\n");
            unsigned long int return_value_Swrite$27;
            return_value_Swrite$27=Swrite(s->sd, output);
            if(return_value_Swrite$27 == 18446744073709551615ul)
            {
              Sclose(s);
              return 4;
            }

            else
            {
              unsigned long int return_value_Sread$28;
              return_value_Sread$28=Sread(s->sd, input, 255, mb->timeout);
              if(!(return_value_Sread$28 == 18446744073709551615ul))
              {
                if(return_value_Sread$28 == 0ul)
                  goto __CPROVER_DUMP_L46;

              }

              else
              {
                Sclose(s);
                return 4;

              __CPROVER_DUMP_L46:
                ;
                Sclose(s);
                return 16;
              }
              sscanf(input, "%5s", (const void *)key);
              signed int return_value_strcmp$29;
              return_value_strcmp$29=strcmp(key, "+OK");
              if(!(return_value_strcmp$29 == 0))
              {
                Sclose(s);
                return 4;
              }

              else
              {
                Sclose(s);
                if(ctotal == mb->ctotal)
                  return 0;

                else
                {
                  if(!(mb->ctotal >= ctotal))
                  {
                    mb->cnew = mb->cnew + (ctotal - mb->ctotal);
                    mb->ctotal = ctotal;
                    pthread_mutex_lock(&mb->mutex);
                    mb->flags = mb->flags | 2;
                    pthread_mutex_unlock(&mb->mutex);
                  }

                  else
                  {
                    mb->cnew = 0;
                    mb->ctotal = ctotal;
                  }
                  return 0;
                }
              }
            }
          }
        }
      }
    }
  }
}

// readLine
// file mh.c line 247
signed int readLine(struct _IO_FILE *stream, char **line, signed int *size)
{
  signed long int pos;
  char buf[256l];
  signed int blen;
  signed int llen;
  pos=ftell(stream);
  memset((void *)*line, 0, (unsigned long int)*size);
  llen = 0;
  _Bool tmp_if_expr$2;
  signed int return_value_feof$1;
  do
  {
    char *return_value_fgets$3;
    return_value_fgets$3=fgets(buf, (signed int)sizeof(char [256l]) /*256ul*/ , stream);
    if(return_value_fgets$3 == ((char *)NULL))
      break;

    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(buf);
    blen = (signed int)return_value_strlen$4;
    if(*size + -1 >= blen + llen)
    {
      strcat(*line, buf);
      llen = llen + blen;
    }

    else
    {
      *size = *size * 2;
      llen = llen + blen;
      void *return_value_realloc$5;
      return_value_realloc$5=realloc((void *)*line, (unsigned long int)*size);
      *line = (char *)return_value_realloc$5;
      strcat(*line, buf);
    }
    if(!((signed int)buf[(signed long int)(blen + -1)] == 10))
    {
      return_value_feof$1=feof(stream);
      tmp_if_expr$2 = !(return_value_feof$1 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$2 = (_Bool)0;
  }
  while(tmp_if_expr$2);
  return 0;
}

// redraw
// file gui.c line 373
void redraw()
{
  setup_window(mainWindow);
  draw_window(mainWindow);
  setup_window(iconWindow);
  draw_window(iconWindow);
  XFlush(mainDisplay);
}

// setup_pixmap
// file gui.c line 356
void setup_pixmap()
{
  switch(x11_set.status)
  {
    case 0:
    {
      Current = NoMail;
      break;
    }
    case 1:
    {
      Current = OldMail;
      break;
    }
    case 2:
      Current = NewMail;
  }
}

// setup_window
// file gui.c line 203
void setup_window(unsigned long int win)
{
  signed int x;
  signed int y;
  if(!(x11_set.shape == 0))
  {
    x = (signed int)(((unsigned int)winsize.x - Current->attributes.width) / (unsigned int)2);
    y = (signed int)(((unsigned int)winsize.y - Current->attributes.height) / (unsigned int)2);
    if(!(x11_set.use_frame == 0))
    {
      XShapeCombineMask(mainDisplay, win, 0, 0, 0, Frame->mask, 0);
      XShapeCombineMask(mainDisplay, win, 0, x, y, Current->mask, 1);
    }

    else
      XShapeCombineMask(mainDisplay, win, 0, x, y, Current->mask, 0);
  }

}

// shorten
// file asmail.c line 187
void shorten(char *line)
{
  signed int i = 0;
  signed int j = 0;
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(line);
  unsigned long int return_value_strlen$1;
  if((signed int)line[-1l + (signed long int)return_value_strlen$2] == 10)
  {
    return_value_strlen$1=strlen(line);
    line[(signed long int)(return_value_strlen$1 - (unsigned long int)1)] = (char)0;
  }

  const unsigned short int **return_value___ctype_b_loc$3;
  do
  {
    return_value___ctype_b_loc$3=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)line[(signed long int)i]]) == 0)
      break;

    if(line[(signed long int)i] == 0)
      break;

    i = i + 1;
  }
  while((_Bool)1);
  _Bool tmp_if_expr$5;
  unsigned long int return_value_strlen$4;
  if(i == 0)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    return_value_strlen$4=strlen(line);
    tmp_if_expr$5 = (unsigned long int)i == return_value_strlen$4 ? (_Bool)1 : (_Bool)0;
  }
  signed int tmp_post$6;
  signed int tmp_post$7;
  const unsigned short int **return_value___ctype_b_loc$9;
  if(!tmp_if_expr$5)
  {
    for( ; !(line[(signed long int)i] == 0); line[(signed long int)tmp_post$6] = line[(signed long int)tmp_post$7])
    {
      tmp_post$6 = j;
      j = j + 1;
      tmp_post$7 = i;
      i = i + 1;
    }
    line[(signed long int)j] = (char)0;
    unsigned long int return_value_strlen$8;
    return_value_strlen$8=strlen(line);
    i = (signed int)return_value_strlen$8;
    do
    {
      return_value___ctype_b_loc$9=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$9)[(signed long int)(signed int)line[(signed long int)i]]) == 0)
        break;

      if(!(i >= 1))
        break;

      i = i - 1;
    }
    while((_Bool)1);
    if((signed int)line[(signed long int)i] == 10)
      i = i - 1;

    i = i + 1;
    line[(signed long int)i] = (char)0;
  }

}

// signal_check
// file globals.c line 60
void signal_check()
{
  pthread_mutex_lock(&check_lock);
  check_count = check_count + 1;
  pthread_mutex_unlock(&check_lock);
  pthread_cond_broadcast(&check_cv);
}

// signal_update
// file globals.h line 128
void signal_update()
{
  pthread_mutex_lock(&update_lock);
  update_count = update_count + 1;
  pthread_mutex_unlock(&update_lock);
  pthread_cond_broadcast(&update_cv);
}

// sleep_check
// file globals.h line 145
signed int sleep_check(const signed int sec)
{
  signed long int t;
  struct timespec tv;
  signed int result;
  time(&t);
  tv.tv_sec = t + (signed long int)sec;
  tv.tv_nsec = (signed long int)0;
  pthread_mutex_lock(&check_lock);
  result=pthread_cond_timedwait(&check_cv, &check_lock, &tv);
  pthread_mutex_unlock(&check_lock);
  if(result == 110)
    return 0;

  else
    return 1;
}

// sleep_update
// file globals.h line 130
signed int sleep_update(const signed int centisec)
{
  struct timespec tv;
  signed int result;
  clock_gettime(0, &tv);
  tv.tv_sec = tv.tv_sec + (signed long int)(centisec / 100);
  tv.tv_nsec = tv.tv_nsec + (signed long int)((centisec % 100) * 10000000);
  if(tv.tv_nsec >= 1000000000l)
  {
    tv.tv_sec = tv.tv_sec + (signed long int)1;
    tv.tv_nsec = tv.tv_nsec - (signed long int)1000000000;
  }

  pthread_mutex_lock(&update_lock);
  result=pthread_cond_timedwait(&update_cv, &update_lock, &tv);
  pthread_mutex_unlock(&update_lock);
  if(result == 110)
    return 0;

  else
    return 1;
}

// startx
// file gui.h line 6
void startx(void *ptr)
{
  signed int screen;
  signed int color_depth;
  struct anonymous$61 SizeHints;
  signed int result;
  signed int x_negative = 0;
  signed int y_negative = 0;
  signed int x_size_forced = 0;
  signed int y_size_forced = 0;
  signed int status;
  struct anonymous$59 title;
  struct anonymous$57 classHint;
  struct anonymous$58 WmHints;
  union _XEvent Event;
  char *char_p;
  signed int return_value_pthread_mutex_trylock$1;
  return_value_pthread_mutex_trylock$1=pthread_mutex_trylock(&x11_mutex);
  if(return_value_pthread_mutex_trylock$1 == 16)
  {
    printf("asmail: startx: non-reentrant function!\n");
    exit(0);
  }

  mainDisplay=XOpenDisplay((const char *)(void *)0);
  if(mainDisplay == ((struct _XDisplay *)NULL))
  {
    char *return_value_XDisplayName$2;
    return_value_XDisplayName$2=XDisplayName((const char *)(void *)0);
    printf("asmail: startx: can't open display %s\n", return_value_XDisplayName$2);
    exit(1);
  }

  screen = ((struct anonymous$55 *)mainDisplay)->default_screen;
  Root = (&((struct anonymous$55 *)mainDisplay)->screens[(signed long int)screen])->root;
  back_pix=GetColor("#385971", mainDisplay, Root);
  fore_pix=GetColor(x11_set.color, mainDisplay, Root);
  color_depth = (&((struct anonymous$55 *)mainDisplay)->screens[(signed long int)screen])->root_depth;
  if(!(x11_set.each == 0) || !(x11_set.total == 0))
  {
    font_struct=XLoadQueryFont(mainDisplay, x11_set.font);
    if(font_struct == ((struct anonymous$21 *)NULL))
    {
      printf("asmail: failed to load font %s\n", (const void *)x11_set.font);
      printf("asmail: the indicators of message numbers");
      printf("will not be drawn\n");
      x11_set.each = 0;
      x11_set.total = 0;
    }

  }

  NumOfMsg.chars = NumOfMsgText;
  NumOfMsg.font=XLoadFont(mainDisplay, x11_set.font);
  NumOfMsgColor = fore_pix;
  char **tmp_if_expr$3;
  if(!(x11_set.nomail == ((struct pixfile *)NULL)))
    LoadXPM(x11_set.nomail, &NoMail);

  else
  {
    if(!(x11_set.shape == 0))
      tmp_if_expr$3 = nomail_s;

    else
      tmp_if_expr$3 = nomail;
    NoMail=GetXPM(tmp_if_expr$3);
    NoMail->next = NoMail;
  }
  char **tmp_if_expr$4;
  if(!(x11_set.oldmail == ((struct pixfile *)NULL)))
    LoadXPM(x11_set.oldmail, &OldMail);

  else
  {
    if(!(x11_set.shape == 0))
      tmp_if_expr$4 = oldmail_s;

    else
      tmp_if_expr$4 = oldmail;
    OldMail=GetXPM(tmp_if_expr$4);
    OldMail->next = OldMail;
  }
  char **tmp_if_expr$5;
  if(!(x11_set.newmail == ((struct pixfile *)NULL)))
    LoadXPM(x11_set.newmail, &NewMail);

  else
  {
    if(!(x11_set.shape == 0))
      tmp_if_expr$5 = newmail_s;

    else
      tmp_if_expr$5 = newmail;
    NewMail=GetXPM(tmp_if_expr$5);
    NewMail->next = NewMail;
  }
  if(!(x11_set.frame == ((struct pixfile *)NULL)))
    LoadXPM(x11_set.frame, &Frame);

  else
    if(!(x11_set.use_frame == 0))
    {
      Frame=GetXPM(frame);
      Frame->next = Frame;
    }

  Current = NoMail;
  SizeHints.x = 0;
  SizeHints.y = 0;
  if(!(x11_set.use_frame == 0))
  {
    winsize.x = (signed short int)Frame->attributes.width;
    winsize.y = (signed short int)Frame->attributes.height;
  }

  else
  {
    winsize.x = (signed short int)Current->attributes.width;
    winsize.y = (signed short int)Current->attributes.height;
  }
  SizeHints.flags = 1L << 1 | 1L << 0;
  unsigned long int return_value_strlen$6;
  return_value_strlen$6=strlen(x11_set.geometry);
  if(!(return_value_strlen$6 == 0ul))
  {
    result=XParseGeometry(x11_set.geometry, &SizeHints.x, &SizeHints.y, (unsigned int *)&SizeHints.width, (unsigned int *)&SizeHints.height);
    if(!((0x0004 & result) == 0))
    {
      x_size_forced = 1;
      winsize.x = (signed short int)SizeHints.width;
    }

    if(!((0x0008 & result) == 0))
    {
      y_size_forced = 1;
      winsize.y = (signed short int)SizeHints.height;
    }

    if(!((0x0010 & result) == 0))
      x_negative = 1;

    if(!((0x0020 & result) == 0))
      y_negative = 1;

  }

  SizeHints.width = (signed int)winsize.x;
  SizeHints.max_width = SizeHints.width;
  SizeHints.min_width = SizeHints.max_width;
  SizeHints.height = (signed int)winsize.y;
  SizeHints.max_height = SizeHints.height;
  SizeHints.min_height = SizeHints.max_height;
  SizeHints.flags = SizeHints.flags | 1L << 4 | 1L << 5;
  XWMGeometry(mainDisplay, screen, x11_set.geometry, (const char *)(void *)0, (unsigned int)0, &SizeHints, &SizeHints.x, &SizeHints.y, &SizeHints.width, &SizeHints.height, &SizeHints.win_gravity);
  SizeHints.win_gravity = 1;
  if(!(x_negative == 0))
    SizeHints.win_gravity = 3;

  if(!(y_negative == 0))
  {
    if(!(x_negative == 0))
      SizeHints.win_gravity = 9;

    else
      SizeHints.win_gravity = 7;
  }

  SizeHints.flags = SizeHints.flags | 1L << 9;
  drawWindow=XCreatePixmap(mainDisplay, Root, (unsigned int)winsize.x, (unsigned int)winsize.y, (unsigned int)color_depth);
  mainWindow=XCreateSimpleWindow(mainDisplay, Root, SizeHints.x, SizeHints.y, (unsigned int)winsize.x, (unsigned int)winsize.y, (unsigned int)0, fore_pix, back_pix);
  iconWindow=XCreateSimpleWindow(mainDisplay, Root, SizeHints.x, SizeHints.y, (unsigned int)winsize.x, (unsigned int)winsize.y, (unsigned int)0, fore_pix, back_pix);
  XSetWMNormalHints(mainDisplay, mainWindow, &SizeHints);
  XSetWMNormalHints(mainDisplay, iconWindow, &SizeHints);
  status=XClearWindow(mainDisplay, mainWindow);
  status=XClearWindow(mainDisplay, iconWindow);
  char_p = x11_set.title;
  status=XStringListToTextProperty(&char_p, 1, &title);
  XSetWMName(mainDisplay, mainWindow, &title);
  XSetWMName(mainDisplay, iconWindow, &title);
  classHint.res_name = "asmail";
  classHint.res_class = "ASMAIL";
  XSetClassHint(mainDisplay, mainWindow, &classHint);
  XStoreName(mainDisplay, mainWindow, x11_set.title);
  XSetIconName(mainDisplay, mainWindow, x11_set.title);
  status=XSelectInput(mainDisplay, mainWindow, 1L << 15 | 1L << 2);
  status=XSelectInput(mainDisplay, iconWindow, 1L << 15 | 1L << 2);
  status=XSetCommand(mainDisplay, mainWindow, x11_set.argv, x11_set.argc);
  wm_delete_window=XInternAtom(mainDisplay, "WM_DELETE_WINDOW", 0);
  wm_protocols=XInternAtom(mainDisplay, "WM_PROTOCOLS", 0);
  status=XSetWMProtocols(mainDisplay, mainWindow, &wm_delete_window, 1);
  status=XSetWMProtocols(mainDisplay, iconWindow, &wm_delete_window, 1);
  WmHints.flags = 1L << 1 | 1L << 3;
  WmHints.initial_state = x11_set.withdrawn != 0 ? 0 : (x11_set.iconic != 0 ? 3 : 1);
  WmHints.icon_window = iconWindow;
  if(!(x11_set.withdrawn == 0))
  {
    WmHints.window_group = mainWindow;
    WmHints.flags = WmHints.flags | 1L << 6;
  }

  if(!(x11_set.iconic == 0) || !(x11_set.withdrawn == 0))
  {
    WmHints.icon_x = SizeHints.x;
    WmHints.icon_y = SizeHints.y;
    WmHints.flags = WmHints.flags | 1L << 4;
  }

  XSetWMHints(mainDisplay, mainWindow, &WmHints);
  mainGCV.foreground = fore_pix;
  mainGCV.background = back_pix;
  mainGCV.graphics_exposures = 0;
  mainGC=XCreateGC(mainDisplay, Root, (unsigned long int)(1L << 2 | 1L << 3), &mainGCV);
  status=XMapWindow(mainDisplay, mainWindow);
  XNextEvent(mainDisplay, &Event);
  redraw();
  XFlush(mainDisplay);
  main_loop();
  XFreeFont(mainDisplay, font_struct);
  XCloseDisplay(mainDisplay);
  pthread_exit((void *)0);
}

// strip_quotes
// file asmail.c line 213
void strip_quotes(char *line)
{
  char tmp1[256l];
  signed int len;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(line);
  if(return_value_strlen$1 >= 2ul)
  {
    strcpy(tmp1, line);
    shorten(tmp1);
    if(!((signed int)tmp1[0l] == 39))
    {
      if((signed int)tmp1[0l] == 34)
        goto __CPROVER_DUMP_L2;

    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(tmp1);
      len = (signed int)return_value_strlen$2;
      if(tmp1[(signed long int)(-1 + len)] == tmp1[0l])
      {
        tmp1[(signed long int)(len - 1)] = (char)0;
        strcpy(line, &tmp1[(signed long int)1]);
      }

    }
  }

}

// tokenizeString
// file mh.c line 278
signed int tokenizeString(char *string, signed int size, char ***output)
{
  char *start;
  char *end;
  char *p;
  char *q;
  signed int i;
  end = string + (signed long int)size;
  p = string;
  _Bool tmp_if_expr$1;
  do
  {
    if(!(p >= end))
      tmp_if_expr$1 = (signed int)*p != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr$1 = (_Bool)0;
    if(!tmp_if_expr$1)
      break;

    p = p + 1l;
  }
  while((_Bool)1);
  p = p - 1l;
  const unsigned short int **return_value___ctype_b_loc$2;
  do
  {
    return_value___ctype_b_loc$2=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)*p]) == 0)
      break;

    p = p - 1l;
  }
  while((_Bool)1);
  end = p + (signed long int)1;
  p = string;
  _Bool tmp_if_expr$4;
  const unsigned short int **return_value___ctype_b_loc$3;
  do
  {
    if(!(p >= end))
    {
      return_value___ctype_b_loc$3=__ctype_b_loc();
      tmp_if_expr$4 = ((signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*p] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr$4 = (_Bool)0;
    if(!tmp_if_expr$4)
      break;

    p = p + 1l;
  }
  while((_Bool)1);
  start = p;
  if(start == end)
  {
    void *return_value_malloc$5;
    return_value_malloc$5=malloc(sizeof(char *) /*8ul*/  * (unsigned long int)1);
    *output = (char **)return_value_malloc$5;
    (*output)[(signed long int)0] = ((char *)NULL);
    return 0;
  }

  p = end - (signed long int)1;
  i = 0;
  const unsigned short int **return_value___ctype_b_loc$6;
  for( ; !(start >= p); p = p - 1l)
  {
    const unsigned short int **return_value___ctype_b_loc$7;
    return_value___ctype_b_loc$7=__ctype_b_loc();
    if(!((8192 & (signed int)(*return_value___ctype_b_loc$7)[(signed long int)(signed int)*p]) == 0))
    {
      return_value___ctype_b_loc$6=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)p[-1l]]) == 0)
        i = i + 1;

    }

  }
  i = i + 1;
  void *return_value_malloc$8;
  return_value_malloc$8=malloc(sizeof(char *) /*8ul*/  * (unsigned long int)(i + 1));
  *output = (char **)return_value_malloc$8;
  (*output)[(signed long int)i] = ((char *)NULL);
  i = 0;
  q = start;
  p = q;
  const unsigned short int **return_value___ctype_b_loc$9;
  const unsigned short int **return_value___ctype_b_loc$11;
  for( ; !(p >= end) && !(q >= end); i = i + 1)
  {
    q = p;
    do
    {
      return_value___ctype_b_loc$9=__ctype_b_loc();
      if(!((8192 & (signed int)(*return_value___ctype_b_loc$9)[(signed long int)(signed int)*q]) == 0) || q >= end)
        break;

      q = q + 1l;
    }
    while((_Bool)1);
    void *return_value_malloc$10;
    return_value_malloc$10=malloc(sizeof(char) /*1ul*/  * (unsigned long int)((q - p) + (signed long int)1));
    (*output)[(signed long int)i] = (char *)return_value_malloc$10;
    strncpy((*output)[(signed long int)i], p, (unsigned long int)(q - p));
    (*output)[(signed long int)i][q - p] = (char)0;
    q = q + 1l;
    do
    {
      return_value___ctype_b_loc$11=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc$11)[(signed long int)(signed int)*q]) == 0 || q >= end)
        break;

      q = q + 1l;
    }
    while((_Bool)1);
    p = q;
  }
  return 0;
}

// usage
// file asmail.c line 37
void usage()
{
  version();
  printf("Usage : asmail [-options...]\n");
  printf("\n");
  printf("-V\t\tprint version and exit\n");
  printf("-h\t\tprint this help screen and exit\n");
  printf("-v\t\tverbose: print mailbox stats to STDOUT\n");
  printf("-insecure\tallow config file to be readable by others\n");
  printf("-f <filename>\tname of the configuration file to use\n");
  printf("-geometry <xy>\tX geometry specification (position/size)\n");
  printf("-nox\t\tdon't use X11 interface (implies -v)\n");
  printf("-noconfig\tdon't read config file (run default settings)\n");
  printf("-iconic\t\tstart as an icon rather than a window\n");
  printf("-withdrawn\t\"withdrawn\" mode for WindowMaker\n");
  printf("\n");
  printf("Use $DISPLAY environment variable to run asmail on a different display.\n");
  printf("\n");
}

// version
// file asmail.c line 33
void version()
{
  printf("asmail : AfterStep e-mail monitor version %s\n", (const void *)"2.1");
}

// x11_event
// file gui.c line 439
void x11_event()
{
  union _XEvent Event;
  signed int return_value_XPending$1;
  do
  {
    return_value_XPending$1=XPending(mainDisplay);
    if(return_value_XPending$1 == 0)
      break;

    XNextEvent(mainDisplay, &Event);
    switch(Event.type)
    {
      case 12:
      {
        if(Event.xexpose.count == 0)
          draw_window(((struct anonymous$28 *)&Event)->window);

        break;
      }
      case 4:
      {
        ButtonHandler(&Event);
        break;
      }
      case 33:
        if(Event.xclient.message_type == wm_protocols)
        {
          if((unsigned long int)Event.xclient.data.l[0l] == wm_delete_window)
            x_cleanup();

        }

    }
  }
  while((_Bool)1);
}

// x_cleanup
// file gui.c line 177
void x_cleanup()
{
  XFreeFont(mainDisplay, font_struct);
  XCloseDisplay(mainDisplay);
  exit(0);
}

