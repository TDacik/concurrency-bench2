// #anon_enum$CURLE_OK=0$CURLE_UNSUPPORTED_PROTOCOL=1$CURLE_FAILED_INIT=2$CURLE_URL_MALFORMAT=3$CURLE_NOT_BUILT_IN=4$CURLE_COULDNT_RESOLVE_PROXY=5$CURLE_COULDNT_RESOLVE_HOST=6$CURLE_COULDNT_CONNECT=7$CURLE_FTP_WEIRD_SERVER_REPLY=8$CURLE_REMOTE_ACCESS_DENIED=9$CURLE_FTP_ACCEPT_FAILED=10$CURLE_FTP_WEIRD_PASS_REPLY=11$CURLE_FTP_ACCEPT_TIMEOUT=12$CURLE_FTP_WEIRD_PASV_REPLY=13$CURLE_FTP_WEIRD_227_FORMAT=14$CURLE_FTP_CANT_GET_HOST=15$CURLE_HTTP2=16$CURLE_FTP_COULDNT_SET_TYPE=17$CURLE_PARTIAL_FILE=18$CURLE_FTP_COULDNT_RETR_FILE=19$CURLE_OBSOLETE20=20$CURLE_QUOTE_ERROR=21$CURLE_HTTP_RETURNED_ERROR=22$CURLE_WRITE_ERROR=23$CURLE_OBSOLETE24=24$CURLE_UPLOAD_FAILED=25$CURLE_READ_ERROR=26$CURLE_OUT_OF_MEMORY=27$CURLE_OPERATION_TIMEDOUT=28$CURLE_OBSOLETE29=29$CURLE_FTP_PORT_FAILED=30$CURLE_FTP_COULDNT_USE_REST=31$CURLE_OBSOLETE32=32$CURLE_RANGE_ERROR=33$CURLE_HTTP_POST_ERROR=34$CURLE_SSL_CONNECT_ERROR=35$CURLE_BAD_DOWNLOAD_RESUME=36$CURLE_FILE_COULDNT_READ_FILE=37$CURLE_LDAP_CANNOT_BIND=38$CURLE_LDAP_SEARCH_FAILED=39$CURLE_OBSOLETE40=40$CURLE_FUNCTION_NOT_FOUND=41$CURLE_ABORTED_BY_CALLBACK=42$CURLE_BAD_FUNCTION_ARGUMENT=43$CURLE_OBSOLETE44=44$CURLE_INTERFACE_FAILED=45$CURLE_OBSOLETE46=46$CURLE_TOO_MANY_REDIRECTS=47$CURLE_UNKNOWN_OPTION=48$CURLE_TELNET_OPTION_SYNTAX=49$CURLE_OBSOLETE50=50$CURLE_PEER_FAILED_VERIFICATION=51$CURLE_GOT_NOTHING=52$CURLE_SSL_ENGINE_NOTFOUND=53$CURLE_SSL_ENGINE_SETFAILED=54$CURLE_SEND_ERROR=55$CURLE_RECV_ERROR=56$CURLE_OBSOLETE57=57$CURLE_SSL_CERTPROBLEM=58$CURLE_SSL_CIPHER=59$CURLE_SSL_CACERT=60$CURLE_BAD_CONTENT_ENCODING=61$CURLE_LDAP_INVALID_URL=62$CURLE_FILESIZE_EXCEEDED=63$CURLE_USE_SSL_FAILED=64$CURLE_SEND_FAIL_REWIND=65$CURLE_SSL_ENGINE_INITFAILED=66$CURLE_LOGIN_DENIED=67$CURLE_TFTP_NOTFOUND=68$CURLE_TFTP_PERM=69$CURLE_REMOTE_DISK_FULL=70$CURLE_TFTP_ILLEGAL=71$CURLE_TFTP_UNKNOWNID=72$CURLE_REMOTE_FILE_EXISTS=73$CURLE_TFTP_NOSUCHUSER=74$CURLE_CONV_FAILED=75$CURLE_CONV_REQD=76$CURLE_SSL_CACERT_BADFILE=77$CURLE_REMOTE_FILE_NOT_FOUND=78$CURLE_SSH=79$CURLE_SSL_SHUTDOWN_FAILED=80$CURLE_AGAIN=81$CURLE_SSL_CRL_BADFILE=82$CURLE_SSL_ISSUER_ERROR=83$CURLE_FTP_PRET_FAILED=84$CURLE_RTSP_CSEQ_ERROR=85$CURLE_RTSP_SESSION_ERROR=86$CURLE_FTP_BAD_FILE_LIST=87$CURLE_CHUNK_FAILED=88$CURLE_NO_CONNECTION_AVAILABLE=89$CURLE_SSL_PINNEDPUBKEYNOTMATCH=90$CURLE_SSL_INVALIDCERTSTATUS=91$CURL_LAST=92
// file /usr/include/curl/curl.h line 413
enum anonymous$4 { CURLE_OK=0, CURLE_UNSUPPORTED_PROTOCOL=1, CURLE_FAILED_INIT=2, CURLE_URL_MALFORMAT=3, CURLE_NOT_BUILT_IN=4, CURLE_COULDNT_RESOLVE_PROXY=5, CURLE_COULDNT_RESOLVE_HOST=6, CURLE_COULDNT_CONNECT=7, CURLE_FTP_WEIRD_SERVER_REPLY=8, CURLE_REMOTE_ACCESS_DENIED=9, CURLE_FTP_ACCEPT_FAILED=10, CURLE_FTP_WEIRD_PASS_REPLY=11, CURLE_FTP_ACCEPT_TIMEOUT=12, CURLE_FTP_WEIRD_PASV_REPLY=13, CURLE_FTP_WEIRD_227_FORMAT=14, CURLE_FTP_CANT_GET_HOST=15, CURLE_HTTP2=16, CURLE_FTP_COULDNT_SET_TYPE=17, CURLE_PARTIAL_FILE=18, CURLE_FTP_COULDNT_RETR_FILE=19, CURLE_OBSOLETE20=20, CURLE_QUOTE_ERROR=21, CURLE_HTTP_RETURNED_ERROR=22, CURLE_WRITE_ERROR=23, CURLE_OBSOLETE24=24, CURLE_UPLOAD_FAILED=25, CURLE_READ_ERROR=26, CURLE_OUT_OF_MEMORY=27, CURLE_OPERATION_TIMEDOUT=28, CURLE_OBSOLETE29=29, CURLE_FTP_PORT_FAILED=30, CURLE_FTP_COULDNT_USE_REST=31, CURLE_OBSOLETE32=32, CURLE_RANGE_ERROR=33, CURLE_HTTP_POST_ERROR=34, CURLE_SSL_CONNECT_ERROR=35, CURLE_BAD_DOWNLOAD_RESUME=36, CURLE_FILE_COULDNT_READ_FILE=37, CURLE_LDAP_CANNOT_BIND=38, CURLE_LDAP_SEARCH_FAILED=39, CURLE_OBSOLETE40=40, CURLE_FUNCTION_NOT_FOUND=41, CURLE_ABORTED_BY_CALLBACK=42, CURLE_BAD_FUNCTION_ARGUMENT=43, CURLE_OBSOLETE44=44, CURLE_INTERFACE_FAILED=45, CURLE_OBSOLETE46=46, CURLE_TOO_MANY_REDIRECTS=47, CURLE_UNKNOWN_OPTION=48, CURLE_TELNET_OPTION_SYNTAX=49, CURLE_OBSOLETE50=50, CURLE_PEER_FAILED_VERIFICATION=51, CURLE_GOT_NOTHING=52, CURLE_SSL_ENGINE_NOTFOUND=53, CURLE_SSL_ENGINE_SETFAILED=54, CURLE_SEND_ERROR=55, CURLE_RECV_ERROR=56, CURLE_OBSOLETE57=57, CURLE_SSL_CERTPROBLEM=58, CURLE_SSL_CIPHER=59, CURLE_SSL_CACERT=60, CURLE_BAD_CONTENT_ENCODING=61, CURLE_LDAP_INVALID_URL=62, CURLE_FILESIZE_EXCEEDED=63, CURLE_USE_SSL_FAILED=64, CURLE_SEND_FAIL_REWIND=65, CURLE_SSL_ENGINE_INITFAILED=66, CURLE_LOGIN_DENIED=67, CURLE_TFTP_NOTFOUND=68, CURLE_TFTP_PERM=69, CURLE_REMOTE_DISK_FULL=70, CURLE_TFTP_ILLEGAL=71, CURLE_TFTP_UNKNOWNID=72, CURLE_REMOTE_FILE_EXISTS=73, CURLE_TFTP_NOSUCHUSER=74, CURLE_CONV_FAILED=75, CURLE_CONV_REQD=76, CURLE_SSL_CACERT_BADFILE=77, CURLE_REMOTE_FILE_NOT_FOUND=78, CURLE_SSH=79, CURLE_SSL_SHUTDOWN_FAILED=80, CURLE_AGAIN=81, CURLE_SSL_CRL_BADFILE=82, CURLE_SSL_ISSUER_ERROR=83, CURLE_FTP_PRET_FAILED=84, CURLE_RTSP_CSEQ_ERROR=85, CURLE_RTSP_SESSION_ERROR=86, CURLE_FTP_BAD_FILE_LIST=87, CURLE_CHUNK_FAILED=88, CURLE_NO_CONNECTION_AVAILABLE=89, CURLE_SSL_PINNEDPUBKEYNOTMATCH=90, CURLE_SSL_INVALIDCERTSTATUS=91, CURL_LAST=92 };

// #anon_enum$CURLINFO_NONE=0$CURLINFO_EFFECTIVE_URL=1048577$CURLINFO_RESPONSE_CODE=2097154$CURLINFO_TOTAL_TIME=3145731$CURLINFO_NAMELOOKUP_TIME=3145732$CURLINFO_CONNECT_TIME=3145733$CURLINFO_PRETRANSFER_TIME=3145734$CURLINFO_SIZE_UPLOAD=3145735$CURLINFO_SIZE_DOWNLOAD=3145736$CURLINFO_SPEED_DOWNLOAD=3145737$CURLINFO_SPEED_UPLOAD=3145738$CURLINFO_HEADER_SIZE=2097163$CURLINFO_REQUEST_SIZE=2097164$CURLINFO_SSL_VERIFYRESULT=2097165$CURLINFO_FILETIME=2097166$CURLINFO_CONTENT_LENGTH_DOWNLOAD=3145743$CURLINFO_CONTENT_LENGTH_UPLOAD=3145744$CURLINFO_STARTTRANSFER_TIME=3145745$CURLINFO_CONTENT_TYPE=1048594$CURLINFO_REDIRECT_TIME=3145747$CURLINFO_REDIRECT_COUNT=2097172$CURLINFO_PRIVATE=1048597$CURLINFO_HTTP_CONNECTCODE=2097174$CURLINFO_HTTPAUTH_AVAIL=2097175$CURLINFO_PROXYAUTH_AVAIL=2097176$CURLINFO_OS_ERRNO=2097177$CURLINFO_NUM_CONNECTS=2097178$CURLINFO_SSL_ENGINES=4194331$CURLINFO_COOKIELIST=4194332$CURLINFO_LASTSOCKET=2097181$CURLINFO_FTP_ENTRY_PATH=1048606$CURLINFO_REDIRECT_URL=1048607$CURLINFO_PRIMARY_IP=1048608$CURLINFO_APPCONNECT_TIME=3145761$CURLINFO_CERTINFO=4194338$CURLINFO_CONDITION_UNMET=2097187$CURLINFO_RTSP_SESSION_ID=1048612$CURLINFO_RTSP_CLIENT_CSEQ=2097189$CURLINFO_RTSP_SERVER_CSEQ=2097190$CURLINFO_RTSP_CSEQ_RECV=2097191$CURLINFO_PRIMARY_PORT=2097192$CURLINFO_LOCAL_IP=1048617$CURLINFO_LOCAL_PORT=2097194$CURLINFO_TLS_SESSION=4194347$CURLINFO_ACTIVESOCKET=5242924$CURLINFO_LASTONE=44
// file /usr/include/curl/curl.h line 2124
enum anonymous$14 { CURLINFO_NONE=0, CURLINFO_EFFECTIVE_URL=1048577, CURLINFO_RESPONSE_CODE=2097154, CURLINFO_TOTAL_TIME=3145731, CURLINFO_NAMELOOKUP_TIME=3145732, CURLINFO_CONNECT_TIME=3145733, CURLINFO_PRETRANSFER_TIME=3145734, CURLINFO_SIZE_UPLOAD=3145735, CURLINFO_SIZE_DOWNLOAD=3145736, CURLINFO_SPEED_DOWNLOAD=3145737, CURLINFO_SPEED_UPLOAD=3145738, CURLINFO_HEADER_SIZE=2097163, CURLINFO_REQUEST_SIZE=2097164, CURLINFO_SSL_VERIFYRESULT=2097165, CURLINFO_FILETIME=2097166, CURLINFO_CONTENT_LENGTH_DOWNLOAD=3145743, CURLINFO_CONTENT_LENGTH_UPLOAD=3145744, CURLINFO_STARTTRANSFER_TIME=3145745, CURLINFO_CONTENT_TYPE=1048594, CURLINFO_REDIRECT_TIME=3145747, CURLINFO_REDIRECT_COUNT=2097172, CURLINFO_PRIVATE=1048597, CURLINFO_HTTP_CONNECTCODE=2097174, CURLINFO_HTTPAUTH_AVAIL=2097175, CURLINFO_PROXYAUTH_AVAIL=2097176, CURLINFO_OS_ERRNO=2097177, CURLINFO_NUM_CONNECTS=2097178, CURLINFO_SSL_ENGINES=4194331, CURLINFO_COOKIELIST=4194332, CURLINFO_LASTSOCKET=2097181, CURLINFO_FTP_ENTRY_PATH=1048606, CURLINFO_REDIRECT_URL=1048607, CURLINFO_PRIMARY_IP=1048608, CURLINFO_APPCONNECT_TIME=3145761, CURLINFO_CERTINFO=4194338, CURLINFO_CONDITION_UNMET=2097187, CURLINFO_RTSP_SESSION_ID=1048612, CURLINFO_RTSP_CLIENT_CSEQ=2097189, CURLINFO_RTSP_SERVER_CSEQ=2097190, CURLINFO_RTSP_CSEQ_RECV=2097191, CURLINFO_PRIMARY_PORT=2097192, CURLINFO_LOCAL_IP=1048617, CURLINFO_LOCAL_PORT=2097194, CURLINFO_TLS_SESSION=4194347, CURLINFO_ACTIVESOCKET=5242924, CURLINFO_LASTONE=44 };

// #anon_enum$CURLOPT_WRITEDATA=10001$CURLOPT_URL=10002$CURLOPT_PORT=3$CURLOPT_PROXY=10004$CURLOPT_USERPWD=10005$CURLOPT_PROXYUSERPWD=10006$CURLOPT_RANGE=10007$CURLOPT_READDATA=10009$CURLOPT_ERRORBUFFER=10010$CURLOPT_WRITEFUNCTION=20011$CURLOPT_READFUNCTION=20012$CURLOPT_TIMEOUT=13$CURLOPT_INFILESIZE=14$CURLOPT_POSTFIELDS=10015$CURLOPT_REFERER=10016$CURLOPT_FTPPORT=10017$CURLOPT_USERAGENT=10018$CURLOPT_LOW_SPEED_LIMIT=19$CURLOPT_LOW_SPEED_TIME=20$CURLOPT_RESUME_FROM=21$CURLOPT_COOKIE=10022$CURLOPT_HTTPHEADER=10023$CURLOPT_HTTPPOST=10024$CURLOPT_SSLCERT=10025$CURLOPT_KEYPASSWD=10026$CURLOPT_CRLF=27$CURLOPT_QUOTE=10028$CURLOPT_HEADERDATA=10029$CURLOPT_COOKIEFILE=10031$CURLOPT_SSLVERSION=32$CURLOPT_TIMECONDITION=33$CURLOPT_TIMEVALUE=34$CURLOPT_CUSTOMREQUEST=10036$CURLOPT_STDERR=10037$CURLOPT_POSTQUOTE=10039$CURLOPT_OBSOLETE40=10040$CURLOPT_VERBOSE=41$CURLOPT_HEADER=42$CURLOPT_NOPROGRESS=43$CURLOPT_NOBODY=44$CURLOPT_FAILONERROR=45$CURLOPT_UPLOAD=46$CURLOPT_POST=47$CURLOPT_DIRLISTONLY=48$CURLOPT_APPEND=50$CURLOPT_NETRC=51$CURLOPT_FOLLOWLOCATION=52$CURLOPT_TRANSFERTEXT=53$CURLOPT_PUT=54$CURLOPT_PROGRESSFUNCTION=20056$CURLOPT_PROGRESSDATA=10057$CURLOPT_AUTOREFERER=58$CURLOPT_PROXYPORT=59$CURLOPT_POSTFIELDSIZE=60$CURLOPT_HTTPPROXYTUNNEL=61$CURLOPT_INTERFACE=10062$CURLOPT_KRBLEVEL=10063$CURLOPT_SSL_VERIFYPEER=64$CURLOPT_CAINFO=10065$CURLOPT_MAXREDIRS=68$CURLOPT_FILETIME=69$CURLOPT_TELNETOPTIONS=10070$CURLOPT_MAXCONNECTS=71$CURLOPT_OBSOLETE72=72$CURLOPT_FRESH_CONNECT=74$CURLOPT_FORBID_REUSE=75$CURLOPT_RANDOM_FILE=10076$CURLOPT_EGDSOCKET=10077$CURLOPT_CONNECTTIMEOUT=78$CURLOPT_HEADERFUNCTION=20079$CURLOPT_HTTPGET=80$CURLOPT_SSL_VERIFYHOST=81$CURLOPT_COOKIEJAR=10082$CURLOPT_SSL_CIPHER_LIST=10083$CURLOPT_HTTP_VERSION=84$CURLOPT_FTP_USE_EPSV=85$CURLOPT_SSLCERTTYPE=10086$CURLOPT_SSLKEY=10087$CURLOPT_SSLKEYTYPE=10088$CURLOPT_SSLENGINE=10089$CURLOPT_SSLENGINE_DEFAULT=90$CURLOPT_DNS_USE_GLOBAL_CACHE=91$CURLOPT_DNS_CACHE_TIMEOUT=92$CURLOPT_PREQUOTE=10093$CURLOPT_DEBUGFUNCTION=20094$CURLOPT_DEBUGDATA=10095$CURLOPT_COOKIESESSION=96$CURLOPT_CAPATH=10097$CURLOPT_BUFFERSIZE=98$CURLOPT_NOSIGNAL=99$CURLOPT_SHARE=10100$CURLOPT_PROXYTYPE=101$CURLOPT_ACCEPT_ENCODING=10102$CURLOPT_PRIVATE=10103$CURLOPT_HTTP200ALIASES=10104$CURLOPT_UNRESTRICTED_AUTH=105$CURLOPT_FTP_USE_EPRT=106$CURLOPT_HTTPAUTH=107$CURLOPT_SSL_CTX_FUNCTION=20108$CURLOPT_SSL_CTX_DATA=10109$CURLOPT_FTP_CREATE_MISSING_DIRS=110$CURLOPT_PROXYAUTH=111$CURLOPT_FTP_RESPONSE_TIMEOUT=112$CURLOPT_IPRESOLVE=113$CURLOPT_MAXFILESIZE=114$CURLOPT_INFILESIZE_LARGE=30115$CURLOPT_RESUME_FROM_LARGE=30116$CURLOPT_MAXFILESIZE_LARGE=30117$CURLOPT_NETRC_FILE=10118$CURLOPT_USE_SSL=119$CURLOPT_POSTFIELDSIZE_LARGE=30120$CURLOPT_TCP_NODELAY=121$CURLOPT_FTPSSLAUTH=129$CURLOPT_IOCTLFUNCTION=20130$CURLOPT_IOCTLDATA=10131$CURLOPT_FTP_ACCOUNT=10134$CURLOPT_COOKIELIST=10135$CURLOPT_IGNORE_CONTENT_LENGTH=136$CURLOPT_FTP_SKIP_PASV_IP=137$CURLOPT_FTP_FILEMETHOD=138$CURLOPT_LOCALPORT=139$CURLOPT_LOCALPORTRANGE=140$CURLOPT_CONNECT_ONLY=141$CURLOPT_CONV_FROM_NETWORK_FUNCTION=20142$CURLOPT_CONV_TO_NETWORK_FUNCTION=20143$CURLOPT_CONV_FROM_UTF8_FUNCTION=20144$CURLOPT_MAX_SEND_SPEED_LARGE=30145$CURLOPT_MAX_RECV_SPEED_LARGE=30146$CURLOPT_FTP_ALTERNATIVE_TO_USER=10147$CURLOPT_SOCKOPTFUNCTION=20148$CURLOPT_SOCKOPTDATA=10149$CURLOPT_SSL_SESSIONID_CACHE=150$CURLOPT_SSH_AUTH_TYPES=151$CURLOPT_SSH_PUBLIC_KEYFILE=10152$CURLOPT_SSH_PRIVATE_KEYFILE=10153$CURLOPT_FTP_SSL_CCC=154$CURLOPT_TIMEOUT_MS=155$CURLOPT_CONNECTTIMEOUT_MS=156$CURLOPT_HTTP_TRANSFER_DECODING=157$CURLOPT_HTTP_CONTENT_DECODING=158$CURLOPT_NEW_FILE_PERMS=159$CURLOPT_NEW_DIRECTORY_PERMS=160$CURLOPT_POSTREDIR=161$CURLOPT_SSH_HOST_PUBLIC_KEY_MD5=10162$CURLOPT_OPENSOCKETFUNCTION=20163$CURLOPT_OPENSOCKETDATA=10164$CURLOPT_COPYPOSTFIELDS=10165$CURLOPT_PROXY_TRANSFER_MODE=166$CURLOPT_SEEKFUNCTION=20167$CURLOPT_SEEKDATA=10168$CURLOPT_CRLFILE=10169$CURLOPT_ISSUERCERT=10170$CURLOPT_ADDRESS_SCOPE=171$CURLOPT_CERTINFO=172$CURLOPT_USERNAME=10173$CURLOPT_PASSWORD=10174$CURLOPT_PROXYUSERNAME=10175$CURLOPT_PROXYPASSWORD=10176$CURLOPT_NOPROXY=10177$CURLOPT_TFTP_BLKSIZE=178$CURLOPT_SOCKS5_GSSAPI_SERVICE=10179$CURLOPT_SOCKS5_GSSAPI_NEC=180$CURLOPT_PROTOCOLS=181$CURLOPT_REDIR_PROTOCOLS=182$CURLOPT_SSH_KNOWNHOSTS=10183$CURLOPT_SSH_KEYFUNCTION=20184$CURLOPT_SSH_KEYDATA=10185$CURLOPT_MAIL_FROM=10186$CURLOPT_MAIL_RCPT=10187$CURLOPT_FTP_USE_PRET=188$CURLOPT_RTSP_REQUEST=189$CURLOPT_RTSP_SESSION_ID=10190$CURLOPT_RTSP_STREAM_URI=10191$CURLOPT_RTSP_TRANSPORT=10192$CURLOPT_RTSP_CLIENT_CSEQ=193$CURLOPT_RTSP_SERVER_CSEQ=194$CURLOPT_INTERLEAVEDATA=10195$CURLOPT_INTERLEAVEFUNCTION=20196$CURLOPT_WILDCARDMATCH=197$CURLOPT_CHUNK_BGN_FUNCTION=20198$CURLOPT_CHUNK_END_FUNCTION=20199$CURLOPT_FNMATCH_FUNCTION=20200$CURLOPT_CHUNK_DATA=10201$CURLOPT_FNMATCH_DATA=10202$CURLOPT_RESOLVE=10203$CURLOPT_TLSAUTH_USERNAME=10204$CURLOPT_TLSAUTH_PASSWORD=10205$CURLOPT_TLSAUTH_TYPE=10206$CURLOPT_TRANSFER_ENCODING=207$CURLOPT_CLOSESOCKETFUNCTION=20208$CURLOPT_CLOSESOCKETDATA=10209$CURLOPT_GSSAPI_DELEGATION=210$CURLOPT_DNS_SERVERS=10211$CURLOPT_ACCEPTTIMEOUT_MS=212$CURLOPT_TCP_KEEPALIVE=213$CURLOPT_TCP_KEEPIDLE=214$CURLOPT_TCP_KEEPINTVL=215$CURLOPT_SSL_OPTIONS=216$CURLOPT_MAIL_AUTH=10217$CURLOPT_SASL_IR=218$CURLOPT_XFERINFOFUNCTION=20219$CURLOPT_XOAUTH2_BEARER=10220$CURLOPT_DNS_INTERFACE=10221$CURLOPT_DNS_LOCAL_IP4=10222$CURLOPT_DNS_LOCAL_IP6=10223$CURLOPT_LOGIN_OPTIONS=10224$CURLOPT_SSL_ENABLE_NPN=225$CURLOPT_SSL_ENABLE_ALPN=226$CURLOPT_EXPECT_100_TIMEOUT_MS=227$CURLOPT_PROXYHEADER=10228$CURLOPT_HEADEROPT=229$CURLOPT_PINNEDPUBLICKEY=10230$CURLOPT_UNIX_SOCKET_PATH=10231$CURLOPT_SSL_VERIFYSTATUS=232$CURLOPT_SSL_FALSESTART=233$CURLOPT_PATH_AS_IS=234$CURLOPT_PROXY_SERVICE_NAME=10235$CURLOPT_SERVICE_NAME=10236$CURLOPT_PIPEWAIT=237$CURLOPT_DEFAULT_PROTOCOL=10238$CURLOPT_STREAM_WEIGHT=239$CURLOPT_STREAM_DEPENDS=10240$CURLOPT_STREAM_DEPENDS_E=10241$CURLOPT_LASTENTRY=10242
// file /usr/include/curl/curl.h line 863
enum anonymous$12 { CURLOPT_WRITEDATA=10001, CURLOPT_URL=10002, CURLOPT_PORT=3, CURLOPT_PROXY=10004, CURLOPT_USERPWD=10005, CURLOPT_PROXYUSERPWD=10006, CURLOPT_RANGE=10007, CURLOPT_READDATA=10009, CURLOPT_ERRORBUFFER=10010, CURLOPT_WRITEFUNCTION=20011, CURLOPT_READFUNCTION=20012, CURLOPT_TIMEOUT=13, CURLOPT_INFILESIZE=14, CURLOPT_POSTFIELDS=10015, CURLOPT_REFERER=10016, CURLOPT_FTPPORT=10017, CURLOPT_USERAGENT=10018, CURLOPT_LOW_SPEED_LIMIT=19, CURLOPT_LOW_SPEED_TIME=20, CURLOPT_RESUME_FROM=21, CURLOPT_COOKIE=10022, CURLOPT_HTTPHEADER=10023, CURLOPT_HTTPPOST=10024, CURLOPT_SSLCERT=10025, CURLOPT_KEYPASSWD=10026, CURLOPT_CRLF=27, CURLOPT_QUOTE=10028, CURLOPT_HEADERDATA=10029, CURLOPT_COOKIEFILE=10031, CURLOPT_SSLVERSION=32, CURLOPT_TIMECONDITION=33, CURLOPT_TIMEVALUE=34, CURLOPT_CUSTOMREQUEST=10036, CURLOPT_STDERR=10037, CURLOPT_POSTQUOTE=10039, CURLOPT_OBSOLETE40=10040, CURLOPT_VERBOSE=41, CURLOPT_HEADER=42, CURLOPT_NOPROGRESS=43, CURLOPT_NOBODY=44, CURLOPT_FAILONERROR=45, CURLOPT_UPLOAD=46, CURLOPT_POST=47, CURLOPT_DIRLISTONLY=48, CURLOPT_APPEND=50, CURLOPT_NETRC=51, CURLOPT_FOLLOWLOCATION=52, CURLOPT_TRANSFERTEXT=53, CURLOPT_PUT=54, CURLOPT_PROGRESSFUNCTION=20056, CURLOPT_PROGRESSDATA=10057, CURLOPT_AUTOREFERER=58, CURLOPT_PROXYPORT=59, CURLOPT_POSTFIELDSIZE=60, CURLOPT_HTTPPROXYTUNNEL=61, CURLOPT_INTERFACE=10062, CURLOPT_KRBLEVEL=10063, CURLOPT_SSL_VERIFYPEER=64, CURLOPT_CAINFO=10065, CURLOPT_MAXREDIRS=68, CURLOPT_FILETIME=69, CURLOPT_TELNETOPTIONS=10070, CURLOPT_MAXCONNECTS=71, CURLOPT_OBSOLETE72=72, CURLOPT_FRESH_CONNECT=74, CURLOPT_FORBID_REUSE=75, CURLOPT_RANDOM_FILE=10076, CURLOPT_EGDSOCKET=10077, CURLOPT_CONNECTTIMEOUT=78, CURLOPT_HEADERFUNCTION=20079, CURLOPT_HTTPGET=80, CURLOPT_SSL_VERIFYHOST=81, CURLOPT_COOKIEJAR=10082, CURLOPT_SSL_CIPHER_LIST=10083, CURLOPT_HTTP_VERSION=84, CURLOPT_FTP_USE_EPSV=85, CURLOPT_SSLCERTTYPE=10086, CURLOPT_SSLKEY=10087, CURLOPT_SSLKEYTYPE=10088, CURLOPT_SSLENGINE=10089, CURLOPT_SSLENGINE_DEFAULT=90, CURLOPT_DNS_USE_GLOBAL_CACHE=91, CURLOPT_DNS_CACHE_TIMEOUT=92, CURLOPT_PREQUOTE=10093, CURLOPT_DEBUGFUNCTION=20094, CURLOPT_DEBUGDATA=10095, CURLOPT_COOKIESESSION=96, CURLOPT_CAPATH=10097, CURLOPT_BUFFERSIZE=98, CURLOPT_NOSIGNAL=99, CURLOPT_SHARE=10100, CURLOPT_PROXYTYPE=101, CURLOPT_ACCEPT_ENCODING=10102, CURLOPT_PRIVATE=10103, CURLOPT_HTTP200ALIASES=10104, CURLOPT_UNRESTRICTED_AUTH=105, CURLOPT_FTP_USE_EPRT=106, CURLOPT_HTTPAUTH=107, CURLOPT_SSL_CTX_FUNCTION=20108, CURLOPT_SSL_CTX_DATA=10109, CURLOPT_FTP_CREATE_MISSING_DIRS=110, CURLOPT_PROXYAUTH=111, CURLOPT_FTP_RESPONSE_TIMEOUT=112, CURLOPT_IPRESOLVE=113, CURLOPT_MAXFILESIZE=114, CURLOPT_INFILESIZE_LARGE=30115, CURLOPT_RESUME_FROM_LARGE=30116, CURLOPT_MAXFILESIZE_LARGE=30117, CURLOPT_NETRC_FILE=10118, CURLOPT_USE_SSL=119, CURLOPT_POSTFIELDSIZE_LARGE=30120, CURLOPT_TCP_NODELAY=121, CURLOPT_FTPSSLAUTH=129, CURLOPT_IOCTLFUNCTION=20130, CURLOPT_IOCTLDATA=10131, CURLOPT_FTP_ACCOUNT=10134, CURLOPT_COOKIELIST=10135, CURLOPT_IGNORE_CONTENT_LENGTH=136, CURLOPT_FTP_SKIP_PASV_IP=137, CURLOPT_FTP_FILEMETHOD=138, CURLOPT_LOCALPORT=139, CURLOPT_LOCALPORTRANGE=140, CURLOPT_CONNECT_ONLY=141, CURLOPT_CONV_FROM_NETWORK_FUNCTION=20142, CURLOPT_CONV_TO_NETWORK_FUNCTION=20143, CURLOPT_CONV_FROM_UTF8_FUNCTION=20144, CURLOPT_MAX_SEND_SPEED_LARGE=30145, CURLOPT_MAX_RECV_SPEED_LARGE=30146, CURLOPT_FTP_ALTERNATIVE_TO_USER=10147, CURLOPT_SOCKOPTFUNCTION=20148, CURLOPT_SOCKOPTDATA=10149, CURLOPT_SSL_SESSIONID_CACHE=150, CURLOPT_SSH_AUTH_TYPES=151, CURLOPT_SSH_PUBLIC_KEYFILE=10152, CURLOPT_SSH_PRIVATE_KEYFILE=10153, CURLOPT_FTP_SSL_CCC=154, CURLOPT_TIMEOUT_MS=155, CURLOPT_CONNECTTIMEOUT_MS=156, CURLOPT_HTTP_TRANSFER_DECODING=157, CURLOPT_HTTP_CONTENT_DECODING=158, CURLOPT_NEW_FILE_PERMS=159, CURLOPT_NEW_DIRECTORY_PERMS=160, CURLOPT_POSTREDIR=161, CURLOPT_SSH_HOST_PUBLIC_KEY_MD5=10162, CURLOPT_OPENSOCKETFUNCTION=20163, CURLOPT_OPENSOCKETDATA=10164, CURLOPT_COPYPOSTFIELDS=10165, CURLOPT_PROXY_TRANSFER_MODE=166, CURLOPT_SEEKFUNCTION=20167, CURLOPT_SEEKDATA=10168, CURLOPT_CRLFILE=10169, CURLOPT_ISSUERCERT=10170, CURLOPT_ADDRESS_SCOPE=171, CURLOPT_CERTINFO=172, CURLOPT_USERNAME=10173, CURLOPT_PASSWORD=10174, CURLOPT_PROXYUSERNAME=10175, CURLOPT_PROXYPASSWORD=10176, CURLOPT_NOPROXY=10177, CURLOPT_TFTP_BLKSIZE=178, CURLOPT_SOCKS5_GSSAPI_SERVICE=10179, CURLOPT_SOCKS5_GSSAPI_NEC=180, CURLOPT_PROTOCOLS=181, CURLOPT_REDIR_PROTOCOLS=182, CURLOPT_SSH_KNOWNHOSTS=10183, CURLOPT_SSH_KEYFUNCTION=20184, CURLOPT_SSH_KEYDATA=10185, CURLOPT_MAIL_FROM=10186, CURLOPT_MAIL_RCPT=10187, CURLOPT_FTP_USE_PRET=188, CURLOPT_RTSP_REQUEST=189, CURLOPT_RTSP_SESSION_ID=10190, CURLOPT_RTSP_STREAM_URI=10191, CURLOPT_RTSP_TRANSPORT=10192, CURLOPT_RTSP_CLIENT_CSEQ=193, CURLOPT_RTSP_SERVER_CSEQ=194, CURLOPT_INTERLEAVEDATA=10195, CURLOPT_INTERLEAVEFUNCTION=20196, CURLOPT_WILDCARDMATCH=197, CURLOPT_CHUNK_BGN_FUNCTION=20198, CURLOPT_CHUNK_END_FUNCTION=20199, CURLOPT_FNMATCH_FUNCTION=20200, CURLOPT_CHUNK_DATA=10201, CURLOPT_FNMATCH_DATA=10202, CURLOPT_RESOLVE=10203, CURLOPT_TLSAUTH_USERNAME=10204, CURLOPT_TLSAUTH_PASSWORD=10205, CURLOPT_TLSAUTH_TYPE=10206, CURLOPT_TRANSFER_ENCODING=207, CURLOPT_CLOSESOCKETFUNCTION=20208, CURLOPT_CLOSESOCKETDATA=10209, CURLOPT_GSSAPI_DELEGATION=210, CURLOPT_DNS_SERVERS=10211, CURLOPT_ACCEPTTIMEOUT_MS=212, CURLOPT_TCP_KEEPALIVE=213, CURLOPT_TCP_KEEPIDLE=214, CURLOPT_TCP_KEEPINTVL=215, CURLOPT_SSL_OPTIONS=216, CURLOPT_MAIL_AUTH=10217, CURLOPT_SASL_IR=218, CURLOPT_XFERINFOFUNCTION=20219, CURLOPT_XOAUTH2_BEARER=10220, CURLOPT_DNS_INTERFACE=10221, CURLOPT_DNS_LOCAL_IP4=10222, CURLOPT_DNS_LOCAL_IP6=10223, CURLOPT_LOGIN_OPTIONS=10224, CURLOPT_SSL_ENABLE_NPN=225, CURLOPT_SSL_ENABLE_ALPN=226, CURLOPT_EXPECT_100_TIMEOUT_MS=227, CURLOPT_PROXYHEADER=10228, CURLOPT_HEADEROPT=229, CURLOPT_PINNEDPUBLICKEY=10230, CURLOPT_UNIX_SOCKET_PATH=10231, CURLOPT_SSL_VERIFYSTATUS=232, CURLOPT_SSL_FALSESTART=233, CURLOPT_PATH_AS_IS=234, CURLOPT_PROXY_SERVICE_NAME=10235, CURLOPT_SERVICE_NAME=10236, CURLOPT_PIPEWAIT=237, CURLOPT_DEFAULT_PROTOCOL=10238, CURLOPT_STREAM_WEIGHT=239, CURLOPT_STREAM_DEPENDS=10240, CURLOPT_STREAM_DEPENDS_E=10241, CURLOPT_LASTENTRY=10242 };

// tag-#anon#ST[*{SYM#tag-block_info#}$SYM#tag-block_info#$'tqe_next'||*{*{SYM#tag-block_info#}$SYM#tag-block_info#$}$*{SYM#tag-block_info#}$SYM#tag-block_info#$$'tqe_prev'|]
// file ec_protect.c line 100
struct anonymous$7;

// tag-#anon#ST[*{SYM#tag-block_info#}$SYM#tag-block_info#$'tqh_first'||*{*{SYM#tag-block_info#}$SYM#tag-block_info#$}$*{SYM#tag-block_info#}$SYM#tag-block_info#$$'tqh_last'|]
// file ec_protect.c line 114
struct anonymous$9;

// tag-#anon#ST[*{SYM#tag-cache_entry#}$SYM#tag-cache_entry#$'tqe_next'||*{*{SYM#tag-cache_entry#}$SYM#tag-cache_entry#$}$*{SYM#tag-cache_entry#}$SYM#tag-cache_entry#$$'tqe_prev'|]
// file block_cache.c line 123
struct anonymous$1;

// tag-#anon#ST[*{SYM#tag-cache_entry#}$SYM#tag-cache_entry#$'tqh_first'||*{*{SYM#tag-cache_entry#}$SYM#tag-cache_entry#$}$*{SYM#tag-cache_entry#}$SYM#tag-cache_entry#$$'tqh_last'|]
// file block_cache.c line 153
struct anonymous;

// tag-#anon#ST[*{SYM#tag-curl_holder#}$SYM#tag-curl_holder#$'le_next'||*{*{SYM#tag-curl_holder#}$SYM#tag-curl_holder#$}$*{SYM#tag-curl_holder#}$SYM#tag-curl_holder#$$'le_prev'|]
// file http_io.c line 140
struct anonymous$6;

// tag-#anon#ST[*{SYM#tag-curl_holder#}$SYM#tag-curl_holder#$'lh_first'|]
// file http_io.c line 147
struct anonymous$11;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous$3;

// tag-#anon#ST[S32'rm_so'||S32'rm_eo'|]
// file /usr/include/regex.h line 452
struct anonymous$10;

// tag-#anon#UN[*{S8}$S8$'ptr'||S32'boolean'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'asn1_string'||*{SYM#tag-asn1_object_st#}$SYM#tag-asn1_object_st#$'object'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'integer'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'enumerated'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'bit_string'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'octet_string'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'printablestring'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'t61string'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'ia5string'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'generalstring'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'bmpstring'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'universalstring'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'utctime'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'generalizedtime'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'visiblestring'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'utf8string'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'set'||*{SYM#tag-asn1_string_st#}$SYM#tag-asn1_string_st#$'sequence'||*{SYM#tag-ASN1_VALUE_st#}$SYM#tag-ASN1_VALUE_st#$'asn1_value'|]
// file /usr/include/openssl/asn1.h line 526
union anonymous$13;

// tag-#anon#UN[*{V}$V$'data'||U32'dslot'|]
// file block_cache.c line 124
union anonymous$2;

// tag-#anon#UN[*{cV}$cV$'data'||ARR16{U8}$U8$'md5'|]
// file ec_protect.c line 101
union anonymous$8;

// tag-#anon#UN[ARR4{S8}$S8$'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous$15;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}$V$'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous$0;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}$S8$'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous$5;

// tag-ASN1_VALUE_st
// file /usr/include/openssl/asn1.h line 299
struct ASN1_VALUE_st;

// tag-MD5state_st
// file /usr/include/openssl/md5.h line 100
struct MD5state_st;

// tag-XML_Error
// file /usr/include/expat.h line 54
enum XML_Error { XML_ERROR_NONE=0, XML_ERROR_NO_MEMORY=1, XML_ERROR_SYNTAX=2, XML_ERROR_NO_ELEMENTS=3, XML_ERROR_INVALID_TOKEN=4, XML_ERROR_UNCLOSED_TOKEN=5, XML_ERROR_PARTIAL_CHAR=6, XML_ERROR_TAG_MISMATCH=7, XML_ERROR_DUPLICATE_ATTRIBUTE=8, XML_ERROR_JUNK_AFTER_DOC_ELEMENT=9, XML_ERROR_PARAM_ENTITY_REF=10, XML_ERROR_UNDEFINED_ENTITY=11, XML_ERROR_RECURSIVE_ENTITY_REF=12, XML_ERROR_ASYNC_ENTITY=13, XML_ERROR_BAD_CHAR_REF=14, XML_ERROR_BINARY_ENTITY_REF=15, XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF=16, XML_ERROR_MISPLACED_XML_PI=17, XML_ERROR_UNKNOWN_ENCODING=18, XML_ERROR_INCORRECT_ENCODING=19, XML_ERROR_UNCLOSED_CDATA_SECTION=20, XML_ERROR_EXTERNAL_ENTITY_HANDLING=21, XML_ERROR_NOT_STANDALONE=22, XML_ERROR_UNEXPECTED_STATE=23, XML_ERROR_ENTITY_DECLARED_IN_PE=24, XML_ERROR_FEATURE_REQUIRES_XML_DTD=25, XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING=26, XML_ERROR_UNBOUND_PREFIX=27, XML_ERROR_UNDECLARING_PREFIX=28, XML_ERROR_INCOMPLETE_PE=29, XML_ERROR_XML_DECL=30, XML_ERROR_TEXT_DECL=31, XML_ERROR_PUBLICID=32, XML_ERROR_SUSPENDED=33, XML_ERROR_NOT_SUSPENDED=34, XML_ERROR_ABORTED=35, XML_ERROR_FINISHED=36, XML_ERROR_SUSPEND_PE=37, XML_ERROR_RESERVED_PREFIX_XML=38, XML_ERROR_RESERVED_PREFIX_XMLNS=39, XML_ERROR_RESERVED_NAMESPACE_URI=40 };

// tag-XML_ParserStruct
// file /usr/include/expat.h line 24
struct XML_ParserStruct;

// tag-XML_Status
// file /usr/include/expat.h line 45
enum XML_Status { XML_STATUS_ERROR=0, XML_STATUS_OK=1, XML_STATUS_SUSPENDED=2 };

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-asn1_object_st
// file /usr/include/openssl/ossl_typ.h line 103
struct asn1_object_st;

// tag-asn1_string_st
// file /usr/include/openssl/ossl_typ.h line 83
struct asn1_string_st;

// tag-asn1_type_st
// file /usr/include/openssl/asn1.h line 524
struct asn1_type_st;

// tag-bio_method_st
// file /usr/include/openssl/bio.h line 312
struct bio_method_st;

// tag-bio_st
// file /usr/include/openssl/crypto.h line 290
struct bio_st;

// tag-block_cache_conf
// file block_cache.h line 38
struct block_cache_conf;

// tag-block_cache_private
// file block_cache.c line 149
struct block_cache_private;

// tag-block_cache_stats
// file block_cache.h line 54
struct block_cache_stats;

// tag-block_info
// file ec_protect.c line 97
struct block_info;

// tag-block_state
// file tester.c line 52
struct block_state;

// tag-buf_mem_st
// file /usr/include/openssl/ossl_typ.h line 127
struct buf_mem_st;

// tag-cache_entry
// file block_cache.c line 118
struct cache_entry;

// tag-cbinfo
// file block_cache.c line 178
struct cbinfo;

// tag-crypto_ex_data_st
// file /usr/include/openssl/ossl_typ.h line 195
struct crypto_ex_data_st;

// tag-curl_holder
// file http_io.c line 138
struct curl_holder;

// tag-curl_slist
// file /usr/include/curl/curl.h line 135
struct curl_slist;

// tag-dir_entry
// file dcache.c line 83
struct dir_entry;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-ec_protect_conf
// file ec_protect.h line 38
struct ec_protect_conf;

// tag-ec_protect_private
// file ec_protect.c line 108
struct ec_protect_private;

// tag-ec_protect_stats
// file ec_protect.h line 47
struct ec_protect_stats;

// tag-engine_st
// file /usr/include/openssl/ossl_typ.h line 177
struct engine_st;

// tag-env_md_ctx_st
// file /usr/include/openssl/ossl_typ.h line 132
struct env_md_ctx_st;

// tag-env_md_st
// file /usr/include/openssl/ossl_typ.h line 131
struct env_md_st;

// tag-erase_state
// file erase.c line 51
struct erase_state;

// tag-evp_cipher_ctx_st
// file /usr/include/openssl/ossl_typ.h line 130
struct evp_cipher_ctx_st;

// tag-evp_cipher_st
// file /usr/include/openssl/ossl_typ.h line 129
struct evp_cipher_st;

// tag-evp_pkey_ctx_st
// file /usr/include/openssl/ossl_typ.h line 138
struct evp_pkey_ctx_st;

// tag-file_header
// file dcache.c line 71
struct file_header;

// tag-fuse_args
// file /usr/include/fuse/fuse_opt.h line 108
struct fuse_args;

// tag-fuse_ops_conf
// file fuse_ops.h line 45
struct fuse_ops_conf;

// tag-fuse_opt
// file /usr/include/fuse/fuse_opt.h line 76
struct fuse_opt;

// tag-hmac_ctx_st
// file /usr/include/openssl/hmac.h line 75
struct hmac_ctx_st;

// tag-http_io
// file http_io.c line 169
struct http_io;

// tag-http_io_bufs
// file http_io.c line 161
struct http_io_bufs;

// tag-http_io_conf
// file http_io.h line 46
struct http_io_conf;

// tag-http_io_evst
// file http_io.h line 80
struct http_io_evst;

// tag-http_io_private
// file http_io.c line 144
struct http_io_private;

// tag-http_io_stats
// file http_io.h line 85
struct http_io_stats;

// tag-list_blocks
// file s3b_config.c line 96
struct list_blocks;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-re_pattern_buffer
// file /usr/include/regex.h line 357
struct re_pattern_buffer;

// tag-s3b_config
// file fuse_ops.h line 38
struct s3b_config;

// tag-s3b_dcache
// file dcache.h line 45
struct s3b_dcache;

// tag-s3b_hash
// file hash.h line 51
struct s3b_hash;

// tag-s3backer_store
// file s3backer.h line 120
struct s3backer_store;

// tag-size_suffix
// file s3b_config.c line 467
struct size_suffix;

// tag-stack_st
// file /usr/include/openssl/stack.h line 66
struct stack_st;

// tag-stack_st_void
// file /usr/include/openssl/crypto.h line 293
struct stack_st_void;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-test_io_private
// file test_io.c line 46
struct test_io_private;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

#ifndef NULL
#define NULL ((void*)0)
#endif

// BIO_ctrl
// file /usr/include/openssl/bio.h line 664
signed long int BIO_ctrl(struct bio_st *, signed int, signed long int, void *);
// BIO_f_base64
// file /usr/include/openssl/evp.h line 701
struct bio_method_st * BIO_f_base64(void);
// BIO_free_all
// file /usr/include/openssl/bio.h line 672
void BIO_free_all(struct bio_st *);
// BIO_new
// file /usr/include/openssl/bio.h line 655
struct bio_st * BIO_new(struct bio_method_st *);
// BIO_push
// file /usr/include/openssl/bio.h line 670
struct bio_st * BIO_push(struct bio_st *, struct bio_st *);
// BIO_s_mem
// file /usr/include/openssl/bio.h line 687
struct bio_method_st * BIO_s_mem(void);
// BIO_write
// file /usr/include/openssl/bio.h line 661
signed int BIO_write(struct bio_st *, const void *, signed int);
// CRYPTO_num_locks
// file /usr/include/openssl/crypto.h line 435
signed int CRYPTO_num_locks(void);
// CRYPTO_set_id_callback
// file /usr/include/openssl/crypto.h line 462
void CRYPTO_set_id_callback(unsigned long int (*)(void));
// CRYPTO_set_locking_callback
// file /usr/include/openssl/crypto.h line 437
void CRYPTO_set_locking_callback(void (*)(signed int, signed int, const char *, signed int));
// EVP_CIPHER_CTX_block_size
// file /usr/include/openssl/evp.h line 539
signed int EVP_CIPHER_CTX_block_size(const struct evp_cipher_ctx_st *);
// EVP_CIPHER_CTX_cleanup
// file /usr/include/openssl/evp.h line 691
signed int EVP_CIPHER_CTX_cleanup(struct evp_cipher_ctx_st *);
// EVP_CIPHER_CTX_init
// file /usr/include/openssl/evp.h line 690
void EVP_CIPHER_CTX_init(struct evp_cipher_ctx_st *);
// EVP_CIPHER_CTX_set_padding
// file /usr/include/openssl/evp.h line 695
signed int EVP_CIPHER_CTX_set_padding(struct evp_cipher_ctx_st *, signed int);
// EVP_CIPHER_block_size
// file /usr/include/openssl/evp.h line 531
signed int EVP_CIPHER_block_size(const struct evp_cipher_st *);
// EVP_CIPHER_iv_length
// file /usr/include/openssl/evp.h line 533
signed int EVP_CIPHER_iv_length(const struct evp_cipher_st *);
// EVP_CIPHER_key_length
// file /usr/include/openssl/evp.h line 532
signed int EVP_CIPHER_key_length(const struct evp_cipher_st *);
// EVP_CIPHER_nid
// file /usr/include/openssl/evp.h line 529
signed int EVP_CIPHER_nid(const struct evp_cipher_st *);
// EVP_CipherFinal_ex
// file /usr/include/openssl/evp.h line 649
signed int EVP_CipherFinal_ex(struct evp_cipher_ctx_st *, unsigned char *, signed int *);
// EVP_CipherInit_ex
// file /usr/include/openssl/evp.h line 643
signed int EVP_CipherInit_ex(struct evp_cipher_ctx_st *, const struct evp_cipher_st *, struct engine_st *, const unsigned char *, const unsigned char *, signed int);
// EVP_CipherUpdate
// file /usr/include/openssl/evp.h line 646
signed int EVP_CipherUpdate(struct evp_cipher_ctx_st *, unsigned char *, signed int *, const unsigned char *, signed int);
// EVP_DigestFinal_ex
// file /usr/include/openssl/evp.h line 596
signed int EVP_DigestFinal_ex(struct env_md_ctx_st *, unsigned char *, unsigned int *);
// EVP_DigestInit_ex
// file /usr/include/openssl/evp.h line 594
signed int EVP_DigestInit_ex(struct env_md_ctx_st *, const struct env_md_st *, struct engine_st *);
// EVP_DigestUpdate
// file /usr/include/openssl/evp.h line 595
signed int EVP_DigestUpdate(struct env_md_ctx_st *, const void *, unsigned long int);
// EVP_EncryptFinal_ex
// file /usr/include/openssl/evp.h line 627
signed int EVP_EncryptFinal_ex(struct evp_cipher_ctx_st *, unsigned char *, signed int *);
// EVP_EncryptInit_ex
// file /usr/include/openssl/evp.h line 622
signed int EVP_EncryptInit_ex(struct evp_cipher_ctx_st *, const struct evp_cipher_st *, struct engine_st *, const unsigned char *, const unsigned char *);
// EVP_EncryptUpdate
// file /usr/include/openssl/evp.h line 625
signed int EVP_EncryptUpdate(struct evp_cipher_ctx_st *, unsigned char *, signed int *, const unsigned char *, signed int);
// EVP_MD_CTX_cleanup
// file /usr/include/openssl/evp.h line 587
signed int EVP_MD_CTX_cleanup(struct env_md_ctx_st *);
// EVP_MD_CTX_init
// file /usr/include/openssl/evp.h line 586
void EVP_MD_CTX_init(struct env_md_ctx_st *);
// EVP_get_cipherbyname
// file /usr/include/openssl/evp.h line 925
const struct evp_cipher_st * EVP_get_cipherbyname(const char *);
// EVP_sha1
// file /usr/include/openssl/evp.h line 720
const struct env_md_st * EVP_sha1(void);
// EVP_sha256
// file /usr/include/openssl/evp.h line 727
const struct env_md_st * EVP_sha256(void);
// HMAC_CTX_cleanup
// file /usr/include/openssl/hmac.h line 87
void HMAC_CTX_cleanup(struct hmac_ctx_st *);
// HMAC_CTX_init
// file /usr/include/openssl/hmac.h line 86
void HMAC_CTX_init(struct hmac_ctx_st *);
// HMAC_Final
// file /usr/include/openssl/hmac.h line 97
signed int HMAC_Final(struct hmac_ctx_st *, unsigned char *, unsigned int *);
// HMAC_Init_ex
// file /usr/include/openssl/hmac.h line 94
signed int HMAC_Init_ex(struct hmac_ctx_st *, const void *, signed int, const struct env_md_st *, struct engine_st *);
// HMAC_Update
// file /usr/include/openssl/hmac.h line 96
signed int HMAC_Update(struct hmac_ctx_st *, const unsigned char *, unsigned long int);
// MD5
// file /usr/include/openssl/md5.h line 113
unsigned char * MD5(const unsigned char *, unsigned long int, unsigned char *);
// MD5_Final
// file /usr/include/openssl/md5.h line 112
signed int MD5_Final(unsigned char *, struct MD5state_st *);
// MD5_Init
// file /usr/include/openssl/md5.h line 110
signed int MD5_Init(struct MD5state_st *);
// MD5_Update
// file /usr/include/openssl/md5.h line 111
signed int MD5_Update(struct MD5state_st *, const void *, unsigned long int);
// OBJ_nid2sn
// file /usr/include/openssl/objects.h line 1010
const char * OBJ_nid2sn(signed int);
// OpenSSL_add_all_ciphers
// file /usr/include/openssl/evp.h line 916
void OpenSSL_add_all_ciphers(void);
// PKCS5_PBKDF2_HMAC_SHA1
// file /usr/include/openssl/evp.h line 1023
signed int PKCS5_PBKDF2_HMAC_SHA1(const char *, signed int, const unsigned char *, signed int, signed int, signed int, unsigned char *);
// XML_ErrorString
// file /usr/include/expat.h line 990
const char * XML_ErrorString(enum XML_Error);
// XML_GetCurrentColumnNumber
// file /usr/include/expat.h line 941
unsigned long int XML_GetCurrentColumnNumber(struct XML_ParserStruct *);
// XML_GetCurrentLineNumber
// file /usr/include/expat.h line 940
unsigned long int XML_GetCurrentLineNumber(struct XML_ParserStruct *);
// XML_GetErrorCode
// file /usr/include/expat.h line 922
enum XML_Error XML_GetErrorCode(struct XML_ParserStruct *);
// XML_Parse
// file /usr/include/expat.h line 778
enum XML_Status XML_Parse(struct XML_ParserStruct *, const char *, signed int, signed int);
// XML_ParserCreate
// file /usr/include/expat.h line 206
struct XML_ParserStruct * XML_ParserCreate(const char *);
// XML_ParserFree
// file /usr/include/expat.h line 986
void XML_ParserFree(struct XML_ParserStruct *);
// XML_ParserReset
// file /usr/include/expat.h line 247
unsigned char XML_ParserReset(struct XML_ParserStruct *, const char *);
// XML_SetCharacterDataHandler
// file /usr/include/expat.h line 547
void XML_SetCharacterDataHandler(struct XML_ParserStruct *, void (*)(void *, const char *, signed int));
// XML_SetElementHandler
// file /usr/include/expat.h line 534
void XML_SetElementHandler(struct XML_ParserStruct *, void (*)(void *, const char *, const char **), void (*)(void *, const char *));
// XML_SetUserData
// file /usr/include/expat.h line 671
void XML_SetUserData(struct XML_ParserStruct *, void *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _curl_easy_getinfo_err_curl_slist
// file /usr/include/curl/typecheck-gcc.h line 201
static void _curl_easy_getinfo_err_curl_slist(void);
// _curl_easy_getinfo_err_double
// file /usr/include/curl/typecheck-gcc.h line 199
static void _curl_easy_getinfo_err_double(void);
// _curl_easy_getinfo_err_long
// file /usr/include/curl/typecheck-gcc.h line 197
static void _curl_easy_getinfo_err_long(void);
// _curl_easy_getinfo_err_string
// file /usr/include/curl/typecheck-gcc.h line 195
static void _curl_easy_getinfo_err_string(void);
// _curl_easy_setopt_err_CURLSH
// file /usr/include/curl/typecheck-gcc.h line 192
static void _curl_easy_setopt_err_CURLSH(void);
// _curl_easy_setopt_err_FILE
// file /usr/include/curl/typecheck-gcc.h line 184
static void _curl_easy_setopt_err_FILE(void);
// _curl_easy_setopt_err_cb_data
// file /usr/include/curl/typecheck-gcc.h line 178
static void _curl_easy_setopt_err_cb_data(void);
// _curl_easy_setopt_err_conv_cb
// file /usr/include/curl/typecheck-gcc.h line 174
static void _curl_easy_setopt_err_conv_cb(void);
// _curl_easy_setopt_err_curl_httpost
// file /usr/include/curl/typecheck-gcc.h line 188
static void _curl_easy_setopt_err_curl_httpost(void);
// _curl_easy_setopt_err_curl_off_t
// file /usr/include/curl/typecheck-gcc.h line 150
static void _curl_easy_setopt_err_curl_off_t(void);
// _curl_easy_setopt_err_curl_slist
// file /usr/include/curl/typecheck-gcc.h line 190
static void _curl_easy_setopt_err_curl_slist(void);
// _curl_easy_setopt_err_debug_cb
// file /usr/include/curl/typecheck-gcc.h line 170
static void _curl_easy_setopt_err_debug_cb(void);
// _curl_easy_setopt_err_error_buffer
// file /usr/include/curl/typecheck-gcc.h line 181
static void _curl_easy_setopt_err_error_buffer(void);
// _curl_easy_setopt_err_ioctl_cb
// file /usr/include/curl/typecheck-gcc.h line 160
static void _curl_easy_setopt_err_ioctl_cb(void);
// _curl_easy_setopt_err_long
// file /usr/include/curl/typecheck-gcc.h line 148
static void _curl_easy_setopt_err_long(void);
// _curl_easy_setopt_err_opensocket_cb
// file /usr/include/curl/typecheck-gcc.h line 164
static void _curl_easy_setopt_err_opensocket_cb(void);
// _curl_easy_setopt_err_postfields
// file /usr/include/curl/typecheck-gcc.h line 186
static void _curl_easy_setopt_err_postfields(void);
// _curl_easy_setopt_err_progress_cb
// file /usr/include/curl/typecheck-gcc.h line 168
static void _curl_easy_setopt_err_progress_cb(void);
// _curl_easy_setopt_err_read_cb
// file /usr/include/curl/typecheck-gcc.h line 158
static void _curl_easy_setopt_err_read_cb(void);
// _curl_easy_setopt_err_seek_cb
// file /usr/include/curl/typecheck-gcc.h line 176
static void _curl_easy_setopt_err_seek_cb(void);
// _curl_easy_setopt_err_sockopt_cb
// file /usr/include/curl/typecheck-gcc.h line 162
static void _curl_easy_setopt_err_sockopt_cb(void);
// _curl_easy_setopt_err_ssl_ctx_cb
// file /usr/include/curl/typecheck-gcc.h line 172
static void _curl_easy_setopt_err_ssl_ctx_cb(void);
// _curl_easy_setopt_err_string
// file /usr/include/curl/typecheck-gcc.h line 152
static void _curl_easy_setopt_err_string(void);
// _curl_easy_setopt_err_write_callback
// file /usr/include/curl/typecheck-gcc.h line 156
static void _curl_easy_setopt_err_write_callback(void);
// asprintf
// file /usr/include/stdio.h line 405
extern signed int asprintf(char ** restrict , const char *, ...);
// block_cache_check_cancel
// file block_cache.c line 1157
static signed int block_cache_check_cancel(void *arg, unsigned int block_num);
// block_cache_create
// file block_cache.c line 232
extern struct s3backer_store * block_cache_create(struct block_cache_conf *config, struct s3backer_store *inner);
// block_cache_dcache_load
// file block_cache.c line 353
static signed int block_cache_dcache_load(void *arg, unsigned int dslot, unsigned int block_num, const unsigned char *md5);
// block_cache_destroy
// file block_cache.c line 429
static void block_cache_destroy(struct s3backer_store * const s3b);
// block_cache_dirty_callback
// file block_cache.c line 1333
static void block_cache_dirty_callback(void *arg, void *value);
// block_cache_dirty_ratio
// file block_cache.c line 1325
static double block_cache_dirty_ratio(struct block_cache_private *priv);
// block_cache_do_read
// file block_cache.c line 554
static signed int block_cache_do_read(struct block_cache_private * const priv, unsigned int block_num, unsigned int off, unsigned int len, void *dest, signed int stats);
// block_cache_flush
// file block_cache.c line 408
static signed int block_cache_flush(struct s3backer_store * const s3b);
// block_cache_free_entry
// file block_cache.c line 970
static void block_cache_free_entry(struct block_cache_private *priv, struct cache_entry **entryp);
// block_cache_free_one
// file block_cache.c line 1230
static void block_cache_free_one(void *arg, void *value);
// block_cache_get_entry
// file block_cache.c line 907
static signed int block_cache_get_entry(struct block_cache_private *priv, struct cache_entry **entryp, void **datap);
// block_cache_get_stats
// file block_cache.c line 464
extern void block_cache_get_stats(struct s3backer_store *s3b, struct block_cache_stats *stats);
// block_cache_get_time
// file block_cache.c line 1209
static unsigned int block_cache_get_time(struct block_cache_private *priv);
// block_cache_get_time_millis
// file block_cache.c line 1221
static unsigned long int block_cache_get_time_millis(void);
// block_cache_list_blocks
// file block_cache.c line 476
static signed int block_cache_list_blocks(struct s3backer_store *s3b, void (*callback)(void *, unsigned int), void *arg);
// block_cache_list_blocks::callback$object
//
void callback$object(void *, unsigned int);
// block_cache_meta_data
// file block_cache.c line 392
static signed int block_cache_meta_data(struct s3backer_store *s3b, signed long int *file_sizep, unsigned int *block_sizep);
// block_cache_read
// file block_cache.c line 516
static signed int block_cache_read(struct block_cache_private * const priv, unsigned int block_num, unsigned int off, unsigned int len, void *dest);
// block_cache_read_block
// file block_cache.c line 493
static signed int block_cache_read_block(struct s3backer_store * const s3b, unsigned int block_num, void *dest, unsigned char *actual_md5, const unsigned char *expect_md5, signed int strict);
// block_cache_read_block_part
// file block_cache.c line 505
static signed int block_cache_read_block_part(struct s3backer_store *s3b, unsigned int block_num, unsigned int off, unsigned int len, void *dest);
// block_cache_read_data
// file block_cache.c line 1275
static signed int block_cache_read_data(struct block_cache_private *priv, struct cache_entry *entry, void *dest, unsigned int off, unsigned int len);
// block_cache_set_mounted
// file block_cache.c line 400
static signed int block_cache_set_mounted(struct s3backer_store *s3b, signed int *old_valuep, signed int new_value);
// block_cache_verified
// file block_cache.c line 1245
static struct cache_entry * block_cache_verified(struct block_cache_private *priv, struct cache_entry *entry);
// block_cache_worker_main
// file block_cache.c line 1004
static void * block_cache_worker_main(void *arg);
// block_cache_worker_wait
// file block_cache.c line 1190
static void block_cache_worker_wait(struct block_cache_private *priv, struct cache_entry *entry);
// block_cache_write
// file block_cache.c line 749
static signed int block_cache_write(struct block_cache_private * const priv, unsigned int block_num, unsigned int off, unsigned int len, const void *src);
// block_cache_write_block
// file block_cache.c line 727
static signed int block_cache_write_block(struct s3backer_store * const s3b, unsigned int block_num, const void *src, unsigned char *md5, signed int (*check_cancel)(void *, unsigned int), void *check_cancel_arg);
// block_cache_write_block::check_cancel$object
//
signed int check_cancel$object(void *, unsigned int);
// block_cache_write_block_part
// file block_cache.c line 738
static signed int block_cache_write_block_part(struct s3backer_store *s3b, unsigned int block_num, unsigned int off, unsigned int len, const void *src);
// block_cache_write_data
// file block_cache.c line 1298
static signed int block_cache_write_data(struct block_cache_private *priv, struct cache_entry *entry, const void *src, unsigned int off, unsigned int len);
// block_part_read_block_part
// file block_part.c line 44
extern signed int block_part_read_block_part(struct s3backer_store *s3b, unsigned int block_num, unsigned int block_size, unsigned int off, unsigned int len, void *dest);
// block_part_write_block_part
// file block_part.c line 83
extern signed int block_part_write_block_part(struct s3backer_store *s3b, unsigned int block_num, unsigned int block_size, unsigned int off, unsigned int len, const void *src);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// compress2
// file /usr/include/zlib.h line 1174
extern signed int compress2(unsigned char *, unsigned long int *, const unsigned char *, unsigned long int, signed int);
// compressBound
// file /usr/include/zlib.h line 1190
extern unsigned long int compressBound(unsigned long int);
// curl_easy_cleanup
// file /usr/include/curl/easy.h line 31
void curl_easy_cleanup(void *);
// curl_easy_getinfo
// file /usr/include/curl/easy.h line 46
enum anonymous$4 curl_easy_getinfo(void *, enum anonymous$14, ...);
// curl_easy_init
// file /usr/include/curl/easy.h line 28
void * curl_easy_init(void);
// curl_easy_perform
// file /usr/include/curl/easy.h line 30
enum anonymous$4 curl_easy_perform(void *);
// curl_easy_reset
// file /usr/include/curl/easy.h line 74
void curl_easy_reset(void *);
// curl_easy_setopt
// file /usr/include/curl/easy.h line 29
enum anonymous$4 curl_easy_setopt(void *, enum anonymous$12, ...);
// curl_easy_strerror
// file /usr/include/curl/curl.h line 2352
const char * curl_easy_strerror(enum anonymous$4);
// curl_global_cleanup
// file /usr/include/curl/curl.h line 2044
void curl_global_cleanup(void);
// curl_global_init
// file /usr/include/curl/curl.h line 2014
enum anonymous$4 curl_global_init(signed long int);
// curl_slist_append
// file /usr/include/curl/curl.h line 2060
struct curl_slist * curl_slist_append(struct curl_slist *, const char *);
// curl_slist_free_all
// file /usr/include/curl/curl.h line 2070
void curl_slist_free_all(struct curl_slist *);
// dump_config
// file s3b_config.c line 1514
static void dump_config(void);
// ec_protect_create
// file ec_protect.c line 166
extern struct s3backer_store * ec_protect_create(struct ec_protect_conf *config, struct s3backer_store *inner);
// ec_protect_destroy
// file ec_protect.c line 264
static void ec_protect_destroy(struct s3backer_store * const s3b);
// ec_protect_dirty_callback
// file ec_protect.c line 612
static void ec_protect_dirty_callback(void *arg, void *value);
// ec_protect_flush
// file ec_protect.c line 246
static signed int ec_protect_flush(struct s3backer_store * const s3b);
// ec_protect_free_one
// file ec_protect.c line 606
static void ec_protect_free_one(void *arg, void *value);
// ec_protect_get_stats
// file ec_protect.c line 291
extern void ec_protect_get_stats(struct s3backer_store *s3b, struct ec_protect_stats *stats);
// ec_protect_get_time
// file ec_protect.c line 529
static unsigned long int ec_protect_get_time(void);
// ec_protect_list_blocks
// file ec_protect.c line 302
static signed int ec_protect_list_blocks(struct s3backer_store *s3b, void (*callback)(void *, unsigned int), void *arg);
// ec_protect_list_blocks::callback$object
//
void callback$object(void *, unsigned int);
// ec_protect_meta_data
// file ec_protect.c line 230
static signed int ec_protect_meta_data(struct s3backer_store *s3b, signed long int *file_sizep, unsigned int *block_sizep);
// ec_protect_read_block
// file ec_protect.c line 319
static signed int ec_protect_read_block(struct s3backer_store * const s3b, unsigned int block_num, void *dest, unsigned char *actual_md5, const unsigned char *expect_md5, signed int strict);
// ec_protect_read_block_part
// file ec_protect.c line 508
static signed int ec_protect_read_block_part(struct s3backer_store *s3b, unsigned int block_num, unsigned int off, unsigned int len, void *dest);
// ec_protect_scrub_expired_writtens
// file ec_protect.c line 542
static void ec_protect_scrub_expired_writtens(struct ec_protect_private *priv, unsigned long int current_time);
// ec_protect_set_mounted
// file ec_protect.c line 238
static signed int ec_protect_set_mounted(struct s3backer_store *s3b, signed int *old_valuep, signed int new_value);
// ec_protect_sleep_until
// file ec_protect.c line 576
static unsigned long int ec_protect_sleep_until(struct ec_protect_private *priv, union anonymous$0 *cond, unsigned long int wake_time_millis);
// ec_protect_write_block
// file ec_protect.c line 382
static signed int ec_protect_write_block(struct s3backer_store * const s3b, unsigned int block_num, const void *src, unsigned char *caller_md5, signed int (*check_cancel)(void *, unsigned int), void *check_cancel_arg);
// ec_protect_write_block::check_cancel$object
//
signed int check_cancel$object(void *, unsigned int);
// ec_protect_write_block_part
// file ec_protect.c line 517
static signed int ec_protect_write_block_part(struct s3backer_store *s3b, unsigned int block_num, unsigned int off, unsigned int len, const void *src);
// erase_list_callback
// file erase.c line 169
static void erase_list_callback(void *arg, unsigned int block_num);
// erase_thread_main
// file erase.c line 182
static void * erase_thread_main(void *arg);
// err
// file /usr/include/err.h line 46
extern void err(signed int, const char *, ...);
// errx
// file /usr/include/err.h line 50
extern void errx(signed int, const char *, ...);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fdatasync
// file /usr/include/unistd.h line 1112
extern signed int fdatasync(signed int);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// ffs
// file /usr/include/string.h line 522
extern signed int ffs(signed int);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fopen
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 219
extern signed int fstat(signed int, struct stat *);
// ftruncate
// file /usr/include/unistd.h line 1019
extern signed int ftruncate(signed int, signed long int);
// fuse_opt_insert_arg
// file /usr/include/fuse/fuse_opt.h line 245
signed int fuse_opt_insert_arg(struct fuse_args *, signed int, const char *);
// fuse_opt_parse
// file /usr/include/fuse/fuse_opt.h line 202
signed int fuse_opt_parse(struct fuse_args *, void *, struct fuse_opt *, signed int (*)(void *, const char *, signed int, struct fuse_args *));
// get_time
// file tester.c line 218
static unsigned long int get_time(void);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getgid
// file /usr/include/unistd.h line 681
extern unsigned int getgid(void);
// gethostname
// file /usr/include/unistd.h line 879
extern signed int gethostname(char *, unsigned long int);
// getpagesize
// file /usr/include/unistd.h line 978
extern signed int getpagesize(void);
// getpass
// file /usr/include/unistd.h line 948
extern char * getpass(const char *);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getuid
// file /usr/include/unistd.h line 675
extern unsigned int getuid(void);
// gmtime_r
// file /usr/include/time.h line 249
extern struct tm * gmtime_r(const signed long int *, struct tm *);
// handle_unknown_option
// file s3b_config.c line 810
static signed int handle_unknown_option(void *data, const char *arg, signed int key, struct fuse_args *outargs);
// http_io_acquire_curl
// file http_io.c line 2297
static void * http_io_acquire_curl(struct http_io_private *priv, struct http_io *io);
// http_io_add_auth
// file http_io.c line 1801
static signed int http_io_add_auth(struct http_io_private *priv, struct http_io * const io, signed long int now, const void *payload, unsigned long int plen);
// http_io_add_auth2
// file http_io.c line 1823
static signed int http_io_add_auth2(struct http_io_private *priv, struct http_io * const io, signed long int now, const void *payload, unsigned long int plen);
// http_io_add_auth4
// file http_io.c line 1936
static signed int http_io_add_auth4(struct http_io_private *priv, struct http_io * const io, signed long int now, const void *payload, unsigned long int plen);
// http_io_add_date
// file http_io.c line 2268
static void http_io_add_date(struct http_io_private * const priv, struct http_io * const io, signed long int now);
// http_io_add_header
// file http_io.c line 2284
static struct curl_slist * http_io_add_header(struct curl_slist *headers, const char *fmt, ...);
// http_io_authsig
// file http_io.c line 2577
static void http_io_authsig(struct http_io_private *priv, unsigned int block_num, const unsigned char *src, unsigned int len, unsigned char *hmac);
// http_io_base64_encode
// file http_io.c line 2475
static void http_io_base64_encode(char *buf, unsigned long int bufsiz, const void *data, unsigned long int len);
// http_io_create
// file http_io.h line 128
extern struct s3backer_store * http_io_create(struct http_io_conf *config);
// http_io_crypt
// file http_io.c line 2512
static unsigned int http_io_crypt(struct http_io_private *priv, unsigned int block_num, signed int enc, const unsigned char *src, unsigned int len, unsigned char *dest);
// http_io_curl_header
// file http_io.c line 2381
static unsigned long int http_io_curl_header(void *ptr, unsigned long int size, unsigned long int nmemb, void *stream);
// http_io_curl_list_reader
// file http_io.c line 627
static unsigned long int http_io_curl_list_reader(const void *ptr, unsigned long int size, unsigned long int nmemb, void *stream);
// http_io_curl_reader
// file http_io.c line 2346
static unsigned long int http_io_curl_reader(const void *ptr, unsigned long int size, unsigned long int nmemb, void *stream);
// http_io_curl_writer
// file http_io.c line 2361
static unsigned long int http_io_curl_writer(void *ptr, unsigned long int size, unsigned long int nmemb, void *stream);
// http_io_destroy
// file http_io.c line 445
static void http_io_destroy(struct s3backer_store * const s3b);
// http_io_flush
// file http_io.c line 488
static signed int http_io_flush(struct s3backer_store * const s3b);
// http_io_get_block_url
// file http_io.c line 2234
static void http_io_get_block_url(char *buf, unsigned long int bufsiz, struct http_io_conf *config, unsigned int block_num);
// http_io_get_mounted_flag_url
// file http_io.c line 2252
static void http_io_get_mounted_flag_url(char *buf, unsigned long int bufsiz, struct http_io_conf *config);
// http_io_get_stats
// file http_io.c line 494
extern void http_io_get_stats(struct s3backer_store *s3b, struct http_io_stats *stats);
// http_io_head_prepper
// file http_io.c line 784
static void http_io_head_prepper(void *curl, struct http_io *io);
// http_io_iamcreds_prepper
// file http_io.c line 1020
static void http_io_iamcreds_prepper(void *curl, struct http_io *io);
// http_io_is_zero_block
// file http_io.c line 2492
static signed int http_io_is_zero_block(const void *data, unsigned int block_size);
// http_io_list_blocks
// file http_io.c line 504
static signed int http_io_list_blocks(struct s3backer_store *s3b, void (*callback)(void *, unsigned int), void *arg);
// http_io_list_blocks::callback$object
//
void callback$object(void *, unsigned int);
// http_io_list_elem_end
// file http_io.c line 665
static void http_io_list_elem_end(void *arg, const char *name);
// http_io_list_elem_start
// file http_io.c line 643
static void http_io_list_elem_start(void *arg, const char *name, const char **atts);
// http_io_list_prepper
// file http_io.c line 617
static void http_io_list_prepper(void *curl, struct http_io *io);
// http_io_list_text
// file http_io.c line 692
static void http_io_list_text(void *arg, const char *s, signed int len);
// http_io_meta_data
// file http_io.c line 741
static signed int http_io_meta_data(struct s3backer_store *s3b, signed long int *file_sizep, unsigned int *block_sizep);
// http_io_openssl_ider
// file http_io.c line 2469
static unsigned long int http_io_openssl_ider(void);
// http_io_openssl_locker
// file http_io.c line 2460
static void http_io_openssl_locker(signed int mode, signed int i, const char *file, signed int line);
// http_io_parse_block
// file http_io.c line 710
extern signed int http_io_parse_block(struct http_io_conf *config, const char *name, unsigned int *block_nump);
// http_io_parse_hex
// file http_io.c line 2637
static signed int http_io_parse_hex(const char *str, unsigned char *buf, unsigned int nbytes);
// http_io_perform_io
// file http_io.c line 1586
static signed int http_io_perform_io(struct http_io_private *priv, struct http_io *io, void (*prepper)(void *, struct http_io *));
// http_io_perform_io::prepper$object
//
void prepper$object(void *, struct http_io *);
// http_io_prhex
// file http_io.c line 2664
static void http_io_prhex(char *buf, const unsigned char *data, unsigned long int len);
// http_io_read_block
// file http_io.c line 1033
static signed int http_io_read_block(struct s3backer_store * const s3b, unsigned int block_num, void *dest, unsigned char *actual_md5, const unsigned char *expect_md5, signed int strict);
// http_io_read_block_part
// file http_io.c line 1565
static signed int http_io_read_block_part(struct s3backer_store *s3b, unsigned int block_num, unsigned int off, unsigned int len, void *dest);
// http_io_read_prepper
// file http_io.c line 1316
static void http_io_read_prepper(void *curl, struct http_io *io);
// http_io_release_curl
// file http_io.c line 2435
static void http_io_release_curl(struct http_io_private *priv, void **curlp, signed int may_cache);
// http_io_set_mounted
// file http_io.c line 796
static signed int http_io_set_mounted(struct s3backer_store *s3b, signed int *old_valuep, signed int new_value);
// http_io_strcasecmp_ptr
// file http_io.c line 2677
static signed int http_io_strcasecmp_ptr(const void * const ptr1, const void * const ptr2);
// http_io_write_block
// file http_io.c line 1335
static signed int http_io_write_block(struct s3backer_store * const s3b, unsigned int block_num, const void *src, unsigned char *caller_md5, signed int (*check_cancel)(void *, unsigned int), void *check_cancel_arg);
// http_io_write_block::check_cancel$object
//
signed int check_cancel$object(void *, unsigned int);
// http_io_write_block_part
// file http_io.c line 1574
static signed int http_io_write_block_part(struct s3backer_store *s3b, unsigned int block_num, unsigned int off, unsigned int len, const void *src);
// http_io_write_prepper
// file http_io.c line 1545
static void http_io_write_prepper(void *curl, struct http_io *io);
// list_blocks_callback
// file s3b_config.c line 1500
static void list_blocks_callback(void *arg, unsigned int block_num);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// logit
// file tester.c line 205
static void logit(signed int id, const char *fmt, ...);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// mkstemp
// file /usr/include/stdlib.h line 622
extern signed int mkstemp(char *);
// nanosleep
// file /usr/include/time.h line 334
extern signed int nanosleep(struct timespec *, struct timespec *);
// open
// file /usr/include/fcntl.h line 149
extern signed int open(const char *, signed int, ...);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// parse_json_field
// file http_io.c line 981
static char * parse_json_field(struct http_io_private *priv, const char *json, const char *field);
// parse_size_string
// file s3b_config.c line 753
static signed int parse_size_string(const char *s, unsigned long int *valp);
// pread
// file /usr/include/unistd.h line 388
extern signed long int pread(signed int, void *, unsigned long int, signed long int);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous$0 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous$0 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous$0 *, const union anonymous$15 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous$0 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous$0 *, union anonymous$5 *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous$0 *, union anonymous$5 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous$5 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous$5 *, const union anonymous$15 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous$5 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous$5 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// pwrite
// file /usr/include/unistd.h line 391
extern signed long int pwrite(signed int, const void *, unsigned long int, signed long int);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// random
// file /usr/include/stdlib.h line 321
extern signed long int random(void);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// readdir
// file /usr/include/dirent.h line 165
extern struct dirent * readdir(struct __dirstream *);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// regcomp
// file /usr/include/regex.h line 562
extern signed int regcomp(struct re_pattern_buffer *, const char *, signed int);
// regerror
// file /usr/include/regex.h line 571
extern unsigned long int regerror(signed int, const struct re_pattern_buffer *, char *, unsigned long int);
// regexec
// file /usr/include/regex.h line 566
extern signed int regexec(const struct re_pattern_buffer *, const char *, unsigned long int, struct anonymous$10 *, signed int);
// regfree
// file /usr/include/regex.h line 574
extern void regfree(struct re_pattern_buffer *);
// rename
// file /usr/include/stdio.h line 180
extern signed int rename(const char *, const char *);
// s3b_config_print_stats
// file s3b_config.c line 652
static void s3b_config_print_stats(void *prarg, void (*printer)(void *, const char *, ...));
// s3b_config_print_stats::printer$object
//
void printer$object(void *, const char *, ...);
// s3b_dcache_alloc_block
// file dcache.h line 52
extern signed int s3b_dcache_alloc_block(struct s3b_dcache *priv, unsigned int *dslotp);
// s3b_dcache_close
// file dcache.h line 50
extern void s3b_dcache_close(struct s3b_dcache *priv);
// s3b_dcache_create_file
// file dcache.c line 599
static signed int s3b_dcache_create_file(struct s3b_dcache *priv, signed int *fdp, const char *filename, unsigned int max_blocks, struct file_header *headerp);
// s3b_dcache_erase_block
// file dcache.h line 54
extern signed int s3b_dcache_erase_block(struct s3b_dcache *priv, unsigned int dslot);
// s3b_dcache_free_block
// file dcache.h line 55
extern signed int s3b_dcache_free_block(struct s3b_dcache *priv, unsigned int dslot);
// s3b_dcache_fsync
// file dcache.c line 429
extern signed int s3b_dcache_fsync(struct s3b_dcache *priv);
// s3b_dcache_init_free_list
// file dcache.c line 647
static signed int s3b_dcache_init_free_list(struct s3b_dcache *priv, signed int (*visitor)(void *, unsigned int, unsigned int, const unsigned char *), void *arg);
// s3b_dcache_init_free_list::visitor$object
//
signed int visitor$object(void *, unsigned int, unsigned int, const unsigned char *);
// s3b_dcache_open
// file dcache.h line 48
extern signed int s3b_dcache_open(struct s3b_dcache **dcachep, void (*log)(signed int, const char *, ...), const char *filename, unsigned int block_size, unsigned int max_blocks, signed int (*visitor)(void *, unsigned int, unsigned int, const unsigned char *), void *arg);
// s3b_dcache_open::log$object
//
void log$object(signed int, const char *, ...);
// s3b_dcache_open::visitor$object
//
signed int visitor$object(void *, unsigned int, unsigned int, const unsigned char *);
// s3b_dcache_pop
// file dcache.c line 767
static void s3b_dcache_pop(struct s3b_dcache *priv, unsigned int *dslotp);
// s3b_dcache_push
// file dcache.c line 735
static signed int s3b_dcache_push(struct s3b_dcache *priv, unsigned int dslot);
// s3b_dcache_read
// file dcache.c line 793
static signed int s3b_dcache_read(struct s3b_dcache *priv, signed long int offset, void *data, unsigned long int len);
// s3b_dcache_read_block
// file dcache.h line 56
extern signed int s3b_dcache_read_block(struct s3b_dcache *priv, unsigned int dslot, void *dest, unsigned int off, unsigned int len);
// s3b_dcache_record_block
// file dcache.h line 53
extern signed int s3b_dcache_record_block(struct s3b_dcache *priv, unsigned int dslot, unsigned int block_num, const unsigned char *md5);
// s3b_dcache_resize_file
// file dcache.c line 480
static signed int s3b_dcache_resize_file(struct s3b_dcache *priv, struct file_header *old_header);
// s3b_dcache_size
// file dcache.c line 279
extern unsigned int s3b_dcache_size(struct s3b_dcache *priv);
// s3b_dcache_write
// file dcache.c line 816
static signed int s3b_dcache_write(struct s3b_dcache *priv, signed long int offset, const void *data, unsigned long int len);
// s3b_dcache_write2
// file dcache.c line 822
static signed int s3b_dcache_write2(struct s3b_dcache *priv, signed int fd, const char *filename, signed long int offset, const void *data, unsigned long int len);
// s3b_dcache_write_block
// file dcache.h line 57
extern signed int s3b_dcache_write_block(struct s3b_dcache *priv, unsigned int dslot, const void *src, unsigned int off, unsigned int len);
// s3b_dcache_write_entry
// file dcache.c line 469
static signed int s3b_dcache_write_entry(struct s3b_dcache *priv, unsigned int dslot, struct dir_entry *entry);
// s3b_hash_create
// file hash.h line 54
extern signed int s3b_hash_create(struct s3b_hash **hashp, unsigned int maxkeys);
// s3b_hash_destroy
// file hash.h line 55
extern void s3b_hash_destroy(struct s3b_hash *hash);
// s3b_hash_foreach
// file hash.h line 61
extern void s3b_hash_foreach(struct s3b_hash *hash, void (*visitor)(void *, void *), void *arg);
// s3b_hash_foreach::visitor$object
//
void visitor$object(void *, void *);
// s3b_hash_get
// file hash.h line 57
extern void * s3b_hash_get(struct s3b_hash *hash, unsigned int key);
// s3b_hash_index
// file hash.c line 206
static unsigned int s3b_hash_index(struct s3b_hash *hash, unsigned int key);
// s3b_hash_put
// file hash.h line 58
extern void * s3b_hash_put(struct s3b_hash *hash, void *value);
// s3b_hash_put_new
// file hash.h line 59
extern void s3b_hash_put_new(struct s3b_hash *hash, void *value);
// s3b_hash_remove
// file hash.h line 60
extern void s3b_hash_remove(struct s3b_hash *hash, unsigned int key);
// s3b_hash_size
// file hash.h line 56
extern unsigned int s3b_hash_size(struct s3b_hash *hash);
// s3backer_create_store
// file s3b_config.h line 74
extern struct s3backer_store * s3backer_create_store(struct s3b_config *conf);
// s3backer_erase
// file erase.c line 69
extern signed int s3backer_erase(struct s3b_config *config);
// s3backer_get_config
// file s3b_config.h line 73
extern struct s3b_config * s3backer_get_config(signed int argc, char **argv);
// s3backer_reset
// file reset.c line 47
extern signed int s3backer_reset(struct s3b_config *config);
// search_access_for
// file s3b_config.c line 859
static signed int search_access_for(const char *file, const char *accessId, char **idptr, char **pwptr);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// srandom
// file /usr/include/stdlib.h line 324
extern void srandom(unsigned int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 216
extern signed int stat(const char *, struct stat *);
// stderr_logger
// file s3b_config.c line 1590
static void stderr_logger(signed int level, const char *fmt, ...);
// strcasecmp
// file /usr/include/string.h line 533
extern signed int strcasecmp(const char *, const char *);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/string.h line 537
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strtok_r
// file /usr/include/string.h line 358
extern char * strtok_r(char *, const char *, char ** restrict );
// syslog_logger
// file s3b_config.c line 1575
static void syslog_logger(signed int level, const char *fmt, ...);
// test_io_create
// file test_io.h line 38
extern struct s3backer_store * test_io_create(struct http_io_conf *config);
// test_io_destroy
// file test_io.c line 123
static void test_io_destroy(struct s3backer_store * const s3b);
// test_io_flush
// file test_io.c line 117
static signed int test_io_flush(struct s3backer_store * const s3b);
// test_io_list_blocks
// file test_io.c line 345
static signed int test_io_list_blocks(struct s3backer_store *s3b, void (*callback)(void *, unsigned int), void *arg);
// test_io_list_blocks::callback$object
//
void callback$object(void *, unsigned int);
// test_io_meta_data
// file test_io.c line 103
static signed int test_io_meta_data(struct s3backer_store *s3b, signed long int *file_sizep, unsigned int *block_sizep);
// test_io_read_block
// file test_io.c line 132
static signed int test_io_read_block(struct s3backer_store * const s3b, unsigned int block_num, void *dest, unsigned char *actual_md5, const unsigned char *expect_md5, signed int strict);
// test_io_read_block_part
// file test_io.c line 327
static signed int test_io_read_block_part(struct s3backer_store *s3b, unsigned int block_num, unsigned int off, unsigned int len, void *dest);
// test_io_set_mounted
// file test_io.c line 109
static signed int test_io_set_mounted(struct s3backer_store *s3b, signed int *old_valuep, signed int new_value);
// test_io_write_block
// file test_io.c line 235
static signed int test_io_write_block(struct s3backer_store * const s3b, unsigned int block_num, const void *src, unsigned char *caller_md5, signed int (*check_cancel)(void *, unsigned int), void *check_cancel_arg);
// test_io_write_block::check_cancel$object
//
signed int check_cancel$object(void *, unsigned int);
// test_io_write_block_part
// file test_io.c line 336
static signed int test_io_write_block_part(struct s3backer_store *s3b, unsigned int block_num, unsigned int off, unsigned int len, const void *src);
// thread_main
// file tester.c line 118
static void * thread_main(void *arg);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// toupper
// file /usr/include/ctype.h line 127
extern signed int toupper(signed int);
// uncompress
// file /usr/include/zlib.h line 1197
extern signed int uncompress(unsigned char *, unsigned long int *, const unsigned char *, unsigned long int);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// unparse_size_string
// file s3b_config.c line 783
static void unparse_size_string(char *buf, unsigned long int bmax, unsigned long int value);
// update_hmac_from_header
// file http_io.c line 2597
static void update_hmac_from_header(struct hmac_ctx_st * const ctx, struct http_io * const io, const char *name, signed int value_only, char *sigbuf, unsigned long int sigbuflen);
// update_iam_credentials
// file http_io.c line 898
static signed int update_iam_credentials(struct http_io_private * const priv);
// update_iam_credentials_main
// file http_io.c line 959
static void * update_iam_credentials_main(void *arg);
// usage
// file s3b_config.c line 1635
static void usage(void);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// validate_config
// file s3b_config.c line 892
static signed int validate_config(void);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// vsyslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 200
extern void vsyslog(signed int, const char *, void **);
// warn
// file /usr/include/err.h line 34
extern void warn(const char *, ...);
// warnx
// file /usr/include/err.h line 40
extern void warnx(const char *, ...);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);

struct anonymous$7
{
  // tqe_next
  struct block_info *tqe_next;
  // tqe_prev
  struct block_info **tqe_prev;
};

struct anonymous$9
{
  // tqh_first
  struct block_info *tqh_first;
  // tqh_last
  struct block_info **tqh_last;
};

struct anonymous$1
{
  // tqe_next
  struct cache_entry *tqe_next;
  // tqe_prev
  struct cache_entry **tqe_prev;
};

struct anonymous
{
  // tqh_first
  struct cache_entry *tqh_first;
  // tqh_last
  struct cache_entry **tqh_last;
};

struct anonymous$6
{
  // le_next
  struct curl_holder *le_next;
  // le_prev
  struct curl_holder **le_prev;
};

struct anonymous$11
{
  // lh_first
  struct curl_holder *lh_first;
};

struct anonymous$3
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous$10
{
  // rm_so
  signed int rm_so;
  // rm_eo
  signed int rm_eo;
};

union anonymous$13
{
  // ptr
  char *ptr;
  // boolean
  signed int boolean;
  // asn1_string
  struct asn1_string_st *asn1_string;
  // object
  struct asn1_object_st *object;
  // integer
  struct asn1_string_st *integer;
  // enumerated
  struct asn1_string_st *enumerated;
  // bit_string
  struct asn1_string_st *bit_string;
  // octet_string
  struct asn1_string_st *octet_string;
  // printablestring
  struct asn1_string_st *printablestring;
  // t61string
  struct asn1_string_st *t61string;
  // ia5string
  struct asn1_string_st *ia5string;
  // generalstring
  struct asn1_string_st *generalstring;
  // bmpstring
  struct asn1_string_st *bmpstring;
  // universalstring
  struct asn1_string_st *universalstring;
  // utctime
  struct asn1_string_st *utctime;
  // generalizedtime
  struct asn1_string_st *generalizedtime;
  // visiblestring
  struct asn1_string_st *visiblestring;
  // utf8string
  struct asn1_string_st *utf8string;
  // set
  struct asn1_string_st *set;
  // sequence
  struct asn1_string_st *sequence;
  // asn1_value
  struct ASN1_VALUE_st *asn1_value;
};

union anonymous$2
{
  // data
  void *data;
  // dslot
  unsigned int dslot;
};

union anonymous$8
{
  // data
  const void *data;
  // md5
  unsigned char md5[16l];
};

union anonymous$15
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous$0
{
  // __data
  struct anonymous$3 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous$5
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct MD5state_st
{
  // A
  unsigned int A;
  // B
  unsigned int B;
  // C
  unsigned int C;
  // D
  unsigned int D;
  // Nl
  unsigned int Nl;
  // Nh
  unsigned int Nh;
  // data
  unsigned int data[16l];
  // num
  unsigned int num;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct asn1_object_st
{
  // sn
  const char *sn;
  // ln
  const char *ln;
  // nid
  signed int nid;
  // length
  signed int length;
  // data
  const unsigned char *data;
  // flags
  signed int flags;
};

struct asn1_string_st
{
  // length
  signed int length;
  // type
  signed int type;
  // data
  unsigned char *data;
  // flags
  signed long int flags;
};

struct asn1_type_st
{
  // type
  signed int type;
  // value
  union anonymous$13 value;
};

struct bio_method_st
{
  // type
  signed int type;
  // name
  const char *name;
  // bwrite
  signed int (*bwrite)(struct bio_st *, const char *, signed int);
  // bread
  signed int (*bread)(struct bio_st *, char *, signed int);
  // bputs
  signed int (*bputs)(struct bio_st *, const char *);
  // bgets
  signed int (*bgets)(struct bio_st *, char *, signed int);
  // ctrl
  signed long int (*ctrl)(struct bio_st *, signed int, signed long int, void *);
  // create
  signed int (*create)(struct bio_st *);
  // destroy
  signed int (*destroy)(struct bio_st *);
  // callback_ctrl
  signed long int (*callback_ctrl)(struct bio_st *, signed int, void (*)(struct bio_st *, signed int, const char *, signed int, signed long int, signed long int));
};

struct crypto_ex_data_st
{
  // sk
  struct stack_st_void *sk;
  // dummy
  signed int dummy;
};

struct bio_st
{
  // method
  struct bio_method_st *method;
  // callback
  signed long int (*callback)(struct bio_st *, signed int, const char *, signed int, signed long int, signed long int);
  // cb_arg
  char *cb_arg;
  // init
  signed int init;
  // shutdown
  signed int shutdown;
  // flags
  signed int flags;
  // retry_reason
  signed int retry_reason;
  // num
  signed int num;
  // ptr
  void *ptr;
  // next_bio
  struct bio_st *next_bio;
  // prev_bio
  struct bio_st *prev_bio;
  // references
  signed int references;
  // num_read
  unsigned long int num_read;
  // num_write
  unsigned long int num_write;
  // ex_data
  struct crypto_ex_data_st ex_data;
};

struct block_cache_conf
{
  // block_size
  unsigned int block_size;
  // cache_size
  unsigned int cache_size;
  // write_delay
  unsigned int write_delay;
  // max_dirty
  unsigned int max_dirty;
  // synchronous
  unsigned int synchronous;
  // timeout
  unsigned int timeout;
  // num_threads
  unsigned int num_threads;
  // read_ahead
  unsigned int read_ahead;
  // read_ahead_trigger
  unsigned int read_ahead_trigger;
  // no_verify
  unsigned int no_verify;
  // cache_file
  const char *cache_file;
  // log
  void (*log)(signed int, const char *, ...);
};

struct block_cache_stats
{
  // initial_size
  unsigned int initial_size;
  // current_size
  unsigned int current_size;
  // dirty_ratio
  double dirty_ratio;
  // read_hits
  unsigned int read_hits;
  // read_misses
  unsigned int read_misses;
  // write_hits
  unsigned int write_hits;
  // write_misses
  unsigned int write_misses;
  // verified
  unsigned int verified;
  // mismatch
  unsigned int mismatch;
  // out_of_memory_errors
  unsigned int out_of_memory_errors;
};

struct block_cache_private
{
  // config
  struct block_cache_conf *config;
  // inner
  struct s3backer_store *inner;
  // stats
  struct block_cache_stats stats;
  // cleans
  struct anonymous cleans;
  // dirties
  struct anonymous dirties;
  // hashtable
  struct s3b_hash *hashtable;
  // dcache
  struct s3b_dcache *dcache;
  // num_cleans
  unsigned int num_cleans;
  // num_dirties
  unsigned int num_dirties;
  // start_time
  unsigned long int start_time;
  // clean_timeout
  unsigned int clean_timeout;
  // dirty_timeout
  unsigned int dirty_timeout;
  // max_dirty_ratio
  double max_dirty_ratio;
  // seq_last
  unsigned int seq_last;
  // seq_count
  unsigned int seq_count;
  // ra_count
  unsigned int ra_count;
  // thread_id
  unsigned int thread_id;
  // num_threads
  unsigned int num_threads;
  // stopping
  signed int stopping;
  // mutex
  union anonymous$5 mutex;
  // space_avail
  union anonymous$0 space_avail;
  // end_reading
  union anonymous$0 end_reading;
  // worker_work
  union anonymous$0 worker_work;
  // worker_exit
  union anonymous$0 worker_exit;
  // write_complete
  union anonymous$0 write_complete;
};

struct block_info
{
  // block_num
  unsigned int block_num;
  // timestamp
  unsigned long int timestamp;
  // link
  struct anonymous$7 link;
  // u
  union anonymous$8 u;
};

struct block_state
{
  // writing
  unsigned int writing;
  // counter
  unsigned int counter;
  // content
  unsigned int content;
};

struct buf_mem_st
{
  // length
  unsigned long int length;
  // data
  char *data;
  // max
  unsigned long int max;
};

struct cache_entry
{
  // block_num
  unsigned int block_num;
  // dirty
  unsigned int dirty : 1;
  // verify
  unsigned int verify : 1;
  // timeout
  unsigned int timeout : 30;
  // link
  struct anonymous$1 link;
  // u
  union anonymous$2 u;
  // md5
  unsigned char md5[0l];
};

struct cbinfo
{
  // callback
  void (*callback)(void *, unsigned int);
  // arg
  void *arg;
};

struct curl_holder
{
  // curl
  void *curl;
  // link
  struct anonymous$6 link;
};

struct curl_slist
{
  // data
  char *data;
  // next
  struct curl_slist *next;
};

struct dir_entry
{
  // block_num
  unsigned int block_num;
  // md5
  unsigned char md5[16l];
} __attribute__ ((__packed__));

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct ec_protect_conf
{
  // block_size
  unsigned int block_size;
  // min_write_delay
  unsigned int min_write_delay;
  // cache_time
  unsigned int cache_time;
  // cache_size
  unsigned int cache_size;
  // log
  void (*log)(signed int, const char *, ...);
};

struct ec_protect_stats
{
  // current_cache_size
  unsigned int current_cache_size;
  // cache_data_hits
  unsigned int cache_data_hits;
  // cache_full_delay
  unsigned long int cache_full_delay;
  // repeated_write_delay
  unsigned long int repeated_write_delay;
  // out_of_memory_errors
  unsigned int out_of_memory_errors;
};

struct ec_protect_private
{
  // config
  struct ec_protect_conf *config;
  // inner
  struct s3backer_store *inner;
  // stats
  struct ec_protect_stats stats;
  // hashtable
  struct s3b_hash *hashtable;
  // num_sleepers
  unsigned int num_sleepers;
  // list
  struct anonymous$9 list;
  // mutex
  union anonymous$5 mutex;
  // space_cond
  union anonymous$0 space_cond;
  // sleepers_cond
  union anonymous$0 sleepers_cond;
  // never_cond
  union anonymous$0 never_cond;
};

struct env_md_ctx_st
{
  // digest
  const struct env_md_st *digest;
  // engine
  struct engine_st *engine;
  // flags
  unsigned long int flags;
  // md_data
  void *md_data;
  // pctx
  struct evp_pkey_ctx_st *pctx;
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
};

struct env_md_st
{
  // type
  signed int type;
  // pkey_type
  signed int pkey_type;
  // md_size
  signed int md_size;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct env_md_ctx_st *);
  // update
  signed int (*update)(struct env_md_ctx_st *, const void *, unsigned long int);
  // final
  signed int (*final)(struct env_md_ctx_st *, unsigned char *);
  // copy
  signed int (*copy)(struct env_md_ctx_st *, const struct env_md_ctx_st *);
  // cleanup
  signed int (*cleanup)(struct env_md_ctx_st *);
  // sign
  signed int (*sign)(signed int, const unsigned char *, unsigned int, unsigned char *, unsigned int *, void *);
  // verify
  signed int (*verify)(signed int, const unsigned char *, unsigned int, const unsigned char *, unsigned int, void *);
  // required_pkey_type
  signed int required_pkey_type[5l];
  // block_size
  signed int block_size;
  // ctx_size
  signed int ctx_size;
  // md_ctrl
  signed int (*md_ctrl)(struct env_md_ctx_st *, signed int, signed int, void *);
};

struct erase_state
{
  // s3b
  struct s3backer_store *s3b;
  // queue
  unsigned int queue[1000l];
  // qlen
  unsigned int qlen;
  // threads
  unsigned long int threads[25l];
  // quiet
  signed int quiet;
  // stopping
  signed int stopping;
  // count
  unsigned long int count;
  // mutex
  union anonymous$5 mutex;
  // thread_wakeup
  union anonymous$0 thread_wakeup;
  // queue_not_full
  union anonymous$0 queue_not_full;
};

struct evp_cipher_ctx_st
{
  // cipher
  const struct evp_cipher_st *cipher;
  // engine
  struct engine_st *engine;
  // encrypt
  signed int encrypt;
  // buf_len
  signed int buf_len;
  // oiv
  unsigned char oiv[16l];
  // iv
  unsigned char iv[16l];
  // buf
  unsigned char buf[32l];
  // num
  signed int num;
  // app_data
  void *app_data;
  // key_len
  signed int key_len;
  // flags
  unsigned long int flags;
  // cipher_data
  void *cipher_data;
  // final_used
  signed int final_used;
  // block_mask
  signed int block_mask;
  // final
  unsigned char final[32l];
};

struct evp_cipher_st
{
  // nid
  signed int nid;
  // block_size
  signed int block_size;
  // key_len
  signed int key_len;
  // iv_len
  signed int iv_len;
  // flags
  unsigned long int flags;
  // init
  signed int (*init)(struct evp_cipher_ctx_st *, const unsigned char *, const unsigned char *, signed int);
  // do_cipher
  signed int (*do_cipher)(struct evp_cipher_ctx_st *, unsigned char *, const unsigned char *, unsigned long int);
  // cleanup
  signed int (*cleanup)(struct evp_cipher_ctx_st *);
  // ctx_size
  signed int ctx_size;
  // set_asn1_parameters
  signed int (*set_asn1_parameters)(struct evp_cipher_ctx_st *, struct asn1_type_st *);
  // get_asn1_parameters
  signed int (*get_asn1_parameters)(struct evp_cipher_ctx_st *, struct asn1_type_st *);
  // ctrl
  signed int (*ctrl)(struct evp_cipher_ctx_st *, signed int, signed int, void *);
  // app_data
  void *app_data;
};

struct file_header
{
  // signature
  unsigned int signature;
  // header_size
  unsigned int header_size;
  // u_int_size
  unsigned int u_int_size;
  // s3b_block_t_size
  unsigned int s3b_block_t_size;
  // block_size
  unsigned int block_size;
  // data_align
  unsigned int data_align;
  // zero
  unsigned int zero;
  // max_blocks
  unsigned int max_blocks;
} __attribute__ ((__packed__));

struct fuse_args
{
  // argc
  signed int argc;
  // argv
  char **argv;
  // allocated
  signed int allocated;
};

struct fuse_ops_conf
{
  // s3bconf
  struct s3b_config *s3bconf;
  // print_stats
  void (*print_stats)(void *, void (*)(void *, const char *, ...));
  // read_only
  signed int read_only;
  // direct_io
  signed int direct_io;
  // filename
  const char *filename;
  // stats_filename
  const char *stats_filename;
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
  // block_size
  unsigned int block_size;
  // num_blocks
  signed long int num_blocks;
  // file_mode
  signed int file_mode;
  // log
  void (*log)(signed int, const char *, ...);
};

struct fuse_opt
{
  // templ
  const char *templ;
  // offset
  unsigned long int offset;
  // value
  signed int value;
};

struct hmac_ctx_st
{
  // md
  const struct env_md_st *md;
  // md_ctx
  struct env_md_ctx_st md_ctx;
  // i_ctx
  struct env_md_ctx_st i_ctx;
  // o_ctx
  struct env_md_ctx_st o_ctx;
  // key_length
  unsigned int key_length;
  // key
  unsigned char key[128l];
};

struct http_io_bufs
{
  // rdremain
  unsigned long int rdremain;
  // wrremain
  unsigned long int wrremain;
  // rddata
  char *rddata;
  // wrdata
  const char *wrdata;
};

struct http_io
{
  // bufs
  struct http_io_bufs bufs;
  // xml
  struct XML_ParserStruct *xml;
  // xml_error
  signed int xml_error;
  // xml_error_line
  signed int xml_error_line;
  // xml_error_column
  signed int xml_error_column;
  // xml_path
  char *xml_path;
  // xml_text
  char *xml_text;
  // xml_text_len
  signed int xml_text_len;
  // xml_text_max
  signed int xml_text_max;
  // list_truncated
  signed int list_truncated;
  // last_block
  unsigned int last_block;
  // callback_func
  void (*callback_func)(void *, unsigned int);
  // callback_arg
  void *callback_arg;
  // config
  struct http_io_conf *config;
  // method
  const char *method;
  // url
  const char *url;
  // headers
  struct curl_slist *headers;
  // dest
  void *dest;
  // src
  const void *src;
  // block_num
  unsigned int block_num;
  // buf_size
  unsigned int buf_size;
  // content_lengthp
  unsigned int *content_lengthp;
  // file_size
  unsigned long int file_size;
  // block_size
  unsigned int block_size;
  // expect_304
  unsigned int expect_304;
  // md5
  unsigned char md5[16l];
  // hmac
  unsigned char hmac[20l];
  // content_encoding
  char content_encoding[32l];
  // check_cancel
  signed int (*check_cancel)(void *, unsigned int);
  // check_cancel_arg
  void *check_cancel_arg;
};

struct http_io_conf
{
  // accessId
  char *accessId;
  // accessKey
  char *accessKey;
  // iam_token
  char *iam_token;
  // accessType
  const char *accessType;
  // ec2iam_role
  const char *ec2iam_role;
  // authVersion
  const char *authVersion;
  // baseURL
  const char *baseURL;
  // region
  const char *region;
  // bucket
  const char *bucket;
  // prefix
  const char *prefix;
  // user_agent
  const char *user_agent;
  // cacert
  const char *cacert;
  // password
  const char *password;
  // encryption
  const char *encryption;
  // key_length
  unsigned int key_length;
  // debug
  signed int debug;
  // debug_http
  signed int debug_http;
  // quiet
  signed int quiet;
  // rrs
  signed int rrs;
  // compress
  signed int compress;
  // vhost
  signed int vhost;
  // nonzero_bitmap
  unsigned int *nonzero_bitmap;
  // insecure
  signed int insecure;
  // block_size
  unsigned int block_size;
  // num_blocks
  signed long int num_blocks;
  // timeout
  unsigned int timeout;
  // initial_retry_pause
  unsigned int initial_retry_pause;
  // max_retry_pause
  unsigned int max_retry_pause;
  // max_speed
  unsigned long int max_speed[2l];
  // log
  void (*log)(signed int, const char *, ...);
};

struct http_io_evst
{
  // count
  unsigned int count;
  // time
  double time;
};

struct http_io_stats
{
  // normal_blocks_read
  unsigned int normal_blocks_read;
  // normal_blocks_written
  unsigned int normal_blocks_written;
  // zero_blocks_read
  unsigned int zero_blocks_read;
  // zero_blocks_written
  unsigned int zero_blocks_written;
  // empty_blocks_read
  unsigned int empty_blocks_read;
  // empty_blocks_written
  unsigned int empty_blocks_written;
  // http_heads
  struct http_io_evst http_heads;
  // http_gets
  struct http_io_evst http_gets;
  // http_puts
  struct http_io_evst http_puts;
  // http_deletes
  struct http_io_evst http_deletes;
  // http_unauthorized
  unsigned int http_unauthorized;
  // http_forbidden
  unsigned int http_forbidden;
  // http_stale
  unsigned int http_stale;
  // http_verified
  unsigned int http_verified;
  // http_mismatch
  unsigned int http_mismatch;
  // http_5xx_error
  unsigned int http_5xx_error;
  // http_4xx_error
  unsigned int http_4xx_error;
  // http_other_error
  unsigned int http_other_error;
  // http_canceled_writes
  unsigned int http_canceled_writes;
  // curl_handles_created
  unsigned int curl_handles_created;
  // curl_handles_reused
  unsigned int curl_handles_reused;
  // curl_timeouts
  unsigned int curl_timeouts;
  // curl_connect_failed
  unsigned int curl_connect_failed;
  // curl_host_unknown
  unsigned int curl_host_unknown;
  // curl_out_of_memory
  unsigned int curl_out_of_memory;
  // curl_other_error
  unsigned int curl_other_error;
  // num_retries
  unsigned int num_retries;
  // retry_delay
  unsigned long int retry_delay;
  // out_of_memory_errors
  unsigned int out_of_memory_errors;
};

struct http_io_private
{
  // config
  struct http_io_conf *config;
  // stats
  struct http_io_stats stats;
  // curls
  struct anonymous$11 curls;
  // mutex
  union anonymous$5 mutex;
  // non_zero
  unsigned int *non_zero;
  // iam_thread
  unsigned long int iam_thread;
  // shutting_down
  unsigned char shutting_down;
  // cipher
  const struct evp_cipher_st *cipher;
  // keylen
  unsigned int keylen;
  // key
  unsigned char key[64l];
  // ivkey
  unsigned char ivkey[64l];
};

struct list_blocks
{
  // bitmap
  unsigned int *bitmap;
  // print_dots
  signed int print_dots;
  // count
  unsigned long int count;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct re_pattern_buffer
{
  // buffer
  unsigned char *buffer;
  // allocated
  unsigned long int allocated;
  // used
  unsigned long int used;
  // syntax
  unsigned long int syntax;
  // fastmap
  char *fastmap;
  // translate
  unsigned char *translate;
  // re_nsub
  unsigned long int re_nsub;
  // can_be_null
  unsigned int can_be_null : 1;
  // regs_allocated
  unsigned int regs_allocated : 2;
  // fastmap_accurate
  unsigned int fastmap_accurate : 1;
  // no_sub
  unsigned int no_sub : 1;
  // not_bol
  unsigned int not_bol : 1;
  // not_eol
  unsigned int not_eol : 1;
  // newline_anchor
  unsigned int newline_anchor : 1;
};

struct s3b_config
{
  // block_cache
  struct block_cache_conf block_cache;
  // fuse_ops
  struct fuse_ops_conf fuse_ops;
  // ec_protect
  struct ec_protect_conf ec_protect;
  // http_io
  struct http_io_conf http_io;
  // accessFile
  const char *accessFile;
  // mount
  const char *mount;
  // description
  char description[768l];
  // block_size
  unsigned int block_size;
  // file_size
  signed long int file_size;
  // num_blocks
  signed long int num_blocks;
  // debug
  signed int debug;
  // erase
  signed int erase;
  // reset
  signed int reset;
  // quiet
  signed int quiet;
  // force
  signed int force;
  // test
  signed int test;
  // ssl
  signed int ssl;
  // no_auto_detect
  signed int no_auto_detect;
  // list_blocks
  signed int list_blocks;
  // fuse_args
  struct fuse_args fuse_args;
  // log
  void (*log)(signed int, const char *, ...);
  // file_size_str
  const char *file_size_str;
  // block_size_str
  const char *block_size_str;
  // password_file
  const char *password_file;
  // max_speed_str
  const char *max_speed_str[2l];
  // encrypt
  signed int encrypt;
};

struct s3b_dcache
{
  // fd
  signed int fd;
  // log
  void (*log)(signed int, const char *, ...);
  // filename
  char *filename;
  // zero_block
  void *zero_block;
  // block_size
  unsigned int block_size;
  // max_blocks
  unsigned int max_blocks;
  // num_alloc
  unsigned int num_alloc;
  // data
  signed long int data;
  // free_list_len
  unsigned int free_list_len;
  // free_list_alloc
  unsigned int free_list_alloc;
  // free_list
  unsigned int *free_list;
};

struct s3b_hash
{
  // maxkeys
  unsigned int maxkeys;
  // numkeys
  unsigned int numkeys;
  // alen
  unsigned int alen;
  // array
  void *array[0l];
};

struct s3backer_store
{
  // meta_data
  signed int (*meta_data)(struct s3backer_store *, signed long int *, unsigned int *);
  // set_mounted
  signed int (*set_mounted)(struct s3backer_store *, signed int *, signed int);
  // read_block
  signed int (*read_block)(struct s3backer_store *, unsigned int, void *, unsigned char *, const unsigned char *, signed int);
  // read_block_part
  signed int (*read_block_part)(struct s3backer_store *, unsigned int, unsigned int, unsigned int, void *);
  // write_block
  signed int (*write_block)(struct s3backer_store *, unsigned int, const void *, unsigned char *, signed int (*)(void *, unsigned int), void *);
  // write_block_part
  signed int (*write_block_part)(struct s3backer_store *, unsigned int, unsigned int, unsigned int, const void *);
  // list_blocks
  signed int (*list_blocks)(struct s3backer_store *, void (*)(void *, unsigned int), void *);
  // flush
  signed int (*flush)(struct s3backer_store *);
  // destroy
  void (*destroy)(struct s3backer_store *);
  // data
  void *data;
};

struct size_suffix
{
  // suffix
  const char *suffix;
  // bits
  signed int bits;
};

struct stack_st
{
  // num
  signed int num;
  // data
  char **data;
  // sorted
  signed int sorted;
  // num_alloc
  signed int num_alloc;
  // comp
  signed int (*comp)(const void *, const void *);
};

struct stack_st_void
{
  // stack
  struct stack_st stack;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct test_io_private
{
  // config
  struct http_io_conf *config;
  // zero_block
  unsigned char zero_block[0l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};


// block_cache_store
// file s3b_config.c line 507
struct s3backer_store *block_cache_store;
// blocks
// file tester.c line 68
static struct block_state *blocks;
// config
// file tester.c line 66
static struct s3b_config *config;
// config$link1
// file s3b_config.c line 143
static struct s3b_config config$link1;
// user_agent_buf
// file s3b_config.c line 142
static char user_agent_buf[64l];
// config$link1
// file s3b_config.c line 143
static struct s3b_config config$link1 = { .block_cache={ .block_size=0u, .cache_size=(unsigned int)1000, .write_delay=(unsigned int)250,
    .max_dirty=(unsigned int)0, .synchronous=0u,
    .timeout=(unsigned int)0, .num_threads=(unsigned int)20,
    .read_ahead=(unsigned int)4, .read_ahead_trigger=(unsigned int)2,
    .no_verify=0u,
    .cache_file=((const char *)NULL), .log=((void (*)(signed int, const char *, ...))NULL) }, .fuse_ops={ .s3bconf=((struct s3b_config *)NULL), .print_stats=((void (*)(void *, void (*)(void *, const char *, ...)))NULL), .read_only=0,
    .direct_io=0, .filename="file", .stats_filename="stats",
    .uid=0u, .gid=0u, .block_size=0u,
    .num_blocks=0l, .file_mode=-1, .log=((void (*)(signed int, const char *, ...))NULL) },
    .ec_protect={ .block_size=0u, .min_write_delay=(unsigned int)500, .cache_time=(unsigned int)10000,
    .cache_size=(unsigned int)10000, .log=((void (*)(signed int, const char *, ...))NULL) },
    .http_io={ .accessId=(char *)(void *)0, .accessKey=(char *)(void *)0, .iam_token=((char *)NULL),
    .accessType="private", .ec2iam_role=((const char *)NULL),
    .authVersion="aws4", .baseURL=(const char *)(void *)0,
    .region=(const char *)(void *)0, .bucket=(const char *)(void *)0,
    .prefix="", .user_agent=user_agent_buf,
    .cacert=((const char *)NULL), .password=((const char *)NULL),
    .encryption=((const char *)NULL), .key_length=0u,
    .debug=0, .debug_http=0, .quiet=0,
    .rrs=0, .compress=0, .vhost=0, .nonzero_bitmap=((unsigned int *)NULL),
    .insecure=0,
    .block_size=0u, .num_blocks=0l, .timeout=(unsigned int)30,
    .initial_retry_pause=(unsigned int)200, .max_retry_pause=(unsigned int)30000,
    .max_speed={ 0ul, 0ul },
    .log=((void (*)(signed int, const char *, ...))NULL) },
    .accessFile=((const char *)NULL),
    .mount=((const char *)NULL), .description={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .block_size=(unsigned int)0,
    .file_size=(signed long int)0, .num_blocks=0l,
    .debug=0, .erase=0, .reset=0, .quiet=0,
    .force=0, .test=0, .ssl=0, .no_auto_detect=0,
    .list_blocks=0, .fuse_args={ .argc=0, .argv=((char **)NULL), .allocated=0 }, .log=syslog_logger,
    .file_size_str=((const char *)NULL), .block_size_str=((const char *)NULL),
    .password_file=((const char *)NULL),
    .max_speed_str={ ((const char *)NULL), ((const char *)NULL) },
    .encrypt=0 };
// ec_protect_store
// file s3b_config.c line 508
struct s3backer_store *ec_protect_store;
// http_io_store
// file s3b_config.c line 509
struct s3backer_store *http_io_store;
// mutex
// file tester.c line 65
static union anonymous$5 mutex;
// num_openssl_locks
// file http_io.c line 275
static signed int num_openssl_locks;
// openssl_locks
// file http_io.c line 274
static union anonymous$5 *openssl_locks;
// option_list
// file s3b_config.c line 203
static struct fuse_opt option_list[55l] = { { .templ="--accessFile=%s", .offset=368ul, .value=0 },
    { .templ="--accessId=%s", .offset=160ul, .value=0 },
    { .templ="--accessKey=%s", .offset=168ul, .value=0 },
    { .templ="--accessType=%s", .offset=184ul, .value=0 },
    { .templ="--accessEC2IAM=%s", .offset=192ul, .value=0 },
    { .templ="--authVersion=%s", .offset=200ul, .value=0 },
    { .templ="--listBlocks", .offset=1208ul, .value=1 },
    { .templ="--baseURL=%s", .offset=208ul, .value=0 },
    { .templ="--region=%s", .offset=216ul, .value=0 },
    { .templ="--blockCacheSize=%u", .offset=4ul, .value=0 },
    { .templ="--blockCacheSync", .offset=16ul, .value=1 },
    { .templ="--blockCacheThreads=%u", .offset=24ul, .value=0 },
    { .templ="--blockCacheTimeout=%u", .offset=20ul, .value=0 },
    { .templ="--blockCacheWriteDelay=%u", .offset=8ul, .value=0 },
    { .templ="--blockCacheMaxDirty=%u", .offset=12ul, .value=0 },
    { .templ="--readAhead=%u", .offset=28ul, .value=0 },
    { .templ="--readAheadTrigger=%u", .offset=32ul, .value=0 },
    { .templ="--blockCacheFile=%s", .offset=40ul, .value=0 },
    { .templ="--blockCacheNoVerify", .offset=36ul, .value=1 },
    { .templ="--blockSize=%s", .offset=1256ul, .value=0 },
    { .templ="--maxUploadSpeed=%s", .offset=1280ul, .value=0 },
    { .templ="--maxDownloadSpeed=%s", .offset=1272ul, .value=0 },
    { .templ="--md5CacheSize=%u", .offset=148ul, .value=0 },
    { .templ="--md5CacheTime=%u", .offset=144ul, .value=0 },
    { .templ="--debug", .offset=1176ul, .value=1 },
    { .templ="--debug-http", .offset=280ul, .value=1 },
    { .templ="--quiet", .offset=1188ul, .value=1 },
    { .templ="--erase", .offset=1180ul, .value=1 },
    { .templ="--reset-mounted-flag", .offset=1184ul, .value=1 },
    { .templ="--vhost", .offset=296ul, .value=1 },
    { .templ="--fileMode=%o", .offset=120ul, .value=0 },
    { .templ="--filename=%s", .offset=80ul, .value=0 },
    { .templ="--force", .offset=1192ul, .value=1 },
    { .templ="--noAutoDetect", .offset=1204ul, .value=1 },
    { .templ="--initialRetryPause=%u", .offset=332ul, .value=0 },
    { .templ="--maxRetryPause=%u", .offset=336ul, .value=0 },
    { .templ="--minWriteDelay=%u", .offset=140ul, .value=0 },
    { .templ="--prefix=%s", .offset=232ul, .value=0 },
    { .templ="--readOnly", .offset=72ul, .value=1 },
    { .templ="--size=%s", .offset=1248ul, .value=0 },
    { .templ="--statsFilename=%s", .offset=88ul, .value=0 },
    { .templ="--rrs", .offset=288ul, .value=1 },
    { .templ="--ssl", .offset=1200ul, .value=1 },
    { .templ="--cacert=%s", .offset=248ul, .value=0 },
    { .templ="--insecure", .offset=312ul, .value=1 },
    { .templ="--compress", .offset=292ul, .value=-1 },
    { .templ="--compress=%d", .offset=292ul, .value=0 },
    { .templ="--encrypt", .offset=1288ul, .value=1 },
    { .templ="--encrypt=%s", .offset=264ul, .value=0 },
    { .templ="--keyLength=%u", .offset=272ul, .value=0 },
    { .templ="--password=%s", .offset=256ul, .value=0 },
    { .templ="--passwordFile=%s", .offset=1264ul, .value=0 },
    { .templ="--test", .offset=1196ul, .value=1 },
    { .templ="--timeout=%u", .offset=328ul, .value=0 },
    { .templ="--directIO", .offset=76ul, .value=1 } };
// s3_acls
// file s3b_config.c line 128
static const char * const s3_acls[4l] = { "private", "public-read", "public-read-write", "authenticated-read" };
// s3_auth_types
// file s3b_config.c line 136
static const char * const s3_auth_types[2l] = { "aws2", "aws4" };
// s3backer_fuse_defaults
// file s3b_config.c line 446
static const char * const s3backer_fuse_defaults[11l] = { "-okernel_cache", "-oallow_other", "-ouse_ino", "-omax_readahead=0", "-osubtype=s3backer", "-oentry_timeout=31536000", "-onegative_timeout=31536000", "-oattr_timeout=0", "-odefault_permissions", "-onodev", "-onosuid" };
// s3backer_version
// file gitrev.c line 1
const char * const s3backer_version = "";
// size_suffixes
// file s3b_config.c line 471
static struct size_suffix size_suffixes[8l] = { { .suffix="k", .bits=10 }, { .suffix="m", .bits=20 }, { .suffix="g", .bits=30 }, { .suffix="t", .bits=40 }, { .suffix="p", .bits=50 }, { .suffix="e", .bits=60 }, { .suffix="z", .bits=70 }, { .suffix="y", .bits=80 } };
// start_time
// file tester.c line 69
static unsigned long int start_time;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdin
// file /usr/include/stdio.h line 168
extern struct _IO_FILE *stdin;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// store
// file tester.c line 67
static struct s3backer_store *store;
// test_io_store
// file s3b_config.c line 510
struct s3backer_store *test_io_store;
// upload_download_names
// file s3b_config.c line 125
static const char * const upload_download_names[2l] = { "download", "upload" };
// zero_block
// file tester.c line 64
static void *zero_block;
// zero_entry
// file dcache.c line 120
static struct dir_entry zero_entry;
// zero_hmac
// file http_io.c line 277
static unsigned char zero_hmac[20l];
// zero_md5
// file ec_protect.c line 158
static const unsigned char zero_md5[16l];
// zero_md5$link1
// file http_io.c line 276
static unsigned char zero_md5$link1[16l];

// _curl_easy_getinfo_err_curl_slist
// file /usr/include/curl/typecheck-gcc.h line 201
static void _curl_easy_getinfo_err_curl_slist(void)
{
  asm("");
}

// _curl_easy_getinfo_err_double
// file /usr/include/curl/typecheck-gcc.h line 199
static void _curl_easy_getinfo_err_double(void)
{
  asm("");
}

// _curl_easy_getinfo_err_long
// file /usr/include/curl/typecheck-gcc.h line 197
static void _curl_easy_getinfo_err_long(void)
{
  asm("");
}

// _curl_easy_getinfo_err_string
// file /usr/include/curl/typecheck-gcc.h line 195
static void _curl_easy_getinfo_err_string(void)
{
  asm("");
}

// _curl_easy_setopt_err_CURLSH
// file /usr/include/curl/typecheck-gcc.h line 192
static void _curl_easy_setopt_err_CURLSH(void)
{
  asm("");
}

// _curl_easy_setopt_err_FILE
// file /usr/include/curl/typecheck-gcc.h line 184
static void _curl_easy_setopt_err_FILE(void)
{
  asm("");
}

// _curl_easy_setopt_err_cb_data
// file /usr/include/curl/typecheck-gcc.h line 178
static void _curl_easy_setopt_err_cb_data(void)
{
  asm("");
}

// _curl_easy_setopt_err_conv_cb
// file /usr/include/curl/typecheck-gcc.h line 174
static void _curl_easy_setopt_err_conv_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_curl_httpost
// file /usr/include/curl/typecheck-gcc.h line 188
static void _curl_easy_setopt_err_curl_httpost(void)
{
  asm("");
}

// _curl_easy_setopt_err_curl_off_t
// file /usr/include/curl/typecheck-gcc.h line 150
static void _curl_easy_setopt_err_curl_off_t(void)
{
  asm("");
}

// _curl_easy_setopt_err_curl_slist
// file /usr/include/curl/typecheck-gcc.h line 190
static void _curl_easy_setopt_err_curl_slist(void)
{
  asm("");
}

// _curl_easy_setopt_err_debug_cb
// file /usr/include/curl/typecheck-gcc.h line 170
static void _curl_easy_setopt_err_debug_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_error_buffer
// file /usr/include/curl/typecheck-gcc.h line 181
static void _curl_easy_setopt_err_error_buffer(void)
{
  asm("");
}

// _curl_easy_setopt_err_ioctl_cb
// file /usr/include/curl/typecheck-gcc.h line 160
static void _curl_easy_setopt_err_ioctl_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_long
// file /usr/include/curl/typecheck-gcc.h line 148
static void _curl_easy_setopt_err_long(void)
{
  asm("");
}

// _curl_easy_setopt_err_opensocket_cb
// file /usr/include/curl/typecheck-gcc.h line 164
static void _curl_easy_setopt_err_opensocket_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_postfields
// file /usr/include/curl/typecheck-gcc.h line 186
static void _curl_easy_setopt_err_postfields(void)
{
  asm("");
}

// _curl_easy_setopt_err_progress_cb
// file /usr/include/curl/typecheck-gcc.h line 168
static void _curl_easy_setopt_err_progress_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_read_cb
// file /usr/include/curl/typecheck-gcc.h line 158
static void _curl_easy_setopt_err_read_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_seek_cb
// file /usr/include/curl/typecheck-gcc.h line 176
static void _curl_easy_setopt_err_seek_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_sockopt_cb
// file /usr/include/curl/typecheck-gcc.h line 162
static void _curl_easy_setopt_err_sockopt_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_ssl_ctx_cb
// file /usr/include/curl/typecheck-gcc.h line 172
static void _curl_easy_setopt_err_ssl_ctx_cb(void)
{
  asm("");
}

// _curl_easy_setopt_err_string
// file /usr/include/curl/typecheck-gcc.h line 152
static void _curl_easy_setopt_err_string(void)
{
  asm("");
}

// _curl_easy_setopt_err_write_callback
// file /usr/include/curl/typecheck-gcc.h line 156
static void _curl_easy_setopt_err_write_callback(void)
{
  asm("");
}

// block_cache_check_cancel
// file block_cache.c line 1157
static signed int block_cache_check_cancel(void *arg, unsigned int block_num)
{
  struct block_cache_private * const priv = (struct block_cache_private *)arg;
  struct cache_entry *entry;
  signed int r;
  pthread_mutex_lock(&priv->mutex);

__CPROVER_DUMP_L1:
  ;
  void *return_value_s3b_hash_get$1;
  return_value_s3b_hash_get$1=s3b_hash_get(priv->hashtable, block_num);
  entry = (struct cache_entry *)return_value_s3b_hash_get$1;
  r = (signed int)entry->dirty;
  pthread_mutex_unlock(&priv->mutex);
  return r;
}

// block_cache_create
// file block_cache.c line 232
extern struct s3backer_store * block_cache_create(struct block_cache_conf *config, struct s3backer_store *inner)
{
  struct s3backer_store *s3b;
  struct block_cache_private *priv;
  struct cache_entry *entry;
  unsigned long int thread;
  signed int r;
  void *return_value_calloc$3;
  return_value_calloc$3=calloc((unsigned long int)1, sizeof(struct s3backer_store) /*80ul*/ );
  s3b = (struct s3backer_store *)return_value_calloc$3;
  if(s3b == ((struct s3backer_store *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    r = *return_value___errno_location$1;
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(r);
    config->log(3, "calloc(): %s", return_value_strerror$2);
  }

  s3b->meta_data = block_cache_meta_data;
  s3b->set_mounted = block_cache_set_mounted;
  s3b->read_block = block_cache_read_block;
  s3b->write_block = block_cache_write_block;
  s3b->read_block_part = block_cache_read_block_part;
  s3b->write_block_part = block_cache_write_block_part;
  s3b->list_blocks = block_cache_list_blocks;
  s3b->flush = block_cache_flush;
  s3b->destroy = block_cache_destroy;
  void *return_value_calloc$6;
  return_value_calloc$6=calloc((unsigned long int)1, sizeof(struct block_cache_private) /*448ul*/ );
  priv = (struct block_cache_private *)return_value_calloc$6;
  if(priv == ((struct block_cache_private *)NULL))
  {
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    r = *return_value___errno_location$4;
    char *return_value_strerror$5;
    return_value_strerror$5=strerror(r);
    config->log(3, "calloc(): %s", return_value_strerror$5);
  }

  priv->config = config;
  priv->inner = inner;
  priv->start_time=block_cache_get_time_millis();
  priv->clean_timeout = ((config->timeout + (unsigned int)64) - (unsigned int)1) / (unsigned int)64;
  priv->dirty_timeout = ((config->write_delay + (unsigned int)64) - (unsigned int)1) / (unsigned int)64;
  r=pthread_mutex_init(&priv->mutex, (const union anonymous$15 *)(void *)0);
  unsigned int tmp_if_expr$7;
  if(r == 0)
  {
    r=pthread_cond_init(&priv->space_avail, (const union anonymous$15 *)(void *)0);
    if(r == 0)
    {
      r=pthread_cond_init(&priv->end_reading, (const union anonymous$15 *)(void *)0);
      if(r == 0)
      {
        r=pthread_cond_init(&priv->worker_work, (const union anonymous$15 *)(void *)0);
        if(r == 0)
        {
          r=pthread_cond_init(&priv->worker_exit, (const union anonymous$15 *)(void *)0);
          if(r == 0)
          {
            r=pthread_cond_init(&priv->write_complete, (const union anonymous$15 *)(void *)0);
            if(r == 0)
            {
              do
              {
                (&priv->cleans)->tqh_first = (struct cache_entry *)(void *)0;
                (&priv->cleans)->tqh_last = &(&priv->cleans)->tqh_first;
              }
              while((_Bool)0);
              do
              {
                (&priv->dirties)->tqh_first = (struct cache_entry *)(void *)0;
                (&priv->dirties)->tqh_last = &(&priv->dirties)->tqh_first;
              }
              while((_Bool)0);
              r=s3b_hash_create(&priv->hashtable, config->cache_size);
              if(r == 0)
              {
                s3b->data = (void *)priv;
                if(!(config->max_dirty == 0u))
                  tmp_if_expr$7 = config->max_dirty;

                else
                  tmp_if_expr$7 = config->cache_size;
                priv->max_dirty_ratio = (double)tmp_if_expr$7 / (double)config->cache_size;
                if(priv->max_dirty_ratio > 0.90)
                  priv->max_dirty_ratio = 0.90;

                if(!(config->cache_file == ((const char *)NULL)))
                {
                  r=s3b_dcache_open(&priv->dcache, config->log, config->cache_file, config->block_size, config->cache_size, block_cache_dcache_load, (void *)priv);
                  if(!(r == 0))
                    goto fail9;

                  priv->stats.initial_size = priv->num_cleans;
                }

                pthread_mutex_lock(&priv->mutex);

              __CPROVER_DUMP_L9:
                ;
                priv->num_threads = (unsigned int)0;
                for( ; !(priv->num_threads >= config->num_threads); priv->num_threads = priv->num_threads + 1u)
                {
                  r=pthread_create(&thread, (const union pthread_attr_t *)(void *)0, block_cache_worker_main, (void *)priv);
                  if(!(r == 0))
                    goto fail10;

                }
                pthread_mutex_unlock(&priv->mutex);
                return s3b;

              fail10:
                ;
                priv->stopping = 1;
                while(priv->num_threads >= 1u)
                {
                  pthread_cond_broadcast(&priv->worker_work);
                  pthread_cond_wait(&priv->worker_exit, &priv->mutex);
                }
                if(!(config->cache_file == ((const char *)NULL)))
                {
                  do
                  {
                    entry = (&priv->cleans)->tqh_first;
                    if(entry == ((struct cache_entry *)NULL))
                      break;

                    do
                    {
                      if(!(entry->link.tqe_next == ((struct cache_entry *)NULL)))
                        entry->link.tqe_next->link.tqe_prev = entry->link.tqe_prev;

                      else
                        (&priv->cleans)->tqh_last = entry->link.tqe_prev;
                      *entry->link.tqe_prev = entry->link.tqe_next;
                    }
                    while((_Bool)0);
                    free((void *)entry);
                  }
                  while((_Bool)1);
                  s3b_dcache_close(priv->dcache);
                }


              fail9:
                ;
                s3b_hash_destroy(priv->hashtable);
              }


            fail8:
              ;
              pthread_cond_destroy(&priv->write_complete);
            }


          fail7:
            ;
            pthread_cond_destroy(&priv->worker_exit);
          }


        fail6:
          ;
          pthread_cond_destroy(&priv->worker_work);
        }


      fail5:
        ;
        pthread_cond_destroy(&priv->end_reading);
      }


    fail4:
      ;
      pthread_cond_destroy(&priv->space_avail);
    }


  fail3:
    ;
    pthread_mutex_destroy(&priv->mutex);
  }


fail2:
  ;
  free((void *)priv);

fail1:
  ;
  free((void *)s3b);

fail0:
  ;
  char *return_value_strerror$8;
  return_value_strerror$8=strerror(r);
  config->log(3, "block_cache creation failed: %s", return_value_strerror$8);
  signed int *return_value___errno_location$9;
  return_value___errno_location$9=__errno_location();
  *return_value___errno_location$9 = r;
  return (struct s3backer_store *)(void *)0;
}

// block_cache_dcache_load
// file block_cache.c line 353
static signed int block_cache_dcache_load(void *arg, unsigned int dslot, unsigned int block_num, const unsigned char *md5)
{
  struct block_cache_private * const priv = (struct block_cache_private *)arg;
  struct block_cache_conf * const block_cache_dcache_load$$1$$config = priv->config;
  struct cache_entry *entry;
  signed int r;
  void *return_value_s3b_hash_get$1;
  return_value_s3b_hash_get$1=s3b_hash_get(priv->hashtable, block_num);
  entry = (struct cache_entry *)return_value_s3b_hash_get$1;
  if(!(entry == ((struct cache_entry *)NULL)))
  {
    block_cache_dcache_load$$1$$config->log(3, "corrupted cache file: block 0x%0*jx listed twice (in dslots %ju and %ju)", (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)block_num, (unsigned long int)entry->u.dslot, (unsigned long int)dslot);
    return 22;
  }

  else
  {
    void *return_value_calloc$4;
    return_value_calloc$4=calloc((unsigned long int)1, sizeof(struct cache_entry) /*32ul*/  + (unsigned long int)(!(block_cache_dcache_load$$1$$config->no_verify != 0u) ? 16 : 0));
    entry = (struct cache_entry *)return_value_calloc$4;
    if(entry == ((struct cache_entry *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      r = *return_value___errno_location$2;
      char *return_value_strerror$3;
      return_value_strerror$3=strerror(r);
      block_cache_dcache_load$$1$$config->log(3, "can't allocate block cache entry: %s", return_value_strerror$3);
      priv->stats.out_of_memory_errors = priv->stats.out_of_memory_errors + 1u;
      return r;
    }

    entry->block_num = block_num;
    entry->verify = (unsigned int)!(block_cache_dcache_load$$1$$config->no_verify != 0u);
    unsigned int return_value_block_cache_get_time$5;
    return_value_block_cache_get_time$5=block_cache_get_time(priv);
    entry->timeout = return_value_block_cache_get_time$5 + priv->clean_timeout;
    if(!(entry->verify == 0u))
      memcpy((void *)&entry->md5, (const void *)md5, (unsigned long int)16);

    entry->u.dslot = dslot;
    do
    {
      entry->link.tqe_next = (struct cache_entry *)(void *)0;
      entry->link.tqe_prev = (&priv->cleans)->tqh_last;
      *(&priv->cleans)->tqh_last = entry;
      (&priv->cleans)->tqh_last = &entry->link.tqe_next;
    }
    while((_Bool)0);
    priv->num_cleans = priv->num_cleans + 1u;
    s3b_hash_put_new(priv->hashtable, (void *)entry);
    return 0;
  }
}

// block_cache_destroy
// file block_cache.c line 429
static void block_cache_destroy(struct s3backer_store * const s3b)
{
  struct block_cache_private * const priv = (struct block_cache_private *)s3b->data;
  struct block_cache_conf * const block_cache_destroy$$1$$config = priv->config;
  pthread_mutex_lock(&priv->mutex);

__CPROVER_DUMP_L1:
  ;
  priv->stopping = 1;
  while((_Bool)1)
  {
    if(priv->dirties.tqh_first == ((struct cache_entry *)NULL))
    {
      if(!(priv->num_threads >= 1u))
        goto __CPROVER_DUMP_L4;

    }

    pthread_cond_broadcast(&priv->worker_work);
    pthread_cond_wait(&priv->worker_exit, &priv->mutex);
  }

__CPROVER_DUMP_L4:
  ;
  priv->inner->destroy(priv->inner);
  if(!(block_cache_destroy$$1$$config->cache_file == ((const char *)NULL)))
    s3b_dcache_close(priv->dcache);

  s3b_hash_foreach(priv->hashtable, block_cache_free_one, (void *)priv);
  s3b_hash_destroy(priv->hashtable);
  pthread_cond_destroy(&priv->write_complete);
  pthread_cond_destroy(&priv->worker_exit);
  pthread_cond_destroy(&priv->worker_work);
  pthread_cond_destroy(&priv->end_reading);
  pthread_cond_destroy(&priv->space_avail);
  pthread_mutex_destroy(&priv->mutex);
  free((void *)priv);
  free((void *)s3b);
}

// block_cache_dirty_callback
// file block_cache.c line 1333
static void block_cache_dirty_callback(void *arg, void *value)
{
  struct cbinfo * const cbinfo = (struct cbinfo *)arg;
  struct cache_entry * const entry = (struct cache_entry *)value;
  signed int tmp_if_expr$3;
  signed int tmp_if_expr$1;
  signed int tmp_if_expr$2;
  if(!(entry->link.tqe_prev == ((struct cache_entry **)NULL)))
  {
    if(!(entry->dirty == 0u))
      tmp_if_expr$1 = 2;

    else
      tmp_if_expr$1 = entry->verify != 0u ? 1 : 0;
    tmp_if_expr$3 = tmp_if_expr$1;
  }

  else
  {
    if((unsigned int)entry->timeout == 1073741823u)
      tmp_if_expr$2 = entry->verify != 0u ? 4 : 3;

    else
      tmp_if_expr$2 = entry->dirty != 0u ? 6 : 5;
    tmp_if_expr$3 = tmp_if_expr$2;
  }
  switch(tmp_if_expr$3)
  {
    case 0:

    case 1:

    case 3:

    case 4:
      goto __CPROVER_DUMP_L9;
    case 6:

    case 5:

    case 2:
      cbinfo->callback(cbinfo->arg, entry->block_num);
    default:

      __CPROVER_DUMP_L9:
        ;
  }
}

// block_cache_dirty_ratio
// file block_cache.c line 1325
static double block_cache_dirty_ratio(struct block_cache_private *priv)
{
  struct block_cache_conf * const block_cache_dirty_ratio$$1$$config = priv->config;
  return (double)priv->num_dirties / (double)block_cache_dirty_ratio$$1$$config->cache_size;
}

// block_cache_do_read
// file block_cache.c line 554
static signed int block_cache_do_read(struct block_cache_private * const priv, unsigned int block_num, unsigned int off, unsigned int len, void *dest, signed int stats)
{
  struct block_cache_conf * const block_cache_do_read$$1$$config = priv->config;
  struct cache_entry *entry;
  unsigned char md5[16l];
  signed int verified_but_not_read = 0;
  void *data = (void *)0;
  signed int r;
  void *return_value_s3b_hash_get$8;
  signed int tmp_if_expr$3;
  signed int tmp_if_expr$1;
  signed int tmp_if_expr$2;
  char *return_value_strerror$6;
  unsigned int return_value_block_cache_get_time$7;
  do
  {

  again:
    ;
    return_value_s3b_hash_get$8=s3b_hash_get(priv->hashtable, block_num);
    entry = (struct cache_entry *)return_value_s3b_hash_get$8;
    if(!(entry == ((struct cache_entry *)NULL)))
    {
      if(!(entry->link.tqe_prev == ((struct cache_entry **)NULL)))
      {
        if(!(entry->dirty == 0u))
          tmp_if_expr$1 = 2;

        else
          tmp_if_expr$1 = entry->verify != 0u ? 1 : 0;
        tmp_if_expr$3 = tmp_if_expr$1;
      }

      else
      {
        if((unsigned int)entry->timeout == 1073741823u)
          tmp_if_expr$2 = entry->verify != 0u ? 4 : 3;

        else
          tmp_if_expr$2 = entry->dirty != 0u ? 6 : 5;
        tmp_if_expr$3 = tmp_if_expr$2;
      }
      switch(tmp_if_expr$3)
      {
        case 3:

        case 4:
        {
          pthread_cond_wait(&priv->end_reading, &priv->mutex);
          goto again;
        }
        case 1:
        {
          if(!(block_cache_do_read$$1$$config->cache_file == ((const char *)NULL)))
          {
            data=malloc((unsigned long int)block_cache_do_read$$1$$config->block_size);
            if(data == NULL)
            {
              signed int *return_value___errno_location$4;
              return_value___errno_location$4=__errno_location();
              r = *return_value___errno_location$4;
              char *return_value_strerror$5;
              return_value_strerror$5=strerror(r);
              block_cache_do_read$$1$$config->log(3, "can't allocate block cache buffer: %s", return_value_strerror$5);
              return r;
            }

          }

          else
            data = entry->u.data;
          if(!(block_cache_do_read$$1$$config->cache_file == ((const char *)NULL)))
          {
            r=s3b_dcache_erase_block(priv->dcache, entry->u.dslot);
            if(!(r == 0))
            {
              return_value_strerror$6=strerror(r);
              block_cache_do_read$$1$$config->log(3, "can't erase cached block! %s", return_value_strerror$6);
            }

          }

          do
          {
            if(!(entry->link.tqe_next == ((struct cache_entry *)NULL)))
              entry->link.tqe_next->link.tqe_prev = entry->link.tqe_prev;

            else
              (&priv->cleans)->tqh_last = entry->link.tqe_prev;
            *entry->link.tqe_prev = entry->link.tqe_next;
          }
          while((_Bool)0);
          do
            entry->link.tqe_prev = (struct cache_entry **)(void *)0;
          while((_Bool)0);
          priv->num_cleans = priv->num_cleans - 1u;
          entry->timeout = (unsigned int)0x3fffffff;
          goto read;
        }
        case 0:
        {
          do
          {
            if(!(entry->link.tqe_next == ((struct cache_entry *)NULL)))
              entry->link.tqe_next->link.tqe_prev = entry->link.tqe_prev;

            else
              (&priv->cleans)->tqh_last = entry->link.tqe_prev;
            *entry->link.tqe_prev = entry->link.tqe_next;
          }
          while((_Bool)0);
          do
          {
            entry->link.tqe_next = (struct cache_entry *)(void *)0;
            entry->link.tqe_prev = (&priv->cleans)->tqh_last;
            *(&priv->cleans)->tqh_last = entry;
            (&priv->cleans)->tqh_last = &entry->link.tqe_next;
          }
          while((_Bool)0);
          return_value_block_cache_get_time$7=block_cache_get_time(priv);
          entry->timeout = return_value_block_cache_get_time$7 + priv->clean_timeout;
        }
        case 2:

        case 5:

        case 6:
        {
          r=block_cache_read_data(priv, entry, dest, off, len);
          if(!(r == 0))
            return r;

          break;
        }
        default:
          ;
      }
      if(!(stats == 0))
        priv->stats.read_hits = priv->stats.read_hits + 1u;

      return 0;
    }

    r=block_cache_get_entry(priv, &entry, &data);
    if(!(r == 0))
      return r;

    if(!(entry == ((struct cache_entry *)NULL)))
      break;

    pthread_cond_wait(&priv->space_avail, &priv->mutex);
  }
  while((_Bool)1);
  entry->block_num = block_num;
  entry->dirty = (unsigned int)0;
  entry->verify = (unsigned int)0;
  entry->timeout = (unsigned int)0x3fffffff;
  do
    entry->link.tqe_prev = (struct cache_entry **)(void *)0;
  while((_Bool)0);
  s3b_hash_put_new(priv->hashtable, (void *)entry);
  if(!(stats == 0))
    priv->stats.read_misses = priv->stats.read_misses + 1u;


read:
  ;
  (void)0;
  pthread_mutex_unlock(&priv->mutex);
  unsigned char *tmp_if_expr$9;
  if(!(entry->verify == 0u))
    tmp_if_expr$9 = entry->md5;

  else
    tmp_if_expr$9 = (unsigned char *)(void *)0;
  r=priv->inner->read_block(priv->inner, block_num, data, md5, tmp_if_expr$9, 0);
  pthread_mutex_lock(&priv->mutex);
  pthread_cond_broadcast(&priv->end_reading);
  pthread_cond_signal(&priv->space_avail);
  if(!(entry->verify == 0u))
  {
    if(r == 17)
    {
      priv->stats.read_hits = priv->stats.read_hits + 1u;
      priv->stats.verified = priv->stats.verified + 1u;
      verified_but_not_read = 1;
      r = 0;
    }

    else
    {
      priv->stats.read_misses = priv->stats.read_misses + 1u;
      priv->stats.mismatch = priv->stats.mismatch + 1u;
    }
    entry=block_cache_verified(priv, entry);
  }

  if(verified_but_not_read == 0)
    memcpy(dest, (const void *)((char *)data + (signed long int)off), (unsigned long int)len);

  if(!(block_cache_do_read$$1$$config->cache_file == ((const char *)NULL)))
  {
    if(verified_but_not_read == 0)
      r=s3b_dcache_write_block(priv->dcache, entry->u.dslot, data, (unsigned int)0, block_cache_do_read$$1$$config->block_size);

    free(data);
  }

  char *return_value_strerror$10;
  if(!(block_cache_do_read$$1$$config->cache_file == ((const char *)NULL)))
  {
    r=s3b_dcache_record_block(priv->dcache, entry->u.dslot, entry->block_num, md5);
    if(!(r == 0))
    {
      return_value_strerror$10=strerror(r);
      block_cache_do_read$$1$$config->log(3, "can't record cached block! %s", return_value_strerror$10);
    }

  }

  unsigned int return_value_block_cache_get_time$11;
  return_value_block_cache_get_time$11=block_cache_get_time(priv);
  entry->timeout = return_value_block_cache_get_time$11 + priv->clean_timeout;
  entry->link.tqe_next = (struct cache_entry *)(void *)0;
  entry->link.tqe_prev = (&priv->cleans)->tqh_last;
  *(&priv->cleans)->tqh_last = entry;
  (&priv->cleans)->tqh_last = &entry->link.tqe_next;
  priv->num_cleans = priv->num_cleans + 1u;
  return 0;

fail:
  ;
  (void)0;
  if(!(block_cache_do_read$$1$$config->cache_file == ((const char *)NULL)))
    s3b_dcache_free_block(priv->dcache, entry->u.dslot);

  s3b_hash_remove(priv->hashtable, entry->block_num);
  free(data);
  free((void *)entry);
  return r;
}

// block_cache_flush
// file block_cache.c line 408
static signed int block_cache_flush(struct s3backer_store * const s3b)
{
  struct block_cache_private * const priv = (struct block_cache_private *)s3b->data;
  pthread_mutex_lock(&priv->mutex);

__CPROVER_DUMP_L1:
  ;
  priv->stopping = 1;
  while((_Bool)1)
  {
    if(priv->dirties.tqh_first == ((struct cache_entry *)NULL))
    {
      if(!(priv->num_threads >= 1u))
        goto __CPROVER_DUMP_L4;

    }

    pthread_cond_broadcast(&priv->worker_work);
    pthread_cond_wait(&priv->worker_exit, &priv->mutex);
  }

__CPROVER_DUMP_L4:
  ;
  pthread_mutex_unlock(&priv->mutex);
  return 0;
}

// block_cache_free_entry
// file block_cache.c line 970
static void block_cache_free_entry(struct block_cache_private *priv, struct cache_entry **entryp)
{
  struct block_cache_conf * const block_cache_free_entry$$1$$config = priv->config;
  struct cache_entry * const entry = *entryp;
  signed int r;
  *entryp = (struct cache_entry *)(void *)0;
  char *return_value_strerror$1;
  char *return_value_strerror$2;
  if(!(block_cache_free_entry$$1$$config->cache_file == ((const char *)NULL)))
  {
    r=s3b_dcache_erase_block(priv->dcache, entry->u.dslot);
    if(!(r == 0))
    {
      return_value_strerror$1=strerror(r);
      block_cache_free_entry$$1$$config->log(3, "can't erase cached block! %s", return_value_strerror$1);
    }

    r=s3b_dcache_free_block(priv->dcache, entry->u.dslot);
    if(!(r == 0))
    {
      return_value_strerror$2=strerror(r);
      block_cache_free_entry$$1$$config->log(3, "can't free cached block! %s", return_value_strerror$2);
    }

  }

  else
    free(entry->u.data);
  do
  {
    if(!(entry->link.tqe_next == ((struct cache_entry *)NULL)))
      entry->link.tqe_next->link.tqe_prev = entry->link.tqe_prev;

    else
      (&priv->cleans)->tqh_last = entry->link.tqe_prev;
    *entry->link.tqe_prev = entry->link.tqe_next;
  }
  while((_Bool)0);
  s3b_hash_remove(priv->hashtable, entry->block_num);
  priv->num_cleans = priv->num_cleans - 1u;
  free((void *)entry);
}

// block_cache_free_one
// file block_cache.c line 1230
static void block_cache_free_one(void *arg, void *value)
{
  struct block_cache_private * const priv = (struct block_cache_private *)arg;
  struct block_cache_conf * const block_cache_free_one$$1$$config = priv->config;
  struct cache_entry * const entry = (struct cache_entry *)value;
  if(block_cache_free_one$$1$$config->cache_file == ((const char *)NULL))
    free(entry->u.data);

  free((void *)entry);
}

// block_cache_get_entry
// file block_cache.c line 907
static signed int block_cache_get_entry(struct block_cache_private *priv, struct cache_entry **entryp, void **datap)
{
  struct block_cache_conf * const block_cache_get_entry$$1$$config = priv->config;
  struct cache_entry *entry;
  void *data = (void *)0;
  signed int r;
  unsigned int return_value_s3b_hash_size$4;
  do
  {

  again:
    ;
    return_value_s3b_hash_size$4=s3b_hash_size(priv->hashtable);
    if(!(return_value_s3b_hash_size$4 >= block_cache_get_entry$$1$$config->cache_size))
    {
      void *return_value_calloc$3;
      return_value_calloc$3=calloc((unsigned long int)1, sizeof(struct cache_entry) /*32ul*/ );
      entry = (struct cache_entry *)return_value_calloc$3;
      if(entry == ((struct cache_entry *)NULL))
      {
        signed int *return_value___errno_location$1;
        return_value___errno_location$1=__errno_location();
        r = *return_value___errno_location$1;
        char *return_value_strerror$2;
        return_value_strerror$2=strerror(r);
        block_cache_get_entry$$1$$config->log(3, "can't allocate block cache entry: %s", return_value_strerror$2);
        priv->stats.out_of_memory_errors = priv->stats.out_of_memory_errors + 1u;
        return r;
      }

      goto __CPROVER_DUMP_L5;
    }

    entry = (&priv->cleans)->tqh_first;
    if(entry == ((struct cache_entry *)NULL))
      break;

    block_cache_free_entry(priv, &entry);
  }
  while((_Bool)1);
  goto done;

__CPROVER_DUMP_L5:
  ;
  _Bool tmp_if_expr$7;
  if(!(datap == ((void **)NULL)))
    tmp_if_expr$7 = (_Bool)1;

  else
    tmp_if_expr$7 = block_cache_get_entry$$1$$config->cache_file == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr$7)
  {
    data=malloc((unsigned long int)block_cache_get_entry$$1$$config->block_size);
    if(data == NULL)
    {
      signed int *return_value___errno_location$5;
      return_value___errno_location$5=__errno_location();
      r = *return_value___errno_location$5;
      char *return_value_strerror$6;
      return_value_strerror$6=strerror(r);
      block_cache_get_entry$$1$$config->log(3, "can't allocate block cache buffer: %s", return_value_strerror$6);
      priv->stats.out_of_memory_errors = priv->stats.out_of_memory_errors + 1u;
      free((void *)entry);
      return r;
    }

  }

  if(block_cache_get_entry$$1$$config->cache_file == ((const char *)NULL))
    entry->u.data = data;

  else
  {
    r=s3b_dcache_alloc_block(priv->dcache, &entry->u.dslot);
    if(!(r == 0))
    {
      char *return_value_strerror$8;
      return_value_strerror$8=strerror(r);
      block_cache_get_entry$$1$$config->log(3, "can't alloc cached block! %s", return_value_strerror$8);
      free(data);
      data = (void *)0;
      free((void *)entry);
      entry = (struct cache_entry *)(void *)0;
    }

  }

done:
  ;
  *entryp = entry;
  if(!(datap == ((void **)NULL)))
    *datap = data;

  return 0;
}

// block_cache_get_stats
// file block_cache.c line 464
extern void block_cache_get_stats(struct s3backer_store *s3b, struct block_cache_stats *stats)
{
  struct block_cache_private * const priv = (struct block_cache_private *)s3b->data;
  pthread_mutex_lock(&priv->mutex);
  memcpy((void *)stats, (const void *)&priv->stats, sizeof(struct block_cache_stats) /*48ul*/ );
  stats->current_size=s3b_hash_size(priv->hashtable);
  stats->dirty_ratio=block_cache_dirty_ratio(priv);
  pthread_mutex_unlock(&priv->mutex);
}

// block_cache_get_time
// file block_cache.c line 1209
static unsigned int block_cache_get_time(struct block_cache_private *priv)
{
  unsigned long int since_start;
  unsigned long int return_value_block_cache_get_time_millis$1;
  return_value_block_cache_get_time_millis$1=block_cache_get_time_millis();
  since_start = return_value_block_cache_get_time_millis$1 - priv->start_time;
  return (unsigned int)(since_start / (unsigned long int)64);
}

// block_cache_get_time_millis
// file block_cache.c line 1221
static unsigned long int block_cache_get_time_millis(void)
{
  struct timeval tv;
  gettimeofday(&tv, (struct timezone *)(void *)0);
  return (unsigned long int)tv.tv_sec * (unsigned long int)1000 + (unsigned long int)tv.tv_usec / (unsigned long int)1000;
}

// block_cache_list_blocks
// file block_cache.c line 476
static signed int block_cache_list_blocks(struct s3backer_store *s3b, void (*callback)(void *, unsigned int), void *arg)
{
  struct block_cache_private * const priv = (struct block_cache_private *)s3b->data;
  struct cbinfo cbinfo;
  signed int r;
  r=priv->inner->list_blocks(priv->inner, callback, arg);
  if(!(r == 0))
    return r;

  else
  {
    cbinfo.callback = callback;
    cbinfo.arg = arg;
    pthread_mutex_lock(&priv->mutex);
    s3b_hash_foreach(priv->hashtable, block_cache_dirty_callback, (void *)&cbinfo);
    pthread_mutex_unlock(&priv->mutex);
    return 0;
  }
}

// block_cache_meta_data
// file block_cache.c line 392
static signed int block_cache_meta_data(struct s3backer_store *s3b, signed long int *file_sizep, unsigned int *block_sizep)
{
  struct block_cache_private * const priv = (struct block_cache_private *)s3b->data;
  signed int return_value;
  return_value=priv->inner->meta_data(priv->inner, file_sizep, block_sizep);
  return return_value;
}

// block_cache_read
// file block_cache.c line 516
static signed int block_cache_read(struct block_cache_private * const priv, unsigned int block_num, unsigned int off, unsigned int len, void *dest)
{
  struct block_cache_conf * const block_cache_read$$1$$config = priv->config;
  signed int r = 0;
  pthread_mutex_lock(&priv->mutex);

__CPROVER_DUMP_L1:
  ;
  if(block_num == 1u + priv->seq_last)
  {
    priv->seq_count = priv->seq_count + 1u;
    if(priv->ra_count >= 1u)
      priv->ra_count = priv->ra_count - 1u;

  }

  else
    if(!(block_num == priv->seq_last))
    {
      priv->seq_count = (unsigned int)1;
      priv->ra_count = (unsigned int)0;
    }

  priv->seq_last = block_num;
  if(priv->seq_count >= block_cache_read$$1$$config->read_ahead_trigger)
  {
    if(!(priv->ra_count >= block_cache_read$$1$$config->read_ahead))
      pthread_cond_signal(&priv->worker_work);

  }

  r=block_cache_do_read(priv, block_num, off, len, dest, 1);
  pthread_mutex_unlock(&priv->mutex);
  return r;
}

// block_cache_read_block
// file block_cache.c line 493
static signed int block_cache_read_block(struct s3backer_store * const s3b, unsigned int block_num, void *dest, unsigned char *actual_md5, const unsigned char *expect_md5, signed int strict)
{
  struct block_cache_private * const priv = (struct block_cache_private *)s3b->data;
  struct block_cache_conf * const block_cache_read_block$$1$$config = priv->config;
  signed int return_value_block_cache_read$1;
  return_value_block_cache_read$1=block_cache_read(priv, block_num, (unsigned int)0, block_cache_read_block$$1$$config->block_size, dest);
  return return_value_block_cache_read$1;
}

// block_cache_read_block_part
// file block_cache.c line 505
static signed int block_cache_read_block_part(struct s3backer_store *s3b, unsigned int block_num, unsigned int off, unsigned int len, void *dest)
{
  struct block_cache_private * const priv = (struct block_cache_private *)s3b->data;
  signed int return_value_block_cache_read$1;
  return_value_block_cache_read$1=block_cache_read(priv, block_num, off, len, dest);
  return return_value_block_cache_read$1;
}

// block_cache_read_data
// file block_cache.c line 1275
static signed int block_cache_read_data(struct block_cache_private *priv, struct cache_entry *entry, void *dest, unsigned int off, unsigned int len)
{
  struct block_cache_conf * const block_cache_read_data$$1$$config = priv->config;
  if(block_cache_read_data$$1$$config->cache_file == ((const char *)NULL))
  {
    memcpy(dest, (const void *)((char *)entry->u.data + (signed long int)off), (unsigned long int)len);
    return 0;
  }

  else
  {
    signed int return_value_s3b_dcache_read_block$1;
    return_value_s3b_dcache_read_block$1=s3b_dcache_read_block(priv->dcache, entry->u.dslot, dest, off, len);
    return return_value_s3b_dcache_read_block$1;
  }
}

// block_cache_set_mounted
// file block_cache.c line 400
static signed int block_cache_set_mounted(struct s3backer_store *s3b, signed int *old_valuep, signed int new_value)
{
  struct block_cache_private * const priv = (struct block_cache_private *)s3b->data;
  signed int return_value;
  return_value=priv->inner->set_mounted(priv->inner, old_valuep, new_value);
  return return_value;
}

// block_cache_verified
// file block_cache.c line 1245
static struct cache_entry * block_cache_verified(struct block_cache_private *priv, struct cache_entry *entry)
{
  struct cache_entry *new_entry;
  void *return_value_realloc$1;
  return_value_realloc$1=realloc((void *)entry, sizeof(struct cache_entry) /*32ul*/ );
  new_entry = (struct cache_entry *)return_value_realloc$1;
  if(!(new_entry == ((struct cache_entry *)NULL)))
  {
    s3b_hash_put(priv->hashtable, (void *)new_entry);
    if(!(entry->link.tqe_prev == ((struct cache_entry **)NULL)))
    {
      do
      {
        if(!(entry->link.tqe_next == ((struct cache_entry *)NULL)))
          entry->link.tqe_next->link.tqe_prev = entry->link.tqe_prev;

        else
          (&priv->cleans)->tqh_last = entry->link.tqe_prev;
        *entry->link.tqe_prev = entry->link.tqe_next;
      }
      while((_Bool)0);
      do
      {
        new_entry->link.tqe_next = (struct cache_entry *)(void *)0;
        new_entry->link.tqe_prev = (&priv->cleans)->tqh_last;
        *(&priv->cleans)->tqh_last = new_entry;
        (&priv->cleans)->tqh_last = &new_entry->link.tqe_next;
      }
      while((_Bool)0);
    }

    entry = new_entry;
  }


done:
  ;
  entry->verify = (unsigned int)0;
  return entry;
}

// block_cache_worker_main
// file block_cache.c line 1004
static void * block_cache_worker_main(void *arg)
{
  struct block_cache_private * const priv = (struct block_cache_private *)arg;
  struct block_cache_conf * const block_cache_worker_main$$1$$config = priv->config;
  struct cache_entry *entry;
  struct cache_entry *clean_entry = (struct cache_entry *)(void *)0;
  unsigned char md5[16l];
  unsigned int adjusted_now;
  unsigned int now;
  unsigned int thread_id;
  void *buf;
  signed int r;
  pthread_mutex_lock(&priv->mutex);
  unsigned int tmp_post$1 = priv->thread_id;
  priv->thread_id = priv->thread_id + 1u;
  thread_id = tmp_post$1;
  buf=malloc((unsigned long int)block_cache_worker_main$$1$$config->block_size);
  if(buf == NULL)
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    char *return_value_strerror$3;
    return_value_strerror$3=strerror(*return_value___errno_location$2);
    block_cache_worker_main$$1$$config->log(3, "block_cache worker %u can't alloc buffer, exiting: %s", thread_id, return_value_strerror$3);
  }

  _Bool tmp_if_expr$8;
  char *return_value_strerror$6;
  _Bool tmp_if_expr$11;
  _Bool tmp_if_expr$10;
  while((_Bool)1)
  {

  __CPROVER_DUMP_L2:
    ;
    now=block_cache_get_time(priv);
    if(!(priv->clean_timeout == 0u))
      do
      {
        clean_entry = (&priv->cleans)->tqh_first;
        if(clean_entry == ((struct cache_entry *)NULL))
          break;

        if(!(now >= (unsigned int)clean_entry->timeout))
          break;

        block_cache_free_entry(priv, &clean_entry);
        pthread_cond_signal(&priv->space_avail);
      }
      while((_Bool)1);

    double return_value_block_cache_dirty_ratio$4;
    return_value_block_cache_dirty_ratio$4=block_cache_dirty_ratio(priv);
    adjusted_now = now + (unsigned int)((double)priv->dirty_timeout * (return_value_block_cache_dirty_ratio$4 / priv->max_dirty_ratio));
    entry = (&priv->dirties)->tqh_first;
    if(!(entry == ((struct cache_entry *)NULL)))
    {
      if(!(priv->stopping == 0))
        tmp_if_expr$8 = (_Bool)1;

      else
        tmp_if_expr$8 = adjusted_now >= (unsigned int)entry->timeout ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr$8)
        goto __CPROVER_DUMP_L21;

      if(priv->seq_count >= block_cache_worker_main$$1$$config->read_ahead_trigger)
      {
        if(!(priv->ra_count >= block_cache_worker_main$$1$$config->read_ahead))
          pthread_cond_signal(&priv->worker_work);

      }

      r=block_cache_read_data(priv, entry, buf, (unsigned int)0, block_cache_worker_main$$1$$config->block_size);
      if(!(r == 0))
      {
        char *return_value_strerror$5;
        return_value_strerror$5=strerror(r);
        block_cache_worker_main$$1$$config->log(3, "error reading cached block! %s", return_value_strerror$5);
        sleep((unsigned int)5);
        continue;
      }

      do
      {
        if(!(entry->link.tqe_next == ((struct cache_entry *)NULL)))
          entry->link.tqe_next->link.tqe_prev = entry->link.tqe_prev;

        else
          (&priv->dirties)->tqh_last = entry->link.tqe_prev;
        *entry->link.tqe_prev = entry->link.tqe_next;
      }
      while((_Bool)0);
      do
        entry->link.tqe_prev = (struct cache_entry **)(void *)0;
      while((_Bool)0);
      entry->dirty = (unsigned int)0;
      entry->timeout = (unsigned int)0;
      pthread_mutex_unlock(&priv->mutex);
      r=priv->inner->write_block(priv->inner, entry->block_num, buf, md5, block_cache_check_cancel, (void *)priv);
      pthread_mutex_lock(&priv->mutex);
      if(!(r == 0))
      {
        entry->dirty = (unsigned int)1;
        entry->link.tqe_next = (&priv->dirties)->tqh_first;
        if(!(entry->link.tqe_next == ((struct cache_entry *)NULL)))
          (&priv->dirties)->tqh_first->link.tqe_prev = &entry->link.tqe_next;

        else
          (&priv->dirties)->tqh_last = &entry->link.tqe_next;
        (&priv->dirties)->tqh_first = entry;
        entry->link.tqe_prev = &(&priv->dirties)->tqh_first;
        continue;
      }

      if(entry->dirty == 0u)
      {
        if(!(block_cache_worker_main$$1$$config->cache_file == ((const char *)NULL)))
        {
          r=s3b_dcache_record_block(priv->dcache, entry->u.dslot, entry->block_num, md5);
          if(!(r == 0))
          {
            return_value_strerror$6=strerror(r);
            block_cache_worker_main$$1$$config->log(3, "can't record cached block! %s", return_value_strerror$6);
          }

        }

        priv->num_dirties = priv->num_dirties - 1u;
        entry->link.tqe_next = (struct cache_entry *)(void *)0;
        entry->link.tqe_prev = (&priv->cleans)->tqh_last;
        *(&priv->cleans)->tqh_last = entry;
        (&priv->cleans)->tqh_last = &entry->link.tqe_next;
        entry->verify = (unsigned int)0;
        unsigned int return_value_block_cache_get_time$7;
        return_value_block_cache_get_time$7=block_cache_get_time(priv);
        entry->timeout = return_value_block_cache_get_time$7 + priv->clean_timeout;
        priv->num_cleans = priv->num_cleans + 1u;
        pthread_cond_signal(&priv->space_avail);
        pthread_cond_broadcast(&priv->write_complete);
        continue;
      }

      entry->link.tqe_next = (struct cache_entry *)(void *)0;
      entry->link.tqe_prev = (&priv->dirties)->tqh_last;
      *(&priv->dirties)->tqh_last = entry;
      (&priv->dirties)->tqh_last = &entry->link.tqe_next;
      entry->timeout = now + priv->dirty_timeout;
    }

    else
    {

    __CPROVER_DUMP_L21:
      ;
      if(!(priv->stopping == 0))
        break;

      if(priv->seq_count >= block_cache_worker_main$$1$$config->read_ahead_trigger)
      {
        if(priv->ra_count >= block_cache_worker_main$$1$$config->read_ahead)
          goto __CPROVER_DUMP_L26;

        while(!(priv->ra_count >= block_cache_worker_main$$1$$config->read_ahead))
        {
          unsigned int ra_block;
          priv->ra_count = priv->ra_count + 1u;
          ra_block = priv->seq_last + priv->ra_count;
          void *return_value_s3b_hash_get$9;
          return_value_s3b_hash_get$9=s3b_hash_get(priv->hashtable, ra_block);
          if(return_value_s3b_hash_get$9 == NULL)
          {
            block_cache_do_read(priv, ra_block, (unsigned int)0, (unsigned int)0, (void *)0, 0);
            break;
          }

        }
      }

      else
      {

      __CPROVER_DUMP_L26:
        ;
        if(entry == ((struct cache_entry *)NULL))
          tmp_if_expr$11 = (_Bool)1;

        else
        {
          if(!(clean_entry == ((struct cache_entry *)NULL)))
            tmp_if_expr$10 = (signed int)clean_entry->timeout < (signed int)entry->timeout ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$10 = (_Bool)0;
          tmp_if_expr$11 = tmp_if_expr$10 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr$11)
          entry = clean_entry;

        block_cache_worker_wait(priv, entry);
      }
    }
  }
  priv->num_threads = priv->num_threads - 1u;
  pthread_cond_signal(&priv->worker_exit);

done:
  ;
  pthread_mutex_unlock(&priv->mutex);
  free(buf);
  return (void *)0;
}

// block_cache_worker_wait
// file block_cache.c line 1190
static void block_cache_worker_wait(struct block_cache_private *priv, struct cache_entry *entry)
{
  unsigned long int wake_time_millis;
  struct timespec wake_time;
  if(entry == ((struct cache_entry *)NULL))
    pthread_cond_wait(&priv->worker_work, &priv->mutex);

  else
  {
    wake_time_millis = priv->start_time + (unsigned long int)entry->timeout * (unsigned long int)64;
    wake_time.tv_sec = (signed long int)(wake_time_millis / (unsigned long int)1000);
    wake_time.tv_nsec = (signed long int)((wake_time_millis % (unsigned long int)1000) * (unsigned long int)1000000);
    pthread_cond_timedwait(&priv->worker_work, &priv->mutex, &wake_time);
  }
}

// block_cache_write
// file block_cache.c line 749
static signed int block_cache_write(struct block_cache_private * const priv, unsigned int block_num, unsigned int off, unsigned int len, const void *src)
{
  struct block_cache_conf * const block_cache_write$$1$$config = priv->config;
  struct cache_entry *entry;
  signed int r;
  pthread_mutex_lock(&priv->mutex);
  void *return_value_s3b_hash_get$7;
  signed int tmp_if_expr$3;
  signed int tmp_if_expr$1;
  signed int tmp_if_expr$2;
  char *return_value_strerror$4;
  unsigned int return_value_block_cache_get_time$5;
  char *return_value_strerror$6;
  _Bool tmp_if_expr$8;
  do
  {

  again:
    ;
    return_value_s3b_hash_get$7=s3b_hash_get(priv->hashtable, block_num);
    entry = (struct cache_entry *)return_value_s3b_hash_get$7;
    if(!(entry == ((struct cache_entry *)NULL)))
    {
      if(!(entry->link.tqe_prev == ((struct cache_entry **)NULL)))
      {
        if(!(entry->dirty == 0u))
          tmp_if_expr$1 = 2;

        else
          tmp_if_expr$1 = entry->verify != 0u ? 1 : 0;
        tmp_if_expr$3 = tmp_if_expr$1;
      }

      else
      {
        if((unsigned int)entry->timeout == 1073741823u)
          tmp_if_expr$2 = entry->verify != 0u ? 4 : 3;

        else
          tmp_if_expr$2 = entry->dirty != 0u ? 6 : 5;
        tmp_if_expr$3 = tmp_if_expr$2;
      }
      switch(tmp_if_expr$3)
      {
        case 3:

        case 4:
        {
          pthread_cond_wait(&priv->end_reading, &priv->mutex);
          goto again;
        }
        case 1:
          entry=block_cache_verified(priv, entry);
        case 0:
        {
          if(!(block_cache_write$$1$$config->max_dirty == 0u))
          {
            if(priv->num_dirties >= block_cache_write$$1$$config->max_dirty)
            {
              pthread_cond_signal(&priv->worker_work);
              pthread_cond_wait(&priv->write_complete, &priv->mutex);
              goto again;
            }

          }

          if(!(block_cache_write$$1$$config->cache_file == ((const char *)NULL)))
          {
            r=s3b_dcache_erase_block(priv->dcache, entry->u.dslot);
            if(!(r == 0))
            {
              return_value_strerror$4=strerror(r);
              block_cache_write$$1$$config->log(3, "can't erase cached block! %s", return_value_strerror$4);
            }

          }

          do
          {
            if(!(entry->link.tqe_next == ((struct cache_entry *)NULL)))
              entry->link.tqe_next->link.tqe_prev = entry->link.tqe_prev;

            else
              (&priv->cleans)->tqh_last = entry->link.tqe_prev;
            *entry->link.tqe_prev = entry->link.tqe_next;
          }
          while((_Bool)0);
          priv->num_cleans = priv->num_cleans - 1u;
          do
          {
            entry->link.tqe_next = (struct cache_entry *)(void *)0;
            entry->link.tqe_prev = (&priv->dirties)->tqh_last;
            *(&priv->dirties)->tqh_last = entry;
            (&priv->dirties)->tqh_last = &entry->link.tqe_next;
          }
          while((_Bool)0);
          priv->num_dirties = priv->num_dirties + 1u;
          return_value_block_cache_get_time$5=block_cache_get_time(priv);
          entry->timeout = return_value_block_cache_get_time$5 + priv->dirty_timeout;
          pthread_cond_signal(&priv->worker_work);
        }
        case 6:

        case 5:

        case 2:
        {
          r=block_cache_write_data(priv, entry, src, off, len);
          if(!(r == 0))
          {
            return_value_strerror$6=strerror(r);
            block_cache_write$$1$$config->log(3, "error updating dirty block! %s", return_value_strerror$6);
          }

          entry->dirty = (unsigned int)1;
          priv->stats.write_hits = priv->stats.write_hits + 1u;
          break;
        }
        default:
          ;
      }
      goto success;
    }

    if(!(off == 0u))
      tmp_if_expr$8 = (_Bool)1;

    else
      tmp_if_expr$8 = len != block_cache_write$$1$$config->block_size ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$8)
    {
      r=block_cache_do_read(priv, block_num, (unsigned int)0, (unsigned int)0, (void *)0, 0);
      if(!(r == 0))
        goto fail;

      goto again;
    }

    if(!(block_cache_write$$1$$config->max_dirty == 0u))
    {
      if(priv->num_dirties >= block_cache_write$$1$$config->max_dirty)
      {
        pthread_cond_signal(&priv->worker_work);
        pthread_cond_wait(&priv->write_complete, &priv->mutex);
        goto again;
      }

    }

    r=block_cache_get_entry(priv, &entry, (void **)(void *)0);
    if(!(r == 0))
      goto fail;

    if(!(entry == ((struct cache_entry *)NULL)))
      break;

    pthread_cond_wait(&priv->space_avail, &priv->mutex);
  }
  while((_Bool)1);
  r=block_cache_write_data(priv, entry, src, off, len);
  char *return_value_strerror$9;
  if(!(r == 0))
  {
    return_value_strerror$9=strerror(r);
    block_cache_write$$1$$config->log(3, "error updating dirty block! %s", return_value_strerror$9);
  }

  priv->stats.write_misses = priv->stats.write_misses + 1u;
  entry->block_num = block_num;
  unsigned int return_value_block_cache_get_time$10;
  return_value_block_cache_get_time$10=block_cache_get_time(priv);
  entry->timeout = return_value_block_cache_get_time$10 + priv->dirty_timeout;
  entry->dirty = (unsigned int)1;
  s3b_hash_put_new(priv->hashtable, (void *)entry);
  do
  {
    entry->link.tqe_next = (struct cache_entry *)(void *)0;
    entry->link.tqe_prev = (&priv->dirties)->tqh_last;
    *(&priv->dirties)->tqh_last = entry;
    (&priv->dirties)->tqh_last = &entry->link.tqe_next;
  }
  while((_Bool)0);
  priv->num_dirties = priv->num_dirties + 1u;
  pthread_cond_signal(&priv->worker_work);

success:
  ;
  signed int tmp_if_expr$14;
  signed int tmp_if_expr$12;
  signed int tmp_if_expr$13;
  if(!(block_cache_write$$1$$config->synchronous == 0u))
    while((_Bool)1)
    {
      signed int state;
      pthread_cond_wait(&priv->write_complete, &priv->mutex);

    __CPROVER_DUMP_L31:
      ;
      void *return_value_s3b_hash_get$11;
      return_value_s3b_hash_get$11=s3b_hash_get(priv->hashtable, block_num);
      entry = (struct cache_entry *)return_value_s3b_hash_get$11;
      if(entry == ((struct cache_entry *)NULL))
        break;

      if(!(entry->link.tqe_prev == ((struct cache_entry **)NULL)))
      {
        if(!(entry->dirty == 0u))
          tmp_if_expr$12 = 2;

        else
          tmp_if_expr$12 = entry->verify != 0u ? 1 : 0;
        tmp_if_expr$14 = tmp_if_expr$12;
      }

      else
      {
        if((unsigned int)entry->timeout == 1073741823u)
          tmp_if_expr$13 = entry->verify != 0u ? 4 : 3;

        else
          tmp_if_expr$13 = entry->dirty != 0u ? 6 : 5;
        tmp_if_expr$14 = tmp_if_expr$13;
      }
      state = tmp_if_expr$14;
      if(state == 0 || state == 1 || state == 3 || state == 4)
        break;

    }

  r = 0;

fail:
  ;
  pthread_mutex_unlock(&priv->mutex);
  return r;
}

// block_cache_write_block
// file block_cache.c line 727
static signed int block_cache_write_block(struct s3backer_store * const s3b, unsigned int block_num, const void *src, unsigned char *md5, signed int (*check_cancel)(void *, unsigned int), void *check_cancel_arg)
{
  struct block_cache_private * const priv = (struct block_cache_private *)s3b->data;
  struct block_cache_conf * const block_cache_write_block$$1$$config = priv->config;
  signed int return_value_block_cache_write$1;
  return_value_block_cache_write$1=block_cache_write(priv, block_num, (unsigned int)0, block_cache_write_block$$1$$config->block_size, src);
  return return_value_block_cache_write$1;
}

// block_cache_write_block_part
// file block_cache.c line 738
static signed int block_cache_write_block_part(struct s3backer_store *s3b, unsigned int block_num, unsigned int off, unsigned int len, const void *src)
{
  struct block_cache_private * const priv = (struct block_cache_private *)s3b->data;
  signed int return_value_block_cache_write$1;
  return_value_block_cache_write$1=block_cache_write(priv, block_num, off, len, src);
  return return_value_block_cache_write$1;
}

// block_cache_write_data
// file block_cache.c line 1298
static signed int block_cache_write_data(struct block_cache_private *priv, struct cache_entry *entry, const void *src, unsigned int off, unsigned int len)
{
  struct block_cache_conf * const block_cache_write_data$$1$$config = priv->config;
  if(block_cache_write_data$$1$$config->cache_file == ((const char *)NULL))
  {
    if(src == NULL)
      memset((void *)((char *)entry->u.data + (signed long int)off), 0, (unsigned long int)len);

    else
      memcpy((void *)((char *)entry->u.data + (signed long int)off), src, (unsigned long int)len);
    return 0;
  }

  else
  {
    signed int return_value_s3b_dcache_write_block$1;
    return_value_s3b_dcache_write_block$1=s3b_dcache_write_block(priv->dcache, entry->u.dslot, src, off, len);
    return return_value_s3b_dcache_write_block$1;
  }
}

// block_part_read_block_part
// file block_part.c line 44
extern signed int block_part_read_block_part(struct s3backer_store *s3b, unsigned int block_num, unsigned int block_size, unsigned int off, unsigned int len, void *dest)
{
  unsigned char *buf;
  signed int r;
  signed int return_value;
  signed int *return_value___errno_location$1;
  if(len == 0u)
    return 0;

  else
    if(len == block_size && off == 0u)
    {
      return_value=s3b->read_block(s3b, block_num, dest, (unsigned char *)(void *)0, (const unsigned char *)(void *)0, 0);
      return return_value;
    }

    else
    {
      void *return_value_malloc$2;
      return_value_malloc$2=malloc((unsigned long int)block_size);
      buf = (unsigned char *)return_value_malloc$2;
      if(buf == ((unsigned char *)NULL))
      {
        return_value___errno_location$1=__errno_location();
        return *return_value___errno_location$1;
      }

      else
      {
        r=s3b->read_block(s3b, block_num, (void *)buf, (unsigned char *)(void *)0, (const unsigned char *)(void *)0, 0);
        if(!(r == 0))
        {
          free((void *)buf);
          return r;
        }

        else
        {
          memcpy(dest, (const void *)(buf + (signed long int)off), (unsigned long int)len);
          free((void *)buf);
          return 0;
        }
      }
    }
}

// block_part_write_block_part
// file block_part.c line 83
extern signed int block_part_write_block_part(struct s3backer_store *s3b, unsigned int block_num, unsigned int block_size, unsigned int off, unsigned int len, const void *src)
{
  unsigned char *buf;
  signed int r;
  signed int return_value;
  signed int *return_value___errno_location$1;
  if(len == 0u)
    return 0;

  else
    if(len == block_size && off == 0u)
    {
      return_value=s3b->write_block(s3b, block_num, src, (unsigned char *)(void *)0, (signed int (*)(void *, unsigned int))(void *)0, (void *)0);
      return return_value;
    }

    else
    {
      void *return_value_malloc$2;
      return_value_malloc$2=malloc((unsigned long int)block_size);
      buf = (unsigned char *)return_value_malloc$2;
      if(buf == ((unsigned char *)NULL))
      {
        return_value___errno_location$1=__errno_location();
        return *return_value___errno_location$1;
      }

      else
      {
        r=s3b->read_block(s3b, block_num, (void *)buf, (unsigned char *)(void *)0, (const unsigned char *)(void *)0, 0);
        if(!(r == 0))
        {
          free((void *)buf);
          return r;
        }

        else
        {
          memcpy((void *)(buf + (signed long int)off), src, (unsigned long int)len);
          r=s3b->write_block(s3b, block_num, (const void *)buf, (unsigned char *)(void *)0, (signed int (*)(void *, unsigned int))(void *)0, (void *)0);
          if(!(r == 0))
          {
            free((void *)buf);
            return r;
          }

          else
          {
            free((void *)buf);
            return 0;
          }
        }
      }
    }
}

// dump_config
// file s3b_config.c line 1514
static void dump_config(void)
{
  signed int i;
  config$link1.log(7, "s3backer config:");
  config$link1.log(7, "%24s: %s", (const void *)"test mode", config$link1.test != 0 ? "true" : "false");
  config$link1.log(7, "%24s: %s", (const void *)"directIO", config$link1.fuse_ops.direct_io != 0 ? "true" : "false");
  config$link1.log(7, "%24s: \"%s\"", (const void *)"accessId", config$link1.http_io.accessId != (char *)(void *)0 ? config$link1.http_io.accessId : "");
  config$link1.log(7, "%24s: \"%s\"", (const void *)"accessKey", config$link1.http_io.accessKey != (char *)(void *)0 ? "****" : "");
  config$link1.log(7, "%24s: \"%s\"", (const void *)"accessFile", config$link1.accessFile);
  config$link1.log(7, "%24s: %s", (const void *)"accessType", config$link1.http_io.accessType);
  config$link1.log(7, "%24s: \"%s\"", (const void *)"ec2iam_role", config$link1.http_io.ec2iam_role != (const char *)(void *)0 ? config$link1.http_io.ec2iam_role : "");
  config$link1.log(7, "%24s: %s", (const void *)"authVersion", config$link1.http_io.authVersion);
  config$link1.log(7, "%24s: \"%s\"", (const void *)"baseURL", config$link1.http_io.baseURL);
  config$link1.log(7, "%24s: \"%s\"", (const void *)"region", config$link1.http_io.region);
  config$link1.log(7, "%24s: \"%s\"", config$link1.test != 0 ? "testdir" : "bucket", config$link1.http_io.bucket);
  config$link1.log(7, "%24s: \"%s\"", (const void *)"prefix", config$link1.http_io.prefix);
  config$link1.log(7, "%24s: %s", (const void *)"list_blocks", config$link1.list_blocks != 0 ? "true" : "false");
  config$link1.log(7, "%24s: \"%s\"", (const void *)"mount", config$link1.mount);
  config$link1.log(7, "%24s: \"%s\"", (const void *)"filename", config$link1.fuse_ops.filename);
  config$link1.log(7, "%24s: \"%s\"", (const void *)"stats_filename", config$link1.fuse_ops.stats_filename);
  config$link1.log(7, "%24s: %s (%u)", (const void *)"block_size", config$link1.block_size_str != (const char *)(void *)0 ? config$link1.block_size_str : "-", config$link1.block_size);
  config$link1.log(7, "%24s: %s (%jd)", (const void *)"file_size", config$link1.file_size_str != (const char *)(void *)0 ? config$link1.file_size_str : "-", (signed long int)config$link1.file_size);
  config$link1.log(7, "%24s: %jd", (const void *)"num_blocks", (signed long int)config$link1.num_blocks);
  config$link1.log(7, "%24s: 0%o", (const void *)"file_mode", config$link1.fuse_ops.file_mode);
  config$link1.log(7, "%24s: %s", (const void *)"read_only", config$link1.fuse_ops.read_only != 0 ? "true" : "false");
  config$link1.log(7, "%24s: %d", (const void *)"compress", config$link1.http_io.compress);
  config$link1.log(7, "%24s: %s", (const void *)"encryption", config$link1.http_io.encryption != (const char *)(void *)0 ? config$link1.http_io.encryption : "(none)");
  config$link1.log(7, "%24s: %u", (const void *)"key_length", config$link1.http_io.key_length);
  config$link1.log(7, "%24s: \"%s\"", (const void *)"password", config$link1.http_io.password != (const char *)(void *)0 ? "****" : "");
  const char *tmp_if_expr$1;
  if(!(config$link1.max_speed_str[1l] == ((const char *)NULL)))
    tmp_if_expr$1 = config$link1.max_speed_str[(signed long int)1];

  else
    tmp_if_expr$1 = "-";
  config$link1.log(7, "%24s: %s bps (%ju)", (const void *)"max_upload", tmp_if_expr$1, config$link1.http_io.max_speed[(signed long int)1]);
  const char *tmp_if_expr$2;
  if(!(config$link1.max_speed_str[0l] == ((const char *)NULL)))
    tmp_if_expr$2 = config$link1.max_speed_str[(signed long int)0];

  else
    tmp_if_expr$2 = "-";
  config$link1.log(7, "%24s: %s bps (%ju)", (const void *)"max_download", tmp_if_expr$2, config$link1.http_io.max_speed[(signed long int)0]);
  config$link1.log(7, "%24s: %us", (const void *)"timeout", config$link1.http_io.timeout);
  config$link1.log(7, "%24s: %ums", (const void *)"initial_retry_pause", config$link1.http_io.initial_retry_pause);
  config$link1.log(7, "%24s: %ums", (const void *)"max_retry_pause", config$link1.http_io.max_retry_pause);
  config$link1.log(7, "%24s: %ums", (const void *)"min_write_delay", config$link1.ec_protect.min_write_delay);
  config$link1.log(7, "%24s: %ums", (const void *)"md5_cache_time", config$link1.ec_protect.cache_time);
  config$link1.log(7, "%24s: %u entries", (const void *)"md5_cache_size", config$link1.ec_protect.cache_size);
  config$link1.log(7, "%24s: %u entries", (const void *)"block_cache_size", config$link1.block_cache.cache_size);
  config$link1.log(7, "%24s: %u threads", (const void *)"block_cache_threads", config$link1.block_cache.num_threads);
  config$link1.log(7, "%24s: %ums", (const void *)"block_cache_timeout", config$link1.block_cache.timeout);
  config$link1.log(7, "%24s: %ums", (const void *)"block_cache_write_delay", config$link1.block_cache.write_delay);
  config$link1.log(7, "%24s: %u blocks", (const void *)"block_cache_max_dirty", config$link1.block_cache.max_dirty);
  config$link1.log(7, "%24s: %s", (const void *)"block_cache_sync", config$link1.block_cache.synchronous != 0u ? "true" : "false");
  config$link1.log(7, "%24s: %u blocks", (const void *)"read_ahead", config$link1.block_cache.read_ahead);
  config$link1.log(7, "%24s: %u blocks", (const void *)"read_ahead_trigger", config$link1.block_cache.read_ahead_trigger);
  config$link1.log(7, "%24s: \"%s\"", (const void *)"block_cache_cache_file", config$link1.block_cache.cache_file != (const char *)(void *)0 ? config$link1.block_cache.cache_file : "");
  config$link1.log(7, "%24s: %s", (const void *)"block_cache_no_verify", config$link1.block_cache.no_verify != 0u ? "true" : "false");
  config$link1.log(7, "fuse_main arguments:");
  i = 0;
  if(!(i >= config$link1.fuse_args.argc))
  {
    config$link1.log(7, "  [%d] = \"%s\"", i, config$link1.fuse_args.argv[(signed long int)i]);
    i = i + 1;
  }

}

// ec_protect_create
// file ec_protect.c line 166
extern struct s3backer_store * ec_protect_create(struct ec_protect_conf *config, struct s3backer_store *inner)
{
  struct s3backer_store *s3b;
  struct ec_protect_private *priv;
  signed int r;
  void *return_value_calloc$3;
  return_value_calloc$3=calloc((unsigned long int)1, sizeof(struct s3backer_store) /*80ul*/ );
  s3b = (struct s3backer_store *)return_value_calloc$3;
  if(s3b == ((struct s3backer_store *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    r = *return_value___errno_location$1;
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(r);
    config->log(3, "calloc(): %s", return_value_strerror$2);
  }

  s3b->meta_data = ec_protect_meta_data;
  s3b->set_mounted = ec_protect_set_mounted;
  s3b->read_block = ec_protect_read_block;
  s3b->write_block = ec_protect_write_block;
  s3b->read_block_part = ec_protect_read_block_part;
  s3b->write_block_part = ec_protect_write_block_part;
  s3b->list_blocks = ec_protect_list_blocks;
  s3b->flush = ec_protect_flush;
  s3b->destroy = ec_protect_destroy;
  void *return_value_calloc$6;
  return_value_calloc$6=calloc((unsigned long int)1, sizeof(struct ec_protect_private) /*264ul*/ );
  priv = (struct ec_protect_private *)return_value_calloc$6;
  if(priv == ((struct ec_protect_private *)NULL))
  {
    signed int *return_value___errno_location$4;
    return_value___errno_location$4=__errno_location();
    r = *return_value___errno_location$4;
    char *return_value_strerror$5;
    return_value_strerror$5=strerror(r);
    config->log(3, "calloc(): %s", return_value_strerror$5);
  }

  priv->config = config;
  priv->inner = inner;
  r=pthread_mutex_init(&priv->mutex, (const union anonymous$15 *)(void *)0);
  if(r == 0)
  {
    r=pthread_cond_init(&priv->space_cond, (const union anonymous$15 *)(void *)0);
    if(r == 0)
    {
      r=pthread_cond_init(&priv->sleepers_cond, (const union anonymous$15 *)(void *)0);
      if(r == 0)
      {
        r=pthread_cond_init(&priv->never_cond, (const union anonymous$15 *)(void *)0);
        if(r == 0)
        {
          do
          {
            (&priv->list)->tqh_first = (struct block_info *)(void *)0;
            (&priv->list)->tqh_last = &(&priv->list)->tqh_first;
          }
          while((_Bool)0);
          r=s3b_hash_create(&priv->hashtable, config->cache_size);
          if(r == 0)
          {
            s3b->data = (void *)priv;

          __CPROVER_DUMP_L4:
            ;
            return s3b;
          }


        fail6:
          ;
          pthread_cond_destroy(&priv->never_cond);
        }


      fail5:
        ;
        pthread_cond_destroy(&priv->sleepers_cond);
      }


    fail4:
      ;
      pthread_cond_destroy(&priv->space_cond);
    }


  fail3:
    ;
    pthread_mutex_destroy(&priv->mutex);
  }


fail2:
  ;
  free((void *)priv);

fail1:
  ;
  free((void *)s3b);

fail0:
  ;
  char *return_value_strerror$7;
  return_value_strerror$7=strerror(r);
  config->log(3, "ec_protect creation failed: %s", return_value_strerror$7);
  signed int *return_value___errno_location$8;
  return_value___errno_location$8=__errno_location();
  *return_value___errno_location$8 = r;
  return (struct s3backer_store *)(void *)0;
}

// ec_protect_destroy
// file ec_protect.c line 264
static void ec_protect_destroy(struct s3backer_store * const s3b)
{
  struct ec_protect_private * const priv = (struct ec_protect_private *)s3b->data;
  pthread_mutex_lock(&priv->mutex);

__CPROVER_DUMP_L1:
  ;
  while(priv->num_sleepers >= 1u)
    pthread_cond_wait(&priv->sleepers_cond, &priv->mutex);
  priv->inner->destroy(priv->inner);
  pthread_mutex_destroy(&priv->mutex);
  pthread_cond_destroy(&priv->space_cond);
  pthread_cond_destroy(&priv->sleepers_cond);
  pthread_cond_destroy(&priv->never_cond);
  s3b_hash_foreach(priv->hashtable, ec_protect_free_one, (void *)0);
  s3b_hash_destroy(priv->hashtable);
  free((void *)priv);
  free((void *)s3b);
}

// ec_protect_dirty_callback
// file ec_protect.c line 612
static void ec_protect_dirty_callback(void *arg, void *value)
{
  struct cbinfo * const cbinfo = (struct cbinfo *)arg;
  struct block_info * const binfo = (struct block_info *)value;
  signed int tmp_if_expr$2;
  signed int return_value_memcmp$1;
  if(binfo->timestamp == 0ul)
    tmp_if_expr$2 = (signed int)(binfo->u.data != (void *)0);

  else
  {
    return_value_memcmp$1=memcmp((const void *)binfo->u.md5, (const void *)zero_md5, (unsigned long int)16);
    tmp_if_expr$2 = (signed int)(return_value_memcmp$1 != 0);
  }
  if(!(tmp_if_expr$2 == 0))
    cbinfo->callback(cbinfo->arg, binfo->block_num);

}

// ec_protect_flush
// file ec_protect.c line 246
static signed int ec_protect_flush(struct s3backer_store * const s3b)
{
  struct ec_protect_private * const priv = (struct ec_protect_private *)s3b->data;
  pthread_mutex_lock(&priv->mutex);

__CPROVER_DUMP_L1:
  ;
  while(priv->num_sleepers >= 1u)
    pthread_cond_wait(&priv->sleepers_cond, &priv->mutex);
  pthread_mutex_unlock(&priv->mutex);
  return 0;
}

// ec_protect_free_one
// file ec_protect.c line 606
static void ec_protect_free_one(void *arg, void *value)
{
  free(value);
}

// ec_protect_get_stats
// file ec_protect.c line 291
extern void ec_protect_get_stats(struct s3backer_store *s3b, struct ec_protect_stats *stats)
{
  struct ec_protect_private * const priv = (struct ec_protect_private *)s3b->data;
  pthread_mutex_lock(&priv->mutex);
  memcpy((void *)stats, (const void *)&priv->stats, sizeof(struct ec_protect_stats) /*32ul*/ );
  stats->current_cache_size=s3b_hash_size(priv->hashtable);
  pthread_mutex_unlock(&priv->mutex);
}

// ec_protect_get_time
// file ec_protect.c line 529
static unsigned long int ec_protect_get_time(void)
{
  struct timeval tv;
  gettimeofday(&tv, (struct timezone *)(void *)0);
  return (unsigned long int)tv.tv_sec * (unsigned long int)1000 + (unsigned long int)tv.tv_usec / (unsigned long int)1000;
}

// ec_protect_list_blocks
// file ec_protect.c line 302
static signed int ec_protect_list_blocks(struct s3backer_store *s3b, void (*callback)(void *, unsigned int), void *arg)
{
  struct ec_protect_private * const priv = (struct ec_protect_private *)s3b->data;
  struct cbinfo cbinfo;
  signed int r;
  r=priv->inner->list_blocks(priv->inner, callback, arg);
  if(!(r == 0))
    return r;

  else
  {
    cbinfo.callback = callback;
    cbinfo.arg = arg;
    pthread_mutex_lock(&priv->mutex);
    s3b_hash_foreach(priv->hashtable, ec_protect_dirty_callback, (void *)&cbinfo);
    pthread_mutex_unlock(&priv->mutex);
    return 0;
  }
}

// ec_protect_meta_data
// file ec_protect.c line 230
static signed int ec_protect_meta_data(struct s3backer_store *s3b, signed long int *file_sizep, unsigned int *block_sizep)
{
  struct ec_protect_private * const priv = (struct ec_protect_private *)s3b->data;
  signed int return_value;
  return_value=priv->inner->meta_data(priv->inner, file_sizep, block_sizep);
  return return_value;
}

// ec_protect_read_block
// file ec_protect.c line 319
static signed int ec_protect_read_block(struct s3backer_store * const s3b, unsigned int block_num, void *dest, unsigned char *actual_md5, const unsigned char *expect_md5, signed int strict)
{
  struct ec_protect_private * const priv = (struct ec_protect_private *)s3b->data;
  struct ec_protect_conf * const ec_protect_read_block$$1$$config = priv->config;
  unsigned char md5[16l];
  struct block_info *binfo;
  signed int return_value_memcmp$2;
  signed int return_value_memcmp$4;
  if(ec_protect_read_block$$1$$config->block_size == 0u)
    return 22;

  else
  {
    pthread_mutex_lock(&priv->mutex);

  __CPROVER_DUMP_L2:
    ;
    unsigned long int return_value_ec_protect_get_time$1;
    return_value_ec_protect_get_time$1=ec_protect_get_time();
    ec_protect_scrub_expired_writtens(priv, return_value_ec_protect_get_time$1);
    void *return_value_s3b_hash_get$5;
    return_value_s3b_hash_get$5=s3b_hash_get(priv->hashtable, block_num);
    binfo = (struct block_info *)return_value_s3b_hash_get$5;
    if(!(binfo == ((struct block_info *)NULL)))
    {
      if(binfo->timestamp == 0ul)
      {
        if(binfo->u.data == NULL)
          memset(dest, 0, (unsigned long int)ec_protect_read_block$$1$$config->block_size);

        else
          memcpy(dest, binfo->u.data, (unsigned long int)ec_protect_read_block$$1$$config->block_size);
        if(!(actual_md5 == ((unsigned char *)NULL)))
          memset((void *)actual_md5, 0, (unsigned long int)16);

        priv->stats.cache_data_hits = priv->stats.cache_data_hits + 1u;
        pthread_mutex_unlock(&priv->mutex);
        return 0;
      }

      signed int return_value_memcmp$3;
      return_value_memcmp$3=memcmp((const void *)binfo->u.md5, (const void *)zero_md5, (unsigned long int)16);
      if(return_value_memcmp$3 == 0)
      {
        if(!(expect_md5 == ((const unsigned char *)NULL)) && !(strict == 0))
        {
          return_value_memcmp$2=memcmp((const void *)expect_md5, (const void *)zero_md5, (unsigned long int)16);
          if(!(return_value_memcmp$2 == 0))
            ec_protect_read_block$$1$$config->log(3, "ec_protect_read_block(): impossible expected MD5?");

        }

        memset(dest, 0, (unsigned long int)ec_protect_read_block$$1$$config->block_size);
        if(!(actual_md5 == ((unsigned char *)NULL)))
          memset((void *)actual_md5, 0, (unsigned long int)16);

        priv->stats.cache_data_hits = priv->stats.cache_data_hits + 1u;
        pthread_mutex_unlock(&priv->mutex);
        return 0;
      }

      memcpy((void *)md5, (const void *)binfo->u.md5, (unsigned long int)16);
      if(!(expect_md5 == ((const unsigned char *)NULL)) && !(strict == 0))
      {
        return_value_memcmp$4=memcmp((const void *)md5, (const void *)expect_md5, (unsigned long int)16);
        if(!(return_value_memcmp$4 == 0))
          ec_protect_read_block$$1$$config->log(3, "ec_protect_read_block(): impossible expected MD5?");

      }

      expect_md5 = md5;
      strict = 1;
    }

    pthread_mutex_unlock(&priv->mutex);
    signed int return_value;
    return_value=priv->inner->read_block(priv->inner, block_num, dest, actual_md5, expect_md5, strict);
    return return_value;
  }
}

// ec_protect_read_block_part
// file ec_protect.c line 508
static signed int ec_protect_read_block_part(struct s3backer_store *s3b, unsigned int block_num, unsigned int off, unsigned int len, void *dest)
{
  struct ec_protect_private * const priv = (struct ec_protect_private *)s3b->data;
  struct ec_protect_conf * const ec_protect_read_block_part$$1$$config = priv->config;
  signed int return_value_block_part_read_block_part$1;
  return_value_block_part_read_block_part$1=block_part_read_block_part(s3b, block_num, ec_protect_read_block_part$$1$$config->block_size, off, len, dest);
  return return_value_block_part_read_block_part$1;
}

// ec_protect_scrub_expired_writtens
// file ec_protect.c line 542
static void ec_protect_scrub_expired_writtens(struct ec_protect_private *priv, unsigned long int current_time)
{
  struct ec_protect_conf * const ec_protect_scrub_expired_writtens$$1$$config = priv->config;
  struct block_info *binfo;
  signed int num_removed = 0;
  if(ec_protect_scrub_expired_writtens$$1$$config->cache_time >= 1u)
    do
    {
      binfo = (&priv->list)->tqh_first;
      if(binfo == ((struct block_info *)NULL))
        break;

      if(!(current_time >= binfo->timestamp + (unsigned long int)ec_protect_scrub_expired_writtens$$1$$config->cache_time))
        break;

      do
      {
        if(!(binfo->link.tqe_next == ((struct block_info *)NULL)))
          binfo->link.tqe_next->link.tqe_prev = binfo->link.tqe_prev;

        else
          (&priv->list)->tqh_last = binfo->link.tqe_prev;
        *binfo->link.tqe_prev = binfo->link.tqe_next;
      }
      while((_Bool)0);
      s3b_hash_remove(priv->hashtable, binfo->block_num);
      free((void *)binfo);
      num_removed = num_removed + 1;
    }
    while((_Bool)1);

  switch(num_removed)
  {
    case 0:
      break;
    case 1:
    {
      pthread_cond_signal(&priv->space_cond);
      break;
    }
    default:
      pthread_cond_broadcast(&priv->space_cond);
  }
}

// ec_protect_set_mounted
// file ec_protect.c line 238
static signed int ec_protect_set_mounted(struct s3backer_store *s3b, signed int *old_valuep, signed int new_value)
{
  struct ec_protect_private * const priv = (struct ec_protect_private *)s3b->data;
  signed int return_value;
  return_value=priv->inner->set_mounted(priv->inner, old_valuep, new_value);
  return return_value;
}

// ec_protect_sleep_until
// file ec_protect.c line 576
static unsigned long int ec_protect_sleep_until(struct ec_protect_private *priv, union anonymous$0 *cond, unsigned long int wake_time_millis)
{
  unsigned long int time_before;
  unsigned long int time_after;
  if(cond == ((union anonymous$0 *)NULL))
    cond = &priv->never_cond;

  time_before=ec_protect_get_time();
  priv->num_sleepers = priv->num_sleepers + 1u;
  if(!(wake_time_millis == 0ul))
  {
    struct timespec wake_time;
    wake_time.tv_sec = (signed long int)(wake_time_millis / (unsigned long int)1000);
    wake_time.tv_nsec = (signed long int)((wake_time_millis % (unsigned long int)1000) * (unsigned long int)1000000);
    signed int return_value_pthread_cond_timedwait$1;
    return_value_pthread_cond_timedwait$1=pthread_cond_timedwait(cond, &priv->mutex, &wake_time);
    if(return_value_pthread_cond_timedwait$1 == 110)
      time_after = wake_time_millis;

    else
      time_after=ec_protect_get_time();
  }

  else
  {
    pthread_cond_wait(cond, &priv->mutex);
    time_after=ec_protect_get_time();
  }
  priv->num_sleepers = priv->num_sleepers - 1u;
  if(priv->num_sleepers == 0u)
    pthread_cond_broadcast(&priv->sleepers_cond);

  return time_after - time_before;
}

// ec_protect_write_block
// file ec_protect.c line 382
static signed int ec_protect_write_block(struct s3backer_store * const s3b, unsigned int block_num, const void *src, unsigned char *caller_md5, signed int (*check_cancel)(void *, unsigned int), void *check_cancel_arg)
{
  struct ec_protect_private * const priv = (struct ec_protect_private *)s3b->data;
  struct ec_protect_conf * const ec_protect_write_block$$1$$config = priv->config;
  unsigned char md5[16l];
  struct block_info *binfo;
  unsigned long int current_time;
  unsigned long int delay;
  signed int r;
  void *return_value_s3b_hash_get$1;
  _Bool tmp_if_expr$2;
  if(ec_protect_write_block$$1$$config->block_size == 0u)
    return 22;

  else
  {
    pthread_mutex_lock(&priv->mutex);
    do
    {

    again:
      ;
      current_time=ec_protect_get_time();
      ec_protect_scrub_expired_writtens(priv, current_time);
      return_value_s3b_hash_get$1=s3b_hash_get(priv->hashtable, block_num);
      binfo = (struct block_info *)return_value_s3b_hash_get$1;
      if(binfo == ((struct block_info *)NULL))
      {
        unsigned int return_value_s3b_hash_size$3;
        return_value_s3b_hash_size$3=s3b_hash_size(priv->hashtable);
        if(return_value_s3b_hash_size$3 >= ec_protect_write_block$$1$$config->cache_size)
        {
          if(ec_protect_write_block$$1$$config->cache_time == 0u)
            ec_protect_write_block$$1$$config->log(3, "md5 cache is full, but timeout is infinite: you have write deadlock!");

          binfo = (&priv->list)->tqh_first;
          if(!(binfo == ((struct block_info *)NULL)))
            tmp_if_expr$2 = ec_protect_write_block$$1$$config->cache_time > (unsigned int)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr$2 = (_Bool)0;
          if(tmp_if_expr$2)
            delay=ec_protect_sleep_until(priv, &priv->space_cond, binfo->timestamp + (unsigned long int)ec_protect_write_block$$1$$config->cache_time);

          else
            delay=ec_protect_sleep_until(priv, &priv->space_cond, (unsigned long int)0);
          priv->stats.cache_full_delay = priv->stats.cache_full_delay + delay;
          goto again;
        }

        void *return_value_calloc$6;
        return_value_calloc$6=calloc((unsigned long int)1, sizeof(struct block_info) /*48ul*/ );
        binfo = (struct block_info *)return_value_calloc$6;
        if(binfo == ((struct block_info *)NULL))
        {
          signed int *return_value___errno_location$4;
          return_value___errno_location$4=__errno_location();
          r = *return_value___errno_location$4;
          char *return_value_strerror$5;
          return_value_strerror$5=strerror(r);
          ec_protect_write_block$$1$$config->log(3, "can't alloc new MD5 cache entry: %s", return_value_strerror$5);
          priv->stats.out_of_memory_errors = priv->stats.out_of_memory_errors + 1u;
          pthread_mutex_unlock(&priv->mutex);
          return r;
        }

        binfo->block_num = block_num;
        binfo->u.data = src;
        s3b_hash_put_new(priv->hashtable, (void *)binfo);

      writeit:
        ;
        pthread_mutex_unlock(&priv->mutex);
        r=priv->inner->write_block(priv->inner, block_num, src, md5, check_cancel, check_cancel_arg);
        pthread_mutex_lock(&priv->mutex);
        if(!(r == 0))
        {
          s3b_hash_remove(priv->hashtable, block_num);
          pthread_cond_signal(&priv->space_cond);
          pthread_mutex_unlock(&priv->mutex);
          free((void *)binfo);
          return r;
        }

        pthread_cond_signal(&priv->space_cond);
        binfo->timestamp=ec_protect_get_time();
        memcpy((void *)binfo->u.md5, (const void *)md5, (unsigned long int)16);
        binfo->link.tqe_next = (struct block_info *)(void *)0;
        binfo->link.tqe_prev = (&priv->list)->tqh_last;
        *(&priv->list)->tqh_last = binfo;
        (&priv->list)->tqh_last = &binfo->link.tqe_next;
        pthread_mutex_unlock(&priv->mutex);
        if(!(caller_md5 == ((unsigned char *)NULL)))
          memcpy((void *)caller_md5, (const void *)md5, (unsigned long int)16);

        return 0;
      }

      if(binfo->timestamp == 0ul)
      {
        delay=ec_protect_sleep_until(priv, (union anonymous$0 *)(void *)0, current_time + (unsigned long int)ec_protect_write_block$$1$$config->min_write_delay);
        priv->stats.repeated_write_delay = priv->stats.repeated_write_delay + delay;
        goto again;
      }

      if(current_time >= binfo->timestamp + (unsigned long int)ec_protect_write_block$$1$$config->min_write_delay)
        break;

      delay=ec_protect_sleep_until(priv, (union anonymous$0 *)(void *)0, binfo->timestamp + (unsigned long int)ec_protect_write_block$$1$$config->min_write_delay);
      priv->stats.repeated_write_delay = priv->stats.repeated_write_delay + delay;
    }
    while((_Bool)1);
    binfo->timestamp = (unsigned long int)0;
    binfo->u.data = src;
    do
    {
      if(!(binfo->link.tqe_next == ((struct block_info *)NULL)))
        binfo->link.tqe_next->link.tqe_prev = binfo->link.tqe_prev;

      else
        (&priv->list)->tqh_last = binfo->link.tqe_prev;
      *binfo->link.tqe_prev = binfo->link.tqe_next;
    }
    while((_Bool)0);
    goto writeit;
  }
}

// ec_protect_write_block_part
// file ec_protect.c line 517
static signed int ec_protect_write_block_part(struct s3backer_store *s3b, unsigned int block_num, unsigned int off, unsigned int len, const void *src)
{
  struct ec_protect_private * const priv = (struct ec_protect_private *)s3b->data;
  struct ec_protect_conf * const ec_protect_write_block_part$$1$$config = priv->config;
  signed int return_value_block_part_write_block_part$1;
  return_value_block_part_write_block_part$1=block_part_write_block_part(s3b, block_num, ec_protect_write_block_part$$1$$config->block_size, off, len, src);
  return return_value_block_part_write_block_part$1;
}

// erase_list_callback
// file erase.c line 169
static void erase_list_callback(void *arg, unsigned int block_num)
{
  struct erase_state * const priv = (struct erase_state *)arg;
  pthread_mutex_lock(&priv->mutex);
  while(priv->qlen == 1000u)
    pthread_cond_wait(&priv->queue_not_full, &priv->mutex);
  unsigned int tmp_post$1 = priv->qlen;
  priv->qlen = priv->qlen + 1u;
  priv->queue[(signed long int)tmp_post$1] = block_num;
  pthread_cond_signal(&priv->thread_wakeup);
  pthread_mutex_unlock(&priv->mutex);
}

// erase_thread_main
// file erase.c line 182
static void * erase_thread_main(void *arg)
{
  struct erase_state * const priv = (struct erase_state *)arg;
  unsigned int block_num;
  signed int r;
  pthread_mutex_lock(&priv->mutex);
  while((_Bool)1)
    if(priv->qlen >= 1u)
    {
      if(priv->qlen == 1000u)
        pthread_cond_signal(&priv->queue_not_full);

      priv->qlen = priv->qlen - 1u;
      block_num = priv->queue[(signed long int)priv->qlen];
      pthread_mutex_unlock(&priv->mutex);
      r=priv->s3b->write_block(priv->s3b, block_num, (void *)0, (unsigned char *)(void *)0, (signed int (*)(void *, unsigned int))(void *)0, (void *)0);
      pthread_mutex_lock(&priv->mutex);
      if(!(r == 0))
      {
        char *return_value_strerror$1;
        return_value_strerror$1=strerror(r);
        warnx("can't delete block %0*jx: %s", (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)block_num, return_value_strerror$1);
        continue;
      }

      priv->count = priv->count + 1ul;
      if(priv->count % 256ul == 0ul)
      {
        if(priv->quiet == 0)
        {
          fprintf(stderr, ".");
          fflush(stderr);
        }

      }

    }

    else
    {
      if(!(priv->stopping == 0))
        break;

      pthread_cond_wait(&priv->thread_wakeup, &priv->mutex);
    }
  pthread_mutex_unlock(&priv->mutex);
  return (void *)0;
}

// get_time
// file tester.c line 218
static unsigned long int get_time(void)
{
  struct timeval tv;
  gettimeofday(&tv, (struct timezone *)(void *)0);
  return (unsigned long int)tv.tv_sec * (unsigned long int)1000 + (unsigned long int)tv.tv_usec / (unsigned long int)1000;
}

// handle_unknown_option
// file s3b_config.c line 810
static signed int handle_unknown_option(void *data, const char *arg, signed int key, struct fuse_args *outargs)
{
  _Bool tmp_if_expr$4;
  signed int return_value_strcmp$3;
  _Bool tmp_if_expr$7;
  signed int return_value_strcmp$6;
  _Bool tmp_if_expr$10;
  signed int return_value_strcmp$9;
  _Bool tmp_if_expr$12;
  signed int return_value_strcmp$11;
  if(key == -1)
  {
    signed int return_value_strcmp$1;
    return_value_strcmp$1=strcmp(arg, "-d");
    if(return_value_strcmp$1 == 0)
      config$link1.debug = 1;

    signed int return_value_strcmp$2;
    return_value_strcmp$2=strcmp(arg, "-d");
    if(return_value_strcmp$2 == 0)
      tmp_if_expr$4 = (_Bool)1;

    else
    {
      return_value_strcmp$3=strcmp(arg, "-f");
      tmp_if_expr$4 = return_value_strcmp$3 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$4)
      config$link1.log = stderr_logger;

    signed int return_value_strcmp$5;
    return_value_strcmp$5=strcmp(arg, "--version");
    if(return_value_strcmp$5 == 0)
      tmp_if_expr$7 = (_Bool)1;

    else
    {
      return_value_strcmp$6=strcmp(arg, "-v");
      tmp_if_expr$7 = return_value_strcmp$6 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$7)
    {
      fprintf(stderr, "%s version %s (%s)\n", (const void *)"s3backer", (const void *)"1.4.2", s3backer_version);
      fprintf(stderr, "Copyright (C) 2008-2011 Archie L. Cobbs.\n");
      fprintf(stderr, "This is free software; see the source for copying conditions.  There is NO\n");
      fprintf(stderr, "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n");
      exit(0);
    }

    signed int return_value_strcmp$8;
    return_value_strcmp$8=strcmp(arg, "--help");
    if(return_value_strcmp$8 == 0)
      tmp_if_expr$10 = (_Bool)1;

    else
    {
      return_value_strcmp$9=strcmp(arg, "-h");
      tmp_if_expr$10 = return_value_strcmp$9 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$10)
      tmp_if_expr$12 = (_Bool)1;

    else
    {
      return_value_strcmp$11=strcmp(arg, "-?");
      tmp_if_expr$12 = return_value_strcmp$11 == 0 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr$12)
    {
      usage();
      exit(0);
    }

    return 1;
  }

  if(config$link1.http_io.bucket == ((const char *)NULL))
  {
    config$link1.http_io.bucket=strdup(arg);
    if(config$link1.http_io.bucket == ((const char *)NULL))
      err(1, "strdup");

    return 0;
  }

  else
    if(config$link1.mount == ((const char *)NULL))
    {
      config$link1.mount=strdup(arg);
      if(config$link1.mount == ((const char *)NULL))
        err(1, "strdup");

      return 1;
    }

    else
      return 1;
}

// http_io_acquire_curl
// file http_io.c line 2297
static void * http_io_acquire_curl(struct http_io_private *priv, struct http_io *io)
{
  struct http_io_conf * const http_io_acquire_curl$$1$$config = priv->config;
  struct curl_holder *holder;
  void *curl;
  pthread_mutex_lock(&priv->mutex);
  holder = (&priv->curls)->lh_first;
  if(!(holder == ((struct curl_holder *)NULL)))
  {
    curl = holder->curl;
    do
    {
      if(!(holder->link.le_next == ((struct curl_holder *)NULL)))
        holder->link.le_next->link.le_prev = holder->link.le_prev;

      *holder->link.le_prev = holder->link.le_next;
    }
    while((_Bool)0);
    priv->stats.curl_handles_reused = priv->stats.curl_handles_reused + 1u;
    pthread_mutex_unlock(&priv->mutex);
    free((void *)holder);
    curl_easy_reset(curl);
  }

  else
  {
    priv->stats.curl_handles_created = priv->stats.curl_handles_created + 1u;
    pthread_mutex_unlock(&priv->mutex);
    curl=curl_easy_init();
    if(curl == NULL)
    {
      pthread_mutex_lock(&priv->mutex);
      priv->stats.curl_handles_created = priv->stats.curl_handles_created - 1u;
      priv->stats.curl_other_error = priv->stats.curl_other_error + 1u;
      pthread_mutex_unlock(&priv->mutex);
      http_io_acquire_curl$$1$$config->log(3, "curl_easy_init() failed");
      return (void *)0;
    }

  }
  signed int http_io_acquire_curl$$1$$3$$_curl_opt = CURLOPT_URL;
  curl_easy_setopt(curl, (enum anonymous$12)http_io_acquire_curl$$1$$3$$_curl_opt, io->url);
  signed int http_io_acquire_curl$$1$$4$$_curl_opt = CURLOPT_FAILONERROR;
  curl_easy_setopt(curl, (enum anonymous$12)http_io_acquire_curl$$1$$4$$_curl_opt, 1);
  signed int http_io_acquire_curl$$1$$5$$_curl_opt = CURLOPT_FOLLOWLOCATION;
  curl_easy_setopt(curl, (enum anonymous$12)http_io_acquire_curl$$1$$5$$_curl_opt, 1);
  signed int http_io_acquire_curl$$1$$6$$_curl_opt = CURLOPT_NOSIGNAL;
  if((_Bool)0)
  {
    if(http_io_acquire_curl$$1$$6$$_curl_opt >= 30001)
    {
      goto __CPROVER_DUMP_L66;
      _curl_easy_setopt_err_curl_off_t();
    }


  __CPROVER_DUMP_L66:
    ;
    if(http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_URL || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_PROXY || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_USERPWD || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_PROXYUSERPWD || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_RANGE || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_REFERER || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_FTPPORT || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_USERAGENT || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_COOKIE || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_SSLCERT || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_KEYPASSWD || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_COOKIEFILE || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_CUSTOMREQUEST || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_INTERFACE || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_KRBLEVEL || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_CAINFO || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_RANDOM_FILE || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_EGDSOCKET || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_COOKIEJAR || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_SSL_CIPHER_LIST || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_SSLCERTTYPE || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_SSLKEY || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_SSLKEYTYPE || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_SSLENGINE || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_CAPATH || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_ACCEPT_ENCODING || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_NETRC_FILE || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_FTP_ACCOUNT || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_COOKIELIST || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_FTP_ALTERNATIVE_TO_USER || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_SSH_PUBLIC_KEYFILE || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_SSH_PRIVATE_KEYFILE || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_SSH_HOST_PUBLIC_KEY_MD5 || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_CRLFILE || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_ISSUERCERT || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_USERNAME || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_PASSWORD || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_PROXYUSERNAME || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_PROXYPASSWORD || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_NOPROXY || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_SOCKS5_GSSAPI_SERVICE || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_SSH_KNOWNHOSTS || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_MAIL_FROM || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_RTSP_SESSION_ID || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_RTSP_STREAM_URI || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_RTSP_TRANSPORT || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_TLSAUTH_USERNAME || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_TLSAUTH_PASSWORD || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_TLSAUTH_TYPE || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_DNS_SERVERS || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_MAIL_AUTH || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_XOAUTH2_BEARER || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_DNS_INTERFACE || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_DNS_LOCAL_IP4 || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_DNS_LOCAL_IP6 || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_LOGIN_OPTIONS || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_PINNEDPUBLICKEY || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_UNIX_SOCKET_PATH || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_PROXY_SERVICE_NAME || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_SERVICE_NAME || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_DEFAULT_PROTOCOL)
      _curl_easy_setopt_err_string();

    if(http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_WRITEFUNCTION || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_HEADERFUNCTION)
      _curl_easy_setopt_err_write_callback();

    if(http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_READFUNCTION)
      _curl_easy_setopt_err_read_cb();

    if(http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_IOCTLFUNCTION)
      _curl_easy_setopt_err_ioctl_cb();

    if(http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_SOCKOPTFUNCTION)
      _curl_easy_setopt_err_sockopt_cb();

    if(http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_OPENSOCKETFUNCTION)
      _curl_easy_setopt_err_opensocket_cb();

    if(http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_PROGRESSFUNCTION)
      _curl_easy_setopt_err_progress_cb();

    if(http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_DEBUGFUNCTION)
      _curl_easy_setopt_err_debug_cb();

    if(http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_SSL_CTX_FUNCTION)
      _curl_easy_setopt_err_ssl_ctx_cb();

    if(http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_CONV_FROM_NETWORK_FUNCTION || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_CONV_TO_NETWORK_FUNCTION || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_CONV_FROM_UTF8_FUNCTION)
      _curl_easy_setopt_err_conv_cb();

    if(http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_SEEKFUNCTION)
      _curl_easy_setopt_err_seek_cb();

    if(http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_ERRORBUFFER)
      _curl_easy_setopt_err_error_buffer();

    if(http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_STDERR)
      _curl_easy_setopt_err_FILE();

    if(http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_POSTFIELDS || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_COPYPOSTFIELDS)
      _curl_easy_setopt_err_postfields();

    if(http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_HTTPPOST)
      _curl_easy_setopt_err_curl_httpost();

    if(http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_HTTPHEADER || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_QUOTE || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_POSTQUOTE || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_TELNETOPTIONS || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_PREQUOTE || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_HTTP200ALIASES || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_MAIL_RCPT || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_RESOLVE || http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_PROXYHEADER)
      _curl_easy_setopt_err_curl_slist();

    if(http_io_acquire_curl$$1$$6$$_curl_opt == CURLOPT_SHARE)
      _curl_easy_setopt_err_CURLSH();

  }

  curl_easy_setopt(curl, (enum anonymous$12)http_io_acquire_curl$$1$$6$$_curl_opt, (signed long int)1);
  signed int http_io_acquire_curl$$1$$7$$_curl_opt = CURLOPT_TIMEOUT;
  if((_Bool)0)
  {
    if(http_io_acquire_curl$$1$$7$$_curl_opt >= 30001)
    {
      goto __CPROVER_DUMP_L86;
      _curl_easy_setopt_err_curl_off_t();
    }


  __CPROVER_DUMP_L86:
    ;
    if(http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_URL || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_PROXY || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_USERPWD || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_PROXYUSERPWD || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_RANGE || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_REFERER || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_FTPPORT || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_USERAGENT || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_COOKIE || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_SSLCERT || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_KEYPASSWD || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_COOKIEFILE || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_CUSTOMREQUEST || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_INTERFACE || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_KRBLEVEL || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_CAINFO || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_RANDOM_FILE || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_EGDSOCKET || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_COOKIEJAR || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_SSL_CIPHER_LIST || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_SSLCERTTYPE || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_SSLKEY || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_SSLKEYTYPE || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_SSLENGINE || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_CAPATH || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_ACCEPT_ENCODING || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_NETRC_FILE || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_FTP_ACCOUNT || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_COOKIELIST || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_FTP_ALTERNATIVE_TO_USER || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_SSH_PUBLIC_KEYFILE || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_SSH_PRIVATE_KEYFILE || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_SSH_HOST_PUBLIC_KEY_MD5 || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_CRLFILE || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_ISSUERCERT || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_USERNAME || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_PASSWORD || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_PROXYUSERNAME || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_PROXYPASSWORD || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_NOPROXY || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_SOCKS5_GSSAPI_SERVICE || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_SSH_KNOWNHOSTS || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_MAIL_FROM || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_RTSP_SESSION_ID || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_RTSP_STREAM_URI || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_RTSP_TRANSPORT || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_TLSAUTH_USERNAME || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_TLSAUTH_PASSWORD || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_TLSAUTH_TYPE || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_DNS_SERVERS || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_MAIL_AUTH || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_XOAUTH2_BEARER || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_DNS_INTERFACE || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_DNS_LOCAL_IP4 || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_DNS_LOCAL_IP6 || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_LOGIN_OPTIONS || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_PINNEDPUBLICKEY || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_UNIX_SOCKET_PATH || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_PROXY_SERVICE_NAME || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_SERVICE_NAME || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_DEFAULT_PROTOCOL)
      _curl_easy_setopt_err_string();

    if(http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_WRITEFUNCTION || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_HEADERFUNCTION)
      _curl_easy_setopt_err_write_callback();

    if(http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_READFUNCTION)
      _curl_easy_setopt_err_read_cb();

    if(http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_IOCTLFUNCTION)
      _curl_easy_setopt_err_ioctl_cb();

    if(http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_SOCKOPTFUNCTION)
      _curl_easy_setopt_err_sockopt_cb();

    if(http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_OPENSOCKETFUNCTION)
      _curl_easy_setopt_err_opensocket_cb();

    if(http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_PROGRESSFUNCTION)
      _curl_easy_setopt_err_progress_cb();

    if(http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_DEBUGFUNCTION)
      _curl_easy_setopt_err_debug_cb();

    if(http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_SSL_CTX_FUNCTION)
      _curl_easy_setopt_err_ssl_ctx_cb();

    if(http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_CONV_FROM_NETWORK_FUNCTION || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_CONV_TO_NETWORK_FUNCTION || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_CONV_FROM_UTF8_FUNCTION)
      _curl_easy_setopt_err_conv_cb();

    if(http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_SEEKFUNCTION)
      _curl_easy_setopt_err_seek_cb();

    if(http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_ERRORBUFFER)
      _curl_easy_setopt_err_error_buffer();

    if(http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_STDERR)
      _curl_easy_setopt_err_FILE();

    if(http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_POSTFIELDS || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_COPYPOSTFIELDS)
      _curl_easy_setopt_err_postfields();

    if(http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_HTTPPOST)
      _curl_easy_setopt_err_curl_httpost();

    if(http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_HTTPHEADER || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_QUOTE || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_POSTQUOTE || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_TELNETOPTIONS || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_PREQUOTE || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_HTTP200ALIASES || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_MAIL_RCPT || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_RESOLVE || http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_PROXYHEADER)
      _curl_easy_setopt_err_curl_slist();

    if(http_io_acquire_curl$$1$$7$$_curl_opt == CURLOPT_SHARE)
      _curl_easy_setopt_err_CURLSH();

  }

  curl_easy_setopt(curl, (enum anonymous$12)http_io_acquire_curl$$1$$7$$_curl_opt, (signed long int)http_io_acquire_curl$$1$$config->timeout);
  signed int http_io_acquire_curl$$1$$8$$_curl_opt = CURLOPT_NOPROGRESS;
  curl_easy_setopt(curl, (enum anonymous$12)http_io_acquire_curl$$1$$8$$_curl_opt, 1);
  signed int http_io_acquire_curl$$1$$9$$_curl_opt = CURLOPT_USERAGENT;
  curl_easy_setopt(curl, (enum anonymous$12)http_io_acquire_curl$$1$$9$$_curl_opt, http_io_acquire_curl$$1$$config->user_agent);
  if(!(http_io_acquire_curl$$1$$config->max_speed[1l] == 0ul))
  {
    signed int http_io_acquire_curl$$1$$10$$_curl_opt = CURLOPT_MAX_SEND_SPEED_LARGE;
    if((_Bool)0)
    {
      if(http_io_acquire_curl$$1$$10$$_curl_opt >= 30001)
      {
        goto __CPROVER_DUMP_L146;
        _curl_easy_setopt_err_curl_off_t();
      }


    __CPROVER_DUMP_L146:
      ;
      if(http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_URL || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_PROXY || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_USERPWD || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_PROXYUSERPWD || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_RANGE || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_REFERER || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_FTPPORT || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_USERAGENT || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_COOKIE || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_SSLCERT || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_KEYPASSWD || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_COOKIEFILE || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_CUSTOMREQUEST || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_INTERFACE || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_KRBLEVEL || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_CAINFO || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_RANDOM_FILE || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_EGDSOCKET || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_COOKIEJAR || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_SSL_CIPHER_LIST || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_SSLCERTTYPE || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_SSLKEY || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_SSLKEYTYPE || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_SSLENGINE || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_CAPATH || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_ACCEPT_ENCODING || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_NETRC_FILE || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_FTP_ACCOUNT || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_COOKIELIST || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_FTP_ALTERNATIVE_TO_USER || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_SSH_PUBLIC_KEYFILE || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_SSH_PRIVATE_KEYFILE || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_SSH_HOST_PUBLIC_KEY_MD5 || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_CRLFILE || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_ISSUERCERT || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_USERNAME || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_PASSWORD || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_PROXYUSERNAME || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_PROXYPASSWORD || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_NOPROXY || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_SOCKS5_GSSAPI_SERVICE || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_SSH_KNOWNHOSTS || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_MAIL_FROM || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_RTSP_SESSION_ID || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_RTSP_STREAM_URI || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_RTSP_TRANSPORT || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_TLSAUTH_USERNAME || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_TLSAUTH_PASSWORD || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_TLSAUTH_TYPE || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_DNS_SERVERS || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_MAIL_AUTH || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_XOAUTH2_BEARER || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_DNS_INTERFACE || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_DNS_LOCAL_IP4 || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_DNS_LOCAL_IP6 || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_LOGIN_OPTIONS || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_PINNEDPUBLICKEY || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_UNIX_SOCKET_PATH || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_PROXY_SERVICE_NAME || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_SERVICE_NAME || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_DEFAULT_PROTOCOL)
        _curl_easy_setopt_err_string();

      if(http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_WRITEFUNCTION || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_HEADERFUNCTION)
        _curl_easy_setopt_err_write_callback();

      if(http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_READFUNCTION)
        _curl_easy_setopt_err_read_cb();

      if(http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_IOCTLFUNCTION)
        _curl_easy_setopt_err_ioctl_cb();

      if(http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_SOCKOPTFUNCTION)
        _curl_easy_setopt_err_sockopt_cb();

      if(http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_OPENSOCKETFUNCTION)
        _curl_easy_setopt_err_opensocket_cb();

      if(http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_PROGRESSFUNCTION)
        _curl_easy_setopt_err_progress_cb();

      if(http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_DEBUGFUNCTION)
        _curl_easy_setopt_err_debug_cb();

      if(http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_SSL_CTX_FUNCTION)
        _curl_easy_setopt_err_ssl_ctx_cb();

      if(http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_CONV_FROM_NETWORK_FUNCTION || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_CONV_TO_NETWORK_FUNCTION || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_CONV_FROM_UTF8_FUNCTION)
        _curl_easy_setopt_err_conv_cb();

      if(http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_SEEKFUNCTION)
        _curl_easy_setopt_err_seek_cb();

      if(http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_ERRORBUFFER)
        _curl_easy_setopt_err_error_buffer();

      if(http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_STDERR)
        _curl_easy_setopt_err_FILE();

      if(http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_POSTFIELDS || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_COPYPOSTFIELDS)
        _curl_easy_setopt_err_postfields();

      if(http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_HTTPPOST)
        _curl_easy_setopt_err_curl_httpost();

      if(http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_HTTPHEADER || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_QUOTE || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_POSTQUOTE || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_TELNETOPTIONS || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_PREQUOTE || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_HTTP200ALIASES || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_MAIL_RCPT || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_RESOLVE || http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_PROXYHEADER)
        _curl_easy_setopt_err_curl_slist();

      if(http_io_acquire_curl$$1$$10$$_curl_opt == CURLOPT_SHARE)
        _curl_easy_setopt_err_CURLSH();

    }

    curl_easy_setopt(curl, (enum anonymous$12)http_io_acquire_curl$$1$$10$$_curl_opt, (signed long int)(http_io_acquire_curl$$1$$config->max_speed[(signed long int)1] / (unsigned long int)8));
  }

  if(!(http_io_acquire_curl$$1$$config->max_speed[0l] == 0ul))
  {
    signed int http_io_acquire_curl$$1$$11$$_curl_opt = CURLOPT_MAX_RECV_SPEED_LARGE;
    if((_Bool)0)
    {
      if(http_io_acquire_curl$$1$$11$$_curl_opt >= 30001)
      {
        goto __CPROVER_DUMP_L167;
        _curl_easy_setopt_err_curl_off_t();
      }


    __CPROVER_DUMP_L167:
      ;
      if(http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_URL || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_PROXY || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_USERPWD || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_PROXYUSERPWD || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_RANGE || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_REFERER || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_FTPPORT || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_USERAGENT || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_COOKIE || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_SSLCERT || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_KEYPASSWD || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_COOKIEFILE || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_CUSTOMREQUEST || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_INTERFACE || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_KRBLEVEL || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_CAINFO || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_RANDOM_FILE || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_EGDSOCKET || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_COOKIEJAR || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_SSL_CIPHER_LIST || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_SSLCERTTYPE || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_SSLKEY || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_SSLKEYTYPE || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_SSLENGINE || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_CAPATH || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_ACCEPT_ENCODING || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_NETRC_FILE || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_FTP_ACCOUNT || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_COOKIELIST || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_FTP_ALTERNATIVE_TO_USER || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_SSH_PUBLIC_KEYFILE || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_SSH_PRIVATE_KEYFILE || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_SSH_HOST_PUBLIC_KEY_MD5 || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_CRLFILE || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_ISSUERCERT || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_USERNAME || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_PASSWORD || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_PROXYUSERNAME || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_PROXYPASSWORD || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_NOPROXY || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_SOCKS5_GSSAPI_SERVICE || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_SSH_KNOWNHOSTS || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_MAIL_FROM || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_RTSP_SESSION_ID || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_RTSP_STREAM_URI || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_RTSP_TRANSPORT || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_TLSAUTH_USERNAME || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_TLSAUTH_PASSWORD || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_TLSAUTH_TYPE || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_DNS_SERVERS || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_MAIL_AUTH || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_XOAUTH2_BEARER || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_DNS_INTERFACE || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_DNS_LOCAL_IP4 || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_DNS_LOCAL_IP6 || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_LOGIN_OPTIONS || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_PINNEDPUBLICKEY || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_UNIX_SOCKET_PATH || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_PROXY_SERVICE_NAME || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_SERVICE_NAME || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_DEFAULT_PROTOCOL)
        _curl_easy_setopt_err_string();

      if(http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_WRITEFUNCTION || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_HEADERFUNCTION)
        _curl_easy_setopt_err_write_callback();

      if(http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_READFUNCTION)
        _curl_easy_setopt_err_read_cb();

      if(http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_IOCTLFUNCTION)
        _curl_easy_setopt_err_ioctl_cb();

      if(http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_SOCKOPTFUNCTION)
        _curl_easy_setopt_err_sockopt_cb();

      if(http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_OPENSOCKETFUNCTION)
        _curl_easy_setopt_err_opensocket_cb();

      if(http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_PROGRESSFUNCTION)
        _curl_easy_setopt_err_progress_cb();

      if(http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_DEBUGFUNCTION)
        _curl_easy_setopt_err_debug_cb();

      if(http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_SSL_CTX_FUNCTION)
        _curl_easy_setopt_err_ssl_ctx_cb();

      if(http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_CONV_FROM_NETWORK_FUNCTION || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_CONV_TO_NETWORK_FUNCTION || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_CONV_FROM_UTF8_FUNCTION)
        _curl_easy_setopt_err_conv_cb();

      if(http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_SEEKFUNCTION)
        _curl_easy_setopt_err_seek_cb();

      if(http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_ERRORBUFFER)
        _curl_easy_setopt_err_error_buffer();

      if(http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_STDERR)
        _curl_easy_setopt_err_FILE();

      if(http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_POSTFIELDS || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_COPYPOSTFIELDS)
        _curl_easy_setopt_err_postfields();

      if(http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_HTTPPOST)
        _curl_easy_setopt_err_curl_httpost();

      if(http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_HTTPHEADER || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_QUOTE || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_POSTQUOTE || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_TELNETOPTIONS || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_PREQUOTE || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_HTTP200ALIASES || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_MAIL_RCPT || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_RESOLVE || http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_PROXYHEADER)
        _curl_easy_setopt_err_curl_slist();

      if(http_io_acquire_curl$$1$$11$$_curl_opt == CURLOPT_SHARE)
        _curl_easy_setopt_err_CURLSH();

    }

    curl_easy_setopt(curl, (enum anonymous$12)http_io_acquire_curl$$1$$11$$_curl_opt, (signed long int)(http_io_acquire_curl$$1$$config->max_speed[(signed long int)0] / (unsigned long int)8));
  }

  signed int return_value_strncmp$1;
  return_value_strncmp$1=strncmp(io->url, "https", (unsigned long int)5);
  if(return_value_strncmp$1 == 0)
  {
    if(!(http_io_acquire_curl$$1$$config->insecure == 0))
    {
      signed int http_io_acquire_curl$$1$$12$$1$$_curl_opt = CURLOPT_SSL_VERIFYPEER;
      if((_Bool)0)
      {
        if(http_io_acquire_curl$$1$$12$$1$$_curl_opt >= 30001)
        {
          goto __CPROVER_DUMP_L188;
          _curl_easy_setopt_err_curl_off_t();
        }


      __CPROVER_DUMP_L188:
        ;
        if(http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_URL || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_PROXY || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_USERPWD || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_PROXYUSERPWD || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_RANGE || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_REFERER || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_FTPPORT || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_USERAGENT || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_COOKIE || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_SSLCERT || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_KEYPASSWD || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_COOKIEFILE || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_CUSTOMREQUEST || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_INTERFACE || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_KRBLEVEL || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_CAINFO || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_RANDOM_FILE || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_EGDSOCKET || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_COOKIEJAR || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_SSL_CIPHER_LIST || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_SSLCERTTYPE || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_SSLKEY || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_SSLKEYTYPE || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_SSLENGINE || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_CAPATH || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_ACCEPT_ENCODING || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_NETRC_FILE || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_FTP_ACCOUNT || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_COOKIELIST || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_FTP_ALTERNATIVE_TO_USER || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_SSH_PUBLIC_KEYFILE || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_SSH_PRIVATE_KEYFILE || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_SSH_HOST_PUBLIC_KEY_MD5 || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_CRLFILE || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_ISSUERCERT || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_USERNAME || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_PASSWORD || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_PROXYUSERNAME || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_PROXYPASSWORD || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_NOPROXY || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_SOCKS5_GSSAPI_SERVICE || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_SSH_KNOWNHOSTS || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_MAIL_FROM || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_RTSP_SESSION_ID || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_RTSP_STREAM_URI || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_RTSP_TRANSPORT || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_TLSAUTH_USERNAME || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_TLSAUTH_PASSWORD || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_TLSAUTH_TYPE || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_DNS_SERVERS || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_MAIL_AUTH || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_XOAUTH2_BEARER || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_DNS_INTERFACE || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_DNS_LOCAL_IP4 || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_DNS_LOCAL_IP6 || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_LOGIN_OPTIONS || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_PINNEDPUBLICKEY || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_UNIX_SOCKET_PATH || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_PROXY_SERVICE_NAME || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_SERVICE_NAME || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_DEFAULT_PROTOCOL)
          _curl_easy_setopt_err_string();

        if(http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_WRITEFUNCTION || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_HEADERFUNCTION)
          _curl_easy_setopt_err_write_callback();

        if(http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_READFUNCTION)
          _curl_easy_setopt_err_read_cb();

        if(http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_IOCTLFUNCTION)
          _curl_easy_setopt_err_ioctl_cb();

        if(http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_SOCKOPTFUNCTION)
          _curl_easy_setopt_err_sockopt_cb();

        if(http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_OPENSOCKETFUNCTION)
          _curl_easy_setopt_err_opensocket_cb();

        if(http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_PROGRESSFUNCTION)
          _curl_easy_setopt_err_progress_cb();

        if(http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_DEBUGFUNCTION)
          _curl_easy_setopt_err_debug_cb();

        if(http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_SSL_CTX_FUNCTION)
          _curl_easy_setopt_err_ssl_ctx_cb();

        if(http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_CONV_FROM_NETWORK_FUNCTION || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_CONV_TO_NETWORK_FUNCTION || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_CONV_FROM_UTF8_FUNCTION)
          _curl_easy_setopt_err_conv_cb();

        if(http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_SEEKFUNCTION)
          _curl_easy_setopt_err_seek_cb();

        if(http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_ERRORBUFFER)
          _curl_easy_setopt_err_error_buffer();

        if(http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_STDERR)
          _curl_easy_setopt_err_FILE();

        if(http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_POSTFIELDS || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_COPYPOSTFIELDS)
          _curl_easy_setopt_err_postfields();

        if(http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_HTTPPOST)
          _curl_easy_setopt_err_curl_httpost();

        if(http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_HTTPHEADER || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_QUOTE || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_POSTQUOTE || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_TELNETOPTIONS || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_PREQUOTE || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_HTTP200ALIASES || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_MAIL_RCPT || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_RESOLVE || http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_PROXYHEADER)
          _curl_easy_setopt_err_curl_slist();

        if(http_io_acquire_curl$$1$$12$$1$$_curl_opt == CURLOPT_SHARE)
          _curl_easy_setopt_err_CURLSH();

      }

      curl_easy_setopt(curl, (enum anonymous$12)http_io_acquire_curl$$1$$12$$1$$_curl_opt, (signed long int)0);
    }

    if(!(http_io_acquire_curl$$1$$config->cacert == ((const char *)NULL)))
    {
      signed int http_io_acquire_curl$$1$$12$$2$$_curl_opt = CURLOPT_CAINFO;
      curl_easy_setopt(curl, (enum anonymous$12)http_io_acquire_curl$$1$$12$$2$$_curl_opt, http_io_acquire_curl$$1$$config->cacert);
    }

  }

  if(!(http_io_acquire_curl$$1$$config->debug_http == 0))
  {
    signed int _curl_opt = CURLOPT_VERBOSE;
    curl_easy_setopt(curl, (enum anonymous$12)_curl_opt, 1);
  }

  return curl;
}

// http_io_add_auth
// file http_io.c line 1801
static signed int http_io_add_auth(struct http_io_private *priv, struct http_io * const io, signed long int now, const void *payload, unsigned long int plen)
{
  struct http_io_conf * const http_io_add_auth$$1$$config = priv->config;
  signed int return_value_http_io_add_auth2$1;
  signed int return_value_http_io_add_auth4$3;
  if(http_io_add_auth$$1$$config->accessId == ((char *)NULL))
    return 0;

  else
  {
    signed int return_value_strcmp$2;
    return_value_strcmp$2=strcmp(http_io_add_auth$$1$$config->authVersion, "aws2");
    if(return_value_strcmp$2 == 0)
    {
      return_value_http_io_add_auth2$1=http_io_add_auth2(priv, io, now, payload, plen);
      return return_value_http_io_add_auth2$1;
    }

    else
    {
      signed int return_value_strcmp$4;
      return_value_strcmp$4=strcmp(http_io_add_auth$$1$$config->authVersion, "aws4");
      if(return_value_strcmp$4 == 0)
      {
        return_value_http_io_add_auth4$3=http_io_add_auth4(priv, io, now, payload, plen);
        return return_value_http_io_add_auth4$3;
      }

      else
        return 22;
    }
  }
}

// http_io_add_auth2
// file http_io.c line 1823
static signed int http_io_add_auth2(struct http_io_private *priv, struct http_io * const io, signed long int now, const void *payload, unsigned long int plen)
{
  struct http_io_conf * const http_io_add_auth2$$1$$config = priv->config;
  struct curl_slist *header;
  unsigned char hmac[20l];
  const char *resource;
  char **amz_hdrs = (char **)(void *)0;
  char access_id[128l];
  char access_key[128l];
  char authbuf[200l];
  char sigbuf[1l];
  signed int num_amz_hdrs;
  const char *qmark;
  unsigned long int resource_len;
  unsigned int hmac_len;
  struct hmac_ctx_st hmac_ctx;
  signed int i;
  signed int r;
  pthread_mutex_lock(&priv->mutex);
  snprintf(access_id, sizeof(char [128l]) /*128ul*/ , "%s", http_io_add_auth2$$1$$config->accessId);
  snprintf(access_key, sizeof(char [128l]) /*128ul*/ , "%s", http_io_add_auth2$$1$$config->accessKey);
  pthread_mutex_unlock(&priv->mutex);
  HMAC_CTX_init(&hmac_ctx);
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(access_key);
  const struct env_md_st *return_value_EVP_sha1$2;
  return_value_EVP_sha1$2=EVP_sha1();
  HMAC_Init_ex(&hmac_ctx, (const void *)access_key, (signed int)return_value_strlen$1, return_value_EVP_sha1$2, (struct engine_st *)(void *)0);
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(io->method);
  HMAC_Update(&hmac_ctx, (const unsigned char *)io->method, return_value_strlen$3);
  HMAC_Update(&hmac_ctx, (const unsigned char *)"\n", (unsigned long int)1);
  update_hmac_from_header(&hmac_ctx, io, "Content-MD5", 1, sigbuf, sizeof(char [1l]) /*1ul*/ );
  update_hmac_from_header(&hmac_ctx, io, "Content-Type", 1, sigbuf, sizeof(char [1l]) /*1ul*/ );
  update_hmac_from_header(&hmac_ctx, io, "Date", 1, sigbuf, sizeof(char [1l]) /*1ul*/ );
  header = io->headers;
  num_amz_hdrs = 0;
  for( ; !(header == ((struct curl_slist *)NULL)); header = header->next)
  {
    signed int return_value_strncmp$4;
    return_value_strncmp$4=strncmp(header->data, "x-amz", (unsigned long int)5);
    if(return_value_strncmp$4 == 0)
      num_amz_hdrs = num_amz_hdrs + 1;

  }
  void *return_value_malloc$6;
  return_value_malloc$6=malloc((unsigned long int)num_amz_hdrs * sizeof(char *) /*8ul*/ );
  amz_hdrs = (char **)return_value_malloc$6;
  if(amz_hdrs == ((char **)NULL))
  {
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    r = *return_value___errno_location$5;
    goto fail;
  }

  header = io->headers;
  i = 0;
  signed int tmp_post$7;
  for( ; !(header == ((struct curl_slist *)NULL)); header = header->next)
  {
    signed int return_value_strncmp$8;
    return_value_strncmp$8=strncmp(header->data, "x-amz", (unsigned long int)5);
    if(return_value_strncmp$8 == 0)
    {
      tmp_post$7 = i;
      i = i + 1;
      amz_hdrs[(signed long int)tmp_post$7] = header->data;
    }

  }
  qsort((void *)amz_hdrs, (unsigned long int)num_amz_hdrs, sizeof(char *) /*8ul*/ , http_io_strcasecmp_ptr);
  i = 0;
  for( ; !(i >= num_amz_hdrs); i = i + 1)
    update_hmac_from_header(&hmac_ctx, io, amz_hdrs[(signed long int)i], 0, sigbuf, sizeof(char [1l]) /*1ul*/ );
  const char *tmp_if_expr$12;
  unsigned long int return_value_strlen$9;
  unsigned long int return_value_strlen$10;
  unsigned long int return_value_strlen$11;
  if(!(http_io_add_auth2$$1$$config->vhost == 0))
  {
    return_value_strlen$9=strlen(http_io_add_auth2$$1$$config->baseURL);
    tmp_if_expr$12 = (io->url + (signed long int)return_value_strlen$9) - (signed long int)1;
  }

  else
  {
    return_value_strlen$10=strlen(http_io_add_auth2$$1$$config->baseURL);
    return_value_strlen$11=strlen(http_io_add_auth2$$1$$config->bucket);
    tmp_if_expr$12 = io->url + (signed long int)return_value_strlen$10 + (signed long int)return_value_strlen$11;
  }
  resource = tmp_if_expr$12;
  qmark=strchr(resource, 63);
  unsigned long int tmp_if_expr$14;
  unsigned long int return_value_strlen$13;
  if(!(qmark == ((const char *)NULL)))
    tmp_if_expr$14 = (unsigned long int)(qmark - resource);

  else
  {
    return_value_strlen$13=strlen(resource);
    tmp_if_expr$14 = return_value_strlen$13;
  }
  resource_len = tmp_if_expr$14;
  HMAC_Update(&hmac_ctx, (const unsigned char *)"/", (unsigned long int)1);
  unsigned long int return_value_strlen$15;
  return_value_strlen$15=strlen(http_io_add_auth2$$1$$config->bucket);
  HMAC_Update(&hmac_ctx, (const unsigned char *)http_io_add_auth2$$1$$config->bucket, return_value_strlen$15);
  HMAC_Update(&hmac_ctx, (const unsigned char *)resource, resource_len);
  HMAC_Final(&hmac_ctx, hmac, &hmac_len);
  HMAC_CTX_cleanup(&hmac_ctx);
  http_io_base64_encode(authbuf, sizeof(char [200l]) /*200ul*/ , (const void *)hmac, (unsigned long int)hmac_len);
  io->headers=http_io_add_header(io->headers, "%s: AWS %s:%s", (const void *)"Authorization", (const void *)access_id, (const void *)authbuf);
  r = 0;

fail:
  ;
  if(!(amz_hdrs == ((char **)NULL)))
    free((void *)amz_hdrs);

  HMAC_CTX_cleanup(&hmac_ctx);
  return r;
}

// http_io_add_auth4
// file http_io.c line 1936
static signed int http_io_add_auth4(struct http_io_private *priv, struct http_io * const io, signed long int now, const void *payload, unsigned long int plen)
{
  struct http_io_conf * const http_io_add_auth4$$1$$config = priv->config;
  unsigned char payload_hash[64l];
  unsigned char creq_hash[64l];
  unsigned char hmac[64l];
  unsigned int payload_hash_len;
  unsigned int creq_hash_len;
  unsigned int hmac_len;
  char payload_hash_buf[129l];
  char creq_hash_buf[129l];
  char hmac_buf[129l];
  struct curl_slist *hdr;
  char **sorted_hdrs = (char **)(void *)0;
  char *header_names = (char *)(void *)0;
  const char *host;
  unsigned long int host_len;
  const char *uripath;
  unsigned long int uripath_len;
  const char *query_params;
  unsigned long int query_params_len;
  unsigned int header_names_length;
  unsigned int num_sorted_hdrs;
  struct env_md_ctx_st hash_ctx;
  struct hmac_ctx_st hmac_ctx;
  char hosthdr[128l];
  char datebuf[64l];
  char access_id[128l];
  char access_key[128l];
  char iam_token[1024l];
  struct tm tm;
  char *p;
  signed int r;
  signed int i;
  EVP_MD_CTX_init(&hash_ctx);
  HMAC_CTX_init(&hmac_ctx);
  pthread_mutex_lock(&priv->mutex);
  snprintf(access_id, sizeof(char [128l]) /*128ul*/ , "%s", http_io_add_auth4$$1$$config->accessId);
  snprintf(access_key, sizeof(char [128l]) /*128ul*/ , "%s%s", (const void *)"AWS4", http_io_add_auth4$$1$$config->accessKey);
  char *tmp_if_expr$1;
  if(!(http_io_add_auth4$$1$$config->iam_token == ((char *)NULL)))
    tmp_if_expr$1 = http_io_add_auth4$$1$$config->iam_token;

  else
    tmp_if_expr$1 = "";
  snprintf(iam_token, sizeof(char [1024l]) /*1024ul*/ , "%s", tmp_if_expr$1);
  pthread_mutex_unlock(&priv->mutex);
  p=strchr(io->url, 58);
  _Bool tmp_if_expr$2;
  if(p == ((char *)NULL))
    tmp_if_expr$2 = (_Bool)1;

  else
  {
    p = p + 1l;
    tmp_if_expr$2 = (signed int)*p != 47 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$3 = (_Bool)1;

  else
  {
    p = p + 1l;
    tmp_if_expr$3 = (signed int)*p != 47 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$3)
    tmp_if_expr$4 = (_Bool)1;

  else
  {
    host = p + (signed long int)1;
    tmp_if_expr$4 = host == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$4)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    uripath=strchr(host, 47);
    tmp_if_expr$5 = uripath == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  struct tm *return_value_gmtime_r$6;
  const struct env_md_st *return_value_EVP_sha256$7;
  const struct env_md_st *return_value_EVP_sha256$8;
  void *return_value_malloc$10;
  signed int tmp_post$11;
  unsigned long int return_value_strlen$12;
  const char *tmp_post$13;
  const unsigned short int **return_value___ctype_b_loc$15;
  void *return_value_malloc$18;
  char *tmp_post$19;
  _Bool tmp_if_expr$20;
  char *tmp_post$21;
  signed int return_value_tolower$22;
  char *tmp_post$23;
  unsigned long int return_value_strlen$24;
  unsigned long int return_value_strlen$25;
  unsigned long int return_value_strlen$26;
  const struct env_md_st *return_value_EVP_sha256$27;
  const struct env_md_st *return_value_EVP_sha256$28;
  unsigned long int return_value_strlen$29;
  const struct env_md_st *return_value_EVP_sha256$30;
  unsigned long int return_value_strlen$31;
  const struct env_md_st *return_value_EVP_sha256$32;
  unsigned long int return_value_strlen$33;
  const struct env_md_st *return_value_EVP_sha256$34;
  unsigned long int return_value_strlen$35;
  unsigned long int return_value_strlen$36;
  unsigned long int return_value_strlen$37;
  unsigned long int return_value_strlen$38;
  unsigned long int return_value_strlen$39;
  unsigned long int return_value_strlen$40;
  if(tmp_if_expr$5)
    r = 22;

  else
  {
    host_len = (unsigned long int)(uripath - host);
    p=strchr(uripath, 63);
    if(!(p == ((char *)NULL)))
    {
      uripath_len = (unsigned long int)(p - uripath);
      query_params = p + (signed long int)1;
      query_params_len=strlen(query_params);
    }

    else
    {
      uripath_len=strlen(uripath);
      query_params = (const char *)(void *)0;
      query_params_len = (unsigned long int)0;
    }
    return_value_gmtime_r$6=gmtime_r(&now, &tm);
    strftime(datebuf, sizeof(char [64l]) /*64ul*/ , "%Y%m%dT%H%M%SZ", return_value_gmtime_r$6);
    return_value_EVP_sha256$7=EVP_sha256();
    EVP_DigestInit_ex(&hash_ctx, return_value_EVP_sha256$7, (struct engine_st *)(void *)0);
    if(!(payload == NULL))
      EVP_DigestUpdate(&hash_ctx, payload, plen);

    EVP_DigestFinal_ex(&hash_ctx, payload_hash, &payload_hash_len);
    http_io_prhex(payload_hash_buf, payload_hash, (unsigned long int)payload_hash_len);
    io->headers=http_io_add_header(io->headers, "%s: %s", (const void *)"x-amz-content-sha256", (const void *)payload_hash_buf);
    if(!((signed int)iam_token[0l] == 0))
      io->headers=http_io_add_header(io->headers, "%s: %s", (const void *)"x-amz-security-token", (const void *)iam_token);

    return_value_EVP_sha256$8=EVP_sha256();
    EVP_DigestInit_ex(&hash_ctx, return_value_EVP_sha256$8, (struct engine_st *)(void *)0);
    snprintf(hosthdr, sizeof(char [128l]) /*128ul*/ , "host:%.*s", (signed int)host_len, host);
    num_sorted_hdrs = (unsigned int)1;
    hdr = io->headers;
    for( ; !(hdr == ((struct curl_slist *)NULL)); hdr = hdr->next)
      num_sorted_hdrs = num_sorted_hdrs + 1u;
    return_value_malloc$10=malloc((unsigned long int)num_sorted_hdrs * sizeof(char *) /*8ul*/ );
    sorted_hdrs = (char **)return_value_malloc$10;
    if(sorted_hdrs == ((char **)NULL))
    {
      signed int *return_value___errno_location$9;
      return_value___errno_location$9=__errno_location();
      r = *return_value___errno_location$9;
      goto fail;
    }

    sorted_hdrs[(signed long int)0] = hosthdr;
    i = 1;
    hdr = io->headers;
    for( ; !(hdr == ((struct curl_slist *)NULL)); hdr = hdr->next)
    {
      tmp_post$11 = i;
      i = i + 1;
      sorted_hdrs[(signed long int)tmp_post$11] = hdr->data;
    }
    qsort((void *)sorted_hdrs, (unsigned long int)num_sorted_hdrs, sizeof(char *) /*8ul*/ , http_io_strcasecmp_ptr);
    return_value_strlen$12=strlen(io->method);
    EVP_DigestUpdate(&hash_ctx, (const void *)(const unsigned char *)io->method, return_value_strlen$12);
    EVP_DigestUpdate(&hash_ctx, (const void *)(const unsigned char *)"\n", (unsigned long int)1);
    EVP_DigestUpdate(&hash_ctx, (const void *)(const unsigned char *)uripath, uripath_len);
    EVP_DigestUpdate(&hash_ctx, (const void *)(const unsigned char *)"\n", (unsigned long int)1);
    EVP_DigestUpdate(&hash_ctx, (const void *)(const unsigned char *)query_params, query_params_len);
    EVP_DigestUpdate(&hash_ctx, (const void *)(const unsigned char *)"\n", (unsigned long int)1);
    header_names_length = (unsigned int)0;
    i = 0;
    for( ; !((unsigned int)i >= num_sorted_hdrs); i = i + 1)
    {
      const char *value = sorted_hdrs[(signed long int)i];
      const char *s;
      char lcase;
      s = value;
      while((_Bool)1)
      {
        if((signed int)*s == 0)
        {
          r = 22;
          goto fail;
        }

        signed int return_value_tolower$14;
        return_value_tolower$14=tolower((signed int)*s);
        lcase = (char)return_value_tolower$14;
        EVP_DigestUpdate(&hash_ctx, (const void *)(const unsigned char *)&lcase, (unsigned long int)1);
        header_names_length = header_names_length + 1u;
        tmp_post$13 = s;
        s = s + 1l;
        if((signed int)*tmp_post$13 == 58)
          break;

      }
      do
      {
        return_value___ctype_b_loc$15=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc$15)[(signed long int)(signed int)*s]) == 0)
          break;

        s = s + 1l;
      }
      while((_Bool)1);
      unsigned long int return_value_strlen$16;
      return_value_strlen$16=strlen(s);
      EVP_DigestUpdate(&hash_ctx, (const void *)(const unsigned char *)s, return_value_strlen$16);
      EVP_DigestUpdate(&hash_ctx, (const void *)(const unsigned char *)"\n", (unsigned long int)1);
    }
    EVP_DigestUpdate(&hash_ctx, (const void *)(const unsigned char *)"\n", (unsigned long int)1);
    return_value_malloc$18=malloc((unsigned long int)header_names_length);
    header_names = (char *)return_value_malloc$18;
    if(header_names == ((char *)NULL))
    {
      signed int *return_value___errno_location$17;
      return_value___errno_location$17=__errno_location();
      r = *return_value___errno_location$17;
      goto fail;
    }

    p = header_names;
    i = 0;
    for( ; !((unsigned int)i >= num_sorted_hdrs); i = i + 1)
    {
      const char *http_io_add_auth4$$1$$9$$1$$value = sorted_hdrs[(signed long int)i];
      const char *http_io_add_auth4$$1$$9$$1$$s;
      if(!(header_names >= p))
      {
        tmp_post$19 = p;
        p = p + 1l;
        *tmp_post$19 = (char)59;
      }

      http_io_add_auth4$$1$$9$$1$$s = http_io_add_auth4$$1$$9$$1$$value;
      do
      {
        if(!((signed int)*http_io_add_auth4$$1$$9$$1$$s == 0))
          tmp_if_expr$20 = (signed int)*http_io_add_auth4$$1$$9$$1$$s != 58 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$20 = (_Bool)0;
        if(!tmp_if_expr$20)
          break;

        tmp_post$21 = p;
        p = p + 1l;
        return_value_tolower$22=tolower((signed int)*http_io_add_auth4$$1$$9$$1$$s);
        *tmp_post$21 = (char)return_value_tolower$22;
        http_io_add_auth4$$1$$9$$1$$s = http_io_add_auth4$$1$$9$$1$$s + 1l;
      }
      while((_Bool)1);
    }
    tmp_post$23 = p;
    p = p + 1l;
    *tmp_post$23 = (char)0;
    return_value_strlen$24=strlen(header_names);
    EVP_DigestUpdate(&hash_ctx, (const void *)(const unsigned char *)header_names, return_value_strlen$24);
    EVP_DigestUpdate(&hash_ctx, (const void *)(const unsigned char *)"\n", (unsigned long int)1);
    return_value_strlen$25=strlen(payload_hash_buf);
    EVP_DigestUpdate(&hash_ctx, (const void *)(const unsigned char *)payload_hash_buf, return_value_strlen$25);
    EVP_DigestFinal_ex(&hash_ctx, creq_hash, &creq_hash_len);
    http_io_prhex(creq_hash_buf, creq_hash, (unsigned long int)creq_hash_len);
    return_value_strlen$26=strlen(access_key);
    return_value_EVP_sha256$27=EVP_sha256();
    HMAC_Init_ex(&hmac_ctx, (const void *)access_key, (signed int)return_value_strlen$26, return_value_EVP_sha256$27, (struct engine_st *)(void *)0);
    HMAC_Update(&hmac_ctx, (const unsigned char *)datebuf, (unsigned long int)8);
    HMAC_Final(&hmac_ctx, hmac, &hmac_len);
    return_value_EVP_sha256$28=EVP_sha256();
    HMAC_Init_ex(&hmac_ctx, (const void *)hmac, (signed int)hmac_len, return_value_EVP_sha256$28, (struct engine_st *)(void *)0);
    return_value_strlen$29=strlen(http_io_add_auth4$$1$$config->region);
    HMAC_Update(&hmac_ctx, (const unsigned char *)http_io_add_auth4$$1$$config->region, return_value_strlen$29);
    HMAC_Final(&hmac_ctx, hmac, &hmac_len);
    return_value_EVP_sha256$30=EVP_sha256();
    HMAC_Init_ex(&hmac_ctx, (const void *)hmac, (signed int)hmac_len, return_value_EVP_sha256$30, (struct engine_st *)(void *)0);
    return_value_strlen$31=strlen("s3");
    HMAC_Update(&hmac_ctx, (const unsigned char *)"s3", return_value_strlen$31);
    HMAC_Final(&hmac_ctx, hmac, &hmac_len);
    return_value_EVP_sha256$32=EVP_sha256();
    HMAC_Init_ex(&hmac_ctx, (const void *)hmac, (signed int)hmac_len, return_value_EVP_sha256$32, (struct engine_st *)(void *)0);
    return_value_strlen$33=strlen("aws4_request");
    HMAC_Update(&hmac_ctx, (const unsigned char *)"aws4_request", return_value_strlen$33);
    HMAC_Final(&hmac_ctx, hmac, &hmac_len);
    return_value_EVP_sha256$34=EVP_sha256();
    HMAC_Init_ex(&hmac_ctx, (const void *)hmac, (signed int)hmac_len, return_value_EVP_sha256$34, (struct engine_st *)(void *)0);
    return_value_strlen$35=strlen("AWS4-HMAC-SHA256");
    HMAC_Update(&hmac_ctx, (const unsigned char *)"AWS4-HMAC-SHA256", return_value_strlen$35);
    HMAC_Update(&hmac_ctx, (const unsigned char *)"\n", (unsigned long int)1);
    return_value_strlen$36=strlen(datebuf);
    HMAC_Update(&hmac_ctx, (const unsigned char *)datebuf, return_value_strlen$36);
    HMAC_Update(&hmac_ctx, (const unsigned char *)"\n", (unsigned long int)1);
    HMAC_Update(&hmac_ctx, (const unsigned char *)datebuf, (unsigned long int)8);
    HMAC_Update(&hmac_ctx, (const unsigned char *)"/", (unsigned long int)1);
    return_value_strlen$37=strlen(http_io_add_auth4$$1$$config->region);
    HMAC_Update(&hmac_ctx, (const unsigned char *)http_io_add_auth4$$1$$config->region, return_value_strlen$37);
    HMAC_Update(&hmac_ctx, (const unsigned char *)"/", (unsigned long int)1);
    return_value_strlen$38=strlen("s3");
    HMAC_Update(&hmac_ctx, (const unsigned char *)"s3", return_value_strlen$38);
    HMAC_Update(&hmac_ctx, (const unsigned char *)"/", (unsigned long int)1);
    return_value_strlen$39=strlen("aws4_request");
    HMAC_Update(&hmac_ctx, (const unsigned char *)"aws4_request", return_value_strlen$39);
    HMAC_Update(&hmac_ctx, (const unsigned char *)"\n", (unsigned long int)1);
    return_value_strlen$40=strlen(creq_hash_buf);
    HMAC_Update(&hmac_ctx, (const unsigned char *)creq_hash_buf, return_value_strlen$40);
    HMAC_Final(&hmac_ctx, hmac, &hmac_len);
    http_io_prhex(hmac_buf, hmac, (unsigned long int)hmac_len);
    io->headers=http_io_add_header(io->headers, "%s: %s Credential=%s/%.8s/%s/%s/%s, SignedHeaders=%s, Signature=%s", (const void *)"Authorization", (const void *)"AWS4-HMAC-SHA256", (const void *)access_id, (const void *)datebuf, http_io_add_auth4$$1$$config->region, (const void *)"s3", (const void *)"aws4_request", header_names, (const void *)hmac_buf);
    r = 0;
  }

fail:
  ;
  if(!(sorted_hdrs == ((char **)NULL)))
    free((void *)sorted_hdrs);

  free((void *)header_names);
  EVP_MD_CTX_cleanup(&hash_ctx);
  HMAC_CTX_cleanup(&hmac_ctx);
  return r;
}

// http_io_add_date
// file http_io.c line 2268
static void http_io_add_date(struct http_io_private * const priv, struct http_io * const io, signed long int now)
{
  struct http_io_conf * const http_io_add_date$$1$$config = priv->config;
  char buf[64l];
  struct tm tm;
  signed int return_value_strcmp$3;
  return_value_strcmp$3=strcmp(http_io_add_date$$1$$config->authVersion, "aws2");
  if(return_value_strcmp$3 == 0)
  {
    struct tm *return_value_gmtime_r$1;
    return_value_gmtime_r$1=gmtime_r(&now, &tm);
    strftime(buf, sizeof(char [64l]) /*64ul*/ , "%a, %d %b %Y %H:%M:%S GMT", return_value_gmtime_r$1);
    io->headers=http_io_add_header(io->headers, "%s: %s", (const void *)"Date", (const void *)buf);
  }

  else
  {
    struct tm *return_value_gmtime_r$2;
    return_value_gmtime_r$2=gmtime_r(&now, &tm);
    strftime(buf, sizeof(char [64l]) /*64ul*/ , "%Y%m%dT%H%M%SZ", return_value_gmtime_r$2);
    io->headers=http_io_add_header(io->headers, "%s: %s", (const void *)"x-amz-date", (const void *)buf);
  }
}

// http_io_add_header
// file http_io.c line 2284
static struct curl_slist * http_io_add_header(struct curl_slist *headers, const char *fmt, ...)
{
  char buf[1024l];
  void **args = (void **)&fmt;
  vsnprintf(buf, sizeof(char [1024l]) /*1024ul*/ , fmt, args);
  headers=curl_slist_append(headers, buf);
  args = ((void **)NULL);
  return headers;
}

// http_io_authsig
// file http_io.c line 2577
static void http_io_authsig(struct http_io_private *priv, unsigned int block_num, const unsigned char *src, unsigned int len, unsigned char *hmac)
{
  const char *ciphername;
  signed int return_value_EVP_CIPHER_nid$1;
  return_value_EVP_CIPHER_nid$1=EVP_CIPHER_nid(priv->cipher);
  ciphername=OBJ_nid2sn(return_value_EVP_CIPHER_nid$1);
  char blockbuf[64l];
  unsigned int hmac_len;
  struct hmac_ctx_st ctx;
  snprintf(blockbuf, sizeof(char [64l]) /*64ul*/ , "%0*jx", (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)block_num);
  HMAC_CTX_init(&ctx);
  const struct env_md_st *return_value_EVP_sha1$2;
  return_value_EVP_sha1$2=EVP_sha1();
  HMAC_Init_ex(&ctx, (const void *)(const unsigned char *)priv->key, (signed int)priv->keylen, return_value_EVP_sha1$2, (struct engine_st *)(void *)0);
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(blockbuf);
  HMAC_Update(&ctx, (const unsigned char *)blockbuf, return_value_strlen$3);
  unsigned long int return_value_strlen$4;
  return_value_strlen$4=strlen(ciphername);
  HMAC_Update(&ctx, (const unsigned char *)ciphername, return_value_strlen$4);
  HMAC_Update(&ctx, (const unsigned char *)src, (unsigned long int)len);
  HMAC_Final(&ctx, (unsigned char *)hmac, &hmac_len);
  HMAC_CTX_cleanup(&ctx);
}

// http_io_base64_encode
// file http_io.c line 2475
static void http_io_base64_encode(char *buf, unsigned long int bufsiz, const void *data, unsigned long int len)
{
  struct buf_mem_st *bptr;
  struct bio_st *bmem;
  struct bio_st *b64;
  struct bio_method_st *return_value_BIO_f_base64$1;
  return_value_BIO_f_base64$1=BIO_f_base64();
  b64=BIO_new(return_value_BIO_f_base64$1);
  struct bio_method_st *return_value_BIO_s_mem$2;
  return_value_BIO_s_mem$2=BIO_s_mem();
  bmem=BIO_new(return_value_BIO_s_mem$2);
  b64=BIO_push(b64, bmem);
  BIO_write(b64, data, (signed int)len);
  BIO_ctrl(b64, 11, (signed long int)0, (void *)0);
  BIO_ctrl(b64, 115, (signed long int)0, (void *)(char *)&bptr);
  snprintf(buf, bufsiz, "%.*s", (signed int)bptr->length - 1, (char *)bptr->data);
  BIO_free_all(b64);
}

// http_io_create
// file http_io.h line 128
extern struct s3backer_store * http_io_create(struct http_io_conf *config)
{
  struct s3backer_store *s3b;
  struct http_io_private *priv;
  struct curl_holder *holder;
  signed int nlocks;
  signed int r;
  void *return_value_calloc$2;
  void *return_value_calloc$4;
  void *return_value_malloc$6;
  unsigned int tmp_if_expr$14;
  _Bool tmp_if_expr$15;
  if(!(openssl_locks == ((union anonymous$5 *)NULL)))
  {
    config->log(3, "http_io_create() called twice");
    r = 114;
  }

  else
  {
    return_value_calloc$2=calloc((unsigned long int)1, sizeof(struct s3backer_store) /*80ul*/ );
    s3b = (struct s3backer_store *)return_value_calloc$2;
    if(s3b == ((struct s3backer_store *)NULL))
    {
      signed int *return_value___errno_location$1;
      return_value___errno_location$1=__errno_location();
      r = *return_value___errno_location$1;
      goto fail0;
    }

    s3b->meta_data = http_io_meta_data;
    s3b->set_mounted = http_io_set_mounted;
    s3b->read_block = http_io_read_block;
    s3b->write_block = http_io_write_block;
    s3b->read_block_part = http_io_read_block_part;
    s3b->write_block_part = http_io_write_block_part;
    s3b->list_blocks = http_io_list_blocks;
    s3b->flush = http_io_flush;
    s3b->destroy = http_io_destroy;
    return_value_calloc$4=calloc((unsigned long int)1, sizeof(struct http_io_private) /*400ul*/ );
    priv = (struct http_io_private *)return_value_calloc$4;
    if(priv == ((struct http_io_private *)NULL))
    {
      signed int *return_value___errno_location$3;
      return_value___errno_location$3=__errno_location();
      r = *return_value___errno_location$3;
      goto fail1;
    }

    priv->config = config;
    r=pthread_mutex_init(&priv->mutex, (const union anonymous$15 *)(void *)0);
    if(r == 0)
    {
      do
        (&priv->curls)->lh_first = (struct curl_holder *)(void *)0;
      while((_Bool)0);
      s3b->data = (void *)priv;
      num_openssl_locks=CRYPTO_num_locks();
      return_value_malloc$6=malloc((unsigned long int)num_openssl_locks * sizeof(union anonymous$5) /*40ul*/ );
      openssl_locks = (union anonymous$5 *)return_value_malloc$6;
      if(openssl_locks == ((union anonymous$5 *)NULL))
      {
        signed int *return_value___errno_location$5;
        return_value___errno_location$5=__errno_location();
        r = *return_value___errno_location$5;
        goto fail3;
      }

      nlocks = 0;
      for( ; !(nlocks >= num_openssl_locks); nlocks = nlocks + 1)
      {
        r=pthread_mutex_init(&openssl_locks[(signed long int)nlocks], (const union anonymous$15 *)(void *)0);
        if(!(r == 0))
          goto fail4;

      }
      CRYPTO_set_locking_callback(http_io_openssl_locker);
      CRYPTO_set_id_callback(http_io_openssl_ider);
      if(!(config->encryption == ((const char *)NULL)))
      {
        signed long int r$array_size0;
        unsigned long int return_value_strlen$7;
        return_value_strlen$7=strlen(config->bucket);
        unsigned long int return_value_strlen$8;
        return_value_strlen$8=strlen(config->prefix);
        r$array_size0 = (signed long int)(return_value_strlen$7 + (unsigned long int)1 + return_value_strlen$8 + (unsigned long int)1);
        char saltbuf[r$array_size0];
        unsigned int cipher_key_len;
        OpenSSL_add_all_ciphers();
        priv->cipher=EVP_get_cipherbyname(config->encryption);
        if(priv->cipher == ((const struct evp_cipher_st *)NULL))
        {
          config->log(3, "unknown encryption cipher `%s'", config->encryption);
          r = 22;
        }

        signed int return_value_EVP_CIPHER_block_size$11;
        return_value_EVP_CIPHER_block_size$11=EVP_CIPHER_block_size(priv->cipher);
        signed int return_value_EVP_CIPHER_iv_length$12;
        return_value_EVP_CIPHER_iv_length$12=EVP_CIPHER_iv_length(priv->cipher);
        if(!(return_value_EVP_CIPHER_block_size$11 == return_value_EVP_CIPHER_iv_length$12))
        {
          signed int return_value_EVP_CIPHER_block_size$9;
          return_value_EVP_CIPHER_block_size$9=EVP_CIPHER_block_size(priv->cipher);
          signed int return_value_EVP_CIPHER_iv_length$10;
          return_value_EVP_CIPHER_iv_length$10=EVP_CIPHER_iv_length(priv->cipher);
          config->log(3, "invalid encryption cipher `%s': block size %d != IV length %d", config->encryption, return_value_EVP_CIPHER_block_size$9, return_value_EVP_CIPHER_iv_length$10);
          r = 22;
        }

        signed int return_value_EVP_CIPHER_key_length$13;
        return_value_EVP_CIPHER_key_length$13=EVP_CIPHER_key_length(priv->cipher);
        cipher_key_len = (unsigned int)return_value_EVP_CIPHER_key_length$13;
        if(config->key_length >= 1u)
          tmp_if_expr$14 = config->key_length;

        else
          tmp_if_expr$14 = cipher_key_len;
        priv->keylen = tmp_if_expr$14;
        if(!(priv->keylen >= cipher_key_len))
          tmp_if_expr$15 = (_Bool)1;

        else
          tmp_if_expr$15 = (unsigned long int)priv->keylen > sizeof(unsigned char [64l]) /*64ul*/  ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr$15)
        {
          config->log(3, "key length %u for cipher `%s' is out of range", priv->keylen, config->encryption);
          r = 22;
        }

        snprintf(saltbuf, (unsigned long int)r$array_size0, "%s/%s", config->bucket, config->prefix);
        unsigned long int return_value_strlen$16;
        return_value_strlen$16=strlen(config->password);
        unsigned long int return_value_strlen$17;
        return_value_strlen$17=strlen(saltbuf);
        r=PKCS5_PBKDF2_HMAC_SHA1(config->password, (signed int)return_value_strlen$16, (unsigned char *)saltbuf, (signed int)return_value_strlen$17, 5000, (signed int)priv->keylen, priv->key);
        if(!(r == 1))
        {
          config->log(3, "failed to create encryption key");
          r = 22;
        }

        r=PKCS5_PBKDF2_HMAC_SHA1((char *)priv->key, (signed int)priv->keylen, priv->key, (signed int)priv->keylen, 5000, (signed int)priv->keylen, priv->ivkey);
        if(!(r == 1))
        {
          config->log(3, "failed to create encryption key");
          r = 22;
        }

      }

      curl_global_init((signed long int)(1 << 0 | 1 << 1));
      if(!(config->ec2iam_role == ((const char *)NULL)))
      {
        r=update_iam_credentials(priv);
        if(!(r == 0))
          goto fail5;

        r=pthread_create(&priv->iam_thread, (const union pthread_attr_t *)(void *)0, update_iam_credentials_main, (void *)priv);
        if(!(r == 0))
          goto fail5;

      }

      priv->non_zero = config->nonzero_bitmap;
      config->nonzero_bitmap = (unsigned int *)(void *)0;
      return s3b;
      do
      {

      fail5:
        ;
        holder = (&priv->curls)->lh_first;
        if(holder == ((struct curl_holder *)NULL))
          break;

        curl_easy_cleanup(holder->curl);
        do
        {
          if(!(holder->link.le_next == ((struct curl_holder *)NULL)))
            holder->link.le_next->link.le_prev = holder->link.le_prev;

          *holder->link.le_prev = holder->link.le_next;
        }
        while((_Bool)0);
        free((void *)holder);
      }
      while((_Bool)1);
      curl_global_cleanup();

    fail4:
      ;
      CRYPTO_set_locking_callback((void (*)(signed int, signed int, const char *, signed int))(void *)0);
      CRYPTO_set_id_callback((unsigned long int (*)(void))(void *)0);
      while(nlocks >= 1)
      {
        nlocks = nlocks - 1;
        pthread_mutex_destroy(&openssl_locks[(signed long int)nlocks]);
      }
      free((void *)openssl_locks);
      openssl_locks = (union anonymous$5 *)(void *)0;
      num_openssl_locks = 0;

    fail3:
      ;
      pthread_mutex_destroy(&priv->mutex);
    }


  fail2:
    ;
    free((void *)priv);

  fail1:
    ;
    free((void *)s3b);
  }

fail0:
  ;
  char *return_value_strerror$18;
  return_value_strerror$18=strerror(r);
  config->log(3, "http_io creation failed: %s", return_value_strerror$18);
  signed int *return_value___errno_location$19;
  return_value___errno_location$19=__errno_location();
  *return_value___errno_location$19 = r;
  return (struct s3backer_store *)(void *)0;
}

// http_io_crypt
// file http_io.c line 2512
static unsigned int http_io_crypt(struct http_io_private *priv, unsigned int block_num, signed int enc, const unsigned char *src, unsigned int len, unsigned char *dest)
{
  unsigned char ivec[16l];
  struct evp_cipher_ctx_st ctx;
  unsigned int total_len;
  char blockbuf[16l];
  signed int clen;
  signed int r;
  (void)r;
  EVP_CIPHER_CTX_init(&ctx);
  memset((void *)blockbuf, 0, sizeof(char [16l]) /*16ul*/ );
  snprintf(blockbuf, sizeof(char [16l]) /*16ul*/ , "%0*jx", (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)block_num);
  r=EVP_EncryptInit_ex(&ctx, priv->cipher, (struct engine_st *)(void *)0, priv->ivkey, priv->ivkey);
  EVP_CIPHER_CTX_set_padding(&ctx, 0);
  signed int return_value_EVP_CIPHER_CTX_block_size$1;
  return_value_EVP_CIPHER_CTX_block_size$1=EVP_CIPHER_CTX_block_size(&ctx);
  r=EVP_EncryptUpdate(&ctx, ivec, &clen, (const unsigned char *)blockbuf, return_value_EVP_CIPHER_CTX_block_size$1);
  r=EVP_EncryptFinal_ex(&ctx, (unsigned char *)(void *)0, &clen);
  r=EVP_CipherInit_ex(&ctx, priv->cipher, (struct engine_st *)(void *)0, priv->key, ivec, enc);
  EVP_CIPHER_CTX_set_padding(&ctx, 1);
  r=EVP_CipherUpdate(&ctx, dest, &clen, src, (signed int)len);
  total_len = (unsigned int)clen;
  r=EVP_CipherFinal_ex(&ctx, dest + (signed long int)total_len, &clen);
  total_len = total_len + (unsigned int)clen;
  EVP_CIPHER_CTX_cleanup(&ctx);
  return total_len;
}

// http_io_curl_header
// file http_io.c line 2381
static unsigned long int http_io_curl_header(void *ptr, unsigned long int size, unsigned long int nmemb, void *stream)
{
  struct http_io * const io = (struct http_io *)stream;
  const unsigned long int total = size * nmemb;
  char fmtbuf[64l];
  char buf[1024l];
  if(total >= 1024ul)
    return total;

  else
  {
    memcpy((void *)buf, ptr, total);
    buf[(signed long int)total] = (char)0;
    sscanf(buf, "x-amz-meta-s3backer-filesize: %ju", &io->file_size);
    sscanf(buf, "x-amz-meta-s3backer-blocksize: %u", &io->block_size);
    signed int return_value_strncasecmp$2;
    return_value_strncasecmp$2=strncasecmp(buf, "ETag:", sizeof(char [5l]) /*5ul*/ );
    if(return_value_strncasecmp$2 == 0)
    {
      char md5buf[33l];
      snprintf(fmtbuf, sizeof(char [64l]) /*64ul*/ , " \"%%%uc\"", 16 * 2);
      signed int return_value_sscanf$1;
      return_value_sscanf$1=sscanf(buf + (signed long int)sizeof(char [5l]) /*5ul*/ , fmtbuf, (const void *)md5buf);
      if(return_value_sscanf$1 == 1)
        http_io_parse_hex(md5buf, io->md5, (unsigned int)16);

    }

    signed int return_value_strncasecmp$4;
    return_value_strncasecmp$4=strncasecmp(buf, "x-amz-meta-s3backer-hmac:", sizeof(char [25l]) /*25ul*/ );
    if(return_value_strncasecmp$4 == 0)
    {
      char hmacbuf[41l];
      snprintf(fmtbuf, sizeof(char [64l]) /*64ul*/ , " \"%%%uc\"", 20 * 2);
      signed int return_value_sscanf$3;
      return_value_sscanf$3=sscanf(buf + (signed long int)sizeof(char [25l]) /*25ul*/ , fmtbuf, (const void *)hmacbuf);
      if(return_value_sscanf$3 == 1)
        http_io_parse_hex(hmacbuf, io->hmac, (unsigned int)20);

    }

    signed int return_value_strncasecmp$5;
    return_value_strncasecmp$5=strncasecmp(buf, "Content-Encoding:", sizeof(char [17l]) /*17ul*/ );
    if(return_value_strncasecmp$5 == 0)
    {
      unsigned long int celen;
      char *state;
      char *s;
      io->content_encoding[0l] = (char)0;
      s=strtok_r(buf + (signed long int)sizeof(char [17l]) /*17ul*/ , " \t\v\f\r\n,", &state);
      while(!(s == ((char *)NULL)))
      {
        celen=strlen(io->content_encoding);
        snprintf(io->content_encoding + (signed long int)celen, sizeof(char [32l]) /*32ul*/  - celen, "%s%s", celen > (unsigned long int)0 ? "," : "", s);
        s=strtok_r((char *)(void *)0, " \t\v\f\r\n,", &state);
      }
    }

    return total;
  }
}

// http_io_curl_list_reader
// file http_io.c line 627
static unsigned long int http_io_curl_list_reader(const void *ptr, unsigned long int size, unsigned long int nmemb, void *stream)
{
  struct http_io * const io = (struct http_io *)stream;
  unsigned long int total = size * nmemb;
  if(!(io->xml_error == XML_ERROR_NONE))
    return total;

  else
  {
    enum XML_Status return_value_XML_Parse$4;
    return_value_XML_Parse$4=XML_Parse(io->xml, (const char *)ptr, (signed int)total, 0);
    if(!((signed int)return_value_XML_Parse$4 == XML_STATUS_OK))
    {
      enum XML_Error return_value_XML_GetErrorCode$1;
      return_value_XML_GetErrorCode$1=XML_GetErrorCode(io->xml);
      io->xml_error = (signed int)return_value_XML_GetErrorCode$1;
      unsigned long int return_value_XML_GetCurrentLineNumber$2;
      return_value_XML_GetCurrentLineNumber$2=XML_GetCurrentLineNumber(io->xml);
      io->xml_error_line = (signed int)return_value_XML_GetCurrentLineNumber$2;
      unsigned long int return_value_XML_GetCurrentColumnNumber$3;
      return_value_XML_GetCurrentColumnNumber$3=XML_GetCurrentColumnNumber(io->xml);
      io->xml_error_column = (signed int)return_value_XML_GetCurrentColumnNumber$3;
    }

    return total;
  }
}

// http_io_curl_reader
// file http_io.c line 2346
static unsigned long int http_io_curl_reader(const void *ptr, unsigned long int size, unsigned long int nmemb, void *stream)
{
  struct http_io * const io = (struct http_io *)stream;
  struct http_io_bufs * const bufs = &io->bufs;
  unsigned long int total = size * nmemb;
  if(!(bufs->rdremain >= total))
    total = bufs->rdremain;

  memcpy((void *)bufs->rddata, ptr, total);
  bufs->rddata = bufs->rddata + (signed long int)total;
  bufs->rdremain = bufs->rdremain - total;
  return total;
}

// http_io_curl_writer
// file http_io.c line 2361
static unsigned long int http_io_curl_writer(void *ptr, unsigned long int size, unsigned long int nmemb, void *stream)
{
  struct http_io * const io = (struct http_io *)stream;
  struct http_io_bufs * const bufs = &io->bufs;
  unsigned long int total = size * nmemb;
  signed int return_value;
  if(!(io->check_cancel == ((signed int (*)(void *, unsigned int))NULL)))
  {
    return_value=io->check_cancel(io->check_cancel_arg, io->block_num);
    return (unsigned long int)0x10000000;
  }

  else
  {
    if(!(bufs->wrremain >= total))
      total = bufs->wrremain;

    memcpy(ptr, (const void *)bufs->wrdata, total);
    bufs->wrdata = bufs->wrdata + (signed long int)total;
    bufs->wrremain = bufs->wrremain - total;
    return total;
  }
}

// http_io_destroy
// file http_io.c line 445
static void http_io_destroy(struct s3backer_store * const s3b)
{
  struct http_io_private * const priv = (struct http_io_private *)s3b->data;
  struct http_io_conf * const http_io_destroy$$1$$config = priv->config;
  struct curl_holder *holder;
  signed int r;
  priv->shutting_down = (unsigned char)1;
  char *return_value_strerror$1;
  char *return_value_strerror$2;
  if(!(http_io_destroy$$1$$config->ec2iam_role == ((const char *)NULL)))
  {
    http_io_destroy$$1$$config->log(7, "waiting for EC2 IAM thread to shutdown");
    r=pthread_cancel(priv->iam_thread);
    if(!(r == 0))
    {
      return_value_strerror$1=strerror(r);
      http_io_destroy$$1$$config->log(3, "pthread_cancel: %s", return_value_strerror$1);
    }

    r=pthread_join(priv->iam_thread, (void **)(void *)0);
    if(!(r == 0))
    {
      return_value_strerror$2=strerror(r);
      http_io_destroy$$1$$config->log(3, "pthread_join: %s", return_value_strerror$2);
    }

    else
      http_io_destroy$$1$$config->log(7, "EC2 IAM thread successfully shutdown");
  }

  while(num_openssl_locks >= 1)
  {
    num_openssl_locks = num_openssl_locks - 1;
    pthread_mutex_destroy(&openssl_locks[(signed long int)num_openssl_locks]);
  }
  free((void *)openssl_locks);
  openssl_locks = (union anonymous$5 *)(void *)0;
  CRYPTO_set_locking_callback((void (*)(signed int, signed int, const char *, signed int))(void *)0);
  CRYPTO_set_id_callback((unsigned long int (*)(void))(void *)0);
  do
  {
    holder = (&priv->curls)->lh_first;
    if(holder == ((struct curl_holder *)NULL))
      break;

    curl_easy_cleanup(holder->curl);
    do
    {
      if(!(holder->link.le_next == ((struct curl_holder *)NULL)))
        holder->link.le_next->link.le_prev = holder->link.le_prev;

      *holder->link.le_prev = holder->link.le_next;
    }
    while((_Bool)0);
    free((void *)holder);
  }
  while((_Bool)1);
  curl_global_cleanup();
  pthread_mutex_destroy(&priv->mutex);
  free((void *)priv->non_zero);
  free((void *)priv);
  free((void *)s3b);
}

// http_io_flush
// file http_io.c line 488
static signed int http_io_flush(struct s3backer_store * const s3b)
{
  return 0;
}

// http_io_get_block_url
// file http_io.c line 2234
static void http_io_get_block_url(char *buf, unsigned long int bufsiz, struct http_io_conf *config, unsigned int block_num)
{
  signed int len;
  if(!(config->vhost == 0))
    len=snprintf(buf, bufsiz, "%s%s%0*jx", config->baseURL, config->prefix, (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)block_num);

  else
    len=snprintf(buf, bufsiz, "%s%s/%s%0*jx", config->baseURL, config->bucket, config->prefix, (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)block_num);
  (void)len;
}

// http_io_get_mounted_flag_url
// file http_io.c line 2252
static void http_io_get_mounted_flag_url(char *buf, unsigned long int bufsiz, struct http_io_conf *config)
{
  signed int len;
  if(!(config->vhost == 0))
    len=snprintf(buf, bufsiz, "%s%s%s", config->baseURL, config->prefix, (const void *)"s3backer-mounted");

  else
    len=snprintf(buf, bufsiz, "%s%s/%s%s", config->baseURL, config->bucket, config->prefix, (const void *)"s3backer-mounted");
  (void)len;
}

// http_io_get_stats
// file http_io.c line 494
extern void http_io_get_stats(struct s3backer_store *s3b, struct http_io_stats *stats)
{
  struct http_io_private * const priv = (struct http_io_private *)s3b->data;
  pthread_mutex_lock(&priv->mutex);
  memcpy((void *)stats, (const void *)&priv->stats, sizeof(struct http_io_stats) /*176ul*/ );
  pthread_mutex_unlock(&priv->mutex);
}

// http_io_head_prepper
// file http_io.c line 784
static void http_io_head_prepper(void *curl, struct http_io *io)
{
  memset((void *)&io->bufs, 0, sizeof(struct http_io_bufs) /*32ul*/ );
  signed int _curl_opt = CURLOPT_NOBODY;
  curl_easy_setopt(curl, (enum anonymous$12)_curl_opt, 1);
  signed int http_io_head_prepper$$1$$2$$_curl_opt = CURLOPT_WRITEFUNCTION;
  curl_easy_setopt(curl, (enum anonymous$12)http_io_head_prepper$$1$$2$$_curl_opt, http_io_curl_reader);
  signed int http_io_head_prepper$$1$$3$$_curl_opt = CURLOPT_WRITEDATA;
  curl_easy_setopt(curl, (enum anonymous$12)http_io_head_prepper$$1$$3$$_curl_opt, io);
  signed int http_io_head_prepper$$1$$4$$_curl_opt = CURLOPT_HEADERFUNCTION;
  curl_easy_setopt(curl, (enum anonymous$12)http_io_head_prepper$$1$$4$$_curl_opt, http_io_curl_header);
  signed int http_io_head_prepper$$1$$5$$_curl_opt = CURLOPT_HEADERDATA;
  curl_easy_setopt(curl, (enum anonymous$12)http_io_head_prepper$$1$$5$$_curl_opt, io);
  signed int http_io_head_prepper$$1$$6$$_curl_opt = CURLOPT_HTTPHEADER;
  curl_easy_setopt(curl, (enum anonymous$12)http_io_head_prepper$$1$$6$$_curl_opt, io->headers);
}

// http_io_iamcreds_prepper
// file http_io.c line 1020
static void http_io_iamcreds_prepper(void *curl, struct http_io *io)
{
  memset((void *)&io->bufs, 0, sizeof(struct http_io_bufs) /*32ul*/ );
  io->bufs.rdremain = (unsigned long int)io->buf_size;
  io->bufs.rddata = (char *)io->dest;
  signed int _curl_opt = CURLOPT_WRITEFUNCTION;
  curl_easy_setopt(curl, (enum anonymous$12)_curl_opt, http_io_curl_reader);
  signed int http_io_iamcreds_prepper$$1$$2$$_curl_opt = CURLOPT_WRITEDATA;
  curl_easy_setopt(curl, (enum anonymous$12)http_io_iamcreds_prepper$$1$$2$$_curl_opt, io);
  signed int http_io_iamcreds_prepper$$1$$3$$_curl_opt = CURLOPT_MAXFILESIZE_LARGE;
  if((_Bool)0)
  {
    if(http_io_iamcreds_prepper$$1$$3$$_curl_opt >= 30001)
    {
      goto __CPROVER_DUMP_L42;
      _curl_easy_setopt_err_curl_off_t();
    }


  __CPROVER_DUMP_L42:
    ;
    if(http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_URL || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_PROXY || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_USERPWD || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_PROXYUSERPWD || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_RANGE || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_REFERER || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_FTPPORT || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_USERAGENT || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_COOKIE || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_SSLCERT || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_KEYPASSWD || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_COOKIEFILE || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_CUSTOMREQUEST || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_INTERFACE || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_KRBLEVEL || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_CAINFO || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_RANDOM_FILE || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_EGDSOCKET || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_COOKIEJAR || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_SSL_CIPHER_LIST || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_SSLCERTTYPE || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_SSLKEY || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_SSLKEYTYPE || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_SSLENGINE || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_CAPATH || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_ACCEPT_ENCODING || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_NETRC_FILE || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_FTP_ACCOUNT || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_COOKIELIST || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_FTP_ALTERNATIVE_TO_USER || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_SSH_PUBLIC_KEYFILE || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_SSH_PRIVATE_KEYFILE || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_SSH_HOST_PUBLIC_KEY_MD5 || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_CRLFILE || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_ISSUERCERT || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_USERNAME || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_PASSWORD || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_PROXYUSERNAME || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_PROXYPASSWORD || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_NOPROXY || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_SOCKS5_GSSAPI_SERVICE || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_SSH_KNOWNHOSTS || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_MAIL_FROM || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_RTSP_SESSION_ID || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_RTSP_STREAM_URI || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_RTSP_TRANSPORT || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_TLSAUTH_USERNAME || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_TLSAUTH_PASSWORD || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_TLSAUTH_TYPE || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_DNS_SERVERS || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_MAIL_AUTH || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_XOAUTH2_BEARER || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_DNS_INTERFACE || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_DNS_LOCAL_IP4 || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_DNS_LOCAL_IP6 || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_LOGIN_OPTIONS || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_PINNEDPUBLICKEY || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_UNIX_SOCKET_PATH || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_PROXY_SERVICE_NAME || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_SERVICE_NAME || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_DEFAULT_PROTOCOL)
      _curl_easy_setopt_err_string();

    if(http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_WRITEFUNCTION || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_HEADERFUNCTION)
      _curl_easy_setopt_err_write_callback();

    if(http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_READFUNCTION)
      _curl_easy_setopt_err_read_cb();

    if(http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_IOCTLFUNCTION)
      _curl_easy_setopt_err_ioctl_cb();

    if(http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_SOCKOPTFUNCTION)
      _curl_easy_setopt_err_sockopt_cb();

    if(http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_OPENSOCKETFUNCTION)
      _curl_easy_setopt_err_opensocket_cb();

    if(http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_PROGRESSFUNCTION)
      _curl_easy_setopt_err_progress_cb();

    if(http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_DEBUGFUNCTION)
      _curl_easy_setopt_err_debug_cb();

    if(http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_SSL_CTX_FUNCTION)
      _curl_easy_setopt_err_ssl_ctx_cb();

    if(http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_CONV_FROM_NETWORK_FUNCTION || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_CONV_TO_NETWORK_FUNCTION || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_CONV_FROM_UTF8_FUNCTION)
      _curl_easy_setopt_err_conv_cb();

    if(http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_SEEKFUNCTION)
      _curl_easy_setopt_err_seek_cb();

    if(http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_ERRORBUFFER)
      _curl_easy_setopt_err_error_buffer();

    if(http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_STDERR)
      _curl_easy_setopt_err_FILE();

    if(http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_POSTFIELDS || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_COPYPOSTFIELDS)
      _curl_easy_setopt_err_postfields();

    if(http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_HTTPPOST)
      _curl_easy_setopt_err_curl_httpost();

    if(http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_HTTPHEADER || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_QUOTE || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_POSTQUOTE || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_TELNETOPTIONS || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_PREQUOTE || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_HTTP200ALIASES || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_MAIL_RCPT || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_RESOLVE || http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_PROXYHEADER)
      _curl_easy_setopt_err_curl_slist();

    if(http_io_iamcreds_prepper$$1$$3$$_curl_opt == CURLOPT_SHARE)
      _curl_easy_setopt_err_CURLSH();

  }

  curl_easy_setopt(curl, (enum anonymous$12)http_io_iamcreds_prepper$$1$$3$$_curl_opt, (signed long int)io->buf_size);
  signed int http_io_iamcreds_prepper$$1$$4$$_curl_opt = CURLOPT_ACCEPT_ENCODING;
  curl_easy_setopt(curl, (enum anonymous$12)http_io_iamcreds_prepper$$1$$4$$_curl_opt, (const void *)"");
  signed int http_io_iamcreds_prepper$$1$$5$$_curl_opt = CURLOPT_HTTP_CONTENT_DECODING;
  if((_Bool)0)
  {
    if(http_io_iamcreds_prepper$$1$$5$$_curl_opt >= 30001)
    {
      goto __CPROVER_DUMP_L82;
      _curl_easy_setopt_err_curl_off_t();
    }


  __CPROVER_DUMP_L82:
    ;
    if(http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_URL || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_PROXY || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_USERPWD || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_PROXYUSERPWD || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_RANGE || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_REFERER || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_FTPPORT || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_USERAGENT || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_COOKIE || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_SSLCERT || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_KEYPASSWD || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_COOKIEFILE || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_CUSTOMREQUEST || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_INTERFACE || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_KRBLEVEL || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_CAINFO || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_RANDOM_FILE || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_EGDSOCKET || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_COOKIEJAR || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_SSL_CIPHER_LIST || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_SSLCERTTYPE || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_SSLKEY || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_SSLKEYTYPE || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_SSLENGINE || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_CAPATH || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_ACCEPT_ENCODING || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_NETRC_FILE || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_FTP_ACCOUNT || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_COOKIELIST || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_FTP_ALTERNATIVE_TO_USER || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_SSH_PUBLIC_KEYFILE || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_SSH_PRIVATE_KEYFILE || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_SSH_HOST_PUBLIC_KEY_MD5 || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_CRLFILE || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_ISSUERCERT || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_USERNAME || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_PASSWORD || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_PROXYUSERNAME || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_PROXYPASSWORD || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_NOPROXY || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_SOCKS5_GSSAPI_SERVICE || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_SSH_KNOWNHOSTS || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_MAIL_FROM || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_RTSP_SESSION_ID || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_RTSP_STREAM_URI || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_RTSP_TRANSPORT || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_TLSAUTH_USERNAME || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_TLSAUTH_PASSWORD || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_TLSAUTH_TYPE || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_DNS_SERVERS || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_MAIL_AUTH || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_XOAUTH2_BEARER || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_DNS_INTERFACE || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_DNS_LOCAL_IP4 || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_DNS_LOCAL_IP6 || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_LOGIN_OPTIONS || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_PINNEDPUBLICKEY || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_UNIX_SOCKET_PATH || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_PROXY_SERVICE_NAME || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_SERVICE_NAME || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_DEFAULT_PROTOCOL)
      _curl_easy_setopt_err_string();

    if(http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_WRITEFUNCTION || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_HEADERFUNCTION)
      _curl_easy_setopt_err_write_callback();

    if(http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_READFUNCTION)
      _curl_easy_setopt_err_read_cb();

    if(http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_IOCTLFUNCTION)
      _curl_easy_setopt_err_ioctl_cb();

    if(http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_SOCKOPTFUNCTION)
      _curl_easy_setopt_err_sockopt_cb();

    if(http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_OPENSOCKETFUNCTION)
      _curl_easy_setopt_err_opensocket_cb();

    if(http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_PROGRESSFUNCTION)
      _curl_easy_setopt_err_progress_cb();

    if(http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_DEBUGFUNCTION)
      _curl_easy_setopt_err_debug_cb();

    if(http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_SSL_CTX_FUNCTION)
      _curl_easy_setopt_err_ssl_ctx_cb();

    if(http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_CONV_FROM_NETWORK_FUNCTION || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_CONV_TO_NETWORK_FUNCTION || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_CONV_FROM_UTF8_FUNCTION)
      _curl_easy_setopt_err_conv_cb();

    if(http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_SEEKFUNCTION)
      _curl_easy_setopt_err_seek_cb();

    if(http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_ERRORBUFFER)
      _curl_easy_setopt_err_error_buffer();

    if(http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_STDERR)
      _curl_easy_setopt_err_FILE();

    if(http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_POSTFIELDS || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_COPYPOSTFIELDS)
      _curl_easy_setopt_err_postfields();

    if(http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_HTTPPOST)
      _curl_easy_setopt_err_curl_httpost();

    if(http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_HTTPHEADER || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_QUOTE || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_POSTQUOTE || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_TELNETOPTIONS || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_PREQUOTE || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_HTTP200ALIASES || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_MAIL_RCPT || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_RESOLVE || http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_PROXYHEADER)
      _curl_easy_setopt_err_curl_slist();

    if(http_io_iamcreds_prepper$$1$$5$$_curl_opt == CURLOPT_SHARE)
      _curl_easy_setopt_err_CURLSH();

  }

  curl_easy_setopt(curl, (enum anonymous$12)http_io_iamcreds_prepper$$1$$5$$_curl_opt, (signed long int)0);
}

// http_io_is_zero_block
// file http_io.c line 2492
static signed int http_io_is_zero_block(const void *data, unsigned int block_size)
{
  const unsigned int *ptr;
  signed int i;
  signed int return_value_memcmp$1;
  const unsigned int *tmp_post$2;
  if(!((unsigned long int)block_size >= 9ul))
  {
    static unsigned long int zero;
    return_value_memcmp$1=memcmp(data, (const void *)&zero, (unsigned long int)block_size);
    return (signed int)(return_value_memcmp$1 == 0);
  }

  else
  {
    ptr = (const unsigned int *)data;
    i = 0;
    for( ; !((unsigned long int)i >= (unsigned long int)block_size / sizeof(const unsigned int) /*4ul*/ ); i = i + 1)
    {
      tmp_post$2 = ptr;
      ptr = ptr + 1l;
      if(!(*tmp_post$2 == 0u))
        return 0;

    }
    return 1;
  }
}

// http_io_list_blocks
// file http_io.c line 504
static signed int http_io_list_blocks(struct s3backer_store *s3b, void (*callback)(void *, unsigned int), void *arg)
{
  struct http_io_private * const priv = (struct http_io_private *)s3b->data;
  struct http_io_conf * const http_io_list_blocks$$1$$config = priv->config;
  signed long int config$array_size0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(http_io_list_blocks$$1$$config->prefix);
  config$array_size0 = (signed long int)(sizeof(char [9l]) /*9ul*/  + return_value_strlen$1 + (unsigned long int)(signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2) + (unsigned long int)1);
  char marker[config$array_size0];
  signed long int marker$array_size0;
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(http_io_list_blocks$$1$$config->baseURL);
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(http_io_list_blocks$$1$$config->bucket);
  unsigned long int return_value_strlen$4;
  return_value_strlen$4=strlen(http_io_list_blocks$$1$$config->prefix);
  marker$array_size0 = (signed long int)(return_value_strlen$2 + return_value_strlen$3 + return_value_strlen$4 + (unsigned long int)(signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2) + (unsigned long int)2 + (unsigned long int)config$array_size0 + (unsigned long int)32);
  char urlbuf[marker$array_size0];
  struct http_io io;
  signed int r;
  memset((void *)&io, 0, sizeof(struct http_io) /*272ul*/ );
  io.url = urlbuf;
  io.method = "GET";
  io.config = http_io_list_blocks$$1$$config;
  io.xml_error = XML_ERROR_NONE;
  io.callback_func = callback;
  io.callback_arg = arg;
  io.xml=XML_ParserCreate((const char *)(void *)0);
  char *tmp_if_expr$12;
  if(io.xml == ((struct XML_ParserStruct *)NULL))
  {
    http_io_list_blocks$$1$$config->log(3, "failed to create XML parser");
    return 12;
  }

  else
  {
    unsigned long int return_value_strlen$5;
    return_value_strlen$5=strlen(http_io_list_blocks$$1$$config->prefix);
    io.xml_text_max = (signed int)(return_value_strlen$5 + (unsigned long int)(signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2) + (unsigned long int)10);
    void *return_value_malloc$8;
    return_value_malloc$8=malloc((unsigned long int)(io.xml_text_max + 1));
    io.xml_text = (char *)return_value_malloc$8;
    if(io.xml_text == ((char *)NULL))
    {
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      char *return_value_strerror$7;
      return_value_strerror$7=strerror(*return_value___errno_location$6);
      http_io_list_blocks$$1$$config->log(3, "malloc: %s", return_value_strerror$7);
    }

    void *return_value_calloc$11;
    return_value_calloc$11=calloc((unsigned long int)1, (unsigned long int)1);
    io.xml_path = (char *)return_value_calloc$11;
    if(io.xml_path == ((char *)NULL))
    {
      signed int *return_value___errno_location$9;
      return_value___errno_location$9=__errno_location();
      char *return_value_strerror$10;
      return_value_strerror$10=strerror(*return_value___errno_location$9);
      http_io_list_blocks$$1$$config->log(3, "calloc: %s", return_value_strerror$10);
    }

    do
    {
      signed long int now;
      now=time((signed long int *)(void *)0);
      XML_ParserReset(io.xml, (const char *)(void *)0);
      XML_SetUserData(io.xml, (void *)&io);
      XML_SetElementHandler(io.xml, http_io_list_elem_start, http_io_list_elem_end);
      XML_SetCharacterDataHandler(io.xml, http_io_list_text);
      if(!(http_io_list_blocks$$1$$config->vhost == 0))
        tmp_if_expr$12 = "";

      else
        tmp_if_expr$12 = http_io_list_blocks$$1$$config->bucket;
      snprintf(urlbuf, (unsigned long int)marker$array_size0, "%s%s?", http_io_list_blocks$$1$$config->baseURL, tmp_if_expr$12);
      if(!(io.list_truncated == 0))
      {
        unsigned long int return_value_strlen$13;
        return_value_strlen$13=strlen(urlbuf);
        unsigned long int return_value_strlen$14;
        return_value_strlen$14=strlen(urlbuf);
        snprintf(urlbuf + (signed long int)return_value_strlen$13, (unsigned long int)marker$array_size0 - return_value_strlen$14, "%s=%s%0*jx&", (const void *)"marker", http_io_list_blocks$$1$$config->prefix, (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)io.last_block);
      }

      unsigned long int return_value_strlen$15;
      return_value_strlen$15=strlen(urlbuf);
      unsigned long int return_value_strlen$16;
      return_value_strlen$16=strlen(urlbuf);
      snprintf(urlbuf + (signed long int)return_value_strlen$15, (unsigned long int)marker$array_size0 - return_value_strlen$16, "%s=%u", (const void *)"max-keys", 0x100);
      unsigned long int return_value_strlen$17;
      return_value_strlen$17=strlen(urlbuf);
      unsigned long int return_value_strlen$18;
      return_value_strlen$18=strlen(urlbuf);
      snprintf(urlbuf + (signed long int)return_value_strlen$17, (unsigned long int)marker$array_size0 - return_value_strlen$18, "&%s=%s", (const void *)"prefix", http_io_list_blocks$$1$$config->prefix);
      http_io_add_date(priv, &io, now);
      r=http_io_add_auth(priv, &io, now, (void *)0, (unsigned long int)0);
      if(!(r == 0))
        goto fail;

      r=http_io_perform_io(priv, &io, http_io_list_prepper);
      curl_slist_free_all(io.headers);
      io.headers = (struct curl_slist *)(void *)0;
      if(!(r == 0))
        goto fail;

      enum XML_Status return_value_XML_Parse$22;
      return_value_XML_Parse$22=XML_Parse(io.xml, (const char *)(void *)0, 0, 1);
      if(!((signed int)return_value_XML_Parse$22 == XML_STATUS_OK))
      {
        enum XML_Error return_value_XML_GetErrorCode$19;
        return_value_XML_GetErrorCode$19=XML_GetErrorCode(io.xml);
        io.xml_error = (signed int)return_value_XML_GetErrorCode$19;
        unsigned long int return_value_XML_GetCurrentLineNumber$20;
        return_value_XML_GetCurrentLineNumber$20=XML_GetCurrentLineNumber(io.xml);
        io.xml_error_line = (signed int)return_value_XML_GetCurrentLineNumber$20;
        unsigned long int return_value_XML_GetCurrentColumnNumber$21;
        return_value_XML_GetCurrentColumnNumber$21=XML_GetCurrentColumnNumber(io.xml);
        io.xml_error_column = (signed int)return_value_XML_GetCurrentColumnNumber$21;
      }

      if(!(io.xml_error == XML_ERROR_NONE))
      {
        const char *return_value_XML_ErrorString$23;
        return_value_XML_ErrorString$23=XML_ErrorString((enum XML_Error)io.xml_error);
        http_io_list_blocks$$1$$config->log(3, "XML parse error: line %d col %d: %s", io.xml_error_line, io.xml_error_column, return_value_XML_ErrorString$23);
        r = 5;
      }

    }
    while(!(io.list_truncated == 0));
    XML_ParserFree(io.xml);
    free((void *)io.xml_path);
    free((void *)io.xml_text);
    return 0;

  oom:
    ;
    pthread_mutex_lock(&priv->mutex);
    priv->stats.out_of_memory_errors = priv->stats.out_of_memory_errors + 1u;
    pthread_mutex_unlock(&priv->mutex);
    r = 12;

  fail:
    ;
    if(!(io.xml == ((struct XML_ParserStruct *)NULL)))
      XML_ParserFree(io.xml);

    free((void *)io.xml_path);
    free((void *)io.xml_text);
    return r;
  }
}

// http_io_list_elem_end
// file http_io.c line 665
static void http_io_list_elem_end(void *arg, const char *name)
{
  struct http_io * const io = (struct http_io *)arg;
  unsigned int block_num;
  signed int return_value_strcmp$4;
  return_value_strcmp$4=strcmp(io->xml_path, "/ListBucketResult/IsTruncated");
  signed int return_value_strcmp$1;
  signed int return_value_strcmp$3;
  if(return_value_strcmp$4 == 0)
  {
    return_value_strcmp$1=strcmp(io->xml_text, "true");
    io->list_truncated = (signed int)(return_value_strcmp$1 == 0);
  }

  else
  {
    return_value_strcmp$3=strcmp(io->xml_path, "/ListBucketResult/Contents/Key");
    if(return_value_strcmp$3 == 0)
    {
      signed int return_value_http_io_parse_block$2;
      return_value_http_io_parse_block$2=http_io_parse_block(io->config, io->xml_text, &block_num);
      if(return_value_http_io_parse_block$2 == 0)
      {
        io->callback_func(io->callback_arg, block_num);
        io->last_block = block_num;
      }

    }

  }
  char *return_value_strrchr$5;
  return_value_strrchr$5=strrchr(io->xml_path, 47);
  *return_value_strrchr$5 = (char)0;
  io->xml_text_len = 0;
  io->xml_text[(signed long int)0] = (char)0;
}

// http_io_list_elem_start
// file http_io.c line 643
static void http_io_list_elem_start(void *arg, const char *name, const char **atts)
{
  struct http_io * const io = (struct http_io *)arg;
  unsigned long int plen;
  plen=strlen(io->xml_path);
  char *newbuf;
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(name);
  void *return_value_realloc$4;
  return_value_realloc$4=realloc((void *)io->xml_path, plen + (unsigned long int)1 + return_value_strlen$3 + (unsigned long int)1);
  newbuf = (char *)return_value_realloc$4;
  if(newbuf == ((char *)NULL))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(*return_value___errno_location$1);
    io->config->log(7, "realloc: %s", return_value_strerror$2);
    io->xml_error = XML_ERROR_NO_MEMORY;
  }

  io->xml_path = newbuf;
  io->xml_path[(signed long int)plen] = (char)47;
  strcpy(io->xml_path + (signed long int)plen + (signed long int)1, name);
  io->xml_text_len = 0;
  io->xml_text[(signed long int)0] = (char)0;
}

// http_io_list_prepper
// file http_io.c line 617
static void http_io_list_prepper(void *curl, struct http_io *io)
{
  signed int http_io_list_prepper$$1$$1$$_curl_opt = CURLOPT_WRITEFUNCTION;
  curl_easy_setopt(curl, (enum anonymous$12)http_io_list_prepper$$1$$1$$_curl_opt, http_io_curl_list_reader);
  signed int http_io_list_prepper$$1$$2$$_curl_opt = CURLOPT_WRITEDATA;
  curl_easy_setopt(curl, (enum anonymous$12)http_io_list_prepper$$1$$2$$_curl_opt, io);
  signed int http_io_list_prepper$$1$$3$$_curl_opt = CURLOPT_HTTPHEADER;
  curl_easy_setopt(curl, (enum anonymous$12)http_io_list_prepper$$1$$3$$_curl_opt, io->headers);
  signed int http_io_list_prepper$$1$$4$$_curl_opt = CURLOPT_ACCEPT_ENCODING;
  curl_easy_setopt(curl, (enum anonymous$12)http_io_list_prepper$$1$$4$$_curl_opt, (const void *)"");
  signed int _curl_opt = CURLOPT_HTTP_CONTENT_DECODING;
  if((_Bool)0)
  {
    if(_curl_opt >= 30001)
    {
      goto __CPROVER_DUMP_L82;
      _curl_easy_setopt_err_curl_off_t();
    }


  __CPROVER_DUMP_L82:
    ;
    if(_curl_opt == CURLOPT_URL || _curl_opt == CURLOPT_PROXY || _curl_opt == CURLOPT_USERPWD || _curl_opt == CURLOPT_PROXYUSERPWD || _curl_opt == CURLOPT_RANGE || _curl_opt == CURLOPT_REFERER || _curl_opt == CURLOPT_FTPPORT || _curl_opt == CURLOPT_USERAGENT || _curl_opt == CURLOPT_COOKIE || _curl_opt == CURLOPT_SSLCERT || _curl_opt == CURLOPT_KEYPASSWD || _curl_opt == CURLOPT_COOKIEFILE || _curl_opt == CURLOPT_CUSTOMREQUEST || _curl_opt == CURLOPT_INTERFACE || _curl_opt == CURLOPT_KRBLEVEL || _curl_opt == CURLOPT_CAINFO || _curl_opt == CURLOPT_RANDOM_FILE || _curl_opt == CURLOPT_EGDSOCKET || _curl_opt == CURLOPT_COOKIEJAR || _curl_opt == CURLOPT_SSL_CIPHER_LIST || _curl_opt == CURLOPT_SSLCERTTYPE || _curl_opt == CURLOPT_SSLKEY || _curl_opt == CURLOPT_SSLKEYTYPE || _curl_opt == CURLOPT_SSLENGINE || _curl_opt == CURLOPT_CAPATH || _curl_opt == CURLOPT_ACCEPT_ENCODING || _curl_opt == CURLOPT_NETRC_FILE || _curl_opt == CURLOPT_FTP_ACCOUNT || _curl_opt == CURLOPT_COOKIELIST || _curl_opt == CURLOPT_FTP_ALTERNATIVE_TO_USER || _curl_opt == CURLOPT_SSH_PUBLIC_KEYFILE || _curl_opt == CURLOPT_SSH_PRIVATE_KEYFILE || _curl_opt == CURLOPT_SSH_HOST_PUBLIC_KEY_MD5 || _curl_opt == CURLOPT_CRLFILE || _curl_opt == CURLOPT_ISSUERCERT || _curl_opt == CURLOPT_USERNAME || _curl_opt == CURLOPT_PASSWORD || _curl_opt == CURLOPT_PROXYUSERNAME || _curl_opt == CURLOPT_PROXYPASSWORD || _curl_opt == CURLOPT_NOPROXY || _curl_opt == CURLOPT_SOCKS5_GSSAPI_SERVICE || _curl_opt == CURLOPT_SSH_KNOWNHOSTS || _curl_opt == CURLOPT_MAIL_FROM || _curl_opt == CURLOPT_RTSP_SESSION_ID || _curl_opt == CURLOPT_RTSP_STREAM_URI || _curl_opt == CURLOPT_RTSP_TRANSPORT || _curl_opt == CURLOPT_TLSAUTH_USERNAME || _curl_opt == CURLOPT_TLSAUTH_PASSWORD || _curl_opt == CURLOPT_TLSAUTH_TYPE || _curl_opt == CURLOPT_DNS_SERVERS || _curl_opt == CURLOPT_MAIL_AUTH || _curl_opt == CURLOPT_XOAUTH2_BEARER || _curl_opt == CURLOPT_DNS_INTERFACE || _curl_opt == CURLOPT_DNS_LOCAL_IP4 || _curl_opt == CURLOPT_DNS_LOCAL_IP6 || _curl_opt == CURLOPT_LOGIN_OPTIONS || _curl_opt == CURLOPT_PINNEDPUBLICKEY || _curl_opt == CURLOPT_UNIX_SOCKET_PATH || _curl_opt == CURLOPT_PROXY_SERVICE_NAME || _curl_opt == CURLOPT_SERVICE_NAME || _curl_opt == CURLOPT_DEFAULT_PROTOCOL)
      _curl_easy_setopt_err_string();

    if(_curl_opt == CURLOPT_WRITEFUNCTION || _curl_opt == CURLOPT_HEADERFUNCTION)
      _curl_easy_setopt_err_write_callback();

    if(_curl_opt == CURLOPT_READFUNCTION)
      _curl_easy_setopt_err_read_cb();

    if(_curl_opt == CURLOPT_IOCTLFUNCTION)
      _curl_easy_setopt_err_ioctl_cb();

    if(_curl_opt == CURLOPT_SOCKOPTFUNCTION)
      _curl_easy_setopt_err_sockopt_cb();

    if(_curl_opt == CURLOPT_OPENSOCKETFUNCTION)
      _curl_easy_setopt_err_opensocket_cb();

    if(_curl_opt == CURLOPT_PROGRESSFUNCTION)
      _curl_easy_setopt_err_progress_cb();

    if(_curl_opt == CURLOPT_DEBUGFUNCTION)
      _curl_easy_setopt_err_debug_cb();

    if(_curl_opt == CURLOPT_SSL_CTX_FUNCTION)
      _curl_easy_setopt_err_ssl_ctx_cb();

    if(_curl_opt == CURLOPT_CONV_FROM_NETWORK_FUNCTION || _curl_opt == CURLOPT_CONV_TO_NETWORK_FUNCTION || _curl_opt == CURLOPT_CONV_FROM_UTF8_FUNCTION)
      _curl_easy_setopt_err_conv_cb();

    if(_curl_opt == CURLOPT_SEEKFUNCTION)
      _curl_easy_setopt_err_seek_cb();

    if(_curl_opt == CURLOPT_ERRORBUFFER)
      _curl_easy_setopt_err_error_buffer();

    if(_curl_opt == CURLOPT_STDERR)
      _curl_easy_setopt_err_FILE();

    if(_curl_opt == CURLOPT_POSTFIELDS || _curl_opt == CURLOPT_COPYPOSTFIELDS)
      _curl_easy_setopt_err_postfields();

    if(_curl_opt == CURLOPT_HTTPPOST)
      _curl_easy_setopt_err_curl_httpost();

    if(_curl_opt == CURLOPT_HTTPHEADER || _curl_opt == CURLOPT_QUOTE || _curl_opt == CURLOPT_POSTQUOTE || _curl_opt == CURLOPT_TELNETOPTIONS || _curl_opt == CURLOPT_PREQUOTE || _curl_opt == CURLOPT_HTTP200ALIASES || _curl_opt == CURLOPT_MAIL_RCPT || _curl_opt == CURLOPT_RESOLVE || _curl_opt == CURLOPT_PROXYHEADER)
      _curl_easy_setopt_err_curl_slist();

    if(_curl_opt == CURLOPT_SHARE)
      _curl_easy_setopt_err_CURLSH();

  }

  curl_easy_setopt(curl, (enum anonymous$12)_curl_opt, (signed long int)1);
}

// http_io_list_text
// file http_io.c line 692
static void http_io_list_text(void *arg, const char *s, signed int len)
{
  struct http_io * const io = (struct http_io *)arg;
  signed int avail = io->xml_text_max - io->xml_text_len;
  if(!(avail >= len))
    len = avail;

  memcpy((void *)(io->xml_text + (signed long int)io->xml_text_len), (const void *)s, (unsigned long int)len);
  io->xml_text_len = io->xml_text_len + len;
  io->xml_text[(signed long int)io->xml_text_len] = (char)0;
}

// http_io_meta_data
// file http_io.c line 741
static signed int http_io_meta_data(struct s3backer_store *s3b, signed long int *file_sizep, unsigned int *block_sizep)
{
  struct http_io_private * const priv = (struct http_io_private *)s3b->data;
  struct http_io_conf * const http_io_meta_data$$1$$config = priv->config;
  signed long int config$array_size0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(http_io_meta_data$$1$$config->baseURL);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(http_io_meta_data$$1$$config->bucket);
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(http_io_meta_data$$1$$config->prefix);
  config$array_size0 = (signed long int)(return_value_strlen$1 + return_value_strlen$2 + return_value_strlen$3 + (unsigned long int)(signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2) + (unsigned long int)2);
  char urlbuf[config$array_size0];
  signed long int now;
  now=time((signed long int *)(void *)0);
  struct http_io io;
  signed int r;
  memset((void *)&io, 0, sizeof(struct http_io) /*272ul*/ );
  io.url = urlbuf;
  io.method = "HEAD";
  http_io_get_block_url(urlbuf, (unsigned long int)config$array_size0, http_io_meta_data$$1$$config, (unsigned int)0);
  http_io_add_date(priv, &io, now);
  r=http_io_add_auth(priv, &io, now, (void *)0, (unsigned long int)0);
  if(r == 0)
  {
    r=http_io_perform_io(priv, &io, http_io_head_prepper);
    if(r == 0)
    {
      if(io.block_size == 0u || io.file_size == 0ul)
        r = 2;

      else
      {
        *file_sizep = (signed long int)io.file_size;
        *block_sizep = io.block_size;
      }
    }

  }


done:
  ;
  curl_slist_free_all(io.headers);
  return r;
}

// http_io_openssl_ider
// file http_io.c line 2469
static unsigned long int http_io_openssl_ider(void)
{
  unsigned long int return_value_pthread_self$1;
  return_value_pthread_self$1=pthread_self();
  return (unsigned long int)return_value_pthread_self$1;
}

// http_io_openssl_locker
// file http_io.c line 2460
static void http_io_openssl_locker(signed int mode, signed int i, const char *file, signed int line)
{
  if(!((1 & mode) == 0))
    pthread_mutex_lock(&openssl_locks[(signed long int)i]);

  else
    pthread_mutex_unlock(&openssl_locks[(signed long int)i]);
}

// http_io_parse_block
// file http_io.c line 710
extern signed int http_io_parse_block(struct http_io_conf *config, const char *name, unsigned int *block_nump)
{
  unsigned long int plen;
  plen=strlen(config->prefix);
  unsigned int block_num = (unsigned int)0;
  signed int i;
  signed int return_value_strncmp$1;
  return_value_strncmp$1=strncmp(name, config->prefix, plen);
  signed int tmp_if_expr$4;
  signed int return_value_tolower$3;
  _Bool tmp_if_expr$5;
  _Bool tmp_if_expr$6;
  if(!(return_value_strncmp$1 == 0))
    return -1;

  else
  {
    name = name + (signed long int)plen;
    i = 0;
    for( ; !(i >= (signed int)(sizeof(unsigned int) * 2) /*8*/ ); i = i + 1)
    {
      char ch = name[(signed long int)i];
      const unsigned short int **return_value___ctype_b_loc$2;
      return_value___ctype_b_loc$2=__ctype_b_loc();
      if((4096 & (signed int)(*return_value___ctype_b_loc$2)[(signed long int)(signed int)ch]) == 0)
        break;

      block_num = block_num << 4;
      if(!((signed int)ch >= 58))
        tmp_if_expr$4 = (signed int)ch - 48;

      else
      {
        return_value_tolower$3=tolower((signed int)ch);
        tmp_if_expr$4 = (return_value_tolower$3 - 97) + 10;
      }
      block_num = block_num | (unsigned int)tmp_if_expr$4;
    }
    if(!(i == (signed int)(sizeof(unsigned int) * 2) /*8*/ ))
      tmp_if_expr$5 = (_Bool)1;

    else
      tmp_if_expr$5 = (signed int)name[(signed long int)i] != 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$5)
      tmp_if_expr$6 = (_Bool)1;

    else
      tmp_if_expr$6 = (signed long int)block_num >= config->num_blocks ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr$6)
      return -1;

    else
    {
      *block_nump = block_num;
      return 0;
    }
  }
}

// http_io_parse_hex
// file http_io.c line 2637
static signed int http_io_parse_hex(const char *str, unsigned char *buf, unsigned int nbytes)
{
  signed int i = 0;
  signed int tmp_if_expr$3;
  signed int return_value_tolower$2;
  for( ; !((unsigned int)i >= nbytes); i = i + 1)
  {
    signed int byte;
    signed int j = 0;
    byte = j;
    for( ; !(j >= 2); j = j + 1)
    {
      const char ch = str[(signed long int)(2 * i + j)];
      const unsigned short int **return_value___ctype_b_loc$1;
      return_value___ctype_b_loc$1=__ctype_b_loc();
      if((4096 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)ch]) == 0)
      {
        memset((void *)buf, 0, (unsigned long int)nbytes);
        return -1;
      }

      byte = byte << 4;
      if(!((signed int)ch >= 58))
        tmp_if_expr$3 = (signed int)ch - 48;

      else
      {
        return_value_tolower$2=tolower((signed int)ch);
        tmp_if_expr$3 = (return_value_tolower$2 - 97) + 10;
      }
      byte = byte | tmp_if_expr$3;
    }
    buf[(signed long int)i] = (unsigned char)byte;
  }
  return 0;
}

// http_io_perform_io
// file http_io.c line 1586
static signed int http_io_perform_io(struct http_io_private *priv, struct http_io *io, void (*prepper)(void *, struct http_io *))
{
  struct http_io_conf * const http_io_perform_io$$1$$config = priv->config;
  struct timespec delay;
  enum anonymous$4 curl_code;
  unsigned int retry_pause = (unsigned int)0;
  unsigned int total_pause;
  signed long int http_code;
  double clen;
  signed int attempt;
  void *curl;
  if(!(http_io_perform_io$$1$$config->debug == 0))
    http_io_perform_io$$1$$config->log(7, "%s %s", io->method, io->url);

  attempt = 0;
  total_pause = (unsigned int)0;
  enum anonymous$4 tmp_statement_expression$1;
  signed int return_value_strcmp$2;
  enum anonymous$4 tmp_statement_expression$4;
  enum anonymous$4 tmp_statement_expression$6;
  signed int return_value_strcmp$9;
  signed int return_value_strcmp$8;
  signed int return_value_strcmp$7;
  unsigned int tmp_if_expr$12;
  {
    curl=http_io_acquire_curl(priv, io);
    if(curl == NULL)
      return 5;

    prepper(curl, io);
    if(attempt >= 1)
      http_io_perform_io$$1$$config->log(6, "retrying query (attempt #%d): %s %s", attempt + 1, io->method, io->url);

    curl_code=curl_easy_perform(curl);
    if((signed int)curl_code == 0 || (signed int)curl_code == CURLE_HTTP_RETURNED_ERROR)
    {
      signed int _curl_info = CURLINFO_RESPONSE_CODE;
      tmp_statement_expression$1=curl_easy_getinfo(curl, (enum anonymous$14)_curl_info, &http_code);
      if(!((signed int)tmp_statement_expression$1 == 0))
        http_code = (signed long int)999;

    }

    http_code = (signed long int)-1;
    if(http_code == 304l && (signed int)curl_code == 0)
      curl_code = (enum anonymous$4)CURLE_HTTP_RETURNED_ERROR;

    if(http_code == 404l && (signed int)curl_code == CURLE_HTTP_RETURNED_ERROR)
    {
      return_value_strcmp$2=strcmp(io->method, "DELETE");
      if(return_value_strcmp$2 == 0)
        curl_code = (enum anonymous$4)0;

    }

    if((signed int)curl_code == 0)
    {
      double curl_time;
      signed int r = 0;
      if(!(http_io_perform_io$$1$$config->debug == 0))
        http_io_perform_io$$1$$config->log(7, "success: %s %s", io->method, io->url);

      signed int http_io_perform_io$$1$$1$$1$$2$$1$$_curl_info = CURLINFO_TOTAL_TIME;
      tmp_statement_expression$4=curl_easy_getinfo(curl, (enum anonymous$14)http_io_perform_io$$1$$1$$1$$2$$1$$_curl_info, &curl_time);
      curl_code = tmp_statement_expression$4;
      if(!((signed int)curl_code == CURLE_OK))
      {
        const char *return_value_curl_easy_strerror$3;
        return_value_curl_easy_strerror$3=curl_easy_strerror(curl_code);
        http_io_perform_io$$1$$config->log(3, "can't get cURL timing: %s", return_value_curl_easy_strerror$3);
        curl_time = 0.0;
      }

      if(!(io->content_lengthp == ((unsigned int *)NULL)))
      {
        signed int http_io_perform_io$$1$$1$$1$$2$$3$$1$$_curl_info = CURLINFO_CONTENT_LENGTH_DOWNLOAD;
        tmp_statement_expression$6=curl_easy_getinfo(curl, (enum anonymous$14)http_io_perform_io$$1$$1$$1$$2$$3$$1$$_curl_info, &clen);
        curl_code = tmp_statement_expression$6;
        if((signed int)curl_code == CURLE_OK)
          *io->content_lengthp = (unsigned int)clen;

        else
        {
          const char *return_value_curl_easy_strerror$5;
          return_value_curl_easy_strerror$5=curl_easy_strerror(curl_code);
          http_io_perform_io$$1$$config->log(3, "can't get content-length: %s", return_value_curl_easy_strerror$5);
          r = 6;
        }
      }

      pthread_mutex_lock(&priv->mutex);
      signed int return_value_strcmp$10;
      return_value_strcmp$10=strcmp(io->method, "GET");
      if(return_value_strcmp$10 == 0)
      {
        priv->stats.http_gets.count = priv->stats.http_gets.count + 1u;
        priv->stats.http_gets.time = priv->stats.http_gets.time + curl_time;
      }

      else
      {
        return_value_strcmp$9=strcmp(io->method, "PUT");
        if(return_value_strcmp$9 == 0)
        {
          priv->stats.http_puts.count = priv->stats.http_puts.count + 1u;
          priv->stats.http_puts.time = priv->stats.http_puts.time + curl_time;
        }

        else
        {
          return_value_strcmp$8=strcmp(io->method, "DELETE");
          if(return_value_strcmp$8 == 0)
          {
            priv->stats.http_deletes.count = priv->stats.http_deletes.count + 1u;
            priv->stats.http_deletes.time = priv->stats.http_deletes.time + curl_time;
          }

          else
          {
            return_value_strcmp$7=strcmp(io->method, "HEAD");
            if(return_value_strcmp$7 == 0)
            {
              priv->stats.http_heads.count = priv->stats.http_heads.count + 1u;
              priv->stats.http_heads.time = priv->stats.http_heads.time + curl_time;
            }

          }
        }
      }
      pthread_mutex_unlock(&priv->mutex);
      http_io_release_curl(priv, &curl, (signed int)(r == 0));
      return r;
    }

    http_io_release_curl(priv, &curl, 0);
    if((signed int)curl_code == CURLE_ABORTED_BY_CALLBACK)
    {
      if(!(http_io_perform_io$$1$$config->debug == 0))
        http_io_perform_io$$1$$config->log(7, "write aborted: %s %s", io->method, io->url);

      pthread_mutex_lock(&priv->mutex);
      priv->stats.http_canceled_writes = priv->stats.http_canceled_writes + 1u;
      pthread_mutex_unlock(&priv->mutex);
      return 103;
      http_io_perform_io$$1$$config->log(5, "operation timeout: %s %s", io->method, io->url);
      pthread_mutex_lock(&priv->mutex);
      priv->stats.curl_timeouts = priv->stats.curl_timeouts + 1u;
      pthread_mutex_unlock(&priv->mutex);
      if(http_code == 404l)
      {
        if(!(http_io_perform_io$$1$$config->debug == 0))
          http_io_perform_io$$1$$config->log(7, "rec'd %ld response: %s %s", http_code, io->method, io->url);

        return 2;
        http_io_perform_io$$1$$config->log(3, "rec'd %ld response: %s %s", http_code, io->method, io->url);
        pthread_mutex_lock(&priv->mutex);
        priv->stats.http_unauthorized = priv->stats.http_unauthorized + 1u;
        pthread_mutex_unlock(&priv->mutex);
        return 13;
        http_io_perform_io$$1$$config->log(3, "rec'd %ld response: %s %s", http_code, io->method, io->url);
        pthread_mutex_lock(&priv->mutex);
        priv->stats.http_forbidden = priv->stats.http_forbidden + 1u;
        pthread_mutex_unlock(&priv->mutex);
        return 1;
        http_io_perform_io$$1$$config->log(6, "rec'd stale content: %s %s", io->method, io->url);
        pthread_mutex_lock(&priv->mutex);
        priv->stats.http_stale = priv->stats.http_stale + 1u;
        pthread_mutex_unlock(&priv->mutex);
        if(!(io->expect_304 == 0u))
        {
          if(!(http_io_perform_io$$1$$config->debug == 0))
            http_io_perform_io$$1$$config->log(7, "rec'd %ld response: %s %s", http_code, io->method, io->url);

          return 17;
        }

      }

      http_io_perform_io$$1$$config->log(3, "rec'd %ld response: %s %s", http_code, io->method, io->url);
      pthread_mutex_lock(&priv->mutex);
      if(http_code / 100l == 4l)
      {
        priv->stats.http_4xx_error = priv->stats.http_4xx_error + 1u;
        priv->stats.http_5xx_error = priv->stats.http_5xx_error + 1u;
      }

      priv->stats.http_other_error = priv->stats.http_other_error + 1u;
      pthread_mutex_unlock(&priv->mutex);
    }

    const char *return_value_curl_easy_strerror$11;
    return_value_curl_easy_strerror$11=curl_easy_strerror(curl_code);
    http_io_perform_io$$1$$config->log(3, "operation failed: %s (%s)", return_value_curl_easy_strerror$11, total_pause >= http_io_perform_io$$1$$config->max_retry_pause ? "final attempt" : "will retry");
    pthread_mutex_lock(&priv->mutex);
    if((signed int)curl_code == CURLE_OUT_OF_MEMORY)
    {
      priv->stats.curl_out_of_memory = priv->stats.curl_out_of_memory + 1u;
      priv->stats.curl_connect_failed = priv->stats.curl_connect_failed + 1u;
      priv->stats.curl_host_unknown = priv->stats.curl_host_unknown + 1u;
    }

    priv->stats.curl_other_error = priv->stats.curl_other_error + 1u;
    pthread_mutex_unlock(&priv->mutex);
    if(!(total_pause >= http_io_perform_io$$1$$config->max_retry_pause))
    {
      if(retry_pause >= 1u)
        tmp_if_expr$12 = retry_pause * (unsigned int)2;

      else
        tmp_if_expr$12 = http_io_perform_io$$1$$config->initial_retry_pause;
      retry_pause = tmp_if_expr$12;
      if(!(http_io_perform_io$$1$$config->max_retry_pause >= retry_pause + total_pause))
        retry_pause = http_io_perform_io$$1$$config->max_retry_pause - total_pause;

      delay.tv_sec = (signed long int)(retry_pause / (unsigned int)1000);
      delay.tv_nsec = (signed long int)((retry_pause % (unsigned int)1000) * (unsigned int)1000000);
      nanosleep(&delay, (struct timespec *)(void *)0);
      pthread_mutex_lock(&priv->mutex);
      priv->stats.num_retries = priv->stats.num_retries + 1u;
      priv->stats.retry_delay = priv->stats.retry_delay + (unsigned long int)retry_pause;
      pthread_mutex_unlock(&priv->mutex);
      attempt = attempt + 1;
      total_pause = total_pause + retry_pause;
    }

  }
  http_io_perform_io$$1$$config->log(3, "giving up on: %s %s", io->method, io->url);
  return 5;
}

// http_io_prhex
// file http_io.c line 2664
static void http_io_prhex(char *buf, const unsigned char *data, unsigned long int len)
{
  signed int i = 0;
  for( ; !((unsigned long int)i >= len); i = i + 1)
  {
    static const char *hexdig = "0123456789abcdef";
    buf[(signed long int)(i * 2 + 0)] = hexdig[(signed long int)((signed int)data[(signed long int)i] >> 4)];
    buf[(signed long int)(i * 2 + 1)] = hexdig[(signed long int)((signed int)data[(signed long int)i] & 0x0f)];
  }
  buf[(signed long int)(i * 2)] = (char)0;
}

// http_io_read_block
// file http_io.c line 1033
static signed int http_io_read_block(struct s3backer_store * const s3b, unsigned int block_num, void *dest, unsigned char *actual_md5, const unsigned char *expect_md5, signed int strict)
{
  struct http_io_private * const priv = (struct http_io_private *)s3b->data;
  struct http_io_conf * const http_io_read_block$$1$$config = priv->config;
  signed long int config$array_size0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(http_io_read_block$$1$$config->baseURL);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(http_io_read_block$$1$$config->bucket);
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(http_io_read_block$$1$$config->prefix);
  config$array_size0 = (signed long int)(return_value_strlen$1 + return_value_strlen$2 + return_value_strlen$3 + (unsigned long int)(signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2) + (unsigned long int)2);
  char urlbuf[config$array_size0];
  signed long int now;
  now=time((signed long int *)(void *)0);
  signed int encrypted = 0;
  struct http_io io;
  unsigned int did_read;
  char *layer;
  signed int r;
  _Bool tmp_if_expr$4;
  if(http_io_read_block$$1$$config->block_size == 0u)
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = (signed long int)block_num >= http_io_read_block$$1$$config->num_blocks ? (_Bool)1 : (_Bool)0;
  signed int return_value_memcmp$8;
  _Bool tmp_if_expr$9;
  char *tmp_post$10;
  signed int return_value_strncasecmp$21;
  signed int return_value_strcasecmp$24;
  char *return_value_strerror$23;
  if(tmp_if_expr$4)
    return 22;

  else
  {
    if(!(priv->non_zero == ((unsigned int *)NULL)))
    {
      const signed int bits_per_word = (const signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)8);
      const signed int word = (const signed int)(block_num / (unsigned int)bits_per_word);
      const signed int bit = 1 << block_num % (unsigned int)bits_per_word;
      pthread_mutex_lock(&priv->mutex);
      if((priv->non_zero[(signed long int)word] & (unsigned int)bit) == 0u)
      {
        priv->stats.empty_blocks_read = priv->stats.empty_blocks_read + 1u;
        pthread_mutex_unlock(&priv->mutex);
        memset(dest, 0, (unsigned long int)http_io_read_block$$1$$config->block_size);
        if(!(actual_md5 == ((unsigned char *)NULL)))
          memset((void *)actual_md5, 0, (unsigned long int)16);

        return 0;
      }

      pthread_mutex_unlock(&priv->mutex);
    }

    memset((void *)&io, 0, sizeof(struct http_io) /*272ul*/ );
    io.url = urlbuf;
    io.method = "GET";
    io.block_num = block_num;
    unsigned long int return_value_compressBound$5;
    return_value_compressBound$5=compressBound((unsigned long int)http_io_read_block$$1$$config->block_size);
    io.buf_size = (unsigned int)(return_value_compressBound$5 + (unsigned long int)16);
    io.dest=malloc((unsigned long int)io.buf_size);
    if(io.dest == NULL)
    {
      signed int *return_value___errno_location$6;
      return_value___errno_location$6=__errno_location();
      char *return_value_strerror$7;
      return_value_strerror$7=strerror(*return_value___errno_location$6);
      http_io_read_block$$1$$config->log(3, "malloc: %s", return_value_strerror$7);
      pthread_mutex_lock(&priv->mutex);
      priv->stats.out_of_memory_errors = priv->stats.out_of_memory_errors + 1u;
      pthread_mutex_unlock(&priv->mutex);
      return 12;
    }

    http_io_get_block_url(urlbuf, (unsigned long int)config$array_size0, http_io_read_block$$1$$config, block_num);
    http_io_add_date(priv, &io, now);
    if(!(expect_md5 == ((const unsigned char *)NULL)))
    {
      return_value_memcmp$8=memcmp((const void *)expect_md5, (const void *)zero_md5$link1, (unsigned long int)16);
      if(!(return_value_memcmp$8 == 0))
      {
        char md5buf[33l];
        const char *header;
        if(!(strict == 0))
          header = "If-Match";

        else
        {
          header = "If-None-Match";
          io.expect_304 = (unsigned int)1;
        }
        http_io_prhex(md5buf, expect_md5, (unsigned long int)16);
        io.headers=http_io_add_header(io.headers, "%s: \"%s\"", header, (const void *)md5buf);
      }

    }

    r=http_io_add_auth(priv, &io, now, (void *)0, (unsigned long int)0);
    if(r == 0)
    {
      r=http_io_perform_io(priv, &io, http_io_read_prepper);
      did_read = (unsigned int)((unsigned long int)io.buf_size - io.bufs.rdremain);
      do
      {
        if(r == 0)
          tmp_if_expr$9 = (signed int)io.content_encoding[0l] != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr$9 = (_Bool)0;
        if(!tmp_if_expr$9)
          break;

        layer=strrchr(io.content_encoding, 44);
        if(!(layer == ((char *)NULL)))
        {
          tmp_post$10 = layer;
          layer = layer + 1l;
          *tmp_post$10 = (char)0;
        }

        else
          layer = io.content_encoding;
        if(!(io.dest == NULL))
        {
          return_value_strncasecmp$21=strncasecmp(layer, "encrypt-", sizeof(char [8l]) /*8ul*/ );
          if(return_value_strncasecmp$21 == 0)
          {
            const char * const block_cipher = layer + (signed long int)sizeof(char [8l]) /*8ul*/ ;
            unsigned char hmac[20l];
            unsigned char *buf;
            if(http_io_read_block$$1$$config->encryption == ((const char *)NULL))
            {
              http_io_read_block$$1$$config->log(3, "block %0*jx is encrypted with `%s' but `--encrypt' was not specified", (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)block_num, block_cipher);
              r = 5;
              break;
            }

            signed int return_value_EVP_CIPHER_nid$13;
            return_value_EVP_CIPHER_nid$13=EVP_CIPHER_nid(priv->cipher);
            const char *return_value_OBJ_nid2sn$14;
            return_value_OBJ_nid2sn$14=OBJ_nid2sn(return_value_EVP_CIPHER_nid$13);
            signed int return_value_strcasecmp$15;
            return_value_strcasecmp$15=strcasecmp(block_cipher, return_value_OBJ_nid2sn$14);
            if(!(return_value_strcasecmp$15 == 0))
            {
              signed int return_value_EVP_CIPHER_nid$11;
              return_value_EVP_CIPHER_nid$11=EVP_CIPHER_nid(priv->cipher);
              const char *return_value_OBJ_nid2sn$12;
              return_value_OBJ_nid2sn$12=OBJ_nid2sn(return_value_EVP_CIPHER_nid$11);
              http_io_read_block$$1$$config->log(3, "block %0*jx was encrypted using `%s' but `%s' encryption is configured", (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)block_num, block_cipher, return_value_OBJ_nid2sn$12);
              r = 5;
              break;
            }

            signed int return_value_memcmp$16;
            return_value_memcmp$16=memcmp((const void *)io.hmac, (const void *)zero_hmac, sizeof(unsigned char [20l]) /*20ul*/ );
            if(return_value_memcmp$16 == 0)
            {
              http_io_read_block$$1$$config->log(3, "block %0*jx is encrypted, but no signature was found", (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)block_num);
              r = 5;
              break;
            }

            http_io_authsig(priv, block_num, (const unsigned char *)io.dest, did_read, hmac);
            signed int return_value_memcmp$17;
            return_value_memcmp$17=memcmp((const void *)io.hmac, (const void *)hmac, sizeof(unsigned char [20l]) /*20ul*/ );
            if(!(return_value_memcmp$17 == 0))
            {
              http_io_read_block$$1$$config->log(3, "block %0*jx has an incorrect signature (did you provide the right password?)", (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)block_num);
              r = 5;
              break;
            }

            void *return_value_malloc$20;
            return_value_malloc$20=malloc((unsigned long int)(did_read + (unsigned int)16));
            buf = (unsigned char *)return_value_malloc$20;
            if(buf == ((unsigned char *)NULL))
            {
              signed int *return_value___errno_location$18;
              return_value___errno_location$18=__errno_location();
              char *return_value_strerror$19;
              return_value_strerror$19=strerror(*return_value___errno_location$18);
              http_io_read_block$$1$$config->log(3, "malloc: %s", return_value_strerror$19);
              pthread_mutex_lock(&priv->mutex);
              priv->stats.out_of_memory_errors = priv->stats.out_of_memory_errors + 1u;
              pthread_mutex_unlock(&priv->mutex);
              r = 12;
              break;
            }

            did_read=http_io_crypt(priv, block_num, 0, (const unsigned char *)io.dest, did_read, buf);
            memcpy(io.dest, (const void *)buf, (unsigned long int)did_read);
            free((void *)buf);
            encrypted = 1;
            goto __CPROVER_DUMP_L29;
          }

          return_value_strcasecmp$24=strcasecmp(layer, "deflate");
          if(return_value_strcasecmp$24 == 0)
          {
            unsigned long int uclen = (unsigned long int)http_io_read_block$$1$$config->block_size;
            signed int return_value_uncompress$22;
            return_value_uncompress$22=uncompress((unsigned char *)dest, &uclen, (const unsigned char *)io.dest, (unsigned long int)did_read);
            if(!(return_value_uncompress$22 == 0))
            {
              if(return_value_uncompress$22 == -4)
                goto __CPROVER_DUMP_L23;

              if(return_value_uncompress$22 == -5)
                goto __CPROVER_DUMP_L24;

              if(return_value_uncompress$22 == -3)
                goto __CPROVER_DUMP_L25;

            }

            else
            {
              did_read = (unsigned int)uclen;
              free(io.dest);
              io.dest = (void *)0;
              r = 0;
              goto __CPROVER_DUMP_L27;

            __CPROVER_DUMP_L23:
              ;
              return_value_strerror$23=strerror(12);
              http_io_read_block$$1$$config->log(3, "zlib uncompress: %s", return_value_strerror$23);
              pthread_mutex_lock(&priv->mutex);
              priv->stats.out_of_memory_errors = priv->stats.out_of_memory_errors + 1u;
              pthread_mutex_unlock(&priv->mutex);
              r = 12;

            __CPROVER_DUMP_L24:
              ;
              http_io_read_block$$1$$config->log(3, "zlib uncompress: %s", (const void *)"decompressed block is oversize");
              r = 5;

            __CPROVER_DUMP_L25:
              ;
              http_io_read_block$$1$$config->log(3, "zlib uncompress: %s", (const void *)"data is corrupted or truncated");
              r = 5;
            }
            http_io_read_block$$1$$config->log(3, "unknown zlib compress2() error %d", r);
            r = 5;

          __CPROVER_DUMP_L27:
            ;
            goto __CPROVER_DUMP_L29;
          }

        }


      bad_encoding:
        ;
        http_io_read_block$$1$$config->log(3, "read of block %0*jx returned unexpected encoding \"%s\"", (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)block_num, layer);
        r = 5;
        break;

      __CPROVER_DUMP_L29:
        ;
        *layer = (char)0;
      }
      while((_Bool)1);
      if(r == 0)
      {
        if(!(http_io_read_block$$1$$config->encryption == ((const char *)NULL)))
        {
          if(encrypted == 0)
          {
            http_io_read_block$$1$$config->log(3, "block %0*jx was supposed to be encrypted but wasn't", (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)block_num);
            r = 5;
          }

        }

      }

      if(r == 0)
      {
        if(!(did_read == http_io_read_block$$1$$config->block_size))
        {
          http_io_read_block$$1$$config->log(3, "read of block %0*jx returned %lu != %lu bytes", (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)block_num, (unsigned long int)did_read, (unsigned long int)http_io_read_block$$1$$config->block_size);
          r = 5;
        }

      }

      if(r == 0 && !(io.dest == NULL))
        memcpy(dest, io.dest, (unsigned long int)http_io_read_block$$1$$config->block_size);

      pthread_mutex_lock(&priv->mutex);
      switch(r)
      {
        case 0:
        {
          priv->stats.normal_blocks_read = priv->stats.normal_blocks_read + 1u;
          break;
        }
        case 2:
          priv->stats.zero_blocks_read = priv->stats.zero_blocks_read + 1u;
      }
      pthread_mutex_unlock(&priv->mutex);
      if(!(expect_md5 == ((const unsigned char *)NULL)))
      {
        signed int expected_not_found;
        signed int return_value_memcmp$25;
        return_value_memcmp$25=memcmp((const void *)expect_md5, (const void *)zero_md5$link1, (unsigned long int)16);
        expected_not_found = (const signed int)(return_value_memcmp$25 == 0);
        switch(r)
        {
          case 0:
          {
            if(!(expected_not_found == 0))
              r = strict != 0 ? 5 : 0;

            break;
          }
          case 2:
            if(!(expected_not_found == 0))
              r = strict != 0 ? 0 : 17;

        }
        if(strict == 0)
          switch(r)
          {
            case 0:
            {
              pthread_mutex_lock(&priv->mutex);
              priv->stats.http_mismatch = priv->stats.http_mismatch + 1u;
              pthread_mutex_unlock(&priv->mutex);
              break;
            }
            case 17:
            {
              pthread_mutex_lock(&priv->mutex);
              priv->stats.http_verified = priv->stats.http_verified + 1u;
              pthread_mutex_unlock(&priv->mutex);
            }
          }

      }

      if(r == 2)
      {
        memset(dest, 0, (unsigned long int)http_io_read_block$$1$$config->block_size);
        r = 0;
      }

      if(!(actual_md5 == ((unsigned char *)NULL)))
        memcpy((void *)actual_md5, (const void *)io.md5, (unsigned long int)16);

    }


  fail:
    ;
    if(!(io.dest == NULL))
      free(io.dest);

    curl_slist_free_all(io.headers);
    return r;
  }
}

// http_io_read_block_part
// file http_io.c line 1565
static signed int http_io_read_block_part(struct s3backer_store *s3b, unsigned int block_num, unsigned int off, unsigned int len, void *dest)
{
  struct http_io_private * const priv = (struct http_io_private *)s3b->data;
  struct http_io_conf * const http_io_read_block_part$$1$$config = priv->config;
  signed int return_value_block_part_read_block_part$1;
  return_value_block_part_read_block_part$1=block_part_read_block_part(s3b, block_num, http_io_read_block_part$$1$$config->block_size, off, len, dest);
  return return_value_block_part_read_block_part$1;
}

// http_io_read_prepper
// file http_io.c line 1316
static void http_io_read_prepper(void *curl, struct http_io *io)
{
  memset((void *)&io->bufs, 0, sizeof(struct http_io_bufs) /*32ul*/ );
  io->bufs.rdremain = (unsigned long int)io->buf_size;
  io->bufs.rddata = (char *)io->dest;
  signed int _curl_opt = CURLOPT_WRITEFUNCTION;
  curl_easy_setopt(curl, (enum anonymous$12)_curl_opt, http_io_curl_reader);
  signed int http_io_read_prepper$$1$$2$$_curl_opt = CURLOPT_WRITEDATA;
  curl_easy_setopt(curl, (enum anonymous$12)http_io_read_prepper$$1$$2$$_curl_opt, io);
  signed int http_io_read_prepper$$1$$3$$_curl_opt = CURLOPT_MAXFILESIZE_LARGE;
  if((_Bool)0)
  {
    if(http_io_read_prepper$$1$$3$$_curl_opt >= 30001)
    {
      goto __CPROVER_DUMP_L42;
      _curl_easy_setopt_err_curl_off_t();
    }


  __CPROVER_DUMP_L42:
    ;
    if(http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_URL || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_PROXY || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_USERPWD || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_PROXYUSERPWD || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_RANGE || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_REFERER || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_FTPPORT || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_USERAGENT || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_COOKIE || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_SSLCERT || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_KEYPASSWD || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_COOKIEFILE || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_CUSTOMREQUEST || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_INTERFACE || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_KRBLEVEL || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_CAINFO || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_RANDOM_FILE || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_EGDSOCKET || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_COOKIEJAR || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_SSL_CIPHER_LIST || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_SSLCERTTYPE || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_SSLKEY || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_SSLKEYTYPE || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_SSLENGINE || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_CAPATH || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_ACCEPT_ENCODING || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_NETRC_FILE || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_FTP_ACCOUNT || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_COOKIELIST || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_FTP_ALTERNATIVE_TO_USER || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_SSH_PUBLIC_KEYFILE || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_SSH_PRIVATE_KEYFILE || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_SSH_HOST_PUBLIC_KEY_MD5 || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_CRLFILE || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_ISSUERCERT || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_USERNAME || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_PASSWORD || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_PROXYUSERNAME || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_PROXYPASSWORD || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_NOPROXY || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_SOCKS5_GSSAPI_SERVICE || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_SSH_KNOWNHOSTS || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_MAIL_FROM || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_RTSP_SESSION_ID || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_RTSP_STREAM_URI || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_RTSP_TRANSPORT || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_TLSAUTH_USERNAME || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_TLSAUTH_PASSWORD || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_TLSAUTH_TYPE || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_DNS_SERVERS || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_MAIL_AUTH || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_XOAUTH2_BEARER || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_DNS_INTERFACE || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_DNS_LOCAL_IP4 || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_DNS_LOCAL_IP6 || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_LOGIN_OPTIONS || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_PINNEDPUBLICKEY || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_UNIX_SOCKET_PATH || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_PROXY_SERVICE_NAME || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_SERVICE_NAME || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_DEFAULT_PROTOCOL)
      _curl_easy_setopt_err_string();

    if(http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_WRITEFUNCTION || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_HEADERFUNCTION)
      _curl_easy_setopt_err_write_callback();

    if(http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_READFUNCTION)
      _curl_easy_setopt_err_read_cb();

    if(http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_IOCTLFUNCTION)
      _curl_easy_setopt_err_ioctl_cb();

    if(http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_SOCKOPTFUNCTION)
      _curl_easy_setopt_err_sockopt_cb();

    if(http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_OPENSOCKETFUNCTION)
      _curl_easy_setopt_err_opensocket_cb();

    if(http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_PROGRESSFUNCTION)
      _curl_easy_setopt_err_progress_cb();

    if(http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_DEBUGFUNCTION)
      _curl_easy_setopt_err_debug_cb();

    if(http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_SSL_CTX_FUNCTION)
      _curl_easy_setopt_err_ssl_ctx_cb();

    if(http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_CONV_FROM_NETWORK_FUNCTION || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_CONV_TO_NETWORK_FUNCTION || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_CONV_FROM_UTF8_FUNCTION)
      _curl_easy_setopt_err_conv_cb();

    if(http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_SEEKFUNCTION)
      _curl_easy_setopt_err_seek_cb();

    if(http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_ERRORBUFFER)
      _curl_easy_setopt_err_error_buffer();

    if(http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_STDERR)
      _curl_easy_setopt_err_FILE();

    if(http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_POSTFIELDS || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_COPYPOSTFIELDS)
      _curl_easy_setopt_err_postfields();

    if(http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_HTTPPOST)
      _curl_easy_setopt_err_curl_httpost();

    if(http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_HTTPHEADER || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_QUOTE || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_POSTQUOTE || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_TELNETOPTIONS || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_PREQUOTE || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_HTTP200ALIASES || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_MAIL_RCPT || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_RESOLVE || http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_PROXYHEADER)
      _curl_easy_setopt_err_curl_slist();

    if(http_io_read_prepper$$1$$3$$_curl_opt == CURLOPT_SHARE)
      _curl_easy_setopt_err_CURLSH();

  }

  curl_easy_setopt(curl, (enum anonymous$12)http_io_read_prepper$$1$$3$$_curl_opt, (signed long int)io->buf_size);
  signed int http_io_read_prepper$$1$$4$$_curl_opt = CURLOPT_HTTPHEADER;
  curl_easy_setopt(curl, (enum anonymous$12)http_io_read_prepper$$1$$4$$_curl_opt, io->headers);
  signed int http_io_read_prepper$$1$$5$$_curl_opt = CURLOPT_HEADERFUNCTION;
  curl_easy_setopt(curl, (enum anonymous$12)http_io_read_prepper$$1$$5$$_curl_opt, http_io_curl_header);
  signed int http_io_read_prepper$$1$$6$$_curl_opt = CURLOPT_HEADERDATA;
  curl_easy_setopt(curl, (enum anonymous$12)http_io_read_prepper$$1$$6$$_curl_opt, io);
  signed int http_io_read_prepper$$1$$7$$_curl_opt = CURLOPT_ACCEPT_ENCODING;
  curl_easy_setopt(curl, (enum anonymous$12)http_io_read_prepper$$1$$7$$_curl_opt, (const void *)"");
  signed int http_io_read_prepper$$1$$8$$_curl_opt = CURLOPT_HTTP_CONTENT_DECODING;
  if((_Bool)0)
  {
    if(http_io_read_prepper$$1$$8$$_curl_opt >= 30001)
    {
      goto __CPROVER_DUMP_L142;
      _curl_easy_setopt_err_curl_off_t();
    }


  __CPROVER_DUMP_L142:
    ;
    if(http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_URL || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_PROXY || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_USERPWD || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_PROXYUSERPWD || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_RANGE || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_REFERER || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_FTPPORT || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_USERAGENT || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_COOKIE || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_SSLCERT || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_KEYPASSWD || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_COOKIEFILE || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_CUSTOMREQUEST || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_INTERFACE || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_KRBLEVEL || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_CAINFO || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_RANDOM_FILE || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_EGDSOCKET || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_COOKIEJAR || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_SSL_CIPHER_LIST || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_SSLCERTTYPE || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_SSLKEY || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_SSLKEYTYPE || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_SSLENGINE || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_CAPATH || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_ACCEPT_ENCODING || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_NETRC_FILE || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_FTP_ACCOUNT || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_COOKIELIST || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_FTP_ALTERNATIVE_TO_USER || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_SSH_PUBLIC_KEYFILE || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_SSH_PRIVATE_KEYFILE || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_SSH_HOST_PUBLIC_KEY_MD5 || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_CRLFILE || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_ISSUERCERT || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_USERNAME || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_PASSWORD || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_PROXYUSERNAME || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_PROXYPASSWORD || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_NOPROXY || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_SOCKS5_GSSAPI_SERVICE || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_SSH_KNOWNHOSTS || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_MAIL_FROM || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_RTSP_SESSION_ID || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_RTSP_STREAM_URI || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_RTSP_TRANSPORT || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_TLSAUTH_USERNAME || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_TLSAUTH_PASSWORD || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_TLSAUTH_TYPE || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_DNS_SERVERS || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_MAIL_AUTH || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_XOAUTH2_BEARER || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_DNS_INTERFACE || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_DNS_LOCAL_IP4 || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_DNS_LOCAL_IP6 || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_LOGIN_OPTIONS || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_PINNEDPUBLICKEY || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_UNIX_SOCKET_PATH || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_PROXY_SERVICE_NAME || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_SERVICE_NAME || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_DEFAULT_PROTOCOL)
      _curl_easy_setopt_err_string();

    if(http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_WRITEFUNCTION || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_HEADERFUNCTION)
      _curl_easy_setopt_err_write_callback();

    if(http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_READFUNCTION)
      _curl_easy_setopt_err_read_cb();

    if(http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_IOCTLFUNCTION)
      _curl_easy_setopt_err_ioctl_cb();

    if(http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_SOCKOPTFUNCTION)
      _curl_easy_setopt_err_sockopt_cb();

    if(http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_OPENSOCKETFUNCTION)
      _curl_easy_setopt_err_opensocket_cb();

    if(http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_PROGRESSFUNCTION)
      _curl_easy_setopt_err_progress_cb();

    if(http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_DEBUGFUNCTION)
      _curl_easy_setopt_err_debug_cb();

    if(http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_SSL_CTX_FUNCTION)
      _curl_easy_setopt_err_ssl_ctx_cb();

    if(http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_CONV_FROM_NETWORK_FUNCTION || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_CONV_TO_NETWORK_FUNCTION || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_CONV_FROM_UTF8_FUNCTION)
      _curl_easy_setopt_err_conv_cb();

    if(http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_SEEKFUNCTION)
      _curl_easy_setopt_err_seek_cb();

    if(http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_ERRORBUFFER)
      _curl_easy_setopt_err_error_buffer();

    if(http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_STDERR)
      _curl_easy_setopt_err_FILE();

    if(http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_POSTFIELDS || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_COPYPOSTFIELDS)
      _curl_easy_setopt_err_postfields();

    if(http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_HTTPPOST)
      _curl_easy_setopt_err_curl_httpost();

    if(http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_HTTPHEADER || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_QUOTE || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_POSTQUOTE || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_TELNETOPTIONS || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_PREQUOTE || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_HTTP200ALIASES || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_MAIL_RCPT || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_RESOLVE || http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_PROXYHEADER)
      _curl_easy_setopt_err_curl_slist();

    if(http_io_read_prepper$$1$$8$$_curl_opt == CURLOPT_SHARE)
      _curl_easy_setopt_err_CURLSH();

  }

  curl_easy_setopt(curl, (enum anonymous$12)http_io_read_prepper$$1$$8$$_curl_opt, (signed long int)0);
}

// http_io_release_curl
// file http_io.c line 2435
static void http_io_release_curl(struct http_io_private *priv, void **curlp, signed int may_cache)
{
  struct curl_holder *holder;
  void * const curl = *curlp;
  *curlp = (void *)0;
  if(may_cache == 0)
    curl_easy_cleanup(curl);

  else
  {
    void *return_value_calloc$1;
    return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct curl_holder) /*24ul*/ );
    holder = (struct curl_holder *)return_value_calloc$1;
    if(holder == ((struct curl_holder *)NULL))
    {
      curl_easy_cleanup(curl);
      pthread_mutex_lock(&priv->mutex);
      priv->stats.out_of_memory_errors = priv->stats.out_of_memory_errors + 1u;
      pthread_mutex_unlock(&priv->mutex);
    }

    else
    {
      holder->curl = curl;
      pthread_mutex_lock(&priv->mutex);
      do
      {
        holder->link.le_next = (&priv->curls)->lh_first;
        if(!(holder->link.le_next == ((struct curl_holder *)NULL)))
          (&priv->curls)->lh_first->link.le_prev = &holder->link.le_next;

        (&priv->curls)->lh_first = holder;
        holder->link.le_prev = &(&priv->curls)->lh_first;
      }
      while((_Bool)0);
      pthread_mutex_unlock(&priv->mutex);
    }
  }
}

// http_io_set_mounted
// file http_io.c line 796
static signed int http_io_set_mounted(struct s3backer_store *s3b, signed int *old_valuep, signed int new_value)
{
  struct http_io_private * const priv = (struct http_io_private *)s3b->data;
  struct http_io_conf * const http_io_set_mounted$$1$$config = priv->config;
  signed long int config$array_size0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(http_io_set_mounted$$1$$config->baseURL);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(http_io_set_mounted$$1$$config->bucket);
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(http_io_set_mounted$$1$$config->prefix);
  config$array_size0 = (signed long int)(return_value_strlen$1 + return_value_strlen$2 + return_value_strlen$3 + (unsigned long int)(signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2) + (unsigned long int)2 + sizeof(char [17l]) /*17ul*/ );
  char urlbuf[config$array_size0];
  signed long int now;
  now=time((signed long int *)(void *)0);
  struct http_io io;
  signed int r = 0;
  memset((void *)&io, 0, sizeof(struct http_io) /*272ul*/ );
  io.url = urlbuf;
  io.method = "HEAD";
  http_io_get_mounted_flag_url(urlbuf, (unsigned long int)config$array_size0, http_io_set_mounted$$1$$config);
  if(!(old_valuep == ((signed int *)NULL)))
  {
    http_io_add_date(priv, &io, now);
    r=http_io_add_auth(priv, &io, now, (void *)0, (unsigned long int)0);
    if(!(r == 0))
      goto done;

    r=http_io_perform_io(priv, &io, http_io_head_prepper);
    switch(r)
    {
      case 2:
      {
        *old_valuep = 0;
        r = 0;
        goto __CPROVER_DUMP_L4;
      }
      case 0:
      {
        *old_valuep = 1;
        goto __CPROVER_DUMP_L4;
      }
      default:
        ;
    }
  }

  else
  {

  __CPROVER_DUMP_L4:
    ;
    if(!(new_value == -1))
    {
      char content[351l];
      unsigned char md5[16l];
      char md5buf[33l];
      struct MD5state_st ctx;
      curl_slist_free_all(io.headers);
      memset((void *)&io, 0, sizeof(struct http_io) /*272ul*/ );
      io.url = urlbuf;
      io.method = new_value != 0 ? "PUT" : "DELETE";
      http_io_add_date(priv, &io, now);
      if(!(new_value == 0))
      {
        struct tm tm;
        gethostname(content, sizeof(char *) /*8ul*/ );
        content[(signed long int)(sizeof(char [351l]) /*351ul*/  - (unsigned long int)1)] = (char)0;
        unsigned long int return_value_strlen$4;
        return_value_strlen$4=strlen(content);
        unsigned long int return_value_strlen$5;
        return_value_strlen$5=strlen(content);
        struct tm *return_value_gmtime_r$6;
        return_value_gmtime_r$6=gmtime_r(&now, &tm);
        strftime(content + (signed long int)return_value_strlen$4, sizeof(char [351l]) /*351ul*/  - return_value_strlen$5, "\n%Y%m%dT%H%M%SZ\n", return_value_gmtime_r$6);
        io.src = (const void *)content;
        unsigned long int return_value_strlen$7;
        return_value_strlen$7=strlen(content);
        io.buf_size = (unsigned int)return_value_strlen$7;
        MD5_Init(&ctx);
        unsigned long int return_value_strlen$8;
        return_value_strlen$8=strlen(content);
        MD5_Update(&ctx, (const void *)content, return_value_strlen$8);
        MD5_Final(md5, &ctx);
        io.headers=http_io_add_header(io.headers, "%s: %s", (const void *)"Content-Type", (const void *)"text/plain");
        http_io_base64_encode(md5buf, sizeof(char [33l]) /*33ul*/ , (const void *)md5, (unsigned long int)16);
        io.headers=http_io_add_header(io.headers, "%s: %s", (const void *)"Content-MD5", (const void *)md5buf);
      }

      if(!(new_value == 0))
        io.headers=http_io_add_header(io.headers, "%s: %s", (const void *)"x-amz-acl", http_io_set_mounted$$1$$config->accessType);

      if(!(http_io_set_mounted$$1$$config->rrs == 0))
        io.headers=http_io_add_header(io.headers, "%s: %s", (const void *)"x-amz-storage-class", (const void *)"REDUCED_REDUNDANCY");

      r=http_io_add_auth(priv, &io, now, io.src, (unsigned long int)io.buf_size);
      if(r == 0)
        r=http_io_perform_io(priv, &io, http_io_write_prepper);

    }

  }

done:
  ;
  curl_slist_free_all(io.headers);
  return r;
}

// http_io_strcasecmp_ptr
// file http_io.c line 2677
static signed int http_io_strcasecmp_ptr(const void * const ptr1, const void * const ptr2)
{
  const char * const str1 = *((const char * const *)ptr1);
  const char * const str2 = *((const char * const *)ptr2);
  signed int return_value_strcasecmp$1;
  return_value_strcasecmp$1=strcasecmp(str1, str2);
  return return_value_strcasecmp$1;
}

// http_io_write_block
// file http_io.c line 1335
static signed int http_io_write_block(struct s3backer_store * const s3b, unsigned int block_num, const void *src, unsigned char *caller_md5, signed int (*check_cancel)(void *, unsigned int), void *check_cancel_arg)
{
  struct http_io_private * const priv = (struct http_io_private *)s3b->data;
  struct http_io_conf * const http_io_write_block$$1$$config = priv->config;
  signed long int config$array_size0;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(http_io_write_block$$1$$config->baseURL);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(http_io_write_block$$1$$config->bucket);
  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(http_io_write_block$$1$$config->prefix);
  config$array_size0 = (signed long int)(return_value_strlen$1 + return_value_strlen$2 + return_value_strlen$3 + (unsigned long int)(signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2) + (unsigned long int)2);
  char urlbuf[config$array_size0];
  char md5buf[25l];
  char hmacbuf[41l];
  unsigned char hmac[20l];
  unsigned char md5[16l];
  signed long int now;
  now=time((signed long int *)(void *)0);
  void *encoded_buf = (void *)0;
  struct http_io io;
  signed int compressed = 0;
  signed int encrypted = 0;
  signed int r;
  _Bool tmp_if_expr$4;
  if(http_io_write_block$$1$$config->block_size == 0u)
    tmp_if_expr$4 = (_Bool)1;

  else
    tmp_if_expr$4 = (signed long int)block_num >= http_io_write_block$$1$$config->num_blocks ? (_Bool)1 : (_Bool)0;
  char *return_value_strerror$8;
  unsigned long int return_value_strlen$11;
  unsigned long int return_value_strlen$12;
  if(tmp_if_expr$4)
    return 22;

  else
  {
    if(!(src == NULL))
    {
      signed int return_value_http_io_is_zero_block$5;
      return_value_http_io_is_zero_block$5=http_io_is_zero_block(src, http_io_write_block$$1$$config->block_size);
      if(!(return_value_http_io_is_zero_block$5 == 0))
        src = (void *)0;

    }

    if(!(priv->non_zero == ((unsigned int *)NULL)))
    {
      const signed int bits_per_word = (const signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)8);
      const signed int word = (const signed int)(block_num / (unsigned int)bits_per_word);
      const signed int bit = 1 << block_num % (unsigned int)bits_per_word;
      pthread_mutex_lock(&priv->mutex);
      if(src == NULL)
      {
        if((priv->non_zero[(signed long int)word] & (unsigned int)bit) == 0u)
        {
          priv->stats.empty_blocks_written = priv->stats.empty_blocks_written + 1u;
          pthread_mutex_unlock(&priv->mutex);
          return 0;
        }

      }

      else
        priv->non_zero[(signed long int)word] = priv->non_zero[(signed long int)word] | (unsigned int)bit;
      pthread_mutex_unlock(&priv->mutex);
    }

    memset((void *)&io, 0, sizeof(struct http_io) /*272ul*/ );
    io.url = urlbuf;
    io.method = src != (void *)0 ? "PUT" : "DELETE";
    io.src = src;
    io.buf_size = http_io_write_block$$1$$config->block_size;
    io.block_num = block_num;
    io.check_cancel = check_cancel;
    io.check_cancel_arg = check_cancel_arg;
    if(!(src == NULL))
    {
      if(!(http_io_write_block$$1$$config->compress == 0))
      {
        unsigned long int compress_len;
        compress_len=compressBound((unsigned long int)io.buf_size);
        encoded_buf=malloc(compress_len);
        if(encoded_buf == NULL)
        {
          signed int *return_value___errno_location$6;
          return_value___errno_location$6=__errno_location();
          char *return_value_strerror$7;
          return_value_strerror$7=strerror(*return_value___errno_location$6);
          http_io_write_block$$1$$config->log(3, "malloc: %s", return_value_strerror$7);
          pthread_mutex_lock(&priv->mutex);
          priv->stats.out_of_memory_errors = priv->stats.out_of_memory_errors + 1u;
          pthread_mutex_unlock(&priv->mutex);
          r = 12;
        }

        r=compress2((unsigned char *)encoded_buf, &compress_len, (const unsigned char *)io.src, (unsigned long int)io.buf_size, http_io_write_block$$1$$config->compress);
        if(!(r == 0))
        {
          if(r == -4)
            goto __CPROVER_DUMP_L12;

        }

        else
        {
          goto __CPROVER_DUMP_L14;

        __CPROVER_DUMP_L12:
          ;
          return_value_strerror$8=strerror(12);
          http_io_write_block$$1$$config->log(3, "zlib compress: %s", return_value_strerror$8);
          pthread_mutex_lock(&priv->mutex);
          priv->stats.out_of_memory_errors = priv->stats.out_of_memory_errors + 1u;
          pthread_mutex_unlock(&priv->mutex);
          r = 12;
        }
        http_io_write_block$$1$$config->log(3, "unknown zlib compress2() error %d", r);
        r = 5;

      __CPROVER_DUMP_L14:
        ;
        io.src = encoded_buf;
        io.buf_size = (unsigned int)compress_len;
        compressed = 1;
      }

    }

    if(!(src == NULL))
    {
      if(!(http_io_write_block$$1$$config->encryption == ((const char *)NULL)))
      {
        void *encrypt_buf;
        unsigned int encrypt_len;
        encrypt_buf=malloc((unsigned long int)(io.buf_size + (unsigned int)16));
        if(encrypt_buf == NULL)
        {
          signed int *return_value___errno_location$9;
          return_value___errno_location$9=__errno_location();
          char *return_value_strerror$10;
          return_value_strerror$10=strerror(*return_value___errno_location$9);
          http_io_write_block$$1$$config->log(3, "malloc: %s", return_value_strerror$10);
          pthread_mutex_lock(&priv->mutex);
          priv->stats.out_of_memory_errors = priv->stats.out_of_memory_errors + 1u;
          pthread_mutex_unlock(&priv->mutex);
          r = 12;
        }

        encrypt_len=http_io_crypt(priv, block_num, 1, (const unsigned char *)io.src, io.buf_size, (unsigned char *)encrypt_buf);
        http_io_authsig(priv, block_num, (const unsigned char *)encrypt_buf, encrypt_len, hmac);
        http_io_prhex(hmacbuf, hmac, (unsigned long int)20);
        io.src = encrypt_buf;
        io.buf_size = encrypt_len;
        free(encoded_buf);
        encoded_buf = encrypt_buf;
        encrypted = 1;
      }

    }

    if(!(compressed == 0) || !(encrypted == 0))
    {
      char ebuf[128l];
      snprintf(ebuf, sizeof(char [128l]) /*128ul*/ , "%s: ", (const void *)"Content-Encoding");
      if(!(compressed == 0))
      {
        return_value_strlen$11=strlen(ebuf);
        return_value_strlen$12=strlen(ebuf);
        snprintf(ebuf + (signed long int)return_value_strlen$11, sizeof(char [128l]) /*128ul*/  - return_value_strlen$12, "%s", (const void *)"deflate");
      }

      if(!(encrypted == 0))
      {
        unsigned long int return_value_strlen$13;
        return_value_strlen$13=strlen(ebuf);
        unsigned long int return_value_strlen$14;
        return_value_strlen$14=strlen(ebuf);
        snprintf(ebuf + (signed long int)return_value_strlen$13, sizeof(char [128l]) /*128ul*/  - return_value_strlen$14, "%s%s-%s", compressed != 0 ? ", " : "", (const void *)"encrypt", http_io_write_block$$1$$config->encryption);
      }

      io.headers=http_io_add_header(io.headers, "%s", (const void *)ebuf);
    }

    if(!(src == NULL))
      MD5((const unsigned char *)io.src, (unsigned long int)io.buf_size, md5);

    else
      memset((void *)md5, 0, (unsigned long int)16);
    if(!(caller_md5 == ((unsigned char *)NULL)))
      memcpy((void *)caller_md5, (const void *)md5, (unsigned long int)16);

    http_io_get_block_url(urlbuf, (unsigned long int)config$array_size0, http_io_write_block$$1$$config, block_num);
    http_io_add_date(priv, &io, now);
    if(!(src == NULL))
    {
      io.headers=http_io_add_header(io.headers, "%s: %s", (const void *)"Content-Type", (const void *)"application/x-s3backer-block");
      http_io_base64_encode(md5buf, sizeof(char [25l]) /*25ul*/ , (const void *)md5, (unsigned long int)16);
      io.headers=http_io_add_header(io.headers, "%s: %s", (const void *)"Content-MD5", (const void *)md5buf);
    }

    if(!(src == NULL))
      io.headers=http_io_add_header(io.headers, "%s: %s", (const void *)"x-amz-acl", http_io_write_block$$1$$config->accessType);

    if(block_num == 0u && !(src == NULL))
    {
      io.headers=http_io_add_header(io.headers, "%s: %u", (const void *)"x-amz-meta-s3backer-blocksize", http_io_write_block$$1$$config->block_size);
      io.headers=http_io_add_header(io.headers, "%s: %ju", (const void *)"x-amz-meta-s3backer-filesize", (unsigned long int)((signed long int)http_io_write_block$$1$$config->block_size * http_io_write_block$$1$$config->num_blocks));
    }

    if(!(src == NULL))
    {
      if(!(http_io_write_block$$1$$config->encryption == ((const char *)NULL)))
        io.headers=http_io_add_header(io.headers, "%s: \"%s\"", (const void *)"x-amz-meta-s3backer-hmac", (const void *)hmacbuf);

    }

    if(!(http_io_write_block$$1$$config->rrs == 0))
      io.headers=http_io_add_header(io.headers, "%s: %s", (const void *)"x-amz-storage-class", (const void *)"REDUCED_REDUNDANCY");

    r=http_io_add_auth(priv, &io, now, io.src, (unsigned long int)io.buf_size);
    if(r == 0)
    {
      r=http_io_perform_io(priv, &io, http_io_write_prepper);
      if(r == 0)
      {
        pthread_mutex_lock(&priv->mutex);
        if(src == NULL)
          priv->stats.zero_blocks_written = priv->stats.zero_blocks_written + 1u;

        else
          priv->stats.normal_blocks_written = priv->stats.normal_blocks_written + 1u;
        pthread_mutex_unlock(&priv->mutex);
      }

    }


  fail:
    ;
    curl_slist_free_all(io.headers);
    if(!(encoded_buf == NULL))
      free(encoded_buf);

    return r;
  }
}

// http_io_write_block_part
// file http_io.c line 1574
static signed int http_io_write_block_part(struct s3backer_store *s3b, unsigned int block_num, unsigned int off, unsigned int len, const void *src)
{
  struct http_io_private * const priv = (struct http_io_private *)s3b->data;
  struct http_io_conf * const http_io_write_block_part$$1$$config = priv->config;
  signed int return_value_block_part_write_block_part$1;
  return_value_block_part_write_block_part$1=block_part_write_block_part(s3b, block_num, http_io_write_block_part$$1$$config->block_size, off, len, src);
  return return_value_block_part_write_block_part$1;
}

// http_io_write_prepper
// file http_io.c line 1545
static void http_io_write_prepper(void *curl, struct http_io *io)
{
  memset((void *)&io->bufs, 0, sizeof(struct http_io_bufs) /*32ul*/ );
  if(!(io->src == NULL))
  {
    io->bufs.wrremain = (unsigned long int)io->buf_size;
    io->bufs.wrdata = (const char *)io->src;
  }

  signed int http_io_write_prepper$$1$$2$$_curl_opt = CURLOPT_READFUNCTION;
  curl_easy_setopt(curl, (enum anonymous$12)http_io_write_prepper$$1$$2$$_curl_opt, http_io_curl_writer);
  signed int _curl_opt = CURLOPT_READDATA;
  curl_easy_setopt(curl, (enum anonymous$12)_curl_opt, io);
  signed int http_io_write_prepper$$1$$4$$_curl_opt = CURLOPT_WRITEFUNCTION;
  curl_easy_setopt(curl, (enum anonymous$12)http_io_write_prepper$$1$$4$$_curl_opt, http_io_curl_reader);
  signed int http_io_write_prepper$$1$$5$$_curl_opt = CURLOPT_WRITEDATA;
  curl_easy_setopt(curl, (enum anonymous$12)http_io_write_prepper$$1$$5$$_curl_opt, io);
  if(!(io->src == NULL))
  {
    signed int http_io_write_prepper$$1$$6$$1$$_curl_opt = CURLOPT_UPLOAD;
    curl_easy_setopt(curl, (enum anonymous$12)http_io_write_prepper$$1$$6$$1$$_curl_opt, 1);
    signed int http_io_write_prepper$$1$$6$$2$$_curl_opt = CURLOPT_INFILESIZE_LARGE;
    if((_Bool)0)
    {
      if(http_io_write_prepper$$1$$6$$2$$_curl_opt >= 30001)
      {
        goto __CPROVER_DUMP_L103;
        _curl_easy_setopt_err_curl_off_t();
      }


    __CPROVER_DUMP_L103:
      ;
      if(http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_URL || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_PROXY || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_USERPWD || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_PROXYUSERPWD || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_RANGE || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_REFERER || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_FTPPORT || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_USERAGENT || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_COOKIE || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_SSLCERT || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_KEYPASSWD || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_COOKIEFILE || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_CUSTOMREQUEST || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_INTERFACE || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_KRBLEVEL || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_CAINFO || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_RANDOM_FILE || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_EGDSOCKET || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_COOKIEJAR || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_SSL_CIPHER_LIST || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_SSLCERTTYPE || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_SSLKEY || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_SSLKEYTYPE || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_SSLENGINE || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_CAPATH || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_ACCEPT_ENCODING || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_NETRC_FILE || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_FTP_ACCOUNT || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_COOKIELIST || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_FTP_ALTERNATIVE_TO_USER || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_SSH_PUBLIC_KEYFILE || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_SSH_PRIVATE_KEYFILE || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_SSH_HOST_PUBLIC_KEY_MD5 || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_CRLFILE || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_ISSUERCERT || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_USERNAME || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_PASSWORD || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_PROXYUSERNAME || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_PROXYPASSWORD || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_NOPROXY || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_SOCKS5_GSSAPI_SERVICE || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_SSH_KNOWNHOSTS || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_MAIL_FROM || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_RTSP_SESSION_ID || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_RTSP_STREAM_URI || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_RTSP_TRANSPORT || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_TLSAUTH_USERNAME || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_TLSAUTH_PASSWORD || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_TLSAUTH_TYPE || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_DNS_SERVERS || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_MAIL_AUTH || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_XOAUTH2_BEARER || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_DNS_INTERFACE || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_DNS_LOCAL_IP4 || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_DNS_LOCAL_IP6 || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_LOGIN_OPTIONS || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_PINNEDPUBLICKEY || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_UNIX_SOCKET_PATH || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_PROXY_SERVICE_NAME || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_SERVICE_NAME || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_DEFAULT_PROTOCOL)
        _curl_easy_setopt_err_string();

      if(http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_WRITEFUNCTION || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_HEADERFUNCTION)
        _curl_easy_setopt_err_write_callback();

      if(http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_READFUNCTION)
        _curl_easy_setopt_err_read_cb();

      if(http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_IOCTLFUNCTION)
        _curl_easy_setopt_err_ioctl_cb();

      if(http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_SOCKOPTFUNCTION)
        _curl_easy_setopt_err_sockopt_cb();

      if(http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_OPENSOCKETFUNCTION)
        _curl_easy_setopt_err_opensocket_cb();

      if(http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_PROGRESSFUNCTION)
        _curl_easy_setopt_err_progress_cb();

      if(http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_DEBUGFUNCTION)
        _curl_easy_setopt_err_debug_cb();

      if(http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_SSL_CTX_FUNCTION)
        _curl_easy_setopt_err_ssl_ctx_cb();

      if(http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_CONV_FROM_NETWORK_FUNCTION || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_CONV_TO_NETWORK_FUNCTION || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_CONV_FROM_UTF8_FUNCTION)
        _curl_easy_setopt_err_conv_cb();

      if(http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_SEEKFUNCTION)
        _curl_easy_setopt_err_seek_cb();

      if(http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_ERRORBUFFER)
        _curl_easy_setopt_err_error_buffer();

      if(http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_STDERR)
        _curl_easy_setopt_err_FILE();

      if(http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_POSTFIELDS || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_COPYPOSTFIELDS)
        _curl_easy_setopt_err_postfields();

      if(http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_HTTPPOST)
        _curl_easy_setopt_err_curl_httpost();

      if(http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_HTTPHEADER || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_QUOTE || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_POSTQUOTE || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_TELNETOPTIONS || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_PREQUOTE || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_HTTP200ALIASES || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_MAIL_RCPT || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_RESOLVE || http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_PROXYHEADER)
        _curl_easy_setopt_err_curl_slist();

      if(http_io_write_prepper$$1$$6$$2$$_curl_opt == CURLOPT_SHARE)
        _curl_easy_setopt_err_CURLSH();

    }

    curl_easy_setopt(curl, (enum anonymous$12)http_io_write_prepper$$1$$6$$2$$_curl_opt, (signed long int)io->buf_size);
  }

  signed int http_io_write_prepper$$1$$7$$_curl_opt = CURLOPT_CUSTOMREQUEST;
  curl_easy_setopt(curl, (enum anonymous$12)http_io_write_prepper$$1$$7$$_curl_opt, io->method);
  signed int http_io_write_prepper$$1$$8$$_curl_opt = CURLOPT_HTTPHEADER;
  curl_easy_setopt(curl, (enum anonymous$12)http_io_write_prepper$$1$$8$$_curl_opt, io->headers);
}

// list_blocks_callback
// file s3b_config.c line 1500
static void list_blocks_callback(void *arg, unsigned int block_num)
{
  struct list_blocks * const lb = (struct list_blocks *)arg;
  const signed int bits_per_word = (const signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)8);
  lb->bitmap[(signed long int)(block_num / (unsigned int)bits_per_word)] = lb->bitmap[(signed long int)(block_num / (unsigned int)bits_per_word)] | (unsigned int)(1 << block_num % (unsigned int)bits_per_word);
  lb->count = lb->count + 1ul;
  if(!(lb->print_dots == 0))
  {
    if(lb->count % 256ul == 0ul)
    {
      fprintf(stderr, ".");
      fflush(stderr);
    }

  }

}

// logit
// file tester.c line 205
static void logit(signed int id, const char *fmt, ...)
{
  unsigned long int timestamp;
  unsigned long int return_value_get_time$1;
  return_value_get_time$1=get_time();
  timestamp = return_value_get_time$1 - start_time;
  void **args;
  printf("%u.%03u [%02d] ", (unsigned int)(timestamp / (unsigned long int)1000), (unsigned int)(timestamp % (unsigned long int)1000), id);
  args = (void **)&fmt;
  vfprintf(stdout, fmt, args);
  args = ((void **)NULL);
}

// main
// file tester.c line 72
signed int main(signed int argc, char **argv)
{
  unsigned long int thread;
  signed int i;
  signed int r;
  config=s3backer_get_config(argc, argv);
  if(config == ((struct s3b_config *)NULL))
    exit(1);

  if(!((unsigned long int)config->block_size >= sizeof(unsigned int) /*4ul*/ ))
    err(1, "block size too small");

  store=s3backer_create_store(config);
  if(store == ((struct s3backer_store *)NULL))
    err(1, "s3backer_create_store");

  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)config->num_blocks, sizeof(struct block_state) /*12ul*/ );
  blocks = (struct block_state *)return_value_calloc$1;
  if(blocks == ((struct block_state *)NULL))
    err(1, "calloc");

  zero_block=calloc((unsigned long int)1, (unsigned long int)config->block_size);
  if(zero_block == NULL)
    err(1, "calloc");

  signed long int return_value_time$2;
  return_value_time$2=time((signed long int *)(void *)0);
  srandom((unsigned int)return_value_time$2);
  pthread_mutex_init(&mutex, (const union anonymous$15 *)(void *)0);
  start_time=get_time();
  i = 0;
  if(!((signed long int)i >= config->num_blocks))
  {
    printf("zeroing block %0*jx\n", (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)i);
    r=store->write_block(store, (unsigned int)i, zero_block, (unsigned char *)(void *)0, (signed int (*)(void *, unsigned int))(void *)0, (void *)0);
    if(!(r == 0))
      err(1, "write error");

    i = i + 1;
  }

  i = 0;
  for( ; !(i >= 10); i = i + 1)
    pthread_create(&thread, (const union pthread_attr_t *)(void *)0, thread_main, (void *)(signed long int)i);
  sleep((unsigned int)(24 * 60 * 60));
  return 0;
}

// parse_json_field
// file http_io.c line 981
static char * parse_json_field(struct http_io_private *priv, const char *json, const char *field)
{
  struct http_io_conf * const parse_json_field$$1$$config = priv->config;
  struct anonymous$10 match[2l];
  struct re_pattern_buffer regex;
  char buf[128l];
  char *value;
  unsigned long int vlen;
  signed int r;
  snprintf(buf, sizeof(char [128l]) /*128ul*/ , "\"%s\"[[:space:]]*:[[:space:]]*\"([^\"]+)\"", field);
  memset((void *)&regex, 0, sizeof(struct re_pattern_buffer) /*64ul*/ );
  r=regcomp(&regex, buf, 1);
  if(!(r == 0))
  {
    regerror(r, &regex, buf, sizeof(char [128l]) /*128ul*/ );
    parse_json_field$$1$$config->log(6, "regex compilation failed: %s", (const void *)buf);
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return (char *)(void *)0;
  }

  r=regexec(&regex, json, sizeof(struct anonymous$10 [2l]) /*16ul*/  / sizeof(struct anonymous$10) /*8ul*/ , match, 0);
  if(!(r == 0))
  {
    regerror(r, &regex, buf, sizeof(char [128l]) /*128ul*/ );
    parse_json_field$$1$$config->log(6, "failed to find JSON field \"%s\" in credentials response: %s", field, (const void *)buf);
    regfree(&regex);
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    *return_value___errno_location$2 = 22;
    return (char *)(void *)0;
  }

  regfree(&regex);
  vlen = (unsigned long int)(match[(signed long int)1].rm_eo - match[(signed long int)1].rm_so);
  void *return_value_malloc$6;
  return_value_malloc$6=malloc(vlen + (unsigned long int)1);
  value = (char *)return_value_malloc$6;
  if(value == ((char *)NULL))
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    r = *return_value___errno_location$3;
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(r);
    parse_json_field$$1$$config->log(6, "malloc: %s", return_value_strerror$4);
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    *return_value___errno_location$5 = r;
    return (char *)(void *)0;
  }

  memcpy((void *)value, (const void *)(json + (signed long int)match[(signed long int)1].rm_so), vlen);
  value[(signed long int)vlen] = (char)0;
  return value;
}

// parse_size_string
// file s3b_config.c line 753
static signed int parse_size_string(const char *s, unsigned long int *valp)
{
  char suffix[3l] = { (char)0, 0, 0 };
  signed int nconv;
  nconv=sscanf(s, "%ju%2s", valp, (const void *)suffix);
  if(!(nconv >= 1))
    return -1;

  else
  {
    if(nconv >= 2)
    {
      signed int found = 0;
      signed int i = 0;
      for( ; !((unsigned long int)i >= 8ul); i = i + 1)
      {
        struct size_suffix * const ss = &size_suffixes[(signed long int)i];
        if((unsigned long int)ss->bits >= sizeof(signed long int) * 8 /*64ul*/ )
          break;

        signed int return_value_strcasecmp$1;
        return_value_strcasecmp$1=strcasecmp(suffix, ss->suffix);
        if(return_value_strcasecmp$1 == 0)
        {
          *valp = *valp << ss->bits;
          found = 1;
          break;
        }

      }
      if(found == 0)
        return -1;

    }

    return 0;
  }
}

// s3b_config_print_stats
// file s3b_config.c line 652
static void s3b_config_print_stats(void *prarg, void (*printer)(void *, const char *, ...))
{
  struct http_io_stats http_io_stats;
  struct ec_protect_stats ec_protect_stats;
  struct block_cache_stats block_cache_stats;
  double curl_reuse_ratio = 0.0;
  unsigned int total_oom = (unsigned int)0;
  unsigned int total_curls;
  if(!(http_io_store == ((struct s3backer_store *)NULL)))
    http_io_get_stats(http_io_store, &http_io_stats);

  if(!(ec_protect_store == ((struct s3backer_store *)NULL)))
    ec_protect_get_stats(ec_protect_store, &ec_protect_stats);

  if(!(block_cache_store == ((struct s3backer_store *)NULL)))
    block_cache_get_stats(block_cache_store, &block_cache_stats);

  if(!(http_io_store == ((struct s3backer_store *)NULL)))
  {
    printer(prarg, "%-28s %u\n", (const void *)"http_normal_blocks_read", http_io_stats.normal_blocks_read);
    printer(prarg, "%-28s %u\n", (const void *)"http_normal_blocks_written", http_io_stats.normal_blocks_written);
    printer(prarg, "%-28s %u\n", (const void *)"http_zero_blocks_read", http_io_stats.zero_blocks_read);
    printer(prarg, "%-28s %u\n", (const void *)"http_zero_blocks_written", http_io_stats.zero_blocks_written);
    if(!(config$link1.list_blocks == 0))
    {
      printer(prarg, "%-28s %u\n", (const void *)"http_empty_blocks_read", http_io_stats.empty_blocks_read);
      printer(prarg, "%-28s %u\n", (const void *)"http_empty_blocks_written", http_io_stats.empty_blocks_written);
    }

    printer(prarg, "%-28s %u\n", (const void *)"http_gets", http_io_stats.http_gets.count);
    printer(prarg, "%-28s %u\n", (const void *)"http_puts", http_io_stats.http_puts.count);
    printer(prarg, "%-28s %u\n", (const void *)"http_deletes", http_io_stats.http_deletes.count);
    printer(prarg, "%-28s %.3f sec\n", (const void *)"http_avg_get_time", http_io_stats.http_gets.count > (unsigned int)0 ? http_io_stats.http_gets.time / (double)http_io_stats.http_gets.count : 0.0);
    printer(prarg, "%-28s %.3f sec\n", (const void *)"http_avg_put_time", http_io_stats.http_puts.count > (unsigned int)0 ? http_io_stats.http_puts.time / (double)http_io_stats.http_puts.count : 0.0);
    printer(prarg, "%-28s %.3f sec\n", (const void *)"http_avg_delete_time", http_io_stats.http_deletes.count > (unsigned int)0 ? http_io_stats.http_deletes.time / (double)http_io_stats.http_deletes.count : 0.0);
    printer(prarg, "%-28s %u\n", (const void *)"http_unauthorized", http_io_stats.http_unauthorized);
    printer(prarg, "%-28s %u\n", (const void *)"http_forbidden", http_io_stats.http_forbidden);
    printer(prarg, "%-28s %u\n", (const void *)"http_stale", http_io_stats.http_stale);
    printer(prarg, "%-28s %u\n", (const void *)"http_verified", http_io_stats.http_verified);
    printer(prarg, "%-28s %u\n", (const void *)"http_mismatch", http_io_stats.http_mismatch);
    printer(prarg, "%-28s %u\n", (const void *)"http_5xx_error", http_io_stats.http_5xx_error);
    printer(prarg, "%-28s %u\n", (const void *)"http_4xx_error", http_io_stats.http_4xx_error);
    printer(prarg, "%-28s %u\n", (const void *)"http_other_error", http_io_stats.http_other_error);
    printer(prarg, "%-28s %u\n", (const void *)"http_canceled_writes", http_io_stats.http_canceled_writes);
    printer(prarg, "%-28s %u\n", (const void *)"http_num_retries", http_io_stats.num_retries);
    printer(prarg, "%-28s %ju.%03u sec\n", (const void *)"http_total_retry_delay", (unsigned long int)(http_io_stats.retry_delay / (unsigned long int)1000), (unsigned int)(http_io_stats.retry_delay % (unsigned long int)1000));
    total_curls = http_io_stats.curl_handles_created + http_io_stats.curl_handles_reused;
    if(total_curls >= 1u)
      curl_reuse_ratio = (double)http_io_stats.curl_handles_reused / (double)total_curls;

    printer(prarg, "%-28s %.4f\n", (const void *)"curl_handle_reuse_ratio", curl_reuse_ratio);
    printer(prarg, "%-28s %u\n", (const void *)"curl_timeouts", http_io_stats.curl_timeouts);
    printer(prarg, "%-28s %u\n", (const void *)"curl_connect_failed", http_io_stats.curl_connect_failed);
    printer(prarg, "%-28s %u\n", (const void *)"curl_host_unknown", http_io_stats.curl_host_unknown);
    printer(prarg, "%-28s %u\n", (const void *)"curl_out_of_memory", http_io_stats.curl_out_of_memory);
    printer(prarg, "%-28s %u\n", (const void *)"curl_other_error", http_io_stats.curl_other_error);
    total_oom = total_oom + http_io_stats.out_of_memory_errors;
  }

  if(!(block_cache_store == ((struct s3backer_store *)NULL)))
  {
    double read_hit_ratio = 0.0;
    double write_hit_ratio = 0.0;
    unsigned int total_reads;
    unsigned int total_writes;
    total_reads = block_cache_stats.read_hits + block_cache_stats.read_misses;
    if(!(total_reads == 0u))
      read_hit_ratio = (double)block_cache_stats.read_hits / (double)total_reads;

    total_writes = block_cache_stats.write_hits + block_cache_stats.write_misses;
    if(!(total_writes == 0u))
      write_hit_ratio = (double)block_cache_stats.write_hits / (double)total_writes;

    printer(prarg, "%-28s %u blocks\n", (const void *)"block_cache_current_size", block_cache_stats.current_size);
    printer(prarg, "%-28s %u blocks\n", (const void *)"block_cache_initial_size", block_cache_stats.initial_size);
    printer(prarg, "%-28s %.4f\n", (const void *)"block_cache_dirty_ratio", block_cache_stats.dirty_ratio);
    printer(prarg, "%-28s %u\n", (const void *)"block_cache_read_hits", block_cache_stats.read_hits);
    printer(prarg, "%-28s %u\n", (const void *)"block_cache_read_misses", block_cache_stats.read_misses);
    printer(prarg, "%-28s %.4f\n", (const void *)"block_cache_read_hit_ratio", read_hit_ratio);
    printer(prarg, "%-28s %u\n", (const void *)"block_cache_write_hits", block_cache_stats.write_hits);
    printer(prarg, "%-28s %u\n", (const void *)"block_cache_write_misses", block_cache_stats.write_misses);
    printer(prarg, "%-28s %.4f\n", (const void *)"block_cache_write_hit_ratio", write_hit_ratio);
    printer(prarg, "%-28s %u\n", (const void *)"block_cache_verified", block_cache_stats.verified);
    printer(prarg, "%-28s %u\n", (const void *)"block_cache_mismatch", block_cache_stats.mismatch);
    total_oom = total_oom + block_cache_stats.out_of_memory_errors;
  }

  if(!(ec_protect_store == ((struct s3backer_store *)NULL)))
  {
    printer(prarg, "%-28s %u blocks\n", (const void *)"md5_cache_current_size", ec_protect_stats.current_cache_size);
    printer(prarg, "%-28s %u\n", (const void *)"md5_cache_data_hits", ec_protect_stats.cache_data_hits);
    printer(prarg, "%-28s %ju.%03u sec\n", (const void *)"md5_cache_full_delays", (unsigned long int)(ec_protect_stats.cache_full_delay / (unsigned long int)1000), (unsigned int)(ec_protect_stats.cache_full_delay % (unsigned long int)1000));
    printer(prarg, "%-28s %ju.%03u sec\n", (const void *)"md5_cache_write_delays", (unsigned long int)(ec_protect_stats.repeated_write_delay / (unsigned long int)1000), (unsigned int)(ec_protect_stats.repeated_write_delay % (unsigned long int)1000));
    total_oom = total_oom + ec_protect_stats.out_of_memory_errors;
  }

  printer(prarg, "%-28s %u\n", (const void *)"out_of_memory_errors", total_oom);
}

// s3b_dcache_alloc_block
// file dcache.h line 52
extern signed int s3b_dcache_alloc_block(struct s3b_dcache *priv, unsigned int *dslotp)
{
  if(priv->free_list_len == 0u)
    return 12;

  else
  {
    s3b_dcache_pop(priv, dslotp);
    priv->num_alloc = priv->num_alloc + 1u;
    return 0;
  }
}

// s3b_dcache_close
// file dcache.h line 50
extern void s3b_dcache_close(struct s3b_dcache *priv)
{
  close(priv->fd);
  free(priv->zero_block);
  free((void *)priv->filename);
  free((void *)priv->free_list);
  free((void *)priv);
}

// s3b_dcache_create_file
// file dcache.c line 599
static signed int s3b_dcache_create_file(struct s3b_dcache *priv, signed int *fdp, const char *filename, unsigned int max_blocks, struct file_header *headerp)
{
  struct file_header header;
  signed int r;
  memset((void *)&header, 0, sizeof(struct file_header) /*32ul*/ );
  header.signature = 0xe496f17b;
  header.header_size = (unsigned int)sizeof(struct file_header) /*32ul*/ ;
  header.u_int_size = (unsigned int)sizeof(unsigned int) /*4ul*/ ;
  header.s3b_block_t_size = (unsigned int)sizeof(unsigned int) /*4ul*/ ;
  header.block_size = priv->block_size;
  header.max_blocks = priv->max_blocks;
  signed int return_value_getpagesize$1;
  return_value_getpagesize$1=getpagesize();
  header.data_align = (unsigned int)return_value_getpagesize$1;
  *fdp=open(filename, 02 | 0100 | 0200, 0644);
  if(*fdp == -1)
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    r = *return_value___errno_location$2;
    char *return_value_strerror$3;
    return_value_strerror$3=strerror(r);
    priv->log(3, "can't create file `%s': %s", filename, return_value_strerror$3);
    return r;
  }

  r=s3b_dcache_write2(priv, *fdp, filename, (signed long int)0, (const void *)&header, sizeof(struct file_header) /*32ul*/ );
  if(!(r == 0))
  {
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(r);
    priv->log(3, "error initializing cache file `%s': %s", filename, return_value_strerror$4);
  }

  signed int return_value_ftruncate$7;
  return_value_ftruncate$7=ftruncate(*fdp, (signed long int)sizeof(struct file_header) /*32ul*/ );
  _Bool tmp_if_expr$9;
  signed int return_value_ftruncate$8;
  if(return_value_ftruncate$7 == -1)
    tmp_if_expr$9 = (_Bool)1;

  else
  {
    return_value_ftruncate$8=ftruncate(*fdp, (signed long int)((unsigned long int)(signed long int)sizeof(struct file_header) /*32ul*/  + (unsigned long int)(signed long int)max_blocks * sizeof(struct dir_entry) /*20ul*/ ));
    tmp_if_expr$9 = return_value_ftruncate$8 == -1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$9)
  {
    signed int *return_value___errno_location$5;
    return_value___errno_location$5=__errno_location();
    r = *return_value___errno_location$5;
    char *return_value_strerror$6;
    return_value_strerror$6=strerror(r);
    priv->log(3, "error initializing cache file `%s': %s", filename, return_value_strerror$6);
  }

  if(!(headerp == ((struct file_header *)NULL)))
    *headerp = header;

  return 0;

fail:
  ;
  unlink(filename);
  close(*fdp);
  *fdp = -1;
  return r;
}

// s3b_dcache_erase_block
// file dcache.h line 54
extern signed int s3b_dcache_erase_block(struct s3b_dcache *priv, unsigned int dslot)
{
  signed int r;
  r=s3b_dcache_write_entry(priv, dslot, &zero_entry);
  if(!(r == 0))
    return r;

  else
  {
    r=s3b_dcache_fsync(priv);
    if(!(r == 0))
      return r;

    else
      return 0;
  }
}

// s3b_dcache_free_block
// file dcache.h line 55
extern signed int s3b_dcache_free_block(struct s3b_dcache *priv, unsigned int dslot)
{
  signed int r;
  r=s3b_dcache_push(priv, dslot);
  if(!(r == 0))
    return r;

  else
  {
    priv->num_alloc = priv->num_alloc - 1u;
    return 0;
  }
}

// s3b_dcache_fsync
// file dcache.c line 429
extern signed int s3b_dcache_fsync(struct s3b_dcache *priv)
{
  signed int r;
  r=fdatasync(priv->fd);
  if(r == -1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    r = *return_value___errno_location$1;
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(r);
    priv->log(3, "error fsync'ing cache file `%s': %s", priv->filename, return_value_strerror$2);
  }

  return 0;
}

// s3b_dcache_init_free_list
// file dcache.c line 647
static signed int s3b_dcache_init_free_list(struct s3b_dcache *priv, signed int (*visitor)(void *, unsigned int, unsigned int, const unsigned char *), void *arg)
{
  signed long int required_size;
  struct stat sb;
  unsigned int num_entries;
  unsigned int num_dslots_used;
  unsigned int base_dslot;
  unsigned int i;
  signed int r;
  priv->log(6, "reading meta-data from cache file `%s'", priv->filename);
  base_dslot = (unsigned int)0;
  num_dslots_used = base_dslot;
  if(!(base_dslot >= priv->max_blocks))
  {
    struct dir_entry entries[1024l];
    num_entries = priv->max_blocks - base_dslot;
    if(num_entries >= 1025u)
      num_entries = (unsigned int)1024;

    r=s3b_dcache_read(priv, (signed long int)((unsigned long int)(signed long int)sizeof(struct file_header) /*32ul*/  + (unsigned long int)(signed long int)base_dslot * sizeof(struct dir_entry) /*20ul*/ ), (void *)entries, (unsigned long int)num_entries * sizeof(struct dir_entry) /*20ul*/ );
    if(!(r == 0))
    {
      char *return_value_strerror$1;
      return_value_strerror$1=strerror(r);
      priv->log(3, "error reading cache file `%s' directory: %s", priv->filename, return_value_strerror$1);
      return r;
    }

    i = (unsigned int)0;
    if(!(i >= num_entries))
    {
      struct dir_entry * const entry = &entries[(signed long int)i];
      const unsigned int dslot = base_dslot + i;
      signed int return_value_memcmp$2;
      return_value_memcmp$2=memcmp((const void *)entry, (const void *)&zero_entry, sizeof(struct dir_entry) /*20ul*/ );
      if(return_value_memcmp$2 == 0)
      {
        r=s3b_dcache_push(priv, dslot);
        if(!(r == 0))
          return r;

      }

      else
      {
        if(!(num_dslots_used >= 1u + dslot))
          num_dslots_used = dslot + (unsigned int)1;

        if(!(visitor == ((signed int (*)(void *, unsigned int, unsigned int, const unsigned char *))NULL)))
        {
          r=visitor(arg, dslot, entry->block_num, entry->md5);
          if(!(r == 0))
            return r;

        }

      }
      i = i + 1u;
    }

    base_dslot = base_dslot + num_entries;
  }

  i = (unsigned int)0;
  if(!(i >= priv->free_list_len / 2u))
  {
    const unsigned int temp = priv->free_list[(signed long int)i];
    priv->free_list[(signed long int)i] = priv->free_list[(signed long int)((priv->free_list_len - i) - (unsigned int)1)];
    priv->free_list[(signed long int)((priv->free_list_len - i) - (unsigned int)1)] = temp;
    i = i + 1u;
  }

  required_size = (signed long int)((unsigned long int)(signed long int)sizeof(struct file_header) /*32ul*/  + (unsigned long int)(signed long int)priv->max_blocks * sizeof(struct dir_entry) /*20ul*/ );
  if(num_dslots_used >= 1u)
  {
    if(!(required_size >= (signed long int)priv->block_size * (signed long int)num_dslots_used + priv->data))
      required_size = (signed long int)priv->data + (signed long int)num_dslots_used * (signed long int)priv->block_size;

  }

  signed int return_value_fstat$5;
  return_value_fstat$5=fstat(priv->fd, &sb);
  if(return_value_fstat$5 == -1)
  {
    signed int *return_value___errno_location$3;
    return_value___errno_location$3=__errno_location();
    r = *return_value___errno_location$3;
    char *return_value_strerror$4;
    return_value_strerror$4=strerror(r);
    priv->log(3, "error reading cache file `%s' length: %s", priv->filename, return_value_strerror$4);
    return r;
  }

  signed int return_value_ftruncate$8;
  if(!(sb.st_size >= required_size))
  {
    priv->log(3, "cache file `%s' is truncated (has size %ju < %ju bytes)", priv->filename, (unsigned long int)sb.st_size, (unsigned long int)required_size);
    return 22;
  }

  else
  {
    if(!(required_size >= sb.st_size))
    {
      return_value_ftruncate$8=ftruncate(priv->fd, required_size);
      if(return_value_ftruncate$8 == -1)
      {
        signed int *return_value___errno_location$6;
        return_value___errno_location$6=__errno_location();
        r = *return_value___errno_location$6;
        char *return_value_strerror$7;
        return_value_strerror$7=strerror(r);
        priv->log(3, "error trimming cache file `%s' to %ju bytes: %s", priv->filename, (unsigned long int)required_size, return_value_strerror$7);
        return 22;
      }

    }

    priv->log(6, "loaded cache file `%s' with %u free and %u used blocks (max index %u)", priv->filename, priv->free_list_len, priv->max_blocks - priv->free_list_len, num_dslots_used);
    return 0;
  }
}

// s3b_dcache_open
// file dcache.h line 48
extern signed int s3b_dcache_open(struct s3b_dcache **dcachep, void (*log)(signed int, const char *, ...), const char *filename, unsigned int block_size, unsigned int max_blocks, signed int (*visitor)(void *, unsigned int, unsigned int, const unsigned char *), void *arg)
{
  struct file_header header;
  struct s3b_dcache *priv;
  struct stat sb;
  signed int r;
  signed int *return_value___errno_location$1;
  signed int *return_value___errno_location$5;
  signed int return_value_getpagesize$13;
  if(max_blocks == 0u)
    return 22;

  else
  {
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(sizeof(struct s3b_dcache) /*72ul*/ );
    priv = (struct s3b_dcache *)return_value_malloc$2;
    if(priv == ((struct s3b_dcache *)NULL))
    {
      return_value___errno_location$1=__errno_location();
      return *return_value___errno_location$1;
    }

    else
    {
      memset((void *)priv, 0, sizeof(struct s3b_dcache) /*72ul*/ );
      priv->fd = -1;
      priv->log = log;
      priv->block_size = block_size;
      priv->max_blocks = max_blocks;
      priv->filename=strdup(filename);
      if(priv->filename == ((char *)NULL))
      {
        signed int *return_value___errno_location$3;
        return_value___errno_location$3=__errno_location();
        r = *return_value___errno_location$3;
        goto fail1;
      }

      priv->zero_block=calloc((unsigned long int)1, (unsigned long int)block_size);
      if(priv->zero_block == NULL)
      {
        signed int *return_value___errno_location$4;
        return_value___errno_location$4=__errno_location();
        r = *return_value___errno_location$4;
        goto fail2;
      }

      signed int return_value_stat$6;
      return_value_stat$6=stat(priv->filename, &sb);
      if(return_value_stat$6 == -1)
      {
        return_value___errno_location$5=__errno_location();
        if(*return_value___errno_location$5 == 2)
        {
          priv->log(5, "creating new cache file `%s' with capacity %u blocks", priv->filename, priv->max_blocks);
          r=s3b_dcache_create_file(priv, &priv->fd, priv->filename, priv->max_blocks, (struct file_header *)(void *)0);
          close(priv->fd);
          priv->fd = -1;
        }

      }


    retry:
      ;
      (void)0;
      priv->fd=open(priv->filename, 02, 0);
      if(priv->fd == -1)
      {
        signed int *return_value___errno_location$7;
        return_value___errno_location$7=__errno_location();
        r = *return_value___errno_location$7;
        char *return_value_strerror$8;
        return_value_strerror$8=strerror(r);
        priv->log(3, "can't open cache file `%s': %s", priv->filename, return_value_strerror$8);
      }

      signed int return_value_fstat$10;
      return_value_fstat$10=fstat(priv->fd, &sb);
      if(return_value_fstat$10 == -1)
      {
        signed int *return_value___errno_location$9;
        return_value___errno_location$9=__errno_location();
        r = *return_value___errno_location$9;
        goto fail4;
      }

      if(!((unsigned long int)sb.st_size >= sizeof(struct file_header) /*32ul*/ ))
      {
        priv->log(3, "invalid cache file `%s': file is truncated (size %ju < %u)", priv->filename, (unsigned long int)sb.st_size, (unsigned int)sizeof(struct file_header) /*32ul*/ );
        r = 22;
      }

      else
      {
        r=s3b_dcache_read(priv, (signed long int)0, (void *)&header, sizeof(struct file_header) /*32ul*/ );
        if(!(r == 0))
        {
          char *return_value_strerror$11;
          return_value_strerror$11=strerror(r);
          priv->log(3, "can't read cache file `%s' header: %s", priv->filename, return_value_strerror$11);
        }

        r = 22;
        if(!(header.signature == 0xe496f17b))
          priv->log(3, "invalid cache file `%s': wrong signature %08x != %08x", priv->filename, header.signature, 0xe496f17b);

        else
          if(!((unsigned long int)header.header_size == sizeof(struct file_header) /*32ul*/ ))
            priv->log(3, "invalid cache file `%s': %s", priv->filename, (const void *)"unrecognized format");

          else
            if(!((unsigned long int)header.u_int_size == sizeof(unsigned int) /*4ul*/ ))
              priv->log(3, "invalid cache file `%s': created with sizeof(u_int) %u != %u", priv->filename, header.u_int_size, (unsigned int)sizeof(unsigned int) /*4ul*/ );

            else
              if(!((unsigned long int)header.s3b_block_t_size == sizeof(unsigned int) /*4ul*/ ))
                priv->log(3, "invalid cache file `%s': created with sizeof(s3b_block_t) %u != %u", priv->filename, header.s3b_block_t_size, (unsigned int)sizeof(unsigned int) /*4ul*/ );

              else
                if(!(header.block_size == priv->block_size))
                  priv->log(3, "invalid cache file `%s': created with block size %u != %u", priv->filename, header.block_size, priv->block_size);

                else
                {
                  return_value_getpagesize$13=getpagesize();
                  if(!(header.data_align == (unsigned int)return_value_getpagesize$13))
                  {
                    signed int return_value_getpagesize$12;
                    return_value_getpagesize$12=getpagesize();
                    priv->log(3, "invalid cache file `%s': created with alignment %u != %u", priv->filename, header.data_align, return_value_getpagesize$12);
                  }

                  if(!(header.zero == 0u))
                    priv->log(3, "invalid cache file `%s': %s", priv->filename, (const void *)"unrecognized field");

                  else
                  {
                    if(!(header.max_blocks == priv->max_blocks))
                    {
                      priv->log(5, "cache file `%s' was created with capacity %u != %u blocks, automatically %s", priv->filename, header.max_blocks, priv->max_blocks, header.max_blocks < priv->max_blocks ? "expanding" : "shrinking");
                      r=s3b_dcache_resize_file(priv, &header);
                      priv->log(6, "successfully resized cache file `%s' from %u to %u blocks", priv->filename, header.max_blocks, priv->max_blocks);
                    }

                    if(!((unsigned long int)sb.st_size >= sizeof(struct dir_entry) /*20ul*/  * (unsigned long int)(signed long int)priv->max_blocks + sizeof(struct file_header) /*32ul*/ ))
                      priv->log(3, "invalid cache file `%s': file is truncated (size %ju < %ju)", priv->filename, (unsigned long int)sb.st_size, (unsigned long int)((unsigned long int)(signed long int)sizeof(struct file_header) /*32ul*/  + (unsigned long int)(signed long int)priv->max_blocks * sizeof(struct dir_entry) /*20ul*/ ));

                    else
                    {
                      priv->data = (signed long int)(((unsigned long int)(signed long int)sizeof(struct file_header) /*32ul*/  + (unsigned long int)(signed long int)priv->max_blocks * sizeof(struct dir_entry) /*20ul*/  + (unsigned long int)header.data_align) - (unsigned long int)1 & (unsigned long int)~(header.data_align - (unsigned int)1));
                      r=s3b_dcache_init_free_list(priv, visitor, arg);
                      if(r == 0)
                      {
                        *dcachep = priv;
                        return 0;
                      }

                    }
                  }
                }
      }

    fail4:
      ;
      close(priv->fd);

    fail3:
      ;
      free(priv->zero_block);

    fail2:
      ;
      free((void *)priv->filename);

    fail1:
      ;
      free((void *)priv->free_list);
      free((void *)priv);
      return r;
    }
  }
}

// s3b_dcache_pop
// file dcache.c line 767
static void s3b_dcache_pop(struct s3b_dcache *priv, unsigned int *dslotp)
{
  priv->free_list_len = priv->free_list_len - 1u;
  *dslotp = priv->free_list[(signed long int)priv->free_list_len];
  signed int *return_value___errno_location$1;
  char *return_value_strerror$2;
  if(priv->free_list_alloc >= 1025u)
  {
    if(priv->free_list_alloc / 4u >= priv->free_list_len)
    {
      unsigned int *new_free_list;
      unsigned int new_free_list_alloc = priv->free_list_alloc / (unsigned int)4;
      void *return_value_realloc$3;
      return_value_realloc$3=realloc((void *)priv->free_list, (unsigned long int)new_free_list_alloc * sizeof(unsigned int) /*4ul*/ );
      new_free_list = (unsigned int *)return_value_realloc$3;
      if(new_free_list == ((unsigned int *)NULL))
      {
        return_value___errno_location$1=__errno_location();
        return_value_strerror$2=strerror(*return_value___errno_location$1);
        priv->log(3, "can't shrink dcache free list: realloc: %s (ignored)", return_value_strerror$2);
      }

      else
      {
        priv->free_list = new_free_list;
        priv->free_list_alloc = new_free_list_alloc;
      }
    }

  }

}

// s3b_dcache_push
// file dcache.c line 735
static signed int s3b_dcache_push(struct s3b_dcache *priv, unsigned int dslot)
{
  unsigned int tmp_if_expr$1;
  if(priv->free_list_alloc == priv->free_list_len)
  {
    unsigned int *new_free_list;
    unsigned int new_free_list_alloc;
    signed int r;
    if(priv->free_list_alloc == 0u)
      tmp_if_expr$1 = (unsigned int)1024;

    else
      tmp_if_expr$1 = (unsigned int)2 * priv->free_list_alloc;
    new_free_list_alloc = tmp_if_expr$1;
    void *return_value_realloc$4;
    return_value_realloc$4=realloc((void *)priv->free_list, (unsigned long int)new_free_list_alloc * sizeof(unsigned int) /*4ul*/ );
    new_free_list = (unsigned int *)return_value_realloc$4;
    if(new_free_list == ((unsigned int *)NULL))
    {
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      r = *return_value___errno_location$2;
      char *return_value_strerror$3;
      return_value_strerror$3=strerror(r);
      priv->log(3, "realloc: %s", return_value_strerror$3);
      return r;
    }

    priv->free_list = new_free_list;
    priv->free_list_alloc = new_free_list_alloc;
  }

  unsigned int tmp_post$5 = priv->free_list_len;
  priv->free_list_len = priv->free_list_len + 1u;
  priv->free_list[(signed long int)tmp_post$5] = dslot;
  return 0;
}

// s3b_dcache_read
// file dcache.c line 793
static signed int s3b_dcache_read(struct s3b_dcache *priv, signed long int offset, void *data, unsigned long int len)
{
  unsigned long int sofar;
  signed long int r;
  sofar = (unsigned long int)0;
  for( ; !(sofar >= len); sofar = sofar + (unsigned long int)r)
  {
    const signed long int posn = (const signed long int)((unsigned long int)offset + sofar);
    r=pread(priv->fd, (void *)((char *)data + (signed long int)sofar), len - sofar, (signed long int)((unsigned long int)offset + sofar));
    if(r == -1l)
    {
      char *return_value_strerror$1;
      return_value_strerror$1=strerror((signed int)r);
      priv->log(3, "error reading cache file `%s' at offset %ju: %s", priv->filename, (unsigned long int)posn, return_value_strerror$1);
      return (signed int)r;
    }

    if(r == 0l)
    {
      priv->log(3, "error reading cache file `%s' at offset %ju: file is truncated", priv->filename, (unsigned long int)posn);
      return 22;
    }

  }
  return 0;
}

// s3b_dcache_read_block
// file dcache.h line 56
extern signed int s3b_dcache_read_block(struct s3b_dcache *priv, unsigned int dslot, void *dest, unsigned int off, unsigned int len)
{
  signed int return_value_s3b_dcache_read$1;
  return_value_s3b_dcache_read$1=s3b_dcache_read(priv, (signed long int)priv->data + (signed long int)dslot * (signed long int)priv->block_size + (signed long int)off, dest, (unsigned long int)len);
  return return_value_s3b_dcache_read$1;
}

// s3b_dcache_record_block
// file dcache.h line 53
extern signed int s3b_dcache_record_block(struct s3b_dcache *priv, unsigned int dslot, unsigned int block_num, const unsigned char *md5)
{
  struct dir_entry entry;
  signed int r;
  r=s3b_dcache_fsync(priv);
  if(!(r == 0))
    return r;

  else
  {
    entry.block_num = block_num;
    memcpy((void *)&entry.md5, (const void *)md5, (unsigned long int)16);
    r=s3b_dcache_write_entry(priv, dslot, &entry);
    if(!(r == 0))
      return r;

    else
      return 0;
  }
}

// s3b_dcache_resize_file
// file dcache.c line 480
static signed int s3b_dcache_resize_file(struct s3b_dcache *priv, struct file_header *old_header)
{
  const unsigned int old_max_blocks = old_header->max_blocks;
  const unsigned int new_max_blocks = priv->max_blocks;
  struct file_header new_header;
  signed long int old_data_base;
  signed long int new_data_base;
  unsigned int base_old_dslot;
  unsigned int new_dslot = (unsigned int)0;
  unsigned int num_entries;
  unsigned char *block_buf = (unsigned char *)(void *)0;
  char *tempfile = (char *)(void *)0;
  signed int new_fd = -1;
  signed int r;
  signed int return_value_asprintf$3;
  return_value_asprintf$3=asprintf(&tempfile, "%s.new", priv->filename);
  if(return_value_asprintf$3 == -1)
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    r = *return_value___errno_location$1;
    tempfile = (char *)(void *)0;
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(r);
    priv->log(3, "can't allocate string: %s", return_value_strerror$2);
  }

  r=s3b_dcache_create_file(priv, &new_fd, tempfile, new_max_blocks, &new_header);
  void *return_value_malloc$6;
  signed int return_value_close$10;
  signed int return_value_rename$13;
  if(r == 0)
  {
    return_value_malloc$6=malloc((unsigned long int)priv->block_size);
    block_buf = (unsigned char *)return_value_malloc$6;
    if(block_buf == ((unsigned char *)NULL))
    {
      signed int *return_value___errno_location$4;
      return_value___errno_location$4=__errno_location();
      r = *return_value___errno_location$4;
      char *return_value_strerror$5;
      return_value_strerror$5=strerror(r);
      priv->log(3, "can't allocate buffer: %s", return_value_strerror$5);
    }

    old_data_base = (signed long int)(((unsigned long int)(signed long int)sizeof(struct file_header) /*32ul*/  + (unsigned long int)(signed long int)old_max_blocks * sizeof(struct dir_entry) /*20ul*/  + (unsigned long int)old_header->data_align) - (unsigned long int)1 & (unsigned long int)~(old_header->data_align - (unsigned int)1));
    new_data_base = (signed long int)(((unsigned long int)(signed long int)sizeof(struct file_header) /*32ul*/  + (unsigned long int)(signed long int)new_max_blocks * sizeof(struct dir_entry) /*20ul*/  + (unsigned long int)new_header.data_align) - (unsigned long int)1 & (unsigned long int)~(new_header.data_align - (unsigned int)1));
    base_old_dslot = (unsigned int)0;
    for( ; !(base_old_dslot >= old_max_blocks); base_old_dslot = base_old_dslot + num_entries)
    {
      struct dir_entry entries[1024l];
      signed int i;
      num_entries = old_max_blocks - base_old_dslot;
      if(num_entries >= 1025u)
        num_entries = (unsigned int)1024;

      r=s3b_dcache_read(priv, (signed long int)((unsigned long int)(signed long int)sizeof(struct file_header) /*32ul*/  + (unsigned long int)(signed long int)base_old_dslot * sizeof(struct dir_entry) /*20ul*/ ), (void *)entries, (unsigned long int)num_entries * sizeof(struct dir_entry) /*20ul*/ );
      if(!(r == 0))
      {
        char *return_value_strerror$7;
        return_value_strerror$7=strerror(r);
        priv->log(3, "error reading cache file `%s' directory: %s", priv->filename, return_value_strerror$7);
      }

      i = 0;
      for( ; !((unsigned int)i >= num_entries); i = i + 1)
      {
        struct dir_entry * const entry = &entries[(signed long int)i];
        const unsigned int old_dslot = base_old_dslot + (unsigned int)i;
        signed long int old_data;
        signed long int new_data;
        signed int return_value_memcmp$8;
        return_value_memcmp$8=memcmp((const void *)entry, (const void *)&zero_entry, sizeof(struct dir_entry) /*20ul*/ );
        if(!(return_value_memcmp$8 == 0))
        {
          if(new_dslot == new_max_blocks)
            priv->log(6, "cache file `%s' contains more than %u blocks; some will be discarded", priv->filename, new_max_blocks);

          r=s3b_dcache_write2(priv, new_fd, tempfile, (signed long int)((unsigned long int)(signed long int)sizeof(struct file_header) /*32ul*/  + (unsigned long int)(signed long int)new_dslot * sizeof(struct dir_entry) /*20ul*/ ), (const void *)entry, sizeof(struct dir_entry) /*20ul*/ );
          if(!(r == 0))
            goto fail;

          old_data = old_data_base + (signed long int)old_dslot * (signed long int)priv->block_size;
          new_data = new_data_base + (signed long int)new_dslot * (signed long int)priv->block_size;
          r=s3b_dcache_read(priv, old_data, (void *)block_buf, (unsigned long int)priv->block_size);
          if(!(r == 0))
            goto fail;

          r=s3b_dcache_write2(priv, new_fd, tempfile, new_data, (const void *)block_buf, (unsigned long int)priv->block_size);
          if(!(r == 0))
            goto fail;

          new_dslot = new_dslot + 1u;
        }

      }
    }

  done:
    ;
    return_value_close$10=close(new_fd);
    if(return_value_close$10 == -1)
    {
      char *return_value_strerror$9;
      return_value_strerror$9=strerror(r);
      priv->log(3, "error closing temporary cache file `%s': %s", tempfile, return_value_strerror$9);
    }

    new_fd = -1;
    return_value_rename$13=rename(tempfile, priv->filename);
    if(return_value_rename$13 == -1)
    {
      signed int *return_value___errno_location$11;
      return_value___errno_location$11=__errno_location();
      r = *return_value___errno_location$11;
      char *return_value_strerror$12;
      return_value_strerror$12=strerror(r);
      priv->log(3, "error renaming `%s' to `%s': %s", tempfile, priv->filename, return_value_strerror$12);
    }

    free((void *)tempfile);
    tempfile = (char *)(void *)0;
    close(priv->fd);
    priv->fd = -1;
    r = 0;
  }


fail:
  ;
  if(!(block_buf == ((unsigned char *)NULL)))
    free((void *)block_buf);

  if(!(new_fd == -1))
    close(new_fd);

  if(!(tempfile == ((char *)NULL)))
  {
    unlink(tempfile);
    free((void *)tempfile);
  }

  return r;
}

// s3b_dcache_size
// file dcache.c line 279
extern unsigned int s3b_dcache_size(struct s3b_dcache *priv)
{
  return priv->num_alloc;
}

// s3b_dcache_write
// file dcache.c line 816
static signed int s3b_dcache_write(struct s3b_dcache *priv, signed long int offset, const void *data, unsigned long int len)
{
  signed int return_value_s3b_dcache_write2$1;
  return_value_s3b_dcache_write2$1=s3b_dcache_write2(priv, priv->fd, priv->filename, offset, data, len);
  return return_value_s3b_dcache_write2$1;
}

// s3b_dcache_write2
// file dcache.c line 822
static signed int s3b_dcache_write2(struct s3b_dcache *priv, signed int fd, const char *filename, signed long int offset, const void *data, unsigned long int len)
{
  unsigned long int sofar;
  signed long int r;
  sofar = (unsigned long int)0;
  for( ; !(sofar >= len); sofar = sofar + (unsigned long int)r)
  {
    const signed long int posn = (const signed long int)((unsigned long int)offset + sofar);
    r=pwrite(fd, (const void *)((const char *)data + (signed long int)sofar), len - sofar, (signed long int)((unsigned long int)offset + sofar));
    if(r == -1l)
    {
      char *return_value_strerror$1;
      return_value_strerror$1=strerror((signed int)r);
      priv->log(3, "error writing cache file `%s' at offset %ju: %s", filename, (unsigned long int)posn, return_value_strerror$1);
      return (signed int)r;
    }

  }
  return 0;
}

// s3b_dcache_write_block
// file dcache.h line 57
extern signed int s3b_dcache_write_block(struct s3b_dcache *priv, unsigned int dslot, const void *src, unsigned int off, unsigned int len)
{
  const void *tmp_if_expr$1;
  if(!(src == NULL))
    tmp_if_expr$1 = src;

  else
    tmp_if_expr$1 = priv->zero_block;
  signed int return_value_s3b_dcache_write$2;
  return_value_s3b_dcache_write$2=s3b_dcache_write(priv, (signed long int)priv->data + (signed long int)dslot * (signed long int)priv->block_size + (signed long int)off, tmp_if_expr$1, (unsigned long int)len);
  return return_value_s3b_dcache_write$2;
}

// s3b_dcache_write_entry
// file dcache.c line 469
static signed int s3b_dcache_write_entry(struct s3b_dcache *priv, unsigned int dslot, struct dir_entry *entry)
{
  signed int return_value_s3b_dcache_write$1;
  return_value_s3b_dcache_write$1=s3b_dcache_write(priv, (signed long int)((unsigned long int)(signed long int)sizeof(struct file_header) /*32ul*/  + (unsigned long int)(signed long int)dslot * sizeof(struct dir_entry) /*20ul*/ ), (const void *)entry, sizeof(struct dir_entry) /*20ul*/ );
  return return_value_s3b_dcache_write$1;
}

// s3b_hash_create
// file hash.h line 54
extern signed int s3b_hash_create(struct s3b_hash **hashp, unsigned int maxkeys)
{
  struct s3b_hash *hash;
  unsigned int alen;
  if(maxkeys >= 2863308665u)
    return 22;

  else
  {
    alen = (unsigned int)((double)maxkeys / 0.666666) + (unsigned int)1;
    void *return_value_calloc$1;
    return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct s3b_hash) /*16ul*/  + (unsigned long int)alen * sizeof(void *) /*8ul*/ );
    hash = (struct s3b_hash *)return_value_calloc$1;
    if(hash == ((struct s3b_hash *)NULL))
      return 12;

    else
    {
      hash->maxkeys = maxkeys;
      hash->alen = alen;
      *hashp = hash;
      return 0;
    }
  }
}

// s3b_hash_destroy
// file hash.h line 55
extern void s3b_hash_destroy(struct s3b_hash *hash)
{
  free((void *)hash);
}

// s3b_hash_foreach
// file hash.h line 61
extern void s3b_hash_foreach(struct s3b_hash *hash, void (*visitor)(void *, void *), void *arg)
{
  unsigned int i = (unsigned int)0;
  for( ; !(i >= hash->alen); i = i + 1u)
  {
    void * const value = hash->array[(signed long int)i];
    if(!(value == NULL))
      visitor(arg, value);

  }
}

// s3b_hash_get
// file hash.h line 57
extern void * s3b_hash_get(struct s3b_hash *hash, unsigned int key)
{
  unsigned int i;
  i=s3b_hash_index(hash, key);
  for( ; (_Bool)1; i = i + (unsigned int)1 < hash->alen ? i + (unsigned int)1 : (unsigned int)0)
  {
    void * const value = hash->array[(signed long int)i];
    if(value == NULL)
      return (void *)0;

    if(*((unsigned int *)value) == key)
      return value;

  }
}

// s3b_hash_index
// file hash.c line 206
static unsigned int s3b_hash_index(struct s3b_hash *hash, unsigned int key)
{
  unsigned int value = (unsigned int)0;
  signed int i = 0;
  for( ; !((unsigned long int)i >= sizeof(unsigned int) /*4ul*/ ); i = i + 1)
  {
    value = value + (unsigned int)((unsigned char *)&key)[(signed long int)i];
    value = value + (value << 10);
    value = value ^ value >> 6;
  }
  value = value + (value << 3);
  value = value ^ value >> 11;
  value = value + (value << 15);
  return value % hash->alen;
}

// s3b_hash_put
// file hash.h line 58
extern void * s3b_hash_put(struct s3b_hash *hash, void *value)
{
  const unsigned int key = *((unsigned int *)value);
  unsigned int i;
  i=s3b_hash_index(hash, key);
  for( ; (_Bool)1; i = i + (unsigned int)1 < hash->alen ? i + (unsigned int)1 : (unsigned int)0)
  {
    void * const value2 = hash->array[(signed long int)i];
    if(value == NULL)
      break;

    if(*((unsigned int *)value2) == key)
    {
      hash->array[(signed long int)i] = value;
      return value2;
    }

  }
  hash->array[(signed long int)i] = value;
  hash->numkeys = hash->numkeys + 1u;
  return (void *)0;
}

// s3b_hash_put_new
// file hash.h line 59
extern void s3b_hash_put_new(struct s3b_hash *hash, void *value)
{
  const unsigned int key = *((unsigned int *)value);
  unsigned int i;
  i=s3b_hash_index(hash, key);
  for( ; (_Bool)1; i = i + (unsigned int)1 < hash->alen ? i + (unsigned int)1 : (unsigned int)0)
  {
    void * const value2 = hash->array[(signed long int)i];
    if(value2 == NULL)
      break;

  }
  hash->array[(signed long int)i] = value;
  hash->numkeys = hash->numkeys + 1u;
}

// s3b_hash_remove
// file hash.h line 60
extern void s3b_hash_remove(struct s3b_hash *hash, unsigned int key)
{
  unsigned int i;
  unsigned int j;
  unsigned int k;
  i=s3b_hash_index(hash, key);
  for( ; (_Bool)1; i = i + (unsigned int)1 < hash->alen ? i + (unsigned int)1 : (unsigned int)0)
  {
    void * const s3b_hash_remove$$1$$1$$1$$value = hash->array[(signed long int)i];
    if(s3b_hash_remove$$1$$1$$1$$value == NULL)
      goto __CPROVER_DUMP_L9;

    if(*((unsigned int *)s3b_hash_remove$$1$$1$$1$$value) == key)
      break;

  }
  j = i + (unsigned int)1 < hash->alen ? i + (unsigned int)1 : (unsigned int)0;
  for( ; (_Bool)1; j = j + (unsigned int)1 < hash->alen ? j + (unsigned int)1 : (unsigned int)0)
  {
    void * const value = hash->array[(signed long int)j];
    if(value == NULL)
      break;

    k=s3b_hash_index(hash, *((unsigned int *)value));
    if(i >= j ? i >= k && !(j >= k) : i >= k || !(j >= k))
    {
      hash->array[(signed long int)i] = value;
      i = j;
    }

  }
  hash->array[(signed long int)i] = (void *)0;
  hash->numkeys = hash->numkeys - 1u;

__CPROVER_DUMP_L9:
  ;
}

// s3b_hash_size
// file hash.h line 56
extern unsigned int s3b_hash_size(struct s3b_hash *hash)
{
  return hash->numkeys;
}

// s3backer_create_store
// file s3b_config.h line 74
extern struct s3backer_store * s3backer_create_store(struct s3b_config *conf)
{
  struct s3backer_store *s3backer_create_store$$1$$store;
  signed int mounted;
  signed int r;
  if(!(http_io_store == ((struct s3backer_store *)NULL)) || !(test_io_store == ((struct s3backer_store *)NULL)))
  {
    signed int *return_value___errno_location$1;
    return_value___errno_location$1=__errno_location();
    *return_value___errno_location$1 = 22;
    return (struct s3backer_store *)(void *)0;
  }

  if(!(conf->test == 0))
  {
    test_io_store=test_io_create(&conf->http_io);
    if(test_io_store == ((struct s3backer_store *)NULL))
      return (struct s3backer_store *)(void *)0;

    s3backer_create_store$$1$$store = test_io_store;
  }

  else
  {
    http_io_store=http_io_create(&conf->http_io);
    if(http_io_store == ((struct s3backer_store *)NULL))
      return (struct s3backer_store *)(void *)0;

    s3backer_create_store$$1$$store = http_io_store;
  }
  if(conf->ec_protect.cache_size >= 1u)
  {
    ec_protect_store=ec_protect_create(&conf->ec_protect, s3backer_create_store$$1$$store);
    if(ec_protect_store == ((struct s3backer_store *)NULL))
      goto fail_with_errno;

    s3backer_create_store$$1$$store = ec_protect_store;
  }

  if(conf->block_cache.cache_size >= 1u)
  {
    block_cache_store=block_cache_create(&conf->block_cache, s3backer_create_store$$1$$store);
    if(block_cache_store == ((struct s3backer_store *)NULL))
      goto fail_with_errno;

    s3backer_create_store$$1$$store = block_cache_store;
  }

  r=s3backer_create_store$$1$$store->set_mounted(s3backer_create_store$$1$$store, &mounted, conf->fuse_ops.read_only != 0 ? -1 : 1);
  if(!(r == 0))
  {
    char *return_value_strerror$2;
    return_value_strerror$2=strerror(r);
    conf->log(3, "error reading mounted flag on %s: %s", (const void *)conf->description, return_value_strerror$2);
  }

  signed int *return_value___errno_location$3;
  if(!(mounted == 0))
  {
    conf->log(3, "%s appears to be mounted by another s3backer process", (const void *)config$link1.description);
    r = 16;
  }

  else
  {
    return s3backer_create_store$$1$$store;

  fail_with_errno:
    ;
    return_value___errno_location$3=__errno_location();
    r = *return_value___errno_location$3;
  }

fail:
  ;
  if(!(s3backer_create_store$$1$$store == ((struct s3backer_store *)NULL)))
    s3backer_create_store$$1$$store->destroy(s3backer_create_store$$1$$store);

  block_cache_store = (struct s3backer_store *)(void *)0;
  ec_protect_store = (struct s3backer_store *)(void *)0;
  http_io_store = (struct s3backer_store *)(void *)0;
  test_io_store = (struct s3backer_store *)(void *)0;
  signed int *return_value___errno_location$4;
  return_value___errno_location$4=__errno_location();
  *return_value___errno_location$4 = r;
  return (struct s3backer_store *)(void *)0;
}

// s3backer_erase
// file erase.c line 69
extern signed int s3backer_erase(struct s3b_config *config)
{
  struct erase_state state;
  struct erase_state * const priv = &state;
  char response[10l];
  signed int ok = 0;
  signed int i;
  signed int r;
  const unsigned short int **return_value___ctype_b_loc$1;
  unsigned long int return_value_strlen$2;
  unsigned long int return_value_strlen$3;
  signed int return_value_strcasecmp$5;
  if(config->force == 0)
  {
    warnx("`--erase' flag given: erasing all blocks in %s", (const void *)config->description);
    fprintf(stderr, "s3backer: is this correct? [y/N] ");
    response[0l] = (char)0;
    char *return_value_fgets$4;
    return_value_fgets$4=fgets(response, (signed int)sizeof(char [10l]) /*10ul*/ , stdin);
    if(!(return_value_fgets$4 == ((char *)NULL)))
      for( ; !(response[0l] == 0); response[(signed long int)(return_value_strlen$3 - (unsigned long int)1)] = (char)0)
      {
        return_value___ctype_b_loc$1=__ctype_b_loc();
        return_value_strlen$2=strlen(response);
        if((8192 & (signed int)(*return_value___ctype_b_loc$1)[(signed long int)(signed int)response[-1l + (signed long int)return_value_strlen$2]]) == 0)
          break;

        return_value_strlen$3=strlen(response);
      }

    signed int return_value_strcasecmp$6;
    return_value_strcasecmp$6=strcasecmp(response, "y");
    if(!(return_value_strcasecmp$6 == 0))
    {
      return_value_strcasecmp$5=strcasecmp(response, "yes");
      if(!(return_value_strcasecmp$5 == 0))
      {
        warnx("not confirmed");
        goto fail0;
      }

    }

  }

  memset((void *)priv, 0, sizeof(struct erase_state) /*4368ul*/ );
  priv->quiet = config->quiet;
  r=pthread_mutex_init(&priv->mutex, (const union anonymous$15 *)(void *)0);
  if(!(r == 0))
  {
    char *return_value_strerror$7;
    return_value_strerror$7=strerror(r);
    warnx("pthread_mutex_init: %s", return_value_strerror$7);
    goto fail0;
  }

  r=pthread_cond_init(&priv->thread_wakeup, (const union anonymous$15 *)(void *)0);
  if(!(r == 0))
  {
    char *return_value_strerror$8;
    return_value_strerror$8=strerror(r);
    warnx("pthread_cond_init: %s", return_value_strerror$8);
    goto fail1;
  }

  r=pthread_cond_init(&priv->queue_not_full, (const union anonymous$15 *)(void *)0);
  if(!(r == 0))
  {
    char *return_value_strerror$9;
    return_value_strerror$9=strerror(r);
    warnx("pthread_cond_init: %s", return_value_strerror$9);
    goto fail2;
  }

  i = 0;
  for( ; !(i >= 25); i = i + 1)
  {
    r=pthread_create(&priv->threads[(signed long int)i], (const union pthread_attr_t *)(void *)0, erase_thread_main, (void *)priv);
    if(!(r == 0))
      goto fail3;

  }
  if(config->quiet == 0)
  {
    fprintf(stderr, "s3backer: erasing non-zero blocks...");
    fflush(stderr);
  }

  struct s3backer_store *tmp_if_expr$12;
  struct s3backer_store *return_value_test_io_create$10;
  struct s3backer_store *return_value_http_io_create$11;
  if(!(config->test == 0))
  {
    return_value_test_io_create$10=test_io_create(&config->http_io);
    tmp_if_expr$12 = return_value_test_io_create$10;
  }

  else
  {
    return_value_http_io_create$11=http_io_create(&config->http_io);
    tmp_if_expr$12 = return_value_http_io_create$11;
  }
  priv->s3b = tmp_if_expr$12;
  if(priv->s3b == ((struct s3backer_store *)NULL))
    warnx(config->test != 0 ? "test_io_create" : "http_io_create");

  else
  {
    r=priv->s3b->list_blocks(priv->s3b, erase_list_callback, (void *)priv);
    if(!(r == 0))
    {
      char *return_value_strerror$13;
      return_value_strerror$13=strerror(r);
      warnx("can't list blocks: %s", return_value_strerror$13);
    }

    r=priv->s3b->set_mounted(priv->s3b, (signed int *)(void *)0, 0);
    if(!(r == 0))
    {
      char *return_value_strerror$14;
      return_value_strerror$14=strerror(r);
      warnx("can't clear mounted flag: %s", return_value_strerror$14);
    }

    ok = 1;
  }

fail3:
  ;
  pthread_mutex_lock(&priv->mutex);
  priv->stopping = 1;
  pthread_cond_broadcast(&priv->thread_wakeup);
  pthread_mutex_unlock(&priv->mutex);
  i = 0;
  char *return_value_strerror$15;
  for( ; !(i >= 25); i = i + 1)
    if(!(priv->threads[(signed long int)i] == 0ul))
    {
      r=pthread_join(priv->threads[(signed long int)i], (void **)(void *)0);
      if(!(r == 0))
      {
        return_value_strerror$15=strerror(r);
        warnx("pthread_join: %s", return_value_strerror$15);
      }

    }

  if(!(priv->s3b == ((struct s3backer_store *)NULL)))
  {
    if(!(ok == 0))
    {
      if(config->quiet == 0)
      {
        fprintf(stderr, "done\n");
        warnx("erased %ju non-zero blocks", priv->count);
      }

    }

    priv->s3b->destroy(priv->s3b);
  }

  pthread_cond_destroy(&priv->queue_not_full);

fail2:
  ;
  pthread_cond_destroy(&priv->thread_wakeup);

fail1:
  ;
  pthread_mutex_destroy(&priv->mutex);

fail0:
  ;
  return ok != 0 ? 0 : -1;
}

// s3backer_get_config
// file s3b_config.h line 73
extern struct s3b_config * s3backer_get_config(signed int argc, char **argv)
{
  const signed int num_options = (const signed int)(sizeof(struct fuse_opt [55l]) /*1320ul*/  / sizeof(struct fuse_opt) /*24ul*/ );
  struct fuse_opt dup_option_list[2641l];
  char buf[1024l];
  signed int i;
  config$link1.fuse_ops.uid=getuid();
  config$link1.fuse_ops.gid=getgid();
  snprintf(user_agent_buf, sizeof(char [64l]) /*64ul*/ , "%s/%s/%s", (const void *)"s3backer", (const void *)"1.4.2", s3backer_version);
  memset((void *)&config$link1.fuse_args, 0, sizeof(struct fuse_args) /*24ul*/ );
  i = 0;
  for( ; !(i >= argc); i = i + 1)
  {
    signed int return_value_fuse_opt_insert_arg$1;
    return_value_fuse_opt_insert_arg$1=fuse_opt_insert_arg(&config$link1.fuse_args, i, argv[(signed long int)i]);
    if(!(return_value_fuse_opt_insert_arg$1 == 0))
      err(1, "fuse_opt_insert_arg");

  }
  i = 0;
  for( ; !((unsigned long int)i >= 11ul); i = i + 1)
  {
    signed int return_value_fuse_opt_insert_arg$2;
    return_value_fuse_opt_insert_arg$2=fuse_opt_insert_arg(&config$link1.fuse_args, i + 1, s3backer_fuse_defaults[(signed long int)i]);
    if(!(return_value_fuse_opt_insert_arg$2 == 0))
      err(1, "fuse_opt_insert_arg");

  }
  memcpy((void *)dup_option_list, (const void *)option_list, sizeof(struct fuse_opt [55l]) /*1320ul*/ );
  memcpy((void *)(dup_option_list + (signed long int)num_options), (const void *)option_list, sizeof(struct fuse_opt [55l]) /*1320ul*/ );
  i = num_options;
  for( ; !(i >= 2 * num_options); i = i + 1)
    dup_option_list[(signed long int)i].templ = dup_option_list[(signed long int)i].templ + (signed long int)2;
  dup_option_list[(signed long int)(2 * num_options)].templ = (const char *)(void *)0;
  signed int return_value_fuse_opt_parse$3;
  return_value_fuse_opt_parse$3=fuse_opt_parse(&config$link1.fuse_args, (void *)&config$link1, dup_option_list, handle_unknown_option);
  if(!(return_value_fuse_opt_parse$3 == 0))
    return (struct s3b_config *)(void *)0;

  else
  {
    signed int return_value_validate_config$4;
    return_value_validate_config$4=validate_config();
    if(!(return_value_validate_config$4 == 0))
      return (struct s3b_config *)(void *)0;

    else
    {
      snprintf(buf, sizeof(char [1024l]) /*1024ul*/ , "-ofsname=%s", (const void *)config$link1.description);
      signed int return_value_fuse_opt_insert_arg$5;
      return_value_fuse_opt_insert_arg$5=fuse_opt_insert_arg(&config$link1.fuse_args, 1, buf);
      if(!(return_value_fuse_opt_insert_arg$5 == 0))
        err(1, "fuse_opt_insert_arg");

      config$link1.fuse_ops.print_stats = s3b_config_print_stats;
      config$link1.fuse_ops.s3bconf = &config$link1;
      if(!(config$link1.debug == 0))
        dump_config();

      return &config$link1;
    }
  }
}

// s3backer_reset
// file reset.c line 47
extern signed int s3backer_reset(struct s3b_config *config)
{
  struct s3backer_store *s3b = (struct s3backer_store *)(void *)0;
  signed int ok = 0;
  signed int r;
  if(config->quiet == 0)
    warnx("resetting mounted flag for %s", (const void *)config->description);

  struct s3backer_store *tmp_if_expr$3;
  struct s3backer_store *return_value_test_io_create$1;
  struct s3backer_store *return_value_http_io_create$2;
  if(!(config->test == 0))
  {
    return_value_test_io_create$1=test_io_create(&config->http_io);
    tmp_if_expr$3 = return_value_test_io_create$1;
  }

  else
  {
    return_value_http_io_create$2=http_io_create(&config->http_io);
    tmp_if_expr$3 = return_value_http_io_create$2;
  }
  s3b = tmp_if_expr$3;
  if(s3b == ((struct s3backer_store *)NULL))
    warnx(config->test != 0 ? "test_io_create" : "http_io_create");

  else
  {
    r=s3b->set_mounted(s3b, (signed int *)(void *)0, 0);
    if(!(r == 0))
    {
      char *return_value_strerror$4;
      return_value_strerror$4=strerror(r);
      warnx("error clearing mounted flag: %s", return_value_strerror$4);
    }

    if(config->quiet == 0)
      warnx("done");

    ok = 1;
  }

fail:
  ;
  if(!(s3b == ((struct s3backer_store *)NULL)))
    s3b->destroy(s3b);

  return ok != 0 ? 0 : -1;
}

// search_access_for
// file s3b_config.c line 859
static signed int search_access_for(const char *file, const char *accessId, char **idptr, char **pwptr)
{
  char buf[1024l];
  struct _IO_FILE *fp;
  if(!(idptr == ((char **)NULL)))
    *idptr = (char *)(void *)0;

  if(!(pwptr == ((char **)NULL)))
    *pwptr = (char *)(void *)0;

  fp=fopen(file, "r");
  char *return_value_fgets$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  const unsigned short int **return_value___ctype_b_loc$3;
  _Bool tmp_if_expr$5;
  const unsigned short int **return_value___ctype_b_loc$6;
  unsigned long int return_value_strlen$7;
  unsigned long int return_value_strlen$8;
  signed int return_value_strcmp$9;
  if(fp == ((struct _IO_FILE *)NULL))
    return 0;

  else
  {
    do
    {
      return_value_fgets$1=fgets(buf, (signed int)sizeof(char [1024l]) /*1024ul*/ , fp);
      if(return_value_fgets$1 == ((char *)NULL))
        break;

      char *colon;
      if((signed int)buf[0l] == 35)
        tmp_if_expr$2 = (_Bool)1;

      else
        tmp_if_expr$2 = (signed int)buf[0l] == 0 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr$2)
        tmp_if_expr$4 = (_Bool)1;

      else
      {
        return_value___ctype_b_loc$3=__ctype_b_loc();
        tmp_if_expr$4 = ((signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)buf[0l]] & (signed int)(unsigned short int)8192) != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr$4)
        tmp_if_expr$5 = (_Bool)1;

      else
      {
        colon=strchr(buf, 58);
        tmp_if_expr$5 = colon == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
      }
      if(!tmp_if_expr$5)
      {
        for( ; !((signed int)buf[0l] == 0); buf[(signed long int)(return_value_strlen$8 - (unsigned long int)1)] = (char)0)
        {
          return_value___ctype_b_loc$6=__ctype_b_loc();
          return_value_strlen$7=strlen(buf);
          if((8192 & (signed int)(*return_value___ctype_b_loc$6)[(signed long int)(signed int)buf[-1l + (signed long int)return_value_strlen$7]]) == 0)
            break;

          return_value_strlen$8=strlen(buf);
        }
        *colon = (char)0;
        if(!(accessId == ((const char *)NULL)))
        {
          return_value_strcmp$9=strcmp(buf, accessId);
          if(return_value_strcmp$9 == 0)
            goto __CPROVER_DUMP_L12;

        }

        else
        {

        __CPROVER_DUMP_L12:
          ;
          if(!(idptr == ((char **)NULL)))
          {
            *idptr=strdup(buf);
            if(*idptr == ((char *)NULL))
              err(1, "strdup");

          }

          if(!(pwptr == ((char **)NULL)))
          {
            *pwptr=strdup(colon + (signed long int)1);
            if(*pwptr == ((char *)NULL))
              err(1, "strdup");

          }

          fclose(fp);
          return 1;
        }
      }

    }
    while((_Bool)1);
    fclose(fp);
    return 0;
  }
}

// stderr_logger
// file s3b_config.c line 1590
static void stderr_logger(signed int level, const char *fmt, ...)
{
  const char *levelstr;
  char timebuf[32l];
  void **args;
  struct tm tm;
  signed long int now;
  if(!(config$link1.debug == 0) || !(level == 7))
  {
    switch(level)
    {
      case 3:
      {
        levelstr = "ERROR";
        break;
      }
      case 4:
      {
        levelstr = "WARNING";
        break;
      }
      case 5:
      {
        levelstr = "NOTICE";
        break;
      }
      case 6:
      {
        levelstr = "INFO";
        break;
      }
      case 7:
      {
        levelstr = "DEBUG";
        break;
      }
      default:
        levelstr = "<?>";
    }
    time(&now);
    struct tm *return_value_localtime_r$1;
    return_value_localtime_r$1=localtime_r(&now, &tm);
    strftime(timebuf, sizeof(char [32l]) /*32ul*/ , "%F %T", return_value_localtime_r$1);
    args = (void **)&fmt;
    fprintf(stderr, "%s %s: ", (const void *)timebuf, levelstr);
    vfprintf(stderr, fmt, args);
    fprintf(stderr, "\n");
    args = ((void **)NULL);
  }

}

// syslog_logger
// file s3b_config.c line 1575
static void syslog_logger(signed int level, const char *fmt, ...)
{
  void **args;
  if(!(config$link1.debug == 0) || !(level == 7))
  {
    args = (void **)&fmt;
    vsyslog(level, fmt, args);
    args = ((void **)NULL);
  }

}

// test_io_create
// file test_io.h line 38
extern struct s3backer_store * test_io_create(struct http_io_conf *config)
{
  struct s3backer_store *s3b;
  struct test_io_private *priv;
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)1, sizeof(struct s3backer_store) /*80ul*/ );
  s3b = (struct s3backer_store *)return_value_calloc$1;
  if(s3b == ((struct s3backer_store *)NULL))
    return (struct s3backer_store *)(void *)0;

  else
  {
    s3b->meta_data = test_io_meta_data;
    s3b->set_mounted = test_io_set_mounted;
    s3b->read_block = test_io_read_block;
    s3b->write_block = test_io_write_block;
    s3b->read_block_part = test_io_read_block_part;
    s3b->write_block_part = test_io_write_block_part;
    s3b->list_blocks = test_io_list_blocks;
    s3b->flush = test_io_flush;
    s3b->destroy = test_io_destroy;
    void *return_value_calloc$3;
    return_value_calloc$3=calloc((unsigned long int)1, sizeof(struct test_io_private) /*8ul*/  + (unsigned long int)config->block_size);
    priv = (struct test_io_private *)return_value_calloc$3;
    if(priv == ((struct test_io_private *)NULL))
    {
      free((void *)s3b);
      signed int *return_value___errno_location$2;
      return_value___errno_location$2=__errno_location();
      *return_value___errno_location$2 = 12;
      return (struct s3backer_store *)(void *)0;
    }

    priv->config = config;
    s3b->data = (void *)priv;
    signed long int return_value_time$4;
    return_value_time$4=time((signed long int *)(void *)0);
    srandom((unsigned int)return_value_time$4);
    return s3b;
  }
}

// test_io_destroy
// file test_io.c line 123
static void test_io_destroy(struct s3backer_store * const s3b)
{
  struct test_io_private * const priv = (struct test_io_private *)s3b->data;
  free((void *)priv);
  free((void *)s3b);
}

// test_io_flush
// file test_io.c line 117
static signed int test_io_flush(struct s3backer_store * const s3b)
{
  return 0;
}

// test_io_list_blocks
// file test_io.c line 345
static signed int test_io_list_blocks(struct s3backer_store *s3b, void (*callback)(void *, unsigned int), void *arg)
{
  struct test_io_private * const priv = (struct test_io_private *)s3b->data;
  struct http_io_conf * const test_io_list_blocks$$1$$config = priv->config;
  unsigned int block_num;
  struct dirent *dent;
  struct __dirstream *dir;
  signed int i;
  dir=opendir(test_io_list_blocks$$1$$config->bucket);
  signed int *return_value___errno_location$1;
  if(dir == ((struct __dirstream *)NULL))
  {
    return_value___errno_location$1=__errno_location();
    return *return_value___errno_location$1;
  }

  else
  {
    i = 0;
    do
    {
      dent=readdir(dir);
      if(dent == ((struct dirent *)NULL))
        break;

      signed int return_value_http_io_parse_block$2;
      return_value_http_io_parse_block$2=http_io_parse_block(test_io_list_blocks$$1$$config, dent->d_name, &block_num);
      if(return_value_http_io_parse_block$2 == 0)
        callback(arg, block_num);

      i = i + 1;
    }
    while((_Bool)1);
    closedir(dir);
    return 0;
  }
}

// test_io_meta_data
// file test_io.c line 103
static signed int test_io_meta_data(struct s3backer_store *s3b, signed long int *file_sizep, unsigned int *block_sizep)
{
  return 0;
}

// test_io_read_block
// file test_io.c line 132
static signed int test_io_read_block(struct s3backer_store * const s3b, unsigned int block_num, void *dest, unsigned char *actual_md5, const unsigned char *expect_md5, signed int strict)
{
  struct test_io_private * const priv = (struct test_io_private *)s3b->data;
  struct http_io_conf * const test_io_read_block$$1$$config = priv->config;
  unsigned char md5[16l];
  char path[4096l];
  signed int test_io_read_block$$1$$zero_block;
  struct MD5state_st ctx;
  signed int fd;
  signed int r;
  if(!(test_io_read_block$$1$$config->debug == 0))
    test_io_read_block$$1$$config->log(7, "test_io: read %0*jx started", (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)block_num);

  signed long int return_value_random$1;
  return_value_random$1=random();
  usleep((unsigned int)((return_value_random$1 % (signed long int)200) * (signed long int)1000));
  signed long int return_value_random$2;
  return_value_random$2=random();
  signed int *return_value___errno_location$6;
  if(!(return_value_random$2 % 100l >= 0l))
  {
    test_io_read_block$$1$$config->log(3, "test_io: random failure reading %0*jx", (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)block_num);
    return 11;
  }

  else
  {
    snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%s/%s%0*jx", test_io_read_block$$1$$config->bucket, test_io_read_block$$1$$config->prefix, (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)block_num);
    fd=open(path, 00);
    if(!(fd == -1))
    {
      signed int total = 0;
      for( ; !((unsigned int)total >= test_io_read_block$$1$$config->block_size); total = total + r)
      {
        signed long int return_value_read$5;
        return_value_read$5=read(fd, (void *)((char *)dest + (signed long int)total), (unsigned long int)(test_io_read_block$$1$$config->block_size - (unsigned int)total));
        r = (signed int)return_value_read$5;
        if(r == -1)
        {
          signed int *return_value___errno_location$3;
          return_value___errno_location$3=__errno_location();
          r = *return_value___errno_location$3;
          char *return_value_strerror$4;
          return_value_strerror$4=strerror(r);
          test_io_read_block$$1$$config->log(3, "can't read %s: %s", (const void *)path, return_value_strerror$4);
          close(fd);
          return r;
        }

        if(r == 0)
          break;

      }
      close(fd);
      if(!((unsigned int)total == test_io_read_block$$1$$config->block_size))
      {
        test_io_read_block$$1$$config->log(3, "%s: file is truncated (only read %d out of %u bytes)", (const void *)path, total, test_io_read_block$$1$$config->block_size);
        return 5;
      }

      r = 0;
    }

    else
    {
      return_value___errno_location$6=__errno_location();
      r = *return_value___errno_location$6;
    }
    test_io_read_block$$1$$zero_block = (signed int)(r == 2);
    if(!(test_io_read_block$$1$$zero_block == 0))
    {
      memset(dest, 0, (unsigned long int)test_io_read_block$$1$$config->block_size);
      r = 0;
    }

    if(!(r == 0))
    {
      char *return_value_strerror$7;
      return_value_strerror$7=strerror(r);
      test_io_read_block$$1$$config->log(3, "can't open %s: %s", (const void *)path, return_value_strerror$7);
      return r;
    }

    if(!(test_io_read_block$$1$$zero_block == 0))
      memset((void *)md5, 0, (unsigned long int)16);

    else
    {
      MD5_Init(&ctx);
      MD5_Update(&ctx, dest, (unsigned long int)test_io_read_block$$1$$config->block_size);
      MD5_Final(md5, &ctx);
    }
    if(!(actual_md5 == ((unsigned char *)NULL)))
      memcpy((void *)actual_md5, (const void *)md5, (unsigned long int)16);

    if(!(expect_md5 == ((const unsigned char *)NULL)))
    {
      signed int match;
      match=memcmp((const void *)md5, (const void *)expect_md5, (unsigned long int)16);
      if(!(strict == 0))
      {
        if(match == 0)
        {
          test_io_read_block$$1$$config->log(3, "%s: wrong MD5 checksum?!", (const void *)path);
          return 22;
        }

      }

      else
        if(!(match == 0))
          r = 17;

    }

    if(!(test_io_read_block$$1$$config->debug == 0))
      test_io_read_block$$1$$config->log(7, "test_io: read %0*jx complete%s%s", (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)block_num, test_io_read_block$$1$$zero_block != 0 ? " (zero)" : "", r == 17 ? " (expected md5 match)" : "");

    return r;
  }
}

// test_io_read_block_part
// file test_io.c line 327
static signed int test_io_read_block_part(struct s3backer_store *s3b, unsigned int block_num, unsigned int off, unsigned int len, void *dest)
{
  struct test_io_private * const priv = (struct test_io_private *)s3b->data;
  struct http_io_conf * const test_io_read_block_part$$1$$config = priv->config;
  signed int return_value_block_part_read_block_part$1;
  return_value_block_part_read_block_part$1=block_part_read_block_part(s3b, block_num, test_io_read_block_part$$1$$config->block_size, off, len, dest);
  return return_value_block_part_read_block_part$1;
}

// test_io_set_mounted
// file test_io.c line 109
static signed int test_io_set_mounted(struct s3backer_store *s3b, signed int *old_valuep, signed int new_value)
{
  if(!(old_valuep == ((signed int *)NULL)))
    *old_valuep = 0;

  return 0;
}

// test_io_write_block
// file test_io.c line 235
static signed int test_io_write_block(struct s3backer_store * const s3b, unsigned int block_num, const void *src, unsigned char *caller_md5, signed int (*check_cancel)(void *, unsigned int), void *check_cancel_arg)
{
  struct test_io_private * const priv = (struct test_io_private *)s3b->data;
  struct http_io_conf * const test_io_write_block$$1$$config = priv->config;
  unsigned char md5[16l];
  char temp[4096l];
  char path[4096l];
  struct MD5state_st ctx;
  signed int total;
  signed int fd;
  signed int r;
  signed int return_value_memcmp$1;
  if(!(src == NULL))
  {
    return_value_memcmp$1=memcmp(src, (const void *)priv->zero_block, (unsigned long int)test_io_write_block$$1$$config->block_size);
    if(return_value_memcmp$1 == 0)
      src = (void *)0;

  }

  if(!(src == NULL))
  {
    MD5_Init(&ctx);
    MD5_Update(&ctx, src, (unsigned long int)test_io_write_block$$1$$config->block_size);
    MD5_Final(md5, &ctx);
  }

  else
    memset((void *)md5, 0, (unsigned long int)16);
  if(!(caller_md5 == ((unsigned char *)NULL)))
    memcpy((void *)caller_md5, (const void *)md5, (unsigned long int)16);

  if(!(test_io_write_block$$1$$config->debug == 0))
    test_io_write_block$$1$$config->log(7, "test_io: write %0*jx started%s", (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)block_num, src == (void *)0 ? " (zero block)" : "");

  signed long int return_value_random$2;
  return_value_random$2=random();
  usleep((unsigned int)((return_value_random$2 % (signed long int)200) * (signed long int)1000));
  signed long int return_value_random$3;
  return_value_random$3=random();
  signed int *return_value___errno_location$6;
  if(!(return_value_random$3 % 100l >= 0l))
  {
    test_io_write_block$$1$$config->log(3, "test_io: random failure writing %0*jx", (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)block_num);
    return 11;
  }

  else
  {
    snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%s/%s%0*jx", test_io_write_block$$1$$config->bucket, test_io_write_block$$1$$config->prefix, (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)block_num);
    if(src == NULL)
    {
      signed int return_value_unlink$7;
      return_value_unlink$7=unlink(path);
      if(return_value_unlink$7 == -1)
      {
        return_value___errno_location$6=__errno_location();
        if(!(*return_value___errno_location$6 == 2))
        {
          signed int *return_value___errno_location$4;
          return_value___errno_location$4=__errno_location();
          r = *return_value___errno_location$4;
          char *return_value_strerror$5;
          return_value_strerror$5=strerror(r);
          test_io_write_block$$1$$config->log(3, "can't unlink %s: %s", (const void *)path, return_value_strerror$5);
          return r;
        }

      }

      return 0;
    }

    snprintf(temp, sizeof(char [4096l]) /*4096ul*/ , "%s.XXXXXX", (const void *)path);
    fd=mkstemp(temp);
    if(fd == -1)
    {
      signed int *return_value___errno_location$8;
      return_value___errno_location$8=__errno_location();
      r = *return_value___errno_location$8;
      char *return_value_strerror$9;
      return_value_strerror$9=strerror(r);
      test_io_write_block$$1$$config->log(3, "%s: %s", (const void *)temp, return_value_strerror$9);
      return r;
    }

    total = 0;
    for( ; !((unsigned int)total >= test_io_write_block$$1$$config->block_size); total = total + r)
    {
      signed long int return_value_write$12;
      return_value_write$12=write(fd, (const void *)((const char *)src + (signed long int)total), (unsigned long int)(test_io_write_block$$1$$config->block_size - (unsigned int)total));
      r = (signed int)return_value_write$12;
      if(r == -1)
      {
        signed int *return_value___errno_location$10;
        return_value___errno_location$10=__errno_location();
        r = *return_value___errno_location$10;
        char *return_value_strerror$11;
        return_value_strerror$11=strerror(r);
        test_io_write_block$$1$$config->log(3, "can't write %s: %s", (const void *)temp, return_value_strerror$11);
        close(fd);
        unlink(temp);
        return r;
      }

    }
    close(fd);
    signed int return_value_rename$15;
    return_value_rename$15=rename(temp, path);
    if(return_value_rename$15 == -1)
    {
      signed int *return_value___errno_location$13;
      return_value___errno_location$13=__errno_location();
      r = *return_value___errno_location$13;
      char *return_value_strerror$14;
      return_value_strerror$14=strerror(r);
      test_io_write_block$$1$$config->log(3, "can't rename %s: %s", (const void *)temp, return_value_strerror$14);
      unlink(temp);
      return r;
    }

    if(!(test_io_write_block$$1$$config->debug == 0))
      test_io_write_block$$1$$config->log(7, "test_io: write %0*jx complete", (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)block_num);

    return 0;
  }
}

// test_io_write_block_part
// file test_io.c line 336
static signed int test_io_write_block_part(struct s3backer_store *s3b, unsigned int block_num, unsigned int off, unsigned int len, const void *src)
{
  struct test_io_private * const priv = (struct test_io_private *)s3b->data;
  struct http_io_conf * const test_io_write_block_part$$1$$config = priv->config;
  signed int return_value_block_part_write_block_part$1;
  return_value_block_part_write_block_part$1=block_part_write_block_part(s3b, block_num, test_io_write_block_part$$1$$config->block_size, off, len, src);
  return return_value_block_part_write_block_part$1;
}

// thread_main
// file tester.c line 118
static void * thread_main(void *arg)
{
  const signed int id = (signed int)(signed long int)arg;
  const signed long int id$array_size0 = (signed long int)config->block_size;
  unsigned char data[id$array_size0];
  unsigned int block_num;
  signed int millis;
  signed int r;
  unsigned int tmp_if_expr$7;
  signed long int return_value_random$6;
  char *return_value_strerror$8;
  char *tmp_if_expr$10;
  char *return_value_strerror$9;
  while((_Bool)1)
  {
    signed long int return_value_random$1;
    return_value_random$1=random();
    millis = (signed int)((signed long int)0 + return_value_random$1 % (signed long int)50);
    usleep((unsigned int)(millis * 1000));
    signed long int return_value_random$2;
    return_value_random$2=random();
    block_num = (unsigned int)(return_value_random$2 % config->num_blocks);
    signed long int return_value_random$11;
    return_value_random$11=random();
    if(!(return_value_random$11 % 2l == 0l))
    {
      struct block_state * const state = &blocks[(signed long int)block_num];
      struct block_state before;
      struct block_state after;
      pthread_mutex_lock(&mutex);
      memcpy((void *)&before, (const void *)state, sizeof(struct block_state) /*12ul*/ );
      pthread_mutex_unlock(&mutex);
      logit(id, "rd %0*jx START\n", (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)block_num);
      r=store->read_block(store, block_num, (void *)data, (unsigned char *)(void *)0, (const unsigned char *)(void *)0, 0);
      if(!(r == 0))
      {
        char *return_value_strerror$3;
        return_value_strerror$3=strerror(r);
        logit(id, "****** READ ERROR: %s", return_value_strerror$3);
        continue;
      }

      pthread_mutex_lock(&mutex);
      memcpy((void *)&after, (const void *)state, sizeof(struct block_state) /*12ul*/ );
      pthread_mutex_unlock(&mutex);
      if(after.writing == 0u && before.counter == after.counter && before.writing == 0u)
      {
        signed int return_value_memcmp$4;
        return_value_memcmp$4=memcmp((const void *)data, (const void *)&before.content, sizeof(unsigned int) /*4ul*/ );
        if(!(return_value_memcmp$4 == 0))
        {
          logit(id, "got wrong content block %0*jx", (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)block_num);
          exit(1);
        }

      }

      logit(id, "rd %0*jx content=0x%02x%02x%02x%02x COMPLETE\n", (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)block_num, data[(signed long int)0], data[(signed long int)1], data[(signed long int)2], data[(signed long int)3]);
    }

    else
    {
      struct block_state * const thread_main$$1$$1$$2$$state = &blocks[(signed long int)block_num];
      unsigned int content;
      pthread_mutex_lock(&mutex);
      if(!(thread_main$$1$$1$$2$$state->writing == 0u))
      {
        pthread_mutex_unlock(&mutex);
        continue;
      }

      thread_main$$1$$1$$2$$state->writing = (unsigned int)1;
      pthread_mutex_unlock(&mutex);
      signed long int return_value_random$5;
      return_value_random$5=random();
      if(!(return_value_random$5 % 3l == 0l))
        tmp_if_expr$7 = (unsigned int)0;

      else
      {
        return_value_random$6=random();
        tmp_if_expr$7 = (unsigned int)return_value_random$6;
      }
      content = tmp_if_expr$7;
      memcpy((void *)data, (const void *)&content, sizeof(unsigned int) /*4ul*/ );
      memset((void *)(data + (signed long int)sizeof(unsigned int) /*4ul*/ ), 0, (unsigned long int)config->block_size - sizeof(unsigned int) /*4ul*/ );
      logit(id, "wr %0*jx content=0x%02x%02x%02x%02x START\n", (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)block_num, data[(signed long int)0], data[(signed long int)1], data[(signed long int)2], data[(signed long int)3]);
      r=store->write_block(store, block_num, (const void *)data, (unsigned char *)(void *)0, (signed int (*)(void *, unsigned int))(void *)0, (void *)0);
      if(!(r == 0))
      {
        return_value_strerror$8=strerror(r);
        logit(id, "****** WRITE ERROR: %s", return_value_strerror$8);
      }

      if(!(r == 0))
      {
        return_value_strerror$9=strerror(r);
        tmp_if_expr$10 = return_value_strerror$9;
      }

      else
        tmp_if_expr$10 = "";
      logit(id, "wr %0*jx content=0x%02x%02x%02x%02x %s%s\n", (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)2), (unsigned long int)block_num, data[(signed long int)0], data[(signed long int)1], data[(signed long int)2], data[(signed long int)3], r != 0 ? "FAILED: " : "COMPLETE", tmp_if_expr$10);
      pthread_mutex_lock(&mutex);
      if(r == 0)
      {
        thread_main$$1$$1$$2$$state->counter = thread_main$$1$$1$$2$$state->counter + 1u;
        thread_main$$1$$1$$2$$state->content = content;
      }

      thread_main$$1$$1$$2$$state->writing = (unsigned int)0;
      pthread_mutex_unlock(&mutex);
    }
  }
}

// unparse_size_string
// file s3b_config.c line 783
static void unparse_size_string(char *buf, unsigned long int bmax, unsigned long int value)
{
  unsigned long int unit;
  signed int i;
  signed int tmp_post$1;
  if(value == 0ul)
    snprintf(buf, bmax, "0");

  else
  {
    i = (signed int)(sizeof(struct size_suffix [8l]) /*128ul*/  / sizeof(struct size_suffix) /*16ul*/ );
    do
    {
      tmp_post$1 = i;
      i = i - 1;
      if(!(tmp_post$1 >= 1))
        break;

      struct size_suffix * const ss = &size_suffixes[(signed long int)i];
      if(!((unsigned long int)ss->bits >= sizeof(signed long int) * 8 /*64ul*/ ))
      {
        unit = (unsigned long int)1 << ss->bits;
        if(value % unit == 0ul)
        {
          snprintf(buf, bmax, "%ju%s", value / unit, ss->suffix);
          goto __CPROVER_DUMP_L7;
        }

      }

    }
    while((_Bool)1);
    snprintf(buf, bmax, "%ju", value);
  }

__CPROVER_DUMP_L7:
  ;
}

// update_hmac_from_header
// file http_io.c line 2597
static void update_hmac_from_header(struct hmac_ctx_st * const ctx, struct http_io * const io, const char *name, signed int value_only, char *sigbuf, unsigned long int sigbuflen)
{
  struct curl_slist *header;
  const char *colon;
  const char *value;
  unsigned long int name_len;
  colon=strchr(name, 58);
  unsigned long int tmp_if_expr$2;
  unsigned long int return_value_strlen$1;
  if(!(colon == ((const char *)NULL)))
    tmp_if_expr$2 = (unsigned long int)(colon - name);

  else
  {
    return_value_strlen$1=strlen(name);
    tmp_if_expr$2 = return_value_strlen$1;
  }
  name_len = tmp_if_expr$2;
  header = io->headers;
  const unsigned short int **return_value___ctype_b_loc$3;
  for( ; !(header == ((struct curl_slist *)NULL)); header = header->next)
  {
    signed int return_value_strncasecmp$5;
    return_value_strncasecmp$5=strncasecmp(header->data, name, name_len);
    if(return_value_strncasecmp$5 == 0)
    {
      if((signed int)header->data[(signed long int)name_len] == 58)
      {
        if(value_only == 0)
          HMAC_Update(ctx, (const unsigned char *)header->data, name_len + (unsigned long int)1);

        value = header->data + (signed long int)name_len + (signed long int)1;
        do
        {
          return_value___ctype_b_loc$3=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc$3)[(signed long int)(signed int)*value]) == 0)
            break;

          value = value + 1l;
        }
        while((_Bool)1);
        unsigned long int return_value_strlen$4;
        return_value_strlen$4=strlen(value);
        HMAC_Update(ctx, (const unsigned char *)value, return_value_strlen$4);
        break;
      }

    }

  }
  HMAC_Update(ctx, (const unsigned char *)"\n", (unsigned long int)1);
}

// update_iam_credentials
// file http_io.c line 898
static signed int update_iam_credentials(struct http_io_private * const priv)
{
  struct http_io_conf * const update_iam_credentials$$1$$config = priv->config;
  char urlbuf[(signed long int)(sizeof(char [66l]) * 2 + 62) /*194l*/ ];
  struct http_io io;
  char buf[2048l] = { (char)0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  char *access_id = (char *)(void *)0;
  char *access_key = (char *)(void *)0;
  char *iam_token = (char *)(void *)0;
  unsigned long int buflen;
  signed int r;
  snprintf(urlbuf, sizeof(char [194l]) /*194ul*/ , "%s%s", (const void *)"http://169.254.169.254/latest/meta-data/iam/security-credentials/", update_iam_credentials$$1$$config->ec2iam_role);
  memset((void *)&io, 0, sizeof(struct http_io) /*272ul*/ );
  io.url = urlbuf;
  io.method = "GET";
  io.dest = (void *)buf;
  io.buf_size = (unsigned int)sizeof(char [2048l]) /*2048ul*/ ;
  update_iam_credentials$$1$$config->log(6, "acquiring EC2 IAM credentials from %s", io.url);
  r=http_io_perform_io(priv, &io, http_io_iamcreds_prepper);
  if(!(r == 0))
  {
    char *return_value_strerror$1;
    return_value_strerror$1=strerror(r);
    update_iam_credentials$$1$$config->log(3, "failed to acquire EC2 IAM credentials from %s: %s", io.url, return_value_strerror$1);
    return r;
  }

  buflen = (unsigned long int)io.buf_size - io.bufs.rdremain;
  if(buflen >= 2048ul)
    buflen = sizeof(char [2048l]) /*2048ul*/  - (unsigned long int)1;

  buf[(signed long int)buflen] = (char)0;
  access_id=parse_json_field(priv, buf, "AccessKeyId");
  _Bool tmp_if_expr$4;
  if(access_id == ((char *)NULL))
    tmp_if_expr$4 = (_Bool)1;

  else
  {
    access_key=parse_json_field(priv, buf, "SecretAccessKey");
    tmp_if_expr$4 = access_key == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$4)
    tmp_if_expr$5 = (_Bool)1;

  else
  {
    iam_token=parse_json_field(priv, buf, "Token");
    tmp_if_expr$5 = iam_token == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr$5)
  {
    signed int *return_value___errno_location$2;
    return_value___errno_location$2=__errno_location();
    char *return_value_strerror$3;
    return_value_strerror$3=strerror(*return_value___errno_location$2);
    update_iam_credentials$$1$$config->log(3, "failed to extract EC2 IAM credentials from response: %s", return_value_strerror$3);
    free((void *)access_id);
    free((void *)access_key);
    return 22;
  }

  pthread_mutex_lock(&priv->mutex);
  free((void *)update_iam_credentials$$1$$config->accessId);
  free((void *)update_iam_credentials$$1$$config->accessKey);
  free((void *)update_iam_credentials$$1$$config->iam_token);
  update_iam_credentials$$1$$config->accessId = access_id;
  update_iam_credentials$$1$$config->accessKey = access_key;
  update_iam_credentials$$1$$config->iam_token = iam_token;
  pthread_mutex_unlock(&priv->mutex);
  update_iam_credentials$$1$$config->log(6, "successfully updated EC2 IAM credentials from %s", io.url);
  return 0;
}

// update_iam_credentials_main
// file http_io.c line 959
static void * update_iam_credentials_main(void *arg)
{
  struct http_io_private * const priv = (struct http_io_private *)arg;
  while(priv->shutting_down == 0)
  {
    sleep((unsigned int)300);
    if(!(priv->shutting_down == 0))
      break;

    update_iam_credentials(priv);
  }
  return (void *)0;
}

// usage
// file s3b_config.c line 1635
static void usage(void)
{
  signed int i;
  fprintf(stderr, "Usage:\n");
  fprintf(stderr, "\ts3backer [options] bucket /mount/point\n");
  fprintf(stderr, "\ts3backer --test [options] directory /mount/point\n");
  fprintf(stderr, "\ts3backer --erase [options] bucket\n");
  fprintf(stderr, "\ts3backer --reset-mounted-flag [options] bucket\n");
  fprintf(stderr, "Options:\n");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"accessFile=FILE", (const void *)"File containing `accessID:accessKey' pairs");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"accessId=ID", (const void *)"S3 access key ID");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"accessKey=KEY", (const void *)"S3 secret access key");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"accessType=TYPE", (const void *)"S3 ACL used when creating new items; one of:");
  fprintf(stderr, "\t  %-27s ", (const void *)"");
  i = 0;
  for( ; !((unsigned long int)i >= 4ul); i = i + 1)
    fprintf(stderr, "%s%s", i > 0 ? ", " : "  ", s3_acls[(signed long int)i]);
  fprintf(stderr, "\n");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"authVersion=TYPE", (const void *)"Specify S3 authentication style; one of:");
  fprintf(stderr, "\t  %-27s ", (const void *)"");
  i = 0;
  for( ; !((unsigned long int)i >= 2ul); i = i + 1)
    fprintf(stderr, "%s%s", i > 0 ? ", " : "  ", s3_auth_types[(signed long int)i]);
  fprintf(stderr, "\n");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"accessEC2IAM=ROLE", (const void *)"Acquire S3 credentials from EC2 machine via IAM role");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"baseURL=URL", (const void *)"Base URL for all requests");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"blockCacheFile=FILE", (const void *)"Block cache persistent file");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"blockCacheMaxDirty=NUM", (const void *)"Block cache maximum number of dirty blocks");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"blockCacheNoVerify", (const void *)"Disable verification of data loaded from cache file");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"blockCacheSize=NUM", (const void *)"Block cache size (in number of blocks)");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"blockCacheSync", (const void *)"Block cache performs all writes synchronously");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"blockCacheThreads=NUM", (const void *)"Block cache write-back thread pool size");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"blockCacheTimeout=MILLIS", (const void *)"Block cache entry timeout (zero = infinite)");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"blockCacheWriteDelay=MILLIS", (const void *)"Block cache maximum write-back delay");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"blockSize=SIZE", (const void *)"Block size (with optional suffix 'K', 'M', 'G', etc.)");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"cacert=FILE", (const void *)"Specify SSL certificate authority file");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"compress[=LEVEL]", (const void *)"Enable block compression, with 1=fast up to 9=small");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"debug", (const void *)"Enable logging of debug messages");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"debug-http", (const void *)"Print HTTP headers to standard output");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"directIO", (const void *)"Disable kernel caching of the backed file");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"encrypt[=CIPHER]", (const void *)"Enable encryption (implies `--compress')");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"erase", (const void *)"Erase all blocks in the filesystem");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"fileMode=MODE", (const void *)"Permissions of backed file in filesystem");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"filename=NAME", (const void *)"Name of backed file in filesystem");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"force", (const void *)"Ignore different auto-detected block and file sizes");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"help", (const void *)"Show this information and exit");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"initialRetryPause=MILLIS", (const void *)"Inital retry pause after stale data or server error");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"insecure", (const void *)"Don't verify SSL server identity");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"keyLength", (const void *)"Override generated cipher key length");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"listBlocks", (const void *)"Auto-detect non-empty blocks at startup");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"maxDownloadSpeed=BITSPERSEC", (const void *)"Max download bandwidth for a single read");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"maxRetryPause=MILLIS", (const void *)"Max total pause after stale data or server error");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"maxUploadSpeed=BITSPERSEC", (const void *)"Max upload bandwidth for a single write");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"md5CacheSize=NUM", (const void *)"Max size of MD5 cache (zero = disabled)");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"md5CacheTime=MILLIS", (const void *)"Expire time for MD5 cache (zero = infinite)");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"minWriteDelay=MILLIS", (const void *)"Minimum time between same block writes");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"password=PASSWORD", (const void *)"Encrypt using PASSWORD");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"passwordFile=FILE", (const void *)"Encrypt using password read from FILE");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"prefix=STRING", (const void *)"Prefix for resource names within bucket");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"quiet", (const void *)"Omit progress output at startup");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"readAhead=NUM", (const void *)"Number of blocks to read-ahead");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"readAheadTrigger=NUM", (const void *)"# of sequentially read blocks to trigger read-ahead");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"readOnly", (const void *)"Return `Read-only file system' error for write attempts");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"region=region", (const void *)"Specify AWS region");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"reset-mounted-flag", (const void *)"Reset `already mounted' flag in the filesystem");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"rrs", (const void *)"Target written blocks for Reduced Redundancy Storage");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"size=SIZE", (const void *)"File size (with optional suffix 'K', 'M', 'G', etc.)");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"ssl", (const void *)"Enable SSL");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"statsFilename=NAME", (const void *)"Name of statistics file in filesystem");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"test", (const void *)"Run in local test mode (bucket is a directory)");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"timeout=SECONDS", (const void *)"Max time allowed for one HTTP operation");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"timeout=SECONDS", (const void *)"Specify HTTP operation timeout");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"version", (const void *)"Show version information and exit");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"vhost", (const void *)"Use virtual host bucket style URL for all requests");
  fprintf(stderr, "Default values:\n");
  fprintf(stderr, "\t--%-27s \"%s\"\n", (const void *)"accessFile", (const void *)"$HOME/.s3backer_passwd");
  fprintf(stderr, "\t--%-27s %s\n", (const void *)"accessId", (const void *)"The first one listed in `accessFile'");
  fprintf(stderr, "\t--%-27s \"%s\"\n", (const void *)"accessType", (const void *)"private");
  fprintf(stderr, "\t--%-27s \"%s\"\n", (const void *)"authVersion", (const void *)"aws4");
  fprintf(stderr, "\t--%-27s \"%s\"\n", (const void *)"baseURL", (const void *)"http://s3.amazonaws.com/");
  fprintf(stderr, "\t--%-27s %u\n", (const void *)"blockCacheSize", 1000);
  fprintf(stderr, "\t--%-27s %u\n", (const void *)"blockCacheThreads", 20);
  fprintf(stderr, "\t--%-27s %u\n", (const void *)"blockCacheTimeout", 0);
  fprintf(stderr, "\t--%-27s %u\n", (const void *)"blockCacheWriteDelay", 250);
  fprintf(stderr, "\t--%-27s %d\n", (const void *)"blockSize", 4096);
  fprintf(stderr, "\t--%-27s \"%s\"\n", (const void *)"filename", (const void *)"file");
  fprintf(stderr, "\t--%-27s %u\n", (const void *)"initialRetryPause", 200);
  fprintf(stderr, "\t--%-27s %u\n", (const void *)"md5CacheSize", 10000);
  fprintf(stderr, "\t--%-27s %u\n", (const void *)"md5CacheTime", 10000);
  fprintf(stderr, "\t--%-27s 0%03o (0%03o if `--readOnly')\n", (const void *)"fileMode", 0600, 0400);
  fprintf(stderr, "\t--%-27s %u\n", (const void *)"maxRetryPause", 30000);
  fprintf(stderr, "\t--%-27s %u\n", (const void *)"minWriteDelay", 500);
  fprintf(stderr, "\t--%-27s \"%s\"\n", (const void *)"prefix", (const void *)"");
  fprintf(stderr, "\t--%-27s %u\n", (const void *)"readAhead", 4);
  fprintf(stderr, "\t--%-27s %u\n", (const void *)"readAheadTrigger", 2);
  fprintf(stderr, "\t--%-27s \"%s\"\n", (const void *)"region", (const void *)"us-east-1");
  fprintf(stderr, "\t--%-27s \"%s\"\n", (const void *)"statsFilename", (const void *)"stats");
  fprintf(stderr, "\t--%-27s %u\n", (const void *)"timeout", 30);
  fprintf(stderr, "FUSE options (partial list):\n");
  fprintf(stderr, "\t%-29s %s\n", (const void *)"-o nonempty", (const void *)"Allows mount over a non-empty directory");
  fprintf(stderr, "\t%-29s %s\n", (const void *)"-o uid=UID", (const void *)"Set user ID");
  fprintf(stderr, "\t%-29s %s\n", (const void *)"-o gid=GID", (const void *)"Set group ID");
  fprintf(stderr, "\t%-29s %s\n", (const void *)"-o sync_read", (const void *)"Do synchronous reads");
  fprintf(stderr, "\t%-29s %s\n", (const void *)"-o max_readahead=NUM", (const void *)"Set maximum read-ahead (bytes)");
  fprintf(stderr, "\t%-29s %s\n", (const void *)"-f", (const void *)"Run in the foreground (do not fork)");
  fprintf(stderr, "\t%-29s %s\n", (const void *)"-d", (const void *)"Debug mode (implies -f)");
  fprintf(stderr, "\t%-29s %s\n", (const void *)"-s", (const void *)"Run in single-threaded mode");
}

// validate_config
// file s3b_config.c line 892
static signed int validate_config(void)
{
  struct s3backer_store *s3b;
  const signed int customBaseURL = (const signed int)(config$link1.http_io.baseURL != (const char *)(void *)0);
  const signed int customRegion = (const signed int)(config$link1.http_io.region != (const char *)(void *)0);
  signed long int auto_file_size;
  unsigned int auto_block_size;
  unsigned long int value;
  const char *s;
  char blockSizeBuf[64l];
  char fileSizeBuf[64l];
  struct stat sb;
  char urlbuf[512l];
  signed int i;
  signed int r;
  if(config$link1.http_io.ec2iam_role == ((const char *)NULL) && config$link1.accessFile == ((const char *)NULL))
  {
    const char *home;
    home=getenv("HOME");
    char buf[4096l];
    if(!(home == ((const char *)NULL)))
    {
      snprintf(buf, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", home, (const void *)".s3backer_passwd");
      config$link1.accessFile=strdup(buf);
      if(config$link1.accessFile == ((const char *)NULL))
        err(1, "strdup");

    }

  }

  if(config$link1.fuse_ops.file_mode == -1)
    config$link1.fuse_ops.file_mode = config$link1.fuse_ops.read_only != 0 ? 0400 : 0600;

  if(config$link1.http_io.accessId == ((char *)NULL) && !(config$link1.accessFile == ((const char *)NULL)))
    search_access_for(config$link1.accessFile, (const char *)(void *)0, &config$link1.http_io.accessId, (char **)(void *)0);

  if(!(config$link1.http_io.accessId == ((char *)NULL)))
  {
    if((signed int)*config$link1.http_io.accessId == 0)
      config$link1.http_io.accessId = (char *)(void *)0;

  }

  if(config$link1.fuse_ops.read_only == 0 && config$link1.http_io.accessId == ((char *)NULL) && config$link1.http_io.ec2iam_role == ((const char *)NULL) && customBaseURL == 0)
  {
    warnx("warning: no `accessId' specified; only read operations will succeed");
    warnx("you can eliminate this warning by providing the `--readOnly' flag");
  }

  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$4;
  char *return_value_strchr$3;
  _Bool tmp_if_expr$8;
  signed int return_value_strcmp$7;
  signed int return_value_strncmp$9;
  _Bool tmp_if_expr$11;
  signed int return_value_strncmp$12;
  _Bool tmp_if_expr$19;
  signed int return_value_toupper$21;
  _Bool tmp_if_expr$23;
  unsigned long int return_value_strlen$24;
  const char *why;
  signed int config_block_size;
  signed int *return_value___errno_location$30;
  struct s3backer_store *tmp_if_expr$35;
  struct s3backer_store *return_value_test_io_create$33;
  struct s3backer_store *return_value_http_io_create$34;
  char *return_value_strerror$37;
  if(config$link1.http_io.accessId == ((char *)NULL) && !(config$link1.http_io.accessKey == ((char *)NULL)))
  {
    warnx("an `accessKey' was specified but no `accessId' was specified");
    return -1;
  }

  else
    if(!(config$link1.http_io.accessId == ((char *)NULL)))
    {
      if(config$link1.http_io.accessKey == ((char *)NULL) && !(config$link1.accessFile == ((const char *)NULL)))
        search_access_for(config$link1.accessFile, config$link1.http_io.accessId, (char **)(void *)0, &config$link1.http_io.accessKey);

      if(!(config$link1.http_io.accessKey == ((char *)NULL)))
        goto __CPROVER_DUMP_L9;

      warnx("no `accessKey' specified");
      return -1;
    }

    else
    {

    __CPROVER_DUMP_L9:
      ;
      if(!(config$link1.http_io.accessId == ((char *)NULL)) && !(config$link1.http_io.ec2iam_role == ((const char *)NULL)))
      {
        warnx("an `accessKey' must not be specified when an `accessEC2IAM' role is specified");
        return -1;
      }

      else
      {
        i = 0;
        for( ; !((unsigned long int)i >= 2ul); i = i + 1)
        {
          signed int return_value_strcmp$1;
          return_value_strcmp$1=strcmp(config$link1.http_io.authVersion, s3_auth_types[(signed long int)i]);
          if(return_value_strcmp$1 == 0)
            break;

        }
        if((unsigned long int)i == 2ul)
        {
          warnx("illegal authentication version `%s'", config$link1.http_io.authVersion);
          return -1;
        }

        else
        {
          if(config$link1.test == 0)
          {
            if(config$link1.http_io.bucket == ((const char *)NULL))
            {
              warnx("no S3 bucket specified");
              return -1;
            }

            if((signed int)*config$link1.http_io.bucket == 0)
              tmp_if_expr$2 = (_Bool)1;

            else
              tmp_if_expr$2 = (signed int)*config$link1.http_io.bucket == 47 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$2)
              tmp_if_expr$4 = (_Bool)1;

            else
            {
              return_value_strchr$3=strchr(config$link1.http_io.bucket, 47);
              tmp_if_expr$4 = return_value_strchr$3 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr$4)
            {
              warnx("invalid S3 bucket `%s'", config$link1.http_io.bucket);
              return -1;
            }

          }

          else
          {
            if(config$link1.http_io.bucket == ((const char *)NULL))
            {
              warnx("no test directory specified");
              return -1;
            }

            signed int return_value_stat$5;
            return_value_stat$5=stat(config$link1.http_io.bucket, &sb);
            if(return_value_stat$5 == -1)
            {
              warn("%s", config$link1.http_io.bucket);
              return -1;
            }

            if(!((61440u & sb.st_mode) == 16384u))
            {
              signed int *return_value___errno_location$6;
              return_value___errno_location$6=__errno_location();
              *return_value___errno_location$6 = 20;
              warn("%s", config$link1.http_io.bucket);
              return -1;
            }

          }
          if(config$link1.http_io.region == ((const char *)NULL))
            config$link1.http_io.region = "us-east-1";

          if(!(customRegion == 0))
            config$link1.http_io.vhost = 1;

          if(config$link1.http_io.baseURL == ((const char *)NULL))
          {
            if(!(customRegion == 0))
            {
              return_value_strcmp$7=strcmp(config$link1.http_io.region, "us-east-1");
              tmp_if_expr$8 = return_value_strcmp$7 != 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr$8 = (_Bool)0;
            if(tmp_if_expr$8)
              snprintf(urlbuf, sizeof(char [512l]) /*512ul*/ , "http%s://s3-%s.%s/", config$link1.ssl != 0 ? "s" : "", config$link1.http_io.region, (const void *)"amazonaws.com");

            else
              snprintf(urlbuf, sizeof(char [512l]) /*512ul*/ , "http%s://s3.%s/", config$link1.ssl != 0 ? "s" : "", (const void *)"amazonaws.com");
            config$link1.http_io.baseURL=strdup(urlbuf);
            if(config$link1.http_io.baseURL == ((const char *)NULL))
            {
              warn("malloc");
              return -1;
            }

          }

          s = (const char *)(void *)0;
          signed int return_value_strncmp$10;
          return_value_strncmp$10=strncmp(config$link1.http_io.baseURL, "http://", (unsigned long int)7);
          if(return_value_strncmp$10 == 0)
            s = config$link1.http_io.baseURL + (signed long int)7;

          else
          {
            return_value_strncmp$9=strncmp(config$link1.http_io.baseURL, "https://", (unsigned long int)8);
            if(return_value_strncmp$9 == 0)
              s = config$link1.http_io.baseURL + (signed long int)8;

          }
          if(!(s == ((const char *)NULL)))
          {
            if((signed int)*s == 47)
              tmp_if_expr$11 = (_Bool)1;

            else
              tmp_if_expr$11 = (signed int)*s == 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr$11)
              s = (const char *)(void *)0;

          }

          if(!(s == ((const char *)NULL)))
          {
            s=strrchr(s, 47);
            if(s == ((const char *)NULL))
            {
              warnx("base URL must end with a '/'");
              s = (const char *)(void *)0;
            }

          }

          if(!(s == ((const char *)NULL)))
          {
            if(!((signed int)s[1l] == 0))
            {
              warnx("base URL must end with a '/' not '%c'", s[(signed long int)1]);
              s = (const char *)(void *)0;
            }

          }

          if(s == ((const char *)NULL))
          {
            warnx("invalid base URL `%s'", config$link1.http_io.baseURL);
            return -1;
          }

          else
            if(!(config$link1.ssl == 0) && !(customBaseURL == 0))
            {
              return_value_strncmp$12=strncmp(config$link1.http_io.baseURL, "https", (unsigned long int)5);
              if(return_value_strncmp$12 == 0)
                goto __CPROVER_DUMP_L41;

              warnx("non-SSL `--baseURL' conflicts with `--ssl'");
              return -1;
            }

            else
            {

            __CPROVER_DUMP_L41:
              ;
              if(!(config$link1.http_io.vhost == 0))
              {
                unsigned long int buflen;
                signed int schemelen;
                char *validate_config$$1$$16$$buf;
                char *return_value_strchr$13;
                return_value_strchr$13=strchr(config$link1.http_io.baseURL, 58);
                schemelen = (signed int)((return_value_strchr$13 - config$link1.http_io.baseURL) + (signed long int)3);
                unsigned long int return_value_strlen$14;
                return_value_strlen$14=strlen(config$link1.http_io.bucket);
                unsigned long int return_value_strlen$15;
                return_value_strlen$15=strlen(config$link1.http_io.baseURL);
                buflen = return_value_strlen$14 + (unsigned long int)1 + return_value_strlen$15 + (unsigned long int)1;
                void *return_value_malloc$16;
                return_value_malloc$16=malloc(buflen);
                validate_config$$1$$16$$buf = (char *)return_value_malloc$16;
                if(validate_config$$1$$16$$buf == ((char *)NULL))
                  err(1, "malloc(%u)", (unsigned int)buflen);

                snprintf(validate_config$$1$$16$$buf, buflen, "%.*s%s.%s", schemelen, config$link1.http_io.baseURL, config$link1.http_io.bucket, config$link1.http_io.baseURL + (signed long int)schemelen);
                config$link1.http_io.baseURL = validate_config$$1$$16$$buf;
              }

              i = 0;
              for( ; !((unsigned long int)i >= 4ul); i = i + 1)
              {
                signed int return_value_strcmp$17;
                return_value_strcmp$17=strcmp(config$link1.http_io.accessType, s3_acls[(signed long int)i]);
                if(return_value_strcmp$17 == 0)
                  break;

              }
              if((unsigned long int)i == 4ul)
              {
                warnx("illegal access type `%s'", config$link1.http_io.accessType);
                return -1;
              }

              else
              {
                char *return_value_strchr$18;
                return_value_strchr$18=strchr(config$link1.fuse_ops.filename, 47);
                if(!(return_value_strchr$18 == ((char *)NULL)))
                  tmp_if_expr$19 = (_Bool)1;

                else
                  tmp_if_expr$19 = (signed int)*config$link1.fuse_ops.filename == 0 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr$19)
                {
                  warnx("illegal filename `%s'", config$link1.fuse_ops.filename);
                  return -1;
                }

                else
                {
                  char *return_value_strchr$20;
                  return_value_strchr$20=strchr(config$link1.fuse_ops.stats_filename, 47);
                  if(!(return_value_strchr$20 == ((char *)NULL)))
                  {
                    warnx("illegal stats filename `%s'", config$link1.fuse_ops.stats_filename);
                    return -1;
                  }

                  else
                  {
                    if(config$link1.http_io.encryption == ((const char *)NULL) && !(config$link1.encrypt == 0))
                      config$link1.http_io.encryption=strdup("AES-128-CBC");

                    if(!(config$link1.http_io.encryption == ((const char *)NULL)))
                    {
                      char *t;
                      t=strdup(config$link1.http_io.encryption);
                      if(t == ((char *)NULL))
                        err(1, "strdup()");

                      i = 0;
                      for( ; !((signed int)t[(signed long int)i] == 0); i = i + 1)
                      {
                        return_value_toupper$21=toupper((signed int)t[(signed long int)i]);
                        t[(signed long int)i] = (char)return_value_toupper$21;
                      }
                      config$link1.http_io.encryption = t;
                    }

                    if(!(config$link1.http_io.encryption == ((const char *)NULL)))
                    {
                      char pwbuf[1024l];
                      struct _IO_FILE *fp;
                      if(!(config$link1.http_io.password == ((const char *)NULL)) && !(config$link1.password_file == ((const char *)NULL)))
                      {
                        warnx("specify only one of `--password' or `--passwordFile'");
                        return -1;
                      }

                      if(config$link1.http_io.password == ((const char *)NULL) && config$link1.password_file == ((const char *)NULL))
                      {
                        s=getpass("Password: ");
                        if(s == ((const char *)NULL))
                          err(1, "getpass()");

                      }

                      if(!(config$link1.password_file == ((const char *)NULL)))
                      {
                        fp=fopen(config$link1.password_file, "r");
                        if(fp == ((struct _IO_FILE *)NULL))
                        {
                          warn("can't open encryption key file `%s'", config$link1.password_file);
                          return -1;
                        }

                        char *return_value_fgets$22;
                        return_value_fgets$22=fgets(pwbuf, (signed int)sizeof(char [1024l]) /*1024ul*/ , fp);
                        if(return_value_fgets$22 == ((char *)NULL))
                          tmp_if_expr$23 = (_Bool)1;

                        else
                          tmp_if_expr$23 = (signed int)pwbuf[0l] == 0 ? (_Bool)1 : (_Bool)0;
                        if(tmp_if_expr$23)
                        {
                          warnx("can't read encryption key from file `%s'", config$link1.password_file);
                          fclose(fp);
                          return -1;
                        }

                        unsigned long int return_value_strlen$25;
                        return_value_strlen$25=strlen(pwbuf);
                        if((signed int)pwbuf[-1l + (signed long int)return_value_strlen$25] == 10)
                        {
                          return_value_strlen$24=strlen(pwbuf);
                          pwbuf[(signed long int)(return_value_strlen$24 - (unsigned long int)1)] = (char)0;
                        }

                        fclose(fp);
                        s = pwbuf;
                      }

                      if(config$link1.http_io.password == ((const char *)NULL))
                      {
                        config$link1.http_io.password=strdup(s);
                        if(config$link1.http_io.password == ((const char *)NULL))
                          err(1, "strdup()");

                      }

                      if(config$link1.http_io.key_length >= 65u)
                      {
                        warnx("`--keyLength' value must be positive and at most %u", 64);
                        return -1;
                      }

                    }

                    else
                    {
                      if(!(config$link1.http_io.password == ((const char *)NULL)))
                        warnx("unexpected flag `%s' (`--encrypt' was not specified)", (const void *)"--password");

                      else
                        if(!(config$link1.password_file == ((const char *)NULL)))
                          warnx("unexpected flag `%s' (`--encrypt' was not specified)", (const void *)"--passwordFile");

                      if(!(config$link1.http_io.key_length == 0u))
                        warnx("unexpected flag `%s' (`--encrypt' was not specified)", (const void *)"--keyLength");

                    }
                    if(config$link1.http_io.compress == 0 && !(config$link1.http_io.encryption == ((const char *)NULL)))
                      config$link1.http_io.compress = -1;

                    if(config$link1.http_io.compress == 0 || config$link1.http_io.compress == -1)
                      goto __CPROVER_DUMP_L73;

                    if(config$link1.http_io.compress >= 10 || !(config$link1.http_io.compress >= 1))
                    {
                      warnx("illegal compression level `%d'", config$link1.http_io.compress);
                      return -1;
                    }

                    else
                    {

                    __CPROVER_DUMP_L73:
                      ;
                      if(!(config$link1.fuse_ops.read_only == 0))
                      {
                        config$link1.ec_protect.cache_size = (unsigned int)0;
                        config$link1.ec_protect.cache_time = (unsigned int)0;
                        config$link1.ec_protect.min_write_delay = (unsigned int)0;
                      }

                      if(config$link1.ec_protect.cache_size == 0u && config$link1.ec_protect.cache_time >= 1u)
                      {
                        warnx("`md5CacheTime' must zero when MD5 cache is disabled");
                        return -1;
                      }

                      else
                        if(config$link1.ec_protect.cache_size == 0u && config$link1.ec_protect.min_write_delay >= 1u)
                        {
                          warnx("`minWriteDelay' must zero when MD5 cache is disabled");
                          return -1;
                        }

                        else
                          if(config$link1.ec_protect.cache_time >= 1u && !(config$link1.ec_protect.cache_time >= config$link1.ec_protect.min_write_delay))
                          {
                            warnx("`md5CacheTime' must be at least `minWriteDelay'");
                            return -1;
                          }

                          else
                            if(!(config$link1.http_io.max_retry_pause >= config$link1.http_io.initial_retry_pause))
                            {
                              warnx("`maxRetryPause' must be at least `initialRetryPause'");
                              return -1;
                            }

                            else
                            {
                              if(!(config$link1.block_size_str == ((const char *)NULL)))
                              {
                                signed int return_value_parse_size_string$26;
                                return_value_parse_size_string$26=parse_size_string(config$link1.block_size_str, &value);
                                if(return_value_parse_size_string$26 == -1 || value == 0ul)
                                {
                                  warnx("invalid block size `%s'", config$link1.block_size_str);
                                  return -1;
                                }

                                if(!((unsigned long int)(unsigned int)value == value))
                                {
                                  warnx("block size `%s' is too big", config$link1.block_size_str);
                                  return -1;
                                }

                                config$link1.block_size = (unsigned int)value;
                              }

                              if(!(config$link1.file_size_str == ((const char *)NULL)))
                              {
                                signed int return_value_parse_size_string$27;
                                return_value_parse_size_string$27=parse_size_string(config$link1.file_size_str, &value);
                                if(return_value_parse_size_string$27 == -1 || value == 0ul)
                                {
                                  warnx("invalid file size `%s'", config$link1.block_size_str);
                                  return -1;
                                }

                                config$link1.file_size = (signed long int)value;
                              }

                              i = 0;
                              for( ; !(i >= 2); i = i + 1)
                              {
                                if(!(config$link1.max_speed_str[(signed long int)i] == ((const char *)NULL)))
                                {
                                  signed int return_value_parse_size_string$28;
                                  return_value_parse_size_string$28=parse_size_string(config$link1.max_speed_str[(signed long int)i], &value);
                                  if(return_value_parse_size_string$28 == -1 || value == 0ul)
                                  {
                                    warnx("invalid max %s speed `%s'", upload_download_names[(signed long int)i], config$link1.max_speed_str[(signed long int)i]);
                                    return -1;
                                  }

                                  if(!((unsigned long int)(signed long int)(value / 8ul) == value / 8ul))
                                  {
                                    warnx("max %s speed `%s' is too big", upload_download_names[(signed long int)i], config$link1.max_speed_str[(signed long int)i]);
                                    return -1;
                                  }

                                  config$link1.http_io.max_speed[(signed long int)i] = value;
                                }

                                if(!(config$link1.http_io.max_speed[(signed long int)i] == 0ul))
                                {
                                  if((unsigned long int)config$link1.block_size / (config$link1.http_io.max_speed[(signed long int)i] / 8ul) >= (unsigned long int)config$link1.http_io.timeout)
                                  {
                                    warnx("configured timeout of %us is too short for block size of %u bytes and max %s speed %s bps", config$link1.http_io.timeout, config$link1.block_size, upload_download_names[(signed long int)i], config$link1.max_speed_str[(signed long int)i]);
                                    return -1;
                                  }

                                }

                              }
                              if(config$link1.block_cache.cache_size >= 1u && !(config$link1.block_cache.num_threads >= 1u))
                              {
                                warnx("invalid block cache thread pool size %u", config$link1.block_cache.num_threads);
                                return -1;
                              }

                              else
                                if(config$link1.block_cache.write_delay >= 1u && !(config$link1.block_cache.synchronous == 0u))
                                {
                                  warnx("`--blockCacheSync' requires setting `--blockCacheWriteDelay=0'");
                                  return -1;
                                }

                                else
                                {
                                  if(config$link1.block_cache.cache_size >= 1u && !(config$link1.block_cache.cache_file == ((const char *)NULL)))
                                  {
                                    signed int bs_bits;
                                    signed int return_value_ffs$29;
                                    return_value_ffs$29=ffs((signed int)config$link1.block_size);
                                    bs_bits = return_value_ffs$29 - 1;
                                    signed int cs_bits;
                                    cs_bits=ffs((signed int)config$link1.block_cache.cache_size);
                                    if((unsigned long int)(bs_bits + cs_bits) >= sizeof(signed long int) * 7 + 7 /*63ul*/ )
                                    {
                                      warnx("the block cache is too big to fit within a single file (%u blocks x %u bytes)", config$link1.block_cache.cache_size, config$link1.block_size);
                                      return -1;
                                    }

                                  }

                                  if(!(config$link1.erase == 0) || !(config$link1.reset == 0))
                                  {
                                    if(!(config$link1.mount == ((const char *)NULL)))
                                    {
                                      warnx("no mount point should be specified with `--erase' or `--reset-mounted-flag'");
                                      return -1;
                                    }

                                  }

                                  else
                                    if(config$link1.mount == ((const char *)NULL))
                                    {
                                      warnx("no mount point specified");
                                      return -1;
                                    }

                                  if(!(config$link1.test == 0))
                                    snprintf(config$link1.description, sizeof(char [768l]) /*768ul*/ , "%s%s/%s", (const void *)"file://", config$link1.http_io.bucket, config$link1.http_io.prefix);

                                  else
                                    if(!(config$link1.http_io.vhost == 0))
                                      snprintf(config$link1.description, sizeof(char [768l]) /*768ul*/ , "%s%s", config$link1.http_io.baseURL, config$link1.http_io.prefix);

                                    else
                                      snprintf(config$link1.description, sizeof(char [768l]) /*768ul*/ , "%s%s/%s", config$link1.http_io.baseURL, config$link1.http_io.bucket, config$link1.http_io.prefix);
                                  if(!(config$link1.test == 0))
                                    config$link1.no_auto_detect = 1;

                                  if(!(config$link1.no_auto_detect == 0))
                                    r = 2;

                                  else
                                  {
                                    config$link1.http_io.debug = config$link1.debug;
                                    config$link1.http_io.quiet = config$link1.quiet;
                                    config$link1.http_io.log = config$link1.log;
                                    s3b=http_io_create(&config$link1.http_io);
                                    if(s3b == ((struct s3backer_store *)NULL))
                                      err(1, "http_io_create");

                                    if(config$link1.quiet == 0)
                                      warnx("auto-detecting block size and total file size...");

                                    r=s3b->meta_data(s3b, &auto_file_size, &auto_block_size);
                                    s3b->destroy(s3b);
                                  }
                                  switch(r)
                                  {
                                    case 0:
                                    {
                                      unparse_size_string(blockSizeBuf, sizeof(char [64l]) /*64ul*/ , (unsigned long int)auto_block_size);
                                      unparse_size_string(fileSizeBuf, sizeof(char [64l]) /*64ul*/ , (unsigned long int)auto_file_size);
                                      if(config$link1.quiet == 0)
                                        warnx("auto-detected block size=%s and total size=%s", (const void *)blockSizeBuf, (const void *)fileSizeBuf);

                                      if(config$link1.block_size == 0u)
                                        config$link1.block_size = auto_block_size;

                                      else
                                        if(!(auto_block_size == config$link1.block_size))
                                        {
                                          char validate_config$$1$$41$$1$$buf[64l];
                                          unparse_size_string(validate_config$$1$$41$$1$$buf, sizeof(char [64l]) /*64ul*/ , (unsigned long int)config$link1.block_size);
                                          if(!(config$link1.force == 0))
                                          {
                                            if(config$link1.quiet == 0)
                                              warnx("warning: configured block size %s != filesystem block size %s,\nbut you said `--force' so I'll proceed anyway even though your data will\nprobably not read back correctly.", (const void *)validate_config$$1$$41$$1$$buf, (const void *)blockSizeBuf);

                                          }

                                          else
                                            errx(1, "error: configured block size %s != filesystem block size %s", (const void *)validate_config$$1$$41$$1$$buf, (const void *)blockSizeBuf);
                                        }

                                      if(config$link1.file_size == 0l)
                                        config$link1.file_size = auto_file_size;

                                      else
                                        if(!(auto_file_size == config$link1.file_size))
                                        {
                                          char validate_config$$1$$41$$2$$buf[64l];
                                          unparse_size_string(validate_config$$1$$41$$2$$buf, sizeof(char [64l]) /*64ul*/ , (unsigned long int)config$link1.file_size);
                                          if(!(config$link1.force == 0))
                                          {
                                            if(config$link1.quiet == 0)
                                              warnx("warning: configured file size %s != filesystem file size %s,\nbut you said `--force' so I'll proceed anyway even though your data will\nprobably not read back correctly.", (const void *)validate_config$$1$$41$$2$$buf, (const void *)fileSizeBuf);

                                          }

                                          else
                                            errx(1, "error: configured file size %s != filesystem file size %s", (const void *)validate_config$$1$$41$$2$$buf, (const void *)fileSizeBuf);
                                        }

                                      break;
                                    }
                                    case 2:
                                    {
                                      why = config$link1.no_auto_detect != 0 ? "disabled" : "failed";
                                      config_block_size = (signed int)config$link1.block_size;
                                      if(config$link1.file_size == 0l)
                                        errx(1, "error: auto-detection of filesystem size %s; please specify `--size'", why);

                                      if(config$link1.block_size == 0u)
                                        config$link1.block_size = (unsigned int)4096;

                                      unparse_size_string(blockSizeBuf, sizeof(char [64l]) /*64ul*/ , (unsigned long int)config$link1.block_size);
                                      unparse_size_string(fileSizeBuf, sizeof(char [64l]) /*64ul*/ , (unsigned long int)config$link1.file_size);
                                      if(config$link1.quiet == 0)
                                        warnx("auto-detection %s; using %s block size %s and file size %s", why, config_block_size == 0 ? "default" : "configured", (const void *)blockSizeBuf, (const void *)fileSizeBuf);

                                      break;
                                    }
                                    default:
                                    {
                                      return_value___errno_location$30=__errno_location();
                                      *return_value___errno_location$30 = r;
                                      err(1, "can't read data store meta-data");
                                    }
                                  }
                                  if(config$link1.erase == 0 && config$link1.reset == 0 && config$link1.test == 0)
                                  {
                                    signed int mounted;
                                    config$link1.http_io.debug = config$link1.debug;
                                    config$link1.http_io.quiet = config$link1.quiet;
                                    config$link1.http_io.log = config$link1.log;
                                    s3b=http_io_create(&config$link1.http_io);
                                    if(s3b == ((struct s3backer_store *)NULL))
                                      err(1, "http_io_create");

                                    r=s3b->set_mounted(s3b, &mounted, -1);
                                    s3b->destroy(s3b);
                                    if(!(r == 0))
                                    {
                                      signed int *return_value___errno_location$31;
                                      return_value___errno_location$31=__errno_location();
                                      *return_value___errno_location$31 = r;
                                      err(1, "error reading mounted flag");
                                    }

                                    if(!(mounted == 0))
                                    {
                                      if(config$link1.force == 0)
                                        errx(1, "error: %s appears to be already mounted", (const void *)config$link1.description);

                                      if(config$link1.quiet == 0)
                                        warnx("warning: filesystem appears already mounted but you said `--force'\n so I'll proceed anyway even though your data may get corrupted.\n");

                                    }

                                  }

                                  signed int return_value_ffs$32;
                                  return_value_ffs$32=ffs((signed int)config$link1.block_size);
                                  if(!(config$link1.block_size == (unsigned int)(1 << return_value_ffs$32 + -1)))
                                  {
                                    warnx("block size must be a power of 2");
                                    return -1;
                                  }

                                  else
                                    if(!(config$link1.file_size % (signed long int)config$link1.block_size == 0l))
                                    {
                                      warnx("file size must be a multiple of block size");
                                      return -1;
                                    }

                                    else
                                    {
                                      config$link1.num_blocks = config$link1.file_size / (signed long int)config$link1.block_size;
                                      if(config$link1.num_blocks >= 4294967297l)
                                      {
                                        warnx("more than 2^%d blocks: decrease file size or increase block size", (signed int)(sizeof(unsigned int) /*4ul*/  * (unsigned long int)8));
                                        return -1;
                                      }

                                      else
                                        if(!(config$link1.http_io.encryption == ((const char *)NULL)) && !(config$link1.block_size % 16u == 0u))
                                        {
                                          warnx("block size must be at least %u when encryption is enabled", 16);
                                          return -1;
                                        }

                                        else
                                          if(config$link1.ec_protect.cache_time == 0u && config$link1.ec_protect.cache_size >= 1u && !((signed long int)config$link1.ec_protect.cache_size >= config$link1.num_blocks))
                                          {
                                            warnx("`md5CacheTime' is infinite but `md5CacheSize' is less than the number of blocks, so eventual deadlock will result");
                                            return -1;
                                          }

                                          else
                                          {
                                            if(!(config$link1.num_blocks >= (signed long int)config$link1.ec_protect.cache_size))
                                            {
                                              warnx("MD5 cache size (%ju) is greater that the total number of blocks (%ju); automatically reducing", (unsigned long int)config$link1.ec_protect.cache_size, (unsigned long int)config$link1.num_blocks);
                                              config$link1.ec_protect.cache_size = (unsigned int)config$link1.num_blocks;
                                            }

                                            if(!(config$link1.num_blocks >= (signed long int)config$link1.block_cache.cache_size))
                                            {
                                              warnx("block cache size (%ju) is greater that the total number of blocks (%ju); automatically reducing", (unsigned long int)config$link1.block_cache.cache_size, (unsigned long int)config$link1.num_blocks);
                                              config$link1.block_cache.cache_size = (unsigned int)config$link1.num_blocks;
                                            }

                                            config$link1.block_cache.block_size = config$link1.block_size;
                                            config$link1.block_cache.log = config$link1.log;
                                            config$link1.http_io.debug = config$link1.debug;
                                            config$link1.http_io.quiet = config$link1.quiet;
                                            config$link1.http_io.block_size = config$link1.block_size;
                                            config$link1.http_io.num_blocks = config$link1.num_blocks;
                                            config$link1.http_io.log = config$link1.log;
                                            config$link1.ec_protect.block_size = config$link1.block_size;
                                            config$link1.ec_protect.log = config$link1.log;
                                            config$link1.fuse_ops.block_size = config$link1.block_size;
                                            config$link1.fuse_ops.num_blocks = config$link1.num_blocks;
                                            config$link1.fuse_ops.log = config$link1.log;
                                            if(!(config$link1.erase == 0) || !(config$link1.reset == 0))
                                              config$link1.list_blocks = 0;

                                            if(!(config$link1.list_blocks == 0))
                                            {
                                              struct s3backer_store *temp_store;
                                              struct list_blocks lb;
                                              unsigned long int nwords;
                                              if(config$link1.quiet == 0)
                                              {
                                                fprintf(stderr, "s3backer: listing non-zero blocks...");
                                                fflush(stderr);
                                              }

                                              if(!(config$link1.test == 0))
                                              {
                                                return_value_test_io_create$33=test_io_create(&config$link1.http_io);
                                                tmp_if_expr$35 = return_value_test_io_create$33;
                                              }

                                              else
                                              {
                                                return_value_http_io_create$34=http_io_create(&config$link1.http_io);
                                                tmp_if_expr$35 = return_value_http_io_create$34;
                                              }
                                              temp_store = tmp_if_expr$35;
                                              if(temp_store == ((struct s3backer_store *)NULL))
                                                err(1, config$link1.test != 0 ? "test_io_create" : "http_io_create");

                                              nwords = (((unsigned long int)config$link1.num_blocks + sizeof(unsigned int) /*4ul*/  * (unsigned long int)8) - (unsigned long int)1) / (sizeof(unsigned int) /*4ul*/  * (unsigned long int)8);
                                              void *return_value_calloc$36;
                                              return_value_calloc$36=calloc(nwords, sizeof(unsigned int) /*4ul*/ );
                                              lb.bitmap = (unsigned int *)return_value_calloc$36;
                                              if(lb.bitmap == ((unsigned int *)NULL))
                                                err(1, "calloc");

                                              lb.print_dots = (signed int)!(config$link1.quiet != 0);
                                              lb.count = (unsigned long int)0;
                                              r=temp_store->list_blocks(temp_store, list_blocks_callback, (void *)&lb);
                                              if(!(r == 0))
                                              {
                                                return_value_strerror$37=strerror(r);
                                                errx(1, "can't list blocks: %s", return_value_strerror$37);
                                              }

                                              temp_store->destroy(temp_store);
                                              config$link1.http_io.nonzero_bitmap = lb.bitmap;
                                              if(config$link1.quiet == 0)
                                              {
                                                fprintf(stderr, "done\n");
                                                warnx("found %ju non-zero blocks", lb.count);
                                              }

                                            }

                                            return 0;
                                          }
                                    }
                                }
                            }
                    }
                  }
                }
              }
            }
        }
      }
    }
}

