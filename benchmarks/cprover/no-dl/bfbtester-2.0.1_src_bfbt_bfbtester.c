// tag-#anon#ST[*{SYM#tag-_crash_report#}_SYM#tag-_crash_report#_'dle_next'||*{SYM#tag-_crash_report#}_SYM#tag-_crash_report#_'dle_prev'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'dle_access'||U32'dle_reader_count'||U32'dle_writer_count'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]#'dle_reader_wait'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]#'dle_writer_wait'|]
// file ../../src/include/datatypes.h line 39
struct anonymous_3;

// tag-#anon#ST[*{SYM#tag-_exec_entry#}_SYM#tag-_exec_entry#_'dle_next'||*{SYM#tag-_exec_entry#}_SYM#tag-_exec_entry#_'dle_prev'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'dle_access'||U32'dle_reader_count'||U32'dle_writer_count'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]#'dle_reader_wait'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]#'dle_writer_wait'|]
// file ../../src/include/datatypes.h line 61
struct anonymous_2;

// tag-#anon#ST[*{SYM#tag-_test_entry#}_SYM#tag-_test_entry#_'dle_next'||*{SYM#tag-_test_entry#}_SYM#tag-_test_entry#_'dle_prev'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'dle_access'||U32'dle_reader_count'||U32'dle_writer_count'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]#'dle_reader_wait'||SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]#'dle_writer_wait'|]
// file ../../src/include/datatypes.h line 82
struct anonymous_5;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_1;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_0;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_4;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_crash_report
// file ../../src/include/datatypes.h line 31
struct _crash_report;

// tag-_exec_entry
// file ../../src/include/datatypes.h line 51
struct _exec_entry;

// tag-_exec_entry_status
// file ../../src/include/datatypes.h line 42
enum _exec_entry_status { EXEC_ENTRY_STATUS_NOTHING=0, EXEC_ENTRY_STATUS_TEST=1, EXEC_ENTRY_STATUS_TESTED=2 };

// tag-_exec_status
// file exec.c line 47
enum _exec_status { EXEC_STATUS_DONE=0, EXEC_STATUS_STALE=1, EXEC_STATUS_GARBAGE=2, EXEC_STATUS_NOTDONE=3 };

// tag-_file_entry
// file tempfiles.c line 40
struct _file_entry;

// tag-_msg_type
// file ../../src/include/utils.h line 27
enum _msg_type { MSG_TYPE_ERROR_ABORT=0, MSG_TYPE_ERROR_WARN=1, MSG_TYPE_ERRNO_ABORT=2, MSG_TYPE_ERRNO_WARN=3, MSG_TYPE_MESSAGE=4, MSG_TYPE_DEBUG_L1=5, MSG_TYPE_DEBUG_L2=6 };

// tag-_tempfile_watch_request
// file tempfiles.c line 61
struct _tempfile_watch_request;

// tag-_test_entry
// file ../../src/include/datatypes.h line 66
struct _test_entry;

// tag-_thread_data
// file ../../src/include/datatypes.h line 85
struct _thread_data;

// tag-crashreport_slist_head
// file data_stuff.c line 222
struct crashreport_slist_head;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-exec_entry_head
// file data_stuff.c line 48
struct exec_entry_head;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-test_entry_head
// file data_stuff.c line 142
struct test_entry_head;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// AddOrUpdate
// file tempfiles.c line 199
static void AddOrUpdate(struct dirent *entry, struct timeval tm);
// CrashReport_add
// file data_stuff.c line 255
struct _crash_report * CrashReport_add(struct _test_entry *test_entry);
// CrashReport_destroy
// file data_stuff.c line 246
static void CrashReport_destroy(struct _crash_report *report);
// CrashReport_init
// file data_stuff.c line 234
static void CrashReport_init(struct _crash_report *report, struct _test_entry *test_entry);
// CrashReport_log
// file data_stuff.c line 275
void CrashReport_log(struct _crash_report *report);
// CrashReport_subtract
// file data_stuff.c line 267
void CrashReport_subtract(struct _crash_report *report);
// ExecEntry_add
// file ../../src/include/data_stuff.h line 27
struct _exec_entry * ExecEntry_add(char *name, struct stat *sb, enum _exec_entry_status status, signed int test_flags);
// ExecEntry_destroy
// file data_stuff.c line 72
static void ExecEntry_destroy(struct _exec_entry *entry);
// ExecEntry_findbyname
// file data_stuff.c line 118
struct _exec_entry * ExecEntry_findbyname(char *name);
// ExecEntry_getnext
// file ../../src/include/data_stuff.h line 37
struct _exec_entry * ExecEntry_getnext(struct _exec_entry **entry);
// ExecEntry_init
// file data_stuff.c line 60
static inline void ExecEntry_init(struct _exec_entry *entry, struct stat *sb, char *fullname, enum _exec_entry_status status, signed int test_flags);
// ExecEntry_isempty
// file ../../src/include/data_stuff.h line 46
signed int ExecEntry_isempty(void);
// ExecEntry_release
// file data_stuff.c line 129
void ExecEntry_release(struct _exec_entry *entry);
// ExecEntry_subtract
// file data_stuff.c line 103
void ExecEntry_subtract(struct _exec_entry *entry);
// TestEntry_create
// file data_stuff.c line 188
struct _test_entry * TestEntry_create(struct _exec_entry *parent, char **args, char **env);
// TestEntry_destroy
// file data_stuff.c line 177
void TestEntry_destroy(struct _test_entry *entry);
// TestEntry_getnext
// file data_stuff.c line 214
struct _test_entry * TestEntry_getnext(struct _test_entry **entry);
// TestEntry_init
// file data_stuff.c line 156
static inline void TestEntry_init(struct _test_entry *entry, struct _exec_entry *parent, char **args, char **env);
// TestEntry_insert
// file data_stuff.c line 199
void TestEntry_insert(struct _test_entry *entry);
// TestEntry_remove
// file data_stuff.c line 206
void TestEntry_remove(struct _test_entry *entry);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __bfbt_message
// file ../../src/include/utils.h line 44
void __bfbt_message(enum _msg_type type, char *function, signed int line, char *fmt, ...);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// _exit
// file /usr/include/unistd.h line 603
extern void _exit(signed int);
// _xcalloc
// file ../../src/include/utils.h line 73
static inline void * _xcalloc(unsigned long int number, unsigned long int size, char *function, signed int line);
// _xcalloc_link1
// file ../../src/include/utils.h line 73
static inline void * _xcalloc_link1(unsigned long int number_link1, unsigned long int size_link1, char *function_link1, signed int line_link1);
// _xcalloc_link2
// file ../../src/include/utils.h line 73
static inline void * _xcalloc_link2(unsigned long int number_link2, unsigned long int size_link2, char *function_link2, signed int line_link2);
// _xmalloc
// file ../../src/include/utils.h line 61
static inline void * _xmalloc(unsigned long int size, char *function, signed int line);
// _xmalloc_link1
// file ../../src/include/utils.h line 61
static inline void * _xmalloc_link1(unsigned long int size_link1, char *function_link1, signed int line_link1);
// _xmalloc_link2
// file ../../src/include/utils.h line 61
static inline void * _xmalloc_link2(unsigned long int size_link2, char *function_link2, signed int line_link2);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// addFile
// file tempfiles.c line 108
static void addFile(struct dirent *entry, struct timeval tm);
// add_exec
// file bfbtester.c line 186
static void add_exec(char *filename, enum _exec_entry_status status, signed int flags, char *rejects);
// args_to_str
// file ../../src/include/utils.h line 87
char * args_to_str(char **args);
// atoi
// file /usr/include/stdlib.h line 147
extern signed int atoi(const char *);
// breaker_cleanup
// file breaker.c line 213
static void breaker_cleanup(void *arg);
// breaker_execute_command
// file breaker.c line 41
static void breaker_execute_command(struct _exec_entry *exec_entry, char **args, char **env);
// breaker_run
// file breaker.c line 222
void * breaker_run(void *data);
// breaker_runtests
// file breaker.c line 179
static void breaker_runtests(struct _exec_entry *entry);
// breaker_start
// file ../../src/include/breaker.h line 27
void breaker_start(void);
// breaker_tempfile_createcb
// file breaker.c line 161
void breaker_tempfile_createcb(char *filename, struct stat *sb, void *data);
// breaker_tempfile_removecb
// file breaker.c line 170
void breaker_tempfile_removecb(char *filename, struct stat *sb, void *data);
// breaker_test_env
// file breaker.c line 130
static void breaker_test_env(struct _exec_entry *entry);
// breaker_test_multiplearg
// file breaker.c line 91
static void breaker_test_multiplearg(struct _exec_entry *entry);
// breaker_test_singlearg
// file breaker.c line 58
static void breaker_test_singlearg(struct _exec_entry *entry);
// breaker_wait
// file ../../src/include/breaker.h line 30
void breaker_wait(void);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// deleteFile
// file tempfiles.c line 192
static void deleteFile(struct _file_entry *entry);
// env_create
// file ../../src/include/utils.h line 93
char ** env_create(char **env);
// env_not_used
// file utils.c line 161
static inline signed int env_not_used(char **env, char *str);
// env_to_str
// file ../../src/include/utils.h line 90
char * env_to_str(char **env);
// exec_GetStatus
// file exec.c line 115
static enum _exec_status exec_GetStatus(struct _test_entry *entry);
// exec_kill
// file exec.c line 109
static void exec_kill(signed int pid);
// exec_poll
// file ../../src/include/exec.h line 29
void exec_poll(void);
// exec_process_close
// file exec.c line 139
static void exec_process_close(struct _test_entry *entry);
// execute_program
// file ../../src/include/exec.h line 26
signed int execute_program(struct _exec_entry *exec_entry, char **args, char **env);
// execve
// file /usr/include/unistd.h line 551
extern signed int execve(const char *, char * const *, char * const *);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// find_exec_in_path
// file ../../src/include/utils.h line 84
char * find_exec_in_path(char *name);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getopt
// file /usr/include/getopt.h line 150
extern signed int getopt(signed int, char * const *, const char *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// isNew
// file tempfiles.c line 84
static signed int isNew(struct dirent *entry);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// load_execs
// file bfbtester.c line 213
static void load_execs(char **av, enum _exec_entry_status status, signed int flags, char *rejects);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_cond_broadcast
// file /usr/include/pthread.h line 983
extern signed int pthread_cond_broadcast(union anonymous_0 *);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous_0 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_0 *, const union anonymous_1 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_0 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_0 *, union anonymous_4 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_4 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_4 *, const union anonymous_1 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_4 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_4 *);
// pthread_testcancel
// file /usr/include/pthread.h line 520
extern void pthread_testcancel(void);
// readdir_r
// file /usr/include/dirent.h line 183
extern signed int readdir_r(struct __dirstream *, struct dirent *, struct dirent ** restrict );
// removeFile
// file tempfiles.c line 167
static void removeFile(struct _file_entry *entry);
// rewinddir
// file /usr/include/dirent.h line 208
extern void rewinddir(struct __dirstream *);
// run_breaker
// file bfbtester.c line 289
static void run_breaker(void);
// setpgid
// file /usr/include/unistd.h line 646
extern signed int setpgid(signed int, signed int);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 129
extern char * strcpy(char *, const char *);
// strcspn
// file /usr/include/string.h line 284
extern unsigned long int strcspn(const char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncat
// file /usr/include/string.h line 140
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 262
extern char * strrchr(const char *, signed int);
// strsignal
// file /usr/include/string.h line 563
extern char * strsignal(signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtok_r
// file /usr/include/string.h line 358
extern char * strtok_r(char *, const char *, char ** restrict );
// tempfile_request_add
// file ../../src/include/tempfiles.h line 28
signed int tempfile_request_add(void (*create)(char *, struct stat *, void *), void (*remove)(char *, struct stat *, void *), void *cbdata);
// tempfile_request_add::create_object
//
void create_object(char *, struct stat *, void *);
// tempfile_request_add::remove_object
//
void remove_object(char *, struct stat *, void *);
// tempfile_request_shutdown
// file tempfiles.c line 249
static void tempfile_request_shutdown(void);
// tempfile_request_startup
// file tempfiles.c line 241
static void tempfile_request_startup(void);
// tempfile_request_subtract
// file ../../src/include/tempfiles.h line 31
signed int tempfile_request_subtract(void);
// tempfile_scandir
// file tempfiles.c line 209
static void tempfile_scandir(struct __dirstream *dir);
// tempfile_start
// file ../../src/include/tempfiles.h line 34
void tempfile_start(struct _thread_data *data);
// tempfile_watch
// file tempfiles.c line 257
static void * tempfile_watch(void *data);
// updateFile
// file tempfiles.c line 149
static void updateFile(struct dirent *entry, struct timeval tm);
// usage
// file bfbtester.c line 163
static void usage(char *progname);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_4
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

union anonymous_0
{
  // __data
  struct anonymous __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct anonymous_3
{
  // dle_next
  struct _crash_report *dle_next;
  // dle_prev
  struct _crash_report *dle_prev;
  // dle_access
  union anonymous_4 dle_access;
  // dle_reader_count
  unsigned int dle_reader_count;
  // dle_writer_count
  unsigned int dle_writer_count;
  // dle_reader_wait
  union anonymous_0 dle_reader_wait;
  // dle_writer_wait
  union anonymous_0 dle_writer_wait;
};

struct anonymous_2
{
  // dle_next
  struct _exec_entry *dle_next;
  // dle_prev
  struct _exec_entry *dle_prev;
  // dle_access
  union anonymous_4 dle_access;
  // dle_reader_count
  unsigned int dle_reader_count;
  // dle_writer_count
  unsigned int dle_writer_count;
  // dle_reader_wait
  union anonymous_0 dle_reader_wait;
  // dle_writer_wait
  union anonymous_0 dle_writer_wait;
};

struct anonymous_5
{
  // dle_next
  struct _test_entry *dle_next;
  // dle_prev
  struct _test_entry *dle_prev;
  // dle_access
  union anonymous_4 dle_access;
  // dle_reader_count
  unsigned int dle_reader_count;
  // dle_writer_count
  unsigned int dle_writer_count;
  // dle_reader_wait
  union anonymous_0 dle_reader_wait;
  // dle_writer_wait
  union anonymous_0 dle_writer_wait;
};

union anonymous_1
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _crash_report
{
  // progname
  char *progname;
  // args_str
  char *args_str;
  // env_str
  char *env_str;
  // signal
  signed int signal;
  // didCore
  signed int didCore;
  // link
  struct anonymous_3 link;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct _exec_entry
{
  // fullname
  char *fullname;
  // status
  enum _exec_entry_status status;
  // test_flags
  signed int test_flags;
  // filestat
  struct stat filestat;
  // testtime
  struct timeval testtime;
  // link
  struct anonymous_2 link;
};

struct _file_entry
{
  // filename
  char *filename;
  // tm
  struct timeval tm;
  // statd
  signed int statd;
  // fileno
  unsigned int fileno;
  // sb
  struct stat sb;
  // next
  struct _file_entry *next;
  // prev
  struct _file_entry *prev;
};

struct _tempfile_watch_request
{
  // mutex
  union anonymous_4 mutex;
  // cond
  union anonymous_0 cond;
  // count
  signed int count;
  // status
  signed int status;
  // create_cb
  void (*create_cb)(char *, struct stat *, void *);
  // remove_cb
  void (*remove_cb)(char *, struct stat *, void *);
  // cb_data
  void *cb_data;
};

struct _test_entry
{
  // pid
  signed int pid;
  // status
  signed int status;
  // progname
  char *progname;
  // args
  char **args;
  // args_str
  char *args_str;
  // env
  char **env;
  // env_str
  char *env_str;
  // env_flag
  signed int env_flag;
  // tm
  struct timeval tm;
  // link
  struct anonymous_5 link;
};

struct _thread_data
{
  // mut
  union anonymous_4 *mut;
  // run_thread
  unsigned long int run_thread;
  // poll_thread
  unsigned long int poll_thread;
  // tempfile_thread
  unsigned long int tempfile_thread;
  // current_execs
  signed int current_execs;
  // max_execs
  signed int max_execs;
};

struct crashreport_slist_head
{
  // dlh_first
  struct _crash_report *dlh_first;
  // dlh_access
  union anonymous_4 dlh_access;
  // dlh_ops
  union anonymous_4 dlh_ops;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

struct exec_entry_head
{
  // dlh_first
  struct _exec_entry *dlh_first;
  // dlh_access
  union anonymous_4 dlh_access;
  // dlh_ops
  union anonymous_4 dlh_ops;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct test_entry_head
{
  // dlh_first
  struct _test_entry *dlh_first;
  // dlh_access
  union anonymous_4 dlh_access;
  // dlh_ops
  union anonymous_4 dlh_ops;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};


// CrashReport_Head
// file data_stuff.c line 222
struct crashreport_slist_head CrashReport_Head;
// ExecEntry_Head
// file data_stuff.c line 48
struct exec_entry_head ExecEntry_Head;
// TestEntry_Head
// file data_stuff.c line 142
struct test_entry_head TestEntry_Head;
// args_options
// file ../../src/include/breaker_data.h line 26
const char *args_options[63l] = { "-0", "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-@", "-A", "-B", "-C", "-D", "-E", "-F", "-G", "-H", "-I", "-J", "-K", "-L", "-M", "-N", "-O", "-P", "-Q", "-R", "-S", "-T", "-U", "-V", "-W", "-X", "-Y", "-Z", "-a", "-b", "-c", "-d", "-e", "-f", "-g", "-h", "-i", "-j", "-k", "-l", "-m", "-n", "-o", "-p", "-q", "-r", "-s", "-t", "-u", "-v", "-w", "-x", "-y", "-z" };
// debug_level
// file bfbtester.c line 58
signed int debug_level;
// environ
// file data_stuff.c line 153
extern char **environ;
// envs
// file ../../src/include/breaker_data.h line 43
const char *envs[252l] = { "USER", "MAIL", "HOME", "ENV", "MORE", "TOP", "CVSROOT", "OLDPWD", "WMAKER_BIN_NAME", "PAGER", "RSTAR_NO_WARN", "OPTIND", "LOGNAME", "WINDOWID", "MAILHOST", "SHOPTYPE", "TERM", "BLOCKSIZE", "DISPLAY", "OPENSSL_CONF", "PWD", "TERMCAP", "EDITOR", "POSIXLY_CORRECT", "BC_ENV_ARGS", "BC_LINE_LENGTH", "GNUTARGET", "GENOCIDED", "COLUMNS", "EMULATION_ENVIRON", "TARGET_ENVIRON", "LD_RUN_PATH", "LD_LIBRARY_PATH", "TMPDIR", "KRB5_CONFIG", "TMP", "TEMP", "CVS_SERVER", "CVS_CLIENT_PORT", "CVS_CLIENT_LOG", "CVS_RSH", "IGNORE_ENV", "CVS_PASSFILE", "CVS_PASSWORD", "TMPDIR_ENV", "SCSI_MODES", "EDITOR1_ENV", "EDITOR2_ENV", "EDITOR3_ENV", "QUERY_STRINGCVSROOT_ENV", "CVSREAD_ENV", "CVSREADONLYFS_ENV", "CVS_OPTIONS", "CVSUMASK_ENV", "CVS_SERVER_SLEEP", "WRAPPER_ENV", "DIFF_OPTIONS", "DIFF", "GETARGMANDOC", "NAME, ENV_NAME", "LANG", "SUNPRO_DEPENDENCIES", "DEPENDENCIES_OUTPUT", "COLLECT_NO_DEMANGLE", "SSL_CIPHER", "COLLECT_GCC_OPTIONS", "COLLECT_GCC", "COMPILER_PATH", "LIBRARY_PATH", "TLINK_VERBOSE", "SHELL", "SSLEAY_CONF", "PATH", "HISTSIZE", "GDBHISTFILE", "PS2", "EMACS", "_POSIX_OPTION_ORDER", "TZ", "PATCH_GET", "AFSLIBPATH", "SIMPLE_BACKUP_SUFFIX", "PATCH_VERSION_CONTROL", "RMT", "VERSION_CONTROL", "INFOPATH", "INFO_PRINT_COMMAND", "LINES", "USERNAME", "AFS_SYSCALL", "HZ", "GREP_OPTIONS", "SYSTEM", "MANROFFSEQ", "KRBTKFILE", "MANSECT", "MANLOCALES", "MANPATH", "PATCH_INDEX_FIRST", "COMSPEC", "TAPE", "MODEMS", "MUSIC_CD", "CD_DRIVE", "DISC", "CDPLAY", "CHANGER_ENV_VAR", "LC_CTYPE", "LS_COLWIDTHS", "LC_TIME", "AWKPATH", "LOCALDEF", "DSTKEYPATH", "NET_ORDER", "HES_DOMAIN", "IRPD_HOST_ENV", "LOCALDOMAIN", "LCD_TYPE", "CVS_LOCAL_BRANCH_NUM", "PROFDIR", "UDICONF", "KERB_DBG", "GTAGSWARNING", "GTAGSDBPATH", "GTAGSROOT", "KRBCONFDIR", "GTAGSLIBPATH", "BROWSER", "GTAGSCONF", "GTAGSLABEL", "GROFF_COMMAND_PREFIX", "GROFF_FONT_PATH", "GROFF_TYPESETTER", "KRB4PRINCIPAL", "GROFF_TMPDIR_ENVVAR", "TMPDIR_ENVVAR", "REFER", "RANDFILE", "FONTPATH_ENV_VAR", "KRB5CCNAME", "BUFMOD_FIXED", "EL_SIZE", "ABCDE", "MOUSE_BUTTONS_123", "NCURSES_NO_PADDING", "BAUDRATE", "CC", "TERMINFO", "TERMINFO_DIRS", "FAITH_NS", "TERMPATH", "NCURSES_NO_SETBUF", "KEYBOARD", "HACKDIR", "LC_MESSAGES", "CSCOPE_DIRS", "NEXINIT", "EXINIT", "TTYPROMPT", "PERL_BADFREE", "PERL_DESTRUCT_LEVEL", "PERL5OPT", "PERL_DEBUG_MSTATS", "PERL5LIB", "PERLLIB", "YYDEBUG", "TERMCAP_COLORS", "PERL5DB", "LANGUAGE", "LC_ALL", "LC_COLLATE", "LC_NUMERIC", "PERL_BADLANG", "PERL_DL_NONLAZY", "HOSTALIASES", "GAI", "USE_UNICODE", "HACKPAGER", "MAGIC", "HACKOPTIONS", "INVENT", "VISUAL", "MAILREADER", "ROGUEOPTS", "WOTD", "SAILNAME", "LIBDIR", "DIALOGRC", "RCSLOCALID", "RCSINCEXC", "RCSINIT", "LDSO", "OBJFORMAT", "RES_OPTIONS", "NLSPATH", "REMOTE", "MALLOC_OPTIONS", "LIBC_R_DEBUG", "DEBUGTTY", "MAKE", "HTTP_PROXY", "FTP_TIMEOUT", "LD_BIND_NOW", "LD_DEBUG", "LD_PRELOAD", "LD_TRACE_LOADED_OBJECTS", "LD_TRACE_LOADED_OBJECTS_PROGNAME", "SYSINSTALL_DEBUG", "LD_TRACE_LOADED_OBJECTS_FMT1", "VINUM_DATEFORMAT", "LD_TRACE_LOADED_OBJECTS_FMT2", "VINUM_HISTORY", "PROM_E_BOOTED_DEV", "PROM_E_BOOTED_OSFLAGS", "PHONES", "PROM_E_BOOTED_FILE", "kernelname", "PROM_E_TTY_DEV", "rootdev", "currdev", "autoboot_delay", "bootfile", "DOS_KERNEL", "MINUSKVAR", "FTP_PASSWORD", "FTP_LOGIN", "FTP_PROXY", "HTTP_TIMEOUT", "HTTP_AUTH", "HTTP_PROXY_AUTH", "FINGER", "REPLYTO", "FTPSERVERPORT", "LOCATE_PATH", "MACHINE", "MACHINE_ARCH", "MAKEOBJDIRPREFIX", "MAKEOBJDIR", "MAKEFLAGS", "OBJFORMAT_PATH", "NLSPROVIDER", "V_TERMCAP", "PRINTER", "PACKAGESITE", "_TOP", "PKG_DBDIR", "PKG_ADD_BASE", "PKG_PATH", "PKG_TMPDIR", "CONNECT", "EL_EDITOR", "PW_SCAN_BIG_IDS" };
// fp_msg
// file bfbtester.c line 57
struct _IO_FILE *fp_msg = (struct _IO_FILE *)(void *)0;
// head
// file tempfiles.c line 77
static struct _file_entry *head = (struct _file_entry *)(void *)0;
// initialized
// file tempfiles.c line 74
static signed int initialized = (signed int)(1 == 0);
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// optind
// file /usr/include/getopt.h line 71
extern signed int optind;
// q
// file bfbtester.c line 55
struct _thread_data *q;
// request
// file tempfiles.c line 79
static struct _tempfile_watch_request request = { .mutex={ .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } }, .cond={ .__data={ .__lock=0, .__futex=(unsigned int)0, .__total_seq=(unsigned long long int)0, .__wakeup_seq=(unsigned long long int)0,
    .__woken_seq=(unsigned long long int)0,
    .__mutex=(void *)0,
    .__nwaiters=(unsigned int)0, .__broadcast_seq=(unsigned int)0 } },
    .count=0,
    .status=0, .create_cb=(void (*)(char *, struct stat *, void *))(void *)0, .remove_cb=(void (*)(char *, struct stat *, void *))(void *)0,
    .cb_data=(void *)0 };
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// tail
// file tempfiles.c line 78
static struct _file_entry *tail = (struct _file_entry *)(void *)0;

// AddOrUpdate
// file tempfiles.c line 199
static void AddOrUpdate(struct dirent *entry, struct timeval tm)
{
  signed int return_value_isNew_1;
  return_value_isNew_1=isNew(entry);
  if(!(return_value_isNew_1 == 0))
    addFile(entry, tm);

  else
    updateFile(entry, tm);
}

// CrashReport_add
// file data_stuff.c line 255
struct _crash_report * CrashReport_add(struct _test_entry *test_entry)
{
  struct _crash_report *new;
  /* assertion test_entry != ((void *)0) */
  assert(test_entry != (struct _test_entry *)(void *)0);
  void *return_value__xmalloc_1;
  return_value__xmalloc_1=_xmalloc_link1(sizeof(struct _crash_report) /*192ul*/ , "CrashReport_add", 260);
  new = (struct _crash_report *)return_value__xmalloc_1;
  CrashReport_init(new, test_entry);
  do
  {

  __CPROVER_DUMP_L1:
    ;
    pthread_mutex_init(&new->link.dle_access, (const union anonymous_1 *)(void *)0);
    new->link.dle_reader_count = (unsigned int)0;
    new->link.dle_writer_count = (unsigned int)0;
    pthread_cond_init(&new->link.dle_reader_wait, (const union anonymous_1 *)(void *)0);
    pthread_cond_init(&new->link.dle_writer_wait, (const union anonymous_1 *)(void *)0);
    pthread_mutex_lock(&(&CrashReport_Head)->dlh_ops);
    pthread_mutex_lock(&(&CrashReport_Head)->dlh_access);
    do
    {
      pthread_mutex_lock(&new->link.dle_access);
      new->link.dle_writer_count = new->link.dle_writer_count + 1u;
      while(!(new->link.dle_reader_count == 0u))
        pthread_cond_wait(&new->link.dle_writer_wait, &new->link.dle_access);
      pthread_mutex_unlock(&new->link.dle_access);
    }
    while((_Bool)0);
    if(!(CrashReport_Head.dlh_first == ((struct _crash_report *)NULL)))
    {
      do
      {
        pthread_mutex_lock(&(&CrashReport_Head)->dlh_first->link.dle_access);
        (&CrashReport_Head)->dlh_first->link.dle_writer_count = (&CrashReport_Head)->dlh_first->link.dle_writer_count + 1u;
        while(!(CrashReport_Head.dlh_first->link.dle_reader_count == 0u))
          pthread_cond_wait(&(&CrashReport_Head)->dlh_first->link.dle_writer_wait, &(&CrashReport_Head)->dlh_first->link.dle_access);
        pthread_mutex_unlock(&(&CrashReport_Head)->dlh_first->link.dle_access);
      }
      while((_Bool)0);
      (&CrashReport_Head)->dlh_first->link.dle_prev = new;
      do
      {
        pthread_mutex_lock(&(&CrashReport_Head)->dlh_first->link.dle_access);
        (&CrashReport_Head)->dlh_first->link.dle_writer_count = (&CrashReport_Head)->dlh_first->link.dle_writer_count - 1u;
        if(!(CrashReport_Head.dlh_first->link.dle_reader_count == 0u))
          pthread_cond_broadcast(&(&CrashReport_Head)->dlh_first->link.dle_reader_wait);

        pthread_mutex_unlock(&(&CrashReport_Head)->dlh_first->link.dle_access);
      }
      while((_Bool)0);
    }

    new->link.dle_next = (&CrashReport_Head)->dlh_first;
    new->link.dle_prev = (struct _crash_report *)(void *)0;
    (&CrashReport_Head)->dlh_first = new;
    do
    {
      pthread_mutex_lock(&new->link.dle_access);
      new->link.dle_writer_count = new->link.dle_writer_count - 1u;
      if(!(new->link.dle_reader_count == 0u))
        pthread_cond_broadcast(&new->link.dle_reader_wait);

      pthread_mutex_unlock(&new->link.dle_access);
    }
    while((_Bool)0);
    pthread_mutex_unlock(&(&CrashReport_Head)->dlh_access);
    pthread_mutex_unlock(&(&CrashReport_Head)->dlh_ops);
  }
  while((_Bool)0);
  return new;
}

// CrashReport_destroy
// file data_stuff.c line 246
static void CrashReport_destroy(struct _crash_report *report)
{
  if(!(report->progname == ((char *)NULL)))
    free((void *)report->progname);

  if(!(report->args_str == ((char *)NULL)))
    free((void *)report->args_str);

  if(!(report->env_str == ((char *)NULL)))
    free((void *)report->env_str);

  free((void *)report);
}

// CrashReport_init
// file data_stuff.c line 234
static void CrashReport_init(struct _crash_report *report, struct _test_entry *test_entry)
{
  report->progname=strdup(test_entry->progname);
  char *tmp_if_expr_2;
  char *return_value_strdup_1;
  if(!(test_entry->args_str == ((char *)NULL)))
  {
    return_value_strdup_1=strdup(test_entry->args_str);
    tmp_if_expr_2 = return_value_strdup_1;
  }

  else
    tmp_if_expr_2 = (char *)(void *)0;
  report->args_str = tmp_if_expr_2;
  char *tmp_if_expr_4;
  char *return_value_strdup_3;
  if(!(test_entry->env_str == ((char *)NULL)))
  {
    return_value_strdup_3=strdup(test_entry->env_str);
    tmp_if_expr_4 = return_value_strdup_3;
  }

  else
    tmp_if_expr_4 = (char *)(void *)0;
  report->env_str = tmp_if_expr_4;
  /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous_6
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
  ;
  report->signal = (signed int)(((union anonymous_6){ .__in=test_entry->status }).__i & 0x7f);
  report->didCore = (signed int)(((union anonymous_6){ .__in=test_entry->status }).__i & 0x80);
}

// CrashReport_log
// file data_stuff.c line 275
void CrashReport_log(struct _crash_report *report)
{
  char *tmp_if_expr_1;
  if(!(report->args_str == ((char *)NULL)))
    tmp_if_expr_1 = report->args_str;

  else
    tmp_if_expr_1 = "";
  char *tmp_if_expr_2;
  if(!(report->env_str == ((char *)NULL)))
    tmp_if_expr_2 = report->env_str;

  else
    tmp_if_expr_2 = "";
  char *return_value_strsignal_3;
  return_value_strsignal_3=strsignal(report->signal);
  __bfbt_message((enum _msg_type)MSG_TYPE_MESSAGE, "CrashReport_log", 287, "*** Crash <%s> ***\nargs:\t\t%s\nenvs:\t\t%s\nSignal:\t\t%d ( %s )\nCore?\t\t%s\n", report->progname, tmp_if_expr_1, tmp_if_expr_2, report->signal, return_value_strsignal_3, report->didCore != 0 ? "Yes" : "No");
}

// CrashReport_subtract
// file data_stuff.c line 267
void CrashReport_subtract(struct _crash_report *report)
{
  /* assertion report != ((void *)0) */
  assert(report != (struct _crash_report *)(void *)0);
  do
  {
    pthread_mutex_lock(&(&CrashReport_Head)->dlh_ops);
    if(report->link.dle_prev == ((struct _crash_report *)NULL))
    {
      pthread_mutex_lock(&(&CrashReport_Head)->dlh_access);
      (&CrashReport_Head)->dlh_first = report->link.dle_next;
    }

    else
    {
      do
      {
        pthread_mutex_lock(&report->link.dle_prev->link.dle_access);
        report->link.dle_prev->link.dle_writer_count = report->link.dle_prev->link.dle_writer_count + 1u;
        while(!(report->link.dle_prev->link.dle_reader_count == 0u))
          pthread_cond_wait(&report->link.dle_prev->link.dle_writer_wait, &report->link.dle_prev->link.dle_access);
        pthread_mutex_unlock(&report->link.dle_prev->link.dle_access);
      }
      while((_Bool)0);
      report->link.dle_prev->link.dle_next = report->link.dle_next;
    }
    do
    {
      pthread_mutex_lock(&report->link.dle_access);
      report->link.dle_writer_count = report->link.dle_writer_count + 1u;
      while(!(report->link.dle_reader_count == 0u))
        pthread_cond_wait(&report->link.dle_writer_wait, &report->link.dle_access);
      pthread_mutex_unlock(&report->link.dle_access);
    }
    while((_Bool)0);
    if(!(report->link.dle_next == ((struct _crash_report *)NULL)))
      report->link.dle_next->link.dle_prev = report->link.dle_prev;

    do
    {
      pthread_mutex_lock(&report->link.dle_access);
      report->link.dle_writer_count = report->link.dle_writer_count - 1u;
      if(!(report->link.dle_reader_count == 0u))
        pthread_cond_broadcast(&report->link.dle_reader_wait);

      pthread_mutex_unlock(&report->link.dle_access);
    }
    while((_Bool)0);
    if(report->link.dle_prev == ((struct _crash_report *)NULL))
      pthread_mutex_unlock(&(&CrashReport_Head)->dlh_access);

    else
      do
      {
        pthread_mutex_lock(&report->link.dle_prev->link.dle_access);
        report->link.dle_prev->link.dle_writer_count = report->link.dle_prev->link.dle_writer_count - 1u;
        if(!(report->link.dle_prev->link.dle_reader_count == 0u))
          pthread_cond_broadcast(&report->link.dle_prev->link.dle_reader_wait);

        pthread_mutex_unlock(&report->link.dle_prev->link.dle_access);
      }
      while((_Bool)0);
    pthread_mutex_unlock(&(&CrashReport_Head)->dlh_ops);
    do
    {
      pthread_mutex_destroy(&report->link.dle_access);
      pthread_cond_destroy(&report->link.dle_reader_wait);
      pthread_cond_destroy(&report->link.dle_writer_wait);
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  CrashReport_destroy(report);
}

// ExecEntry_add
// file ../../src/include/data_stuff.h line 27
struct _exec_entry * ExecEntry_add(char *name, struct stat *sb, enum _exec_entry_status status, signed int test_flags)
{
  struct _exec_entry *new;
  /* assertion name != ((void *)0) && sb != ((void *)0) */
  assert(name != (char *)(void *)0 && sb != (struct stat *)(void *)0);
  void *return_value__xmalloc_1;
  return_value__xmalloc_1=_xmalloc_link1(sizeof(struct _exec_entry) /*336ul*/ , "ExecEntry_add", 96);
  new = (struct _exec_entry *)return_value__xmalloc_1;
  ExecEntry_init(new, sb, name, status, test_flags);
  do
  {

  __CPROVER_DUMP_L1:
    ;
    pthread_mutex_init(&new->link.dle_access, (const union anonymous_1 *)(void *)0);
    new->link.dle_reader_count = (unsigned int)0;
    new->link.dle_writer_count = (unsigned int)0;
    pthread_cond_init(&new->link.dle_reader_wait, (const union anonymous_1 *)(void *)0);
    pthread_cond_init(&new->link.dle_writer_wait, (const union anonymous_1 *)(void *)0);
    pthread_mutex_lock(&(&ExecEntry_Head)->dlh_ops);
    pthread_mutex_lock(&(&ExecEntry_Head)->dlh_access);
    do
    {
      pthread_mutex_lock(&new->link.dle_access);
      new->link.dle_writer_count = new->link.dle_writer_count + 1u;
      while(!(new->link.dle_reader_count == 0u))
        pthread_cond_wait(&new->link.dle_writer_wait, &new->link.dle_access);
      pthread_mutex_unlock(&new->link.dle_access);
    }
    while((_Bool)0);
    if(!(ExecEntry_Head.dlh_first == ((struct _exec_entry *)NULL)))
    {
      do
      {
        pthread_mutex_lock(&(&ExecEntry_Head)->dlh_first->link.dle_access);
        (&ExecEntry_Head)->dlh_first->link.dle_writer_count = (&ExecEntry_Head)->dlh_first->link.dle_writer_count + 1u;
        while(!(ExecEntry_Head.dlh_first->link.dle_reader_count == 0u))
          pthread_cond_wait(&(&ExecEntry_Head)->dlh_first->link.dle_writer_wait, &(&ExecEntry_Head)->dlh_first->link.dle_access);
        pthread_mutex_unlock(&(&ExecEntry_Head)->dlh_first->link.dle_access);
      }
      while((_Bool)0);
      (&ExecEntry_Head)->dlh_first->link.dle_prev = new;
      do
      {
        pthread_mutex_lock(&(&ExecEntry_Head)->dlh_first->link.dle_access);
        (&ExecEntry_Head)->dlh_first->link.dle_writer_count = (&ExecEntry_Head)->dlh_first->link.dle_writer_count - 1u;
        if(!(ExecEntry_Head.dlh_first->link.dle_reader_count == 0u))
          pthread_cond_broadcast(&(&ExecEntry_Head)->dlh_first->link.dle_reader_wait);

        pthread_mutex_unlock(&(&ExecEntry_Head)->dlh_first->link.dle_access);
      }
      while((_Bool)0);
    }

    new->link.dle_next = (&ExecEntry_Head)->dlh_first;
    new->link.dle_prev = (struct _exec_entry *)(void *)0;
    (&ExecEntry_Head)->dlh_first = new;
    do
    {
      pthread_mutex_lock(&new->link.dle_access);
      new->link.dle_writer_count = new->link.dle_writer_count - 1u;
      if(!(new->link.dle_reader_count == 0u))
        pthread_cond_broadcast(&new->link.dle_reader_wait);

      pthread_mutex_unlock(&new->link.dle_access);
    }
    while((_Bool)0);
    pthread_mutex_unlock(&(&ExecEntry_Head)->dlh_access);
    pthread_mutex_unlock(&(&ExecEntry_Head)->dlh_ops);
  }
  while((_Bool)0);
  return new;
}

// ExecEntry_destroy
// file data_stuff.c line 72
static void ExecEntry_destroy(struct _exec_entry *entry)
{
  /* assertion entry != ((void *)0) */
  assert(entry != (struct _exec_entry *)(void *)0);
  if(!(entry->fullname == ((char *)NULL)))
    free((void *)entry->fullname);

  free((void *)entry);
}

// ExecEntry_findbyname
// file data_stuff.c line 118
struct _exec_entry * ExecEntry_findbyname(char *name)
{
  struct _exec_entry *entry = (struct _exec_entry *)(void *)0;
  entry=ExecEntry_getnext(&entry);
  signed int return_value_strcmp_1;
  while(!(entry == ((struct _exec_entry *)NULL)))
  {
    return_value_strcmp_1=strcmp(entry->fullname, name);
    if(return_value_strcmp_1 == 0)
      break;

    entry=ExecEntry_getnext(&entry);
  }
  return entry;
}

// ExecEntry_getnext
// file ../../src/include/data_stuff.h line 37
struct _exec_entry * ExecEntry_getnext(struct _exec_entry **entry)
{
  do
    if(*entry == ((struct _exec_entry *)NULL))
    {
      pthread_mutex_lock(&(&ExecEntry_Head)->dlh_access);
      *entry = (&ExecEntry_Head)->dlh_first;
      if(!(*entry == ((struct _exec_entry *)NULL)))
        do
        {
          pthread_mutex_lock(&(*entry)->link.dle_access);
          while(!((*entry)->link.dle_writer_count == 0u))
            pthread_cond_wait(&(*entry)->link.dle_reader_wait, &(*entry)->link.dle_access);
          (*entry)->link.dle_reader_count = (*entry)->link.dle_reader_count + 1u;
          pthread_mutex_unlock(&(*entry)->link.dle_access);
        }
        while((_Bool)0);

      pthread_mutex_unlock(&(&ExecEntry_Head)->dlh_access);
    }

    else
      if((*entry)->link.dle_next == ((struct _exec_entry *)NULL))
      {
        do
        {
          pthread_mutex_lock(&(*entry)->link.dle_access);
          (*entry)->link.dle_reader_count = (*entry)->link.dle_reader_count - 1u;
          if(!((*entry)->link.dle_writer_count == 0u))
          {
            if((*entry)->link.dle_reader_count == 0u)
              pthread_cond_broadcast(&(*entry)->link.dle_writer_wait);

          }

          pthread_mutex_unlock(&(*entry)->link.dle_access);
        }
        while((_Bool)0);
        *entry = (struct _exec_entry *)(void *)0;
      }

      else
      {
        *entry = (*entry)->link.dle_next;
        do
        {
          pthread_mutex_lock(&(*entry)->link.dle_access);
          while(!((*entry)->link.dle_writer_count == 0u))
            pthread_cond_wait(&(*entry)->link.dle_reader_wait, &(*entry)->link.dle_access);
          (*entry)->link.dle_reader_count = (*entry)->link.dle_reader_count + 1u;
          pthread_mutex_unlock(&(*entry)->link.dle_access);
        }
        while((_Bool)0);
        do
        {
          pthread_mutex_lock(&(*entry)->link.dle_prev->link.dle_access);
          (*entry)->link.dle_prev->link.dle_reader_count = (*entry)->link.dle_prev->link.dle_reader_count - 1u;
          if(!((*entry)->link.dle_prev->link.dle_writer_count == 0u))
          {
            if((*entry)->link.dle_prev->link.dle_reader_count == 0u)
              pthread_cond_broadcast(&(*entry)->link.dle_prev->link.dle_writer_wait);

          }

          pthread_mutex_unlock(&(*entry)->link.dle_prev->link.dle_access);
        }
        while((_Bool)0);
      }
  while((_Bool)0);
  return *entry;
}

// ExecEntry_init
// file data_stuff.c line 60
static inline void ExecEntry_init(struct _exec_entry *entry, struct stat *sb, char *fullname, enum _exec_entry_status status, signed int test_flags)
{
  entry->fullname=strdup(fullname);
  memcpy((void *)&entry->filestat, (const void *)sb, sizeof(struct stat) /*144ul*/ );
  entry->status = status;
  entry->test_flags = test_flags;
  entry->testtime.tv_sec = (signed long int)0;
  entry->testtime.tv_usec = (signed long int)0;
}

// ExecEntry_isempty
// file ../../src/include/data_stuff.h line 46
signed int ExecEntry_isempty(void)
{
  return (signed int)((&ExecEntry_Head)->dlh_first == (struct _exec_entry *)(void *)0);
}

// ExecEntry_release
// file data_stuff.c line 129
void ExecEntry_release(struct _exec_entry *entry)
{
  do
  {
    pthread_mutex_lock(&entry->link.dle_access);
    entry->link.dle_reader_count = entry->link.dle_reader_count - 1u;
    if(!(entry->link.dle_writer_count == 0u))
    {
      if(entry->link.dle_reader_count == 0u)
        pthread_cond_broadcast(&entry->link.dle_writer_wait);

    }

    pthread_mutex_unlock(&entry->link.dle_access);
  }
  while((_Bool)0);
}

// ExecEntry_subtract
// file data_stuff.c line 103
void ExecEntry_subtract(struct _exec_entry *entry)
{
  /* assertion entry != ((void *)0) */
  assert(entry != (struct _exec_entry *)(void *)0);
  do
  {
    pthread_mutex_lock(&(&ExecEntry_Head)->dlh_ops);
    if(entry->link.dle_prev == ((struct _exec_entry *)NULL))
    {
      pthread_mutex_lock(&(&ExecEntry_Head)->dlh_access);
      (&ExecEntry_Head)->dlh_first = entry->link.dle_next;
    }

    else
    {
      do
      {
        pthread_mutex_lock(&entry->link.dle_prev->link.dle_access);
        entry->link.dle_prev->link.dle_writer_count = entry->link.dle_prev->link.dle_writer_count + 1u;
        while(!(entry->link.dle_prev->link.dle_reader_count == 0u))
          pthread_cond_wait(&entry->link.dle_prev->link.dle_writer_wait, &entry->link.dle_prev->link.dle_access);
        pthread_mutex_unlock(&entry->link.dle_prev->link.dle_access);
      }
      while((_Bool)0);
      entry->link.dle_prev->link.dle_next = entry->link.dle_next;
    }
    do
    {
      pthread_mutex_lock(&entry->link.dle_access);
      entry->link.dle_writer_count = entry->link.dle_writer_count + 1u;
      while(!(entry->link.dle_reader_count == 0u))
        pthread_cond_wait(&entry->link.dle_writer_wait, &entry->link.dle_access);
      pthread_mutex_unlock(&entry->link.dle_access);
    }
    while((_Bool)0);
    if(!(entry->link.dle_next == ((struct _exec_entry *)NULL)))
      entry->link.dle_next->link.dle_prev = entry->link.dle_prev;

    do
    {
      pthread_mutex_lock(&entry->link.dle_access);
      entry->link.dle_writer_count = entry->link.dle_writer_count - 1u;
      if(!(entry->link.dle_reader_count == 0u))
        pthread_cond_broadcast(&entry->link.dle_reader_wait);

      pthread_mutex_unlock(&entry->link.dle_access);
    }
    while((_Bool)0);
    if(entry->link.dle_prev == ((struct _exec_entry *)NULL))
      pthread_mutex_unlock(&(&ExecEntry_Head)->dlh_access);

    else
      do
      {
        pthread_mutex_lock(&entry->link.dle_prev->link.dle_access);
        entry->link.dle_prev->link.dle_writer_count = entry->link.dle_prev->link.dle_writer_count - 1u;
        if(!(entry->link.dle_prev->link.dle_reader_count == 0u))
          pthread_cond_broadcast(&entry->link.dle_prev->link.dle_reader_wait);

        pthread_mutex_unlock(&entry->link.dle_prev->link.dle_access);
      }
      while((_Bool)0);
    pthread_mutex_unlock(&(&ExecEntry_Head)->dlh_ops);
    do
    {
      pthread_mutex_destroy(&entry->link.dle_access);
      pthread_cond_destroy(&entry->link.dle_reader_wait);
      pthread_cond_destroy(&entry->link.dle_writer_wait);
    }
    while((_Bool)0);
  }
  while((_Bool)0);
  ExecEntry_destroy(entry);
}

// TestEntry_create
// file data_stuff.c line 188
struct _test_entry * TestEntry_create(struct _exec_entry *parent, char **args, char **env)
{
  struct _test_entry *new;
  void *return_value__xmalloc_1;
  return_value__xmalloc_1=_xmalloc_link1(sizeof(struct _test_entry) /*232ul*/ , "TestEntry_create", 192);
  new = (struct _test_entry *)return_value__xmalloc_1;
  TestEntry_init(new, parent, args, env);
  return new;
}

// TestEntry_destroy
// file data_stuff.c line 177
void TestEntry_destroy(struct _test_entry *entry)
{
  /* assertion entry != ((void *)0) */
  assert(entry != (struct _test_entry *)(void *)0);
  if(!(entry->progname == ((char *)NULL)))
    free((void *)entry->progname);

  if(!(entry->args_str == ((char *)NULL)))
    free((void *)entry->args_str);

  if(!(entry->env == ((char **)NULL)))
  {
    if(entry->env_flag == 0)
      free((void *)entry->env);

  }

  if(!(entry->env_str == ((char *)NULL)))
    free((void *)entry->env_str);

  free((void *)entry);
}

// TestEntry_getnext
// file data_stuff.c line 214
struct _test_entry * TestEntry_getnext(struct _test_entry **entry)
{
  do
    if(*entry == ((struct _test_entry *)NULL))
    {
      pthread_mutex_lock(&(&TestEntry_Head)->dlh_access);
      *entry = (&TestEntry_Head)->dlh_first;
      if(!(*entry == ((struct _test_entry *)NULL)))
        do
        {
          pthread_mutex_lock(&(*entry)->link.dle_access);
          while(!((*entry)->link.dle_writer_count == 0u))
            pthread_cond_wait(&(*entry)->link.dle_reader_wait, &(*entry)->link.dle_access);
          (*entry)->link.dle_reader_count = (*entry)->link.dle_reader_count + 1u;
          pthread_mutex_unlock(&(*entry)->link.dle_access);
        }
        while((_Bool)0);

      pthread_mutex_unlock(&(&TestEntry_Head)->dlh_access);
    }

    else
      if((*entry)->link.dle_next == ((struct _test_entry *)NULL))
      {
        do
        {
          pthread_mutex_lock(&(*entry)->link.dle_access);
          (*entry)->link.dle_reader_count = (*entry)->link.dle_reader_count - 1u;
          if(!((*entry)->link.dle_writer_count == 0u))
          {
            if((*entry)->link.dle_reader_count == 0u)
              pthread_cond_broadcast(&(*entry)->link.dle_writer_wait);

          }

          pthread_mutex_unlock(&(*entry)->link.dle_access);
        }
        while((_Bool)0);
        *entry = (struct _test_entry *)(void *)0;
      }

      else
      {
        *entry = (*entry)->link.dle_next;
        do
        {
          pthread_mutex_lock(&(*entry)->link.dle_access);
          while(!((*entry)->link.dle_writer_count == 0u))
            pthread_cond_wait(&(*entry)->link.dle_reader_wait, &(*entry)->link.dle_access);
          (*entry)->link.dle_reader_count = (*entry)->link.dle_reader_count + 1u;
          pthread_mutex_unlock(&(*entry)->link.dle_access);
        }
        while((_Bool)0);
        do
        {
          pthread_mutex_lock(&(*entry)->link.dle_prev->link.dle_access);
          (*entry)->link.dle_prev->link.dle_reader_count = (*entry)->link.dle_prev->link.dle_reader_count - 1u;
          if(!((*entry)->link.dle_prev->link.dle_writer_count == 0u))
          {
            if((*entry)->link.dle_prev->link.dle_reader_count == 0u)
              pthread_cond_broadcast(&(*entry)->link.dle_prev->link.dle_writer_wait);

          }

          pthread_mutex_unlock(&(*entry)->link.dle_prev->link.dle_access);
        }
        while((_Bool)0);
      }
  while((_Bool)0);
  return *entry;
}

// TestEntry_init
// file data_stuff.c line 156
static inline void TestEntry_init(struct _test_entry *entry, struct _exec_entry *parent, char **args, char **env)
{
  /* assertion entry != ((void *)0) */
  assert(entry != (struct _test_entry *)(void *)0);
  entry->pid = -1;
  entry->status = 0;
  entry->progname=strdup(parent->fullname);
  if(entry->progname == ((char *)NULL))
    __bfbt_message((enum _msg_type)MSG_TYPE_ERRNO_ABORT, "TestEntry_init", 162, "Out of memory");

  entry->args = args;
  entry->args_str=args_to_str(entry->args);
  if(!(env == ((char **)NULL)))
  {
    entry->env=env_create(env);
    entry->env_flag = (signed int)(1 == 0);
    entry->env_str=env_to_str(env);
  }

  else
  {
    entry->env = environ;
    entry->env_flag = (signed int)!(1 == 0);
    entry->env_str = (char *)(void *)0;
  }
}

// TestEntry_insert
// file data_stuff.c line 199
void TestEntry_insert(struct _test_entry *entry)
{
  _Bool tmp_if_expr_1;
  if(!(entry == ((struct _test_entry *)NULL)))
    tmp_if_expr_1 = entry->pid != -1 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  /* assertion entry != ((void *)0) && entry->pid != -1 */
  assert(tmp_if_expr_1);
  do
  {

  __CPROVER_DUMP_L3:
    ;
    pthread_mutex_init(&entry->link.dle_access, (const union anonymous_1 *)(void *)0);
    entry->link.dle_reader_count = (unsigned int)0;
    entry->link.dle_writer_count = (unsigned int)0;
    pthread_cond_init(&entry->link.dle_reader_wait, (const union anonymous_1 *)(void *)0);
    pthread_cond_init(&entry->link.dle_writer_wait, (const union anonymous_1 *)(void *)0);
    pthread_mutex_lock(&(&TestEntry_Head)->dlh_ops);
    pthread_mutex_lock(&(&TestEntry_Head)->dlh_access);
    do
    {
      pthread_mutex_lock(&entry->link.dle_access);
      entry->link.dle_writer_count = entry->link.dle_writer_count + 1u;
      while(!(entry->link.dle_reader_count == 0u))
        pthread_cond_wait(&entry->link.dle_writer_wait, &entry->link.dle_access);
      pthread_mutex_unlock(&entry->link.dle_access);
    }
    while((_Bool)0);
    if(!(TestEntry_Head.dlh_first == ((struct _test_entry *)NULL)))
    {
      do
      {
        pthread_mutex_lock(&(&TestEntry_Head)->dlh_first->link.dle_access);
        (&TestEntry_Head)->dlh_first->link.dle_writer_count = (&TestEntry_Head)->dlh_first->link.dle_writer_count + 1u;
        while(!(TestEntry_Head.dlh_first->link.dle_reader_count == 0u))
          pthread_cond_wait(&(&TestEntry_Head)->dlh_first->link.dle_writer_wait, &(&TestEntry_Head)->dlh_first->link.dle_access);
        pthread_mutex_unlock(&(&TestEntry_Head)->dlh_first->link.dle_access);
      }
      while((_Bool)0);
      (&TestEntry_Head)->dlh_first->link.dle_prev = entry;
      do
      {
        pthread_mutex_lock(&(&TestEntry_Head)->dlh_first->link.dle_access);
        (&TestEntry_Head)->dlh_first->link.dle_writer_count = (&TestEntry_Head)->dlh_first->link.dle_writer_count - 1u;
        if(!(TestEntry_Head.dlh_first->link.dle_reader_count == 0u))
          pthread_cond_broadcast(&(&TestEntry_Head)->dlh_first->link.dle_reader_wait);

        pthread_mutex_unlock(&(&TestEntry_Head)->dlh_first->link.dle_access);
      }
      while((_Bool)0);
    }

    entry->link.dle_next = (&TestEntry_Head)->dlh_first;
    entry->link.dle_prev = (struct _test_entry *)(void *)0;
    (&TestEntry_Head)->dlh_first = entry;
    do
    {
      pthread_mutex_lock(&entry->link.dle_access);
      entry->link.dle_writer_count = entry->link.dle_writer_count - 1u;
      if(!(entry->link.dle_reader_count == 0u))
        pthread_cond_broadcast(&entry->link.dle_reader_wait);

      pthread_mutex_unlock(&entry->link.dle_access);
    }
    while((_Bool)0);
    pthread_mutex_unlock(&(&TestEntry_Head)->dlh_access);
    pthread_mutex_unlock(&(&TestEntry_Head)->dlh_ops);
  }
  while((_Bool)0);
}

// TestEntry_remove
// file data_stuff.c line 206
void TestEntry_remove(struct _test_entry *entry)
{
  _Bool tmp_if_expr_1;
  if(!(entry == ((struct _test_entry *)NULL)))
    tmp_if_expr_1 = entry->pid != -1 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  /* assertion entry != ((void *)0) && entry->pid != -1 */
  assert(tmp_if_expr_1);
  do
  {
    pthread_mutex_lock(&(&TestEntry_Head)->dlh_ops);
    if(entry->link.dle_prev == ((struct _test_entry *)NULL))
    {
      pthread_mutex_lock(&(&TestEntry_Head)->dlh_access);
      (&TestEntry_Head)->dlh_first = entry->link.dle_next;
    }

    else
    {
      do
      {
        pthread_mutex_lock(&entry->link.dle_prev->link.dle_access);
        entry->link.dle_prev->link.dle_writer_count = entry->link.dle_prev->link.dle_writer_count + 1u;
        while(!(entry->link.dle_prev->link.dle_reader_count == 0u))
          pthread_cond_wait(&entry->link.dle_prev->link.dle_writer_wait, &entry->link.dle_prev->link.dle_access);
        pthread_mutex_unlock(&entry->link.dle_prev->link.dle_access);
      }
      while((_Bool)0);
      entry->link.dle_prev->link.dle_next = entry->link.dle_next;
    }
    do
    {
      pthread_mutex_lock(&entry->link.dle_access);
      entry->link.dle_writer_count = entry->link.dle_writer_count + 1u;
      while(!(entry->link.dle_reader_count == 0u))
        pthread_cond_wait(&entry->link.dle_writer_wait, &entry->link.dle_access);
      pthread_mutex_unlock(&entry->link.dle_access);
    }
    while((_Bool)0);
    if(!(entry->link.dle_next == ((struct _test_entry *)NULL)))
      entry->link.dle_next->link.dle_prev = entry->link.dle_prev;

    do
    {
      pthread_mutex_lock(&entry->link.dle_access);
      entry->link.dle_writer_count = entry->link.dle_writer_count - 1u;
      if(!(entry->link.dle_reader_count == 0u))
        pthread_cond_broadcast(&entry->link.dle_reader_wait);

      pthread_mutex_unlock(&entry->link.dle_access);
    }
    while((_Bool)0);
    if(entry->link.dle_prev == ((struct _test_entry *)NULL))
      pthread_mutex_unlock(&(&TestEntry_Head)->dlh_access);

    else
      do
      {
        pthread_mutex_lock(&entry->link.dle_prev->link.dle_access);
        entry->link.dle_prev->link.dle_writer_count = entry->link.dle_prev->link.dle_writer_count - 1u;
        if(!(entry->link.dle_prev->link.dle_reader_count == 0u))
          pthread_cond_broadcast(&entry->link.dle_prev->link.dle_reader_wait);

        pthread_mutex_unlock(&entry->link.dle_prev->link.dle_access);
      }
      while((_Bool)0);
    pthread_mutex_unlock(&(&TestEntry_Head)->dlh_ops);
    do
    {
      pthread_mutex_destroy(&entry->link.dle_access);
      pthread_cond_destroy(&entry->link.dle_reader_wait);
      pthread_cond_destroy(&entry->link.dle_writer_wait);
    }
    while((_Bool)0);
  }
  while((_Bool)0);
}

// __bfbt_message
// file ../../src/include/utils.h line 44
void __bfbt_message(enum _msg_type type, char *function, signed int line, char *fmt, ...)
{
  void **args;
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  if(!((signed int)type == MSG_TYPE_DEBUG_L1) || debug_level >= 1)
  {
    if(!((signed int)type == MSG_TYPE_DEBUG_L2) || debug_level >= 2)
    {
      args = (void **)&fmt;
      if(!((signed int)type == MSG_TYPE_MESSAGE))
        fprintf(fp_msg, "[%s:%d] ", function, line);

      vfprintf(fp_msg, fmt, args);
      if((signed int)type == MSG_TYPE_ERRNO_ABORT || (signed int)type == MSG_TYPE_ERRNO_WARN)
      {
        return_value___errno_location_1=__errno_location();
        return_value_strerror_2=strerror(*return_value___errno_location_1);
        fprintf(fp_msg, ": %s", return_value_strerror_2);
      }

      fprintf(fp_msg, "\n");
      if((signed int)type == MSG_TYPE_ERROR_ABORT || (signed int)type == MSG_TYPE_ERRNO_ABORT)
        exit(1);

      args = ((void **)NULL);
    }

  }

}

// _xcalloc
// file ../../src/include/utils.h line 73
static inline void * _xcalloc(unsigned long int number, unsigned long int size, char *function, signed int line)
{
  void *temp;
  temp=calloc(number, size);
  if(temp == NULL)
    __bfbt_message((enum _msg_type)MSG_TYPE_ERRNO_ABORT, "_xcalloc", 79, "Calloc failed at [%s:%d]", function, line);

  return temp;
}

// _xcalloc_link1
// file ../../src/include/utils.h line 73
static inline void * _xcalloc_link1(unsigned long int number_link1, unsigned long int size_link1, char *function_link1, signed int line_link1)
{
  void *temp_link1;
  temp_link1=calloc(number_link1, size_link1);
  if(temp_link1 == NULL)
    __bfbt_message((enum _msg_type)MSG_TYPE_ERRNO_ABORT, "_xcalloc", 79, "Calloc failed at [%s:%d]", function_link1, line_link1);

  return temp_link1;
}

// _xcalloc_link2
// file ../../src/include/utils.h line 73
static inline void * _xcalloc_link2(unsigned long int number_link2, unsigned long int size_link2, char *function_link2, signed int line_link2)
{
  void *temp_link2;
  temp_link2=calloc(number_link2, size_link2);
  if(temp_link2 == NULL)
    __bfbt_message((enum _msg_type)MSG_TYPE_ERRNO_ABORT, "_xcalloc", 79, "Calloc failed at [%s:%d]", function_link2, line_link2);

  return temp_link2;
}

// _xmalloc
// file ../../src/include/utils.h line 61
static inline void * _xmalloc(unsigned long int size, char *function, signed int line)
{
  void *temp;
  temp=malloc(size);
  if(temp == NULL)
    __bfbt_message((enum _msg_type)MSG_TYPE_ERRNO_ABORT, "_xmalloc", 67, "Malloc failed at [%s:%d]", function, line);

  return temp;
}

// _xmalloc_link1
// file ../../src/include/utils.h line 61
static inline void * _xmalloc_link1(unsigned long int size_link1, char *function_link1, signed int line_link1)
{
  void *temp_link1;
  temp_link1=malloc(size_link1);
  if(temp_link1 == NULL)
    __bfbt_message((enum _msg_type)MSG_TYPE_ERRNO_ABORT, "_xmalloc", 67, "Malloc failed at [%s:%d]", function_link1, line_link1);

  return temp_link1;
}

// _xmalloc_link2
// file ../../src/include/utils.h line 61
static inline void * _xmalloc_link2(unsigned long int size_link2, char *function_link2, signed int line_link2)
{
  void *temp_link2;
  temp_link2=malloc(size_link2);
  if(temp_link2 == NULL)
    __bfbt_message((enum _msg_type)MSG_TYPE_ERRNO_ABORT, "_xmalloc", 67, "Malloc failed at [%s:%d]", function_link2, line_link2);

  return temp_link2;
}

// addFile
// file tempfiles.c line 108
static void addFile(struct dirent *entry, struct timeval tm)
{
  struct _file_entry *new;
  void *return_value__xmalloc_1;
  return_value__xmalloc_1=_xmalloc_link2(sizeof(struct _file_entry) /*192ul*/ , "addFile", 112);
  new = (struct _file_entry *)return_value__xmalloc_1;
  new->filename=strdup(entry->d_name);
  new->tm = tm;
  new->fileno = (unsigned int)entry->d_ino;
  new->next = (struct _file_entry *)(void *)0;
  new->prev = (struct _file_entry *)(void *)0;
  if(head == ((struct _file_entry *)NULL))
  {
    tail = new;
    head = tail;
  }

  else
    if(!(new->fileno >= head->fileno))
    {
      head->prev = new;
      new->next = head;
      head = new;
    }

    else
      if(!(tail->fileno >= new->fileno))
      {
        new->prev = tail;
        tail->next = new;
        tail = new;
      }

      else
      {
        struct _file_entry *temp = head;
        for( ; !(temp->fileno >= new->fileno); temp = temp->next)
          ;
        temp->prev->next = new;
        new->prev = temp->prev;
        new->next = temp;
        temp->prev = new;
      }
  if(!(request.create_cb == ((void (*)(char *, struct stat *, void *))NULL)) && !(request.count == 0) && (request.status == 2 || request.status == 3))
    request.create_cb(new->filename, &new->sb, request.cb_data);

}

// add_exec
// file bfbtester.c line 186
static void add_exec(char *filename, enum _exec_entry_status status, signed int flags, char *rejects)
{
  struct stat sb;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  unsigned long int return_value_strlen_1;
  _Bool tmp_if_expr_3;
  unsigned long int return_value_strlen_2;
  _Bool tmp_if_expr_5;
  unsigned long int return_value_strlen_4;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_14;
  unsigned long int return_value_strlen_8;
  _Bool tmp_if_expr_10;
  unsigned long int return_value_strlen_9;
  _Bool tmp_if_expr_12;
  unsigned long int return_value_strlen_11;
  if(!(rejects == ((char *)NULL)))
  {
    char *ptr;
    char *ptr2;
    ptr=strstr(rejects, filename);
    if(!(ptr == ((char *)NULL)))
    {
      if(ptr == rejects)
        tmp_if_expr_6 = (_Bool)1;

      else
        tmp_if_expr_6 = (signed int)*(ptr - (signed long int)1) == 32 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_6)
        tmp_if_expr_7 = (_Bool)1;

      else
        tmp_if_expr_7 = (signed int)*(ptr - (signed long int)1) == 44 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_7)
      {
        return_value_strlen_1=strlen(filename);
        if((signed int)ptr[(signed long int)return_value_strlen_1] == 0)
          tmp_if_expr_3 = (_Bool)1;

        else
        {
          return_value_strlen_2=strlen(filename);
          tmp_if_expr_3 = (signed int)ptr[(signed long int)return_value_strlen_2] == 32 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_3)
          tmp_if_expr_5 = (_Bool)1;

        else
        {
          return_value_strlen_4=strlen(filename);
          tmp_if_expr_5 = (signed int)ptr[(signed long int)return_value_strlen_4] == 44 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_5)
          goto __CPROVER_DUMP_L21;

      }

    }

    ptr2=strrchr(filename, 47);
    if(!(ptr2 == ((char *)NULL)))
    {
      ptr2 = ptr2 + 1l;
      ptr=strstr(rejects, ptr2);
      if(!(ptr == ((char *)NULL)))
      {
        if(ptr == rejects)
          tmp_if_expr_13 = (_Bool)1;

        else
          tmp_if_expr_13 = (signed int)*(ptr - (signed long int)1) == 32 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_13)
          tmp_if_expr_14 = (_Bool)1;

        else
          tmp_if_expr_14 = (signed int)*(ptr - (signed long int)1) == 44 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_14)
        {
          return_value_strlen_8=strlen(ptr2);
          if((signed int)ptr[(signed long int)return_value_strlen_8] == 0)
            tmp_if_expr_10 = (_Bool)1;

          else
          {
            return_value_strlen_9=strlen(ptr2);
            tmp_if_expr_10 = (signed int)ptr[(signed long int)return_value_strlen_9] == 32 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_10)
            tmp_if_expr_12 = (_Bool)1;

          else
          {
            return_value_strlen_11=strlen(ptr2);
            tmp_if_expr_12 = (signed int)ptr[(signed long int)return_value_strlen_11] == 44 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_12)
            goto __CPROVER_DUMP_L21;

        }

      }

    }

  }

  signed int return_value_stat_16;
  return_value_stat_16=stat(filename, &sb);
  signed int return_value_access_15;
  if(return_value_stat_16 == 0)
  {
    if((61440u & sb.st_mode) == 32768u)
    {
      return_value_access_15=access(filename, 0 | 1);
      if(return_value_access_15 == 0)
        ExecEntry_add(filename, &sb, status, flags);

    }

  }


__CPROVER_DUMP_L21:
  ;
}

// args_to_str
// file ../../src/include/utils.h line 87
char * args_to_str(char **args)
{
  char *str;
  char **temp;
  signed int i;
  unsigned long int return_value_strlen_1;
  unsigned long int tmp_if_expr_3;
  unsigned long int return_value_strlen_2;
  if(args[1l] == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    i = 0;
    temp = args + (signed long int)1;
    for( ; !(*temp == ((char *)NULL)); temp = temp + 1l)
    {
      return_value_strlen_1=strlen(*temp);
      if(return_value_strlen_1 >= 101ul)
        tmp_if_expr_3 = sizeof(char [8l]) /*8ul*/  - (unsigned long int)1;

      else
      {
        return_value_strlen_2=strlen(*temp);
        tmp_if_expr_3 = return_value_strlen_2;
      }
      i = i + (signed int)(tmp_if_expr_3 + (unsigned long int)1);
    }
    void *return_value__xcalloc_4;
    return_value__xcalloc_4=_xcalloc_link2((unsigned long int)1, (unsigned long int)i, "args_to_str", 115);
    str = (char *)return_value__xcalloc_4;
    temp = args + (signed long int)1;
    for( ; !(*temp == ((char *)NULL)); temp = temp + 1l)
    {
      unsigned long int return_value_strlen_6;
      return_value_strlen_6=strlen(*temp);
      if(return_value_strlen_6 >= 101ul)
      {
        char long_str[8l];
        unsigned long int return_value_strlen_5;
        return_value_strlen_5=strlen(*temp);
        snprintf(long_str, (sizeof(char [8l]) /*8ul*/  - (unsigned long int)1) + (unsigned long int)1, "[%5.5d]", (signed int)return_value_strlen_5);
        strcat(str, long_str);
      }

      else
        strcat(str, *temp);
      if(!(temp[1l] == ((char *)NULL)))
        strcat(str, " ");

    }
    return str;
  }
}

// breaker_cleanup
// file breaker.c line 213
static void breaker_cleanup(void *arg)
{
  __bfbt_message((enum _msg_type)MSG_TYPE_MESSAGE, "breaker_cleanup", 215, "Cleaning up...might take a few seconds");
  sleep((unsigned int)(5 + 1));
  exec_poll();
  exec_poll();
}

// breaker_execute_command
// file breaker.c line 41
static void breaker_execute_command(struct _exec_entry *exec_entry, char **args, char **env)
{
  signed int i;
  if(!(q->max_execs / 2 >= q->current_execs))
    exec_poll();

  i = 10000;
  signed int return_value_execute_program_1;
  do
  {
    return_value_execute_program_1=execute_program(exec_entry, args, env);
    if(return_value_execute_program_1 == 0)
      break;

    usleep((unsigned int)i);
    exec_poll();
    i = i * 3;
  }
  while((_Bool)1);
}

// breaker_run
// file breaker.c line 222
void * breaker_run(void *data)
{
  struct _exec_entry *entry = (struct _exec_entry *)(void *)0;
  entry=ExecEntry_getnext(&entry);
  while(!(entry == ((struct _exec_entry *)NULL)))
  {
    if((signed int)entry->status == EXEC_ENTRY_STATUS_TEST)
    {
      gettimeofday(&entry->testtime, (struct timezone *)(void *)0);
      breaker_runtests(entry);
      entry->status = (enum _exec_entry_status)EXEC_ENTRY_STATUS_TESTED;
    }

    entry=ExecEntry_getnext(&entry);
  }
  breaker_cleanup((void *)0);
  return (void *)0;
}

// breaker_runtests
// file breaker.c line 179
static void breaker_runtests(struct _exec_entry *entry)
{
  signed int test_flags = entry->test_flags;
  tempfile_request_add(breaker_tempfile_createcb, breaker_tempfile_removecb, (void *)entry);
  __bfbt_message((enum _msg_type)MSG_TYPE_MESSAGE, "breaker_runtests", 186, "=> %s", entry->fullname);
  if(!((2048u & entry->filestat.st_mode) == 0u))
    __bfbt_message((enum _msg_type)MSG_TYPE_MESSAGE, "breaker_runtests", 189, " (setuid: %d)", (signed int)entry->filestat.st_uid);

  if(!((1024u & entry->filestat.st_mode) == 0u))
    __bfbt_message((enum _msg_type)MSG_TYPE_MESSAGE, "breaker_runtests", 192, " (setgid: %d)", (signed int)entry->filestat.st_gid);

  if(!((1 & test_flags) == 0))
    breaker_test_singlearg(entry);

  if(!((2 & test_flags) == 0))
    breaker_test_multiplearg(entry);

  if(!((4 & test_flags) == 0))
    breaker_test_env(entry);

  tempfile_request_subtract();
}

// breaker_start
// file ../../src/include/breaker.h line 27
void breaker_start(void)
{
  signed int return_value_pthread_create_1;
  return_value_pthread_create_1=pthread_create(&q->run_thread, (const union pthread_attr_t *)(void *)0, breaker_run, (void *)0);
  if(!(return_value_pthread_create_1 == 0))
    __bfbt_message((enum _msg_type)MSG_TYPE_ERRNO_ABORT, "breaker_start", 263, "Can't create run thread");

}

// breaker_tempfile_createcb
// file breaker.c line 161
void breaker_tempfile_createcb(char *filename, struct stat *sb, void *data)
{
  struct _exec_entry *entry = (struct _exec_entry *)data;
  __bfbt_message((enum _msg_type)MSG_TYPE_MESSAGE, "breaker_tempfile_createcb", 166, "[Tempfile: %s]+ \"%s\"", entry->fullname, filename);
}

// breaker_tempfile_removecb
// file breaker.c line 170
void breaker_tempfile_removecb(char *filename, struct stat *sb, void *data)
{
  struct _exec_entry *entry = (struct _exec_entry *)data;
  __bfbt_message((enum _msg_type)MSG_TYPE_MESSAGE, "breaker_tempfile_removecb", 175, "[Tempfile: %s]- \"%s\"", entry->fullname, filename);
}

// breaker_test_env
// file breaker.c line 130
static void breaker_test_env(struct _exec_entry *entry)
{
  char *args_arr[3l] = { entry->fullname, (char *)(void *)0, (char *)(void *)0 };
  char *envs_arr[2l] = { (char *)(void *)0, (char *)(void *)0 };
  char *long_arg;
  char *long_arg2;
  signed int i;
  signed int env_len;
  signed int long_arg_len = 10 * 1024 + 1;
  __bfbt_message((enum _msg_type)MSG_TYPE_MESSAGE, "breaker_test_env", 138, "   * Environment variable testing");
  void *return_value__xcalloc_1;
  return_value__xcalloc_1=_xcalloc_link1((unsigned long int)1, (unsigned long int)long_arg_len, "breaker_test_env", 139);
  long_arg = (char *)return_value__xcalloc_1;
  void *return_value__xcalloc_2;
  return_value__xcalloc_2=_xcalloc_link1((unsigned long int)1, (unsigned long int)long_arg_len, "breaker_test_env", 140);
  long_arg2 = (char *)return_value__xcalloc_2;
  memset((void *)long_arg2, 65, (unsigned long int)(long_arg_len - 1));
  envs_arr[(signed long int)0] = long_arg;
  i = 0;
  for( ; !((unsigned long int)i >= 252ul); i = i + 1)
  {
    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(envs[(signed long int)i]);
    env_len = (signed int)return_value_strlen_3;
    if(!(1 + env_len >= -1 + long_arg_len))
    {
      strcpy(long_arg, envs[(signed long int)i]);
      long_arg[(signed long int)env_len] = (char)61;
      memset((void *)(long_arg + (signed long int)env_len + (signed long int)1), 65, (unsigned long int)(((long_arg_len - env_len) - 1) - 1));
      breaker_execute_command(entry, args_arr, envs_arr);
      args_arr[(signed long int)1] = (char *)long_arg2;
      breaker_execute_command(entry, args_arr, envs_arr);
      args_arr[(signed long int)1] = (char *)(void *)0;
    }

  }
  free((void *)long_arg);
  free((void *)long_arg2);
}

// breaker_test_multiplearg
// file breaker.c line 91
static void breaker_test_multiplearg(struct _exec_entry *entry)
{
  char *args[7l] = { (char *)(void *)0, ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL), ((char *)NULL) };
  char *long_arg;
  signed int i;
  signed int j;
  signed int arg_len = 10 * 1024 + 1;
  args[(signed long int)0] = entry->fullname;
  __bfbt_message((enum _msg_type)MSG_TYPE_MESSAGE, "breaker_test_multiplearg", 99, "   * Multiple arguments testing");
  void *return_value__xcalloc_1;
  return_value__xcalloc_1=_xcalloc_link1((unsigned long int)1, (unsigned long int)arg_len, "breaker_test_multiplearg", 100);
  long_arg = (char *)return_value__xcalloc_1;
  memset((void *)long_arg, 65, (unsigned long int)(arg_len - 1));
  args[(signed long int)2] = long_arg;
  args[(signed long int)3] = long_arg;
  args[(signed long int)4] = (char *)(void *)0;
  i = 0;
  for( ; !((unsigned long int)i >= 63ul); i = i + 1)
  {
    args[(signed long int)1] = (char *)args_options[(signed long int)i];
    breaker_execute_command(entry, args, (char **)(void *)0);
  }
  args[(signed long int)2] = long_arg;
  args[(signed long int)4] = long_arg;
  args[(signed long int)5] = (char *)(void *)0;
  i = 0;
  for( ; !((unsigned long int)i >= 63ul); i = i + 1)
  {
    args[(signed long int)1] = (char *)args_options[(signed long int)i];
    j = 0;
    for( ; !((unsigned long int)j >= 63ul); j = j + 1)
    {
      args[(signed long int)3] = (char *)args_options[(signed long int)j];
      breaker_execute_command(entry, args, (char **)(void *)0);
    }
  }
  args[(signed long int)2] = long_arg;
  args[(signed long int)4] = long_arg;
  args[(signed long int)5] = long_arg;
  args[(signed long int)6] = (char *)(void *)0;
  i = 0;
  for( ; !((unsigned long int)i >= 63ul); i = i + 1)
  {
    args[(signed long int)1] = (char *)args_options[(signed long int)i];
    j = 0;
    for( ; !((unsigned long int)j >= 63ul); j = j + 1)
    {
      args[(signed long int)3] = (char *)args_options[(signed long int)j];
      breaker_execute_command(entry, args, (char **)(void *)0);
    }
  }
  args[(signed long int)1] = long_arg;
  args[(signed long int)2] = long_arg;
  args[(signed long int)3] = (char *)(void *)0;
  breaker_execute_command(entry, args, (char **)(void *)0);
  free((void *)long_arg);
  sleep((unsigned int)1);
}

// breaker_test_singlearg
// file breaker.c line 58
static void breaker_test_singlearg(struct _exec_entry *entry)
{
  char *args[4l] = { entry->fullname, (char *)(void *)0, (char *)(void *)0, (char *)(void *)0 };
  char *long_arg;
  signed int i;
  signed int long_arg_len = 50 * 1024 + 1;
  signed int short_arg_len = 5 * 1024 + 1;
  __bfbt_message((enum _msg_type)MSG_TYPE_MESSAGE, "breaker_test_singlearg", 66, "   * Single argument testing");
  void *return_value__xcalloc_1;
  return_value__xcalloc_1=_xcalloc_link1((unsigned long int)1, (unsigned long int)short_arg_len, "breaker_test_singlearg", 67);
  long_arg = (char *)return_value__xcalloc_1;
  memset((void *)long_arg, 65, (unsigned long int)(short_arg_len - 1));
  args[(signed long int)2] = long_arg;
  i = 0;
  for( ; !((unsigned long int)i >= 63ul); i = i + 1)
  {
    args[(signed long int)1] = (char *)args_options[(signed long int)i];
    breaker_execute_command(entry, args, (char **)(void *)0);
  }
  free((void *)long_arg);
  void *return_value__xcalloc_2;
  return_value__xcalloc_2=_xcalloc_link1((unsigned long int)1, (unsigned long int)long_arg_len, "breaker_test_singlearg", 75);
  long_arg = (char *)return_value__xcalloc_2;
  memset((void *)long_arg, 65, (unsigned long int)(long_arg_len - 1));
  args[(signed long int)2] = long_arg;
  i = 0;
  for( ; !((unsigned long int)i >= 63ul); i = i + 1)
  {
    args[(signed long int)1] = (char *)args_options[(signed long int)i];
    breaker_execute_command(entry, args, (char **)(void *)0);
  }
  args[(signed long int)1] = long_arg;
  args[(signed long int)2] = (char *)(void *)0;
  breaker_execute_command(entry, args, (char **)(void *)0);
  free((void *)long_arg);
  sleep((unsigned int)1);
}

// breaker_wait
// file ../../src/include/breaker.h line 30
void breaker_wait(void)
{
  pthread_join(q->run_thread, (void **)(void *)0);
}

// deleteFile
// file tempfiles.c line 192
static void deleteFile(struct _file_entry *entry)
{
  if(!(entry->filename == ((char *)NULL)))
    free((void *)entry->filename);

  free((void *)entry);
}

// env_create
// file ../../src/include/utils.h line 93
char ** env_create(char **env)
{
  signed int i;
  signed int j;
  char **temp;
  char **temp2;
  i = 0;
  temp = env;
  for( ; !(*temp == ((char *)NULL)); i = i + 1)
    temp = temp + 1l;
  temp = environ;
  for( ; !(*temp == ((char *)NULL)); i = i + 1)
    temp = temp + 1l;
  void *return_value__xcalloc_1;
  return_value__xcalloc_1=_xcalloc_link2((unsigned long int)1, (unsigned long int)(i + 1) * sizeof(char *) /*8ul*/ , "env_create", 188);
  temp2 = (char **)return_value__xcalloc_1;
  j = 0;
  temp = env;
  for( ; !(*temp == ((char *)NULL)); temp = temp + 1l)
  {
    temp2[(signed long int)j] = *temp;
    j = j + 1;
  }
  temp = environ;
  signed int return_value_env_not_used_2;
  for( ; !(*temp == ((char *)NULL)); temp = temp + 1l)
  {
    return_value_env_not_used_2=env_not_used(env, *temp);
    if(!(return_value_env_not_used_2 == 0))
    {
      temp2[(signed long int)j] = *temp;
      j = j + 1;
    }

  }
  return temp2;
}

// env_not_used
// file utils.c line 161
static inline signed int env_not_used(char **env, char *str)
{
  signed int len;
  unsigned long int return_value_strcspn_1;
  return_value_strcspn_1=strcspn(str, "=");
  len = (signed int)return_value_strcspn_1;
  char **temp = env;
  signed int return_value_strncmp_2;
  for( ; !(*temp == ((char *)NULL)); temp = temp + 1l)
  {
    return_value_strncmp_2=strncmp(*temp, str, (unsigned long int)len);
    if(return_value_strncmp_2 == 0)
      return (signed int)(1 == 0);

  }
  return (signed int)!(1 == 0);
}

// env_to_str
// file ../../src/include/utils.h line 90
char * env_to_str(char **env)
{
  char **temp;
  char *str;
  signed int i = 0;
  temp = env;
  unsigned long int return_value_strlen_1;
  unsigned long int tmp_if_expr_4;
  unsigned long int return_value_strcspn_2;
  unsigned long int return_value_strlen_3;
  for( ; !(*temp == ((char *)NULL)); temp = temp + 1l)
  {
    return_value_strlen_1=strlen(*temp);
    if(return_value_strlen_1 >= 101ul)
    {
      return_value_strcspn_2=strcspn(*temp, "=");
      tmp_if_expr_4 = return_value_strcspn_2 + (unsigned long int)1 + (sizeof(char [8l]) /*8ul*/  - (unsigned long int)1);
    }

    else
    {
      return_value_strlen_3=strlen(*temp);
      tmp_if_expr_4 = return_value_strlen_3;
    }
    i = i + (signed int)(tmp_if_expr_4 + (unsigned long int)1);
  }
  void *return_value__xcalloc_5;
  return_value__xcalloc_5=_xcalloc_link2((unsigned long int)1, (unsigned long int)i, "env_to_str", 143);
  str = (char *)return_value__xcalloc_5;
  temp = env;
  for( ; !(*temp == ((char *)NULL)); temp = temp + 1l)
  {
    unsigned long int return_value_strlen_8;
    return_value_strlen_8=strlen(*temp);
    if(return_value_strlen_8 >= 101ul)
    {
      char long_env[8l];
      unsigned long int return_value_strcspn_6;
      return_value_strcspn_6=strcspn(*temp, "=");
      i = (signed int)return_value_strcspn_6;
      strncat(str, *temp, (unsigned long int)(i + 1));
      unsigned long int return_value_strlen_7;
      return_value_strlen_7=strlen(*temp + (signed long int)i + (signed long int)1);
      snprintf(long_env, (sizeof(char [8l]) /*8ul*/  - (unsigned long int)1) + (unsigned long int)1, "[%5.5d]", (signed int)return_value_strlen_7);
      strcat(str, long_env);
    }

    else
      strcat(str, *temp);
    if(!(temp[1l] == ((char *)NULL)))
      strcat(str, " ");

  }
  return str;
}

// exec_GetStatus
// file exec.c line 115
static enum _exec_status exec_GetStatus(struct _test_entry *entry)
{
  struct timeval tm;
  signed int return_value_waitpid_1;
  return_value_waitpid_1=waitpid(entry->pid, &entry->status, 1);
  if(return_value_waitpid_1 >= 1)
    return (enum _exec_status)EXEC_STATUS_DONE;

  else
  {
    gettimeofday(&tm, (struct timezone *)(void *)0);
    if(tm.tv_sec + -entry->tm.tv_sec >= 6l)
    {
      exec_kill(entry->pid);
      signed int return_value_waitpid_2;
      return_value_waitpid_2=waitpid(entry->pid, &entry->status, 1);
      if(return_value_waitpid_2 >= 1)
        return (enum _exec_status)EXEC_STATUS_DONE;

    }

    if(tm.tv_sec + -entry->tm.tv_sec >= 41l)
      return (enum _exec_status)EXEC_STATUS_GARBAGE;

    else
      if(tm.tv_sec + -entry->tm.tv_sec >= 21l)
        return (enum _exec_status)EXEC_STATUS_STALE;

      else
        return (enum _exec_status)EXEC_STATUS_NOTDONE;
  }
}

// exec_kill
// file exec.c line 109
static void exec_kill(signed int pid)
{
  kill(-pid, 9);
}

// exec_poll
// file ../../src/include/exec.h line 29
void exec_poll(void)
{
  struct _test_entry *temp;
  struct _test_entry *dead;
  temp = (struct _test_entry *)(void *)0;
  temp=TestEntry_getnext(&temp);
  enum _exec_status return_value_exec_GetStatus_1;
  while(!(temp == ((struct _test_entry *)NULL)))
  {
    return_value_exec_GetStatus_1=exec_GetStatus(temp);
    switch((signed int)return_value_exec_GetStatus_1)
    {
      case EXEC_STATUS_NOTDONE:
      {
        temp=TestEntry_getnext(&temp);
        break;
      }
      case EXEC_STATUS_DONE:
        exec_process_close(temp);
      case EXEC_STATUS_GARBAGE:
      {
        dead = temp;
        temp=TestEntry_getnext(&temp);
        TestEntry_remove(dead);
        TestEntry_destroy(dead);
      }
      case EXEC_STATUS_STALE:

      default:
        ;
    }
  }
}

// exec_process_close
// file exec.c line 139
static void exec_process_close(struct _test_entry *entry)
{
  q->current_execs = q->current_execs - 1;
  _Bool tmp_if_expr_1;
  if(!((0x7f & entry->status) == 0))
  {
    if((signed int)((127 & (signed char)entry->status) + 1) >> 1 >= 1)
    {
      /* tag-#anon#lUN[lS32'__in'||S32'__i'|] */
union anonymous_6
{
  // __in
  signed int __in;
  // __i
  signed int __i;
};

/* */
      ;
      if((0x7f & entry->status) == 9)
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = (((union anonymous_6){ .__in=entry->status }).__i & 0x7f) == 13 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
        goto __CPROVER_DUMP_L5;

      struct _crash_report *report;
      report=CrashReport_add(entry);
      CrashReport_log(report);
    }

    else
      __bfbt_message((enum _msg_type)MSG_TYPE_ERROR_WARN, "exec_process_close", 158, "%s ended in unknown condition, status=%d", entry->progname, entry->status);
  }


__CPROVER_DUMP_L5:
  ;
}

// execute_program
// file ../../src/include/exec.h line 26
signed int execute_program(struct _exec_entry *exec_entry, char **args, char **env)
{
  struct _test_entry *test_entry;
  if(args == ((char **)NULL))
    return -1;

  else
    if(q->current_execs >= q->max_execs)
    {
      __bfbt_message((enum _msg_type)MSG_TYPE_DEBUG_L1, "execute_program", 63, "Hit maximum execs");
      return -1;
    }

    else
    {
      test_entry=TestEntry_create(exec_entry, args, env);
      test_entry->pid=fork();
      if(!(test_entry->pid == -1))
      {
        if(test_entry->pid == 0)
          goto __CPROVER_DUMP_L4;

      }

      else
      {
        __bfbt_message((enum _msg_type)MSG_TYPE_ERROR_WARN, "execute_program", 71, "Couldn't fork process");
        TestEntry_destroy(test_entry);
        return 1;

      __CPROVER_DUMP_L4:
        ;
        signed int pgid;
        pgid=getpid();
        signed int return_value_setpgid_1;
        return_value_setpgid_1=setpgid(pgid, pgid);
        if(!(return_value_setpgid_1 == 0))
          __bfbt_message((enum _msg_type)MSG_TYPE_ERRNO_WARN, "execute_program", 81, "Couldn't set process group");

        close(0);
        close(1);
        close(2);
        execve(test_entry->progname, test_entry->args, test_entry->env);
        __bfbt_message((enum _msg_type)MSG_TYPE_ERRNO_WARN, "execute_program", 94, "execve '%s'", test_entry->progname);
        _exit(2);
      }
      gettimeofday(&test_entry->tm, (struct timezone *)(void *)0);
      TestEntry_insert(test_entry);
      q->current_execs = q->current_execs + 1;
      return 0;
    }
}

// find_exec_in_path
// file ../../src/include/utils.h line 84
char * find_exec_in_path(char *name)
{
  char *str;
  char *buf;
  char *last;
  char *path;
  path=getenv("PATH");
  char filename[4096l];
  _Bool tmp_if_expr_1;
  if(!(name == ((char *)NULL)))
    tmp_if_expr_1 = (signed int)name[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  /* assertion name != ((void *)0) && name[0] != '\0' */
  assert(tmp_if_expr_1);
  if(!(path == ((char *)NULL)))
  {
    buf=strdup(path);
    if(buf == ((char *)NULL))
      __bfbt_message((enum _msg_type)MSG_TYPE_ERROR_ABORT, "find_exec_in_path", 81, "out of memory");

    str=strtok_r(buf, ":", &last);
    while(!(str == ((char *)NULL)))
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(str);
      signed int return_value_snprintf_3;
      return_value_snprintf_3=snprintf(filename, sizeof(char [4096l]) /*4096ul*/ , "%s%s%s", str, (signed int)str[(signed long int)(return_value_strlen_2 - (unsigned long int)1)] == 47 ? "" : "/", name);
      if(!((unsigned long int)return_value_snprintf_3 >= sizeof(char [4096l]) /*4096ul*/ ))
      {
        signed int return_value_access_5;
        return_value_access_5=access(filename, 0 | 1);
        if(return_value_access_5 == 0)
        {
          free((void *)buf);
          char *return_value_strdup_4;
          return_value_strdup_4=strdup(filename);
          return return_value_strdup_4;
        }

      }

      str=strtok_r((char *)(void *)0, ":", &last);
    }
    free((void *)buf);
  }

  return (char *)(void *)0;
}

// isNew
// file tempfiles.c line 84
static signed int isNew(struct dirent *entry)
{
  struct _file_entry *entries = head;
  for( ; !(entries == ((struct _file_entry *)NULL)); entries = entries->next)
    if((unsigned long int)entries->fileno >= entry->d_ino)
      break;

  _Bool tmp_if_expr_1;
  if(!(entries == ((struct _file_entry *)NULL)))
    tmp_if_expr_1 = (unsigned long int)entries->fileno == entry->d_ino ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
    return (signed int)(1 == 0);

  else
    return (signed int)!(1 == 0);
}

// load_execs
// file bfbtester.c line 213
static void load_execs(char **av, enum _exec_entry_status status, signed int flags, char *rejects)
{
  struct stat sb;
  char *filename;
  char *pwd;
  pwd=getenv("PWD");
  _Bool tmp_if_expr_4;
  unsigned long int return_value_strlen_1;
  unsigned long int return_value_strlen_2;
  void *return_value__xmalloc_3;
  _Bool tmp_if_expr_7;
  unsigned long int return_value_strlen_5;
  signed int return_value_sprintf_6;
  _Bool tmp_if_expr_9;
  signed int return_value_access_8;
  _Bool tmp_if_expr_13;
  signed int return_value_stat_12;
  _Bool tmp_if_expr_15;
  signed int return_value_access_14;
  for( ; !(*av == ((char *)NULL)); av = av + 1l)
  {
    if((signed int)*(*av) == 47)
      filename=strdup(*av);

    else
    {
      if(!(pwd == ((char *)NULL)))
      {
        return_value_strlen_1=strlen(pwd);
        return_value_strlen_2=strlen(*av);
        return_value__xmalloc_3=_xmalloc(return_value_strlen_1 + return_value_strlen_2 + (unsigned long int)2, "load_execs", 243);
        filename = (char *)return_value__xmalloc_3;
        tmp_if_expr_4 = filename != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_4 = (_Bool)0;
      if(tmp_if_expr_4)
      {
        return_value_strlen_5=strlen(pwd);
        return_value_sprintf_6=sprintf(filename, "%s%s%s", pwd, (signed int)pwd[(signed long int)(return_value_strlen_5 - (unsigned long int)1)] == 47 ? "" : "/", *av);
        tmp_if_expr_7 = return_value_sprintf_6 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_7 = (_Bool)0;
      if(tmp_if_expr_7)
      {
        return_value_access_8=access(filename, 0 | 1);
        tmp_if_expr_9 = return_value_access_8 == 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_9 = (_Bool)0;
      if(!tmp_if_expr_9)
        filename=find_exec_in_path(*av);

    }
    if(!(filename == ((char *)NULL)))
    {
      return_value_stat_12=stat(filename, &sb);
      tmp_if_expr_13 = return_value_stat_12 == 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_13 = (_Bool)0;
    if(tmp_if_expr_13)
    {
      return_value_access_14=access(filename, 0 | 1);
      tmp_if_expr_15 = return_value_access_14 == 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_15 = (_Bool)0;
    if(tmp_if_expr_15)
    {
      if((61440u & sb.st_mode) == 16384u)
      {
        struct __dirstream *dir;
        struct dirent entry;
        struct dirent *result;
        signed int ret;
        char fname[4096l];
        dir=opendir(filename);
        if(dir == ((struct __dirstream *)NULL))
        {
          __bfbt_message((enum _msg_type)MSG_TYPE_ERROR_WARN, "load_execs", 262, "Can't open dir %s", filename);
          free((void *)filename);
          goto __CPROVER_DUMP_L25;
        }

        ret=readdir_r(dir, &entry, &result);
        while(ret == 0 && !(result == ((struct dirent *)NULL)))
        {
          unsigned long int return_value_strlen_10;
          return_value_strlen_10=strlen(filename);
          signed int return_value_snprintf_11;
          return_value_snprintf_11=snprintf(fname, sizeof(char [4096l]) /*4096ul*/ , "%s%s%s", filename, (signed int)filename[(signed long int)(return_value_strlen_10 - (unsigned long int)1)] == 47 ? "" : "/", (const void *)result->d_name);
          if(!((unsigned long int)return_value_snprintf_11 >= sizeof(char [4096l]) /*4096ul*/ ))
            add_exec(fname, status, flags, rejects);

          ret=readdir_r(dir, &entry, &result);
        }
      }

      else
        add_exec(filename, status, flags, rejects);
    }

    else
      if(!(filename == ((char *)NULL)))
        __bfbt_message((enum _msg_type)MSG_TYPE_ERROR_WARN, "load_execs", 279, "Can't access file: %s (%s)", filename, *av);

      else
        __bfbt_message((enum _msg_type)MSG_TYPE_ERROR_WARN, "load_execs", 281, "Can't find file: %s", *av);
    if(!(filename == ((char *)NULL)))
      free((void *)filename);


  __CPROVER_DUMP_L25:
    ;
  }
}

// main
// file bfbtester.c line 64
signed int main(signed int ac, char **av)
{
  char *progname;
  char *rejects = (char *)(void *)0;
  signed int t_on = (signed int)(1 == 0);
  signed int max_execs = 250;
  signed int ch;
  signed int flags = 0;
  progname=strrchr(av[(signed long int)0], 47);
  if(!(progname == ((char *)NULL)))
    progname = progname + 1l;

  else
    progname = av[(signed long int)0];
  do
  {
    ch=getopt(ac, av, "ad:ehmo:r:stvx:");
    if(ch == -1)
      break;

    switch(ch)
    {
      case 97:
      {
        flags = flags | 1 << 0 | 1 << 1 | 1 << 2;
        break;
      }
      case 100:
      {
        debug_level=atoi(optarg);
        break;
      }
      case 101:
      {
        flags = flags | 1 << 2;
        break;
      }
      case 104:
      {
        usage(progname);
        break;
      }
      case 109:
      {
        flags = flags | 1 << 1;
        break;
      }
      case 111:
      {
        fp_msg=fopen(optarg, "w");
        if(fp_msg == ((struct _IO_FILE *)NULL))
        {
          printf("Can't open output file: %s\n", optarg);
          return -1;
        }

        break;
      }
      case 114:
      {
        rejects = optarg;
        break;
      }
      case 115:
      {
        flags = flags | 1 << 0;
        break;
      }
      case 116:
      {
        t_on = (signed int)!(1 == 0);
        break;
      }
      case 118:
      {
        printf("%s v. %s\n", (const void *)"BFBTester: Brute Force Binary Tester", (const void *)"2.0.1");
        return 0;
      }
      case 120:
      {
        max_execs=atoi(optarg);
        break;
      }
      default:
        usage(progname);
    }
  }
  while((_Bool)1);
  ac = ac - optind;
  av = av + (signed long int)optind;
  if(fp_msg == ((struct _IO_FILE *)NULL))
    fp_msg = stdout;

  _Bool tmp_if_expr_1;
  if(flags == 0)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = *av == (char *)(void *)0 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    usage(progname);

  void *return_value__xcalloc_2;
  return_value__xcalloc_2=_xcalloc((unsigned long int)1, sizeof(struct _thread_data) /*40ul*/ , "main", 128);
  q = (struct _thread_data *)return_value__xcalloc_2;
  q->max_execs = max_execs;
  void *return_value__xmalloc_3;
  return_value__xmalloc_3=_xmalloc(sizeof(union anonymous_4) /*40ul*/ , "main", 130);
  q->mut = (union anonymous_4 *)return_value__xmalloc_3;
  signed int return_value_pthread_mutex_init_4;
  return_value_pthread_mutex_init_4=pthread_mutex_init(q->mut, (const union anonymous_1 *)(void *)0);
  if(!(return_value_pthread_mutex_init_4 == 0))
    __bfbt_message((enum _msg_type)MSG_TYPE_ERRNO_ABORT, "main", 133, "mutex init");

  if(!(t_on == 0))
    tempfile_start(q);

  load_execs(av, (enum _exec_entry_status)EXEC_ENTRY_STATUS_TEST, flags, rejects);
  run_breaker();
  return 0;
}

// removeFile
// file tempfiles.c line 167
static void removeFile(struct _file_entry *entry)
{
  _Bool tmp_if_expr_1;
  if(!(entry->prev == ((struct _file_entry *)NULL)))
    tmp_if_expr_1 = entry->next != ((struct _file_entry *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
  {
    entry->prev->next = entry->next;
    entry->next->prev = entry->prev;
  }

  else
    if(head == entry)
    {
      if(!(entry->next == ((struct _file_entry *)NULL)))
        entry->next->prev = (struct _file_entry *)(void *)0;

      else
        tail = (struct _file_entry *)(void *)0;
      head = entry->next;
    }

    else
    {
      entry->prev->next = (struct _file_entry *)(void *)0;
      tail = entry->prev;
    }
  if(!(request.remove_cb == ((void (*)(char *, struct stat *, void *))NULL)) && !(request.count == 0) && (request.status == 2 || request.status == 3))
    request.remove_cb(entry->filename, &entry->sb, request.cb_data);

}

// run_breaker
// file bfbtester.c line 289
static void run_breaker(void)
{
  signed int return_value_ExecEntry_isempty_1;
  return_value_ExecEntry_isempty_1=ExecEntry_isempty();
  if(return_value_ExecEntry_isempty_1 == 0)
  {
    breaker_start();
    breaker_wait();
  }

}

// tempfile_request_add
// file ../../src/include/tempfiles.h line 28
signed int tempfile_request_add(void (*create)(char *, struct stat *, void *), void (*remove)(char *, struct stat *, void *), void *cbdata)
{
  if(initialized == 0)
    return 0;

  else
  {
    pthread_mutex_lock(&request.mutex);
    if(!(request.count == 0) || !(request.status == 0))
      return -1;

    else
    {
      request.count = 1;
      request.status = 1;
      pthread_cond_signal(&request.cond);
      while(request.status == 1)
        pthread_cond_wait(&request.cond, &request.mutex);
      request.create_cb = create;
      request.remove_cb = remove;
      request.cb_data = cbdata;
      pthread_mutex_unlock(&request.mutex);
      return 0;
    }
  }
}

// tempfile_request_shutdown
// file tempfiles.c line 249
static void tempfile_request_shutdown(void)
{
  request.status = 0;
  pthread_cond_signal(&request.cond);
}

// tempfile_request_startup
// file tempfiles.c line 241
static void tempfile_request_startup(void)
{
  request.status = 2;
  pthread_cond_signal(&request.cond);
}

// tempfile_request_subtract
// file ../../src/include/tempfiles.h line 31
signed int tempfile_request_subtract(void)
{
  if(initialized == 0)
    return 0;

  else
  {
    pthread_mutex_unlock(&request.mutex);
    if(request.count == 0 || !(request.status == 2))
      return -1;

    else
    {
      request.status = 3;
      while(request.status == 3)
        pthread_cond_wait(&request.cond, &request.mutex);
      request.count = request.count - 1;
      request.create_cb = (void (*)(char *, struct stat *, void *))(void *)0;
      request.remove_cb = (void (*)(char *, struct stat *, void *))(void *)0;
      request.cb_data = (void *)0;
      pthread_mutex_unlock(&request.mutex);
      return 0;
    }
  }
}

// tempfile_scandir
// file tempfiles.c line 209
static void tempfile_scandir(struct __dirstream *dir)
{
  struct dirent entry;
  struct dirent *result;
  signed int ret;
  struct timeval tm;
  struct _file_entry *temp;
  struct _file_entry *dead;
  gettimeofday(&tm, (struct timezone *)(void *)0);
  ret=readdir_r(dir, &entry, &result);
  while(ret == 0 && !(result == ((struct dirent *)NULL)))
  {
    AddOrUpdate(result, tm);
    ret=readdir_r(dir, &entry, &result);
  }
  if(ret == 0)
  {
    temp = head;
    while(!(temp == ((struct _file_entry *)NULL)))
    {
      signed int return_value_memcmp_1;
      return_value_memcmp_1=memcmp((const void *)&temp->tm, (const void *)&tm, sizeof(struct timeval) /*16ul*/ );
      if(!(return_value_memcmp_1 == 0))
      {
        dead = temp;
        temp = temp->next;
        removeFile(dead);
        deleteFile(dead);
      }

      else
        temp = temp->next;
    }
  }

  rewinddir(dir);
}

// tempfile_start
// file ../../src/include/tempfiles.h line 34
void tempfile_start(struct _thread_data *data)
{
  signed int return_value_pthread_create_1;
  return_value_pthread_create_1=pthread_create(&data->tempfile_thread, (const union pthread_attr_t *)(void *)0, tempfile_watch, (void *)0);
  if(!(return_value_pthread_create_1 == 0))
    __bfbt_message((enum _msg_type)MSG_TYPE_ERRNO_ABORT, "tempfile_start", 341, "tempfile thread create");

}

// tempfile_watch
// file tempfiles.c line 257
static void * tempfile_watch(void *data)
{
  char *dirname;
  struct __dirstream *dir;
  signed int lasttime = 0;
  dirname=getenv("BFBT_TMPDIR");
  if(dirname == ((char *)NULL))
    dirname = "/tmp";

  initialized = (signed int)!(1 == 0);
  dir=opendir(dirname);
  if(dir == ((struct __dirstream *)NULL))
    __bfbt_message((enum _msg_type)MSG_TYPE_ERROR_ABORT, "tempfile_watch", 269, "opendir: %s failed", dirname);

  while((_Bool)1)
  {
    tempfile_scandir(dir);
    pthread_mutex_lock(&request.mutex);
    if(request.status == 1 || request.status == 3)
    {
      if(request.status == 1)
      {
        if(!(lasttime == 0))
        {
          tempfile_request_startup();
          lasttime = 0;
        }

        else
          lasttime = 1;
      }

      else
        if(!(lasttime == 0))
        {
          tempfile_request_shutdown();
          lasttime = 0;
        }

        else
          lasttime = 1;
    }

    else
      while(request.status == 0)
        pthread_cond_wait(&request.cond, &request.mutex);
    pthread_mutex_unlock(&request.mutex);
    pthread_testcancel();
  }
  return (void *)0;
}

// updateFile
// file tempfiles.c line 149
static void updateFile(struct dirent *entry, struct timeval tm)
{
  struct _file_entry *temp = head;
  for( ; !((unsigned long int)temp->fileno == entry->d_ino); temp = temp->next)
    ;
  temp->tm = tm;
}

// usage
// file bfbtester.c line 163
static void usage(char *progname)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(progname);
  printf("%s [-htv] [-d level ] [-r rejects] [-o out-file]\n%*s [-x max-execs] -asme file [file2 file3 ...]\nMust specify one or more of the following tests:\n    -s\tSingle Argument Test\n    -m\tMultiple Argument Test\n    -e\tEnvironment Variable Test\n    -a\tSelects all tests\nOptions:\n    -h  Print this message\n    -t  Enable tempfile monitoring\n    -v  Print version string\n    -d level     Set debug level (default = 0, max = 2)\n    -r rejects   Comma separated list of binaries to skip\n    -o out-file  Output to out-file rather than stdout\n    -x max-execs Set maximum executables to run in parallel (default = %d)\nfile    Specific binary or a directory of binaries to test\n", progname, (signed int)return_value_strlen_1, (const void *)"", 250);
  exit(2);
}

