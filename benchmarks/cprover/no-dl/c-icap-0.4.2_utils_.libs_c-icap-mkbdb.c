// #anon_enum_DB_BACKUP_READ_COUNT=1_DB_BACKUP_READ_SLEEP=2_DB_BACKUP_SIZE=3_DB_BACKUP_WRITE_DIRECT=4
// file /usr/include/db.h line 2269
enum anonymous_14 { DB_BACKUP_READ_COUNT=1, DB_BACKUP_READ_SLEEP=2, DB_BACKUP_SIZE=3, DB_BACKUP_WRITE_DIRECT=4 };

// #anon_enum_DB_BTREE=1_DB_HASH=2_DB_HEAP=6_DB_RECNO=3_DB_QUEUE=4_DB_UNKNOWN=5
// file /usr/include/db.h line 1292
enum anonymous_17 { DB_BTREE=1, DB_HASH=2, DB_HEAP=6, DB_RECNO=3, DB_QUEUE=4, DB_UNKNOWN=5 };

// #anon_enum_DB_LOCK_DUMP=0_DB_LOCK_GET=1_DB_LOCK_GET_TIMEOUT=2_DB_LOCK_INHERIT=3_DB_LOCK_PUT=4_DB_LOCK_PUT_ALL=5_DB_LOCK_PUT_OBJ=6_DB_LOCK_PUT_READ=7_DB_LOCK_TIMEOUT=8_DB_LOCK_TRADE=9_DB_LOCK_UPGRADE_WRITE=10
// file /usr/include/db.h line 325
enum anonymous_25 { DB_LOCK_DUMP=0, DB_LOCK_GET=1, DB_LOCK_GET_TIMEOUT=2, DB_LOCK_INHERIT=3, DB_LOCK_PUT=4, DB_LOCK_PUT_ALL=5, DB_LOCK_PUT_OBJ=6, DB_LOCK_PUT_READ=7, DB_LOCK_TIMEOUT=8, DB_LOCK_TRADE=9, DB_LOCK_UPGRADE_WRITE=10 };

// #anon_enum_DB_LOCK_NG=0_DB_LOCK_READ=1_DB_LOCK_WRITE=2_DB_LOCK_WAIT=3_DB_LOCK_IWRITE=4_DB_LOCK_IREAD=5_DB_LOCK_IWR=6_DB_LOCK_READ_UNCOMMITTED=7_DB_LOCK_WWRITE=8
// file /usr/include/db.h line 310
enum anonymous_16 { DB_LOCK_NG=0, DB_LOCK_READ=1, DB_LOCK_WRITE=2, DB_LOCK_WAIT=3, DB_LOCK_IWRITE=4, DB_LOCK_IREAD=5, DB_LOCK_IWR=6, DB_LOCK_READ_UNCOMMITTED=7, DB_LOCK_WWRITE=8 };

// #anon_enum_DB_MEM_LOCK=1_DB_MEM_LOCKOBJECT=2_DB_MEM_LOCKER=3_DB_MEM_LOGID=4_DB_MEM_TRANSACTION=5_DB_MEM_THREAD=6
// file /usr/include/db.h line 2257
enum anonymous_15 { DB_MEM_LOCK=1, DB_MEM_LOCKOBJECT=2, DB_MEM_LOCKER=3, DB_MEM_LOGID=4, DB_MEM_TRANSACTION=5, DB_MEM_THREAD=6 };

// #anon_enum_DB_PRIORITY_UNCHANGED=0_DB_PRIORITY_VERY_LOW=1_DB_PRIORITY_LOW=2_DB_PRIORITY_DEFAULT=3_DB_PRIORITY_HIGH=4_DB_PRIORITY_VERY_HIGH=5
// file /usr/include/db.h line 618
enum anonymous_7 { DB_PRIORITY_UNCHANGED=0, DB_PRIORITY_VERY_LOW=1, DB_PRIORITY_LOW=2, DB_PRIORITY_DEFAULT=3, DB_PRIORITY_HIGH=4, DB_PRIORITY_VERY_HIGH=5 };

// #anon_enum_DB_TXN_ABORT=0_DB_TXN_APPLY=1_DB_TXN_BACKWARD_ROLL=3_DB_TXN_FORWARD_ROLL=4_DB_TXN_OPENFILES=5_DB_TXN_POPENFILES=6_DB_TXN_PRINT=7_DB_TXN_LOG_VERIFY=8
// file /usr/include/db.h line 794
enum anonymous_13 { DB_TXN_ABORT=0, DB_TXN_APPLY=1, DB_TXN_BACKWARD_ROLL=3, DB_TXN_FORWARD_ROLL=4, DB_TXN_OPENFILES=5, DB_TXN_POPENFILES=6, DB_TXN_PRINT=7, DB_TXN_LOG_VERIFY=8 };

// #anon_enum_LOGREC_Done=0_LOGREC_ARG=1_LOGREC_HDR=2_LOGREC_DATA=3_LOGREC_DB=4_LOGREC_DBOP=5_LOGREC_DBT=6_LOGREC_LOCKS=7_LOGREC_OP=8_LOGREC_PGDBT=9_LOGREC_PGDDBT=10_LOGREC_PGLIST=11_LOGREC_POINTER=12_LOGREC_TIME=13
// file /usr/include/db.h line 584
enum anonymous_24 { LOGREC_Done=0, LOGREC_ARG=1, LOGREC_HDR=2, LOGREC_DATA=3, LOGREC_DB=4, LOGREC_DBOP=5, LOGREC_DBT=6, LOGREC_LOCKS=7, LOGREC_OP=8, LOGREC_PGDBT=9, LOGREC_PGDDBT=10, LOGREC_PGLIST=11, LOGREC_POINTER=12, LOGREC_TIME=13 };

// tag-#anon#ST[*{S8}_S8_'TEMPLATE_NAME'|*{S8}_S8_'SERVICE_NAME'|*{S8}_S8_'LANGUAGE'|*{SYM#tag-ci_membuf#}_SYM#tag-ci_membuf#_'data'|S64'last_used'|S64'loaded'|S64'modified'|S32'locked'|S32'must_free'|S32'non_cached'|U32'_pad0']
// file txtTemplate.c line 42
struct anonymous_22;

// tag-#anon#ST[*{SYM#tag-#anon#UN[ARR32{S8}_S8_'__size'|S64'__align']#}_SYM#tag-#anon#UN[ARR32{S8}_S8_'__size'|S64'__align']#_'sem']
// file include/proc_mutex.h line 74
struct anonymous_3;

// tag-#anon#ST[*{SYM#tag-__db#}_SYM#tag-__db#_'le_next'|*{*{SYM#tag-__db#}_SYM#tag-__db#_}_*{SYM#tag-__db#}_SYM#tag-__db#__'le_prev']
// file /usr/include/db.h line 1548
struct anonymous_20;

// tag-#anon#ST[*{SYM#tag-__db#}_SYM#tag-__db#_'lh_first']
// file /usr/include/db.h line 1532
struct anonymous_19;

// tag-#anon#ST[*{SYM#tag-__db#}_SYM#tag-__db#_'tqe_next'|*{*{SYM#tag-__db#}_SYM#tag-__db#_}_*{SYM#tag-__db#}_SYM#tag-__db#__'tqe_prev']
// file /usr/include/db.h line 1496
struct anonymous_18;

// tag-#anon#ST[*{SYM#tag-__db_foreign_info#}_SYM#tag-__db_foreign_info#_'lh_first']
// file /usr/include/db.h line 1575
struct anonymous_21;

// tag-#anon#ST[*{SYM#tag-__db_mpoolfile#}_SYM#tag-__db_mpoolfile#_'tqe_next'|*{*{SYM#tag-__db_mpoolfile#}_SYM#tag-__db_mpoolfile#_}_*{SYM#tag-__db_mpoolfile#}_SYM#tag-__db_mpoolfile#__'tqe_prev']
// file /usr/include/db.h line 644
struct anonymous_6;

// tag-#anon#ST[*{SYM#tag-__db_txn#}_SYM#tag-__db_txn#_'tqe_next'|*{*{SYM#tag-__db_txn#}_SYM#tag-__db_txn#_}_*{SYM#tag-__db_txn#}_SYM#tag-__db_txn#__'tqe_prev']
// file /usr/include/db.h line 832
struct anonymous_8;

// tag-#anon#ST[*{SYM#tag-__dbc#}_SYM#tag-__dbc#_'tqe_next'|*{*{SYM#tag-__dbc#}_SYM#tag-__dbc#_}_*{SYM#tag-__dbc#}_SYM#tag-__dbc#__'tqe_prev']
// file /usr/include/db.h line 2027
struct anonymous_23;

// tag-#anon#ST[*{SYM#tag-__txn_event#}_SYM#tag-__txn_event#_'tqh_first'|*{*{SYM#tag-__txn_event#}_SYM#tag-__txn_event#_}_*{SYM#tag-__txn_event#}_SYM#tag-__txn_event#__'tqh_last']
// file /usr/include/db.h line 864
struct anonymous_10;

// tag-#anon#ST[*{SYM#tag-__txn_logrec#}_SYM#tag-__txn_logrec#_'stqh_first'|*{*{SYM#tag-__txn_logrec#}_SYM#tag-__txn_logrec#_}_*{SYM#tag-__txn_logrec#}_SYM#tag-__txn_logrec#__'stqh_last']
// file /usr/include/db.h line 874
struct anonymous_11;

// tag-#anon#ST[ARR16{S64}_S64_'fds_bits']
// file /usr/include/x86_64-linux-gnu/sys/select.h line 64
struct anonymous_26;

// tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}_V_'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_33;

// tag-#anon#ST[S32'__lock'|U32'__nr_readers'|U32'__readers_wakeup'|U32'__writer_wakeup'|U32'__nr_readers_queued'|U32'__nr_writers_queued'|S32'__writer'|S32'__shared'|S8'__rwelision'|ARR7{U8}_U8_'__pad1'|U64'__pad2'|U32'__flags'|U32'_pad0']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 177
struct anonymous_36;

// tag-#anon#ST[S32'fd']
// file include/proc_mutex.h line 79
struct anonymous_5;

// tag-#anon#ST[S32'id']
// file include/proc_mutex.h line 69
struct anonymous_2;

// tag-#anon#ST[S64'stqe_next'|S64'stqe_prev']
// file /usr/include/db.h line 844
struct anonymous_9;

// tag-#anon#UN[*{SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}_S8_'__size'|S64'__align']#}_SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}_S8_'__size'|S64'__align']#_'mutex'|*{SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__nr_readers'|U32'__readers_wakeup'|U32'__writer_wakeup'|U32'__nr_readers_queued'|U32'__nr_writers_queued'|S32'__writer'|S32'__shared'|S8'__rwelision'|ARR7{U8}_U8_'__pad1'|U64'__pad2'|U32'__flags'|U32'_pad0']#'__data'|ARR56{S8}_S8_'__size'|S64'__align']#}_SYM#tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__nr_readers'|U32'__readers_wakeup'|U32'__writer_wakeup'|U32'__nr_readers_queued'|U32'__nr_writers_queued'|S32'__writer'|S32'__shared'|S8'__rwelision'|ARR7{U8}_U8_'__pad1'|U64'__pad2'|U32'__flags'|U32'_pad0']#'__data'|ARR56{S8}_S8_'__size'|S64'__align']#_'rwlock']
// file os/unix/threads.c line 30
union anonymous_38;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'|ARR8{U16}_U16_'__u6_addr16'|ARR4{U32}_U32_'__u6_addr32']
// file /usr/include/netinet/in.h line 211
union anonymous;

// tag-#anon#UN[ARR32{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 239
union anonymous_29;

// tag-#anon#UN[ARR4{S8}_S8_'__size'|S32'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_32;

// tag-#anon#UN[ARR8{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 224
union anonymous_35;

// tag-#anon#UN[F64'__align'|ARR1{S8}_S8_'ptr']
// file mem.c line 100
union anonymous_0;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__futex'|U64'__total_seq'|U64'__wakeup_seq'|U64'__woken_seq'|*{V}_V_'__mutex'|U32'__nwaiters'|U32'__broadcast_seq']#'__data'|ARR48{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_34;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'|U32'__nr_readers'|U32'__readers_wakeup'|U32'__writer_wakeup'|U32'__nr_readers_queued'|U32'__nr_writers_queued'|S32'__writer'|S32'__shared'|S8'__rwelision'|ARR7{U8}_U8_'__pad1'|U64'__pad2'|U32'__flags'|U32'_pad0']#'__data'|ARR56{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 174
union anonymous_37;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'id']#'sysv'|SYM#tag-#anon#ST[*{SYM#tag-#anon#UN[ARR32{S8}_S8_'__size'|S64'__align']#}_SYM#tag-#anon#UN[ARR32{S8}_S8_'__size'|S64'__align']#_'sem']#'posix'|SYM#tag-#anon#ST[S32'fd']#'file']
// file include/proc_mutex.h line 67
union anonymous_30;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}_S8_'__size'|S64'__align']
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_4;

// tag-#anon#UN[SYM#tag-ci_proc_mutex#'proc_mutex'|SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'|ARR40{S8}_S8_'__size'|S64'__align']#'thread_mutex']
// file cache.c line 90
union anonymous_1;

// tag-#anon#UN[SYM#tag-posix#'posix'|SYM#tag-sysv#'sysv'|S32'id_']
// file include/shared_mem.h line 58
union anonymous_31;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'|r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__']
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_28;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'|r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'|r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'|r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'|r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'|r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'|r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'|r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'|r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'|r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'|r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'|r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'|r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__']_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_27;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 156
struct _IO_marker;

// tag-__channel
// file /usr/include/db.h line 151
struct __channel;

// tag-__cq_aq
// file /usr/include/db.h line 1514
struct __cq_aq;

// tag-__cq_fq
// file /usr/include/db.h line 1510
struct __cq_fq;

// tag-__cq_jq
// file /usr/include/db.h line 1518
struct __cq_jq;

// tag-__db
// file /usr/include/db.h line 152
struct __db;

// tag-__db_channel
// file /usr/include/db.h line 154
struct __db_channel;

// tag-__db_compact
// file /usr/include/db.h line 156
struct __db_compact;

// tag-__db_dbt
// file /usr/include/db.h line 157
struct __db_dbt;

// tag-__db_env
// file /usr/include/db.h line 159
struct __db_env;

// tag-__db_foreign_info
// file /usr/include/db.h line 1576
struct __db_foreign_info;

// tag-__db_ilock
// file /usr/include/db.h line 163
struct __db_ilock;

// tag-__db_lock_stat
// file /usr/include/db.h line 166
struct __db_lock_stat;

// tag-__db_lock_u
// file /usr/include/db.h line 167
struct __db_lock_u;

// tag-__db_locker
// file /usr/include/db.h line 168
struct __db_locker;

// tag-__db_lockreq
// file /usr/include/db.h line 169
struct __db_lockreq;

// tag-__db_log_cursor
// file /usr/include/db.h line 172
struct __db_log_cursor;

// tag-__db_log_stat
// file /usr/include/db.h line 173
struct __db_log_stat;

// tag-__db_logvrfy_config
// file /usr/include/db.h line 207
struct __db_logvrfy_config;

// tag-__db_lsn
// file /usr/include/db.h line 174
struct __db_lsn;

// tag-__db_mpool_fstat
// file /usr/include/db.h line 176
struct __db_mpool_fstat;

// tag-__db_mpool_stat
// file /usr/include/db.h line 177
struct __db_mpool_stat;

// tag-__db_mpoolfile
// file /usr/include/db.h line 178
struct __db_mpoolfile;

// tag-__db_mutex_stat
// file /usr/include/db.h line 179
struct __db_mutex_stat;

// tag-__db_preplist
// file /usr/include/db.h line 182
struct __db_preplist;

// tag-__db_rep_stat
// file /usr/include/db.h line 185
struct __db_rep_stat;

// tag-__db_repmgr_site
// file /usr/include/db.h line 188
struct __db_repmgr_site;

// tag-__db_repmgr_stat
// file /usr/include/db.h line 189
struct __db_repmgr_stat;

// tag-__db_site
// file /usr/include/db.h line 192
struct __db_site;

// tag-__db_thread_info
// file /usr/include/db.h line 194
struct __db_thread_info;

// tag-__db_txn
// file /usr/include/db.h line 195
struct __db_txn;

// tag-__db_txn_active
// file /usr/include/db.h line 196
struct __db_txn_active;

// tag-__db_txn_stat
// file /usr/include/db.h line 197
struct __db_txn_stat;

// tag-__db_txn_token
// file /usr/include/db.h line 198
struct __db_txn_token;

// tag-__db_txnmgr
// file /usr/include/db.h line 199
struct __db_txnmgr;

// tag-__dbc
// file /usr/include/db.h line 200
struct __dbc;

// tag-__dbc_internal
// file /usr/include/db.h line 201
struct __dbc_internal;

// tag-__env
// file /usr/include/db.h line 202
struct __env;

// tag-__femfs
// file /usr/include/db.h line 906
struct __femfs;

// tag-__fh_t
// file /usr/include/db.h line 203
struct __fh_t;

// tag-__fname
// file /usr/include/db.h line 204
struct __fname;

// tag-__key_range
// file /usr/include/db.h line 205
struct __key_range;

// tag-__kids
// file /usr/include/db.h line 854
struct __kids;

// tag-__log_rec_spec
// file /usr/include/db.h line 601
struct __log_rec_spec;

// tag-__mpoolfile
// file /usr/include/db.h line 206
struct __mpoolfile;

// tag-__my_cursors
// file /usr/include/db.h line 894
struct __my_cursors;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-__txn_event
// file /usr/include/db.h line 865
struct __txn_event;

// tag-__txn_logrec
// file /usr/include/db.h line 875
struct __txn_logrec;

// tag-_ci_align_test
// file include/c-icap.h line 131
struct _ci_align_test;

// tag-acl_cmp_uint64_data
// file acl.c line 175
struct acl_cmp_uint64_data;

// tag-acl_time_data
// file acl.c line 264
struct acl_time_data;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-check_reg_data
// file registry.c line 102
struct check_reg_data;

// tag-ci_MD5Context
// file include/md5.h line 6
struct ci_MD5Context;

// tag-ci_access_entry
// file include/acl.h line 143
struct ci_access_entry;

// tag-ci_acl_data
// file include/acl.h line 96
struct ci_acl_data;

// tag-ci_acl_regex
// file types_ops.c line 227
struct ci_acl_regex;

// tag-ci_acl_spec
// file include/acl.h line 111
struct ci_acl_spec;

// tag-ci_acl_type
// file include/acl.h line 47
struct ci_acl_type;

// tag-ci_acl_type_list
// file include/acl.h line 81
struct ci_acl_type_list;

// tag-ci_array
// file include/array.h line 54
struct ci_array;

// tag-ci_array_item
// file include/array.h line 37
struct ci_array_item;

// tag-ci_buf
// file include/request.h line 60
struct ci_buf;

// tag-ci_cache
// file include/cache.h line 35
struct ci_cache;

// tag-ci_cache_entry
// file cache.c line 78
struct ci_cache_entry;

// tag-ci_cache_type
// file include/cache.h line 42
struct ci_cache_type;

// tag-ci_cached_file
// file include/body.h line 78
struct ci_cached_file;

// tag-ci_conf_entry
// file include/cfg_param.h line 85
struct ci_conf_entry;

// tag-ci_connection
// file include/net_io.h line 107
struct ci_connection;

// tag-ci_data_group
// file include/filetype.h line 49
struct ci_data_group;

// tag-ci_data_type
// file include/filetype.h line 43
struct ci_data_type;

// tag-ci_dyn_array
// file include/array.h line 309
struct ci_dyn_array;

// tag-ci_encaps_entity
// file include/header.h line 82
struct ci_encaps_entity;

// tag-ci_error_code
// file include/c-icap.h line 153
struct ci_error_code;

// tag-ci_fmt_entry
// file include/txt_format.h line 41
struct ci_fmt_entry;

// tag-ci_hash_entry
// file include/hash.h line 32
struct ci_hash_entry;

// tag-ci_hash_table
// file include/hash.h line 40
struct ci_hash_table;

// tag-ci_headers_list
// file include/header.h line 71
struct ci_headers_list;

// tag-ci_ip
// file include/net_io.h line 101
struct ci_ip;

// tag-ci_list
// file include/array.h line 598
struct ci_list;

// tag-ci_list_item
// file include/array.h line 585
struct ci_list_item;

// tag-ci_local_cache_data
// file cache.c line 96
struct ci_local_cache_data;

// tag-ci_lookup_table
// file include/lookup_table.h line 43
struct ci_lookup_table;

// tag-ci_lookup_table_type
// file include/lookup_table.h line 44
struct ci_lookup_table_type;

// tag-ci_magic
// file include/filetype.h line 55
struct ci_magic;

// tag-ci_magic_record
// file filetype.c line 57
struct ci_magic_record;

// tag-ci_magics_db
// file include/cfg_param.h line 30
struct ci_magics_db;

// tag-ci_mem_allocator
// file ../include/mem.h line 32
struct ci_mem_allocator;

// tag-ci_membuf
// file include/body.h line 44
struct ci_membuf;

// tag-ci_options_entry
// file ../include/cfg_param.h line 109
struct ci_options_entry;

// tag-ci_proc_mutex
// file include/proc_mutex.h line 44
struct ci_proc_mutex;

// tag-ci_proc_mutex_scheme
// file include/proc_mutex.h line 46
struct ci_proc_mutex_scheme;

// tag-ci_regex_match
// file include/ci_regex.h line 32
struct ci_regex_match;

// tag-ci_regex_replace_part
// file include/ci_regex.h line 37
struct ci_regex_replace_part;

// tag-ci_request
// file include/service.h line 62
struct ci_request;

// tag-ci_ring_buf
// file include/body.h line 161
struct ci_ring_buf;

// tag-ci_server_conf
// file include/cfg_param.h line 46
struct ci_server_conf;

// tag-ci_service_module
// file include/service.h line 64
struct ci_service_module;

// tag-ci_service_xdata
// file include/service.h line 76
struct ci_service_xdata;

// tag-ci_shared_mem_id
// file include/shared_mem.h line 35
struct ci_shared_mem_id;

// tag-ci_shared_mem_scheme
// file include/shared_mem.h line 37
struct ci_shared_mem_scheme;

// tag-ci_simple_file
// file include/body.h line 114
struct ci_simple_file;

// tag-ci_sockaddr
// file include/net_io.h line 50
struct ci_sockaddr;

// tag-ci_specs_list
// file include/acl.h line 121
struct ci_specs_list;

// tag-ci_type_ops
// file ../include/types_ops.h line 31
struct ci_type_ops;

// tag-ci_vector
// file include/array.h line 448
struct ci_vector;

// tag-common_mutex
// file cache.c line 88
struct common_mutex;

// tag-flock
// file /usr/include/x86_64-linux-gnu/bits/fcntl.h line 35
struct flock;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-internal_state
// file /usr/include/zlib.h line 83
struct internal_state;

// tag-ipc_perm
// file /usr/include/x86_64-linux-gnu/bits/ipc.h line 42
struct ipc_perm;

// tag-kbs
// file include/stats.h line 31
struct kbs;

// tag-linger
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 383
struct linger;

// tag-mem_block_item
// file mem.c line 760
struct mem_block_item;

// tag-mem_buffer_block
// file mem.c line 97
struct mem_buffer_block;

// tag-mutex_itm
// file os/unix/threads.c line 23
struct mutex_itm;

// tag-pack_allocator
// file mem.c line 573
struct pack_allocator;

// tag-pcre_extra
// file /usr/include/pcre.h line 376
struct pcre_extra;

// tag-pool_allocator
// file mem.c line 765
struct pool_allocator;

// tag-posix
// file include/shared_mem.h line 60
struct posix;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-real_pcre
// file /usr/include/pcre.h line 324
struct real_pcre;

// tag-sembuf
// file /usr/include/x86_64-linux-gnu/sys/sem.h line 41
struct sembuf;

// tag-semid_ds
// file /usr/include/x86_64-linux-gnu/bits/sem.h line 38
struct semid_ds;

// tag-seminfo
// file /usr/include/x86_64-linux-gnu/bits/sem.h line 72
struct seminfo;

// tag-semun
// file os/unix/proc_mutex.c line 47
union semun;

// tag-serial_allocator
// file mem.c line 445
struct serial_allocator;

// tag-shmid_ds
// file /usr/include/x86_64-linux-gnu/bits/shm.h line 49
struct shmid_ds;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 153
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-stat_area
// file include/stats.h line 45
struct stat_area;

// tag-stat_entry
// file include/stats.h line 52
struct stat_entry;

// tag-stat_entry_list
// file include/stats.h line 58
struct stat_entry_list;

// tag-stat_groups_list
// file include/stats.h line 64
struct stat_groups_list;

// tag-stat_memblock
// file include/stats.h line 37
struct stat_memblock;

// tag-sysv
// file include/shared_mem.h line 65
struct sysv;

// tag-text_table
// file lookup_file_table.c line 49
struct text_table;

// tag-text_table_entry
// file lookup_file_table.c line 43
struct text_table_entry;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-z_stream_s
// file /usr/include/zlib.h line 85
struct z_stream_s;

#include <assert.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

// MD5Transform
// file md5.c line 168
static void MD5Transform(unsigned int *buf, unsigned int *in);
// __assert_fail
// file /usr/include/assert.h line 69
extern void __assert_fail(const char *, const char *, unsigned int, const char *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __intl_free_object
//
void __intl_free_object(void *);
// __intl_malloc_object
//
void * __intl_malloc_object(signed int);
// __log_error_object
//
void __log_error_object(void *, const char *, ...);
// _os_free
// file request_common.c line 35
static void _os_free(void *ptr);
// _os_malloc
// file request_common.c line 30
static void * _os_malloc(signed int size);
// acl_cmp_uint64_dup
// file acl.c line 182
void * acl_cmp_uint64_dup(const char *str, struct ci_mem_allocator *allocator);
// acl_cmp_uint64_equal
// file acl.c line 187
signed int acl_cmp_uint64_equal(const void *key1, const void *key2);
// acl_cmp_uint64_free
// file acl.c line 202
void acl_cmp_uint64_free(void *key, struct ci_mem_allocator *allocator);
// acl_load_defaults
// file acl.c line 776
static signed int acl_load_defaults();
// acl_time_dup
// file acl.c line 270
void * acl_time_dup(const char *str, struct ci_mem_allocator *allocator);
// acl_time_equal
// file acl.c line 373
signed int acl_time_equal(const void *key1, const void *key2);
// acl_time_free
// file acl.c line 389
void acl_time_free(void *tmd, struct ci_mem_allocator *allocator);
// add_mutex
// file os/unix/threads.c line 66
static struct mutex_itm * add_mutex(void *pmutex, signed int type);
// alloc_a_buffer
// file decode.c line 198
static void * alloc_a_buffer(void *op, unsigned int items, unsigned int size);
// alloc_mem_allocator_struct
// file mem.c line 79
static struct ci_mem_allocator * alloc_mem_allocator_struct();
// alloc_text_table_entry
// file lookup_file_table.c line 55
struct text_table_entry * alloc_text_table_entry(signed int val_num, struct ci_mem_allocator *allocator);
// asctime_r
// file /usr/include/time.h line 272
extern char * asctime_r(struct tm *, char *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous_27, unsigned int);
// byteReverse
// file md5.c line 28
static void byteReverse(unsigned char *buf, unsigned int longs);
// cfg_set_type
// file c-icap-mkbdb.c line 285
signed int cfg_set_type(const char *directive, const char **argv, void *setdata);
// check_ascii
// file filetype.c line 419
signed int check_ascii(unsigned char *buf, signed int buflen);
// check_directive
// file txt_format.c line 200
signed int check_directive(const char *var, const char *directive, signed int *directive_len);
// check_magics
// file filetype.c line 368
signed int check_magics(struct ci_magics_db *db, const char *buf, signed int buflen);
// check_realloc
// file request_common.c line 874
static signed int check_realloc(char **buf, signed int *size, signed int used, signed int mustadded);
// check_reg
// file registry.c line 108
static signed int check_reg(void *data, const char *name, const void *val);
// check_tables
// file txt_format.c line 218
struct ci_fmt_entry * check_tables(const char *var, struct ci_fmt_entry *u_table, signed int *directive_len, unsigned int *width, signed int *left_align, char *parameter);
// check_unicode
// file filetype.c line 495
signed int check_unicode(unsigned char *buf, signed int buflen);
// ci_MD5Final
// file md5.c line 107
void ci_MD5Final(unsigned char *digest, struct ci_MD5Context *ctx);
// ci_MD5Init
// file md5.c line 44
void ci_MD5Init(struct ci_MD5Context *ctx);
// ci_MD5Update
// file md5.c line 59
void ci_MD5Update(struct ci_MD5Context *ctx, const unsigned char *buf, unsigned long int len);
// ci_access_entry_add_acl
// file acl.c line 468
const struct ci_acl_spec * ci_access_entry_add_acl(struct ci_access_entry *access_entry, const struct ci_acl_spec *acl, signed int negate);
// ci_access_entry_add_acl_by_name
// file acl.c line 492
signed int ci_access_entry_add_acl_by_name(struct ci_access_entry *access_entry, const char *acl_name);
// ci_access_entry_match_request
// file acl.c line 751
signed int ci_access_entry_match_request(struct ci_access_entry *access_entry, struct ci_request *req);
// ci_access_entry_new
// file acl.c line 419
struct ci_access_entry * ci_access_entry_new(struct ci_access_entry **list, signed int type);
// ci_access_entry_release
// file acl.c line 445
void ci_access_entry_release(struct ci_access_entry *list);
// ci_acl_add_data
// file acl.c line 824
signed int ci_acl_add_data(const char *name, const char *type, const char *data);
// ci_acl_init
// file acl.c line 796
void ci_acl_init();
// ci_acl_reset
// file acl.c line 803
void ci_acl_reset();
// ci_acl_search
// file acl.c line 811
const struct ci_acl_spec * ci_acl_search(const char *name);
// ci_acl_spec_list_release
// file acl.c line 615
void ci_acl_spec_list_release(struct ci_acl_spec *spec);
// ci_acl_spec_new
// file acl.c line 514
struct ci_acl_spec * ci_acl_spec_new(const char *name, const char *type, const char *param, struct ci_acl_type_list *list, struct ci_acl_spec **spec_list);
// ci_acl_spec_new_data
// file acl.c line 552
struct ci_acl_data * ci_acl_spec_new_data(struct ci_acl_spec *spec, const char *val);
// ci_acl_spec_release
// file acl.c line 601
void ci_acl_spec_release(struct ci_acl_spec *cur);
// ci_acl_spec_search
// file acl.c line 583
struct ci_acl_spec * ci_acl_spec_search(struct ci_acl_spec *list, const char *name);
// ci_acl_type_add
// file acl.c line 819
signed int ci_acl_type_add(const struct ci_acl_type *type);
// ci_acl_type_search
// file acl.c line 815
const struct ci_acl_type * ci_acl_type_search(const char *name);
// ci_acl_typelist_add
// file acl.c line 638
signed int ci_acl_typelist_add(struct ci_acl_type_list *list, const struct ci_acl_type *type);
// ci_acl_typelist_init
// file acl.c line 630
signed int ci_acl_typelist_init(struct ci_acl_type_list *list);
// ci_acl_typelist_release
// file acl.c line 681
signed int ci_acl_typelist_release(struct ci_acl_type_list *list);
// ci_acl_typelist_reset
// file acl.c line 689
signed int ci_acl_typelist_reset(struct ci_acl_type_list *list);
// ci_acl_typelist_search
// file acl.c line 671
const struct ci_acl_type * ci_acl_typelist_search(struct ci_acl_type_list *list, const char *name);
// ci_args_apply
// file ../include/cfg_param.h line 200
signed int ci_args_apply(signed int argc, char **argv, struct ci_options_entry *options);
// ci_args_usage
// file ../include/cfg_param.h line 199
void ci_args_usage(const char *progname, struct ci_options_entry *options);
// ci_array_add
// file include/array.h line 118
const struct ci_array_item * ci_array_add(struct ci_array *array, const char *name, const void *value, unsigned long int size);
// ci_array_destroy
// file include/array.h line 107
void ci_array_destroy(struct ci_array *array);
// ci_array_get_item
// file array.c line 144
const struct ci_array_item * ci_array_get_item(struct ci_array *array, signed int pos);
// ci_array_iterate
// file array.c line 116
void ci_array_iterate(const struct ci_array *array, void *data, signed int (*fn)(void *, const char *, const void *));
// ci_array_iterate::fn_object
//
signed int fn_object(void *, const char *, const void *);
// ci_array_new
// file include/array.h line 90
struct ci_array * ci_array_new(unsigned long int size);
// ci_array_new2
// file array.c line 60
struct ci_array * ci_array_new2(unsigned long int items, unsigned long int item_size);
// ci_array_pop
// file array.c line 125
const struct ci_array_item * ci_array_pop(struct ci_array *array);
// ci_array_search
// file include/array.h line 135
const void * ci_array_search(struct ci_array *array, const char *name);
// ci_atol_ext
// file util.c line 78
signed long int ci_atol_ext(const char *str, const char **error);
// ci_base64_decode
// file decode.c line 54
signed int ci_base64_decode(const char *encoded, char *decoded, signed int len);
// ci_base64_decode_dup
// file decode.c line 88
char * ci_base64_decode_dup(const char *encoded);
// ci_base64_encode
// file decode.c line 111
signed int ci_base64_encode(const unsigned char *data, unsigned long int len, char *out, unsigned long int outlen);
// ci_belongs_to_group
// file filetype.c line 153
signed int ci_belongs_to_group(struct ci_magics_db *db, signed int type, signed int group);
// ci_buf_init
// file request_common.c line 45
void ci_buf_init(struct ci_buf *buf);
// ci_buf_mem_alloc
// file request_common.c line 56
signed int ci_buf_mem_alloc(struct ci_buf *buf, signed int size);
// ci_buf_mem_free
// file request_common.c line 65
void ci_buf_mem_free(struct ci_buf *buf);
// ci_buf_reset
// file request_common.c line 52
void ci_buf_reset(struct ci_buf *buf);
// ci_buf_reset_size
// file request_common.c line 83
signed int ci_buf_reset_size(struct ci_buf *buf, signed int req_size);
// ci_buf_write
// file request_common.c line 74
signed int ci_buf_write(struct ci_buf *buf, char *data, signed int len);
// ci_buffer_alloc
// file include/mem.h line 66
void * ci_buffer_alloc(signed int block_size);
// ci_buffer_blocksize
// file mem.c line 204
unsigned long int ci_buffer_blocksize(const void *data);
// ci_buffer_free
// file include/mem.h line 68
void ci_buffer_free(void *data);
// ci_buffer_realloc
// file include/mem.h line 67
void * ci_buffer_realloc(void *data, signed int block_size);
// ci_buffers_destroy
// file mem.c line 166
void ci_buffers_destroy();
// ci_buffers_init
// file mem.c line 112
signed int ci_buffers_init();
// ci_cache_build
// file cache.c line 387
struct ci_cache * ci_cache_build(const char *name, const char *cache_type, unsigned int cache_size, unsigned int max_object_size, signed int ttl, const struct ci_type_ops *key_ops);
// ci_cache_destroy
// file cache.c line 47
void ci_cache_destroy(struct ci_cache *cache);
// ci_cache_read_vector_val
// file cache.c line 492
void * ci_cache_read_vector_val(const void *val, unsigned long int val_size, void *o);
// ci_cache_search
// file cache.c line 53
const void * ci_cache_search(struct ci_cache *cache, const void *key, void **val, void *data, void * (*dup_from_cache)(const void *, unsigned long int, void *));
// ci_cache_search::dup_from_cache_object
//
void * dup_from_cache_object(const void *, unsigned long int, void *);
// ci_cache_store_vector_size
// file cache.c line 432
unsigned long int ci_cache_store_vector_size(struct ci_vector *v);
// ci_cache_store_vector_val
// file cache.c line 453
void * ci_cache_store_vector_val(void *buf, const void *val, unsigned long int buf_size);
// ci_cache_type_get
// file cache.c line 42
static const struct ci_cache_type * ci_cache_type_get(const char *name);
// ci_cache_type_register
// file cache.c line 37
void ci_cache_type_register(struct ci_cache_type *type);
// ci_cache_update
// file cache.c line 58
signed int ci_cache_update(struct ci_cache *cache, const void *key, const void *val, unsigned long int val_size, void * (*copy_to_cache)(void *, const void *, unsigned long int));
// ci_cache_update::copy_to_cache_object
//
void * copy_to_cache_object(void *, const void *, unsigned long int);
// ci_cached_file_destroy
// file body.c line 423
void ci_cached_file_destroy(struct ci_cached_file *body);
// ci_cached_file_new
// file body.c line 360
struct ci_cached_file * ci_cached_file_new(signed int size);
// ci_cached_file_read
// file body.c line 520
signed int ci_cached_file_read(struct ci_cached_file *body, char *buf, signed int len);
// ci_cached_file_release
// file body.c line 442
void ci_cached_file_release(struct ci_cached_file *body);
// ci_cached_file_reset
// file body.c line 398
void ci_cached_file_reset(struct ci_cached_file *body, signed int new_size);
// ci_cached_file_write
// file body.c line 461
signed int ci_cached_file_write(struct ci_cached_file *body, const char *buf, signed int len, signed int iseof);
// ci_cfg_alloc_mem
// file cfg_lib.c line 44
void * ci_cfg_alloc_mem(signed int size);
// ci_cfg_disable
// file cfg_lib.c line 192
signed int ci_cfg_disable(const char *directive, const char **argv, void *setdata);
// ci_cfg_enable
// file ../include/cfg_param.h line 185
signed int ci_cfg_enable(const char *directive, const char **argv, void *setdata);
// ci_cfg_lib_init
// file ../include/cfg_param.h line 150
void ci_cfg_lib_init();
// ci_cfg_lib_reset
// file cfg_lib.c line 39
void ci_cfg_lib_reset();
// ci_cfg_onoff
// file cfg_lib.c line 169
signed int ci_cfg_onoff(const char *directive, const char **argv, void *setdata);
// ci_cfg_set_int
// file ../include/cfg_param.h line 164
signed int ci_cfg_set_int(const char *directive, const char **argv, void *setdata);
// ci_cfg_set_str
// file ../include/cfg_param.h line 158
signed int ci_cfg_set_str(const char *directive, const char **argv, void *setdata);
// ci_cfg_size_long
// file cfg_lib.c line 245
signed int ci_cfg_size_long(const char *directive, const char **argv, void *setdata);
// ci_cfg_size_off
// file cfg_lib.c line 213
signed int ci_cfg_size_off(const char *directive, const char **argv, void *setdata);
// ci_client_connect_to
// file request_common.c line 984
struct ci_connection * ci_client_connect_to(char *servername, signed int port, signed int proto);
// ci_client_get_server_options
// file request_common.c line 962
signed int ci_client_get_server_options(struct ci_request *req, signed int timeout);
// ci_client_http_headers_completed
// file request_common.c line 1422
signed int ci_client_http_headers_completed(struct ci_request *req);
// ci_client_icapfilter
// file request_common.c line 1303
signed int ci_client_icapfilter(struct ci_request *req, signed int timeout, struct ci_headers_list *req_headers, struct ci_headers_list *resp_headers, void *data_source, signed int (*source_read)(void *, char *, signed int), void *data_dest, signed int (*dest_write)(void *, char *, signed int));
// ci_client_icapfilter::dest_write_object
//
signed int dest_write_object(void *, char *, signed int);
// ci_client_icapfilter::source_read_object
//
signed int source_read_object(void *, char *, signed int);
// ci_client_request
// file request_common.c line 662
struct ci_request * ci_client_request(struct ci_connection *conn, char *server, char *service);
// ci_client_request_reuse
// file request_common.c line 679
void ci_client_request_reuse(struct ci_request *req);
// ci_connection_destroy
// file net_io.c line 191
void ci_connection_destroy(struct ci_connection *connection);
// ci_copy_connection
// file net_io.c line 162
void ci_copy_connection(struct ci_connection *dest, struct ci_connection *src);
// ci_copy_sockaddr
// file net_io.c line 68
void ci_copy_sockaddr(struct ci_sockaddr *dest, struct ci_sockaddr *src);
// ci_create_os_allocator
// file ../include/mem.h line 47
struct ci_mem_allocator * ci_create_os_allocator();
// ci_create_pack_allocator
// file mem.c line 687
struct ci_mem_allocator * ci_create_pack_allocator(char *memblock, unsigned long int size);
// ci_create_pack_allocator_on_memblock
// file mem.c line 704
struct ci_mem_allocator * ci_create_pack_allocator_on_memblock(char *memblock, unsigned long int size);
// ci_create_pool_allocator
// file mem.c line 888
struct ci_mem_allocator * ci_create_pool_allocator(signed int items_size);
// ci_create_serial_allocator
// file include/mem.h line 48
struct ci_mem_allocator * ci_create_serial_allocator(signed int size);
// ci_dyn_array_add
// file array.c line 269
const struct ci_array_item * ci_dyn_array_add(struct ci_dyn_array *array, const char *name, const void *value, unsigned long int size);
// ci_dyn_array_destroy
// file array.c line 260
void ci_dyn_array_destroy(struct ci_dyn_array *array);
// ci_dyn_array_iterate
// file array.c line 329
void ci_dyn_array_iterate(const struct ci_dyn_array *array, void *data, signed int (*fn)(void *, const char *, const void *));
// ci_dyn_array_iterate::fn_object
//
signed int fn_object(void *, const char *, const void *);
// ci_dyn_array_new
// file array.c line 212
struct ci_dyn_array * ci_dyn_array_new(unsigned long int size);
// ci_dyn_array_new2
// file array.c line 225
struct ci_dyn_array * ci_dyn_array_new2(unsigned long int items, unsigned long int item_size);
// ci_dyn_array_search
// file array.c line 317
const void * ci_dyn_array_search(struct ci_dyn_array *array, const char *name);
// ci_extend_filetype
// file filetype.c line 661
signed int ci_extend_filetype(struct ci_magics_db *db, struct ci_request *req, const char *buf, signed int len, signed int *iscompressed);
// ci_filetype
// file filetype.c line 541
signed int ci_filetype(struct ci_magics_db *db, const char *buf, signed int buflen);
// ci_fill_ip_t
// file net_io.c line 75
void ci_fill_ip_t(struct ci_ip *ip_dest, struct ci_sockaddr *src);
// ci_fill_sockaddr
// file include/net_io.h line 115
void ci_fill_sockaddr(struct ci_sockaddr *addr);
// ci_format_text
// file txt_format.c line 240
signed int ci_format_text(struct ci_request *req_data, const char *fmt, char *buffer, signed int len, struct ci_fmt_entry *user_table);
// ci_get_data_group_id
// file filetype.c line 143
signed int ci_get_data_group_id(struct ci_magics_db *db, const char *group);
// ci_get_data_type_id
// file filetype.c line 133
signed int ci_get_data_type_id(struct ci_magics_db *db, const char *name);
// ci_hard_close
// file os/unix/net_io.c line 359
signed int ci_hard_close(signed int fd);
// ci_hash_add
// file include/hash.h line 54
void * ci_hash_add(struct ci_hash_table *htable, const void *key, const void *val);
// ci_hash_build
// file include/hash.h line 49
struct ci_hash_table * ci_hash_build(unsigned int hash_size, const struct ci_type_ops *ops, struct ci_mem_allocator *allocator);
// ci_hash_compute
// file include/hash.h line 48
unsigned int ci_hash_compute(unsigned long int hash_max_value, const void *key, signed int len);
// ci_hash_destroy
// file include/hash.h line 52
void ci_hash_destroy(struct ci_hash_table *htable);
// ci_hash_search
// file include/hash.h line 53
const void * ci_hash_search(struct ci_hash_table *htable, const void *key);
// ci_headers_add
// file header.c line 220
const char * ci_headers_add(struct ci_headers_list *h, const char *line);
// ci_headers_addheaders
// file header.c line 269
signed int ci_headers_addheaders(struct ci_headers_list *h, const struct ci_headers_list *headers);
// ci_headers_copy_value
// file header.c line 343
const char * ci_headers_copy_value(struct ci_headers_list *h, const char *header, char *buf, unsigned long int len);
// ci_headers_create
// file header.c line 156
struct ci_headers_list * ci_headers_create();
// ci_headers_destroy
// file header.c line 186
void ci_headers_destroy(struct ci_headers_list *h);
// ci_headers_iterate
// file header.c line 424
signed int ci_headers_iterate(struct ci_headers_list *h, void *data, void (*fn)(void *, const char *, const char *));
// ci_headers_iterate::fn_object
//
void fn_object(void *, const char *, const char *);
// ci_headers_pack
// file header.c line 451
void ci_headers_pack(struct ci_headers_list *h);
// ci_headers_remove
// file header.c line 369
signed int ci_headers_remove(struct ci_headers_list *h, const char *header);
// ci_headers_replace
// file header.c line 414
const char * ci_headers_replace(struct ci_headers_list *h, const char *header, const char *newval);
// ci_headers_reset
// file header.c line 213
void ci_headers_reset(struct ci_headers_list *h);
// ci_headers_search
// file header.c line 318
const char * ci_headers_search(struct ci_headers_list *h, const char *header);
// ci_headers_setsize
// file header.c line 195
signed int ci_headers_setsize(struct ci_headers_list *h, signed int size);
// ci_headers_unpack
// file header.c line 478
signed int ci_headers_unpack(struct ci_headers_list *h);
// ci_headers_value
// file header.c line 328
const char * ci_headers_value(struct ci_headers_list *h, const char *header);
// ci_host_to_sockaddr_t
// file include/net_io.h line 136
signed int ci_host_to_sockaddr_t(const char *servername, struct ci_sockaddr *addr, signed int proto);
// ci_http_client_ip
// file simple_api.c line 301
const struct ci_ip * ci_http_client_ip(struct ci_request *req);
// ci_http_content_length
// file simple_api.c line 207
signed long int ci_http_content_length(struct ci_request *req);
// ci_http_request
// file simple_api.c line 234
const char * ci_http_request(struct ci_request *req);
// ci_http_request_add_header
// file simple_api.c line 152
const char * ci_http_request_add_header(struct ci_request *req, const char *header);
// ci_http_request_create
// file simple_api.c line 119
signed int ci_http_request_create(struct ci_request *req, signed int has_body);
// ci_http_request_get_header
// file simple_api.c line 195
const char * ci_http_request_get_header(struct ci_request *req, const char *head_name);
// ci_http_request_headers
// file simple_api.c line 52
struct ci_headers_list * ci_http_request_headers(struct ci_request *req);
// ci_http_request_remove_header
// file simple_api.c line 173
signed int ci_http_request_remove_header(struct ci_request *req, const char *header);
// ci_http_request_reset_headers
// file simple_api.c line 79
signed int ci_http_request_reset_headers(struct ci_request *req);
// ci_http_request_url
// file simple_api.c line 257
signed int ci_http_request_url(struct ci_request *req, char *buf, signed int buf_size);
// ci_http_response_add_header
// file simple_api.c line 141
const char * ci_http_response_add_header(struct ci_request *req, const char *header);
// ci_http_response_create
// file simple_api.c line 96
signed int ci_http_response_create(struct ci_request *req, signed int has_reshdr, signed int has_body);
// ci_http_response_get_header
// file simple_api.c line 184
const char * ci_http_response_get_header(struct ci_request *req, const char *head_name);
// ci_http_response_headers
// file simple_api.c line 39
struct ci_headers_list * ci_http_response_headers(struct ci_request *req);
// ci_http_response_remove_header
// file simple_api.c line 162
signed int ci_http_response_remove_header(struct ci_request *req, const char *header);
// ci_http_response_reset_headers
// file simple_api.c line 70
signed int ci_http_response_reset_headers(struct ci_request *req);
// ci_icap_add_xheader
// file simple_api.c line 246
const char * ci_icap_add_xheader(struct ci_request *req, const char *header);
// ci_icap_append_xheaders
// file simple_api.c line 251
signed int ci_icap_append_xheaders(struct ci_request *req, struct ci_headers_list *headers);
// ci_inet_aton
// file include/net_io.h line 119
signed int ci_inet_aton(signed int af, const char *cp, void *addr);
// ci_inet_ntoa
// file include/net_io.h line 120
const char * ci_inet_ntoa(signed int af, const void *src, char *dst, signed int cnt);
// ci_internal_time
// file cache.c line 32
signed long int ci_internal_time();
// ci_linger_close
// file os/unix/net_io.c line 338
signed int ci_linger_close(signed int fd, signed int timeout);
// ci_list_cmp_handler
// file array.c line 536
void ci_list_cmp_handler(struct ci_list *list, signed int (*cmp_func)(const void *, const void *, unsigned long int));
// ci_list_cmp_handler::cmp_func_object
//
signed int cmp_func_object(const void *, const void *, unsigned long int);
// ci_list_copy_handler
// file array.c line 546
void ci_list_copy_handler(struct ci_list *list, signed int (*copy_func)(void *, const void *));
// ci_list_copy_handler::copy_func_object
//
signed int copy_func_object(void *, const void *);
// ci_list_create
// file array.c line 507
struct ci_list * ci_list_create(unsigned long int init_size, unsigned long int obj_size);
// ci_list_destroy
// file array.c line 530
void ci_list_destroy(struct ci_list *list);
// ci_list_free_handler
// file array.c line 541
void ci_list_free_handler(struct ci_list *list, void (*free_func)(void *));
// ci_list_free_handler::free_func_object
//
void free_func_object(void *);
// ci_list_iterate
// file array.c line 551
void ci_list_iterate(struct ci_list *list, void *data, signed int (*fn)(void *, const void *));
// ci_list_iterate::fn_object
//
signed int fn_object(void *, const void *);
// ci_list_pop
// file array.c line 617
void * ci_list_pop(struct ci_list *list, void *data);
// ci_list_pop_back
// file array.c line 647
void * ci_list_pop_back(struct ci_list *list, void *data);
// ci_list_push
// file array.c line 589
const void * ci_list_push(struct ci_list *list, const void *data);
// ci_list_push_back
// file array.c line 603
const void * ci_list_push_back(struct ci_list *list, const void *data);
// ci_list_remove
// file array.c line 690
signed int ci_list_remove(struct ci_list *list, const void *obj);
// ci_list_remove::1::cmp_func_object
//
signed int cmp_func_object(const void *, const void *, unsigned long int);
// ci_list_search
// file array.c line 723
const void * ci_list_search(struct ci_list *list, const void *data);
// ci_list_search2
// file array.c line 742
const void * ci_list_search2(struct ci_list *list, const void *data, signed int (*cmp_func)(const void *, const void *, unsigned long int));
// ci_list_search2::cmp_func_object
//
signed int cmp_func_object(const void *, const void *, unsigned long int);
// ci_list_search::1::cmp_func_object
//
signed int cmp_func_object(const void *, const void *, unsigned long int);
// ci_list_sort
// file array.c line 752
void ci_list_sort(struct ci_list *list);
// ci_list_sort2
// file array.c line 766
void ci_list_sort2(struct ci_list *list, signed int (*cmp_func)(const void *, const void *, unsigned long int));
// ci_list_sort2::cmp_func_object
//
signed int cmp_func_object(const void *, const void *, unsigned long int);
// ci_list_sort::1::cmp_func_object
//
signed int cmp_func_object(const void *, const void *, unsigned long int);
// ci_local_cache_destroy
// file cache.c line 217
void ci_local_cache_destroy(struct ci_cache *cache);
// ci_local_cache_init
// file cache.c line 135
signed int ci_local_cache_init(struct ci_cache *cache, const char *name);
// ci_local_cache_search
// file cache.c line 238
const void * ci_local_cache_search(struct ci_cache *cache, const void *key, void **val, void *data, void * (*dup_from_cache)(const void *, unsigned long int, void *));
// ci_local_cache_search::dup_from_cache_object
//
void * dup_from_cache_object(const void *, unsigned long int, void *);
// ci_local_cache_update
// file cache.c line 277
signed int ci_local_cache_update(struct ci_cache *cache, const void *key, const void *val, unsigned long int val_size, void * (*copy_to_cache)(void *, const void *, unsigned long int));
// ci_local_cache_update::copy_to_cache_object
//
void * copy_to_cache_object(void *, const void *, unsigned long int);
// ci_lookup_table_create
// file lookup_table.c line 144
struct ci_lookup_table * ci_lookup_table_create(const char *table);
// ci_lookup_table_create_ext
// file lookup_table.c line 69
struct ci_lookup_table * ci_lookup_table_create_ext(const char *table, const struct ci_type_ops *key_ops, const struct ci_type_ops *val_ops, struct ci_mem_allocator *allocator);
// ci_lookup_table_destroy
// file lookup_table.c line 158
void ci_lookup_table_destroy(struct ci_lookup_table *lt);
// ci_lookup_table_get_row
// file lookup_table.c line 228
const char * ci_lookup_table_get_row(struct ci_lookup_table *table, const char *key, const char **columns, char ***vals);
// ci_lookup_table_open
// file lookup_table.c line 172
void * ci_lookup_table_open(struct ci_lookup_table *table);
// ci_lookup_table_release_result
// file lookup_table.c line 196
void ci_lookup_table_release_result(struct ci_lookup_table *table, void **val);
// ci_lookup_table_search
// file lookup_table.c line 181
const char * ci_lookup_table_search(struct ci_lookup_table *table, const char *key, char ***vals);
// ci_lookup_table_type_register
// file lookup_table.c line 36
struct ci_lookup_table_type * ci_lookup_table_type_register(struct ci_lookup_table_type *lt_type);
// ci_lookup_table_type_search
// file lookup_table.c line 58
struct ci_lookup_table_type * ci_lookup_table_type_search(const char *type);
// ci_lookup_table_type_unregister
// file lookup_table.c line 46
void ci_lookup_table_type_unregister(struct ci_lookup_table_type *lt_type);
// ci_magic_data_type
// file filetype.c line 711
signed int ci_magic_data_type(const char *buf, signed int len);
// ci_magic_data_type_ext
// file filetype.c line 720
signed int ci_magic_data_type_ext(struct ci_headers_list *headers, const char *buf, signed int len, signed int *iscompressed);
// ci_magic_db_free
// file filetype.c line 685
void ci_magic_db_free();
// ci_magic_db_load
// file filetype.c line 674
struct ci_magics_db * ci_magic_db_load(const char *filename);
// ci_magic_group_check
// file filetype.c line 745
signed int ci_magic_group_check(signed int type, signed int group);
// ci_magic_group_id
// file filetype.c line 737
signed int ci_magic_group_id(const char *group);
// ci_magic_group_name
// file filetype.c line 783
char * ci_magic_group_name(signed int group);
// ci_magic_groups_count
// file filetype.c line 760
signed int ci_magic_groups_count();
// ci_magic_req_data_type
// file filetype.c line 694
signed int ci_magic_req_data_type(struct ci_request *req, signed int *isencoded);
// ci_magic_type_descr
// file filetype.c line 774
char * ci_magic_type_descr(signed int type);
// ci_magic_type_id
// file filetype.c line 729
signed int ci_magic_type_id(const char *name);
// ci_magic_type_name
// file filetype.c line 765
char * ci_magic_type_name(signed int type);
// ci_magic_types_count
// file filetype.c line 754
signed int ci_magic_types_count();
// ci_magics_db_build
// file filetype.c line 358
struct ci_magics_db * ci_magics_db_build(const char *filename);
// ci_magics_db_file_add
// file filetype.c line 302
signed int ci_magics_db_file_add(struct ci_magics_db *db, const char *filename);
// ci_magics_db_init
// file filetype.c line 267
struct ci_magics_db * ci_magics_db_init();
// ci_magics_db_release
// file filetype.c line 294
void ci_magics_db_release(struct ci_magics_db *db);
// ci_mem_allocator_destroy
// file ../include/mem.h line 46
void ci_mem_allocator_destroy(struct ci_mem_allocator *allocator);
// ci_membuf_attr_add
// file body.c line 244
signed int ci_membuf_attr_add(struct ci_membuf *body, const char *attr, const void *val, unsigned long int val_size);
// ci_membuf_attr_get
// file body.c line 256
const void * ci_membuf_attr_get(struct ci_membuf *body, const char *attr);
// ci_membuf_free
// file body.c line 147
void ci_membuf_free(struct ci_membuf *b);
// ci_membuf_from_content
// file body.c line 108
struct ci_membuf * ci_membuf_from_content(char *buf, unsigned long int buf_size, unsigned long int content_size, unsigned int flags);
// ci_membuf_new
// file body.c line 82
struct ci_membuf * ci_membuf_new();
// ci_membuf_new_sized
// file body.c line 87
struct ci_membuf * ci_membuf_new_sized(signed int size);
// ci_membuf_read
// file body.c line 225
signed int ci_membuf_read(struct ci_membuf *b, char *data, signed int len);
// ci_membuf_set_flag
// file body.c line 158
unsigned int ci_membuf_set_flag(struct ci_membuf *body, unsigned int flag);
// ci_membuf_truncate
// file body.c line 263
signed int ci_membuf_truncate(struct ci_membuf *body, signed int new_size);
// ci_membuf_write
// file body.c line 167
signed int ci_membuf_write(struct ci_membuf *b, const char *data, signed int len, signed int iseof);
// ci_mktemp_file
// file include/util.h line 34
signed int ci_mktemp_file(char *dir, char *template, char *filename);
// ci_module_load
// file os/unix/dlib.c line 27
void * ci_module_load(const char *module_file, const char *default_path);
// ci_module_sym
// file os/unix/dlib.c line 59
void * ci_module_sym(void *handle, const char *symbol);
// ci_module_unload
// file os/unix/dlib.c line 65
signed int ci_module_unload(void *handle, const char *name);
// ci_netio_init
// file include/net_io.h line 149
signed int ci_netio_init(signed int fd);
// ci_object_pool_alloc
// file include/mem.h line 73
void * ci_object_pool_alloc(signed int id);
// ci_object_pool_free
// file include/mem.h line 74
void ci_object_pool_free(void *ptr);
// ci_object_pool_register
// file include/mem.h line 71
signed int ci_object_pool_register(const char *name, signed int size);
// ci_object_pool_unregister
// file include/mem.h line 72
void ci_object_pool_unregister(signed int id);
// ci_object_pools_destroy
// file mem.c line 310
void ci_object_pools_destroy();
// ci_object_pools_init
// file mem.c line 305
signed int ci_object_pools_init();
// ci_pack_allocator_alloc
// file mem.c line 604
void * ci_pack_allocator_alloc(struct ci_mem_allocator *allocator, unsigned long int size);
// ci_pack_allocator_alloc_from_rear
// file mem.c line 610
void * ci_pack_allocator_alloc_from_rear(struct ci_mem_allocator *allocator, signed int size);
// ci_pack_allocator_alloc_unaligned
// file mem.c line 582
void * ci_pack_allocator_alloc_unaligned(struct ci_mem_allocator *allocator, unsigned long int size);
// ci_pack_allocator_data_size
// file mem.c line 722
signed int ci_pack_allocator_data_size(struct ci_mem_allocator *allocator);
// ci_pack_allocator_destroy
// file mem.c line 647
void ci_pack_allocator_destroy(struct ci_mem_allocator *allocator);
// ci_pack_allocator_free
// file mem.c line 633
void ci_pack_allocator_free(struct ci_mem_allocator *allocator, void *p);
// ci_pack_allocator_required_size
// file mem.c line 730
unsigned long int ci_pack_allocator_required_size();
// ci_pack_allocator_reset
// file mem.c line 638
void ci_pack_allocator_reset(struct ci_mem_allocator *allocator);
// ci_pack_allocator_set_end_pos
// file mem.c line 746
void ci_pack_allocator_set_end_pos(struct ci_mem_allocator *allocator, void *p);
// ci_pack_allocator_set_start_pos
// file mem.c line 737
void ci_pack_allocator_set_start_pos(struct ci_mem_allocator *allocator, void *p);
// ci_parse_key_value_list
// file util.c line 163
struct ci_dyn_array * ci_parse_key_value_list(const char *str, char sep);
// ci_proc_mutex_default_scheme
// file os/unix/proc_mutex.c line 254
const struct ci_proc_mutex_scheme * ci_proc_mutex_default_scheme();
// ci_proc_mutex_destroy
// file os/unix/proc_mutex.c line 292
signed int ci_proc_mutex_destroy(struct ci_proc_mutex *mutex);
// ci_proc_mutex_init
// file os/unix/proc_mutex.c line 283
signed int ci_proc_mutex_init(struct ci_proc_mutex *mutex, const char *name);
// ci_proc_mutex_lock
// file os/unix/proc_mutex.c line 299
signed int ci_proc_mutex_lock(struct ci_proc_mutex *mutex);
// ci_proc_mutex_set_scheme
// file os/unix/proc_mutex.c line 259
signed int ci_proc_mutex_set_scheme(const char *scheme);
// ci_proc_mutex_unlock
// file os/unix/proc_mutex.c line 306
signed int ci_proc_mutex_unlock(struct ci_proc_mutex *mutex);
// ci_ptr_array_add
// file array.c line 165
const struct ci_array_item * ci_ptr_array_add(struct ci_array *ptr_array, const char *name, void *value);
// ci_ptr_array_new2
// file array.c line 151
struct ci_array * ci_ptr_array_new2(unsigned long int items);
// ci_ptr_array_pop
// file array.c line 189
const struct ci_array_item * ci_ptr_array_pop(struct ci_array *ptr_array);
// ci_ptr_array_pop_value
// file array.c line 200
void * ci_ptr_array_pop_value(struct ci_array *ptr_array, char *name, unsigned long int name_size);
// ci_ptr_array_search
// file array.c line 160
void * ci_ptr_array_search(struct ci_array *array, const char *name);
// ci_ptr_dyn_array_add
// file array.c line 336
const struct ci_array_item * ci_ptr_dyn_array_add(struct ci_dyn_array *array, const char *name, void *value);
// ci_ptr_vector_add
// file array.c line 479
void * ci_ptr_vector_add(struct ci_vector *vector, void *value);
// ci_read
// file os/unix/net_io.c line 253
signed int ci_read(signed int fd, void *buf, unsigned long int count, signed int timeout);
// ci_read_nonblock
// file include/net_io.h line 152
signed int ci_read_nonblock(signed int fd, void *buf, unsigned long int count);
// ci_regex_apply
// file include/ci_regex.h line 46
signed int ci_regex_apply(void * const regex, const char *str, signed int len, signed int recurs, struct ci_list *matches, const void *user_data);
// ci_regex_build
// file include/ci_regex.h line 44
void * ci_regex_build(const char *regex_str, signed int regex_flags);
// ci_regex_free
// file include/ci_regex.h line 45
void ci_regex_free(void *regex);
// ci_regex_parse
// file include/ci_regex.h line 43
char * ci_regex_parse(const char *str, signed int *flags, signed int *recursive);
// ci_registry_add_item
// file include/registry.h line 34
signed int ci_registry_add_item(const char *name, const char *label, const void *obj);
// ci_registry_clean
// file registry.c line 49
void ci_registry_clean();
// ci_registry_create
// file registry.c line 29
signed int ci_registry_create(const char *name);
// ci_registry_get_id
// file registry.c line 119
signed int ci_registry_get_id(const char *name);
// ci_registry_get_item
// file include/registry.h line 35
const void * ci_registry_get_item(const char *name, const char *label);
// ci_registry_id_get_item
// file registry.c line 147
const void * ci_registry_id_get_item(signed int reg_id, const char *label);
// ci_registry_id_iterate
// file registry.c line 135
signed int ci_registry_id_iterate(signed int reg_id, void *data, signed int (*fn)(void *, const char *, const void *));
// ci_registry_id_iterate::fn_object
//
signed int fn_object(void *, const char *, const void *);
// ci_registry_iterate
// file registry.c line 65
signed int ci_registry_iterate(const char *name, void *data, signed int (*fn)(void *, const char *, const void *));
// ci_registry_iterate::fn_object
//
signed int fn_object(void *, const char *, const void *);
// ci_request_206_origin_body
// file request_common.c line 436
signed int ci_request_206_origin_body(struct ci_request *req, unsigned long int offset);
// ci_request_alloc
// file request_common.c line 231
struct ci_request * ci_request_alloc(struct ci_connection *connection);
// ci_request_alloc_entity
// file include/request.h line 174
struct ci_encaps_entity * ci_request_alloc_entity(struct ci_request *req, signed int type, signed int val);
// ci_request_destroy
// file request_common.c line 378
void ci_request_destroy(struct ci_request *req);
// ci_request_pack
// file request_common.c line 152
void ci_request_pack(struct ci_request *req);
// ci_request_release_entity
// file include/request.h line 175
signed int ci_request_release_entity(struct ci_request *req, signed int pos);
// ci_request_reset
// file request_common.c line 308
void ci_request_reset(struct ci_request *req);
// ci_request_set_log_str
// file request_common.c line 405
char * ci_request_set_log_str(struct ci_request *req, char *logstr);
// ci_request_set_str_attribute
// file request_common.c line 419
signed int ci_request_set_str_attribute(struct ci_request *req, const char *name, const char *value);
// ci_request_t_pack
// file request_common.c line 92
void ci_request_t_pack(struct ci_request *req, signed int is_request);
// ci_response_pack
// file request_common.c line 156
void ci_response_pack(struct ci_request *req);
// ci_ring_buf_consume
// file body.c line 931
void ci_ring_buf_consume(struct ci_ring_buf *buf, signed int len);
// ci_ring_buf_destroy
// file body.c line 882
void ci_ring_buf_destroy(struct ci_ring_buf *buf);
// ci_ring_buf_is_empty
// file body.c line 888
signed int ci_ring_buf_is_empty(struct ci_ring_buf *buf);
// ci_ring_buf_new
// file body.c line 863
struct ci_ring_buf * ci_ring_buf_new(signed int size);
// ci_ring_buf_produce
// file body.c line 942
void ci_ring_buf_produce(struct ci_ring_buf *buf, signed int len);
// ci_ring_buf_read
// file body.c line 975
signed int ci_ring_buf_read(struct ci_ring_buf *buf, char *data, signed int size);
// ci_ring_buf_read_block
// file body.c line 912
signed int ci_ring_buf_read_block(struct ci_ring_buf *buf, char **rb, signed int *len);
// ci_ring_buf_write
// file body.c line 955
signed int ci_ring_buf_write(struct ci_ring_buf *buf, const char *data, signed int size);
// ci_ring_buf_write_block
// file body.c line 893
signed int ci_ring_buf_write_block(struct ci_ring_buf *buf, char **wb, signed int *len);
// ci_service_add_xincludes
// file service_lib.c line 125
void ci_service_add_xincludes(struct ci_service_xdata *srv_xdata, char **xincludes);
// ci_service_add_xopts
// file service_lib.c line 118
void ci_service_add_xopts(struct ci_service_xdata *srv_xdata, unsigned long int xopts);
// ci_service_data_read_lock
// file service_lib.c line 25
void ci_service_data_read_lock(struct ci_service_xdata *srv_xdata);
// ci_service_data_read_unlock
// file service_lib.c line 30
void ci_service_data_read_unlock(struct ci_service_xdata *srv_xdata);
// ci_service_enable_204
// file service_lib.c line 82
void ci_service_enable_204(struct ci_service_xdata *srv_xdata);
// ci_service_enable_206
// file service_lib.c line 89
void ci_service_enable_206(struct ci_service_xdata *srv_xdata);
// ci_service_set_istag
// file service_lib.c line 35
void ci_service_set_istag(struct ci_service_xdata *srv_xdata, const char *istag);
// ci_service_set_max_connections
// file service_lib.c line 97
void ci_service_set_max_connections(struct ci_service_xdata *srv_xdata, signed int max_connections);
// ci_service_set_options_ttl
// file service_lib.c line 104
void ci_service_set_options_ttl(struct ci_service_xdata *srv_xdata, signed int ttl);
// ci_service_set_preview
// file service_lib.c line 75
void ci_service_set_preview(struct ci_service_xdata *srv_xdata, signed int preview);
// ci_service_set_transfer_complete
// file service_lib.c line 64
void ci_service_set_transfer_complete(struct ci_service_xdata *srv_xdata, const char *complete);
// ci_service_set_transfer_ignore
// file service_lib.c line 54
void ci_service_set_transfer_ignore(struct ci_service_xdata *srv_xdata, const char *ignore);
// ci_service_set_transfer_preview
// file service_lib.c line 44
void ci_service_set_transfer_preview(struct ci_service_xdata *srv_xdata, const char *preview);
// ci_service_set_xopts
// file service_lib.c line 111
void ci_service_set_xopts(struct ci_service_xdata *srv_xdata, unsigned long int xopts);
// ci_shared_mem_attach
// file os/unix/shared_mem.c line 262
void * ci_shared_mem_attach(struct ci_shared_mem_id *id);
// ci_shared_mem_create
// file os/unix/shared_mem.c line 252
void * ci_shared_mem_create(struct ci_shared_mem_id *id, const char *name, signed int size);
// ci_shared_mem_destroy
// file os/unix/shared_mem.c line 276
signed int ci_shared_mem_destroy(struct ci_shared_mem_id *id);
// ci_shared_mem_detach
// file os/unix/shared_mem.c line 269
signed int ci_shared_mem_detach(struct ci_shared_mem_id *id);
// ci_shared_mem_set_scheme
// file os/unix/shared_mem.c line 227
signed int ci_shared_mem_set_scheme(const char *name);
// ci_simple_file_destroy
// file body.c line 643
void ci_simple_file_destroy(struct ci_simple_file *body);
// ci_simple_file_named_new
// file body.c line 601
struct ci_simple_file * ci_simple_file_named_new(char *dir, char *filename, signed long int maxsize);
// ci_simple_file_new
// file body.c line 571
struct ci_simple_file * ci_simple_file_new(signed long int maxsize);
// ci_simple_file_read
// file body.c line 750
signed int ci_simple_file_read(struct ci_simple_file *body, char *buf, signed int len);
// ci_simple_file_release
// file body.c line 665
void ci_simple_file_release(struct ci_simple_file *body);
// ci_simple_file_to_const_string
// file body.c line 824
const char * ci_simple_file_to_const_string(struct ci_simple_file *body);
// ci_simple_file_to_membuf
// file body.c line 848
struct ci_membuf * ci_simple_file_to_membuf(struct ci_simple_file *body, unsigned int flags);
// ci_simple_file_truncate
// file body.c line 797
signed int ci_simple_file_truncate(struct ci_simple_file *body, signed long int new_size);
// ci_simple_file_write
// file body.c line 686
signed int ci_simple_file_write(struct ci_simple_file *body, const char *buf, signed int len, signed int iseof);
// ci_sockaddr_set_port
// file include/net_io.h line 131
void ci_sockaddr_set_port(struct ci_sockaddr *addr, signed int port);
// ci_sockaddr_t_to_host
// file include/net_io.h line 135
const char * ci_sockaddr_t_to_host(struct ci_sockaddr *addr, char *hname, signed int maxhostlen);
// ci_sockaddr_t_to_ip
// file include/net_io.h line 123
const char * ci_sockaddr_t_to_ip(struct ci_sockaddr *addr, char *ip, signed int maxlen);
// ci_stat_area_construct
// file stats.c line 198
struct stat_area * ci_stat_area_construct(void *mem_block, signed int size, void (*release_mem)(void *));
// ci_stat_area_construct::release_mem_object
//
void release_mem_object(void *);
// ci_stat_area_destroy
// file stats.c line 236
void ci_stat_area_destroy(struct stat_area *area);
// ci_stat_area_kbs_inc
// file stats.c line 257
void ci_stat_area_kbs_inc(struct stat_area *area, signed int ID, signed int count);
// ci_stat_area_merge
// file stats.c line 322
void ci_stat_area_merge(struct stat_area *dest, struct stat_area *src);
// ci_stat_area_reset
// file stats.c line 221
void ci_stat_area_reset(struct stat_area *area);
// ci_stat_area_uint64_inc
// file stats.c line 245
void ci_stat_area_uint64_inc(struct stat_area *area, signed int ID, signed int count);
// ci_stat_attach_mem
// file stats.c line 152
void ci_stat_attach_mem(void *mem_block, signed int size, void (*release_mem)(void *));
// ci_stat_attach_mem::release_mem_object
//
void release_mem_object(void *);
// ci_stat_entry_register
// file stats.c line 129
signed int ci_stat_entry_register(char *label, signed int type, char *group);
// ci_stat_entry_release_lists
// file stats.c line 146
void ci_stat_entry_release_lists();
// ci_stat_kbs_inc
// file stats.c line 179
void ci_stat_kbs_inc(signed int ID, signed int count);
// ci_stat_memblock_merge
// file stats.c line 303
void ci_stat_memblock_merge(struct stat_memblock *dest_block, struct stat_memblock *mem_block);
// ci_stat_memblock_reset
// file stats.c line 292
void ci_stat_memblock_reset(struct stat_memblock *block);
// ci_stat_memblock_size
// file stats.c line 33
signed int ci_stat_memblock_size(void);
// ci_stat_release
// file stats.c line 160
void ci_stat_release();
// ci_stat_uint64_inc
// file stats.c line 168
void ci_stat_uint64_inc(signed int ID, signed int count);
// ci_str_trim
// file util.c line 108
void ci_str_trim(char *str);
// ci_str_trim2
// file util.c line 131
char * ci_str_trim2(char *s);
// ci_str_vector_iterate
// file array.c line 461
void ci_str_vector_iterate(const struct ci_vector *vector, void *data, signed int (*fn)(void *, const char *));
// ci_str_vector_iterate::fn_object
//
signed int fn_object(void *, const char *);
// ci_str_vector_search
// file include/array.h line 549
const char * ci_str_vector_search(struct ci_vector *vector, const char *item);
// ci_strcasestr
// file util.c line 43
const char * ci_strcasestr(const char *str, const char *find);
// ci_strerror
// file include/util.h line 57
char * ci_strerror(signed int error, char *buf, unsigned long int buflen);
// ci_strncasestr
// file util.c line 59
const char * ci_strncasestr(const char *s, const char *find, unsigned long int slen);
// ci_strnstr
// file include/util.h line 44
const char * ci_strnstr(const char *s, const char *find, unsigned long int slen);
// ci_strtime
// file os/unix/utilfunc.c line 51
void ci_strtime(char *buf);
// ci_strtime_rfc822
// file os/unix/utilfunc.c line 61
void ci_strtime_rfc822(char *buf);
// ci_thread_cond_destroy
// file os/unix/threads.c line 196
signed int ci_thread_cond_destroy(union anonymous_34 *pcond);
// ci_thread_cond_init
// file os/unix/threads.c line 191
signed int ci_thread_cond_init(union anonymous_34 *pcond);
// ci_thread_create
// file os/unix/threads.c line 201
signed int ci_thread_create(unsigned long int *pthread_id, void * (*pfunc)(void *), void *parg);
// ci_thread_create::pfunc_object
//
void * pfunc_object(void *);
// ci_thread_join
// file os/unix/threads.c line 206
signed int ci_thread_join(unsigned long int thread_id);
// ci_thread_mutex_destroy
// file include/ci_threads.h line 40
signed int ci_thread_mutex_destroy(union anonymous_4 *pmutex);
// ci_thread_mutex_init
// file include/ci_threads.h line 39
signed int ci_thread_mutex_init(union anonymous_4 *pmutex);
// ci_thread_rwlock_destroy
// file os/unix/threads.c line 154
signed int ci_thread_rwlock_destroy(union anonymous_37 *rwlock);
// ci_thread_rwlock_init
// file os/unix/threads.c line 144
signed int ci_thread_rwlock_init(union anonymous_37 *rwlock);
// ci_txt_template_build_content
// file txtTemplate.c line 396
struct ci_membuf * ci_txt_template_build_content(const struct ci_request *req, const char *SERVICE_NAME, const char *TEMPLATE_NAME, struct ci_fmt_entry *user_table);
// ci_txt_template_close
// file txtTemplate.c line 192
void ci_txt_template_close(void);
// ci_txt_template_init
// file txtTemplate.c line 77
signed int ci_txt_template_init(void);
// ci_txt_template_reset
// file txtTemplate.c line 181
void ci_txt_template_reset(void);
// ci_txt_template_set_default_lang
// file txtTemplate.c line 104
void ci_txt_template_set_default_lang(const char *lang);
// ci_txt_template_set_dir
// file txtTemplate.c line 99
void ci_txt_template_set_dir(const char *dir);
// ci_uncompress_preview
// file decode.c line 313
signed int ci_uncompress_preview(signed int compress_method, const char *buf, signed int len, char *unzipped_buf, signed int *unzipped_buf_len);
// ci_usleep
// file os/unix/utilfunc.c line 85
signed int ci_usleep(unsigned long int usec);
// ci_vector_add
// file include/array.h line 480
void * ci_vector_add(struct ci_vector *vector, const void *value, unsigned long int size);
// ci_vector_cast_from_voidvoid
// file array.c line 386
struct ci_vector * ci_vector_cast_from_voidvoid(const void **p);
// ci_vector_cast_to_voidvoid
// file array.c line 381
const void ** ci_vector_cast_to_voidvoid(struct ci_vector *vector);
// ci_vector_create
// file include/array.h line 463
struct ci_vector * ci_vector_create(unsigned long int max_size);
// ci_vector_destroy
// file array.c line 398
void ci_vector_destroy(struct ci_vector *vector);
// ci_vector_iterate
// file array.c line 452
void ci_vector_iterate(const struct ci_vector *vector, void *data, signed int (*fn)(void *, const void *));
// ci_vector_iterate::fn_object
//
signed int fn_object(void *, const void *);
// ci_vector_pop
// file array.c line 427
void * ci_vector_pop(struct ci_vector *vector);
// ci_wait_for_data
// file include/net_io.h line 144
signed int ci_wait_for_data(signed int fd, signed int secs, signed int what_wait);
// ci_write
// file include/net_io.h line 151
signed int ci_write(signed int fd, const void *buf, unsigned long int count, signed int timeout);
// ci_write_nonblock
// file include/net_io.h line 153
signed int ci_write_nonblock(signed int fd, const void *buf, unsigned long int count);
// ci_writen
// file request_common.c line 801
static signed int ci_writen(signed int fd, char *buf, signed int len, signed int timeout);
// client_build_headers
// file request_common.c line 1281
static signed int client_build_headers(struct ci_request *req, signed int has_reqhdr, signed int has_reshdr, signed int has_body);
// client_create_request
// file request_common.c line 724
static signed int client_create_request(struct ci_request *req, char *servername, char *service, signed int reqtype);
// client_parse_encaps_header
// file request_common.c line 921
static signed int client_parse_encaps_header(struct ci_request *req, struct ci_headers_list *h, signed int size);
// client_parse_icap_header
// file request_common.c line 891
static signed int client_parse_icap_header(struct ci_request *req, struct ci_headers_list *h);
// client_parse_incoming_data
// file request_common.c line 1082
static signed int client_parse_incoming_data(struct ci_request *req, void *data_dest, signed int (*dest_write)(void *, char *, signed int));
// client_parse_incoming_data::dest_write_object
//
signed int dest_write_object(void *, char *, signed int);
// client_prepere_body_chunk
// file request_common.c line 1052
static signed int client_prepere_body_chunk(struct ci_request *req, void *data, signed int (*readdata)(void *, char *, signed int));
// client_prepere_body_chunk::readdata_object
//
signed int readdata_object(void *, char *, signed int);
// client_send_get_data
// file request_common.c line 1200
static signed int client_send_get_data(struct ci_request *req, signed int timeout, void *data_source, signed int (*source_read)(void *, char *, signed int), void *data_dest, signed int (*dest_write)(void *, char *, signed int));
// client_send_get_data::dest_write_object
//
signed int dest_write_object(void *, char *, signed int);
// client_send_get_data::source_read_object
//
signed int source_read_object(void *, char *, signed int);
// client_send_request_headers
// file request_common.c line 816
static signed int client_send_request_headers(struct ci_request *req, signed int has_eof, signed int timeout);
// close
// file /usr/include/unistd.h line 356
extern signed int close(signed int);
// close_db
// file c-icap-mkbdb.c line 98
void close_db();
// common_mutex_destroy
// file cache.c line 114
signed int common_mutex_destroy(struct common_mutex *mtx);
// common_mutex_init
// file cache.c line 105
signed int common_mutex_init(struct common_mutex *mtx, signed int proc_mtx);
// common_mutex_lock
// file cache.c line 121
signed int common_mutex_lock(struct common_mutex *mtx);
// common_mutex_unlock
// file cache.c line 128
signed int common_mutex_unlock(struct common_mutex *mtx);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, union anonymous_27, unsigned int);
// datatype_cmp
// file types_ops.c line 330
signed int datatype_cmp(const void *key1, const void *key2);
// datatype_dup
// file types_ops.c line 311
void * datatype_dup(const char *str, struct ci_mem_allocator *allocator);
// datatype_equal
// file types_ops.c line 348
signed int datatype_equal(const void *key1, const void *key2);
// datatype_free
// file types_ops.c line 371
void datatype_free(void *key, struct ci_mem_allocator *allocator);
// datatype_len
// file types_ops.c line 366
unsigned long int datatype_len(const void *key);
// db_create
// file /usr/include/db.h line 3049
signed int db_create(struct __db **, struct __db_env *, unsigned int);
// db_env_create
// file /usr/include/db.h line 3073
signed int db_env_create(struct __db_env **, unsigned int);
// db_strerror
// file /usr/include/db.h line 3050
char * db_strerror(signed int);
// default_cmp
// file array.c line 680
static signed int default_cmp(const void *obj1, const void *obj2, unsigned long int size);
// del_mutex
// file os/unix/threads.c line 105
static void del_mutex(void *pmutex);
// destroy_encaps_entity
// file header.c line 563
void destroy_encaps_entity(struct ci_encaps_entity *e);
// dlclose
// file /usr/include/dlfcn.h line 60
extern signed int dlclose(void *);
// dlerror
// file /usr/include/dlfcn.h line 82
extern char * dlerror(void);
// dlopen
// file /usr/include/dlfcn.h line 56
extern void * dlopen(const char *, signed int);
// dlsym
// file /usr/include/dlfcn.h line 64
extern void * dlsym(void *, const char *);
// do_close
// file body.c line 318
void do_close(signed int fd);
// do_open
// file body.c line 308
signed int do_open(const char *pathname, signed int flags);
// do_read
// file body.c line 292
signed int do_read(signed int fd, void *buf, unsigned long int count);
// do_write
// file body.c line 282
signed int do_write(signed int fd, const void *buf, unsigned long int count);
// dump_db
// file c-icap-mkbdb.c line 104
signed int dump_db();
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// extend_object_type
// file filetype.c line 559
signed int extend_object_type(struct ci_magics_db *db, struct ci_headers_list *headers, const char *buf, signed int len, signed int *iscompressed);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// fcntl
// file /usr/include/fcntl.h line 146
extern signed int fcntl(signed int, signed int, ...);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// file_proc_mutex_destroy
// file os/unix/proc_mutex.c line 195
static signed int file_proc_mutex_destroy(struct ci_proc_mutex *mutex);
// file_proc_mutex_init
// file os/unix/proc_mutex.c line 185
static signed int file_proc_mutex_init(struct ci_proc_mutex *mutex, const char *name);
// file_proc_mutex_lock
// file os/unix/proc_mutex.c line 203
static signed int file_proc_mutex_lock(struct ci_proc_mutex *mutex);
// file_proc_mutex_print_info
// file os/unix/proc_mutex.c line 228
static signed int file_proc_mutex_print_info(struct ci_proc_mutex *mutex, char *buf, unsigned long int buf_size);
// file_proc_mutex_unlock
// file os/unix/proc_mutex.c line 216
static signed int file_proc_mutex_unlock(struct ci_proc_mutex *mutex);
// file_table_close
// file lookup_file_table.c line 264
void file_table_close(struct ci_lookup_table *table);
// file_table_open
// file lookup_file_table.c line 247
void * file_table_open(struct ci_lookup_table *table);
// file_table_release_result
// file lookup_file_table.c line 316
void file_table_release_result(struct ci_lookup_table *table_data, void **val);
// file_table_search
// file lookup_file_table.c line 294
void * file_table_search(struct ci_lookup_table *table, void *key, void ***vals);
// fmt_gmttime
// file txt_format.c line 399
signed int fmt_gmttime(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_http_req_head_o
// file txt_format.c line 474
signed int fmt_http_req_head_o(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_http_req_url_o
// file txt_format.c line 466
signed int fmt_http_req_url_o(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_http_res_head_o
// file txt_format.c line 497
signed int fmt_http_res_head_o(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_httpclientip
// file txt_format.c line 429
signed int fmt_httpclientip(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_httpserverip
// file txt_format.c line 448
signed int fmt_httpserverip(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_icap_req_head
// file txt_format.c line 525
signed int fmt_icap_req_head(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_icap_res_head
// file txt_format.c line 549
signed int fmt_icap_res_head(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_icapmethod
// file txt_format.c line 338
signed int fmt_icapmethod(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_icapstatus
// file txt_format.c line 416
signed int fmt_icapstatus(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_localip
// file txt_format.c line 327
signed int fmt_localip(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_localtime
// file txt_format.c line 382
signed int fmt_localtime(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_logstr
// file txt_format.c line 645
signed int fmt_logstr(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_none
// file txt_format.c line 142
signed int fmt_none(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_percent
// file txt_format.c line 151
signed int fmt_percent(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_remoteip
// file txt_format.c line 316
signed int fmt_remoteip(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_attribute
// file txt_format.c line 659
signed int fmt_req_attribute(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_body_bytes_rcv
// file txt_format.c line 593
signed int fmt_req_body_bytes_rcv(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_body_bytes_sent
// file txt_format.c line 597
signed int fmt_req_body_bytes_sent(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_bytes_rcv
// file txt_format.c line 577
signed int fmt_req_bytes_rcv(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_bytes_sent
// file txt_format.c line 581
signed int fmt_req_bytes_sent(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_http_bytes_rcv
// file txt_format.c line 585
signed int fmt_req_http_bytes_rcv(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_http_bytes_sent
// file txt_format.c line 589
signed int fmt_req_http_bytes_sent(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_preview_hex
// file txt_format.c line 601
signed int fmt_req_preview_hex(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_req_preview_len
// file txt_format.c line 633
signed int fmt_req_preview_len(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_request
// file txt_format.c line 365
signed int fmt_request(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_seconds
// file txt_format.c line 422
signed int fmt_seconds(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_service
// file txt_format.c line 347
signed int fmt_service(struct ci_request *req, char *buf, signed int len, const char *param);
// fmt_username
// file txt_format.c line 356
signed int fmt_username(struct ci_request *req, char *buf, signed int len, const char *param);
// fopen64
// file /usr/include/stdio.h line 283
extern struct _IO_FILE * fopen64(const char *, const char *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_a_buffer
// file decode.c line 203
static void free_a_buffer(void *op, void *ptr);
// free_cmp_uint64_data
// file acl.c line 997
void free_cmp_uint64_data(struct ci_request *req, void *param);
// free_data_type
// file acl.c line 976
void free_data_type(struct ci_request *req, void *param);
// free_http_req_header
// file acl.c line 938
void free_http_req_header(struct ci_request *req, void *param);
// free_http_resp_header
// file acl.c line 952
void free_http_resp_header(struct ci_request *req, void *param);
// free_icap_header
// file acl.c line 911
void free_icap_header(struct ci_request *req, void *param);
// free_icap_response_header
// file acl.c line 925
void free_icap_response_header(struct ci_request *req, void *param);
// free_records_group
// file filetype.c line 167
void free_records_group(struct ci_magic_record *record);
// free_time_data
// file acl.c line 394
void free_time_data(struct ci_request *req, void *param);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// fstat64
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 219
extern signed int fstat64(signed int, struct stat *);
// ftruncate64
// file /usr/include/unistd.h line 1022
extern signed int ftruncate64(signed int, signed long int);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// get_client_ip
// file acl.c line 60
void * get_client_ip(struct ci_request *req, char *param);
// get_content_length
// file acl.c line 980
void * get_content_length(struct ci_request *req, char *param);
// get_data_type
// file acl.c line 961
void * get_data_type(struct ci_request *req, char *param);
// get_encaps_type
// file header.c line 573
signed int get_encaps_type(const char *buf, signed int *val, char **endpoint);
// get_header
// file acl.c line 872
const char * get_header(struct ci_headers_list *headers, char *head);
// get_http_client_ip
// file acl.c line 68
void * get_http_client_ip(struct ci_request *req, char *param);
// get_http_req_header
// file acl.c line 932
void * get_http_req_header(struct ci_request *req, char *param);
// get_http_resp_header
// file acl.c line 945
void * get_http_resp_header(struct ci_request *req, char *param);
// get_icap_header
// file acl.c line 904
void * get_icap_header(struct ci_request *req, char *param);
// get_icap_response_header
// file acl.c line 918
void * get_icap_response_header(struct ci_request *req, char *param);
// get_port
// file acl.c line 56
void * get_port(struct ci_request *req, char *param);
// get_reqtype
// file acl.c line 52
void * get_reqtype(struct ci_request *req, char *param);
// get_request_options
// file request_common.c line 757
static signed int get_request_options(struct ci_request *req, struct ci_headers_list *h);
// get_service
// file acl.c line 48
void * get_service(struct ci_request *req, char *param);
// get_srv_ip
// file acl.c line 64
void * get_srv_ip(struct ci_request *req, char *param);
// get_time_data
// file acl.c line 401
void * get_time_data(struct ci_request *req, char *param);
// get_user
// file acl.c line 44
void * get_user(struct ci_request *req, char *param);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getsockname
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 127
extern signed int getsockname(signed int, union anonymous_27, unsigned int *);
// gmtime_r
// file /usr/include/time.h line 249
extern struct tm * gmtime_r(const signed long int *, struct tm *);
// groups_add
// file filetype.c line 104
signed int groups_add(struct ci_magics_db *db, const char *name, const char *descr);
// groups_init
// file filetype.c line 82
signed int groups_init(struct ci_magics_db *db);
// hash_table_close
// file lookup_file_table.c line 365
void hash_table_close(struct ci_lookup_table *table);
// hash_table_open
// file lookup_file_table.c line 339
void * hash_table_open(struct ci_lookup_table *table);
// hash_table_release_result
// file lookup_file_table.c line 396
void hash_table_release_result(struct ci_lookup_table *table_data, void **val);
// hash_table_search
// file lookup_file_table.c line 377
void * hash_table_search(struct ci_lookup_table *table, void *key, void ***vals);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// icap_init_server
// file os/unix/net_io.c line 87
signed int icap_init_server(char *address, signed int port, signed int *protocol_family, signed int secs_to_linger);
// icap_socket_opts
// file os/unix/net_io.c line 135
signed int icap_socket_opts(signed int fd, signed int secs_to_linger);
// index
// file /usr/include/strings.h line 72
extern char * index(const char *, signed int);
// inet_aton
// file /usr/include/arpa/inet.h line 73
extern signed int inet_aton(const char *, struct in_addr *);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// inflate
// file /usr/include/zlib.h line 392
extern signed int inflate(struct z_stream_s *, signed int);
// inflateEnd
// file /usr/include/zlib.h line 508
extern signed int inflateEnd(struct z_stream_s *);
// inflateInit2_
// file /usr/include/zlib.h line 1641
extern signed int inflateInit2_(struct z_stream_s *, signed int, const char *, signed int);
// init_body_system
// file body.c line 49
signed int init_body_system();
// init_child_mutexes
// file os/unix/threads.c line 46
static void init_child_mutexes();
// init_internal_lookup_tables
// file lookup_table.c line 241
void init_internal_lookup_tables();
// init_pack_allocator
// file mem.c line 661
struct ci_mem_allocator * init_pack_allocator(struct ci_mem_allocator *allocator, struct pack_allocator *pack_alloc, char *memblock, unsigned long int size, signed int free);
// int32_cmp
// file types_ops.c line 125
signed int int32_cmp(const void *key1, const void *key2);
// int32_dup
// file types_ops.c line 107
void * int32_dup(const char *str, struct ci_mem_allocator *allocator);
// int32_equal
// file types_ops.c line 138
signed int int32_equal(const void *key1, const void *key2);
// int32_free
// file types_ops.c line 151
void int32_free(void *key, struct ci_mem_allocator *allocator);
// int32_len
// file types_ops.c line 146
unsigned long int int32_len(const void *key);
// ip_cmp
// file types_ops.c line 520
signed int ip_cmp(const void *ref_key, const void *key_check);
// ip_dup
// file types_ops.c line 448
void * ip_dup(const char *value, struct ci_mem_allocator *allocator);
// ip_equal
// file types_ops.c line 525
signed int ip_equal(const void *ref_key, const void *key_check);
// ip_free
// file types_ops.c line 511
void ip_free(void *data, struct ci_mem_allocator *allocator);
// ip_len
// file types_ops.c line 515
unsigned long int ip_len(const void *key);
// ip_sockaddr_cmp
// file types_ops.c line 556
signed int ip_sockaddr_cmp(const void *ref_key, const void *key_check);
// ip_sockaddr_equal
// file types_ops.c line 561
signed int ip_sockaddr_equal(const void *ref_key, const void *key_check);
// isUTF8
// file filetype.c line 439
signed int isUTF8(unsigned char *c, signed int size);
// list_alloc_item
// file array.c line 562
static struct ci_list_item * list_alloc_item(struct ci_list *list, const void *data);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// load_text_table
// file lookup_file_table.c line 205
signed int load_text_table(char *filename, struct ci_lookup_table *table);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// log_errors
// file c-icap-mkbdb.c line 315
void log_errors(void *unused, const char *format, ...);
// lookup_table_get_row
// file lookup_table.c line 205
static const void * lookup_table_get_row(struct ci_lookup_table *table, const void *key, const char **columns, void ***vals);
// lseek64
// file /usr/include/unistd.h line 340
extern signed long int lseek64(signed int, signed long int, signed int);
// magics_add
// file filetype.c line 116
signed int magics_add(struct ci_magics_db *db, signed int offset, unsigned char *magic, unsigned long int len, signed int type);
// magics_init
// file filetype.c line 83
signed int magics_init(struct ci_magics_db *db);
// makeTemplatePathFileName
// file txtTemplate.c line 70
static void makeTemplatePathFileName(char *path, signed int path_len, const char *service_name, const char *page_name, const char *lang);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// mem_init
// file mem.c line 40
signed int mem_init();
// mem_reset
// file mem.c line 58
void mem_reset();
// memcmp
// file /usr/include/string.h line 65
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 42
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 46
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 62
extern void * memset(void *, signed int, unsigned long int);
// mk_encaps_entity
// file header.c line 547
struct ci_encaps_entity * mk_encaps_entity(signed int type, signed int val);
// mkstemp64
// file /usr/include/stdlib.h line 622
extern signed int mkstemp64(char *);
// mmap64
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 61
extern void * mmap64(void *, unsigned long int, signed int, signed int, signed int, signed long int);
// mmap_shared_mem_attach
// file os/unix/shared_mem.c line 118
void * mmap_shared_mem_attach(struct ci_shared_mem_id *id);
// mmap_shared_mem_create
// file os/unix/shared_mem.c line 103
void * mmap_shared_mem_create(struct ci_shared_mem_id *id, const char *name, signed int size);
// mmap_shared_mem_destroy
// file os/unix/shared_mem.c line 131
signed int mmap_shared_mem_destroy(struct ci_shared_mem_id *id);
// mmap_shared_mem_detach
// file os/unix/shared_mem.c line 124
signed int mmap_shared_mem_detach(struct ci_shared_mem_id *id);
// mmap_shared_mem_print_info
// file os/unix/shared_mem.c line 137
signed int mmap_shared_mem_print_info(struct ci_shared_mem_id *id, char *buf, unsigned long int buf_size);
// munmap
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 76
extern signed int munmap(void *, unsigned long int);
// nanosleep
// file /usr/include/time.h line 334
extern signed int nanosleep(struct timespec *, struct timespec *);
// net_data_read
// file request_common.c line 627
signed int net_data_read(struct ci_request *req);
// open64
// file /usr/include/fcntl.h line 159
extern signed int open64(const char *, signed int, ...);
// open_db
// file c-icap-mkbdb.c line 47
signed int open_db(char *path);
// os_allocator_alloc
// file mem.c line 404
static void * os_allocator_alloc(struct ci_mem_allocator *allocator, unsigned long int size);
// os_allocator_destroy
// file mem.c line 419
static void os_allocator_destroy(struct ci_mem_allocator *allocator);
// os_allocator_free
// file mem.c line 409
static void os_allocator_free(struct ci_mem_allocator *allocator, void *p);
// os_allocator_reset
// file mem.c line 414
static void os_allocator_reset(struct ci_mem_allocator *allocator);
// parse_chunk_data
// file request_common.c line 492
signed int parse_chunk_data(struct ci_request *req, char **wdata);
// parse_directive
// file txt_format.c line 160
unsigned int parse_directive(const char *var, unsigned int *width, signed int *left_align, char *parameter);
// parse_record
// file filetype.c line 179
static signed int parse_record(char *line, struct ci_magic_record *record);
// pcre_compile
// file /usr/include/pcre.h line 540
extern struct real_pcre * pcre_compile(const char *, signed int, const char **, signed int *, const unsigned char *);
// pcre_exec
// file /usr/include/pcre.h line 573
extern signed int pcre_exec(const struct real_pcre *, const struct pcre_extra *, const char *, signed int, signed int, signed int, signed int *, signed int);
// pcre_free_object
//
void pcre_free_object(void *);
// pointers_cmp
// file array.c line 685
static signed int pointers_cmp(const void *obj1, const void *obj2, unsigned long int size);
// pool_allocator_alloc
// file mem.c line 796
static void * pool_allocator_alloc(struct ci_mem_allocator *allocator, unsigned long int size);
// pool_allocator_build
// file mem.c line 775
static struct pool_allocator * pool_allocator_build(signed int items_size, signed int strict);
// pool_allocator_destroy
// file mem.c line 880
static void pool_allocator_destroy(struct ci_mem_allocator *allocator);
// pool_allocator_free
// file mem.c line 829
static void pool_allocator_free(struct ci_mem_allocator *allocator, void *p);
// pool_allocator_reset
// file mem.c line 850
static void pool_allocator_reset(struct ci_mem_allocator *allocator);
// posix_proc_mutex_destroy
// file os/unix/proc_mutex.c line 139
static signed int posix_proc_mutex_destroy(struct ci_proc_mutex *mutex);
// posix_proc_mutex_init
// file os/unix/proc_mutex.c line 118
static signed int posix_proc_mutex_init(struct ci_proc_mutex *mutex, const char *name);
// posix_proc_mutex_lock
// file os/unix/proc_mutex.c line 147
static signed int posix_proc_mutex_lock(struct ci_proc_mutex *mutex);
// posix_proc_mutex_print_info
// file os/unix/proc_mutex.c line 165
static signed int posix_proc_mutex_print_info(struct ci_proc_mutex *mutex, char *buf, unsigned long int buf_size);
// posix_proc_mutex_unlock
// file os/unix/proc_mutex.c line 156
static signed int posix_proc_mutex_unlock(struct ci_proc_mutex *mutex);
// posix_shared_mem_attach
// file os/unix/shared_mem.c line 179
void * posix_shared_mem_attach(struct ci_shared_mem_id *id);
// posix_shared_mem_create
// file os/unix/shared_mem.c line 157
void * posix_shared_mem_create(struct ci_shared_mem_id *id, const char *name, signed int size);
// posix_shared_mem_destroy
// file os/unix/shared_mem.c line 192
signed int posix_shared_mem_destroy(struct ci_shared_mem_id *id);
// posix_shared_mem_detach
// file os/unix/shared_mem.c line 184
signed int posix_shared_mem_detach(struct ci_shared_mem_id *id);
// posix_shared_mem_print_info
// file os/unix/shared_mem.c line 201
signed int posix_shared_mem_print_info(struct ci_shared_mem_id *id, char *buf, unsigned long int buf_size);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process_encapsulated
// file request_common.c line 456
signed int process_encapsulated(struct ci_request *req, const char *buf);
// pthread_atfork
// file /usr/include/pthread.h line 1145
extern signed int pthread_atfork(void (*)(void), void (*)(void), void (*)(void));
// pthread_cond_destroy
// file /usr/include/pthread.h line 973
extern signed int pthread_cond_destroy(union anonymous_34 *);
// pthread_cond_init
// file /usr/include/pthread.h line 968
extern signed int pthread_cond_init(union anonymous_34 *, const union anonymous_32 *);
// pthread_create
// file /usr/include/pthread.h line 233
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 250
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 754
extern signed int pthread_mutex_destroy(union anonymous_4 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 749
extern signed int pthread_mutex_init(union anonymous_4 *, const union anonymous_32 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 762
extern signed int pthread_mutex_lock(union anonymous_4 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 773
extern signed int pthread_mutex_unlock(union anonymous_4 *);
// pthread_rwlock_destroy
// file /usr/include/pthread.h line 893
extern signed int pthread_rwlock_destroy(union anonymous_37 *);
// pthread_rwlock_init
// file /usr/include/pthread.h line 888
extern signed int pthread_rwlock_init(union anonymous_37 *, const union anonymous_35 *);
// pthread_rwlock_rdlock
// file /usr/include/pthread.h line 897
extern signed int pthread_rwlock_rdlock(union anonymous_37 *);
// pthread_rwlock_unlock
// file /usr/include/pthread.h line 927
extern signed int pthread_rwlock_unlock(union anonymous_37 *);
// pthread_rwlock_wrlock
// file /usr/include/pthread.h line 912
extern signed int pthread_rwlock_wrlock(union anonymous_37 *);
// read
// file /usr/include/unistd.h line 363
extern signed long int read(signed int, void *, unsigned long int);
// read_row
// file lookup_file_table.c line 102
signed int read_row(struct _IO_FILE *f, signed int cols, struct text_table_entry **e, struct ci_lookup_table *table);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// record_extract
// file c-icap-mkbdb.c line 153
signed int record_extract(char *line, void **key, signed int *keysize, void **val, signed int *valsize);
// regex_cmp
// file types_ops.c line 271
signed int regex_cmp(const void *key1, const void *key2);
// regex_dup
// file types_ops.c line 238
void * regex_dup(const char *str, struct ci_mem_allocator *allocator);
// regex_equal
// file types_ops.c line 279
signed int regex_equal(const void *key1, const void *key2);
// regex_free
// file types_ops.c line 292
void regex_free(void *key, struct ci_mem_allocator *allocator);
// regex_len
// file types_ops.c line 287
unsigned long int regex_len(const void *key);
// regex_table_close
// file lookup_file_table.c line 440
void regex_table_close(struct ci_lookup_table *table);
// regex_table_open
// file lookup_file_table.c line 419
void * regex_table_open(struct ci_lookup_table *table);
// regex_table_release_result
// file lookup_file_table.c line 461
void regex_table_release_result(struct ci_lookup_table *table_data, void **val);
// regex_table_search
// file lookup_file_table.c line 451
void * regex_table_search(struct ci_lookup_table *table, void *key, void ***vals);
// release_body_system
// file body.c line 74
void release_body_system();
// release_header_value
// file acl.c line 898
void release_header_value(struct ci_headers_list *headers, char *head);
// release_text_table_entry
// file lookup_file_table.c line 81
void release_text_table_entry(struct text_table_entry *e, struct ci_lookup_table *table);
// request_match_specslist
// file acl.c line 716
signed int request_match_specslist(struct ci_request *req, struct ci_specs_list *spec_list);
// resize_buffer
// file body.c line 343
signed int resize_buffer(struct ci_cached_file *body, signed int new_size);
// search_options_table
// file cfg_lib.c line 76
struct ci_options_entry * search_options_table(const char *directive, struct ci_options_entry *options);
// select
// file /usr/include/x86_64-linux-gnu/sys/select.h line 106
extern signed int select(signed int, struct anonymous_26 *, struct anonymous_26 *, struct anonymous_26 *, struct timeval *);
// sem_open
// file /usr/include/semaphore.h line 42
extern union anonymous_29 * sem_open(const char *, signed int, ...);
// sem_post
// file /usr/include/semaphore.h line 69
extern signed int sem_post(union anonymous_29 *);
// sem_unlink
// file /usr/include/semaphore.h line 48
extern signed int sem_unlink(const char *);
// sem_wait
// file /usr/include/semaphore.h line 54
extern signed int sem_wait(union anonymous_29 *);
// semctl
// file /usr/include/x86_64-linux-gnu/sys/sem.h line 52
extern signed int semctl(signed int, signed int, signed int, ...);
// semget
// file /usr/include/x86_64-linux-gnu/sys/sem.h line 55
extern signed int semget(signed int, signed int, signed int);
// semop
// file /usr/include/x86_64-linux-gnu/sys/sem.h line 58
extern signed int semop(signed int, struct sembuf *, unsigned long int);
// serial_allocation
// file mem.c line 476
static void * serial_allocation(struct serial_allocator *serial_alloc, unsigned long int size);
// serial_allocator_alloc
// file mem.c line 499
static void * serial_allocator_alloc(struct ci_mem_allocator *allocator, unsigned long int size);
// serial_allocator_build
// file mem.c line 453
static struct serial_allocator * serial_allocator_build(signed int size);
// serial_allocator_destroy
// file mem.c line 530
static void serial_allocator_destroy(struct ci_mem_allocator *allocator);
// serial_allocator_free
// file mem.c line 508
static void serial_allocator_free(struct ci_mem_allocator *allocator, void *p);
// serial_allocator_reset
// file mem.c line 513
static void serial_allocator_reset(struct ci_mem_allocator *allocator);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// shm_open
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 144
extern signed int shm_open(const char *, signed int, unsigned int);
// shm_unlink
// file /usr/include/x86_64-linux-gnu/sys/mman.h line 147
extern signed int shm_unlink(const char *);
// shmat
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 56
extern void * shmat(signed int, const void *, signed int);
// shmctl
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 50
extern signed int shmctl(signed int, signed int, struct shmid_ds *);
// shmdt
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 60
extern signed int shmdt(const void *);
// shmget
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 53
extern signed int shmget(signed int, unsigned long int, signed int);
// shutdown
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 261
extern signed int shutdown(signed int, signed int);
// sizeof_pack_allocator
// file mem.c line 735
static unsigned long int sizeof_pack_allocator();
// sizeofencaps
// file header.c line 613
signed int sizeofencaps(struct ci_encaps_entity *e);
// sizeofheader
// file header.c line 600
signed int sizeofheader(struct ci_headers_list *h);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// spec_data_check
// file acl.c line 699
signed int spec_data_check(const struct ci_acl_spec *spec, const void *req_raw_data);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// stat64
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 216
extern signed int stat64(const char *, struct stat *);
// stat_entry_add
// file stats.c line 40
signed int stat_entry_add(struct stat_entry_list *list, const char *label, signed int type, signed int gid);
// stat_entry_by_name
// file stats.c line 88
signed int stat_entry_by_name(struct stat_entry_list *list, const char *label);
// stat_entry_release_list
// file stats.c line 75
void stat_entry_release_list(struct stat_entry_list *list);
// stat_group_add
// file stats.c line 100
signed int stat_group_add(char *group);
// stat_memblock_fix
// file stats.c line 273
void stat_memblock_fix(struct stat_memblock *mem_block);
// stat_memblock_reconstruct
// file stats.c line 284
void stat_memblock_reconstruct(struct stat_memblock *mem_block);
// store_db
// file c-icap-mkbdb.c line 266
void store_db(void *key, signed int keysize, void *val, signed int valsize);
// strcasecmp
// file /usr/include/strings.h line 112
extern signed int strcasecmp(const char *, const char *);
// strcasestr
// file /usr/include/string.h line 368
extern char * strcasestr(const char *, const char *);
// strcat
// file /usr/include/string.h line 133
extern char * strcat(char *, const char *);
// strchr
// file /usr/include/string.h line 231
extern char * strchr(const char *, signed int);
// strcmp
// file /usr/include/string.h line 140
extern signed int strcmp(const char *, const char *);
// strcpy
// file /usr/include/string.h line 125
extern char * strcpy(char *, const char *);
// strdup
// file /usr/include/string.h line 171
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 408
extern char * strerror(signed int);
// strerror_r
// file /usr/include/string.h line 433
extern char * strerror_r(signed int, char *, unsigned long int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// string_ext_cmp
// file types_ops.c line 73
signed int string_ext_cmp(const void *key1, const void *key2);
// string_ext_equal
// file types_ops.c line 84
signed int string_ext_equal(const void *key1, const void *key2);
// stringcmp
// file types_ops.c line 41
signed int stringcmp(const void *key1, const void *key2);
// stringdup
// file types_ops.c line 33
void * stringdup(const char *str, struct ci_mem_allocator *allocator);
// stringequal
// file types_ops.c line 48
signed int stringequal(const void *key1, const void *key2);
// stringfree
// file types_ops.c line 60
void stringfree(void *key, struct ci_mem_allocator *allocator);
// stringlen
// file types_ops.c line 55
unsigned long int stringlen(const void *key);
// strlen
// file /usr/include/string.h line 394
extern unsigned long int strlen(const char *);
// strncasecmp
// file /usr/include/strings.h line 116
extern signed int strncasecmp(const char *, const char *, unsigned long int);
// strncat
// file /usr/include/string.h line 136
extern char * strncat(char *, const char *, unsigned long int);
// strncmp
// file /usr/include/string.h line 143
extern signed int strncmp(const char *, const char *, unsigned long int);
// strncpy
// file /usr/include/string.h line 128
extern char * strncpy(char *, const char *, unsigned long int);
// strrchr
// file /usr/include/string.h line 258
extern char * strrchr(const char *, signed int);
// strstr
// file /usr/include/string.h line 337
extern char * strstr(const char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// strtoll
// file /usr/include/stdlib.h line 209
extern signed long long int strtoll(const char *, char ** restrict , signed int);
// sysv_proc_mutex_destroy
// file os/unix/proc_mutex.c line 74
static signed int sysv_proc_mutex_destroy(struct ci_proc_mutex *mutex);
// sysv_proc_mutex_init
// file os/unix/proc_mutex.c line 56
static signed int sysv_proc_mutex_init(struct ci_proc_mutex *mutex, const char *name);
// sysv_proc_mutex_lock
// file os/unix/proc_mutex.c line 83
static signed int sysv_proc_mutex_lock(struct ci_proc_mutex *mutex);
// sysv_proc_mutex_print_info
// file os/unix/proc_mutex.c line 99
static signed int sysv_proc_mutex_print_info(struct ci_proc_mutex *mutex, char *buf, unsigned long int buf_size);
// sysv_proc_mutex_unlock
// file os/unix/proc_mutex.c line 91
static signed int sysv_proc_mutex_unlock(struct ci_proc_mutex *mutex);
// sysv_shared_mem_attach
// file os/unix/shared_mem.c line 56
void * sysv_shared_mem_attach(struct ci_shared_mem_id *id);
// sysv_shared_mem_create
// file os/unix/shared_mem.c line 40
void * sysv_shared_mem_create(struct ci_shared_mem_id *id, const char *name, signed int size);
// sysv_shared_mem_destroy
// file os/unix/shared_mem.c line 73
signed int sysv_shared_mem_destroy(struct ci_shared_mem_id *id);
// sysv_shared_mem_detach
// file os/unix/shared_mem.c line 64
signed int sysv_shared_mem_detach(struct ci_shared_mem_id *id);
// sysv_shared_mem_print_info
// file os/unix/shared_mem.c line 84
signed int sysv_shared_mem_print_info(struct ci_shared_mem_id *id, char *buf, unsigned long int buf_size);
// templateExpired
// file txtTemplate.c line 109
static signed int templateExpired(struct anonymous_22 *template);
// templateFind
// file txtTemplate.c line 208
static struct anonymous_22 * templateFind(const char *SERVICE_NAME, const char *TEMPLATE_NAME, const char *LANGUAGE);
// templateFindFree
// file txtTemplate.c line 228
static struct anonymous_22 * templateFindFree(void);
// templateFree
// file txtTemplate.c line 136
static void templateFree(struct anonymous_22 *template);
// templateLoadText
// file txtTemplate.c line 347
static struct anonymous_22 * templateLoadText(const struct ci_request *req, const char *service_name, const char *page_name);
// templateTryLoadText
// file txtTemplate.c line 251
static struct anonymous_22 * templateTryLoadText(const struct ci_request *req, const char *service_name, const char *page_name, const char *lang);
// template_release
// file txtTemplate.c line 152
static void template_release(struct anonymous_22 *template);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tolower
// file /usr/include/ctype.h line 124
extern signed int tolower(signed int);
// types_add
// file filetype.c line 86
signed int types_add(struct ci_magics_db *db, const char *name, const char *descr, signed int *groups);
// types_init
// file filetype.c line 81
signed int types_init(struct ci_magics_db *db);
// uint64_cmp
// file types_ops.c line 183
signed int uint64_cmp(const void *key1, const void *key2);
// uint64_dup
// file types_ops.c line 166
void * uint64_dup(const char *str, struct ci_mem_allocator *allocator);
// uint64_equal
// file types_ops.c line 196
signed int uint64_equal(const void *key1, const void *key2);
// uint64_free
// file types_ops.c line 204
void uint64_free(void *key, struct ci_mem_allocator *allocator);
// uint64_len
// file types_ops.c line 209
unsigned long int uint64_len(const void *key);
// unlink
// file /usr/include/unistd.h line 829
extern signed int unlink(const char *);
// url_decoder
// file decode.c line 131
signed int url_decoder(const char *input, char *output, signed int output_len);
// url_decoder2
// file decode.c line 164
signed int url_decoder2(char *input);
// vfprintf
// file /usr/include/stdio.h line 371
extern signed int vfprintf(struct _IO_FILE *, const char *, void **);
// vlog_errors
// file c-icap-mkbdb.c line 323
void vlog_errors(void *unused, const char *format, void **ap);
// write
// file /usr/include/unistd.h line 369
extern signed long int write(signed int, const void *, unsigned long int);
// zlib_inflate
// file decode.c line 208
static signed int zlib_inflate(const char *buf, signed int len, char *unzipped_buf, signed int *unzipped_buf_len);

struct anonymous_22
{
  // TEMPLATE_NAME
  char *TEMPLATE_NAME;
  // SERVICE_NAME
  char *SERVICE_NAME;
  // LANGUAGE
  char *LANGUAGE;
  // data
  struct ci_membuf *data;
  // last_used
  signed long int last_used;
  // loaded
  signed long int loaded;
  // modified
  signed long int modified;
  // locked
  signed int locked;
  // must_free
  signed int must_free;
  // non_cached
  signed int non_cached;
};

struct anonymous_3
{
  // sem
  union anonymous_29 *sem;
};

struct anonymous_20
{
  // le_next
  struct __db *le_next;
  // le_prev
  struct __db **le_prev;
};

struct anonymous_19
{
  // lh_first
  struct __db *lh_first;
};

struct anonymous_18
{
  // tqe_next
  struct __db *tqe_next;
  // tqe_prev
  struct __db **tqe_prev;
};

struct anonymous_21
{
  // lh_first
  struct __db_foreign_info *lh_first;
};

struct anonymous_6
{
  // tqe_next
  struct __db_mpoolfile *tqe_next;
  // tqe_prev
  struct __db_mpoolfile **tqe_prev;
};

struct anonymous_8
{
  // tqe_next
  struct __db_txn *tqe_next;
  // tqe_prev
  struct __db_txn **tqe_prev;
};

struct anonymous_23
{
  // tqe_next
  struct __dbc *tqe_next;
  // tqe_prev
  struct __dbc **tqe_prev;
};

struct anonymous_10
{
  // tqh_first
  struct __txn_event *tqh_first;
  // tqh_last
  struct __txn_event **tqh_last;
};

struct anonymous_11
{
  // stqh_first
  struct __txn_logrec *stqh_first;
  // stqh_last
  struct __txn_logrec **stqh_last;
};

struct anonymous_26
{
  // fds_bits
  signed long int fds_bits[16l];
};

struct anonymous_33
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_36
{
  // __lock
  signed int __lock;
  // __nr_readers
  unsigned int __nr_readers;
  // __readers_wakeup
  unsigned int __readers_wakeup;
  // __writer_wakeup
  unsigned int __writer_wakeup;
  // __nr_readers_queued
  unsigned int __nr_readers_queued;
  // __nr_writers_queued
  unsigned int __nr_writers_queued;
  // __writer
  signed int __writer;
  // __shared
  signed int __shared;
  // __rwelision
  signed char __rwelision;
  // __pad1
  unsigned char __pad1[7l];
  // __pad2
  unsigned long int __pad2;
  // __flags
  unsigned int __flags;
};

struct anonymous_5
{
  // fd
  signed int fd;
};

struct anonymous_2
{
  // id
  signed int id;
};

struct anonymous_9
{
  // stqe_next
  signed long int stqe_next;
  // stqe_prev
  signed long int stqe_prev;
};

union anonymous_38
{
  // mutex
  union anonymous_4 *mutex;
  // rwlock
  union anonymous_37 *rwlock;
};

union anonymous
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_29
{
  // __size
  char __size[32l];
  // __align
  signed long int __align;
};

union anonymous_32
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_35
{
  // __size
  char __size[8l];
  // __align
  signed long int __align;
};

union anonymous_0
{
  // __align
  double __align;
  // ptr
  char ptr[1l];
};

union anonymous_34
{
  // __data
  struct anonymous_33 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

union anonymous_37
{
  // __data
  struct anonymous_36 __data;
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

union anonymous_30
{
  // sysv
  struct anonymous_2 sysv;
  // posix
  struct anonymous_3 posix;
  // file
  struct anonymous_5 file;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_4
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct ci_proc_mutex
{
  // name
  char name[64l];
  // scheme
  const struct ci_proc_mutex_scheme *scheme;
  // _anon0
  union anonymous_30 _anon0;
};

union anonymous_1
{
  // proc_mutex
  struct ci_proc_mutex proc_mutex;
  // thread_mutex
  union anonymous_4 thread_mutex;
};

struct posix
{
  // fd
  signed int fd;
};

struct sysv
{
  // id
  signed int id;
};

union anonymous_31
{
  // posix
  struct posix posix;
  // sysv
  struct sysv sysv;
  // id_
  signed int id_;
};

union anonymous_28
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_27
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct __cq_aq
{
  // tqh_first
  struct __dbc *tqh_first;
  // tqh_last
  struct __dbc **tqh_last;
};

struct __cq_fq
{
  // tqh_first
  struct __dbc *tqh_first;
  // tqh_last
  struct __dbc **tqh_last;
};

struct __cq_jq
{
  // tqh_first
  struct __dbc *tqh_first;
  // tqh_last
  struct __dbc **tqh_last;
};

struct __db_lock_u
{
  // off
  unsigned long int off;
  // ndx
  unsigned int ndx;
  // gen
  unsigned int gen;
  // mode
  enum anonymous_16 mode;
};

struct __db_dbt
{
  // data
  void *data;
  // size
  unsigned int size;
  // ulen
  unsigned int ulen;
  // dlen
  unsigned int dlen;
  // doff
  unsigned int doff;
  // app_data
  void *app_data;
  // flags
  unsigned int flags;
};

struct __db
{
  // pgsize
  unsigned int pgsize;
  // priority
  enum anonymous_7 priority;
  // db_append_recno
  signed int (*db_append_recno)(struct __db *, struct __db_dbt *, unsigned int);
  // db_feedback
  void (*db_feedback)(struct __db *, signed int, signed int);
  // dup_compare
  signed int (*dup_compare)(struct __db *, const struct __db_dbt *, const struct __db_dbt *);
  // app_private
  void *app_private;
  // dbenv
  struct __db_env *dbenv;
  // env
  struct __env *env;
  // type
  enum anonymous_17 type;
  // mpf
  struct __db_mpoolfile *mpf;
  // mutex
  unsigned long int mutex;
  // fname
  char *fname;
  // dname
  char *dname;
  // dirname
  const char *dirname;
  // open_flags
  unsigned int open_flags;
  // fileid
  unsigned char fileid[20l];
  // adj_fileid
  unsigned int adj_fileid;
  // log_filename
  struct __fname *log_filename;
  // meta_pgno
  unsigned int meta_pgno;
  // locker
  struct __db_locker *locker;
  // cur_locker
  struct __db_locker *cur_locker;
  // cur_txn
  struct __db_txn *cur_txn;
  // associate_locker
  struct __db_locker *associate_locker;
  // handle_lock
  struct __db_lock_u handle_lock;
  // timestamp
  signed long int timestamp;
  // fid_gen
  unsigned int fid_gen;
  // my_rskey
  struct __db_dbt my_rskey;
  // my_rkey
  struct __db_dbt my_rkey;
  // my_rdata
  struct __db_dbt my_rdata;
  // saved_open_fhp
  struct __fh_t *saved_open_fhp;
  // dblistlinks
  struct anonymous_18 dblistlinks;
  // free_queue
  struct __cq_fq free_queue;
  // active_queue
  struct __cq_aq active_queue;
  // join_queue
  struct __cq_jq join_queue;
  // s_secondaries
  struct anonymous_19 s_secondaries;
  // s_links
  struct anonymous_20 s_links;
  // s_refcnt
  unsigned int s_refcnt;
  // s_callback
  signed int (*s_callback)(struct __db *, const struct __db_dbt *, const struct __db_dbt *, struct __db_dbt *);
  // s_primary
  struct __db *s_primary;
  // s_assoc_flags
  unsigned int s_assoc_flags;
  // f_primaries
  struct anonymous_21 f_primaries;
  // felink
  struct anonymous_18 felink;
  // s_foreign
  struct __db *s_foreign;
  // api_internal
  void *api_internal;
  // bt_internal
  void *bt_internal;
  // h_internal
  void *h_internal;
  // heap_internal
  void *heap_internal;
  // p_internal
  void *p_internal;
  // q_internal
  void *q_internal;
  // associate
  signed int (*associate)(struct __db *, struct __db_txn *, struct __db *, signed int (*)(struct __db *, const struct __db_dbt *, const struct __db_dbt *, struct __db_dbt *), unsigned int);
  // associate_foreign
  signed int (*associate_foreign)(struct __db *, struct __db *, signed int (*)(struct __db *, const struct __db_dbt *, struct __db_dbt *, const struct __db_dbt *, signed int *), unsigned int);
  // close
  signed int (*close)(struct __db *, unsigned int);
  // compact
  signed int (*compact)(struct __db *, struct __db_txn *, struct __db_dbt *, struct __db_dbt *, struct __db_compact *, unsigned int, struct __db_dbt *);
  // cursor
  signed int (*cursor)(struct __db *, struct __db_txn *, struct __dbc **, unsigned int);
  // del
  signed int (*del)(struct __db *, struct __db_txn *, struct __db_dbt *, unsigned int);
  // err
  void (*err)(struct __db *, signed int, const char *, ...);
  // errx
  void (*errx)(struct __db *, const char *, ...);
  // exists
  signed int (*exists)(struct __db *, struct __db_txn *, struct __db_dbt *, unsigned int);
  // fd
  signed int (*fd)(struct __db *, signed int *);
  // get
  signed int (*get)(struct __db *, struct __db_txn *, struct __db_dbt *, struct __db_dbt *, unsigned int);
  // get_alloc
  signed int (*get_alloc)(struct __db *, void * (**)(unsigned long int), void * (**)(void *, unsigned long int), void (**)(void *));
  // get_append_recno
  signed int (*get_append_recno)(struct __db *, signed int (**)(struct __db *, struct __db_dbt *, unsigned int));
  // get_assoc_flags
  signed int (*get_assoc_flags)(struct __db *, unsigned int *);
  // get_bt_compare
  signed int (*get_bt_compare)(struct __db *, signed int (**)(struct __db *, const struct __db_dbt *, const struct __db_dbt *));
  // get_bt_compress
  signed int (*get_bt_compress)(struct __db *, signed int (**)(struct __db *, const struct __db_dbt *, const struct __db_dbt *, const struct __db_dbt *, const struct __db_dbt *, struct __db_dbt *), signed int (**)(struct __db *, const struct __db_dbt *, const struct __db_dbt *, struct __db_dbt *, struct __db_dbt *, struct __db_dbt *));
  // get_bt_minkey
  signed int (*get_bt_minkey)(struct __db *, unsigned int *);
  // get_bt_prefix
  signed int (*get_bt_prefix)(struct __db *, unsigned long int (**)(struct __db *, const struct __db_dbt *, const struct __db_dbt *));
  // get_byteswapped
  signed int (*get_byteswapped)(struct __db *, signed int *);
  // get_cachesize
  signed int (*get_cachesize)(struct __db *, unsigned int *, unsigned int *, signed int *);
  // get_create_dir
  signed int (*get_create_dir)(struct __db *, const char **);
  // get_dbname
  signed int (*get_dbname)(struct __db *, const char **, const char **);
  // get_dup_compare
  signed int (*get_dup_compare)(struct __db *, signed int (**)(struct __db *, const struct __db_dbt *, const struct __db_dbt *));
  // get_encrypt_flags
  signed int (*get_encrypt_flags)(struct __db *, unsigned int *);
  // get_env
  struct __db_env * (*get_env)(struct __db *);
  // get_errcall
  void (*get_errcall)(struct __db *, void (**)(const struct __db_env *, const char *, const char *));
  // get_errfile
  void (*get_errfile)(struct __db *, struct _IO_FILE **);
  // get_errpfx
  void (*get_errpfx)(struct __db *, const char **);
  // get_feedback
  signed int (*get_feedback)(struct __db *, void (**)(struct __db *, signed int, signed int));
  // get_flags
  signed int (*get_flags)(struct __db *, unsigned int *);
  // get_h_compare
  signed int (*get_h_compare)(struct __db *, signed int (**)(struct __db *, const struct __db_dbt *, const struct __db_dbt *));
  // get_h_ffactor
  signed int (*get_h_ffactor)(struct __db *, unsigned int *);
  // get_h_hash
  signed int (*get_h_hash)(struct __db *, unsigned int (**)(struct __db *, const void *, unsigned int));
  // get_h_nelem
  signed int (*get_h_nelem)(struct __db *, unsigned int *);
  // get_heapsize
  signed int (*get_heapsize)(struct __db *, unsigned int *, unsigned int *);
  // get_heap_regionsize
  signed int (*get_heap_regionsize)(struct __db *, unsigned int *);
  // get_lk_exclusive
  signed int (*get_lk_exclusive)(struct __db *, signed int *, signed int *);
  // get_lorder
  signed int (*get_lorder)(struct __db *, signed int *);
  // get_mpf
  struct __db_mpoolfile * (*get_mpf)(struct __db *);
  // get_msgcall
  void (*get_msgcall)(struct __db *, void (**)(const struct __db_env *, const char *));
  // get_msgfile
  void (*get_msgfile)(struct __db *, struct _IO_FILE **);
  // get_multiple
  signed int (*get_multiple)(struct __db *);
  // get_open_flags
  signed int (*get_open_flags)(struct __db *, unsigned int *);
  // get_pagesize
  signed int (*get_pagesize)(struct __db *, unsigned int *);
  // get_partition_callback
  signed int (*get_partition_callback)(struct __db *, unsigned int *, unsigned int (**)(struct __db *, struct __db_dbt *));
  // get_partition_dirs
  signed int (*get_partition_dirs)(struct __db *, const char ***);
  // get_partition_keys
  signed int (*get_partition_keys)(struct __db *, unsigned int *, struct __db_dbt **);
  // get_priority
  signed int (*get_priority)(struct __db *, enum anonymous_7 *);
  // get_q_extentsize
  signed int (*get_q_extentsize)(struct __db *, unsigned int *);
  // get_re_delim
  signed int (*get_re_delim)(struct __db *, signed int *);
  // get_re_len
  signed int (*get_re_len)(struct __db *, unsigned int *);
  // get_re_pad
  signed int (*get_re_pad)(struct __db *, signed int *);
  // get_re_source
  signed int (*get_re_source)(struct __db *, const char **);
  // get_transactional
  signed int (*get_transactional)(struct __db *);
  // get_type
  signed int (*get_type)(struct __db *, enum anonymous_17 *);
  // join
  signed int (*join)(struct __db *, struct __dbc **, struct __dbc **, unsigned int);
  // key_range
  signed int (*key_range)(struct __db *, struct __db_txn *, struct __db_dbt *, struct __key_range *, unsigned int);
  // open
  signed int (*open)(struct __db *, struct __db_txn *, const char *, const char *, enum anonymous_17, unsigned int, signed int);
  // pget
  signed int (*pget)(struct __db *, struct __db_txn *, struct __db_dbt *, struct __db_dbt *, struct __db_dbt *, unsigned int);
  // put
  signed int (*put)(struct __db *, struct __db_txn *, struct __db_dbt *, struct __db_dbt *, unsigned int);
  // remove
  signed int (*remove)(struct __db *, const char *, const char *, unsigned int);
  // rename
  signed int (*rename)(struct __db *, const char *, const char *, const char *, unsigned int);
  // set_alloc
  signed int (*set_alloc)(struct __db *, void * (*)(unsigned long int), void * (*)(void *, unsigned long int), void (*)(void *));
  // set_append_recno
  signed int (*set_append_recno)(struct __db *, signed int (*)(struct __db *, struct __db_dbt *, unsigned int));
  // set_bt_compare
  signed int (*set_bt_compare)(struct __db *, signed int (*)(struct __db *, const struct __db_dbt *, const struct __db_dbt *));
  // set_bt_compress
  signed int (*set_bt_compress)(struct __db *, signed int (*)(struct __db *, const struct __db_dbt *, const struct __db_dbt *, const struct __db_dbt *, const struct __db_dbt *, struct __db_dbt *), signed int (*)(struct __db *, const struct __db_dbt *, const struct __db_dbt *, struct __db_dbt *, struct __db_dbt *, struct __db_dbt *));
  // set_bt_minkey
  signed int (*set_bt_minkey)(struct __db *, unsigned int);
  // set_bt_prefix
  signed int (*set_bt_prefix)(struct __db *, unsigned long int (*)(struct __db *, const struct __db_dbt *, const struct __db_dbt *));
  // set_cachesize
  signed int (*set_cachesize)(struct __db *, unsigned int, unsigned int, signed int);
  // set_create_dir
  signed int (*set_create_dir)(struct __db *, const char *);
  // set_dup_compare
  signed int (*set_dup_compare)(struct __db *, signed int (*)(struct __db *, const struct __db_dbt *, const struct __db_dbt *));
  // set_encrypt
  signed int (*set_encrypt)(struct __db *, const char *, unsigned int);
  // set_errcall
  void (*set_errcall)(struct __db *, void (*)(const struct __db_env *, const char *, const char *));
  // set_errfile
  void (*set_errfile)(struct __db *, struct _IO_FILE *);
  // set_errpfx
  void (*set_errpfx)(struct __db *, const char *);
  // set_feedback
  signed int (*set_feedback)(struct __db *, void (*)(struct __db *, signed int, signed int));
  // set_flags
  signed int (*set_flags)(struct __db *, unsigned int);
  // set_h_compare
  signed int (*set_h_compare)(struct __db *, signed int (*)(struct __db *, const struct __db_dbt *, const struct __db_dbt *));
  // set_h_ffactor
  signed int (*set_h_ffactor)(struct __db *, unsigned int);
  // set_h_hash
  signed int (*set_h_hash)(struct __db *, unsigned int (*)(struct __db *, const void *, unsigned int));
  // set_h_nelem
  signed int (*set_h_nelem)(struct __db *, unsigned int);
  // set_heapsize
  signed int (*set_heapsize)(struct __db *, unsigned int, unsigned int, unsigned int);
  // set_heap_regionsize
  signed int (*set_heap_regionsize)(struct __db *, unsigned int);
  // set_lk_exclusive
  signed int (*set_lk_exclusive)(struct __db *, signed int);
  // set_lorder
  signed int (*set_lorder)(struct __db *, signed int);
  // set_msgcall
  void (*set_msgcall)(struct __db *, void (*)(const struct __db_env *, const char *));
  // set_msgfile
  void (*set_msgfile)(struct __db *, struct _IO_FILE *);
  // set_pagesize
  signed int (*set_pagesize)(struct __db *, unsigned int);
  // set_paniccall
  signed int (*set_paniccall)(struct __db *, void (*)(struct __db_env *, signed int));
  // set_partition
  signed int (*set_partition)(struct __db *, unsigned int, struct __db_dbt *, unsigned int (*)(struct __db *, struct __db_dbt *));
  // set_partition_dirs
  signed int (*set_partition_dirs)(struct __db *, const char **);
  // set_priority
  signed int (*set_priority)(struct __db *, enum anonymous_7);
  // set_q_extentsize
  signed int (*set_q_extentsize)(struct __db *, unsigned int);
  // set_re_delim
  signed int (*set_re_delim)(struct __db *, signed int);
  // set_re_len
  signed int (*set_re_len)(struct __db *, unsigned int);
  // set_re_pad
  signed int (*set_re_pad)(struct __db *, signed int);
  // set_re_source
  signed int (*set_re_source)(struct __db *, const char *);
  // sort_multiple
  signed int (*sort_multiple)(struct __db *, struct __db_dbt *, struct __db_dbt *, unsigned int);
  // stat
  signed int (*stat)(struct __db *, struct __db_txn *, void *, unsigned int);
  // stat_print
  signed int (*stat_print)(struct __db *, unsigned int);
  // sync
  signed int (*sync)(struct __db *, unsigned int);
  // truncate
  signed int (*truncate)(struct __db *, struct __db_txn *, unsigned int *, unsigned int);
  // upgrade
  signed int (*upgrade)(struct __db *, const char *, unsigned int);
  // verify
  signed int (*verify)(struct __db *, const char *, const char *, struct _IO_FILE *, unsigned int);
  // dump
  signed int (*dump)(struct __db *, const char *, signed int (*)(void *, const void *), void *, signed int, signed int);
  // db_am_remove
  signed int (*db_am_remove)(struct __db *, struct __db_thread_info *, struct __db_txn *, const char *, const char *, unsigned int);
  // db_am_rename
  signed int (*db_am_rename)(struct __db *, struct __db_thread_info *, struct __db_txn *, const char *, const char *, const char *);
  // stored_get
  signed int (*stored_get)(struct __db *, struct __db_txn *, struct __db_dbt *, struct __db_dbt *, unsigned int);
  // stored_close
  signed int (*stored_close)(struct __db *, unsigned int);
  // alt_close
  signed int (*alt_close)(struct __db *, unsigned int);
  // am_ok
  unsigned int am_ok;
  // preserve_fid
  signed int preserve_fid;
  // orig_flags
  unsigned int orig_flags;
  // flags
  unsigned int flags;
  // orig_flags2
  unsigned int orig_flags2;
  // flags2
  unsigned int flags2;
};

struct __db_channel
{
  // channel
  struct __channel *channel;
  // eid
  signed int eid;
  // timeout
  unsigned int timeout;
  // close
  signed int (*close)(struct __db_channel *, unsigned int);
  // send_msg
  signed int (*send_msg)(struct __db_channel *, struct __db_dbt *, unsigned int, unsigned int);
  // send_request
  signed int (*send_request)(struct __db_channel *, struct __db_dbt *, unsigned int, struct __db_dbt *, unsigned int, unsigned int);
  // set_timeout
  signed int (*set_timeout)(struct __db_channel *, unsigned int);
};

struct __db_compact
{
  // compact_fillpercent
  unsigned int compact_fillpercent;
  // compact_timeout
  unsigned int compact_timeout;
  // compact_pages
  unsigned int compact_pages;
  // compact_empty_buckets
  unsigned int compact_empty_buckets;
  // compact_pages_free
  unsigned int compact_pages_free;
  // compact_pages_examine
  unsigned int compact_pages_examine;
  // compact_levels
  unsigned int compact_levels;
  // compact_deadlock
  unsigned int compact_deadlock;
  // compact_pages_truncated
  unsigned int compact_pages_truncated;
  // compact_truncate
  unsigned int compact_truncate;
};

struct __db_env
{
  // env
  struct __env *env;
  // mtx_db_env
  unsigned long int mtx_db_env;
  // db_errcall
  void (*db_errcall)(const struct __db_env *, const char *, const char *);
  // db_errfile
  struct _IO_FILE *db_errfile;
  // db_errpfx
  const char *db_errpfx;
  // db_msgcall
  void (*db_msgcall)(const struct __db_env *, const char *);
  // db_msgfile
  struct _IO_FILE *db_msgfile;
  // app_dispatch
  signed int (*app_dispatch)(struct __db_env *, struct __db_dbt *, struct __db_lsn *, enum anonymous_13);
  // db_event_func
  void (*db_event_func)(struct __db_env *, unsigned int, void *);
  // db_feedback
  void (*db_feedback)(struct __db_env *, signed int, signed int);
  // db_free
  void (*db_free)(void *);
  // db_paniccall
  void (*db_paniccall)(struct __db_env *, signed int);
  // db_malloc
  void * (*db_malloc)(unsigned long int);
  // db_realloc
  void * (*db_realloc)(void *, unsigned long int);
  // is_alive
  signed int (*is_alive)(struct __db_env *, signed int, unsigned long int, unsigned int);
  // thread_id
  void (*thread_id)(struct __db_env *, signed int *, unsigned long int *);
  // thread_id_string
  char * (*thread_id_string)(struct __db_env *, signed int, unsigned long int, char *);
  // db_log_dir
  char *db_log_dir;
  // db_md_dir
  char *db_md_dir;
  // db_tmp_dir
  char *db_tmp_dir;
  // db_create_dir
  char *db_create_dir;
  // db_data_dir
  char **db_data_dir;
  // data_cnt
  signed int data_cnt;
  // data_next
  signed int data_next;
  // intermediate_dir_mode
  char *intermediate_dir_mode;
  // shm_key
  signed long int shm_key;
  // passwd
  char *passwd;
  // passwd_len
  unsigned long int passwd_len;
  // app_private
  void *app_private;
  // api1_internal
  void *api1_internal;
  // api2_internal
  void *api2_internal;
  // verbose
  unsigned int verbose;
  // mutex_align
  unsigned int mutex_align;
  // mutex_cnt
  unsigned int mutex_cnt;
  // mutex_inc
  unsigned int mutex_inc;
  // mutex_max
  unsigned int mutex_max;
  // mutex_tas_spins
  unsigned int mutex_tas_spins;
  // lk_conflicts
  unsigned char *lk_conflicts;
  // lk_modes
  signed int lk_modes;
  // lk_detect
  unsigned int lk_detect;
  // lk_max
  unsigned int lk_max;
  // lk_max_lockers
  unsigned int lk_max_lockers;
  // lk_max_objects
  unsigned int lk_max_objects;
  // lk_init
  unsigned int lk_init;
  // lk_init_lockers
  unsigned int lk_init_lockers;
  // lk_init_objects
  unsigned int lk_init_objects;
  // lk_partitions
  unsigned int lk_partitions;
  // lk_timeout
  unsigned int lk_timeout;
  // locker_t_size
  unsigned int locker_t_size;
  // object_t_size
  unsigned int object_t_size;
  // lg_bsize
  unsigned int lg_bsize;
  // lg_fileid_init
  unsigned int lg_fileid_init;
  // lg_filemode
  signed int lg_filemode;
  // lg_regionmax
  unsigned int lg_regionmax;
  // lg_size
  unsigned int lg_size;
  // lg_flags
  unsigned int lg_flags;
  // mp_gbytes
  unsigned int mp_gbytes;
  // mp_bytes
  unsigned int mp_bytes;
  // mp_max_gbytes
  unsigned int mp_max_gbytes;
  // mp_max_bytes
  unsigned int mp_max_bytes;
  // mp_mmapsize
  unsigned long int mp_mmapsize;
  // mp_maxopenfd
  signed int mp_maxopenfd;
  // mp_maxwrite
  signed int mp_maxwrite;
  // mp_ncache
  unsigned int mp_ncache;
  // mp_pagesize
  unsigned int mp_pagesize;
  // mp_tablesize
  unsigned int mp_tablesize;
  // mp_mtxcount
  unsigned int mp_mtxcount;
  // mp_maxwrite_sleep
  unsigned int mp_maxwrite_sleep;
  // tx_init
  unsigned int tx_init;
  // tx_max
  unsigned int tx_max;
  // tx_timestamp
  signed long int tx_timestamp;
  // tx_timeout
  unsigned int tx_timeout;
  // thr_init
  unsigned int thr_init;
  // thr_max
  unsigned int thr_max;
  // memory_max
  unsigned long int memory_max;
  // registry
  struct __fh_t *registry;
  // registry_off
  unsigned int registry_off;
  // envreg_timeout
  unsigned int envreg_timeout;
  // flags
  unsigned int flags;
  // add_data_dir
  signed int (*add_data_dir)(struct __db_env *, const char *);
  // backup
  signed int (*backup)(struct __db_env *, const char *, unsigned int);
  // cdsgroup_begin
  signed int (*cdsgroup_begin)(struct __db_env *, struct __db_txn **);
  // close
  signed int (*close)(struct __db_env *, unsigned int);
  // dbbackup
  signed int (*dbbackup)(struct __db_env *, const char *, const char *, unsigned int);
  // dbremove
  signed int (*dbremove)(struct __db_env *, struct __db_txn *, const char *, const char *, unsigned int);
  // dbrename
  signed int (*dbrename)(struct __db_env *, struct __db_txn *, const char *, const char *, const char *, unsigned int);
  // err
  void (*err)(const struct __db_env *, signed int, const char *, ...);
  // errx
  void (*errx)(const struct __db_env *, const char *, ...);
  // failchk
  signed int (*failchk)(struct __db_env *, unsigned int);
  // fileid_reset
  signed int (*fileid_reset)(struct __db_env *, const char *, unsigned int);
  // get_alloc
  signed int (*get_alloc)(struct __db_env *, void * (**)(unsigned long int), void * (**)(void *, unsigned long int), void (**)(void *));
  // get_app_dispatch
  signed int (*get_app_dispatch)(struct __db_env *, signed int (**)(struct __db_env *, struct __db_dbt *, struct __db_lsn *, enum anonymous_13));
  // get_cache_max
  signed int (*get_cache_max)(struct __db_env *, unsigned int *, unsigned int *);
  // get_cachesize
  signed int (*get_cachesize)(struct __db_env *, unsigned int *, unsigned int *, signed int *);
  // get_create_dir
  signed int (*get_create_dir)(struct __db_env *, const char **);
  // get_data_dirs
  signed int (*get_data_dirs)(struct __db_env *, const char ***);
  // get_data_len
  signed int (*get_data_len)(struct __db_env *, unsigned int *);
  // get_backup_callbacks
  signed int (*get_backup_callbacks)(struct __db_env *, signed int (**)(struct __db_env *, const char *, const char *, void **), signed int (**)(struct __db_env *, unsigned int, unsigned int, unsigned int, unsigned char *, void *), signed int (**)(struct __db_env *, const char *, void *));
  // get_backup_config
  signed int (*get_backup_config)(struct __db_env *, enum anonymous_14, unsigned int *);
  // get_encrypt_flags
  signed int (*get_encrypt_flags)(struct __db_env *, unsigned int *);
  // get_errcall
  void (*get_errcall)(struct __db_env *, void (**)(const struct __db_env *, const char *, const char *));
  // get_errfile
  void (*get_errfile)(struct __db_env *, struct _IO_FILE **);
  // get_errpfx
  void (*get_errpfx)(struct __db_env *, const char **);
  // get_flags
  signed int (*get_flags)(struct __db_env *, unsigned int *);
  // get_feedback
  signed int (*get_feedback)(struct __db_env *, void (**)(struct __db_env *, signed int, signed int));
  // get_home
  signed int (*get_home)(struct __db_env *, const char **);
  // get_intermediate_dir_mode
  signed int (*get_intermediate_dir_mode)(struct __db_env *, const char **);
  // get_isalive
  signed int (*get_isalive)(struct __db_env *, signed int (**)(struct __db_env *, signed int, unsigned long int, unsigned int));
  // get_lg_bsize
  signed int (*get_lg_bsize)(struct __db_env *, unsigned int *);
  // get_lg_dir
  signed int (*get_lg_dir)(struct __db_env *, const char **);
  // get_lg_filemode
  signed int (*get_lg_filemode)(struct __db_env *, signed int *);
  // get_lg_max
  signed int (*get_lg_max)(struct __db_env *, unsigned int *);
  // get_lg_regionmax
  signed int (*get_lg_regionmax)(struct __db_env *, unsigned int *);
  // get_lk_conflicts
  signed int (*get_lk_conflicts)(struct __db_env *, const unsigned char **, signed int *);
  // get_lk_detect
  signed int (*get_lk_detect)(struct __db_env *, unsigned int *);
  // get_lk_max_lockers
  signed int (*get_lk_max_lockers)(struct __db_env *, unsigned int *);
  // get_lk_max_locks
  signed int (*get_lk_max_locks)(struct __db_env *, unsigned int *);
  // get_lk_max_objects
  signed int (*get_lk_max_objects)(struct __db_env *, unsigned int *);
  // get_lk_partitions
  signed int (*get_lk_partitions)(struct __db_env *, unsigned int *);
  // get_lk_priority
  signed int (*get_lk_priority)(struct __db_env *, unsigned int, unsigned int *);
  // get_lk_tablesize
  signed int (*get_lk_tablesize)(struct __db_env *, unsigned int *);
  // get_memory_init
  signed int (*get_memory_init)(struct __db_env *, enum anonymous_15, unsigned int *);
  // get_memory_max
  signed int (*get_memory_max)(struct __db_env *, unsigned int *, unsigned int *);
  // get_metadata_dir
  signed int (*get_metadata_dir)(struct __db_env *, const char **);
  // get_mp_max_openfd
  signed int (*get_mp_max_openfd)(struct __db_env *, signed int *);
  // get_mp_max_write
  signed int (*get_mp_max_write)(struct __db_env *, signed int *, unsigned int *);
  // get_mp_mmapsize
  signed int (*get_mp_mmapsize)(struct __db_env *, unsigned long int *);
  // get_mp_mtxcount
  signed int (*get_mp_mtxcount)(struct __db_env *, unsigned int *);
  // get_mp_pagesize
  signed int (*get_mp_pagesize)(struct __db_env *, unsigned int *);
  // get_mp_tablesize
  signed int (*get_mp_tablesize)(struct __db_env *, unsigned int *);
  // get_msgcall
  void (*get_msgcall)(struct __db_env *, void (**)(const struct __db_env *, const char *));
  // get_msgfile
  void (*get_msgfile)(struct __db_env *, struct _IO_FILE **);
  // get_open_flags
  signed int (*get_open_flags)(struct __db_env *, unsigned int *);
  // get_shm_key
  signed int (*get_shm_key)(struct __db_env *, signed long int *);
  // get_thread_count
  signed int (*get_thread_count)(struct __db_env *, unsigned int *);
  // get_thread_id_fn
  signed int (*get_thread_id_fn)(struct __db_env *, void (**)(struct __db_env *, signed int *, unsigned long int *));
  // get_thread_id_string_fn
  signed int (*get_thread_id_string_fn)(struct __db_env *, char * (**)(struct __db_env *, signed int, unsigned long int, char *));
  // get_timeout
  signed int (*get_timeout)(struct __db_env *, unsigned int *, unsigned int);
  // get_tmp_dir
  signed int (*get_tmp_dir)(struct __db_env *, const char **);
  // get_tx_max
  signed int (*get_tx_max)(struct __db_env *, unsigned int *);
  // get_tx_timestamp
  signed int (*get_tx_timestamp)(struct __db_env *, signed long int *);
  // get_verbose
  signed int (*get_verbose)(struct __db_env *, unsigned int, signed int *);
  // is_bigendian
  signed int (*is_bigendian)(void);
  // lock_detect
  signed int (*lock_detect)(struct __db_env *, unsigned int, unsigned int, signed int *);
  // lock_get
  signed int (*lock_get)(struct __db_env *, unsigned int, unsigned int, struct __db_dbt *, enum anonymous_16, struct __db_lock_u *);
  // lock_id
  signed int (*lock_id)(struct __db_env *, unsigned int *);
  // lock_id_free
  signed int (*lock_id_free)(struct __db_env *, unsigned int);
  // lock_put
  signed int (*lock_put)(struct __db_env *, struct __db_lock_u *);
  // lock_stat
  signed int (*lock_stat)(struct __db_env *, struct __db_lock_stat **, unsigned int);
  // lock_stat_print
  signed int (*lock_stat_print)(struct __db_env *, unsigned int);
  // lock_vec
  signed int (*lock_vec)(struct __db_env *, unsigned int, unsigned int, struct __db_lockreq *, signed int, struct __db_lockreq **);
  // log_archive
  signed int (*log_archive)(struct __db_env *, char ***, unsigned int);
  // log_cursor
  signed int (*log_cursor)(struct __db_env *, struct __db_log_cursor **, unsigned int);
  // log_file
  signed int (*log_file)(struct __db_env *, const struct __db_lsn *, char *, unsigned long int);
  // log_flush
  signed int (*log_flush)(struct __db_env *, const struct __db_lsn *);
  // log_get_config
  signed int (*log_get_config)(struct __db_env *, unsigned int, signed int *);
  // log_printf
  signed int (*log_printf)(struct __db_env *, struct __db_txn *, const char *, ...);
  // log_put
  signed int (*log_put)(struct __db_env *, struct __db_lsn *, const struct __db_dbt *, unsigned int);
  // log_put_record
  signed int (*log_put_record)(struct __db_env *, struct __db *, struct __db_txn *, struct __db_lsn *, unsigned int, unsigned int, unsigned int, unsigned int, struct __log_rec_spec *, ...);
  // log_read_record
  signed int (*log_read_record)(struct __db_env *, struct __db **, void *, void *, struct __log_rec_spec *, unsigned int, void **);
  // log_set_config
  signed int (*log_set_config)(struct __db_env *, unsigned int, signed int);
  // log_stat
  signed int (*log_stat)(struct __db_env *, struct __db_log_stat **, unsigned int);
  // log_stat_print
  signed int (*log_stat_print)(struct __db_env *, unsigned int);
  // log_verify
  signed int (*log_verify)(struct __db_env *, const struct __db_logvrfy_config *);
  // lsn_reset
  signed int (*lsn_reset)(struct __db_env *, const char *, unsigned int);
  // memp_fcreate
  signed int (*memp_fcreate)(struct __db_env *, struct __db_mpoolfile **, unsigned int);
  // memp_register
  signed int (*memp_register)(struct __db_env *, signed int, signed int (*)(struct __db_env *, unsigned int, void *, struct __db_dbt *), signed int (*)(struct __db_env *, unsigned int, void *, struct __db_dbt *));
  // memp_stat
  signed int (*memp_stat)(struct __db_env *, struct __db_mpool_stat **, struct __db_mpool_fstat ***, unsigned int);
  // memp_stat_print
  signed int (*memp_stat_print)(struct __db_env *, unsigned int);
  // memp_sync
  signed int (*memp_sync)(struct __db_env *, struct __db_lsn *);
  // memp_trickle
  signed int (*memp_trickle)(struct __db_env *, signed int, signed int *);
  // mutex_alloc
  signed int (*mutex_alloc)(struct __db_env *, unsigned int, unsigned long int *);
  // mutex_free
  signed int (*mutex_free)(struct __db_env *, unsigned long int);
  // mutex_get_align
  signed int (*mutex_get_align)(struct __db_env *, unsigned int *);
  // mutex_get_increment
  signed int (*mutex_get_increment)(struct __db_env *, unsigned int *);
  // mutex_get_init
  signed int (*mutex_get_init)(struct __db_env *, unsigned int *);
  // mutex_get_max
  signed int (*mutex_get_max)(struct __db_env *, unsigned int *);
  // mutex_get_tas_spins
  signed int (*mutex_get_tas_spins)(struct __db_env *, unsigned int *);
  // mutex_lock
  signed int (*mutex_lock)(struct __db_env *, unsigned long int);
  // mutex_set_align
  signed int (*mutex_set_align)(struct __db_env *, unsigned int);
  // mutex_set_increment
  signed int (*mutex_set_increment)(struct __db_env *, unsigned int);
  // mutex_set_init
  signed int (*mutex_set_init)(struct __db_env *, unsigned int);
  // mutex_set_max
  signed int (*mutex_set_max)(struct __db_env *, unsigned int);
  // mutex_set_tas_spins
  signed int (*mutex_set_tas_spins)(struct __db_env *, unsigned int);
  // mutex_stat
  signed int (*mutex_stat)(struct __db_env *, struct __db_mutex_stat **, unsigned int);
  // mutex_stat_print
  signed int (*mutex_stat_print)(struct __db_env *, unsigned int);
  // mutex_unlock
  signed int (*mutex_unlock)(struct __db_env *, unsigned long int);
  // open
  signed int (*open)(struct __db_env *, const char *, unsigned int, signed int);
  // remove
  signed int (*remove)(struct __db_env *, const char *, unsigned int);
  // rep_elect
  signed int (*rep_elect)(struct __db_env *, unsigned int, unsigned int, unsigned int);
  // rep_flush
  signed int (*rep_flush)(struct __db_env *);
  // rep_get_clockskew
  signed int (*rep_get_clockskew)(struct __db_env *, unsigned int *, unsigned int *);
  // rep_get_config
  signed int (*rep_get_config)(struct __db_env *, unsigned int, signed int *);
  // rep_get_limit
  signed int (*rep_get_limit)(struct __db_env *, unsigned int *, unsigned int *);
  // rep_get_nsites
  signed int (*rep_get_nsites)(struct __db_env *, unsigned int *);
  // rep_get_priority
  signed int (*rep_get_priority)(struct __db_env *, unsigned int *);
  // rep_get_request
  signed int (*rep_get_request)(struct __db_env *, unsigned int *, unsigned int *);
  // rep_get_timeout
  signed int (*rep_get_timeout)(struct __db_env *, signed int, unsigned int *);
  // rep_process_message
  signed int (*rep_process_message)(struct __db_env *, struct __db_dbt *, struct __db_dbt *, signed int, struct __db_lsn *);
  // rep_set_clockskew
  signed int (*rep_set_clockskew)(struct __db_env *, unsigned int, unsigned int);
  // rep_set_config
  signed int (*rep_set_config)(struct __db_env *, unsigned int, signed int);
  // rep_set_limit
  signed int (*rep_set_limit)(struct __db_env *, unsigned int, unsigned int);
  // rep_set_nsites
  signed int (*rep_set_nsites)(struct __db_env *, unsigned int);
  // rep_set_priority
  signed int (*rep_set_priority)(struct __db_env *, unsigned int);
  // rep_set_request
  signed int (*rep_set_request)(struct __db_env *, unsigned int, unsigned int);
  // rep_set_timeout
  signed int (*rep_set_timeout)(struct __db_env *, signed int, unsigned int);
  // rep_set_transport
  signed int (*rep_set_transport)(struct __db_env *, signed int, signed int (*)(struct __db_env *, const struct __db_dbt *, const struct __db_dbt *, const struct __db_lsn *, signed int, unsigned int));
  // rep_start
  signed int (*rep_start)(struct __db_env *, struct __db_dbt *, unsigned int);
  // rep_stat
  signed int (*rep_stat)(struct __db_env *, struct __db_rep_stat **, unsigned int);
  // rep_stat_print
  signed int (*rep_stat_print)(struct __db_env *, unsigned int);
  // rep_sync
  signed int (*rep_sync)(struct __db_env *, unsigned int);
  // repmgr_channel
  signed int (*repmgr_channel)(struct __db_env *, signed int, struct __db_channel **, unsigned int);
  // repmgr_get_ack_policy
  signed int (*repmgr_get_ack_policy)(struct __db_env *, signed int *);
  // repmgr_local_site
  signed int (*repmgr_local_site)(struct __db_env *, struct __db_site **);
  // repmgr_msg_dispatch
  signed int (*repmgr_msg_dispatch)(struct __db_env *, void (*)(struct __db_env *, struct __db_channel *, struct __db_dbt *, unsigned int, unsigned int), unsigned int);
  // repmgr_set_ack_policy
  signed int (*repmgr_set_ack_policy)(struct __db_env *, signed int);
  // repmgr_site
  signed int (*repmgr_site)(struct __db_env *, const char *, unsigned int, struct __db_site **, unsigned int);
  // repmgr_site_by_eid
  signed int (*repmgr_site_by_eid)(struct __db_env *, signed int, struct __db_site **);
  // repmgr_site_list
  signed int (*repmgr_site_list)(struct __db_env *, unsigned int *, struct __db_repmgr_site **);
  // repmgr_start
  signed int (*repmgr_start)(struct __db_env *, signed int, unsigned int);
  // repmgr_stat
  signed int (*repmgr_stat)(struct __db_env *, struct __db_repmgr_stat **, unsigned int);
  // repmgr_stat_print
  signed int (*repmgr_stat_print)(struct __db_env *, unsigned int);
  // set_alloc
  signed int (*set_alloc)(struct __db_env *, void * (*)(unsigned long int), void * (*)(void *, unsigned long int), void (*)(void *));
  // set_app_dispatch
  signed int (*set_app_dispatch)(struct __db_env *, signed int (*)(struct __db_env *, struct __db_dbt *, struct __db_lsn *, enum anonymous_13));
  // set_cache_max
  signed int (*set_cache_max)(struct __db_env *, unsigned int, unsigned int);
  // set_cachesize
  signed int (*set_cachesize)(struct __db_env *, unsigned int, unsigned int, signed int);
  // set_create_dir
  signed int (*set_create_dir)(struct __db_env *, const char *);
  // set_data_dir
  signed int (*set_data_dir)(struct __db_env *, const char *);
  // set_data_len
  signed int (*set_data_len)(struct __db_env *, unsigned int);
  // set_backup_callbacks
  signed int (*set_backup_callbacks)(struct __db_env *, signed int (*)(struct __db_env *, const char *, const char *, void **), signed int (*)(struct __db_env *, unsigned int, unsigned int, unsigned int, unsigned char *, void *), signed int (*)(struct __db_env *, const char *, void *));
  // set_backup_config
  signed int (*set_backup_config)(struct __db_env *, enum anonymous_14, unsigned int);
  // set_encrypt
  signed int (*set_encrypt)(struct __db_env *, const char *, unsigned int);
  // set_errcall
  void (*set_errcall)(struct __db_env *, void (*)(const struct __db_env *, const char *, const char *));
  // set_errfile
  void (*set_errfile)(struct __db_env *, struct _IO_FILE *);
  // set_errpfx
  void (*set_errpfx)(struct __db_env *, const char *);
  // set_event_notify
  signed int (*set_event_notify)(struct __db_env *, void (*)(struct __db_env *, unsigned int, void *));
  // set_feedback
  signed int (*set_feedback)(struct __db_env *, void (*)(struct __db_env *, signed int, signed int));
  // set_flags
  signed int (*set_flags)(struct __db_env *, unsigned int, signed int);
  // set_intermediate_dir_mode
  signed int (*set_intermediate_dir_mode)(struct __db_env *, const char *);
  // set_isalive
  signed int (*set_isalive)(struct __db_env *, signed int (*)(struct __db_env *, signed int, unsigned long int, unsigned int));
  // set_lg_bsize
  signed int (*set_lg_bsize)(struct __db_env *, unsigned int);
  // set_lg_dir
  signed int (*set_lg_dir)(struct __db_env *, const char *);
  // set_lg_filemode
  signed int (*set_lg_filemode)(struct __db_env *, signed int);
  // set_lg_max
  signed int (*set_lg_max)(struct __db_env *, unsigned int);
  // set_lg_regionmax
  signed int (*set_lg_regionmax)(struct __db_env *, unsigned int);
  // set_lk_conflicts
  signed int (*set_lk_conflicts)(struct __db_env *, unsigned char *, signed int);
  // set_lk_detect
  signed int (*set_lk_detect)(struct __db_env *, unsigned int);
  // set_lk_max_lockers
  signed int (*set_lk_max_lockers)(struct __db_env *, unsigned int);
  // set_lk_max_locks
  signed int (*set_lk_max_locks)(struct __db_env *, unsigned int);
  // set_lk_max_objects
  signed int (*set_lk_max_objects)(struct __db_env *, unsigned int);
  // set_lk_partitions
  signed int (*set_lk_partitions)(struct __db_env *, unsigned int);
  // set_lk_priority
  signed int (*set_lk_priority)(struct __db_env *, unsigned int, unsigned int);
  // set_lk_tablesize
  signed int (*set_lk_tablesize)(struct __db_env *, unsigned int);
  // set_memory_init
  signed int (*set_memory_init)(struct __db_env *, enum anonymous_15, unsigned int);
  // set_memory_max
  signed int (*set_memory_max)(struct __db_env *, unsigned int, unsigned int);
  // set_metadata_dir
  signed int (*set_metadata_dir)(struct __db_env *, const char *);
  // set_mp_max_openfd
  signed int (*set_mp_max_openfd)(struct __db_env *, signed int);
  // set_mp_max_write
  signed int (*set_mp_max_write)(struct __db_env *, signed int, unsigned int);
  // set_mp_mmapsize
  signed int (*set_mp_mmapsize)(struct __db_env *, unsigned long int);
  // set_mp_mtxcount
  signed int (*set_mp_mtxcount)(struct __db_env *, unsigned int);
  // set_mp_pagesize
  signed int (*set_mp_pagesize)(struct __db_env *, unsigned int);
  // set_mp_tablesize
  signed int (*set_mp_tablesize)(struct __db_env *, unsigned int);
  // set_msgcall
  void (*set_msgcall)(struct __db_env *, void (*)(const struct __db_env *, const char *));
  // set_msgfile
  void (*set_msgfile)(struct __db_env *, struct _IO_FILE *);
  // set_paniccall
  signed int (*set_paniccall)(struct __db_env *, void (*)(struct __db_env *, signed int));
  // set_shm_key
  signed int (*set_shm_key)(struct __db_env *, signed long int);
  // set_thread_count
  signed int (*set_thread_count)(struct __db_env *, unsigned int);
  // set_thread_id
  signed int (*set_thread_id)(struct __db_env *, void (*)(struct __db_env *, signed int *, unsigned long int *));
  // set_thread_id_string
  signed int (*set_thread_id_string)(struct __db_env *, char * (*)(struct __db_env *, signed int, unsigned long int, char *));
  // set_timeout
  signed int (*set_timeout)(struct __db_env *, unsigned int, unsigned int);
  // set_tmp_dir
  signed int (*set_tmp_dir)(struct __db_env *, const char *);
  // set_tx_max
  signed int (*set_tx_max)(struct __db_env *, unsigned int);
  // set_tx_timestamp
  signed int (*set_tx_timestamp)(struct __db_env *, signed long int *);
  // set_verbose
  signed int (*set_verbose)(struct __db_env *, unsigned int, signed int);
  // txn_applied
  signed int (*txn_applied)(struct __db_env *, struct __db_txn_token *, unsigned int, unsigned int);
  // stat_print
  signed int (*stat_print)(struct __db_env *, unsigned int);
  // txn_begin
  signed int (*txn_begin)(struct __db_env *, struct __db_txn *, struct __db_txn **, unsigned int);
  // txn_checkpoint
  signed int (*txn_checkpoint)(struct __db_env *, unsigned int, unsigned int, unsigned int);
  // txn_recover
  signed int (*txn_recover)(struct __db_env *, struct __db_preplist *, signed long int, signed long int *, unsigned int);
  // txn_stat
  signed int (*txn_stat)(struct __db_env *, struct __db_txn_stat **, unsigned int);
  // txn_stat_print
  signed int (*txn_stat_print)(struct __db_env *, unsigned int);
  // prdbt
  signed int (*prdbt)(struct __db_dbt *, signed int, const char *, void *, signed int (*)(void *, const void *), signed int, signed int);
};

struct __db_ilock
{
  // pgno
  unsigned int pgno;
  // fileid
  unsigned char fileid[20l];
  // type
  unsigned int type;
};

struct __db_lock_stat
{
  // st_id
  unsigned int st_id;
  // st_cur_maxid
  unsigned int st_cur_maxid;
  // st_initlocks
  unsigned int st_initlocks;
  // st_initlockers
  unsigned int st_initlockers;
  // st_initobjects
  unsigned int st_initobjects;
  // st_locks
  unsigned int st_locks;
  // st_lockers
  unsigned int st_lockers;
  // st_objects
  unsigned int st_objects;
  // st_maxlocks
  unsigned int st_maxlocks;
  // st_maxlockers
  unsigned int st_maxlockers;
  // st_maxobjects
  unsigned int st_maxobjects;
  // st_partitions
  unsigned int st_partitions;
  // st_tablesize
  unsigned int st_tablesize;
  // st_nmodes
  signed int st_nmodes;
  // st_nlockers
  unsigned int st_nlockers;
  // st_nlocks
  unsigned int st_nlocks;
  // st_maxnlocks
  unsigned int st_maxnlocks;
  // st_maxhlocks
  unsigned int st_maxhlocks;
  // st_locksteals
  unsigned long int st_locksteals;
  // st_maxlsteals
  unsigned long int st_maxlsteals;
  // st_maxnlockers
  unsigned int st_maxnlockers;
  // st_nobjects
  unsigned int st_nobjects;
  // st_maxnobjects
  unsigned int st_maxnobjects;
  // st_maxhobjects
  unsigned int st_maxhobjects;
  // st_objectsteals
  unsigned long int st_objectsteals;
  // st_maxosteals
  unsigned long int st_maxosteals;
  // st_nrequests
  unsigned long int st_nrequests;
  // st_nreleases
  unsigned long int st_nreleases;
  // st_nupgrade
  unsigned long int st_nupgrade;
  // st_ndowngrade
  unsigned long int st_ndowngrade;
  // st_lock_wait
  unsigned long int st_lock_wait;
  // st_lock_nowait
  unsigned long int st_lock_nowait;
  // st_ndeadlocks
  unsigned long int st_ndeadlocks;
  // st_locktimeout
  unsigned int st_locktimeout;
  // st_nlocktimeouts
  unsigned long int st_nlocktimeouts;
  // st_txntimeout
  unsigned int st_txntimeout;
  // st_ntxntimeouts
  unsigned long int st_ntxntimeouts;
  // st_part_wait
  unsigned long int st_part_wait;
  // st_part_nowait
  unsigned long int st_part_nowait;
  // st_part_max_wait
  unsigned long int st_part_max_wait;
  // st_part_max_nowait
  unsigned long int st_part_max_nowait;
  // st_objs_wait
  unsigned long int st_objs_wait;
  // st_objs_nowait
  unsigned long int st_objs_nowait;
  // st_lockers_wait
  unsigned long int st_lockers_wait;
  // st_lockers_nowait
  unsigned long int st_lockers_nowait;
  // st_region_wait
  unsigned long int st_region_wait;
  // st_region_nowait
  unsigned long int st_region_nowait;
  // st_hash_len
  unsigned int st_hash_len;
  // st_regsize
  unsigned long int st_regsize;
};

struct __db_lockreq
{
  // op
  enum anonymous_25 op;
  // mode
  enum anonymous_16 mode;
  // timeout
  unsigned int timeout;
  // obj
  struct __db_dbt *obj;
  // lock
  struct __db_lock_u lock;
};

struct __db_lsn
{
  // file
  unsigned int file;
  // offset
  unsigned int offset;
};

struct __db_log_cursor
{
  // env
  struct __env *env;
  // fhp
  struct __fh_t *fhp;
  // lsn
  struct __db_lsn lsn;
  // len
  unsigned int len;
  // prev
  unsigned int prev;
  // dbt
  struct __db_dbt dbt;
  // p_lsn
  struct __db_lsn p_lsn;
  // p_version
  unsigned int p_version;
  // bp
  unsigned char *bp;
  // bp_size
  unsigned int bp_size;
  // bp_rlen
  unsigned int bp_rlen;
  // bp_lsn
  struct __db_lsn bp_lsn;
  // bp_maxrec
  unsigned int bp_maxrec;
  // close
  signed int (*close)(struct __db_log_cursor *, unsigned int);
  // get
  signed int (*get)(struct __db_log_cursor *, struct __db_lsn *, struct __db_dbt *, unsigned int);
  // version
  signed int (*version)(struct __db_log_cursor *, unsigned int *, unsigned int);
  // flags
  unsigned int flags;
};

struct __db_log_stat
{
  // st_magic
  unsigned int st_magic;
  // st_version
  unsigned int st_version;
  // st_mode
  signed int st_mode;
  // st_lg_bsize
  unsigned int st_lg_bsize;
  // st_lg_size
  unsigned int st_lg_size;
  // st_wc_bytes
  unsigned int st_wc_bytes;
  // st_wc_mbytes
  unsigned int st_wc_mbytes;
  // st_fileid_init
  unsigned int st_fileid_init;
  // st_nfileid
  unsigned int st_nfileid;
  // st_maxnfileid
  unsigned int st_maxnfileid;
  // st_record
  unsigned long int st_record;
  // st_w_bytes
  unsigned int st_w_bytes;
  // st_w_mbytes
  unsigned int st_w_mbytes;
  // st_wcount
  unsigned long int st_wcount;
  // st_wcount_fill
  unsigned long int st_wcount_fill;
  // st_rcount
  unsigned long int st_rcount;
  // st_scount
  unsigned long int st_scount;
  // st_region_wait
  unsigned long int st_region_wait;
  // st_region_nowait
  unsigned long int st_region_nowait;
  // st_cur_file
  unsigned int st_cur_file;
  // st_cur_offset
  unsigned int st_cur_offset;
  // st_disk_file
  unsigned int st_disk_file;
  // st_disk_offset
  unsigned int st_disk_offset;
  // st_maxcommitperflush
  unsigned int st_maxcommitperflush;
  // st_mincommitperflush
  unsigned int st_mincommitperflush;
  // st_regsize
  unsigned long int st_regsize;
};

struct __db_logvrfy_config
{
  // continue_after_fail
  signed int continue_after_fail;
  // verbose
  signed int verbose;
  // cachesize
  unsigned int cachesize;
  // temp_envhome
  const char *temp_envhome;
  // dbfile
  const char *dbfile;
  // dbname
  const char *dbname;
  // start_lsn
  struct __db_lsn start_lsn;
  // end_lsn
  struct __db_lsn end_lsn;
  // start_time
  signed long int start_time;
  // end_time
  signed long int end_time;
};

struct __db_mpool_fstat
{
  // st_pagesize
  unsigned int st_pagesize;
  // st_map
  unsigned int st_map;
  // st_cache_hit
  unsigned long int st_cache_hit;
  // st_cache_miss
  unsigned long int st_cache_miss;
  // st_page_create
  unsigned long int st_page_create;
  // st_page_in
  unsigned long int st_page_in;
  // st_page_out
  unsigned long int st_page_out;
  // st_backup_spins
  unsigned long int st_backup_spins;
  // file_name
  char *file_name;
};

struct __db_mpool_stat
{
  // st_gbytes
  unsigned int st_gbytes;
  // st_bytes
  unsigned int st_bytes;
  // st_ncache
  unsigned int st_ncache;
  // st_max_ncache
  unsigned int st_max_ncache;
  // st_mmapsize
  unsigned long int st_mmapsize;
  // st_maxopenfd
  signed int st_maxopenfd;
  // st_maxwrite
  signed int st_maxwrite;
  // st_maxwrite_sleep
  unsigned int st_maxwrite_sleep;
  // st_pages
  unsigned int st_pages;
  // st_map
  unsigned int st_map;
  // st_cache_hit
  unsigned long int st_cache_hit;
  // st_cache_miss
  unsigned long int st_cache_miss;
  // st_page_create
  unsigned long int st_page_create;
  // st_page_in
  unsigned long int st_page_in;
  // st_page_out
  unsigned long int st_page_out;
  // st_ro_evict
  unsigned long int st_ro_evict;
  // st_rw_evict
  unsigned long int st_rw_evict;
  // st_page_trickle
  unsigned long int st_page_trickle;
  // st_page_clean
  unsigned int st_page_clean;
  // st_page_dirty
  unsigned int st_page_dirty;
  // st_hash_buckets
  unsigned int st_hash_buckets;
  // st_hash_mutexes
  unsigned int st_hash_mutexes;
  // st_pagesize
  unsigned int st_pagesize;
  // st_hash_searches
  unsigned int st_hash_searches;
  // st_hash_longest
  unsigned int st_hash_longest;
  // st_hash_examined
  unsigned long int st_hash_examined;
  // st_hash_nowait
  unsigned long int st_hash_nowait;
  // st_hash_wait
  unsigned long int st_hash_wait;
  // st_hash_max_nowait
  unsigned long int st_hash_max_nowait;
  // st_hash_max_wait
  unsigned long int st_hash_max_wait;
  // st_region_nowait
  unsigned long int st_region_nowait;
  // st_region_wait
  unsigned long int st_region_wait;
  // st_mvcc_frozen
  unsigned long int st_mvcc_frozen;
  // st_mvcc_thawed
  unsigned long int st_mvcc_thawed;
  // st_mvcc_freed
  unsigned long int st_mvcc_freed;
  // st_alloc
  unsigned long int st_alloc;
  // st_alloc_buckets
  unsigned long int st_alloc_buckets;
  // st_alloc_max_buckets
  unsigned long int st_alloc_max_buckets;
  // st_alloc_pages
  unsigned long int st_alloc_pages;
  // st_alloc_max_pages
  unsigned long int st_alloc_max_pages;
  // st_io_wait
  unsigned long int st_io_wait;
  // st_sync_interrupted
  unsigned long int st_sync_interrupted;
  // st_regsize
  unsigned long int st_regsize;
  // st_regmax
  unsigned long int st_regmax;
};

struct __db_mpoolfile
{
  // fhp
  struct __fh_t *fhp;
  // ref
  unsigned int ref;
  // pinref
  unsigned int pinref;
  // q
  struct anonymous_6 q;
  // env
  struct __env *env;
  // mfp
  struct __mpoolfile *mfp;
  // clear_len
  unsigned int clear_len;
  // fileid
  unsigned char fileid[20l];
  // ftype
  signed int ftype;
  // lsn_offset
  signed int lsn_offset;
  // gbytes
  unsigned int gbytes;
  // bytes
  unsigned int bytes;
  // pgcookie
  struct __db_dbt *pgcookie;
  // priority
  signed int priority;
  // addr
  void *addr;
  // len
  unsigned long int len;
  // config_flags
  unsigned int config_flags;
  // close
  signed int (*close)(struct __db_mpoolfile *, unsigned int);
  // get
  signed int (*get)(struct __db_mpoolfile *, unsigned int *, struct __db_txn *, unsigned int, void *);
  // get_clear_len
  signed int (*get_clear_len)(struct __db_mpoolfile *, unsigned int *);
  // get_fileid
  signed int (*get_fileid)(struct __db_mpoolfile *, unsigned char *);
  // get_flags
  signed int (*get_flags)(struct __db_mpoolfile *, unsigned int *);
  // get_ftype
  signed int (*get_ftype)(struct __db_mpoolfile *, signed int *);
  // get_last_pgno
  signed int (*get_last_pgno)(struct __db_mpoolfile *, unsigned int *);
  // get_lsn_offset
  signed int (*get_lsn_offset)(struct __db_mpoolfile *, signed int *);
  // get_maxsize
  signed int (*get_maxsize)(struct __db_mpoolfile *, unsigned int *, unsigned int *);
  // get_pgcookie
  signed int (*get_pgcookie)(struct __db_mpoolfile *, struct __db_dbt *);
  // get_priority
  signed int (*get_priority)(struct __db_mpoolfile *, enum anonymous_7 *);
  // open
  signed int (*open)(struct __db_mpoolfile *, const char *, unsigned int, signed int, unsigned long int);
  // put
  signed int (*put)(struct __db_mpoolfile *, void *, enum anonymous_7, unsigned int);
  // set_clear_len
  signed int (*set_clear_len)(struct __db_mpoolfile *, unsigned int);
  // set_fileid
  signed int (*set_fileid)(struct __db_mpoolfile *, unsigned char *);
  // set_flags
  signed int (*set_flags)(struct __db_mpoolfile *, unsigned int, signed int);
  // set_ftype
  signed int (*set_ftype)(struct __db_mpoolfile *, signed int);
  // set_lsn_offset
  signed int (*set_lsn_offset)(struct __db_mpoolfile *, signed int);
  // set_maxsize
  signed int (*set_maxsize)(struct __db_mpoolfile *, unsigned int, unsigned int);
  // set_pgcookie
  signed int (*set_pgcookie)(struct __db_mpoolfile *, struct __db_dbt *);
  // set_priority
  signed int (*set_priority)(struct __db_mpoolfile *, enum anonymous_7);
  // sync
  signed int (*sync)(struct __db_mpoolfile *);
  // flags
  unsigned int flags;
};

struct __db_mutex_stat
{
  // st_mutex_align
  unsigned int st_mutex_align;
  // st_mutex_tas_spins
  unsigned int st_mutex_tas_spins;
  // st_mutex_init
  unsigned int st_mutex_init;
  // st_mutex_cnt
  unsigned int st_mutex_cnt;
  // st_mutex_max
  unsigned int st_mutex_max;
  // st_mutex_free
  unsigned int st_mutex_free;
  // st_mutex_inuse
  unsigned int st_mutex_inuse;
  // st_mutex_inuse_max
  unsigned int st_mutex_inuse_max;
  // st_region_wait
  unsigned long int st_region_wait;
  // st_region_nowait
  unsigned long int st_region_nowait;
  // st_regsize
  unsigned long int st_regsize;
  // st_regmax
  unsigned long int st_regmax;
};

struct __db_preplist
{
  // txn
  struct __db_txn *txn;
  // gid
  unsigned char gid[128l];
};

struct __db_rep_stat
{
  // st_startup_complete
  unsigned int st_startup_complete;
  // st_log_queued
  unsigned long int st_log_queued;
  // st_status
  unsigned int st_status;
  // st_next_lsn
  struct __db_lsn st_next_lsn;
  // st_waiting_lsn
  struct __db_lsn st_waiting_lsn;
  // st_max_perm_lsn
  struct __db_lsn st_max_perm_lsn;
  // st_next_pg
  unsigned int st_next_pg;
  // st_waiting_pg
  unsigned int st_waiting_pg;
  // st_dupmasters
  unsigned int st_dupmasters;
  // st_env_id
  signed long int st_env_id;
  // st_env_priority
  unsigned int st_env_priority;
  // st_bulk_fills
  unsigned long int st_bulk_fills;
  // st_bulk_overflows
  unsigned long int st_bulk_overflows;
  // st_bulk_records
  unsigned long int st_bulk_records;
  // st_bulk_transfers
  unsigned long int st_bulk_transfers;
  // st_client_rerequests
  unsigned long int st_client_rerequests;
  // st_client_svc_req
  unsigned long int st_client_svc_req;
  // st_client_svc_miss
  unsigned long int st_client_svc_miss;
  // st_gen
  unsigned int st_gen;
  // st_egen
  unsigned int st_egen;
  // st_lease_chk
  unsigned long int st_lease_chk;
  // st_lease_chk_misses
  unsigned long int st_lease_chk_misses;
  // st_lease_chk_refresh
  unsigned long int st_lease_chk_refresh;
  // st_lease_sends
  unsigned long int st_lease_sends;
  // st_log_duplicated
  unsigned long int st_log_duplicated;
  // st_log_queued_max
  unsigned long int st_log_queued_max;
  // st_log_queued_total
  unsigned long int st_log_queued_total;
  // st_log_records
  unsigned long int st_log_records;
  // st_log_requested
  unsigned long int st_log_requested;
  // st_master
  signed long int st_master;
  // st_master_changes
  unsigned long int st_master_changes;
  // st_msgs_badgen
  unsigned long int st_msgs_badgen;
  // st_msgs_processed
  unsigned long int st_msgs_processed;
  // st_msgs_recover
  unsigned long int st_msgs_recover;
  // st_msgs_send_failures
  unsigned long int st_msgs_send_failures;
  // st_msgs_sent
  unsigned long int st_msgs_sent;
  // st_newsites
  unsigned long int st_newsites;
  // st_nsites
  unsigned int st_nsites;
  // st_nthrottles
  unsigned long int st_nthrottles;
  // st_outdated
  unsigned long int st_outdated;
  // st_pg_duplicated
  unsigned long int st_pg_duplicated;
  // st_pg_records
  unsigned long int st_pg_records;
  // st_pg_requested
  unsigned long int st_pg_requested;
  // st_txns_applied
  unsigned long int st_txns_applied;
  // st_startsync_delayed
  unsigned long int st_startsync_delayed;
  // st_elections
  unsigned long int st_elections;
  // st_elections_won
  unsigned long int st_elections_won;
  // st_election_cur_winner
  signed long int st_election_cur_winner;
  // st_election_gen
  unsigned int st_election_gen;
  // st_election_datagen
  unsigned int st_election_datagen;
  // st_election_lsn
  struct __db_lsn st_election_lsn;
  // st_election_nsites
  unsigned int st_election_nsites;
  // st_election_nvotes
  unsigned int st_election_nvotes;
  // st_election_priority
  unsigned int st_election_priority;
  // st_election_status
  signed int st_election_status;
  // st_election_tiebreaker
  unsigned int st_election_tiebreaker;
  // st_election_votes
  unsigned int st_election_votes;
  // st_election_sec
  unsigned int st_election_sec;
  // st_election_usec
  unsigned int st_election_usec;
  // st_max_lease_sec
  unsigned int st_max_lease_sec;
  // st_max_lease_usec
  unsigned int st_max_lease_usec;
};

struct __db_repmgr_site
{
  // eid
  signed int eid;
  // host
  char *host;
  // port
  unsigned int port;
  // status
  unsigned int status;
  // flags
  unsigned int flags;
};

struct __db_repmgr_stat
{
  // st_perm_failed
  unsigned long int st_perm_failed;
  // st_msgs_queued
  unsigned long int st_msgs_queued;
  // st_msgs_dropped
  unsigned long int st_msgs_dropped;
  // st_connection_drop
  unsigned long int st_connection_drop;
  // st_connect_fail
  unsigned long int st_connect_fail;
  // st_elect_threads
  unsigned long int st_elect_threads;
  // st_max_elect_threads
  unsigned long int st_max_elect_threads;
};

struct __db_site
{
  // env
  struct __env *env;
  // eid
  signed int eid;
  // host
  const char *host;
  // port
  unsigned int port;
  // flags
  unsigned int flags;
  // get_address
  signed int (*get_address)(struct __db_site *, const char **, unsigned int *);
  // get_config
  signed int (*get_config)(struct __db_site *, unsigned int, unsigned int *);
  // get_eid
  signed int (*get_eid)(struct __db_site *, signed int *);
  // set_config
  signed int (*set_config)(struct __db_site *, unsigned int, unsigned int);
  // remove
  signed int (*remove)(struct __db_site *);
  // close
  signed int (*close)(struct __db_site *);
};

struct __kids
{
  // tqh_first
  struct __db_txn *tqh_first;
  // tqh_last
  struct __db_txn **tqh_last;
};

struct __my_cursors
{
  // tqh_first
  struct __dbc *tqh_first;
  // tqh_last
  struct __dbc **tqh_last;
};

struct __femfs
{
  // tqh_first
  struct __db *tqh_first;
  // tqh_last
  struct __db **tqh_last;
};

struct __db_txn
{
  // mgrp
  struct __db_txnmgr *mgrp;
  // parent
  struct __db_txn *parent;
  // thread_info
  struct __db_thread_info *thread_info;
  // txnid
  unsigned int txnid;
  // name
  char *name;
  // locker
  struct __db_locker *locker;
  // td
  void *td;
  // lock_timeout
  unsigned int lock_timeout;
  // txn_list
  void *txn_list;
  // links
  struct anonymous_8 links;
  // xa_links
  struct anonymous_9 xa_links;
  // kids
  struct __kids kids;
  // events
  struct anonymous_10 events;
  // logs
  struct anonymous_11 logs;
  // klinks
  struct anonymous_8 klinks;
  // my_cursors
  struct __my_cursors my_cursors;
  // femfs
  struct __femfs femfs;
  // token_buffer
  struct __db_txn_token *token_buffer;
  // api_internal
  void *api_internal;
  // xml_internal
  void *xml_internal;
  // cursors
  unsigned int cursors;
  // abort
  signed int (*abort)(struct __db_txn *);
  // commit
  signed int (*commit)(struct __db_txn *, unsigned int);
  // discard
  signed int (*discard)(struct __db_txn *, unsigned int);
  // get_name
  signed int (*get_name)(struct __db_txn *, const char **);
  // get_priority
  signed int (*get_priority)(struct __db_txn *, unsigned int *);
  // id
  unsigned int (*id)(struct __db_txn *);
  // prepare
  signed int (*prepare)(struct __db_txn *, unsigned char *);
  // set_commit_token
  signed int (*set_commit_token)(struct __db_txn *, struct __db_txn_token *);
  // set_name
  signed int (*set_name)(struct __db_txn *, const char *);
  // set_priority
  signed int (*set_priority)(struct __db_txn *, unsigned int);
  // set_timeout
  signed int (*set_timeout)(struct __db_txn *, unsigned int, unsigned int);
  // set_txn_lsnp
  void (*set_txn_lsnp)(struct __db_txn *, struct __db_lsn **, struct __db_lsn **);
  // xa_thr_status
  unsigned int xa_thr_status;
  // flags
  unsigned int flags;
};

struct __db_txn_active
{
  // txnid
  unsigned int txnid;
  // parentid
  unsigned int parentid;
  // pid
  signed int pid;
  // tid
  unsigned long int tid;
  // lsn
  struct __db_lsn lsn;
  // read_lsn
  struct __db_lsn read_lsn;
  // mvcc_ref
  unsigned int mvcc_ref;
  // priority
  unsigned int priority;
  // status
  unsigned int status;
  // xa_status
  unsigned int xa_status;
  // gid
  unsigned char gid[128l];
  // name
  char name[51l];
};

struct __db_txn_stat
{
  // st_nrestores
  unsigned int st_nrestores;
  // st_last_ckp
  struct __db_lsn st_last_ckp;
  // st_time_ckp
  signed long int st_time_ckp;
  // st_last_txnid
  unsigned int st_last_txnid;
  // st_inittxns
  unsigned int st_inittxns;
  // st_maxtxns
  unsigned int st_maxtxns;
  // st_naborts
  unsigned long int st_naborts;
  // st_nbegins
  unsigned long int st_nbegins;
  // st_ncommits
  unsigned long int st_ncommits;
  // st_nactive
  unsigned int st_nactive;
  // st_nsnapshot
  unsigned int st_nsnapshot;
  // st_maxnactive
  unsigned int st_maxnactive;
  // st_maxnsnapshot
  unsigned int st_maxnsnapshot;
  // st_region_wait
  unsigned long int st_region_wait;
  // st_region_nowait
  unsigned long int st_region_nowait;
  // st_regsize
  unsigned long int st_regsize;
  // st_txnarray
  struct __db_txn_active *st_txnarray;
};

struct __db_txn_token
{
  // buf
  unsigned char buf[20l];
};

struct __dbc
{
  // dbp
  struct __db *dbp;
  // dbenv
  struct __db_env *dbenv;
  // env
  struct __env *env;
  // thread_info
  struct __db_thread_info *thread_info;
  // txn
  struct __db_txn *txn;
  // priority
  enum anonymous_7 priority;
  // links
  struct anonymous_23 links;
  // txn_cursors
  struct anonymous_23 txn_cursors;
  // rskey
  struct __db_dbt *rskey;
  // rkey
  struct __db_dbt *rkey;
  // rdata
  struct __db_dbt *rdata;
  // my_rskey
  struct __db_dbt my_rskey;
  // my_rkey
  struct __db_dbt my_rkey;
  // my_rdata
  struct __db_dbt my_rdata;
  // lref
  struct __db_locker *lref;
  // locker
  struct __db_locker *locker;
  // lock_dbt
  struct __db_dbt lock_dbt;
  // lock
  struct __db_ilock lock;
  // mylock
  struct __db_lock_u mylock;
  // dbtype
  enum anonymous_17 dbtype;
  // internal
  struct __dbc_internal *internal;
  // close
  signed int (*close)(struct __dbc *);
  // cmp
  signed int (*cmp)(struct __dbc *, struct __dbc *, signed int *, unsigned int);
  // count
  signed int (*count)(struct __dbc *, unsigned int *, unsigned int);
  // del
  signed int (*del)(struct __dbc *, unsigned int);
  // dup
  signed int (*dup)(struct __dbc *, struct __dbc **, unsigned int);
  // get
  signed int (*get)(struct __dbc *, struct __db_dbt *, struct __db_dbt *, unsigned int);
  // get_priority
  signed int (*get_priority)(struct __dbc *, enum anonymous_7 *);
  // pget
  signed int (*pget)(struct __dbc *, struct __db_dbt *, struct __db_dbt *, struct __db_dbt *, unsigned int);
  // put
  signed int (*put)(struct __dbc *, struct __db_dbt *, struct __db_dbt *, unsigned int);
  // set_priority
  signed int (*set_priority)(struct __dbc *, enum anonymous_7);
  // c_close
  signed int (*c_close)(struct __dbc *);
  // c_count
  signed int (*c_count)(struct __dbc *, unsigned int *, unsigned int);
  // c_del
  signed int (*c_del)(struct __dbc *, unsigned int);
  // c_dup
  signed int (*c_dup)(struct __dbc *, struct __dbc **, unsigned int);
  // c_get
  signed int (*c_get)(struct __dbc *, struct __db_dbt *, struct __db_dbt *, unsigned int);
  // c_pget
  signed int (*c_pget)(struct __dbc *, struct __db_dbt *, struct __db_dbt *, struct __db_dbt *, unsigned int);
  // c_put
  signed int (*c_put)(struct __dbc *, struct __db_dbt *, struct __db_dbt *, unsigned int);
  // am_bulk
  signed int (*am_bulk)(struct __dbc *, struct __db_dbt *, unsigned int);
  // am_close
  signed int (*am_close)(struct __dbc *, unsigned int, signed int *);
  // am_del
  signed int (*am_del)(struct __dbc *, unsigned int);
  // am_destroy
  signed int (*am_destroy)(struct __dbc *);
  // am_get
  signed int (*am_get)(struct __dbc *, struct __db_dbt *, struct __db_dbt *, unsigned int, unsigned int *);
  // am_put
  signed int (*am_put)(struct __dbc *, struct __db_dbt *, struct __db_dbt *, unsigned int, unsigned int *);
  // am_writelock
  signed int (*am_writelock)(struct __dbc *);
  // flags
  unsigned int flags;
};

struct __key_range
{
  // less
  double less;
  // equal
  double equal;
  // greater
  double greater;
};

struct __log_rec_spec
{
  // type
  enum anonymous_24 type;
  // offset
  unsigned int offset;
  // name
  const char *name;
  // fmt
  const char fmt[4l];
};

struct _ci_align_test
{
  // n
  char n[1l];
  // d
  double d;
};

struct acl_cmp_uint64_data
{
  // data
  unsigned long int data;
  // operator
  signed int operator;
};

struct acl_time_data
{
  // days
  unsigned int days;
  // start_time
  unsigned int start_time;
  // end_time
  unsigned int end_time;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct check_reg_data
{
  // name
  const char *name;
  // found
  signed int found;
  // count
  signed int count;
};

struct ci_MD5Context
{
  // buf
  unsigned int buf[4l];
  // bits
  unsigned int bits[2l];
  // in
  unsigned char in[64l];
};

struct ci_access_entry
{
  // type
  signed int type;
  // spec_list
  struct ci_specs_list *spec_list;
  // next
  struct ci_access_entry *next;
};

struct ci_acl_data
{
  // data
  void *data;
  // next
  struct ci_acl_data *next;
};

struct ci_acl_regex
{
  // str
  char *str;
  // flags
  signed int flags;
  // preg
  void *preg;
};

struct ci_acl_spec
{
  // name
  char name[32l];
  // type
  const struct ci_acl_type *type;
  // parameter
  char *parameter;
  // data
  struct ci_acl_data *data;
  // next
  struct ci_acl_spec *next;
};

struct ci_acl_type
{
  // name
  char name[32l];
  // get_test_data
  void * (*get_test_data)(struct ci_request *, char *);
  // free_test_data
  void (*free_test_data)(struct ci_request *, void *);
  // type
  const struct ci_type_ops *type;
};

struct ci_acl_type_list
{
  // acl_type_list
  struct ci_acl_type *acl_type_list;
  // acl_type_list_size
  signed int acl_type_list_size;
  // acl_type_list_num
  signed int acl_type_list_num;
};

struct ci_array
{
  // items
  struct ci_array_item *items;
  // mem
  char *mem;
  // max_size
  unsigned long int max_size;
  // count
  unsigned int count;
  // alloc
  struct ci_mem_allocator *alloc;
};

struct ci_array_item
{
  // name
  char *name;
  // value
  void *value;
};

struct ci_buf
{
  // buf
  char *buf;
  // size
  signed int size;
  // used
  signed int used;
};

struct ci_cache
{
  // init
  signed int (*init)(struct ci_cache *, const char *);
  // search
  const void * (*search)(struct ci_cache *, const void *, void **, void *, void * (*)(const void *, unsigned long int, void *));
  // update
  signed int (*update)(struct ci_cache *, const void *, const void *, unsigned long int, void * (*)(void *, const void *, unsigned long int));
  // destroy
  void (*destroy)(struct ci_cache *);
  // ttl
  signed long int ttl;
  // mem_size
  unsigned int mem_size;
  // max_object_size
  unsigned int max_object_size;
  // flags
  unsigned int flags;
  // key_ops
  const struct ci_type_ops *key_ops;
  // _cache_type
  const struct ci_cache_type *_cache_type;
  // cache_data
  void *cache_data;
};

struct ci_cache_entry
{
  // hash
  unsigned int hash;
  // time
  signed long int time;
  // key
  void *key;
  // val
  void *val;
  // val_size
  signed int val_size;
  // qnext
  struct ci_cache_entry *qnext;
  // hnext
  struct ci_cache_entry *hnext;
};

struct ci_cache_type
{
  // init
  signed int (*init)(struct ci_cache *, const char *);
  // search
  const void * (*search)(struct ci_cache *, const void *, void **, void *, void * (*)(const void *, unsigned long int, void *));
  // update
  signed int (*update)(struct ci_cache *, const void *, const void *, unsigned long int, void * (*)(void *, const void *, unsigned long int));
  // destroy
  void (*destroy)(struct ci_cache *);
  // name
  const char *name;
};

struct ci_cached_file
{
  // endpos
  signed long int endpos;
  // readpos
  signed long int readpos;
  // bufsize
  signed int bufsize;
  // flags
  signed int flags;
  // unlocked
  signed long int unlocked;
  // buf
  char *buf;
  // fd
  signed int fd;
  // filename
  char filename[4097l];
  // attributes
  struct ci_array *attributes;
};

struct ci_conf_entry
{
  // name
  const char *name;
  // data
  void *data;
  // action
  signed int (*action)(const char *, const char **, void *);
  // msg
  const char *msg;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct ci_sockaddr
{
  // sockaddr
  struct sockaddr_in sockaddr;
  // ci_sin_family
  signed int ci_sin_family;
  // ci_sin_port
  signed int ci_sin_port;
  // ci_sin_addr
  void *ci_sin_addr;
  // ci_inaddr_len
  signed int ci_inaddr_len;
};

struct ci_connection
{
  // fd
  signed int fd;
  // claddr
  struct ci_sockaddr claddr;
  // srvaddr
  struct ci_sockaddr srvaddr;
};

struct ci_data_group
{
  // name
  char name[16l];
  // descr
  char descr[51l];
};

struct ci_data_type
{
  // name
  char name[16l];
  // descr
  char descr[51l];
  // groups
  signed int groups[64l];
};

struct ci_dyn_array
{
  // items
  struct ci_array_item **items;
  // count
  signed int count;
  // max_items
  signed int max_items;
  // alloc
  struct ci_mem_allocator *alloc;
};

struct ci_encaps_entity
{
  // start
  signed int start;
  // type
  signed int type;
  // entity
  void *entity;
};

struct ci_error_code
{
  // code
  signed int code;
  // str
  char *str;
};

struct ci_fmt_entry
{
  // directive
  const char *directive;
  // description
  const char *description;
  // format
  signed int (*format)(struct ci_request *, char *, signed int, const char *);
};

struct ci_hash_entry
{
  // hash
  unsigned int hash;
  // key
  const void *key;
  // val
  const void *val;
  // hnext
  struct ci_hash_entry *hnext;
};

struct ci_hash_table
{
  // hash_table
  struct ci_hash_entry **hash_table;
  // hash_table_size
  unsigned int hash_table_size;
  // ops
  const struct ci_type_ops *ops;
  // allocator
  struct ci_mem_allocator *allocator;
};

struct ci_headers_list
{
  // size
  signed int size;
  // used
  signed int used;
  // headers
  char **headers;
  // bufsize
  signed int bufsize;
  // bufused
  signed int bufused;
  // buf
  char *buf;
  // packed
  signed int packed;
};

struct ci_ip
{
  // address
  struct in_addr address;
  // netmask
  struct in_addr netmask;
  // family
  signed int family;
};

struct ci_list
{
  // items
  struct ci_list_item *items;
  // last
  struct ci_list_item *last;
  // trash
  struct ci_list_item *trash;
  // cursor
  struct ci_list_item *cursor;
  // tmp
  struct ci_list_item *tmp;
  // obj_size
  unsigned long int obj_size;
  // alloc
  struct ci_mem_allocator *alloc;
  // cmp_func
  signed int (*cmp_func)(const void *, const void *, unsigned long int);
  // copy_func
  signed int (*copy_func)(void *, const void *);
  // free_func
  void (*free_func)(void *);
};

struct ci_list_item
{
  // item
  void *item;
  // next
  struct ci_list_item *next;
};

struct common_mutex
{
  // isproc
  signed int isproc;
  // mtx
  union anonymous_1 mtx;
};

struct ci_local_cache_data
{
  // first_queue_entry
  struct ci_cache_entry *first_queue_entry;
  // last_queue_entry
  struct ci_cache_entry *last_queue_entry;
  // hash_table
  struct ci_cache_entry **hash_table;
  // hash_table_size
  unsigned int hash_table_size;
  // allocator
  struct ci_mem_allocator *allocator;
  // mtx
  struct common_mutex mtx;
};

struct ci_lookup_table
{
  // open
  void * (*open)(struct ci_lookup_table *);
  // close
  void (*close)(struct ci_lookup_table *);
  // search
  void * (*search)(struct ci_lookup_table *, void *, void ***);
  // release_result
  void (*release_result)(struct ci_lookup_table *, void **);
  // get_row
  const void * (*get_row)(struct ci_lookup_table *, const void *, const char **, void ***);
  // type
  char *type;
  // path
  char *path;
  // args
  char *args;
  // cols
  signed int cols;
  // col_names
  struct ci_vector *col_names;
  // key_ops
  const struct ci_type_ops *key_ops;
  // val_ops
  const struct ci_type_ops *val_ops;
  // allocator
  struct ci_mem_allocator *allocator;
  // _lt_type
  struct ci_lookup_table_type *_lt_type;
  // data
  void *data;
};

struct ci_lookup_table_type
{
  // open
  void * (*open)(struct ci_lookup_table *);
  // close
  void (*close)(struct ci_lookup_table *);
  // search
  void * (*search)(struct ci_lookup_table *, void *, void ***);
  // release_result
  void (*release_result)(struct ci_lookup_table *, void **);
  // get_row
  const void * (*get_row)(struct ci_lookup_table *, const void *, const char **, void ***);
  // type
  char *type;
};

struct ci_magic
{
  // offset
  signed int offset;
  // magic
  unsigned char magic[51l];
  // len
  unsigned long int len;
  // type
  unsigned int type;
};

struct ci_magic_record
{
  // offset
  signed int offset;
  // magic
  unsigned char magic[51l];
  // len
  unsigned long int len;
  // type
  char type[16l];
  // groups
  char *groups[65l];
  // descr
  char descr[51l];
};

struct ci_magics_db
{
  // types
  struct ci_data_type *types;
  // types_num
  signed int types_num;
  // types_size
  signed int types_size;
  // groups
  struct ci_data_group *groups;
  // groups_num
  signed int groups_num;
  // groups_size
  signed int groups_size;
  // magics
  struct ci_magic *magics;
  // magics_num
  signed int magics_num;
  // magics_size
  signed int magics_size;
};

struct ci_mem_allocator
{
  // alloc
  void * (*alloc)(struct ci_mem_allocator *, unsigned long int);
  // free
  void (*free)(struct ci_mem_allocator *, void *);
  // reset
  void (*reset)(struct ci_mem_allocator *);
  // destroy
  void (*destroy)(struct ci_mem_allocator *);
  // data
  void *data;
  // name
  char *name;
  // type
  signed int type;
  // must_free
  signed int must_free;
};

struct ci_membuf
{
  // endpos
  signed int endpos;
  // readpos
  signed int readpos;
  // bufsize
  signed int bufsize;
  // unlocked
  signed int unlocked;
  // flags
  unsigned int flags;
  // buf
  char *buf;
  // attributes
  struct ci_array *attributes;
};

struct ci_options_entry
{
  // name
  const char *name;
  // parameter
  const char *parameter;
  // data
  void *data;
  // action
  signed int (*action)(const char *, const char **, void *);
  // msg
  const char *msg;
};

struct ci_proc_mutex_scheme
{
  // proc_mutex_init
  signed int (*proc_mutex_init)(struct ci_proc_mutex *, const char *);
  // proc_mutex_destroy
  signed int (*proc_mutex_destroy)(struct ci_proc_mutex *);
  // proc_mutex_lock
  signed int (*proc_mutex_lock)(struct ci_proc_mutex *);
  // proc_mutex_unlock
  signed int (*proc_mutex_unlock)(struct ci_proc_mutex *);
  // proc_mutex_print_info
  signed int (*proc_mutex_print_info)(struct ci_proc_mutex *, char *, unsigned long int);
  // name
  const char *name;
};

struct ci_regex_match
{
  // s
  unsigned long int s;
  // e
  unsigned long int e;
};

struct ci_regex_replace_part
{
  // user_data
  const void *user_data;
  // matches
  struct ci_regex_match matches[10l];
};

struct ci_request
{
  // connection
  struct ci_connection *connection;
  // packed
  signed int packed;
  // type
  signed int type;
  // req_server
  char req_server[257l];
  // access_type
  signed int access_type;
  // user
  char user[256l];
  // service
  char service[64l];
  // args
  char args[255l];
  // preview
  signed int preview;
  // keepalive
  signed int keepalive;
  // allow204
  signed int allow204;
  // hasbody
  signed int hasbody;
  // responce_hasbody
  signed int responce_hasbody;
  // preview_data
  struct ci_buf preview_data;
  // current_service_mod
  struct ci_service_module *current_service_mod;
  // request_header
  struct ci_headers_list *request_header;
  // response_header
  struct ci_headers_list *response_header;
  // entities
  struct ci_encaps_entity *entities[5l];
  // trash_entities
  struct ci_encaps_entity *trash_entities[7l];
  // xheaders
  struct ci_headers_list *xheaders;
  // service_data
  void *service_data;
  // rbuf
  char rbuf[4096l];
  // wbuf
  char wbuf[4096l];
  // eof_received
  signed int eof_received;
  // data_locked
  signed int data_locked;
  // pstrblock_read
  char *pstrblock_read;
  // pstrblock_read_len
  signed int pstrblock_read_len;
  // current_chunk_len
  unsigned int current_chunk_len;
  // chunk_bytes_read
  unsigned int chunk_bytes_read;
  // write_to_module_pending
  unsigned int write_to_module_pending;
  // status
  signed int status;
  // return_code
  signed int return_code;
  // pstrblock_responce
  char *pstrblock_responce;
  // remain_send_block_bytes
  signed int remain_send_block_bytes;
  // preview_data_type
  signed int preview_data_type;
  // auth_required
  signed int auth_required;
  // log_str
  char *log_str;
  // attributes
  struct ci_array *attributes;
  // bytes_in
  unsigned long int bytes_in;
  // bytes_out
  unsigned long int bytes_out;
  // request_bytes_in
  unsigned long int request_bytes_in;
  // http_bytes_in
  unsigned long int http_bytes_in;
  // http_bytes_out
  unsigned long int http_bytes_out;
  // body_bytes_in
  unsigned long int body_bytes_in;
  // body_bytes_out
  unsigned long int body_bytes_out;
  // allow206
  signed int allow206;
  // i206_use_original_body
  signed long int i206_use_original_body;
  // xclient_ip
  struct ci_ip xclient_ip;
};

struct ci_ring_buf
{
  // buf
  char *buf;
  // end_buf
  char *end_buf;
  // read_pos
  char *read_pos;
  // write_pos
  char *write_pos;
  // full
  signed int full;
};

struct ci_server_conf
{
  // ADDRESS
  char *ADDRESS;
  // PORT
  signed int PORT;
  // PROTOCOL_FAMILY
  signed int PROTOCOL_FAMILY;
  // TMPDIR
  char *TMPDIR;
  // PIDFILE
  char *PIDFILE;
  // COMMANDS_SOCKET
  char *COMMANDS_SOCKET;
  // RUN_USER
  char *RUN_USER;
  // RUN_GROUP
  char *RUN_GROUP;
  // cfg_file
  char *cfg_file;
  // magics_file
  char *magics_file;
  // MAGIC_DB
  struct ci_magics_db *MAGIC_DB;
  // SERVICES_DIR
  char *SERVICES_DIR;
  // MODULES_DIR
  char *MODULES_DIR;
  // SERVER_ADMIN
  char *SERVER_ADMIN;
  // SERVER_NAME
  char *SERVER_NAME;
  // START_SERVERS
  signed int START_SERVERS;
  // MAX_SERVERS
  signed int MAX_SERVERS;
  // THREADS_PER_CHILD
  signed int THREADS_PER_CHILD;
  // MIN_SPARE_THREADS
  signed int MIN_SPARE_THREADS;
  // MAX_SPARE_THREADS
  signed int MAX_SPARE_THREADS;
};

struct ci_service_module
{
  // mod_name
  const char *mod_name;
  // mod_short_descr
  const char *mod_short_descr;
  // mod_type
  signed int mod_type;
  // mod_init_service
  signed int (*mod_init_service)(struct ci_service_xdata *, struct ci_server_conf *);
  // mod_post_init_service
  signed int (*mod_post_init_service)(struct ci_service_xdata *, struct ci_server_conf *);
  // mod_close_service
  void (*mod_close_service)();
  // mod_init_request_data
  void * (*mod_init_request_data)(struct ci_request *);
  // mod_release_request_data
  void (*mod_release_request_data)(void *);
  // mod_check_preview_handler
  signed int (*mod_check_preview_handler)(char *, signed int, struct ci_request *);
  // mod_end_of_data_handler
  signed int (*mod_end_of_data_handler)(struct ci_request *);
  // mod_service_io
  signed int (*mod_service_io)(char *, signed int *, char *, signed int *, signed int, struct ci_request *);
  // mod_conf_table
  struct ci_conf_entry *mod_conf_table;
  // mod_data
  void *mod_data;
};

struct ci_service_xdata
{
  // lock
  union anonymous_37 lock;
  // status
  signed int status;
  // intl_srv_conf_table
  struct ci_conf_entry *intl_srv_conf_table;
  // xopts
  unsigned long int xopts;
  // ISTag
  char ISTag[40l];
  // xincludes
  char xincludes[512l];
  // TransferPreview
  char TransferPreview[1024l];
  // TransferIgnore
  char TransferIgnore[1024l];
  // TransferComplete
  char TransferComplete[1024l];
  // preview_size
  signed int preview_size;
  // max_connections
  signed int max_connections;
  // options_ttl
  signed int options_ttl;
  // allow_204
  signed int allow_204;
  // allow_206
  signed int allow_206;
  // disable_206
  signed int disable_206;
  // stat_bytes_in
  signed int stat_bytes_in;
  // stat_bytes_out
  signed int stat_bytes_out;
  // stat_http_bytes_in
  signed int stat_http_bytes_in;
  // stat_http_bytes_out
  signed int stat_http_bytes_out;
  // stat_body_bytes_in
  signed int stat_body_bytes_in;
  // stat_body_bytes_out
  signed int stat_body_bytes_out;
  // stat_reqmods
  signed int stat_reqmods;
  // stat_respmods
  signed int stat_respmods;
  // stat_options
  signed int stat_options;
  // stat_allow204
  signed int stat_allow204;
};

struct ci_shared_mem_id
{
  // name
  char name[64l];
  // mem
  void *mem;
  // size
  unsigned long int size;
  // scheme
  const struct ci_shared_mem_scheme *scheme;
  // _anon0
  union anonymous_31 _anon0;
};

struct ci_shared_mem_scheme
{
  // shared_mem_create
  void * (*shared_mem_create)(struct ci_shared_mem_id *, const char *, signed int);
  // shared_mem_attach
  void * (*shared_mem_attach)(struct ci_shared_mem_id *);
  // shared_mem_detach
  signed int (*shared_mem_detach)(struct ci_shared_mem_id *);
  // shared_mem_destroy
  signed int (*shared_mem_destroy)(struct ci_shared_mem_id *);
  // shared_mem_print_info
  signed int (*shared_mem_print_info)(struct ci_shared_mem_id *, char *, unsigned long int);
  // name
  const char *name;
};

struct ci_simple_file
{
  // endpos
  signed long int endpos;
  // readpos
  signed long int readpos;
  // max_store_size
  signed long int max_store_size;
  // bytes_in
  signed long int bytes_in;
  // bytes_out
  signed long int bytes_out;
  // flags
  unsigned int flags;
  // unlocked
  signed long int unlocked;
  // fd
  signed int fd;
  // filename
  char filename[4097l];
  // attributes
  struct ci_array *attributes;
  // mmap_addr
  char *mmap_addr;
  // mmap_size
  signed long int mmap_size;
};

struct ci_specs_list
{
  // spec
  const struct ci_acl_spec *spec;
  // negate
  signed int negate;
  // next
  struct ci_specs_list *next;
};

struct ci_type_ops
{
  // dup
  void * (*dup)(const char *, struct ci_mem_allocator *);
  // free
  void (*free)(void *, struct ci_mem_allocator *);
  // compare
  signed int (*compare)(const void *, const void *);
  // size
  unsigned long int (*size)(const void *);
  // equal
  signed int (*equal)(const void *, const void *);
};

struct ci_vector
{
  // items
  void **items;
  // last
  void **last;
  // mem
  char *mem;
  // max_size
  unsigned long int max_size;
  // count
  signed int count;
  // alloc
  struct ci_mem_allocator *alloc;
};

struct flock
{
  // l_type
  signed short int l_type;
  // l_whence
  signed short int l_whence;
  // l_start
  signed long int l_start;
  // l_len
  signed long int l_len;
  // l_pid
  signed int l_pid;
};

struct in6_addr
{
  // __in6_u
  union anonymous __in6_u;
};

struct internal_state
{
  // dummy
  signed int dummy;
};

struct ipc_perm
{
  // __key
  signed int __key;
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
  // cuid
  unsigned int cuid;
  // cgid
  unsigned int cgid;
  // mode
  unsigned short int mode;
  // __pad1
  unsigned short int __pad1;
  // __seq
  unsigned short int __seq;
  // __pad2
  unsigned short int __pad2;
  // __glibc_reserved1
  unsigned long int __glibc_reserved1;
  // __glibc_reserved2
  unsigned long int __glibc_reserved2;
};

struct kbs
{
  // kb
  unsigned long int kb;
  // bytes
  unsigned int bytes;
};

struct linger
{
  // l_onoff
  signed int l_onoff;
  // l_linger
  signed int l_linger;
};

struct mem_block_item
{
  // data
  void *data;
  // next
  struct mem_block_item *next;
};

struct mem_buffer_block
{
  // sig
  unsigned short int sig;
  // ID
  signed int ID;
  // data
  union anonymous_0 data;
};

struct mutex_itm
{
  // mtx
  union anonymous_38 mtx;
  // type
  signed int type;
  // next
  struct mutex_itm *next;
};

struct pack_allocator
{
  // memchunk
  void *memchunk;
  // curpos
  void *curpos;
  // endpos
  void *endpos;
  // end
  void *end;
  // must_free
  signed int must_free;
};

struct pcre_extra
{
  // flags
  unsigned long int flags;
  // study_data
  void *study_data;
  // match_limit
  unsigned long int match_limit;
  // callout_data
  void *callout_data;
  // tables
  const unsigned char *tables;
  // match_limit_recursion
  unsigned long int match_limit_recursion;
  // mark
  unsigned char **mark;
  // executable_jit
  void *executable_jit;
};

struct pool_allocator
{
  // items_size
  signed int items_size;
  // strict
  signed int strict;
  // alloc_count
  signed int alloc_count;
  // hits_count
  signed int hits_count;
  // mutex
  union anonymous_4 mutex;
  // free
  struct mem_block_item *free;
  // allocated
  struct mem_block_item *allocated;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct sembuf
{
  // sem_num
  unsigned short int sem_num;
  // sem_op
  signed short int sem_op;
  // sem_flg
  signed short int sem_flg;
};

struct semid_ds
{
  // sem_perm
  struct ipc_perm sem_perm;
  // sem_otime
  signed long int sem_otime;
  // __glibc_reserved1
  unsigned long int __glibc_reserved1;
  // sem_ctime
  signed long int sem_ctime;
  // __glibc_reserved2
  unsigned long int __glibc_reserved2;
  // sem_nsems
  unsigned long int sem_nsems;
  // __glibc_reserved3
  unsigned long int __glibc_reserved3;
  // __glibc_reserved4
  unsigned long int __glibc_reserved4;
};

struct seminfo
{
  // semmap
  signed int semmap;
  // semmni
  signed int semmni;
  // semmns
  signed int semmns;
  // semmnu
  signed int semmnu;
  // semmsl
  signed int semmsl;
  // semopm
  signed int semopm;
  // semume
  signed int semume;
  // semusz
  signed int semusz;
  // semvmx
  signed int semvmx;
  // semaem
  signed int semaem;
};

union semun
{
  // val
  signed int val;
  // buf
  struct semid_ds *buf;
  // array
  unsigned short int *array;
  // __buf
  struct seminfo *__buf;
};

struct serial_allocator
{
  // memchunk
  void *memchunk;
  // curpos
  void *curpos;
  // endpos
  void *endpos;
  // next
  struct serial_allocator *next;
};

struct shmid_ds
{
  // shm_perm
  struct ipc_perm shm_perm;
  // shm_segsz
  unsigned long int shm_segsz;
  // shm_atime
  signed long int shm_atime;
  // shm_dtime
  signed long int shm_dtime;
  // shm_ctime
  signed long int shm_ctime;
  // shm_cpid
  signed int shm_cpid;
  // shm_lpid
  signed int shm_lpid;
  // shm_nattch
  unsigned long int shm_nattch;
  // __glibc_reserved4
  unsigned long int __glibc_reserved4;
  // __glibc_reserved5
  unsigned long int __glibc_reserved5;
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct stat_area
{
  // mtx
  union anonymous_4 mtx;
  // release_mem
  void (*release_mem)(void *);
  // mem_block
  struct stat_memblock *mem_block;
};

struct stat_entry
{
  // label
  char *label;
  // type
  signed int type;
  // gid
  signed int gid;
};

struct stat_entry_list
{
  // entries
  struct stat_entry *entries;
  // size
  signed int size;
  // entries_num
  signed int entries_num;
};

struct stat_groups_list
{
  // groups
  char **groups;
  // size
  signed int size;
  // entries_num
  signed int entries_num;
};

struct stat_memblock
{
  // sig
  unsigned int sig;
  // counters64_size
  signed int counters64_size;
  // counterskbs_size
  signed int counterskbs_size;
  // counters64
  unsigned long int *counters64;
  // counterskbs
  struct kbs *counterskbs;
};

struct text_table
{
  // entries
  struct text_table_entry *entries;
  // hash_table
  struct ci_hash_table *hash_table;
  // rows
  signed int rows;
};

struct text_table_entry
{
  // key
  void *key;
  // vals
  void **vals;
  // next
  struct text_table_entry *next;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct z_stream_s
{
  // next_in
  unsigned char *next_in;
  // avail_in
  unsigned int avail_in;
  // total_in
  unsigned long int total_in;
  // next_out
  unsigned char *next_out;
  // avail_out
  unsigned int avail_out;
  // total_out
  unsigned long int total_out;
  // msg
  char *msg;
  // state
  struct internal_state *state;
  // zalloc
  void * (*zalloc)(void *, unsigned int, unsigned int);
  // zfree
  void (*zfree)(void *, void *);
  // opaque
  void *opaque;
  // data_type
  signed int data_type;
  // adler
  unsigned long int adler;
  // reserved
  unsigned long int reserved;
};


// CACHED_FILE_POOL
// file body.c line 45
static signed int CACHED_FILE_POOL = -1;
// CI_BODY_MAX_MEM
// file body.c line 334
signed int CI_BODY_MAX_MEM = 131072;
// CI_DEBUG_LEVEL
// file debug.c line 26
signed int CI_DEBUG_LEVEL = 1;
// CI_DEBUG_STDOUT
// file debug.c line 27
signed int CI_DEBUG_STDOUT = 0;
// CI_TMPDIR
// file body.c line 335
char *CI_TMPDIR = "/var/tmp/";
// DUMP_MODE
// file c-icap-mkbdb.c line 24
signed int DUMP_MODE = 0;
// GlobalTable
// file txt_format.c line 100
struct ci_fmt_entry GlobalTable[35l];
// GlobalTable
// file txt_format.c line 100
struct ci_fmt_entry GlobalTable[35l] = { { .directive="%a", .description="Remote IP-Address", .format=fmt_remoteip },
    { .directive="%la", .description="Local IP Address", .format=fmt_localip },
    { .directive="%lp", .description="Local port", .format=fmt_none },
    { .directive="%>a", .description="Http Client IP Address", .format=fmt_httpclientip },
    { .directive="%<A", .description="Http Server IP Address", .format=fmt_httpserverip },
    { .directive="%ts", .description="Seconds since epoch", .format=fmt_seconds },
    { .directive="%tl", .description="Local time", .format=fmt_localtime },
    { .directive="%tg", .description="GMT time", .format=fmt_gmttime },
    { .directive="%tr", .description="Response time", .format=fmt_none },
    { .directive="%>hi", .description="Http request header", .format=fmt_none },
    { .directive="%>ho", .description="Modified Http request header", .format=fmt_http_req_head_o },
    { .directive="%huo", .description="Modified Http request url", .format=fmt_http_req_url_o },
    { .directive="%hu", .description="Http request url", .format=fmt_none },
    { .directive="%<hi", .description="Http reply header", .format=fmt_none },
    { .directive="%<ho", .description="Modified Http reply header", .format=fmt_http_res_head_o },
    { .directive="%Hs", .description="Http reply status", .format=fmt_none },
    { .directive="%Hso", .description="Modified Http reply status", .format=fmt_none },
    { .directive="%iu", .description="Icap request url", .format=fmt_request },
    { .directive="%im", .description="Icap method", .format=fmt_icapmethod },
    { .directive="%is", .description="Icap status code", .format=fmt_icapstatus },
    { .directive="%>ih", .description="Icap request header", .format=fmt_icap_req_head },
    { .directive="%<ih", .description="Icap response header", .format=fmt_icap_res_head },
    { .directive="%ipl", .description="Icap preview length", .format=fmt_req_preview_len },
    { .directive="%Ih", .description="Http bytes received", .format=fmt_req_http_bytes_rcv },
    { .directive="%Oh", .description="Http bytes sent", .format=fmt_req_http_bytes_sent },
    { .directive="%Ib", .description="Http body bytes received", .format=fmt_req_body_bytes_rcv },
    { .directive="%Ob", .description="Http body bytes sent", .format=fmt_req_body_bytes_sent },
    { .directive="%I", .description="Bytes received", .format=fmt_req_bytes_rcv },
    { .directive="%O", .description="Bytes sent", .format=fmt_req_bytes_sent },
    { .directive="%bph", .description="Body data preview", .format=fmt_req_preview_hex },
    { .directive="%un", .description="Username", .format=fmt_username },
    { .directive="%Sl", .description="Service log string", .format=fmt_logstr },
    { .directive="%Sa", .description="Attribute set by service", .format=fmt_req_attribute },
    { .directive="%%", .description="% sign", .format=fmt_percent },
    { .directive=(const char *)(void *)0, .description=(const char *)(void *)0, .format=(signed int (*)(struct ci_request *, char *, signed int, const char *))(void *)0 } };
// MEMBUF_POOL
// file body.c line 44
static signed int MEMBUF_POOL = -1;
// MEM_ALLOCATOR_POOL
// file mem.c line 34
signed int MEM_ALLOCATOR_POOL = -1;
// PACK_ALLOCATOR_POOL
// file mem.c line 35
signed int PACK_ALLOCATOR_POOL = -1;
// REGISTRIES
// file registry.c line 26
static struct ci_array *REGISTRIES = (struct ci_array *)(void *)0;
// REG_ITEMS_COUNT
// file registry.c line 27
static signed int REG_ITEMS_COUNT = 0;
// RING_BUF_POOL
// file body.c line 47
static signed int RING_BUF_POOL = -1;
// SIMPLE_FILE_POOL
// file body.c line 46
static signed int SIMPLE_FILE_POOL = -1;
// STATS
// file stats.c line 29
struct stat_area *STATS = (struct stat_area *)(void *)0;
// STAT_GROUPS
// file stats.c line 27
struct stat_groups_list STAT_GROUPS = { .groups=(char **)(void *)0, .size=0, .entries_num=0 };
// STAT_INT64
// file stats.c line 25
struct stat_entry_list STAT_INT64 = { .entries=(struct stat_entry *)(void *)0, .size=0,
    .entries_num=0 };
// STAT_KBS
// file stats.c line 26
struct stat_entry_list STAT_KBS = { .entries=(struct stat_entry *)(void *)0, .size=0,
    .entries_num=0 };
// TEMPLATE_CACHE_SIZE
// file txtTemplate.c line 63
signed int TEMPLATE_CACHE_SIZE = 20;
// TEMPLATE_DEF_LANG
// file txtTemplate.c line 57
const char *TEMPLATE_DEF_LANG = "en";
// TEMPLATE_DIR
// file txtTemplate.c line 56
const char *TEMPLATE_DIR = (const char *)(void *)0;
// TEMPLATE_MEMBUF_SIZE
// file txtTemplate.c line 64
signed int TEMPLATE_MEMBUF_SIZE = 8192;
// TEMPLATE_RELOAD_TIME
// file txtTemplate.c line 58
signed int TEMPLATE_RELOAD_TIME = 360;
// _MAGIC_DB
// file filetype.c line 39
static struct ci_magics_db *_MAGIC_DB = (struct ci_magics_db *)(void *)0;
// __intl_free
// file request_common.c line 41
void (*__intl_free)(void *);
// __intl_free
// file request_common.c line 41
void (*__intl_free)(void *) = _os_free;
// __intl_malloc
// file request_common.c line 40
void * (*__intl_malloc)(signed int);
// __intl_malloc
// file request_common.c line 40
void * (*__intl_malloc)(signed int) = _os_malloc;
// __log_error
// file debug.c line 31
void (*__log_error)(void *, const char *, ...) = (void (*)(void *, const char *, ...))(void *)0;
// acl_cmp_uint64_ops
// file acl.c line 207
static const struct ci_type_ops acl_cmp_uint64_ops;
// acl_cmp_uint64_ops
// file acl.c line 207
static const struct ci_type_ops acl_cmp_uint64_ops = { .dup=acl_cmp_uint64_dup, .free=acl_cmp_uint64_free, .compare=(signed int (*)(const void *, const void *))(void *)0,
    .size=(unsigned long int (*)(const void *))(void *)0,
    .equal=acl_cmp_uint64_equal };
// acl_content_length
// file acl.c line 217
static struct ci_acl_type acl_content_length;
// acl_content_length
// file acl.c line 217
static struct ci_acl_type acl_content_length = { .name={ 'c', 'o', 'n', 't', 'e', 'n', 't', '_', 'l', 'e', 'n', 'g', 't', 'h', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_content_length,
    .free_test_data=free_cmp_uint64_data, .type=&acl_cmp_uint64_ops };
// acl_data_type
// file acl.c line 168
struct ci_acl_type acl_data_type;
// ci_datatype_ops
// file types_ops.c line 377
const struct ci_type_ops ci_datatype_ops;
// ci_datatype_ops
// file types_ops.c line 377
const struct ci_type_ops ci_datatype_ops = { .dup=datatype_dup, .free=datatype_free, .compare=datatype_cmp,
    .size=datatype_len, .equal=datatype_equal };
// acl_data_type
// file acl.c line 168
struct ci_acl_type acl_data_type = { .name={ 'd', 'a', 't', 'a', '_', 't', 'y', 'p', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_data_type,
    .free_test_data=free_data_type, .type=&ci_datatype_ops };
// acl_http_req_header
// file acl.c line 153
struct ci_acl_type acl_http_req_header;
// ci_regex_ops
// file types_ops.c line 301
const struct ci_type_ops ci_regex_ops;
// ci_regex_ops
// file types_ops.c line 301
const struct ci_type_ops ci_regex_ops = { .dup=regex_dup, .free=regex_free, .compare=regex_cmp, .size=regex_len,
    .equal=regex_equal };
// acl_http_req_header
// file acl.c line 153
struct ci_acl_type acl_http_req_header = { .name={ 'h', 't', 't', 'p', '_', 'r', 'e', 'q', '_', 'h', 'e', 'a', 'd', 'e', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_http_req_header,
    .free_test_data=free_http_req_header, .type=&ci_regex_ops };
// acl_http_resp_header
// file acl.c line 160
struct ci_acl_type acl_http_resp_header;
// acl_http_resp_header
// file acl.c line 160
struct ci_acl_type acl_http_resp_header = { .name={ 'h', 't', 't', 'p', '_', 'r', 'e', 's', 'p', '_', 'h', 'e', 'a', 'd', 'e', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_http_resp_header,
    .free_test_data=free_http_resp_header,
    .type=&ci_regex_ops };
// acl_icap_header
// file acl.c line 139
struct ci_acl_type acl_icap_header;
// acl_icap_header
// file acl.c line 139
struct ci_acl_type acl_icap_header = { .name={ 'i', 'c', 'a', 'p', '_', 'h', 'e', 'a', 'd', 'e', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_icap_header,
    .free_test_data=free_icap_header, .type=&ci_regex_ops };
// acl_icap_resp_header
// file acl.c line 146
struct ci_acl_type acl_icap_resp_header;
// acl_icap_resp_header
// file acl.c line 146
struct ci_acl_type acl_icap_resp_header = { .name={ 'i', 'c', 'a', 'p', '_', 'r', 'e', 's', 'p', '_', 'h', 'e', 'a', 'd', 'e', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_icap_response_header,
    .free_test_data=free_icap_response_header,
    .type=&ci_regex_ops };
// acl_req_type
// file acl.c line 103
struct ci_acl_type acl_req_type;
// ci_str_ops
// file types_ops.c line 65
const struct ci_type_ops ci_str_ops;
// ci_str_ops
// file types_ops.c line 65
const struct ci_type_ops ci_str_ops = { .dup=stringdup, .free=stringfree, .compare=stringcmp, .size=stringlen,
    .equal=stringequal };
// acl_req_type
// file acl.c line 103
struct ci_acl_type acl_req_type = { .name={ 't', 'y', 'p', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_reqtype,
    .free_test_data=(void (*)(struct ci_request *, void *))(void *)0, .type=&ci_str_ops };
// acl_service
// file acl.c line 96
struct ci_acl_type acl_service;
// acl_service
// file acl.c line 96
struct ci_acl_type acl_service = { .name={ 's', 'e', 'r', 'v', 'i', 'c', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_service,
    .free_test_data=(void (*)(struct ci_request *, void *))(void *)0, .type=&ci_str_ops };
// acl_tcp_port
// file acl.c line 110
struct ci_acl_type acl_tcp_port;
// ci_int32_ops
// file types_ops.c line 157
const struct ci_type_ops ci_int32_ops;
// ci_int32_ops
// file types_ops.c line 157
const struct ci_type_ops ci_int32_ops = { .dup=int32_dup, .free=int32_free, .compare=int32_cmp, .size=int32_len,
    .equal=int32_equal };
// acl_tcp_port
// file acl.c line 110
struct ci_acl_type acl_tcp_port = { .name={ 'p', 'o', 'r', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_port,
    .free_test_data=(void (*)(struct ci_request *, void *))(void *)0, .type=&ci_int32_ops };
// acl_tcp_src
// file acl.c line 117
struct ci_acl_type acl_tcp_src;
// ci_ip_sockaddr_ops
// file types_ops.c line 604
const struct ci_type_ops ci_ip_sockaddr_ops;
// ci_ip_sockaddr_ops
// file types_ops.c line 604
const struct ci_type_ops ci_ip_sockaddr_ops = { .dup=ip_dup, .free=ip_free, .compare=ip_sockaddr_cmp, .size=ip_len,
    .equal=ip_sockaddr_equal };
// acl_tcp_src
// file acl.c line 117
struct ci_acl_type acl_tcp_src = { .name={ 's', 'r', 'c', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_client_ip,
    .free_test_data=(void (*)(struct ci_request *, void *))(void *)0, .type=&ci_ip_sockaddr_ops };
// acl_tcp_srvip
// file acl.c line 124
struct ci_acl_type acl_tcp_srvip;
// acl_tcp_srvip
// file acl.c line 124
struct ci_acl_type acl_tcp_srvip = { .name={ 's', 'r', 'v', 'i', 'p', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_srv_ip,
    .free_test_data=(void (*)(struct ci_request *, void *))(void *)0, .type=&ci_ip_sockaddr_ops };
// acl_tcp_xclientip
// file acl.c line 131
struct ci_acl_type acl_tcp_xclientip;
// ci_ip_ops
// file types_ops.c line 594
const struct ci_type_ops ci_ip_ops;
// ci_ip_ops
// file types_ops.c line 594
const struct ci_type_ops ci_ip_ops = { .dup=ip_dup, .free=ip_free, .compare=ip_cmp, .size=ip_len,
    .equal=ip_equal };
// acl_tcp_xclientip
// file acl.c line 131
struct ci_acl_type acl_tcp_xclientip = { .name={ 'h', 't', 't', 'p', '_', 'c', 'l', 'i', 'e', 'n', 't', '_', 'i', 'p', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_http_client_ip,
    .free_test_data=(void (*)(struct ci_request *, void *))(void *)0, .type=&ci_ip_ops };
// acl_time
// file acl.c line 257
static struct ci_acl_type acl_time;
// acl_time_ops
// file acl.c line 246
static const struct ci_type_ops acl_time_ops;
// acl_time_ops
// file acl.c line 246
static const struct ci_type_ops acl_time_ops = { .dup=acl_time_dup, .free=acl_time_free, .compare=(signed int (*)(const void *, const void *))(void *)0,
    .size=(unsigned long int (*)(const void *))(void *)0,
    .equal=acl_time_equal };
// acl_time
// file acl.c line 257
static struct ci_acl_type acl_time = { .name={ 't', 'i', 'm', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_time_data,
    .free_test_data=free_time_data, .type=&acl_time_ops };
// acl_user
// file acl.c line 89
struct ci_acl_type acl_user;
// acl_user
// file acl.c line 89
struct ci_acl_type acl_user = { .name={ 'u', 's', 'e', 'r', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .get_test_data=get_user,
    .free_test_data=(void (*)(struct ci_request *, void *))(void *)0, .type=&ci_str_ops };
// allocator
// file c-icap-mkbdb.c line 26
struct ci_mem_allocator *allocator = (struct ci_mem_allocator *)(void *)0;
// atol_err_conversion
// file util.c line 75
static const char *atol_err_conversion = "CONVERSION_ERROR";
// atol_err_erange
// file util.c line 74
static const char *atol_err_erange = "ERANGE";
// atol_err_nonumber
// file util.c line 76
static const char *atol_err_nonumber = "NO_DIGITS_ERROR";
// base64_table
// file decode.c line 34
unsigned char base64_table[256l] = { (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)62, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)63, (unsigned char)52, (unsigned char)53, (unsigned char)54, (unsigned char)55, (unsigned char)56, (unsigned char)57, (unsigned char)58, (unsigned char)59, (unsigned char)60, (unsigned char)61, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)0, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)0, (unsigned char)1, (unsigned char)2, (unsigned char)3, (unsigned char)4, (unsigned char)5, (unsigned char)6, (unsigned char)7, (unsigned char)8, (unsigned char)9, (unsigned char)10, (unsigned char)11, (unsigned char)12, (unsigned char)13, (unsigned char)14, (unsigned char)15, (unsigned char)16, (unsigned char)17, (unsigned char)18, (unsigned char)19, (unsigned char)20, (unsigned char)21, (unsigned char)22, (unsigned char)23, (unsigned char)24, (unsigned char)25, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)26, (unsigned char)27, (unsigned char)28, (unsigned char)29, (unsigned char)30, (unsigned char)31, (unsigned char)32, (unsigned char)33, (unsigned char)34, (unsigned char)35, (unsigned char)36, (unsigned char)37, (unsigned char)38, (unsigned char)39, (unsigned char)40, (unsigned char)41, (unsigned char)42, (unsigned char)43, (unsigned char)44, (unsigned char)45, (unsigned char)46, (unsigned char)47, (unsigned char)48, (unsigned char)49, (unsigned char)50, (unsigned char)51, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255, (unsigned char)255 };
// cfg_params_allocator
// file cfg_lib.c line 32
struct ci_mem_allocator *cfg_params_allocator = (struct ci_mem_allocator *)(void *)0;
// ci_common_headers
// file header.c line 29
const char *ci_common_headers[8l] = { "Cache-Control", "Connection", "Date", "Expires", "Pragma", "Trailer", "Upgrade", "Encapsulated" };
// ci_encaps_entities
// file header.c line 128
const char *ci_encaps_entities[6l] = { "req-hdr", "res-hdr", "req-body", "res-body", "null-body", "opt-body" };
// ci_error_codes
// file header.c line 87
struct ci_error_code ci_error_codes[16l] = { { .code=100, .str="Continue" }, { .code=200, .str="OK" }, { .code=204, .str="Unmodified" }, { .code=206, .str="Partial Content" }, { .code=400, .str="Bad request" }, { .code=401, .str="Unauthorized" }, { .code=403, .str="Forbidden" }, { .code=404, .str="Service not found" },
    { .code=405, .str="Not allowed" }, { .code=407, .str="Authentication Required" },
    { .code=408, .str="Request timeout" }, { .code=500, .str="Server error" }, { .code=501, .str="Not implemented" }, { .code=502, .str="Bad Gateway" }, { .code=503, .str="Service overloaded" },
    { .code=505, .str="Unsupported version" } };
// ci_local_cache
// file cache.c line 70
struct ci_cache_type ci_local_cache;
// ci_local_cache
// file cache.c line 70
struct ci_cache_type ci_local_cache = { .init=ci_local_cache_init, .search=ci_local_cache_search, .update=ci_local_cache_update,
    .destroy=ci_local_cache_destroy, .name="local" };
// ci_methods
// file header.c line 43
const char *ci_methods[5l] = { "", "OPTIONS", "REQMOD", "", "RESPMOD" };
// ci_options_headers
// file header.c line 69
const char *ci_options_headers[14l] = { "Methods", "Service", "ISTag", "Encapsulated", "Opt-body-type", "Max-Connections", "Options-TTL", "Date", "Service-ID", "Allow", "Preview", "Transfer-Preview", "Transfer-Ignore", "Transfer-Complete" };
// ci_request_headers
// file header.c line 52
const char *ci_request_headers[7l] = { "Authorization", "Allow", "From", "Host", "Referer", "User-Agent", "Preview" };
// ci_responce_headers
// file header.c line 63
const char *ci_responce_headers[2l] = { "Server", "ISTag" };
// ci_str_ext_ops
// file types_ops.c line 96
const struct ci_type_ops ci_str_ext_ops;
// ci_str_ext_ops
// file types_ops.c line 96
const struct ci_type_ops ci_str_ext_ops = { .dup=stringdup, .free=stringfree, .compare=string_ext_cmp, .size=stringlen,
    .equal=string_ext_equal };
// ci_uint64_ops
// file types_ops.c line 214
const struct ci_type_ops ci_uint64_ops;
// ci_uint64_ops
// file types_ops.c line 214
const struct ci_type_ops ci_uint64_ops = { .dup=uint64_dup, .free=uint64_free, .compare=uint64_cmp, .size=uint64_len,
    .equal=uint64_equal };
// days
// file os/unix/utilfunc.c line 26
static const char *days[7l] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
// db
// file c-icap-mkbdb.c line 16
struct __db *db = (struct __db *)(void *)0;
// dbfile
// file c-icap-mkbdb.c line 23
char *dbfile = (char *)(void *)0;
// default_allocator
// file mem.c line 33
struct ci_mem_allocator *default_allocator = (struct ci_mem_allocator *)(void *)0;
// default_mutex_scheme
// file os/unix/proc_mutex.c line 245
const struct ci_proc_mutex_scheme *default_mutex_scheme;
// file_mutex_scheme
// file os/unix/proc_mutex.c line 233
static struct ci_proc_mutex_scheme file_mutex_scheme;
// file_mutex_scheme
// file os/unix/proc_mutex.c line 233
static struct ci_proc_mutex_scheme file_mutex_scheme = { .proc_mutex_init=file_proc_mutex_init, .proc_mutex_destroy=file_proc_mutex_destroy,
    .proc_mutex_lock=file_proc_mutex_lock,
    .proc_mutex_unlock=file_proc_mutex_unlock,
    .proc_mutex_print_info=file_proc_mutex_print_info,
    .name="file" };
// default_mutex_scheme
// file os/unix/proc_mutex.c line 245
const struct ci_proc_mutex_scheme *default_mutex_scheme = &file_mutex_scheme;
// default_scheme
// file os/unix/shared_mem.c line 218
const struct ci_shared_mem_scheme *default_scheme;
// posix_scheme
// file os/unix/shared_mem.c line 206
const struct ci_shared_mem_scheme posix_scheme;
// posix_scheme
// file os/unix/shared_mem.c line 206
const struct ci_shared_mem_scheme posix_scheme = { .shared_mem_create=posix_shared_mem_create, .shared_mem_attach=posix_shared_mem_attach,
    .shared_mem_detach=posix_shared_mem_detach,
    .shared_mem_destroy=posix_shared_mem_destroy,
    .shared_mem_print_info=posix_shared_mem_print_info,
    .name="posix" };
// default_scheme
// file os/unix/shared_mem.c line 218
const struct ci_shared_mem_scheme *default_scheme = &posix_scheme;
// env_db
// file c-icap-mkbdb.c line 15
struct __db_env *env_db = (struct __db_env *)(void *)0;
// eof_str
// file request_common.c line 1198
static const char *eof_str = "0\r\n\r\n";
// file_table_type
// file lookup_file_table.c line 34
struct ci_lookup_table_type file_table_type;
// file_table_type
// file lookup_file_table.c line 34
struct ci_lookup_table_type file_table_type = { .open=file_table_open, .close=file_table_close, .search=file_table_search,
    .release_result=file_table_release_result, .get_row=(const void * (*)(struct ci_lookup_table *, const void *, const char **, void ***))(void *)0,
    .type="file" };
// hash_table_type
// file lookup_file_table.c line 329
struct ci_lookup_table_type hash_table_type;
// hash_table_type
// file lookup_file_table.c line 329
struct ci_lookup_table_type hash_table_type = { .open=hash_table_open, .close=hash_table_close, .search=hash_table_search,
    .release_result=hash_table_release_result, .get_row=(const void * (*)(struct ci_lookup_table *, const void *, const char **, void ***))(void *)0,
    .type="hash" };
// init_child_mutexes_scheduled
// file os/unix/threads.c line 44
static signed int init_child_mutexes_scheduled = 0;
// key_ops
// file c-icap-mkbdb.c line 17
const struct ci_type_ops *key_ops;
// key_ops
// file c-icap-mkbdb.c line 17
const struct ci_type_ops *key_ops = &ci_str_ops;
// last
// file os/unix/threads.c line 42
static struct mutex_itm *last = (struct mutex_itm *)(void *)0;
// long_buffer_sizes
// file mem.c line 158
signed int long_buffer_sizes[16l] = { 2048, 4096, 8192, 8192, 16384, 16384, 16384, 16384, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768 };
// long_buffers
// file mem.c line 110
struct ci_mem_allocator *long_buffers[16l];
// lookup_tables_types
// file lookup_table.c line 30
struct ci_lookup_table_type *lookup_tables_types[128l];
// lookup_tables_types_num
// file lookup_table.c line 31
signed int lookup_tables_types_num = 0;
// mmap_scheme
// file os/unix/shared_mem.c line 142
const struct ci_shared_mem_scheme mmap_scheme;
// mmap_scheme
// file os/unix/shared_mem.c line 142
const struct ci_shared_mem_scheme mmap_scheme = { .shared_mem_create=mmap_shared_mem_create, .shared_mem_attach=mmap_shared_mem_attach,
    .shared_mem_detach=mmap_shared_mem_detach,
    .shared_mem_destroy=mmap_shared_mem_destroy,
    .shared_mem_print_info=mmap_shared_mem_print_info,
    .name="mmap" };
// months
// file os/unix/utilfunc.c line 36
static const char *months[12l] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
// mutexes
// file os/unix/threads.c line 41
static struct mutex_itm *mutexes = (struct mutex_itm *)(void *)0;
// mutexes_lock
// file os/unix/threads.c line 40
union anonymous_4 mutexes_lock = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// object_pools
// file mem.c line 301
struct ci_mem_allocator **object_pools = (struct ci_mem_allocator **)(void *)0;
// object_pools_size
// file mem.c line 302
signed int object_pools_size = 0;
// object_pools_used
// file mem.c line 303
signed int object_pools_used = 0;
// op_lock
// file os/unix/proc_mutex.c line 37
static struct sembuf op_lock[2l] = { { .sem_num=(unsigned short int)0, .sem_op=(signed short int)0, .sem_flg=(signed short int)0 },
    { .sem_num=(unsigned short int)0, .sem_op=(signed short int)1, .sem_flg=(signed short int)0x1000 } };
// op_unlock
// file os/unix/proc_mutex.c line 42
static struct sembuf op_unlock[1l] = { { .sem_num=(unsigned short int)0, .sem_op=(signed short int)-1, .sem_flg=(signed short int)(04000 | 0x1000) } };
// options
// file c-icap-mkbdb.c line 29
static struct ci_options_entry options[7l];
// txtfile
// file c-icap-mkbdb.c line 22
char *txtfile = (char *)(void *)0;
// options
// file c-icap-mkbdb.c line 29
static struct ci_options_entry options[7l] = { { .name="-d", .parameter="debug_level", .data=(void *)&CI_DEBUG_LEVEL, .action=ci_cfg_set_int,
    .msg="The debug level" },
    { .name="-i", .parameter="file.txt", .data=(void *)&txtfile, .action=ci_cfg_set_str,
    .msg="The file contains the data (required)" },
    { .name="-o", .parameter="file.db", .data=(void *)&dbfile, .action=ci_cfg_set_str,
    .msg="The database to be created" },
    { .name="-t", .parameter="string|int|ip", .data=(void *)0,
    .action=cfg_set_type, .msg="The type of the key" },
    { .name="-v", .parameter="string|int|ip", .data=(void *)0,
    .action=cfg_set_type, .msg="The type of values" },
    { .name="--dump", .parameter=(const char *)(void *)0, .data=(void *)&DUMP_MODE,
    .action=ci_cfg_enable, .msg="Do not update the database just dump it to the screen" },
    { .name=(const char *)(void *)0, .parameter=(const char *)(void *)0, .data=(void *)0,
    .action=(signed int (*)(const char *, const char **, void *))(void *)0, .msg=((const char *)NULL) } };
// pcre_free
// file /usr/include/pcre.h line 490
extern void (*pcre_free)(void *);
// posix_mutex_scheme
// file os/unix/proc_mutex.c line 170
static struct ci_proc_mutex_scheme posix_mutex_scheme;
// posix_mutex_scheme
// file os/unix/proc_mutex.c line 170
static struct ci_proc_mutex_scheme posix_mutex_scheme = { .proc_mutex_init=posix_proc_mutex_init, .proc_mutex_destroy=posix_proc_mutex_destroy,
    .proc_mutex_lock=posix_proc_mutex_lock,
    .proc_mutex_unlock=posix_proc_mutex_unlock,
    .proc_mutex_print_info=posix_proc_mutex_print_info,
    .name="posix" };
// predefined_groups
// file filetype.c line 51
struct ci_data_group predefined_groups[3l] = { { .name={ 'T', 'E', 'X', 'T', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 'A', 'l', 'l', ' ', 't', 'e', 'x', 't', 's', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .name={ 'D', 'A', 'T', 'A', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 'U', 'n', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 'd', 'a', 't', 'a', ' ', 't', 'y', 'p', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .name={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } } };
// predefined_types
// file filetype.c line 41
struct ci_data_type predefined_types[7l] = { { .name={ 'A', 'S', 'C', 'I', 'I', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 'A', 'S', 'C', 'I', 'I', ' ', 't', 'e', 'x', 't', ' ', 'f', 'i', 'l', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .groups={ 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .name={ 'I', 'S', 'O', '-', '8', '8', '5', '9', 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 'I', 'S', 'O', '-', '8', '8', '5', '9', ' ', 't', 'e', 'x', 't', ' ', 'f', 'i', 'l', 'e', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .groups={ 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .name={ 'E', 'X', 'T', '-', 'A', 'S', 'C', 'I', 'I', 0, 0, 0, 0, 0, 0, 0 }, .descr={ 'E', 'x', 't', 'e', 'n', 'd', 'e', 'd', ' ', 'A', 'S', 'C', 'I', 'I', ' ', '(', 'M', 'a', 'c', ',', 'I', 'B', 'M', ' ', 'P', 'C', ' ', 'e', 't', 'c', '.', ')', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .groups={ 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .name={ 'U', 'T', 'F', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 'U', 'n', 'i', 'c', 'o', 'd', 'e', ' ', 't', 'e', 'x', 't', ' ', 'f', 'i', 'l', 'e', ' ', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .groups={ 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .name={ 'H', 'T', 'M', 'L', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 'H', 'T', 'M', 'L', ' ', 't', 'e', 'x', 't', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .groups={ 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .name={ 'B', 'I', 'N', 'A', 'R', 'Y', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'd', 'a', 't', 'a', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .groups={ 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
    { .name={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .descr={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    .groups={ -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } } };
// regex_table_type
// file lookup_file_table.c line 409
struct ci_lookup_table_type regex_table_type;
// regex_table_type
// file lookup_file_table.c line 409
struct ci_lookup_table_type regex_table_type = { .open=regex_table_open, .close=regex_table_close, .search=regex_table_search,
    .release_result=regex_table_release_result, .get_row=(const void * (*)(struct ci_lookup_table *, const void *, const char **, void ***))(void *)0,
    .type="regex" };
// short_buffer_sizes
// file mem.c line 150
signed int short_buffer_sizes[16l] = { 64, 128, 256, 256, 512, 512, 512, 512, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024 };
// short_buffers
// file mem.c line 109
struct ci_mem_allocator *short_buffers[16l];
// specs_list
// file acl.c line 774
static struct ci_acl_spec *specs_list;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// sysv_mutex_scheme
// file os/unix/proc_mutex.c line 104
static struct ci_proc_mutex_scheme sysv_mutex_scheme;
// sysv_mutex_scheme
// file os/unix/proc_mutex.c line 104
static struct ci_proc_mutex_scheme sysv_mutex_scheme = { .proc_mutex_init=sysv_proc_mutex_init, .proc_mutex_destroy=sysv_proc_mutex_destroy,
    .proc_mutex_lock=sysv_proc_mutex_lock,
    .proc_mutex_unlock=sysv_proc_mutex_unlock,
    .proc_mutex_print_info=sysv_proc_mutex_print_info,
    .name="sysv" };
// sysv_scheme
// file os/unix/shared_mem.c line 89
const struct ci_shared_mem_scheme sysv_scheme;
// sysv_scheme
// file os/unix/shared_mem.c line 89
const struct ci_shared_mem_scheme sysv_scheme = { .shared_mem_create=sysv_shared_mem_create, .shared_mem_attach=sysv_shared_mem_attach,
    .shared_mem_detach=sysv_shared_mem_detach,
    .shared_mem_destroy=sysv_shared_mem_destroy,
    .shared_mem_print_info=sysv_shared_mem_print_info,
    .name="sysv" };
// templates
// file txtTemplate.c line 60
struct anonymous_22 *templates = (struct anonymous_22 *)(void *)0;
// templates_mutex
// file txtTemplate.c line 66
static union anonymous_4 templates_mutex;
// text_chars
// file filetype.c line 390
static const char text_chars[256l] = { (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)1, (const char)1, (const char)1, (const char)1, (const char)0, (const char)1, (const char)1, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)1, (const char)0, (const char)0, (const char)0, (const char)0, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)1, (const char)0, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)1, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)4, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2, (const char)2 };
// txtTemplateInited
// file txtTemplate.c line 61
signed int txtTemplateInited = 0;
// types_list
// file acl.c line 773
static struct ci_acl_type_list types_list;
// utf_boundaries
// file filetype.c line 436
static unsigned int utf_boundaries[7l] = { (unsigned int)0x0, (unsigned int)0x0, (unsigned int)0x07F, (unsigned int)0x7FF, (unsigned int)0xFFFF, (unsigned int)0x1FFFFF, (unsigned int)0x3FFFFFF };
// val_ops
// file c-icap-mkbdb.c line 18
const struct ci_type_ops *val_ops;
// val_ops
// file c-icap-mkbdb.c line 18
const struct ci_type_ops *val_ops = &ci_str_ops;

// MD5Transform
// file md5.c line 168
static void MD5Transform(unsigned int *buf, unsigned int *in)
{
  unsigned int a;
  unsigned int b;
  unsigned int c;
  unsigned int d;
  a = buf[(signed long int)0];
  b = buf[(signed long int)1];
  c = buf[(signed long int)2];
  d = buf[(signed long int)3];
  a = a + (d ^ b & (c ^ d)) + in[(signed long int)0] + 0xd76aa478;
  a = a << 7 | a >> 32 - 7;
  a = a + b;
  d = d + (c ^ a & (b ^ c)) + in[(signed long int)1] + 0xe8c7b756;
  d = d << 12 | d >> 32 - 12;
  d = d + a;
  c = c + (b ^ d & (a ^ b)) + in[(signed long int)2] + (unsigned int)0x242070db;
  c = c << 17 | c >> 32 - 17;
  c = c + d;
  b = b + (a ^ c & (d ^ a)) + in[(signed long int)3] + 0xc1bdceee;
  b = b << 22 | b >> 32 - 22;
  b = b + c;
  a = a + (d ^ b & (c ^ d)) + in[(signed long int)4] + 0xf57c0faf;
  a = a << 7 | a >> 32 - 7;
  a = a + b;
  d = d + (c ^ a & (b ^ c)) + in[(signed long int)5] + (unsigned int)0x4787c62a;
  d = d << 12 | d >> 32 - 12;
  d = d + a;
  c = c + (b ^ d & (a ^ b)) + in[(signed long int)6] + 0xa8304613;
  c = c << 17 | c >> 32 - 17;
  c = c + d;
  b = b + (a ^ c & (d ^ a)) + in[(signed long int)7] + 0xfd469501;
  b = b << 22 | b >> 32 - 22;
  b = b + c;
  a = a + (d ^ b & (c ^ d)) + in[(signed long int)8] + (unsigned int)0x698098d8;
  a = a << 7 | a >> 32 - 7;
  a = a + b;
  d = d + (c ^ a & (b ^ c)) + in[(signed long int)9] + 0x8b44f7af;
  d = d << 12 | d >> 32 - 12;
  d = d + a;
  c = c + (b ^ d & (a ^ b)) + in[(signed long int)10] + 0xffff5bb1;
  c = c << 17 | c >> 32 - 17;
  c = c + d;
  b = b + (a ^ c & (d ^ a)) + in[(signed long int)11] + 0x895cd7be;
  b = b << 22 | b >> 32 - 22;
  b = b + c;
  a = a + (d ^ b & (c ^ d)) + in[(signed long int)12] + (unsigned int)0x6b901122;
  a = a << 7 | a >> 32 - 7;
  a = a + b;
  d = d + (c ^ a & (b ^ c)) + in[(signed long int)13] + 0xfd987193;
  d = d << 12 | d >> 32 - 12;
  d = d + a;
  c = c + (b ^ d & (a ^ b)) + in[(signed long int)14] + 0xa679438e;
  c = c << 17 | c >> 32 - 17;
  c = c + d;
  b = b + (a ^ c & (d ^ a)) + in[(signed long int)15] + (unsigned int)0x49b40821;
  b = b << 22 | b >> 32 - 22;
  b = b + c;
  a = a + (c ^ d & (b ^ c)) + in[(signed long int)1] + 0xf61e2562;
  a = a << 5 | a >> 32 - 5;
  a = a + b;
  d = d + (b ^ c & (a ^ b)) + in[(signed long int)6] + 0xc040b340;
  d = d << 9 | d >> 32 - 9;
  d = d + a;
  c = c + (a ^ b & (d ^ a)) + in[(signed long int)11] + (unsigned int)0x265e5a51;
  c = c << 14 | c >> 32 - 14;
  c = c + d;
  b = b + (d ^ a & (c ^ d)) + in[(signed long int)0] + 0xe9b6c7aa;
  b = b << 20 | b >> 32 - 20;
  b = b + c;
  a = a + (c ^ d & (b ^ c)) + in[(signed long int)5] + 0xd62f105d;
  a = a << 5 | a >> 32 - 5;
  a = a + b;
  d = d + (b ^ c & (a ^ b)) + in[(signed long int)10] + (unsigned int)0x02441453;
  d = d << 9 | d >> 32 - 9;
  d = d + a;
  c = c + (a ^ b & (d ^ a)) + in[(signed long int)15] + 0xd8a1e681;
  c = c << 14 | c >> 32 - 14;
  c = c + d;
  b = b + (d ^ a & (c ^ d)) + in[(signed long int)4] + 0xe7d3fbc8;
  b = b << 20 | b >> 32 - 20;
  b = b + c;
  a = a + (c ^ d & (b ^ c)) + in[(signed long int)9] + (unsigned int)0x21e1cde6;
  a = a << 5 | a >> 32 - 5;
  a = a + b;
  d = d + (b ^ c & (a ^ b)) + in[(signed long int)14] + 0xc33707d6;
  d = d << 9 | d >> 32 - 9;
  d = d + a;
  c = c + (a ^ b & (d ^ a)) + in[(signed long int)3] + 0xf4d50d87;
  c = c << 14 | c >> 32 - 14;
  c = c + d;
  b = b + (d ^ a & (c ^ d)) + in[(signed long int)8] + (unsigned int)0x455a14ed;
  b = b << 20 | b >> 32 - 20;
  b = b + c;
  a = a + (c ^ d & (b ^ c)) + in[(signed long int)13] + 0xa9e3e905;
  a = a << 5 | a >> 32 - 5;
  a = a + b;
  d = d + (b ^ c & (a ^ b)) + in[(signed long int)2] + 0xfcefa3f8;
  d = d << 9 | d >> 32 - 9;
  d = d + a;
  c = c + (a ^ b & (d ^ a)) + in[(signed long int)7] + (unsigned int)0x676f02d9;
  c = c << 14 | c >> 32 - 14;
  c = c + d;
  b = b + (d ^ a & (c ^ d)) + in[(signed long int)12] + 0x8d2a4c8a;
  b = b << 20 | b >> 32 - 20;
  b = b + c;
  a = a + (b ^ c ^ d) + in[(signed long int)5] + 0xfffa3942;
  a = a << 4 | a >> 32 - 4;
  a = a + b;
  d = d + (a ^ b ^ c) + in[(signed long int)8] + 0x8771f681;
  d = d << 11 | d >> 32 - 11;
  d = d + a;
  c = c + (d ^ a ^ b) + in[(signed long int)11] + (unsigned int)0x6d9d6122;
  c = c << 16 | c >> 32 - 16;
  c = c + d;
  b = b + (c ^ d ^ a) + in[(signed long int)14] + 0xfde5380c;
  b = b << 23 | b >> 32 - 23;
  b = b + c;
  a = a + (b ^ c ^ d) + in[(signed long int)1] + 0xa4beea44;
  a = a << 4 | a >> 32 - 4;
  a = a + b;
  d = d + (a ^ b ^ c) + in[(signed long int)4] + (unsigned int)0x4bdecfa9;
  d = d << 11 | d >> 32 - 11;
  d = d + a;
  c = c + (d ^ a ^ b) + in[(signed long int)7] + 0xf6bb4b60;
  c = c << 16 | c >> 32 - 16;
  c = c + d;
  b = b + (c ^ d ^ a) + in[(signed long int)10] + 0xbebfbc70;
  b = b << 23 | b >> 32 - 23;
  b = b + c;
  a = a + (b ^ c ^ d) + in[(signed long int)13] + (unsigned int)0x289b7ec6;
  a = a << 4 | a >> 32 - 4;
  a = a + b;
  d = d + (a ^ b ^ c) + in[(signed long int)0] + 0xeaa127fa;
  d = d << 11 | d >> 32 - 11;
  d = d + a;
  c = c + (d ^ a ^ b) + in[(signed long int)3] + 0xd4ef3085;
  c = c << 16 | c >> 32 - 16;
  c = c + d;
  b = b + (c ^ d ^ a) + in[(signed long int)6] + (unsigned int)0x04881d05;
  b = b << 23 | b >> 32 - 23;
  b = b + c;
  a = a + (b ^ c ^ d) + in[(signed long int)9] + 0xd9d4d039;
  a = a << 4 | a >> 32 - 4;
  a = a + b;
  d = d + (a ^ b ^ c) + in[(signed long int)12] + 0xe6db99e5;
  d = d << 11 | d >> 32 - 11;
  d = d + a;
  c = c + (d ^ a ^ b) + in[(signed long int)15] + (unsigned int)0x1fa27cf8;
  c = c << 16 | c >> 32 - 16;
  c = c + d;
  b = b + (c ^ d ^ a) + in[(signed long int)2] + 0xc4ac5665;
  b = b << 23 | b >> 32 - 23;
  b = b + c;
  a = a + (c ^ (b | ~d)) + in[(signed long int)0] + 0xf4292244;
  a = a << 6 | a >> 32 - 6;
  a = a + b;
  d = d + (b ^ (a | ~c)) + in[(signed long int)7] + (unsigned int)0x432aff97;
  d = d << 10 | d >> 32 - 10;
  d = d + a;
  c = c + (a ^ (d | ~b)) + in[(signed long int)14] + 0xab9423a7;
  c = c << 15 | c >> 32 - 15;
  c = c + d;
  b = b + (d ^ (c | ~a)) + in[(signed long int)5] + 0xfc93a039;
  b = b << 21 | b >> 32 - 21;
  b = b + c;
  a = a + (c ^ (b | ~d)) + in[(signed long int)12] + (unsigned int)0x655b59c3;
  a = a << 6 | a >> 32 - 6;
  a = a + b;
  d = d + (b ^ (a | ~c)) + in[(signed long int)3] + 0x8f0ccc92;
  d = d << 10 | d >> 32 - 10;
  d = d + a;
  c = c + (a ^ (d | ~b)) + in[(signed long int)10] + 0xffeff47d;
  c = c << 15 | c >> 32 - 15;
  c = c + d;
  b = b + (d ^ (c | ~a)) + in[(signed long int)1] + 0x85845dd1;
  b = b << 21 | b >> 32 - 21;
  b = b + c;
  a = a + (c ^ (b | ~d)) + in[(signed long int)8] + (unsigned int)0x6fa87e4f;
  a = a << 6 | a >> 32 - 6;
  a = a + b;
  d = d + (b ^ (a | ~c)) + in[(signed long int)15] + 0xfe2ce6e0;
  d = d << 10 | d >> 32 - 10;
  d = d + a;
  c = c + (a ^ (d | ~b)) + in[(signed long int)6] + 0xa3014314;
  c = c << 15 | c >> 32 - 15;
  c = c + d;
  b = b + (d ^ (c | ~a)) + in[(signed long int)13] + (unsigned int)0x4e0811a1;
  b = b << 21 | b >> 32 - 21;
  b = b + c;
  a = a + (c ^ (b | ~d)) + in[(signed long int)4] + 0xf7537e82;
  a = a << 6 | a >> 32 - 6;
  a = a + b;
  d = d + (b ^ (a | ~c)) + in[(signed long int)11] + 0xbd3af235;
  d = d << 10 | d >> 32 - 10;
  d = d + a;
  c = c + (a ^ (d | ~b)) + in[(signed long int)2] + (unsigned int)0x2ad7d2bb;
  c = c << 15 | c >> 32 - 15;
  c = c + d;
  b = b + (d ^ (c | ~a)) + in[(signed long int)9] + 0xeb86d391;
  b = b << 21 | b >> 32 - 21;
  b = b + c;
  buf[(signed long int)0] = buf[(signed long int)0] + a;
  buf[(signed long int)1] = buf[(signed long int)1] + b;
  buf[(signed long int)2] = buf[(signed long int)2] + c;
  buf[(signed long int)3] = buf[(signed long int)3] + d;
}

// _os_free
// file request_common.c line 35
static void _os_free(void *ptr)
{
  free(ptr);
}

// _os_malloc
// file request_common.c line 30
static void * _os_malloc(signed int size)
{
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)size);
  return return_value_malloc_1;
}

// acl_cmp_uint64_dup
// file acl.c line 182
void * acl_cmp_uint64_dup(const char *str, struct ci_mem_allocator *allocator)
{
  void *return_value;
  return_value=ci_uint64_ops.dup(str, allocator);
  return return_value;
}

// acl_cmp_uint64_equal
// file acl.c line 187
signed int acl_cmp_uint64_equal(const void *key1, const void *key2)
{
  unsigned long int k1 = *((unsigned long int *)key1);
  struct acl_cmp_uint64_data *data = (struct acl_cmp_uint64_data *)key2;
  if(CI_DEBUG_LEVEL >= 8)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
    {
      signed int tmp_if_expr_1;
      if(data->operator == 1)
        tmp_if_expr_1 = 62;

      else
        tmp_if_expr_1 = data->operator == 2 ? 60 : 61;
      __log_error((void *)0, "Acl content length check %llu %c %llu\n", (signed long long int)data->data, tmp_if_expr_1, (signed long long int)k1);
    }

    if(!(CI_DEBUG_STDOUT == 0))
    {
      signed int tmp_if_expr_2;
      if(data->operator == 1)
        tmp_if_expr_2 = 62;

      else
        tmp_if_expr_2 = data->operator == 2 ? 60 : 61;
      printf("Acl content length check %llu %c %llu\n", (signed long long int)data->data, tmp_if_expr_2, (signed long long int)k1);
    }

  }

  if(data->operator == 1)
    return (signed int)(data->data > k1);

  else
    if(data->operator == 2)
      return (signed int)(data->data < k1);

    else
      return (signed int)(k1 == data->data);
}

// acl_cmp_uint64_free
// file acl.c line 202
void acl_cmp_uint64_free(void *key, struct ci_mem_allocator *allocator)
{
  ci_uint64_ops.free(key, allocator);
}

// acl_load_defaults
// file acl.c line 776
static signed int acl_load_defaults()
{
  ci_acl_typelist_add(&types_list, &acl_tcp_port);
  ci_acl_typelist_add(&types_list, &acl_service);
  ci_acl_typelist_add(&types_list, &acl_req_type);
  ci_acl_typelist_add(&types_list, &acl_user);
  ci_acl_typelist_add(&types_list, &acl_tcp_src);
  ci_acl_typelist_add(&types_list, &acl_tcp_srvip);
  ci_acl_typelist_add(&types_list, &acl_icap_header);
  ci_acl_typelist_add(&types_list, &acl_icap_resp_header);
  ci_acl_typelist_add(&types_list, &acl_http_req_header);
  ci_acl_typelist_add(&types_list, &acl_http_resp_header);
  ci_acl_typelist_add(&types_list, &acl_data_type);
  ci_acl_typelist_add(&types_list, &acl_content_length);
  ci_acl_typelist_add(&types_list, &acl_time);
  ci_acl_typelist_add(&types_list, &acl_tcp_xclientip);
  return 1;
}

// acl_time_dup
// file acl.c line 270
void * acl_time_dup(const char *str, struct ci_mem_allocator *allocator)
{
  /* tag-#anon#lST[l*{cS8}_cS8_'day'|S32'id'|U32'_pad0'] */
struct anonymous_12
{
  // day
  const char *day;
  // id
  signed int id;
};

/* */
  ;
  struct anonymous_12 acl_time_dup__1__days[15l] = { { .day="Sunday", .id=0 }, { .day="Monday", .id=1 }, { .day="Tuesday", .id=2 }, { .day="Wednesday", .id=3 }, { .day="Thursday", .id=4 }, { .day="Friday", .id=5 }, { .day="Saturday", .id=6 }, { .day="S", .id=0 }, { .day="M", .id=1 }, { .day="T", .id=2 }, { .day="W", .id=3 }, { .day="H", .id=4 }, { .day="F", .id=5 }, { .day="A", .id=6 }, { .day=(const char *)(void *)0, .id=-1 } };
  signed int h1;
  signed int m1;
  signed int h2;
  signed int m2;
  signed int i;
  char *s;
  char *e;
  const char *error;
  char buf[1024l];
  struct acl_time_data *tmd;
  void *return_value;
  return_value=allocator->alloc(allocator, sizeof(struct acl_time_data) /*12ul*/ );
  tmd = (struct acl_time_data *)return_value;
  tmd->days = (unsigned int)0;
  strncpy(buf, str, sizeof(char [1024l]) /*1024ul*/ );
  buf[(signed long int)(sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1)] = (char)0;
  s = buf;
  const unsigned short int **return_value___ctype_b_loc_4;
  return_value___ctype_b_loc_4=__ctype_b_loc();
  if((2048 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)*s]) == 0)
  {
    if((signed int)*s == 44)
      s = s + 1l;

    i = 0;
    if(!(acl_time_dup__1__days[(signed long int)i].day == ((const char *)NULL)))
    {
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(acl_time_dup__1__days[(signed long int)i].day);
      signed int return_value_strncasecmp_2;
      return_value_strncasecmp_2=strncasecmp(s, acl_time_dup__1__days[(signed long int)i].day, return_value_strlen_1);
      if(return_value_strncasecmp_2 == 0)
        tmd->days = tmd->days | (unsigned int)(1 << acl_time_dup__1__days[(signed long int)i].id);

      else
        i = i + 1;
    }

    if(acl_time_dup__1__days[(signed long int)i].day == ((const char *)NULL))
      error = s;

    unsigned long int return_value_strlen_3;
    return_value_strlen_3=strlen(acl_time_dup__1__days[(signed long int)i].day);
    s = s + (signed long int)return_value_strlen_3;
    if(!((signed int)*s == 47))
      error = s;

    if(!(*s == 0))
      s = s + 1l;

  }

  const unsigned short int **return_value___ctype_b_loc_5;
  return_value___ctype_b_loc_5=__ctype_b_loc();
  signed long int return_value_strtol_6;
  const unsigned short int **return_value___ctype_b_loc_7;
  signed long int return_value_strtol_9;
  const unsigned short int **return_value___ctype_b_loc_10;
  signed long int return_value_strtol_12;
  const unsigned short int **return_value___ctype_b_loc_13;
  signed long int return_value_strtol_15;
  if((2048 & (signed int)(*return_value___ctype_b_loc_5)[(signed long int)(signed int)*s]) == 0)
    error = s;

  else
  {
    return_value_strtol_6=strtol(s, &e, 10);
    h1 = (signed int)return_value_strtol_6;
    if(h1 >= 25 || !(h1 >= 0))
      error = s;

    else
    {
      _Bool tmp_if_expr_8;
      if(!((signed int)*e == 58))
        tmp_if_expr_8 = (_Bool)1;

      else
      {
        return_value___ctype_b_loc_7=__ctype_b_loc();
        tmp_if_expr_8 = !(((signed int)(*return_value___ctype_b_loc_7)[(signed long int)(signed int)e[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0) ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_8)
        error = e;

      else
      {
        s = e + (signed long int)1;
        return_value_strtol_9=strtol(s, &e, 10);
        m1 = (signed int)return_value_strtol_9;
        if(m1 >= 60 || !(m1 >= 0))
          error = s;

        else
        {
          _Bool tmp_if_expr_11;
          if(!((signed int)*e == 45))
            tmp_if_expr_11 = (_Bool)1;

          else
          {
            return_value___ctype_b_loc_10=__ctype_b_loc();
            tmp_if_expr_11 = !(((signed int)(*return_value___ctype_b_loc_10)[(signed long int)(signed int)e[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_11)
            error = e;

          else
          {
            s = e + (signed long int)1;
            return_value_strtol_12=strtol(s, &e, 10);
            h2 = (signed int)return_value_strtol_12;
            if(h2 >= 25 || !(h2 >= 0))
              error = s;

            else
            {
              _Bool tmp_if_expr_14;
              if(!((signed int)*e == 58))
                tmp_if_expr_14 = (_Bool)1;

              else
              {
                return_value___ctype_b_loc_13=__ctype_b_loc();
                tmp_if_expr_14 = !(((signed int)(*return_value___ctype_b_loc_13)[(signed long int)(signed int)e[(signed long int)1]] & (signed int)(unsigned short int)2048) != 0) ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_14)
                error = e;

              else
              {
                s = e + (signed long int)1;
                return_value_strtol_15=strtol(s, &e, 10);
                m2 = (signed int)return_value_strtol_15;
                if(m2 >= 60 || !(m2 >= 0))
                  error = s;

                else
                {
                  tmd->start_time = (unsigned int)(h1 * 60 + m1);
                  tmd->end_time = (unsigned int)(h2 * 60 + m2);
                  if(tmd->end_time >= tmd->start_time)
                  {
                    if(CI_DEBUG_LEVEL >= 5)
                    {
                      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                        __log_error((void *)0, "Acl time, adding days: %x,  start time %d, end time: %d!\n", tmd->days, tmd->start_time, tmd->end_time);

                      if(!(CI_DEBUG_STDOUT == 0))
                        printf("Acl time, adding days: %x,  start time %d, end time: %d!\n", tmd->days, tmd->start_time, tmd->end_time);

                    }

                    return (void *)tmd;
                  }

                  if(CI_DEBUG_LEVEL >= 1)
                  {
                    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                      __log_error((void *)0, "Acl '%s': end time is smaller than the start time!\n", str);

                    if(!(CI_DEBUG_STDOUT == 0))
                      printf("Acl '%s': end time is smaller than the start time!\n", str);

                  }

                  error = str;
                }
              }
            }
          }
        }
      }
    }
  }

acl_time_dup_fail:
  ;
  if(CI_DEBUG_LEVEL >= 1)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Failed to parse acl time: %s (error on pos '...%s')\n", str, error);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Failed to parse acl time: %s (error on pos '...%s')\n", str, error);

  }

  allocator->free(allocator, (void *)tmd);
  return (void *)0;
}

// acl_time_equal
// file acl.c line 373
signed int acl_time_equal(const void *key1, const void *key2)
{
  struct acl_time_data *tmd_acl = (struct acl_time_data *)key1;
  struct acl_time_data *tmd_request = (struct acl_time_data *)key2;
  if(CI_DEBUG_LEVEL >= 9)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "acl_time_equal(key1=%p, key2=%p)\n", key1, key2);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("acl_time_equal(key1=%p, key2=%p)\n", key1, key2);

  }

  signed int matches;
  _Bool tmp_if_expr_1;
  if(!((tmd_acl->days & tmd_request->days) == 0u))
    tmp_if_expr_1 = tmd_request->start_time >= tmd_acl->start_time ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = tmd_request->start_time <= tmd_acl->end_time ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  matches = (signed int)tmp_if_expr_2;
  if(CI_DEBUG_LEVEL >= 8)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "acl_time_equal: %x/%d-%d <> %x/%d-%d -> %d\n", tmd_acl->days, tmd_acl->start_time, tmd_acl->end_time, tmd_request->days, tmd_request->start_time, tmd_request->end_time, matches);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("acl_time_equal: %x/%d-%d <> %x/%d-%d -> %d\n", tmd_acl->days, tmd_acl->start_time, tmd_acl->end_time, tmd_request->days, tmd_request->start_time, tmd_request->end_time, matches);

  }

  return matches;
}

// acl_time_free
// file acl.c line 389
void acl_time_free(void *tmd, struct ci_mem_allocator *allocator)
{
  allocator->free(allocator, (void *)tmd);
}

// add_mutex
// file os/unix/threads.c line 66
static struct mutex_itm * add_mutex(void *pmutex, signed int type)
{
  struct mutex_itm *m;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct mutex_itm) /*24ul*/ );
  m = (struct mutex_itm *)return_value_malloc_1;
  if(m == ((struct mutex_itm *)NULL))
    return (struct mutex_itm *)(void *)0;

  else
  {
    switch(type)
    {
      case 0:
      {
        m->mtx.mutex = (union anonymous_4 *)pmutex;
        break;
      }
      case 1:
      {
        m->mtx.rwlock = (union anonymous_37 *)pmutex;
        break;
      }
      default:
      {
        free((void *)m);
        return (struct mutex_itm *)(void *)0;
      }
    }
    m->type = type;
    m->next = (struct mutex_itm *)(void *)0;
    pthread_mutex_lock(&mutexes_lock);
    if(mutexes == ((struct mutex_itm *)NULL))
    {
      mutexes = m;
      last = m;
    }

    else
    {
      last->next = m;
      last = last->next;
    }
    if(init_child_mutexes_scheduled == 0)
    {
      pthread_atfork((void (*)(void))(void *)0, (void (*)(void))(void *)0, (void (*)(void))init_child_mutexes);
      init_child_mutexes_scheduled = 1;
    }

    pthread_mutex_unlock(&mutexes_lock);
    return m;
  }
}

// alloc_a_buffer
// file decode.c line 198
static void * alloc_a_buffer(void *op, unsigned int items, unsigned int size)
{
  void *return_value_ci_buffer_alloc_1;
  return_value_ci_buffer_alloc_1=ci_buffer_alloc((signed int)(items * size));
  return return_value_ci_buffer_alloc_1;
}

// alloc_mem_allocator_struct
// file mem.c line 79
static struct ci_mem_allocator * alloc_mem_allocator_struct()
{
  struct ci_mem_allocator *alc;
  if(!(MEM_ALLOCATOR_POOL >= 0))
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct ci_mem_allocator) /*56ul*/ );
    alc = (struct ci_mem_allocator *)return_value_malloc_1;
    alc->must_free = 1;
  }

  else
  {
    void *return_value_ci_object_pool_alloc_2;
    return_value_ci_object_pool_alloc_2=ci_object_pool_alloc(MEM_ALLOCATOR_POOL);
    alc = (struct ci_mem_allocator *)return_value_ci_object_pool_alloc_2;
    alc->must_free = 2;
  }
  return alc;
}

// alloc_text_table_entry
// file lookup_file_table.c line 55
struct text_table_entry * alloc_text_table_entry(signed int val_num, struct ci_mem_allocator *allocator)
{
  struct text_table_entry *e;
  signed int i;
  void *return_value;
  return_value=allocator->alloc(allocator, sizeof(struct text_table_entry) /*24ul*/ );
  e = (struct text_table_entry *)return_value;
  e->key = (void *)0;
  e->next = (struct text_table_entry *)(void *)0;
  if(e == ((struct text_table_entry *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error allocating memory for table entry \n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error allocating memory for table entry \n");

    }

    return (struct text_table_entry *)(void *)0;
  }

  else
  {
    if(val_num >= 1)
    {
      void *return_value_1;
      return_value_1=allocator->alloc(allocator, (unsigned long int)(val_num + 1) * sizeof(void *) /*8ul*/ );
      e->vals = (void **)return_value_1;
      if(e->vals == ((void **)NULL))
      {
        allocator->free(allocator, (void *)e);
        e = (struct text_table_entry *)(void *)0;
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Error allocating memory for values of  table entry.\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Error allocating memory for values of  table entry.\n");

        }

        return (struct text_table_entry *)(void *)0;
      }

      i = 0;
      if(!(i >= 1 + val_num))
      {
        e->vals[(signed long int)i] = (void *)0;
        i = i + 1;
      }

    }

    else
      e->vals = (void **)(void *)0;
    return e;
  }
}

// byteReverse
// file md5.c line 28
static void byteReverse(unsigned char *buf, unsigned int longs)
{
  unsigned int t;
  do
  {
    t = (unsigned int)((unsigned int)buf[(signed long int)3] << 8 | (unsigned int)buf[(signed long int)2]) << 16 | (unsigned int)buf[(signed long int)1] << 8 | (unsigned int)buf[(signed long int)0];
    *((unsigned int *)buf) = t;
    buf = buf + (signed long int)4;
    longs = longs - 1u;
  }
  while(!(longs == 0u));
}

// cfg_set_type
// file c-icap-mkbdb.c line 285
signed int cfg_set_type(const char *directive, const char **argv, void *setdata)
{
  const struct ci_type_ops *ops = &ci_str_ops;
  signed int return_value_strcmp_2;
  signed int return_value_strcmp_1;
  signed int return_value_strcmp_4;
  if(*argv == ((const char *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "error not argument for %s argument\n", argv[(signed long int)0]);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("error not argument for %s argument\n", argv[(signed long int)0]);

    }

    return 0;
  }

  else
  {
    signed int return_value_strcmp_3;
    return_value_strcmp_3=strcmp(argv[(signed long int)0], "string");
    if(return_value_strcmp_3 == 0)
      ops = &ci_str_ops;

    else
    {
      return_value_strcmp_2=strcmp(argv[(signed long int)0], "int");
      if(return_value_strcmp_2 == 0)
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "%s: not implemented type %s\n", directive, argv[(signed long int)0]);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("%s: not implemented type %s\n", directive, argv[(signed long int)0]);

        }

        return 0;
      }

      else
      {
        return_value_strcmp_1=strcmp(argv[(signed long int)0], "ip");
        if(return_value_strcmp_1 == 0)
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "%s: not implemented type %s\n", directive, argv[(signed long int)0]);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("%s: not implemented type %s\n", directive, argv[(signed long int)0]);

          }

          return 0;
        }

      }
    }
    signed int return_value_strcmp_5;
    return_value_strcmp_5=strcmp(directive, "-t");
    if(return_value_strcmp_5 == 0)
      key_ops = ops;

    else
    {
      return_value_strcmp_4=strcmp(directive, "-v");
      if(return_value_strcmp_4 == 0)
        val_ops = ops;

    }
    return 1;
  }
}

// check_ascii
// file filetype.c line 419
signed int check_ascii(unsigned char *buf, signed int buflen)
{
  unsigned int i;
  unsigned int res = (unsigned int)0;
  unsigned int type;
  i = (unsigned int)0;
  for( ; !(i >= (unsigned int)buflen); i = i + 1u)
  {
    type = (unsigned int)text_chars[(signed long int)buf[(signed long int)i]];
    if(type == 0u)
      return -1;

    res = res | type;
  }
  if(!(res >= 2u))
    return 0;

  else
    if(!(res >= 4u))
      return 1;

    else
      return 2;
}

// check_directive
// file txt_format.c line 200
signed int check_directive(const char *var, const char *directive, signed int *directive_len)
{
  const char *s1;
  const char *s2;
  s1 = var;
  s2 = directive + (signed long int)1;
  *directive_len = 0;
  for( ; !(*s2 == 0); s2 = s2 + 1l)
  {
    if(s1 == ((const char *)NULL))
      return 0;

    if(!(*s1 == *s2))
      return 0;

    s1 = s1 + 1l;
  }
  *directive_len = (signed int)(s1 - var);
  return 1;
}

// check_magics
// file filetype.c line 368
signed int check_magics(struct ci_magics_db *db, const char *buf, signed int buflen)
{
  signed int i = 0;
  for( ; !(i >= db->magics_num); i = i + 1)
    if((unsigned long int)buflen >= (db->magics + (signed long int)i)->len + (unsigned long int)(db->magics + (signed long int)i)->offset)
    {
      signed int return_value_memcmp_1;
      return_value_memcmp_1=memcmp((const void *)(buf + (signed long int)(db->magics + (signed long int)i)->offset), (const void *)(db->magics + (signed long int)i)->magic, (db->magics + (signed long int)i)->len);
      if(return_value_memcmp_1 == 0)
        return (signed int)(db->magics + (signed long int)i)->type;

    }

  return -1;
}

// check_realloc
// file request_common.c line 874
static signed int check_realloc(char **buf, signed int *size, signed int used, signed int mustadded)
{
  char *newbuf;
  signed int len;
  while(!(*size + -used >= mustadded))
  {
    len = *size + 4096;
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)*buf, (unsigned long int)len);
    newbuf = (char *)return_value_realloc_1;
    if(newbuf == ((char *)NULL))
      return 11;

    *buf = newbuf;
    *size = *size + 4096;
  }
  return 1;
}

// check_reg
// file registry.c line 108
static signed int check_reg(void *data, const char *name, const void *val)
{
  struct check_reg_data *rdata = (struct check_reg_data *)data;
  rdata->count = rdata->count + 1;
  signed int return_value_strcmp_1;
  return_value_strcmp_1=strcmp(rdata->name, name);
  if(return_value_strcmp_1 == 0)
  {
    rdata->found = 1;
    return 1;
  }

  else
    return 0;
}

// check_tables
// file txt_format.c line 218
struct ci_fmt_entry * check_tables(const char *var, struct ci_fmt_entry *u_table, signed int *directive_len, unsigned int *width, signed int *left_align, char *parameter)
{
  signed int i;
  unsigned int params_len;
  params_len=parse_directive(var, width, left_align, parameter);
  i = 0;
  for( ; !(GlobalTable[(signed long int)i].directive == ((const char *)NULL)); i = i + 1)
  {
    signed int return_value_check_directive_1;
    return_value_check_directive_1=check_directive(var + (signed long int)params_len, GlobalTable[(signed long int)i].directive, directive_len);
    if(!(return_value_check_directive_1 == 0))
    {
      *directive_len = *directive_len + (signed int)params_len;
      return &GlobalTable[(signed long int)i];
    }

  }
  if(!(u_table == ((struct ci_fmt_entry *)NULL)))
  {
    i = 0;
    for( ; !((u_table + (signed long int)i)->directive == ((const char *)NULL)); i = i + 1)
    {
      signed int return_value_check_directive_2;
      return_value_check_directive_2=check_directive(var + (signed long int)params_len, (u_table + (signed long int)i)->directive, directive_len);
      if(!(return_value_check_directive_2 == 0))
      {
        *directive_len = *directive_len + (signed int)params_len;
        return &u_table[(signed long int)i];
      }

    }
  }

  return (struct ci_fmt_entry *)(void *)0;
}

// check_unicode
// file filetype.c line 495
signed int check_unicode(unsigned char *buf, signed int buflen)
{
  signed int i;
  signed int ret = 0;
  signed int endian = 0;
  i = 0;
  for( ; !(i >= buflen); i = i + ret)
  {
    ret=isUTF8(buf + (signed long int)i, buflen - i);
    if(!(ret >= 1))
      break;

  }
  if(i == 0 && !(ret >= 0))
    ret = 0;

  if(!(ret == 0))
    return 3;

  else
    if(!(buflen >= 2))
      return -1;

    else
    {
      _Bool tmp_if_expr_2;
      if((signed int)*buf == 0xff)
        tmp_if_expr_2 = (signed int)buf[(signed long int)1] == 0xfe ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        endian = 0;

      else
      {
        _Bool tmp_if_expr_1;
        if((signed int)*buf == 0xfe)
          tmp_if_expr_1 = (signed int)buf[(signed long int)1] == 0xff ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        if(tmp_if_expr_1)
          endian = 1;

        else
          return -1;
      }
      i = 2;
      for( ; !(i >= buflen); i = i + 2)
        if(!(endian == 0))
        {
          if((signed int)buf[(signed long int)i] == 0)
          {
            if(!((signed int)buf[(signed long int)(1 + i)] >= 128))
            {
              if(!((signed int)text_chars[(signed long int)buf[(signed long int)(1 + i)]] == 1))
                return -1;

            }

          }

        }

        else
          if((signed int)buf[(signed long int)(1 + i)] == 0)
          {
            if(!((signed int)buf[(signed long int)i] >= 128))
            {
              if(!((signed int)text_chars[(signed long int)buf[(signed long int)i]] == 1))
                return -1;

            }

          }

      return 3;
    }
}

// ci_MD5Final
// file md5.c line 107
void ci_MD5Final(unsigned char *digest, struct ci_MD5Context *ctx)
{
  unsigned int count;
  unsigned char *p;
  unsigned int *uin;
  count = ctx->bits[(signed long int)0] >> 3 & (unsigned int)0x3F;
  p = ctx->in + (signed long int)count;
  unsigned char *tmp_post_1 = p;
  p = p + 1l;
  *tmp_post_1 = (unsigned char)0x80;
  count = (unsigned int)(64 - 1) - count;
  if(!(count >= 8u))
  {
    memset((void *)p, 0, (unsigned long int)count);
    byteReverse(ctx->in, (unsigned int)16);
    MD5Transform(ctx->buf, (unsigned int *)ctx->in);
    memset((void *)ctx->in, 0, (unsigned long int)56);
  }

  else
    memset((void *)p, 0, (unsigned long int)(count - (unsigned int)8));
  byteReverse(ctx->in, (unsigned int)14);
  uin = (unsigned int *)ctx->in;
  uin[(signed long int)14] = ctx->bits[(signed long int)0];
  uin[(signed long int)15] = ctx->bits[(signed long int)1];
  MD5Transform(ctx->buf, (unsigned int *)ctx->in);
  byteReverse((unsigned char *)ctx->buf, (unsigned int)4);
  memcpy((void *)digest, (const void *)ctx->buf, (unsigned long int)16);
  memset((void *)ctx, 0, sizeof(struct ci_MD5Context) /*88ul*/ );
}

// ci_MD5Init
// file md5.c line 44
void ci_MD5Init(struct ci_MD5Context *ctx)
{
  ctx->buf[(signed long int)0] = (unsigned int)0x67452301;
  ctx->buf[(signed long int)1] = 0xefcdab89;
  ctx->buf[(signed long int)2] = 0x98badcfe;
  ctx->buf[(signed long int)3] = (unsigned int)0x10325476;
  ctx->bits[(signed long int)0] = (unsigned int)0;
  ctx->bits[(signed long int)1] = (unsigned int)0;
}

// ci_MD5Update
// file md5.c line 59
void ci_MD5Update(struct ci_MD5Context *ctx, const unsigned char *buf, unsigned long int len)
{
  unsigned int t = ctx->bits[(signed long int)0];
  ctx->bits[(signed long int)0] = t + ((unsigned int)len << 3);
  if(!(ctx->bits[0l] >= t))
    ctx->bits[(signed long int)1] = ctx->bits[(signed long int)1] + 1u;

  ctx->bits[(signed long int)1] = ctx->bits[(signed long int)1] + (unsigned int)(len >> 29);
  t = t >> 3 & (unsigned int)0x3f;
  if(!(t == 0u))
  {
    unsigned char *p = (unsigned char *)ctx->in + (signed long int)t;
    t = (unsigned int)64 - t;
    if(!(len >= (unsigned long int)t))
    {
      memcpy((void *)p, (const void *)buf, len);
      goto __CPROVER_DUMP_L5;
    }

    memcpy((void *)p, (const void *)buf, (unsigned long int)t);
    byteReverse(ctx->in, (unsigned int)16);
    MD5Transform(ctx->buf, (unsigned int *)ctx->in);
    buf = buf + (signed long int)t;
    len = len - (unsigned long int)t;
  }

  for( ; len >= 64ul; len = len - (unsigned long int)64)
  {
    memcpy((void *)ctx->in, (const void *)buf, (unsigned long int)64);
    byteReverse(ctx->in, (unsigned int)16);
    MD5Transform(ctx->buf, (unsigned int *)ctx->in);
    buf = buf + (signed long int)64;
  }
  memcpy((void *)ctx->in, (const void *)buf, len);

__CPROVER_DUMP_L5:
  ;
}

// ci_access_entry_add_acl
// file acl.c line 468
const struct ci_acl_spec * ci_access_entry_add_acl(struct ci_access_entry *access_entry, const struct ci_acl_spec *acl, signed int negate)
{
  struct ci_specs_list *spec_list;
  struct ci_specs_list *spec_entry;
  if(access_entry == ((struct ci_access_entry *)NULL))
    return (const struct ci_acl_spec *)(void *)0;

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct ci_specs_list) /*24ul*/ );
    spec_entry = (struct ci_specs_list *)return_value_malloc_1;
    if(spec_entry == ((struct ci_specs_list *)NULL))
      return (const struct ci_acl_spec *)(void *)0;

    else
    {
      spec_entry->next = (struct ci_specs_list *)(void *)0;
      spec_entry->negate = negate;
      spec_entry->spec = acl;
      if(access_entry->spec_list == ((struct ci_specs_list *)NULL))
        access_entry->spec_list = spec_entry;

      else
      {
        spec_list = access_entry->spec_list;
        for( ; !(spec_list->next == ((struct ci_specs_list *)NULL)); spec_list = spec_list->next)
          ;
        spec_list->next = spec_entry;
      }
      return acl;
    }
  }
}

// ci_access_entry_add_acl_by_name
// file acl.c line 492
signed int ci_access_entry_add_acl_by_name(struct ci_access_entry *access_entry, const char *acl_name)
{
  const struct ci_acl_spec *acl;
  signed int negate = 0;
  if((signed int)*acl_name == 33)
  {
    negate = 1;
    acl_name = acl_name + (signed long int)1;
  }

  acl=ci_acl_search(acl_name);
  if(acl == ((const struct ci_acl_spec *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "The acl spec %s does not exists!\n", acl_name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("The acl spec %s does not exists!\n", acl_name);

    }

    return 0;
  }

  else
  {
    const struct ci_acl_spec *return_value_ci_access_entry_add_acl_1;
    return_value_ci_access_entry_add_acl_1=ci_access_entry_add_acl(access_entry, acl, negate);
    if(return_value_ci_access_entry_add_acl_1 == ((const struct ci_acl_spec *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error adding acl spec %s to the access list!\n", acl_name);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error adding acl spec %s to the access list!\n", acl_name);

      }

      return 0;
    }

    else
      return 1;
  }
}

// ci_access_entry_match_request
// file acl.c line 751
signed int ci_access_entry_match_request(struct ci_access_entry *access_entry, struct ci_request *req)
{
  struct ci_specs_list *spec_list;
  signed int return_value_request_match_specslist_1;
  if(access_entry == ((struct ci_access_entry *)NULL))
    return 1;

  else
  {
    while(!(access_entry == ((struct ci_access_entry *)NULL)))
    {
      if(CI_DEBUG_LEVEL >= 9)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Check request with an access entry\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Check request with an access entry\n");

      }

      spec_list = access_entry->spec_list;
      if(!(spec_list == ((struct ci_specs_list *)NULL)))
      {
        if(!(spec_list->spec == ((const struct ci_acl_spec *)NULL)))
        {
          return_value_request_match_specslist_1=request_match_specslist(req, spec_list);
          if(!(return_value_request_match_specslist_1 == 0))
            return access_entry->type;

        }

      }

      access_entry = access_entry->next;
    }
    return 0;
  }
}

// ci_access_entry_new
// file acl.c line 419
struct ci_access_entry * ci_access_entry_new(struct ci_access_entry **list, signed int type)
{
  struct ci_access_entry *access_entry;
  struct ci_access_entry *cur;
  if(list == ((struct ci_access_entry **)NULL))
    return (struct ci_access_entry *)(void *)0;

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct ci_access_entry) /*24ul*/ );
    access_entry = (struct ci_access_entry *)return_value_malloc_1;
    if(access_entry == ((struct ci_access_entry *)NULL))
      return (struct ci_access_entry *)(void *)0;

    else
    {
      access_entry->type = type;
      access_entry->spec_list = (struct ci_specs_list *)(void *)0;
      access_entry->next = (struct ci_access_entry *)(void *)0;
      if(*list == ((struct ci_access_entry *)NULL))
        *list = access_entry;

      else
      {
        cur = *list;
        for( ; !(cur->next == ((struct ci_access_entry *)NULL)); cur = cur->next)
          ;
        cur->next = access_entry;
      }
      return access_entry;
    }
  }
}

// ci_access_entry_release
// file acl.c line 445
void ci_access_entry_release(struct ci_access_entry *list)
{
  struct ci_access_entry *access_entry;
  struct ci_specs_list *spec_list;
  struct ci_specs_list *cur;
  if(!(list == ((struct ci_access_entry *)NULL)))
  {
    access_entry = list;
    while(!(list == ((struct ci_access_entry *)NULL)))
    {
      access_entry = list;
      list = list->next;
      spec_list = access_entry->spec_list;
      while(!(spec_list == ((struct ci_specs_list *)NULL)))
      {
        cur = spec_list;
        spec_list = spec_list->next;
        free((void *)cur);
      }
      free((void *)access_entry);
    }
  }

}

// ci_acl_add_data
// file acl.c line 824
signed int ci_acl_add_data(const char *name, const char *type, const char *data)
{
  struct ci_acl_spec *spec;
  const struct ci_acl_type *spec_type;
  char *s;
  char *param = (char *)(void *)0;
  char *acl_type;
  acl_type=strdup(type);
  if(acl_type == ((char *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "cfg_acl_add: error strduping!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("cfg_acl_add: error strduping!\n");

    }

    return 0;
  }

  else
  {
    s = acl_type;
    s=strchr(s, 123);
    if(!(s == ((char *)NULL)))
    {
      *s = (char)0;
      param = s + (signed long int)1;
      s=strchr(param, 125);
      if(!(s == ((char *)NULL)))
        *s = (char)0;

    }

    spec=ci_acl_spec_search(specs_list, name);
    if(!(spec == ((struct ci_acl_spec *)NULL)))
    {
      spec_type=ci_acl_type_search(acl_type);
      if(!(spec_type == spec->type))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "The acl type:%s does not match with type of existing acl \"%s\"", acl_type, name);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("The acl type:%s does not match with type of existing acl \"%s\"", acl_type, name);

        }

        free((void *)acl_type);
        return 0;
      }

    }

    else
      spec=ci_acl_spec_new(name, acl_type, param, &types_list, &specs_list);
    free((void *)acl_type);
    if(spec == ((struct ci_acl_spec *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error in acl:%s! Maybe the acl type \"%s\" does not exists!\n", name, acl_type);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error in acl:%s! Maybe the acl type \"%s\" does not exists!\n", name, acl_type);

      }

      return 0;
    }

    else
    {
      ci_acl_spec_new_data(spec, data);
      return 1;
    }
  }
}

// ci_acl_init
// file acl.c line 796
void ci_acl_init()
{
  ci_acl_typelist_init(&types_list);
  acl_load_defaults();
  specs_list = (struct ci_acl_spec *)(void *)0;
}

// ci_acl_reset
// file acl.c line 803
void ci_acl_reset()
{
  ci_acl_spec_list_release(specs_list);
  specs_list = (struct ci_acl_spec *)(void *)0;
  ci_acl_typelist_reset(&types_list);
  acl_load_defaults();
}

// ci_acl_search
// file acl.c line 811
const struct ci_acl_spec * ci_acl_search(const char *name)
{
  struct ci_acl_spec *return_value_ci_acl_spec_search_1;
  return_value_ci_acl_spec_search_1=ci_acl_spec_search(specs_list, name);
  return (const struct ci_acl_spec *)return_value_ci_acl_spec_search_1;
}

// ci_acl_spec_list_release
// file acl.c line 615
void ci_acl_spec_list_release(struct ci_acl_spec *spec)
{
  struct ci_acl_spec *cur;
  while(!(spec == ((struct ci_acl_spec *)NULL)))
  {
    cur = spec;
    spec = spec->next;
    ci_acl_spec_release(cur);
  }
}

// ci_acl_spec_new
// file acl.c line 514
struct ci_acl_spec * ci_acl_spec_new(const char *name, const char *type, const char *param, struct ci_acl_type_list *list, struct ci_acl_spec **spec_list)
{
  struct ci_acl_spec *spec;
  struct ci_acl_spec *cur;
  const struct ci_acl_type *acl_type;
  acl_type=ci_acl_typelist_search(list, type);
  if(acl_type == ((const struct ci_acl_type *)NULL))
    return (struct ci_acl_spec *)(void *)0;

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct ci_acl_spec) /*64ul*/ );
    spec = (struct ci_acl_spec *)return_value_malloc_1;
    if(spec == ((struct ci_acl_spec *)NULL))
      return (struct ci_acl_spec *)(void *)0;

    else
    {
      strncpy(spec->name, name, (unsigned long int)31);
      spec->name[(signed long int)31] = (char)0;
      if(!(param == ((const char *)NULL)))
      {
        spec->parameter=strdup(param);
        if(spec->parameter == ((char *)NULL))
        {
          free((void *)spec);
          return (struct ci_acl_spec *)(void *)0;
        }

      }

      else
        spec->parameter = (char *)(void *)0;
      spec->type = acl_type;
      spec->data = (struct ci_acl_data *)(void *)0;
      spec->next = (struct ci_acl_spec *)(void *)0;
      if(!(spec_list == ((struct ci_acl_spec **)NULL)))
      {
        if(!(*spec_list == ((struct ci_acl_spec *)NULL)))
        {
          cur = *spec_list;
          for( ; !(cur->next == ((struct ci_acl_spec *)NULL)); cur = cur->next)
            ;
          cur->next = spec;
        }

        else
          *spec_list = spec;
      }

      return spec;
    }
  }
}

// ci_acl_spec_new_data
// file acl.c line 552
struct ci_acl_data * ci_acl_spec_new_data(struct ci_acl_spec *spec, const char *val)
{
  struct ci_acl_data *new_data;
  struct ci_acl_data *list;
  const struct ci_type_ops *ops;
  void *data;
  if(spec == ((struct ci_acl_spec *)NULL))
    return (struct ci_acl_data *)(void *)0;

  else
  {
    ops = spec->type->type;
    data=ops->dup(val, default_allocator);
    if(data == NULL)
      return (struct ci_acl_data *)(void *)0;

    else
    {
      void *return_value_malloc_1;
      return_value_malloc_1=malloc(sizeof(struct ci_acl_data) /*16ul*/ );
      new_data = (struct ci_acl_data *)return_value_malloc_1;
      if(new_data == ((struct ci_acl_data *)NULL))
      {
        ops->free(data, default_allocator);
        return (struct ci_acl_data *)(void *)0;
      }

      else
      {
        new_data->data = data;
        new_data->next = (struct ci_acl_data *)(void *)0;
        list = spec->data;
        if(!(list == ((struct ci_acl_data *)NULL)))
        {
          if(!(list->next == ((struct ci_acl_data *)NULL)))
            list = list->next;

          list->next = new_data;
        }

        else
          spec->data = new_data;
        return new_data;
      }
    }
  }
}

// ci_acl_spec_release
// file acl.c line 601
void ci_acl_spec_release(struct ci_acl_spec *cur)
{
  struct ci_acl_data *dhead;
  struct ci_acl_data *dtmp;
  const struct ci_type_ops *ops;
  dhead = cur->data;
  ops = cur->type->type;
  if(!(dhead == ((struct ci_acl_data *)NULL)))
  {
    dtmp = dhead;
    dhead = dhead->next;
    ops->free(dtmp->data, default_allocator);
    free((void *)dtmp);
  }

}

// ci_acl_spec_search
// file acl.c line 583
struct ci_acl_spec * ci_acl_spec_search(struct ci_acl_spec *list, const char *name)
{
  struct ci_acl_spec *spec;
  if(CI_DEBUG_LEVEL >= 9)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "In search specs list %p,name %s\n", list, name);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("In search specs list %p,name %s\n", list, name);

  }

  if(name == ((const char *)NULL) || list == ((struct ci_acl_spec *)NULL))
    return (struct ci_acl_spec *)(void *)0;

  else
  {
    spec = list;
    while(!(spec == ((struct ci_acl_spec *)NULL)))
    {
      if(CI_DEBUG_LEVEL >= 9)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Checking name:%s with specname %s\n", name, (const void *)spec->name);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Checking name:%s with specname %s\n", name, (const void *)spec->name);

      }

      signed int return_value_strcmp_1;
      return_value_strcmp_1=strcmp(spec->name, name);
      if(return_value_strcmp_1 == 0)
        return spec;

      spec = spec->next;
    }
    return (struct ci_acl_spec *)(void *)0;
  }
}

// ci_acl_type_add
// file acl.c line 819
signed int ci_acl_type_add(const struct ci_acl_type *type)
{
  signed int return_value_ci_acl_typelist_add_1;
  return_value_ci_acl_typelist_add_1=ci_acl_typelist_add(&types_list, type);
  return return_value_ci_acl_typelist_add_1;
}

// ci_acl_type_search
// file acl.c line 815
const struct ci_acl_type * ci_acl_type_search(const char *name)
{
  const struct ci_acl_type *return_value_ci_acl_typelist_search_1;
  return_value_ci_acl_typelist_search_1=ci_acl_typelist_search(&types_list, name);
  return return_value_ci_acl_typelist_search_1;
}

// ci_acl_typelist_add
// file acl.c line 638
signed int ci_acl_typelist_add(struct ci_acl_type_list *list, const struct ci_acl_type *type)
{
  struct ci_acl_type *cur;
  struct ci_acl_type *nl = (struct ci_acl_type *)(void *)0;
  {
    const struct ci_acl_type *return_value_ci_acl_typelist_search_1;
    return_value_ci_acl_typelist_search_1=ci_acl_typelist_search(list, type->name);
    if(!(return_value_ci_acl_typelist_search_1 == ((const struct ci_acl_type *)NULL)))
    {
      if(CI_DEBUG_LEVEL >= 3)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "The acl type %s already defined\n", (const void *)type->name);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("The acl type %s already defined\n", (const void *)type->name);

      }

      return 0;
    }

    else
    {
      if(list->acl_type_list_num == list->acl_type_list_size)
      {
        list->acl_type_list_size = list->acl_type_list_size + 32;
        void *return_value_realloc_2;
        return_value_realloc_2=realloc((void *)list->acl_type_list, (unsigned long int)list->acl_type_list_size * sizeof(struct ci_acl_type) /*56ul*/ );
        nl = (struct ci_acl_type *)return_value_realloc_2;
        if(nl == ((struct ci_acl_type *)NULL))
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Failed to allocate more space for new ci_acl_typr_t\n");

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Failed to allocate more space for new ci_acl_typr_t\n");

          }

          return 0;
        }

        list->acl_type_list = nl;
      }

      cur = &list->acl_type_list[(signed long int)list->acl_type_list_num];
      strncpy(cur->name, type->name, (unsigned long int)31);
      cur->name[(signed long int)31] = (char)0;
      cur->type = type->type;
      cur->get_test_data = type->get_test_data;
      list->acl_type_list_num = list->acl_type_list_num + 1;
      return 1;
    }
  }
}

// ci_acl_typelist_init
// file acl.c line 630
signed int ci_acl_typelist_init(struct ci_acl_type_list *list)
{
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)32 * sizeof(struct ci_acl_type) /*56ul*/ );
  list->acl_type_list = (struct ci_acl_type *)return_value_malloc_1;
  list->acl_type_list_size = 32;
  list->acl_type_list_num = 0;
  return 1;
}

// ci_acl_typelist_release
// file acl.c line 681
signed int ci_acl_typelist_release(struct ci_acl_type_list *list)
{
  free((void *)list->acl_type_list);
  list->acl_type_list_size = 0;
  list->acl_type_list_num = 0;
  return 1;
}

// ci_acl_typelist_reset
// file acl.c line 689
signed int ci_acl_typelist_reset(struct ci_acl_type_list *list)
{
  list->acl_type_list_num = 0;
  return 1;
}

// ci_acl_typelist_search
// file acl.c line 671
const struct ci_acl_type * ci_acl_typelist_search(struct ci_acl_type_list *list, const char *name)
{
  signed int i = 0;
  for( ; !(i >= list->acl_type_list_num); i = i + 1)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp((list->acl_type_list + (signed long int)i)->name, name);
    if(return_value_strcmp_1 == 0)
      return (const struct ci_acl_type *)&list->acl_type_list[(signed long int)i];

  }
  return (const struct ci_acl_type *)(void *)0;
}

// ci_args_apply
// file ../include/cfg_param.h line 200
signed int ci_args_apply(signed int argc, char **argv, struct ci_options_entry *options)
{
  signed int i;
  struct ci_options_entry *entry;
  const char *act_args[2l];
  act_args[(signed long int)1] = (const char *)(void *)0;
  i = 1;
  if(!(i >= argc))
  {
    entry=search_options_table(argv[(signed long int)i], options);
    if(entry == ((struct ci_options_entry *)NULL))
      return 0;

    if(!(entry->parameter == ((const char *)NULL)))
    {
      i = i + 1;
      if(i >= argc)
        return 0;

      act_args[(signed long int)0] = argv[(signed long int)i];
      entry->action(entry->name, act_args, entry->data);
    }

    else
    {
      signed int return_value_strcmp_1;
      return_value_strcmp_1=strcmp(entry->name, "__");
      if(return_value_strcmp_1 == 0)
      {
        act_args[(signed long int)0] = argv[(signed long int)i];
        entry->action(entry->name, act_args, entry->data);
      }

      else
        entry->action(entry->name, (const char **)(void *)0, entry->data);
    }
    i = i + 1;
  }

  return 1;
}

// ci_args_usage
// file ../include/cfg_param.h line 199
void ci_args_usage(const char *progname, struct ci_options_entry *options)
{
  signed int i;
  printf("Usage : \n");
  printf("%s", progname);
  i = 0;
  for( ; !((options + (signed long int)i)->name == ((const char *)NULL)); i = i + 1)
    if((signed int)*(options + (signed long int)i)->name == 36)
      printf(" [file1] [file2] ...");

    else
    {
      char *tmp_if_expr_1;
      if((options + (signed long int)i)->parameter == ((const char *)NULL))
        tmp_if_expr_1 = "";

      else
        tmp_if_expr_1 = (options + (signed long int)i)->parameter;
      printf(" [%s %s]", (options + (signed long int)i)->name, tmp_if_expr_1);
    }
  printf("\n\n");
  i = 0;
  for( ; !((options + (signed long int)i)->name == ((const char *)NULL)); i = i + 1)
    if((signed int)*(options + (signed long int)i)->name == 36)
      printf(" [file1] [file2] ...\t: %s\n", (options + (signed long int)i)->msg);

    else
    {
      char *tmp_if_expr_2;
      if((options + (signed long int)i)->parameter == ((const char *)NULL))
        tmp_if_expr_2 = "\t";

      else
        tmp_if_expr_2 = (options + (signed long int)i)->parameter;
      printf("%s %s\t\t: %s\n", (options + (signed long int)i)->name, tmp_if_expr_2, (options + (signed long int)i)->msg);
    }
}

// ci_array_add
// file include/array.h line 118
const struct ci_array_item * ci_array_add(struct ci_array *array, const char *name, const void *value, unsigned long int size)
{
  struct ci_array_item *item;
  struct ci_mem_allocator *packer = array->alloc;
  /* assertion packer */
  assert(packer != ((struct ci_mem_allocator *)NULL));
  void *return_value_ci_pack_allocator_alloc_unaligned_1;
  return_value_ci_pack_allocator_alloc_unaligned_1=ci_pack_allocator_alloc_unaligned(packer, (unsigned long int)&((struct ci_array_item *)0)[(signed long int)1]);
  item = (struct ci_array_item *)return_value_ci_pack_allocator_alloc_unaligned_1;
  if(!(item == ((struct ci_array_item *)NULL)))
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(name);
    void *return_value_ci_pack_allocator_alloc_from_rear_3;
    return_value_ci_pack_allocator_alloc_from_rear_3=ci_pack_allocator_alloc_from_rear(packer, (signed int)(return_value_strlen_2 + (unsigned long int)1));
    item->name = (char *)return_value_ci_pack_allocator_alloc_from_rear_3;
    item->value=ci_pack_allocator_alloc_from_rear(packer, (signed int)size);
  }

  _Bool tmp_if_expr_4;
  if(item == ((struct ci_array_item *)NULL))
    tmp_if_expr_4 = (_Bool)1;

  else
    tmp_if_expr_4 = !(item->name != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_5;
  if(tmp_if_expr_4)
    tmp_if_expr_5 = (_Bool)1;

  else
    tmp_if_expr_5 = !(item->value != NULL) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_5)
  {
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Not enough space to add the new item to array!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Not enough space to add the new item to array!\n");

    }

    return (const struct ci_array_item *)(void *)0;
  }

  else
  {
    strcpy(item->name, name);
    memcpy(item->value, value, size);
    if(array->items == ((struct ci_array_item *)NULL))
      array->items = item;

    array->count = array->count + 1u;
    return item;
  }
}

// ci_array_destroy
// file include/array.h line 107
void ci_array_destroy(struct ci_array *array)
{
  void *buffer = (void *)array->mem;
  /* assertion buffer */
  assert(buffer != NULL);
  if(!(array->alloc == ((struct ci_mem_allocator *)NULL)))
    ci_mem_allocator_destroy(array->alloc);

  ci_buffer_free(buffer);
}

// ci_array_get_item
// file array.c line 144
const struct ci_array_item * ci_array_get_item(struct ci_array *array, signed int pos)
{
  if((unsigned int)pos >= array->count)
    return (const struct ci_array_item *)(void *)0;

  else
    return &array->items[(signed long int)pos];
}

// ci_array_iterate
// file array.c line 116
void ci_array_iterate(const struct ci_array *array, void *data, signed int (*fn)(void *, const char *, const void *))
{
  signed int i;
  signed int ret = 0;
  i = 0;
  if(ret == 0 && !((unsigned int)i >= array->count))
  {
    ret=fn(data, (array->items + (signed long int)i)->name, (array->items + (signed long int)i)->value);
    i = i + 1;
  }

}

// ci_array_new
// file include/array.h line 90
struct ci_array * ci_array_new(unsigned long int size)
{
  struct ci_array *array;
  struct ci_mem_allocator *packer;
  void *buffer;
  buffer=ci_buffer_alloc((signed int)size);
  if(buffer == NULL)
    return (struct ci_array *)(void *)0;

  else
  {
    packer=ci_create_pack_allocator_on_memblock((char *)buffer, size);
    if(packer == ((struct ci_mem_allocator *)NULL))
    {
      ci_buffer_free(buffer);
      return (struct ci_array *)(void *)0;
    }

    else
    {
      void *return_value_ci_pack_allocator_alloc_1;
      return_value_ci_pack_allocator_alloc_1=ci_pack_allocator_alloc(packer, sizeof(struct ci_array) /*40ul*/ );
      array = (struct ci_array *)return_value_ci_pack_allocator_alloc_1;
      if(array == ((struct ci_array *)NULL))
      {
        ci_buffer_free(buffer);
        ci_mem_allocator_destroy(packer);
        return (struct ci_array *)(void *)0;
      }

      else
      {
        array->max_size = size;
        array->count = (unsigned int)0;
        array->items = (struct ci_array_item *)(void *)0;
        array->mem = (char *)buffer;
        array->alloc = packer;
        return array;
      }
    }
  }
}

// ci_array_new2
// file array.c line 60
struct ci_array * ci_array_new2(unsigned long int items, unsigned long int item_size)
{
  unsigned long int array_size;
  unsigned long int return_value_ci_pack_allocator_required_size_1;
  return_value_ci_pack_allocator_required_size_1=ci_pack_allocator_required_size();
  array_size = return_value_ci_pack_allocator_required_size_1 + (sizeof(struct ci_array) /*40ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + items * ((item_size + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + (sizeof(struct ci_array_item) /*16ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)));
  struct ci_array *return_value_ci_array_new_2;
  return_value_ci_array_new_2=ci_array_new(array_size);
  return return_value_ci_array_new_2;
}

// ci_array_pop
// file array.c line 125
const struct ci_array_item * ci_array_pop(struct ci_array *array)
{
  struct ci_array_item *item;
  if(array->count == 0u)
    return (const struct ci_array_item *)(void *)0;

  else
  {
    item = &array->items[(signed long int)(array->count - (unsigned int)1)];
    ci_pack_allocator_set_start_pos(array->alloc, (void *)item);
    array->count = array->count - 1u;
    if(array->count == 0u)
      ci_pack_allocator_set_end_pos(array->alloc, (void *)0);

    else
    {
      void *tmp_if_expr_1;
      if(!((void *)(array->items + (signed long int)(array->count + 4294967295u))->name >= (array->items + (signed long int)(array->count + 4294967295u))->value))
        tmp_if_expr_1 = (void *)(array->items + (signed long int)(array->count - (unsigned int)1))->name;

      else
        tmp_if_expr_1 = (void *)(array->items + (signed long int)(array->count - (unsigned int)1))->value;
      ci_pack_allocator_set_end_pos(array->alloc, tmp_if_expr_1);
    }
    return item;
  }
}

// ci_array_search
// file include/array.h line 135
const void * ci_array_search(struct ci_array *array, const char *name)
{
  signed int i = 0;
  for( ; !((unsigned int)i >= array->count); i = i + 1)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp((array->items + (signed long int)i)->name, name);
    if(return_value_strcmp_1 == 0)
      return (array->items + (signed long int)i)->value;

  }
  return (void *)0;
}

// ci_atol_ext
// file util.c line 78
signed long int ci_atol_ext(const char *str, const char **error)
{
  char *e;
  signed long int val;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  val=strtol(str, &e, 10);
  if(!(error == ((const char **)NULL)))
  {
    *error = (const char *)(void *)0;
    signed int *return_value___errno_location_3;
    return_value___errno_location_3=__errno_location();
    if((val == 0x7fffffffffffffffL || val == -9223372036854775808l) && *return_value___errno_location_3 == 34)
    {
      *error = atol_err_erange;
      goto __CPROVER_DUMP_L5;
    }

    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    if(val == 0l && !(*return_value___errno_location_2 == 0))
      *error = atol_err_conversion;

    else
      if(e == str)
        *error = atol_err_nonumber;


  __CPROVER_DUMP_L5:
    ;
    if(!(*error == ((const char *)NULL)))
      return (signed long int)0;

  }

  if(!(val == 0l))
  {
    _Bool tmp_if_expr_5;
    if((signed int)*e == 107)
      tmp_if_expr_5 = (_Bool)1;

    else
      tmp_if_expr_5 = (signed int)*e == 75 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_5)
      val = val * (signed long int)1024;

    else
    {
      _Bool tmp_if_expr_4;
      if((signed int)*e == 109)
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = (signed int)*e == 77 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_4)
        val = val * (signed long int)1024 * (signed long int)1024;

    }
  }

  return val;
}

// ci_base64_decode
// file decode.c line 54
signed int ci_base64_decode(const char *encoded, char *decoded, signed int len)
{
  signed int i;
  unsigned char *str;
  unsigned char *result;
  if(decoded == ((char *)NULL) || encoded == ((const char *)NULL) || len == 0)
    return 0;

  else
  {
    str = (unsigned char *)encoded;
    result = (unsigned char *)decoded;
    i = len;
    for( ; i >= 4; i = i - 3)
    {
      _Bool tmp_if_expr_1;
      if((signed int)base64_table[(signed long int)*str] >= 64)
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = (signed int)base64_table[(signed long int)str[(signed long int)1]] > 63 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr_2;
      if(tmp_if_expr_1)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (signed int)base64_table[(signed long int)str[(signed long int)2]] > 63 ? (_Bool)1 : (_Bool)0;
      _Bool tmp_if_expr_3;
      if(tmp_if_expr_2)
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = (signed int)base64_table[(signed long int)str[(signed long int)3]] > 63 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3)
        break;

      unsigned char *tmp_post_4 = result;
      result = result + 1l;
      *tmp_post_4 = (unsigned char)((signed int)base64_table[(signed long int)*str] << 2 | (signed int)base64_table[(signed long int)str[(signed long int)1]] >> 4);
      unsigned char *tmp_post_5 = result;
      result = result + 1l;
      *tmp_post_5 = (unsigned char)((signed int)base64_table[(signed long int)str[(signed long int)1]] << 4 | (signed int)base64_table[(signed long int)str[(signed long int)2]] >> 2);
      unsigned char *tmp_post_6 = result;
      result = result + 1l;
      *tmp_post_6 = (unsigned char)((signed int)base64_table[(signed long int)str[(signed long int)2]] << 6 | (signed int)base64_table[(signed long int)str[(signed long int)3]]);
      str = str + (signed long int)4;
    }
    *result = (unsigned char)0;
    return len - i;
  }
}

// ci_base64_decode_dup
// file decode.c line 88
char * ci_base64_decode_dup(const char *encoded)
{
  signed int len;
  char *result;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(encoded);
  len = (signed int)return_value_strlen_1;
  len = ((len + 3) / 4) * 3 + 1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)len * sizeof(char) /*1ul*/ );
  result = (char *)return_value_malloc_2;
  if(result == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    ci_base64_decode(encoded, result, len);
    return result;
  }
}

// ci_base64_encode
// file decode.c line 111
signed int ci_base64_encode(const unsigned char *data, unsigned long int len, char *out, unsigned long int outlen)
{
  signed int i;
  signed int k;
  const char *base64_set = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  i = 0;
  k = 0;
  for( ; !((unsigned long int)i >= len + 18446744073709551613ul) && !((unsigned long int)k >= outlen + 18446744073709551612ul); i = i + 3)
  {
    signed int tmp_post_1 = k;
    k = k + 1;
    out[(signed long int)tmp_post_1] = base64_set[(signed long int)((signed int)data[(signed long int)i] >> 2 & 0x3F)];
    signed int tmp_post_2 = k;
    k = k + 1;
    out[(signed long int)tmp_post_2] = base64_set[(signed long int)(((signed int)data[(signed long int)i] << 4 | (signed int)data[(signed long int)(i + 1)] >> 4) & 0x3F)];
    signed int tmp_post_3 = k;
    k = k + 1;
    out[(signed long int)tmp_post_3] = base64_set[(signed long int)(((signed int)data[(signed long int)(i + 1)] << 2 | (signed int)data[(signed long int)(i + 2)] >> 6) & 0x3F)];
    signed int tmp_post_4 = k;
    k = k + 1;
    out[(signed long int)tmp_post_4] = base64_set[(signed long int)((signed int)data[(signed long int)(i + 2)] & 0x3F)];
  }
  if(!((unsigned long int)i >= len) && !((unsigned long int)k >= outlen + 18446744073709551612ul))
  {
    signed int tmp_post_5 = k;
    k = k + 1;
    signed int tmp_if_expr_6;
    if(!((unsigned long int)i >= len))
      tmp_if_expr_6 = (signed int)data[(signed long int)i];

    else
      tmp_if_expr_6 = 0;
    out[(signed long int)tmp_post_5] = base64_set[(signed long int)(tmp_if_expr_6 >> 2 & 0x3F)];
    signed int tmp_post_7 = k;
    k = k + 1;
    signed int tmp_if_expr_8;
    if(!((unsigned long int)i >= len))
      tmp_if_expr_8 = (signed int)data[(signed long int)i];

    else
      tmp_if_expr_8 = 0;
    signed int tmp_if_expr_9;
    if(!((unsigned long int)(1 + i) >= len))
      tmp_if_expr_9 = (signed int)data[(signed long int)(i + 1)];

    else
      tmp_if_expr_9 = 0;
    out[(signed long int)tmp_post_7] = base64_set[(signed long int)((tmp_if_expr_8 << 4 | tmp_if_expr_9 >> 4) & 0x3F)];
    signed int tmp_post_10 = k;
    k = k + 1;
    signed int tmp_if_expr_11;
    if(!((unsigned long int)(1 + i) >= len))
      tmp_if_expr_11 = (signed int)data[(signed long int)(i + 1)];

    else
      tmp_if_expr_11 = 0;
    signed int tmp_if_expr_12;
    if(!((unsigned long int)(2 + i) >= len))
      tmp_if_expr_12 = (signed int)data[(signed long int)(i + 2)];

    else
      tmp_if_expr_12 = 0;
    out[(signed long int)tmp_post_10] = base64_set[(signed long int)((tmp_if_expr_11 << 2 | tmp_if_expr_12 >> 6) & 0x3F)];
    signed int tmp_post_13 = k;
    k = k + 1;
    signed int tmp_if_expr_14;
    if(!((unsigned long int)(2 + i) >= len))
      tmp_if_expr_14 = (signed int)data[(signed long int)(i + 2)];

    else
      tmp_if_expr_14 = 0;
    out[(signed long int)tmp_post_13] = base64_set[(signed long int)(tmp_if_expr_14 & 0x3F)];
  }

  out[(signed long int)k] = (char)0;
  return k;
}

// ci_belongs_to_group
// file filetype.c line 153
signed int ci_belongs_to_group(struct ci_magics_db *db, signed int type, signed int group)
{
  signed int i;
  if(!(db->types_num >= type))
    return 0;

  else
  {
    i = 0;
    for( ; (db->types + (signed long int)type)->groups[(signed long int)i] >= 0; i = i + 1)
    {
      if(i >= 64)
        break;

      if((db->types + (signed long int)type)->groups[(signed long int)i] == group)
        return 1;

    }
    return 0;
  }
}

// ci_buf_init
// file request_common.c line 45
void ci_buf_init(struct ci_buf *buf)
{
  buf->buf = (char *)(void *)0;
  buf->size = 0;
  buf->used = 0;
}

// ci_buf_mem_alloc
// file request_common.c line 56
signed int ci_buf_mem_alloc(struct ci_buf *buf, signed int size)
{
  void *return_value;
  return_value=__intl_malloc((signed int)((unsigned long int)size * sizeof(char) /*1ul*/ ));
  buf->buf = (char *)return_value;
  if(buf->buf == ((char *)NULL))
    return 0;

  else
  {
    buf->size = size;
    buf->used = 0;
    return size;
  }
}

// ci_buf_mem_free
// file request_common.c line 65
void ci_buf_mem_free(struct ci_buf *buf)
{
  __intl_free((void *)buf->buf);
  buf->buf = (char *)(void *)0;
  buf->size = 0;
  buf->used = 0;
}

// ci_buf_reset
// file request_common.c line 52
void ci_buf_reset(struct ci_buf *buf)
{
  buf->used = 0;
}

// ci_buf_reset_size
// file request_common.c line 83
signed int ci_buf_reset_size(struct ci_buf *buf, signed int req_size)
{
  if(!(req_size >= buf->size))
    return req_size;

  else
  {
    if(!(buf->buf == ((char *)NULL)))
      __intl_free((void *)buf->buf);

    signed int return_value_ci_buf_mem_alloc_1;
    return_value_ci_buf_mem_alloc_1=ci_buf_mem_alloc(buf, req_size);
    return return_value_ci_buf_mem_alloc_1;
  }
}

// ci_buf_write
// file request_common.c line 74
signed int ci_buf_write(struct ci_buf *buf, char *data, signed int len)
{
  if(!(buf->size + -buf->used >= len))
    return -1;

  else
  {
    memcpy((void *)(buf->buf + (signed long int)buf->used), (const void *)data, (unsigned long int)len);
    buf->used = buf->used + len;
    return len;
  }
}

// ci_buffer_alloc
// file include/mem.h line 66
void * ci_buffer_alloc(signed int block_size)
{
  signed int type;
  signed int size;
  struct mem_buffer_block *block = (struct mem_buffer_block *)(void *)0;
  size = (signed int)((unsigned long int)block_size + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]);
  type = block_size - 1 >> 6;
  _Bool tmp_if_expr_1;
  if(!(type >= 16))
    tmp_if_expr_1 = short_buffers[(signed long int)type] != (struct ci_mem_allocator *)(void *)0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
  {
    void *return_value;
    return_value=short_buffers[(signed long int)type]->alloc(short_buffers[(signed long int)type], (unsigned long int)size);
    block = (struct mem_buffer_block *)return_value;
  }

  else
    if(!(type >= 512))
    {
      type = type >> 5;
      if(!(long_buffers[(signed long int)type] == ((struct ci_mem_allocator *)NULL)))
      {
        void *return_value_1;
        return_value_1=long_buffers[(signed long int)type]->alloc(long_buffers[(signed long int)type], (unsigned long int)size);
        block = (struct mem_buffer_block *)return_value_1;
      }

    }

  void *return_value_malloc_2;
  if(block == ((struct mem_buffer_block *)NULL))
  {
    return_value_malloc_2=malloc((unsigned long int)size);
    block = (struct mem_buffer_block *)return_value_malloc_2;
  }

  if(block == ((struct mem_buffer_block *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Failed to allocate space for buffer of size:%d\n", block_size);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Failed to allocate space for buffer of size:%d\n", block_size);

    }

    return (void *)0;
  }

  else
  {
    block->sig = (unsigned short int)0xAA55;
    block->ID = block_size;
    if(CI_DEBUG_LEVEL >= 8)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Geting buffer from pool %d:%d\n", block_size, type);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Geting buffer from pool %d:%d\n", block_size, type);

    }

    return (void *)block->data.ptr;
  }
}

// ci_buffer_blocksize
// file mem.c line 204
unsigned long int ci_buffer_blocksize(const void *data)
{
  struct mem_buffer_block *block;
  signed int type;
  unsigned long int buffer_block_size = (unsigned long int)0;
  block = (struct mem_buffer_block *)(data - (signed long int)(unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]);
  if(!((signed int)block->sig == 0xAA55))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "ci_buffer_blocksize: ERROR, %p is not internal buffer. This is a bug!!!!\n", data);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("ci_buffer_blocksize: ERROR, %p is not internal buffer. This is a bug!!!!\n", data);

    }

    return (unsigned long int)0;
  }

  else
  {
    type = block->ID - 1 >> 6;
    _Bool tmp_if_expr_1;
    if(!(type >= 16))
      tmp_if_expr_1 = short_buffers[(signed long int)type] != (struct ci_mem_allocator *)(void *)0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      buffer_block_size = (unsigned long int)short_buffer_sizes[(signed long int)type];

    else
      if(!(type >= 512))
      {
        type = type >> 5;
        if(!(long_buffers[(signed long int)type] == ((struct ci_mem_allocator *)NULL)))
          buffer_block_size = (unsigned long int)long_buffer_sizes[(signed long int)type];

      }

    if(buffer_block_size == 0ul)
      buffer_block_size = (unsigned long int)block->ID;

    return buffer_block_size;
  }
}

// ci_buffer_free
// file include/mem.h line 68
void ci_buffer_free(void *data)
{
  signed int block_size;
  signed int type;
  struct mem_buffer_block *block;
  if(!(data == NULL))
  {
    block = (struct mem_buffer_block *)(data - (signed long int)(unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]);
    if(!((signed int)block->sig == 0xAA55))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "ci_buffer_free: ERROR, %p is not internal buffer. This is a bug!!!!\n", data);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("ci_buffer_free: ERROR, %p is not internal buffer. This is a bug!!!!\n", data);

      }

    }

    else
    {
      block_size = block->ID;
      type = block_size - 1 >> 6;
      _Bool tmp_if_expr_1;
      if(!(type >= 16))
        tmp_if_expr_1 = short_buffers[(signed long int)type] != (struct ci_mem_allocator *)(void *)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
      {
        short_buffers[(signed long int)type]->free(short_buffers[(signed long int)type], (void *)block);
        if(CI_DEBUG_LEVEL >= 8)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Store buffer to short pool %d:%d\n", block_size, type);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Store buffer to short pool %d:%d\n", block_size, type);

        }

      }

      else
        if(!(type >= 512))
        {
          type = type >> 5;
          if(!(long_buffers[(signed long int)type] == ((struct ci_mem_allocator *)NULL)))
            long_buffers[(signed long int)type]->free(long_buffers[(signed long int)type], (void *)block);

          else
            free((void *)block);
          if(CI_DEBUG_LEVEL >= 8)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Store buffer to long pool %d:%d\n", block_size, type);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Store buffer to long pool %d:%d\n", block_size, type);

          }

        }

        else
          free((void *)block);
    }
  }

}

// ci_buffer_realloc
// file include/mem.h line 67
void * ci_buffer_realloc(void *data, signed int block_size)
{
  signed int buffer_size = 0;
  struct mem_buffer_block *block;
  void *return_value_ci_buffer_alloc_1;
  if(data == NULL)
  {
    return_value_ci_buffer_alloc_1=ci_buffer_alloc(block_size);
    return return_value_ci_buffer_alloc_1;
  }

  block = (struct mem_buffer_block *)(data - (signed long int)(unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]);
  if(!((signed int)block->sig == 0xAA55))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "ci_buffer_realloc: ERROR, %p is not internal buffer. This is a bug!!!!\n", data);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("ci_buffer_realloc: ERROR, %p is not internal buffer. This is a bug!!!!\n", data);

    }

    return (void *)0;
  }

  else
  {
    unsigned long int return_value_ci_buffer_blocksize_2;
    return_value_ci_buffer_blocksize_2=ci_buffer_blocksize(data);
    buffer_size = (signed int)return_value_ci_buffer_blocksize_2;
    /* assertion buffer_size > 0 */
    assert(buffer_size > 0);
    if(CI_DEBUG_LEVEL >= 8)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Current block size for realloc: %d, requested block size: %d. The initial size: %d\n", buffer_size, block_size, block->ID);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Current block size for realloc: %d, requested block size: %d. The initial size: %d\n", buffer_size, block_size, block->ID);

    }

    if(!(buffer_size >= block_size))
    {
      if(CI_DEBUG_LEVEL >= 10)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "We are going to allocate a bigger block of size: %d\n", block_size);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("We are going to allocate a bigger block of size: %d\n", block_size);

      }

      data=ci_buffer_alloc(block_size);
      if(data == NULL)
        return (void *)0;

      if(CI_DEBUG_LEVEL >= 10)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Preserve data of size: %d\n", block->ID);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Preserve data of size: %d\n", block->ID);

      }

      memcpy(data, (const void *)block->data.ptr, (unsigned long int)block->ID);
      ci_buffer_free((void *)block->data.ptr);
    }

    else
      block->ID = block_size;
    return data;
  }
}

// ci_buffers_destroy
// file mem.c line 166
void ci_buffers_destroy()
{
  signed int i = 0;
  for( ; !(i >= 16); i = i + 1)
    if(!(short_buffers[(signed long int)i] == ((struct ci_mem_allocator *)NULL)))
      ci_mem_allocator_destroy(short_buffers[(signed long int)i]);

}

// ci_buffers_init
// file mem.c line 112
signed int ci_buffers_init()
{
  signed int i;
  struct ci_mem_allocator *buf64_pool;
  struct ci_mem_allocator *buf128_pool;
  struct ci_mem_allocator *buf256_pool;
  struct ci_mem_allocator *buf512_pool;
  struct ci_mem_allocator *buf1024_pool;
  struct ci_mem_allocator *buf2048_pool;
  struct ci_mem_allocator *buf4096_pool;
  struct ci_mem_allocator *buf8192_pool;
  struct ci_mem_allocator *buf16384_pool;
  struct ci_mem_allocator *buf32768_pool;
  buf64_pool=ci_create_pool_allocator((signed int)((unsigned long int)64 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf128_pool=ci_create_pool_allocator((signed int)((unsigned long int)128 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf256_pool=ci_create_pool_allocator((signed int)((unsigned long int)256 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf512_pool=ci_create_pool_allocator((signed int)((unsigned long int)512 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf1024_pool=ci_create_pool_allocator((signed int)((unsigned long int)1024 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf2048_pool=ci_create_pool_allocator((signed int)((unsigned long int)2048 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf4096_pool=ci_create_pool_allocator((signed int)((unsigned long int)4096 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf8192_pool=ci_create_pool_allocator((signed int)((unsigned long int)8192 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf16384_pool=ci_create_pool_allocator((signed int)((unsigned long int)16384 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  buf32768_pool=ci_create_pool_allocator((signed int)((unsigned long int)32768 + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
  short_buffers[(signed long int)0] = buf64_pool;
  short_buffers[(signed long int)1] = buf128_pool;
  short_buffers[(signed long int)3] = buf256_pool;
  short_buffers[(signed long int)2] = short_buffers[(signed long int)3];
  short_buffers[(signed long int)7] = buf512_pool;
  short_buffers[(signed long int)6] = short_buffers[(signed long int)7];
  short_buffers[(signed long int)5] = short_buffers[(signed long int)6];
  short_buffers[(signed long int)4] = short_buffers[(signed long int)5];
  i = 8;
  for( ; !(i >= 16); i = i + 1)
    short_buffers[(signed long int)i] = buf1024_pool;
  long_buffers[(signed long int)0] = buf2048_pool;
  long_buffers[(signed long int)1] = buf4096_pool;
  long_buffers[(signed long int)3] = buf8192_pool;
  long_buffers[(signed long int)2] = long_buffers[(signed long int)3];
  long_buffers[(signed long int)7] = buf16384_pool;
  long_buffers[(signed long int)6] = long_buffers[(signed long int)7];
  long_buffers[(signed long int)5] = long_buffers[(signed long int)6];
  long_buffers[(signed long int)4] = long_buffers[(signed long int)5];
  i = 8;
  for( ; !(i >= 16); i = i + 1)
    long_buffers[(signed long int)i] = buf32768_pool;
  return 1;
}

// ci_cache_build
// file cache.c line 387
struct ci_cache * ci_cache_build(const char *name, const char *cache_type, unsigned int cache_size, unsigned int max_object_size, signed int ttl, const struct ci_type_ops *key_ops)
{
  struct ci_cache *cache;
  const struct ci_cache_type *type;
  if(!(cache_size >= 1u))
    return (struct ci_cache *)(void *)0;

  else
  {
    type=ci_cache_type_get(cache_type);
    if(type == ((const struct ci_cache_type *)NULL))
    {
      type = &ci_local_cache;
      signed int return_value_strcasecmp_1;
      return_value_strcasecmp_1=strcasecmp(cache_type, ci_local_cache.name);
      if(!(return_value_strcasecmp_1 == 0))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "WARNING: Cache type '%s' not found. Creating a local cache\n", cache_type);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("WARNING: Cache type '%s' not found. Creating a local cache\n", cache_type);

        }

      }

    }

    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(struct ci_cache) /*80ul*/ );
    cache = (struct ci_cache *)return_value_malloc_2;
    if(cache == ((struct ci_cache *)NULL))
      return (struct ci_cache *)(void *)0;

    else
    {
      if(!(key_ops == ((const struct ci_type_ops *)NULL)))
        cache->key_ops = key_ops;

      else
        cache->key_ops = &ci_str_ops;
      cache->mem_size = cache_size;
      cache->max_object_size = max_object_size;
      cache->ttl = (signed long int)ttl;
      cache->init = type->init;
      cache->destroy = type->destroy;
      cache->search = type->search;
      cache->update = type->update;
      cache->_cache_type = type;
      signed int return_value;
      return_value=cache->init(cache, name);
      if(return_value == 0)
      {
        free((void *)cache);
        return (struct ci_cache *)(void *)0;
      }

      else
        return cache;
    }
  }
}

// ci_cache_destroy
// file cache.c line 47
void ci_cache_destroy(struct ci_cache *cache)
{
  cache->destroy(cache);
  free((void *)cache);
}

// ci_cache_read_vector_val
// file cache.c line 492
void * ci_cache_read_vector_val(const void *val, unsigned long int val_size, void *o)
{
  unsigned long int vector_size;
  unsigned long int item_size;
  signed int i;
  struct ci_vector *v;
  const void **data_indx;
  if(val == NULL)
    return (void *)0;

  else
  {
    data_indx = (const void **)(val + (signed long int)sizeof(unsigned long int) /*8ul*/ );
    vector_size = *((unsigned long int *)val);
    v=ci_vector_create(vector_size);
    item_size = (val_size - sizeof(unsigned long int) /*8ul*/ ) - (unsigned long int)data_indx[(signed long int)0];
    i = 0;
    for( ; !(data_indx[(signed long int)i] == NULL); i = i + 1)
    {
      ci_vector_add(v, (const void *)((const void *)data_indx + (signed long int)(unsigned long int)data_indx[(signed long int)i]), item_size);
      item_size = (unsigned long int)(data_indx[(signed long int)i] - data_indx[(signed long int)(i + 1)]);
    }
    return (void *)v;
  }
}

// ci_cache_search
// file cache.c line 53
const void * ci_cache_search(struct ci_cache *cache, const void *key, void **val, void *data, void * (*dup_from_cache)(const void *, unsigned long int, void *))
{
  const void *return_value;
  return_value=cache->search(cache, key, val, data, dup_from_cache);
  return return_value;
}

// ci_cache_store_vector_size
// file cache.c line 432
unsigned long int ci_cache_store_vector_size(struct ci_vector *v)
{
  signed int vector_data_size;
  signed int vector_indx_size;
  void *vector_data_start;
  void *vector_data_end;
  if(v == ((struct ci_vector *)NULL))
    return (unsigned long int)0;

  else
  {
    vector_data_start = (void *)v->items[(signed long int)(v->count - 1)];
    vector_data_end = (void *)(v->mem + (signed long int)v->max_size);
    _Bool tmp_if_expr_1;
    if(!(vector_data_start >= vector_data_end))
      tmp_if_expr_1 = vector_data_start > (void *)v->mem ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    /* assertion vector_data_start < vector_data_end && vector_data_start > (void *)v->mem */
    assert(tmp_if_expr_1);
    vector_data_size = (signed int)(vector_data_end - vector_data_start);
    vector_indx_size = (signed int)((unsigned long int)(v->count + 1) * sizeof(void *) /*8ul*/ );
    return sizeof(unsigned long int) /*8ul*/  + (unsigned long int)vector_indx_size + (unsigned long int)vector_data_size;
  }
}

// ci_cache_store_vector_val
// file cache.c line 453
void * ci_cache_store_vector_val(void *buf, const void *val, unsigned long int buf_size)
{
  signed int vector_data_size;
  signed int vector_indx_size;
  signed int i;
  const void *vector_data_start;
  const void *vector_data_end;
  void *data;
  void **data_indx;
  struct ci_vector *v = (struct ci_vector *)val;
  if(buf == NULL || val == NULL)
    return (void *)0;

  else
  {
    vector_data_start = (void *)v->items[(signed long int)(v->count - 1)];
    vector_data_end = (const void *)(v->mem + (signed long int)v->max_size);
    _Bool tmp_if_expr_1;
    if(!(vector_data_start >= vector_data_end))
      tmp_if_expr_1 = vector_data_start > (void *)v->mem ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    /* assertion vector_data_start < vector_data_end && vector_data_start > (void *)v->mem */
    assert(tmp_if_expr_1);
    vector_data_size = (signed int)(vector_data_end - vector_data_start);
    vector_indx_size = (signed int)((unsigned long int)(v->count + 1) * sizeof(void *) /*8ul*/ );
    /* assertion buf_size >= sizeof(size_t) + vector_indx_size + vector_data_size */
    assert(buf_size >= sizeof(unsigned long int) /*8ul*/  + (unsigned long int)vector_indx_size + (unsigned long int)vector_data_size);
    data = buf;
    memcpy(data, (const void *)&v->max_size, sizeof(unsigned long int) /*8ul*/ );
    data_indx = (void **)(data + (signed long int)sizeof(unsigned long int) /*8ul*/ );
    memcpy((void *)data_indx + (signed long int)vector_indx_size, vector_data_start, (unsigned long int)vector_data_size);
    i = 0;
    for( ; !(v->items[(signed long int)i] == NULL); i = i + 1)
      data_indx[(signed long int)i] = (void *)((v->items[(signed long int)i] - vector_data_start) + (signed long int)vector_indx_size);
    data_indx[(signed long int)i] = (void *)0;
    return data;
  }
}

// ci_cache_type_get
// file cache.c line 42
static const struct ci_cache_type * ci_cache_type_get(const char *name)
{
  const void *return_value_ci_registry_get_item_1;
  return_value_ci_registry_get_item_1=ci_registry_get_item("c-icap::ci_cache_type", name);
  return (const struct ci_cache_type *)return_value_ci_registry_get_item_1;
}

// ci_cache_type_register
// file cache.c line 37
void ci_cache_type_register(struct ci_cache_type *type)
{
  ci_registry_add_item("c-icap::ci_cache_type", type->name, (const void *)type);
}

// ci_cache_update
// file cache.c line 58
signed int ci_cache_update(struct ci_cache *cache, const void *key, const void *val, unsigned long int val_size, void * (*copy_to_cache)(void *, const void *, unsigned long int))
{
  signed int return_value;
  return_value=cache->update(cache, key, val, val_size, copy_to_cache);
  return return_value;
}

// ci_cached_file_destroy
// file body.c line 423
void ci_cached_file_destroy(struct ci_cached_file *body)
{
  if(!(body == ((struct ci_cached_file *)NULL)))
  {
    if(!(body->buf == ((char *)NULL)))
      ci_buffer_free((void *)body->buf);

    if(body->fd >= 0)
    {
      do_close(body->fd);
      unlink(body->filename);
    }

    if(!(body->attributes == ((struct ci_array *)NULL)))
      ci_array_destroy(body->attributes);

    ci_object_pool_free((void *)body);
  }

}

// ci_cached_file_new
// file body.c line 360
struct ci_cached_file * ci_cached_file_new(signed int size)
{
  struct ci_cached_file *body;
  void *return_value_ci_object_pool_alloc_1;
  return_value_ci_object_pool_alloc_1=ci_object_pool_alloc(CACHED_FILE_POOL);
  body = (struct ci_cached_file *)return_value_ci_object_pool_alloc_1;
  if(body == ((struct ci_cached_file *)NULL))
    return (struct ci_cached_file *)(void *)0;

  else
  {
    if(size == 0)
      size = CI_BODY_MAX_MEM;

    if(CI_BODY_MAX_MEM >= size && size >= 1)
    {
      void *return_value_ci_buffer_alloc_2;
      return_value_ci_buffer_alloc_2=ci_buffer_alloc((signed int)((unsigned long int)size * sizeof(char) /*1ul*/ ));
      body->buf = (char *)return_value_ci_buffer_alloc_2;
    }

    else
      body->buf = (char *)(void *)0;
    if(body->buf == ((char *)NULL))
    {
      body->bufsize = 0;
      body->fd=ci_mktemp_file(CI_TMPDIR, "CI_TMP_XXXXXX", body->filename);
      if(!(body->fd >= 0))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Can not open temporary filename in directory:%s\n", CI_TMPDIR);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Can not open temporary filename in directory:%s\n", CI_TMPDIR);

        }

        ci_object_pool_free((void *)body);
        return (struct ci_cached_file *)(void *)0;
      }

    }

    else
    {
      body->bufsize = size;
      body->fd = -1;
    }
    body->endpos = (signed long int)0;
    body->readpos = (signed long int)0;
    body->flags = 0;
    body->unlocked = (signed long int)0;
    body->attributes = (struct ci_array *)(void *)0;
    return body;
  }
}

// ci_cached_file_read
// file body.c line 520
signed int ci_cached_file_read(struct ci_cached_file *body, char *buf, signed int len)
{
  signed int remains;
  signed int bytes;
  if(body->readpos == body->endpos)
  {
    if((0x02 & body->flags) == 0)
      goto __CPROVER_DUMP_L1;

    return -2;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(len == 0)
      return 0;

    else
      if(body->fd >= 1)
      {
        _Bool tmp_if_expr_1;
        if(!((0x01 & body->flags) == 0))
          tmp_if_expr_1 = body->unlocked >= (signed long int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        if(tmp_if_expr_1)
          remains = (signed int)(body->unlocked - body->readpos);

        else
          remains = len;
        bytes = remains > len ? len : remains;
        lseek64(body->fd, body->readpos, 0);
        bytes=do_read(body->fd, (void *)buf, (unsigned long int)bytes);
        if(bytes >= 1)
          body->readpos = body->readpos + (signed long int)bytes;

        return bytes;
      }

      else
      {
        _Bool tmp_if_expr_2;
        if(!((0x01 & body->flags) == 0))
          tmp_if_expr_2 = body->unlocked >= (signed long int)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(tmp_if_expr_2)
          remains = (signed int)(body->unlocked - body->readpos);

        else
          remains = (signed int)(body->endpos - body->readpos);
        bytes = len <= remains ? len : remains;
        if(bytes >= 1)
        {
          memcpy((void *)buf, (const void *)(body->buf + body->readpos), (unsigned long int)bytes);
          body->readpos = body->readpos + (signed long int)bytes;
        }

        else
        {
          bytes = 0;
          if(CI_DEBUG_LEVEL >= 10)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Read 0, %lld %lld\n", (signed long long int)body->readpos, (signed long long int)body->endpos);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Read 0, %lld %lld\n", (signed long long int)body->readpos, (signed long long int)body->endpos);

          }

        }
        return bytes;
      }
  }
}

// ci_cached_file_release
// file body.c line 442
void ci_cached_file_release(struct ci_cached_file *body)
{
  if(!(body == ((struct ci_cached_file *)NULL)))
  {
    if(!(body->buf == ((char *)NULL)))
      ci_buffer_free((void *)body->buf);

    if(body->fd >= 0)
      do_close(body->fd);

    if(!(body->attributes == ((struct ci_array *)NULL)))
      ci_array_destroy(body->attributes);

    ci_object_pool_free((void *)body);
  }

}

// ci_cached_file_reset
// file body.c line 398
void ci_cached_file_reset(struct ci_cached_file *body, signed int new_size)
{
  if(body->fd >= 1)
  {
    do_close(body->fd);
    unlink(body->filename);
  }

  body->endpos = (signed long int)0;
  body->readpos = (signed long int)0;
  body->flags = 0;
  body->unlocked = (signed long int)0;
  body->fd = -1;
  if(!(body->attributes == ((struct ci_array *)NULL)))
    ci_array_destroy(body->attributes);

  body->attributes = (struct ci_array *)(void *)0;
  signed int return_value_resize_buffer_1;
  return_value_resize_buffer_1=resize_buffer(body, new_size);
}

// ci_cached_file_write
// file body.c line 461
signed int ci_cached_file_write(struct ci_cached_file *body, const char *buf, signed int len, signed int iseof)
{
  signed int remains;
  signed int ret;
  if(!(iseof == 0))
  {
    body->flags = body->flags | 0x02;
    if(CI_DEBUG_LEVEL >= 10)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Buffer size=%d, Data size=%lld\n ", ((struct ci_cached_file *)body)->bufsize, (signed long long int)((struct ci_cached_file *)body)->endpos);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Buffer size=%d, Data size=%lld\n ", ((struct ci_cached_file *)body)->bufsize, (signed long long int)((struct ci_cached_file *)body)->endpos);

    }

  }

  signed int *return_value___errno_location_1;
  signed int *return_value___errno_location_2;
  signed int return_value_do_write_7;
  signed int *return_value___errno_location_3;
  char *return_value_strerror_4;
  signed int *return_value___errno_location_5;
  char *return_value_strerror_6;
  if(len == 0)
    return 0;

  else
    if(body->fd >= 1)
    {
      lseek64(body->fd, (signed long int)0, 2);
      ret=do_write(body->fd, (const void *)buf, (unsigned long int)len);
      if(!(ret >= 0))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          {
            return_value___errno_location_1=__errno_location();
            __log_error((void *)0, "Cannot write to file!!! (errno=%d)\n", *return_value___errno_location_1);
          }

          if(!(CI_DEBUG_STDOUT == 0))
          {
            return_value___errno_location_2=__errno_location();
            printf("Cannot write to file!!! (errno=%d)\n", *return_value___errno_location_2);
          }

        }

      }

      body->endpos = body->endpos + (signed long int)len;
      return len;
    }

    else
    {
      remains = (signed int)((signed long int)body->bufsize - body->endpos);
      /* assertion remains >= 0 */
      assert(remains >= 0);
      if(!(remains >= len))
      {
        body->fd=ci_mktemp_file(CI_TMPDIR, "CI_TMP_XXXXXX", body->filename);
        if(!(body->fd >= 0))
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "I cannot create the temporary file: %s!!!!!!\n", (const void *)body->filename);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("I cannot create the temporary file: %s!!!!!!\n", (const void *)body->filename);

          }

          return -1;
        }

        ret=do_write(body->fd, (const void *)body->buf, (unsigned long int)body->endpos);
        _Bool tmp_if_expr_8;
        if(ret >= 0)
        {
          return_value_do_write_7=do_write(body->fd, (const void *)buf, (unsigned long int)len);
          tmp_if_expr_8 = return_value_do_write_7 >= 0 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_8 = (_Bool)0;
        if(tmp_if_expr_8)
        {
          body->endpos = body->endpos + (signed long int)len;
          return len;
        }

        else
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            {
              return_value___errno_location_3=__errno_location();
              return_value_strerror_4=strerror(*return_value___errno_location_3);
              __log_error((void *)0, "Cannot write to cachefile: %s\n", return_value_strerror_4);
            }

            if(!(CI_DEBUG_STDOUT == 0))
            {
              return_value___errno_location_5=__errno_location();
              return_value_strerror_6=strerror(*return_value___errno_location_5);
              printf("Cannot write to cachefile: %s\n", return_value_strerror_6);
            }

          }

          return -1;
        }
      }

      if(len >= 1)
      {
        memcpy((void *)(body->buf + body->endpos), (const void *)buf, (unsigned long int)len);
        body->endpos = body->endpos + (signed long int)len;
      }

      return len;
    }
}

// ci_cfg_alloc_mem
// file cfg_lib.c line 44
void * ci_cfg_alloc_mem(signed int size)
{
  void *return_value;
  return_value=cfg_params_allocator->alloc(cfg_params_allocator, (unsigned long int)size);
  return return_value;
}

// ci_cfg_disable
// file cfg_lib.c line 192
signed int ci_cfg_disable(const char *directive, const char **argv, void *setdata)
{
  if(setdata == NULL)
    return 0;

  else
  {
    *((signed int *)setdata) = 0;
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Disabling parameter %s\n", directive);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Disabling parameter %s\n", directive);

    }

    return 1;
  }
}

// ci_cfg_enable
// file ../include/cfg_param.h line 185
signed int ci_cfg_enable(const char *directive, const char **argv, void *setdata)
{
  if(setdata == NULL)
    return 0;

  else
  {
    *((signed int *)setdata) = 1;
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Enabling parameter %s\n", directive);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Enabling parameter %s\n", directive);

    }

    return 1;
  }
}

// ci_cfg_lib_init
// file ../include/cfg_param.h line 150
void ci_cfg_lib_init()
{
  cfg_params_allocator=ci_create_serial_allocator(65536);
}

// ci_cfg_lib_reset
// file cfg_lib.c line 39
void ci_cfg_lib_reset()
{
  cfg_params_allocator->reset(cfg_params_allocator);
}

// ci_cfg_onoff
// file cfg_lib.c line 169
signed int ci_cfg_onoff(const char *directive, const char **argv, void *setdata)
{
  signed int return_value_strcasecmp_2;
  if(setdata == NULL)
    return 0;

  else
  {
    _Bool tmp_if_expr_1;
    if(argv == ((const char **)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Missing arguments in directive:%s\n", directive);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Missing arguments in directive:%s\n", directive);

      }

      return 0;
    }

    else
    {
      signed int return_value_strcasecmp_3;
      return_value_strcasecmp_3=strcasecmp(argv[(signed long int)0], "on");
      if(return_value_strcasecmp_3 == 0)
        *((signed int *)setdata) = 1;

      else
      {
        return_value_strcasecmp_2=strcasecmp(argv[(signed long int)0], "off");
        if(return_value_strcasecmp_2 == 0)
          *((signed int *)setdata) = 0;

        else
          return 0;
      }
      if(CI_DEBUG_LEVEL >= 2)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Setting parameter :%s=%d\n", directive, *((signed int *)setdata));

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Setting parameter :%s=%d\n", directive, *((signed int *)setdata));

      }

      return 1;
    }
  }
}

// ci_cfg_set_int
// file ../include/cfg_param.h line 164
signed int ci_cfg_set_int(const char *directive, const char **argv, void *setdata)
{
  signed int val = 0;
  char *end;
  signed int *return_value___errno_location_4;
  if(setdata == NULL)
    return 0;

  else
  {
    _Bool tmp_if_expr_1;
    if(argv == ((const char **)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Missing arguments in directive:%s\n", directive);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Missing arguments in directive:%s\n", directive);

      }

      return 0;
    }

    else
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = 0;
      signed long long int return_value_strtoll_3;
      return_value_strtoll_3=strtoll(argv[(signed long int)0], &end, 10);
      val = (signed int)return_value_strtoll_3;
      if(val == 0)
      {
        return_value___errno_location_4=__errno_location();
        if(!(*return_value___errno_location_4 == 0))
          return 0;

      }

      *((signed int *)setdata) = val;
      if(CI_DEBUG_LEVEL >= 2)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Setting parameter :%s=%d\n", directive, val);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Setting parameter :%s=%d\n", directive, val);

      }

      return 1;
    }
  }
}

// ci_cfg_set_str
// file ../include/cfg_param.h line 158
signed int ci_cfg_set_str(const char *directive, const char **argv, void *setdata)
{
  if(setdata == NULL)
    return 0;

  else
  {
    _Bool tmp_if_expr_1;
    if(argv == ((const char **)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      return 0;

    else
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(argv[(signed long int)0]);
      void *return_value_ci_cfg_alloc_mem_3;
      return_value_ci_cfg_alloc_mem_3=ci_cfg_alloc_mem((signed int)(return_value_strlen_2 + (unsigned long int)1));
      *((char **)setdata) = (char *)return_value_ci_cfg_alloc_mem_3;
      if(*((char **)setdata) == ((char *)NULL))
        return 0;

      else
      {
        strcpy(*((char **)setdata), argv[(signed long int)0]);
        if(CI_DEBUG_LEVEL >= 2)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Setting parameter :%s=%s\n", directive, argv[(signed long int)0]);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Setting parameter :%s=%s\n", directive, argv[(signed long int)0]);

        }

        return 1;
      }
    }
  }
}

// ci_cfg_size_long
// file cfg_lib.c line 245
signed int ci_cfg_size_long(const char *directive, const char **argv, void *setdata)
{
  signed long int val = (signed long int)0;
  char *end;
  signed int *return_value___errno_location_3;
  if(setdata == NULL)
    return 0;

  else
  {
    _Bool tmp_if_expr_1;
    if(argv == ((const char **)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Missing arguments in directive: %s\n", directive);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Missing arguments in directive: %s\n", directive);

      }

      return 0;
    }

    else
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = 0;
      val=strtol(argv[(signed long int)0], &end, 10);
      _Bool tmp_if_expr_4;
      if(val == 0l)
      {
        return_value___errno_location_3=__errno_location();
        tmp_if_expr_4 = *return_value___errno_location_3 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_4 = (_Bool)0;
      if(!(val >= 0l) || tmp_if_expr_4)
        return 0;

      else
      {
        _Bool tmp_if_expr_6;
        if((signed int)*end == 107)
          tmp_if_expr_6 = (_Bool)1;

        else
          tmp_if_expr_6 = (signed int)*end == 75 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_6)
          val = val * (signed long int)1024;

        else
        {
          _Bool tmp_if_expr_5;
          if((signed int)*end == 109)
            tmp_if_expr_5 = (_Bool)1;

          else
            tmp_if_expr_5 = (signed int)*end == 77 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_5)
            val = val * (signed long int)1024 * (signed long int)1024;

        }
        if(val >= 1l)
          *((signed long int *)setdata) = val;

        if(CI_DEBUG_LEVEL >= 2)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Setting parameter :%s=%ld\n", directive, val);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Setting parameter :%s=%ld\n", directive, val);

        }

        return 1;
      }
    }
  }
}

// ci_cfg_size_off
// file cfg_lib.c line 213
signed int ci_cfg_size_off(const char *directive, const char **argv, void *setdata)
{
  signed long int val = (signed long int)0;
  char *end;
  signed int *return_value___errno_location_3;
  if(setdata == NULL)
    return 0;

  else
  {
    _Bool tmp_if_expr_1;
    if(argv == ((const char **)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = argv[(signed long int)0] == (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Missing arguments in directive:%s\n", directive);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Missing arguments in directive:%s\n", directive);

      }

      return 0;
    }

    else
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = 0;
      val=strtoll(argv[(signed long int)0], &end, 10);
      _Bool tmp_if_expr_4;
      if(val == 0l)
      {
        return_value___errno_location_3=__errno_location();
        tmp_if_expr_4 = *return_value___errno_location_3 != 0 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_4 = (_Bool)0;
      if(!(val >= 0l) || tmp_if_expr_4)
        return 0;

      else
      {
        _Bool tmp_if_expr_6;
        if((signed int)*end == 107)
          tmp_if_expr_6 = (_Bool)1;

        else
          tmp_if_expr_6 = (signed int)*end == 75 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_6)
          val = val * (signed long int)1024;

        else
        {
          _Bool tmp_if_expr_5;
          if((signed int)*end == 109)
            tmp_if_expr_5 = (_Bool)1;

          else
            tmp_if_expr_5 = (signed int)*end == 77 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_5)
            val = val * (signed long int)1024 * (signed long int)1024;

        }
        if(val >= 1l)
          *((signed long int *)setdata) = val;

        if(CI_DEBUG_LEVEL >= 2)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Setting parameter :%s=%lld\n", directive, (signed long long int)val);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Setting parameter :%s=%lld\n", directive, (signed long long int)val);

        }

        return 1;
      }
    }
  }
}

// ci_client_connect_to
// file request_common.c line 984
struct ci_connection * ci_client_connect_to(char *servername, signed int port, signed int proto)
{
  struct ci_connection *connection;
  void *return_value;
  return_value=__intl_malloc((signed int)sizeof(struct ci_connection) /*88ul*/ );
  connection = (struct ci_connection *)return_value;
  char hostname[257l];
  unsigned int addrlen = (unsigned int)0;
  char errBuf[512l];
  signed int errNo;
  signed int *return_value___errno_location_1;
  char *return_value_ci_strerror_2;
  signed int *return_value___errno_location_3;
  char *return_value_ci_strerror_4;
  signed int *return_value___errno_location_6;
  signed int *return_value___errno_location_7;
  char *return_value_ci_strerror_8;
  signed int *return_value___errno_location_9;
  signed int *return_value___errno_location_10;
  char *return_value_ci_strerror_11;
  char *return_value_ci_strerror_13;
  char *return_value_ci_strerror_14;
  signed int *return_value___errno_location_16;
  char *return_value_ci_strerror_17;
  signed int *return_value___errno_location_18;
  char *return_value_ci_strerror_19;
  if(connection == ((struct ci_connection *)NULL))
    return (struct ci_connection *)(void *)0;

  else
  {
    signed int return_value_ci_host_to_sockaddr_t_5;
    return_value_ci_host_to_sockaddr_t_5=ci_host_to_sockaddr_t(servername, &connection->srvaddr, proto);
    if(return_value_ci_host_to_sockaddr_t_5 == 0)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        {
          return_value___errno_location_1=__errno_location();
          return_value_ci_strerror_2=ci_strerror(*return_value___errno_location_1, errBuf, sizeof(char [512l]) /*512ul*/ );
          __log_error((void *)0, "Error getting address info for host '%s': %s\n", servername, return_value_ci_strerror_2);
        }

        if(!(CI_DEBUG_STDOUT == 0))
        {
          return_value___errno_location_3=__errno_location();
          return_value_ci_strerror_4=ci_strerror(*return_value___errno_location_3, errBuf, sizeof(char [512l]) /*512ul*/ );
          printf("Error getting address info for host '%s': %s\n", servername, return_value_ci_strerror_4);
        }

      }

      close(connection->fd);
      __intl_free((void *)connection);
      return (struct ci_connection *)(void *)0;
    }

    else
    {
      ci_sockaddr_set_port(&connection->srvaddr, port);
      connection->fd=socket(connection->srvaddr.ci_sin_family, 1, 0);
      if(connection->fd == -1)
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          {
            return_value___errno_location_6=__errno_location();
            return_value___errno_location_7=__errno_location();
            return_value_ci_strerror_8=ci_strerror(*return_value___errno_location_7, errBuf, sizeof(char [512l]) /*512ul*/ );
            __log_error((void *)0, "Error opening socket :%d:%s....\n", *return_value___errno_location_6, return_value_ci_strerror_8);
          }

          if(!(CI_DEBUG_STDOUT == 0))
          {
            return_value___errno_location_9=__errno_location();
            return_value___errno_location_10=__errno_location();
            return_value_ci_strerror_11=ci_strerror(*return_value___errno_location_10, errBuf, sizeof(char [512l]) /*512ul*/ );
            printf("Error opening socket :%d:%s....\n", *return_value___errno_location_9, return_value_ci_strerror_11);
          }

        }

        __intl_free((void *)connection);
        return (struct ci_connection *)(void *)0;
      }

      else
      {
        addrlen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
        signed int return_value_connect_15;
        return_value_connect_15=connect(connection->fd, (struct sockaddr *)&connection->srvaddr.sockaddr, addrlen);
        if(!(return_value_connect_15 == 0))
        {
          signed int *return_value___errno_location_12;
          return_value___errno_location_12=__errno_location();
          errNo = *return_value___errno_location_12;
          ci_sockaddr_t_to_host(&connection->srvaddr, hostname, 256);
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            {
              return_value_ci_strerror_13=ci_strerror(errNo, errBuf, sizeof(char [512l]) /*512ul*/ );
              __log_error((void *)0, "Error connecting to host  '%s': %s \n", (const void *)hostname, return_value_ci_strerror_13);
            }

            if(!(CI_DEBUG_STDOUT == 0))
            {
              return_value_ci_strerror_14=ci_strerror(errNo, errBuf, sizeof(char [512l]) /*512ul*/ );
              printf("Error connecting to host  '%s': %s \n", (const void *)hostname, return_value_ci_strerror_14);
            }

          }

          close(connection->fd);
          __intl_free((void *)connection);
          return (struct ci_connection *)(void *)0;
        }

        addrlen = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
        signed int return_value_getsockname_20;
        return_value_getsockname_20=getsockname(connection->fd, (struct sockaddr *)&connection->claddr.sockaddr, &addrlen);
        if(!(return_value_getsockname_20 == 0))
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            {
              return_value___errno_location_16=__errno_location();
              return_value_ci_strerror_17=ci_strerror(*return_value___errno_location_16, errBuf, sizeof(char [512l]) /*512ul*/ );
              __log_error((void *)0, "Error getting client sockname: %s\n", return_value_ci_strerror_17);
            }

            if(!(CI_DEBUG_STDOUT == 0))
            {
              return_value___errno_location_18=__errno_location();
              return_value_ci_strerror_19=ci_strerror(*return_value___errno_location_18, errBuf, sizeof(char [512l]) /*512ul*/ );
              printf("Error getting client sockname: %s\n", return_value_ci_strerror_19);
            }

          }

          close(connection->fd);
          __intl_free((void *)connection);
          return (struct ci_connection *)(void *)0;
        }

        else
        {
          ci_fill_sockaddr(&connection->claddr);
          ci_fill_sockaddr(&connection->srvaddr);
          ci_netio_init(connection->fd);
          return connection;
        }
      }
    }
  }
}

// ci_client_get_server_options
// file request_common.c line 962
signed int ci_client_get_server_options(struct ci_request *req, signed int timeout)
{
  signed int return_value_client_create_request_1;
  return_value_client_create_request_1=client_create_request(req, req->req_server, req->service, 0x01);
  signed int return_value_client_parse_icap_header_2;
  if(!(return_value_client_create_request_1 == 1))
    return -1;

  else
  {
    client_send_request_headers(req, 0, timeout);
    do
    {
      ci_wait_for_data(req->connection->fd, timeout, 0x1);
      signed int return_value_net_data_read_3;
      return_value_net_data_read_3=net_data_read(req);
      if(return_value_net_data_read_3 == -1)
        return -1;

      return_value_client_parse_icap_header_2=client_parse_icap_header(req, req->response_header);
    }
    while(return_value_client_parse_icap_header_2 == 2);
    ci_headers_unpack(req->response_header);
    get_request_options(req, req->response_header);
    return 1;
  }
}

// ci_client_http_headers_completed
// file request_common.c line 1422
signed int ci_client_http_headers_completed(struct ci_request *req)
{
  return (signed int)(req->status >= 2);
}

// ci_client_icapfilter
// file request_common.c line 1303
signed int ci_client_icapfilter(struct ci_request *req, signed int timeout, struct ci_headers_list *req_headers, struct ci_headers_list *resp_headers, void *data_source, signed int (*source_read)(void *, char *, signed int), void *data_dest, signed int (*dest_write)(void *, char *, signed int))
{
  signed int i;
  signed int ret;
  signed int v1;
  signed int v2;
  signed int remains;
  signed int pre_eof = 0;
  signed int preview_status;
  char *buf;
  const char *val;
  signed int return_value_client_create_request_1;
  return_value_client_create_request_1=client_create_request(req, req->req_server, req->service, req->type);
  signed int return_value_client_parse_icap_header_3;
  if(!(return_value_client_create_request_1 == 1))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error making respmod request ....\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error making respmod request ....\n");

    }

    return -1;
  }

  else
  {
    if(data_source == NULL)
      req->preview = -1;

    if(req->preview >= 1)
    {
      ci_buf_mem_alloc(&req->preview_data, req->preview);
      buf = req->preview_data.buf;
      remains = req->preview;
      if(pre_eof == 0 && !(remains == 0))
      {
        ret=source_read(data_source, buf, remains);
        if(!(ret >= 1))
          pre_eof = 1;

        else
          remains = remains - ret;
      }

      req->preview = req->preview - remains;
      req->preview_data.used = req->preview;
    }

    if(!(pre_eof == 0))
      req->eof_received = 1;

    signed int return_value_client_build_headers_2;
    return_value_client_build_headers_2=client_build_headers(req, (signed int)(req_headers != (struct ci_headers_list *)(void *)0), (signed int)(resp_headers != (struct ci_headers_list *)(void *)0), (signed int)(data_source != (void *)0));
    if(return_value_client_build_headers_2 == 0)
      return -1;

    else
    {
      if(!(req_headers == ((struct ci_headers_list *)NULL)))
      {
        if(CI_DEBUG_LEVEL >= 5)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Going to add %d request headers\n", req_headers->used);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Going to add %d request headers\n", req_headers->used);

        }

        i = 0;
        for( ; !(i >= req_headers->used); i = i + 1)
        {
          if(CI_DEBUG_LEVEL >= 8)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Add request header: %s\n", req_headers->headers[(signed long int)i]);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Add request header: %s\n", req_headers->headers[(signed long int)i]);

          }

          ci_http_request_add_header(req, req_headers->headers[(signed long int)i]);
        }
      }

      if(!(resp_headers == ((struct ci_headers_list *)NULL)))
      {
        if(CI_DEBUG_LEVEL >= 5)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Going to add %d response headers\n", resp_headers->used);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Going to add %d response headers\n", resp_headers->used);

        }

        i = 0;
        for( ; !(i >= resp_headers->used); i = i + 1)
        {
          if(CI_DEBUG_LEVEL >= 8)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Add resp header: %s\n", resp_headers->headers[(signed long int)i]);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Add resp header: %s\n", resp_headers->headers[(signed long int)i]);

          }

          ci_http_response_add_header(req, resp_headers->headers[(signed long int)i]);
        }
      }

      ret=client_send_request_headers(req, pre_eof, timeout);
      if(!(ret >= 0))
        return -1;

      else
      {
        i = 0;
        for( ; !(req->entities[(signed long int)i] == ((struct ci_encaps_entity *)NULL)); i = i + 1)
          ci_request_release_entity(req, i);
        preview_status = 100;
        if(req->preview >= 0)
        {
          do
          {
            ci_wait_for_data(req->connection->fd, timeout, 0x1);
            signed int return_value_net_data_read_4;
            return_value_net_data_read_4=net_data_read(req);
            if(return_value_net_data_read_4 == -1)
              return -1;

            return_value_client_parse_icap_header_3=client_parse_icap_header(req, req->response_header);
          }
          while(return_value_client_parse_icap_header_3 == 2);
          sscanf(req->response_header->buf, "ICAP/%d.%d %d", &v1, &v2, &preview_status);
          if(CI_DEBUG_LEVEL >= 3)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Preview response was with status: %d \n", preview_status);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Preview response was with status: %d \n", preview_status);

          }

          if(preview_status == 204)
            ci_headers_unpack(req->response_header);

          else
            if(preview_status == 206 || preview_status == 200 && !(req->eof_received == 0))
            {
              ci_headers_unpack(req->response_header);
              val=ci_headers_search(req->response_header, "Encapsulated");
              if(val == ((const char *)NULL))
              {
                if(CI_DEBUG_LEVEL >= 1)
                {
                  if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                    __log_error((void *)0, "No encapsulated entities!\n");

                  if(!(CI_DEBUG_STDOUT == 0))
                    printf("No encapsulated entities!\n");

                }

                return -1;
              }

              process_encapsulated(req, val);
              if(req->entities[1l] == ((struct ci_encaps_entity *)NULL))
                req->status = 3;

              else
                req->status = 1;
            }

            else
              ci_headers_reset(req->response_header);
        }

        if(preview_status == 204 || preview_status == 206)
          return preview_status;

        else
        {
          ret=client_send_get_data(req, timeout, data_source, source_read, data_dest, dest_write);
          if(preview_status == 206 && ret == 1)
            return 206;

          else
            return ret;
        }
      }
    }
  }
}

// ci_client_request
// file request_common.c line 662
struct ci_request * ci_client_request(struct ci_connection *conn, char *server, char *service)
{
  struct ci_request *req;
  req=ci_request_alloc(conn);
  if(req == ((struct ci_request *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error allocation ci_request_t object(ci_client_request())\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error allocation ci_request_t object(ci_client_request())\n");

    }

    return (struct ci_request *)(void *)0;
  }

  else
  {
    strncpy(req->req_server, server, (unsigned long int)256);
    req->req_server[(signed long int)256] = (char)0;
    strncpy(req->service, service, (unsigned long int)63);
    req->service[(signed long int)63] = (char)0;
    return req;
  }
}

// ci_client_request_reuse
// file request_common.c line 679
void ci_client_request_reuse(struct ci_request *req)
{
  signed int i;
  req->packed = 0;
  req->args[(signed long int)0] = (char)0;
  req->type = -1;
  ci_buf_reset(&req->preview_data);
  req->hasbody = 0;
  req->responce_hasbody = 0;
  ci_headers_reset(req->request_header);
  ci_headers_reset(req->response_header);
  ci_headers_reset(req->xheaders);
  req->eof_received = 0;
  req->status = 0;
  req->pstrblock_read = (char *)(void *)0;
  req->pstrblock_read_len = 0;
  req->current_chunk_len = (unsigned int)0;
  req->chunk_bytes_read = (unsigned int)0;
  req->pstrblock_responce = (char *)(void *)0;
  req->remain_send_block_bytes = 0;
  req->write_to_module_pending = (unsigned int)0;
  req->data_locked = 1;
  req->allow204 = 0;
  req->allow206 = 0;
  req->i206_use_original_body = (signed long int)-1;
  req->bytes_in = (unsigned long int)0;
  req->bytes_out = (unsigned long int)0;
  req->http_bytes_in = (unsigned long int)0;
  req->http_bytes_out = (unsigned long int)0;
  req->body_bytes_in = (unsigned long int)0;
  req->body_bytes_out = (unsigned long int)0;
  i = 0;
  for( ; !(req->entities[(signed long int)i] == ((struct ci_encaps_entity *)NULL)); i = i + 1)
    ci_request_release_entity(req, i);
}

// ci_connection_destroy
// file net_io.c line 191
void ci_connection_destroy(struct ci_connection *connection)
{
  if(!(connection == ((struct ci_connection *)NULL)))
  {
    if(connection->fd >= 0)
      close(connection->fd);

    free((void *)connection);
  }

}

// ci_copy_connection
// file net_io.c line 162
void ci_copy_connection(struct ci_connection *dest, struct ci_connection *src)
{
  dest->fd = src->fd;
  ci_copy_sockaddr(&dest->claddr, &src->claddr);
  ci_copy_sockaddr(&dest->srvaddr, &src->srvaddr);
}

// ci_copy_sockaddr
// file net_io.c line 68
void ci_copy_sockaddr(struct ci_sockaddr *dest, struct ci_sockaddr *src)
{
  memcpy((void *)dest, (const void *)src, sizeof(struct ci_sockaddr) /*40ul*/ );
  dest->ci_sin_addr = (void *)&dest->sockaddr.sin_addr;
}

// ci_create_os_allocator
// file ../include/mem.h line 47
struct ci_mem_allocator * ci_create_os_allocator()
{
  struct ci_mem_allocator *ci_create_os_allocator__1__allocator;
  ci_create_os_allocator__1__allocator=alloc_mem_allocator_struct();
  if(ci_create_os_allocator__1__allocator == ((struct ci_mem_allocator *)NULL))
    return (struct ci_mem_allocator *)(void *)0;

  else
  {
    ci_create_os_allocator__1__allocator->alloc = os_allocator_alloc;
    ci_create_os_allocator__1__allocator->free = os_allocator_free;
    ci_create_os_allocator__1__allocator->reset = os_allocator_reset;
    ci_create_os_allocator__1__allocator->destroy = os_allocator_destroy;
    ci_create_os_allocator__1__allocator->data = (void *)0;
    ci_create_os_allocator__1__allocator->name = (char *)(void *)0;
    ci_create_os_allocator__1__allocator->type = 0;
    return ci_create_os_allocator__1__allocator;
  }
}

// ci_create_pack_allocator
// file mem.c line 687
struct ci_mem_allocator * ci_create_pack_allocator(char *memblock, unsigned long int size)
{
  struct ci_mem_allocator *ci_create_pack_allocator__1__allocator;
  struct pack_allocator *pack_alloc;
  void *return_value_ci_object_pool_alloc_1;
  return_value_ci_object_pool_alloc_1=ci_object_pool_alloc(PACK_ALLOCATOR_POOL);
  pack_alloc = (struct pack_allocator *)return_value_ci_object_pool_alloc_1;
  if(pack_alloc == ((struct pack_allocator *)NULL))
    return (struct ci_mem_allocator *)(void *)0;

  else
  {
    ci_create_pack_allocator__1__allocator=alloc_mem_allocator_struct();
    if(ci_create_pack_allocator__1__allocator == ((struct ci_mem_allocator *)NULL))
    {
      ci_object_pool_free((void *)pack_alloc);
      return (struct ci_mem_allocator *)(void *)0;
    }

    else
    {
      struct ci_mem_allocator *return_value_init_pack_allocator_2;
      return_value_init_pack_allocator_2=init_pack_allocator(ci_create_pack_allocator__1__allocator, pack_alloc, memblock, size, 2);
      return return_value_init_pack_allocator_2;
    }
  }
}

// ci_create_pack_allocator_on_memblock
// file mem.c line 704
struct ci_mem_allocator * ci_create_pack_allocator_on_memblock(char *memblock, unsigned long int size)
{
  struct ci_mem_allocator *ci_create_pack_allocator_on_memblock__1__allocator;
  if(!(size >= 97ul))
    return (struct ci_mem_allocator *)(void *)0;

  else
  {
    struct pack_allocator *pack_alloc = (struct pack_allocator *)memblock;
    memblock = memblock + (signed long int)(sizeof(struct pack_allocator) /*40ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1));
    size = size - (sizeof(struct pack_allocator) /*40ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1));
    ci_create_pack_allocator_on_memblock__1__allocator = (struct ci_mem_allocator *)memblock;
    memblock = memblock + (signed long int)(sizeof(struct ci_mem_allocator) /*56ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1));
    size = size - (sizeof(struct ci_mem_allocator) /*56ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1));
    struct ci_mem_allocator *return_value_init_pack_allocator_1;
    return_value_init_pack_allocator_1=init_pack_allocator(ci_create_pack_allocator_on_memblock__1__allocator, pack_alloc, memblock, size, 0);
    return return_value_init_pack_allocator_1;
  }
}

// ci_create_pool_allocator
// file mem.c line 888
struct ci_mem_allocator * ci_create_pool_allocator(signed int items_size)
{
  struct pool_allocator *palloc;
  struct ci_mem_allocator *ci_create_pool_allocator__1__allocator;
  palloc=pool_allocator_build(items_size, 0);
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct ci_mem_allocator) /*56ul*/ );
  ci_create_pool_allocator__1__allocator = (struct ci_mem_allocator *)return_value_malloc_1;
  if(ci_create_pool_allocator__1__allocator == ((struct ci_mem_allocator *)NULL))
    return (struct ci_mem_allocator *)(void *)0;

  else
  {
    ci_create_pool_allocator__1__allocator->alloc = pool_allocator_alloc;
    ci_create_pool_allocator__1__allocator->free = pool_allocator_free;
    ci_create_pool_allocator__1__allocator->reset = pool_allocator_reset;
    ci_create_pool_allocator__1__allocator->destroy = pool_allocator_destroy;
    ci_create_pool_allocator__1__allocator->data = (void *)palloc;
    ci_create_pool_allocator__1__allocator->name = (char *)(void *)0;
    ci_create_pool_allocator__1__allocator->type = 2;
    ci_create_pool_allocator__1__allocator->must_free = 1;
    return ci_create_pool_allocator__1__allocator;
  }
}

// ci_create_serial_allocator
// file include/mem.h line 48
struct ci_mem_allocator * ci_create_serial_allocator(signed int size)
{
  struct ci_mem_allocator *ci_create_serial_allocator__1__allocator;
  struct serial_allocator *sdata;
  sdata=serial_allocator_build(size);
  void *return_value_serial_allocation_1;
  return_value_serial_allocation_1=serial_allocation(sdata, sizeof(struct ci_mem_allocator) /*56ul*/ );
  ci_create_serial_allocator__1__allocator = (struct ci_mem_allocator *)return_value_serial_allocation_1;
  if(ci_create_serial_allocator__1__allocator == ((struct ci_mem_allocator *)NULL))
  {
    ci_buffer_free((void *)sdata);
    return (struct ci_mem_allocator *)(void *)0;
  }

  else
  {
    ci_create_serial_allocator__1__allocator->alloc = serial_allocator_alloc;
    ci_create_serial_allocator__1__allocator->free = serial_allocator_free;
    ci_create_serial_allocator__1__allocator->reset = serial_allocator_reset;
    ci_create_serial_allocator__1__allocator->destroy = serial_allocator_destroy;
    ci_create_serial_allocator__1__allocator->data = (void *)sdata;
    ci_create_serial_allocator__1__allocator->name = (char *)(void *)0;
    ci_create_serial_allocator__1__allocator->type = 1;
    ci_create_serial_allocator__1__allocator->must_free = 0;
    return ci_create_serial_allocator__1__allocator;
  }
}

// ci_dyn_array_add
// file array.c line 269
const struct ci_array_item * ci_dyn_array_add(struct ci_dyn_array *array, const char *name, const void *value, unsigned long int size)
{
  struct ci_array_item *item;
  struct ci_array_item **items_space;
  struct ci_mem_allocator *packer = array->alloc;
  signed int name_size;
  if(array->count == array->max_items)
  {
    void *return_value_ci_buffer_realloc_1;
    return_value_ci_buffer_realloc_1=ci_buffer_realloc((void *)array->items, (signed int)((unsigned long int)(array->max_items + 32) * sizeof(struct ci_array_item *) /*8ul*/ ));
    items_space = (struct ci_array_item **)return_value_ci_buffer_realloc_1;
    if(items_space == ((struct ci_array_item **)NULL))
      return (const struct ci_array_item *)(void *)0;

    array->items = items_space;
    array->max_items = array->max_items + 32;
  }

  /* assertion packer */
  assert(packer != ((struct ci_mem_allocator *)NULL));
  void *return_value;
  return_value=packer->alloc(packer, sizeof(struct ci_array_item) /*16ul*/ );
  item = (struct ci_array_item *)return_value;
  if(item == ((struct ci_array_item *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Not enough space to add the new item %s to array!\n", name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Not enough space to add the new item %s to array!\n", name);

    }

    return (const struct ci_array_item *)(void *)0;
  }

  else
  {
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(name);
    name_size = (signed int)(return_value_strlen_2 + (unsigned long int)1);
    void *return_value_1;
    return_value_1=packer->alloc(packer, (unsigned long int)name_size);
    item->name = (char *)return_value_1;
    if(size >= 1ul)
      item->value=packer->alloc(packer, size);

    else
      item->value = (void *)0;
    _Bool tmp_if_expr_3;
    if(item->name == ((char *)NULL))
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = (!(item->value != NULL) ? (size > (unsigned long int)0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
    {
      if(CI_DEBUG_LEVEL >= 2)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Not enough space to add the new item %s to array!\n", name);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Not enough space to add the new item %s to array!\n", name);

      }

      if(!(item->name == ((char *)NULL)))
        packer->free(packer, (void *)item->name);

      if(!(item->value == NULL))
        packer->free(packer, item->value);

      packer->free(packer, (void *)item);
      return (const struct ci_array_item *)(void *)0;
    }

    else
    {
      memcpy((void *)item->name, (const void *)name, (unsigned long int)name_size);
      if(size >= 1ul)
        memcpy(item->value, value, size);

      else
        item->value = (void *)value;
      signed int tmp_post_4 = array->count;
      array->count = array->count + 1;
      array->items[(signed long int)tmp_post_4] = item;
      return item;
    }
  }
}

// ci_dyn_array_destroy
// file array.c line 260
void ci_dyn_array_destroy(struct ci_dyn_array *array)
{
  if(!(array->items == ((struct ci_array_item **)NULL)))
    ci_buffer_free((void *)array->items);

  if(!(array->alloc == ((struct ci_mem_allocator *)NULL)))
    ci_mem_allocator_destroy(array->alloc);

}

// ci_dyn_array_iterate
// file array.c line 329
void ci_dyn_array_iterate(const struct ci_dyn_array *array, void *data, signed int (*fn)(void *, const char *, const void *))
{
  signed int i;
  signed int ret = 0;
  i = 0;
  if(ret == 0 && !(i >= array->count))
  {
    ret=fn(data, array->items[(signed long int)i]->name, array->items[(signed long int)i]->value);
    i = i + 1;
  }

}

// ci_dyn_array_new
// file array.c line 212
struct ci_dyn_array * ci_dyn_array_new(unsigned long int size)
{
  unsigned long int index_memory = size / (unsigned long int)4;
  unsigned long int items_memory = size - index_memory;
  unsigned long int items_count = index_memory / sizeof(struct ci_array_item *) /*8ul*/ ;
  unsigned long int item_size = items_memory / items_count;
  if(!(item_size >= sizeof(struct ci_array_item) /*16ul*/ ))
    item_size = sizeof(struct ci_array_item) /*16ul*/ ;

  struct ci_dyn_array *return_value_ci_dyn_array_new2_1;
  return_value_ci_dyn_array_new2_1=ci_dyn_array_new2(items_count, item_size);
  return return_value_ci_dyn_array_new2_1;
}

// ci_dyn_array_new2
// file array.c line 225
struct ci_dyn_array * ci_dyn_array_new2(unsigned long int items, unsigned long int item_size)
{
  struct ci_dyn_array *array;
  struct ci_mem_allocator *packer;
  unsigned long int array_size = (sizeof(struct ci_dyn_array) /*24ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + items * ((item_size + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + (sizeof(struct ci_array_item) /*16ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + ((unsigned long int)16 + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)));
  packer=ci_create_serial_allocator((signed int)array_size);
  if(packer == ((struct ci_mem_allocator *)NULL))
    return (struct ci_dyn_array *)(void *)0;

  else
  {
    void *return_value;
    return_value=packer->alloc(packer, sizeof(struct ci_dyn_array) /*24ul*/ );
    array = (struct ci_dyn_array *)return_value;
    if(array == ((struct ci_dyn_array *)NULL))
    {
      ci_mem_allocator_destroy(packer);
      return (struct ci_dyn_array *)(void *)0;
    }

    else
    {
      if(!(items >= 32ul))
        items = (unsigned long int)32;

      array->max_items = (signed int)items;
      void *return_value_ci_buffer_alloc_1;
      return_value_ci_buffer_alloc_1=ci_buffer_alloc((signed int)(items * sizeof(struct ci_array_item *) /*8ul*/ ));
      array->items = (struct ci_array_item **)return_value_ci_buffer_alloc_1;
      array->count = 0;
      array->alloc = packer;
      return array;
    }
  }
}

// ci_dyn_array_search
// file array.c line 317
const void * ci_dyn_array_search(struct ci_dyn_array *array, const char *name)
{
  struct ci_array_item *item;
  signed int i = 0;
  signed int return_value_strcmp_1;
  for( ; !(i >= array->count); i = i + 1)
  {
    return_value_strcmp_1=strcmp(array->items[(signed long int)i]->name, name);
    if(return_value_strcmp_1 == 0)
      return array->items[(signed long int)i]->value;

  }
  return (void *)0;
}

// ci_extend_filetype
// file filetype.c line 661
signed int ci_extend_filetype(struct ci_magics_db *db, struct ci_request *req, const char *buf, signed int len, signed int *iscompressed)
{
  struct ci_headers_list *heads;
  if(req->type == 0x04)
    heads=ci_http_response_headers(req);

  else
    heads = (struct ci_headers_list *)(void *)0;
  signed int return_value_extend_object_type_1;
  return_value_extend_object_type_1=extend_object_type(db, heads, buf, len, iscompressed);
  return return_value_extend_object_type_1;
}

// ci_filetype
// file filetype.c line 541
signed int ci_filetype(struct ci_magics_db *db, const char *buf, signed int buflen)
{
  signed int ret;
  ret=check_magics(db, buf, buflen);
  if(ret >= 0)
    return ret;

  else
  {
    ret=check_ascii((unsigned char *)buf, buflen);
    if(ret >= 0)
      return ret;

    else
    {
      ret=check_unicode((unsigned char *)buf, buflen);
      if(ret >= 0)
        return 3;

      else
        return 5;
    }
  }
}

// ci_fill_ip_t
// file net_io.c line 75
void ci_fill_ip_t(struct ci_ip *ip_dest, struct ci_sockaddr *src)
{
  ip_dest->family = src->ci_sin_family;
  memcpy((void *)&ip_dest->address, src->ci_sin_addr, sizeof(struct in_addr) /*4ul*/ );
  ip_dest->netmask.s_addr=htonl(0xFFFFFFFF);
}

// ci_fill_sockaddr
// file include/net_io.h line 115
void ci_fill_sockaddr(struct ci_sockaddr *addr)
{
  addr->ci_sin_family = (signed int)addr->sockaddr.sin_family;
  addr->ci_sin_port = (signed int)addr->sockaddr.sin_port;
  addr->ci_sin_addr = (void *)&addr->sockaddr.sin_addr;
  addr->ci_inaddr_len = (signed int)sizeof(struct in_addr) /*4ul*/ ;
}

// ci_format_text
// file txt_format.c line 240
signed int ci_format_text(struct ci_request *req_data, const char *fmt, char *buffer, signed int len, struct ci_fmt_entry *user_table)
{
  const char *s;
  char *b;
  char *lb;
  struct ci_fmt_entry *fmte;
  signed int directive_len;
  signed int val_len;
  signed int remains;
  signed int left_align;
  signed int i;
  unsigned int width;
  unsigned int space = (unsigned int)0;
  char parameter[256l];
  lb = (char *)(void *)0;
  s = fmt;
  b = buffer;
  remains = len - 1;
  void *return_value_malloc_1;
  while(!(*s == 0))
  {
    if(!(remains >= 1))
      break;

    if((signed int)*s == 37)
    {
      fmte=check_tables(s, user_table, &directive_len, &width, &left_align, parameter);
      if(CI_DEBUG_LEVEL >= 7)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Width: %d, Parameter:%s\n", width, (const void *)parameter);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Width: %d, Parameter:%s\n", width, (const void *)parameter);

      }

      if(!(width == 0u))
      {
        width = (unsigned int)remains < width ? (unsigned int)remains : width;
        space = width;
      }

      else
        space = (unsigned int)remains;
      if(!(fmte == ((struct ci_fmt_entry *)NULL)))
      {
        if(!(width == 0u))
        {
          if(!(left_align == 0))
          {
            val_len=fmte->format(req_data, b, (signed int)space, parameter);
            if(!(val_len >= 1))
              val_len=fmt_none(req_data, b, (signed int)space, parameter);

            if(!(space >= (unsigned int)val_len))
              val_len = (signed int)space;

            b = b + (signed long int)val_len;
            i = 0;
            if(!((unsigned int)i >= width + -((unsigned int)val_len)))
            {
              b[(signed long int)i] = (char)32;
              i = i + 1;
            }

            b = b + (signed long int)(width - (unsigned int)val_len);
          }

          else
          {
            return_value_malloc_1=malloc((unsigned long int)(space + (unsigned int)1) * sizeof(char) /*1ul*/ );
            lb = (char *)return_value_malloc_1;
            if(!(lb == ((char *)NULL)))
            {
              val_len=fmte->format(req_data, lb, (signed int)space, parameter);
              if(!(val_len >= 1))
                val_len=fmt_none(req_data, lb, (signed int)space, parameter);

              if(!(space >= (unsigned int)val_len))
                val_len = (signed int)space;

              i = 0;
              if(!((unsigned int)i >= width + -((unsigned int)val_len)))
              {
                b[(signed long int)i] = (char)32;
                i = i + 1;
              }

              b = b + (signed long int)(width - (unsigned int)val_len);
              i = 0;
              if(!(i >= val_len))
              {
                b[(signed long int)i] = lb[(signed long int)i];
                i = i + 1;
              }

              b = b + (signed long int)val_len;
              free((void *)lb);
              lb = (char *)(void *)0;
            }

          }
          remains = remains - (signed int)width;
        }

        else
        {
          val_len=fmte->format(req_data, b, (signed int)space, parameter);
          if(!(val_len >= 1))
            val_len=fmt_none(req_data, b, (signed int)space, parameter);

          if(!(space >= (unsigned int)val_len))
            val_len = (signed int)space;

          b = b + (signed long int)val_len;
          remains = remains - val_len;
        }
        s = s + (signed long int)directive_len;
      }

      else
      {
        char *tmp_post_2 = b;
        b = b + 1l;
        const char *tmp_post_3 = s;
        s = s + 1l;
        *tmp_post_2 = *tmp_post_3;
        remains = remains - 1;
      }
    }

    else
    {
      char *tmp_post_4 = b;
      b = b + 1l;
      const char *tmp_post_5 = s;
      s = s + 1l;
      *tmp_post_4 = *tmp_post_5;
      remains = remains - 1;
    }
  }
  *b = (char)0;
  return len - remains;
}

// ci_get_data_group_id
// file filetype.c line 143
signed int ci_get_data_group_id(struct ci_magics_db *db, const char *group)
{
  signed int i = 0;
  i = 0;
  for( ; !(i >= db->groups_num); i = i + 1)
  {
    signed int return_value_strcasecmp_1;
    return_value_strcasecmp_1=strcasecmp(group, (db->groups + (signed long int)i)->name);
    if(return_value_strcasecmp_1 == 0)
      return i;

  }
  return -1;
}

// ci_get_data_type_id
// file filetype.c line 133
signed int ci_get_data_type_id(struct ci_magics_db *db, const char *name)
{
  signed int i = 0;
  i = 0;
  for( ; !(i >= db->types_num); i = i + 1)
  {
    signed int return_value_strcasecmp_1;
    return_value_strcasecmp_1=strcasecmp(name, (db->types + (signed long int)i)->name);
    if(return_value_strcasecmp_1 == 0)
      return i;

  }
  return -1;
}

// ci_hard_close
// file os/unix/net_io.c line 359
signed int ci_hard_close(signed int fd)
{
  close(fd);
  return 1;
}

// ci_hash_add
// file include/hash.h line 54
void * ci_hash_add(struct ci_hash_table *htable, const void *key, const void *val)
{
  struct ci_hash_entry *e;
  unsigned int hash;
  unsigned long int return_value;
  return_value=htable->ops->size(key);
  hash=ci_hash_compute((unsigned long int)htable->hash_table_size, key, (signed int)return_value);
  /* assertion hash <= htable->hash_table_size */
  assert(hash <= htable->hash_table_size);
  void *return_value_1;
  return_value_1=htable->allocator->alloc(htable->allocator, sizeof(struct ci_hash_entry) /*32ul*/ );
  e = (struct ci_hash_entry *)return_value_1;
  if(e == ((struct ci_hash_entry *)NULL))
    return (void *)0;

  else
  {
    e->hnext = (struct ci_hash_entry *)(void *)0;
    e->key = key;
    e->val = val;
    e->hash = hash;
    e->hnext = htable->hash_table[(signed long int)hash];
    htable->hash_table[(signed long int)hash] = e;
    return (void *)e;
  }
}

// ci_hash_build
// file include/hash.h line 49
struct ci_hash_table * ci_hash_build(unsigned int hash_size, const struct ci_type_ops *ops, struct ci_mem_allocator *allocator)
{
  struct ci_hash_table *htable;
  unsigned int new_hash_size;
  void *return_value;
  return_value=allocator->alloc(allocator, sizeof(struct ci_hash_table) /*32ul*/ );
  htable = (struct ci_hash_table *)return_value;
  if(htable == ((struct ci_hash_table *)NULL))
    return (struct ci_hash_table *)(void *)0;

  else
  {
    new_hash_size = (unsigned int)63;
    if(hash_size >= 64u)
    {
      if(!(new_hash_size >= 16777215u) && !(new_hash_size >= hash_size))
      {
        new_hash_size = new_hash_size + 1u;
        new_hash_size = (new_hash_size << 1) - (unsigned int)1;
      }

    }

    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Build hash table of size: %d, memallocated:%d\n", new_hash_size, (unsigned long int)(new_hash_size + (unsigned int)1) * sizeof(struct ci_hash_entry *) /*8ul*/ );

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Build hash table of size: %d, memallocated:%d\n", new_hash_size, (unsigned long int)(new_hash_size + (unsigned int)1) * sizeof(struct ci_hash_entry *) /*8ul*/ );

    }

    void *return_value_1;
    return_value_1=allocator->alloc(allocator, (unsigned long int)(new_hash_size + (unsigned int)1) * sizeof(struct ci_hash_entry *) /*8ul*/ );
    htable->hash_table = (struct ci_hash_entry **)return_value_1;
    if(htable->hash_table == ((struct ci_hash_entry **)NULL))
    {
      allocator->free(allocator, (void *)htable);
      return (struct ci_hash_table *)(void *)0;
    }

    else
    {
      memset((void *)htable->hash_table, 0, (unsigned long int)(new_hash_size + (unsigned int)1) * sizeof(struct ci_hash_entry *) /*8ul*/ );
      htable->hash_table_size = new_hash_size;
      htable->ops = ops;
      htable->allocator = allocator;
      return htable;
    }
  }
}

// ci_hash_compute
// file include/hash.h line 48
unsigned int ci_hash_compute(unsigned long int hash_max_value, const void *key, signed int len)
{
  unsigned long int hash = (unsigned long int)5381;
  const unsigned char *s = (const unsigned char *)key;
  signed int i;
  if(!(len == 0))
  {
    i = 0;
    for( ; !(i >= len); s = s + 1l)
    {
      hash = (hash << 5) + hash + (unsigned long int)*s;
      i = i + 1;
    }
  }

  else
    for( ; !(*s == 0); s = s + 1l)
      hash = (hash << 5) + hash + (unsigned long int)*s;
  if(hash == 0ul)
    hash = hash + 1ul;

  hash = hash & hash_max_value;
  return (unsigned int)hash;
}

// ci_hash_destroy
// file include/hash.h line 52
void ci_hash_destroy(struct ci_hash_table *htable)
{
  signed int i;
  struct ci_hash_entry *e;
  struct ci_mem_allocator *ci_hash_destroy__1__allocator = htable->allocator;
  i = 0;
  for( ; htable->hash_table_size >= (unsigned int)i; i = i + 1)
    if(!(htable->hash_table[(signed long int)i] == ((struct ci_hash_entry *)NULL)))
    {
      e = htable->hash_table[(signed long int)i];
      htable->hash_table[(signed long int)i] = htable->hash_table[(signed long int)i]->hnext;
      ci_hash_destroy__1__allocator->free(ci_hash_destroy__1__allocator, (void *)e);
    }

  htable->allocator->free(ci_hash_destroy__1__allocator, (void *)htable->hash_table);
  ci_hash_destroy__1__allocator->free(ci_hash_destroy__1__allocator, (void *)htable);
}

// ci_hash_search
// file include/hash.h line 53
const void * ci_hash_search(struct ci_hash_table *htable, const void *key)
{
  struct ci_hash_entry *e;
  unsigned int hash;
  unsigned long int return_value;
  return_value=htable->ops->size(key);
  hash=ci_hash_compute((unsigned long int)htable->hash_table_size, key, (signed int)return_value);
  /* assertion hash <= htable->hash_table_size */
  assert(hash <= htable->hash_table_size);
  e = htable->hash_table[(signed long int)hash];
  if(!(e == ((struct ci_hash_entry *)NULL)))
  {
    signed int return_value_1;
    return_value_1=htable->ops->compare(e->key, key);
    if(return_value_1 == 0)
      return e->val;

    e = e->hnext;
  }

  return (void *)0;
}

// ci_headers_add
// file header.c line 220
const char * ci_headers_add(struct ci_headers_list *h, const char *line)
{
  char *newhead;
  char **newspace;
  char *newbuf;
  signed int len;
  signed int linelen;
  signed int i = 0;
  unsigned long int return_value_strlen_4;
  if(!(h->packed == 0))
    return (const char *)(void *)0;

  else
  {
    if(h->used == h->size)
    {
      len = h->size + 64;
      void *return_value_realloc_1;
      return_value_realloc_1=realloc((void *)h->headers, (unsigned long int)len * sizeof(char *) /*8ul*/ );
      newspace = (char **)return_value_realloc_1;
      if(newspace == ((char **)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Server Error:Error allocation memory \n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Server Error:Error allocation memory \n");

        }

        return (const char *)(void *)0;
      }

      h->headers = newspace;
      h->size = len;
    }

    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(line);
    linelen = (signed int)return_value_strlen_2;
    len = h->bufsize;
    for( ; !(len + -h->bufused >= 4 + linelen); len = len + 4096)
      ;
    if(!(h->bufsize >= len))
    {
      void *return_value_realloc_3;
      return_value_realloc_3=realloc((void *)h->buf, (unsigned long int)len * sizeof(char) /*1ul*/ );
      newbuf = (char *)return_value_realloc_3;
      if(newbuf == ((char *)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Server Error:Error allocation memory \n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Server Error:Error allocation memory \n");

        }

        return (const char *)(void *)0;
      }

      h->buf = newbuf;
      h->bufsize = len;
      h->headers[(signed long int)0] = h->buf;
      i = 1;
      for( ; !(i >= h->used); i = i + 1)
      {
        return_value_strlen_4=strlen(h->headers[(signed long int)(i - 1)]);
        h->headers[(signed long int)i] = h->headers[(signed long int)(i - 1)] + (signed long int)return_value_strlen_4 + (signed long int)2;
      }
    }

    newhead = h->buf + (signed long int)h->bufused;
    strcpy(newhead, line);
    h->bufused = h->bufused + linelen + 2;
    (newhead + (signed long int)linelen)[(signed long int)1] = (char)10;
    (newhead + (signed long int)linelen)[(signed long int)3] = (char)10;
    if(!(newhead == ((char *)NULL)))
    {
      signed int tmp_post_5 = h->used;
      h->used = h->used + 1;
      h->headers[(signed long int)tmp_post_5] = newhead;
    }

    return newhead;
  }
}

// ci_headers_addheaders
// file header.c line 269
signed int ci_headers_addheaders(struct ci_headers_list *h, const struct ci_headers_list *headers)
{
  signed int len;
  signed int i;
  char *newbuf;
  char **newspace;
  unsigned long int return_value_strlen_3;
  if(!(h->packed == 0))
    return 0;

  else
  {
    len = h->size;
    for( ; !(len + -h->used >= headers->used); len = len + 64)
      ;
    if(!(h->size >= len))
    {
      void *return_value_realloc_1;
      return_value_realloc_1=realloc((void *)h->headers, (unsigned long int)len * sizeof(char *) /*8ul*/ );
      newspace = (char **)return_value_realloc_1;
      if(newspace == ((char **)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Server Error: Error allocating memory \n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Server Error: Error allocating memory \n");

        }

        return 0;
      }

      h->headers = newspace;
      h->size = len;
    }

    len = h->bufsize;
    for( ; !(len + -h->bufused >= 2 + headers->bufused); len = len + 4096)
      ;
    if(!(h->bufsize >= len))
    {
      void *return_value_realloc_2;
      return_value_realloc_2=realloc((void *)h->buf, (unsigned long int)len * sizeof(char) /*1ul*/ );
      newbuf = (char *)return_value_realloc_2;
      if(newbuf == ((char *)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Server Error: Error allocating memory \n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Server Error: Error allocating memory \n");

        }

        return 0;
      }

      h->buf = newbuf;
      h->bufsize = len;
    }

    memcpy((void *)(h->buf + (signed long int)h->bufused), (const void *)headers->buf, (unsigned long int)(headers->bufused + 2));
    h->bufused = h->bufused + headers->bufused;
    h->used = h->used + headers->used;
    h->headers[(signed long int)0] = h->buf;
    i = 1;
    for( ; !(i >= h->used); i = i + 1)
    {
      return_value_strlen_3=strlen(h->headers[(signed long int)(i - 1)]);
      h->headers[(signed long int)i] = h->headers[(signed long int)(i - 1)] + (signed long int)return_value_strlen_3 + (signed long int)2;
    }
    return 1;
  }
}

// ci_headers_copy_value
// file header.c line 343
const char * ci_headers_copy_value(struct ci_headers_list *h, const char *header, char *buf, unsigned long int len)
{
  const char *phead;
  signed int i;
  phead=ci_headers_search(h, header);
  const unsigned short int **return_value___ctype_b_loc_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(phead == ((const char *)NULL))
    return (const char *)(void *)0;

  else
  {
    if(!(h->packed == 0))
      for( ; !((signed int)*phead == 0); phead = phead + 1l)
      {
        if((signed int)*phead == 58)
          break;

        if((signed int)*phead == 13)
          break;

        if((signed int)*phead == 10)
          break;

      }

    else
      for( ; !((signed int)*phead == 0); phead = phead + 1l)
        if((signed int)*phead == 58)
          break;

    if(!((signed int)*phead == 58))
      return (const char *)(void *)0;

    else
    {
      phead = phead + 1l;
      do
      {
        return_value___ctype_b_loc_1=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*phead]) == 0)
          break;

        if((signed int)*phead == 0)
          break;

        phead = phead + 1l;
      }
      while((_Bool)1);
      i = 0;
      do
      {
        if(!((unsigned long int)i >= len + 18446744073709551615ul))
          tmp_if_expr_2 = (signed int)*phead != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(tmp_if_expr_2)
          tmp_if_expr_3 = (signed int)*phead != 13 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_3 = (_Bool)0;
        if(tmp_if_expr_3)
          tmp_if_expr_4 = (signed int)*phead != 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        if(!tmp_if_expr_4)
          break;

        buf[(signed long int)i] = *phead;
        i = i + 1;
        phead = phead + 1l;
      }
      while((_Bool)1);
      buf[(signed long int)i] = (char)0;
      return buf;
    }
  }
}

// ci_headers_create
// file header.c line 156
struct ci_headers_list * ci_headers_create()
{
  struct ci_headers_list *h;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct ci_headers_list) /*40ul*/ );
  h = (struct ci_headers_list *)return_value_malloc_1;
  void *return_value_malloc_3;
  if(h == ((struct ci_headers_list *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error allocation memory for ci_headers_list_t (header.c: ci_headers_create)\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error allocation memory for ci_headers_list_t (header.c: ci_headers_create)\n");

    }

    return (struct ci_headers_list *)(void *)0;
  }

  else
  {
    h->headers = (char **)(void *)0;
    h->buf = (char *)(void *)0;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)64 * sizeof(char *) /*8ul*/ );
    h->headers = (char **)return_value_malloc_2;
    _Bool tmp_if_expr_4;
    if(h->headers == ((char **)NULL))
      tmp_if_expr_4 = (_Bool)1;

    else
    {
      return_value_malloc_3=malloc((unsigned long int)4096 * sizeof(char) /*1ul*/ );
      h->buf = (char *)return_value_malloc_3;
      tmp_if_expr_4 = !(h->buf != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_4)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Server Error: Error allocation memory \n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Server Error: Error allocation memory \n");

      }

      if(!(h->headers == ((char **)NULL)))
        free((void *)h->headers);

      if(!(h->buf == ((char *)NULL)))
        free((void *)h->buf);

      free((void *)h);
      return (struct ci_headers_list *)(void *)0;
    }

    else
    {
      h->size = 64;
      h->used = 0;
      h->bufsize = 4096;
      h->bufused = 0;
      h->packed = 0;
      return h;
    }
  }
}

// ci_headers_destroy
// file header.c line 186
void ci_headers_destroy(struct ci_headers_list *h)
{
  free((void *)h->headers);
  free((void *)h->buf);
  free((void *)h);
}

// ci_headers_iterate
// file header.c line 424
signed int ci_headers_iterate(struct ci_headers_list *h, void *data, void (*fn)(void *, const char *, const char *))
{
  char header[256l];
  char value[8196l];
  char *s;
  signed int i;
  signed int j;
  i = 0;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_11;
  if(!(i >= h->used))
  {
    s = h->headers[(signed long int)i];
    j = 0;
    do
    {
      if(!((unsigned long int)j >= 255ul))
        tmp_if_expr_1 = (signed int)*s != 58 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
        tmp_if_expr_2 = (signed int)*s != 32 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        tmp_if_expr_3 = (signed int)*s != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(tmp_if_expr_3)
        tmp_if_expr_4 = (signed int)*s != 13 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_4 = (_Bool)0;
      if(tmp_if_expr_4)
        tmp_if_expr_5 = (signed int)*s != 10 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      if(!tmp_if_expr_5)
        break;

      header[(signed long int)j] = *s;
      s = s + 1l;
      j = j + 1;
    }
    while((_Bool)1);
    header[(signed long int)j] = (char)0;
    j = 0;
    if((signed int)*s == 58)
      s = s + 1l;

    else
    {
      header[(signed long int)0] = (char)0;
      s = h->headers[(signed long int)i];
    }
    for( ; (signed int)*s == 32; s = s + 1l)
      ;
    j = 0;
    do
    {
      if(!((unsigned long int)j >= 8195ul))
        tmp_if_expr_6 = (signed int)*s != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_6 = (_Bool)0;
      if(tmp_if_expr_6)
      {
        if((signed int)*s == 13)
          tmp_if_expr_7 = (signed int)s[(signed long int)1] == 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_7 = (_Bool)0;
        if(tmp_if_expr_7)
          tmp_if_expr_8 = (signed int)s[(signed long int)2] != 9 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_8 = (_Bool)0;
        if(tmp_if_expr_8)
          tmp_if_expr_9 = (signed int)s[(signed long int)2] != 32 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_9 = (_Bool)0;
        if(tmp_if_expr_9)
          tmp_if_expr_12 = (_Bool)1;

        else
        {
          if((signed int)*s == 10)
            tmp_if_expr_10 = (signed int)s[(signed long int)1] != 9 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_10 = (_Bool)0;
          if(tmp_if_expr_10)
            tmp_if_expr_11 = (signed int)s[(signed long int)1] != 32 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_11 = (_Bool)0;
          tmp_if_expr_12 = tmp_if_expr_11 ? (_Bool)1 : (_Bool)0;
        }
        tmp_if_expr_13 = !tmp_if_expr_12 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_13 = (_Bool)0;
      if(!tmp_if_expr_13)
        break;

      value[(signed long int)j] = *s;
      s = s + 1l;
      j = j + 1;
    }
    while((_Bool)1);
    value[(signed long int)j] = (char)0;
    fn(data, header, value);
    i = i + 1;
  }

  return 1;
}

// ci_headers_pack
// file header.c line 451
void ci_headers_pack(struct ci_headers_list *h)
{
  signed int i = 0;
  signed int len = 0;
  i = 0;
  for( ; !(i >= h->used); i = i + 1)
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(h->headers[(signed long int)i]);
    len = (signed int)return_value_strlen_1;
    if((signed int)h->headers[(signed long int)i][(signed long int)(1 + len)] == 10)
      h->headers[(signed long int)i][(signed long int)len] = (char)13;

    else
      h->headers[(signed long int)i][(signed long int)len] = (char)10;
  }
  if((signed int)h->buf[(signed long int)(1 + h->bufused)] == 10)
  {
    h->buf[(signed long int)h->bufused] = (char)13;
    h->bufused = h->bufused + 2;
  }

  else
  {
    h->buf[(signed long int)h->bufused] = (char)10;
    h->bufused = h->bufused + 1;
  }
  h->packed = 1;
}

// ci_headers_remove
// file header.c line 369
signed int ci_headers_remove(struct ci_headers_list *h, const char *header)
{
  char *phead;
  signed int i;
  signed int j;
  signed int header_len;
  signed int rest_len;
  if(!(h->packed == 0))
    return 0;

  else
  {
    i = 0;
    for( ; !(i >= h->used); i = i + 1)
    {
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(header);
      signed int return_value_strncasecmp_3;
      return_value_strncasecmp_3=strncasecmp(h->headers[(signed long int)i], header, return_value_strlen_2);
      if(return_value_strncasecmp_3 == 0)
      {
        phead = h->headers[(signed long int)i];
        if(i == h->used + -1)
        {
          phead = h->headers[(signed long int)i];
          *phead = (char)13;
          phead[(signed long int)1] = (char)10;
          h->bufused = (signed int)(phead - h->buf);
          h->used = h->used - 1;
          return 1;
        }

        else
        {
          header_len = (signed int)(h->headers[(signed long int)(i + 1)] - h->headers[(signed long int)i]);
          rest_len = (signed int)(((signed long int)h->bufused - (h->headers[(signed long int)i] - h->buf)) - (signed long int)header_len);
          if(CI_DEBUG_LEVEL >= 5)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "remove_header : remain len %d\n", rest_len);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("remove_header : remain len %d\n", rest_len);

          }

          memmove((void *)phead, (const void *)h->headers[(signed long int)(i + 1)], (unsigned long int)rest_len);
          h->bufused = h->bufused - header_len;
          h->used = h->used - 1;
          j = i + 1;
          for( ; !(j >= h->used); j = j + 1)
          {
            unsigned long int return_value_strlen_1;
            return_value_strlen_1=strlen(h->headers[(signed long int)(j - 1)]);
            header_len = (signed int)return_value_strlen_1;
            h->headers[(signed long int)j] = h->headers[(signed long int)(j - 1)] + (signed long int)header_len + (signed long int)1;
            if((signed int)*h->headers[(signed long int)j] == 10)
              h->headers[(signed long int)j] = h->headers[(signed long int)j] + 1l;

          }
          return 1;
        }
      }

    }
    return 0;
  }
}

// ci_headers_replace
// file header.c line 414
const char * ci_headers_replace(struct ci_headers_list *h, const char *header, const char *newval)
{
  if(!(h->packed == 0))
    return (const char *)(void *)0;

  else
    return (const char *)(void *)0;
}

// ci_headers_reset
// file header.c line 213
void ci_headers_reset(struct ci_headers_list *h)
{
  h->packed = 0;
  h->used = 0;
  h->bufused = 0;
}

// ci_headers_search
// file header.c line 318
const char * ci_headers_search(struct ci_headers_list *h, const char *header)
{
  signed int i = 0;
  for( ; !(i >= h->used); i = i + 1)
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(header);
    signed int return_value_strncasecmp_2;
    return_value_strncasecmp_2=strncasecmp(h->headers[(signed long int)i], header, return_value_strlen_1);
    if(return_value_strncasecmp_2 == 0)
      return h->headers[(signed long int)i];

  }
  return (const char *)(void *)0;
}

// ci_headers_setsize
// file header.c line 195
signed int ci_headers_setsize(struct ci_headers_list *h, signed int size)
{
  char *newbuf;
  signed int new_size;
  if(!(size >= h->bufsize))
    return 1;

  else
  {
    new_size = (size / 4096 + 1) * 4096;
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)h->buf, (unsigned long int)new_size * sizeof(char) /*1ul*/ );
    newbuf = (char *)return_value_realloc_1;
    if(newbuf == ((char *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Server Error:Error allocation memory \n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Server Error:Error allocation memory \n");

      }

      return 0;
    }

    else
    {
      h->buf = newbuf;
      h->bufsize = new_size;
      return 1;
    }
  }
}

// ci_headers_unpack
// file header.c line 478
signed int ci_headers_unpack(struct ci_headers_list *h)
{
  signed int len;
  signed int eoh;
  char **newspace;
  char *shead;
  char *ebuf;
  char *str;
  _Bool tmp_if_expr_1;
  if(!(h->bufused >= 2))
    return 4;

  else
  {
    ebuf = (h->buf + (signed long int)h->bufused) - (signed long int)2;
    if(!((signed int)*ebuf == 13))
    {
      if((signed int)*ebuf == 10)
        goto __CPROVER_DUMP_L4;

      if(CI_DEBUG_LEVEL >= 3)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Parse error. The end chars are %c %c (%d %d) not the \\r \n", *ebuf, ebuf[(signed long int)1], (unsigned int)*ebuf, (unsigned int)ebuf[(signed long int)1]);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Parse error. The end chars are %c %c (%d %d) not the \\r \n", *ebuf, ebuf[(signed long int)1], (unsigned int)*ebuf, (unsigned int)ebuf[(signed long int)1]);

      }

      return 4;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      *ebuf = (char)0;
      shead = h->buf;
      h->headers[(signed long int)0] = h->buf;
      h->used = 1;
      str = h->buf;
      for( ; !(str >= ebuf); str = str + 1l)
      {
        eoh = 0;
        _Bool tmp_if_expr_5;
        if((signed int)*str == 13)
          tmp_if_expr_5 = (signed int)str[(signed long int)1] == 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_5 = (_Bool)0;
        if(tmp_if_expr_5)
        {
          _Bool tmp_if_expr_2;
          if(str + 2l >= ebuf)
            tmp_if_expr_2 = (_Bool)1;

          else
          {
            if(!((signed int)str[2l] == 9))
              tmp_if_expr_1 = (signed int)str[(signed long int)2] != 32 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_1 = (_Bool)0;
            tmp_if_expr_2 = tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_2)
            eoh = 1;

        }

        else
        {
          _Bool tmp_if_expr_3;
          if((signed int)*str == 10)
            tmp_if_expr_3 = (signed int)str[(signed long int)1] != 9 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_3 = (_Bool)0;
          _Bool tmp_if_expr_4;
          if(tmp_if_expr_3)
            tmp_if_expr_4 = (signed int)str[(signed long int)1] != 32 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4 = (_Bool)0;
          if(tmp_if_expr_4)
            eoh = 1;

          else
            if((signed int)*str == 0)
              *str = (char)32;

        }
        if(!(eoh == 0))
        {
          *str = (char)0;
          if(h->used >= h->size)
          {
            len = h->size + 64;
            void *return_value_realloc_6;
            return_value_realloc_6=realloc((void *)h->headers, (unsigned long int)len * sizeof(char *) /*8ul*/ );
            newspace = (char **)return_value_realloc_6;
            if(newspace == ((char **)NULL))
            {
              if(CI_DEBUG_LEVEL >= 1)
              {
                if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                  __log_error((void *)0, "Server Error: Error allocating memory \n");

                if(!(CI_DEBUG_STDOUT == 0))
                  printf("Server Error: Error allocating memory \n");

              }

              return 11;
            }

            h->headers = newspace;
            h->size = len;
          }

          str = str + 1l;
          if((signed int)*str == 10)
            str = str + 1l;

          h->headers[(signed long int)h->used] = str;
          h->used = h->used + 1;
        }

      }
      h->packed = 0;
      return 0;
    }
  }
}

// ci_headers_value
// file header.c line 328
const char * ci_headers_value(struct ci_headers_list *h, const char *header)
{
  const char *phead;
  phead=ci_headers_search(h, header);
  const unsigned short int **return_value___ctype_b_loc_1;
  if(phead == ((const char *)NULL))
    return (const char *)(void *)0;

  else
  {
    for( ; !((signed int)*phead == 0); phead = phead + 1l)
      if((signed int)*phead == 58)
        break;

    if(!((signed int)*phead == 58))
      return (const char *)(void *)0;

    else
    {
      phead = phead + 1l;
      do
      {
        return_value___ctype_b_loc_1=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*phead]) == 0)
          break;

        if((signed int)*phead == 0)
          break;

        phead = phead + 1l;
      }
      while((_Bool)1);
      return phead;
    }
  }
}

// ci_host_to_sockaddr_t
// file include/net_io.h line 136
signed int ci_host_to_sockaddr_t(const char *servername, struct ci_sockaddr *addr, signed int proto)
{
  signed int ret = 0;
  struct addrinfo hints;
  struct addrinfo *res;
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_family = proto;
  hints.ai_socktype = 1;
  hints.ai_protocol = 0;
  ret=getaddrinfo(servername, (const char *)(void *)0, &hints, &res);
  const char *return_value_gai_strerror_1;
  const char *return_value_gai_strerror_2;
  if(!(ret == 0))
  {
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      {
        return_value_gai_strerror_1=gai_strerror(ret);
        __log_error((void *)0, "Error geting addrinfo:%s\n", return_value_gai_strerror_1);
      }

      if(!(CI_DEBUG_STDOUT == 0))
      {
        return_value_gai_strerror_2=gai_strerror(ret);
        printf("Error geting addrinfo:%s\n", return_value_gai_strerror_2);
      }

    }

    return 0;
  }

  else
  {
    memcpy((void *)&addr->sockaddr, (const void *)res->ai_addr, sizeof(struct sockaddr_in) /*16ul*/ );
    freeaddrinfo(res);
    ci_fill_sockaddr(addr);
    return 1;
  }
}

// ci_http_client_ip
// file simple_api.c line 301
const struct ci_ip * ci_http_client_ip(struct ci_request *req)
{
  const char *ip;
  if(req == ((struct ci_request *)NULL))
    return (const struct ci_ip *)(void *)0;

  else
    if(req->xclient_ip.family == -1)
      return (const struct ci_ip *)(void *)0;

    else
      if(!(req->xclient_ip.family == 0))
        return &req->xclient_ip;

      else
      {
        ip=ci_headers_value(req->request_header, "X-Client-IP");
        if(ip == ((const char *)NULL))
          return (const struct ci_ip *)(void *)0;

        else
        {
          signed int return_value_ci_inet_aton_1;
          return_value_ci_inet_aton_1=ci_inet_aton(2, ip, (void *)&req->xclient_ip.address);
          if(!(return_value_ci_inet_aton_1 == 0))
          {
            req->xclient_ip.family = 2;
            req->xclient_ip.netmask.s_addr=htonl(0xFFFFFFFF);
          }

          else
            req->xclient_ip.family = -1;
          if(req->xclient_ip.family == -1)
            return (const struct ci_ip *)(void *)0;

          else
            return &req->xclient_ip;
        }
      }
}

// ci_http_content_length
// file simple_api.c line 207
signed long int ci_http_content_length(struct ci_request *req)
{
  struct ci_headers_list *heads;
  const char *val;
  signed long int res = (signed long int)0;
  char *e;
  heads=ci_http_response_headers(req);
  if(heads == ((struct ci_headers_list *)NULL))
  {
    heads=ci_http_request_headers(req);
    if(!(heads == ((struct ci_headers_list *)NULL)))
      goto __CPROVER_DUMP_L1;

    return (signed long int)0;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    val=ci_headers_value(heads, "Content-Length");
    if(val == ((const char *)NULL))
      return (signed long int)-1;

    else
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = 0;
      res=strtoll(val, &e, 10);
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      if(*return_value___errno_location_2 == 34)
      {
        if(!(res == 0x7fffffffffffffffLL) && !(res == -9223372036854775808ll))
          goto __CPROVER_DUMP_L5;

        if(CI_DEBUG_LEVEL >= 4)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Content-Length: overflow\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Content-Length: overflow\n");

        }

        return (signed long int)-2;
      }

      else
      {

      __CPROVER_DUMP_L5:
        ;
        if(val == e)
        {
          if(CI_DEBUG_LEVEL >= 4)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Content-Length: not valid value: '%s' \n", val);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Content-Length: not valid value: '%s' \n", val);

          }

          return (signed long int)-2;
        }

        else
          return res;
      }
    }
  }
}

// ci_http_request
// file simple_api.c line 234
const char * ci_http_request(struct ci_request *req)
{
  struct ci_headers_list *heads;
  heads=ci_http_request_headers(req);
  if(heads == ((struct ci_headers_list *)NULL))
    return (const char *)(void *)0;

  else
    if(heads->used == 0)
      return (const char *)(void *)0;

    else
      return heads->headers[(signed long int)0];
}

// ci_http_request_add_header
// file simple_api.c line 152
const char * ci_http_request_add_header(struct ci_request *req, const char *header)
{
  struct ci_headers_list *heads;
  if(!(req->packed == 0))
    return (const char *)(void *)0;

  else
  {
    heads=ci_http_request_headers(req);
    if(heads == ((struct ci_headers_list *)NULL))
      return (const char *)(void *)0;

    else
    {
      const char *return_value_ci_headers_add_1;
      return_value_ci_headers_add_1=ci_headers_add(heads, header);
      return return_value_ci_headers_add_1;
    }
  }
}

// ci_http_request_create
// file simple_api.c line 119
signed int ci_http_request_create(struct ci_request *req, signed int has_body)
{
  signed int i = 0;
  struct ci_encaps_entity **e_list = req->entities;
  i = 0;
  for( ; !(i >= 4); i = i + 1)
    if(!(req->entities[(signed long int)i] == ((struct ci_encaps_entity *)NULL)))
      ci_request_release_entity(req, i);

  i = 0;
  signed int tmp_post_1 = i;
  i = i + 1;
  req->entities[(signed long int)tmp_post_1]=ci_request_alloc_entity(req, 0, 0);
  if(!(has_body == 0))
    req->entities[(signed long int)i]=ci_request_alloc_entity(req, 2, 0);

  else
    req->entities[(signed long int)i]=ci_request_alloc_entity(req, 4, 0);
  return 1;
}

// ci_http_request_get_header
// file simple_api.c line 195
const char * ci_http_request_get_header(struct ci_request *req, const char *head_name)
{
  struct ci_headers_list *heads;
  const char *val;
  heads=ci_http_request_headers(req);
  if(heads == ((struct ci_headers_list *)NULL))
    return (const char *)(void *)0;

  else
  {
    val=ci_headers_value(heads, head_name);
    if(val == ((const char *)NULL))
      return (const char *)(void *)0;

    else
      return val;
  }
}

// ci_http_request_headers
// file simple_api.c line 52
struct ci_headers_list * ci_http_request_headers(struct ci_request *req)
{
  struct ci_encaps_entity **e_list = req->entities;
  if(!(*e_list == ((struct ci_encaps_entity *)NULL)))
  {
    if(!((*e_list)->type == 0))
      goto __CPROVER_DUMP_L1;

    return (struct ci_headers_list *)e_list[(signed long int)0]->entity;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    if(!(req->trash_entities[0l] == ((struct ci_encaps_entity *)NULL)))
    {
      if(req->trash_entities[0l]->entity == NULL)
        goto __CPROVER_DUMP_L2;

      if(((struct ci_headers_list *)req->trash_entities[0l]->entity)->used == 0)
        goto __CPROVER_DUMP_L2;

      return (struct ci_headers_list *)req->trash_entities[(signed long int)0]->entity;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      return (struct ci_headers_list *)(void *)0;
    }
  }
}

// ci_http_request_remove_header
// file simple_api.c line 173
signed int ci_http_request_remove_header(struct ci_request *req, const char *header)
{
  struct ci_headers_list *heads;
  if(!(req->packed == 0))
    return 0;

  else
  {
    heads=ci_http_request_headers(req);
    if(heads == ((struct ci_headers_list *)NULL))
      return 0;

    else
    {
      signed int return_value_ci_headers_remove_1;
      return_value_ci_headers_remove_1=ci_headers_remove(heads, header);
      return return_value_ci_headers_remove_1;
    }
  }
}

// ci_http_request_reset_headers
// file simple_api.c line 79
signed int ci_http_request_reset_headers(struct ci_request *req)
{
  struct ci_headers_list *heads;
  heads=ci_http_request_headers(req);
  if(heads == ((struct ci_headers_list *)NULL))
    return 0;

  else
  {
    ci_headers_reset(heads);
    return 1;
  }
}

// ci_http_request_url
// file simple_api.c line 257
signed int ci_http_request_url(struct ci_request *req, char *buf, signed int buf_size)
{
  struct ci_headers_list *heads;
  const char *str;
  const char *host;
  signed int i;
  signed int bytes;
  heads=ci_http_request_headers(req);
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_5;
  const unsigned short int **return_value___ctype_b_loc_4;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_10;
  const unsigned short int **return_value___ctype_b_loc_9;
  _Bool tmp_if_expr_11;
  if(heads == ((struct ci_headers_list *)NULL))
    return 0;

  else
    if(heads->used == 0)
      return 0;

    else
    {
      str = heads->headers[(signed long int)0];
      str=strchr(str, 32);
      if(str == ((const char *)NULL))
        return 0;

      else
      {
        for( ; (signed int)*str == 32; str = str + 1l)
          ;
        bytes = 0;
        if((signed int)*str == 47)
        {
          host=ci_headers_value(heads, "Host");
          if(!(host == ((const char *)NULL)))
          {
            i = 0;
            do
            {
              if(!(i >= buf_size + -1))
              {
                if((signed int)host[(signed long int)i] == 0)
                  tmp_if_expr_1 = (_Bool)1;

                else
                  tmp_if_expr_1 = (signed int)host[(signed long int)i] == 10 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_1)
                  tmp_if_expr_2 = (_Bool)1;

                else
                  tmp_if_expr_2 = (signed int)host[(signed long int)i] == 13 ? (_Bool)1 : (_Bool)0;
                tmp_if_expr_3 = !tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_3 = (_Bool)0;
              if(tmp_if_expr_3)
              {
                return_value___ctype_b_loc_4=__ctype_b_loc();
                tmp_if_expr_5 = !(((signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)host[(signed long int)i]] & (signed int)(unsigned short int)8192) != 0) ? (_Bool)1 : (_Bool)0;
              }

              else
                tmp_if_expr_5 = (_Bool)0;
              if(!tmp_if_expr_5)
                break;

              buf[(signed long int)i] = host[(signed long int)i];
              i = i + 1;
            }
            while((_Bool)1);
            buf = buf + (signed long int)i;
            buf_size = buf_size - i;
            bytes = i;
          }

        }

        i = 0;
        do
        {
          if(!(i >= buf_size + -1))
          {
            if((signed int)str[(signed long int)i] == 0)
              tmp_if_expr_6 = (_Bool)1;

            else
              tmp_if_expr_6 = (signed int)str[(signed long int)i] == 10 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_6)
              tmp_if_expr_7 = (_Bool)1;

            else
              tmp_if_expr_7 = (signed int)str[(signed long int)i] == 13 ? (_Bool)1 : (_Bool)0;
            tmp_if_expr_8 = !tmp_if_expr_7 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_8 = (_Bool)0;
          if(tmp_if_expr_8)
          {
            return_value___ctype_b_loc_9=__ctype_b_loc();
            tmp_if_expr_10 = !(((signed int)(*return_value___ctype_b_loc_9)[(signed long int)(signed int)str[(signed long int)i]] & (signed int)(unsigned short int)8192) != 0) ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_10 = (_Bool)0;
          if(tmp_if_expr_10)
            tmp_if_expr_11 = (signed int)str[(signed long int)i] != 63 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_11 = (_Bool)0;
          if(!tmp_if_expr_11)
            break;

          buf[(signed long int)i] = str[(signed long int)i];
          i = i + 1;
        }
        while((_Bool)1);
        buf[(signed long int)i] = (char)0;
        bytes = bytes + i;
        return bytes;
      }
    }
}

// ci_http_response_add_header
// file simple_api.c line 141
const char * ci_http_response_add_header(struct ci_request *req, const char *header)
{
  struct ci_headers_list *heads;
  if(!(req->packed == 0))
    return (const char *)(void *)0;

  else
  {
    heads=ci_http_response_headers(req);
    if(heads == ((struct ci_headers_list *)NULL))
      return (const char *)(void *)0;

    else
    {
      const char *return_value_ci_headers_add_1;
      return_value_ci_headers_add_1=ci_headers_add(heads, header);
      return return_value_ci_headers_add_1;
    }
  }
}

// ci_http_response_create
// file simple_api.c line 96
signed int ci_http_response_create(struct ci_request *req, signed int has_reshdr, signed int has_body)
{
  signed int i = 0;
  struct ci_encaps_entity **e_list = req->entities;
  i = 0;
  for( ; !(i >= 4); i = i + 1)
    if(!(req->entities[(signed long int)i] == ((struct ci_encaps_entity *)NULL)))
      ci_request_release_entity(req, i);

  i = 0;
  if(!(has_reshdr == 0))
  {
    signed int tmp_post_1 = i;
    i = i + 1;
    req->entities[(signed long int)tmp_post_1]=ci_request_alloc_entity(req, 1, 0);
  }

  if(!(has_body == 0))
    req->entities[(signed long int)i]=ci_request_alloc_entity(req, 3, 0);

  else
    req->entities[(signed long int)i]=ci_request_alloc_entity(req, 4, 0);
  return 1;
}

// ci_http_response_get_header
// file simple_api.c line 184
const char * ci_http_response_get_header(struct ci_request *req, const char *head_name)
{
  struct ci_headers_list *heads;
  const char *val;
  heads=ci_http_response_headers(req);
  if(heads == ((struct ci_headers_list *)NULL))
    return (const char *)(void *)0;

  else
  {
    val=ci_headers_value(heads, head_name);
    if(val == ((const char *)NULL))
      return (const char *)(void *)0;

    else
      return val;
  }
}

// ci_http_response_headers
// file simple_api.c line 39
struct ci_headers_list * ci_http_response_headers(struct ci_request *req)
{
  signed int i;
  struct ci_encaps_entity **e_list = req->entities;
  i = 0;
  for( ; !(e_list[(signed long int)i] == ((struct ci_encaps_entity *)NULL)) && !(i >= 3); i = i + 1)
    if(e_list[(signed long int)i]->type == 1)
      return (struct ci_headers_list *)e_list[(signed long int)i]->entity;

  return (struct ci_headers_list *)(void *)0;
}

// ci_http_response_remove_header
// file simple_api.c line 162
signed int ci_http_response_remove_header(struct ci_request *req, const char *header)
{
  struct ci_headers_list *heads;
  if(!(req->packed == 0))
    return 0;

  else
  {
    heads=ci_http_response_headers(req);
    if(heads == ((struct ci_headers_list *)NULL))
      return 0;

    else
    {
      signed int return_value_ci_headers_remove_1;
      return_value_ci_headers_remove_1=ci_headers_remove(heads, header);
      return return_value_ci_headers_remove_1;
    }
  }
}

// ci_http_response_reset_headers
// file simple_api.c line 70
signed int ci_http_response_reset_headers(struct ci_request *req)
{
  struct ci_headers_list *heads;
  heads=ci_http_response_headers(req);
  if(heads == ((struct ci_headers_list *)NULL))
    return 0;

  else
  {
    ci_headers_reset(heads);
    return 1;
  }
}

// ci_icap_add_xheader
// file simple_api.c line 246
const char * ci_icap_add_xheader(struct ci_request *req, const char *header)
{
  const char *return_value_ci_headers_add_1;
  return_value_ci_headers_add_1=ci_headers_add(req->xheaders, header);
  return return_value_ci_headers_add_1;
}

// ci_icap_append_xheaders
// file simple_api.c line 251
signed int ci_icap_append_xheaders(struct ci_request *req, struct ci_headers_list *headers)
{
  signed int return_value_ci_headers_addheaders_1;
  return_value_ci_headers_addheaders_1=ci_headers_addheaders(req->xheaders, headers);
  return return_value_ci_headers_addheaders_1;
}

// ci_inet_aton
// file include/net_io.h line 119
signed int ci_inet_aton(signed int af, const char *cp, void *addr)
{
  signed int return_value_inet_aton_1;
  return_value_inet_aton_1=inet_aton(cp, (struct in_addr *)addr);
  return return_value_inet_aton_1;
}

// ci_inet_ntoa
// file include/net_io.h line 120
const char * ci_inet_ntoa(signed int af, const void *src, char *dst, signed int cnt)
{
  unsigned char *addr_bytes = (unsigned char *)src;
  snprintf(dst, (unsigned long int)cnt, "%d.%d.%d.%d", addr_bytes[(signed long int)0], addr_bytes[(signed long int)1], addr_bytes[(signed long int)2], addr_bytes[(signed long int)3]);
  dst[(signed long int)(cnt - 1)] = (char)0;
  return (const char *)dst;
}

// ci_internal_time
// file cache.c line 32
signed long int ci_internal_time()
{
  signed long int return_value_time_1;
  return_value_time_1=time((signed long int *)(void *)0);
  return return_value_time_1;
}

// ci_linger_close
// file os/unix/net_io.c line 338
signed int ci_linger_close(signed int fd, signed int timeout)
{
  char buf[10l];
  signed int ret;
  if(CI_DEBUG_LEVEL >= 8)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Waiting to close connection\n");

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Waiting to close connection\n");

  }

  signed int return_value_shutdown_1;
  return_value_shutdown_1=shutdown(fd, 1);
  signed int return_value_ci_wait_for_data_2;
  if(!(return_value_shutdown_1 == 0))
  {
    close(fd);
    return 1;
  }

  else
  {
    do
    {
      return_value_ci_wait_for_data_2=ci_wait_for_data(fd, timeout, 0x1);
      if(return_value_ci_wait_for_data_2 == 0)
        break;

      ret=ci_read_nonblock(fd, (void *)buf, (unsigned long int)10);
      if(!(ret >= 1))
        break;

      if(CI_DEBUG_LEVEL >= 10)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "OK I linger %d bytes.....\n", ret);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("OK I linger %d bytes.....\n", ret);

      }

    }
    while((_Bool)1);
    close(fd);
    if(CI_DEBUG_LEVEL >= 8)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Connection closed ...\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Connection closed ...\n");

    }

    return 1;
  }
}

// ci_list_cmp_handler
// file array.c line 536
void ci_list_cmp_handler(struct ci_list *list, signed int (*cmp_func)(const void *, const void *, unsigned long int))
{
  list->cmp_func = cmp_func;
}

// ci_list_copy_handler
// file array.c line 546
void ci_list_copy_handler(struct ci_list *list, signed int (*copy_func)(void *, const void *))
{
  list->copy_func = copy_func;
}

// ci_list_create
// file array.c line 507
struct ci_list * ci_list_create(unsigned long int init_size, unsigned long int obj_size)
{
  struct ci_list *list = (struct ci_list *)(void *)0;
  struct ci_mem_allocator *alloc = (struct ci_mem_allocator *)(void *)0;
  if(!(init_size >= 1024ul))
    init_size = (unsigned long int)1024;

  alloc=ci_create_serial_allocator((signed int)init_size);
  void *return_value;
  return_value=alloc->alloc(alloc, sizeof(struct ci_list) /*80ul*/ );
  list = (struct ci_list *)return_value;
  list->alloc = alloc;
  list->items = (struct ci_list_item *)(void *)0;
  list->last = (struct ci_list_item *)(void *)0;
  list->trash = (struct ci_list_item *)(void *)0;
  list->cursor = (struct ci_list_item *)(void *)0;
  list->obj_size = obj_size;
  list->cmp_func = (signed int (*)(const void *, const void *, unsigned long int))(void *)0;
  list->copy_func = (signed int (*)(void *, const void *))(void *)0;
  list->free_func = (void (*)(void *))(void *)0;
  return list;
}

// ci_list_destroy
// file array.c line 530
void ci_list_destroy(struct ci_list *list)
{
  struct ci_mem_allocator *alloc = list->alloc;
  ci_mem_allocator_destroy(alloc);
}

// ci_list_free_handler
// file array.c line 541
void ci_list_free_handler(struct ci_list *list, void (*free_func)(void *))
{
  list->free_func = free_func;
}

// ci_list_iterate
// file array.c line 551
void ci_list_iterate(struct ci_list *list, void *data, signed int (*fn)(void *, const void *))
{
  struct ci_list_item *it;
  list->cursor = list->items;
  if(!(list->cursor == ((struct ci_list_item *)NULL)))
  {
    it = list->cursor;
    list->cursor = list->cursor->next;
    signed int return_value;
    return_value=fn(data, it->item);
  }

}

// ci_list_pop
// file array.c line 617
void * ci_list_pop(struct ci_list *list, void *data)
{
  struct ci_list_item *it = list->items;
  if(list->items == ((struct ci_list_item *)NULL))
    return (void *)0;

  else
  {
    if(list->last == list->items)
    {
      list->last = (struct ci_list_item *)(void *)0;
      list->items = (struct ci_list_item *)(void *)0;
      list->cursor = (struct ci_list_item *)(void *)0;
    }

    else
    {
      if(list->cursor == list->items)
        list->cursor = list->items->next;

      list->items = list->items->next;
    }
    it->next = list->trash;
    list->trash = it;
    if(!(list->obj_size == 0ul))
    {
      memcpy(data, it->item, list->obj_size);
      if(!(list->copy_func == ((signed int (*)(void *, const void *))NULL)))
        list->copy_func(data, it->item);

      if(!(list->free_func == ((void (*)(void *))NULL)))
        list->free_func(it->item);

      return data;
    }

    else
    {
      *((void **)data) = it->item;
      return *((void **)data);
    }
  }
}

// ci_list_pop_back
// file array.c line 647
void * ci_list_pop_back(struct ci_list *list, void *data)
{
  struct ci_list_item *tmp;
  struct ci_list_item *it = list->last;
  _Bool tmp_if_expr_1;
  if(list->items == ((struct ci_list_item *)NULL))
    return (void *)0;

  else
  {
    if(list->last == list->items)
    {
      list->last = (struct ci_list_item *)(void *)0;
      list->items = (struct ci_list_item *)(void *)0;
      list->cursor = (struct ci_list_item *)(void *)0;
    }

    else
    {
      if(list->cursor == list->last)
        list->cursor = (struct ci_list_item *)(void *)0;

      tmp = list->items;
      do
      {
        if(!(tmp == ((struct ci_list_item *)NULL)))
          tmp_if_expr_1 = tmp->next != list->last ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        if(!tmp_if_expr_1)
          break;

        tmp = tmp->next;
      }
      while((_Bool)1);
      /* assertion tmp != ((void *)0) */
      assert(tmp != (struct ci_list_item *)(void *)0);
      list->last = tmp;
      list->last->next = (struct ci_list_item *)(void *)0;
    }
    it->next = list->trash;
    list->trash = it;
    if(!(list->obj_size == 0ul))
    {
      memcpy(data, it->item, list->obj_size);
      if(!(list->copy_func == ((signed int (*)(void *, const void *))NULL)))
        list->copy_func(data, it->item);

      if(!(list->free_func == ((void (*)(void *))NULL)))
        list->free_func(it->item);

      return data;
    }

    else
    {
      *((void **)data) = it->item;
      return *((void **)data);
    }
  }
}

// ci_list_push
// file array.c line 589
const void * ci_list_push(struct ci_list *list, const void *data)
{
  struct ci_list_item *it;
  it=list_alloc_item(list, data);
  if(it == ((struct ci_list_item *)NULL))
    return (void *)0;

  else
  {
    if(!(list->items == ((struct ci_list_item *)NULL)))
    {
      it->next = list->items;
      list->items = it;
    }

    else
    {
      list->last = it;
      list->items = list->last;
    }
    return it->item;
  }
}

// ci_list_push_back
// file array.c line 603
const void * ci_list_push_back(struct ci_list *list, const void *data)
{
  struct ci_list_item *it;
  it=list_alloc_item(list, data);
  if(it == ((struct ci_list_item *)NULL))
    return (void *)0;

  else
  {
    if(!(list->last == ((struct ci_list_item *)NULL)))
    {
      list->last->next = it;
      list->last = it;
    }

    else
    {
      list->last = it;
      list->items = list->last;
    }
    return it->item;
  }
}

// ci_list_remove
// file array.c line 690
signed int ci_list_remove(struct ci_list *list, const void *obj)
{
  struct ci_list_item *it;
  struct ci_list_item *prev;
  signed int (*cmp_func)(const void *, const void *, unsigned long int);
  if(!(list->cmp_func == ((signed int (*)(const void *, const void *, unsigned long int))NULL)))
    cmp_func = list->cmp_func;

  else
    if(!(list->obj_size == 0ul))
      cmp_func = default_cmp;

    else
      cmp_func = pointers_cmp;
  prev = (struct ci_list_item *)(void *)0;
  it = list->items;
  if(!(it == ((struct ci_list_item *)NULL)))
  {
    signed int return_value;
    return_value=cmp_func(it->item, obj, list->obj_size);
    if(return_value == 0)
    {
      if(!(prev == ((struct ci_list_item *)NULL)))
        prev->next = it->next;

      else
        list->items = it->next;
      if(list->cursor == it)
        list->cursor = list->cursor->next;

      it->next = list->trash;
      list->trash = it;
      if(!(list->free_func == ((void (*)(void *))NULL)))
      {
        if(!(list->obj_size == 0ul))
          list->free_func(it->item);

      }

      return 1;
    }

    prev = it;
    it = it->next;
  }

  return 0;
}

// ci_list_search
// file array.c line 723
const void * ci_list_search(struct ci_list *list, const void *data)
{
  struct ci_list_item *it;
  signed int (*cmp_func)(const void *, const void *, unsigned long int);
  if(!(list->cmp_func == ((signed int (*)(const void *, const void *, unsigned long int))NULL)))
    cmp_func = list->cmp_func;

  else
    if(!(list->obj_size == 0ul))
      cmp_func = default_cmp;

    else
      cmp_func = pointers_cmp;
  it = list->items;
  if(!(it == ((struct ci_list_item *)NULL)))
  {
    signed int return_value;
    return_value=cmp_func(it->item, data, list->obj_size);
    if(return_value == 0)
      return it->item;

    it = it->next;
  }

  return (void *)0;
}

// ci_list_search2
// file array.c line 742
const void * ci_list_search2(struct ci_list *list, const void *data, signed int (*cmp_func)(const void *, const void *, unsigned long int))
{
  struct ci_list_item *it = list->items;
  if(!(it == ((struct ci_list_item *)NULL)))
  {
    signed int return_value;
    return_value=cmp_func(it->item, data, list->obj_size);
    if(return_value == 0)
      return it->item;

    it = it->next;
  }

  return (void *)0;
}

// ci_list_sort
// file array.c line 752
void ci_list_sort(struct ci_list *list)
{
  signed int (*cmp_func)(const void *, const void *, unsigned long int);
  if(!(list->cmp_func == ((signed int (*)(const void *, const void *, unsigned long int))NULL)))
    cmp_func = list->cmp_func;

  else
    if(!(list->obj_size == 0ul))
      cmp_func = default_cmp;

    else
      cmp_func = pointers_cmp;
  ci_list_sort2(list, cmp_func);
}

// ci_list_sort2
// file array.c line 766
void ci_list_sort2(struct ci_list *list, signed int (*cmp_func)(const void *, const void *, unsigned long int))
{
  struct ci_list_item *it;
  struct ci_list_item *sortedHead = (struct ci_list_item *)(void *)0;
  struct ci_list_item *sortedTail = (struct ci_list_item *)(void *)0;
  struct ci_list_item **currentSorted;
  struct ci_list_item *currentHead;
  _Bool tmp_if_expr_1;
  if(list->items == ((struct ci_list_item *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(list->items->next != ((struct ci_list_item *)NULL)) ? (_Bool)1 : (_Bool)0;
  signed int return_value;
  if(!tmp_if_expr_1)
  {
    it = list->items;
    while(!(it == ((struct ci_list_item *)NULL)))
    {
      currentHead = it;
      it = it->next;
      currentSorted = &sortedHead;
      if(!(*currentSorted == ((struct ci_list_item *)NULL)))
      {
        return_value=cmp_func(currentHead->item, (*currentSorted)->item, list->obj_size);
        if(return_value >= 0)
          currentSorted = &(*currentSorted)->next;

      }

      currentHead->next = *currentSorted;
      *currentSorted = currentHead;
      if((*currentSorted)->next == ((struct ci_list_item *)NULL))
        sortedTail = *currentSorted;

    }
    list->items = sortedHead;
    list->last = sortedTail;
  }

}

// ci_local_cache_destroy
// file cache.c line 217
void ci_local_cache_destroy(struct ci_cache *cache)
{
  struct ci_cache_entry *e;
  struct ci_local_cache_data *cache_data = (struct ci_local_cache_data *)cache->cache_data;
  e = cache_data->first_queue_entry;
  if(!(e == ((struct ci_cache_entry *)NULL)))
  {
    cache_data->first_queue_entry = cache_data->first_queue_entry->qnext;
    if(!(e->key == NULL))
      cache->key_ops->free(e->key, cache_data->allocator);

    if(!(e->val == NULL))
    {
      if(e->val_size >= 1)
        cache_data->allocator->free(cache_data->allocator, e->val);

    }

    cache_data->allocator->free(cache_data->allocator, (void *)e);
    e = cache_data->first_queue_entry;
  }

  cache_data->allocator->free(cache_data->allocator, (void *)cache_data->hash_table);
  common_mutex_destroy(&cache_data->mtx);
  ci_mem_allocator_destroy(cache_data->allocator);
  free((void *)cache_data);
}

// ci_local_cache_init
// file cache.c line 135
signed int ci_local_cache_init(struct ci_cache *cache, const char *name)
{
  struct ci_local_cache_data *cache_data;
  signed int i;
  unsigned int new_hash_size;
  struct ci_mem_allocator *ci_local_cache_init__1__allocator;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct ci_local_cache_data) /*128ul*/ );
  cache_data = (struct ci_local_cache_data *)return_value_malloc_1;
  if(cache_data == ((struct ci_local_cache_data *)NULL))
    return 0;

  else
  {
    cache->cache_data = (void *)cache_data;
    ci_local_cache_init__1__allocator=ci_create_os_allocator();
    if(ci_local_cache_init__1__allocator == ((struct ci_mem_allocator *)NULL))
    {
      free((void *)cache_data);
      return 0;
    }

    else
    {
      cache_data->allocator = ci_local_cache_init__1__allocator;
      void *return_value;
      return_value=ci_local_cache_init__1__allocator->alloc(ci_local_cache_init__1__allocator, sizeof(struct ci_cache_entry) /*56ul*/ );
      cache_data->first_queue_entry = (struct ci_cache_entry *)return_value;
      if(cache_data->first_queue_entry == ((struct ci_cache_entry *)NULL))
      {
        ci_mem_allocator_destroy(ci_local_cache_init__1__allocator);
        free((void *)cache_data);
        return 0;
      }

      else
      {
        cache_data->last_queue_entry = cache_data->first_queue_entry;
        cache_data->last_queue_entry->hnext = (struct ci_cache_entry *)(void *)0;
        cache_data->last_queue_entry->qnext = (struct ci_cache_entry *)(void *)0;
        cache_data->last_queue_entry->key = (void *)0;
        cache_data->last_queue_entry->val = (void *)0;
        cache_data->last_queue_entry->time = (signed long int)0;
        cache_data->last_queue_entry->hash = (unsigned int)0;
        unsigned int cache_items = (unsigned int)((unsigned long int)cache->mem_size / ((unsigned long int)cache->max_object_size + sizeof(struct ci_cache_entry) /*56ul*/ ));
        if(cache_items == 0u)
        {
          ci_mem_allocator_destroy(ci_local_cache_init__1__allocator);
          free((void *)cache_data);
          return 0;
        }

        else
        {
          i = 0;
          if(!((unsigned int)i >= cache_items + 4294967295u))
          {
            void *return_value_1;
            return_value_1=ci_local_cache_init__1__allocator->alloc(ci_local_cache_init__1__allocator, sizeof(struct ci_cache_entry) /*56ul*/ );
            cache_data->last_queue_entry->qnext = (struct ci_cache_entry *)return_value_1;
            if(cache_data->last_queue_entry->qnext == ((struct ci_cache_entry *)NULL))
            {
              ci_mem_allocator_destroy(ci_local_cache_init__1__allocator);
              return 0;
            }

            cache_data->last_queue_entry = cache_data->last_queue_entry->qnext;
            cache_data->last_queue_entry->hnext = (struct ci_cache_entry *)(void *)0;
            cache_data->last_queue_entry->qnext = (struct ci_cache_entry *)(void *)0;
            cache_data->last_queue_entry->key = (void *)0;
            cache_data->last_queue_entry->val = (void *)0;
            cache_data->last_queue_entry->time = (signed long int)0;
            cache_data->last_queue_entry->hash = (unsigned int)0;
            i = i + 1;
          }

          new_hash_size = (unsigned int)63;
          if(cache_items >= 64u)
          {
            if(!(new_hash_size >= 16777215u) && !(new_hash_size >= cache_items))
            {
              new_hash_size = new_hash_size + 1u;
              new_hash_size = (new_hash_size << 1) - (unsigned int)1;
            }

          }

          if(CI_DEBUG_LEVEL >= 7)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Hash size: %d\n", new_hash_size);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Hash size: %d\n", new_hash_size);

          }

          void *return_value_2;
          return_value_2=ci_local_cache_init__1__allocator->alloc(ci_local_cache_init__1__allocator, (unsigned long int)(new_hash_size + (unsigned int)1) * sizeof(struct ci_cache_entry *) /*8ul*/ );
          cache_data->hash_table = (struct ci_cache_entry **)return_value_2;
          if(cache_data->hash_table == ((struct ci_cache_entry **)NULL))
          {
            ci_mem_allocator_destroy(ci_local_cache_init__1__allocator);
            free((void *)cache);
            free((void *)cache_data);
            return 0;
          }

          else
          {
            memset((void *)cache_data->hash_table, 0, (unsigned long int)(new_hash_size + (unsigned int)1) * sizeof(struct ci_cache_entry *) /*8ul*/ );
            cache_data->hash_table_size = new_hash_size;
            common_mutex_init(&cache_data->mtx, 0);
            return 1;
          }
        }
      }
    }
  }
}

// ci_local_cache_search
// file cache.c line 238
const void * ci_local_cache_search(struct ci_cache *cache, const void *key, void **val, void *data, void * (*dup_from_cache)(const void *, unsigned long int, void *))
{
  struct ci_cache_entry *e;
  struct ci_local_cache_data *cache_data;
  signed long int current_time;
  cache_data = (struct ci_local_cache_data *)cache->cache_data;
  unsigned int hash;
  unsigned long int return_value;
  return_value=cache->key_ops->size(key);
  hash=ci_hash_compute((unsigned long int)cache_data->hash_table_size, key, (signed int)return_value);
  /* assertion hash <= cache_data->hash_table_size */
  assert(hash <= cache_data->hash_table_size);
  common_mutex_lock(&cache_data->mtx);
  e = cache_data->hash_table[(signed long int)hash];
  *val = (void *)0;
  if(!(e == ((struct ci_cache_entry *)NULL)))
  {
    if(CI_DEBUG_LEVEL >= 10)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, " \t\t->>>>Val %s\n", (char *)e->val);

      if(!(CI_DEBUG_STDOUT == 0))
        printf(" \t\t->>>>Val %s\n", (char *)e->val);

    }

    if(CI_DEBUG_LEVEL >= 10)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, " \t\t->>>>compare %s ~ %s\n", (char *)e->key, (char *)key);

      if(!(CI_DEBUG_STDOUT == 0))
        printf(" \t\t->>>>compare %s ~ %s\n", (char *)e->key, (char *)key);

    }

    signed int return_value_1;
    return_value_1=cache->key_ops->compare(e->key, key);
    if(return_value_1 == 0)
    {
      current_time=ci_internal_time();
      if(!(cache->ttl >= current_time + -e->time))
        key = (void *)0;

      else
        if(!(e->val_size == 0))
        {
          if(!(dup_from_cache == ((void * (*)(const void *, unsigned long int, void *))NULL)))
            *val=dup_from_cache(e->val, (unsigned long int)e->val_size, data);

          else
          {
            *val=ci_buffer_alloc(e->val_size);
            memcpy(*val, e->val, (unsigned long int)e->val_size);
          }
        }

      common_mutex_unlock(&cache_data->mtx);
      return key;
    }

    /* assertion e != e->hnext */
    assert(e != e->hnext);
    e = e->hnext;
  }

  common_mutex_unlock(&cache_data->mtx);
  return (void *)0;
}

// ci_local_cache_update
// file cache.c line 277
signed int ci_local_cache_update(struct ci_cache *cache, const void *key, const void *val, unsigned long int val_size, void * (*copy_to_cache)(void *, const void *, unsigned long int))
{
  struct ci_cache_entry *e;
  struct ci_cache_entry *tmp;
  signed int key_size;
  signed long int current_time;
  struct ci_local_cache_data *cache_data;
  unsigned int hash;
  cache_data = (struct ci_local_cache_data *)cache->cache_data;
  unsigned long int return_value;
  return_value=cache->key_ops->size(key);
  hash=ci_hash_compute((unsigned long int)cache_data->hash_table_size, key, (signed int)return_value);
  /* assertion hash <= cache_data->hash_table_size */
  assert(hash <= cache_data->hash_table_size);
  if(CI_DEBUG_LEVEL >= 10)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Adding :%s:%p\n", (char *)key, (char *)val);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Adding :%s:%p\n", (char *)key, (char *)val);

  }

  current_time=ci_internal_time();
  common_mutex_lock(&cache_data->mtx);
  e = cache_data->first_queue_entry;
  if(!(current_time + -e->time >= cache->ttl))
  {
    if(CI_DEBUG_LEVEL >= 6)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "ci_cache_update: not available slot (%d-%d %d).\n", (unsigned int)current_time, (unsigned int)e->time, (unsigned int)cache->ttl);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("ci_cache_update: not available slot (%d-%d %d).\n", (unsigned int)current_time, (unsigned int)e->time, (unsigned int)cache->ttl);

    }

    common_mutex_unlock(&cache_data->mtx);
    return 0;
  }

  else
  {
    if(!(e->key == NULL))
    {
      cache->key_ops->free(e->key, cache_data->allocator);
      e->key = (void *)0;
    }

    if(!(e->val == NULL))
    {
      if(e->val_size >= 1)
      {
        cache_data->allocator->free(cache_data->allocator, e->val);
        e->val = (void *)0;
      }

    }

    /* assertion e->hash <= cache_data->hash_table_size */
    assert(e->hash <= cache_data->hash_table_size);
    tmp = cache_data->hash_table[(signed long int)e->hash];
    if(tmp == e)
      cache_data->hash_table[(signed long int)e->hash] = tmp->hnext;

    else
      if(!(tmp == ((struct ci_cache_entry *)NULL)))
      {
        if(!(tmp->hnext == ((struct ci_cache_entry *)NULL)))
        {
          if(!(e == tmp->hnext))
            tmp = tmp->hnext;

        }

        if(!(tmp->hnext == ((struct ci_cache_entry *)NULL)))
          tmp->hnext = tmp->hnext->hnext;

      }

    e->hnext = (struct ci_cache_entry *)(void *)0;
    e->time = (signed long int)0;
    e->hash = (unsigned int)0;
    unsigned long int return_value_1;
    return_value_1=cache->key_ops->size(key);
    key_size = (signed int)return_value_1;
    e->key=cache_data->allocator->alloc(cache_data->allocator, (unsigned long int)key_size);
    if(e->key == NULL)
    {
      common_mutex_unlock(&cache_data->mtx);
      if(CI_DEBUG_LEVEL >= 6)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "ci_cache_update: failed to allocate memory for key.\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("ci_cache_update: failed to allocate memory for key.\n");

      }

      return 0;
    }

    else
    {
      memcpy(e->key, key, (unsigned long int)key_size);
      if(val_size >= 1ul && !(val == NULL))
      {
        e->val=cache_data->allocator->alloc(cache_data->allocator, val_size);
        e->val_size = (signed int)val_size;
        if(!(e->val == NULL))
        {
          if(!(copy_to_cache == ((void * (*)(void *, const void *, unsigned long int))NULL)))
          {
            void *return_value_2;
            return_value_2=copy_to_cache(e->val, val, (unsigned long int)e->val_size);
            if(return_value_2 == NULL)
            {
              cache_data->allocator->free(cache_data->allocator, e->val);
              e->val = (void *)0;
            }

          }

          else
            memcpy(e->val, val, (unsigned long int)e->val_size);
        }

        if(e->val == NULL)
        {
          cache_data->allocator->free(cache_data->allocator, e->key);
          e->key = (void *)0;
          common_mutex_unlock(&cache_data->mtx);
          if(CI_DEBUG_LEVEL >= 6)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "ci_cache_update: failed to allocate memory for cache data.\n");

            if(!(CI_DEBUG_STDOUT == 0))
              printf("ci_cache_update: failed to allocate memory for cache data.\n");

          }

          return 0;
        }

      }

      else
      {
        e->val = (void *)0;
        e->val_size = 0;
      }
      e->hash = hash;
      e->time = current_time;
      cache_data->first_queue_entry = cache_data->first_queue_entry->qnext;
      cache_data->last_queue_entry->qnext = e;
      cache_data->last_queue_entry = e;
      e->qnext = (struct ci_cache_entry *)(void *)0;
      if(!(cache_data->hash_table[(signed long int)hash] == ((struct ci_cache_entry *)NULL)))
      {
        if(CI_DEBUG_LEVEL >= 10)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "\t\t:::Found %s\n", (char *)cache_data->hash_table[(signed long int)hash]->val);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("\t\t:::Found %s\n", (char *)cache_data->hash_table[(signed long int)hash]->val);

        }

      }

      e->hnext = cache_data->hash_table[(signed long int)hash];
      cache_data->hash_table[(signed long int)hash] = e;
      common_mutex_unlock(&cache_data->mtx);
      return 1;
    }
  }
}

// ci_lookup_table_create
// file lookup_table.c line 144
struct ci_lookup_table * ci_lookup_table_create(const char *table)
{
  struct ci_mem_allocator *ci_lookup_table_create__1__allocator;
  struct ci_lookup_table *lt;
  ci_lookup_table_create__1__allocator=ci_create_os_allocator();
  if(ci_lookup_table_create__1__allocator == ((struct ci_mem_allocator *)NULL))
    return (struct ci_lookup_table *)(void *)0;

  else
  {
    lt=ci_lookup_table_create_ext(table, &ci_str_ops, &ci_str_ops, ci_lookup_table_create__1__allocator);
    if(lt == ((struct ci_lookup_table *)NULL))
      ci_mem_allocator_destroy(ci_lookup_table_create__1__allocator);

    return lt;
  }
}

// ci_lookup_table_create_ext
// file lookup_table.c line 69
struct ci_lookup_table * ci_lookup_table_create_ext(const char *table, const struct ci_type_ops *key_ops, const struct ci_type_ops *val_ops, struct ci_mem_allocator *allocator)
{
  char *ttype;
  char *path;
  char *args;
  char *s;
  struct ci_lookup_table_type *lt_type;
  struct ci_lookup_table *lt;
  char *stable;
  stable=strdup(table);
  if(stable == ((char *)NULL))
    return (struct ci_lookup_table *)(void *)0;

  else
  {
    s=index(stable, 58);
    if(s == ((char *)NULL))
    {
      ttype = "file";
      path = stable;
      args = (char *)(void *)0;
    }

    else
    {
      ttype = stable;
      path = s + (signed long int)1;
      *s = (char)0;
      s=index(path, 123);
      if(!(s == ((char *)NULL)))
      {
        *s = (char)0;
        args = s + (signed long int)1;
        s=index(args, 125);
        if(!(s == ((char *)NULL)))
          *s = (char)0;

      }

      else
        args = (char *)(void *)0;
    }
    lt_type=ci_lookup_table_type_search(ttype);
    _Bool tmp_if_expr_1;
    if(lt_type == ((struct ci_lookup_table_type *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = !(lt_type->open != ((void * (*)(struct ci_lookup_table *))NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Not lookuptable of type :%s!!!\n", ttype);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Not lookuptable of type :%s!!!\n", ttype);

      }

      free((void *)stable);
      return (struct ci_lookup_table *)(void *)0;
    }

    else
    {
      void *return_value_malloc_2;
      return_value_malloc_2=malloc(sizeof(struct ci_lookup_table) /*120ul*/ );
      lt = (struct ci_lookup_table *)return_value_malloc_2;
      if(lt == ((struct ci_lookup_table *)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "memory allocation error!!");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("memory allocation error!!");

        }

        free((void *)stable);
        return (struct ci_lookup_table *)(void *)0;
      }

      else
      {
        lt->path=strdup(path);
        if(!(args == ((char *)NULL)))
          lt->args=strdup(args);

        else
          lt->args = (char *)(void *)0;
        free((void *)stable);
        lt->cols = -1;
        lt->key_ops = key_ops;
        lt->val_ops = val_ops;
        lt->type = lt_type->type;
        lt->open = lt_type->open;
        lt->close = lt_type->close;
        lt->search = lt_type->search;
        lt->get_row = lookup_table_get_row;
        lt->release_result = lt_type->release_result;
        lt->allocator = allocator;
        lt->_lt_type = lt_type;
        lt->data = (void *)0;
        return lt;
      }
    }
  }
}

// ci_lookup_table_destroy
// file lookup_table.c line 158
void ci_lookup_table_destroy(struct ci_lookup_table *lt)
{
  if(!(lt == ((struct ci_lookup_table *)NULL)))
  {
    lt->close(lt);
    free((void *)lt->path);
    if(!(lt->args == ((char *)NULL)))
      free((void *)lt->args);

    if(!(lt->allocator == ((struct ci_mem_allocator *)NULL)))
      ci_mem_allocator_destroy(lt->allocator);

    free((void *)lt);
  }

}

// ci_lookup_table_get_row
// file lookup_table.c line 228
const char * ci_lookup_table_get_row(struct ci_lookup_table *table, const char *key, const char **columns, char ***vals)
{
  _Bool tmp_if_expr_1;
  if(table->key_ops == &ci_str_ops)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = table->key_ops == &ci_str_ext_ops ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = table->key_ops == &ci_regex_ops ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(!tmp_if_expr_2)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    if(table->val_ops == &ci_str_ops)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = table->val_ops == &ci_str_ext_ops ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = table->val_ops == &ci_regex_ops ? (_Bool)1 : (_Bool)0;
    tmp_if_expr_5 = !tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "lookup_table of type  %s does not support search with string like keys!\n", table->type);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("lookup_table of type  %s does not support search with string like keys!\n", table->type);

    }

    return (const char *)(void *)0;
  }

  else
  {
    const void *return_value_lookup_table_get_row_6;
    return_value_lookup_table_get_row_6=lookup_table_get_row(table, (const void *)key, columns, (void ***)vals);
    return (const char *)return_value_lookup_table_get_row_6;
  }
}

// ci_lookup_table_open
// file lookup_table.c line 172
void * ci_lookup_table_open(struct ci_lookup_table *table)
{
  _Bool tmp_if_expr_1;
  if(table->_lt_type == ((struct ci_lookup_table_type *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(table->open != ((void * (*)(struct ci_lookup_table *))NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "lookup_table of type  %s is corrupted (\"open\" method missing)!\n", table->type);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("lookup_table of type  %s is corrupted (\"open\" method missing)!\n", table->type);

    }

    return (void *)0;
  }

  else
  {
    void *return_value;
    return_value=table->open(table);
    return return_value;
  }
}

// ci_lookup_table_release_result
// file lookup_table.c line 196
void ci_lookup_table_release_result(struct ci_lookup_table *table, void **val)
{
  _Bool tmp_if_expr_1;
  if(table->_lt_type == ((struct ci_lookup_table_type *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(table->release_result != ((void (*)(struct ci_lookup_table *, void **))NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "lookup_table of type  %s is corrupted (\"release_result\" method missing)!\n", table->type);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("lookup_table of type  %s is corrupted (\"release_result\" method missing)!\n", table->type);

    }

  }

  else
    table->release_result(table, (void **)val);
}

// ci_lookup_table_search
// file lookup_table.c line 181
const char * ci_lookup_table_search(struct ci_lookup_table *table, const char *key, char ***vals)
{
  _Bool tmp_if_expr_1;
  if(table->_lt_type == ((struct ci_lookup_table_type *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(table->search != ((void * (*)(struct ci_lookup_table *, void *, void ***))NULL)) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  if(tmp_if_expr_1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "lookup_table of type  %s is corrupted (\"search\" method missing)!\n", table->type);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("lookup_table of type  %s is corrupted (\"search\" method missing)!\n", table->type);

    }

    return (const char *)(void *)0;
  }

  else
  {
    _Bool tmp_if_expr_2;
    if(table->key_ops == &ci_str_ops)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = table->key_ops == &ci_str_ext_ops ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr_3;
    if(tmp_if_expr_2)
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = table->key_ops == &ci_regex_ops ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr_6;
    if(!tmp_if_expr_3)
      tmp_if_expr_6 = (_Bool)1;

    else
    {
      if(table->val_ops == &ci_str_ops)
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = table->val_ops == &ci_str_ext_ops ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_4)
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = table->val_ops == &ci_regex_ops ? (_Bool)1 : (_Bool)0;
      tmp_if_expr_6 = !tmp_if_expr_5 ? (_Bool)1 : (_Bool)0;
    }
    if(tmp_if_expr_6)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "lookup_table of type  %s does not support search with string like keys!\n", table->type);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("lookup_table of type  %s does not support search with string like keys!\n", table->type);

      }

      return (const char *)(void *)0;
    }

    else
    {
      void *return_value;
      return_value=table->search(table, (void *)key, (void ***)vals);
      return (const char *)return_value;
    }
  }
}

// ci_lookup_table_type_register
// file lookup_table.c line 36
struct ci_lookup_table_type * ci_lookup_table_type_register(struct ci_lookup_table_type *lt_type)
{
  if(lookup_tables_types_num >= 128)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "c-icap does not support more than 128 loookup table types");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("c-icap does not support more than 128 loookup table types");

    }

    return (struct ci_lookup_table_type *)(void *)0;
  }

  else
  {
    signed int tmp_post_1 = lookup_tables_types_num;
    lookup_tables_types_num = lookup_tables_types_num + 1;
    lookup_tables_types[(signed long int)tmp_post_1] = lt_type;
    return lt_type;
  }
}

// ci_lookup_table_type_search
// file lookup_table.c line 58
struct ci_lookup_table_type * ci_lookup_table_type_search(const char *type)
{
  signed int i = 0;
  for( ; !(i >= lookup_tables_types_num); i = i + 1)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(type, lookup_tables_types[(signed long int)i]->type);
    if(return_value_strcmp_1 == 0)
      return lookup_tables_types[(signed long int)i];

  }
  return (struct ci_lookup_table_type *)(void *)0;
}

// ci_lookup_table_type_unregister
// file lookup_table.c line 46
void ci_lookup_table_type_unregister(struct ci_lookup_table_type *lt_type)
{
  signed int i = 0;
  for( ; !(lookup_tables_types[(signed long int)i] == lt_type) && !(i >= lookup_tables_types_num); i = i + 1)
    ;
  if(!(i >= lookup_tables_types_num))
  {
    lookup_tables_types_num = lookup_tables_types_num - 1;
    for( ; !(i >= lookup_tables_types_num); i = i + 1)
      lookup_tables_types[(signed long int)i] = lookup_tables_types[(signed long int)(i + 1)];
  }

}

// ci_magic_data_type
// file filetype.c line 711
signed int ci_magic_data_type(const char *buf, signed int len)
{
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL))
    return -1;

  else
  {
    signed int return_value_ci_filetype_1;
    return_value_ci_filetype_1=ci_filetype(_MAGIC_DB, buf, len);
    return return_value_ci_filetype_1;
  }
}

// ci_magic_data_type_ext
// file filetype.c line 720
signed int ci_magic_data_type_ext(struct ci_headers_list *headers, const char *buf, signed int len, signed int *iscompressed)
{
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL))
    return -1;

  else
  {
    signed int return_value_extend_object_type_1;
    return_value_extend_object_type_1=extend_object_type(_MAGIC_DB, headers, buf, len, iscompressed);
    return return_value_extend_object_type_1;
  }
}

// ci_magic_db_free
// file filetype.c line 685
void ci_magic_db_free()
{
  if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
    ci_magics_db_release(_MAGIC_DB);

  _MAGIC_DB = (struct ci_magics_db *)(void *)0;
}

// ci_magic_db_load
// file filetype.c line 674
struct ci_magics_db * ci_magic_db_load(const char *filename)
{
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL))
  {
    _MAGIC_DB=ci_magics_db_build(filename);
    return _MAGIC_DB;
  }

  else
  {
    signed int return_value_ci_magics_db_file_add_1;
    return_value_ci_magics_db_file_add_1=ci_magics_db_file_add(_MAGIC_DB, filename);
    if(!(return_value_ci_magics_db_file_add_1 == 0))
      return _MAGIC_DB;

    else
      return (struct ci_magics_db *)(void *)0;
  }
}

// ci_magic_group_check
// file filetype.c line 745
signed int ci_magic_group_check(signed int type, signed int group)
{
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL))
    return 0;

  else
  {
    signed int return_value_ci_belongs_to_group_1;
    return_value_ci_belongs_to_group_1=ci_belongs_to_group(_MAGIC_DB, type, group);
    return return_value_ci_belongs_to_group_1;
  }
}

// ci_magic_group_id
// file filetype.c line 737
signed int ci_magic_group_id(const char *group)
{
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL))
    return -1;

  else
  {
    signed int return_value_ci_get_data_group_id_1;
    return_value_ci_get_data_group_id_1=ci_get_data_group_id(_MAGIC_DB, group);
    return return_value_ci_get_data_group_id_1;
  }
}

// ci_magic_group_name
// file filetype.c line 783
char * ci_magic_group_name(signed int group)
{
  _Bool tmp_if_expr_2;
  signed int tmp_if_expr_1;
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL) || !(group >= 1))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
      tmp_if_expr_1 = _MAGIC_DB->groups_num;

    else
      tmp_if_expr_1 = 0;
    tmp_if_expr_2 = group >= tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
    return (char *)(void *)0;

  else
  {
    _Bool tmp_if_expr_3;
    if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
      tmp_if_expr_3 = group < _MAGIC_DB->groups_num ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    char *tmp_if_expr_4;
    if(group >= 0 && tmp_if_expr_3)
      tmp_if_expr_4 = (_MAGIC_DB->groups + (signed long int)group)->name;

    else
      tmp_if_expr_4 = (char *)(void *)0;
    return tmp_if_expr_4;
  }
}

// ci_magic_groups_count
// file filetype.c line 760
signed int ci_magic_groups_count()
{
  signed int tmp_if_expr_1;
  if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
    tmp_if_expr_1 = _MAGIC_DB->groups_num;

  else
    tmp_if_expr_1 = 0;
  return tmp_if_expr_1;
}

// ci_magic_req_data_type
// file filetype.c line 694
signed int ci_magic_req_data_type(struct ci_request *req, signed int *isencoded)
{
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL))
    return -1;

  else
    if(req->preview_data.used == 0)
      return -1;

    else
    {
      if(!(req->preview_data_type >= 0))
        req->preview_data_type=ci_extend_filetype(_MAGIC_DB, req, req->preview_data.buf, req->preview_data.used, isencoded);

      return req->preview_data_type;
    }
}

// ci_magic_type_descr
// file filetype.c line 774
char * ci_magic_type_descr(signed int type)
{
  _Bool tmp_if_expr_2;
  signed int tmp_if_expr_1;
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL) || !(type >= 1))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
      tmp_if_expr_1 = _MAGIC_DB->types_num;

    else
      tmp_if_expr_1 = 0;
    tmp_if_expr_2 = type >= tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
    return (char *)(void *)0;

  else
  {
    _Bool tmp_if_expr_3;
    if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
      tmp_if_expr_3 = type < _MAGIC_DB->types_num ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    char *tmp_if_expr_4;
    if(type >= 0 && tmp_if_expr_3)
      tmp_if_expr_4 = (_MAGIC_DB->types + (signed long int)type)->descr;

    else
      tmp_if_expr_4 = (char *)(void *)0;
    return tmp_if_expr_4;
  }
}

// ci_magic_type_id
// file filetype.c line 729
signed int ci_magic_type_id(const char *name)
{
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL))
    return -1;

  else
  {
    signed int return_value_ci_get_data_type_id_1;
    return_value_ci_get_data_type_id_1=ci_get_data_type_id(_MAGIC_DB, name);
    return return_value_ci_get_data_type_id_1;
  }
}

// ci_magic_type_name
// file filetype.c line 765
char * ci_magic_type_name(signed int type)
{
  _Bool tmp_if_expr_2;
  signed int tmp_if_expr_1;
  if(_MAGIC_DB == ((struct ci_magics_db *)NULL) || !(type >= 1))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
      tmp_if_expr_1 = _MAGIC_DB->types_num;

    else
      tmp_if_expr_1 = 0;
    tmp_if_expr_2 = type >= tmp_if_expr_1 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
    return (char *)(void *)0;

  else
  {
    char *tmp_if_expr_3;
    if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
      tmp_if_expr_3 = (_MAGIC_DB->types + (signed long int)type)->name;

    else
      tmp_if_expr_3 = (char *)(void *)0;
    return tmp_if_expr_3;
  }
}

// ci_magic_types_count
// file filetype.c line 754
signed int ci_magic_types_count()
{
  signed int tmp_if_expr_1;
  if(!(_MAGIC_DB == ((struct ci_magics_db *)NULL)))
    tmp_if_expr_1 = _MAGIC_DB->types_num;

  else
    tmp_if_expr_1 = 0;
  return tmp_if_expr_1;
}

// ci_magics_db_build
// file filetype.c line 358
struct ci_magics_db * ci_magics_db_build(const char *filename)
{
  struct ci_magics_db *ci_magics_db_build__1__db;
  ci_magics_db_build__1__db=ci_magics_db_init();
  if(!(ci_magics_db_build__1__db == ((struct ci_magics_db *)NULL)))
    ci_magics_db_file_add(ci_magics_db_build__1__db, filename);

  return ci_magics_db_build__1__db;
}

// ci_magics_db_file_add
// file filetype.c line 302
signed int ci_magics_db_file_add(struct ci_magics_db *db, const char *filename)
{
  signed int type;
  signed int ret;
  signed int group;
  signed int i;
  signed int lineNum;
  signed int groups[65l];
  char line[32768l];
  struct ci_magic_record record;
  struct _IO_FILE *f;
  f=fopen64(filename, "r");
  char *return_value_fgets_1;
  if(f == ((struct _IO_FILE *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error opening magic file: %s\n", filename);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error opening magic file: %s\n", filename);

    }

    return 0;
  }

  else
  {
    lineNum = 0;
    ret = 0;
    do
    {
      return_value_fgets_1=fgets(line, 32768, f);
      if(return_value_fgets_1 == ((char *)NULL))
        break;

      lineNum = lineNum + 1;
      ret=parse_record(line, &record);
      if(!(ret == 0))
      {
        if(!(ret >= 0))
          break;

        type=ci_get_data_type_id(db, record.type);
        if(!(type >= 0))
        {
          i = 0;
          for( ; !(record.groups[(signed long int)i] == ((char *)NULL)); i = i + 1)
          {
            if(i >= 64)
              break;

            group=ci_get_data_group_id(db, record.groups[(signed long int)i]);
            if(!(group >= 0))
              group=groups_add(db, record.groups[(signed long int)i], "");

            groups[(signed long int)i] = group;
          }
          groups[(signed long int)i] = -1;
          type=types_add(db, record.type, record.descr, groups);
          if(!(type >= 0))
          {
            ret = -2;
            break;
          }

        }

        magics_add(db, record.offset, record.magic, record.len, (signed int)(unsigned int)type);
        free_records_group(&record);
      }

    }
    while((_Bool)1);
    fclose(f);
    if(!(ret >= 0))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error reading magic file (%d), line number: %d\nBuggy line: %s\n", ret, lineNum, (const void *)line);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error reading magic file (%d), line number: %d\nBuggy line: %s\n", ret, lineNum, (const void *)line);

      }

      return 0;
    }

    else
    {
      if(CI_DEBUG_LEVEL >= 3)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "In database: magic: %d, types: %d, groups: %d\n", db->magics_num, db->types_num, db->groups_num);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("In database: magic: %d, types: %d, groups: %d\n", db->magics_num, db->types_num, db->groups_num);

      }

      return 1;
    }
  }
}

// ci_magics_db_init
// file filetype.c line 267
struct ci_magics_db * ci_magics_db_init()
{
  struct ci_magics_db *ci_magics_db_init__1__db;
  signed int i;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct ci_magics_db) /*48ul*/ );
  ci_magics_db_init__1__db = (struct ci_magics_db *)return_value_malloc_1;
  if(ci_magics_db_init__1__db == ((struct ci_magics_db *)NULL))
    return (struct ci_magics_db *)(void *)0;

  else
  {
    types_init(ci_magics_db_init__1__db);
    groups_init(ci_magics_db_init__1__db);
    magics_init(ci_magics_db_init__1__db);
    i = 0;
    for( ; !((signed int)predefined_types[(signed long int)i].name[0l] == 0); i = i + 1)
      types_add(ci_magics_db_init__1__db, predefined_types[(signed long int)i].name, predefined_types[(signed long int)i].descr, predefined_types[(signed long int)i].groups);
    i = 0;
    for( ; !((signed int)predefined_groups[(signed long int)i].name[0l] == 0); i = i + 1)
      groups_add(ci_magics_db_init__1__db, predefined_groups[(signed long int)i].name, predefined_groups[(signed long int)i].descr);
    return ci_magics_db_init__1__db;
  }
}

// ci_magics_db_release
// file filetype.c line 294
void ci_magics_db_release(struct ci_magics_db *db)
{
  free((void *)db->types);
  free((void *)db->groups);
  free((void *)db->magics);
  free((void *)db);
}

// ci_mem_allocator_destroy
// file ../include/mem.h line 46
void ci_mem_allocator_destroy(struct ci_mem_allocator *allocator)
{
  allocator->destroy(allocator);
  if(allocator->must_free == 1)
    free((void *)allocator);

  else
    if(allocator->must_free == 2)
      ci_object_pool_free((void *)allocator);

}

// ci_membuf_attr_add
// file body.c line 244
signed int ci_membuf_attr_add(struct ci_membuf *body, const char *attr, const void *val, unsigned long int val_size)
{
  if(body->attributes == ((struct ci_array *)NULL))
    body->attributes=ci_array_new((unsigned long int)1024);

  const struct ci_array_item *return_value_ci_array_add_1;
  if(!(body->attributes == ((struct ci_array *)NULL)))
  {
    return_value_ci_array_add_1=ci_array_add(body->attributes, attr, val, val_size);
    return (signed int)(return_value_ci_array_add_1 != (const struct ci_array_item *)(void *)0);
  }

  return 0;
}

// ci_membuf_attr_get
// file body.c line 256
const void * ci_membuf_attr_get(struct ci_membuf *body, const char *attr)
{
  const void *return_value_ci_array_search_1;
  if(!(body->attributes == ((struct ci_array *)NULL)))
  {
    return_value_ci_array_search_1=ci_array_search(body->attributes, attr);
    return return_value_ci_array_search_1;
  }

  return (void *)0;
}

// ci_membuf_free
// file body.c line 147
void ci_membuf_free(struct ci_membuf *b)
{
  if(!(b == ((struct ci_membuf *)NULL)))
  {
    if(!(b->buf == ((char *)NULL)))
    {
      if((16u & b->flags) == 0u)
        ci_buffer_free((void *)b->buf);

    }

    if(!(b->attributes == ((struct ci_array *)NULL)))
      ci_array_destroy(b->attributes);

    ci_object_pool_free((void *)b);
  }

}

// ci_membuf_from_content
// file body.c line 108
struct ci_membuf * ci_membuf_from_content(char *buf, unsigned long int buf_size, unsigned long int content_size, unsigned int flags)
{
  struct ci_membuf *b;
  if(buf == ((char *)NULL) || !(buf_size >= 1ul) || !(buf_size >= content_size))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "ci_membuf_from_content: Wrong arguments: %p, of size=%u and content size=%u\n", buf, (unsigned int)buf_size, (unsigned int)content_size);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("ci_membuf_from_content: Wrong arguments: %p, of size=%u and content size=%u\n", buf, (unsigned int)buf_size, (unsigned int)content_size);

    }

    return (struct ci_membuf *)(void *)0;
  }

  else
    if(!((15u & flags) == flags))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "ci_membuf_from_content: Wrong flags: %u\n", flags);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("ci_membuf_from_content: Wrong flags: %u\n", flags);

      }

      return (struct ci_membuf *)(void *)0;
    }

    else
    {
      if(!((1u & flags) == 0u))
      {
        if((signed int)buf[-1l + (signed long int)content_size] == 0)
          content_size = content_size - 1ul;

        else
        {
          _Bool tmp_if_expr_1;
          if(content_size >= buf_size)
            tmp_if_expr_1 = (_Bool)1;

          else
            tmp_if_expr_1 = (signed int)buf[(signed long int)content_size] != 0 ? (_Bool)1 : (_Bool)0;
          if(tmp_if_expr_1)
          {
            if(CI_DEBUG_LEVEL >= 1)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "ci_membuf_from_content: content is not NULL terminated!\n");

              if(!(CI_DEBUG_STDOUT == 0))
                printf("ci_membuf_from_content: content is not NULL terminated!\n");

            }

            return (struct ci_membuf *)(void *)0;
          }

        }
      }

      void *return_value_ci_object_pool_alloc_2;
      return_value_ci_object_pool_alloc_2=ci_object_pool_alloc(MEMBUF_POOL);
      b = (struct ci_membuf *)return_value_ci_object_pool_alloc_2;
      if(b == ((struct ci_membuf *)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "ci_membuf_from_content: memory allocation failed\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("ci_membuf_from_content: memory allocation failed\n");

        }

        return (struct ci_membuf *)(void *)0;
      }

      else
      {
        b->flags = (unsigned int)0x10 | flags;
        b->endpos = (signed int)content_size;
        b->readpos = 0;
        b->buf = buf;
        b->bufsize = (signed int)buf_size;
        b->unlocked = -1;
        b->attributes = (struct ci_array *)(void *)0;
        return b;
      }
    }
}

// ci_membuf_new
// file body.c line 82
struct ci_membuf * ci_membuf_new()
{
  struct ci_membuf *return_value_ci_membuf_new_sized_1;
  return_value_ci_membuf_new_sized_1=ci_membuf_new_sized(8192);
  return return_value_ci_membuf_new_sized_1;
}

// ci_membuf_new_sized
// file body.c line 87
struct ci_membuf * ci_membuf_new_sized(signed int size)
{
  struct ci_membuf *b;
  void *return_value_ci_object_pool_alloc_1;
  return_value_ci_object_pool_alloc_1=ci_object_pool_alloc(MEMBUF_POOL);
  b = (struct ci_membuf *)return_value_ci_object_pool_alloc_1;
  if(b == ((struct ci_membuf *)NULL))
    return (struct ci_membuf *)(void *)0;

  else
  {
    b->endpos = 0;
    b->readpos = 0;
    b->flags = (unsigned int)0;
    void *return_value_ci_buffer_alloc_2;
    return_value_ci_buffer_alloc_2=ci_buffer_alloc((signed int)((unsigned long int)size * sizeof(char) /*1ul*/ ));
    b->buf = (char *)return_value_ci_buffer_alloc_2;
    if(b->buf == ((char *)NULL))
    {
      ci_object_pool_free((void *)b);
      return (struct ci_membuf *)(void *)0;
    }

    else
    {
      b->bufsize = size;
      b->unlocked = -1;
      b->attributes = (struct ci_array *)(void *)0;
      return b;
    }
  }
}

// ci_membuf_read
// file body.c line 225
signed int ci_membuf_read(struct ci_membuf *b, char *data, signed int len)
{
  signed int remains;
  signed int copybytes;
  if(b->unlocked >= 0)
    remains = b->unlocked - b->readpos;

  else
    remains = b->endpos - b->readpos;
  if(remains == 0)
  {
    if((2u & b->flags) == 0u)
      goto __CPROVER_DUMP_L3;

    return -2;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    copybytes = len <= remains ? len : remains;
    if(!(copybytes == 0))
    {
      memcpy((void *)data, (const void *)(b->buf + (signed long int)b->readpos), (unsigned long int)copybytes);
      b->readpos = b->readpos + copybytes;
    }

    return copybytes;
  }
}

// ci_membuf_set_flag
// file body.c line 158
unsigned int ci_membuf_set_flag(struct ci_membuf *body, unsigned int flag)
{
  if((5u & flag) == 0u)
    return (unsigned int)0;

  else
  {
    body->flags = body->flags | flag;
    return body->flags;
  }
}

// ci_membuf_truncate
// file body.c line 263
signed int ci_membuf_truncate(struct ci_membuf *body, signed int new_size)
{
  if(!(body->endpos >= new_size))
    return 0;

  else
  {
    body->endpos = new_size;
    if(!((1u & body->flags) == 0u))
      body->buf[(signed long int)body->endpos] = (char)0;

    if(!(body->endpos >= body->readpos))
      body->readpos = body->endpos;

    if(!(body->endpos >= body->unlocked))
      body->unlocked = body->endpos;

    return 1;
  }
}

// ci_membuf_write
// file body.c line 167
signed int ci_membuf_write(struct ci_membuf *b, const char *data, signed int len, signed int iseof)
{
  signed int remains;
  signed int newsize;
  char *newbuf;
  signed int terminate = (signed int)(b->flags & (unsigned int)0x01);
  _Bool tmp_if_expr_1;
  if(!((4u & b->flags) == 0u))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (b->flags & (unsigned int)0x08) != 0u ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "ci_membuf_write: can not write: buffer is read-only!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("ci_membuf_write: can not write: buffer is read-only!\n");

    }

    return 0;
  }

  else
    if(!((2u & b->flags) == 0u))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Cannot write to membuf: the eof flag is set!\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Cannot write to membuf: the eof flag is set!\n");

      }

      return 0;
    }

    else
    {
      if(!(iseof == 0))
        b->flags = b->flags | (unsigned int)0x02;

      remains = (b->bufsize - b->endpos) - (terminate != 0 ? 1 : 0);
      /* assertion remains >= -1 */
      assert(remains >= -1);
      while(!(remains >= len))
      {
        newsize = b->bufsize + 4096;
        void *return_value_ci_buffer_realloc_2;
        return_value_ci_buffer_realloc_2=ci_buffer_realloc((void *)b->buf, newsize);
        newbuf = (char *)return_value_ci_buffer_realloc_2;
        if(newbuf == ((char *)NULL))
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "ci_membuf_write: Failed to grow membuf for new data!\n");

            if(!(CI_DEBUG_STDOUT == 0))
              printf("ci_membuf_write: Failed to grow membuf for new data!\n");

          }

          if(remains >= 0)
          {
            if(!(remains == 0))
              memcpy((void *)(b->buf + (signed long int)b->endpos), (const void *)data, (unsigned long int)remains);

            if(!(terminate == 0))
            {
              b->endpos = b->bufsize - 1;
              b->buf[(signed long int)b->endpos] = (char)0;
            }

            else
              b->endpos = b->bufsize;
          }

          else
            if(CI_DEBUG_LEVEL >= 1)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "ci_membuf_write: Failed to NULL terminate membuf!\n");

              if(!(CI_DEBUG_STDOUT == 0))
                printf("ci_membuf_write: Failed to NULL terminate membuf!\n");

            }

          return remains;
        }

        b->buf = newbuf;
        b->bufsize = newsize;
        remains = (b->bufsize - b->endpos) - (terminate != 0 ? 1 : 0);
      }
      if(!(len == 0))
      {
        memcpy((void *)(b->buf + (signed long int)b->endpos), (const void *)data, (unsigned long int)len);
        b->endpos = b->endpos + len;
      }

      if(!(terminate == 0))
        b->buf[(signed long int)b->endpos] = (char)0;

      return len;
    }
}

// ci_mktemp_file
// file include/util.h line 34
signed int ci_mktemp_file(char *dir, char *template, char *filename)
{
  snprintf(filename, (unsigned long int)4096, "%s%s", dir, template);
  filename[(signed long int)(4096 - 1)] = (char)0;
  signed int return_value_mkstemp64_1;
  return_value_mkstemp64_1=mkstemp64(filename);
  return return_value_mkstemp64_1;
}

// ci_module_load
// file os/unix/dlib.c line 27
void * ci_module_load(const char *module_file, const char *default_path)
{
  char path[4096l];
  void *handle;
  signed int len;
  if(!((signed int)*module_file == 47))
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(default_path);
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(module_file);
    len = (signed int)(return_value_strlen_1 + return_value_strlen_2 + (unsigned long int)1);
    if(len >= 4096)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Path name len of %s+%s is greater than MAXPATH:%d, not loading\n", default_path, module_file, 4096);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Path name len of %s+%s is greater than MAXPATH:%d, not loading\n", default_path, module_file, 4096);

      }

      return (void *)0;
    }

    strcpy(path, default_path);
    strcat(path, "/");
    strcat(path, module_file);
  }

  else
    strncpy(path, module_file, (unsigned long int)(4096 - 1));
  path[(signed long int)(4096 - 1)] = (char)0;
  handle=dlopen(path, 0x00002 | 0x00100);
  if(handle == NULL)
  {
    char *error_str;
    error_str=dlerror();
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error loading module %s:%s\n", module_file, error_str);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error loading module %s:%s\n", module_file, error_str);

    }

    return (void *)0;
  }

  return handle;
}

// ci_module_sym
// file os/unix/dlib.c line 59
void * ci_module_sym(void *handle, const char *symbol)
{
  void *return_value_dlsym_1;
  return_value_dlsym_1=dlsym(handle, symbol);
  return return_value_dlsym_1;
}

// ci_module_unload
// file os/unix/dlib.c line 65
signed int ci_module_unload(void *handle, const char *name)
{
  signed int ret;
  ret=dlclose(handle);
  if(ret == 1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error unloading module:%s\n", name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error unloading module:%s\n", name);

    }

    return 0;
  }

  else
    return 1;
}

// ci_netio_init
// file include/net_io.h line 149
signed int ci_netio_init(signed int fd)
{
  fcntl(fd, 4, 04000);
  return 1;
}

// ci_object_pool_alloc
// file include/mem.h line 73
void * ci_object_pool_alloc(signed int id)
{
  struct mem_buffer_block *block = (struct mem_buffer_block *)(void *)0;
  _Bool tmp_if_expr_1;
  if(id >= object_pools_used || !(id >= 0))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(object_pools[(signed long int)id] != ((struct ci_mem_allocator *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Invalid object pool %d. This is a BUG!\n", id);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Invalid object pool %d. This is a BUG!\n", id);

    }

    return (void *)0;
  }

  else
  {
    void *return_value;
    return_value=object_pools[(signed long int)id]->alloc(object_pools[(signed long int)id], (unsigned long int)1);
    block = (struct mem_buffer_block *)return_value;
    if(block == ((struct mem_buffer_block *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 2)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Failed to allocate object from pool %d\n", id);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Failed to allocate object from pool %d\n", id);

      }

      return (void *)0;
    }

    else
    {
      if(CI_DEBUG_LEVEL >= 8)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Allocating from objects pool object %d\n", id);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Allocating from objects pool object %d\n", id);

      }

      block->sig = (unsigned short int)0x55AA;
      block->ID = id;
      return (void *)block->data.ptr;
    }
  }
}

// ci_object_pool_free
// file include/mem.h line 74
void ci_object_pool_free(void *ptr)
{
  struct mem_buffer_block *block = (struct mem_buffer_block *)(ptr - (signed long int)(unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]);
  if(!((signed int)block->sig == 0x55AA))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "ci_object_pool_free: ERROR, %p is not internal buffer. This is a bug!!!!\n", ptr);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("ci_object_pool_free: ERROR, %p is not internal buffer. This is a bug!!!!\n", ptr);

    }

  }

  else
  {
    _Bool tmp_if_expr_1;
    if(!(object_pools_used >= block->ID))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = block->ID < 0 ? (_Bool)1 : (_Bool)0;
    _Bool tmp_if_expr_2;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = !(object_pools[(signed long int)block->ID] != ((struct ci_mem_allocator *)NULL)) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_2)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "ci_object_pool_free: ERROR, %p is pointing to corrupted mem? This is a bug!!!!\n", ptr);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("ci_object_pool_free: ERROR, %p is pointing to corrupted mem? This is a bug!!!!\n", ptr);

      }

    }

    else
    {
      if(CI_DEBUG_LEVEL >= 8)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Storing to objects pool object %d\n", block->ID);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Storing to objects pool object %d\n", block->ID);

      }

      object_pools[(signed long int)block->ID]->free(object_pools[(signed long int)block->ID], (void *)block);
    }
  }
}

// ci_object_pool_register
// file include/mem.h line 71
signed int ci_object_pool_register(const char *name, signed int size)
{
  signed int ID;
  signed int i;
  ID = -1;
  if(object_pools == ((struct ci_mem_allocator **)NULL))
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)128 * sizeof(struct ci_mem_allocator *) /*8ul*/ );
    object_pools = (struct ci_mem_allocator **)return_value_malloc_1;
    object_pools_size = 128;
    ID = 0;
  }

  else
  {
    i = 0;
    for( ; !(i >= object_pools_used); i = i + 1)
      if(object_pools[(signed long int)i] == ((struct ci_mem_allocator *)NULL))
      {
        ID = i;
        break;
      }

    if(ID == -1)
    {
      if(object_pools_size == object_pools_used)
      {
        object_pools_size = object_pools_size + 128;
        void *return_value_realloc_2;
        return_value_realloc_2=realloc((void *)object_pools, (unsigned long int)object_pools_size * sizeof(struct ci_mem_allocator *) /*8ul*/ );
        object_pools = (struct ci_mem_allocator **)return_value_realloc_2;
      }

      ID = object_pools_used;
    }

  }
  if(object_pools == ((struct ci_mem_allocator **)NULL))
    return -1;

  else
  {
    object_pools[(signed long int)ID]=ci_create_pool_allocator((signed int)((unsigned long int)size + (unsigned long int)&((struct mem_buffer_block *)0)->data.ptr[(signed long int)0]));
    object_pools_used = object_pools_used + 1;
    return ID;
  }
}

// ci_object_pool_unregister
// file include/mem.h line 72
void ci_object_pool_unregister(signed int id)
{
  if(!(id >= object_pools_used) && id >= 0)
  {
    if(!(object_pools[(signed long int)id] == ((struct ci_mem_allocator *)NULL)))
    {
      ci_mem_allocator_destroy(object_pools[(signed long int)id]);
      object_pools[(signed long int)id] = (struct ci_mem_allocator *)(void *)0;
    }

  }

}

// ci_object_pools_destroy
// file mem.c line 310
void ci_object_pools_destroy()
{
  signed int i = 0;
  for( ; !(i >= object_pools_used); i = i + 1)
    if(!(object_pools[(signed long int)i] == ((struct ci_mem_allocator *)NULL)))
      ci_mem_allocator_destroy(object_pools[(signed long int)i]);

}

// ci_object_pools_init
// file mem.c line 305
signed int ci_object_pools_init()
{
  return 1;
}

// ci_pack_allocator_alloc
// file mem.c line 604
void * ci_pack_allocator_alloc(struct ci_mem_allocator *allocator, unsigned long int size)
{
  size = size + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1);
  void *return_value_ci_pack_allocator_alloc_unaligned_1;
  return_value_ci_pack_allocator_alloc_unaligned_1=ci_pack_allocator_alloc_unaligned(allocator, size);
  return return_value_ci_pack_allocator_alloc_unaligned_1;
}

// ci_pack_allocator_alloc_from_rear
// file mem.c line 610
void * ci_pack_allocator_alloc_from_rear(struct ci_mem_allocator *allocator, signed int size)
{
  signed int max_size;
  void *mem;
  struct pack_allocator *pack_alloc;
  /* assertion allocator->type == PACK_ALLOC */
  assert(allocator->type == 3);
  pack_alloc = (struct pack_allocator *)allocator->data;
  if(pack_alloc == ((struct pack_allocator *)NULL))
    return (void *)0;

  else
  {
    size = (signed int)((unsigned long int)size + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1));
    max_size = (signed int)(pack_alloc->endpos - pack_alloc->curpos);
    if(!(max_size >= size))
      return (void *)0;

    else
    {
      pack_alloc->endpos = pack_alloc->endpos - (signed long int)size;
      mem = pack_alloc->endpos;
      return mem;
    }
  }
}

// ci_pack_allocator_alloc_unaligned
// file mem.c line 582
void * ci_pack_allocator_alloc_unaligned(struct ci_mem_allocator *allocator, unsigned long int size)
{
  signed int max_size;
  void *mem;
  struct pack_allocator *pack_alloc;
  /* assertion allocator->type == PACK_ALLOC */
  assert(allocator->type == 3);
  pack_alloc = (struct pack_allocator *)allocator->data;
  if(pack_alloc == ((struct pack_allocator *)NULL))
    return (void *)0;

  else
  {
    max_size = (signed int)(pack_alloc->endpos - pack_alloc->curpos);
    if(!((unsigned long int)max_size >= size))
      return (void *)0;

    else
    {
      mem = pack_alloc->curpos;
      pack_alloc->curpos = pack_alloc->curpos + (signed long int)size;
      return mem;
    }
  }
}

// ci_pack_allocator_data_size
// file mem.c line 722
signed int ci_pack_allocator_data_size(struct ci_mem_allocator *allocator)
{
  /* assertion allocator->type == PACK_ALLOC */
  assert(allocator->type == 3);
  struct pack_allocator *pack_alloc = (struct pack_allocator *)allocator->data;
  return (signed int)((signed long int)(signed int)(pack_alloc->curpos - pack_alloc->memchunk) + (pack_alloc->end - pack_alloc->endpos));
}

// ci_pack_allocator_destroy
// file mem.c line 647
void ci_pack_allocator_destroy(struct ci_mem_allocator *allocator)
{
  struct pack_allocator *pack_alloc;
  /* assertion allocator->type == PACK_ALLOC */
  assert(allocator->type == 3);
  pack_alloc = (struct pack_allocator *)allocator->data;
  if(!(pack_alloc->must_free == 0))
  {
    ci_object_pool_free(allocator->data);
    allocator->data = (void *)0;
  }

}

// ci_pack_allocator_free
// file mem.c line 633
void ci_pack_allocator_free(struct ci_mem_allocator *allocator, void *p)
{
  ;
}

// ci_pack_allocator_required_size
// file mem.c line 730
unsigned long int ci_pack_allocator_required_size()
{
  return (sizeof(struct pack_allocator) /*40ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + (sizeof(struct ci_mem_allocator) /*56ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1));
}

// ci_pack_allocator_reset
// file mem.c line 638
void ci_pack_allocator_reset(struct ci_mem_allocator *allocator)
{
  struct pack_allocator *pack_alloc;
  /* assertion allocator->type == PACK_ALLOC */
  assert(allocator->type == 3);
  pack_alloc = (struct pack_allocator *)allocator->data;
  pack_alloc->curpos = pack_alloc->memchunk;
  pack_alloc->endpos = pack_alloc->end;
}

// ci_pack_allocator_set_end_pos
// file mem.c line 746
void ci_pack_allocator_set_end_pos(struct ci_mem_allocator *allocator, void *p)
{
  struct pack_allocator *pack_alloc;
  /* assertion allocator->type == PACK_ALLOC */
  assert(allocator->type == 3);
  pack_alloc = (struct pack_allocator *)allocator->data;
  /* assertion p <= pack_alloc->end */
  assert(p <= pack_alloc->end);
  if(p == NULL)
    pack_alloc->endpos = pack_alloc->end;

  else
    pack_alloc->endpos = p;
}

// ci_pack_allocator_set_start_pos
// file mem.c line 737
void ci_pack_allocator_set_start_pos(struct ci_mem_allocator *allocator, void *p)
{
  struct pack_allocator *pack_alloc;
  /* assertion allocator->type == PACK_ALLOC */
  assert(allocator->type == 3);
  pack_alloc = (struct pack_allocator *)allocator->data;
  /* assertion p >= pack_alloc->memchunk */
  assert(p >= pack_alloc->memchunk);
  pack_alloc->curpos = p;
}

// ci_parse_key_value_list
// file util.c line 163
struct ci_dyn_array * ci_parse_key_value_list(const char *str, char sep)
{
  char *s;
  char *e;
  char *k;
  char *v;
  struct ci_dyn_array *args_array;
  s=strdup(str);
  unsigned long int return_value_strlen_1;
  if(s == ((char *)NULL))
    return (struct ci_dyn_array *)(void *)0;

  else
  {
    args_array=ci_dyn_array_new((unsigned long int)1024);
    k = s;
    while(!(k == ((char *)NULL)))
    {
      e=strchr(k, (signed int)sep);
      if(!(e == ((char *)NULL)))
      {
        *e = (char)0;
        e = e + 1l;
      }

      v=strchr(k, 61);
      if(!(v == ((char *)NULL)))
      {
        *v = (char)0;
        v = v + 1l;
      }

      k=ci_str_trim2(k);
      if(!(v == ((char *)NULL)))
        v=ci_str_trim2(v);

      if(!(*k == 0))
      {
        unsigned long int tmp_if_expr_2;
        if(!(v == ((char *)NULL)))
        {
          return_value_strlen_1=strlen(v);
          tmp_if_expr_2 = return_value_strlen_1 + (unsigned long int)1;
        }

        else
          tmp_if_expr_2 = (unsigned long int)1;
        ci_dyn_array_add(args_array, k, (const void *)(v != ((char *)NULL) ? v : ""), tmp_if_expr_2);
      }

      _Bool tmp_if_expr_3;
      if(!(e == ((char *)NULL)))
        tmp_if_expr_3 = *e != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      k = tmp_if_expr_3 ? e : (char *)(void *)0;
    }
    return args_array;
  }
}

// ci_proc_mutex_default_scheme
// file os/unix/proc_mutex.c line 254
const struct ci_proc_mutex_scheme * ci_proc_mutex_default_scheme()
{
  return default_mutex_scheme;
}

// ci_proc_mutex_destroy
// file os/unix/proc_mutex.c line 292
signed int ci_proc_mutex_destroy(struct ci_proc_mutex *mutex)
{
  signed int return_value;
  if(!(mutex->scheme == ((const struct ci_proc_mutex_scheme *)NULL)))
  {
    return_value=mutex->scheme->proc_mutex_destroy(mutex);
    return return_value;
  }

  return 0;
}

// ci_proc_mutex_init
// file os/unix/proc_mutex.c line 283
signed int ci_proc_mutex_init(struct ci_proc_mutex *mutex, const char *name)
{
  if(!(default_mutex_scheme == ((const struct ci_proc_mutex_scheme *)NULL)))
  {
    mutex->scheme = default_mutex_scheme;
    signed int return_value;
    return_value=default_mutex_scheme->proc_mutex_init(mutex, name);
    return return_value;
  }

  return 0;
}

// ci_proc_mutex_lock
// file os/unix/proc_mutex.c line 299
signed int ci_proc_mutex_lock(struct ci_proc_mutex *mutex)
{
  signed int return_value;
  if(!(mutex->scheme == ((const struct ci_proc_mutex_scheme *)NULL)))
  {
    return_value=mutex->scheme->proc_mutex_lock(mutex);
    return return_value;
  }

  return 0;
}

// ci_proc_mutex_set_scheme
// file os/unix/proc_mutex.c line 259
signed int ci_proc_mutex_set_scheme(const char *scheme)
{
  signed int return_value_strcasecmp_3;
  return_value_strcasecmp_3=strcasecmp(scheme, "sysv");
  signed int return_value_strcasecmp_2;
  signed int return_value_strcasecmp_1;
  if(return_value_strcasecmp_3 == 0)
    default_mutex_scheme = &sysv_mutex_scheme;

  else
  {
    return_value_strcasecmp_2=strcasecmp(scheme, "posix");
    if(return_value_strcasecmp_2 == 0)
      default_mutex_scheme = &posix_mutex_scheme;

    else
    {
      return_value_strcasecmp_1=strcasecmp(scheme, "file");
      if(return_value_strcasecmp_1 == 0)
        default_mutex_scheme = &file_mutex_scheme;

      else
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Unknown interprocess locking scheme: '%s'", scheme);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Unknown interprocess locking scheme: '%s'", scheme);

        }

        return 0;
      }
    }
  }
  return 1;
}

// ci_proc_mutex_unlock
// file os/unix/proc_mutex.c line 306
signed int ci_proc_mutex_unlock(struct ci_proc_mutex *mutex)
{
  signed int return_value;
  if(!(mutex->scheme == ((const struct ci_proc_mutex_scheme *)NULL)))
  {
    return_value=mutex->scheme->proc_mutex_unlock(mutex);
    return return_value;
  }

  return 0;
}

// ci_ptr_array_add
// file array.c line 165
const struct ci_array_item * ci_ptr_array_add(struct ci_array *ptr_array, const char *name, void *value)
{
  struct ci_array_item *item;
  struct ci_mem_allocator *packer = ptr_array->alloc;
  /* assertion packer */
  assert(packer != ((struct ci_mem_allocator *)NULL));
  void *return_value_ci_pack_allocator_alloc_unaligned_1;
  return_value_ci_pack_allocator_alloc_unaligned_1=ci_pack_allocator_alloc_unaligned(packer, (unsigned long int)&((struct ci_array_item *)0)[(signed long int)1]);
  item = (struct ci_array_item *)return_value_ci_pack_allocator_alloc_unaligned_1;
  unsigned long int return_value_strlen_2;
  void *return_value_ci_pack_allocator_alloc_from_rear_3;
  if(!(item == ((struct ci_array_item *)NULL)))
  {
    return_value_strlen_2=strlen(name);
    return_value_ci_pack_allocator_alloc_from_rear_3=ci_pack_allocator_alloc_from_rear(packer, (signed int)(return_value_strlen_2 + (unsigned long int)1));
    item->name = (char *)return_value_ci_pack_allocator_alloc_from_rear_3;
  }

  _Bool tmp_if_expr_4;
  if(item == ((struct ci_array_item *)NULL))
    tmp_if_expr_4 = (_Bool)1;

  else
    tmp_if_expr_4 = !(item->name != ((char *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_4)
  {
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Not enough space to add the new item to array!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Not enough space to add the new item to array!\n");

    }

    return (const struct ci_array_item *)(void *)0;
  }

  else
  {
    strcpy(item->name, name);
    item->value = value;
    if(ptr_array->items == ((struct ci_array_item *)NULL))
      ptr_array->items = item;

    ptr_array->count = ptr_array->count + 1u;
    return item;
  }
}

// ci_ptr_array_new2
// file array.c line 151
struct ci_array * ci_ptr_array_new2(unsigned long int items)
{
  unsigned long int array_size;
  unsigned long int return_value_ci_pack_allocator_required_size_1;
  return_value_ci_pack_allocator_required_size_1=ci_pack_allocator_required_size();
  array_size = return_value_ci_pack_allocator_required_size_1 + (sizeof(struct ci_array) /*40ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + items * ((sizeof(void *) /*8ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + (sizeof(struct ci_array_item) /*16ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)));
  struct ci_array *return_value_ci_array_new_2;
  return_value_ci_array_new_2=ci_array_new(array_size);
  return return_value_ci_array_new_2;
}

// ci_ptr_array_pop
// file array.c line 189
const struct ci_array_item * ci_ptr_array_pop(struct ci_array *ptr_array)
{
  struct ci_array_item *item;
  if(ptr_array->count == 0u)
    return (const struct ci_array_item *)(void *)0;

  else
  {
    item = &ptr_array->items[(signed long int)(ptr_array->count - (unsigned int)1)];
    ci_pack_allocator_set_start_pos(ptr_array->alloc, (void *)item);
    ptr_array->count = ptr_array->count - 1u;
    return item;
  }
}

// ci_ptr_array_pop_value
// file array.c line 200
void * ci_ptr_array_pop_value(struct ci_array *ptr_array, char *name, unsigned long int name_size)
{
  const struct ci_array_item *item;
  item=ci_ptr_array_pop(ptr_array);
  if(item == ((const struct ci_array_item *)NULL))
    return (void *)0;

  else
  {
    strncpy(name, item->name, name_size);
    name[(signed long int)(name_size - (unsigned long int)1)] = (char)0;
    return item->value;
  }
}

// ci_ptr_array_search
// file array.c line 160
void * ci_ptr_array_search(struct ci_array *array, const char *name)
{
  const void *return_value_ci_array_search_1;
  return_value_ci_array_search_1=ci_array_search(array, name);
  return (void *)return_value_ci_array_search_1;
}

// ci_ptr_dyn_array_add
// file array.c line 336
const struct ci_array_item * ci_ptr_dyn_array_add(struct ci_dyn_array *array, const char *name, void *value)
{
  const struct ci_array_item *return_value_ci_dyn_array_add_1;
  return_value_ci_dyn_array_add_1=ci_dyn_array_add(array, name, value, (unsigned long int)0);
  return return_value_ci_dyn_array_add_1;
}

// ci_ptr_vector_add
// file array.c line 479
void * ci_ptr_vector_add(struct ci_vector *vector, void *value)
{
  void **indx;
  struct ci_mem_allocator *packer = vector->alloc;
  /* assertion packer */
  assert(packer != ((struct ci_mem_allocator *)NULL));
  if(value == NULL)
    return (void *)0;

  else
  {
    void *return_value_ci_pack_allocator_alloc_unaligned_1;
    return_value_ci_pack_allocator_alloc_unaligned_1=ci_pack_allocator_alloc_unaligned(packer, (unsigned long int)&((void **)0)[(signed long int)1]);
    indx = (void **)return_value_ci_pack_allocator_alloc_unaligned_1;
    if(indx == ((void **)NULL))
    {
      if(CI_DEBUG_LEVEL >= 2)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Not enough space to add the new item to ptr_vector!\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Not enough space to add the new item to ptr_vector!\n");

      }

      return (void *)0;
    }

    else
    {
      *vector->last = value;
      vector->last = indx;
      *vector->last = (void *)0;
      vector->count = vector->count + 1;
      return value;
    }
  }
}

// ci_read
// file os/unix/net_io.c line 253
signed int ci_read(signed int fd, void *buf, unsigned long int count, signed int timeout)
{
  signed int bytes = 0;
  _Bool tmp_if_expr_2;
  signed int *return_value___errno_location_1;
  do
  {
    signed long int return_value_read_3;
    return_value_read_3=read(fd, buf, count);
    bytes = (signed int)return_value_read_3;
    if(bytes == -1)
    {
      return_value___errno_location_1=__errno_location();
      tmp_if_expr_2 = *return_value___errno_location_1 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
  }
  while(tmp_if_expr_2);
  signed int *return_value___errno_location_8;
  _Bool tmp_if_expr_6;
  signed int *return_value___errno_location_5;
  if(bytes == -1)
  {
    return_value___errno_location_8=__errno_location();
    if(*return_value___errno_location_8 == 11)
    {
      signed int return_value_ci_wait_for_data_4;
      return_value_ci_wait_for_data_4=ci_wait_for_data(fd, timeout, 0x1);
      if(return_value_ci_wait_for_data_4 == 0)
        return bytes;

      do
      {
        signed long int return_value_read_7;
        return_value_read_7=read(fd, buf, count);
        bytes = (signed int)return_value_read_7;
        if(bytes == -1)
        {
          return_value___errno_location_5=__errno_location();
          tmp_if_expr_6 = *return_value___errno_location_5 == 4 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_6 = (_Bool)0;
      }
      while(tmp_if_expr_6);
    }

  }

  if(bytes == 0)
    return -1;

  else
    return bytes;
}

// ci_read_nonblock
// file include/net_io.h line 152
signed int ci_read_nonblock(signed int fd, void *buf, unsigned long int count)
{
  signed int bytes = 0;
  _Bool tmp_if_expr_2;
  signed int *return_value___errno_location_1;
  do
  {
    signed long int return_value_read_3;
    return_value_read_3=read(fd, buf, count);
    bytes = (signed int)return_value_read_3;
    if(bytes == -1)
    {
      return_value___errno_location_1=__errno_location();
      tmp_if_expr_2 = *return_value___errno_location_1 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
  }
  while(tmp_if_expr_2);
  signed int *return_value___errno_location_4;
  if(!(bytes >= 0))
  {
    return_value___errno_location_4=__errno_location();
    if(*return_value___errno_location_4 == 11)
      return 0;

  }

  return bytes;
}

// ci_regex_apply
// file include/ci_regex.h line 46
signed int ci_regex_apply(void * const regex, const char *str, signed int len, signed int recurs, struct ci_list *matches, const void *user_data)
{
  signed int count = 0;
  signed int i;
  struct ci_regex_replace_part parts;
  unsigned long int return_value_strlen_1;
  _Bool tmp_if_expr_3;
  if(str == ((const char *)NULL))
    return 0;

  else
  {
    signed int ovector[30l];
    signed int rc;
    signed int offset = 0;
    signed int str_length;
    unsigned long int tmp_if_expr_2;
    if(len >= 0)
      tmp_if_expr_2 = (unsigned long int)len;

    else
    {
      return_value_strlen_1=strlen(str);
      tmp_if_expr_2 = return_value_strlen_1;
    }
    str_length = (signed int)tmp_if_expr_2;
    do
    {
      memset((void *)ovector, 0, sizeof(signed int [30l]) /*120ul*/ );
      rc=pcre_exec((const struct real_pcre *)regex, (const struct pcre_extra *)(void *)0, str, str_length, offset, 0, ovector, 30);
      if(rc >= 0)
      {
        if(!(ovector[0l] == ovector[1l]))
        {
          count = count + 1;
          if(CI_DEBUG_LEVEL >= 9)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Match pattern (pos:%d-%d): '%.*s'\n", ovector[(signed long int)0], ovector[(signed long int)1], ovector[(signed long int)1] - ovector[(signed long int)0], str + (signed long int)ovector[(signed long int)0]);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Match pattern (pos:%d-%d): '%.*s'\n", ovector[(signed long int)0], ovector[(signed long int)1], ovector[(signed long int)1] - ovector[(signed long int)0], str + (signed long int)ovector[(signed long int)0]);

          }

          offset = ovector[(signed long int)1];
          if(!(matches == ((struct ci_list *)NULL)))
          {
            parts.user_data = user_data;
            memset((void *)parts.matches, 0, sizeof(struct ci_regex_match [10l]) /*160ul*/ );
            i = 0;
            do
            {
              if(!(i >= 10))
                tmp_if_expr_3 = ovector[(signed long int)(2 * i + 1)] > ovector[(signed long int)(2 * i)] ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_3 = (_Bool)0;
              if(!tmp_if_expr_3)
                break;

              if(CI_DEBUG_LEVEL >= 9)
              {
                if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                  __log_error((void *)0, "\t sub-match pattern (pos:%d-%d): '%.*s'\n", ovector[(signed long int)(2 * i)], ovector[(signed long int)(2 * i + 1)], ovector[(signed long int)(2 * i + 1)] - ovector[(signed long int)(2 * i)], str + (signed long int)ovector[(signed long int)(2 * i)]);

                if(!(CI_DEBUG_STDOUT == 0))
                  printf("\t sub-match pattern (pos:%d-%d): '%.*s'\n", ovector[(signed long int)(2 * i)], ovector[(signed long int)(2 * i + 1)], ovector[(signed long int)(2 * i + 1)] - ovector[(signed long int)(2 * i)], str + (signed long int)ovector[(signed long int)(2 * i)]);

              }

              parts.matches[(signed long int)i].s = (unsigned long int)ovector[(signed long int)(2 * i)];
              parts.matches[(signed long int)i].e = (unsigned long int)ovector[(signed long int)(2 * i + 1)];
              i = i + 1;
            }
            while((_Bool)1);
            ci_list_push_back(matches, (void *)&parts);
          }

        }

      }

    }
    while(rc >= 0 && !(recurs == 0) && !(offset >= str_length));
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "ci_regex_apply matches count: %d\n", count);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("ci_regex_apply matches count: %d\n", count);

    }

    return count;
  }
}

// ci_regex_build
// file include/ci_regex.h line 44
void * ci_regex_build(const char *regex_str, signed int regex_flags)
{
  struct real_pcre *re;
  const char *error;
  signed int erroffset;
  re=pcre_compile(regex_str, regex_flags, &error, &erroffset, (const unsigned char *)(void *)0);
  if(re == ((struct real_pcre *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "PCRE compilation failed at offset %d: %s\n", erroffset, error);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("PCRE compilation failed at offset %d: %s\n", erroffset, error);

    }

    return (void *)0;
  }

  else
    return (void *)re;
}

// ci_regex_free
// file include/ci_regex.h line 45
void ci_regex_free(void *regex)
{
  pcre_free((void *)(struct real_pcre *)regex);
}

// ci_regex_parse
// file include/ci_regex.h line 43
char * ci_regex_parse(const char *str, signed int *flags, signed int *recursive)
{
  signed int slen;
  const char *e;
  char *s;
  if(!((signed int)*str == 47))
    return (char *)(void *)0;

  else
  {
    str = str + 1l;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(str);
    slen = (signed int)return_value_strlen_1;
    e = str + (signed long int)slen;
    for( ; !((signed int)*e == 47); e = e - 1l)
      if(e == str)
        break;

    if(!((signed int)*e == 47))
      return (char *)(void *)0;

    else
    {
      slen = (signed int)(e - str);
      void *return_value_malloc_2;
      return_value_malloc_2=malloc((unsigned long int)(slen + 1) * sizeof(char) /*1ul*/ );
      s = (char *)return_value_malloc_2;
      strncpy(s, str, (unsigned long int)slen);
      s[(signed long int)slen] = (char)0;
      *flags = 0;
      *flags = *flags | 0x00400000;
      *flags = *flags | 0x00500000;
      for( ; !((signed int)*e == 0); e = e + 1l)
        if((signed int)*e == 105)
          *flags = *flags | 0x00000001;

        else
          if((signed int)*e == 109)
            *flags = *flags | 0x00000002;

          else
            if((signed int)*e == 115)
              *flags = *flags | 0x00000004;

            else
              if((signed int)*e == 120)
                *flags = *flags | 0x00000008;

              else
                if((signed int)*e == 65)
                  *flags = *flags | 0x00000010;

                else
                  if((signed int)*e == 68)
                    *flags = *flags | 0x00000020;

                  else
                    if((signed int)*e == 85)
                      *flags = *flags | 0x00000200;

                    else
                      if((signed int)*e == 88)
                        *flags = *flags | 0x00000040;

                      else
                        if((signed int)*e == 68)
                          *flags = *flags | 0x00000020;

                        else
                          if((signed int)*e == 117)
                            *flags = *flags | 0x00000800;

                          else
                            if((signed int)*e == 103)
                              *recursive = 1;

      return s;
    }
  }
}

// ci_registry_add_item
// file include/registry.h line 34
signed int ci_registry_add_item(const char *name, const char *label, const void *obj)
{
  struct ci_dyn_array *registry = (struct ci_dyn_array *)(void *)0;
  _Bool tmp_if_expr_4;
  void *return_value_ci_ptr_array_search_3;
  if(REGISTRIES == ((struct ci_array *)NULL))
    tmp_if_expr_4 = (_Bool)1;

  else
  {
    return_value_ci_ptr_array_search_3=ci_ptr_array_search(REGISTRIES, name);
    registry = (struct ci_dyn_array *)return_value_ci_ptr_array_search_3;
    tmp_if_expr_4 = registry == (struct ci_dyn_array *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_4)
  {
    if(CI_DEBUG_LEVEL >= 3)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Registry '%s' does not exist create it\n", name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Registry '%s' does not exist create it\n", name);

    }

    signed int return_value_ci_registry_create_1;
    return_value_ci_registry_create_1=ci_registry_create(name);
    if(!(return_value_ci_registry_create_1 >= 0))
      return 0;

    void *return_value_ci_ptr_array_search_2;
    return_value_ci_ptr_array_search_2=ci_ptr_array_search(REGISTRIES, name);
    registry = (struct ci_dyn_array *)return_value_ci_ptr_array_search_2;
  }

  const struct ci_array_item *return_value_ci_ptr_dyn_array_add_5;
  return_value_ci_ptr_dyn_array_add_5=ci_ptr_dyn_array_add(registry, label, (void *)obj);
  if(!(return_value_ci_ptr_dyn_array_add_5 == ((const struct ci_array_item *)NULL)))
  {
    REG_ITEMS_COUNT = REG_ITEMS_COUNT + 1;
    return REG_ITEMS_COUNT;
  }

  else
    return 0;
}

// ci_registry_clean
// file registry.c line 49
void ci_registry_clean()
{
  struct ci_dyn_array *registry = (struct ci_dyn_array *)(void *)0;
  char buf[1024l];
  void *return_value_ci_ptr_array_pop_value_1;
  if(!(REGISTRIES == ((struct ci_array *)NULL)))
  {
    do
    {
      return_value_ci_ptr_array_pop_value_1=ci_ptr_array_pop_value(REGISTRIES, buf, sizeof(char [1024l]) /*1024ul*/ );
      registry = (struct ci_dyn_array *)return_value_ci_ptr_array_pop_value_1;
      if(registry == ((struct ci_dyn_array *)NULL))
        break;

      if(CI_DEBUG_LEVEL >= 4)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Registry %s removed\n", (const void *)buf);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Registry %s removed\n", (const void *)buf);

      }

      ci_dyn_array_destroy(registry);
    }
    while((_Bool)1);
    ci_array_destroy(REGISTRIES);
    REGISTRIES = (struct ci_array *)(void *)0;
  }

}

// ci_registry_create
// file registry.c line 29
signed int ci_registry_create(const char *name)
{
  void *return_value_ci_ptr_array_search_1;
  if(REGISTRIES == ((struct ci_array *)NULL))
    REGISTRIES=ci_ptr_array_new2((unsigned long int)1024);

  else
  {
    return_value_ci_ptr_array_search_1=ci_ptr_array_search(REGISTRIES, name);
    if(!(return_value_ci_ptr_array_search_1 == NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Registry '%s' already exist!\n", name);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Registry '%s' already exist!\n", name);

      }

      return -1;
    }

  }
  struct ci_dyn_array *registry;
  registry=ci_dyn_array_new((unsigned long int)1024);
  ci_ptr_array_add(REGISTRIES, name, (void *)registry);
  if(CI_DEBUG_LEVEL >= 4)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Registry '%s' added and is ready to store new registry entries\n", name);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Registry '%s' added and is ready to store new registry entries\n", name);

  }

  return (signed int)(REGISTRIES->count - (unsigned int)1);
}

// ci_registry_get_id
// file registry.c line 119
signed int ci_registry_get_id(const char *name)
{
  struct check_reg_data rdata;
  rdata.name = name;
  rdata.found = 0;
  rdata.count = 0;
  if(!(REGISTRIES == ((struct ci_array *)NULL)))
    ci_array_iterate(REGISTRIES, (void *)&rdata, check_reg);

  if(!(rdata.found == 0))
    return rdata.count - 1;

  else
    return -1;
}

// ci_registry_get_item
// file include/registry.h line 35
const void * ci_registry_get_item(const char *name, const char *label)
{
  struct ci_dyn_array *registry = (struct ci_dyn_array *)(void *)0;
  _Bool tmp_if_expr_2;
  void *return_value_ci_ptr_array_search_1;
  if(REGISTRIES == ((struct ci_array *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_ci_ptr_array_search_1=ci_ptr_array_search(REGISTRIES, name);
    registry = (struct ci_dyn_array *)return_value_ci_ptr_array_search_1;
    tmp_if_expr_2 = registry == (struct ci_dyn_array *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Registry '%s' does not exist!\n", name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Registry '%s' does not exist!\n", name);

    }

    return (void *)0;
  }

  else
  {
    const void *return_value_ci_dyn_array_search_3;
    return_value_ci_dyn_array_search_3=ci_dyn_array_search(registry, label);
    return return_value_ci_dyn_array_search_3;
  }
}

// ci_registry_id_get_item
// file registry.c line 147
const void * ci_registry_id_get_item(signed int reg_id, const char *label)
{
  const struct ci_dyn_array *registry = (const struct ci_dyn_array *)(void *)0;
  const struct ci_array_item *ai;
  _Bool tmp_if_expr_1;
  if(REGISTRIES == ((struct ci_array *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
  {
    ai=ci_array_get_item(REGISTRIES, reg_id);
    tmp_if_expr_1 = ai == (const struct ci_array_item *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    registry = (const struct ci_dyn_array *)ai->value;
    tmp_if_expr_2 = registry == (const struct ci_dyn_array *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Registry with id='%d' does not exist!\n", reg_id);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Registry with id='%d' does not exist!\n", reg_id);

    }

    return NULL;
  }

  else
  {
    const void *return_value_ci_dyn_array_search_3;
    return_value_ci_dyn_array_search_3=ci_dyn_array_search(registry, label);
    return return_value_ci_dyn_array_search_3;
  }
}

// ci_registry_id_iterate
// file registry.c line 135
signed int ci_registry_id_iterate(signed int reg_id, void *data, signed int (*fn)(void *, const char *, const void *))
{
  const struct ci_dyn_array *registry = (const struct ci_dyn_array *)(void *)0;
  const struct ci_array_item *ai;
  _Bool tmp_if_expr_1;
  if(REGISTRIES == ((struct ci_array *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
  {
    ai=ci_array_get_item(REGISTRIES, reg_id);
    tmp_if_expr_1 = ai == (const struct ci_array_item *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    registry = (const struct ci_dyn_array *)ai->value;
    tmp_if_expr_2 = registry == (const struct ci_dyn_array *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Registry with id='%d' does not exist!\n", reg_id);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Registry with id='%d' does not exist!\n", reg_id);

    }

    return 0;
  }

  else
  {
    ci_dyn_array_iterate(registry, data, fn);
    return 1;
  }
}

// ci_registry_iterate
// file registry.c line 65
signed int ci_registry_iterate(const char *name, void *data, signed int (*fn)(void *, const char *, const void *))
{
  const struct ci_dyn_array *registry = (const struct ci_dyn_array *)(void *)0;
  _Bool tmp_if_expr_2;
  void *return_value_ci_ptr_array_search_1;
  if(REGISTRIES == ((struct ci_array *)NULL))
    tmp_if_expr_2 = (_Bool)1;

  else
  {
    return_value_ci_ptr_array_search_1=ci_ptr_array_search(REGISTRIES, name);
    registry = (const struct ci_dyn_array *)return_value_ci_ptr_array_search_1;
    tmp_if_expr_2 = registry == (const struct ci_dyn_array *)(void *)0 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_2)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Registry '%s' does not exist!\n", name);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Registry '%s' does not exist!\n", name);

    }

    return 0;
  }

  else
  {
    ci_dyn_array_iterate(registry, data, fn);
    return 1;
  }
}

// ci_request_206_origin_body
// file request_common.c line 436
signed int ci_request_206_origin_body(struct ci_request *req, unsigned long int offset)
{
  if(req == ((struct ci_request *)NULL))
    return 0;

  else
    if(req->allow206 == 0)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Request does not support allow206 responses! Can not set use-original-body extension\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Request does not support allow206 responses! Can not set use-original-body extension\n");

      }

      return 0;
    }

    else
    {
      req->i206_use_original_body = (signed long int)offset;
      return 1;
    }
}

// ci_request_alloc
// file request_common.c line 231
struct ci_request * ci_request_alloc(struct ci_connection *connection)
{
  struct ci_request *req;
  signed int i;
  void *return_value;
  return_value=__intl_malloc((signed int)sizeof(struct ci_request) /*9392ul*/ );
  req = (struct ci_request *)return_value;
  if(req == ((struct ci_request *)NULL))
    return (struct ci_request *)(void *)0;

  else
  {
    req->connection = connection;
    req->packed = 0;
    req->user[(signed long int)0] = (char)0;
    req->access_type = 0;
    req->service[(signed long int)0] = (char)0;
    req->req_server[(signed long int)0] = (char)0;
    req->current_service_mod = (struct ci_service_module *)(void *)0;
    req->service_data = (void *)0;
    req->args[(signed long int)0] = (char)0;
    req->type = -1;
    req->preview = -1;
    ci_buf_init(&req->preview_data);
    req->keepalive = 1;
    req->allow204 = 0;
    req->allow206 = 0;
    req->hasbody = 0;
    req->responce_hasbody = 0;
    req->eof_received = 0;
    req->request_header=ci_headers_create();
    req->response_header=ci_headers_create();
    req->xheaders=ci_headers_create();
    req->status = 0;
    req->return_code = -1;
    req->pstrblock_read = (char *)(void *)0;
    req->pstrblock_read_len = 0;
    req->current_chunk_len = (unsigned int)0;
    req->chunk_bytes_read = (unsigned int)0;
    req->write_to_module_pending = (unsigned int)0;
    req->pstrblock_responce = (char *)(void *)0;
    req->remain_send_block_bytes = 0;
    req->data_locked = 1;
    req->i206_use_original_body = (signed long int)-1;
    req->preview_data_type = -1;
    req->auth_required = 0;
    req->log_str = (char *)(void *)0;
    req->attributes = (struct ci_array *)(void *)0;
    memset((void *)&req->xclient_ip, 0, sizeof(struct ci_ip) /*12ul*/ );
    req->bytes_in = (unsigned long int)0;
    req->bytes_out = (unsigned long int)0;
    req->request_bytes_in = (unsigned long int)0;
    req->http_bytes_in = (unsigned long int)0;
    req->http_bytes_out = (unsigned long int)0;
    req->body_bytes_in = (unsigned long int)0;
    req->body_bytes_out = (unsigned long int)0;
    i = 0;
    if(!(i >= 5))
    {
      req->entities[(signed long int)i] = (struct ci_encaps_entity *)(void *)0;
      i = i + 1;
    }

    i = 0;
    if(!(i >= 7))
    {
      req->trash_entities[(signed long int)i] = (struct ci_encaps_entity *)(void *)0;
      i = i + 1;
    }

    return req;
  }
}

// ci_request_alloc_entity
// file include/request.h line 174
struct ci_encaps_entity * ci_request_alloc_entity(struct ci_request *req, signed int type, signed int val)
{
  struct ci_encaps_entity *e = (struct ci_encaps_entity *)(void *)0;
  if(type >= 6 || !(type >= 0))
    return (struct ci_encaps_entity *)(void *)0;

  else
    if(!(req->trash_entities[(signed long int)type] == ((struct ci_encaps_entity *)NULL)))
    {
      e = req->trash_entities[(signed long int)type];
      req->trash_entities[(signed long int)type] = (struct ci_encaps_entity *)(void *)0;
      e->type = type;
      e->start = val;
      _Bool tmp_if_expr_1;
      if(e->type == 0)
        tmp_if_expr_1 = (_Bool)1;

      else
        tmp_if_expr_1 = e->type == 1 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_1)
      {
        if(!(e->entity == NULL))
          ci_headers_reset((struct ci_headers_list *)e->entity);

      }

      if(CI_DEBUG_LEVEL >= 8)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Get entity from trash....\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Get entity from trash....\n");

      }

      return e;
    }

    else
    {
      if(CI_DEBUG_LEVEL >= 8)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Allocate a new entity of type %d\n", type);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Allocate a new entity of type %d\n", type);

      }

      struct ci_encaps_entity *return_value_mk_encaps_entity_2;
      return_value_mk_encaps_entity_2=mk_encaps_entity(type, val);
      return return_value_mk_encaps_entity_2;
    }
}

// ci_request_destroy
// file request_common.c line 378
void ci_request_destroy(struct ci_request *req)
{
  signed int i;
  if(!(req->connection == ((struct ci_connection *)NULL)))
    __intl_free((void *)req->connection);

  ci_buf_mem_free(&req->preview_data);
  ci_headers_destroy(req->request_header);
  ci_headers_destroy(req->response_header);
  ci_headers_destroy(req->xheaders);
  i = 0;
  for( ; !(req->entities[(signed long int)i] == ((struct ci_encaps_entity *)NULL)); i = i + 1)
    destroy_encaps_entity(req->entities[(signed long int)i]);
  i = 0;
  for( ; !(i >= 7); i = i + 1)
    if(!(req->trash_entities[(signed long int)i] == ((struct ci_encaps_entity *)NULL)))
      destroy_encaps_entity(req->trash_entities[(signed long int)i]);

  if(!(req->log_str == ((char *)NULL)))
    __intl_free((void *)req->log_str);

  if(!(req->attributes == ((struct ci_array *)NULL)))
    ci_array_destroy(req->attributes);

  __intl_free((void *)req);
}

// ci_request_pack
// file request_common.c line 152
void ci_request_pack(struct ci_request *req)
{
  ci_request_t_pack(req, 1);
}

// ci_request_release_entity
// file include/request.h line 175
signed int ci_request_release_entity(struct ci_request *req, signed int pos)
{
  signed int type = 0;
  if(req->entities[(signed long int)pos] == ((struct ci_encaps_entity *)NULL))
    return 0;

  else
  {
    type = req->entities[(signed long int)pos]->type;
    if(type >= 6 || !(type >= 0))
    {
      destroy_encaps_entity(req->entities[(signed long int)pos]);
      req->entities[(signed long int)pos] = (struct ci_encaps_entity *)(void *)0;
      return 0;
    }

    else
    {
      if(!(req->trash_entities[(signed long int)type] == ((struct ci_encaps_entity *)NULL)))
      {
        if(CI_DEBUG_LEVEL >= 3)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "ERROR!!!!! There is an entity of type %d to trash..... ", type);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("ERROR!!!!! There is an entity of type %d to trash..... ", type);

        }

        destroy_encaps_entity(req->trash_entities[(signed long int)type]);
      }

      req->trash_entities[(signed long int)type] = req->entities[(signed long int)pos];
      req->entities[(signed long int)pos] = (struct ci_encaps_entity *)(void *)0;
      return 1;
    }
  }
}

// ci_request_reset
// file request_common.c line 308
void ci_request_reset(struct ci_request *req)
{
  signed int i;
  req->packed = 0;
  req->user[(signed long int)0] = (char)0;
  req->service[(signed long int)0] = (char)0;
  req->current_service_mod = (struct ci_service_module *)(void *)0;
  req->service_data = (void *)0;
  req->args[(signed long int)0] = (char)0;
  req->type = -1;
  req->preview = -1;
  ci_buf_reset(&req->preview_data);
  req->keepalive = 1;
  req->allow204 = 0;
  req->allow206 = 0;
  req->hasbody = 0;
  req->responce_hasbody = 0;
  ci_headers_reset(req->request_header);
  ci_headers_reset(req->response_header);
  ci_headers_reset(req->xheaders);
  req->eof_received = 0;
  req->status = 0;
  req->return_code = -1;
  req->pstrblock_read = (char *)(void *)0;
  req->pstrblock_read_len = 0;
  req->current_chunk_len = (unsigned int)0;
  req->chunk_bytes_read = (unsigned int)0;
  req->pstrblock_responce = (char *)(void *)0;
  req->remain_send_block_bytes = 0;
  req->write_to_module_pending = (unsigned int)0;
  req->data_locked = 1;
  req->i206_use_original_body = (signed long int)-1;
  req->preview_data_type = -1;
  req->auth_required = 0;
  if(!(req->log_str == ((char *)NULL)))
    __intl_free((void *)req->log_str);

  req->log_str = (char *)(void *)0;
  if(!(req->attributes == ((struct ci_array *)NULL)))
    ci_array_destroy(req->attributes);

  req->attributes = (struct ci_array *)(void *)0;
  memset((void *)&req->xclient_ip, 0, sizeof(struct ci_ip) /*12ul*/ );
  req->bytes_in = (unsigned long int)0;
  req->bytes_out = (unsigned long int)0;
  req->request_bytes_in = (unsigned long int)0;
  req->http_bytes_in = (unsigned long int)0;
  req->http_bytes_out = (unsigned long int)0;
  req->body_bytes_in = (unsigned long int)0;
  req->body_bytes_out = (unsigned long int)0;
  i = 0;
  for( ; !(req->entities[(signed long int)i] == ((struct ci_encaps_entity *)NULL)); i = i + 1)
    ci_request_release_entity(req, i);
  if(!(req->trash_entities[0l] == ((struct ci_encaps_entity *)NULL)))
  {
    if(!(req->trash_entities[0l]->entity == NULL))
      ci_headers_reset((struct ci_headers_list *)req->trash_entities[(signed long int)0]->entity);

  }

  if(!(req->trash_entities[1l] == ((struct ci_encaps_entity *)NULL)))
  {
    if(!(req->trash_entities[1l]->entity == NULL))
      ci_headers_reset((struct ci_headers_list *)req->trash_entities[(signed long int)1]->entity);

  }

}

// ci_request_set_log_str
// file request_common.c line 405
char * ci_request_set_log_str(struct ci_request *req, char *logstr)
{
  signed int size;
  if(!(req->log_str == ((char *)NULL)))
    __intl_free((void *)req->log_str);

  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(logstr);
  size = (signed int)(return_value_strlen_1 + (unsigned long int)1);
  void *return_value;
  return_value=__intl_malloc((signed int)((unsigned long int)size * sizeof(char) /*1ul*/ ));
  req->log_str = (char *)return_value;
  if(req->log_str == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    strcpy(req->log_str, logstr);
    return req->log_str;
  }
}

// ci_request_set_str_attribute
// file request_common.c line 419
signed int ci_request_set_str_attribute(struct ci_request *req, const char *name, const char *value)
{
  if(req->attributes == ((struct ci_array *)NULL))
  {
    req->attributes=ci_array_new((unsigned long int)4096);
    if(!(req->attributes == ((struct ci_array *)NULL)))
      goto __CPROVER_DUMP_L3;

    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error allocating request attributes array!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error allocating request attributes array!\n");

    }

    return 0;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(value);
    const struct ci_array_item *return_value_ci_array_add_2;
    return_value_ci_array_add_2=ci_array_add(req->attributes, name, (const void *)value, return_value_strlen_1 + (unsigned long int)1);
    if(return_value_ci_array_add_2 == ((const struct ci_array_item *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Not enough space to add attribute %s:%s for service %s\n", name, value, (const void *)req->service);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Not enough space to add attribute %s:%s for service %s\n", name, value, (const void *)req->service);

      }

      return 0;
    }

    else
      return 1;
  }
}

// ci_request_t_pack
// file request_common.c line 92
void ci_request_t_pack(struct ci_request *req, signed int is_request)
{
  struct ci_encaps_entity **elist;
  struct ci_encaps_entity *e;
  char buf[256l];
  req->packed = 1;
  if(!(is_request == 0))
  {
    if(req->preview >= 0)
    {
      sprintf(buf, "Preview: %d", req->preview);
      ci_headers_add(req->request_header, buf);
    }

  }

  elist = req->entities;
  if(!(*elist == ((struct ci_encaps_entity *)NULL)))
    elist[(signed long int)0]->start = 0;

  if(!(elist[1l] == ((struct ci_encaps_entity *)NULL)))
    elist[(signed long int)1]->start=sizeofencaps(elist[(signed long int)0]);

  if(!(elist[2l] == ((struct ci_encaps_entity *)NULL)))
  {
    signed int return_value_sizeofencaps_1;
    return_value_sizeofencaps_1=sizeofencaps(elist[(signed long int)1]);
    elist[(signed long int)2]->start = return_value_sizeofencaps_1 + elist[(signed long int)1]->start;
  }

  if(*elist == ((struct ci_encaps_entity *)NULL))
    sprintf(buf, "Encapsulated: null-body=0");

  else
    if(!(elist[2l] == ((struct ci_encaps_entity *)NULL)))
    {
      _Bool tmp_if_expr_2;
      if(!((*elist)->type >= 6))
        tmp_if_expr_2 = elist[(signed long int)0]->type >= 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      const char *tmp_if_expr_3;
      if(tmp_if_expr_2)
        tmp_if_expr_3 = ci_encaps_entities[(signed long int)elist[(signed long int)0]->type];

      else
        tmp_if_expr_3 = "UNKNOWN";
      _Bool tmp_if_expr_4;
      if(!(elist[1l]->type >= 6))
        tmp_if_expr_4 = elist[(signed long int)1]->type >= 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_4 = (_Bool)0;
      const char *tmp_if_expr_5;
      if(tmp_if_expr_4)
        tmp_if_expr_5 = ci_encaps_entities[(signed long int)elist[(signed long int)1]->type];

      else
        tmp_if_expr_5 = "UNKNOWN";
      _Bool tmp_if_expr_6;
      if(!(elist[2l]->type >= 6))
        tmp_if_expr_6 = elist[(signed long int)2]->type >= 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_6 = (_Bool)0;
      const char *tmp_if_expr_7;
      if(tmp_if_expr_6)
        tmp_if_expr_7 = ci_encaps_entities[(signed long int)elist[(signed long int)2]->type];

      else
        tmp_if_expr_7 = "UNKNOWN";
      sprintf(buf, "Encapsulated: %s=%d, %s=%d, %s=%d", tmp_if_expr_3, elist[(signed long int)0]->start, tmp_if_expr_5, elist[(signed long int)1]->start, tmp_if_expr_7, elist[(signed long int)2]->start);
    }

    else
      if(!(elist[1l] == ((struct ci_encaps_entity *)NULL)))
      {
        _Bool tmp_if_expr_8;
        if(!((*elist)->type >= 6))
          tmp_if_expr_8 = elist[(signed long int)0]->type >= 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_8 = (_Bool)0;
        const char *tmp_if_expr_9;
        if(tmp_if_expr_8)
          tmp_if_expr_9 = ci_encaps_entities[(signed long int)elist[(signed long int)0]->type];

        else
          tmp_if_expr_9 = "UNKNOWN";
        _Bool tmp_if_expr_10;
        if(!(elist[1l]->type >= 6))
          tmp_if_expr_10 = elist[(signed long int)1]->type >= 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_10 = (_Bool)0;
        const char *tmp_if_expr_11;
        if(tmp_if_expr_10)
          tmp_if_expr_11 = ci_encaps_entities[(signed long int)elist[(signed long int)1]->type];

        else
          tmp_if_expr_11 = "UNKNOWN";
        sprintf(buf, "Encapsulated: %s=%d, %s=%d", tmp_if_expr_9, elist[(signed long int)0]->start, tmp_if_expr_11, elist[(signed long int)1]->start);
      }

      else
      {
        _Bool tmp_if_expr_12;
        if(!((*elist)->type >= 6))
          tmp_if_expr_12 = elist[(signed long int)0]->type >= 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_12 = (_Bool)0;
        const char *tmp_if_expr_13;
        if(tmp_if_expr_12)
          tmp_if_expr_13 = ci_encaps_entities[(signed long int)elist[(signed long int)0]->type];

        else
          tmp_if_expr_13 = "UNKNOWN";
        sprintf(buf, "Encapsulated: %s=%d", tmp_if_expr_13, elist[(signed long int)0]->start);
      }
  if(!(is_request == 0))
    ci_headers_add(req->request_header, buf);

  else
    ci_headers_add(req->response_header, buf);
  struct ci_encaps_entity **tmp_post_14;
  do
  {
    tmp_post_14 = elist;
    elist = elist + 1l;
    e = *tmp_post_14;
    if(e == ((struct ci_encaps_entity *)NULL))
      break;

    _Bool tmp_if_expr_15;
    if(e->type == 0)
      tmp_if_expr_15 = (_Bool)1;

    else
      tmp_if_expr_15 = e->type == 1 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_15)
      ci_headers_pack((struct ci_headers_list *)e->entity);

  }
  while((_Bool)1);
  if(!(is_request == 0))
    ci_headers_pack(req->request_header);

  else
    ci_headers_pack(req->response_header);
}

// ci_response_pack
// file request_common.c line 156
void ci_response_pack(struct ci_request *req)
{
  ci_request_t_pack(req, 0);
}

// ci_ring_buf_consume
// file body.c line 931
void ci_ring_buf_consume(struct ci_ring_buf *buf, signed int len)
{
  if(len >= 1)
  {
    buf->read_pos = buf->read_pos + (signed long int)len;
    if(!(buf->end_buf >= buf->read_pos))
      buf->read_pos = buf->buf;

    if(!(buf->full == 0))
      buf->full = 0;

  }

}

// ci_ring_buf_destroy
// file body.c line 882
void ci_ring_buf_destroy(struct ci_ring_buf *buf)
{
  ci_buffer_free((void *)buf->buf);
  ci_object_pool_free((void *)buf);
}

// ci_ring_buf_is_empty
// file body.c line 888
signed int ci_ring_buf_is_empty(struct ci_ring_buf *buf)
{
  _Bool tmp_if_expr_1;
  if(buf->read_pos == buf->write_pos)
    tmp_if_expr_1 = buf->full == 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  return (signed int)tmp_if_expr_1;
}

// ci_ring_buf_new
// file body.c line 863
struct ci_ring_buf * ci_ring_buf_new(signed int size)
{
  struct ci_ring_buf *buf;
  void *return_value_ci_object_pool_alloc_1;
  return_value_ci_object_pool_alloc_1=ci_object_pool_alloc(RING_BUF_POOL);
  buf = (struct ci_ring_buf *)return_value_ci_object_pool_alloc_1;
  if(buf == ((struct ci_ring_buf *)NULL))
    return (struct ci_ring_buf *)(void *)0;

  else
  {
    void *return_value_ci_buffer_alloc_2;
    return_value_ci_buffer_alloc_2=ci_buffer_alloc(size);
    buf->buf = (char *)return_value_ci_buffer_alloc_2;
    if(buf->buf == ((char *)NULL))
    {
      ci_object_pool_free((void *)buf);
      return (struct ci_ring_buf *)(void *)0;
    }

    else
    {
      buf->end_buf = (buf->buf + (signed long int)size) - (signed long int)1;
      buf->read_pos = buf->buf;
      buf->write_pos = buf->buf;
      buf->full = 0;
      return buf;
    }
  }
}

// ci_ring_buf_produce
// file body.c line 942
void ci_ring_buf_produce(struct ci_ring_buf *buf, signed int len)
{
  if(len >= 1)
  {
    buf->write_pos = buf->write_pos + (signed long int)len;
    if(!(buf->end_buf >= buf->write_pos))
      buf->write_pos = buf->buf;

    if(buf->write_pos == buf->read_pos)
      buf->full = 1;

  }

}

// ci_ring_buf_read
// file body.c line 975
signed int ci_ring_buf_read(struct ci_ring_buf *buf, char *data, signed int size)
{
  char *rb;
  signed int rb_len;
  signed int ret;
  signed int data_read = 0;
  do
  {
    ret=ci_ring_buf_read_block(buf, &rb, &rb_len);
    if(!(rb_len == 0))
    {
      rb_len = size > rb_len ? rb_len : size;
      memcpy((void *)data, (const void *)rb, (unsigned long int)rb_len);
      ci_ring_buf_consume(buf, rb_len);
      size = size - rb_len;
      data = data + (signed long int)rb_len;
      data_read = data_read + rb_len;
    }

  }
  while(size >= 1 && !(ret == 0));
  return data_read;
}

// ci_ring_buf_read_block
// file body.c line 912
signed int ci_ring_buf_read_block(struct ci_ring_buf *buf, char **rb, signed int *len)
{
  _Bool tmp_if_expr_1;
  if(buf->read_pos == buf->write_pos)
    tmp_if_expr_1 = buf->full == 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
  {
    *rb = buf->read_pos;
    *len = 0;
    return 0;
  }

  else
    if(buf->read_pos >= buf->write_pos)
    {
      *rb = buf->read_pos;
      *len = (signed int)((buf->end_buf - buf->read_pos) + (signed long int)1);
      return buf->read_pos != buf->buf ? 1 : 0;
    }

    else
    {
      *rb = buf->read_pos;
      *len = (signed int)(buf->write_pos - buf->read_pos);
      return 0;
    }
}

// ci_ring_buf_write
// file body.c line 955
signed int ci_ring_buf_write(struct ci_ring_buf *buf, const char *data, signed int size)
{
  char *wb;
  signed int wb_len;
  signed int ret;
  signed int written = 0;
  do
  {
    ret=ci_ring_buf_write_block(buf, &wb, &wb_len);
    if(!(wb_len == 0))
    {
      wb_len = size > wb_len ? wb_len : size;
      memcpy((void *)wb, (const void *)data, (unsigned long int)wb_len);
      ci_ring_buf_produce(buf, wb_len);
      size = size - wb_len;
      data = data + (signed long int)wb_len;
      written = written + wb_len;
    }

  }
  while(size >= 1 && !(ret == 0));
  return written;
}

// ci_ring_buf_write_block
// file body.c line 893
signed int ci_ring_buf_write_block(struct ci_ring_buf *buf, char **wb, signed int *len)
{
  _Bool tmp_if_expr_1;
  if(buf->read_pos == buf->write_pos)
    tmp_if_expr_1 = buf->full == 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  if(tmp_if_expr_1)
  {
    *wb = buf->write_pos;
    *len = (signed int)((buf->end_buf - buf->write_pos) + (signed long int)1);
    return 0;
  }

  else
    if(buf->read_pos >= buf->write_pos)
    {
      *wb = buf->write_pos;
      *len = (signed int)(buf->read_pos - buf->write_pos);
      return 0;
    }

    else
    {
      *wb = buf->write_pos;
      *len = (signed int)((buf->end_buf - buf->write_pos) + (signed long int)1);
      return 1;
    }
}

// ci_service_add_xincludes
// file service_lib.c line 125
void ci_service_add_xincludes(struct ci_service_xdata *srv_xdata, char **xincludes)
{
  signed int len;
  signed int i;
  len = 0;
  i = 0;
  if(!(xincludes == ((char **)NULL)))
  {
    pthread_rwlock_wrlock(&srv_xdata->lock);
    while(511 + -len + -2 >= 1)
    {
      if(xincludes[(signed long int)i] == ((char *)NULL))
        break;

      if(!(len == 0))
      {
        strcat(srv_xdata->xincludes, ", ");
        len = len + 2;
      }

      strncat(srv_xdata->xincludes, xincludes[(signed long int)i], (unsigned long int)(511 - len));
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(xincludes[(signed long int)i]);
      len = len + (signed int)return_value_strlen_1;
      i = i + 1;
    }
    pthread_rwlock_unlock(&srv_xdata->lock);
  }

}

// ci_service_add_xopts
// file service_lib.c line 118
void ci_service_add_xopts(struct ci_service_xdata *srv_xdata, unsigned long int xopts)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  srv_xdata->xopts = srv_xdata->xopts | xopts;
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_data_read_lock
// file service_lib.c line 25
void ci_service_data_read_lock(struct ci_service_xdata *srv_xdata)
{
  pthread_rwlock_rdlock(&srv_xdata->lock);
}

// ci_service_data_read_unlock
// file service_lib.c line 30
void ci_service_data_read_unlock(struct ci_service_xdata *srv_xdata)
{
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_enable_204
// file service_lib.c line 82
void ci_service_enable_204(struct ci_service_xdata *srv_xdata)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  srv_xdata->allow_204 = 1;
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_enable_206
// file service_lib.c line 89
void ci_service_enable_206(struct ci_service_xdata *srv_xdata)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  if(srv_xdata->disable_206 == 0)
    srv_xdata->allow_206 = 1;

  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_set_istag
// file service_lib.c line 35
void ci_service_set_istag(struct ci_service_xdata *srv_xdata, const char *istag)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  strncpy(srv_xdata->ISTag + (signed long int)13, istag, (unsigned long int)(39 - 13));
  srv_xdata->ISTag[(signed long int)39] = (char)0;
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_set_max_connections
// file service_lib.c line 97
void ci_service_set_max_connections(struct ci_service_xdata *srv_xdata, signed int max_connections)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  srv_xdata->max_connections = max_connections;
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_set_options_ttl
// file service_lib.c line 104
void ci_service_set_options_ttl(struct ci_service_xdata *srv_xdata, signed int ttl)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  srv_xdata->options_ttl = ttl;
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_set_preview
// file service_lib.c line 75
void ci_service_set_preview(struct ci_service_xdata *srv_xdata, signed int preview)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  srv_xdata->preview_size = preview;
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_set_transfer_complete
// file service_lib.c line 64
void ci_service_set_transfer_complete(struct ci_service_xdata *srv_xdata, const char *complete)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  strcpy(srv_xdata->TransferComplete, "Transfer-Complete: ");
  strncat(srv_xdata->TransferComplete, complete, (unsigned long int)1023 - sizeof(char [20l]) /*20ul*/ );
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_set_transfer_ignore
// file service_lib.c line 54
void ci_service_set_transfer_ignore(struct ci_service_xdata *srv_xdata, const char *ignore)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  strcpy(srv_xdata->TransferIgnore, "Transfer-Ignore: ");
  strncat(srv_xdata->TransferIgnore, ignore, (unsigned long int)1023 - sizeof(char [18l]) /*18ul*/ );
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_set_transfer_preview
// file service_lib.c line 44
void ci_service_set_transfer_preview(struct ci_service_xdata *srv_xdata, const char *preview)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  strcpy(srv_xdata->TransferPreview, "Transfer-Preview: ");
  strncat(srv_xdata->TransferPreview, preview, (unsigned long int)1023 - sizeof(char [19l]) /*19ul*/ );
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_service_set_xopts
// file service_lib.c line 111
void ci_service_set_xopts(struct ci_service_xdata *srv_xdata, unsigned long int xopts)
{
  pthread_rwlock_wrlock(&srv_xdata->lock);
  srv_xdata->xopts = xopts;
  pthread_rwlock_unlock(&srv_xdata->lock);
}

// ci_shared_mem_attach
// file os/unix/shared_mem.c line 262
void * ci_shared_mem_attach(struct ci_shared_mem_id *id)
{
  _Bool tmp_if_expr_1;
  if(!(id == ((struct ci_shared_mem_id *)NULL)))
    tmp_if_expr_1 = id->scheme != ((const struct ci_shared_mem_scheme *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  /* assertion id && id->scheme */
  assert(tmp_if_expr_1);
  void *return_value;
  return_value=id->scheme->shared_mem_attach(id);
  return return_value;
}

// ci_shared_mem_create
// file os/unix/shared_mem.c line 252
void * ci_shared_mem_create(struct ci_shared_mem_id *id, const char *name, signed int size)
{
  if(default_scheme == ((const struct ci_shared_mem_scheme *)NULL))
    return (void *)0;

  else
  {
    id->scheme = default_scheme;
    void *return_value;
    return_value=default_scheme->shared_mem_create(id, name, size);
    return return_value;
  }
}

// ci_shared_mem_destroy
// file os/unix/shared_mem.c line 276
signed int ci_shared_mem_destroy(struct ci_shared_mem_id *id)
{
  _Bool tmp_if_expr_1;
  if(!(id == ((struct ci_shared_mem_id *)NULL)))
    tmp_if_expr_1 = id->scheme != ((const struct ci_shared_mem_scheme *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  /* assertion id && id->scheme */
  assert(tmp_if_expr_1);
  signed int return_value;
  return_value=id->scheme->shared_mem_destroy(id);
  return return_value;
}

// ci_shared_mem_detach
// file os/unix/shared_mem.c line 269
signed int ci_shared_mem_detach(struct ci_shared_mem_id *id)
{
  _Bool tmp_if_expr_1;
  if(!(id == ((struct ci_shared_mem_id *)NULL)))
    tmp_if_expr_1 = id->scheme != ((const struct ci_shared_mem_scheme *)NULL) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  /* assertion id && id->scheme */
  assert(tmp_if_expr_1);
  signed int return_value;
  return_value=id->scheme->shared_mem_detach(id);
  return return_value;
}

// ci_shared_mem_set_scheme
// file os/unix/shared_mem.c line 227
signed int ci_shared_mem_set_scheme(const char *name)
{
  signed int return_value_strcasecmp_3;
  return_value_strcasecmp_3=strcasecmp(name, "posix");
  signed int return_value_strcasecmp_2;
  signed int return_value_strcasecmp_1;
  if(return_value_strcasecmp_3 == 0)
    default_scheme = &posix_scheme;

  else
  {
    return_value_strcasecmp_2=strcasecmp(name, "mmap");
    if(return_value_strcasecmp_2 == 0)
      default_scheme = &mmap_scheme;

    else
    {
      return_value_strcasecmp_1=strcasecmp(name, "sysv");
      if(return_value_strcasecmp_1 == 0)
        default_scheme = &sysv_scheme;

      else
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Shared mem scheme '%s' does not supported by c-icap\n", name);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Shared mem scheme '%s' does not supported by c-icap\n", name);

        }

        return 0;
      }
    }
  }
  return 1;
}

// ci_simple_file_destroy
// file body.c line 643
void ci_simple_file_destroy(struct ci_simple_file *body)
{
  if(!(body == ((struct ci_simple_file *)NULL)))
  {
    if(body->fd >= 0)
    {
      do_close(body->fd);
      unlink(body->filename);
    }

    if(!(body->attributes == ((struct ci_array *)NULL)))
      ci_array_destroy(body->attributes);

    if(!(body->mmap_addr == ((char *)NULL)))
      munmap((void *)body->mmap_addr, (unsigned long int)body->mmap_size);

    ci_object_pool_free((void *)body);
  }

}

// ci_simple_file_named_new
// file body.c line 601
struct ci_simple_file * ci_simple_file_named_new(char *dir, char *filename, signed long int maxsize)
{
  struct ci_simple_file *body;
  void *return_value_ci_object_pool_alloc_1;
  return_value_ci_object_pool_alloc_1=ci_object_pool_alloc(SIMPLE_FILE_POOL);
  body = (struct ci_simple_file *)return_value_ci_object_pool_alloc_1;
  if(body == ((struct ci_simple_file *)NULL))
    return (struct ci_simple_file *)(void *)0;

  else
  {
    if(!(filename == ((char *)NULL)))
    {
      snprintf(body->filename, (unsigned long int)4096, "%s/%s", dir, filename);
      body->fd=do_open(body->filename, 0100 | 02 | 0200);
      if(!(body->fd >= 0))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Can not open temporary filename: %s\n", (const void *)body->filename);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Can not open temporary filename: %s\n", (const void *)body->filename);

        }

        ci_object_pool_free((void *)body);
        return (struct ci_simple_file *)(void *)0;
      }

    }

    else
    {
      body->fd=ci_mktemp_file(dir, "CI_TMP_XXXXXX", body->filename);
      if(!(body->fd >= 0))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Can not open temporary filename in directory: %s\n", dir);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Can not open temporary filename in directory: %s\n", dir);

        }

        ci_object_pool_free((void *)body);
        return (struct ci_simple_file *)(void *)0;
      }

    }
    body->endpos = (signed long int)0;
    body->readpos = (signed long int)0;
    body->flags = (unsigned int)0;
    body->unlocked = (signed long int)0;
    body->max_store_size = maxsize > (signed long int)0 ? maxsize : (signed long int)0;
    body->bytes_in = (signed long int)0;
    body->bytes_out = (signed long int)0;
    body->attributes = (struct ci_array *)(void *)0;
    body->mmap_addr = (char *)(void *)0;
    body->mmap_size = (signed long int)0;
    return body;
  }
}

// ci_simple_file_new
// file body.c line 571
struct ci_simple_file * ci_simple_file_new(signed long int maxsize)
{
  struct ci_simple_file *body;
  void *return_value_ci_object_pool_alloc_1;
  return_value_ci_object_pool_alloc_1=ci_object_pool_alloc(SIMPLE_FILE_POOL);
  body = (struct ci_simple_file *)return_value_ci_object_pool_alloc_1;
  if(body == ((struct ci_simple_file *)NULL))
    return (struct ci_simple_file *)(void *)0;

  else
  {
    body->fd=ci_mktemp_file(CI_TMPDIR, "CI_TMP_XXXXXX", body->filename);
    if(!(body->fd >= 0))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "ci_simple_file_new: Can not open temporary filename in directory:%s\n", CI_TMPDIR);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("ci_simple_file_new: Can not open temporary filename in directory:%s\n", CI_TMPDIR);

      }

      ci_object_pool_free((void *)body);
      return (struct ci_simple_file *)(void *)0;
    }

    else
    {
      if(CI_DEBUG_LEVEL >= 5)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "ci_simple_file_new: Use temporary filename: %s\n", (const void *)body->filename);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("ci_simple_file_new: Use temporary filename: %s\n", (const void *)body->filename);

      }

      body->endpos = (signed long int)0;
      body->readpos = (signed long int)0;
      body->flags = (unsigned int)0;
      body->unlocked = (signed long int)0;
      body->max_store_size = maxsize > (signed long int)0 ? maxsize : (signed long int)0;
      body->bytes_in = (signed long int)0;
      body->bytes_out = (signed long int)0;
      body->attributes = (struct ci_array *)(void *)0;
      return body;
    }
  }
}

// ci_simple_file_read
// file body.c line 750
signed int ci_simple_file_read(struct ci_simple_file *body, char *buf, signed int len)
{
  signed int remains;
  signed int bytes;
  if(!(len >= 1))
    return 0;

  else
    if(body->readpos == body->endpos)
    {
      if(!((2u & body->flags) == 0u))
      {
        if(CI_DEBUG_LEVEL >= 9)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Has EOF and no data to read, send EOF\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Has EOF and no data to read, send EOF\n");

        }

        return -2;
      }

      return 0;
    }

    else
    {
      if(!(body->max_store_size == 0l))
      {
        if(body->readpos == body->max_store_size)
          body->readpos = (signed long int)0;

      }

      _Bool tmp_if_expr_1;
      if(!((1u & body->flags) == 0u))
        tmp_if_expr_1 = body->unlocked >= (signed long int)0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(tmp_if_expr_1)
        remains = (signed int)(body->unlocked - body->readpos);

      else
        if(!(body->readpos >= body->endpos))
          remains = (signed int)(body->endpos - body->readpos);

        else
          if(!(body->max_store_size == 0l))
            remains = (signed int)(body->max_store_size - body->readpos);

          else
          {
            if(CI_DEBUG_LEVEL >= 9)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "Error? anyway send EOF\n");

              if(!(CI_DEBUG_STDOUT == 0))
                printf("Error? anyway send EOF\n");

            }

            return -2;
          }
      bytes = remains > len ? len : remains;
      lseek64(body->fd, body->readpos, 0);
      bytes=do_read(body->fd, (void *)buf, (unsigned long int)bytes);
      if(bytes >= 1)
      {
        body->readpos = body->readpos + (signed long int)bytes;
        body->bytes_out = body->bytes_out + (signed long int)bytes;
      }

      return bytes;
    }
}

// ci_simple_file_release
// file body.c line 665
void ci_simple_file_release(struct ci_simple_file *body)
{
  if(!(body == ((struct ci_simple_file *)NULL)))
  {
    if(body->fd >= 0)
      do_close(body->fd);

    if(!(body->attributes == ((struct ci_array *)NULL)))
      ci_array_destroy(body->attributes);

    if(!(body->mmap_addr == ((char *)NULL)))
      munmap((void *)body->mmap_addr, (unsigned long int)body->mmap_size);

    ci_object_pool_free((void *)body);
  }

}

// ci_simple_file_to_const_string
// file body.c line 824
const char * ci_simple_file_to_const_string(struct ci_simple_file *body)
{
  signed long int map_size;
  char *addr = (char *)(void *)0;
  if((2u & body->flags) == 0u)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "mmap to file: '%s' failed, the eof flag is not set!\n", (const void *)body->filename);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("mmap to file: '%s' failed, the eof flag is not set!\n", (const void *)body->filename);

    }

    return (const char *)(void *)0;
  }

  else
  {
    map_size = body->endpos + (signed long int)1;
    if(body->mmap_addr == ((char *)NULL))
    {
      void *return_value_mmap64_1;
      return_value_mmap64_1=mmap64((void *)0, (unsigned long int)map_size, 0x1 | 0x2, 0x02, body->fd, (signed long int)0);
      addr = (char *)return_value_mmap64_1;
      if(addr == ((char *)NULL))
        return ((const char *)NULL);

      addr[map_size - (signed long int)1] = (char)0;
      body->mmap_addr = addr;
      body->mmap_size = map_size;
    }

    return body->mmap_addr;
  }
}

// ci_simple_file_to_membuf
// file body.c line 848
struct ci_membuf * ci_simple_file_to_membuf(struct ci_simple_file *body, unsigned int flags)
{
  /* assertion ((0x08 | 0x04 | 0x01) & flags) ==flags */
  assert(((unsigned int)(0x08 | 0x04 | 0x01) & flags) == flags);
  /* assertion flags & 0x08 */
  assert((flags & (unsigned int)0x08) != 0u);
  void *addr;
  const char *return_value_ci_simple_file_to_const_string_1;
  return_value_ci_simple_file_to_const_string_1=ci_simple_file_to_const_string(body);
  addr = (void *)return_value_ci_simple_file_to_const_string_1;
  if(addr == NULL)
    return (struct ci_membuf *)(void *)0;

  else
  {
    struct ci_membuf *return_value_ci_membuf_from_content_2;
    return_value_ci_membuf_from_content_2=ci_membuf_from_content(body->mmap_addr, (unsigned long int)body->mmap_size, (unsigned long int)body->endpos, (unsigned int)(0x08 | 0x04 | 0x01 | 0x02));
    return return_value_ci_membuf_from_content_2;
  }
}

// ci_simple_file_truncate
// file body.c line 797
signed int ci_simple_file_truncate(struct ci_simple_file *body, signed long int new_size)
{
  if(!(body->endpos >= new_size))
    return 0;

  else
  {
    if(new_size == 0l)
    {
      new_size=lseek64(body->fd, (signed long int)0, 2);
      if(!(body->endpos >= new_size))
        return 0;

    }

    else
    {
      signed int return_value_ftruncate64_1;
      return_value_ftruncate64_1=ftruncate64(body->fd, new_size);
      if(!(return_value_ftruncate64_1 == 0))
        return 0;

    }
    body->endpos = new_size;
    if(!(new_size >= body->readpos))
      body->readpos = new_size;

    if(!(new_size >= body->unlocked))
      body->unlocked = new_size;

    return 1;
  }
}

// ci_simple_file_write
// file body.c line 686
signed int ci_simple_file_write(struct ci_simple_file *body, const char *buf, signed int len, signed int iseof)
{
  signed int ret;
  signed int wsize = 0;
  signed int *return_value___errno_location_6;
  char *return_value_strerror_7;
  signed int *return_value___errno_location_8;
  char *return_value_strerror_9;
  if(!((2u & body->flags) == 0u))
  {
    if(len >= 1)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Cannot write to file: '%s', the eof flag is set!\n", (const void *)body->filename);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Cannot write to file: '%s', the eof flag is set!\n", (const void *)body->filename);

      }

    }

    return 0;
  }

  else
    if(!(len >= 1))
    {
      if(!(iseof == 0))
        body->flags = body->flags | (unsigned int)0x02;

      return 0;
    }

    else
    {
      if(!(body->endpos >= body->readpos))
      {
        signed long int tmp_if_expr_1;
        if(!((signed long int)len >= body->readpos + -body->endpos + -1l))
          tmp_if_expr_1 = (signed long int)len;

        else
          tmp_if_expr_1 = (body->readpos - body->endpos) - (signed long int)1;
        wsize = (signed int)tmp_if_expr_1;
      }

      else
      {
        _Bool tmp_if_expr_5;
        if(!(body->max_store_size == 0l))
          tmp_if_expr_5 = body->endpos >= body->max_store_size ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_5 = (_Bool)0;
        if(tmp_if_expr_5)
        {
          _Bool tmp_if_expr_3;
          if(!(body->readpos == 0l))
            tmp_if_expr_3 = (body->flags & (unsigned int)0x01) == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_3 = (_Bool)0;
          if(tmp_if_expr_3)
          {
            body->endpos = (signed long int)0;
            if((4u & body->flags) == 0u)
            {
              body->flags = body->flags | (unsigned int)0x04;
              if(CI_DEBUG_LEVEL >= 9)
              {
                if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                  __log_error((void *)0, "Entering Ring mode!\n");

                if(!(CI_DEBUG_STDOUT == 0))
                  printf("Entering Ring mode!\n");

              }

            }

            signed long int tmp_if_expr_2;
            if(!((signed long int)len >= body->readpos + -body->endpos + -1l))
              tmp_if_expr_2 = (signed long int)len;

            else
              tmp_if_expr_2 = (body->readpos - body->endpos) - (signed long int)1;
            wsize = (signed int)tmp_if_expr_2;
          }

          else
          {
            if(!((1u & body->flags) == 0u))
            {
              if(CI_DEBUG_LEVEL >= 1)
              {
                if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                  __log_error((void *)0, "File locked and no space on file for writing data, (Is this a bug?)!\n");

                if(!(CI_DEBUG_STDOUT == 0))
                  printf("File locked and no space on file for writing data, (Is this a bug?)!\n");

              }

            }

            return 0;
          }
        }

        else
          if(!(body->max_store_size == 0l))
          {
            signed long int tmp_if_expr_4;
            if(!((signed long int)len >= body->max_store_size + -body->endpos))
              tmp_if_expr_4 = (signed long int)len;

            else
              tmp_if_expr_4 = body->max_store_size - body->endpos;
            wsize = (signed int)tmp_if_expr_4;
          }

          else
            wsize = len;
      }
      lseek64(body->fd, body->endpos, 0);
      ret=do_write(body->fd, (const void *)buf, (unsigned long int)wsize);
      if(!(ret >= 0))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          {
            return_value___errno_location_6=__errno_location();
            return_value_strerror_7=strerror(*return_value___errno_location_6);
            __log_error((void *)0, "Cannot write to file: %s\n", return_value_strerror_7);
          }

          if(!(CI_DEBUG_STDOUT == 0))
          {
            return_value___errno_location_8=__errno_location();
            return_value_strerror_9=strerror(*return_value___errno_location_8);
            printf("Cannot write to file: %s\n", return_value_strerror_9);
          }

        }

      }

      else
      {
        body->endpos = body->endpos + (signed long int)ret;
        body->bytes_in = body->bytes_in + (signed long int)ret;
      }
      if(ret == len && !(iseof == 0))
      {
        body->flags = body->flags | (unsigned int)0x02;
        if(CI_DEBUG_LEVEL >= 9)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Body data size=%lld\n ", (signed long long int)body->endpos);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Body data size=%lld\n ", (signed long long int)body->endpos);

        }

      }

      return ret;
    }
}

// ci_sockaddr_set_port
// file include/net_io.h line 131
void ci_sockaddr_set_port(struct ci_sockaddr *addr, signed int port)
{
  addr->sockaddr.sin_port=htons((unsigned short int)port);
  addr->ci_sin_port = (signed int)addr->sockaddr.sin_port;
}

// ci_sockaddr_t_to_host
// file include/net_io.h line 135
const char * ci_sockaddr_t_to_host(struct ci_sockaddr *addr, char *hname, signed int maxhostlen)
{
  getnameinfo((struct sockaddr *)&addr->sockaddr, (unsigned int)(addr->ci_sin_family == 10 ? sizeof(struct sockaddr_in6) /*28ul*/  : sizeof(struct sockaddr_in) /*16ul*/ ), hname, (unsigned int)(maxhostlen - 1), (char *)(void *)0, (unsigned int)0, 0);
  return (const char *)hname;
}

// ci_sockaddr_t_to_ip
// file include/net_io.h line 123
const char * ci_sockaddr_t_to_ip(struct ci_sockaddr *addr, char *ip, signed int maxlen)
{
  const char *return_value_ci_inet_ntoa_1;
  return_value_ci_inet_ntoa_1=ci_inet_ntoa(addr->ci_sin_family, addr->ci_sin_addr, ip, maxlen);
  return return_value_ci_inet_ntoa_1;
}

// ci_stat_area_construct
// file stats.c line 198
struct stat_area * ci_stat_area_construct(void *mem_block, signed int size, void (*release_mem)(void *))
{
  struct stat_area *area = (struct stat_area *)(void *)0;
  signed int return_value_ci_stat_memblock_size_1;
  return_value_ci_stat_memblock_size_1=ci_stat_memblock_size();
  if(!(size >= return_value_ci_stat_memblock_size_1))
    return (struct stat_area *)(void *)0;

  else
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc(sizeof(struct stat_area) /*56ul*/ );
    area = (struct stat_area *)return_value_malloc_2;
    if(area == ((struct stat_area *)NULL))
      return (struct stat_area *)(void *)0;

    else
    {
      /* assertion ((struct stat_memblock *)mem_block)->sig == 0xFAFA */
      assert(((struct stat_memblock *)mem_block)->sig == (unsigned int)0xFAFA);
      ci_thread_mutex_init(&area->mtx);
      area->mem_block = (struct stat_memblock *)mem_block;
      area->release_mem = release_mem;
      area->mem_block->counters64 = (unsigned long int *)(mem_block + (signed long int)(sizeof(struct stat_memblock) /*32ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)));
      area->mem_block->counterskbs = (struct kbs *)(mem_block + (signed long int)(sizeof(struct stat_memblock) /*32ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + (signed long int)((unsigned long int)STAT_INT64.entries_num * sizeof(unsigned long int) /*8ul*/ ));
      area->mem_block->counters64_size = STAT_INT64.entries_num;
      area->mem_block->counterskbs_size = STAT_KBS.entries_num;
      ci_stat_area_reset(area);
      return area;
    }
  }
}

// ci_stat_area_destroy
// file stats.c line 236
void ci_stat_area_destroy(struct stat_area *area)
{
  ci_thread_mutex_destroy(&area->mtx);
  if(!(area->release_mem == ((void (*)(void *))NULL)))
    area->release_mem((void *)area->mem_block);

  free((void *)area);
}

// ci_stat_area_kbs_inc
// file stats.c line 257
void ci_stat_area_kbs_inc(struct stat_area *area, signed int ID, signed int count)
{
  if(!(area->mem_block == ((struct stat_memblock *)NULL)))
  {
    _Bool tmp_if_expr_1;
    if(!(ID >= 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = ID >= area->mem_block->counterskbs_size ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_1)
    {
      pthread_mutex_lock(&area->mtx);
      (area->mem_block->counterskbs + (signed long int)ID)->bytes = (area->mem_block->counterskbs + (signed long int)ID)->bytes + (unsigned int)count;
      (area->mem_block->counterskbs + (signed long int)ID)->kb = (area->mem_block->counterskbs + (signed long int)ID)->kb + (unsigned long int)((area->mem_block->counterskbs + (signed long int)ID)->bytes >> 10);
      (area->mem_block->counterskbs + (signed long int)ID)->bytes = (area->mem_block->counterskbs + (signed long int)ID)->bytes & (unsigned int)0x3FF;
      pthread_mutex_unlock(&area->mtx);
    }

  }

}

// ci_stat_area_merge
// file stats.c line 322
void ci_stat_area_merge(struct stat_area *dest, struct stat_area *src)
{
  _Bool tmp_if_expr_1;
  if(dest->mem_block == ((struct stat_memblock *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(src->mem_block != ((struct stat_memblock *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr_1)
    ci_stat_memblock_merge(dest->mem_block, src->mem_block);

}

// ci_stat_area_reset
// file stats.c line 221
void ci_stat_area_reset(struct stat_area *area)
{
  signed int i;
  pthread_mutex_lock(&area->mtx);
  i = 0;
  for( ; !(i >= area->mem_block->counters64_size); i = i + 1)
    area->mem_block->counters64[(signed long int)i] = (unsigned long int)0;
  i = 0;
  for( ; !(i >= area->mem_block->counterskbs_size); i = i + 1)
  {
    (area->mem_block->counterskbs + (signed long int)i)->kb = (unsigned long int)0;
    (area->mem_block->counterskbs + (signed long int)i)->bytes = (unsigned int)0;
  }
  pthread_mutex_unlock(&area->mtx);
}

// ci_stat_area_uint64_inc
// file stats.c line 245
void ci_stat_area_uint64_inc(struct stat_area *area, signed int ID, signed int count)
{
  if(!(area->mem_block == ((struct stat_memblock *)NULL)))
  {
    _Bool tmp_if_expr_1;
    if(!(ID >= 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = ID >= area->mem_block->counters64_size ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_1)
    {
      pthread_mutex_lock(&area->mtx);
      area->mem_block->counters64[(signed long int)ID] = area->mem_block->counters64[(signed long int)ID] + (unsigned long int)count;
      pthread_mutex_unlock(&area->mtx);
    }

  }

}

// ci_stat_attach_mem
// file stats.c line 152
void ci_stat_attach_mem(void *mem_block, signed int size, void (*release_mem)(void *))
{
  if(STATS == ((struct stat_area *)NULL))
    STATS=ci_stat_area_construct(mem_block, size, release_mem);

}

// ci_stat_entry_register
// file stats.c line 129
signed int ci_stat_entry_register(char *label, signed int type, char *group)
{
  signed int gid;
  gid=stat_group_add(group);
  if(!(gid >= 0))
    return -1;

  else
  {
    if(type == 0)
    {
      signed int return_value_stat_entry_add_1;
      return_value_stat_entry_add_1=stat_entry_add(&STAT_INT64, label, type, gid);
      return return_value_stat_entry_add_1;
    }

    else
      if(type == 1)
      {
        signed int return_value_stat_entry_add_2;
        return_value_stat_entry_add_2=stat_entry_add(&STAT_KBS, label, type, gid);
        return return_value_stat_entry_add_2;
      }

    return -1;
  }
}

// ci_stat_entry_release_lists
// file stats.c line 146
void ci_stat_entry_release_lists()
{
  stat_entry_release_list(&STAT_INT64);
  stat_entry_release_list(&STAT_KBS);
}

// ci_stat_kbs_inc
// file stats.c line 179
void ci_stat_kbs_inc(signed int ID, signed int count)
{
  if(!(STATS->mem_block == ((struct stat_memblock *)NULL)))
  {
    _Bool tmp_if_expr_1;
    if(!(ID >= 0))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = ID >= STATS->mem_block->counterskbs_size ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_1)
    {
      pthread_mutex_lock(&STATS->mtx);
      (STATS->mem_block->counterskbs + (signed long int)ID)->bytes = (STATS->mem_block->counterskbs + (signed long int)ID)->bytes + (unsigned int)count;
      (STATS->mem_block->counterskbs + (signed long int)ID)->kb = (STATS->mem_block->counterskbs + (signed long int)ID)->kb + (unsigned long int)((STATS->mem_block->counterskbs + (signed long int)ID)->bytes >> 10);
      (STATS->mem_block->counterskbs + (signed long int)ID)->bytes = (STATS->mem_block->counterskbs + (signed long int)ID)->bytes & (unsigned int)0x3FF;
      pthread_mutex_unlock(&STATS->mtx);
    }

  }

}

// ci_stat_memblock_merge
// file stats.c line 303
void ci_stat_memblock_merge(struct stat_memblock *dest_block, struct stat_memblock *mem_block)
{
  signed int i;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if(!(dest_block == ((struct stat_memblock *)NULL)) && !(mem_block == ((struct stat_memblock *)NULL)))
  {
    i = 0;
    do
    {
      if(!(i >= dest_block->counters64_size))
        tmp_if_expr_1 = i < mem_block->counters64_size ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(!tmp_if_expr_1)
        break;

      dest_block->counters64[(signed long int)i] = dest_block->counters64[(signed long int)i] + mem_block->counters64[(signed long int)i];
      i = i + 1;
    }
    while((_Bool)1);
    i = 0;
    do
    {
      if(!(i >= dest_block->counterskbs_size))
        tmp_if_expr_2 = i < mem_block->counterskbs_size ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(!tmp_if_expr_2)
        break;

      (dest_block->counterskbs + (signed long int)i)->kb = (dest_block->counterskbs + (signed long int)i)->kb + (mem_block->counterskbs + (signed long int)i)->kb;
      (dest_block->counterskbs + (signed long int)i)->bytes = (dest_block->counterskbs + (signed long int)i)->bytes + (mem_block->counterskbs + (signed long int)i)->bytes;
      (dest_block->counterskbs + (signed long int)i)->kb = (dest_block->counterskbs + (signed long int)i)->kb + (unsigned long int)((dest_block->counterskbs + (signed long int)i)->bytes >> 10);
      (dest_block->counterskbs + (signed long int)i)->bytes = (dest_block->counterskbs + (signed long int)i)->bytes & (unsigned int)0x3FF;
      i = i + 1;
    }
    while((_Bool)1);
  }

}

// ci_stat_memblock_reset
// file stats.c line 292
void ci_stat_memblock_reset(struct stat_memblock *block)
{
  signed int i = 0;
  for( ; !(i >= block->counters64_size); i = i + 1)
    block->counters64[(signed long int)i] = (unsigned long int)0;
  i = 0;
  for( ; !(i >= block->counterskbs_size); i = i + 1)
  {
    (block->counterskbs + (signed long int)i)->kb = (unsigned long int)0;
    (block->counterskbs + (signed long int)i)->bytes = (unsigned int)0;
  }
}

// ci_stat_memblock_size
// file stats.c line 33
signed int ci_stat_memblock_size(void)
{
  return (signed int)((sizeof(struct stat_memblock) /*32ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + (unsigned long int)STAT_INT64.entries_num * sizeof(unsigned long int) /*8ul*/  + (unsigned long int)STAT_KBS.entries_num * sizeof(struct kbs) /*16ul*/ );
}

// ci_stat_release
// file stats.c line 160
void ci_stat_release()
{
  if(!(STATS == ((struct stat_area *)NULL)))
  {
    ci_stat_area_destroy(STATS);
    STATS = (struct stat_area *)(void *)0;
  }

}

// ci_stat_uint64_inc
// file stats.c line 168
void ci_stat_uint64_inc(signed int ID, signed int count)
{
  _Bool tmp_if_expr_1;
  if(STATS == ((struct stat_area *)NULL))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = !(STATS->mem_block != ((struct stat_memblock *)NULL)) ? (_Bool)1 : (_Bool)0;
  if(!tmp_if_expr_1)
  {
    _Bool tmp_if_expr_2;
    if(!(ID >= 0))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = ID >= STATS->mem_block->counters64_size ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_2)
    {
      pthread_mutex_lock(&STATS->mtx);
      STATS->mem_block->counters64[(signed long int)ID] = STATS->mem_block->counters64[(signed long int)ID] + (unsigned long int)count;
      pthread_mutex_unlock(&STATS->mtx);
    }

  }

}

// ci_str_trim
// file util.c line 108
void ci_str_trim(char *str)
{
  char *s;
  char *e;
  const unsigned short int **return_value___ctype_b_loc_1;
  const unsigned short int **return_value___ctype_b_loc_3;
  if(!(str == ((char *)NULL)))
  {
    s = str;
    e = (char *)(void *)0;
    do
    {
      return_value___ctype_b_loc_1=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*s]) == 0)
        break;

      e = s;
      for( ; !((signed int)*e == 0); e = e + 1l)
        *e = e[(signed long int)1];
    }
    while((_Bool)1);
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(str);
    e = str + (signed long int)return_value_strlen_2;
    e = e - 1l;
    do
    {
      return_value___ctype_b_loc_3=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)*e]) == 0)
        break;

      if(!(e >= str))
        break;

      *e = (char)0;
      e = e - 1l;
    }
    while((_Bool)1);
  }

}

// ci_str_trim2
// file util.c line 131
char * ci_str_trim2(char *s)
{
  char *e;
  const unsigned short int **return_value___ctype_b_loc_1;
  const unsigned short int **return_value___ctype_b_loc_3;
  if(s == ((char *)NULL))
    return (char *)(void *)0;

  else
  {
    do
    {
      return_value___ctype_b_loc_1=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*s]) == 0)
        break;

      s = s + 1l;
    }
    while((_Bool)1);
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(s);
    e = s + (signed long int)return_value_strlen_2;
    e = e - 1l;
    do
    {
      return_value___ctype_b_loc_3=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)*e]) == 0)
        break;

      if(!(e >= s))
        break;

      *e = (char)0;
      e = e - 1l;
    }
    while((_Bool)1);
    return s;
  }
}

// ci_str_vector_iterate
// file array.c line 461
void ci_str_vector_iterate(const struct ci_vector *vector, void *data, signed int (*fn)(void *, const char *))
{
  ci_vector_iterate(vector, data, (signed int (*)(void *, const void *))fn);
}

// ci_str_vector_search
// file include/array.h line 549
const char * ci_str_vector_search(struct ci_vector *vector, const char *item)
{
  signed int i = 0;
  for( ; !(vector->items[(signed long int)i] == NULL); i = i + 1)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp((const char *)vector->items[(signed long int)i], item);
    if(return_value_strcmp_1 == 0)
      return (const char *)vector->items[(signed long int)i];

  }
  return (const char *)(void *)0;
}

// ci_strcasestr
// file util.c line 43
const char * ci_strcasestr(const char *str, const char *find)
{
  const char *s;
  const char *c;
  const char *f;
  s = str;
  for( ; !((signed int)*s == 0); s = s + 1l)
  {
    f = find;
    c = s;
    for( ; (_Bool)1; c = c + 1l)
    {
      if((signed int)*f == 0)
        return s;

      if((signed int)*c == 0)
        return (const char *)(void *)0;

      signed int return_value_tolower_1;
      return_value_tolower_1=tolower((signed int)*c);
      signed int return_value_tolower_2;
      return_value_tolower_2=tolower((signed int)*f);
      if(!(return_value_tolower_1 == return_value_tolower_2))
        break;

      f = f + 1l;
    }
  }
  return (const char *)(void *)0;
}

// ci_strerror
// file include/util.h line 57
char * ci_strerror(signed int error, char *buf, unsigned long int buflen)
{
  char *return_value_strerror_r_1;
  return_value_strerror_r_1=strerror_r(error, buf, buflen);
  return return_value_strerror_r_1;
}

// ci_strncasestr
// file util.c line 59
const char * ci_strncasestr(const char *s, const char *find, unsigned long int slen)
{
  unsigned long int len;
  len=strlen(find);
  signed int return_value_strncasecmp_1;
  if(len == 0ul)
    return (const char *)(void *)0;

  else
  {
    while(slen >= len)
    {
      signed int return_value_tolower_2;
      return_value_tolower_2=tolower((signed int)*s);
      signed int return_value_tolower_3;
      return_value_tolower_3=tolower((signed int)*find);
      if(return_value_tolower_2 == return_value_tolower_3)
      {
        return_value_strncasecmp_1=strncasecmp(s, find, len);
        if(return_value_strncasecmp_1 == 0)
          return s;

      }

      s = s + 1l;
      slen = slen - 1ul;
    }
    return (const char *)(void *)0;
  }
}

// ci_strnstr
// file include/util.h line 44
const char * ci_strnstr(const char *s, const char *find, unsigned long int slen)
{
  unsigned long int len;
  len=strlen(find);
  signed int return_value_strncmp_1;
  if(len == 0ul)
    return (const char *)(void *)0;

  else
  {
    while(slen >= len)
    {
      if(*s == *find)
      {
        return_value_strncmp_1=strncmp(s, find, len);
        if(return_value_strncmp_1 == 0)
          return s;

      }

      s = s + 1l;
      slen = slen - 1ul;
    }
    return (const char *)(void *)0;
  }
}

// ci_strtime
// file os/unix/utilfunc.c line 51
void ci_strtime(char *buf)
{
  struct tm br_tm;
  signed long int tm;
  time(&tm);
  struct tm *return_value_localtime_r_1;
  return_value_localtime_r_1=localtime_r(&tm, &br_tm);
  asctime_r(return_value_localtime_r_1, buf);
  buf[(signed long int)(64 - 1)] = (char)0;
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(buf);
  buf[(signed long int)(return_value_strlen_2 - (unsigned long int)1)] = (char)0;
}

// ci_strtime_rfc822
// file os/unix/utilfunc.c line 61
void ci_strtime_rfc822(char *buf)
{
  struct tm br_tm;
  signed long int tm;
  time(&tm);
  gmtime_r(&tm, &br_tm);
  snprintf(buf, (unsigned long int)64, "%s, %.2d %s %d %.2d:%.2d:%.2d GMT", days[(signed long int)br_tm.tm_wday], br_tm.tm_mday, months[(signed long int)br_tm.tm_mon], br_tm.tm_year + 1900, br_tm.tm_hour, br_tm.tm_min, br_tm.tm_sec);
  buf[(signed long int)(64 - 1)] = (char)0;
}

// ci_thread_cond_destroy
// file os/unix/threads.c line 196
signed int ci_thread_cond_destroy(union anonymous_34 *pcond)
{
  signed int return_value_pthread_cond_destroy_1;
  return_value_pthread_cond_destroy_1=pthread_cond_destroy(pcond);
  return return_value_pthread_cond_destroy_1;
}

// ci_thread_cond_init
// file os/unix/threads.c line 191
signed int ci_thread_cond_init(union anonymous_34 *pcond)
{
  signed int return_value_pthread_cond_init_1;
  return_value_pthread_cond_init_1=pthread_cond_init(pcond, (const union anonymous_32 *)(void *)0);
  return return_value_pthread_cond_init_1;
}

// ci_thread_create
// file os/unix/threads.c line 201
signed int ci_thread_create(unsigned long int *pthread_id, void * (*pfunc)(void *), void *parg)
{
  signed int return_value_pthread_create_1;
  return_value_pthread_create_1=pthread_create(pthread_id, (const union pthread_attr_t *)(void *)0, pfunc, parg);
  return return_value_pthread_create_1;
}

// ci_thread_join
// file os/unix/threads.c line 206
signed int ci_thread_join(unsigned long int thread_id)
{
  signed int return_value_pthread_join_1;
  return_value_pthread_join_1=pthread_join(thread_id, (void **)(void *)0);
  return return_value_pthread_join_1;
}

// ci_thread_mutex_destroy
// file include/ci_threads.h line 40
signed int ci_thread_mutex_destroy(union anonymous_4 *pmutex)
{
  del_mutex((void *)pmutex);
  signed int return_value_pthread_mutex_destroy_1;
  return_value_pthread_mutex_destroy_1=pthread_mutex_destroy(pmutex);
  return return_value_pthread_mutex_destroy_1;
}

// ci_thread_mutex_init
// file include/ci_threads.h line 39
signed int ci_thread_mutex_init(union anonymous_4 *pmutex)
{
  signed int ret;
  ret=pthread_mutex_init(pmutex, (const union anonymous_32 *)(void *)0);
  if(!(ret == 0))
    return ret;

  else
  {
    add_mutex((void *)pmutex, 0);
    return ret;
  }
}

// ci_thread_rwlock_destroy
// file os/unix/threads.c line 154
signed int ci_thread_rwlock_destroy(union anonymous_37 *rwlock)
{
  del_mutex((void *)rwlock);
  signed int return_value_pthread_rwlock_destroy_1;
  return_value_pthread_rwlock_destroy_1=pthread_rwlock_destroy(rwlock);
  return return_value_pthread_rwlock_destroy_1;
}

// ci_thread_rwlock_init
// file os/unix/threads.c line 144
signed int ci_thread_rwlock_init(union anonymous_37 *rwlock)
{
  signed int ret;
  ret=pthread_rwlock_init(rwlock, (const union anonymous_35 *)(void *)0);
  if(!(ret == 0))
    return ret;

  else
  {
    add_mutex((void *)rwlock, 1);
    return ret;
  }
}

// ci_txt_template_build_content
// file txtTemplate.c line 396
struct ci_membuf * ci_txt_template_build_content(const struct ci_request *req, const char *SERVICE_NAME, const char *TEMPLATE_NAME, struct ci_fmt_entry *user_table)
{
  struct ci_membuf *content;
  char templpath[4096l];
  struct anonymous_22 *template = (struct anonymous_22 *)(void *)0;
  content=ci_membuf_new_sized(TEMPLATE_MEMBUF_SIZE);
  unsigned long int return_value_strlen_1;
  if(content == ((struct ci_membuf *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Failed to allocate buffer to load template!");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Failed to allocate buffer to load template!");

    }

    return (struct ci_membuf *)(void *)0;
  }

  else
  {
    template=templateLoadText(req, SERVICE_NAME, TEMPLATE_NAME);
    if(!(template == ((struct anonymous_22 *)NULL)))
    {
      content->endpos=ci_format_text((struct ci_request *)req, template->data->buf, content->buf, content->bufsize, user_table);
      ci_membuf_write(content, "\0", 1, 1);
      if(!(template->LANGUAGE == ((char *)NULL)))
      {
        return_value_strlen_1=strlen(template->LANGUAGE);
        ci_membuf_attr_add(content, "lang", (const void *)template->LANGUAGE, return_value_strlen_1 + (unsigned long int)1);
      }

      template_release(template);
    }

    else
    {
      makeTemplatePathFileName(templpath, 4096, SERVICE_NAME, TEMPLATE_NAME, TEMPLATE_DEF_LANG);
      content->endpos=snprintf(content->buf, (unsigned long int)content->bufsize, "ERROR: Unable to find specified template: %s\n", (const void *)templpath);
      if(!(content->bufsize >= content->endpos))
        content->endpos = content->bufsize;

      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(TEMPLATE_DEF_LANG);
      ci_membuf_attr_add(content, "lang", (const void *)TEMPLATE_DEF_LANG, return_value_strlen_2 + (unsigned long int)1);
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "ERROR: Unable to find specified template: %s\n", (const void *)templpath);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("ERROR: Unable to find specified template: %s\n", (const void *)templpath);

      }

    }
    return content;
  }
}

// ci_txt_template_close
// file txtTemplate.c line 192
void ci_txt_template_close(void)
{
  signed int i;
  if(!(templates == ((struct anonymous_22 *)NULL)))
  {
    i = 0;
    for( ; !(i >= TEMPLATE_CACHE_SIZE); i = i + 1)
      templateFree(&templates[(signed long int)i]);
    free((void *)templates);
    templates = (struct anonymous_22 *)(void *)0;
    ci_thread_mutex_destroy(&templates_mutex);
  }

}

// ci_txt_template_init
// file txtTemplate.c line 77
signed int ci_txt_template_init(void)
{
  signed int i;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)TEMPLATE_CACHE_SIZE * sizeof(struct anonymous_22) /*72ul*/ );
  templates = (struct anonymous_22 *)return_value_malloc_1;
  if(templates == ((struct anonymous_22 *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Unable to allocate memory in in inittxtTemplate for template storage!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Unable to allocate memory in in inittxtTemplate for template storage!\n");

    }

    return -1;
  }

  else
  {
    i = 0;
    for( ; !(i >= TEMPLATE_CACHE_SIZE); i = i + 1)
    {
      (templates + (signed long int)i)->data = (struct ci_membuf *)(void *)0;
      (templates + (signed long int)i)->loaded = (signed long int)0;
      (templates + (signed long int)i)->locked = 0;
      (templates + (signed long int)i)->must_free = 0;
      (templates + (signed long int)i)->non_cached = 0;
    }
    txtTemplateInited = 1;
    ci_thread_mutex_init(&templates_mutex);
    return 1;
  }
}

// ci_txt_template_reset
// file txtTemplate.c line 181
void ci_txt_template_reset(void)
{
  signed int i = 0;
  pthread_mutex_lock(&templates_mutex);
  i = 0;
  for( ; !(i >= TEMPLATE_CACHE_SIZE); i = i + 1)
    templateFree(&templates[(signed long int)i]);
  pthread_mutex_unlock(&templates_mutex);
}

// ci_txt_template_set_default_lang
// file txtTemplate.c line 104
void ci_txt_template_set_default_lang(const char *lang)
{
  TEMPLATE_DEF_LANG = lang;
}

// ci_txt_template_set_dir
// file txtTemplate.c line 99
void ci_txt_template_set_dir(const char *dir)
{
  TEMPLATE_DIR = dir;
}

// ci_uncompress_preview
// file decode.c line 313
signed int ci_uncompress_preview(signed int compress_method, const char *buf, signed int len, char *unzipped_buf, signed int *unzipped_buf_len)
{
  signed int return_value_zlib_inflate_1;
  return_value_zlib_inflate_1=zlib_inflate(buf, len, unzipped_buf, unzipped_buf_len);
  return return_value_zlib_inflate_1;
  return -1;
}

// ci_usleep
// file os/unix/utilfunc.c line 85
signed int ci_usleep(unsigned long int usec)
{
  struct timespec us;
  struct timespec ur;
  us.tv_sec = (signed long int)0;
  us.tv_nsec = (signed long int)(usec * (unsigned long int)1000);
  nanosleep(&us, &ur);
  return 0;
}

// ci_vector_add
// file include/array.h line 480
void * ci_vector_add(struct ci_vector *vector, const void *value, unsigned long int size)
{
  void *item;
  void **indx;
  struct ci_mem_allocator *packer = vector->alloc;
  /* assertion packer */
  assert(packer != ((struct ci_mem_allocator *)NULL));
  void *return_value_ci_pack_allocator_alloc_unaligned_1;
  return_value_ci_pack_allocator_alloc_unaligned_1=ci_pack_allocator_alloc_unaligned(packer, (unsigned long int)&((void **)0)[(signed long int)1]);
  indx = (void **)return_value_ci_pack_allocator_alloc_unaligned_1;
  item=ci_pack_allocator_alloc_from_rear(packer, (signed int)size);
  if(item == NULL || indx == ((void **)NULL))
  {
    if(CI_DEBUG_LEVEL >= 2)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Not enough space to add the new item to vector!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Not enough space to add the new item to vector!\n");

    }

    return (void *)0;
  }

  else
  {
    memcpy(item, value, size);
    *vector->last = item;
    vector->last = indx;
    *vector->last = (void *)0;
    vector->count = vector->count + 1;
    return item;
  }
}

// ci_vector_cast_from_voidvoid
// file array.c line 386
struct ci_vector * ci_vector_cast_from_voidvoid(const void **p)
{
  const void *buf;
  struct ci_vector *v = (struct ci_vector *)((void *)p - (signed long int)(sizeof(struct ci_vector) /*48ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)));
  unsigned long int return_value_ci_pack_allocator_required_size_1;
  return_value_ci_pack_allocator_required_size_1=ci_pack_allocator_required_size();
  buf = (void *)v - (signed long int)return_value_ci_pack_allocator_required_size_1;
  /* assertion v->mem == buf */
  assert(v->mem == (char *)buf);
  unsigned long int return_value_ci_buffer_blocksize_2;
  return_value_ci_buffer_blocksize_2=ci_buffer_blocksize(buf);
  /* assertion ci_buffer_blocksize(buf) != 0 */
  assert(return_value_ci_buffer_blocksize_2 != (unsigned long int)0);
  return v;
}

// ci_vector_cast_to_voidvoid
// file array.c line 381
const void ** ci_vector_cast_to_voidvoid(struct ci_vector *vector)
{
  return (const void **)vector->items;
}

// ci_vector_create
// file include/array.h line 463
struct ci_vector * ci_vector_create(unsigned long int max_size)
{
  struct ci_vector *vector;
  struct ci_mem_allocator *packer;
  void *buffer;
  void **indx;
  buffer=ci_buffer_alloc((signed int)max_size);
  if(buffer == NULL)
    return (struct ci_vector *)(void *)0;

  else
  {
    packer=ci_create_pack_allocator_on_memblock((char *)buffer, max_size);
    if(packer == ((struct ci_mem_allocator *)NULL))
    {
      ci_buffer_free(buffer);
      return (struct ci_vector *)(void *)0;
    }

    else
    {
      void *return_value_ci_pack_allocator_alloc_1;
      return_value_ci_pack_allocator_alloc_1=ci_pack_allocator_alloc(packer, sizeof(struct ci_vector) /*48ul*/ );
      vector = (struct ci_vector *)return_value_ci_pack_allocator_alloc_1;
      void *return_value_ci_pack_allocator_alloc_unaligned_2;
      return_value_ci_pack_allocator_alloc_unaligned_2=ci_pack_allocator_alloc_unaligned(packer, (unsigned long int)&((void **)0)[(signed long int)1]);
      indx = (void **)return_value_ci_pack_allocator_alloc_unaligned_2;
      if(indx == ((void **)NULL) || vector == ((struct ci_vector *)NULL))
      {
        ci_buffer_free(buffer);
        ci_mem_allocator_destroy(packer);
        return (struct ci_vector *)(void *)0;
      }

      else
      {
        *indx = (void *)0;
        vector->max_size = max_size;
        vector->mem = (char *)buffer;
        vector->items = indx;
        vector->last = indx;
        vector->count = 0;
        vector->alloc = packer;
        return vector;
      }
    }
  }
}

// ci_vector_destroy
// file array.c line 398
void ci_vector_destroy(struct ci_vector *vector)
{
  void *buffer = (void *)vector->mem;
  /* assertion buffer */
  assert(buffer != NULL);
  if(!(vector->alloc == ((struct ci_mem_allocator *)NULL)))
    ci_mem_allocator_destroy(vector->alloc);

  ci_buffer_free(buffer);
}

// ci_vector_iterate
// file array.c line 452
void ci_vector_iterate(const struct ci_vector *vector, void *data, signed int (*fn)(void *, const void *))
{
  signed int i;
  signed int ret = 0;
  i = 0;
  if(ret == 0 && !(vector->items[(signed long int)i] == NULL))
  {
    ret=fn(data, vector->items[(signed long int)i]);
    i = i + 1;
  }

}

// ci_vector_pop
// file array.c line 427
void * ci_vector_pop(struct ci_vector *vector)
{
  void *p;
  if(vector->count == 0)
    return (void *)0;

  else
  {
    ci_pack_allocator_set_start_pos(vector->alloc, (void *)vector->last);
    vector->count = vector->count - 1;
    vector->last = &vector->items[(signed long int)vector->count];
    if(vector->count == 0)
      ci_pack_allocator_set_end_pos(vector->alloc, (void *)0);

    else
      ci_pack_allocator_set_end_pos(vector->alloc, vector->items[(signed long int)(vector->count - 1)]);
    p = *vector->last;
    *vector->last = (void *)0;
    return p;
  }
}

// ci_wait_for_data
// file include/net_io.h line 144
signed int ci_wait_for_data(signed int fd, signed int secs, signed int what_wait)
{
  struct anonymous_26 rfds;
  struct anonymous_26 wfds;
  struct anonymous_26 *preadfds;
  struct anonymous_26 *pwritefds;
  struct timeval tv;
  signed int ret = 0;
  if(secs >= 0)
  {
    tv.tv_sec = (signed long int)secs;
    tv.tv_usec = (signed long int)0;
  }

  preadfds = (struct anonymous_26 *)(void *)0;
  pwritefds = (struct anonymous_26 *)(void *)0;
  if(!((0x1 & what_wait) == 0))
  {
    do
    {
      signed int __d0;
      signed int __d1;
      asm("cld; rep; stosq" : "=c"(__d0), "=D"(__d1) : "a"(0), "0"(sizeof(struct anonymous_26) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&rfds)->fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&rfds)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&rfds)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    preadfds = &rfds;
  }

  if(!((0x2 & what_wait) == 0))
  {
    do
    {
      signed int ci_wait_for_data__1__3__1____d0;
      signed int ci_wait_for_data__1__3__1____d1;
      asm("cld; rep; stosq" : "=c"(ci_wait_for_data__1__3__1____d0), "=D"(ci_wait_for_data__1__3__1____d1) : "a"(0), "0"(sizeof(struct anonymous_26) /*128ul*/  / sizeof(signed long int) /*8ul*/ ), "1"(&(&wfds)->fds_bits[(signed long int)0]) : "memory");
    }
    while((_Bool)0);
    (&wfds)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] = (&wfds)->fds_bits[(signed long int)(fd / (8 * (signed int)sizeof(signed long int) /*8ul*/ ))] | (signed long int)(1UL << fd % (8 * (signed int)sizeof(signed long int) /*8ul*/ ));
    pwritefds = &wfds;
  }

  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  ret=select(fd + 1, preadfds, pwritefds, (struct anonymous_26 *)(void *)0, secs >= 0 ? &tv : (struct timeval *)(void *)0);
  signed int *return_value___errno_location_4;
  signed int *return_value___errno_location_2;
  signed int *return_value___errno_location_3;
  if(ret >= 1)
  {
    ret = 0;
    if(!(preadfds == ((struct anonymous_26 *)NULL)))
    {
      if(!((preadfds->fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
        ret = 0x1;

    }

    if(!(pwritefds == ((struct anonymous_26 *)NULL)))
    {
      if(!((pwritefds->fds_bits[(signed long int)(fd / 8)] & (signed long int)(1UL << fd % 8)) == 0l))
        ret = ret | 0x2;

    }

    return ret;
  }

  else
  {
    if(!(ret >= 0))
    {
      return_value___errno_location_4=__errno_location();
      if(!(*return_value___errno_location_4 == 4))
      {
        if(CI_DEBUG_LEVEL >= 5)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          {
            return_value___errno_location_2=__errno_location();
            __log_error((void *)0, "Fatal error while waiting for new data (errno=%d....\n", *return_value___errno_location_2);
          }

          if(!(CI_DEBUG_STDOUT == 0))
          {
            return_value___errno_location_3=__errno_location();
            printf("Fatal error while waiting for new data (errno=%d....\n", *return_value___errno_location_3);
          }

        }

        return -1;
      }

    }

    return 0;
  }
}

// ci_write
// file include/net_io.h line 151
signed int ci_write(signed int fd, const void *buf, unsigned long int count, signed int timeout)
{
  signed int bytes = 0;
  signed int remains = (signed int)count;
  char *b = (char *)buf;
  _Bool tmp_if_expr_2;
  signed int *return_value___errno_location_1;
  signed int *return_value___errno_location_8;
  _Bool tmp_if_expr_6;
  signed int *return_value___errno_location_5;
  while(remains >= 1)
  {
    do
    {
      signed long int return_value_write_3;
      return_value_write_3=write(fd, (const void *)b, (unsigned long int)remains);
      bytes = (signed int)return_value_write_3;
      if(bytes == -1)
      {
        return_value___errno_location_1=__errno_location();
        tmp_if_expr_2 = *return_value___errno_location_1 == 4 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_2 = (_Bool)0;
    }
    while(tmp_if_expr_2);
    if(bytes == -1)
    {
      return_value___errno_location_8=__errno_location();
      if(*return_value___errno_location_8 == 11)
      {
        signed int return_value_ci_wait_for_data_4;
        return_value_ci_wait_for_data_4=ci_wait_for_data(fd, timeout, 0x2);
        if(return_value_ci_wait_for_data_4 == 0)
          return bytes;

        do
        {
          signed long int return_value_write_7;
          return_value_write_7=write(fd, (const void *)b, (unsigned long int)remains);
          bytes = (signed int)return_value_write_7;
          if(bytes == -1)
          {
            return_value___errno_location_5=__errno_location();
            tmp_if_expr_6 = *return_value___errno_location_5 == 4 ? (_Bool)1 : (_Bool)0;
          }

          else
            tmp_if_expr_6 = (_Bool)0;
        }
        while(tmp_if_expr_6);
      }

    }

    if(!(bytes >= 0))
      return bytes;

    b = b + (signed long int)bytes;
    remains = remains - bytes;
  }
  return (signed int)count;
}

// ci_write_nonblock
// file include/net_io.h line 153
signed int ci_write_nonblock(signed int fd, const void *buf, unsigned long int count)
{
  signed int bytes = 0;
  _Bool tmp_if_expr_2;
  signed int *return_value___errno_location_1;
  do
  {
    signed long int return_value_write_3;
    return_value_write_3=write(fd, buf, count);
    bytes = (signed int)return_value_write_3;
    if(bytes == -1)
    {
      return_value___errno_location_1=__errno_location();
      tmp_if_expr_2 = *return_value___errno_location_1 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
  }
  while(tmp_if_expr_2);
  signed int *return_value___errno_location_4;
  if(!(bytes >= 0))
  {
    return_value___errno_location_4=__errno_location();
    if(*return_value___errno_location_4 == 11)
      return 0;

  }

  return bytes;
}

// ci_writen
// file request_common.c line 801
static signed int ci_writen(signed int fd, char *buf, signed int len, signed int timeout)
{
  signed int ret = 0;
  signed int remains = len;
  for( ; !(remains == 0); remains = remains - ret)
  {
    ret=ci_write(fd, (const void *)buf, (unsigned long int)remains, timeout);
    if(!(ret >= 0))
      return ret;

    buf = buf + (signed long int)ret;
  }
  return len;
}

// client_build_headers
// file request_common.c line 1281
static signed int client_build_headers(struct ci_request *req, signed int has_reqhdr, signed int has_reshdr, signed int has_body)
{
  signed int i = 0;
  i = 0;
  for( ; !(i >= 4); i = i + 1)
    if(!(req->entities[(signed long int)i] == ((struct ci_encaps_entity *)NULL)))
      ci_request_release_entity(req, i);

  i = 0;
  if(!(has_reqhdr == 0))
  {
    signed int tmp_post_1 = i;
    i = i + 1;
    req->entities[(signed long int)tmp_post_1]=ci_request_alloc_entity(req, 0, 0);
  }

  if(!(has_reshdr == 0))
  {
    signed int tmp_post_2 = i;
    i = i + 1;
    req->entities[(signed long int)tmp_post_2]=ci_request_alloc_entity(req, 1, 0);
  }

  if(!(has_body == 0))
    req->entities[(signed long int)i]=ci_request_alloc_entity(req, req->type == 0x04 ? 3 : 2, 0);

  else
    req->entities[(signed long int)i]=ci_request_alloc_entity(req, 4, 0);
  return 1;
}

// client_create_request
// file request_common.c line 724
static signed int client_create_request(struct ci_request *req, char *servername, char *service, signed int reqtype)
{
  char buf[256l];
  if(!(reqtype == 0x01) && !(reqtype == 0x02) && !(reqtype == 0x04))
    return -1;

  else
  {
    req->type = reqtype;
    const char *tmp_if_expr_1;
    if(reqtype >= 0x01 && !(reqtype >= 5))
      tmp_if_expr_1 = ci_methods[(signed long int)reqtype];

    else
      tmp_if_expr_1 = "UNKNOWN";
    snprintf(buf, (unsigned long int)255, "%s icap://%s/%s ICAP/1.0", tmp_if_expr_1, servername, service);
    buf[(signed long int)255] = (char)0;
    ci_headers_add(req->request_header, buf);
    snprintf(buf, (unsigned long int)255, "Host: %s", servername);
    buf[(signed long int)255] = (char)0;
    ci_headers_add(req->request_header, buf);
    ci_headers_add(req->request_header, "User-Agent: C-ICAP-Client-Library/0.01");
    _Bool tmp_if_expr_2;
    if(!(req->allow204 == 0))
      tmp_if_expr_2 = req->allow206 != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(tmp_if_expr_2)
      ci_headers_add(req->request_header, "Allow: 204, 206");

    else
      if(!(req->allow204 == 0))
        ci_headers_add(req->request_header, "Allow: 204");

    if(!(req->allow206 == 0))
      ci_headers_add(req->request_header, "Allow: 206");

    if(!(req->xheaders->used == 0))
      ci_headers_addheaders(req->request_header, req->xheaders);

    return 1;
  }
}

// client_parse_encaps_header
// file request_common.c line 921
static signed int client_parse_encaps_header(struct ci_request *req, struct ci_headers_list *h, signed int size)
{
  signed int remains;
  signed int readed = 0;
  char *buf_end = (char *)(void *)0;
  remains = size - h->bufused;
  if(!(remains >= 0))
    return -1;

  else
    if(remains == 0)
      return 1;

    else
    {
      if(req->pstrblock_read_len >= 1)
      {
        signed int tmp_if_expr_1;
        if(!(req->pstrblock_read_len >= remains))
          tmp_if_expr_1 = req->pstrblock_read_len;

        else
          tmp_if_expr_1 = remains;
        readed = tmp_if_expr_1;
        memcpy((void *)(h->buf + (signed long int)h->bufused), (const void *)req->pstrblock_read, (unsigned long int)readed);
        h->bufused = h->bufused + readed;
        req->pstrblock_read = req->pstrblock_read + (signed long int)readed;
        req->pstrblock_read_len = req->pstrblock_read_len - readed;
      }

      if(!(h->bufused >= size))
        return 2;

      else
      {
        buf_end = h->buf + (signed long int)h->bufused;
        signed int return_value_strncmp_2;
        return_value_strncmp_2=strncmp(buf_end - (signed long int)4, "\r\n\r\n", (unsigned long int)4);
        if(return_value_strncmp_2 == 0)
        {
          h->bufused = h->bufused - 2;
          return 1;
        }

        else
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Error parsing encapsulated headers,no \\r\\n\\r\\n at the end of headers:%s!\n", buf_end);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Error parsing encapsulated headers,no \\r\\n\\r\\n at the end of headers:%s!\n", buf_end);

          }

          return -1;
        }
      }
    }
}

// client_parse_icap_header
// file request_common.c line 891
static signed int client_parse_icap_header(struct ci_request *req, struct ci_headers_list *h)
{
  signed int readed = 0;
  signed int eoh = 0;
  char *buf;
  char *end;
  if(!(req->pstrblock_read_len >= 4))
    return 2;

  else
  {
    end=strstr(req->pstrblock_read, "\r\n\r\n");
    if(!(end == ((char *)NULL)))
    {
      readed = (signed int)((end - req->pstrblock_read) + (signed long int)4);
      eoh = 1;
    }

    else
      readed = req->pstrblock_read_len - 3;
    signed int return_value_check_realloc_1;
    return_value_check_realloc_1=check_realloc(&h->buf, &h->bufsize, h->bufused, readed);
    if(!(return_value_check_realloc_1 == 1))
      return -1;

    else
    {
      buf = h->buf + (signed long int)h->bufused;
      memcpy((void *)buf, (const void *)req->pstrblock_read, (unsigned long int)readed);
      h->bufused = h->bufused + readed;
      req->pstrblock_read = req->pstrblock_read + (signed long int)readed;
      req->pstrblock_read_len = req->pstrblock_read_len - readed;
      if(eoh == 0)
        return 2;

      else
      {
        h->bufused = h->bufused - 2;
        return 1;
      }
    }
  }
}

// client_parse_incoming_data
// file request_common.c line 1082
static signed int client_parse_incoming_data(struct ci_request *req, void *data_dest, signed int (*dest_write)(void *, char *, signed int))
{
  signed int ret;
  signed int v1;
  signed int v2;
  signed int status;
  signed int bytes;
  signed int size;
  char *buf;
  const char *val;
  struct ci_headers_list *resp_heads;
  if(req->status == 0)
  {
    ret=client_parse_icap_header(req, req->response_header);
    if(!(ret == 1))
      return ret;

    sscanf(req->response_header->buf, "ICAP/%d.%d %d", &v1, &v2, &status);
    if(CI_DEBUG_LEVEL >= 3)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Response was with status:%d \n", status);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Response was with status:%d \n", status);

    }

    ci_headers_unpack(req->response_header);
    if(!(req->allow204 == 0))
    {
      if(status == 204)
      {
        req->status = 4;
        return 204;
      }

    }

    val=ci_headers_search(req->response_header, "Encapsulated");
    if(val == ((const char *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "No encapsulated entities!\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("No encapsulated entities!\n");

      }

      return -1;
    }

    process_encapsulated(req, val);
    if(req->entities[0l] == ((struct ci_encaps_entity *)NULL))
      return -1;

    if(req->entities[1l] == ((struct ci_encaps_entity *)NULL))
    {
      req->status = 3;
      if(req->pstrblock_read_len == 0)
        return 2;

    }

    else
    {
      req->status = 1;
      size = req->entities[(signed long int)1]->start - req->entities[(signed long int)0]->start;
      resp_heads = (struct ci_headers_list *)req->entities[(signed long int)0]->entity;
      signed int return_value_ci_headers_setsize_1;
      return_value_ci_headers_setsize_1=ci_headers_setsize(resp_heads, size);
      if(return_value_ci_headers_setsize_1 == 0)
        return -1;

    }
  }

  if(req->status == 1)
  {
    size = req->entities[(signed long int)1]->start - req->entities[(signed long int)0]->start;
    resp_heads = (struct ci_headers_list *)req->entities[(signed long int)0]->entity;
    ret=client_parse_encaps_header(req, resp_heads, size);
    if(!(ret == 1))
      return ret;

    ci_headers_unpack(resp_heads);
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "OK reading headers, going to read body\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("OK reading headers, going to read body\n");

    }

    req->current_chunk_len = (unsigned int)0;
    req->chunk_bytes_read = (unsigned int)0;
    req->write_to_module_pending = (unsigned int)0;
    if(req->entities[1l]->type == 4)
    {
      req->status = 4;
      return 1;
    }

    req->status = 3;
    if(!(req->pstrblock_read_len == 0))
      goto __CPROVER_DUMP_L17;

    return 2;
  }

  else
  {

  __CPROVER_DUMP_L17:
    ;
    if(req->status == 3)
    {
      do
      {
        ret=parse_chunk_data(req, &buf);
        if(ret == -1)
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Error parsing chunks, current chunk len: %d, read: %d, readlen: %d, str: %s\n", req->current_chunk_len, req->chunk_bytes_read, req->pstrblock_read_len, req->pstrblock_read);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Error parsing chunks, current chunk len: %d, read: %d, readlen: %d, str: %s\n", req->current_chunk_len, req->chunk_bytes_read, req->pstrblock_read_len, req->pstrblock_read);

          }

          return -1;
        }

        if(req->write_to_module_pending >= 1u)
        {
          bytes=dest_write(data_dest, buf, (signed int)req->write_to_module_pending);
          if(!(bytes >= 0))
          {
            if(CI_DEBUG_LEVEL >= 1)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "Error writing to output file!\n");

              if(!(CI_DEBUG_STDOUT == 0))
                printf("Error writing to output file!\n");

            }

            return -1;
          }

          req->write_to_module_pending = req->write_to_module_pending - (unsigned int)bytes;
        }

        if(ret == -2)
        {
          req->status = 4;
          return 1;
        }

      }
      while(!(ret == 2));
      return 2;
    }

    else
      return 1;
  }
}

// client_prepere_body_chunk
// file request_common.c line 1052
static signed int client_prepere_body_chunk(struct ci_request *req, void *data, signed int (*readdata)(void *, char *, signed int))
{
  signed int chunksize;
  signed int def_bytes;
  char *wbuf = (char *)(void *)0;
  char tmpbuf[30l];
  wbuf = req->wbuf + (signed long int)30;
  chunksize=readdata(data, wbuf, 4064);
  if(!(chunksize >= 1))
  {
    req->remain_send_block_bytes = 0;
    return chunksize;
  }

  else
  {
    wbuf = wbuf + (signed long int)chunksize;
    char *tmp_post_1 = wbuf;
    wbuf = wbuf + 1l;
    *tmp_post_1 = (char)13;
    *wbuf = (char)10;
    def_bytes=snprintf(tmpbuf, (unsigned long int)30, "%x\r\n", chunksize);
    wbuf = (req->wbuf + (signed long int)30) - (signed long int)def_bytes;
    memcpy((void *)wbuf, (const void *)tmpbuf, (unsigned long int)def_bytes);
    req->pstrblock_responce = wbuf;
    req->remain_send_block_bytes = def_bytes + chunksize + 2;
    return req->remain_send_block_bytes;
  }
}

// client_send_get_data
// file request_common.c line 1200
static signed int client_send_get_data(struct ci_request *req, signed int timeout, void *data_source, signed int (*source_read)(void *, char *, signed int), void *data_dest, signed int (*dest_write)(void *, char *, signed int))
{
  signed int io_ret;
  signed int read_status;
  signed int bytes;
  signed int io_action;
  signed int return_value_client_prepere_body_chunk_1;
  if(!(req->pstrblock_read_len == 0))
  {
    read_status=client_parse_incoming_data(req, data_dest, dest_write);
    if(read_status == -1)
      return -1;

    if(read_status == 204)
      return 204;

    if(!(req->status == 4))
      goto __CPROVER_DUMP_L3;

    return 1;
  }

  else
  {

  __CPROVER_DUMP_L3:
    ;
    if(data_source == NULL)
      req->eof_received = 1;

    if(req->eof_received == 0)
      io_action = 0x3;

    else
      io_action = 0x1;
    while(!(io_action == 0))
    {
      io_ret=ci_wait_for_data(req->connection->fd, timeout, io_action);
      if(io_ret == 0)
        break;

      if(!(io_ret >= 0))
        return -1;

      if(!((0x2 & io_ret) == 0))
      {
        if(req->remain_send_block_bytes == 0)
        {
          if(!(data_source == NULL))
          {
            return_value_client_prepere_body_chunk_1=client_prepere_body_chunk(req, data_source, source_read);
            if(!(return_value_client_prepere_body_chunk_1 >= 1))
            {
              req->eof_received = 1;
              req->pstrblock_responce = (char *)eof_str;
              req->remain_send_block_bytes = 5;
            }

          }

        }

        bytes=ci_write_nonblock(req->connection->fd, (const void *)req->pstrblock_responce, (unsigned long int)req->remain_send_block_bytes);
        if(!(bytes >= 0))
          return -1;

        req->bytes_out = req->bytes_out + (unsigned long int)bytes;
        req->pstrblock_responce = req->pstrblock_responce + (signed long int)bytes;
        req->remain_send_block_bytes = req->remain_send_block_bytes - bytes;
      }

      _Bool tmp_if_expr_2;
      if(!(req->eof_received == 0))
        tmp_if_expr_2 = req->remain_send_block_bytes == 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_2 = (_Bool)0;
      if(tmp_if_expr_2)
        io_action = 0;

      else
        io_action = 0x2;
      if(!((0x1 & io_ret) == 0))
      {
        signed int return_value_net_data_read_3;
        return_value_net_data_read_3=net_data_read(req);
        if(return_value_net_data_read_3 == -1)
          return -1;

        read_status=client_parse_incoming_data(req, data_dest, dest_write);
        if(read_status == -1)
          return -1;

        if(read_status == 204)
          return 204;

      }

      if(!(req->status == 4))
        io_action = io_action | 0x1;

    }
    return 1;
  }
}

// client_send_request_headers
// file request_common.c line 816
static signed int client_send_request_headers(struct ci_request *req, signed int has_eof, signed int timeout)
{
  struct ci_encaps_entity **elist;
  struct ci_encaps_entity *e;
  struct ci_headers_list *headers;
  signed int bytes;
  ci_request_pack(req);
  signed int return_value_ci_writen_1;
  return_value_ci_writen_1=ci_writen(req->connection->fd, req->request_header->buf, req->request_header->bufused, timeout);
  struct ci_encaps_entity **tmp_post_2;
  if(!(return_value_ci_writen_1 >= 0))
    return -1;

  else
  {
    req->bytes_out = req->bytes_out + (unsigned long int)req->request_header->bufused;
    elist = req->entities;
    do
    {
      tmp_post_2 = elist;
      elist = elist + 1l;
      e = *tmp_post_2;
      if(e == ((struct ci_encaps_entity *)NULL))
        break;

      _Bool tmp_if_expr_4;
      if(e->type == 0)
        tmp_if_expr_4 = (_Bool)1;

      else
        tmp_if_expr_4 = e->type == 1 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_4)
      {
        headers = (struct ci_headers_list *)e->entity;
        signed int return_value_ci_writen_3;
        return_value_ci_writen_3=ci_writen(req->connection->fd, headers->buf, headers->bufused, timeout);
        if(!(return_value_ci_writen_3 >= 0))
          return -1;

        req->bytes_out = req->bytes_out + (unsigned long int)headers->bufused;
      }

    }
    while((_Bool)1);
    _Bool tmp_if_expr_10;
    if(req->preview >= 1)
      tmp_if_expr_10 = req->preview_data.used > 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_10 = (_Bool)0;
    if(tmp_if_expr_10)
    {
      bytes=sprintf(req->wbuf, "%x\r\n", req->preview);
      signed int return_value_ci_writen_5;
      return_value_ci_writen_5=ci_writen(req->connection->fd, req->wbuf, bytes, timeout);
      if(!(return_value_ci_writen_5 >= 0))
        return -1;

      req->bytes_out = req->bytes_out + (unsigned long int)bytes;
      signed int return_value_ci_writen_6;
      return_value_ci_writen_6=ci_writen(req->connection->fd, req->preview_data.buf, req->preview, timeout);
      if(!(return_value_ci_writen_6 >= 0))
        return -1;

      req->bytes_out = req->bytes_out + (unsigned long int)req->preview;
      if(!(has_eof == 0))
      {
        signed int return_value_ci_writen_7;
        return_value_ci_writen_7=ci_writen(req->connection->fd, "\r\n0; ieof\r\n\r\n", 13, timeout);
        if(!(return_value_ci_writen_7 >= 0))
          return -1;

        req->bytes_out = req->bytes_out + (unsigned long int)13;
        req->eof_received = 1;
      }

      else
      {
        signed int return_value_ci_writen_8;
        return_value_ci_writen_8=ci_writen(req->connection->fd, "\r\n0\r\n\r\n", 7, timeout);
        if(!(return_value_ci_writen_8 >= 0))
          return -1;

        req->bytes_out = req->bytes_out + (unsigned long int)7;
      }
    }

    else
      if(req->preview == 0)
      {
        signed int return_value_ci_writen_9;
        return_value_ci_writen_9=ci_writen(req->connection->fd, "0\r\n\r\n", 5, timeout);
        if(!(return_value_ci_writen_9 >= 0))
          return -1;

        req->bytes_out = req->bytes_out + (unsigned long int)5;
      }

    return 1;
  }
}

// close_db
// file c-icap-mkbdb.c line 98
void close_db()
{
  db->close(db, (unsigned int)0);
  env_db->close(env_db, (unsigned int)0);
}

// common_mutex_destroy
// file cache.c line 114
signed int common_mutex_destroy(struct common_mutex *mtx)
{
  if(!(mtx->isproc == 0))
    return 0;

  else
  {
    signed int return_value_ci_thread_mutex_destroy_1;
    return_value_ci_thread_mutex_destroy_1=ci_thread_mutex_destroy(&mtx->mtx.thread_mutex);
    return return_value_ci_thread_mutex_destroy_1;
  }
}

// common_mutex_init
// file cache.c line 105
signed int common_mutex_init(struct common_mutex *mtx, signed int proc_mtx)
{
  if(!(proc_mtx == 0))
    return 0;

  else
  {
    mtx->isproc = 0;
    signed int return_value_ci_thread_mutex_init_1;
    return_value_ci_thread_mutex_init_1=ci_thread_mutex_init(&mtx->mtx.thread_mutex);
    return return_value_ci_thread_mutex_init_1;
  }
}

// common_mutex_lock
// file cache.c line 121
signed int common_mutex_lock(struct common_mutex *mtx)
{
  if(!(mtx->isproc == 0))
    return 0;

  else
  {
    signed int return_value_pthread_mutex_lock_1;
    return_value_pthread_mutex_lock_1=pthread_mutex_lock(&mtx->mtx.thread_mutex);
    return return_value_pthread_mutex_lock_1;
  }
}

// common_mutex_unlock
// file cache.c line 128
signed int common_mutex_unlock(struct common_mutex *mtx)
{
  if(!(mtx->isproc == 0))
    return 0;

  else
  {
    signed int return_value_pthread_mutex_unlock_1;
    return_value_pthread_mutex_unlock_1=pthread_mutex_unlock(&mtx->mtx.thread_mutex);
    return return_value_pthread_mutex_unlock_1;
  }
}

// datatype_cmp
// file types_ops.c line 330
signed int datatype_cmp(const void *key1, const void *key2)
{
  unsigned int type = *((unsigned int *)key1);
  if(key2 == NULL)
    return -1;

  else
    if((0xFFFF0000 & type) == 0u)
      return (signed int)(*((unsigned int *)key1) - *((unsigned int *)key2));

    else
    {
      type = type >> 16;
      signed int return_value_ci_magic_group_check_1;
      return_value_ci_magic_group_check_1=ci_magic_group_check((signed int)*((unsigned int *)key2), (signed int)type);
      if(!(return_value_ci_magic_group_check_1 == 0))
        return 0;

      else
        return 1;
    }
}

// datatype_dup
// file types_ops.c line 311
void * datatype_dup(const char *str, struct ci_mem_allocator *allocator)
{
  signed int type;
  unsigned int *val;
  void *return_value;
  return_value=allocator->alloc(allocator, sizeof(unsigned int) /*4ul*/ );
  val = (unsigned int *)return_value;
  type=ci_magic_type_id(str);
  if(type >= 0)
    *val = (unsigned int)type;

  else
  {
    type=ci_magic_group_id(str);
    if(type >= 0)
    {
      *val = (unsigned int)type;
      *val = *val << 16;
    }

    else
    {
      allocator->free(allocator, (void *)val);
      val = (unsigned int *)(void *)0;
    }
  }
  return (void *)val;
}

// datatype_equal
// file types_ops.c line 348
signed int datatype_equal(const void *key1, const void *key2)
{
  unsigned int type = *((unsigned int *)key1);
  if(key2 == NULL)
    return 0;

  else
    if((0xFFFF0000 & type) == 0u)
      return (signed int)(*((unsigned int *)key1) == *((unsigned int *)key2));

    else
    {
      type = type >> 16;
      signed int return_value_ci_magic_group_check_1;
      return_value_ci_magic_group_check_1=ci_magic_group_check((signed int)*((unsigned int *)key2), (signed int)type);
      if(!(return_value_ci_magic_group_check_1 == 0))
        return 1;

      else
        return 0;
    }
}

// datatype_free
// file types_ops.c line 371
void datatype_free(void *key, struct ci_mem_allocator *allocator)
{
  allocator->free(allocator, key);
}

// datatype_len
// file types_ops.c line 366
unsigned long int datatype_len(const void *key)
{
  return sizeof(unsigned int) /*4ul*/ ;
}

// default_cmp
// file array.c line 680
static signed int default_cmp(const void *obj1, const void *obj2, unsigned long int size)
{
  signed int return_value_memcmp_1;
  return_value_memcmp_1=memcmp(obj1, obj2, size);
  return return_value_memcmp_1;
}

// del_mutex
// file os/unix/threads.c line 105
static void del_mutex(void *pmutex)
{
  struct mutex_itm *m;
  struct mutex_itm *p = (struct mutex_itm *)(void *)0;
  pthread_mutex_lock(&mutexes_lock);
  m = mutexes;
  for( ; !(m == ((struct mutex_itm *)NULL)); m = m->next)
  {
    if(m->mtx.mutex == (union anonymous_4 *)pmutex)
    {
      if(p == ((struct mutex_itm *)NULL))
        mutexes = mutexes->next;

      else
        p->next = m->next;
      free((void *)m);
      pthread_mutex_unlock(&mutexes_lock);
      goto __CPROVER_DUMP_L6;
    }

    p = m;
  }
  pthread_mutex_unlock(&mutexes_lock);

__CPROVER_DUMP_L6:
  ;
}

// destroy_encaps_entity
// file header.c line 563
void destroy_encaps_entity(struct ci_encaps_entity *e)
{
  _Bool tmp_if_expr_1;
  if(e->type == 0)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = e->type == 1 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_1)
    ci_headers_destroy((struct ci_headers_list *)e->entity);

  else
    free(e->entity);
  free((void *)e);
}

// do_close
// file body.c line 318
void do_close(signed int fd)
{
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  signed int return_value_close_2;
  signed int *return_value___errno_location_3;
  do
  {
    return_value_close_2=close(fd);
    if(return_value_close_2 >= 0)
      break;

    return_value___errno_location_3=__errno_location();
    if(!(*return_value___errno_location_3 == 4))
      break;

  }
  while((_Bool)1);
}

// do_open
// file body.c line 308
signed int do_open(const char *pathname, signed int flags)
{
  signed int fd;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  do
  {
    fd=open64(pathname, flags, 0400 | 0200 | 0400 >> 3 | (0400 >> 3) >> 3);
    if(!(fd >= 0))
    {
      return_value___errno_location_2=__errno_location();
      tmp_if_expr_3 = *return_value___errno_location_2 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
  }
  while(tmp_if_expr_3);
  return fd;
}

// do_read
// file body.c line 292
signed int do_read(signed int fd, void *buf, unsigned long int count)
{
  signed int bytes;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  do
  {
    signed long int return_value_read_4;
    return_value_read_4=read(fd, buf, count);
    bytes = (signed int)return_value_read_4;
    if(!(bytes >= 0))
    {
      return_value___errno_location_2=__errno_location();
      tmp_if_expr_3 = *return_value___errno_location_2 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
  }
  while(tmp_if_expr_3);
  return bytes;
}

// do_write
// file body.c line 282
signed int do_write(signed int fd, const void *buf, unsigned long int count)
{
  signed int bytes;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  do
  {
    signed long int return_value_write_4;
    return_value_write_4=write(fd, buf, count);
    bytes = (signed int)return_value_write_4;
    if(!(bytes >= 0))
    {
      return_value___errno_location_2=__errno_location();
      tmp_if_expr_3 = *return_value___errno_location_2 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
  }
  while(tmp_if_expr_3);
  return bytes;
}

// dump_db
// file c-icap-mkbdb.c line 104
signed int dump_db()
{
  struct __dbc *dbc;
  struct __db_dbt db_key;
  struct __db_dbt db_data;
  signed int ret;
  signed int i;
  void *store;
  void **store_index;
  printf("Going to dump database!\n");
  char *return_value_db_strerror_1;
  char *return_value_db_strerror_2;
  if(!(key_ops == &ci_str_ops) || !(val_ops == &ci_str_ops))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "can not dump not string databases\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("can not dump not string databases\n");

    }

    return 0;
  }

  else
  {
    ret=db->cursor(db, (struct __db_txn *)(void *)0, &dbc, (unsigned int)0);
    if(!(ret == 0))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "error creating cursor\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("error creating cursor\n");

      }

      return 0;
    }

    else
    {
      memset((void *)&db_data, 0, sizeof(struct __db_dbt) /*40ul*/ );
      memset((void *)&db_key, 0, sizeof(struct __db_dbt) /*40ul*/ );
      ret=dbc->c_get(dbc, &db_key, &db_data, (unsigned int)27);
      if(!(ret == 0))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          {
            return_value_db_strerror_1=db_strerror(ret);
            __log_error((void *)0, "error getting first element of DB : %s\n", return_value_db_strerror_1);
          }

          if(!(CI_DEBUG_STDOUT == 0))
          {
            return_value_db_strerror_2=db_strerror(ret);
            printf("error getting first element of DB : %s\n", return_value_db_strerror_2);
          }

        }

        dbc->c_close(dbc);
        return 0;
      }

      else
      {
        printf("%s :", (char *)db_key.data);
        if(!(db_data.data == NULL))
        {
          store = db_data.data;
          store_index = (void **)store;
          i = 0;
          if(!(store_index[(signed long int)i] == NULL))
          {
            store_index[(signed long int)i] = store_index[(signed long int)i] + (signed long int)store;
            i = i + 1;
          }

          i = 0;
          if(!(store_index[(signed long int)i] == NULL))
          {
            printf("%s |", (char *)store_index[(signed long int)i]);
            i = i + 1;
          }

        }

        printf("\n");
        ret=dbc->c_get(dbc, &db_key, &db_data, (unsigned int)16);
        dbc->c_close(dbc);
        return 1;
      }
    }
  }
}

// extend_object_type
// file filetype.c line 559
signed int extend_object_type(struct ci_magics_db *db, struct ci_headers_list *headers, const char *buf, signed int len, signed int *iscompressed)
{
  signed int file_type;
  signed int unzip_error = 0;
  signed int unzipped_buf_len = 0;
  char *unzipped_buf = (char *)(void *)0;
  const char *checkbuf = buf;
  const char *content_type = (const char *)(void *)0;
  const char *content_encoding = (const char *)(void *)0;
  *iscompressed = 0;
  char *return_value_strcasestr_2;
  char *return_value_strcasestr_1;
  char *return_value_strcasestr_14;
  char *return_value_strcasestr_16;
  if(!(len >= 1))
    return 5;

  else
  {
    if(!(headers == ((struct ci_headers_list *)NULL)))
    {
      content_encoding=ci_headers_value(headers, "Content-Encoding");
      if(!(content_encoding == ((const char *)NULL)))
      {
        if(CI_DEBUG_LEVEL >= 8)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Content-Encoding :%s\n", content_encoding);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Content-Encoding :%s\n", content_encoding);

        }

        char *return_value_strcasestr_3;
        return_value_strcasestr_3=strcasestr(content_encoding, "gzip");
        if(!(return_value_strcasestr_3 == ((char *)NULL)))
          *iscompressed = 1;

        else
        {
          return_value_strcasestr_2=strcasestr(content_encoding, "deflate");
          if(!(return_value_strcasestr_2 == ((char *)NULL)))
            *iscompressed = 2;

          else
          {
            return_value_strcasestr_1=strcasestr(content_encoding, "bzip2");
            if(!(return_value_strcasestr_1 == ((char *)NULL)))
              *iscompressed = 3;

            else
              *iscompressed = 4;
          }
        }
        _Bool tmp_if_expr_6;
        if(*iscompressed == 1)
          tmp_if_expr_6 = (_Bool)1;

        else
          tmp_if_expr_6 = *iscompressed == 2 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_6)
        {
          void *return_value_ci_buffer_alloc_4;
          return_value_ci_buffer_alloc_4=ci_buffer_alloc(len);
          unzipped_buf = (char *)return_value_ci_buffer_alloc_4;
          unzipped_buf_len = len;
          signed int return_value_ci_uncompress_preview_5;
          return_value_ci_uncompress_preview_5=ci_uncompress_preview(*iscompressed, buf, len, unzipped_buf, &unzipped_buf_len);
          if(!(return_value_ci_uncompress_preview_5 == -1))
          {
            checkbuf = unzipped_buf;
            len = unzipped_buf_len;
          }

          else
          {
            if(CI_DEBUG_LEVEL >= 3)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "Error uncompressing encoded object\n");

              if(!(CI_DEBUG_STDOUT == 0))
                printf("Error uncompressing encoded object\n");

            }

            ci_buffer_free((void *)unzipped_buf);
            unzipped_buf = (char *)(void *)0;
            unzip_error = 1;
          }
        }

      }

    }

    file_type=ci_filetype(db, checkbuf, len);
    if(CI_DEBUG_LEVEL >= 7)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      {
        char *tmp_if_expr_7;
        if(!(db == ((struct ci_magics_db *)NULL)))
          tmp_if_expr_7 = (db->types + (signed long int)file_type)->name;

        else
          tmp_if_expr_7 = (char *)(void *)0;
        _Bool tmp_if_expr_8;
        if(!(db == ((struct ci_magics_db *)NULL)))
          tmp_if_expr_8 = file_type < db->types_num ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_8 = (_Bool)0;
        char *tmp_if_expr_9;
        if(file_type >= 0 && tmp_if_expr_8)
          tmp_if_expr_9 = (db->types + (signed long int)file_type)->descr;

        else
          tmp_if_expr_9 = (char *)(void *)0;
        __log_error((void *)0, "File type returned :%s,%s\n", tmp_if_expr_7, tmp_if_expr_9);
      }

      if(!(CI_DEBUG_STDOUT == 0))
      {
        char *tmp_if_expr_10;
        if(!(db == ((struct ci_magics_db *)NULL)))
          tmp_if_expr_10 = (db->types + (signed long int)file_type)->name;

        else
          tmp_if_expr_10 = (char *)(void *)0;
        _Bool tmp_if_expr_11;
        if(!(db == ((struct ci_magics_db *)NULL)))
          tmp_if_expr_11 = file_type < db->types_num ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_11 = (_Bool)0;
        char *tmp_if_expr_12;
        if(file_type >= 0 && tmp_if_expr_11)
          tmp_if_expr_12 = (db->types + (signed long int)file_type)->descr;

        else
          tmp_if_expr_12 = (char *)(void *)0;
        printf("File type returned :%s,%s\n", tmp_if_expr_10, tmp_if_expr_12);
      }

    }

    signed int return_value_ci_belongs_to_group_18;
    return_value_ci_belongs_to_group_18=ci_belongs_to_group(db, file_type, 0);
    if(!(return_value_ci_belongs_to_group_18 == 0))
    {
      if(!(headers == ((struct ci_headers_list *)NULL)))
      {
        content_type=ci_headers_value(headers, "Content-Type");
        if(!(content_type == ((const char *)NULL)))
        {
          char *return_value_strcasestr_13;
          return_value_strcasestr_13=strcasestr(content_type, "text/html");
          _Bool tmp_if_expr_15;
          if(!(return_value_strcasestr_13 == ((char *)NULL)))
            tmp_if_expr_15 = (_Bool)1;

          else
          {
            return_value_strcasestr_14=strcasestr(content_type, "text/css");
            tmp_if_expr_15 = return_value_strcasestr_14 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
          }
          _Bool tmp_if_expr_17;
          if(tmp_if_expr_15)
            tmp_if_expr_17 = (_Bool)1;

          else
          {
            return_value_strcasestr_16=strcasestr(content_type, "text/javascript");
            tmp_if_expr_17 = return_value_strcasestr_16 != ((char *)NULL) ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_17)
            file_type = 4;

        }

      }

    }

    if(CI_DEBUG_LEVEL >= 7)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      {
        char *tmp_if_expr_19;
        if(!(db == ((struct ci_magics_db *)NULL)))
          tmp_if_expr_19 = (db->types + (signed long int)file_type)->name;

        else
          tmp_if_expr_19 = (char *)(void *)0;
        _Bool tmp_if_expr_20;
        if(!(db == ((struct ci_magics_db *)NULL)))
          tmp_if_expr_20 = file_type < db->types_num ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_20 = (_Bool)0;
        char *tmp_if_expr_21;
        if(file_type >= 0 && tmp_if_expr_20)
          tmp_if_expr_21 = (db->types + (signed long int)file_type)->descr;

        else
          tmp_if_expr_21 = (char *)(void *)0;
        __log_error((void *)0, "The file type now is :%s,%s\n", tmp_if_expr_19, tmp_if_expr_21);
      }

      if(!(CI_DEBUG_STDOUT == 0))
      {
        char *tmp_if_expr_22;
        if(!(db == ((struct ci_magics_db *)NULL)))
          tmp_if_expr_22 = (db->types + (signed long int)file_type)->name;

        else
          tmp_if_expr_22 = (char *)(void *)0;
        _Bool tmp_if_expr_23;
        if(!(db == ((struct ci_magics_db *)NULL)))
          tmp_if_expr_23 = file_type < db->types_num ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_23 = (_Bool)0;
        char *tmp_if_expr_24;
        if(file_type >= 0 && tmp_if_expr_23)
          tmp_if_expr_24 = (db->types + (signed long int)file_type)->descr;

        else
          tmp_if_expr_24 = (char *)(void *)0;
        printf("The file type now is :%s,%s\n", tmp_if_expr_22, tmp_if_expr_24);
      }

    }

    if(!(unzipped_buf == ((char *)NULL)))
      ci_buffer_free((void *)unzipped_buf);

    return file_type;
  }
}

// file_proc_mutex_destroy
// file os/unix/proc_mutex.c line 195
static signed int file_proc_mutex_destroy(struct ci_proc_mutex *mutex)
{
  close(mutex->_anon0.file.fd);
  signed int return_value_unlink_1;
  return_value_unlink_1=unlink(mutex->name);
  if(!(return_value_unlink_1 == 0))
    return 0;

  else
    return 1;
}

// file_proc_mutex_init
// file os/unix/proc_mutex.c line 185
static signed int file_proc_mutex_init(struct ci_proc_mutex *mutex, const char *name)
{
  strcpy(mutex->name, "/tmp/icap_lock");
  snprintf(mutex->name, (unsigned long int)64, "%s_%s.XXXXXX", (const void *)"/tmp/icap_lock", name);
  mutex->_anon0.file.fd=mkstemp64(mutex->name);
  if(!(mutex->_anon0.file.fd >= 0))
    return 0;

  else
    return 1;
}

// file_proc_mutex_lock
// file os/unix/proc_mutex.c line 203
static signed int file_proc_mutex_lock(struct ci_proc_mutex *mutex)
{
  struct flock fl;
  fl.l_type = (signed short int)1;
  fl.l_whence = (signed short int)0;
  fl.l_start = (signed long int)0;
  fl.l_len = (signed long int)0;
  signed int return_value_fcntl_1;
  return_value_fcntl_1=fcntl(mutex->_anon0.file.fd, 7, &fl);
  if(!(return_value_fcntl_1 >= 0))
    return 0;

  else
    return 1;
}

// file_proc_mutex_print_info
// file os/unix/proc_mutex.c line 228
static signed int file_proc_mutex_print_info(struct ci_proc_mutex *mutex, char *buf, unsigned long int buf_size)
{
  signed int return_value_snprintf_1;
  return_value_snprintf_1=snprintf(buf, buf_size, "file:%s", (const void *)mutex->name);
  return return_value_snprintf_1;
}

// file_proc_mutex_unlock
// file os/unix/proc_mutex.c line 216
static signed int file_proc_mutex_unlock(struct ci_proc_mutex *mutex)
{
  struct flock fl;
  fl.l_type = (signed short int)2;
  fl.l_whence = (signed short int)0;
  fl.l_start = (signed long int)0;
  fl.l_len = (signed long int)0;
  signed int return_value_fcntl_1;
  return_value_fcntl_1=fcntl(mutex->_anon0.file.fd, 6, &fl);
  if(!(return_value_fcntl_1 >= 0))
    return 0;

  else
    return 1;
}

// file_table_close
// file lookup_file_table.c line 264
void file_table_close(struct ci_lookup_table *table)
{
  signed int i;
  void **vals = (void **)(void *)0;
  struct text_table_entry *tmp;
  struct ci_mem_allocator *file_table_close__1__allocator = table->allocator;
  struct text_table *text_table = (struct text_table *)table->data;
  if(text_table == ((struct text_table *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Closing a non open file lookup table?(%s)\n", table->path);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Closing a non open file lookup table?(%s)\n", table->path);

    }

  }

  else
  {
    if(!(text_table->entries == ((struct text_table_entry *)NULL)))
    {
      tmp = text_table->entries;
      text_table->entries = text_table->entries->next;
      if(!(tmp->vals == ((void **)NULL)))
      {
        vals = (void **)tmp->vals;
        i = 0;
        if(!(vals[(signed long int)i] == NULL))
        {
          table->val_ops->free(vals[(signed long int)i], file_table_close__1__allocator);
          i = i + 1;
        }

        file_table_close__1__allocator->free(file_table_close__1__allocator, (void *)tmp->vals);
      }

      table->key_ops->free(tmp->key, file_table_close__1__allocator);
      file_table_close__1__allocator->free(file_table_close__1__allocator, (void *)tmp);
    }

    file_table_close__1__allocator->free(file_table_close__1__allocator, (void *)text_table);
    table->data = (void *)0;
  }
}

// file_table_open
// file lookup_file_table.c line 247
void * file_table_open(struct ci_lookup_table *table)
{
  struct ci_mem_allocator *file_table_open__1__allocator = table->allocator;
  struct text_table *text_table;
  void *return_value;
  return_value=file_table_open__1__allocator->alloc(file_table_open__1__allocator, sizeof(struct text_table) /*24ul*/ );
  text_table = (struct text_table *)return_value;
  if(text_table == ((struct text_table *)NULL))
    return (void *)0;

  else
  {
    text_table->entries = (struct text_table_entry *)(void *)0;
    table->data = (void *)text_table;
    signed int return_value_load_text_table_1;
    return_value_load_text_table_1=load_text_table(table->path, table);
    if(return_value_load_text_table_1 == 0)
    {
      table->data = (void *)0;
      return table->data;
    }

    else
    {
      text_table->hash_table = (struct ci_hash_table *)(void *)0;
      return (void *)text_table;
    }
  }
}

// file_table_release_result
// file lookup_file_table.c line 316
void file_table_release_result(struct ci_lookup_table *table_data, void **val)
{
  ;
}

// file_table_search
// file lookup_file_table.c line 294
void * file_table_search(struct ci_lookup_table *table, void *key, void ***vals)
{
  struct text_table_entry *e;
  struct text_table *text_table = (struct text_table *)table->data;
  if(text_table == ((struct text_table *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Search a non open lookup table?(%s)\n", table->path);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Search a non open lookup table?(%s)\n", table->path);

    }

    return (void *)0;
  }

  else
  {
    e = text_table->entries;
    *vals = (void **)(void *)0;
    if(!(e == ((struct text_table_entry *)NULL)))
    {
      signed int return_value;
      return_value=table->key_ops->compare((void *)e->key, key);
      if(return_value == 0)
      {
        *vals = (void **)e->vals;
        return (void *)e->key;
      }

      e = e->next;
    }

    return (void *)0;
  }
}

// fmt_gmttime
// file txt_format.c line 399
signed int fmt_gmttime(struct ci_request *req, char *buf, signed int len, const char *param)
{
  struct tm tm;
  signed long int t;
  const char *tfmt = "%d/%b/%Y:%H:%M:%S";
  if(len == 0)
    return 0;

  else
  {
    if(!(param == ((const char *)NULL)))
    {
      if(!((signed int)*param == 0))
        tfmt = param;

    }

    t=time(&t);
    gmtime_r(&t, &tm);
    unsigned long int return_value_strftime_1;
    return_value_strftime_1=strftime(buf, (unsigned long int)len, tfmt, &tm);
    return (signed int)return_value_strftime_1;
  }
}

// fmt_http_req_head_o
// file txt_format.c line 474
signed int fmt_http_req_head_o(struct ci_request *req, char *buf, signed int len, const char *param)
{
  const char *s = (const char *)(void *)0;
  signed int i;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(len == 0)
    return 0;

  else
  {
    _Bool tmp_if_expr_1;
    if(param == ((const char *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)param[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
      s=ci_http_request(req);

    else
      s=ci_http_request_get_header(req, param);
    if(!(s == ((const char *)NULL)))
    {
      i = 0;
      do
      {
        if(!(i >= len))
          tmp_if_expr_2 = (signed int)*s != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(tmp_if_expr_2)
          tmp_if_expr_3 = (signed int)*s != 13 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_3 = (_Bool)0;
        if(tmp_if_expr_3)
          tmp_if_expr_4 = (signed int)*s != 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        if(!tmp_if_expr_4)
          break;

        buf[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
      return i;
    }

    else
    {
      *buf = (char)45;
      return 1;
    }
  }
}

// fmt_http_req_url_o
// file txt_format.c line 466
signed int fmt_http_req_url_o(struct ci_request *req, char *buf, signed int len, const char *param)
{
  if(len == 0)
    return 0;

  else
  {
    signed int return_value_ci_http_request_url_1;
    return_value_ci_http_request_url_1=ci_http_request_url(req, buf, len);
    return return_value_ci_http_request_url_1;
  }
}

// fmt_http_res_head_o
// file txt_format.c line 497
signed int fmt_http_res_head_o(struct ci_request *req, char *buf, signed int len, const char *param)
{
  const char *s = (const char *)(void *)0;
  signed int i;
  struct ci_headers_list *http_resp_headers;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(len == 0)
    return 0;

  else
  {
    _Bool tmp_if_expr_1;
    if(param == ((const char *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)param[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      http_resp_headers=ci_http_response_headers(req);
      if(!(http_resp_headers == ((struct ci_headers_list *)NULL)))
      {
        if(!(http_resp_headers->used == 0))
          s = http_resp_headers->headers[(signed long int)0];

      }

    }

    else
      s=ci_http_response_get_header(req, param);
    if(!(s == ((const char *)NULL)))
    {
      i = 0;
      do
      {
        if(!(i >= len))
          tmp_if_expr_2 = (signed int)*s != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(tmp_if_expr_2)
          tmp_if_expr_3 = (signed int)*s != 13 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_3 = (_Bool)0;
        if(tmp_if_expr_3)
          tmp_if_expr_4 = (signed int)*s != 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        if(!tmp_if_expr_4)
          break;

        buf[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
      return i;
    }

    else
    {
      *buf = (char)45;
      return 1;
    }
  }
}

// fmt_httpclientip
// file txt_format.c line 429
signed int fmt_httpclientip(struct ci_request *req, char *buf, signed int len, const char *param)
{
  const char *s;
  signed int i;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  if(len == 0)
    return 0;

  else
  {
    s=ci_headers_value(req->request_header, "X-Client-IP");
    if(!(s == ((const char *)NULL)))
    {
      i = 0;
      do
      {
        if(!(i >= len))
          tmp_if_expr_1 = (signed int)*s != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        if(tmp_if_expr_1)
          tmp_if_expr_2 = (signed int)*s != 13 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(tmp_if_expr_2)
          tmp_if_expr_3 = (signed int)*s != 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_3 = (_Bool)0;
        if(!tmp_if_expr_3)
          break;

        buf[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
      return i;
    }

    else
    {
      *buf = (char)45;
      return 1;
    }
  }
}

// fmt_httpserverip
// file txt_format.c line 448
signed int fmt_httpserverip(struct ci_request *req, char *buf, signed int len, const char *param)
{
  const char *s;
  signed int i;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  if(len == 0)
    return 0;

  else
  {
    s=ci_headers_value(req->request_header, "X-Server-IP");
    if(!(s == ((const char *)NULL)))
    {
      i = 0;
      do
      {
        if(!(i >= len))
          tmp_if_expr_1 = (signed int)*s != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_1 = (_Bool)0;
        if(tmp_if_expr_1)
          tmp_if_expr_2 = (signed int)*s != 13 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(tmp_if_expr_2)
          tmp_if_expr_3 = (signed int)*s != 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_3 = (_Bool)0;
        if(!tmp_if_expr_3)
          break;

        buf[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
      return i;
    }

    else
    {
      *buf = (char)45;
      return 1;
    }
  }
}

// fmt_icap_req_head
// file txt_format.c line 525
signed int fmt_icap_req_head(struct ci_request *req, char *buf, signed int len, const char *param)
{
  const char *s = (const char *)(void *)0;
  signed int i;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(len == 0)
    return 0;

  else
  {
    _Bool tmp_if_expr_1;
    if(param == ((const char *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)param[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      if(!(req->request_header == ((struct ci_headers_list *)NULL)))
      {
        if(!(req->request_header->used == 0))
          s = req->request_header->headers[(signed long int)0];

      }

    }

    else
      s=ci_headers_value(req->request_header, param);
    if(!(s == ((const char *)NULL)))
    {
      i = 0;
      do
      {
        if(!(i >= len))
          tmp_if_expr_2 = (signed int)*s != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(tmp_if_expr_2)
          tmp_if_expr_3 = (signed int)*s != 13 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_3 = (_Bool)0;
        if(tmp_if_expr_3)
          tmp_if_expr_4 = (signed int)*s != 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        if(!tmp_if_expr_4)
          break;

        buf[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
      return i;
    }

    else
    {
      *buf = (char)45;
      return 1;
    }
  }
}

// fmt_icap_res_head
// file txt_format.c line 549
signed int fmt_icap_res_head(struct ci_request *req, char *buf, signed int len, const char *param)
{
  const char *s = (const char *)(void *)0;
  signed int i;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(len == 0)
    return 0;

  else
  {
    _Bool tmp_if_expr_1;
    if(param == ((const char *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = (signed int)param[(signed long int)0] == 0 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      if(!(req->response_header == ((struct ci_headers_list *)NULL)))
      {
        if(!(req->response_header->used == 0))
          s = req->response_header->headers[(signed long int)0];

      }

    }

    else
    {
      s=ci_headers_value(req->response_header, param);
      if(s == ((const char *)NULL))
      {
        if(!(req->xheaders == ((struct ci_headers_list *)NULL)))
          s=ci_headers_value(req->xheaders, param);

      }

    }
    if(!(s == ((const char *)NULL)))
    {
      i = 0;
      do
      {
        if(!(i >= len))
          tmp_if_expr_2 = (signed int)*s != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(tmp_if_expr_2)
          tmp_if_expr_3 = (signed int)*s != 13 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_3 = (_Bool)0;
        if(tmp_if_expr_3)
          tmp_if_expr_4 = (signed int)*s != 10 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        if(!tmp_if_expr_4)
          break;

        buf[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
      return i;
    }

    else
    {
      *buf = (char)45;
      return 1;
    }
  }
}

// fmt_icapmethod
// file txt_format.c line 338
signed int fmt_icapmethod(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int i;
  const char *s;
  _Bool tmp_if_expr_1;
  if(!(req->type >= 5))
    tmp_if_expr_1 = req->type >= 0x01 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  const char *tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = ci_methods[(signed long int)req->type];

  else
    tmp_if_expr_2 = "UNKNOWN";
  s = tmp_if_expr_2;
  i = 0;
  _Bool tmp_if_expr_3;
  do
  {
    if(!(i >= len))
      tmp_if_expr_3 = *s != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(!tmp_if_expr_3)
      break;

    buf[(signed long int)i] = *s;
    i = i + 1;
    s = s + 1l;
  }
  while((_Bool)1);
  return i;
}

// fmt_icapstatus
// file txt_format.c line 416
signed int fmt_icapstatus(struct ci_request *req, char *buf, signed int len, const char *param)
{
  _Bool tmp_if_expr_1;
  if(req->return_code >= 0)
    tmp_if_expr_1 = req->return_code < 16 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  signed int tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = ci_error_codes[(signed long int)req->return_code].code;

  else
    tmp_if_expr_2 = 1000;
  signed int return_value_snprintf_3;
  return_value_snprintf_3=snprintf(buf, (unsigned long int)len, "%d", tmp_if_expr_2);
  return return_value_snprintf_3;
}

// fmt_localip
// file txt_format.c line 327
signed int fmt_localip(struct ci_request *req, char *buf, signed int len, const char *param)
{
  if(!(len >= 16))
    return 0;

  else
  {
    const char *return_value_ci_sockaddr_t_to_ip_1;
    return_value_ci_sockaddr_t_to_ip_1=ci_sockaddr_t_to_ip(&req->connection->srvaddr, buf, 16);
    if(return_value_ci_sockaddr_t_to_ip_1 == ((const char *)NULL))
      strcpy(buf, "-");

    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(buf);
    return (signed int)return_value_strlen_2;
  }
}

// fmt_localtime
// file txt_format.c line 382
signed int fmt_localtime(struct ci_request *req, char *buf, signed int len, const char *param)
{
  struct tm tm;
  signed long int t;
  const char *tfmt = "%d/%b/%Y:%H:%M:%S %z";
  if(len == 0)
    return 0;

  else
  {
    if(!(param == ((const char *)NULL)))
    {
      if(!((signed int)*param == 0))
        tfmt = param;

    }

    t=time(&t);
    localtime_r(&t, &tm);
    unsigned long int return_value_strftime_1;
    return_value_strftime_1=strftime(buf, (unsigned long int)len, tfmt, &tm);
    return (signed int)return_value_strftime_1;
  }
}

// fmt_logstr
// file txt_format.c line 645
signed int fmt_logstr(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int i;
  const char *s;
  _Bool tmp_if_expr_1;
  if(req->log_str == ((char *)NULL))
    return 0;

  else
  {
    s = req->log_str;
    i = 0;
    do
    {
      if(!(i >= len))
        tmp_if_expr_1 = *s != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_1 = (_Bool)0;
      if(!tmp_if_expr_1)
        break;

      buf[(signed long int)i] = *s;
      i = i + 1;
      s = s + 1l;
    }
    while((_Bool)1);
    return i;
  }
}

// fmt_none
// file txt_format.c line 142
signed int fmt_none(struct ci_request *req, char *buf, signed int len, const char *param)
{
  if(len == 0)
    return 0;

  else
  {
    *buf = (char)45;
    return 1;
  }
}

// fmt_percent
// file txt_format.c line 151
signed int fmt_percent(struct ci_request *req, char *buf, signed int len, const char *param)
{
  if(len == 0)
    return 0;

  else
  {
    *buf = (char)37;
    return 1;
  }
}

// fmt_remoteip
// file txt_format.c line 316
signed int fmt_remoteip(struct ci_request *req, char *buf, signed int len, const char *param)
{
  if(!(len >= 16))
    return 0;

  else
  {
    const char *return_value_ci_sockaddr_t_to_ip_1;
    return_value_ci_sockaddr_t_to_ip_1=ci_sockaddr_t_to_ip(&req->connection->claddr, buf, 16);
    if(return_value_ci_sockaddr_t_to_ip_1 == ((const char *)NULL))
      strcpy(buf, "-");

    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(buf);
    return (signed int)return_value_strlen_2;
  }
}

// fmt_req_attribute
// file txt_format.c line 659
signed int fmt_req_attribute(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int i;
  const char *s;
  _Bool tmp_if_expr_2;
  if(req->attributes == ((struct ci_array *)NULL))
    return 0;

  else
  {
    const void *return_value_ci_array_search_1;
    return_value_ci_array_search_1=ci_array_search(req->attributes, param);
    s = (const char *)return_value_ci_array_search_1;
    if(s == ((const char *)NULL))
      return 0;

    else
    {
      i = 0;
      do
      {
        if(!(i >= len))
          tmp_if_expr_2 = *s != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(!tmp_if_expr_2)
          break;

        buf[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
      return i;
    }
  }
}

// fmt_req_body_bytes_rcv
// file txt_format.c line 593
signed int fmt_req_body_bytes_rcv(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int return_value_snprintf_1;
  return_value_snprintf_1=snprintf(buf, (unsigned long int)len, "%lld", (signed long long int)req->body_bytes_in);
  return return_value_snprintf_1;
}

// fmt_req_body_bytes_sent
// file txt_format.c line 597
signed int fmt_req_body_bytes_sent(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int return_value_snprintf_1;
  return_value_snprintf_1=snprintf(buf, (unsigned long int)len, "%lld", (signed long long int)req->body_bytes_out);
  return return_value_snprintf_1;
}

// fmt_req_bytes_rcv
// file txt_format.c line 577
signed int fmt_req_bytes_rcv(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int return_value_snprintf_1;
  return_value_snprintf_1=snprintf(buf, (unsigned long int)len, "%lld", (signed long long int)req->bytes_in);
  return return_value_snprintf_1;
}

// fmt_req_bytes_sent
// file txt_format.c line 581
signed int fmt_req_bytes_sent(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int return_value_snprintf_1;
  return_value_snprintf_1=snprintf(buf, (unsigned long int)len, "%lld", (signed long long int)req->bytes_out);
  return return_value_snprintf_1;
}

// fmt_req_http_bytes_rcv
// file txt_format.c line 585
signed int fmt_req_http_bytes_rcv(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int return_value_snprintf_1;
  return_value_snprintf_1=snprintf(buf, (unsigned long int)len, "%lld", (signed long long int)req->http_bytes_in);
  return return_value_snprintf_1;
}

// fmt_req_http_bytes_sent
// file txt_format.c line 589
signed int fmt_req_http_bytes_sent(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int return_value_snprintf_1;
  return_value_snprintf_1=snprintf(buf, (unsigned long int)len, "%lld", (signed long long int)req->http_bytes_out);
  return return_value_snprintf_1;
}

// fmt_req_preview_hex
// file txt_format.c line 601
signed int fmt_req_preview_hex(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int i;
  signed int num;
  signed int n;
  signed int bytes;
  _Bool tmp_if_expr_2;
  if(len == 0)
    return 0;

  else
    if(!(req->preview_data.used >= 1))
    {
      *buf = (char)45;
      return 1;
    }

    else
    {
      if(!(param == ((const char *)NULL)))
      {
        signed long int return_value_strtol_1;
        return_value_strtol_1=strtol(param, (char ** restrict )(void *)0, 10);
        num = (signed int)return_value_strtol_1;
      }

      else
        num = 5;
      n = 0;
      i = 0;
      do
      {
        if(!(i >= num))
          tmp_if_expr_2 = i < req->preview_data.used ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(!(len >= 1) || !tmp_if_expr_2)
          break;

        _Bool tmp_if_expr_4;
        if((signed int)req->preview_data.buf[(signed long int)i] >= 32)
          tmp_if_expr_4 = (signed int)req->preview_data.buf[(signed long int)i] <= 126 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        if(tmp_if_expr_4)
        {
          signed int tmp_post_3 = n;
          n = n + 1;
          buf[(signed long int)tmp_post_3] = req->preview_data.buf[(signed long int)i];
          len = len - 1;
        }

        else
        {
          bytes=snprintf(buf + (signed long int)n, (unsigned long int)len, "\\x%X", 0xFF & (signed int)buf[(signed long int)i]);
          if(!(len >= bytes))
            bytes = len;

          n = n + bytes;
          len = len - bytes;
        }
        i = i + 1;
      }
      while((_Bool)1);
      return n;
    }
}

// fmt_req_preview_len
// file txt_format.c line 633
signed int fmt_req_preview_len(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int return_value_snprintf_1;
  if(len == 0)
    return 0;

  else
  {
    if(req->preview >= 0)
    {
      return_value_snprintf_1=snprintf(buf, (unsigned long int)len, "%d", req->preview_data.used);
      return return_value_snprintf_1;
    }

    *buf = (char)45;
    return 1;
  }
}

// fmt_request
// file txt_format.c line 365
signed int fmt_request(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int i;
  char *s = req->service;
  i = 0;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(i >= len))
      tmp_if_expr_1 = *s != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    buf[(signed long int)i] = *s;
    i = i + 1;
    s = s + 1l;
  }
  while((_Bool)1);
  _Bool tmp_if_expr_2;
  if(!((signed int)req->args[0l] == 0))
  {
    if(!(i >= len))
    {
      buf[(signed long int)i] = (char)63;
      s = req->args;
      i = i + 1;
      do
      {
        if(!(i >= len))
          tmp_if_expr_2 = *s != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(!tmp_if_expr_2)
          break;

        buf[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
    }

  }

  return i;
}

// fmt_seconds
// file txt_format.c line 422
signed int fmt_seconds(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed long int tm;
  time(&tm);
  signed int return_value_snprintf_1;
  return_value_snprintf_1=snprintf(buf, (unsigned long int)len, "%ld", tm);
  return return_value_snprintf_1;
}

// fmt_service
// file txt_format.c line 347
signed int fmt_service(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int i;
  char *s = req->service;
  i = 0;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(i >= len))
      tmp_if_expr_1 = *s != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    buf[(signed long int)i] = *s;
    i = i + 1;
    s = s + 1l;
  }
  while((_Bool)1);
  return i;
}

// fmt_username
// file txt_format.c line 356
signed int fmt_username(struct ci_request *req, char *buf, signed int len, const char *param)
{
  signed int i;
  char *s = req->user;
  i = 0;
  _Bool tmp_if_expr_1;
  do
  {
    if(!(i >= len))
      tmp_if_expr_1 = *s != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    buf[(signed long int)i] = *s;
    i = i + 1;
    s = s + 1l;
  }
  while((_Bool)1);
  return i;
}

// free_a_buffer
// file decode.c line 203
static void free_a_buffer(void *op, void *ptr)
{
  ci_buffer_free(ptr);
}

// free_cmp_uint64_data
// file acl.c line 997
void free_cmp_uint64_data(struct ci_request *req, void *param)
{
  ci_buffer_free(param);
}

// free_data_type
// file acl.c line 976
void free_data_type(struct ci_request *req, void *param)
{
  free(param);
}

// free_http_req_header
// file acl.c line 938
void free_http_req_header(struct ci_request *req, void *param)
{
  struct ci_headers_list *heads;
  heads=ci_http_request_headers(req);
  release_header_value(heads, (char *)param);
}

// free_http_resp_header
// file acl.c line 952
void free_http_resp_header(struct ci_request *req, void *param)
{
  struct ci_headers_list *heads;
  heads=ci_http_response_headers(req);
  release_header_value(heads, (char *)param);
}

// free_icap_header
// file acl.c line 911
void free_icap_header(struct ci_request *req, void *param)
{
  struct ci_headers_list *heads = req->request_header;
  release_header_value(heads, (char *)param);
}

// free_icap_response_header
// file acl.c line 925
void free_icap_response_header(struct ci_request *req, void *param)
{
  struct ci_headers_list *heads = req->response_header;
  release_header_value(heads, (char *)param);
}

// free_records_group
// file filetype.c line 167
void free_records_group(struct ci_magic_record *record)
{
  signed int i = 0;
  for( ; !(record->groups[(signed long int)i] == ((char *)NULL)); i = i + 1)
  {
    free((void *)record->groups[(signed long int)i]);
    record->groups[(signed long int)i] = (char *)(void *)0;
  }
}

// free_time_data
// file acl.c line 394
void free_time_data(struct ci_request *req, void *param)
{
  if(CI_DEBUG_LEVEL >= 5)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "free_time_data(req=%p, param=%p)", req, param);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("free_time_data(req=%p, param=%p)", req, param);

  }

  ci_buffer_free(param);
}

// get_client_ip
// file acl.c line 60
void * get_client_ip(struct ci_request *req, char *param)
{
  return (void *)&req->connection->claddr;
}

// get_content_length
// file acl.c line 980
void * get_content_length(struct ci_request *req, char *param)
{
  struct acl_cmp_uint64_data *clen_p;
  void *return_value_ci_buffer_alloc_1;
  return_value_ci_buffer_alloc_1=ci_buffer_alloc((signed int)sizeof(struct acl_cmp_uint64_data) /*16ul*/ );
  clen_p = (struct acl_cmp_uint64_data *)return_value_ci_buffer_alloc_1;
  signed long int clen;
  clen=ci_http_content_length(req);
  if(!(clen >= 0l))
    return (void *)0;

  else
  {
    clen_p->data = (unsigned long int)clen;
    if((signed int)*param == 61)
      clen_p->operator = 0;

    else
      if((signed int)*param == 62)
        clen_p->operator = 1;

      else
        if((signed int)*param == 60)
          clen_p->operator = 2;

    return (void *)clen_p;
  }
}

// get_data_type
// file acl.c line 961
void * get_data_type(struct ci_request *req, char *param)
{
  signed int type;
  signed int isenc;
  signed int *ret_type;
  type=ci_magic_req_data_type(req, &isenc);
  if(!(type >= 0))
    return (void *)0;

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(unsigned int) /*4ul*/ );
    ret_type = (signed int *)return_value_malloc_1;
    if(ret_type == ((signed int *)NULL))
      return (void *)0;

    else
    {
      *ret_type = type;
      return (void *)ret_type;
    }
  }
}

// get_encaps_type
// file header.c line 573
signed int get_encaps_type(const char *buf, signed int *val, char **endpoint)
{
  signed int return_value_strncmp_2;
  return_value_strncmp_2=strncmp(buf, "req-hdr", (unsigned long int)7);
  if(return_value_strncmp_2 == 0)
  {
    signed long int return_value_strtol_1;
    return_value_strtol_1=strtol(buf + (signed long int)8, endpoint, 10);
    *val = (signed int)return_value_strtol_1;
    return 0;
  }

  signed int return_value_strncmp_4;
  return_value_strncmp_4=strncmp(buf, "res-hdr", (unsigned long int)7);
  if(return_value_strncmp_4 == 0)
  {
    signed long int return_value_strtol_3;
    return_value_strtol_3=strtol(buf + (signed long int)8, endpoint, 10);
    *val = (signed int)return_value_strtol_3;
    return 1;
  }

  signed int return_value_strncmp_6;
  return_value_strncmp_6=strncmp(buf, "req-body", (unsigned long int)8);
  if(return_value_strncmp_6 == 0)
  {
    signed long int return_value_strtol_5;
    return_value_strtol_5=strtol(buf + (signed long int)9, endpoint, 10);
    *val = (signed int)return_value_strtol_5;
    return 2;
  }

  signed int return_value_strncmp_8;
  return_value_strncmp_8=strncmp(buf, "res-body", (unsigned long int)8);
  if(return_value_strncmp_8 == 0)
  {
    signed long int return_value_strtol_7;
    return_value_strtol_7=strtol(buf + (signed long int)9, endpoint, 10);
    *val = (signed int)return_value_strtol_7;
    return 3;
  }

  signed int return_value_strncmp_10;
  return_value_strncmp_10=strncmp(buf, "null-body", (unsigned long int)9);
  if(return_value_strncmp_10 == 0)
  {
    signed long int return_value_strtol_9;
    return_value_strtol_9=strtol(buf + (signed long int)10, endpoint, 10);
    *val = (signed int)return_value_strtol_9;
    return 4;
  }

  return -1;
}

// get_header
// file acl.c line 872
const char * get_header(struct ci_headers_list *headers, char *head)
{
  const char *val;
  char *buf;
  signed int i;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(head == ((char *)NULL) || headers == ((struct ci_headers_list *)NULL))
    return (const char *)(void *)0;

  else
  {
    val=ci_headers_value(headers, head);
    if(val == ((const char *)NULL))
      return (const char *)(void *)0;

    else
      if(headers->packed == 0)
        return val;

      else
      {
        void *return_value_ci_buffer_alloc_1;
        return_value_ci_buffer_alloc_1=ci_buffer_alloc(8192);
        buf = (char *)return_value_ci_buffer_alloc_1;
        if(buf == ((char *)NULL))
          return (const char *)(void *)0;

        else
        {
          i = 0;
          do
          {
            if(!(i >= 8191))
              tmp_if_expr_2 = (signed int)*val != 0 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_2 = (_Bool)0;
            if(tmp_if_expr_2)
              tmp_if_expr_3 = (signed int)*val != 13 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_3 = (_Bool)0;
            if(tmp_if_expr_3)
              tmp_if_expr_4 = (signed int)*val != 10 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_4 = (_Bool)0;
            if(!tmp_if_expr_4)
              break;

            buf[(signed long int)i] = *val;
            i = i + 1;
            val = val + 1l;
          }
          while((_Bool)1);
          buf[(signed long int)8191] = (char)0;
          return buf;
        }
      }
  }
}

// get_http_client_ip
// file acl.c line 68
void * get_http_client_ip(struct ci_request *req, char *param)
{
  const struct ci_ip *return_value_ci_http_client_ip_1;
  return_value_ci_http_client_ip_1=ci_http_client_ip(req);
  return (void *)return_value_ci_http_client_ip_1;
}

// get_http_req_header
// file acl.c line 932
void * get_http_req_header(struct ci_request *req, char *param)
{
  struct ci_headers_list *heads;
  heads=ci_http_request_headers(req);
  const char *return_value_get_header_1;
  return_value_get_header_1=get_header(heads, param);
  return (void *)return_value_get_header_1;
}

// get_http_resp_header
// file acl.c line 945
void * get_http_resp_header(struct ci_request *req, char *param)
{
  struct ci_headers_list *heads;
  heads=ci_http_response_headers(req);
  const char *return_value_get_header_1;
  return_value_get_header_1=get_header(heads, param);
  return (void *)return_value_get_header_1;
}

// get_icap_header
// file acl.c line 904
void * get_icap_header(struct ci_request *req, char *param)
{
  struct ci_headers_list *heads = req->request_header;
  const char *return_value_get_header_1;
  return_value_get_header_1=get_header(heads, param);
  return (void *)return_value_get_header_1;
}

// get_icap_response_header
// file acl.c line 918
void * get_icap_response_header(struct ci_request *req, char *param)
{
  struct ci_headers_list *heads = req->response_header;
  const char *return_value_get_header_1;
  return_value_get_header_1=get_header(heads, param);
  return (void *)return_value_get_header_1;
}

// get_port
// file acl.c line 56
void * get_port(struct ci_request *req, char *param)
{
  return (void *)&req->connection->srvaddr.ci_sin_port;
}

// get_reqtype
// file acl.c line 52
void * get_reqtype(struct ci_request *req, char *param)
{
  _Bool tmp_if_expr_1;
  if(!(req->type >= 5))
    tmp_if_expr_1 = req->type >= 0x01 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  const char *tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = ci_methods[(signed long int)req->type];

  else
    tmp_if_expr_2 = "UNKNOWN";
  return (void *)tmp_if_expr_2;
}

// get_request_options
// file request_common.c line 757
static signed int get_request_options(struct ci_request *req, struct ci_headers_list *h)
{
  const char *pstr;
  pstr=ci_headers_value(h, "Preview");
  if(!(pstr == ((const char *)NULL)))
  {
    signed long int return_value_strtol_1;
    return_value_strtol_1=strtol(pstr, (char ** restrict )(void *)0, 10);
    req->preview = (signed int)return_value_strtol_1;
  }

  else
    req->preview = -1;
  req->allow204 = 0;
  pstr=ci_headers_value(h, "Allow");
  if(!(pstr == ((const char *)NULL)))
  {
    signed long int return_value_strtol_2;
    return_value_strtol_2=strtol(pstr, (char ** restrict )(void *)0, 10);
    if(return_value_strtol_2 == 204l)
      req->allow204 = 1;

  }

  pstr=ci_headers_value(h, "Connection");
  signed int return_value_strncmp_3;
  if(!(pstr == ((const char *)NULL)))
  {
    return_value_strncmp_3=strncmp(pstr, "close", (unsigned long int)5);
    if(return_value_strncmp_3 == 0)
      req->keepalive = 0;

  }

  pstr=ci_headers_value(h, "Transfer-Preview");
  pstr=ci_headers_value(h, "Transfer-Ignore");
  pstr=ci_headers_value(h, "Transfer-Complete");
  return 1;
}

// get_service
// file acl.c line 48
void * get_service(struct ci_request *req, char *param)
{
  return (void *)req->service;
}

// get_srv_ip
// file acl.c line 64
void * get_srv_ip(struct ci_request *req, char *param)
{
  return (void *)&req->connection->srvaddr;
}

// get_time_data
// file acl.c line 401
void * get_time_data(struct ci_request *req, char *param)
{
  struct acl_time_data *tmd_req;
  void *return_value_ci_buffer_alloc_1;
  return_value_ci_buffer_alloc_1=ci_buffer_alloc((signed int)sizeof(struct acl_time_data) /*12ul*/ );
  tmd_req = (struct acl_time_data *)return_value_ci_buffer_alloc_1;
  struct tm br_tm;
  signed long int tm;
  time(&tm);
  localtime_r(&tm, &br_tm);
  tmd_req->days = (unsigned int)0;
  tmd_req->days = tmd_req->days | (unsigned int)(1 << br_tm.tm_wday);
  tmd_req->start_time = (unsigned int)(br_tm.tm_hour * 60 + br_tm.tm_min);
  tmd_req->end_time = (unsigned int)0;
  return (void *)tmd_req;
}

// get_user
// file acl.c line 44
void * get_user(struct ci_request *req, char *param)
{
  return (void *)req->user;
}

// groups_add
// file filetype.c line 104
signed int groups_add(struct ci_magics_db *db, const char *name, const char *descr)
{
  struct ci_data_group *newdata;
  signed int indx;
  if(db->groups_num >= db->groups_size)
  {
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)db->groups, (unsigned long int)(db->groups_size + 15) * sizeof(struct ci_data_group) /*67ul*/ );
    newdata = (struct ci_data_group *)return_value_realloc_1;
    if(newdata == ((struct ci_data_group *)NULL))
      return -1;

    db->groups_size = db->groups_size + 15;
    db->groups = newdata;
  }

  indx = db->groups_num;
  db->groups_num = db->groups_num + 1;
  strcpy((db->groups + (signed long int)indx)->name, name);
  strcpy((db->groups + (signed long int)indx)->descr, descr);
  return indx;
}

// groups_init
// file filetype.c line 82
signed int groups_init(struct ci_magics_db *db)
{
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)15 * sizeof(struct ci_data_group) /*67ul*/ );
  db->groups = (struct ci_data_group *)return_value_malloc_1;
  if(db->groups == ((struct ci_data_group *)NULL))
    return 0;

  else
  {
    db->groups_num = 0;
    db->groups_size = 15;
    return 1;
  }
}

// hash_table_close
// file lookup_file_table.c line 365
void hash_table_close(struct ci_lookup_table *table)
{
  struct text_table *text_table = (struct text_table *)table->data;
  if(!(text_table == ((struct text_table *)NULL)))
  {
    if(!(text_table->hash_table == ((struct ci_hash_table *)NULL)))
    {
      ci_hash_destroy(text_table->hash_table);
      text_table->hash_table = (struct ci_hash_table *)(void *)0;
    }

  }

  file_table_close(table);
}

// hash_table_open
// file lookup_file_table.c line 339
void * hash_table_open(struct ci_lookup_table *table)
{
  struct text_table_entry *e;
  struct text_table *text_table;
  void *return_value_file_table_open_1;
  return_value_file_table_open_1=file_table_open(table);
  text_table = (struct text_table *)return_value_file_table_open_1;
  if(text_table == ((struct text_table *)NULL))
    return (void *)0;

  else
  {
    if(CI_DEBUG_LEVEL >= 7)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Will build a hash for %d rows of data\n", text_table->rows);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Will build a hash for %d rows of data\n", text_table->rows);

    }

    text_table->hash_table=ci_hash_build((unsigned int)text_table->rows, table->key_ops, table->allocator);
    if(text_table->hash_table == ((struct ci_hash_table *)NULL))
    {
      file_table_close(table);
      return (void *)0;
    }

    else
    {
      e = text_table->entries;
      for( ; !(e == ((struct text_table_entry *)NULL)); e = e->next)
        ci_hash_add(text_table->hash_table, e->key, (const void *)e);
      return (void *)text_table;
    }
  }
}

// hash_table_release_result
// file lookup_file_table.c line 396
void hash_table_release_result(struct ci_lookup_table *table_data, void **val)
{
  ;
}

// hash_table_search
// file lookup_file_table.c line 377
void * hash_table_search(struct ci_lookup_table *table, void *key, void ***vals)
{
  struct text_table_entry *e;
  struct text_table *text_table = (struct text_table *)table->data;
  if(text_table == ((struct text_table *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Search a non open hash lookup table?(%s)\n", table->path);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Search a non open hash lookup table?(%s)\n", table->path);

    }

    return (void *)0;
  }

  else
  {
    *vals = (void **)(void *)0;
    const void *return_value_ci_hash_search_1;
    return_value_ci_hash_search_1=ci_hash_search(text_table->hash_table, key);
    e = (struct text_table_entry *)return_value_ci_hash_search_1;
    if(e == ((struct text_table_entry *)NULL))
      return (void *)0;

    else
    {
      *vals = (void **)e->vals;
      return (void *)e->key;
    }
  }
}

// icap_init_server
// file os/unix/net_io.c line 87
signed int icap_init_server(char *address, signed int port, signed int *protocol_family, signed int secs_to_linger)
{
  signed int fd;
  struct sockaddr_in addr;
  fd=socket(2, 1, 0);
  signed int return_value_inet_pton_1;
  if(fd == -1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error opening socket ....\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error opening socket ....\n");

    }

    return -1;
  }

  else
  {
    icap_socket_opts(fd, secs_to_linger);
    memset((void *)&addr, 0, sizeof(struct sockaddr_in) /*16ul*/ );
    addr.sin_family = (unsigned short int)2;
    addr.sin_port=htons((unsigned short int)port);
    if(address == ((char *)NULL))
      addr.sin_addr.s_addr = (unsigned int)0x00000000;

    else
    {
      return_value_inet_pton_1=inet_pton(2, address, (void *)&addr.sin_addr.s_addr);
      if(!(return_value_inet_pton_1 == 1))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Error converting ipv4 address to the network byte order \n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Error converting ipv4 address to the network byte order \n");

        }

        close(fd);
        return -1;
      }

    }
    signed int return_value_bind_2;
    return_value_bind_2=bind(fd, (struct sockaddr *)&addr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    if(!(return_value_bind_2 == 0))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error binding  \n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error binding  \n");

      }

      return -1;
    }

    else
    {
      signed int return_value_listen_3;
      return_value_listen_3=listen(fd, 512);
      if(!(return_value_listen_3 == 0))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Error listening .....\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Error listening .....\n");

        }

        return -1;
      }

      else
      {
        *protocol_family = 2;
        return fd;
      }
    }
  }
}

// icap_socket_opts
// file os/unix/net_io.c line 135
signed int icap_socket_opts(signed int fd, signed int secs_to_linger)
{
  struct linger li;
  signed int value = 1;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(fd, 1, 2, (const void *)&value, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(return_value_setsockopt_1 == -1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "setsockopt: unable to set SO_REUSEADDR\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("setsockopt: unable to set SO_REUSEADDR\n");

    }

  }

  value = 1;
  signed int return_value_setsockopt_2;
  return_value_setsockopt_2=setsockopt(fd, 6, 1, (const void *)&value, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(return_value_setsockopt_2 == -1)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "setsockopt: unable to set TCP_NODELAY\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("setsockopt: unable to set TCP_NODELAY\n");

    }

  }

  li.l_onoff = 1;
  li.l_linger = secs_to_linger;
  signed int return_value_setsockopt_3;
  return_value_setsockopt_3=setsockopt(fd, 1, 13, (const void *)(char *)&li, (unsigned int)sizeof(struct linger) /*8ul*/ );
  if(!(return_value_setsockopt_3 >= 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "setsockopt: unable to set SO_LINGER \n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("setsockopt: unable to set SO_LINGER \n");

    }

  }

  return 1;
}

// init_body_system
// file body.c line 49
signed int init_body_system()
{
  MEMBUF_POOL=ci_object_pool_register("ci_membuf_t", (signed int)sizeof(struct ci_membuf) /*40ul*/ );
  if(!(MEMBUF_POOL >= 0))
    return -1;

  else
  {
    CACHED_FILE_POOL=ci_object_pool_register("ci_cached_file_t", (signed int)sizeof(struct ci_cached_file) /*4152ul*/ );
    if(!(CACHED_FILE_POOL >= 0))
      return -1;

    else
    {
      SIMPLE_FILE_POOL=ci_object_pool_register("ci_simple_file_t", (signed int)sizeof(struct ci_simple_file) /*4184ul*/ );
      if(!(SIMPLE_FILE_POOL >= 0))
        return -1;

      else
      {
        RING_BUF_POOL=ci_object_pool_register("ci_ring_buf_t", (signed int)sizeof(struct ci_ring_buf) /*40ul*/ );
        if(!(RING_BUF_POOL >= 0))
          return -1;

        else
          return 1;
      }
    }
  }
}

// init_child_mutexes
// file os/unix/threads.c line 46
static void init_child_mutexes()
{
  struct mutex_itm *m;
  pthread_mutex_init(&mutexes_lock, (const union anonymous_32 *)(void *)0);
  m = mutexes;
  for( ; !(m == ((struct mutex_itm *)NULL)); m = m->next)
    switch(m->type)
    {
      case 0:
      {
        pthread_mutex_init(m->mtx.mutex, (const union anonymous_32 *)(void *)0);
        break;
      }
      case 1:
        pthread_rwlock_init(m->mtx.rwlock, (const union anonymous_35 *)(void *)0);
    }
}

// init_internal_lookup_tables
// file lookup_table.c line 241
void init_internal_lookup_tables()
{
  ci_lookup_table_type_register(&file_table_type);
  ci_lookup_table_type_register(&hash_table_type);
  ci_lookup_table_type_register(&regex_table_type);
}

// init_pack_allocator
// file mem.c line 661
struct ci_mem_allocator * init_pack_allocator(struct ci_mem_allocator *allocator, struct pack_allocator *pack_alloc, char *memblock, unsigned long int size, signed int free)
{
  unsigned long int tmp_if_expr_1;
  if(!(size == (7 + size & 18446744073709551608)))
    tmp_if_expr_1 = (size - (unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d) + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1);

  else
    tmp_if_expr_1 = size;
  size = tmp_if_expr_1;
  pack_alloc->memchunk = (void *)memblock;
  pack_alloc->curpos = pack_alloc->memchunk;
  pack_alloc->end = pack_alloc->memchunk + (signed long int)size;
  pack_alloc->endpos = pack_alloc->end;
  pack_alloc->must_free = free;
  allocator->alloc = ci_pack_allocator_alloc;
  allocator->free = ci_pack_allocator_free;
  allocator->reset = ci_pack_allocator_reset;
  allocator->destroy = ci_pack_allocator_destroy;
  allocator->data = (void *)pack_alloc;
  allocator->name = (char *)(void *)0;
  allocator->type = 3;
  allocator->must_free = free;
  return allocator;
}

// int32_cmp
// file types_ops.c line 125
signed int int32_cmp(const void *key1, const void *key2)
{
  signed int k1;
  signed int k2;
  k1 = *((signed int *)key1);
  k2 = *((signed int *)key2);
  if(!(k1 >= k2))
    return -1;

  else
    if(!(k2 >= k1))
      return 1;

    else
      return 0;
}

// int32_dup
// file types_ops.c line 107
void * int32_dup(const char *str, struct ci_mem_allocator *allocator)
{
  signed int *i;
  char *e = (char *)(void *)0;
  void *return_value;
  return_value=allocator->alloc(allocator, sizeof(signed int) /*4ul*/ );
  i = (signed int *)return_value;
  if(!(i == ((signed int *)NULL)))
  {
    signed long int return_value_strtol_1;
    return_value_strtol_1=strtol(str, &e, 10);
    *i = (signed int)return_value_strtol_1;
    _Bool tmp_if_expr_4;
    if((signed int)*e == 75)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (signed int)*e == 107 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      *i = *i * 1000;

    else
    {
      _Bool tmp_if_expr_3;
      if((signed int)*e == 77)
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = (signed int)*e == 109 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3)
        *i = *i * 1000000;

      else
      {
        _Bool tmp_if_expr_2;
        if((signed int)*e == 71)
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = (signed int)*e == 103 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
          *i = *i * 1000000000;

      }
    }
  }

  return (void *)i;
}

// int32_equal
// file types_ops.c line 138
signed int int32_equal(const void *key1, const void *key2)
{
  signed int k1;
  signed int k2;
  k1 = *((signed int *)key1);
  k2 = *((signed int *)key2);
  return (signed int)(k1 == k2);
}

// int32_free
// file types_ops.c line 151
void int32_free(void *key, struct ci_mem_allocator *allocator)
{
  allocator->free(allocator, key);
}

// int32_len
// file types_ops.c line 146
unsigned long int int32_len(const void *key)
{
  return (unsigned long int)4;
}

// ip_cmp
// file types_ops.c line 520
signed int ip_cmp(const void *ref_key, const void *key_check)
{
  return 0;
}

// ip_dup
// file types_ops.c line 448
void * ip_dup(const char *value, struct ci_mem_allocator *allocator)
{
  signed int socket_family;
  signed int len;
  struct ci_ip *ip;
  char str_addr[17l];
  char str_netmask[17l];
  char *pstr;
  struct in_addr address;
  struct in_addr netmask;
  address.s_addr = (unsigned int)0;
  netmask.s_addr = (unsigned int)0;
  socket_family = 2;
  pstr=strchr(value, 47);
  if(!(pstr == ((char *)NULL)))
  {
    len = (signed int)(pstr - value);
    if(len >= 16)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Invalid ip address (len>%d): %s\n", 16, value);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Invalid ip address (len>%d): %s\n", 16, value);

      }

      return (void *)0;
    }

    strncpy(str_addr, value, (unsigned long int)len);
    str_addr[(signed long int)len] = (char)0;
    signed int return_value_ci_inet_aton_1;
    return_value_ci_inet_aton_1=ci_inet_aton(socket_family, str_addr, (void *)&address);
    if(return_value_ci_inet_aton_1 == 0)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Invalid ip address in network %s definition\n", value);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Invalid ip address in network %s definition\n", value);

      }

      return (void *)0;
    }

    strncpy(str_netmask, pstr + (signed long int)1, (unsigned long int)16);
    str_netmask[(signed long int)16] = (char)0;
    signed int return_value_ci_inet_aton_2;
    return_value_ci_inet_aton_2=ci_inet_aton(socket_family, str_netmask, (void *)&netmask);
    if(return_value_ci_inet_aton_2 == 0)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Invalid netmask in network %s definition\n", value);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Invalid netmask in network %s definition\n", value);

      }

      return (void *)0;
    }

  }

  else
  {
    signed int return_value_ci_inet_aton_3;
    return_value_ci_inet_aton_3=ci_inet_aton(socket_family, value, (void *)&address);
    if(return_value_ci_inet_aton_3 == 0)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Invalid ip address: %s\n", value);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Invalid ip address: %s\n", value);

      }

      return (void *)0;
    }

    netmask.s_addr=htonl(0xFFFFFFFF);
  }
  void *return_value;
  return_value=allocator->alloc(allocator, sizeof(struct ci_ip) /*12ul*/ );
  ip = (struct ci_ip *)return_value;
  ip->family = socket_family;
  ip->address = address;
  ip->netmask = netmask;
  return (void *)ip;
}

// ip_equal
// file types_ops.c line 525
signed int ip_equal(const void *ref_key, const void *key_check)
{
  const struct ci_ip *ip_ref = (const struct ci_ip *)ref_key;
  const struct ci_ip *ip_check = (const struct ci_ip *)key_check;
  char buf[128l];
  char buf1[128l];
  char buf2[128l];
  const char *return_value_ci_inet_ntoa_1;
  const char *return_value_ci_inet_ntoa_2;
  const char *return_value_ci_inet_ntoa_3;
  const char *return_value_ci_inet_ntoa_4;
  const char *return_value_ci_inet_ntoa_5;
  const char *return_value_ci_inet_ntoa_6;
  if(ip_check == ((const struct ci_ip *)NULL))
    return 0;

  else
  {
    if(CI_DEBUG_LEVEL >= 9)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      {
        return_value_ci_inet_ntoa_1=ci_inet_ntoa(ip_check->family, (const void *)&ip_check->address, buf, 128);
        return_value_ci_inet_ntoa_2=ci_inet_ntoa(ip_ref->family, (const void *)&ip_ref->address, buf1, 128);
        return_value_ci_inet_ntoa_3=ci_inet_ntoa(ip_ref->family, (const void *)&ip_ref->netmask, buf2, 128);
        __log_error((void *)0, "going to check addresses  ip address: %s %s/%s\n", return_value_ci_inet_ntoa_1, return_value_ci_inet_ntoa_2, return_value_ci_inet_ntoa_3);
      }

      if(!(CI_DEBUG_STDOUT == 0))
      {
        return_value_ci_inet_ntoa_4=ci_inet_ntoa(ip_check->family, (const void *)&ip_check->address, buf, 128);
        return_value_ci_inet_ntoa_5=ci_inet_ntoa(ip_ref->family, (const void *)&ip_ref->address, buf1, 128);
        return_value_ci_inet_ntoa_6=ci_inet_ntoa(ip_ref->family, (const void *)&ip_ref->netmask, buf2, 128);
        printf("going to check addresses  ip address: %s %s/%s\n", return_value_ci_inet_ntoa_4, return_value_ci_inet_ntoa_5, return_value_ci_inet_ntoa_6);
      }

    }

    return (signed int)((ip_ref->address.s_addr & ip_ref->netmask.s_addr) == (ip_check->address.s_addr & ip_ref->netmask.s_addr));
  }
}

// ip_free
// file types_ops.c line 511
void ip_free(void *data, struct ci_mem_allocator *allocator)
{
  allocator->free(allocator, data);
}

// ip_len
// file types_ops.c line 515
unsigned long int ip_len(const void *key)
{
  return sizeof(struct ci_ip) /*12ul*/ ;
}

// ip_sockaddr_cmp
// file types_ops.c line 556
signed int ip_sockaddr_cmp(const void *ref_key, const void *key_check)
{
  return 1;
}

// ip_sockaddr_equal
// file types_ops.c line 561
signed int ip_sockaddr_equal(const void *ref_key, const void *key_check)
{
  const struct ci_ip *ip_ref = (const struct ci_ip *)ref_key;
  const struct ci_sockaddr *ip_check = (const struct ci_sockaddr *)key_check;
  char buf[128l];
  char buf1[128l];
  char buf2[128l];
  const char *return_value_ci_inet_ntoa_1;
  const char *return_value_ci_inet_ntoa_2;
  const char *return_value_ci_inet_ntoa_3;
  const char *return_value_ci_inet_ntoa_4;
  const char *return_value_ci_inet_ntoa_5;
  const char *return_value_ci_inet_ntoa_6;
  if(ip_check == ((const struct ci_sockaddr *)NULL))
    return 0;

  else
  {
    if(CI_DEBUG_LEVEL >= 9)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      {
        return_value_ci_inet_ntoa_1=ci_inet_ntoa(ip_check->ci_sin_family, ip_check->ci_sin_addr, buf, 128);
        return_value_ci_inet_ntoa_2=ci_inet_ntoa(ip_ref->family, (const void *)&ip_ref->address, buf1, 128);
        return_value_ci_inet_ntoa_3=ci_inet_ntoa(ip_ref->family, (const void *)&ip_ref->netmask, buf2, 128);
        __log_error((void *)0, "going to check addresses  ip address: %s %s/%s\n", return_value_ci_inet_ntoa_1, return_value_ci_inet_ntoa_2, return_value_ci_inet_ntoa_3);
      }

      if(!(CI_DEBUG_STDOUT == 0))
      {
        return_value_ci_inet_ntoa_4=ci_inet_ntoa(ip_check->ci_sin_family, ip_check->ci_sin_addr, buf, 128);
        return_value_ci_inet_ntoa_5=ci_inet_ntoa(ip_ref->family, (const void *)&ip_ref->address, buf1, 128);
        return_value_ci_inet_ntoa_6=ci_inet_ntoa(ip_ref->family, (const void *)&ip_ref->netmask, buf2, 128);
        printf("going to check addresses  ip address: %s %s/%s\n", return_value_ci_inet_ntoa_4, return_value_ci_inet_ntoa_5, return_value_ci_inet_ntoa_6);
      }

    }

    return (signed int)((ip_ref->address.s_addr & ip_ref->netmask.s_addr) == (((struct in_addr *)ip_check->ci_sin_addr)->s_addr & ip_ref->netmask.s_addr));
  }
}

// isUTF8
// file filetype.c line 439
signed int isUTF8(unsigned char *c, signed int size)
{
  signed int i;
  signed int r_size = 0;
  unsigned int ucs_c = (unsigned int)0;
  if((signed int)text_chars[(signed long int)(signed int)*c] == 1)
    return 1;

  else
  {
    if((0xE0 & (signed int)*c) == 0xC0)
    {
      ucs_c = (unsigned int)((signed int)*c & 0x1F);
      r_size = 2;
    }

    else
      if((0xF0 & (signed int)*c) == 0xE0)
      {
        ucs_c = (unsigned int)((signed int)*c & 0x0F);
        r_size = 3;
      }

      else
        if((0xF8 & (signed int)*c) == 0xF0)
        {
          ucs_c = (unsigned int)((signed int)*c & 0x07);
          r_size = 4;
        }

        else
          if((0xFC & (signed int)*c) == 0xF8)
          {
            ucs_c = (unsigned int)((signed int)*c & 0x03);
            r_size = 5;
          }

          else
            if((0xFE & (signed int)*c) == 0xFC)
            {
              ucs_c = (unsigned int)((signed int)*c & 0x01);
              r_size = 6;
            }

    if(r_size == 0)
      return 0;

    else
    {
      i = 1;
      for( ; !(i >= r_size) && !(i >= size); i = i + 1)
      {
        if(!((0xC0 & (signed int)c[(signed long int)i]) == 0x80))
          return 0;

        ucs_c = ucs_c << 6 | (unsigned int)((signed int)c[(signed long int)i] & 0x3F);
      }
      if(!(i >= r_size))
        return -1;

      else
        if(utf_boundaries[(signed long int)r_size] >= ucs_c)
          return 0;

        else
          if(ucs_c == 65534u || ucs_c == 65535u || ucs_c >= 55296u && !(ucs_c >= 57344u))
            return 0;

          else
            return r_size;
    }
  }
}

// list_alloc_item
// file array.c line 562
static struct ci_list_item * list_alloc_item(struct ci_list *list, const void *data)
{
  struct ci_list_item *it;
  if(!(list->trash == ((struct ci_list_item *)NULL)))
  {
    it = list->trash;
    list->trash = list->trash->next;
  }

  else
  {
    void *return_value;
    return_value=list->alloc->alloc(list->alloc, sizeof(struct ci_list_item) /*16ul*/ );
    it = (struct ci_list_item *)return_value;
    if(it == ((struct ci_list_item *)NULL))
      return (struct ci_list_item *)(void *)0;

    if(!(list->obj_size == 0ul))
    {
      it->item=list->alloc->alloc(list->alloc, list->obj_size);
      if(it->item == NULL)
        return (struct ci_list_item *)(void *)0;

    }

  }
  it->next = (struct ci_list_item *)(void *)0;
  if(!(list->obj_size == 0ul))
  {
    memcpy(it->item, data, list->obj_size);
    if(!(list->copy_func == ((signed int (*)(void *, const void *))NULL)))
      list->copy_func(it->item, data);

  }

  else
    it->item = data;
  return it;
}

// load_text_table
// file lookup_file_table.c line 205
signed int load_text_table(char *filename, struct ci_lookup_table *table)
{
  struct _IO_FILE *f;
  struct text_table_entry *e;
  struct text_table_entry *l = (struct text_table_entry *)(void *)0;
  signed int rows;
  signed int ret;
  struct text_table *text_table = (struct text_table *)table->data;
  f=fopen64(filename, "r");
  if(f == ((struct _IO_FILE *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error opening file: %s\n", filename);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error opening file: %s\n", filename);

    }

    return 0;
  }

  else
  {
    rows = 0;
    if(!(text_table->entries == ((struct text_table_entry *)NULL)))
    {
      l = text_table->entries;
      for( ; !(l->next == ((struct text_table_entry *)NULL)); l = l->next)
        ;
    }

    do
    {
      ret=read_row(f, table->cols, &e, table);
      if(!(ret >= 1))
        break;

      if(!(e == ((struct text_table_entry *)NULL)))
      {
        e->next = (struct text_table_entry *)(void *)0;
        if(text_table->entries == ((struct text_table_entry *)NULL))
        {
          text_table->entries = e;
          l = e;
        }

        else
        {
          l->next = e;
          l = e;
        }
      }

      rows = rows + 1;
    }
    while((_Bool)1);
    fclose(f);
    if(ret == -1)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error loading file table %s: parse error on line %d\n", filename, rows + 1);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error loading file table %s: parse error on line %d\n", filename, rows + 1);

      }

      file_table_close(table);
      return 0;
    }

    else
    {
      text_table->rows = rows;
      return 1;
    }
  }
}

// log_errors
// file c-icap-mkbdb.c line 315
void log_errors(void *unused, const char *format, ...)
{
  void **ap = (void **)&format;
  vfprintf(stderr, format, ap);
  ap = ((void **)NULL);
}

// lookup_table_get_row
// file lookup_table.c line 205
static const void * lookup_table_get_row(struct ci_lookup_table *table, const void *key, const char **columns, void ***vals)
{
  signed int i;
  _Bool tmp_if_expr_2;
  if(table->_lt_type == ((struct ci_lookup_table_type *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "lookup_table of type  %s is corrupted!\n", table->type);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("lookup_table of type  %s is corrupted!\n", table->type);

    }

    return (void *)0;
  }

  else
  {
    _Bool tmp_if_expr_1;
    if(table->col_names == ((struct ci_vector *)NULL))
      tmp_if_expr_1 = (_Bool)1;

    else
      tmp_if_expr_1 = table->_lt_type->get_row != ((const void * (*)(struct ci_lookup_table *, const void *, const char **, void ***))NULL) ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_1)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "lookup_table :%s does not support lookup on named columns\n", table->type);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("lookup_table :%s does not support lookup on named columns\n", table->type);

      }

      return (void *)0;
    }

    else
    {
      i = 0;
      do
      {
        if(!(i >= 1024))
          tmp_if_expr_2 = columns[(signed long int)i] != (const char *)(void *)0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(!tmp_if_expr_2)
          break;

        const char *return_value_ci_str_vector_search_3;
        return_value_ci_str_vector_search_3=ci_str_vector_search(table->col_names, columns[(signed long int)i]);
        if(return_value_ci_str_vector_search_3 == ((const char *)NULL))
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "lookup_table :%s does not has column %s\n", table->type, columns[(signed long int)i]);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("lookup_table :%s does not has column %s\n", table->type, columns[(signed long int)i]);

          }

          return (void *)0;
        }

        i = i + 1;
      }
      while((_Bool)1);
      const void *return_value;
      return_value=table->_lt_type->get_row(table, key, columns, vals);
      return return_value;
    }
  }
}

// magics_add
// file filetype.c line 116
signed int magics_add(struct ci_magics_db *db, signed int offset, unsigned char *magic, unsigned long int len, signed int type)
{
  struct ci_magic *newdata;
  signed int indx;
  if(db->magics_num >= db->magics_size)
  {
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)db->magics, (unsigned long int)(db->magics_size + 50) * sizeof(struct ci_magic) /*72ul*/ );
    newdata = (struct ci_magic *)return_value_realloc_1;
    if(newdata == ((struct ci_magic *)NULL))
      return -1;

    db->magics_size = db->magics_size + 50;
    db->magics = newdata;
  }

  indx = db->magics_num;
  db->magics_num = db->magics_num + 1;
  (db->magics + (signed long int)indx)->type = (unsigned int)type;
  (db->magics + (signed long int)indx)->offset = offset;
  (db->magics + (signed long int)indx)->len = len;
  memcpy((void *)(db->magics + (signed long int)indx)->magic, (const void *)magic, len);
  return indx;
}

// magics_init
// file filetype.c line 83
signed int magics_init(struct ci_magics_db *db)
{
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)50 * sizeof(struct ci_magic) /*72ul*/ );
  db->magics = (struct ci_magic *)return_value_malloc_1;
  if(db->magics == ((struct ci_magic *)NULL))
    return 0;

  else
  {
    db->magics_num = 0;
    db->magics_size = 50;
    return 1;
  }
}

// main
// file c-icap-mkbdb.c line 331
signed int main(signed int argc, char **argv)
{
  struct _IO_FILE *f = (struct _IO_FILE *)(void *)0;
  char outfile[4096l];
  char line[65535l];
  signed int len;
  void *key;
  void *val;
  signed int keysize;
  signed int valsize;
  CI_DEBUG_LEVEL = 1;
  ci_cfg_lib_init();
  signed int return_value_ci_args_apply_1;
  return_value_ci_args_apply_1=ci_args_apply(argc, argv, options);
  if(return_value_ci_args_apply_1 == 0 || txtfile == ((char *)NULL) && DUMP_MODE == 0)
  {
    ci_args_usage(argv[(signed long int)0], options);
    exit(-1);
  }

  __log_error = (void (*)(void *, const char *, ...))log_errors;
  allocator=ci_create_os_allocator();
  char *return_value_fgets_4;
  if(allocator == ((struct ci_mem_allocator *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error allocating mem allocator!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error allocating mem allocator!\n");

    }

    return -1;
  }

  else
  {
    if(dbfile == ((char *)NULL) && !(DUMP_MODE == 0))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "\nError: You need to specify the database to dump ('-o file.db')\n\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("\nError: You need to specify the database to dump ('-o file.db')\n\n");

      }

      ci_args_usage(argv[(signed long int)0], options);
      exit(-1);
    }

    if(dbfile == ((char *)NULL))
    {
      strncpy(outfile, txtfile, (unsigned long int)4096);
      outfile[(signed long int)(4096 - 1)] = (char)0;
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(outfile);
      len = (signed int)return_value_strlen_2;
      if(len >= 4092)
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "The filename  %s is too long\n", (const void *)outfile);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("The filename  %s is too long\n", (const void *)outfile);

        }

        exit(0);
      }

      strcat(outfile, ".db");
    }

    else
    {
      strncpy(outfile, dbfile, (unsigned long int)4096);
      outfile[(signed long int)(4096 - 1)] = (char)0;
    }
    signed int return_value_open_db_3;
    return_value_open_db_3=open_db(outfile);
    if(return_value_open_db_3 == 0)
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error opening bdb file %s\n", (const void *)outfile);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error opening bdb file %s\n", (const void *)outfile);

      }

      if(!(f == ((struct _IO_FILE *)NULL)))
        fclose(f);

      return -1;
    }

    else
    {
      if(!(DUMP_MODE == 0))
        dump_db();

      else
      {
        f=fopen64(txtfile, "r+");
        if(f == ((struct _IO_FILE *)NULL))
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "Error opening file: %s\n", txtfile);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("Error opening file: %s\n", txtfile);

          }

          return -1;
        }

        do
        {
          return_value_fgets_4=fgets(line, 65535, f);
          if(return_value_fgets_4 == ((char *)NULL))
            break;

          line[(signed long int)(65535 - 1)] = (char)0;
          signed int return_value_record_extract_5;
          return_value_record_extract_5=record_extract(line, &key, &keysize, &val, &valsize);
          if(return_value_record_extract_5 == 0)
          {
            if(CI_DEBUG_LEVEL >= 1)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "Error parsing line : %s\n", (const void *)line);

              if(!(CI_DEBUG_STDOUT == 0))
                printf("Error parsing line : %s\n", (const void *)line);

            }

            break;
          }

          else
            if(!(key == NULL))
              store_db(key, keysize, val, valsize);

        }
        while((_Bool)1);
        fclose(f);
      }
      close_db();
      ci_mem_allocator_destroy(allocator);
      return 0;
    }
  }
}

// makeTemplatePathFileName
// file txtTemplate.c line 70
static void makeTemplatePathFileName(char *path, signed int path_len, const char *service_name, const char *page_name, const char *lang)
{
  snprintf(path, (unsigned long int)path_len, "%s/%s/%s/%s", TEMPLATE_DIR, service_name, lang, page_name);
  path[(signed long int)(path_len - 1)] = (char)0;
}

// mem_init
// file mem.c line 40
signed int mem_init()
{
  signed int ret = -1;
  ret=ci_buffers_init();
  default_allocator=ci_create_os_allocator();
  if(default_allocator == ((struct ci_mem_allocator *)NULL) && ret == -1)
    ret = 0;

  MEM_ALLOCATOR_POOL=ci_object_pool_register("ci_mem_allocator_t", (signed int)sizeof(struct ci_mem_allocator) /*56ul*/ );
  /* assertion MEM_ALLOCATOR_POOL >=0 */
  assert(MEM_ALLOCATOR_POOL >= 0);
  unsigned long int return_value_sizeof_pack_allocator_1;
  return_value_sizeof_pack_allocator_1=sizeof_pack_allocator();
  PACK_ALLOCATOR_POOL=ci_object_pool_register("pack_allocator_t", (signed int)return_value_sizeof_pack_allocator_1);
  /* assertion PACK_ALLOCATOR_POOL >=0 */
  assert(PACK_ALLOCATOR_POOL >= 0);
  return ret;
}

// mem_reset
// file mem.c line 58
void mem_reset()
{
  ;
}

// mk_encaps_entity
// file header.c line 547
struct ci_encaps_entity * mk_encaps_entity(signed int type, signed int val)
{
  struct ci_encaps_entity *h;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct ci_encaps_entity) /*16ul*/ );
  h = (struct ci_encaps_entity *)return_value_malloc_1;
  struct ci_headers_list *return_value_ci_headers_create_2;
  if(h == ((struct ci_encaps_entity *)NULL))
    return (struct ci_encaps_entity *)(void *)0;

  else
  {
    h->start = val;
    h->type = type;
    if(type == 0 || type == 1)
    {
      return_value_ci_headers_create_2=ci_headers_create();
      h->entity = (void *)return_value_ci_headers_create_2;
    }

    else
      h->entity = (void *)0;
    return h;
  }
}

// mmap_shared_mem_attach
// file os/unix/shared_mem.c line 118
void * mmap_shared_mem_attach(struct ci_shared_mem_id *id)
{
  return (void *)id->mem;
}

// mmap_shared_mem_create
// file os/unix/shared_mem.c line 103
void * mmap_shared_mem_create(struct ci_shared_mem_id *id, const char *name, signed int size)
{
  id->mem=mmap64(NULL, (unsigned long int)size, 0x1 | 0x2, 0x01 | 0x20, -1, (signed long int)0);
  if(id->mem == (void *)-1)
    return (void *)0;

  else
  {
    id->size = (unsigned long int)size;
    snprintf(id->name, (unsigned long int)64, "%s", name);
    return id->mem;
  }
}

// mmap_shared_mem_destroy
// file os/unix/shared_mem.c line 131
signed int mmap_shared_mem_destroy(struct ci_shared_mem_id *id)
{
  munmap(id->mem, id->size);
  return 1;
}

// mmap_shared_mem_detach
// file os/unix/shared_mem.c line 124
signed int mmap_shared_mem_detach(struct ci_shared_mem_id *id)
{
  return 1;
}

// mmap_shared_mem_print_info
// file os/unix/shared_mem.c line 137
signed int mmap_shared_mem_print_info(struct ci_shared_mem_id *id, char *buf, unsigned long int buf_size)
{
  signed int return_value_snprintf_1;
  return_value_snprintf_1=snprintf(buf, buf_size, "mmap:%s/%p %ld kbs", (const void *)id->name, id->mem, (signed long int)(id->size / (unsigned long int)1024));
  return return_value_snprintf_1;
}

// net_data_read
// file request_common.c line 627
signed int net_data_read(struct ci_request *req)
{
  signed int bytes;
  if(!(req->pstrblock_read == req->rbuf))
  {
    if(!(req->pstrblock_read_len == 0))
      memmove((void *)req->rbuf, (const void *)req->pstrblock_read, (unsigned long int)req->pstrblock_read_len);

    req->pstrblock_read = req->rbuf;
  }

  bytes = 4096 - req->pstrblock_read_len;
  signed int *return_value___errno_location_1;
  signed int *return_value___errno_location_2;
  if(!(bytes >= 1))
  {
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Not enough space to read data! Is this a bug (%d %d)?????\n", req->pstrblock_read_len, 4096);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Not enough space to read data! Is this a bug (%d %d)?????\n", req->pstrblock_read_len, 4096);

    }

    return -1;
  }

  else
  {
    bytes=ci_read_nonblock(req->connection->fd, (void *)(req->rbuf + (signed long int)req->pstrblock_read_len), (unsigned long int)bytes);
    if(!(bytes >= 1))
    {
      if(CI_DEBUG_LEVEL >= 5)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        {
          return_value___errno_location_1=__errno_location();
          __log_error((void *)0, "Error reading data (read return=%d, errno=%d) \n", bytes, *return_value___errno_location_1);
        }

        if(!(CI_DEBUG_STDOUT == 0))
        {
          return_value___errno_location_2=__errno_location();
          printf("Error reading data (read return=%d, errno=%d) \n", bytes, *return_value___errno_location_2);
        }

      }

      return -1;
    }

    else
    {
      req->pstrblock_read_len = req->pstrblock_read_len + bytes;
      req->bytes_in = req->bytes_in + (unsigned long int)bytes;
      return 1;
    }
  }
}

// open_db
// file c-icap-mkbdb.c line 47
signed int open_db(char *path)
{
  char *s;
  char home[4096l];
  signed int ret;
  strncpy(home, path, (unsigned long int)4096);
  home[(signed long int)(4096 - 1)] = (char)0;
  s=strrchr(home, 47);
  if(!(s == ((char *)NULL)))
    *s = (char)0;

  else
    home[(signed long int)0] = (char)0;
  ret=db_env_create(&env_db, (unsigned int)0);
  char *return_value_db_strerror_1;
  char *return_value_db_strerror_2;
  char *return_value_db_strerror_3;
  char *return_value_db_strerror_4;
  char *return_value_db_strerror_5;
  char *return_value_db_strerror_6;
  if(!(ret == 0))
    return 0;

  else
  {
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "bdb_table_open: Environment created OK.\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("bdb_table_open: Environment created OK.\n");

    }

    env_db->set_data_dir(env_db, home);
    if(CI_DEBUG_LEVEL >= 5)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "bdb_table_open: Data dir set to %s.\n", (const void *)home);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("bdb_table_open: Data dir set to %s.\n", (const void *)home);

    }

    ret=env_db->open(env_db, home, (unsigned int)(0x00000001 | 0x00000100 | 0x00000400), 0);
    if(!(ret == 0))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        {
          return_value_db_strerror_1=db_strerror(ret);
          __log_error((void *)0, "bdb_table_open: Environment open failed: %s\n", return_value_db_strerror_1);
        }

        if(!(CI_DEBUG_STDOUT == 0))
        {
          return_value_db_strerror_2=db_strerror(ret);
          printf("bdb_table_open: Environment open failed: %s\n", return_value_db_strerror_2);
        }

      }

      env_db->close(env_db, (unsigned int)0);
      return 0;
    }

    else
    {
      if(CI_DEBUG_LEVEL >= 5)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "bdb_table_open: DB environment setup OK.\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("bdb_table_open: DB environment setup OK.\n");

      }

      ret=db_create(&db, env_db, (unsigned int)0);
      if(!(ret == 0))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          {
            return_value_db_strerror_3=db_strerror(ret);
            __log_error((void *)0, "db_create: %s\n", return_value_db_strerror_3);
          }

          if(!(CI_DEBUG_STDOUT == 0))
          {
            return_value_db_strerror_4=db_strerror(ret);
            printf("db_create: %s\n", return_value_db_strerror_4);
          }

        }

        return 0;
      }

      else
      {
        ret=db->open(db, (struct __db_txn *)(void *)0, path, (const char *)(void *)0, (enum anonymous_17)DB_BTREE, (unsigned int)0x00000001, 0664);
        if(!(ret == 0))
        {
          if(CI_DEBUG_LEVEL >= 1)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            {
              return_value_db_strerror_5=db_strerror(ret);
              __log_error((void *)0, "open db %s: %s\n", path, return_value_db_strerror_5);
            }

            if(!(CI_DEBUG_STDOUT == 0))
            {
              return_value_db_strerror_6=db_strerror(ret);
              printf("open db %s: %s\n", path, return_value_db_strerror_6);
            }

          }

          db->close(db, (unsigned int)0);
          return 0;
        }

        else
        {
          if(CI_DEBUG_LEVEL >= 5)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
              __log_error((void *)0, "bdb_table_open: file %s created OK.\n", path);

            if(!(CI_DEBUG_STDOUT == 0))
              printf("bdb_table_open: file %s created OK.\n", path);

          }

          return 1;
        }
      }
    }
  }
}

// os_allocator_alloc
// file mem.c line 404
static void * os_allocator_alloc(struct ci_mem_allocator *allocator, unsigned long int size)
{
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(size);
  return return_value_malloc_1;
}

// os_allocator_destroy
// file mem.c line 419
static void os_allocator_destroy(struct ci_mem_allocator *allocator)
{
  ;
}

// os_allocator_free
// file mem.c line 409
static void os_allocator_free(struct ci_mem_allocator *allocator, void *p)
{
  free(p);
}

// os_allocator_reset
// file mem.c line 414
static void os_allocator_reset(struct ci_mem_allocator *allocator)
{
  ;
}

// parse_chunk_data
// file request_common.c line 492
signed int parse_chunk_data(struct ci_request *req, char **wdata)
{
  char *end;
  const char *eofChunk;
  signed int chunkLen;
  signed int remains;
  signed int tmp;
  signed int read_status = 0;
  *wdata = (char *)(void *)0;
  signed int return_value_strncmp_4;
  signed int return_value_strncmp_3;
  if(!(req->write_to_module_pending == 0u))
    return -1;

  else
  {
    while((_Bool)1)
    {
      if(req->current_chunk_len == req->chunk_bytes_read)
        read_status = 1;

      else
        read_status = 2;
      if(read_status == 1)
      {
        eofChunk=ci_strnstr(req->pstrblock_read, "\r\n", (unsigned long int)req->pstrblock_read_len);
        if(eofChunk == ((const char *)NULL))
        {
          if(req->pstrblock_read_len >= 4096)
            return -1;

          return 2;
        }

        eofChunk = eofChunk + (signed long int)2;
        chunkLen = (signed int)(eofChunk - req->pstrblock_read);
        req->request_bytes_in = req->request_bytes_in + (unsigned long int)(eofChunk - req->pstrblock_read);
        signed int *return_value___errno_location_1;
        return_value___errno_location_1=__errno_location();
        *return_value___errno_location_1 = 0;
        signed long int return_value_strtol_2;
        return_value_strtol_2=strtol(req->pstrblock_read, &end, 16);
        tmp = (signed int)return_value_strtol_2;
        if(tmp == 0)
        {
          if(req->pstrblock_read == end)
          {
            if(CI_DEBUG_LEVEL >= 5)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "Parse error:count=%d,start=%c\n", tmp, req->pstrblock_read[(signed long int)0]);

              if(!(CI_DEBUG_STDOUT == 0))
                printf("Parse error:count=%d,start=%c\n", tmp, req->pstrblock_read[(signed long int)0]);

            }

            return -1;
          }

        }

        req->current_chunk_len = (unsigned int)tmp;
        req->chunk_bytes_read = (unsigned int)0;
        for( ; (_Bool)1; end = end + 1l)
          if(!((signed int)*end == 32))
          {
            if(!((signed int)*end == 9))
              goto __CPROVER_DUMP_L11;

          }


      __CPROVER_DUMP_L11:
        ;
        if(req->current_chunk_len == 0u)
        {
          remains = req->pstrblock_read_len - chunkLen;
          if(!(remains >= 2))
            return 2;

          if(!((signed int)*eofChunk == 13))
          {
            if(!((signed int)eofChunk[1l] == 10))
              return -1;

          }

          eofChunk = eofChunk + (signed long int)2;
          chunkLen = chunkLen + 2;
          req->request_bytes_in = req->request_bytes_in + (unsigned long int)2;
          if((signed int)*end == 59)
          {
            end = end + 1l;
            for( ; (_Bool)1; end = end + 1l)
              if(!((signed int)*end == 32))
              {
                if(!((signed int)*end == 9))
                  goto __CPROVER_DUMP_L16;

              }


          __CPROVER_DUMP_L16:
            ;
            remains = (signed int)((signed long int)req->pstrblock_read_len - (end - req->pstrblock_read));
            _Bool tmp_if_expr_5;
            if(remains >= 18)
            {
              return_value_strncmp_4=strncmp(end, "use-original-body=", (unsigned long int)18);
              tmp_if_expr_5 = return_value_strncmp_4 == 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_5 = (_Bool)0;
            if(tmp_if_expr_5)
              req->i206_use_original_body=strtol(end + (signed long int)18, &end, 10);

            else
              if(remains >= 4)
              {
                return_value_strncmp_3=strncmp(end, "ieof", (unsigned long int)4);
                if(!(return_value_strncmp_3 == 0))
                  return -1;

              }

            for( ; !((signed int)*end == 13); end = end + 1l)
              ;
            req->eof_received = 1;
          }

        }

        else
        {
          read_status = 2;
          req->current_chunk_len = req->current_chunk_len + (unsigned int)2;
        }
        _Bool tmp_if_expr_6;
        if(!((signed int)*end == 13))
          tmp_if_expr_6 = (_Bool)1;

        else
          tmp_if_expr_6 = (signed int)end[(signed long int)1] != 10 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_6)
          return -1;

        req->pstrblock_read_len = req->pstrblock_read_len - chunkLen;
        req->pstrblock_read = req->pstrblock_read + (signed long int)chunkLen;
      }

      if(req->current_chunk_len == 0u)
        return -2;

      if(!(req->write_to_module_pending == 0u))
        return 1;

      if(read_status == 2)
      {
        if(!(req->pstrblock_read_len >= 1))
          return 2;

        *wdata = req->pstrblock_read;
        remains = (signed int)(req->current_chunk_len - req->chunk_bytes_read);
        if(req->pstrblock_read_len >= remains)
        {
          if(remains >= 3)
          {
            req->write_to_module_pending = (unsigned int)(remains - 2);
            req->http_bytes_in = req->http_bytes_in + (unsigned long int)req->write_to_module_pending;
            req->body_bytes_in = req->body_bytes_in + (unsigned long int)req->write_to_module_pending;
          }

          else
            req->write_to_module_pending = (unsigned int)0;
          req->chunk_bytes_read = req->chunk_bytes_read + (unsigned int)remains;
          req->pstrblock_read = req->pstrblock_read + (signed long int)remains;
          req->pstrblock_read_len = req->pstrblock_read_len - remains;
          req->request_bytes_in = req->request_bytes_in + (unsigned long int)remains;
        }

        else
        {
          tmp = remains - req->pstrblock_read_len;
          if(!(tmp >= 2))
            req->write_to_module_pending = (unsigned int)(req->pstrblock_read_len - tmp);

          else
            req->write_to_module_pending = (unsigned int)req->pstrblock_read_len;
          req->http_bytes_in = req->http_bytes_in + (unsigned long int)req->write_to_module_pending;
          req->body_bytes_in = req->body_bytes_in + (unsigned long int)req->write_to_module_pending;
          req->request_bytes_in = req->request_bytes_in + (unsigned long int)req->pstrblock_read_len;
          req->chunk_bytes_read = req->chunk_bytes_read + (unsigned int)req->pstrblock_read_len;
          req->pstrblock_read = req->pstrblock_read + (signed long int)req->pstrblock_read_len;
          req->pstrblock_read_len = req->pstrblock_read_len - req->pstrblock_read_len;
        }
      }

      if(req->pstrblock_read_len == 0)
        return 2;

    }
    return 1;
  }
}

// parse_directive
// file txt_format.c line 160
unsigned int parse_directive(const char *var, unsigned int *width, signed int *left_align, char *parameter)
{
  const char *s1;
  signed int i = 0;
  char *e;
  s1 = var + (signed long int)1;
  parameter[(signed long int)0] = (char)0;
  if((signed int)*s1 == 45)
  {
    *left_align = 1;
    s1 = s1 + 1l;
  }

  else
    *left_align = 0;
  signed long int return_value_strtol_1;
  return_value_strtol_1=strtol(s1, &e, 10);
  *width = (unsigned int)return_value_strtol_1;
  if(e == s1)
    *width = (unsigned int)0;

  else
    s1 = e;
  if((signed int)*s1 == 123)
  {
    s1 = s1 + 1l;
    i = 0;
    for( ; !(*s1 == 0); s1 = s1 + 1l)
    {
      if((signed int)*s1 == 125)
        break;

      if(i >= 256)
        break;

      parameter[(signed long int)i] = *s1;
      i = i + 1;
    }
    if(!((signed int)*s1 == 125))
      return (unsigned int)0;

    parameter[(signed long int)i] = (char)0;
    s1 = s1 + 1l;
  }

  return (unsigned int)(s1 - var);
}

// parse_record
// file filetype.c line 179
static signed int parse_record(char *line, struct ci_magic_record *record)
{
  char *s;
  char *end;
  char num[4l];
  signed int len;
  signed int c;
  signed int i;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(line);
  len = (signed int)return_value_strlen_1;
  signed int *return_value___errno_location_4;
  if(!(len >= 4))
    return 0;

  else
    if((signed int)*line == 35)
      return 0;

    else
    {
      len = len - 1;
      line[(signed long int)len] = (char)0;
      s = line;
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = 0;
      signed long int return_value_strtol_3;
      return_value_strtol_3=strtol(s, &end, 10);
      record->offset = (signed int)return_value_strtol_3;
      _Bool tmp_if_expr_5;
      if(!((signed int)*end == 58))
        tmp_if_expr_5 = (_Bool)1;

      else
      {
        return_value___errno_location_4=__errno_location();
        tmp_if_expr_5 = *return_value___errno_location_4 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_5)
        return 0;

      else
      {
        s = end + (signed long int)1;
        i = 0;
        end = line + (signed long int)len;
        while(!((signed int)*s == 58))
        {
          if(s >= end)
            break;

          if(i >= 50)
            break;

          if((signed int)*s == 92)
          {
            s = s + 1l;
            if((signed int)*s == 120)
            {
              s = s + 1l;
              char *tmp_post_6 = s;
              s = s + 1l;
              num[(signed long int)0] = *tmp_post_6;
              char *tmp_post_7 = s;
              s = s + 1l;
              num[(signed long int)1] = *tmp_post_7;
              num[(signed long int)2] = (char)0;
              signed long int return_value_strtol_8;
              return_value_strtol_8=strtol(num, (char ** restrict )(void *)0, 16);
              c = (signed int)return_value_strtol_8;
            }

            else
            {
              char *tmp_post_9 = s;
              s = s + 1l;
              num[(signed long int)0] = *tmp_post_9;
              char *tmp_post_10 = s;
              s = s + 1l;
              num[(signed long int)1] = *tmp_post_10;
              char *tmp_post_11 = s;
              s = s + 1l;
              num[(signed long int)2] = *tmp_post_11;
              num[(signed long int)3] = (char)0;
              signed long int return_value_strtol_12;
              return_value_strtol_12=strtol(num, (char ** restrict )(void *)0, 8);
              c = (signed int)return_value_strtol_12;
            }
            if(c >= 257 || !(c >= 0))
              return -2;

            signed int tmp_post_13 = i;
            i = i + 1;
            record->magic[(signed long int)tmp_post_13] = (unsigned char)c;
          }

          else
          {
            signed int tmp_post_14 = i;
            i = i + 1;
            record->magic[(signed long int)tmp_post_14] = (unsigned char)*s;
            s = s + 1l;
          }
        }
        record->len = (unsigned long int)i;
        _Bool tmp_if_expr_15;
        if(s >= end)
          tmp_if_expr_15 = (_Bool)1;

        else
          tmp_if_expr_15 = (signed int)*s != 58 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_15)
          return -2;

        else
        {
          s = s + 1l;
          end=strchr(s, 58);
          if(end == ((char *)NULL))
            return -2;

          else
          {
            *end = (char)0;
            strncpy(record->type, s, (unsigned long int)15);
            record->type[(signed long int)15] = (char)0;
            s = end + (signed long int)1;
            end=strchr(s, 58);
            if(end == ((char *)NULL))
              return -2;

            else
            {
              *end = (char)0;
              strncpy(record->descr, s, (unsigned long int)50);
              record->descr[(signed long int)50] = (char)0;
              s = end + (signed long int)1;
              i = 0;
              do
              {
                end=strchr(s, 58);
                if(end == ((char *)NULL))
                  break;

                *end = (char)0;
                void *return_value_malloc_16;
                return_value_malloc_16=malloc((unsigned long int)(15 + 1));
                record->groups[(signed long int)i] = (char *)return_value_malloc_16;
                strncpy(record->groups[(signed long int)i], s, (unsigned long int)15);
                record->groups[(signed long int)i][(signed long int)15] = (char)0;
                i = i + 1;
                if(i >= 64)
                  break;

                s = end + (signed long int)1;
              }
              while((_Bool)1);
              void *return_value_malloc_17;
              return_value_malloc_17=malloc((unsigned long int)(15 + 1));
              record->groups[(signed long int)i] = (char *)return_value_malloc_17;
              strncpy(record->groups[(signed long int)i], s, (unsigned long int)15);
              record->groups[(signed long int)i][(signed long int)15] = (char)0;
              i = i + 1;
              record->groups[(signed long int)i] = (char *)(void *)0;
              return 1;
            }
          }
        }
      }
    }
}

// pointers_cmp
// file array.c line 685
static signed int pointers_cmp(const void *obj1, const void *obj2, unsigned long int size)
{
  return obj1 == obj2 ? 0 : (obj1 > obj2 ? 1 : -1);
}

// pool_allocator_alloc
// file mem.c line 796
static void * pool_allocator_alloc(struct ci_mem_allocator *allocator, unsigned long int size)
{
  struct mem_block_item *mem_item;
  void *data = (void *)0;
  struct pool_allocator *palloc = (struct pool_allocator *)allocator->data;
  if(!((unsigned long int)palloc->items_size >= size))
    return (void *)0;

  else
  {
    pthread_mutex_lock(&palloc->mutex);
    if(!(palloc->free == ((struct mem_block_item *)NULL)))
    {
      mem_item = palloc->free;
      palloc->free = palloc->free->next;
      data = mem_item->data;
      mem_item->data = (void *)0;
      palloc->hits_count = palloc->hits_count + 1;
    }

    else
    {
      void *return_value_malloc_1;
      return_value_malloc_1=malloc(sizeof(struct mem_block_item) /*16ul*/ );
      mem_item = (struct mem_block_item *)return_value_malloc_1;
      mem_item->data = (void *)0;
      data=malloc((unsigned long int)palloc->items_size);
      palloc->alloc_count = palloc->alloc_count + 1;
    }
    mem_item->next = palloc->allocated;
    palloc->allocated = mem_item;
    pthread_mutex_unlock(&palloc->mutex);
    if(CI_DEBUG_LEVEL >= 8)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "pool hits:%d allocations: %d\n", palloc->hits_count, palloc->alloc_count);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("pool hits:%d allocations: %d\n", palloc->hits_count, palloc->alloc_count);

    }

    return data;
  }
}

// pool_allocator_build
// file mem.c line 775
static struct pool_allocator * pool_allocator_build(signed int items_size, signed int strict)
{
  struct pool_allocator *palloc;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct pool_allocator) /*72ul*/ );
  palloc = (struct pool_allocator *)return_value_malloc_1;
  if(palloc == ((struct pool_allocator *)NULL))
    return (struct pool_allocator *)(void *)0;

  else
  {
    palloc->items_size = items_size;
    palloc->strict = strict;
    palloc->free = (struct mem_block_item *)(void *)0;
    palloc->allocated = (struct mem_block_item *)(void *)0;
    palloc->alloc_count = 0;
    palloc->hits_count = 0;
    ci_thread_mutex_init(&palloc->mutex);
    return palloc;
  }
}

// pool_allocator_destroy
// file mem.c line 880
static void pool_allocator_destroy(struct ci_mem_allocator *allocator)
{
  pool_allocator_reset(allocator);
  struct pool_allocator *palloc = (struct pool_allocator *)allocator->data;
  ci_thread_mutex_destroy(&palloc->mutex);
  free((void *)palloc);
}

// pool_allocator_free
// file mem.c line 829
static void pool_allocator_free(struct ci_mem_allocator *allocator, void *p)
{
  struct mem_block_item *mem_item;
  struct pool_allocator *palloc = (struct pool_allocator *)allocator->data;
  pthread_mutex_lock(&palloc->mutex);
  if(palloc->allocated == ((struct mem_block_item *)NULL))
    free(p);

  else
  {
    mem_item = palloc->allocated;
    palloc->allocated = palloc->allocated->next;
    mem_item->data = p;
    mem_item->next = palloc->free;
    palloc->free = mem_item;
  }
  pthread_mutex_unlock(&palloc->mutex);
}

// pool_allocator_reset
// file mem.c line 850
static void pool_allocator_reset(struct ci_mem_allocator *allocator)
{
  struct mem_block_item *mem_item;
  struct mem_block_item *cur;
  struct pool_allocator *palloc = (struct pool_allocator *)allocator->data;
  pthread_mutex_lock(&palloc->mutex);
  if(!(palloc->allocated == ((struct mem_block_item *)NULL)))
  {
    mem_item = palloc->allocated;
    while(!(mem_item == ((struct mem_block_item *)NULL)))
    {
      cur = mem_item;
      mem_item = mem_item->next;
      free((void *)cur);
    }
  }

  palloc->allocated = (struct mem_block_item *)(void *)0;
  if(!(palloc->free == ((struct mem_block_item *)NULL)))
  {
    mem_item = palloc->free;
    while(!(mem_item == ((struct mem_block_item *)NULL)))
    {
      cur = mem_item;
      mem_item = mem_item->next;
      free(cur->data);
      free((void *)cur);
    }
  }

  palloc->free = (struct mem_block_item *)(void *)0;
  pthread_mutex_unlock(&palloc->mutex);
}

// posix_proc_mutex_destroy
// file os/unix/proc_mutex.c line 139
static signed int posix_proc_mutex_destroy(struct ci_proc_mutex *mutex)
{
  signed int return_value_sem_unlink_1;
  return_value_sem_unlink_1=sem_unlink(mutex->name);
  if(!(return_value_sem_unlink_1 >= 0))
    return 0;

  else
    return 1;
}

// posix_proc_mutex_init
// file os/unix/proc_mutex.c line 118
static signed int posix_proc_mutex_init(struct ci_proc_mutex *mutex, const char *name)
{
  signed int i = 0;
  mutex->_anon0.posix.sem = (union anonymous_29 *)0;
  i = 0;
  for( ; !(i >= 1024); i = i + 1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 0;
    snprintf(mutex->name, (unsigned long int)64, "%s%s.%d", (const void *)"/c-icap-sem.", name, i);
    mutex->_anon0.posix.sem=sem_open(mutex->name, 0100 | 0200, 0400 | 0200 | 0400 >> 3, 1);
    if(!(mutex->_anon0.posix.sem == ((union anonymous_29 *)NULL)))
      return 1;

    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    if(!(*return_value___errno_location_2 == 17))
      break;

  }
  signed int *return_value___errno_location_5;
  return_value___errno_location_5=__errno_location();
  signed int *return_value___errno_location_3;
  signed int *return_value___errno_location_4;
  if(*return_value___errno_location_5 == 17)
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error allocation posix proc mutex, to many c-icap mutexes are open!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error allocation posix proc mutex, to many c-icap mutexes are open!\n");

    }

  }

  else
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      {
        return_value___errno_location_3=__errno_location();
        __log_error((void *)0, "Error allocation posix proc mutex, errno: %d\n", *return_value___errno_location_3);
      }

      if(!(CI_DEBUG_STDOUT == 0))
      {
        return_value___errno_location_4=__errno_location();
        printf("Error allocation posix proc mutex, errno: %d\n", *return_value___errno_location_4);
      }

    }

  return 0;
}

// posix_proc_mutex_lock
// file os/unix/proc_mutex.c line 147
static signed int posix_proc_mutex_lock(struct ci_proc_mutex *mutex)
{
  signed int return_value_sem_wait_1;
  return_value_sem_wait_1=sem_wait(mutex->_anon0.posix.sem);
  if(!(return_value_sem_wait_1 == 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Failed to get lock of posix mutex\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Failed to get lock of posix mutex\n");

    }

    return 0;
  }

  else
    return 1;
}

// posix_proc_mutex_print_info
// file os/unix/proc_mutex.c line 165
static signed int posix_proc_mutex_print_info(struct ci_proc_mutex *mutex, char *buf, unsigned long int buf_size)
{
  signed int return_value_snprintf_1;
  return_value_snprintf_1=snprintf(buf, buf_size, "posix:%s", (const void *)mutex->name);
  return return_value_snprintf_1;
}

// posix_proc_mutex_unlock
// file os/unix/proc_mutex.c line 156
static signed int posix_proc_mutex_unlock(struct ci_proc_mutex *mutex)
{
  signed int return_value_sem_post_1;
  return_value_sem_post_1=sem_post(mutex->_anon0.posix.sem);
  if(!(return_value_sem_post_1 == 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Failed to unlock of posix mutex\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Failed to unlock of posix mutex\n");

    }

    return 0;
  }

  else
    return 1;
}

// posix_shared_mem_attach
// file os/unix/shared_mem.c line 179
void * posix_shared_mem_attach(struct ci_shared_mem_id *id)
{
  return id->mem;
}

// posix_shared_mem_create
// file os/unix/shared_mem.c line 157
void * posix_shared_mem_create(struct ci_shared_mem_id *id, const char *name, signed int size)
{
  signed int i;
  id->size = (unsigned long int)size;
  i = 0;
  for( ; !(i >= 1024); i = i + 1)
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    *return_value___errno_location_1 = 0;
    snprintf(id->name, (unsigned long int)64, "%s-%s.%d", (const void *)"/c-icap-shared", name, i);
    id->_anon0.posix.fd=shm_open(id->name, 02 | 0100 | 0200, (unsigned int)(0400 | 0200));
    ftruncate64(id->_anon0.posix.fd, (signed long int)id->size);
    if(id->_anon0.posix.fd >= 0)
    {
      id->mem=mmap64((void *)0, (unsigned long int)size, 0x1 | 0x2, 0x01, id->_anon0.posix.fd, (signed long int)0);
      if(id->mem == (void *)-1)
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Posix mem: Failed to created shared memory!\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Posix mem: Failed to created shared memory!\n");

        }

        return (void *)0;
      }

      return id->mem;
    }

  }
  return (void *)0;
}

// posix_shared_mem_destroy
// file os/unix/shared_mem.c line 192
signed int posix_shared_mem_destroy(struct ci_shared_mem_id *id)
{
  munmap(id->mem, id->size);
  close(id->_anon0.posix.fd);
  id->mem = (void *)0;
  shm_unlink(id->name);
  return 1;
}

// posix_shared_mem_detach
// file os/unix/shared_mem.c line 184
signed int posix_shared_mem_detach(struct ci_shared_mem_id *id)
{
  munmap(id->mem, id->size);
  id->mem = (void *)0;
  return 1;
}

// posix_shared_mem_print_info
// file os/unix/shared_mem.c line 201
signed int posix_shared_mem_print_info(struct ci_shared_mem_id *id, char *buf, unsigned long int buf_size)
{
  signed int return_value_snprintf_1;
  return_value_snprintf_1=snprintf(buf, buf_size, "posix:%s %ld kbs", (const void *)id->name, (signed long int)(id->size / (unsigned long int)1024));
  return return_value_snprintf_1;
}

// process_encapsulated
// file request_common.c line 456
signed int process_encapsulated(struct ci_request *req, const char *buf)
{
  const char *start;
  const char *pos;
  char *end;
  signed int type = 0;
  signed int num = 0;
  signed int val = 0;
  signed int hasbody = 1;
  start = buf + (signed long int)13;
  pos = start;
  end = (char *)start;
  const unsigned short int **return_value___ctype_b_loc_1;
  _Bool tmp_if_expr_2;
  do
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if(!((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*pos]) == 0))
      tmp_if_expr_2 = (signed int)*pos != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    if(!tmp_if_expr_2)
      break;

    pos = pos + 1l;
  }
  while((_Bool)1);
  const unsigned short int **return_value___ctype_b_loc_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  while(!((signed int)*pos == 0))
  {
    type=get_encaps_type(pos, &val, &end);
    if(!(type >= 0))
      return 4;

    if(num >= 6)
      break;

    if(type == 4)
      hasbody = 0;

    signed int tmp_post_3 = num;
    num = num + 1;
    req->entities[(signed long int)tmp_post_3]=ci_request_alloc_entity(req, type, val);
    /* assertion start != end */
    assert(start != end);
    pos = end;
    do
    {
      return_value___ctype_b_loc_4=__ctype_b_loc();
      if(!((8192 & (signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)*pos]) == 0))
        tmp_if_expr_5 = (_Bool)1;

      else
        tmp_if_expr_5 = (signed int)*pos == 44 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_5)
        tmp_if_expr_6 = (signed int)*pos != 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_6 = (_Bool)0;
      if(!tmp_if_expr_6)
        break;

      pos = pos + 1l;
    }
    while((_Bool)1);
  }
  req->hasbody = hasbody;
  return 0;
}

// read_row
// file lookup_file_table.c line 102
signed int read_row(struct _IO_FILE *f, signed int cols, struct text_table_entry **e, struct ci_lookup_table *table)
{
  char line[65536l];
  char *s;
  char *val;
  char *end;
  signed int row_cols;
  signed int line_len;
  signed int i;
  struct ci_mem_allocator *read_row__1__allocator = table->allocator;
  const struct ci_type_ops *read_row__1__key_ops = table->key_ops;
  const struct ci_type_ops *read_row__1__val_ops = table->val_ops;
  *e = (struct text_table_entry *)(void *)0;
  char *return_value_fgets_1;
  return_value_fgets_1=fgets(line, 65535, f);
  unsigned long int return_value_strlen_3;
  if(return_value_fgets_1 == ((char *)NULL))
    return 0;

  else
  {
    line[(signed long int)65535] = (char)0;
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(line);
    line_len = (signed int)return_value_strlen_2;
    if(line_len >= 65536)
    {
      line[(signed long int)64] = (char)0;
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Too long line: %s...", (const void *)line);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Too long line: %s...", (const void *)line);

      }

      return 0;
    }

    else
    {
      if((signed int)line[(signed long int)(line_len + -1)] == 10)
        line[(signed long int)(line_len - 1)] = (char)0;

      s = line;
      for( ; (_Bool)1; s = s + 1l)
        if(!((signed int)*s == 32))
        {
          if(!((signed int)*s == 9))
            goto __CPROVER_DUMP_L8;

        }


    __CPROVER_DUMP_L8:
      ;
      if((signed int)*s == 35)
        return 1;

      else
        if((signed int)*s == 0)
          return 1;

        else
        {
          if(!(cols >= 0))
          {
            s=index(line, 58);
            if(s == ((char *)NULL))
              row_cols = 1;

            else
            {
              row_cols = 2;
              do
              {
                s=index(s, 44);
                if(s == ((char *)NULL))
                  break;

                row_cols = row_cols + 1;
                s = s + 1l;
              }
              while((_Bool)1);
            }
          }

          else
            row_cols = cols;
          *e=alloc_text_table_entry(row_cols - 1, read_row__1__allocator);
          if(*e == ((struct text_table_entry *)NULL))
          {
            if(CI_DEBUG_LEVEL >= 1)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "Error allocating memory for table entry:%s\n", (const void *)line);

              if(!(CI_DEBUG_STDOUT == 0))
                printf("Error allocating memory for table entry:%s\n", (const void *)line);

            }

            return 0;
          }

          else
          {
            s = line;
            for( ; (_Bool)1; s = s + 1l)
              if(!((signed int)*s == 32))
              {
                if(!((signed int)*s == 9))
                  goto __CPROVER_DUMP_L21;

              }


          __CPROVER_DUMP_L21:
            ;
            val = s;
            end = (char *)(void *)0;
            if(row_cols >= 2)
              end=index(s, 58);

            if(end == ((char *)NULL))
            {
              return_value_strlen_3=strlen(s);
              end = s + (signed long int)return_value_strlen_3;
            }

            s = end + (signed long int)1;
            end = end - 1l;
            for( ; (_Bool)1; end = end - 1l)
              if(!((signed int)*end == 32))
              {
                if(!((signed int)*end == 9))
                  goto __CPROVER_DUMP_L26;

              }


          __CPROVER_DUMP_L26:
            ;
            end[(signed long int)1] = (char)0;
            (*e)->key=read_row__1__key_ops->dup(val, read_row__1__allocator);
            if((*e)->key == NULL)
            {
              if(CI_DEBUG_LEVEL >= 1)
              {
                if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                  __log_error((void *)0, "Error reading key in line:%s\n", (const void *)line);

                if(!(CI_DEBUG_STDOUT == 0))
                  printf("Error reading key in line:%s\n", (const void *)line);

              }

              release_text_table_entry(*e, table);
              *e = (struct text_table_entry *)(void *)0;
              return -1;
            }

            else
            {
              if(row_cols >= 2)
              {
                /* assertion (*e)->vals */
                assert((*e)->vals != ((void **)NULL));
                i = 0;
                if(!((signed int)*s == 0))
                {
                  if(i >= row_cols)
                  {
                    if(CI_DEBUG_LEVEL >= 1)
                    {
                      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                        __log_error((void *)0, "Error in read_row of file lookup table!(line:%s)\n", (const void *)line);

                      if(!(CI_DEBUG_STDOUT == 0))
                        printf("Error in read_row of file lookup table!(line:%s)\n", (const void *)line);

                    }

                    release_text_table_entry(*e, table);
                    *e = (struct text_table_entry *)(void *)0;
                    return -1;
                  }

                  if((signed int)*s == 32)
                    s = s + 1l;

                  val = s;
                  end = s;
                  if(!((signed int)*end == 44))
                  {
                    if(!((signed int)*end == 0))
                      end = end + 1l;

                  }

                  if((signed int)*end == 0)
                    s = end;

                  else
                    s = end + (signed long int)1;
                  end = end - 1l;
                  if((signed int)*end == 32)
                    end = end - 1l;

                  end[(signed long int)1] = (char)0;
                  (*e)->vals[(signed long int)i]=read_row__1__val_ops->dup(val, read_row__1__allocator);
                  i = i + 1;
                }

                (*e)->vals[(signed long int)i] = (void *)0;
              }

              return 1;
            }
          }
        }
    }
  }
}

// record_extract
// file c-icap-mkbdb.c line 153
signed int record_extract(char *line, void **key, signed int *keysize, void **val, signed int *valsize)
{
  char *s;
  char *v;
  char *e;
  void *avalue;
  void *store;
  void *store_value;
  void **store_index;
  signed int i;
  signed int row_cols = 0;
  signed int avalue_size;
  signed int store_value_size;
  *key = (void *)0;
  *val = (void *)0;
  *keysize = 0;
  *valsize = 0;
  s=index(line, 58);
  if(s == ((char *)NULL))
    row_cols = 1;

  else
  {
    row_cols = 2;
    do
    {
      s=index(s, 44);
      if(s == ((char *)NULL))
        break;

      row_cols = row_cols + 1;
      s = s + 1l;
    }
    while((_Bool)1);
  }
  s = line;
  for( ; (_Bool)1; s = s + 1l)
    if(!((signed int)*s == 32))
    {
      if(!((signed int)*s == 9))
        goto __CPROVER_DUMP_L6;

    }


__CPROVER_DUMP_L6:
  ;
  v = s;
  unsigned long int return_value_strlen_1;
  if((signed int)*s == 35)
    return 1;

  else
    if((signed int)*s == 0)
      return 1;

    else
    {
      if(row_cols == 1)
      {
        return_value_strlen_1=strlen(s);
        e = s + (signed long int)return_value_strlen_1;
      }

      else
        e=index(s, 58);
      s = e + (signed long int)1;
      e = e - 1l;
      for( ; (_Bool)1; e = e - 1l)
        if(!((signed int)*e == 32))
        {
          if(!((signed int)*e == 9))
          {
            if(!((signed int)*e == 10))
              goto __CPROVER_DUMP_L13;

          }

        }


    __CPROVER_DUMP_L13:
      ;
      e[(signed long int)1] = (char)0;
      *key=key_ops->dup(v, allocator);
      unsigned long int return_value;
      return_value=key_ops->size(*key);
      *keysize = (signed int)return_value;
      if(row_cols >= 2)
      {
        if(row_cols >= 129)
          return -1;

        *val=allocator->alloc(allocator, (unsigned long int)65535);
        store = *val;
        store_index = (void **)*val;
        store_value = *val + (signed long int)((unsigned long int)row_cols * sizeof(void *) /*8ul*/ );
        store_value_size = (signed int)((unsigned long int)65535 - (unsigned long int)row_cols * sizeof(void *) /*8ul*/ );
        *valsize = (signed int)((unsigned long int)row_cols * sizeof(void *) /*8ul*/ );
        i = 0;
        if(!((signed int)*s == 0) && !(i >= row_cols + -1))
        {
          if((signed int)*s == 32)
            s = s + 1l;

          v = s;
          e = s;
          if(!((signed int)*e == 44))
          {
            if(!((signed int)*e == 0))
              e = e + 1l;

          }

          if((signed int)*e == 0)
            s = e;

          else
            s = e + (signed long int)1;
          e = e - 1l;
          if((signed int)*e == 32)
            e = e - 1l;

          e[(signed long int)1] = (char)0;
          avalue=val_ops->dup(v, allocator);
          unsigned long int return_value_1;
          return_value_1=val_ops->size(avalue);
          avalue_size = (signed int)return_value_1;
          if(*valsize + avalue_size >= store_value_size)
          {
            allocator->free(allocator, avalue);
            store_index[(signed long int)i] = NULL;
            return -1;
          }

          memcpy(store_value, avalue, (unsigned long int)avalue_size);
          store_index[(signed long int)i] = (void *)(store_value - store);
          void *apos = store + (signed long int)store_index[(signed long int)i];
          printf("\t\t- Storing val:%s at pos:%p(%s:%d)\n", (char *)avalue, store_index[(signed long int)i], (char *)apos, avalue_size);
          store_value = store_value + (signed long int)avalue_size;
          *valsize = *valsize + avalue_size;
          allocator->free(allocator, avalue);
          avalue = (void *)0;
          i = i + 1;
        }

        store_index[(signed long int)i] = NULL;
      }

      else
      {
        *val = (void *)0;
        *valsize = 0;
      }
      return 1;
    }
}

// regex_cmp
// file types_ops.c line 271
signed int regex_cmp(const void *key1, const void *key2)
{
  struct ci_acl_regex *reg = (struct ci_acl_regex *)key1;
  if(key2 == NULL)
    return -1;

  else
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen((const char *)key2);
    signed int return_value_ci_regex_apply_2;
    return_value_ci_regex_apply_2=ci_regex_apply(reg->preg, (const char *)key2, (signed int)return_value_strlen_1, 0, (struct ci_list *)(void *)0, (void *)0);
    return return_value_ci_regex_apply_2 == 0 ? 1 : 0;
  }
}

// regex_dup
// file types_ops.c line 238
void * regex_dup(const char *str, struct ci_mem_allocator *allocator)
{
  struct ci_acl_regex *reg;
  char *newstr;
  signed int flags;
  signed int recursive;
  newstr=ci_regex_parse(str, &flags, &recursive);
  if(newstr == ((char *)NULL))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Parse error, while parsing regex: '%s')!\n", str);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Parse error, while parsing regex: '%s')!\n", str);

    }

    return (void *)0;
  }

  else
  {
    void *return_value;
    return_value=allocator->alloc(allocator, sizeof(struct ci_acl_regex) /*24ul*/ );
    reg = (struct ci_acl_regex *)return_value;
    if(reg == ((struct ci_acl_regex *)NULL))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error allocating memory for regex_dup (1)!\n");

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error allocating memory for regex_dup (1)!\n");

      }

      free((void *)newstr);
      return (void *)0;
    }

    else
    {
      reg->preg=ci_regex_build(newstr, flags);
      if(reg->preg == NULL)
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "Error compiling regular expression :%s (%s)\n", str, newstr);

          if(!(CI_DEBUG_STDOUT == 0))
            printf("Error compiling regular expression :%s (%s)\n", str, newstr);

        }

        allocator->free(allocator, (void *)reg);
        free((void *)newstr);
        return (void *)0;
      }

      else
      {
        reg->str = newstr;
        reg->flags = flags;
        return (void *)reg;
      }
    }
  }
}

// regex_equal
// file types_ops.c line 279
signed int regex_equal(const void *key1, const void *key2)
{
  struct ci_acl_regex *reg = (struct ci_acl_regex *)key1;
  if(key2 == NULL)
    return 0;

  else
  {
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen((const char *)key2);
    signed int return_value_ci_regex_apply_2;
    return_value_ci_regex_apply_2=ci_regex_apply(reg->preg, (const char *)key2, (signed int)return_value_strlen_1, 0, (struct ci_list *)(void *)0, (void *)0);
    return (signed int)(return_value_ci_regex_apply_2 != 0);
  }
}

// regex_free
// file types_ops.c line 292
void regex_free(void *key, struct ci_mem_allocator *allocator)
{
  struct ci_acl_regex *reg = (struct ci_acl_regex *)key;
  ci_regex_free(reg->preg);
  allocator->free(allocator, (void *)reg->str);
  allocator->free(allocator, (void *)reg);
}

// regex_len
// file types_ops.c line 287
unsigned long int regex_len(const void *key)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(((struct ci_acl_regex *)key)->str);
  return return_value_strlen_1;
}

// regex_table_close
// file lookup_file_table.c line 440
void regex_table_close(struct ci_lookup_table *table)
{
  file_table_close(table);
}

// regex_table_open
// file lookup_file_table.c line 419
void * regex_table_open(struct ci_lookup_table *table)
{
  struct text_table *text_table;
  if(!(table->key_ops == &ci_str_ops))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "This type of table is not compatible with regex tables!\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("This type of table is not compatible with regex tables!\n");

    }

    return (void *)0;
  }

  else
  {
    table->key_ops = &ci_regex_ops;
    void *return_value_file_table_open_1;
    return_value_file_table_open_1=file_table_open(table);
    text_table = (struct text_table *)return_value_file_table_open_1;
    if(text_table == ((struct text_table *)NULL))
      return (void *)0;

    else
      return (void *)text_table;
  }
}

// regex_table_release_result
// file lookup_file_table.c line 461
void regex_table_release_result(struct ci_lookup_table *table_data, void **val)
{
  ;
}

// regex_table_search
// file lookup_file_table.c line 451
void * regex_table_search(struct ci_lookup_table *table, void *key, void ***vals)
{
  void *return_value_file_table_search_1;
  return_value_file_table_search_1=file_table_search(table, key, vals);
  return return_value_file_table_search_1;
}

// release_body_system
// file body.c line 74
void release_body_system()
{
  ci_object_pool_unregister(MEMBUF_POOL);
  ci_object_pool_unregister(CACHED_FILE_POOL);
  ci_object_pool_unregister(SIMPLE_FILE_POOL);
  ci_object_pool_unregister(RING_BUF_POOL);
}

// release_header_value
// file acl.c line 898
void release_header_value(struct ci_headers_list *headers, char *head)
{
  if(!(headers == ((struct ci_headers_list *)NULL)))
  {
    if(!(headers->packed == 0))
    {
      if(!(head == ((char *)NULL)))
        ci_buffer_free((void *)head);

    }

  }

}

// release_text_table_entry
// file lookup_file_table.c line 81
void release_text_table_entry(struct text_table_entry *e, struct ci_lookup_table *table)
{
  void **vals;
  signed int i;
  struct ci_mem_allocator *release_text_table_entry__1__allocator = table->allocator;
  if(!(e == ((struct text_table_entry *)NULL)))
  {
    if(!(e->vals == ((void **)NULL)))
    {
      vals = (void **)e->vals;
      i = 0;
      if(!(vals[(signed long int)i] == NULL))
      {
        table->val_ops->free(vals[(signed long int)i], release_text_table_entry__1__allocator);
        i = i + 1;
      }

      release_text_table_entry__1__allocator->free(release_text_table_entry__1__allocator, (void *)e->vals);
    }

    if(!(e->key == NULL))
      table->key_ops->free(e->key, release_text_table_entry__1__allocator);

    release_text_table_entry__1__allocator->free(release_text_table_entry__1__allocator, (void *)e);
  }

}

// request_match_specslist
// file acl.c line 716
signed int request_match_specslist(struct ci_request *req, struct ci_specs_list *spec_list)
{
  const struct ci_acl_spec *spec;
  const struct ci_acl_type *type;
  signed int ret;
  signed int negate;
  signed int check_result;
  void *test_data;
  ret = 1;
  if(!(spec_list == ((struct ci_specs_list *)NULL)))
  {
    spec = spec_list->spec;
    negate = spec_list->negate;
    type = spec->type;
    test_data=type->get_test_data(req, spec->parameter);
    if(test_data == NULL)
    {
      if(CI_DEBUG_LEVEL >= 9)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "No data to test for %s/%s, ignore\n", (const void *)type->name, spec->parameter);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("No data to test for %s/%s, ignore\n", (const void *)type->name, spec->parameter);

      }

      return 0;
    }

    check_result=spec_data_check(spec, test_data);
    if(check_result == 0 && negate == 0)
      ret = 0;

    else
      if(!(check_result == 0) && !(negate == 0))
        ret = 0;

    if(!(type->free_test_data == ((void (*)(struct ci_request *, void *))NULL)))
      type->free_test_data(req, test_data);

    if(ret == 0)
      return 0;

    spec_list = spec_list->next;
  }

  return 1;
}

// resize_buffer
// file body.c line 343
signed int resize_buffer(struct ci_cached_file *body, signed int new_size)
{
  char *newbuf;
  if(!(new_size >= body->bufsize))
    return 1;

  else
    if(!(CI_BODY_MAX_MEM >= new_size))
      return 0;

    else
    {
      void *return_value_ci_buffer_realloc_1;
      return_value_ci_buffer_realloc_1=ci_buffer_realloc((void *)body->buf, new_size);
      newbuf = (char *)return_value_ci_buffer_realloc_1;
      if(!(newbuf == ((char *)NULL)))
      {
        body->buf = newbuf;
        body->bufsize = new_size;
      }

      return 1;
    }
}

// search_options_table
// file cfg_lib.c line 76
struct ci_options_entry * search_options_table(const char *directive, struct ci_options_entry *options)
{
  signed int i;
  const char *option_search;
  if(!((signed int)*directive == 45))
    option_search = "__";

  else
    option_search = directive;
  i = 0;
  for( ; !((options + (signed long int)i)->name == ((const char *)NULL)); i = i + 1)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(option_search, (options + (signed long int)i)->name);
    if(return_value_strcmp_1 == 0)
      return &options[(signed long int)i];

  }
  return (struct ci_options_entry *)(void *)0;
}

// serial_allocation
// file mem.c line 476
static void * serial_allocation(struct serial_allocator *serial_alloc, unsigned long int size)
{
  signed int max_size;
  void *mem;
  size = size + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1);
  max_size = (signed int)(serial_alloc->endpos - serial_alloc->memchunk);
  if(!((unsigned long int)max_size >= size))
    return (void *)0;

  else
  {
    for( ; !((unsigned long int)(serial_alloc->endpos - serial_alloc->curpos) >= size); serial_alloc = serial_alloc->next)
      if(serial_alloc->next == ((struct serial_allocator *)NULL))
      {
        serial_alloc->next=serial_allocator_build(max_size);
        if(serial_alloc->next == ((struct serial_allocator *)NULL))
          return (void *)0;

      }

    mem = serial_alloc->curpos;
    serial_alloc->curpos = serial_alloc->curpos + (signed long int)size;
    return mem;
  }
}

// serial_allocator_alloc
// file mem.c line 499
static void * serial_allocator_alloc(struct ci_mem_allocator *allocator, unsigned long int size)
{
  struct serial_allocator *serial_alloc = (struct serial_allocator *)allocator->data;
  if(serial_alloc == ((struct serial_allocator *)NULL))
    return (void *)0;

  else
  {
    void *return_value_serial_allocation_1;
    return_value_serial_allocation_1=serial_allocation(serial_alloc, size);
    return return_value_serial_allocation_1;
  }
}

// serial_allocator_build
// file mem.c line 453
static struct serial_allocator * serial_allocator_build(signed int size)
{
  struct serial_allocator *serial_alloc;
  void *buffer;
  size = (signed int)((unsigned long int)size + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1));
  if(!((unsigned long int)size >= sizeof(struct serial_allocator) * 2 + 24 /*88ul*/ ))
    return (struct serial_allocator *)(void *)0;

  else
  {
    buffer=ci_buffer_alloc(size);
    serial_alloc = (struct serial_allocator *)buffer;
    unsigned long int return_value_ci_buffer_blocksize_1;
    return_value_ci_buffer_blocksize_1=ci_buffer_blocksize(buffer);
    size = (signed int)return_value_ci_buffer_blocksize_1;
    serial_alloc->memchunk = buffer + (signed long int)sizeof(struct serial_allocator) /*32ul*/ ;
    size = size - (signed int)sizeof(struct serial_allocator) /*32ul*/ ;
    serial_alloc->curpos = serial_alloc->memchunk;
    serial_alloc->endpos = serial_alloc->memchunk + (signed long int)size;
    serial_alloc->next = (struct serial_allocator *)(void *)0;
    return serial_alloc;
  }
}

// serial_allocator_destroy
// file mem.c line 530
static void serial_allocator_destroy(struct ci_mem_allocator *allocator)
{
  struct serial_allocator *cur;
  struct serial_allocator *next;
  if(!(allocator->data == NULL))
  {
    cur = (struct serial_allocator *)allocator->data;
    next = cur->next;
    while(!(cur == ((struct serial_allocator *)NULL)))
    {
      ci_buffer_free((void *)cur);
      cur = next;
      if(!(next == ((struct serial_allocator *)NULL)))
        next = next->next;

    }
  }

}

// serial_allocator_free
// file mem.c line 508
static void serial_allocator_free(struct ci_mem_allocator *allocator, void *p)
{
  ;
}

// serial_allocator_reset
// file mem.c line 513
static void serial_allocator_reset(struct ci_mem_allocator *allocator)
{
  struct serial_allocator *serial_alloc;
  struct serial_allocator *sa;
  void *tmp;
  serial_alloc = (struct serial_allocator *)allocator->data;
  serial_alloc->curpos = serial_alloc->memchunk + (signed long int)(sizeof(struct ci_mem_allocator) /*56ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1));
  sa = serial_alloc->next;
  serial_alloc->next = (struct serial_allocator *)(void *)0;
  for( ; !(sa == ((struct serial_allocator *)NULL)); sa = sa->next)
  {
    tmp = (void *)sa;
    ci_buffer_free(tmp);
  }
}

// sizeof_pack_allocator
// file mem.c line 735
static unsigned long int sizeof_pack_allocator()
{
  return sizeof(struct pack_allocator) /*40ul*/ ;
}

// sizeofencaps
// file header.c line 613
signed int sizeofencaps(struct ci_encaps_entity *e)
{
  _Bool tmp_if_expr_2;
  if(e->type == 0)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = e->type == 1 ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_2)
  {
    signed int return_value_sizeofheader_1;
    return_value_sizeofheader_1=sizeofheader((struct ci_headers_list *)e->entity);
    return return_value_sizeofheader_1;
  }

  return 0;
}

// sizeofheader
// file header.c line 600
signed int sizeofheader(struct ci_headers_list *h)
{
  return h->bufused + 2;
}

// spec_data_check
// file acl.c line 699
signed int spec_data_check(const struct ci_acl_spec *spec, const void *req_raw_data)
{
  struct ci_acl_data *spec_data = spec->data;
  const struct ci_type_ops *ops = spec->type->type;
  if(CI_DEBUG_LEVEL >= 9)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "Check request with ci_acl_spec_t:%s\n", (const void *)spec->name);

    if(!(CI_DEBUG_STDOUT == 0))
      printf("Check request with ci_acl_spec_t:%s\n", (const void *)spec->name);

  }

  if(!(spec_data == ((struct ci_acl_data *)NULL)))
  {
    signed int return_value;
    return_value=ops->equal(spec_data->data, (void *)req_raw_data);
    if(!(return_value == 0))
    {
      if(CI_DEBUG_LEVEL >= 9)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "The ci_acl_spec_t:%s matches\n", (const void *)spec->name);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("The ci_acl_spec_t:%s matches\n", (const void *)spec->name);

      }

      return 1;
    }

    spec_data = spec_data->next;
  }

  return 0;
}

// stat_entry_add
// file stats.c line 40
signed int stat_entry_add(struct stat_entry_list *list, const char *label, signed int type, signed int gid)
{
  struct stat_entry *l;
  signed int indx;
  if(list == ((struct stat_entry_list *)NULL))
    return -1;

  else
  {
    indx=stat_entry_by_name(list, label);
    if(indx >= 0)
      return indx;

    else
    {
      if(list->size == list->entries_num)
      {
        if(list->size == 0)
        {
          void *return_value_malloc_1;
          return_value_malloc_1=malloc((unsigned long int)128 * sizeof(struct stat_entry) /*16ul*/ );
          list->entries = (struct stat_entry *)return_value_malloc_1;
          if(list->entries == ((struct stat_entry *)NULL))
            return -1;

        }

        else
        {
          void *return_value_realloc_2;
          return_value_realloc_2=realloc((void *)list->entries, (unsigned long int)(list->size + 128) * sizeof(struct stat_entry) /*16ul*/ );
          l = (struct stat_entry *)return_value_realloc_2;
          if(l == ((struct stat_entry *)NULL))
            return -1;

          list->entries = l;
        }
        list->size = list->size + 128;
      }

      (list->entries + (signed long int)list->entries_num)->label=strdup(label);
      (list->entries + (signed long int)list->entries_num)->type = type;
      (list->entries + (signed long int)list->entries_num)->gid = gid;
      indx = list->entries_num;
      list->entries_num = list->entries_num + 1;
      return indx;
    }
  }
}

// stat_entry_by_name
// file stats.c line 88
signed int stat_entry_by_name(struct stat_entry_list *list, const char *label)
{
  signed int i;
  signed int return_value_strcmp_1;
  if(list->entries == ((struct stat_entry *)NULL))
    return -1;

  else
  {
    i = 0;
    for( ; !(i >= list->entries_num); i = i + 1)
    {
      return_value_strcmp_1=strcmp(label, (list->entries + (signed long int)i)->label);
      if(return_value_strcmp_1 == 0)
        return i;

    }
    return -1;
  }
}

// stat_entry_release_list
// file stats.c line 75
void stat_entry_release_list(struct stat_entry_list *list)
{
  signed int i;
  if(!(list->entries == ((struct stat_entry *)NULL)))
  {
    i = 0;
    for( ; !(i >= list->entries_num); i = i + 1)
      free((void *)(list->entries + (signed long int)i)->label);
    free((void *)list->entries);
    list->entries = (struct stat_entry *)(void *)0;
    list->size = 0;
    list->entries_num = 0;
  }

}

// stat_group_add
// file stats.c line 100
signed int stat_group_add(char *group)
{
  char **group_list;
  signed int gid = 0;
  gid = 0;
  for( ; !(gid >= STAT_GROUPS.entries_num); gid = gid + 1)
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp(STAT_GROUPS.groups[(signed long int)gid], group);
    if(return_value_strcmp_1 == 0)
      return gid;

  }
  if(STAT_GROUPS.size == 0)
  {
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)128 * sizeof(char *) /*8ul*/ );
    STAT_GROUPS.groups = (char **)return_value_malloc_2;
    if(STAT_GROUPS.groups == ((char **)NULL))
      return -1;

    STAT_GROUPS.size = 128;
  }

  else
    if(STAT_GROUPS.size == STAT_GROUPS.entries_num)
    {
      void *return_value_realloc_3;
      return_value_realloc_3=realloc((void *)STAT_GROUPS.groups, (unsigned long int)(STAT_GROUPS.size + 128) * sizeof(char *) /*8ul*/ );
      group_list = (char **)return_value_realloc_3;
      if(group_list == ((char **)NULL))
        return -1;

      STAT_GROUPS.groups = group_list;
      STAT_GROUPS.size = STAT_GROUPS.size + 128;
    }

  STAT_GROUPS.groups[(signed long int)STAT_GROUPS.entries_num]=strdup(group);
  gid = STAT_GROUPS.entries_num;
  STAT_GROUPS.entries_num = STAT_GROUPS.entries_num + 1;
  return gid;
}

// stat_memblock_fix
// file stats.c line 273
void stat_memblock_fix(struct stat_memblock *mem_block)
{
  /* assertion mem_block->sig == 0xFAFA */
  assert(mem_block->sig == (unsigned int)0xFAFA);
  mem_block->counters64_size = STAT_INT64.entries_num;
  mem_block->counterskbs_size = STAT_KBS.entries_num;
  mem_block->counters64 = (unsigned long int *)((void *)mem_block + (signed long int)(sizeof(struct stat_memblock) /*32ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)));
  mem_block->counterskbs = (struct kbs *)((void *)mem_block + (signed long int)(sizeof(struct stat_memblock) /*32ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + (signed long int)((unsigned long int)mem_block->counters64_size * sizeof(unsigned long int) /*8ul*/ ));
}

// stat_memblock_reconstruct
// file stats.c line 284
void stat_memblock_reconstruct(struct stat_memblock *mem_block)
{
  /* assertion mem_block->sig == 0xFAFA */
  assert(mem_block->sig == (unsigned int)0xFAFA);
  mem_block->counters64 = (unsigned long int *)((void *)mem_block + (signed long int)(sizeof(struct stat_memblock) /*32ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)));
  mem_block->counterskbs = (struct kbs *)((void *)mem_block + (signed long int)(sizeof(struct stat_memblock) /*32ul*/  + ((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1) & ~((unsigned long int)&((struct _ci_align_test *)0 + (signed long int)0)->d - (unsigned long int)1)) + (signed long int)((unsigned long int)mem_block->counters64_size * sizeof(unsigned long int) /*8ul*/ ));
}

// store_db
// file c-icap-mkbdb.c line 266
void store_db(void *key, signed int keysize, void *val, signed int valsize)
{
  struct __db_dbt db_key;
  struct __db_dbt db_data;
  signed int ret;
  memset((void *)&db_key, 0, sizeof(struct __db_dbt) /*40ul*/ );
  memset((void *)&db_data, 0, sizeof(struct __db_dbt) /*40ul*/ );
  db_key.data = key;
  db_key.size = (unsigned int)keysize;
  db_data.data = val;
  db_data.size = (unsigned int)valsize;
  ret=db->put(db, (struct __db_txn *)(void *)0, &db_key, &db_data, (unsigned int)0);
  char *return_value_db_strerror_1;
  char *return_value_db_strerror_2;
  if(!(ret == 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      {
        return_value_db_strerror_1=db_strerror(ret);
        __log_error((void *)0, "db_create: %s (key size:%d, val size:%d)\n", return_value_db_strerror_1, keysize, valsize);
      }

      if(!(CI_DEBUG_STDOUT == 0))
      {
        return_value_db_strerror_2=db_strerror(ret);
        printf("db_create: %s (key size:%d, val size:%d)\n", return_value_db_strerror_2, keysize, valsize);
      }

    }

  }

}

// string_ext_cmp
// file types_ops.c line 73
signed int string_ext_cmp(const void *key1, const void *key2)
{
  if(key2 == NULL)
    return -1;

  else
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp((const char *)key1, "*");
    if(return_value_strcmp_1 == 0)
      return 0;

    else
    {
      signed int return_value_strcmp_2;
      return_value_strcmp_2=strcmp((const char *)key1, (const char *)key2);
      return return_value_strcmp_2;
    }
  }
}

// string_ext_equal
// file types_ops.c line 84
signed int string_ext_equal(const void *key1, const void *key2)
{
  if(key2 == NULL)
    return 0;

  else
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp((const char *)key1, "*");
    if(return_value_strcmp_1 == 0)
      return 1;

    else
    {
      signed int return_value_strcmp_2;
      return_value_strcmp_2=strcmp((const char *)key1, (const char *)key2);
      return (signed int)(return_value_strcmp_2 == 0);
    }
  }
}

// stringcmp
// file types_ops.c line 41
signed int stringcmp(const void *key1, const void *key2)
{
  if(key2 == NULL)
    return -1;

  else
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp((const char *)key1, (const char *)key2);
    return return_value_strcmp_1;
  }
}

// stringdup
// file types_ops.c line 33
void * stringdup(const char *str, struct ci_mem_allocator *allocator)
{
  char *new_s;
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(str);
  void *return_value;
  return_value=allocator->alloc(allocator, return_value_strlen_1 + (unsigned long int)1);
  new_s = (char *)return_value;
  if(!(new_s == ((char *)NULL)))
    strcpy(new_s, str);

  return (void *)new_s;
}

// stringequal
// file types_ops.c line 48
signed int stringequal(const void *key1, const void *key2)
{
  if(key2 == NULL)
    return 0;

  else
  {
    signed int return_value_strcmp_1;
    return_value_strcmp_1=strcmp((const char *)key1, (const char *)key2);
    return (signed int)(return_value_strcmp_1 == 0);
  }
}

// stringfree
// file types_ops.c line 60
void stringfree(void *key, struct ci_mem_allocator *allocator)
{
  allocator->free(allocator, key);
}

// stringlen
// file types_ops.c line 55
unsigned long int stringlen(const void *key)
{
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen((const char *)key);
  return return_value_strlen_1 + (unsigned long int)1;
}

// sysv_proc_mutex_destroy
// file os/unix/proc_mutex.c line 74
static signed int sysv_proc_mutex_destroy(struct ci_proc_mutex *mutex)
{
  signed int return_value_semctl_1;
  return_value_semctl_1=semctl(mutex->_anon0.sysv.id, 0, 0, 0);
  if(!(return_value_semctl_1 >= 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error removing mutex\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error removing mutex\n");

    }

    return 0;
  }

  else
    return 1;
}

// sysv_proc_mutex_init
// file os/unix/proc_mutex.c line 56
static signed int sysv_proc_mutex_init(struct ci_proc_mutex *mutex, const char *name)
{
  union semun arg;
  mutex->_anon0.sysv.id=semget((signed int)0, 1, 01000 | 0600);
  signed int *return_value___errno_location_1;
  signed int *return_value___errno_location_2;
  if(!(mutex->_anon0.sysv.id >= 0))
  {
    if(CI_DEBUG_LEVEL >= 1)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "Error creating mutex\n");

      if(!(CI_DEBUG_STDOUT == 0))
        printf("Error creating mutex\n");

    }

    return 0;
  }

  else
  {
    arg.val = 0;
    signed int return_value_semctl_3;
    return_value_semctl_3=semctl(mutex->_anon0.sysv.id, 0, 16, arg);
    if(!(return_value_semctl_3 >= 0))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        {
          return_value___errno_location_1=__errno_location();
          __log_error((void *)0, "Error setting default value for mutex, errno:%d\n", *return_value___errno_location_1);
        }

        if(!(CI_DEBUG_STDOUT == 0))
        {
          return_value___errno_location_2=__errno_location();
          printf("Error setting default value for mutex, errno:%d\n", *return_value___errno_location_2);
        }

      }

      return 0;
    }

    else
    {
      strncpy(mutex->name, name, (unsigned long int)64);
      mutex->name[(signed long int)(64 - 1)] = (char)0;
      return 1;
    }
  }
}

// sysv_proc_mutex_lock
// file os/unix/proc_mutex.c line 83
static signed int sysv_proc_mutex_lock(struct ci_proc_mutex *mutex)
{
  signed int return_value_semop_1;
  return_value_semop_1=semop(mutex->_anon0.sysv.id, (struct sembuf *)&op_lock, (unsigned long int)2);
  if(!(return_value_semop_1 >= 0))
    return 0;

  else
    return 1;
}

// sysv_proc_mutex_print_info
// file os/unix/proc_mutex.c line 99
static signed int sysv_proc_mutex_print_info(struct ci_proc_mutex *mutex, char *buf, unsigned long int buf_size)
{
  signed int return_value_snprintf_1;
  return_value_snprintf_1=snprintf(buf, buf_size, "sysv:%s/%d", (const void *)mutex->name, mutex->_anon0.sysv.id);
  return return_value_snprintf_1;
}

// sysv_proc_mutex_unlock
// file os/unix/proc_mutex.c line 91
static signed int sysv_proc_mutex_unlock(struct ci_proc_mutex *mutex)
{
  signed int return_value_semop_1;
  return_value_semop_1=semop(mutex->_anon0.sysv.id, (struct sembuf *)&op_unlock, (unsigned long int)1);
  if(!(return_value_semop_1 >= 0))
    return 0;

  else
    return 1;
}

// sysv_shared_mem_attach
// file os/unix/shared_mem.c line 56
void * sysv_shared_mem_attach(struct ci_shared_mem_id *id)
{
  id->mem=shmat(id->_anon0.sysv.id, (void *)0, 0);
  if(id->mem == (void *)-1)
    return (void *)0;

  else
    return id->mem;
}

// sysv_shared_mem_create
// file os/unix/shared_mem.c line 40
void * sysv_shared_mem_create(struct ci_shared_mem_id *id, const char *name, signed int size)
{
  id->_anon0.sysv.id=shmget((signed int)0, (unsigned long int)size, 0600 | 01000);
  if(!(id->_anon0.sysv.id >= 0))
    return (void *)0;

  else
  {
    id->mem=shmat(id->_anon0.sysv.id, (void *)0, 0);
    if(id->mem == (void *)-1)
      return (void *)0;

    else
    {
      id->size = (unsigned long int)size;
      snprintf(id->name, (unsigned long int)64, "%s", name);
      return id->mem;
    }
  }
}

// sysv_shared_mem_destroy
// file os/unix/shared_mem.c line 73
signed int sysv_shared_mem_destroy(struct ci_shared_mem_id *id)
{
  signed int return_value_shmdt_1;
  return_value_shmdt_1=shmdt(id->mem);
  if(!(return_value_shmdt_1 >= 0))
    return 0;

  else
  {
    signed int return_value_shmctl_2;
    return_value_shmctl_2=shmctl(id->_anon0.sysv.id, 0, (struct shmid_ds *)(void *)0);
    if(!(return_value_shmctl_2 >= 0))
      return 0;

    else
      return 1;
  }
}

// sysv_shared_mem_detach
// file os/unix/shared_mem.c line 64
signed int sysv_shared_mem_detach(struct ci_shared_mem_id *id)
{
  signed int return_value_shmdt_1;
  return_value_shmdt_1=shmdt(id->mem);
  if(!(return_value_shmdt_1 >= 0))
    return 0;

  else
    return 1;
}

// sysv_shared_mem_print_info
// file os/unix/shared_mem.c line 84
signed int sysv_shared_mem_print_info(struct ci_shared_mem_id *id, char *buf, unsigned long int buf_size)
{
  signed int return_value_snprintf_1;
  return_value_snprintf_1=snprintf(buf, buf_size, "sysv:%s/%d %ld kbs", (const void *)id->name, id->_anon0.sysv.id, (signed long int)(id->size / (unsigned long int)1024));
  return return_value_snprintf_1;
}

// templateExpired
// file txtTemplate.c line 109
static signed int templateExpired(struct anonymous_22 *template)
{
  char path[4096l];
  struct stat file;
  signed long int current_time;
  time(&current_time);
  if(current_time + -template->loaded >= (signed long int)TEMPLATE_RELOAD_TIME)
  {
    makeTemplatePathFileName(path, 4096, template->SERVICE_NAME, template->TEMPLATE_NAME, template->LANGUAGE);
    signed int return_value_stat64_1;
    return_value_stat64_1=stat64(path, &file);
    if(!(return_value_stat64_1 >= 0))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Can not found the text template file %s!", (const void *)path);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Can not found the text template file %s!", (const void *)path);

      }

      return 0;
    }

    if(!(template->modified >= file.st_mtim.tv_sec))
    {
      if(CI_DEBUG_LEVEL >= 4)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "templateFind: found: %s, %s, %s updated on disk, expired.\n", template->SERVICE_NAME, template->LANGUAGE, template->TEMPLATE_NAME);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("templateFind: found: %s, %s, %s updated on disk, expired.\n", template->SERVICE_NAME, template->LANGUAGE, template->TEMPLATE_NAME);

      }

      return 1;
    }

  }

  return 0;
}

// templateFind
// file txtTemplate.c line 208
static struct anonymous_22 * templateFind(const char *SERVICE_NAME, const char *TEMPLATE_NAME, const char *LANGUAGE)
{
  signed int i = 0;
  i = 0;
  signed int return_value_strcmp_2;
  signed int return_value_strcmp_1;
  for( ; !(i >= TEMPLATE_CACHE_SIZE); i = i + 1)
    if(!((templates + (signed long int)i)->data == ((struct ci_membuf *)NULL)))
    {
      if((templates + (signed long int)i)->must_free == 0)
      {
        signed int return_value_strcmp_3;
        return_value_strcmp_3=strcmp((templates + (signed long int)i)->SERVICE_NAME, SERVICE_NAME);
        if(return_value_strcmp_3 == 0)
        {
          return_value_strcmp_2=strcmp((templates + (signed long int)i)->TEMPLATE_NAME, TEMPLATE_NAME);
          if(return_value_strcmp_2 == 0)
          {
            return_value_strcmp_1=strcmp((templates + (signed long int)i)->LANGUAGE, LANGUAGE);
            if(return_value_strcmp_1 == 0)
            {
              if(CI_DEBUG_LEVEL >= 4)
              {
                if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                  __log_error((void *)0, "templateFind: found: %s, %s, %s in cache at index %d\n", SERVICE_NAME, LANGUAGE, TEMPLATE_NAME, i);

                if(!(CI_DEBUG_STDOUT == 0))
                  printf("templateFind: found: %s, %s, %s in cache at index %d\n", SERVICE_NAME, LANGUAGE, TEMPLATE_NAME, i);

              }

              return &templates[(signed long int)i];
            }

          }

        }

      }

    }

  return (struct anonymous_22 *)(void *)0;
}

// templateFindFree
// file txtTemplate.c line 228
static struct anonymous_22 * templateFindFree(void)
{
  signed long int oldest = (signed long int)0;
  struct anonymous_22 *useme = (struct anonymous_22 *)(void *)0;
  signed int i = 0;
  i = 0;
  for( ; !(i >= TEMPLATE_CACHE_SIZE); i = i + 1)
    if((templates + (signed long int)i)->data == ((struct ci_membuf *)NULL))
      return &templates[(signed long int)i];

  i = 0;
  for( ; !(i >= TEMPLATE_CACHE_SIZE); i = i + 1)
    if(!((templates + (signed long int)i)->last_used >= oldest))
    {
      if(!((templates + (signed long int)i)->locked >= 1))
      {
        oldest = (templates + (signed long int)i)->last_used;
        useme = &templates[(signed long int)i];
      }

    }

  if(!(useme == ((struct anonymous_22 *)NULL)))
  {
    if(!(useme->data == ((struct ci_membuf *)NULL)))
      templateFree(useme);

  }

  return useme;
}

// templateFree
// file txtTemplate.c line 136
static void templateFree(struct anonymous_22 *template)
{
  /* assertion template != ((void *)0) */
  assert(template != (struct anonymous_22 *)(void *)0);
  if(!(template->data == ((struct ci_membuf *)NULL)))
  {
    if(!(template->TEMPLATE_NAME == ((char *)NULL)))
      free((void *)template->TEMPLATE_NAME);

    if(!(template->SERVICE_NAME == ((char *)NULL)))
      free((void *)template->SERVICE_NAME);

    if(!(template->LANGUAGE == ((char *)NULL)))
      free((void *)template->LANGUAGE);

    template->LANGUAGE = (char *)(void *)0;
    template->SERVICE_NAME = template->LANGUAGE;
    template->TEMPLATE_NAME = template->SERVICE_NAME;
    ci_membuf_free(template->data);
    template->data = (struct ci_membuf *)(void *)0;
  }

}

// templateLoadText
// file txtTemplate.c line 347
static struct anonymous_22 * templateLoadText(const struct ci_request *req, const char *service_name, const char *page_name)
{
  const char *acceptLangHeader;
  const char *s;
  char preferred[32l];
  signed int i;
  struct anonymous_22 *template = (struct anonymous_22 *)(void *)0;
  acceptLangHeader=ci_http_request_get_header((struct ci_request *)req, "Accept-Language");
  const unsigned short int **return_value___ctype_b_loc_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_5;
  const unsigned short int **return_value___ctype_b_loc_4;
  if(!(acceptLangHeader == ((const char *)NULL)))
  {
    s = acceptLangHeader;
    if(CI_DEBUG_LEVEL >= 4)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "templateLoadText: Languages are: '%s'\n", s);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("templateLoadText: Languages are: '%s'\n", s);

    }

    while(!((signed int)*s == 0))
    {
      for( ; !((signed int)*s == 0); s = s + 1l)
      {
        return_value___ctype_b_loc_1=__ctype_b_loc();
        if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)*s]) == 0)
          break;

      }
      i = 0;
      do
      {
        if(!((signed int)*s == 0))
          tmp_if_expr_2 = (signed int)*s != 44 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_2 = (_Bool)0;
        if(tmp_if_expr_2)
          tmp_if_expr_3 = (signed int)*s != 59 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_3 = (_Bool)0;
        if(tmp_if_expr_3)
        {
          return_value___ctype_b_loc_4=__ctype_b_loc();
          tmp_if_expr_5 = !(((signed int)(*return_value___ctype_b_loc_4)[(signed long int)(signed int)*s] & (signed int)(unsigned short int)8192) != 0) ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_5 = (_Bool)0;
        if((unsigned long int)i >= 31ul || !tmp_if_expr_5)
          break;

        preferred[(signed long int)i] = *s;
        i = i + 1;
        s = s + 1l;
      }
      while((_Bool)1);
      preferred[(signed long int)i] = (char)0;
      if(CI_DEBUG_LEVEL >= 6)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Try load the error message on language:%s\n", (const void *)preferred);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Try load the error message on language:%s\n", (const void *)preferred);

      }

      template=templateTryLoadText(req, service_name, page_name, preferred);
      if(!(template == ((struct anonymous_22 *)NULL)))
        return template;

      for( ; !((signed int)*s == 0); s = s + 1l)
        if((signed int)*s == 44)
          break;

      if((signed int)*s == 44)
        s = s + 1l;

    }
  }

  if(CI_DEBUG_LEVEL >= 4)
  {
    if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
      __log_error((void *)0, "templateLoadText: Accept-Language header not found or was empty!\n");

    if(!(CI_DEBUG_STDOUT == 0))
      printf("templateLoadText: Accept-Language header not found or was empty!\n");

  }

  struct anonymous_22 *return_value_templateTryLoadText_6;
  return_value_templateTryLoadText_6=templateTryLoadText(req, service_name, page_name, TEMPLATE_DEF_LANG);
  return return_value_templateTryLoadText_6;
}

// templateTryLoadText
// file txtTemplate.c line 251
static struct anonymous_22 * templateTryLoadText(const struct ci_request *req, const char *service_name, const char *page_name, const char *lang)
{
  signed int fd;
  char path[4096l];
  char buf[4096l];
  struct stat file;
  signed long int len;
  struct ci_membuf *textbuff = (struct ci_membuf *)(void *)0;
  struct anonymous_22 *tempTemplate = (struct anonymous_22 *)(void *)0;
  signed long int current_time;
  time(&current_time);
  pthread_mutex_lock(&templates_mutex);
  tempTemplate=templateFind(service_name, page_name, lang);
  signed int *return_value___errno_location_1;
  char *return_value_strerror_2;
  signed int *return_value___errno_location_3;
  char *return_value_strerror_4;
  signed int *return_value___errno_location_5;
  char *return_value_strerror_6;
  signed int *return_value___errno_location_7;
  char *return_value_strerror_8;
  if(!(tempTemplate == ((struct anonymous_22 *)NULL)))
  {
    tempTemplate->last_used = current_time;
    tempTemplate->locked = tempTemplate->locked + 1;
    pthread_mutex_unlock(&templates_mutex);
    return tempTemplate;
  }

  else
  {
    pthread_mutex_unlock(&templates_mutex);
    makeTemplatePathFileName(path, 4096, service_name, page_name, lang);
    if(CI_DEBUG_LEVEL >= 9)
    {
      if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        __log_error((void *)0, "templateTryLoadText: %s\n", (const void *)path);

      if(!(CI_DEBUG_STDOUT == 0))
        printf("templateTryLoadText: %s\n", (const void *)path);

    }

    fd=open64(path, 00);
    if(!(fd >= 0))
    {
      if(CI_DEBUG_LEVEL >= 4)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
        {
          return_value___errno_location_1=__errno_location();
          return_value_strerror_2=strerror(*return_value___errno_location_1);
          __log_error((void *)0, "templateTryLoadText: '%s': %s\n", (const void *)path, return_value_strerror_2);
        }

        if(!(CI_DEBUG_STDOUT == 0))
        {
          return_value___errno_location_3=__errno_location();
          return_value_strerror_4=strerror(*return_value___errno_location_3);
          printf("templateTryLoadText: '%s': %s\n", (const void *)path, return_value_strerror_4);
        }

      }

      return (struct anonymous_22 *)(void *)0;
    }

    else
    {
      fstat64(fd, &file);
      textbuff=ci_membuf_new_sized((signed int)(file.st_size + (signed long int)1));
      if(textbuff == ((struct ci_membuf *)NULL))
      {
        if(CI_DEBUG_LEVEL >= 1)
        {
          if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            __log_error((void *)0, "templateTryLoadText: membuf allocation failed!\n");

          if(!(CI_DEBUG_STDOUT == 0))
            printf("templateTryLoadText: membuf allocation failed!\n");

        }

        return (struct anonymous_22 *)(void *)0;
      }

      else
      {
        do
        {
          len=read(fd, (void *)buf, sizeof(char [4096l]) /*4096ul*/ );
          if(!(len >= 1l))
            break;

          ci_membuf_write(textbuff, buf, (signed int)len, 0);
        }
        while((_Bool)1);
        close(fd);
        if(!(len >= 0l))
        {
          if(CI_DEBUG_LEVEL >= 4)
          {
            if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
            {
              return_value___errno_location_5=__errno_location();
              return_value_strerror_6=strerror(*return_value___errno_location_5);
              __log_error((void *)0, "templateTryLoadText: failed to fully read: '%s': %s\n", (const void *)path, return_value_strerror_6);
            }

            if(!(CI_DEBUG_STDOUT == 0))
            {
              return_value___errno_location_7=__errno_location();
              return_value_strerror_8=strerror(*return_value___errno_location_7);
              printf("templateTryLoadText: failed to fully read: '%s': %s\n", (const void *)path, return_value_strerror_8);
            }

          }

          ci_membuf_free(textbuff);
          return (struct anonymous_22 *)(void *)0;
        }

        else
        {
          ci_membuf_write(textbuff, "\0", 1, 1);
          pthread_mutex_lock(&templates_mutex);
          tempTemplate=templateFindFree();
          if(!(tempTemplate == ((struct anonymous_22 *)NULL)))
          {
            tempTemplate->locked = tempTemplate->locked + 1;
            tempTemplate->non_cached = 0;
          }

          else
          {
            if(CI_DEBUG_LEVEL >= 4)
            {
              if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                __log_error((void *)0, "templateTryLoadText: Unable to find free template slot.\n");

              if(!(CI_DEBUG_STDOUT == 0))
                printf("templateTryLoadText: Unable to find free template slot.\n");

            }

            void *return_value_malloc_9;
            return_value_malloc_9=malloc(sizeof(struct anonymous_22) /*72ul*/ );
            tempTemplate = (struct anonymous_22 *)return_value_malloc_9;
            if(tempTemplate == ((struct anonymous_22 *)NULL))
            {
              if(CI_DEBUG_LEVEL >= 1)
              {
                if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
                  __log_error((void *)0, "templateTryLoadText: memory allocation error!\n");

                if(!(CI_DEBUG_STDOUT == 0))
                  printf("templateTryLoadText: memory allocation error!\n");

              }

              pthread_mutex_unlock(&templates_mutex);
              ci_membuf_free(textbuff);
              return (struct anonymous_22 *)(void *)0;
            }

            tempTemplate->non_cached = 1;
          }
          tempTemplate->SERVICE_NAME=strdup(service_name);
          tempTemplate->TEMPLATE_NAME=strdup(page_name);
          tempTemplate->LANGUAGE=strdup(lang);
          tempTemplate->data = textbuff;
          tempTemplate->loaded = current_time;
          tempTemplate->modified = file.st_mtim.tv_sec;
          tempTemplate->last_used = current_time;
          tempTemplate->must_free = 0;
          pthread_mutex_unlock(&templates_mutex);
          return tempTemplate;
        }
      }
    }
  }
}

// template_release
// file txtTemplate.c line 152
static void template_release(struct anonymous_22 *template)
{
  signed int must_free = 0;
  signed int return_value_templateExpired_1;
  if(!(template == ((struct anonymous_22 *)NULL)))
  {
    if(!(template->non_cached == 0))
    {
      templateFree(template);
      free((void *)template);
    }

    else
    {
      _Bool tmp_if_expr_2;
      if(!(template->must_free == 0))
        tmp_if_expr_2 = (_Bool)1;

      else
      {
        return_value_templateExpired_1=templateExpired(template);
        tmp_if_expr_2 = return_value_templateExpired_1 != 0 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_2)
        must_free = 1;

      pthread_mutex_lock(&templates_mutex);
      template->locked = template->locked - 1;
      if(!(template->locked >= 0))
        template->locked = 0;

      _Bool tmp_if_expr_3;
      if(!(must_free == 0))
        tmp_if_expr_3 = template->locked == 0 ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_3 = (_Bool)0;
      if(tmp_if_expr_3)
        templateFree(template);

      else
        template->must_free = must_free;
      pthread_mutex_unlock(&templates_mutex);
    }
  }

}

// types_add
// file filetype.c line 86
signed int types_add(struct ci_magics_db *db, const char *name, const char *descr, signed int *groups)
{
  struct ci_data_type *newdata;
  signed int indx;
  signed int i;
  if(db->types_num >= db->types_size)
  {
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)db->types, (unsigned long int)(db->types_size + 50) * sizeof(struct ci_data_type) /*324ul*/ );
    newdata = (struct ci_data_type *)return_value_realloc_1;
    if(newdata == ((struct ci_data_type *)NULL))
      return -1;

    db->types_size = db->types_size + 50;
    db->types = newdata;
  }

  indx = db->types_num;
  db->types_num = db->types_num + 1;
  strcpy((db->types + (signed long int)indx)->name, name);
  strcpy((db->types + (signed long int)indx)->descr, descr);
  i = 0;
  for( ; groups[(signed long int)i] >= 0; i = i + 1)
  {
    if(i >= 64)
      break;

    (db->types + (signed long int)indx)->groups[(signed long int)i] = groups[(signed long int)i];
  }
  (db->types + (signed long int)indx)->groups[(signed long int)i] = -1;
  return indx;
}

// types_init
// file filetype.c line 81
signed int types_init(struct ci_magics_db *db)
{
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)50 * sizeof(struct ci_data_type) /*324ul*/ );
  db->types = (struct ci_data_type *)return_value_malloc_1;
  if(db->types == ((struct ci_data_type *)NULL))
    return 0;

  else
  {
    db->types_num = 0;
    db->types_size = 50;
    return 1;
  }
}

// uint64_cmp
// file types_ops.c line 183
signed int uint64_cmp(const void *key1, const void *key2)
{
  unsigned long int k1;
  unsigned long int k2;
  k1 = *((unsigned long int *)key1);
  k2 = *((unsigned long int *)key2);
  if(!(k1 >= k2))
    return -1;

  else
    if(!(k2 >= k1))
      return 1;

    else
      return 0;
}

// uint64_dup
// file types_ops.c line 166
void * uint64_dup(const char *str, struct ci_mem_allocator *allocator)
{
  unsigned long int *i;
  char *e = (char *)(void *)0;
  void *return_value;
  return_value=allocator->alloc(allocator, sizeof(unsigned long int) /*8ul*/ );
  i = (unsigned long int *)return_value;
  if(!(i == ((unsigned long int *)NULL)))
  {
    signed long long int return_value_strtoll_1;
    return_value_strtoll_1=strtoll(str, &e, 10);
    *i = (unsigned long int)return_value_strtoll_1;
    _Bool tmp_if_expr_4;
    if((signed int)*e == 75)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = (signed int)*e == 107 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      *i = *i * (unsigned long int)1000;

    else
    {
      _Bool tmp_if_expr_3;
      if((signed int)*e == 77)
        tmp_if_expr_3 = (_Bool)1;

      else
        tmp_if_expr_3 = (signed int)*e == 109 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_3)
        *i = *i * (unsigned long int)1000000;

      else
      {
        _Bool tmp_if_expr_2;
        if((signed int)*e == 71)
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = (signed int)*e == 103 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_2)
          *i = *i * (unsigned long int)1000000000;

      }
    }
  }

  return (void *)i;
}

// uint64_equal
// file types_ops.c line 196
signed int uint64_equal(const void *key1, const void *key2)
{
  unsigned long int k1;
  unsigned long int k2;
  k1 = *((unsigned long int *)key1);
  k2 = *((unsigned long int *)key2);
  return (signed int)(k1 == k2);
}

// uint64_free
// file types_ops.c line 204
void uint64_free(void *key, struct ci_mem_allocator *allocator)
{
  allocator->free(allocator, key);
}

// uint64_len
// file types_ops.c line 209
unsigned long int uint64_len(const void *key)
{
  return (unsigned long int)sizeof(unsigned long int) /*8ul*/ ;
}

// url_decoder
// file decode.c line 131
signed int url_decoder(const char *input, char *output, signed int output_len)
{
  signed int i;
  signed int k;
  char str[3l];
  i = 0;
  k = 0;
  for( ; !((signed int)input[(signed long int)i] == 0); k = k + 1)
  {
    if(k >= output_len + -1)
      break;

    if((signed int)input[(signed long int)i] == 37)
    {
      str[(signed long int)0] = input[(signed long int)(i + 1)];
      str[(signed long int)1] = input[(signed long int)(i + 2)];
      str[(signed long int)2] = (char)0;
      signed long int return_value_strtol_1;
      return_value_strtol_1=strtol(str, (char ** restrict )(void *)0, 16);
      output[(signed long int)k] = (char)return_value_strtol_1;
      i = i + 3;
    }

    else
      if((signed int)input[(signed long int)i] == 43)
      {
        output[(signed long int)k] = (char)32;
        i = i + 1;
      }

      else
      {
        output[(signed long int)k] = input[(signed long int)i];
        i = i + 1;
      }
  }
  output[(signed long int)k] = (char)0;
  if(k == output_len + -1)
    return -1;

  else
    return 1;
}

// url_decoder2
// file decode.c line 164
signed int url_decoder2(char *input)
{
  signed int i;
  signed int k;
  char str[3l];
  i = 0;
  k = 0;
  for( ; !((signed int)input[(signed long int)i] == 0); k = k + 1)
    if((signed int)input[(signed long int)i] == 37)
    {
      str[(signed long int)0] = input[(signed long int)(i + 1)];
      str[(signed long int)1] = input[(signed long int)(i + 2)];
      str[(signed long int)2] = (char)0;
      signed long int return_value_strtol_1;
      return_value_strtol_1=strtol(str, (char ** restrict )(void *)0, 16);
      input[(signed long int)k] = (char)return_value_strtol_1;
      i = i + 3;
    }

    else
      if((signed int)input[(signed long int)i] == 43)
      {
        input[(signed long int)k] = (char)32;
        i = i + 1;
      }

      else
      {
        input[(signed long int)k] = input[(signed long int)i];
        i = i + 1;
      }
  input[(signed long int)k] = (char)0;
  return 1;
}

// vlog_errors
// file c-icap-mkbdb.c line 323
void vlog_errors(void *unused, const char *format, void **ap)
{
  vfprintf(stderr, format, ap);
}

// zlib_inflate
// file decode.c line 208
static signed int zlib_inflate(const char *buf, signed int len, char *unzipped_buf, signed int *unzipped_buf_len)
{
  signed int ret;
  signed int retriable;
  struct z_stream_s strm;
  strm.zalloc = alloc_a_buffer;
  strm.zfree = free_a_buffer;
  strm.opaque = NULL;
  strm.avail_in = (unsigned int)0;
  strm.next_in = ((unsigned char *)NULL);
  ret=inflateInit2_(&strm, 32 + 15, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
  retriable = 1;

zlib_inflate_retry:
  ;
  for( ; (_Bool)1; retriable = 0)
  {
    if(!(ret == 0))
    {
      if(CI_DEBUG_LEVEL >= 1)
      {
        if(!(__log_error == ((void (*)(void *, const char *, ...))NULL)))
          __log_error((void *)0, "Error initializing  zlib (inflateInit2 return:%d)\n", ret);

        if(!(CI_DEBUG_STDOUT == 0))
          printf("Error initializing  zlib (inflateInit2 return:%d)\n", ret);

      }

      return -1;
    }

    strm.next_in = (unsigned char *)buf;
    strm.avail_in = (unsigned int)len;
    strm.avail_out = (unsigned int)*unzipped_buf_len;
    strm.next_out = (unsigned char *)unzipped_buf;
    ret=inflate(&strm, 0);
    inflateEnd(&strm);
    if(!(ret == 2) && !(ret == -3))
    {
      if(ret == -4)
        break;

      goto __CPROVER_DUMP_L7;
    }

    if(retriable == 0)
      break;

    ret=inflateInit2_(&strm, -15, "1.2.8", (signed int)sizeof(struct z_stream_s) /*112ul*/ );
  }
  return -1;

__CPROVER_DUMP_L7:
  ;
  if((unsigned int)*unzipped_buf_len == strm.avail_out)
  {
    if(ret == 1)
      goto __CPROVER_DUMP_L8;

    return -1;
  }

  else
  {

  __CPROVER_DUMP_L8:
    ;
    *unzipped_buf_len = (signed int)((unsigned int)*unzipped_buf_len - strm.avail_out);
    return 1;
  }
}

