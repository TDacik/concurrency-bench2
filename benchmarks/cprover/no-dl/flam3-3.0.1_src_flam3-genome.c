// #anon_enum_JCS_UNKNOWN=0_JCS_GRAYSCALE=1_JCS_RGB=2_JCS_YCbCr=3_JCS_CMYK=4_JCS_YCCK=5_JCS_EXT_RGB=6_JCS_EXT_RGBX=7_JCS_EXT_BGR=8_JCS_EXT_BGRX=9_JCS_EXT_XBGR=10_JCS_EXT_XRGB=11_JCS_EXT_RGBA=12_JCS_EXT_BGRA=13_JCS_EXT_ABGR=14_JCS_EXT_ARGB=15_JCS_RGB565=16
// file /usr/include/jpeglib.h line 215
enum anonymous_20 { JCS_UNKNOWN=0, JCS_GRAYSCALE=1, JCS_RGB=2, JCS_YCbCr=3, JCS_CMYK=4, JCS_YCCK=5, JCS_EXT_RGB=6, JCS_EXT_RGBX=7, JCS_EXT_BGR=8, JCS_EXT_BGRX=9, JCS_EXT_XBGR=10, JCS_EXT_XRGB=11, JCS_EXT_RGBA=12, JCS_EXT_BGRA=13, JCS_EXT_ABGR=14, JCS_EXT_ARGB=15, JCS_RGB565=16 };

// #anon_enum_JDCT_ISLOW=0_JDCT_IFAST=1_JDCT_FLOAT=2
// file /usr/include/jpeglib.h line 244
enum anonymous_21 { JDCT_ISLOW=0, JDCT_IFAST=1, JDCT_FLOAT=2 };

// #anon_enum_JDITHER_NONE=0_JDITHER_ORDERED=1_JDITHER_FS=2
// file /usr/include/jpeglib.h line 259
enum anonymous_22 { JDITHER_NONE=0, JDITHER_ORDERED=1, JDITHER_FS=2 };

// #anon_enum_XML_ATTRIBUTE_CDATA=1_XML_ATTRIBUTE_ID=2_XML_ATTRIBUTE_IDREF=3_XML_ATTRIBUTE_IDREFS=4_XML_ATTRIBUTE_ENTITY=5_XML_ATTRIBUTE_ENTITIES=6_XML_ATTRIBUTE_NMTOKEN=7_XML_ATTRIBUTE_NMTOKENS=8_XML_ATTRIBUTE_ENUMERATION=9_XML_ATTRIBUTE_NOTATION=10
// file /usr/include/libxml2/libxml/tree.h line 206
enum anonymous_5 { XML_ATTRIBUTE_CDATA=1, XML_ATTRIBUTE_ID=2, XML_ATTRIBUTE_IDREF=3, XML_ATTRIBUTE_IDREFS=4, XML_ATTRIBUTE_ENTITY=5, XML_ATTRIBUTE_ENTITIES=6, XML_ATTRIBUTE_NMTOKEN=7, XML_ATTRIBUTE_NMTOKENS=8, XML_ATTRIBUTE_ENUMERATION=9, XML_ATTRIBUTE_NOTATION=10 };

// #anon_enum_XML_ELEMENT_NODE=1_XML_ATTRIBUTE_NODE=2_XML_TEXT_NODE=3_XML_CDATA_SECTION_NODE=4_XML_ENTITY_REF_NODE=5_XML_ENTITY_NODE=6_XML_PI_NODE=7_XML_COMMENT_NODE=8_XML_DOCUMENT_NODE=9_XML_DOCUMENT_TYPE_NODE=10_XML_DOCUMENT_FRAG_NODE=11_XML_NOTATION_NODE=12_XML_HTML_DOCUMENT_NODE=13_XML_DTD_NODE=14_XML_ELEMENT_DECL=15_XML_ATTRIBUTE_DECL=16_XML_ENTITY_DECL=17_XML_NAMESPACE_DECL=18_XML_XINCLUDE_START=19_XML_XINCLUDE_END=20_XML_DOCB_DOCUMENT_NODE=21
// file /usr/include/libxml2/libxml/tree.h line 159
enum anonymous_2 { XML_ELEMENT_NODE=1, XML_ATTRIBUTE_NODE=2, XML_TEXT_NODE=3, XML_CDATA_SECTION_NODE=4, XML_ENTITY_REF_NODE=5, XML_ENTITY_NODE=6, XML_PI_NODE=7, XML_COMMENT_NODE=8, XML_DOCUMENT_NODE=9, XML_DOCUMENT_TYPE_NODE=10, XML_DOCUMENT_FRAG_NODE=11, XML_NOTATION_NODE=12, XML_HTML_DOCUMENT_NODE=13, XML_DTD_NODE=14, XML_ELEMENT_DECL=15, XML_ATTRIBUTE_DECL=16, XML_ENTITY_DECL=17, XML_NAMESPACE_DECL=18, XML_XINCLUDE_START=19, XML_XINCLUDE_END=20, XML_DOCB_DOCUMENT_NODE=21 };

// tag-#anon#ST[*{ARR5{F64}_F64_}_ARR5{F64}_F64__'b'||*{ARR4{F64}_F64_}_ARR4{F64}_F64__'accumulate'||S32'width'||S32'height'||S32'oversample'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'max_filtered_counts'||S32'max_filter_index'||S32'kernel_size'||U32'_pad0'||*{F64}_F64_'filter_widths'||*{F64}_F64_'filter_coefs'|]#}_SYM#tag-#anon#ST[S32'max_filtered_counts'||S32'max_filter_index'||S32'kernel_size'||U32'_pad0'||*{F64}_F64_'filter_widths'||*{F64}_F64_'filter_coefs'|]#_'de'||F64'k1'||F64'k2'||F64'curve'||S32'last_thread'||S32'start_row'||S32'end_row'||U32'_pad1'||*{SYM#tag-#anon#ST[F64'pixel_aspect_ratio'||*{SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#}_SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#_'genomes'||S32'ngenomes'||S32'verbose'||S32'bits'||S32'bytes_per_channel'||S32'earlyclip'||U32'_pad0'||F64'time'||*{S32(*{V}_V_|F64|S32|F64)->S32}_S32(*{V}_V_|F64|S32|F64)->S32_'progress'||*{V}_V_'progress_parameter'||SYM#tag-randctx#'rc'||S32'nthreads'||S32'sub_batch_size'|]#}_SYM#tag-#anon#ST[F64'pixel_aspect_ratio'||*{SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#}_SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#_'genomes'||S32'ngenomes'||S32'verbose'||S32'bits'||S32'bytes_per_channel'||S32'earlyclip'||U32'_pad0'||F64'time'||*{S32(*{V}_V_|F64|S32|F64)->S32}_S32(*{V}_V_|F64|S32|F64)->S32_'progress'||*{V}_V_'progress_parameter'||SYM#tag-randctx#'rc'||S32'nthreads'||S32'sub_batch_size'|]#_'spec'||*{S32}_S32_'aborted'||S32'progress_size'||U32'_pad2'|]
// file rect.c line 41
struct anonymous_15;

// tag-#anon#ST[*{ARR5{U32}_U32_}_ARR5{U32}_U32__'b'||*{ARR4{F32}_F32_}_ARR4{F32}_F32__'accumulate'||S32'width'||S32'height'||S32'oversample'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'max_filtered_counts'||S32'max_filter_index'||S32'kernel_size'||U32'_pad0'||*{F64}_F64_'filter_widths'||*{F64}_F64_'filter_coefs'|]#}_SYM#tag-#anon#ST[S32'max_filtered_counts'||S32'max_filter_index'||S32'kernel_size'||U32'_pad0'||*{F64}_F64_'filter_widths'||*{F64}_F64_'filter_coefs'|]#_'de'||F64'k1'||F64'k2'||F64'curve'||S32'last_thread'||S32'start_row'||S32'end_row'||U32'_pad1'||*{SYM#tag-#anon#ST[F64'pixel_aspect_ratio'||*{SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#}_SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#_'genomes'||S32'ngenomes'||S32'verbose'||S32'bits'||S32'bytes_per_channel'||S32'earlyclip'||U32'_pad0'||F64'time'||*{S32(*{V}_V_|F64|S32|F64)->S32}_S32(*{V}_V_|F64|S32|F64)->S32_'progress'||*{V}_V_'progress_parameter'||SYM#tag-randctx#'rc'||S32'nthreads'||S32'sub_batch_size'|]#}_SYM#tag-#anon#ST[F64'pixel_aspect_ratio'||*{SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#}_SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#_'genomes'||S32'ngenomes'||S32'verbose'||S32'bits'||S32'bytes_per_channel'||S32'earlyclip'||U32'_pad0'||F64'time'||*{S32(*{V}_V_|F64|S32|F64)->S32}_S32(*{V}_V_|F64|S32|F64)->S32_'progress'||*{V}_V_'progress_parameter'||SYM#tag-randctx#'rc'||S32'nthreads'||S32'sub_batch_size'|]#_'spec'||*{S32}_S32_'aborted'||S32'progress_size'||U32'_pad2'|]
// file rect.c line 41
struct anonymous_17;

// tag-#anon#ST[*{ARR5{U32}_U32_}_ARR5{U32}_U32__'b'||*{ARR4{U32}_U32_}_ARR4{U32}_U32__'accumulate'||S32'width'||S32'height'||S32'oversample'||U32'_pad0'||*{SYM#tag-#anon#ST[S32'max_filtered_counts'||S32'max_filter_index'||S32'kernel_size'||U32'_pad0'||*{F64}_F64_'filter_widths'||*{F64}_F64_'filter_coefs'|]#}_SYM#tag-#anon#ST[S32'max_filtered_counts'||S32'max_filter_index'||S32'kernel_size'||U32'_pad0'||*{F64}_F64_'filter_widths'||*{F64}_F64_'filter_coefs'|]#_'de'||F64'k1'||F64'k2'||F64'curve'||S32'last_thread'||S32'start_row'||S32'end_row'||U32'_pad1'||*{SYM#tag-#anon#ST[F64'pixel_aspect_ratio'||*{SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#}_SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#_'genomes'||S32'ngenomes'||S32'verbose'||S32'bits'||S32'bytes_per_channel'||S32'earlyclip'||U32'_pad0'||F64'time'||*{S32(*{V}_V_|F64|S32|F64)->S32}_S32(*{V}_V_|F64|S32|F64)->S32_'progress'||*{V}_V_'progress_parameter'||SYM#tag-randctx#'rc'||S32'nthreads'||S32'sub_batch_size'|]#}_SYM#tag-#anon#ST[F64'pixel_aspect_ratio'||*{SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#}_SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#_'genomes'||S32'ngenomes'||S32'verbose'||S32'bits'||S32'bytes_per_channel'||S32'earlyclip'||U32'_pad0'||F64'time'||*{S32(*{V}_V_|F64|S32|F64)->S32}_S32(*{V}_V_|F64|S32|F64)->S32_'progress'||*{V}_V_'progress_parameter'||SYM#tag-randctx#'rc'||S32'nthreads'||S32'sub_batch_size'|]#_'spec'||*{S32}_S32_'aborted'||S32'progress_size'||U32'_pad2'|]
// file rect.c line 41
struct anonymous_16;

// tag-#anon#ST[*{F64}_F64_'iter_storage'||SYM#tag-randctx#'rc'||SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#'cp'||S32'first_thread'||S32'timer_initialize'||*{SYM#tag-#anon#ST[*{U16}_U16_'xform_distrib'||*{SYM#tag-#anon#ST[F64'pixel_aspect_ratio'||*{SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#}_SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#_'genomes'||S32'ngenomes'||S32'verbose'||S32'bits'||S32'bytes_per_channel'||S32'earlyclip'||U32'_pad0'||F64'time'||*{S32(*{V}_V_|F64|S32|F64)->S32}_S32(*{V}_V_|F64|S32|F64)->S32_'progress'||*{V}_V_'progress_parameter'||SYM#tag-randctx#'rc'||S32'nthreads'||S32'sub_batch_size'|]#}_SYM#tag-#anon#ST[F64'pixel_aspect_ratio'||*{SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#}_SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#_'genomes'||S32'ngenomes'||S32'verbose'||S32'bits'||S32'bytes_per_channel'||S32'earlyclip'||U32'_pad0'||F64'time'||*{S32(*{V}_V_|F64|S32|F64)->S32}_S32(*{V}_V_|F64|S32|F64)->S32_'progress'||*{V}_V_'progress_parameter'||SYM#tag-randctx#'rc'||S32'nthreads'||S32'sub_batch_size'|]#_'spec'||ARR4{F64}_F64_'bounds'||ARR2{ARR2{F64}_F64_}_ARR2{F64}_F64__'rot'||ARR2{F64}_F64_'size'||S32'width'||S32'height'||F64'ws0'||F64'wb0s0'||F64'hs1'||F64'hb1s1'||*{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'dmap'||F64'color_scalar'||*{V}_V_'buckets'||F64'badvals'||F64'batch_size'||S32'temporal_sample_num'||S32'ntemporal_samples'||S32'batch_num'||S32'nbatches'||S32'aborted'||U32'_pad0'||*{S64}_S64_'progress_timer'||*{S64}_S64_'progress_timer_history'||*{F64}_F64_'progress_history'||*{S32}_S32_'progress_history_mark'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'bucket_mutex'|]#}_SYM#tag-#anon#ST[*{U16}_U16_'xform_distrib'||*{SYM#tag-#anon#ST[F64'pixel_aspect_ratio'||*{SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#}_SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#_'genomes'||S32'ngenomes'||S32'verbose'||S32'bits'||S32'bytes_per_channel'||S32'earlyclip'||U32'_pad0'||F64'time'||*{S32(*{V}_V_|F64|S32|F64)->S32}_S32(*{V}_V_|F64|S32|F64)->S32_'progress'||*{V}_V_'progress_parameter'||SYM#tag-randctx#'rc'||S32'nthreads'||S32'sub_batch_size'|]#}_SYM#tag-#anon#ST[F64'pixel_aspect_ratio'||*{SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#}_SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#_'genomes'||S32'ngenomes'||S32'verbose'||S32'bits'||S32'bytes_per_channel'||S32'earlyclip'||U32'_pad0'||F64'time'||*{S32(*{V}_V_|F64|S32|F64)->S32}_S32(*{V}_V_|F64|S32|F64)->S32_'progress'||*{V}_V_'progress_parameter'||SYM#tag-randctx#'rc'||S32'nthreads'||S32'sub_batch_size'|]#_'spec'||ARR4{F64}_F64_'bounds'||ARR2{ARR2{F64}_F64_}_ARR2{F64}_F64__'rot'||ARR2{F64}_F64_'size'||S32'width'||S32'height'||F64'ws0'||F64'wb0s0'||F64'hs1'||F64'hb1s1'||*{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'dmap'||F64'color_scalar'||*{V}_V_'buckets'||F64'badvals'||F64'batch_size'||S32'temporal_sample_num'||S32'ntemporal_samples'||S32'batch_num'||S32'nbatches'||S32'aborted'||U32'_pad0'||*{S64}_S64_'progress_timer'||*{S64}_S64_'progress_timer_history'||*{F64}_F64_'progress_history'||*{S32}_S32_'progress_history_mark'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'bucket_mutex'|]#_'fic'|]
// file private.h line 121
struct anonymous_13;

// tag-#anon#ST[*{S8}_S8_'genome'||*{S8}_S8_'badvals'||*{S8}_S8_'numiters'||*{S8}_S8_'rtime'|]
// file img.h line 29
struct anonymous_19;

// tag-#anon#ST[*{U16}_U16_'xform_distrib'||*{SYM#tag-#anon#ST[F64'pixel_aspect_ratio'||*{SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#}_SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#_'genomes'||S32'ngenomes'||S32'verbose'||S32'bits'||S32'bytes_per_channel'||S32'earlyclip'||U32'_pad0'||F64'time'||*{S32(*{V}_V_|F64|S32|F64)->S32}_S32(*{V}_V_|F64|S32|F64)->S32_'progress'||*{V}_V_'progress_parameter'||SYM#tag-randctx#'rc'||S32'nthreads'||S32'sub_batch_size'|]#}_SYM#tag-#anon#ST[F64'pixel_aspect_ratio'||*{SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#}_SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#_'genomes'||S32'ngenomes'||S32'verbose'||S32'bits'||S32'bytes_per_channel'||S32'earlyclip'||U32'_pad0'||F64'time'||*{S32(*{V}_V_|F64|S32|F64)->S32}_S32(*{V}_V_|F64|S32|F64)->S32_'progress'||*{V}_V_'progress_parameter'||SYM#tag-randctx#'rc'||S32'nthreads'||S32'sub_batch_size'|]#_'spec'||ARR4{F64}_F64_'bounds'||ARR2{ARR2{F64}_F64_}_ARR2{F64}_F64__'rot'||ARR2{F64}_F64_'size'||S32'width'||S32'height'||F64'ws0'||F64'wb0s0'||F64'hs1'||F64'hb1s1'||*{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'dmap'||F64'color_scalar'||*{V}_V_'buckets'||F64'badvals'||F64'batch_size'||S32'temporal_sample_num'||S32'ntemporal_samples'||S32'batch_num'||S32'nbatches'||S32'aborted'||U32'_pad0'||*{S64}_S64_'progress_timer'||*{S64}_S64_'progress_timer_history'||*{F64}_F64_'progress_history'||*{S32}_S32_'progress_history_mark'||SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'bucket_mutex'|]
// file private.h line 76
struct anonymous_12;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_3;

// tag-#anon#ST[ARR17{U8}_U8_'bits'||ARR256{U8}_U8_'huffval'||U24'_pad0'||S32'sent_table'|]
// file /usr/include/jpeglib.h line 101
struct anonymous_24;

// tag-#anon#ST[ARR64{U16}_U16_'quantval'||S32'sent_table'|]
// file /usr/include/jpeglib.h line 84
struct anonymous_23;

// tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]
// file flam3.h line 441
struct anonymous_0;

// tag-#anon#ST[F64'badvals'||S64'num_iters'||S32'render_seconds'||U32'_pad0'|]
// file flam3.h line 182
struct anonymous_8;

// tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]
// file flam3.h line 48
struct anonymous_1;

// tag-#anon#ST[F64'pixel_aspect_ratio'||*{SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#}_SYM#tag-#anon#ST[ARR65{S8}_S8_'flame_name'||U56'_pad0'||F64'time'||S32'interpolation'||S32'interpolation_type'||S32'palette_interpolation'||S32'num_xforms'||S32'final_xform_index'||S32'final_xform_enable'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||*{*{F64}_F64_}_*{F64}_F64__'chaos'||S32'chaos_enable'||S32'genome_index'||ARR30{S8}_S8_'parent_fname'||U16'_pad1'||S32'symmetry'||U32'_pad2'||ARR256{SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#}_SYM#tag-#anon#ST[F64'index'||ARR4{F64}_F64_'color'|]#_'palette'||*{S8}_S8_'input_image'||S32'palette_index'||U32'_pad3'||F64'brightness'||F64'contrast'||F64'gamma'||F64'highlight_power'||S32'width'||S32'height'||S32'spatial_oversample'||U32'_pad4'||ARR2{F64}_F64_'center'||ARR2{F64}_F64_'rot_center'||F64'rotate'||F64'vibrancy'||F64'hue_rotation'||ARR3{F64}_F64_'background'||F64'zoom'||F64'pixels_per_unit'||F64'spatial_filter_radius'||S32'spatial_filter_select'||U32'_pad5'||F64'sample_density'||S32'nbatches'||S32'ntemporal_samples'||F64'estimator'||F64'estimator_curve'||F64'estimator_minimum'||*{SYM#tag-_xmlDoc#}_SYM#tag-_xmlDoc#_'edits'||F64'gam_lin_thresh'||S32'palette_index0'||U32'_pad6'||F64'hue_rotation0'||S32'palette_index1'||U32'_pad7'||F64'hue_rotation1'||F64'palette_blend'||S32'temporal_filter_type'||U32'_pad8'||F64'temporal_filter_width'||F64'temporal_filter_exp'||S32'palette_mode'||U32'_pad9'|]#_'genomes'||S32'ngenomes'||S32'verbose'||S32'bits'||S32'bytes_per_channel'||S32'earlyclip'||U32'_pad0'||F64'time'||*{S32(*{V}_V_|F64|S32|F64)->S32}_S32(*{V}_V_|F64|S32|F64)->S32_'progress'||*{V}_V_'progress_parameter'||SYM#tag-randctx#'rc'||S32'nthreads'||S32'sub_batch_size'|]
// file flam3.h line 589
struct anonymous_4;

// tag-#anon#ST[F64'tx'||F64'ty'||F64'precalc_atan'||F64'precalc_sina'||F64'precalc_cosa'||F64'precalc_sqrt'||F64'precalc_sumsq'||F64'precalc_atanyx'||*{SYM#tag-xform#}_SYM#tag-xform#_'xform'||F64'p0'||F64'p1'||*{SYM#tag-randctx#}_SYM#tag-randctx#_'rc'|]
// file private.h line 102
struct anonymous_9;

// tag-#anon#ST[S32'component_id'||S32'component_index'||S32'h_samp_factor'||S32'v_samp_factor'||S32'quant_tbl_no'||S32'dc_tbl_no'||S32'ac_tbl_no'||U32'width_in_blocks'||U32'height_in_blocks'||S32'DCT_scaled_size'||U32'downsampled_width'||U32'downsampled_height'||S32'component_needed'||S32'MCU_width'||S32'MCU_height'||S32'MCU_blocks'||S32'MCU_sample_width'||S32'last_col_width'||S32'last_row_height'||U32'_pad0'||*{SYM#tag-#anon#ST[ARR64{U16}_U16_'quantval'||S32'sent_table'|]#}_SYM#tag-#anon#ST[ARR64{U16}_U16_'quantval'||S32'sent_table'|]#_'quant_table'||*{V}_V_'dct_table'|]
// file /usr/include/jpeglib.h line 117
struct anonymous_25;

// tag-#anon#ST[S32'comps_in_scan'||ARR4{S32}_S32_'component_index'||S32'Ss'||S32'Se'||S32'Ah'||S32'Al'|]
// file /usr/include/jpeglib.h line 190
struct anonymous;

// tag-#anon#ST[S32'from'||S32'to'||F64'scalar'|]
// file flam3.h line 517
struct anonymous_7;

// tag-#anon#ST[S32'max_filtered_counts'||S32'max_filter_index'||S32'kernel_size'||U32'_pad0'||*{F64}_F64_'filter_widths'||*{F64}_F64_'filter_coefs'|]
// file filters.h line 47
struct anonymous_6;

// tag-#anon#ST[S32'number'||ARR64{S8}_S8_'name'||ARR256{ARR3{U8}_U8_}_ARR3{U8}_U8__'colors'|]
// file palettes.h line 23
struct anonymous_18;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_11;

// tag-#anon#UN[ARR8{S32}_S32_'i'||ARR80{S8}_S8_'s'|]
// file /usr/include/jpeglib.h line 736
union anonymous_26;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_10;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__jmp_buf_tag
// file /usr/include/setjmp.h line 34
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-_xmlAttr
// file /usr/include/libxml2/libxml/tree.h line 432
struct _xmlAttr;

// tag-_xmlDict
// file /usr/include/libxml2/libxml/dict.h line 25
struct _xmlDict;

// tag-_xmlDoc
// file /usr/include/libxml2/libxml/tree.h line 262
struct _xmlDoc;

// tag-_xmlDtd
// file /usr/include/libxml2/libxml/tree.h line 259
struct _xmlDtd;

// tag-_xmlNode
// file /usr/include/libxml2/libxml/tree.h line 257
struct _xmlNode;

// tag-_xmlNs
// file /usr/include/libxml2/libxml/tree.h line 387
struct _xmlNs;

// tag-internal_state
// file /usr/include/zlib.h line 83
struct internal_state;

// tag-jpeg_c_coef_controller
// file /usr/include/jpeglib.h line 457
struct jpeg_c_coef_controller;

// tag-jpeg_c_main_controller
// file /usr/include/jpeglib.h line 455
struct jpeg_c_main_controller;

// tag-jpeg_c_prep_controller
// file /usr/include/jpeglib.h line 456
struct jpeg_c_prep_controller;

// tag-jpeg_color_converter
// file /usr/include/jpeglib.h line 459
struct jpeg_color_converter;

// tag-jpeg_color_deconverter
// file /usr/include/jpeglib.h line 703
struct jpeg_color_deconverter;

// tag-jpeg_color_quantizer
// file /usr/include/jpeglib.h line 704
struct jpeg_color_quantizer;

// tag-jpeg_common_struct
// file /usr/include/jpeglib.h line 280
struct jpeg_common_struct;

// tag-jpeg_comp_master
// file /usr/include/jpeglib.h line 454
struct jpeg_comp_master;

// tag-jpeg_compress_struct
// file /usr/include/jpeglib.h line 289
struct jpeg_compress_struct;

// tag-jpeg_d_coef_controller
// file /usr/include/jpeglib.h line 696
struct jpeg_d_coef_controller;

// tag-jpeg_d_main_controller
// file /usr/include/jpeglib.h line 695
struct jpeg_d_main_controller;

// tag-jpeg_d_post_controller
// file /usr/include/jpeglib.h line 697
struct jpeg_d_post_controller;

// tag-jpeg_decomp_master
// file /usr/include/jpeglib.h line 694
struct jpeg_decomp_master;

// tag-jpeg_decompress_struct
// file /usr/include/jpeglib.h line 290
struct jpeg_decompress_struct;

// tag-jpeg_destination_mgr
// file /usr/include/jpeglib.h line 299
struct jpeg_destination_mgr;

// tag-jpeg_downsampler
// file /usr/include/jpeglib.h line 460
struct jpeg_downsampler;

// tag-jpeg_entropy_decoder
// file /usr/include/jpeglib.h line 700
struct jpeg_entropy_decoder;

// tag-jpeg_entropy_encoder
// file /usr/include/jpeglib.h line 462
struct jpeg_entropy_encoder;

// tag-jpeg_error_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_error_mgr;

// tag-jpeg_forward_dct
// file /usr/include/jpeglib.h line 461
struct jpeg_forward_dct;

// tag-jpeg_input_controller
// file /usr/include/jpeglib.h line 698
struct jpeg_input_controller;

// tag-jpeg_inverse_dct
// file /usr/include/jpeglib.h line 701
struct jpeg_inverse_dct;

// tag-jpeg_marker_reader
// file /usr/include/jpeglib.h line 699
struct jpeg_marker_reader;

// tag-jpeg_marker_struct
// file /usr/include/jpeglib.h line 199
struct jpeg_marker_struct;

// tag-jpeg_marker_writer
// file /usr/include/jpeglib.h line 458
struct jpeg_marker_writer;

// tag-jpeg_memory_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_memory_mgr;

// tag-jpeg_progress_mgr
// file /usr/include/jpeglib.h line 281
struct jpeg_progress_mgr;

// tag-jpeg_source_mgr
// file /usr/include/jpeglib.h line 474
struct jpeg_source_mgr;

// tag-jpeg_upsampler
// file /usr/include/jpeglib.h line 702
struct jpeg_upsampler;

// tag-jvirt_barray_control
// file /usr/include/jpeglib.h line 828
struct jvirt_barray_control;

// tag-jvirt_sarray_control
// file /usr/include/jpeglib.h line 827
struct jvirt_sarray_control;

// tag-png_color_16_struct
// file /usr/include/png.h line 436
struct png_color_16_struct;

// tag-png_color_8_struct
// file /usr/include/png.h line 447
struct png_color_8_struct;

// tag-png_color_struct
// file /usr/include/png.h line 427
struct png_color_struct;

// tag-png_info_struct
// file /usr/include/png.h line 610
struct png_info_struct;

// tag-png_row_info_struct
// file /usr/include/png.h line 953
struct png_row_info_struct;

// tag-png_sPLT_entry_struct
// file /usr/include/png.h line 462
struct png_sPLT_entry_struct;

// tag-png_sPLT_struct
// file /usr/include/png.h line 478
struct png_sPLT_struct;

// tag-png_struct_def
// file /usr/include/png.h line 972
struct png_struct_def;

// tag-png_text_struct
// file /usr/include/png.h line 497
struct png_text_struct;

// tag-png_time_struct
// file /usr/include/png.h line 537
struct png_time_struct;

// tag-png_unknown_chunk_t
// file /usr/include/png.h line 557
struct png_unknown_chunk_t;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-randctx
// file isaac.h line 23
struct randctx;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-xform
// file flam3.h line 210
struct xform;

// tag-z_stream_s
// file /usr/include/zlib.h line 85
struct z_stream_s;

#include <math.h>

#ifndef NULL
#define NULL ((void*)0)
#endif

#ifndef FENCE
#define FENCE(x) ((void)0)
#endif

#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) ((x)==(y))
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) ((x)!=(y))
#endif

// _IO_getc
// file /usr/include/libio.h line 434
extern signed int _IO_getc(struct _IO_FILE *);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __sync_bool_compare_and_swap
// file gcc_builtin_headers_generic.h line 105
_Bool __sync_bool_compare_and_swap();
// __xpg_basename
// file /usr/include/libgen.h line 34
extern char * __xpg_basename(char *);
// _setjmp
// file /usr/include/setjmp.h line 63
extern signed int _setjmp(struct __jmp_buf_tag *);
// acos
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 54
extern double acos(double);
// add_to_action
// file flam3.h line 565
void add_to_action(char *action, char *addtoaction);
// adjust_percentage
// file interpolation.h line 31
double adjust_percentage(double in);
// apply_motion_parameters
// file flam3.c line 554
void apply_motion_parameters(struct xform *xf, struct xform *addto, double blend);
// apply_xform
// file variations.h line 139
signed int apply_xform(struct anonymous_0 *cp, signed int fn, double *p, double *q, struct randctx *rc);
// atan2
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 60
extern double atan2(double, double);
// atof
// file /usr/include/x86_64-linux-gnu/bits/stdlib-float.h line 26
static inline double atof(const char *__nptr);
// atof_link1
// file /usr/include/x86_64-linux-gnu/bits/stdlib-float.h line 26
static inline double atof_link1(const char *__nptr_link1);
// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr);
// atoi_link1
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link1(const char *__nptr_link1);
// atoi_link2
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link2(const char *__nptr_link2);
// atoi_link3
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link3(const char *__nptr_link3);
// atoi_link4
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link4(const char *__nptr_link4);
// atoi_link5
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link5(const char *__nptr_link5);
// bits_error
// file flam3.c line 3745
void bits_error(struct anonymous_4 *spec);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// ceil
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 178
extern double ceil(double);
// change_colors
// file palettes.c line 458
static void change_colors(struct anonymous_0 *g, signed int change_palette);
// clear_cp
// file flam3.h line 538
void clear_cp(struct anonymous_0 *cp, signed int default_flag);
// clear_matrix
// file interpolation.c line 91
void clear_matrix(double (*m)[2l]);
// compare_xforms
// file interpolation.h line 45
signed int compare_xforms(const void *av, const void *bv);
// convert_linear_to_polar
// file interpolation.c line 236
void convert_linear_to_polar(struct anonymous_0 *cp, signed int ncps, signed int xfi, signed int cflag, double (*cxang)[2l], double (*cxmag)[2l], double (*cxtrn)[2l]);
// copy_matrix
// file interpolation.c line 80
void copy_matrix(double (*to)[2l], double (*from)[2l]);
// cos
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 63
extern double cos(double);
// cosh
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 72
extern double cosh(double);
// create_new_editdoc
// file flam3-genome.c line 80
struct _xmlDoc * create_new_editdoc(char *action, struct anonymous_0 *parent0, struct anonymous_0 *parent1);
// de_thread_32
// file rect.c line 57
static void de_thread_32(void *dth);
// de_thread_32_mt
// file rect.c line 57
static void de_thread_32_mt(void *dth);
// de_thread_33
// file rect.c line 57
static void de_thread_33(void *dth);
// de_thread_33_mt
// file rect.c line 57
static void de_thread_33_mt(void *dth);
// de_thread_64
// file rect.c line 57
static void de_thread_64(void *dth);
// de_thread_64_mt
// file rect.c line 57
static void de_thread_64_mt(void *dth);
// det_matrix
// file interpolation.c line 56
double det_matrix(double (*s)[2l]);
// disc2_precalc
// file variations.c line 1962
void disc2_precalc(struct xform *xf);
// docstring
// file private.h line 73
void docstring();
// double_atomic_add
// file flam3.c line 3507
static inline void double_atomic_add(double *dest, double delta);
// establish_asymmetric_refangles
// file interpolation.h line 56
void establish_asymmetric_refangles(struct anonymous_0 *cp, signed int ncps);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// exp
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 100
extern double exp(double);
// fabs
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 181
extern double fabs(double);
// fclose
// file /usr/include/stdio.h line 237
extern signed int fclose(struct _IO_FILE *);
// ferror
// file /usr/include/stdio.h line 830
extern signed int ferror(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// flam3_add_motion_element
// file flam3.c line 981
void flam3_add_motion_element(struct xform *xf);
// flam3_add_symmetry
// file flam3.c line 2437
void flam3_add_symmetry(struct anonymous_0 *cp, signed int sym);
// flam3_add_xforms
// file flam3.c line 1007
void flam3_add_xforms(struct anonymous_0 *thiscp, signed int num_to_add, signed int interp_padding, signed int final_flag);
// flam3_align
// file interpolation.h line 57
void flam3_align(struct anonymous_0 *dst, struct anonymous_0 *src, signed int nsrc);
// flam3_apply_template
// file flam3.h line 585
void flam3_apply_template(struct anonymous_0 *cp, struct anonymous_0 *templ);
// flam3_atof
// file parser.c line 50
double flam3_atof(char *nstr);
// flam3_atoi
// file parser.c line 26
signed int flam3_atoi(char *nstr);
// flam3_b_spline_filter
// file filters.c line 76
double flam3_b_spline_filter(double t);
// flam3_bell_filter
// file filters.c line 65
double flam3_bell_filter(double t);
// flam3_blackman_filter
// file filters.c line 98
double flam3_blackman_filter(double x);
// flam3_box_filter
// file filters.c line 54
double flam3_box_filter(double t);
// flam3_calc_alpha
// file palettes.h line 33
double flam3_calc_alpha(double density, double gamma, double linrange);
// flam3_calc_newrgb
// file palettes.h line 34
void flam3_calc_newrgb(double *cbuf, double ls, double highpow, double *newrgb);
// flam3_catrom_filter
// file filters.c line 102
double flam3_catrom_filter(double x);
// flam3_check_unity_chaos
// file flam3.c line 144
signed int flam3_check_unity_chaos(struct anonymous_0 *cp);
// flam3_colorhist
// file flam3.c line 346
signed int flam3_colorhist(struct anonymous_0 *cp, signed int num_batches, struct randctx *rc, double *hist);
// flam3_copy
// file flam3.h line 529
void flam3_copy(struct anonymous_0 *dest, struct anonymous_0 *src);
// flam3_copy_params
// file flam3.c line 788
void flam3_copy_params(struct xform *dest, struct xform *src, signed int varn);
// flam3_copy_xform
// file flam3.c line 1121
void flam3_copy_xform(struct xform *dest, struct xform *src);
// flam3_copyx
// file flam3.c line 1185
void flam3_copyx(struct anonymous_0 *dest, struct anonymous_0 *src, signed int dest_std_xforms, signed int dest_final_xform);
// flam3_count_nthreads
// file flam3.c line 1345
signed int flam3_count_nthreads(void);
// flam3_create_chaos_distrib
// file flam3.c line 161
signed int flam3_create_chaos_distrib(struct anonymous_0 *cp, signed int xi, unsigned short int *xform_distrib);
// flam3_create_de_filters
// file filters.h line 59
struct anonymous_6 flam3_create_de_filters(double max_rad, double min_rad, double curve, signed int ss);
// flam3_create_spatial_filter
// file filters.h line 58
signed int flam3_create_spatial_filter(struct anonymous_4 *spec, signed int field, double **filter);
// flam3_create_temporal_filter
// file filters.h line 60
double flam3_create_temporal_filter(signed int numsteps, signed int filter_type, double filter_exp, double filter_width, double **temporal_filter, double **temporal_deltas);
// flam3_create_xform_distrib
// file flam3.c line 72
unsigned short int * flam3_create_xform_distrib(struct anonymous_0 *cp);
// flam3_cross
// file flam3.h line 568
void flam3_cross(struct anonymous_0 *cp0, struct anonymous_0 *cp1, struct anonymous_0 *out, signed int cross_mode, struct randctx *rc, char *action);
// flam3_delete_motion_elements
// file flam3.h line 532
void flam3_delete_motion_elements(struct xform *xf);
// flam3_delete_xform
// file flam3.h line 527
void flam3_delete_xform(struct anonymous_0 *thiscp, signed int idx_to_delete);
// flam3_dimension
// file flam3.c line 3807
double flam3_dimension(struct anonymous_0 *cp, signed int ntries, signed int clip_to_camera);
// flam3_edit_print
// file parser.h line 33
void flam3_edit_print(struct _IO_FILE *f, struct _xmlNode *editNode, signed int tabs, signed int formatting);
// flam3_estimate_bounding_box
// file flam3.h line 578
signed int flam3_estimate_bounding_box(struct anonymous_0 *cp, double eps, signed int nsamples, double *bmin, double *bmax, struct randctx *rc);
// flam3_free
// file flam3.c line 3420
void flam3_free(void *ptr);
// flam3_gaussian_filter
// file filters.c line 156
double flam3_gaussian_filter(double x);
// flam3_get_palette
// file flam3.h line 55
signed int flam3_get_palette(signed int n, struct anonymous_1 *c, double hue_rotation);
// flam3_hamming_filter
// file filters.c line 140
double flam3_hamming_filter(double x);
// flam3_hanning_filter
// file filters.c line 136
double flam3_hanning_filter(double x);
// flam3_hermite_filter
// file filters.c line 47
double flam3_hermite_filter(double t);
// flam3_improve_colors
// file flam3.h line 576
void flam3_improve_colors(struct anonymous_0 *g, signed int ntries, signed int change_palette, signed int color_resolution);
// flam3_init_frame
// file flam3.h line 629
void flam3_init_frame(struct anonymous_4 *f);
// flam3_interp_missing_colors
// file parser.c line 135
signed int flam3_interp_missing_colors(struct anonymous_0 *cp);
// flam3_interpolate
// file flam3.h line 552
void flam3_interpolate(struct anonymous_0 *cps, signed int ncps, double time, double stagger, struct anonymous_0 *result);
// flam3_interpolate_n
// file interpolation.h line 55
void flam3_interpolate_n(struct anonymous_0 *result, signed int ncp, struct anonymous_0 *cpi, double *c, double stagger);
// flam3_iterate
// file flam3.c line 228
signed int flam3_iterate(struct anonymous_0 *cp, signed int n, signed int fuse, double *samples, unsigned short int *xform_distrib, struct randctx *rc);
// flam3_lanczos2_filter
// file filters.c line 150
double flam3_lanczos2_filter(double t);
// flam3_lanczos3_filter
// file filters.c line 144
double flam3_lanczos3_filter(double t);
// flam3_lyapunov
// file flam3.c line 3923
double flam3_lyapunov(struct anonymous_0 *cp, signed int ntries);
// flam3_make_strip
// file flam3.c line 110
signed int flam3_make_strip(struct anonymous_0 *cp, signed int nstrips, signed int stripnum);
// flam3_malloc
// file flam3.c line 3414
void * flam3_malloc(unsigned long int size);
// flam3_mitchell_filter
// file filters.c line 116
double flam3_mitchell_filter(double t);
// flam3_mutate
// file flam3.h line 567
void flam3_mutate(struct anonymous_0 *cp, signed int mutate_mode, signed int *ivars, signed int ivars_n, signed int sym, double speed, struct randctx *rc, char *action);
// flam3_parse_from_file
// file flam3.h line 572
struct anonymous_0 * flam3_parse_from_file(struct _IO_FILE *f, char *fname, signed int default_flag, signed int *ncps);
// flam3_parse_hexformat_colors
// file parser.c line 83
signed int flam3_parse_hexformat_colors(char *colstr, struct anonymous_0 *cp, signed int numcolors, signed int chan);
// flam3_parse_xml2
// file flam3.c line 1396
struct anonymous_0 * flam3_parse_xml2(char *xmldata, char *xmlfilename, signed int default_flag, signed int *ncps);
// flam3_print
// file flam3.h line 555
void flam3_print(struct _IO_FILE *f, struct anonymous_0 *cp, char *extra_attributes, signed int print_edits);
// flam3_print_to_string
// file flam3.c line 1596
char * flam3_print_to_string(struct anonymous_0 *cp);
// flam3_print_xform
// file flam3.c line 1806
void flam3_print_xform(struct _IO_FILE *f, struct xform *x, signed int final_flag, signed int numstd, double *chaos_row, signed int motion_flag);
// flam3_quadratic_filter
// file filters.c line 160
double flam3_quadratic_filter(double x);
// flam3_random
// file flam3.h line 563
void flam3_random(struct anonymous_0 *cp, signed int *ivars, signed int ivars_n, signed int sym, signed int spec_xforms);
// flam3_random01
// file flam3.c line 2364
double flam3_random01();
// flam3_random11
// file flam3.c line 2368
double flam3_random11();
// flam3_random_bit
// file flam3.h line 622
signed int flam3_random_bit();
// flam3_random_isaac_01
// file flam3.h line 625
double flam3_random_isaac_01(struct randctx *ct);
// flam3_random_isaac_11
// file flam3.h line 626
double flam3_random_isaac_11(struct randctx *ct);
// flam3_random_isaac_bit
// file flam3.h line 627
signed int flam3_random_isaac_bit(struct randctx *ct);
// flam3_render
// file flam3.h line 613
signed int flam3_render(struct anonymous_4 *spec, void *out, signed int field, signed int nchan, signed int trans, struct anonymous_8 *stats);
// flam3_render_memory_required
// file flam3.c line 3730
double flam3_render_memory_required(struct anonymous_4 *spec);
// flam3_rotate
// file flam3.c line 505
void flam3_rotate(struct anonymous_0 *cp, double by, signed int interpolation_type);
// flam3_sinc
// file filters.c line 92
double flam3_sinc(double x);
// flam3_spatial_filter
// file filters.c line 172
double flam3_spatial_filter(signed int knum, double x);
// flam3_srandom
// file flam3.h line 635
void flam3_srandom();
// flam3_triangle_filter
// file filters.c line 59
double flam3_triangle_filter(double t);
// flam3_version
// file flam3.h line 34
char * flam3_version();
// flam3_xform_preview
// file flam3.c line 296
signed int flam3_xform_preview(struct anonymous_0 *cp, signed int xi, double range, signed int numvals, signed int depth, double *result, struct randctx *rc);
// floor
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 184
extern double floor(double);
// fmod
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 187
extern double fmod(double, double);
// fopen
// file /usr/include/stdio.h line 272
extern struct _IO_FILE * fopen(const char *, const char *);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// fputs
// file /usr/include/stdio.h line 689
extern signed int fputs(const char *, struct _IO_FILE *);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// fseek
// file /usr/include/stdio.h line 749
extern signed int fseek(struct _IO_FILE *, signed long int, signed int);
// ftell
// file /usr/include/stdio.h line 754
extern signed long int ftell(struct _IO_FILE *);
// get_extras
// file flam3-genome.c line 25
char * get_extras();
// get_stagger_coef
// file interpolation.c line 332
double get_stagger_coef(double t, double stagger_prc, signed int num_xforms, signed int this_xform);
// getenv
// file /usr/include/stdlib.h line 564
extern char * getenv(const char *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// golden_bit
// file flam3-genome.c line 372
static double golden_bit(struct randctx *rc);
// gprint
// file flam3-genome.c line 30
void gprint(struct anonymous_0 *cp, signed int extras);
// hsv2rgb
// file palettes.h line 31
void hsv2rgb(double *hsv, double *rgb);
// id_matrix
// file interpolation.h line 38
signed int id_matrix(double (*s)[2l]);
// init_palettes
// file palettes.c line 89
static signed int init_palettes(char *filename);
// initialize_xforms
// file variations.h line 140
void initialize_xforms(struct anonymous_0 *thiscp, signed int start_here);
// interp_and_convert_back
// file interpolation.c line 183
void interp_and_convert_back(double *c, signed int ncps, signed int xfi, double (*cxang)[2l], double (*cxmag)[2l], double (*cxtrn)[2l], double (*store_array)[2l]);
// interpolate_catmull_rom
// file interpolation.h line 54
void interpolate_catmull_rom(struct anonymous_0 *cps, double t, struct anonymous_0 *result);
// interpolate_cmap
// file interpolation.h line 47
void interpolate_cmap(struct anonymous_1 *cmap, double blend, signed int index0, double hue0, signed int index1, double hue1);
// irandinit
// file isaac.h line 39
void irandinit(struct randctx *ctx, signed int flag);
// isaac
// file isaac.h line 41
void isaac(struct randctx *ctx);
// iter_thread_double
// file rect.c line 253
static void iter_thread_double(void *fth);
// iter_thread_double_mt
// file rect.c line 253
static void iter_thread_double_mt(void *fth);
// iter_thread_float
// file rect.c line 253
static void iter_thread_float(void *fth);
// iter_thread_float_mt
// file rect.c line 253
static void iter_thread_float_mt(void *fth);
// iter_thread_int
// file rect.c line 253
static void iter_thread_int(void *fth);
// iter_thread_int_mt
// file rect.c line 253
static void iter_thread_int_mt(void *fth);
// jpeg_CreateCompress
// file /usr/include/jpeglib.h line 904
extern void jpeg_CreateCompress(struct jpeg_compress_struct *, signed int, unsigned long int);
// jpeg_CreateDecompress
// file /usr/include/jpeglib.h line 906
extern void jpeg_CreateDecompress(struct jpeg_decompress_struct *, signed int, unsigned long int);
// jpeg_destroy_compress
// file /usr/include/jpeglib.h line 909
extern void jpeg_destroy_compress(struct jpeg_compress_struct *);
// jpeg_destroy_decompress
// file /usr/include/jpeglib.h line 910
extern void jpeg_destroy_decompress(struct jpeg_decompress_struct *);
// jpeg_finish_compress
// file /usr/include/jpeglib.h line 954
extern void jpeg_finish_compress(struct jpeg_compress_struct *);
// jpeg_finish_decompress
// file /usr/include/jpeglib.h line 993
extern signed int jpeg_finish_decompress(struct jpeg_decompress_struct *);
// jpeg_read_header
// file /usr/include/jpeglib.h line 977
extern signed int jpeg_read_header(struct jpeg_decompress_struct *, signed int);
// jpeg_read_scanlines
// file /usr/include/jpeglib.h line 990
extern unsigned int jpeg_read_scanlines(struct jpeg_decompress_struct *, unsigned char **, unsigned int);
// jpeg_set_defaults
// file /usr/include/jpeglib.h line 926
extern void jpeg_set_defaults(struct jpeg_compress_struct *);
// jpeg_set_quality
// file /usr/include/jpeglib.h line 931
extern void jpeg_set_quality(struct jpeg_compress_struct *, signed int, signed int);
// jpeg_start_compress
// file /usr/include/jpeglib.h line 949
extern void jpeg_start_compress(struct jpeg_compress_struct *, signed int);
// jpeg_start_decompress
// file /usr/include/jpeglib.h line 989
extern signed int jpeg_start_decompress(struct jpeg_decompress_struct *);
// jpeg_std_error
// file /usr/include/jpeglib.h line 889
extern struct jpeg_error_mgr * jpeg_std_error(struct jpeg_error_mgr *);
// jpeg_stdio_dest
// file /usr/include/jpeglib.h line 914
extern void jpeg_stdio_dest(struct jpeg_compress_struct *, struct _IO_FILE *);
// jpeg_stdio_src
// file /usr/include/jpeglib.h line 915
extern void jpeg_stdio_src(struct jpeg_decompress_struct *, struct _IO_FILE *);
// jpeg_write_marker
// file /usr/include/jpeglib.h line 966
extern void jpeg_write_marker(struct jpeg_compress_struct *, signed int, const unsigned char *, unsigned int);
// jpeg_write_scanlines
// file /usr/include/jpeglib.h line 951
extern unsigned int jpeg_write_scanlines(struct jpeg_compress_struct *, unsigned char **, unsigned int);
// juliaN_precalc
// file variations.c line 1933
void juliaN_precalc(struct xform *xf);
// juliaScope_precalc
// file variations.c line 1944
void juliaScope_precalc(struct xform *xf);
// localtime
// file /usr/include/time.h line 243
extern struct tm * localtime(const signed long int *);
// log
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 109
extern double log(double);
// log10
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 112
extern double log10(double);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// motion_funcs
// file interpolation.h line 32
double motion_funcs(signed int funcnum, double timeval);
// mult_matrix
// file interpolation.h line 43
void mult_matrix(double (*s1)[2l], double (*s2)[2l], double (*d)[2l]);
// nanosleep
// file /usr/include/time.h line 334
extern signed int nanosleep(struct timespec *, struct timespec *);
// normalize_vector
// file filters.c line 204
signed int normalize_vector(double *v, signed int n);
// offset
// file flam3-genome.c line 220
void offset(struct anonymous_0 *g);
// parse_flame_element
// file parser.c line 284
signed int parse_flame_element(struct _xmlNode *flame_node, struct anonymous_0 *loc_current_cp);
// parse_palettes
// file palettes.c line 25
static void parse_palettes(struct _xmlNode *node);
// parse_xform_xml
// file parser.c line 823
signed int parse_xform_xml(struct _xmlNode *chld_node, struct xform *this_xform, signed int *num_xaos, struct anonymous_7 **xaos, signed int numstd, signed int motionxf);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// perspective_precalc
// file variations.c line 1927
void perspective_precalc(struct xform *xf);
// png_create_info_struct
// file /usr/include/png.h line 1426
extern struct png_info_struct * png_create_info_struct(struct png_struct_def *);
// png_create_read_struct
// file /usr/include/png.h line 1376
extern struct png_struct_def * png_create_read_struct(const char *, void *, void (*)(struct png_struct_def *, const char *), void (*)(struct png_struct_def *, const char *));
// png_create_write_struct
// file /usr/include/png.h line 1381
extern struct png_struct_def * png_create_write_struct(const char *, void *, void (*)(struct png_struct_def *, const char *), void (*)(struct png_struct_def *, const char *));
// png_destroy_read_struct
// file /usr/include/png.h line 1672
extern void png_destroy_read_struct(struct png_struct_def **, struct png_info_struct **, struct png_info_struct **);
// png_destroy_write_struct
// file /usr/include/png.h line 1680
extern void png_destroy_write_struct(struct png_struct_def **, struct png_info_struct **);
// png_get_bit_depth
// file /usr/include/png.h line 2038
extern unsigned char png_get_bit_depth(struct png_struct_def *, struct png_info_struct *);
// png_get_color_type
// file /usr/include/png.h line 2042
extern unsigned char png_get_color_type(struct png_struct_def *, struct png_info_struct *);
// png_get_image_height
// file /usr/include/png.h line 2034
extern unsigned long int png_get_image_height(struct png_struct_def *, struct png_info_struct *);
// png_get_image_width
// file /usr/include/png.h line 2030
extern unsigned long int png_get_image_width(struct png_struct_def *, struct png_info_struct *);
// png_init_io
// file /usr/include/png.h line 1791
extern void png_init_io(struct png_struct_def *, struct _IO_FILE *);
// png_read_end
// file /usr/include/png.h line 1663
extern void png_read_end(struct png_struct_def *, struct png_info_struct *);
// png_read_image
// file /usr/include/png.h line 1641
extern void png_read_image(struct png_struct_def *, unsigned char **);
// png_read_info
// file /usr/include/png.h line 1449
extern void png_read_info(struct png_struct_def *, struct png_info_struct *);
// png_set_IHDR
// file /usr/include/png.h line 2161
extern void png_set_IHDR(struct png_struct_def *, struct png_info_struct *, unsigned long int, unsigned long int, signed int, signed int, signed int, signed int, signed int);
// png_set_sig_bytes
// file /usr/include/png.h line 1359
extern void png_set_sig_bytes(struct png_struct_def *, signed int);
// png_set_swap
// file /usr/include/png.h line 1539
extern void png_set_swap(struct png_struct_def *);
// png_set_text
// file /usr/include/png.h line 2267
extern void png_set_text(struct png_struct_def *, struct png_info_struct *, struct png_text_struct *, signed int);
// png_sig_cmp
// file /usr/include/png.h line 1367
extern signed int png_sig_cmp(unsigned char *, unsigned long int, unsigned long int);
// png_write_end
// file /usr/include/png.h line 1658
extern void png_write_end(struct png_struct_def *, struct png_info_struct *);
// png_write_image
// file /usr/include/png.h line 1654
extern void png_write_image(struct png_struct_def *, unsigned char **);
// png_write_info
// file /usr/include/png.h line 1444
extern void png_write_info(struct png_struct_def *, struct png_info_struct *);
// pow
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 153
extern double pow(double, double);
// prepare_precalc_flags
// file variations.h line 137
signed int prepare_precalc_flags(struct anonymous_0 *cp);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pthread_attr_destroy
// file /usr/include/pthread.h line 292
extern signed int pthread_attr_destroy(union pthread_attr_t *);
// pthread_attr_init
// file /usr/include/pthread.h line 289
extern signed int pthread_attr_init(union pthread_attr_t *);
// pthread_attr_setdetachstate
// file /usr/include/pthread.h line 301
extern signed int pthread_attr_setdetachstate(union pthread_attr_t *, signed int);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_10 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_10 *, const union anonymous_11 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_10 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_10 *);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// radial_blur_precalc
// file variations.c line 1949
void radial_blur_precalc(struct xform *xf);
// random
// file /usr/include/stdlib.h line 321
extern signed long int random(void);
// random_var
// file flam3.c line 2933
static signed int random_var();
// random_varn
// file flam3.c line 2937
static signed int random_varn(signed int n);
// random_xform
// file palettes.c line 351
static signed int random_xform(struct anonymous_0 *g, signed int excluded);
// read_jpeg
// file jpeg.c line 102
unsigned char * read_jpeg(struct _IO_FILE *ifp, signed int *width, signed int *height);
// read_png
// file png.c line 121
unsigned char * read_png(struct _IO_FILE *ifp, signed int *width, signed int *height);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// render_rectangle_double
// file rect.c line 527
static signed int render_rectangle_double(struct anonymous_4 *spec, void *out, signed int field, signed int nchan, signed int transp, struct anonymous_8 *stats);
// render_rectangle_double_mt
// file rect.c line 527
static signed int render_rectangle_double_mt(struct anonymous_4 *spec, void *out, signed int field, signed int nchan, signed int transp, struct anonymous_8 *stats);
// render_rectangle_float
// file rect.c line 527
static signed int render_rectangle_float(struct anonymous_4 *spec, void *out, signed int field, signed int nchan, signed int transp, struct anonymous_8 *stats);
// render_rectangle_float_mt
// file rect.c line 527
static signed int render_rectangle_float_mt(struct anonymous_4 *spec, void *out, signed int field, signed int nchan, signed int transp, struct anonymous_8 *stats);
// render_rectangle_int
// file rect.c line 527
static signed int render_rectangle_int(struct anonymous_4 *spec, void *out, signed int field, signed int nchan, signed int transp, struct anonymous_8 *stats);
// render_rectangle_int_mt
// file rect.c line 527
static signed int render_rectangle_int_mt(struct anonymous_4 *spec, void *out, signed int field, signed int nchan, signed int transp, struct anonymous_8 *stats);
// rgb2hsv
// file palettes.h line 30
void rgb2hsv(double *rgb, double *hsv);
// rint
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 279
extern double rint(double);
// rotate_by
// file flam3.h line 617
void rotate_by(double *p, double *center, double by);
// round6
// file flam3.c line 2425
static double round6(double x);
// scan_for_flame_nodes
// file parser.h line 29
void scan_for_flame_nodes(struct _xmlNode *cur_node, char *parent_file, signed int default_flag, struct anonymous_0 **all_cps, signed int *all_ncps);
// setlocale
// file /usr/include/locale.h line 124
extern char * setlocale(signed int, const char *);
// sheep_edge
// file flam3.h line 638
struct anonymous_0 * sheep_edge(struct anonymous_0 *cp, double blend, signed int seqflag, double stagger);
// sheep_loop
// file flam3.h line 637
struct anonymous_0 * sheep_loop(struct anonymous_0 *cp, double blend);
// sin
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 65
extern double sin(double);
// sincos
// file variations.c line 28
extern void sincos(double, double *, double *);
// sinh
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 74
extern double sinh(double);
// smoother
// file interpolation.h line 34
double smoother(double t);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sort_by_x
// file flam3.c line 3392
static signed int sort_by_x(const void *av, const void *bv);
// sort_by_y
// file flam3.c line 3400
static signed int sort_by_y(const void *av, const void *bv);
// spin
// file flam3-genome.c line 229
void spin(signed int frame, double blend, struct anonymous_0 *parent, struct anonymous_0 *templ);
// spin_inter
// file flam3-genome.c line 275
void spin_inter(signed int frame, double blend, signed int seqflag, struct anonymous_0 *parents, struct anonymous_0 *templ);
// sprintf
// file /usr/include/stdio.h line 364
extern signed int sprintf(char *, const char *, ...);
// sqrt
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 156
extern double sqrt(double);
// srandom
// file /usr/include/stdlib.h line 324
extern void srandom(unsigned int);
// sscanf
// file /usr/include/stdio.h line 433
extern signed int sscanf(const char *, const char *, ...);
// strcat
// file /usr/include/string.h line 137
extern char * strcat(char *, const char *);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// string_to_cp
// file flam3-genome.c line 63
struct anonymous_0 * string_to_cp(char *s, signed int *n);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// strtok
// file /usr/include/string.h line 347
extern char * strtok(char *, const char *);
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// sum_matrix
// file interpolation.c line 100
void sum_matrix(double s, double (*m1)[2l], double (*m2)[2l]);
// supershape_precalc
// file variations.c line 1984
void supershape_precalc(struct xform *xf);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// tan
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 67
extern double tan(double);
// test_cp
// file flam3-genome.c line 38
void test_cp(struct anonymous_0 *cp);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// tmpfile
// file /usr/include/stdio.h line 195
extern struct _IO_FILE * tmpfile(void);
// trunc
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 313
extern double trunc(double);
// truncate_variations
// file flam3-genome.c line 328
void truncate_variations(struct anonymous_0 *g, signed int max_vars, char *action);
// try_colors
// file palettes.c line 362
static double try_colors(struct anonymous_0 *g, signed int color_resolution);
// uint_atomic_add
// file flam3.c line 3545
static inline void uint_atomic_add(unsigned int *dest, unsigned int delta);
// var0_linear
// file variations.c line 141
void var0_linear(struct anonymous_9 *f, double weight);
// var10_hyperbolic
// file variations.c line 297
void var10_hyperbolic(struct anonymous_9 *f, double weight);
// var11_diamond
// file variations.c line 310
void var11_diamond(struct anonymous_9 *f, double weight);
// var12_ex
// file variations.c line 325
void var12_ex(struct anonymous_9 *f, double weight);
// var13_julia
// file variations.c line 349
void var13_julia(struct anonymous_9 *f, double weight);
// var14_bent
// file variations.c line 374
void var14_bent(struct anonymous_9 *f, double weight);
// var15_waves
// file variations.c line 395
void var15_waves(struct anonymous_9 *f, double weight);
// var16_fisheye
// file variations.c line 414
void var16_fisheye(struct anonymous_9 *f, double weight);
// var17_popcorn
// file variations.c line 432
void var17_popcorn(struct anonymous_9 *f, double weight);
// var18_exponential
// file variations.c line 451
void var18_exponential(struct anonymous_9 *f, double weight);
// var19_power
// file variations.c line 471
void var19_power(struct anonymous_9 *f, double weight);
// var1_sinusoidal
// file variations.c line 152
void var1_sinusoidal(struct anonymous_9 *f, double weight);
// var20_cosine
// file variations.c line 488
void var20_cosine(struct anonymous_9 *f, double weight);
// var21_rings
// file variations.c line 507
void var21_rings(struct anonymous_9 *f, double weight);
// var22_fan
// file variations.c line 527
void var22_fan(struct anonymous_9 *f, double weight);
// var23_blob
// file variations.c line 556
void var23_blob(struct anonymous_9 *f, double weight);
// var24_pdj
// file variations.c line 578
void var24_pdj(struct anonymous_9 *f, double weight);
// var25_fan2
// file variations.c line 597
void var25_fan2(struct anonymous_9 *f, double weight);
// var26_rings2
// file variations.c line 639
void var26_rings2(struct anonymous_9 *f, double weight);
// var27_eyefish
// file variations.c line 658
void var27_eyefish(struct anonymous_9 *f, double weight);
// var28_bubble
// file variations.c line 670
void var28_bubble(struct anonymous_9 *f, double weight);
// var29_cylinder
// file variations.c line 679
void var29_cylinder(struct anonymous_9 *f, double weight);
// var2_spherical
// file variations.c line 163
void var2_spherical(struct anonymous_9 *f, double weight);
// var2n
// file parser.c line 74
signed int var2n(const char *s);
// var30_perspective
// file variations.c line 686
void var30_perspective(struct anonymous_9 *f, double weight);
// var31_noise
// file variations.c line 695
void var31_noise(struct anonymous_9 *f, double weight);
// var32_juliaN_generic
// file variations.c line 709
void var32_juliaN_generic(struct anonymous_9 *f, double weight);
// var33_juliaScope_generic
// file variations.c line 724
void var33_juliaScope_generic(struct anonymous_9 *f, double weight);
// var34_blur
// file variations.c line 745
void var34_blur(struct anonymous_9 *f, double weight);
// var35_gaussian
// file variations.c line 759
void var35_gaussian(struct anonymous_9 *f, double weight);
// var36_radial_blur
// file variations.c line 774
void var36_radial_blur(struct anonymous_9 *f, double weight);
// var37_pie
// file variations.c line 794
void var37_pie(struct anonymous_9 *f, double weight);
// var38_ngon
// file variations.c line 810
void var38_ngon(struct anonymous_9 *f, double weight);
// var39_curl
// file variations.c line 831
void var39_curl(struct anonymous_9 *f, double weight);
// var3_swirl
// file variations.c line 177
void var3_swirl(struct anonymous_9 *f, double weight);
// var40_rectangles
// file variations.c line 842
void var40_rectangles(struct anonymous_9 *f, double weight);
// var41_arch
// file variations.c line 856
void var41_arch(struct anonymous_9 *f, double weight);
// var42_tangent
// file variations.c line 884
void var42_tangent(struct anonymous_9 *f, double weight);
// var43_square
// file variations.c line 899
void var43_square(struct anonymous_9 *f, double weight);
// var44_rays
// file variations.c line 914
void var44_rays(struct anonymous_9 *f, double weight);
// var45_blade
// file variations.c line 945
void var45_blade(struct anonymous_9 *f, double weight);
// var46_secant2
// file variations.c line 975
void var46_secant2(struct anonymous_9 *f, double weight);
// var47_twintrian
// file variations.c line 997
void var47_twintrian(struct anonymous_9 *f, double weight);
// var48_cross
// file variations.c line 1032
void var48_cross(struct anonymous_9 *f, double weight);
// var49_disc2
// file variations.c line 1053
void var49_disc2(struct anonymous_9 *f, double weight);
// var4_horseshoe
// file variations.c line 201
void var4_horseshoe(struct anonymous_9 *f, double weight);
// var50_supershape
// file variations.c line 1091
void var50_supershape(struct anonymous_9 *f, double weight);
// var51_flower
// file variations.c line 1117
void var51_flower(struct anonymous_9 *f, double weight);
// var52_conic
// file variations.c line 1132
void var52_conic(struct anonymous_9 *f, double weight);
// var53_parabola
// file variations.c line 1147
void var53_parabola(struct anonymous_9 *f, double weight);
// var54_bent2
// file variations.c line 1163
void var54_bent2(struct anonymous_9 *f, double weight);
// var55_bipolar
// file variations.c line 1179
void var55_bipolar(struct anonymous_9 *f, double weight);
// var56_boarders
// file variations.c line 1198
void var56_boarders(struct anonymous_9 *f, double weight);
// var57_butterfly
// file variations.c line 1237
void var57_butterfly(struct anonymous_9 *f, double weight);
// var58_cell
// file variations.c line 1252
void var58_cell(struct anonymous_9 *f, double weight);
// var59_cpow
// file variations.c line 1290
void var59_cpow(struct anonymous_9 *f, double weight);
// var5_polar
// file variations.c line 217
void var5_polar(struct anonymous_9 *f, double weight);
// var60_curve
// file variations.c line 1311
void var60_curve(struct anonymous_9 *f, double weight);
// var61_edisc
// file variations.c line 1327
void var61_edisc(struct anonymous_9 *f, double weight);
// var62_elliptic
// file variations.c line 1353
void var62_elliptic(struct anonymous_9 *f, double weight);
// var63_escher
// file variations.c line 1384
void var63_escher(struct anonymous_9 *f, double weight);
// var64_foci
// file variations.c line 1411
void var64_foci(struct anonymous_9 *f, double weight);
// var65_lazysusan
// file variations.c line 1427
void var65_lazysusan(struct anonymous_9 *f, double weight);
// var66_loonie
// file variations.c line 1455
void var66_loonie(struct anonymous_9 *f, double weight);
// var67_pre_blur
// file variations.c line 1479
void var67_pre_blur(struct anonymous_9 *f, double weight);
// var68_modulus
// file variations.c line 1497
void var68_modulus(struct anonymous_9 *f, double weight);
// var69_oscope
// file variations.c line 1520
void var69_oscope(struct anonymous_9 *f, double weight);
// var6_handkerchief
// file variations.c line 231
void var6_handkerchief(struct anonymous_9 *f, double weight);
// var70_polar2
// file variations.c line 1543
void var70_polar2(struct anonymous_9 *f, double weight);
// var71_popcorn2
// file variations.c line 1553
void var71_popcorn2(struct anonymous_9 *f, double weight);
// var72_scry
// file variations.c line 1562
void var72_scry(struct anonymous_9 *f, double weight);
// var73_separation
// file variations.c line 1583
void var73_separation(struct anonymous_9 *f, double weight);
// var74_split
// file variations.c line 1602
void var74_split(struct anonymous_9 *f, double weight);
// var75_splits
// file variations.c line 1618
void var75_splits(struct anonymous_9 *f, double weight);
// var76_stripes
// file variations.c line 1634
void var76_stripes(struct anonymous_9 *f, double weight);
// var77_wedge
// file variations.c line 1648
void var77_wedge(struct anonymous_9 *f, double weight);
// var78_wedge_julia
// file variations.c line 1670
void var78_wedge_julia(struct anonymous_9 *f, double weight);
// var79_wedge_sph
// file variations.c line 1688
void var79_wedge_sph(struct anonymous_9 *f, double weight);
// var7_heart
// file variations.c line 245
void var7_heart(struct anonymous_9 *f, double weight);
// var80_whorl
// file variations.c line 1709
void var80_whorl(struct anonymous_9 *f, double weight);
// var81_waves2
// file variations.c line 1734
void var81_waves2(struct anonymous_9 *f, double weight);
// var82_exp
// file variations.c line 1746
void var82_exp(struct anonymous_9 *f, double weight);
// var83_log
// file variations.c line 1755
void var83_log(struct anonymous_9 *f, double weight);
// var84_sin
// file variations.c line 1762
void var84_sin(struct anonymous_9 *f, double weight);
// var85_cos
// file variations.c line 1772
void var85_cos(struct anonymous_9 *f, double weight);
// var86_tan
// file variations.c line 1782
void var86_tan(struct anonymous_9 *f, double weight);
// var87_sec
// file variations.c line 1794
void var87_sec(struct anonymous_9 *f, double weight);
// var88_csc
// file variations.c line 1806
void var88_csc(struct anonymous_9 *f, double weight);
// var89_cot
// file variations.c line 1818
void var89_cot(struct anonymous_9 *f, double weight);
// var8_disc
// file variations.c line 263
void var8_disc(struct anonymous_9 *f, double weight);
// var90_sinh
// file variations.c line 1830
void var90_sinh(struct anonymous_9 *f, double weight);
// var91_cosh
// file variations.c line 1840
void var91_cosh(struct anonymous_9 *f, double weight);
// var92_tanh
// file variations.c line 1850
void var92_tanh(struct anonymous_9 *f, double weight);
// var93_sech
// file variations.c line 1862
void var93_sech(struct anonymous_9 *f, double weight);
// var94_csch
// file variations.c line 1874
void var94_csch(struct anonymous_9 *f, double weight);
// var95_coth
// file variations.c line 1886
void var95_coth(struct anonymous_9 *f, double weight);
// var96_auger
// file variations.c line 1898
void var96_auger(struct anonymous_9 *f, double weight);
// var97_flux
// file variations.c line 1910
void var97_flux(struct anonymous_9 *f, double weight);
// var9_spiral
// file variations.c line 281
void var9_spiral(struct anonymous_9 *f, double weight);
// waves_precalc
// file variations.c line 1954
void waves_precalc(struct xform *xf);
// wedgeJulia_precalc
// file variations.c line 1938
void wedgeJulia_precalc(struct xform *xf);
// write_jpeg
// file jpeg.c line 31
void write_jpeg(struct _IO_FILE *file, unsigned char *image, signed int width, signed int height, struct anonymous_19 *fpc);
// write_png
// file png.c line 36
void write_png(struct _IO_FILE *file, void *image, signed int width, signed int height, struct anonymous_19 *fpc, signed int bpc);
// xform_precalc
// file variations.h line 136
void xform_precalc(struct anonymous_0 *cp, signed int xi);
// xmlAddChild
// file /usr/include/libxml2/libxml/tree.h line 942
struct _xmlNode * xmlAddChild(struct _xmlNode *, struct _xmlNode *);
// xmlCleanupParser
// file /usr/include/libxml2/libxml/parser.h line 825
void xmlCleanupParser(void);
// xmlCopyNode
// file /usr/include/libxml2/libxml/tree.h line 884
struct _xmlNode * xmlCopyNode(struct _xmlNode *, signed int);
// xmlDocGetRootElement
// file /usr/include/libxml2/libxml/tree.h line 920
struct _xmlNode * xmlDocGetRootElement(const struct _xmlDoc *);
// xmlDocSetRootElement
// file /usr/include/libxml2/libxml/tree.h line 933
struct _xmlNode * xmlDocSetRootElement(struct _xmlDoc *, struct _xmlNode *);
// xmlFree_object
//
void xmlFree_object(void *);
// xmlFreeDoc
// file /usr/include/libxml2/libxml/tree.h line 782
void xmlFreeDoc(struct _xmlDoc *);
// xmlGetProp
// file /usr/include/libxml2/libxml/tree.h line 1029
unsigned char * xmlGetProp(const struct _xmlNode *, const unsigned char *);
// xmlIsBlankNode
// file /usr/include/libxml2/libxml/tree.h line 926
signed int xmlIsBlankNode(const struct _xmlNode *);
// xmlNewChild
// file /usr/include/libxml2/libxml/tree.h line 844
struct _xmlNode * xmlNewChild(struct _xmlNode *, struct _xmlNs *, const unsigned char *, const unsigned char *);
// xmlNewDoc
// file /usr/include/libxml2/libxml/tree.h line 780
struct _xmlDoc * xmlNewDoc(const unsigned char *);
// xmlNewNode
// file /usr/include/libxml2/libxml/tree.h line 837
struct _xmlNode * xmlNewNode(struct _xmlNs *, const unsigned char *);
// xmlNewProp
// file /usr/include/libxml2/libxml/tree.h line 790
struct _xmlAttr * xmlNewProp(struct _xmlNode *, const unsigned char *, const unsigned char *);
// xmlNodeGetContent
// file /usr/include/libxml2/libxml/tree.h line 1076
unsigned char * xmlNodeGetContent(const struct _xmlNode *);
// xmlReadMemory
// file /usr/include/libxml2/libxml/parser.h line 1138
struct _xmlDoc * xmlReadMemory(const char *, signed int, const char *, const char *, signed int);
// xmlStrcmp
// file /usr/include/libxml2/libxml/xmlstring.h line 64
signed int xmlStrcmp(const unsigned char *, const unsigned char *);
// zero_matrix
// file interpolation.h line 39
signed int zero_matrix(double (*s)[2l]);

struct anonymous_15
{
  // b
  double (*b)[5l];
  // accumulate
  double (*accumulate)[4l];
  // width
  signed int width;
  // height
  signed int height;
  // oversample
  signed int oversample;
  // de
  struct anonymous_6 *de;
  // k1
  double k1;
  // k2
  double k2;
  // curve
  double curve;
  // last_thread
  signed int last_thread;
  // start_row
  signed int start_row;
  // end_row
  signed int end_row;
  // spec
  struct anonymous_4 *spec;
  // aborted
  signed int *aborted;
  // progress_size
  signed int progress_size;
};

struct anonymous_17
{
  // b
  unsigned int (*b)[5l];
  // accumulate
  float (*accumulate)[4l];
  // width
  signed int width;
  // height
  signed int height;
  // oversample
  signed int oversample;
  // de
  struct anonymous_6 *de;
  // k1
  double k1;
  // k2
  double k2;
  // curve
  double curve;
  // last_thread
  signed int last_thread;
  // start_row
  signed int start_row;
  // end_row
  signed int end_row;
  // spec
  struct anonymous_4 *spec;
  // aborted
  signed int *aborted;
  // progress_size
  signed int progress_size;
};

struct anonymous_16
{
  // b
  unsigned int (*b)[5l];
  // accumulate
  unsigned int (*accumulate)[4l];
  // width
  signed int width;
  // height
  signed int height;
  // oversample
  signed int oversample;
  // de
  struct anonymous_6 *de;
  // k1
  double k1;
  // k2
  double k2;
  // curve
  double curve;
  // last_thread
  signed int last_thread;
  // start_row
  signed int start_row;
  // end_row
  signed int end_row;
  // spec
  struct anonymous_4 *spec;
  // aborted
  signed int *aborted;
  // progress_size
  signed int progress_size;
};

struct randctx
{
  // randcnt
  unsigned long int randcnt;
  // randrsl
  unsigned long int randrsl[16l];
  // randmem
  unsigned long int randmem[16l];
  // randa
  unsigned long int randa;
  // randb
  unsigned long int randb;
  // randc
  unsigned long int randc;
};

struct anonymous_1
{
  // index
  double index;
  // color
  double color[4l];
};

struct anonymous_0
{
  // flame_name
  char flame_name[65l];
  // time
  double time;
  // interpolation
  signed int interpolation;
  // interpolation_type
  signed int interpolation_type;
  // palette_interpolation
  signed int palette_interpolation;
  // num_xforms
  signed int num_xforms;
  // final_xform_index
  signed int final_xform_index;
  // final_xform_enable
  signed int final_xform_enable;
  // xform
  struct xform *xform;
  // chaos
  double **chaos;
  // chaos_enable
  signed int chaos_enable;
  // genome_index
  signed int genome_index;
  // parent_fname
  char parent_fname[30l];
  // symmetry
  signed int symmetry;
  // palette
  struct anonymous_1 palette[256l];
  // input_image
  char *input_image;
  // palette_index
  signed int palette_index;
  // brightness
  double brightness;
  // contrast
  double contrast;
  // gamma
  double gamma;
  // highlight_power
  double highlight_power;
  // width
  signed int width;
  // height
  signed int height;
  // spatial_oversample
  signed int spatial_oversample;
  // center
  double center[2l];
  // rot_center
  double rot_center[2l];
  // rotate
  double rotate;
  // vibrancy
  double vibrancy;
  // hue_rotation
  double hue_rotation;
  // background
  double background[3l];
  // zoom
  double zoom;
  // pixels_per_unit
  double pixels_per_unit;
  // spatial_filter_radius
  double spatial_filter_radius;
  // spatial_filter_select
  signed int spatial_filter_select;
  // sample_density
  double sample_density;
  // nbatches
  signed int nbatches;
  // ntemporal_samples
  signed int ntemporal_samples;
  // estimator
  double estimator;
  // estimator_curve
  double estimator_curve;
  // estimator_minimum
  double estimator_minimum;
  // edits
  struct _xmlDoc *edits;
  // gam_lin_thresh
  double gam_lin_thresh;
  // palette_index0
  signed int palette_index0;
  // hue_rotation0
  double hue_rotation0;
  // palette_index1
  signed int palette_index1;
  // hue_rotation1
  double hue_rotation1;
  // palette_blend
  double palette_blend;
  // temporal_filter_type
  signed int temporal_filter_type;
  // temporal_filter_width
  double temporal_filter_width;
  // temporal_filter_exp
  double temporal_filter_exp;
  // palette_mode
  signed int palette_mode;
};

struct anonymous_13
{
  // iter_storage
  double *iter_storage;
  // rc
  struct randctx rc;
  // cp
  struct anonymous_0 cp;
  // first_thread
  signed int first_thread;
  // timer_initialize
  signed int timer_initialize;
  // fic
  struct anonymous_12 *fic;
};

struct anonymous_19
{
  // genome
  char *genome;
  // badvals
  char *badvals;
  // numiters
  char *numiters;
  // rtime
  char *rtime;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_10
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous_12
{
  // xform_distrib
  unsigned short int *xform_distrib;
  // spec
  struct anonymous_4 *spec;
  // bounds
  double bounds[4l];
  // rot
  double rot[2l][2l];
  // size
  double size[2l];
  // width
  signed int width;
  // height
  signed int height;
  // ws0
  double ws0;
  // wb0s0
  double wb0s0;
  // hs1
  double hs1;
  // hb1s1
  double hb1s1;
  // dmap
  struct anonymous_1 *dmap;
  // color_scalar
  double color_scalar;
  // buckets
  void *buckets;
  // badvals
  double badvals;
  // batch_size
  double batch_size;
  // temporal_sample_num
  signed int temporal_sample_num;
  // ntemporal_samples
  signed int ntemporal_samples;
  // batch_num
  signed int batch_num;
  // nbatches
  signed int nbatches;
  // aborted
  signed int aborted;
  // progress_timer
  signed long int *progress_timer;
  // progress_timer_history
  signed long int *progress_timer_history;
  // progress_history
  double *progress_history;
  // progress_history_mark
  signed int *progress_history_mark;
  // bucket_mutex
  union anonymous_10 bucket_mutex;
};

struct anonymous_3
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_24
{
  // bits
  unsigned char bits[17l];
  // huffval
  unsigned char huffval[256l];
  // sent_table
  signed int sent_table;
};

struct anonymous_23
{
  // quantval
  unsigned short int quantval[64l];
  // sent_table
  signed int sent_table;
};

struct anonymous_8
{
  // badvals
  double badvals;
  // num_iters
  signed long int num_iters;
  // render_seconds
  signed int render_seconds;
};

struct anonymous_4
{
  // pixel_aspect_ratio
  double pixel_aspect_ratio;
  // genomes
  struct anonymous_0 *genomes;
  // ngenomes
  signed int ngenomes;
  // verbose
  signed int verbose;
  // bits
  signed int bits;
  // bytes_per_channel
  signed int bytes_per_channel;
  // earlyclip
  signed int earlyclip;
  // time
  double time;
  // progress
  signed int (*progress)(void *, double, signed int, double);
  // progress_parameter
  void *progress_parameter;
  // rc
  struct randctx rc;
  // nthreads
  signed int nthreads;
  // sub_batch_size
  signed int sub_batch_size;
};

struct anonymous_9
{
  // tx
  double tx;
  // ty
  double ty;
  // precalc_atan
  double precalc_atan;
  // precalc_sina
  double precalc_sina;
  // precalc_cosa
  double precalc_cosa;
  // precalc_sqrt
  double precalc_sqrt;
  // precalc_sumsq
  double precalc_sumsq;
  // precalc_atanyx
  double precalc_atanyx;
  // xform
  struct xform *xform;
  // p0
  double p0;
  // p1
  double p1;
  // rc
  struct randctx *rc;
};

struct anonymous_25
{
  // component_id
  signed int component_id;
  // component_index
  signed int component_index;
  // h_samp_factor
  signed int h_samp_factor;
  // v_samp_factor
  signed int v_samp_factor;
  // quant_tbl_no
  signed int quant_tbl_no;
  // dc_tbl_no
  signed int dc_tbl_no;
  // ac_tbl_no
  signed int ac_tbl_no;
  // width_in_blocks
  unsigned int width_in_blocks;
  // height_in_blocks
  unsigned int height_in_blocks;
  // DCT_scaled_size
  signed int DCT_scaled_size;
  // downsampled_width
  unsigned int downsampled_width;
  // downsampled_height
  unsigned int downsampled_height;
  // component_needed
  signed int component_needed;
  // MCU_width
  signed int MCU_width;
  // MCU_height
  signed int MCU_height;
  // MCU_blocks
  signed int MCU_blocks;
  // MCU_sample_width
  signed int MCU_sample_width;
  // last_col_width
  signed int last_col_width;
  // last_row_height
  signed int last_row_height;
  // quant_table
  struct anonymous_23 *quant_table;
  // dct_table
  void *dct_table;
};

struct anonymous
{
  // comps_in_scan
  signed int comps_in_scan;
  // component_index
  signed int component_index[4l];
  // Ss
  signed int Ss;
  // Se
  signed int Se;
  // Ah
  signed int Ah;
  // Al
  signed int Al;
};

struct anonymous_7
{
  // from
  signed int from;
  // to
  signed int to;
  // scalar
  double scalar;
};

struct anonymous_6
{
  // max_filtered_counts
  signed int max_filtered_counts;
  // max_filter_index
  signed int max_filter_index;
  // kernel_size
  signed int kernel_size;
  // filter_widths
  double *filter_widths;
  // filter_coefs
  double *filter_coefs;
};

struct anonymous_18
{
  // number
  signed int number;
  // name
  char name[64l];
  // colors
  unsigned char colors[256l][3l];
};

union anonymous_11
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_26
{
  // i
  signed int i[8l];
  // s
  char s[80l];
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct __jmp_buf_tag
{
  // __jmpbuf
  signed long int __jmpbuf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
  // __saved_mask
  struct anonymous_3 __saved_mask;
};

struct _xmlAttr
{
  // _private
  void *_private;
  // type
  enum anonymous_2 type;
  // name
  const unsigned char *name;
  // children
  struct _xmlNode *children;
  // last
  struct _xmlNode *last;
  // parent
  struct _xmlNode *parent;
  // next
  struct _xmlAttr *next;
  // prev
  struct _xmlAttr *prev;
  // doc
  struct _xmlDoc *doc;
  // ns
  struct _xmlNs *ns;
  // atype
  enum anonymous_5 atype;
  // psvi
  void *psvi;
};

struct _xmlDoc
{
  // _private
  void *_private;
  // type
  enum anonymous_2 type;
  // name
  char *name;
  // children
  struct _xmlNode *children;
  // last
  struct _xmlNode *last;
  // parent
  struct _xmlNode *parent;
  // next
  struct _xmlNode *next;
  // prev
  struct _xmlNode *prev;
  // doc
  struct _xmlDoc *doc;
  // compression
  signed int compression;
  // standalone
  signed int standalone;
  // intSubset
  struct _xmlDtd *intSubset;
  // extSubset
  struct _xmlDtd *extSubset;
  // oldNs
  struct _xmlNs *oldNs;
  // version
  const unsigned char *version;
  // encoding
  const unsigned char *encoding;
  // ids
  void *ids;
  // refs
  void *refs;
  // URL
  const unsigned char *URL;
  // charset
  signed int charset;
  // dict
  struct _xmlDict *dict;
  // psvi
  void *psvi;
  // parseFlags
  signed int parseFlags;
  // properties
  signed int properties;
};

struct _xmlDtd
{
  // _private
  void *_private;
  // type
  enum anonymous_2 type;
  // name
  const unsigned char *name;
  // children
  struct _xmlNode *children;
  // last
  struct _xmlNode *last;
  // parent
  struct _xmlDoc *parent;
  // next
  struct _xmlNode *next;
  // prev
  struct _xmlNode *prev;
  // doc
  struct _xmlDoc *doc;
  // notations
  void *notations;
  // elements
  void *elements;
  // attributes
  void *attributes;
  // entities
  void *entities;
  // ExternalID
  const unsigned char *ExternalID;
  // SystemID
  const unsigned char *SystemID;
  // pentities
  void *pentities;
};

struct _xmlNode
{
  // _private
  void *_private;
  // type
  enum anonymous_2 type;
  // name
  const unsigned char *name;
  // children
  struct _xmlNode *children;
  // last
  struct _xmlNode *last;
  // parent
  struct _xmlNode *parent;
  // next
  struct _xmlNode *next;
  // prev
  struct _xmlNode *prev;
  // doc
  struct _xmlDoc *doc;
  // ns
  struct _xmlNs *ns;
  // content
  unsigned char *content;
  // properties
  struct _xmlAttr *properties;
  // nsDef
  struct _xmlNs *nsDef;
  // psvi
  void *psvi;
  // line
  unsigned short int line;
  // extra
  unsigned short int extra;
};

struct _xmlNs
{
  // next
  struct _xmlNs *next;
  // type
  enum anonymous_2 type;
  // href
  const unsigned char *href;
  // prefix
  const unsigned char *prefix;
  // _private
  void *_private;
  // context
  struct _xmlDoc *context;
};

struct internal_state
{
  // dummy
  signed int dummy;
};

struct jpeg_common_struct
{
  // err
  struct jpeg_error_mgr *err;
  // mem
  struct jpeg_memory_mgr *mem;
  // progress
  struct jpeg_progress_mgr *progress;
  // client_data
  void *client_data;
  // is_decompressor
  signed int is_decompressor;
  // global_state
  signed int global_state;
};

struct jpeg_compress_struct
{
  // err
  struct jpeg_error_mgr *err;
  // mem
  struct jpeg_memory_mgr *mem;
  // progress
  struct jpeg_progress_mgr *progress;
  // client_data
  void *client_data;
  // is_decompressor
  signed int is_decompressor;
  // global_state
  signed int global_state;
  // dest
  struct jpeg_destination_mgr *dest;
  // image_width
  unsigned int image_width;
  // image_height
  unsigned int image_height;
  // input_components
  signed int input_components;
  // in_color_space
  enum anonymous_20 in_color_space;
  // input_gamma
  double input_gamma;
  // data_precision
  signed int data_precision;
  // num_components
  signed int num_components;
  // jpeg_color_space
  enum anonymous_20 jpeg_color_space;
  // comp_info
  struct anonymous_25 *comp_info;
  // quant_tbl_ptrs
  struct anonymous_23 *quant_tbl_ptrs[4l];
  // dc_huff_tbl_ptrs
  struct anonymous_24 *dc_huff_tbl_ptrs[4l];
  // ac_huff_tbl_ptrs
  struct anonymous_24 *ac_huff_tbl_ptrs[4l];
  // arith_dc_L
  unsigned char arith_dc_L[16l];
  // arith_dc_U
  unsigned char arith_dc_U[16l];
  // arith_ac_K
  unsigned char arith_ac_K[16l];
  // num_scans
  signed int num_scans;
  // scan_info
  const struct anonymous *scan_info;
  // raw_data_in
  signed int raw_data_in;
  // arith_code
  signed int arith_code;
  // optimize_coding
  signed int optimize_coding;
  // CCIR601_sampling
  signed int CCIR601_sampling;
  // smoothing_factor
  signed int smoothing_factor;
  // dct_method
  enum anonymous_21 dct_method;
  // restart_interval
  unsigned int restart_interval;
  // restart_in_rows
  signed int restart_in_rows;
  // write_JFIF_header
  signed int write_JFIF_header;
  // JFIF_major_version
  unsigned char JFIF_major_version;
  // JFIF_minor_version
  unsigned char JFIF_minor_version;
  // density_unit
  unsigned char density_unit;
  // X_density
  unsigned short int X_density;
  // Y_density
  unsigned short int Y_density;
  // write_Adobe_marker
  signed int write_Adobe_marker;
  // next_scanline
  unsigned int next_scanline;
  // progressive_mode
  signed int progressive_mode;
  // max_h_samp_factor
  signed int max_h_samp_factor;
  // max_v_samp_factor
  signed int max_v_samp_factor;
  // total_iMCU_rows
  unsigned int total_iMCU_rows;
  // comps_in_scan
  signed int comps_in_scan;
  // cur_comp_info
  struct anonymous_25 *cur_comp_info[4l];
  // MCUs_per_row
  unsigned int MCUs_per_row;
  // MCU_rows_in_scan
  unsigned int MCU_rows_in_scan;
  // blocks_in_MCU
  signed int blocks_in_MCU;
  // MCU_membership
  signed int MCU_membership[10l];
  // Ss
  signed int Ss;
  // Se
  signed int Se;
  // Ah
  signed int Ah;
  // Al
  signed int Al;
  // master
  struct jpeg_comp_master *master;
  // main
  struct jpeg_c_main_controller *main;
  // prep
  struct jpeg_c_prep_controller *prep;
  // coef
  struct jpeg_c_coef_controller *coef;
  // marker
  struct jpeg_marker_writer *marker;
  // cconvert
  struct jpeg_color_converter *cconvert;
  // downsample
  struct jpeg_downsampler *downsample;
  // fdct
  struct jpeg_forward_dct *fdct;
  // entropy
  struct jpeg_entropy_encoder *entropy;
  // script_space
  struct anonymous *script_space;
  // script_space_size
  signed int script_space_size;
};

struct jpeg_decompress_struct
{
  // err
  struct jpeg_error_mgr *err;
  // mem
  struct jpeg_memory_mgr *mem;
  // progress
  struct jpeg_progress_mgr *progress;
  // client_data
  void *client_data;
  // is_decompressor
  signed int is_decompressor;
  // global_state
  signed int global_state;
  // src
  struct jpeg_source_mgr *src;
  // image_width
  unsigned int image_width;
  // image_height
  unsigned int image_height;
  // num_components
  signed int num_components;
  // jpeg_color_space
  enum anonymous_20 jpeg_color_space;
  // out_color_space
  enum anonymous_20 out_color_space;
  // scale_num
  unsigned int scale_num;
  // scale_denom
  unsigned int scale_denom;
  // output_gamma
  double output_gamma;
  // buffered_image
  signed int buffered_image;
  // raw_data_out
  signed int raw_data_out;
  // dct_method
  enum anonymous_21 dct_method;
  // do_fancy_upsampling
  signed int do_fancy_upsampling;
  // do_block_smoothing
  signed int do_block_smoothing;
  // quantize_colors
  signed int quantize_colors;
  // dither_mode
  enum anonymous_22 dither_mode;
  // two_pass_quantize
  signed int two_pass_quantize;
  // desired_number_of_colors
  signed int desired_number_of_colors;
  // enable_1pass_quant
  signed int enable_1pass_quant;
  // enable_external_quant
  signed int enable_external_quant;
  // enable_2pass_quant
  signed int enable_2pass_quant;
  // output_width
  unsigned int output_width;
  // output_height
  unsigned int output_height;
  // out_color_components
  signed int out_color_components;
  // output_components
  signed int output_components;
  // rec_outbuf_height
  signed int rec_outbuf_height;
  // actual_number_of_colors
  signed int actual_number_of_colors;
  // colormap
  unsigned char **colormap;
  // output_scanline
  unsigned int output_scanline;
  // input_scan_number
  signed int input_scan_number;
  // input_iMCU_row
  unsigned int input_iMCU_row;
  // output_scan_number
  signed int output_scan_number;
  // output_iMCU_row
  unsigned int output_iMCU_row;
  // coef_bits
  signed int (*coef_bits)[64l];
  // quant_tbl_ptrs
  struct anonymous_23 *quant_tbl_ptrs[4l];
  // dc_huff_tbl_ptrs
  struct anonymous_24 *dc_huff_tbl_ptrs[4l];
  // ac_huff_tbl_ptrs
  struct anonymous_24 *ac_huff_tbl_ptrs[4l];
  // data_precision
  signed int data_precision;
  // comp_info
  struct anonymous_25 *comp_info;
  // progressive_mode
  signed int progressive_mode;
  // arith_code
  signed int arith_code;
  // arith_dc_L
  unsigned char arith_dc_L[16l];
  // arith_dc_U
  unsigned char arith_dc_U[16l];
  // arith_ac_K
  unsigned char arith_ac_K[16l];
  // restart_interval
  unsigned int restart_interval;
  // saw_JFIF_marker
  signed int saw_JFIF_marker;
  // JFIF_major_version
  unsigned char JFIF_major_version;
  // JFIF_minor_version
  unsigned char JFIF_minor_version;
  // density_unit
  unsigned char density_unit;
  // X_density
  unsigned short int X_density;
  // Y_density
  unsigned short int Y_density;
  // saw_Adobe_marker
  signed int saw_Adobe_marker;
  // Adobe_transform
  unsigned char Adobe_transform;
  // CCIR601_sampling
  signed int CCIR601_sampling;
  // marker_list
  struct jpeg_marker_struct *marker_list;
  // max_h_samp_factor
  signed int max_h_samp_factor;
  // max_v_samp_factor
  signed int max_v_samp_factor;
  // min_DCT_scaled_size
  signed int min_DCT_scaled_size;
  // total_iMCU_rows
  unsigned int total_iMCU_rows;
  // sample_range_limit
  unsigned char *sample_range_limit;
  // comps_in_scan
  signed int comps_in_scan;
  // cur_comp_info
  struct anonymous_25 *cur_comp_info[4l];
  // MCUs_per_row
  unsigned int MCUs_per_row;
  // MCU_rows_in_scan
  unsigned int MCU_rows_in_scan;
  // blocks_in_MCU
  signed int blocks_in_MCU;
  // MCU_membership
  signed int MCU_membership[10l];
  // Ss
  signed int Ss;
  // Se
  signed int Se;
  // Ah
  signed int Ah;
  // Al
  signed int Al;
  // unread_marker
  signed int unread_marker;
  // master
  struct jpeg_decomp_master *master;
  // main
  struct jpeg_d_main_controller *main;
  // coef
  struct jpeg_d_coef_controller *coef;
  // post
  struct jpeg_d_post_controller *post;
  // inputctl
  struct jpeg_input_controller *inputctl;
  // marker
  struct jpeg_marker_reader *marker;
  // entropy
  struct jpeg_entropy_decoder *entropy;
  // idct
  struct jpeg_inverse_dct *idct;
  // upsample
  struct jpeg_upsampler *upsample;
  // cconvert
  struct jpeg_color_deconverter *cconvert;
  // cquantize
  struct jpeg_color_quantizer *cquantize;
};

struct jpeg_destination_mgr
{
  // next_output_byte
  unsigned char *next_output_byte;
  // free_in_buffer
  unsigned long int free_in_buffer;
  // init_destination
  void (*init_destination)(struct jpeg_compress_struct *);
  // empty_output_buffer
  signed int (*empty_output_buffer)(struct jpeg_compress_struct *);
  // term_destination
  void (*term_destination)(struct jpeg_compress_struct *);
};

struct jpeg_error_mgr
{
  // error_exit
  void (*error_exit)(struct jpeg_common_struct *);
  // emit_message
  void (*emit_message)(struct jpeg_common_struct *, signed int);
  // output_message
  void (*output_message)(struct jpeg_common_struct *);
  // format_message
  void (*format_message)(struct jpeg_common_struct *, char *);
  // reset_error_mgr
  void (*reset_error_mgr)(struct jpeg_common_struct *);
  // msg_code
  signed int msg_code;
  // msg_parm
  union anonymous_26 msg_parm;
  // trace_level
  signed int trace_level;
  // num_warnings
  signed long int num_warnings;
  // jpeg_message_table
  const char * const *jpeg_message_table;
  // last_jpeg_message
  signed int last_jpeg_message;
  // addon_message_table
  const char * const *addon_message_table;
  // first_addon_message
  signed int first_addon_message;
  // last_addon_message
  signed int last_addon_message;
};

struct jpeg_marker_struct
{
  // next
  struct jpeg_marker_struct *next;
  // marker
  unsigned char marker;
  // original_length
  unsigned int original_length;
  // data_length
  unsigned int data_length;
  // data
  unsigned char *data;
};

struct jpeg_memory_mgr
{
  // alloc_small
  void * (*alloc_small)(struct jpeg_common_struct *, signed int, unsigned long int);
  // alloc_large
  void * (*alloc_large)(struct jpeg_common_struct *, signed int, unsigned long int);
  // alloc_sarray
  unsigned char ** (*alloc_sarray)(struct jpeg_common_struct *, signed int, unsigned int, unsigned int);
  // alloc_barray
  signed short int (**(*alloc_barray)(struct jpeg_common_struct *, signed int, unsigned int, unsigned int))[64l];
  // request_virt_sarray
  struct jvirt_sarray_control * (*request_virt_sarray)(struct jpeg_common_struct *, signed int, signed int, unsigned int, unsigned int, unsigned int);
  // request_virt_barray
  struct jvirt_barray_control * (*request_virt_barray)(struct jpeg_common_struct *, signed int, signed int, unsigned int, unsigned int, unsigned int);
  // realize_virt_arrays
  void (*realize_virt_arrays)(struct jpeg_common_struct *);
  // access_virt_sarray
  unsigned char ** (*access_virt_sarray)(struct jpeg_common_struct *, struct jvirt_sarray_control *, unsigned int, unsigned int, signed int);
  // access_virt_barray
  signed short int (**(*access_virt_barray)(struct jpeg_common_struct *, struct jvirt_barray_control *, unsigned int, unsigned int, signed int))[64l];
  // free_pool
  void (*free_pool)(struct jpeg_common_struct *, signed int);
  // self_destruct
  void (*self_destruct)(struct jpeg_common_struct *);
  // max_memory_to_use
  signed long int max_memory_to_use;
  // max_alloc_chunk
  signed long int max_alloc_chunk;
};

struct jpeg_progress_mgr
{
  // progress_monitor
  void (*progress_monitor)(struct jpeg_common_struct *);
  // pass_counter
  signed long int pass_counter;
  // pass_limit
  signed long int pass_limit;
  // completed_passes
  signed int completed_passes;
  // total_passes
  signed int total_passes;
};

struct jpeg_source_mgr
{
  // next_input_byte
  const unsigned char *next_input_byte;
  // bytes_in_buffer
  unsigned long int bytes_in_buffer;
  // init_source
  void (*init_source)(struct jpeg_decompress_struct *);
  // fill_input_buffer
  signed int (*fill_input_buffer)(struct jpeg_decompress_struct *);
  // skip_input_data
  void (*skip_input_data)(struct jpeg_decompress_struct *, signed long int);
  // resync_to_restart
  signed int (*resync_to_restart)(struct jpeg_decompress_struct *, signed int);
  // term_source
  void (*term_source)(struct jpeg_decompress_struct *);
};

struct png_color_16_struct
{
  // index
  unsigned char index;
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
  // gray
  unsigned short int gray;
};

struct png_color_8_struct
{
  // red
  unsigned char red;
  // green
  unsigned char green;
  // blue
  unsigned char blue;
  // gray
  unsigned char gray;
  // alpha
  unsigned char alpha;
};

struct png_color_struct
{
  // red
  unsigned char red;
  // green
  unsigned char green;
  // blue
  unsigned char blue;
};

struct png_time_struct
{
  // year
  unsigned short int year;
  // month
  unsigned char month;
  // day
  unsigned char day;
  // hour
  unsigned char hour;
  // minute
  unsigned char minute;
  // second
  unsigned char second;
};

struct png_info_struct
{
  // width
  unsigned long int width;
  // height
  unsigned long int height;
  // valid
  unsigned long int valid;
  // rowbytes
  unsigned long int rowbytes;
  // palette
  struct png_color_struct *palette;
  // num_palette
  unsigned short int num_palette;
  // num_trans
  unsigned short int num_trans;
  // bit_depth
  unsigned char bit_depth;
  // color_type
  unsigned char color_type;
  // compression_type
  unsigned char compression_type;
  // filter_type
  unsigned char filter_type;
  // interlace_type
  unsigned char interlace_type;
  // channels
  unsigned char channels;
  // pixel_depth
  unsigned char pixel_depth;
  // spare_byte
  unsigned char spare_byte;
  // signature
  unsigned char signature[8l];
  // gamma
  float gamma;
  // srgb_intent
  unsigned char srgb_intent;
  // num_text
  signed int num_text;
  // max_text
  signed int max_text;
  // text
  struct png_text_struct *text;
  // mod_time
  struct png_time_struct mod_time;
  // sig_bit
  struct png_color_8_struct sig_bit;
  // trans
  unsigned char *trans;
  // trans_values
  struct png_color_16_struct trans_values;
  // background
  struct png_color_16_struct background;
  // x_offset
  signed long int x_offset;
  // y_offset
  signed long int y_offset;
  // offset_unit_type
  unsigned char offset_unit_type;
  // x_pixels_per_unit
  unsigned long int x_pixels_per_unit;
  // y_pixels_per_unit
  unsigned long int y_pixels_per_unit;
  // phys_unit_type
  unsigned char phys_unit_type;
  // hist
  unsigned short int *hist;
  // x_white
  float x_white;
  // y_white
  float y_white;
  // x_red
  float x_red;
  // y_red
  float y_red;
  // x_green
  float x_green;
  // y_green
  float y_green;
  // x_blue
  float x_blue;
  // y_blue
  float y_blue;
  // pcal_purpose
  char *pcal_purpose;
  // pcal_X0
  signed long int pcal_X0;
  // pcal_X1
  signed long int pcal_X1;
  // pcal_units
  char *pcal_units;
  // pcal_params
  char **pcal_params;
  // pcal_type
  unsigned char pcal_type;
  // pcal_nparams
  unsigned char pcal_nparams;
  // free_me
  unsigned long int free_me;
  // unknown_chunks
  struct png_unknown_chunk_t *unknown_chunks;
  // unknown_chunks_num
  unsigned long int unknown_chunks_num;
  // iccp_name
  char *iccp_name;
  // iccp_profile
  char *iccp_profile;
  // iccp_proflen
  unsigned long int iccp_proflen;
  // iccp_compression
  unsigned char iccp_compression;
  // splt_palettes
  struct png_sPLT_struct *splt_palettes;
  // splt_palettes_num
  unsigned long int splt_palettes_num;
  // scal_unit
  unsigned char scal_unit;
  // scal_pixel_width
  double scal_pixel_width;
  // scal_pixel_height
  double scal_pixel_height;
  // scal_s_width
  char *scal_s_width;
  // scal_s_height
  char *scal_s_height;
  // row_pointers
  unsigned char **row_pointers;
  // int_gamma
  signed long int int_gamma;
  // int_x_white
  signed long int int_x_white;
  // int_y_white
  signed long int int_y_white;
  // int_x_red
  signed long int int_x_red;
  // int_y_red
  signed long int int_y_red;
  // int_x_green
  signed long int int_x_green;
  // int_y_green
  signed long int int_y_green;
  // int_x_blue
  signed long int int_x_blue;
  // int_y_blue
  signed long int int_y_blue;
};

struct png_row_info_struct
{
  // width
  unsigned long int width;
  // rowbytes
  unsigned long int rowbytes;
  // color_type
  unsigned char color_type;
  // bit_depth
  unsigned char bit_depth;
  // channels
  unsigned char channels;
  // pixel_depth
  unsigned char pixel_depth;
};

struct png_sPLT_entry_struct
{
  // red
  unsigned short int red;
  // green
  unsigned short int green;
  // blue
  unsigned short int blue;
  // alpha
  unsigned short int alpha;
  // frequency
  unsigned short int frequency;
};

struct png_sPLT_struct
{
  // name
  char *name;
  // depth
  unsigned char depth;
  // entries
  struct png_sPLT_entry_struct *entries;
  // nentries
  signed long int nentries;
};

struct z_stream_s
{
  // next_in
  unsigned char *next_in;
  // avail_in
  unsigned int avail_in;
  // total_in
  unsigned long int total_in;
  // next_out
  unsigned char *next_out;
  // avail_out
  unsigned int avail_out;
  // total_out
  unsigned long int total_out;
  // msg
  char *msg;
  // state
  struct internal_state *state;
  // zalloc
  void * (*zalloc)(void *, unsigned int, unsigned int);
  // zfree
  void (*zfree)(void *, void *);
  // opaque
  void *opaque;
  // data_type
  signed int data_type;
  // adler
  unsigned long int adler;
  // reserved
  unsigned long int reserved;
};

struct png_unknown_chunk_t
{
  // name
  unsigned char name[5l];
  // data
  unsigned char *data;
  // size
  unsigned long int size;
  // location
  unsigned char location;
};

struct png_struct_def
{
  // jmpbuf
  struct __jmp_buf_tag jmpbuf[1l];
  // error_fn
  void (*error_fn)(struct png_struct_def *, const char *);
  // warning_fn
  void (*warning_fn)(struct png_struct_def *, const char *);
  // error_ptr
  void *error_ptr;
  // write_data_fn
  void (*write_data_fn)(struct png_struct_def *, unsigned char *, unsigned long int);
  // read_data_fn
  void (*read_data_fn)(struct png_struct_def *, unsigned char *, unsigned long int);
  // io_ptr
  void *io_ptr;
  // read_user_transform_fn
  void (*read_user_transform_fn)(struct png_struct_def *, struct png_row_info_struct *, unsigned char *);
  // write_user_transform_fn
  void (*write_user_transform_fn)(struct png_struct_def *, struct png_row_info_struct *, unsigned char *);
  // user_transform_ptr
  void *user_transform_ptr;
  // user_transform_depth
  unsigned char user_transform_depth;
  // user_transform_channels
  unsigned char user_transform_channels;
  // mode
  unsigned long int mode;
  // flags
  unsigned long int flags;
  // transformations
  unsigned long int transformations;
  // zstream
  struct z_stream_s zstream;
  // zbuf
  unsigned char *zbuf;
  // zbuf_size
  unsigned long int zbuf_size;
  // zlib_level
  signed int zlib_level;
  // zlib_method
  signed int zlib_method;
  // zlib_window_bits
  signed int zlib_window_bits;
  // zlib_mem_level
  signed int zlib_mem_level;
  // zlib_strategy
  signed int zlib_strategy;
  // width
  unsigned long int width;
  // height
  unsigned long int height;
  // num_rows
  unsigned long int num_rows;
  // usr_width
  unsigned long int usr_width;
  // rowbytes
  unsigned long int rowbytes;
  // user_chunk_cache_max
  unsigned long int user_chunk_cache_max;
  // iwidth
  unsigned long int iwidth;
  // row_number
  unsigned long int row_number;
  // prev_row
  unsigned char *prev_row;
  // row_buf
  unsigned char *row_buf;
  // sub_row
  unsigned char *sub_row;
  // up_row
  unsigned char *up_row;
  // avg_row
  unsigned char *avg_row;
  // paeth_row
  unsigned char *paeth_row;
  // row_info
  struct png_row_info_struct row_info;
  // idat_size
  unsigned long int idat_size;
  // crc
  unsigned long int crc;
  // palette
  struct png_color_struct *palette;
  // num_palette
  unsigned short int num_palette;
  // num_trans
  unsigned short int num_trans;
  // chunk_name
  unsigned char chunk_name[5l];
  // compression
  unsigned char compression;
  // filter
  unsigned char filter;
  // interlaced
  unsigned char interlaced;
  // pass
  unsigned char pass;
  // do_filter
  unsigned char do_filter;
  // color_type
  unsigned char color_type;
  // bit_depth
  unsigned char bit_depth;
  // usr_bit_depth
  unsigned char usr_bit_depth;
  // pixel_depth
  unsigned char pixel_depth;
  // channels
  unsigned char channels;
  // usr_channels
  unsigned char usr_channels;
  // sig_bytes
  unsigned char sig_bytes;
  // filler
  unsigned short int filler;
  // background_gamma_type
  unsigned char background_gamma_type;
  // background_gamma
  float background_gamma;
  // background
  struct png_color_16_struct background;
  // background_1
  struct png_color_16_struct background_1;
  // output_flush_fn
  void (*output_flush_fn)(struct png_struct_def *);
  // flush_dist
  unsigned long int flush_dist;
  // flush_rows
  unsigned long int flush_rows;
  // gamma_shift
  signed int gamma_shift;
  // gamma
  float gamma;
  // screen_gamma
  float screen_gamma;
  // gamma_table
  unsigned char *gamma_table;
  // gamma_from_1
  unsigned char *gamma_from_1;
  // gamma_to_1
  unsigned char *gamma_to_1;
  // gamma_16_table
  unsigned short int **gamma_16_table;
  // gamma_16_from_1
  unsigned short int **gamma_16_from_1;
  // gamma_16_to_1
  unsigned short int **gamma_16_to_1;
  // sig_bit
  struct png_color_8_struct sig_bit;
  // shift
  struct png_color_8_struct shift;
  // trans
  unsigned char *trans;
  // trans_values
  struct png_color_16_struct trans_values;
  // read_row_fn
  void (*read_row_fn)(struct png_struct_def *, unsigned long int, signed int);
  // write_row_fn
  void (*write_row_fn)(struct png_struct_def *, unsigned long int, signed int);
  // info_fn
  void (*info_fn)(struct png_struct_def *, struct png_info_struct *);
  // row_fn
  void (*row_fn)(struct png_struct_def *, unsigned char *, unsigned long int, signed int);
  // end_fn
  void (*end_fn)(struct png_struct_def *, struct png_info_struct *);
  // save_buffer_ptr
  unsigned char *save_buffer_ptr;
  // save_buffer
  unsigned char *save_buffer;
  // current_buffer_ptr
  unsigned char *current_buffer_ptr;
  // current_buffer
  unsigned char *current_buffer;
  // push_length
  unsigned long int push_length;
  // skip_length
  unsigned long int skip_length;
  // save_buffer_size
  unsigned long int save_buffer_size;
  // save_buffer_max
  unsigned long int save_buffer_max;
  // buffer_size
  unsigned long int buffer_size;
  // current_buffer_size
  unsigned long int current_buffer_size;
  // process_mode
  signed int process_mode;
  // cur_palette
  signed int cur_palette;
  // current_text_size
  unsigned long int current_text_size;
  // current_text_left
  unsigned long int current_text_left;
  // current_text
  char *current_text;
  // current_text_ptr
  char *current_text_ptr;
  // palette_lookup
  unsigned char *palette_lookup;
  // dither_index
  unsigned char *dither_index;
  // hist
  unsigned short int *hist;
  // time_buffer
  char *time_buffer;
  // free_me
  unsigned long int free_me;
  // user_chunk_ptr
  void *user_chunk_ptr;
  // read_user_chunk_fn
  signed int (*read_user_chunk_fn)(struct png_struct_def *, struct png_unknown_chunk_t *);
  // num_chunk_list
  signed int num_chunk_list;
  // chunk_list
  unsigned char *chunk_list;
  // rgb_to_gray_status
  unsigned char rgb_to_gray_status;
  // rgb_to_gray_red_coeff
  unsigned short int rgb_to_gray_red_coeff;
  // rgb_to_gray_green_coeff
  unsigned short int rgb_to_gray_green_coeff;
  // rgb_to_gray_blue_coeff
  unsigned short int rgb_to_gray_blue_coeff;
  // mng_features_permitted
  unsigned long int mng_features_permitted;
  // int_gamma
  signed long int int_gamma;
  // filter_type
  unsigned char filter_type;
  // mmx_bitdepth_threshold
  unsigned char mmx_bitdepth_threshold;
  // mmx_rowbytes_threshold
  unsigned long int mmx_rowbytes_threshold;
  // asm_flags
  unsigned long int asm_flags;
  // mem_ptr
  void *mem_ptr;
  // malloc_fn
  void * (*malloc_fn)(struct png_struct_def *, unsigned long int);
  // free_fn
  void (*free_fn)(struct png_struct_def *, void *);
  // big_row_buf
  unsigned char *big_row_buf;
  // dither_sort
  unsigned char *dither_sort;
  // index_to_palette
  unsigned char *index_to_palette;
  // palette_to_index
  unsigned char *palette_to_index;
  // compression_type
  unsigned char compression_type;
  // user_width_max
  unsigned long int user_width_max;
  // user_height_max
  unsigned long int user_height_max;
  // unknown_chunk
  struct png_unknown_chunk_t unknown_chunk;
  // old_big_row_buf_size
  unsigned long int old_big_row_buf_size;
  // old_prev_row_size
  unsigned long int old_prev_row_size;
  // chunkdata
  char *chunkdata;
};

struct png_text_struct
{
  // compression
  signed int compression;
  // key
  char *key;
  // text
  char *text;
  // text_length
  unsigned long int text_length;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct xform
{
  // var
  double var[98l];
  // c
  double c[3l][2l];
  // post
  double post[3l][2l];
  // density
  double density;
  // color
  double color;
  // color_speed
  double color_speed;
  // animate
  double animate;
  // opacity
  double opacity;
  // vis_adjusted
  double vis_adjusted;
  // padding
  signed int padding;
  // wind
  double wind[2l];
  // precalc_angles_flag
  signed int precalc_angles_flag;
  // precalc_atan_xy_flag
  signed int precalc_atan_xy_flag;
  // precalc_atan_yx_flag
  signed int precalc_atan_yx_flag;
  // has_preblur
  double has_preblur;
  // has_post
  signed int has_post;
  // blob_low
  double blob_low;
  // blob_high
  double blob_high;
  // blob_waves
  double blob_waves;
  // pdj_a
  double pdj_a;
  // pdj_b
  double pdj_b;
  // pdj_c
  double pdj_c;
  // pdj_d
  double pdj_d;
  // fan2_x
  double fan2_x;
  // fan2_y
  double fan2_y;
  // rings2_val
  double rings2_val;
  // perspective_angle
  double perspective_angle;
  // perspective_dist
  double perspective_dist;
  // julian_power
  double julian_power;
  // julian_dist
  double julian_dist;
  // juliascope_power
  double juliascope_power;
  // juliascope_dist
  double juliascope_dist;
  // radial_blur_angle
  double radial_blur_angle;
  // pie_slices
  double pie_slices;
  // pie_rotation
  double pie_rotation;
  // pie_thickness
  double pie_thickness;
  // ngon_sides
  double ngon_sides;
  // ngon_power
  double ngon_power;
  // ngon_circle
  double ngon_circle;
  // ngon_corners
  double ngon_corners;
  // curl_c1
  double curl_c1;
  // curl_c2
  double curl_c2;
  // rectangles_x
  double rectangles_x;
  // rectangles_y
  double rectangles_y;
  // amw_amp
  double amw_amp;
  // disc2_rot
  double disc2_rot;
  // disc2_twist
  double disc2_twist;
  // super_shape_rnd
  double super_shape_rnd;
  // super_shape_m
  double super_shape_m;
  // super_shape_n1
  double super_shape_n1;
  // super_shape_n2
  double super_shape_n2;
  // super_shape_n3
  double super_shape_n3;
  // super_shape_holes
  double super_shape_holes;
  // flower_petals
  double flower_petals;
  // flower_holes
  double flower_holes;
  // conic_eccentricity
  double conic_eccentricity;
  // conic_holes
  double conic_holes;
  // parabola_height
  double parabola_height;
  // parabola_width
  double parabola_width;
  // bent2_x
  double bent2_x;
  // bent2_y
  double bent2_y;
  // bipolar_shift
  double bipolar_shift;
  // cell_size
  double cell_size;
  // cpow_r
  double cpow_r;
  // cpow_i
  double cpow_i;
  // cpow_power
  double cpow_power;
  // curve_xamp
  double curve_xamp;
  // curve_yamp
  double curve_yamp;
  // curve_xlength
  double curve_xlength;
  // curve_ylength
  double curve_ylength;
  // escher_beta
  double escher_beta;
  // lazysusan_spin
  double lazysusan_spin;
  // lazysusan_space
  double lazysusan_space;
  // lazysusan_twist
  double lazysusan_twist;
  // lazysusan_x
  double lazysusan_x;
  // lazysusan_y
  double lazysusan_y;
  // modulus_x
  double modulus_x;
  // modulus_y
  double modulus_y;
  // oscope_separation
  double oscope_separation;
  // oscope_frequency
  double oscope_frequency;
  // oscope_amplitude
  double oscope_amplitude;
  // oscope_damping
  double oscope_damping;
  // popcorn2_x
  double popcorn2_x;
  // popcorn2_y
  double popcorn2_y;
  // popcorn2_c
  double popcorn2_c;
  // separation_x
  double separation_x;
  // separation_xinside
  double separation_xinside;
  // separation_y
  double separation_y;
  // separation_yinside
  double separation_yinside;
  // split_xsize
  double split_xsize;
  // split_ysize
  double split_ysize;
  // splits_x
  double splits_x;
  // splits_y
  double splits_y;
  // stripes_space
  double stripes_space;
  // stripes_warp
  double stripes_warp;
  // wedge_angle
  double wedge_angle;
  // wedge_hole
  double wedge_hole;
  // wedge_count
  double wedge_count;
  // wedge_swirl
  double wedge_swirl;
  // wedge_julia_angle
  double wedge_julia_angle;
  // wedge_julia_count
  double wedge_julia_count;
  // wedge_julia_power
  double wedge_julia_power;
  // wedge_julia_dist
  double wedge_julia_dist;
  // wedge_sph_angle
  double wedge_sph_angle;
  // wedge_sph_count
  double wedge_sph_count;
  // wedge_sph_hole
  double wedge_sph_hole;
  // wedge_sph_swirl
  double wedge_sph_swirl;
  // whorl_inside
  double whorl_inside;
  // whorl_outside
  double whorl_outside;
  // waves2_freqx
  double waves2_freqx;
  // waves2_scalex
  double waves2_scalex;
  // waves2_freqy
  double waves2_freqy;
  // waves2_scaley
  double waves2_scaley;
  // auger_sym
  double auger_sym;
  // auger_weight
  double auger_weight;
  // auger_freq
  double auger_freq;
  // auger_scale
  double auger_scale;
  // flux_spread
  double flux_spread;
  // persp_vsin
  double persp_vsin;
  // persp_vfcos
  double persp_vfcos;
  // julian_rN
  double julian_rN;
  // julian_cn
  double julian_cn;
  // juliascope_rN
  double juliascope_rN;
  // juliascope_cn
  double juliascope_cn;
  // wedgeJulia_rN
  double wedgeJulia_rN;
  // wedgeJulia_cn
  double wedgeJulia_cn;
  // wedgeJulia_cf
  double wedgeJulia_cf;
  // radialBlur_spinvar
  double radialBlur_spinvar;
  // radialBlur_zoomvar
  double radialBlur_zoomvar;
  // waves_dx2
  double waves_dx2;
  // waves_dy2
  double waves_dy2;
  // disc2_sinadd
  double disc2_sinadd;
  // disc2_cosadd
  double disc2_cosadd;
  // disc2_timespi
  double disc2_timespi;
  // super_shape_pm_4
  double super_shape_pm_4;
  // super_shape_pneg1_n1
  double super_shape_pneg1_n1;
  // num_active_vars
  signed int num_active_vars;
  // active_var_weights
  double active_var_weights[98l];
  // varFunc
  signed int varFunc[98l];
  // motion_freq
  signed int motion_freq;
  // motion_func
  signed int motion_func;
  // motion
  struct xform *motion;
  // num_motion
  signed int num_motion;
};


// flam3_conversion_failed
// file parser.c line 24
static signed int flam3_conversion_failed;
// flam3_spatial_support
// file filters.c line 29
double flam3_spatial_support[14l] = { 1.5, 1.0, 0.5, 1.0, 1.5, 2.0, 2.0, 1.0, 2.0, 1.0, 1.0, 3.0, 2.0, 1.5 };
// flam3_variation_names
// file variations.c line 35
char *flam3_variation_names[99l] = { "linear", "sinusoidal", "spherical", "swirl", "horseshoe", "polar", "handkerchief", "heart", "disc", "spiral", "hyperbolic", "diamond", "ex", "julia", "bent", "waves", "fisheye", "popcorn", "exponential", "power", "cosine", "rings", "fan", "blob", "pdj", "fan2", "rings2", "eyefish", "bubble", "cylinder", "perspective", "noise", "julian", "juliascope", "blur", "gaussian_blur", "radial_blur", "pie", "ngon", "curl", "rectangles", "arch", "tangent", "square", "rays", "blade", "secant2", "twintrian", "cross", "disc2", "super_shape", "flower", "conic", "parabola", "bent2", "bipolar", "boarders", "butterfly", "cell", "cpow", "curve", "edisc", "elliptic", "escher", "foci", "lazysusan", "loonie", "pre_blur", "modulus", "oscilloscope", "polar2", "popcorn2", "scry", "separation", "split", "splits", "stripes", "wedge", "wedge_julia", "wedge_sph", "whorl", "waves2", "exp", "log", "sin", "cos", "tan", "sec", "csc", "cot", "sinh", "cosh", "tanh", "sech", "csch", "coth", "auger", "flux", ((char *)NULL) };
// npalettes
// file palettes.c line 23
signed int npalettes;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// stdout
// file /usr/include/stdio.h line 169
extern struct _IO_FILE *stdout;
// the_docstring0
// file docstring.c line 24
static char *the_docstring0 = "FLAM3 - cosmic recursive fractal flames version ";
// the_docstring1
// file docstring.c line 27
static char *the_docstring1 = "\n\nThis software is licensed under the GPL.  You should have access\nto the source code; see http://www.fsf.org/licenses/gpl.html.\n\nThis is free software to render fractal flames as described on\nhttp://flam3.com.  Flam3-animate makes animations, and flam3-render\nmakes still images.  Flam3-genome creates and manipulates genomes\n(parameter sets).  A C library is also installed.\n\nNote: the following instructions are written for Linux users.  Windows\nusers may have to install the cygwin package to get the \"env\"\ncommand or set the envars in your windows command prompt manually.\nThat means instead of a command like\n\n    env dtime=5 prefix=foo. in=test.flame flam3-animate\n\nuse the following set of commands:\n\n    set dtime=5\n    set prefix=foo.\n    set in=test.flame\n    flam3-animate\n\n\nenvar           default     meaning\n=====           =======     =======\nprefix          (empty)     prefix names of output files with this string.\nbegin           j           time of first frame to render (j=first time specified in file) (animate only)\nend             n-1         time of last frame to render (n=last time specified in the input file) (animate only)\ntime            NA          time of first and last frame (ie do one frame) (animate only)\nframe           NA          synonym for \"time\" (animate only)\nin              stdin       name of input file\nout             NA          name of output file (bad idea if rending more than one, use prefix instead)\ntemplate        NA          apply defaults based on this genome (genome only)\ndtime           1           time between frames (animate only)\nfields          0           if 1 then render fields, ie odd scanlines at time+0.5\nnstrips         1           number of strips, ie render fractions of a frame at once (render only)\nqs              1           quality scale, multiply quality of all frames by this\nss              1           size scale, multiply size (in pixels) of all frames by this\njpeg            NA          jpeg quality for compression, default is native jpeg default\nformat          png         jpg or ppm or png\npixel_aspect    1.0         aspect ratio of pixels (width over height), eg 0.90909 for NTSC\nseed            random      integer seed for random numbers, defaults to time+pid\nisaac_seed      random      character-based seed for iteration loop randomness, defaults to time\nnthreads        0           number of threads to use for render.  default auto-detects.\nverbose         0           if non-zero then print progress meter on stderr\nbits            33          also 32 or 64: sets bit-width of internal buffers (33 means 32-bit floating-point)\nbpc             8           bits per color channel: png supports 16, all others are 8 only (render/animate)\nimage           filename    replace palette with png, jpg, or ppm image\nuse_vars        -1          comma separated list of variation #'s to use when generating a random flame (genome only)\ndont_use_vars   NA          comma separated list of variation #'s to NOT use when generating a random flame (genome only)\ncross0          NA          randomly select one genome from this file to genetically cross (genome only)\ncross1          NA            with one genome from this file (genome only)\nmethod          NA          method used for genetic cross: alternate, interpolate, or union. (genome only)\nmutate          NA          randomly mutate a random genome from this file (genome only)\nsymmetry        NA          set symmetry of result. (genome only)\nclone           NA          clone random flame in input (genome only)\nclone_all       NA          clones all flames in file.  useful for applying template to all flames (genome only)\nanimate         NA          interpolates between all flames in a file, using times specified in file (genome only)\nsequence        NA          360 degree rotation 'loops' times of each control point plus rotating transitions (genome only)\nloops           NA          number of times to rotate each control point in sequence (genome only)\ntries           50          number of tries to make to find a good genome. (genome only)\nstrip           NA          strip input, frame and nframes control which one. (genome only)\ntransparency    0           make bknd transparent, if format supports it (render/animate)\nname_enable     0           use 'name' attr in <flame> to name image output if present (render only)\nnick            \"\"          nickname to use in <edit> tags / img comments\nurl             \"\"          url to use in <edit> tags / img comments\nid              \"\"          ID to use in <edit> tags\ncomment         \"\"          comment string for <edit> tags (genome only)\nuse_mem         auto        floating point number of bytes of memory to use (render only)\nwrite_genome    0           write out genome associated with center of motion blur window (animate only)\nnoedits         unset       omit edit tags from output (genome only)\nprint_edit_depth 0          depth to truncate <edit> tag structure.  0 prints all <edit> tags (genome only)\nintpalette      unset       round palette entries for importing into older Apophysis versions (genome only)\ninsert_palette  unset       insert the palette into the image.\nenable_jpeg_comments   1    enables comments in the jpeg header (render and animate)\nenable_png_comments    1    enables comments in the png header (render and animate)\n\nNew in 2.8:\nearlyclip       0               enables the early clipping of rgb values for better antialiasing and resizing\n                                defaults to 0 for backwards compatibility\nflam27          0               flam3 2.7 compatibility mode; ensures generated genomes can be used by flam3 2.7.18\nstagger         0               affects simultaneity of xform interpolation during genome interpolation.\n                                represents how 'separate' the xforms are interpolated.  set to 1 for each\n                                xform to be interpolated individually, fractions control interp overlap.\n\nfor example:\n\n    env dtime=5 prefix=foo. in=test.flam3 flam3-animate\n\nmeans to render every 5th frame of parameter file foo.flam3, and store\nthe results in files named foo.XXXX.jpg.\n\nthe flam3-convert program reads from stdin the old format created by\nthe GIMP and writes to stdout the new xml format.\n\nthe flam3-genome program creates random parameter files. it also mutates,\nrotates, and interpolates existing parameter files.  for example to\ncreate 10 wholly new control points and render them at normal quality:\n\n    env template=vidres.flam3 repeat=10 flam3-genome > new.flam3\n    flam3-render < new.flam3\n\nif you left out the \"template=vidres.flam3\" part then the size,\nquality, etc parameters would be their default (small) values.  you\ncan set the symmetry group:\n\n    env template=vidres.flam3 symmetry=3 flam3-genome > new3.flam3\n    env template=vidres.flam3 symmetry=-2 flam3-genome > new-2.flam3\n    flam3-render < new3.flam3\n    flam3-render < new-2.flam3\n\nMutation is done by giving an input flame file to alter:\n\n    env template=vidres.flam3 flam3-genome > parent.flam3\n    env prefix=parent. flam3-render < parent.flam3\n    env template=vidres.flam3 mutate=parent.flam3 repeat=10 flam3-genome > mutation.flam3\n    flam3-render < mutation.flam3\n\nNormally one wouldn't use the same file for the template and the file\nto mutate.  Crossover is handled similarly:\n\n    env template=vidres.flam3 flam3-genome > parent0.flam3\n    env prefix=parent0. flam3-render < parent0.flam3\n    env template=vidres.flam3 flam3-genome > parent1.flam3\n    env prefix=parent1. flam3-render < parent1.flam3\n    env template=vidres.flam3 cross0=parent0.flam3 cross1=parent1.flam3 flam3-genome > crossover.flam3\n    flam3-render < crossover.flam3\n\nflam3-genome has 3 ways to produce parameter files for animation in\nthe style of electric sheep.  the highest level and most useful from\nthe command line is the sequence method.  it takes a collection of\ncontrol points and makes an animation that has each flame do fractal\nrotation for 360 degrees, then make a smooth transition to the next.\nfor example:\n\n    env sequence=test.flam3 nframes=20 flam3-genome > seq.flam3\n    flam3-animate < seq.flam3\n\ncreates and renders a 60 frame animation.  there are two flames in\ntest.flam3, so the animation consists three stags: the first one\nrotating, then a transition, then the second one rotating.  each stage\nhas 20 frames as specified on the command line.  if you want to\nrender only some fraction of a whole animation file, specify the begin\nand end times:\n\n    env begin=20 end=40 flam3-animate < seq.flam3\n\nthe other two methods are harder to use becaues they produce files that\nare only good for one frame of animation.  the output consists of 3\ncontrol points, one for the time requested, one before and one after.\nthat allows proper motion blur.  for example:\n\n    env template=vidres.flam3 flam3-genome > rotme.flam3\n    env rotate=rotme.flam3 frame=10 nframes=20 flam3-genome > rot10.flam3\n    env frame=10 flam3-animate < rot10.flam3\n\nthe file rot10.flam3 specifies the animation for just one frame, in\nthis case 10 out of 20 frames in the complete animation.  C1\ncontinuous electric sheep genetic crossfades are created like this:\n\n    env inter=test.flam3 frame=10 nframes=20 flam3-genome > inter10.flam3\n    env frame=10 flam3-animate < inter10.flam3\n\nsee http://flam3.com/flame.pdf for descriptions & formulas, and\nsee http://electricsheep.wikispaces.com/Variations for updates.\n\nThe complete list of variations:\n";
// the_palettes
// file palettes.c line 22
struct anonymous_18 *the_palettes = (struct anonymous_18 *)(void *)0;
// verbose
// file flam3-genome.c line 23
signed int verbose;
// xmlFree
// file /usr/include/libxml2/libxml/globals.h line 251
extern void (*xmlFree)(void *);

// add_to_action
// file flam3.h line 565
void add_to_action(char *action, char *addtoaction)
{
  if(!(action == ((char *)NULL)))
  {
    signed int alen;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(action);
    alen = (signed int)return_value_strlen_1;
    signed int addlen;
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(addtoaction);
    addlen = (signed int)return_value_strlen_2;
    if(!(addlen + alen >= 10000))
      strcat(action, addtoaction);

    else
      fprintf(stderr, "action string too long, truncating...\n");
  }

}

// adjust_percentage
// file interpolation.h line 31
double adjust_percentage(double in)
{
  double return_value_log_1;
  double return_value_log_2;
  double return_value_pow_3;
  if(IEEE_FLOAT_EQUAL(in, 0.0))
    return 0.0;

  else
  {
    return_value_log_1=log(1.0 / in);
    return_value_log_2=log((double)2);
    return_value_pow_3=pow(10.0, -return_value_log_1 / return_value_log_2);
    return return_value_pow_3;
  }
}

// apply_motion_parameters
// file flam3.c line 554
void apply_motion_parameters(struct xform *xf, struct xform *addto, double blend)
{
  signed int i;
  signed int j;
  signed int k;
  signed int freq;
  signed int func;
  struct xform *mot = xf->motion;
  i = 0;
  for( ; !(i >= xf->num_motion); i = i + 1)
  {
    freq = mot->motion_freq;
    func = mot->motion_func;
    do
    {
      double return_value_motion_funcs_1;
      return_value_motion_funcs_1=motion_funcs(func, (double)freq * blend);
      addto->density = addto->density + (mot + (signed long int)i)->density * return_value_motion_funcs_1;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_2;
      return_value_motion_funcs_2=motion_funcs(func, (double)freq * blend);
      addto->color = addto->color + (mot + (signed long int)i)->color * return_value_motion_funcs_2;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_3;
      return_value_motion_funcs_3=motion_funcs(func, (double)freq * blend);
      addto->opacity = addto->opacity + (mot + (signed long int)i)->opacity * return_value_motion_funcs_3;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_4;
      return_value_motion_funcs_4=motion_funcs(func, (double)freq * blend);
      addto->color_speed = addto->color_speed + (mot + (signed long int)i)->color_speed * return_value_motion_funcs_4;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_5;
      return_value_motion_funcs_5=motion_funcs(func, (double)freq * blend);
      addto->animate = addto->animate + (mot + (signed long int)i)->animate * return_value_motion_funcs_5;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_6;
      return_value_motion_funcs_6=motion_funcs(func, (double)freq * blend);
      addto->blob_low = addto->blob_low + (mot + (signed long int)i)->blob_low * return_value_motion_funcs_6;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_7;
      return_value_motion_funcs_7=motion_funcs(func, (double)freq * blend);
      addto->blob_high = addto->blob_high + (mot + (signed long int)i)->blob_high * return_value_motion_funcs_7;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_8;
      return_value_motion_funcs_8=motion_funcs(func, (double)freq * blend);
      addto->blob_waves = addto->blob_waves + (mot + (signed long int)i)->blob_waves * return_value_motion_funcs_8;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_9;
      return_value_motion_funcs_9=motion_funcs(func, (double)freq * blend);
      addto->pdj_a = addto->pdj_a + (mot + (signed long int)i)->pdj_a * return_value_motion_funcs_9;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_10;
      return_value_motion_funcs_10=motion_funcs(func, (double)freq * blend);
      addto->pdj_b = addto->pdj_b + (mot + (signed long int)i)->pdj_b * return_value_motion_funcs_10;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_11;
      return_value_motion_funcs_11=motion_funcs(func, (double)freq * blend);
      addto->pdj_c = addto->pdj_c + (mot + (signed long int)i)->pdj_c * return_value_motion_funcs_11;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_12;
      return_value_motion_funcs_12=motion_funcs(func, (double)freq * blend);
      addto->pdj_d = addto->pdj_d + (mot + (signed long int)i)->pdj_d * return_value_motion_funcs_12;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_13;
      return_value_motion_funcs_13=motion_funcs(func, (double)freq * blend);
      addto->fan2_x = addto->fan2_x + (mot + (signed long int)i)->fan2_x * return_value_motion_funcs_13;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_14;
      return_value_motion_funcs_14=motion_funcs(func, (double)freq * blend);
      addto->fan2_y = addto->fan2_y + (mot + (signed long int)i)->fan2_y * return_value_motion_funcs_14;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_15;
      return_value_motion_funcs_15=motion_funcs(func, (double)freq * blend);
      addto->rings2_val = addto->rings2_val + (mot + (signed long int)i)->rings2_val * return_value_motion_funcs_15;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_16;
      return_value_motion_funcs_16=motion_funcs(func, (double)freq * blend);
      addto->perspective_angle = addto->perspective_angle + (mot + (signed long int)i)->perspective_angle * return_value_motion_funcs_16;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_17;
      return_value_motion_funcs_17=motion_funcs(func, (double)freq * blend);
      addto->perspective_dist = addto->perspective_dist + (mot + (signed long int)i)->perspective_dist * return_value_motion_funcs_17;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_18;
      return_value_motion_funcs_18=motion_funcs(func, (double)freq * blend);
      addto->julian_power = addto->julian_power + (mot + (signed long int)i)->julian_power * return_value_motion_funcs_18;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_19;
      return_value_motion_funcs_19=motion_funcs(func, (double)freq * blend);
      addto->julian_dist = addto->julian_dist + (mot + (signed long int)i)->julian_dist * return_value_motion_funcs_19;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_20;
      return_value_motion_funcs_20=motion_funcs(func, (double)freq * blend);
      addto->juliascope_power = addto->juliascope_power + (mot + (signed long int)i)->juliascope_power * return_value_motion_funcs_20;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_21;
      return_value_motion_funcs_21=motion_funcs(func, (double)freq * blend);
      addto->juliascope_dist = addto->juliascope_dist + (mot + (signed long int)i)->juliascope_dist * return_value_motion_funcs_21;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_22;
      return_value_motion_funcs_22=motion_funcs(func, (double)freq * blend);
      addto->radial_blur_angle = addto->radial_blur_angle + (mot + (signed long int)i)->radial_blur_angle * return_value_motion_funcs_22;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_23;
      return_value_motion_funcs_23=motion_funcs(func, (double)freq * blend);
      addto->pie_slices = addto->pie_slices + (mot + (signed long int)i)->pie_slices * return_value_motion_funcs_23;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_24;
      return_value_motion_funcs_24=motion_funcs(func, (double)freq * blend);
      addto->pie_rotation = addto->pie_rotation + (mot + (signed long int)i)->pie_rotation * return_value_motion_funcs_24;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_25;
      return_value_motion_funcs_25=motion_funcs(func, (double)freq * blend);
      addto->pie_thickness = addto->pie_thickness + (mot + (signed long int)i)->pie_thickness * return_value_motion_funcs_25;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_26;
      return_value_motion_funcs_26=motion_funcs(func, (double)freq * blend);
      addto->ngon_sides = addto->ngon_sides + (mot + (signed long int)i)->ngon_sides * return_value_motion_funcs_26;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_27;
      return_value_motion_funcs_27=motion_funcs(func, (double)freq * blend);
      addto->ngon_power = addto->ngon_power + (mot + (signed long int)i)->ngon_power * return_value_motion_funcs_27;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_28;
      return_value_motion_funcs_28=motion_funcs(func, (double)freq * blend);
      addto->ngon_circle = addto->ngon_circle + (mot + (signed long int)i)->ngon_circle * return_value_motion_funcs_28;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_29;
      return_value_motion_funcs_29=motion_funcs(func, (double)freq * blend);
      addto->ngon_corners = addto->ngon_corners + (mot + (signed long int)i)->ngon_corners * return_value_motion_funcs_29;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_30;
      return_value_motion_funcs_30=motion_funcs(func, (double)freq * blend);
      addto->curl_c1 = addto->curl_c1 + (mot + (signed long int)i)->curl_c1 * return_value_motion_funcs_30;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_31;
      return_value_motion_funcs_31=motion_funcs(func, (double)freq * blend);
      addto->curl_c2 = addto->curl_c2 + (mot + (signed long int)i)->curl_c2 * return_value_motion_funcs_31;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_32;
      return_value_motion_funcs_32=motion_funcs(func, (double)freq * blend);
      addto->rectangles_x = addto->rectangles_x + (mot + (signed long int)i)->rectangles_x * return_value_motion_funcs_32;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_33;
      return_value_motion_funcs_33=motion_funcs(func, (double)freq * blend);
      addto->rectangles_y = addto->rectangles_y + (mot + (signed long int)i)->rectangles_y * return_value_motion_funcs_33;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_34;
      return_value_motion_funcs_34=motion_funcs(func, (double)freq * blend);
      addto->amw_amp = addto->amw_amp + (mot + (signed long int)i)->amw_amp * return_value_motion_funcs_34;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_35;
      return_value_motion_funcs_35=motion_funcs(func, (double)freq * blend);
      addto->disc2_rot = addto->disc2_rot + (mot + (signed long int)i)->disc2_rot * return_value_motion_funcs_35;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_36;
      return_value_motion_funcs_36=motion_funcs(func, (double)freq * blend);
      addto->disc2_twist = addto->disc2_twist + (mot + (signed long int)i)->disc2_twist * return_value_motion_funcs_36;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_37;
      return_value_motion_funcs_37=motion_funcs(func, (double)freq * blend);
      addto->super_shape_rnd = addto->super_shape_rnd + (mot + (signed long int)i)->super_shape_rnd * return_value_motion_funcs_37;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_38;
      return_value_motion_funcs_38=motion_funcs(func, (double)freq * blend);
      addto->super_shape_m = addto->super_shape_m + (mot + (signed long int)i)->super_shape_m * return_value_motion_funcs_38;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_39;
      return_value_motion_funcs_39=motion_funcs(func, (double)freq * blend);
      addto->super_shape_n1 = addto->super_shape_n1 + (mot + (signed long int)i)->super_shape_n1 * return_value_motion_funcs_39;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_40;
      return_value_motion_funcs_40=motion_funcs(func, (double)freq * blend);
      addto->super_shape_n2 = addto->super_shape_n2 + (mot + (signed long int)i)->super_shape_n2 * return_value_motion_funcs_40;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_41;
      return_value_motion_funcs_41=motion_funcs(func, (double)freq * blend);
      addto->super_shape_n3 = addto->super_shape_n3 + (mot + (signed long int)i)->super_shape_n3 * return_value_motion_funcs_41;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_42;
      return_value_motion_funcs_42=motion_funcs(func, (double)freq * blend);
      addto->super_shape_holes = addto->super_shape_holes + (mot + (signed long int)i)->super_shape_holes * return_value_motion_funcs_42;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_43;
      return_value_motion_funcs_43=motion_funcs(func, (double)freq * blend);
      addto->flower_petals = addto->flower_petals + (mot + (signed long int)i)->flower_petals * return_value_motion_funcs_43;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_44;
      return_value_motion_funcs_44=motion_funcs(func, (double)freq * blend);
      addto->flower_holes = addto->flower_holes + (mot + (signed long int)i)->flower_holes * return_value_motion_funcs_44;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_45;
      return_value_motion_funcs_45=motion_funcs(func, (double)freq * blend);
      addto->conic_eccentricity = addto->conic_eccentricity + (mot + (signed long int)i)->conic_eccentricity * return_value_motion_funcs_45;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_46;
      return_value_motion_funcs_46=motion_funcs(func, (double)freq * blend);
      addto->conic_holes = addto->conic_holes + (mot + (signed long int)i)->conic_holes * return_value_motion_funcs_46;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_47;
      return_value_motion_funcs_47=motion_funcs(func, (double)freq * blend);
      addto->parabola_height = addto->parabola_height + (mot + (signed long int)i)->parabola_height * return_value_motion_funcs_47;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_48;
      return_value_motion_funcs_48=motion_funcs(func, (double)freq * blend);
      addto->parabola_width = addto->parabola_width + (mot + (signed long int)i)->parabola_width * return_value_motion_funcs_48;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_49;
      return_value_motion_funcs_49=motion_funcs(func, (double)freq * blend);
      addto->bent2_x = addto->bent2_x + (mot + (signed long int)i)->bent2_x * return_value_motion_funcs_49;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_50;
      return_value_motion_funcs_50=motion_funcs(func, (double)freq * blend);
      addto->bent2_y = addto->bent2_y + (mot + (signed long int)i)->bent2_y * return_value_motion_funcs_50;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_51;
      return_value_motion_funcs_51=motion_funcs(func, (double)freq * blend);
      addto->bipolar_shift = addto->bipolar_shift + (mot + (signed long int)i)->bipolar_shift * return_value_motion_funcs_51;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_52;
      return_value_motion_funcs_52=motion_funcs(func, (double)freq * blend);
      addto->cell_size = addto->cell_size + (mot + (signed long int)i)->cell_size * return_value_motion_funcs_52;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_53;
      return_value_motion_funcs_53=motion_funcs(func, (double)freq * blend);
      addto->cpow_r = addto->cpow_r + (mot + (signed long int)i)->cpow_r * return_value_motion_funcs_53;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_54;
      return_value_motion_funcs_54=motion_funcs(func, (double)freq * blend);
      addto->cpow_i = addto->cpow_i + (mot + (signed long int)i)->cpow_i * return_value_motion_funcs_54;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_55;
      return_value_motion_funcs_55=motion_funcs(func, (double)freq * blend);
      addto->cpow_power = addto->cpow_power + (mot + (signed long int)i)->cpow_power * return_value_motion_funcs_55;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_56;
      return_value_motion_funcs_56=motion_funcs(func, (double)freq * blend);
      addto->curve_xamp = addto->curve_xamp + (mot + (signed long int)i)->curve_xamp * return_value_motion_funcs_56;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_57;
      return_value_motion_funcs_57=motion_funcs(func, (double)freq * blend);
      addto->curve_yamp = addto->curve_yamp + (mot + (signed long int)i)->curve_yamp * return_value_motion_funcs_57;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_58;
      return_value_motion_funcs_58=motion_funcs(func, (double)freq * blend);
      addto->curve_xlength = addto->curve_xlength + (mot + (signed long int)i)->curve_xlength * return_value_motion_funcs_58;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_59;
      return_value_motion_funcs_59=motion_funcs(func, (double)freq * blend);
      addto->curve_ylength = addto->curve_ylength + (mot + (signed long int)i)->curve_ylength * return_value_motion_funcs_59;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_60;
      return_value_motion_funcs_60=motion_funcs(func, (double)freq * blend);
      addto->escher_beta = addto->escher_beta + (mot + (signed long int)i)->escher_beta * return_value_motion_funcs_60;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_61;
      return_value_motion_funcs_61=motion_funcs(func, (double)freq * blend);
      addto->lazysusan_x = addto->lazysusan_x + (mot + (signed long int)i)->lazysusan_x * return_value_motion_funcs_61;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_62;
      return_value_motion_funcs_62=motion_funcs(func, (double)freq * blend);
      addto->lazysusan_y = addto->lazysusan_y + (mot + (signed long int)i)->lazysusan_y * return_value_motion_funcs_62;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_63;
      return_value_motion_funcs_63=motion_funcs(func, (double)freq * blend);
      addto->lazysusan_twist = addto->lazysusan_twist + (mot + (signed long int)i)->lazysusan_twist * return_value_motion_funcs_63;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_64;
      return_value_motion_funcs_64=motion_funcs(func, (double)freq * blend);
      addto->lazysusan_space = addto->lazysusan_space + (mot + (signed long int)i)->lazysusan_space * return_value_motion_funcs_64;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_65;
      return_value_motion_funcs_65=motion_funcs(func, (double)freq * blend);
      addto->lazysusan_spin = addto->lazysusan_spin + (mot + (signed long int)i)->lazysusan_spin * return_value_motion_funcs_65;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_66;
      return_value_motion_funcs_66=motion_funcs(func, (double)freq * blend);
      addto->modulus_x = addto->modulus_x + (mot + (signed long int)i)->modulus_x * return_value_motion_funcs_66;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_67;
      return_value_motion_funcs_67=motion_funcs(func, (double)freq * blend);
      addto->modulus_y = addto->modulus_y + (mot + (signed long int)i)->modulus_y * return_value_motion_funcs_67;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_68;
      return_value_motion_funcs_68=motion_funcs(func, (double)freq * blend);
      addto->oscope_separation = addto->oscope_separation + (mot + (signed long int)i)->oscope_separation * return_value_motion_funcs_68;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_69;
      return_value_motion_funcs_69=motion_funcs(func, (double)freq * blend);
      addto->oscope_frequency = addto->oscope_frequency + (mot + (signed long int)i)->oscope_frequency * return_value_motion_funcs_69;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_70;
      return_value_motion_funcs_70=motion_funcs(func, (double)freq * blend);
      addto->oscope_amplitude = addto->oscope_amplitude + (mot + (signed long int)i)->oscope_amplitude * return_value_motion_funcs_70;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_71;
      return_value_motion_funcs_71=motion_funcs(func, (double)freq * blend);
      addto->oscope_damping = addto->oscope_damping + (mot + (signed long int)i)->oscope_damping * return_value_motion_funcs_71;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_72;
      return_value_motion_funcs_72=motion_funcs(func, (double)freq * blend);
      addto->popcorn2_x = addto->popcorn2_x + (mot + (signed long int)i)->popcorn2_x * return_value_motion_funcs_72;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_73;
      return_value_motion_funcs_73=motion_funcs(func, (double)freq * blend);
      addto->popcorn2_y = addto->popcorn2_y + (mot + (signed long int)i)->popcorn2_y * return_value_motion_funcs_73;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_74;
      return_value_motion_funcs_74=motion_funcs(func, (double)freq * blend);
      addto->popcorn2_c = addto->popcorn2_c + (mot + (signed long int)i)->popcorn2_c * return_value_motion_funcs_74;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_75;
      return_value_motion_funcs_75=motion_funcs(func, (double)freq * blend);
      addto->separation_x = addto->separation_x + (mot + (signed long int)i)->separation_x * return_value_motion_funcs_75;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_76;
      return_value_motion_funcs_76=motion_funcs(func, (double)freq * blend);
      addto->separation_xinside = addto->separation_xinside + (mot + (signed long int)i)->separation_xinside * return_value_motion_funcs_76;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_77;
      return_value_motion_funcs_77=motion_funcs(func, (double)freq * blend);
      addto->separation_y = addto->separation_y + (mot + (signed long int)i)->separation_y * return_value_motion_funcs_77;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_78;
      return_value_motion_funcs_78=motion_funcs(func, (double)freq * blend);
      addto->separation_yinside = addto->separation_yinside + (mot + (signed long int)i)->separation_yinside * return_value_motion_funcs_78;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_79;
      return_value_motion_funcs_79=motion_funcs(func, (double)freq * blend);
      addto->split_xsize = addto->split_xsize + (mot + (signed long int)i)->split_xsize * return_value_motion_funcs_79;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_80;
      return_value_motion_funcs_80=motion_funcs(func, (double)freq * blend);
      addto->split_ysize = addto->split_ysize + (mot + (signed long int)i)->split_ysize * return_value_motion_funcs_80;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_81;
      return_value_motion_funcs_81=motion_funcs(func, (double)freq * blend);
      addto->splits_x = addto->splits_x + (mot + (signed long int)i)->splits_x * return_value_motion_funcs_81;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_82;
      return_value_motion_funcs_82=motion_funcs(func, (double)freq * blend);
      addto->splits_y = addto->splits_y + (mot + (signed long int)i)->splits_y * return_value_motion_funcs_82;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_83;
      return_value_motion_funcs_83=motion_funcs(func, (double)freq * blend);
      addto->stripes_space = addto->stripes_space + (mot + (signed long int)i)->stripes_space * return_value_motion_funcs_83;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_84;
      return_value_motion_funcs_84=motion_funcs(func, (double)freq * blend);
      addto->stripes_warp = addto->stripes_warp + (mot + (signed long int)i)->stripes_warp * return_value_motion_funcs_84;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_85;
      return_value_motion_funcs_85=motion_funcs(func, (double)freq * blend);
      addto->wedge_angle = addto->wedge_angle + (mot + (signed long int)i)->wedge_angle * return_value_motion_funcs_85;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_86;
      return_value_motion_funcs_86=motion_funcs(func, (double)freq * blend);
      addto->wedge_hole = addto->wedge_hole + (mot + (signed long int)i)->wedge_hole * return_value_motion_funcs_86;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_87;
      return_value_motion_funcs_87=motion_funcs(func, (double)freq * blend);
      addto->wedge_count = addto->wedge_count + (mot + (signed long int)i)->wedge_count * return_value_motion_funcs_87;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_88;
      return_value_motion_funcs_88=motion_funcs(func, (double)freq * blend);
      addto->wedge_swirl = addto->wedge_swirl + (mot + (signed long int)i)->wedge_swirl * return_value_motion_funcs_88;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_89;
      return_value_motion_funcs_89=motion_funcs(func, (double)freq * blend);
      addto->wedge_julia_angle = addto->wedge_julia_angle + (mot + (signed long int)i)->wedge_julia_angle * return_value_motion_funcs_89;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_90;
      return_value_motion_funcs_90=motion_funcs(func, (double)freq * blend);
      addto->wedge_julia_count = addto->wedge_julia_count + (mot + (signed long int)i)->wedge_julia_count * return_value_motion_funcs_90;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_91;
      return_value_motion_funcs_91=motion_funcs(func, (double)freq * blend);
      addto->wedge_julia_power = addto->wedge_julia_power + (mot + (signed long int)i)->wedge_julia_power * return_value_motion_funcs_91;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_92;
      return_value_motion_funcs_92=motion_funcs(func, (double)freq * blend);
      addto->wedge_julia_dist = addto->wedge_julia_dist + (mot + (signed long int)i)->wedge_julia_dist * return_value_motion_funcs_92;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_93;
      return_value_motion_funcs_93=motion_funcs(func, (double)freq * blend);
      addto->wedge_sph_angle = addto->wedge_sph_angle + (mot + (signed long int)i)->wedge_sph_angle * return_value_motion_funcs_93;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_94;
      return_value_motion_funcs_94=motion_funcs(func, (double)freq * blend);
      addto->wedge_sph_hole = addto->wedge_sph_hole + (mot + (signed long int)i)->wedge_sph_hole * return_value_motion_funcs_94;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_95;
      return_value_motion_funcs_95=motion_funcs(func, (double)freq * blend);
      addto->wedge_sph_count = addto->wedge_sph_count + (mot + (signed long int)i)->wedge_sph_count * return_value_motion_funcs_95;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_96;
      return_value_motion_funcs_96=motion_funcs(func, (double)freq * blend);
      addto->wedge_sph_swirl = addto->wedge_sph_swirl + (mot + (signed long int)i)->wedge_sph_swirl * return_value_motion_funcs_96;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_97;
      return_value_motion_funcs_97=motion_funcs(func, (double)freq * blend);
      addto->whorl_inside = addto->whorl_inside + (mot + (signed long int)i)->whorl_inside * return_value_motion_funcs_97;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_98;
      return_value_motion_funcs_98=motion_funcs(func, (double)freq * blend);
      addto->whorl_outside = addto->whorl_outside + (mot + (signed long int)i)->whorl_outside * return_value_motion_funcs_98;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_99;
      return_value_motion_funcs_99=motion_funcs(func, (double)freq * blend);
      addto->waves2_scalex = addto->waves2_scalex + (mot + (signed long int)i)->waves2_scalex * return_value_motion_funcs_99;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_100;
      return_value_motion_funcs_100=motion_funcs(func, (double)freq * blend);
      addto->waves2_scaley = addto->waves2_scaley + (mot + (signed long int)i)->waves2_scaley * return_value_motion_funcs_100;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_101;
      return_value_motion_funcs_101=motion_funcs(func, (double)freq * blend);
      addto->waves2_freqx = addto->waves2_freqx + (mot + (signed long int)i)->waves2_freqx * return_value_motion_funcs_101;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_102;
      return_value_motion_funcs_102=motion_funcs(func, (double)freq * blend);
      addto->waves2_freqy = addto->waves2_freqy + (mot + (signed long int)i)->waves2_freqy * return_value_motion_funcs_102;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_103;
      return_value_motion_funcs_103=motion_funcs(func, (double)freq * blend);
      addto->auger_sym = addto->auger_sym + (mot + (signed long int)i)->auger_sym * return_value_motion_funcs_103;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_104;
      return_value_motion_funcs_104=motion_funcs(func, (double)freq * blend);
      addto->auger_weight = addto->auger_weight + (mot + (signed long int)i)->auger_weight * return_value_motion_funcs_104;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_105;
      return_value_motion_funcs_105=motion_funcs(func, (double)freq * blend);
      addto->auger_freq = addto->auger_freq + (mot + (signed long int)i)->auger_freq * return_value_motion_funcs_105;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_106;
      return_value_motion_funcs_106=motion_funcs(func, (double)freq * blend);
      addto->auger_scale = addto->auger_scale + (mot + (signed long int)i)->auger_scale * return_value_motion_funcs_106;
    }
    while((_Bool)0);
    do
    {
      double return_value_motion_funcs_107;
      return_value_motion_funcs_107=motion_funcs(func, (double)freq * blend);
      addto->flux_spread = addto->flux_spread + (mot + (signed long int)i)->flux_spread * return_value_motion_funcs_107;
    }
    while((_Bool)0);
    j = 0;
    for( ; !(j >= 98); j = j + 1)
      do
      {
        double return_value_motion_funcs_108;
        return_value_motion_funcs_108=motion_funcs(func, (double)freq * blend);
        addto->var[(signed long int)j] = addto->var[(signed long int)j] + (mot + (signed long int)i)->var[(signed long int)j] * return_value_motion_funcs_108;
      }
      while((_Bool)0);
    j = 0;
    for( ; !(j >= 3); j = j + 1)
    {
      k = 0;
      for( ; !(k >= 2); k = k + 1)
      {
        do
        {
          double return_value_motion_funcs_109;
          return_value_motion_funcs_109=motion_funcs(func, (double)freq * blend);
          addto->c[(signed long int)j][(signed long int)k] = addto->c[(signed long int)j][(signed long int)k] + (mot + (signed long int)i)->c[(signed long int)j][(signed long int)k] * return_value_motion_funcs_109;
        }
        while((_Bool)0);
        do
        {
          double return_value_motion_funcs_110;
          return_value_motion_funcs_110=motion_funcs(func, (double)freq * blend);
          addto->post[(signed long int)j][(signed long int)k] = addto->post[(signed long int)j][(signed long int)k] + (mot + (signed long int)i)->post[(signed long int)j][(signed long int)k] * return_value_motion_funcs_110;
        }
        while((_Bool)0);
      }
    }
  }
  if(addto->color < 0.000000)
    addto->color = (double)0;

  if(addto->color > 1.000000)
    addto->color = (double)1;

  if(addto->density < 0.000000)
    addto->density = (double)0;

}

// apply_xform
// file variations.h line 139
signed int apply_xform(struct anonymous_0 *cp, signed int fn, double *p, double *q, struct randctx *rc)
{
  struct anonymous_9 f;
  signed int var_n;
  double next_color;
  double s;
  double s1;
  double weight;
  f.rc = rc;
  s1 = (cp->xform + (signed long int)fn)->color_speed;
  q[(signed long int)2] = s1 * (cp->xform + (signed long int)fn)->color + (1.0 - s1) * p[(signed long int)2];
  q[(signed long int)3] = (cp->xform + (signed long int)fn)->vis_adjusted;
  f.tx = (cp->xform + (signed long int)fn)->c[(signed long int)0][(signed long int)0] * p[(signed long int)0] + (cp->xform + (signed long int)fn)->c[(signed long int)1][(signed long int)0] * p[(signed long int)1] + (cp->xform + (signed long int)fn)->c[(signed long int)2][(signed long int)0];
  f.ty = (cp->xform + (signed long int)fn)->c[(signed long int)0][(signed long int)1] * p[(signed long int)0] + (cp->xform + (signed long int)fn)->c[(signed long int)1][(signed long int)1] * p[(signed long int)1] + (cp->xform + (signed long int)fn)->c[(signed long int)2][(signed long int)1];
  if(IEEE_FLOAT_NOTEQUAL((cp->xform + (signed long int)fn)->has_preblur, 0.0))
    var67_pre_blur(&f, (cp->xform + (signed long int)fn)->has_preblur);

  f.precalc_sumsq = f.tx * f.tx + f.ty * f.ty;
  f.precalc_sqrt=sqrt(f.precalc_sumsq);
  if((cp->xform + (signed long int)fn)->precalc_atan_xy_flag >= 1)
    f.precalc_atan=atan2(f.tx, f.ty);

  if((cp->xform + (signed long int)fn)->precalc_angles_flag >= 1)
  {
    f.precalc_sina = f.tx / f.precalc_sqrt;
    f.precalc_cosa = f.ty / f.precalc_sqrt;
  }

  if((cp->xform + (signed long int)fn)->precalc_atan_yx_flag >= 1)
    f.precalc_atanyx=atan2(f.ty, f.tx);

  f.p0 = 0.0;
  f.p1 = 0.0;
  f.xform = &cp->xform[(signed long int)fn];
  var_n = 0;
  for( ; !(var_n >= (cp->xform + (signed long int)fn)->num_active_vars); var_n = var_n + 1)
  {
    weight = (cp->xform + (signed long int)fn)->active_var_weights[(signed long int)var_n];
    switch((cp->xform + (signed long int)fn)->varFunc[(signed long int)var_n])
    {
      case 0:
      {
        var0_linear(&f, weight);
        break;
      }
      case 1:
      {
        var1_sinusoidal(&f, weight);
        break;
      }
      case 2:
      {
        var2_spherical(&f, weight);
        break;
      }
      case 3:
      {
        var3_swirl(&f, weight);
        break;
      }
      case 4:
      {
        var4_horseshoe(&f, weight);
        break;
      }
      case 5:
      {
        var5_polar(&f, weight);
        break;
      }
      case 6:
      {
        var6_handkerchief(&f, weight);
        break;
      }
      case 7:
      {
        var7_heart(&f, weight);
        break;
      }
      case 8:
      {
        var8_disc(&f, weight);
        break;
      }
      case 9:
      {
        var9_spiral(&f, weight);
        break;
      }
      case 10:
      {
        var10_hyperbolic(&f, weight);
        break;
      }
      case 11:
      {
        var11_diamond(&f, weight);
        break;
      }
      case 12:
      {
        var12_ex(&f, weight);
        break;
      }
      case 13:
      {
        var13_julia(&f, weight);
        break;
      }
      case 14:
      {
        var14_bent(&f, weight);
        break;
      }
      case 15:
      {
        var15_waves(&f, weight);
        break;
      }
      case 16:
      {
        var16_fisheye(&f, weight);
        break;
      }
      case 17:
      {
        var17_popcorn(&f, weight);
        break;
      }
      case 18:
      {
        var18_exponential(&f, weight);
        break;
      }
      case 19:
      {
        var19_power(&f, weight);
        break;
      }
      case 20:
      {
        var20_cosine(&f, weight);
        break;
      }
      case 21:
      {
        var21_rings(&f, weight);
        break;
      }
      case 22:
      {
        var22_fan(&f, weight);
        break;
      }
      case 23:
      {
        var23_blob(&f, weight);
        break;
      }
      case 24:
      {
        var24_pdj(&f, weight);
        break;
      }
      case 25:
      {
        var25_fan2(&f, weight);
        break;
      }
      case 26:
      {
        var26_rings2(&f, weight);
        break;
      }
      case 27:
      {
        var27_eyefish(&f, weight);
        break;
      }
      case 28:
      {
        var28_bubble(&f, weight);
        break;
      }
      case 29:
      {
        var29_cylinder(&f, weight);
        break;
      }
      case 30:
      {
        var30_perspective(&f, weight);
        break;
      }
      case 31:
      {
        var31_noise(&f, weight);
        break;
      }
      case 32:
      {
        var32_juliaN_generic(&f, weight);
        break;
      }
      case 33:
      {
        var33_juliaScope_generic(&f, weight);
        break;
      }
      case 34:
      {
        var34_blur(&f, weight);
        break;
      }
      case 35:
      {
        var35_gaussian(&f, weight);
        break;
      }
      case 36:
      {
        var36_radial_blur(&f, weight);
        break;
      }
      case 37:
      {
        var37_pie(&f, weight);
        break;
      }
      case 38:
      {
        var38_ngon(&f, weight);
        break;
      }
      case 39:
      {
        var39_curl(&f, weight);
        break;
      }
      case 40:
      {
        var40_rectangles(&f, weight);
        break;
      }
      case 41:
      {
        var41_arch(&f, weight);
        break;
      }
      case 42:
      {
        var42_tangent(&f, weight);
        break;
      }
      case 43:
      {
        var43_square(&f, weight);
        break;
      }
      case 44:
      {
        var44_rays(&f, weight);
        break;
      }
      case 45:
      {
        var45_blade(&f, weight);
        break;
      }
      case 46:
      {
        var46_secant2(&f, weight);
        break;
      }
      case 47:
      {
        var47_twintrian(&f, weight);
        break;
      }
      case 48:
      {
        var48_cross(&f, weight);
        break;
      }
      case 49:
      {
        var49_disc2(&f, weight);
        break;
      }
      case 50:
      {
        var50_supershape(&f, weight);
        break;
      }
      case 51:
      {
        var51_flower(&f, weight);
        break;
      }
      case 52:
      {
        var52_conic(&f, weight);
        break;
      }
      case 53:
      {
        var53_parabola(&f, weight);
        break;
      }
      case 54:
      {
        var54_bent2(&f, weight);
        break;
      }
      case 55:
      {
        var55_bipolar(&f, weight);
        break;
      }
      case 56:
      {
        var56_boarders(&f, weight);
        break;
      }
      case 57:
      {
        var57_butterfly(&f, weight);
        break;
      }
      case 58:
      {
        var58_cell(&f, weight);
        break;
      }
      case 59:
      {
        var59_cpow(&f, weight);
        break;
      }
      case 60:
      {
        var60_curve(&f, weight);
        break;
      }
      case 61:
      {
        var61_edisc(&f, weight);
        break;
      }
      case 62:
      {
        var62_elliptic(&f, weight);
        break;
      }
      case 63:
      {
        var63_escher(&f, weight);
        break;
      }
      case 64:
      {
        var64_foci(&f, weight);
        break;
      }
      case 65:
      {
        var65_lazysusan(&f, weight);
        break;
      }
      case 66:
      {
        var66_loonie(&f, weight);
        break;
      }
      case 68:
      {
        var68_modulus(&f, weight);
        break;
      }
      case 69:
      {
        var69_oscope(&f, weight);
        break;
      }
      case 70:
      {
        var70_polar2(&f, weight);
        break;
      }
      case 71:
      {
        var71_popcorn2(&f, weight);
        break;
      }
      case 72:
      {
        var72_scry(&f, weight);
        break;
      }
      case 73:
      {
        var73_separation(&f, weight);
        break;
      }
      case 74:
      {
        var74_split(&f, weight);
        break;
      }
      case 75:
      {
        var75_splits(&f, weight);
        break;
      }
      case 76:
      {
        var76_stripes(&f, weight);
        break;
      }
      case 77:
      {
        var77_wedge(&f, weight);
        break;
      }
      case 78:
      {
        var78_wedge_julia(&f, weight);
        break;
      }
      case 79:
      {
        var79_wedge_sph(&f, weight);
        break;
      }
      case 80:
      {
        var80_whorl(&f, weight);
        break;
      }
      case 81:
      {
        var81_waves2(&f, weight);
        break;
      }
      case 82:
      {
        var82_exp(&f, weight);
        break;
      }
      case 83:
      {
        var83_log(&f, weight);
        break;
      }
      case 84:
      {
        var84_sin(&f, weight);
        break;
      }
      case 85:
      {
        var85_cos(&f, weight);
        break;
      }
      case 86:
      {
        var86_tan(&f, weight);
        break;
      }
      case 87:
      {
        var87_sec(&f, weight);
        break;
      }
      case 88:
      {
        var88_csc(&f, weight);
        break;
      }
      case 89:
      {
        var89_cot(&f, weight);
        break;
      }
      case 90:
      {
        var90_sinh(&f, weight);
        break;
      }
      case 91:
      {
        var91_cosh(&f, weight);
        break;
      }
      case 92:
      {
        var92_tanh(&f, weight);
        break;
      }
      case 93:
      {
        var93_sech(&f, weight);
        break;
      }
      case 94:
      {
        var94_csch(&f, weight);
        break;
      }
      case 95:
      {
        var95_coth(&f, weight);
        break;
      }
      case 96:
      {
        var96_auger(&f, weight);
        break;
      }
      case 97:
        var97_flux(&f, weight);
    }
  }
  if(!((cp->xform + (signed long int)fn)->has_post == 0))
  {
    q[(signed long int)0] = (cp->xform + (signed long int)fn)->post[(signed long int)0][(signed long int)0] * f.p0 + (cp->xform + (signed long int)fn)->post[(signed long int)1][(signed long int)0] * f.p1 + (cp->xform + (signed long int)fn)->post[(signed long int)2][(signed long int)0];
    q[(signed long int)1] = (cp->xform + (signed long int)fn)->post[(signed long int)0][(signed long int)1] * f.p0 + (cp->xform + (signed long int)fn)->post[(signed long int)1][(signed long int)1] * f.p1 + (cp->xform + (signed long int)fn)->post[(signed long int)2][(signed long int)1];
  }

  else
  {
    q[(signed long int)0] = f.p0;
    q[(signed long int)1] = f.p1;
  }
  _Bool tmp_if_expr_1;
  if(isnan(*q))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = q[(signed long int)0] > 1e10 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = q[(signed long int)0] < -1e10 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_2)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    if(isnan(q[1l]))
      tmp_if_expr_3 = (_Bool)1;

    else
      tmp_if_expr_3 = q[(signed long int)1] > 1e10 ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = q[(signed long int)1] < -1e10 ? (_Bool)1 : (_Bool)0;
    tmp_if_expr_5 = tmp_if_expr_4 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_5)
  {
    q[(signed long int)0]=flam3_random_isaac_11(rc);
    q[(signed long int)1]=flam3_random_isaac_11(rc);
    return 1;
  }

  else
    return 0;
}

// atof
// file /usr/include/x86_64-linux-gnu/bits/stdlib-float.h line 26
static inline double atof(const char *__nptr)
{
  double return_value_strtod_1;
  return_value_strtod_1=strtod(__nptr, (char **)(void *)0);
  return return_value_strtod_1;
}

// atof_link1
// file /usr/include/x86_64-linux-gnu/bits/stdlib-float.h line 26
static inline double atof_link1(const char *__nptr_link1)
{
  double return_value_strtod_1_link1;
  return_value_strtod_1_link1=strtod(__nptr_link1, (char **)(void *)0);
  return return_value_strtod_1_link1;
}

// atoi
// file /usr/include/stdlib.h line 278
static inline signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol_1;
  return_value_strtol_1=strtol(__nptr, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1;
}

// atoi_link1
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link1(const char *__nptr_link1)
{
  signed long int return_value_strtol_1_link1;
  return_value_strtol_1_link1=strtol(__nptr_link1, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1_link1;
}

// atoi_link2
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link2(const char *__nptr_link2)
{
  signed long int return_value_strtol_1_link2;
  return_value_strtol_1_link2=strtol(__nptr_link2, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1_link2;
}

// atoi_link3
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link3(const char *__nptr_link3)
{
  signed long int return_value_strtol_1_link3;
  return_value_strtol_1_link3=strtol(__nptr_link3, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1_link3;
}

// atoi_link4
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link4(const char *__nptr_link4)
{
  signed long int return_value_strtol_1_link4;
  return_value_strtol_1_link4=strtol(__nptr_link4, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1_link4;
}

// atoi_link5
// file /usr/include/stdlib.h line 278
static inline signed int atoi_link5(const char *__nptr_link5)
{
  signed long int return_value_strtol_1_link5;
  return_value_strtol_1_link5=strtol(__nptr_link5, (char **)(void *)0, 10);
  return (signed int)return_value_strtol_1_link5;
}

// bits_error
// file flam3.c line 3745
void bits_error(struct anonymous_4 *spec)
{
  fprintf(stderr, "flam3: bits must be 32, 33, or 64 not %d.\n", spec->bits);
}

// change_colors
// file palettes.c line 458
static void change_colors(struct anonymous_0 *g, signed int change_palette)
{
  signed int i;
  signed int x0;
  signed int x1;
  if(!(change_palette == 0))
  {
    g->hue_rotation = 0.0;
    g->palette_index=flam3_get_palette(-1, g->palette, 0.0);
    if(!(g->palette_index >= 0))
      fprintf(stderr, "error retrieving random palette, setting to all white\n");

  }

  i = 0;
  for( ; !(i >= g->num_xforms); i = i + 1)
    (g->xform + (signed long int)i)->color=flam3_random01();
  x0=random_xform(g, -1);
  x1=random_xform(g, x0);
  signed long int return_value_random_1;
  if(x0 >= 0)
  {
    return_value_random_1=random();
    if(!((1l & return_value_random_1) == 0l))
      (g->xform + (signed long int)x0)->color = 0.0;

  }

  signed long int return_value_random_2;
  if(x1 >= 0)
  {
    return_value_random_2=random();
    if(!((1l & return_value_random_2) == 0l))
      (g->xform + (signed long int)x1)->color = 1.0;

  }

}

// clear_cp
// file flam3.h line 538
void clear_cp(struct anonymous_0 *cp, signed int default_flag)
{
  cp->palette_index = -1;
  cp->center[(signed long int)0] = 0.0;
  cp->center[(signed long int)1] = 0.0;
  cp->rot_center[(signed long int)0] = 0.0;
  cp->rot_center[(signed long int)1] = 0.0;
  cp->gamma = 4.0;
  cp->vibrancy = 1.0;
  cp->contrast = 1.0;
  cp->brightness = 4.0;
  cp->symmetry = 0;
  cp->hue_rotation = 0.0;
  cp->rotate = 0.0;
  cp->pixels_per_unit = (double)50;
  cp->interpolation = 0;
  cp->palette_interpolation = 0;
  cp->genome_index = 0;
  memset((void *)cp->parent_fname, 0, (unsigned long int)30);
  if(default_flag == 1)
  {
    cp->highlight_power = -1.0;
    cp->background[(signed long int)0] = 0.0;
    cp->background[(signed long int)1] = 0.0;
    cp->background[(signed long int)2] = 0.0;
    cp->width = 100;
    cp->height = 100;
    cp->spatial_oversample = 1;
    cp->spatial_filter_radius = 0.5;
    cp->zoom = 0.0;
    cp->sample_density = (double)1;
    cp->estimator = 9.0;
    cp->estimator_minimum = 0.0;
    cp->estimator_curve = 0.4;
    cp->gam_lin_thresh = 0.01;
    cp->nbatches = 1;
    cp->ntemporal_samples = 1000;
    cp->spatial_filter_select = 0;
    cp->interpolation_type = 1;
    cp->temporal_filter_type = 0;
    cp->temporal_filter_width = 1.0;
    cp->temporal_filter_exp = 0.0;
    cp->palette_mode = 0;
  }

  else
  {
    cp->highlight_power = -1.0;
    cp->background[(signed long int)0] = -1.0;
    cp->background[(signed long int)1] = -1.0;
    cp->background[(signed long int)2] = -1.0;
    cp->zoom = (double)999999999;
    cp->spatial_oversample = -1;
    cp->spatial_filter_radius = (double)-1;
    cp->nbatches = -1;
    cp->ntemporal_samples = -1;
    cp->width = -1;
    cp->height = -1;
    cp->sample_density = (double)-1;
    cp->estimator = (double)-1;
    cp->estimator_minimum = (double)-1;
    cp->estimator_curve = (double)-1;
    cp->gam_lin_thresh = (double)-1;
    cp->nbatches = 0;
    cp->ntemporal_samples = 0;
    cp->spatial_filter_select = -1;
    cp->interpolation_type = -1;
    cp->temporal_filter_type = -1;
    cp->temporal_filter_width = (double)-1;
    cp->temporal_filter_exp = (double)-999;
    cp->palette_mode = -1;
  }
  if(!(cp->xform == ((struct xform *)NULL)))
  {
    if(cp->num_xforms >= 1)
    {
      signed int i;
      signed int ns = cp->num_xforms - (signed int)(cp->final_xform_index >= 0);
      i = 0;
      for( ; !(i >= ns); i = i + 1)
        free((void *)cp->chaos[(signed long int)i]);
      free((void *)cp->chaos);
      cp->chaos = (double **)(void *)0;
      i = 0;
      for( ; !(i >= cp->num_xforms); i = i + 1)
        flam3_delete_motion_elements(&cp->xform[(signed long int)i]);
      free((void *)cp->xform);
      cp->xform = (struct xform *)(void *)0;
      cp->num_xforms = 0;
    }

  }

  cp->final_xform_enable = 0;
  cp->final_xform_index = -1;
}

// clear_matrix
// file interpolation.c line 91
void clear_matrix(double (*m)[2l])
{
  m[(signed long int)0][(signed long int)0] = 0.0;
  m[(signed long int)0][(signed long int)1] = 0.0;
  m[(signed long int)1][(signed long int)0] = 0.0;
  m[(signed long int)1][(signed long int)1] = 0.0;
  m[(signed long int)2][(signed long int)0] = 0.0;
  m[(signed long int)2][(signed long int)1] = 0.0;
}

// compare_xforms
// file interpolation.h line 45
signed int compare_xforms(const void *av, const void *bv)
{
  struct xform *a = (struct xform *)av;
  struct xform *b = (struct xform *)bv;
  double aa[2l][2l];
  double bb[2l][2l];
  double ad;
  double bd;
  aa[(signed long int)0][(signed long int)0] = a->c[(signed long int)0][(signed long int)0];
  aa[(signed long int)0][(signed long int)1] = a->c[(signed long int)0][(signed long int)1];
  aa[(signed long int)1][(signed long int)0] = a->c[(signed long int)1][(signed long int)0];
  aa[(signed long int)1][(signed long int)1] = a->c[(signed long int)1][(signed long int)1];
  bb[(signed long int)0][(signed long int)0] = b->c[(signed long int)0][(signed long int)0];
  bb[(signed long int)0][(signed long int)1] = b->c[(signed long int)0][(signed long int)1];
  bb[(signed long int)1][(signed long int)0] = b->c[(signed long int)1][(signed long int)0];
  bb[(signed long int)1][(signed long int)1] = b->c[(signed long int)1][(signed long int)1];
  ad=det_matrix(aa);
  bd=det_matrix(bb);
  if(a->color_speed > b->color_speed)
    return 1;

  else
    if(a->color_speed < b->color_speed)
      return -1;

    else
    {
      if(IEEE_FLOAT_NOTEQUAL(a->color_speed, 0.000000))
      {
        if(ad < 0.000000)
          return -1;

        if(bd < 0.000000)
          return 1;

        ad=atan2(a->c[(signed long int)0][(signed long int)0], a->c[(signed long int)0][(signed long int)1]);
        bd=atan2(b->c[(signed long int)0][(signed long int)0], b->c[(signed long int)0][(signed long int)1]);
      }

      if(ad < bd)
        return -1;

      else
        if(ad > bd)
          return 1;

        else
          return 0;
    }
}

// convert_linear_to_polar
// file interpolation.c line 236
void convert_linear_to_polar(struct anonymous_0 *cp, signed int ncps, signed int xfi, signed int cflag, double (*cxang)[2l], double (*cxmag)[2l], double (*cxtrn)[2l])
{
  double c1[2l];
  double d;
  double t;
  double refang;
  signed int col;
  signed int k;
  signed int zlm[2l];
  k = 0;
  _Bool tmp_if_expr_1;
  for( ; !(k >= ncps); k = k + 1)
  {
    zlm[(signed long int)1] = 0;
    zlm[(signed long int)0] = zlm[(signed long int)1];
    col = 0;
    for( ; !(col >= 2); col = col + 1)
    {
      if(cflag == 0)
      {
        c1[(signed long int)0] = ((cp + (signed long int)k)->xform + (signed long int)xfi)->c[(signed long int)col][(signed long int)0];
        c1[(signed long int)1] = ((cp + (signed long int)k)->xform + (signed long int)xfi)->c[(signed long int)col][(signed long int)1];
        t = ((cp + (signed long int)k)->xform + (signed long int)xfi)->c[(signed long int)2][(signed long int)col];
      }

      else
      {
        c1[(signed long int)0] = ((cp + (signed long int)k)->xform + (signed long int)xfi)->post[(signed long int)col][(signed long int)0];
        c1[(signed long int)1] = ((cp + (signed long int)k)->xform + (signed long int)xfi)->post[(signed long int)col][(signed long int)1];
        t = ((cp + (signed long int)k)->xform + (signed long int)xfi)->post[(signed long int)2][(signed long int)col];
      }
      cxang[(signed long int)k][(signed long int)col]=atan2(c1[(signed long int)1], c1[(signed long int)0]);
      cxmag[(signed long int)k][(signed long int)col]=sqrt(c1[(signed long int)0] * c1[(signed long int)0] + c1[(signed long int)1] * c1[(signed long int)1]);
      if(IEEE_FLOAT_EQUAL(cxmag[(signed long int)k][(signed long int)col], 0.0))
        zlm[(signed long int)col] = 1;

      cxtrn[(signed long int)k][(signed long int)col] = t;
    }
    if(zlm[0l] == 1)
      tmp_if_expr_1 = zlm[(signed long int)1] == 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      cxang[(signed long int)k][(signed long int)0] = cxang[(signed long int)k][(signed long int)1];

    else
      if(zlm[0l] == 0)
      {
        if(zlm[1l] == 1)
          cxang[(signed long int)k][(signed long int)1] = cxang[(signed long int)k][(signed long int)0];

      }

  }
  col = 0;
  for( ; !(col >= 2); col = col + 1)
  {
    k = 1;
    for( ; !(k >= ncps); k = k + 1)
      if(cflag == 0 && ((cp + (signed long int)k)->xform + (signed long int)xfi)->wind[(signed long int)col] > 0.000000)
      {
        refang = ((cp + (signed long int)k)->xform + (signed long int)xfi)->wind[(signed long int)col] - (double)2 * 3.14159265358979323846;
        for( ; cxang[(signed long int)(k + -1)][(signed long int)col] < refang; cxang[(signed long int)(k - 1)][(signed long int)col] = cxang[(signed long int)(k - 1)][(signed long int)col] + (double)2 * 3.14159265358979323846)
          ;
        for( ; cxang[(signed long int)(k + -1)][(signed long int)col] > refang + 6.283185e+0; cxang[(signed long int)(k - 1)][(signed long int)col] = cxang[(signed long int)(k - 1)][(signed long int)col] - (double)2 * 3.14159265358979323846)
          ;
        for( ; cxang[(signed long int)k][(signed long int)col] < refang; cxang[(signed long int)k][(signed long int)col] = cxang[(signed long int)k][(signed long int)col] + (double)2 * 3.14159265358979323846)
          ;
        for( ; cxang[(signed long int)k][(signed long int)col] > refang + 6.283185e+0; cxang[(signed long int)k][(signed long int)col] = cxang[(signed long int)k][(signed long int)col] - (double)2 * 3.14159265358979323846)
          ;
      }

      else
      {
        d = cxang[(signed long int)k][(signed long int)col] - cxang[(signed long int)(k - 1)][(signed long int)col];
        if(d > 3.141593e+0)
          cxang[(signed long int)k][(signed long int)col] = cxang[(signed long int)k][(signed long int)col] - (double)2 * 3.14159265358979323846;

        else
          if(d < -3.141593e+0)
            cxang[(signed long int)k][(signed long int)col] = cxang[(signed long int)k][(signed long int)col] + (double)2 * 3.14159265358979323846;

      }
  }
}

// copy_matrix
// file interpolation.c line 80
void copy_matrix(double (*to)[2l], double (*from)[2l])
{
  to[(signed long int)0][(signed long int)0] = from[(signed long int)0][(signed long int)0];
  to[(signed long int)0][(signed long int)1] = from[(signed long int)0][(signed long int)1];
  to[(signed long int)1][(signed long int)0] = from[(signed long int)1][(signed long int)0];
  to[(signed long int)1][(signed long int)1] = from[(signed long int)1][(signed long int)1];
  to[(signed long int)2][(signed long int)0] = from[(signed long int)2][(signed long int)0];
  to[(signed long int)2][(signed long int)1] = from[(signed long int)2][(signed long int)1];
}

// create_new_editdoc
// file flam3-genome.c line 80
struct _xmlDoc * create_new_editdoc(char *action, struct anonymous_0 *parent0, struct anonymous_0 *parent1)
{
  struct _xmlDoc *doc = (struct _xmlDoc *)(void *)0;
  struct _xmlDoc *comment_doc = (struct _xmlDoc *)(void *)0;
  struct _xmlNode *root_node = (struct _xmlNode *)(void *)0;
  struct _xmlNode *node = (struct _xmlNode *)(void *)0;
  struct _xmlNode *nodecopy = (struct _xmlNode *)(void *)0;
  struct _xmlNode *root_comment = (struct _xmlNode *)(void *)0;
  struct tm *localt;
  signed long int mytime;
  char *ai;
  char timestring[100l];
  char *nick;
  nick=getenv("nick");
  char *url;
  url=getenv("url");
  char *id;
  id=getenv("id");
  char *comment;
  comment=getenv("comment");
  signed int sheep_gen;
  ai=getenv("sheep_gen");
  signed int tmp_if_expr_2;
  signed int return_value_atoi_1;
  if(!(ai == ((char *)NULL)))
  {
    return_value_atoi_1=atoi(ai);
    tmp_if_expr_2 = return_value_atoi_1;
  }

  else
    tmp_if_expr_2 = -1;
  sheep_gen = tmp_if_expr_2;
  signed int sheep_id;
  ai=getenv("sheep_id");
  signed int tmp_if_expr_4;
  signed int return_value_atoi_3;
  if(!(ai == ((char *)NULL)))
  {
    return_value_atoi_3=atoi(ai);
    tmp_if_expr_4 = return_value_atoi_3;
  }

  else
    tmp_if_expr_4 = -1;
  sheep_id = tmp_if_expr_4;
  char buffer[100l];
  char comment_string[100l];
  doc=xmlNewDoc((const unsigned char *)"1.0");
  root_node=xmlNewNode((struct _xmlNs *)(void *)0, (const unsigned char *)"edit");
  xmlDocSetRootElement(doc, root_node);
  mytime=time((signed long int *)(void *)0);
  localt=localtime(&mytime);
  strftime(timestring, (unsigned long int)100, "%a %b %e %H:%M:%S %z %Y", localt);
  xmlNewProp(root_node, (const unsigned char *)"date", (const unsigned char *)timestring);
  if(!(nick == ((char *)NULL)))
    xmlNewProp(root_node, (const unsigned char *)"nick", (const unsigned char *)nick);

  if(!(url == ((char *)NULL)))
    xmlNewProp(root_node, (const unsigned char *)"url", (const unsigned char *)url);

  if(!(id == ((char *)NULL)))
    xmlNewProp(root_node, (const unsigned char *)"id", (const unsigned char *)id);

  xmlNewProp(root_node, (const unsigned char *)"action", (const unsigned char *)action);
  if(sheep_gen >= 1 && sheep_id >= 1)
  {
    node=xmlNewChild(root_node, (struct _xmlNs *)(void *)0, (const unsigned char *)"sheep", (const unsigned char *)(void *)0);
    sprintf(buffer, "%d", sheep_gen);
    xmlNewProp(node, (const unsigned char *)"generation", (const unsigned char *)buffer);
    sprintf(buffer, "%d", sheep_id);
    xmlNewProp(node, (const unsigned char *)"id", (const unsigned char *)buffer);
  }

  if(!(parent0 == ((struct anonymous_0 *)NULL)))
  {
    if(!(parent0->edits == ((struct _xmlDoc *)NULL)))
    {
      node=xmlDocGetRootElement(parent0->edits);
      nodecopy=xmlCopyNode(node, 1);
      xmlNewProp(nodecopy, (const unsigned char *)"filename", (const unsigned char *)parent0->parent_fname);
      sprintf(buffer, "%d", parent0->genome_index);
      xmlNewProp(nodecopy, (const unsigned char *)"index", (const unsigned char *)buffer);
      xmlAddChild(root_node, nodecopy);
    }

    else
    {
      nodecopy=xmlNewChild(root_node, (struct _xmlNs *)(void *)0, (const unsigned char *)"edit", (const unsigned char *)(void *)0);
      xmlNewProp(nodecopy, (const unsigned char *)"filename", (const unsigned char *)parent0->parent_fname);
      sprintf(buffer, "%d", parent0->genome_index);
      xmlNewProp(nodecopy, (const unsigned char *)"index", (const unsigned char *)buffer);
    }
  }

  if(!(parent1 == ((struct anonymous_0 *)NULL)))
  {
    if(!(parent1->edits == ((struct _xmlDoc *)NULL)))
    {
      node=xmlDocGetRootElement(parent1->edits);
      nodecopy=xmlCopyNode(node, 1);
      xmlNewProp(nodecopy, (const unsigned char *)"filename", (const unsigned char *)parent1->parent_fname);
      sprintf(buffer, "%d", parent1->genome_index);
      xmlNewProp(nodecopy, (const unsigned char *)"index", (const unsigned char *)buffer);
      xmlAddChild(root_node, nodecopy);
    }

    else
    {
      nodecopy=xmlNewChild(root_node, (struct _xmlNs *)(void *)0, (const unsigned char *)"edit", (const unsigned char *)(void *)0);
      xmlNewProp(nodecopy, (const unsigned char *)"filename", (const unsigned char *)parent1->parent_fname);
      sprintf(buffer, "%d", parent1->genome_index);
      xmlNewProp(nodecopy, (const unsigned char *)"index", (const unsigned char *)buffer);
    }
  }

  if(!(comment == ((char *)NULL)))
  {
    sprintf(comment_string, "<comm>%s</comm>", comment);
    unsigned long int return_value_strlen_5;
    return_value_strlen_5=strlen(comment_string);
    comment_doc=xmlReadMemory(comment_string, (signed int)return_value_strlen_5, "comment.env", (const char *)(void *)0, 2048);
    if(comment_doc == ((struct _xmlDoc *)NULL))
    {
      fprintf(stderr, "Failed to parse comment into XML!\n");
      exit(1);
    }

    root_comment=xmlDocGetRootElement(comment_doc);
    node = root_comment->children;
    for( ; !(node == ((struct _xmlNode *)NULL)); node = node->next)
    {
      nodecopy=xmlCopyNode(node, 1);
      xmlAddChild(root_node, nodecopy);
    }
    xmlFreeDoc(comment_doc);
  }

  return doc;
}

// de_thread_32
// file rect.c line 57
static void de_thread_32(void *dth)
{
  struct anonymous_16 *dthp = (struct anonymous_16 *)dth;
  signed int oversample = dthp->oversample;
  signed int ss;
  double return_value_floor_1;
  return_value_floor_1=floor((double)oversample / 2.0);
  ss = (signed int)return_value_floor_1;
  signed int scf = (signed int)!((oversample & 1) != 0);
  double scfact;
  scfact=pow((double)oversample / ((double)oversample + 1.0), 2.0);
  signed int wid = dthp->width;
  signed int hig = dthp->height;
  signed int ps = dthp->progress_size;
  signed int str = (oversample - 1) + dthp->start_row;
  signed int enr = (oversample - 1) + dthp->end_row;
  signed int i;
  signed int j;
  signed long int progress_timer = (signed long int)0;
  struct timespec pauset;
  signed int progress_count = 0;
  signed int pixel_num;
  pauset.tv_sec = (signed long int)0;
  pauset.tv_nsec = (signed long int)100000000;
  j = str;
  _Bool tmp_if_expr_2;
  double return_value_ceil_3;
  double return_value_pow_4;
  double return_value_floor_5;
  signed long int return_value_time_8;
  for( ; !(j >= enr); j = j + 1)
  {
    i = oversample - 1;
    for( ; !(i >= wid + -(oversample + -1)); i = i + 1)
    {
      signed int ii;
      signed int jj;
      double f_select = 0.0;
      signed int f_select_int;
      signed int f_coef_idx;
      signed int arr_filt_width;
      unsigned int (*b)[5l];
      double c[4l];
      double ls;
      b = dthp->b + (signed long int)i + (signed long int)(j * wid);
      if((*b)[4l] == 0u)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = b[(signed long int)0][(signed long int)3] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_2)
      {
        ii = -ss;
        for( ; ss >= ii; ii = ii + 1)
        {
          jj = -ss;
          for( ; ss >= jj; jj = jj + 1)
          {
            b = dthp->b + (signed long int)(i + ii) + (signed long int)((j + jj) * wid);
            f_select = f_select + (double)b[(signed long int)0][(signed long int)4] / 255.0;
          }
        }
        if(!(scf == 0))
          f_select = f_select * scfact;

        if(f_select > (double)dthp->de->max_filtered_counts)
          f_select_int = dthp->de->max_filter_index;

        else
          if(f_select <= 100.000000)
          {
            return_value_ceil_3=ceil(f_select);
            f_select_int = (signed int)return_value_ceil_3 - 1;
          }

          else
          {
            return_value_pow_4=pow(f_select - (double)100, dthp->curve);
            return_value_floor_5=floor(return_value_pow_4);
            f_select_int = (signed int)100 + (signed int)return_value_floor_5;
          }
        if(!(dthp->de->max_filter_index >= f_select_int))
          f_select_int = dthp->de->max_filter_index;

        f_coef_idx = f_select_int * dthp->de->kernel_size;
        double return_value_ceil_6;
        return_value_ceil_6=ceil(dthp->de->filter_widths[(signed long int)f_select_int]);
        arr_filt_width = (signed int)return_value_ceil_6 - 1;
        b = dthp->b + (signed long int)i + (signed long int)(j * wid);
        jj = 0;
        for( ; arr_filt_width >= jj; jj = jj + 1)
        {
          ii = 0;
          for( ; jj >= ii; ii = ii + 1)
            if(IEEE_FLOAT_EQUAL(dthp->de->filter_coefs[(signed long int)f_coef_idx], 0.0))
              f_coef_idx = f_coef_idx + 1;

            else
            {
              c[(signed long int)0] = (double)b[(signed long int)0][(signed long int)0];
              c[(signed long int)1] = (double)b[(signed long int)0][(signed long int)1];
              c[(signed long int)2] = (double)b[(signed long int)0][(signed long int)2];
              c[(signed long int)3] = (double)b[(signed long int)0][(signed long int)3];
              double return_value_log_7;
              return_value_log_7=log(1.0 + c[(signed long int)3] * dthp->k2);
              ls = (dthp->de->filter_coefs[(signed long int)f_coef_idx] * dthp->k1 * return_value_log_7) / c[(signed long int)3];
              c[(signed long int)0] = c[(signed long int)0] * ls;
              c[(signed long int)1] = c[(signed long int)1] * ls;
              c[(signed long int)2] = c[(signed long int)2] * ls;
              c[(signed long int)3] = c[(signed long int)3] * ls;
              if(ii == 0 && jj == 0)
                do
                  if(ii + i >= 0 && jj + j >= 0 && !(ii + i >= wid) && !(jj + j >= hig))
                  {
                    unsigned int (*a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + jj) * wid);
                    do
                      if((double)(1U + -(*a)[0l]) > c[0l])
                        a[(signed long int)0][(signed long int)0] = a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                      else
                        a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                    while((_Bool)0);
                    do
                      if((double)(1U + -(*a)[1l]) > c[1l])
                        a[(signed long int)0][(signed long int)1] = a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                      else
                        a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                    while((_Bool)0);
                    do
                      if((double)(1U + -(*a)[2l]) > c[2l])
                        a[(signed long int)0][(signed long int)2] = a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                      else
                        a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                    while((_Bool)0);
                    do
                      if((double)(1U + -(*a)[3l]) > c[3l])
                        a[(signed long int)0][(signed long int)3] = a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                      else
                        a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                    while((_Bool)0);
                  }

                while((_Bool)0);

              else
                if(ii == 0)
                {
                  do
                    if(jj + i >= 0 && j >= 0 && !(jj + i >= wid) && !(j >= hig))
                    {
                      unsigned int (*de_thread_32__1__1__1__1__1__2__1__1__1__3__1__1__a)[4l] = dthp->accumulate + (signed long int)(i + jj) + (signed long int)((j + 0) * wid);
                      do
                        if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__3__1__1__a)[0l]) > c[0l])
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)0] = de_thread_32__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                        else
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                      do
                        if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__3__1__1__a)[1l]) > c[1l])
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)1] = de_thread_32__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                        else
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                      do
                        if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__3__1__1__a)[2l]) > c[2l])
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)2] = de_thread_32__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                        else
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                      do
                        if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__3__1__1__a)[3l]) > c[3l])
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)3] = de_thread_32__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                        else
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                    }

                  while((_Bool)0);
                  do
                    if(i + -jj >= 0 && j >= 0 && !(i + -jj >= wid) && !(j >= hig))
                    {
                      unsigned int (*de_thread_32__1__1__1__1__1__2__1__1__1__3__2__1__a)[4l] = dthp->accumulate + (signed long int)(i + -jj) + (signed long int)((j + 0) * wid);
                      do
                        if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__3__2__1__a)[0l]) > c[0l])
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)0] = de_thread_32__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                        else
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                      do
                        if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__3__2__1__a)[1l]) > c[1l])
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)1] = de_thread_32__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                        else
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                      do
                        if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__3__2__1__a)[2l]) > c[2l])
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)2] = de_thread_32__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                        else
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                      do
                        if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__3__2__1__a)[3l]) > c[3l])
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)3] = de_thread_32__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                        else
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                    }

                  while((_Bool)0);
                  do
                    if(jj + j >= 0 && i >= 0 && !(jj + j >= hig) && !(i >= wid))
                    {
                      unsigned int (*de_thread_32__1__1__1__1__1__2__1__1__1__3__3__1__a)[4l] = dthp->accumulate + (signed long int)(i + 0) + (signed long int)((j + jj) * wid);
                      do
                        if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__3__3__1__a)[0l]) > c[0l])
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)0] = de_thread_32__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                        else
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                      do
                        if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__3__3__1__a)[1l]) > c[1l])
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)1] = de_thread_32__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                        else
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                      do
                        if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__3__3__1__a)[2l]) > c[2l])
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)2] = de_thread_32__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                        else
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                      do
                        if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__3__3__1__a)[3l]) > c[3l])
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)3] = de_thread_32__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                        else
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                    }

                  while((_Bool)0);
                  do
                    if(j + -jj >= 0 && i >= 0 && !(j + -jj >= hig) && !(i >= wid))
                    {
                      unsigned int (*de_thread_32__1__1__1__1__1__2__1__1__1__3__4__1__a)[4l] = dthp->accumulate + (signed long int)(i + 0) + (signed long int)((j + -jj) * wid);
                      do
                        if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__3__4__1__a)[0l]) > c[0l])
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)0] = de_thread_32__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                        else
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                      do
                        if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__3__4__1__a)[1l]) > c[1l])
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)1] = de_thread_32__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                        else
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                      do
                        if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__3__4__1__a)[2l]) > c[2l])
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)2] = de_thread_32__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                        else
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                      do
                        if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__3__4__1__a)[3l]) > c[3l])
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)3] = de_thread_32__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                        else
                          de_thread_32__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                    }

                  while((_Bool)0);
                }

                else
                  if(jj == ii)
                  {
                    do
                      if(ii + i >= 0 && jj + j >= 0 && !(ii + i >= wid) && !(jj + j >= hig))
                      {
                        unsigned int (*de_thread_32__1__1__1__1__1__2__1__1__1__4__1__1__a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + jj) * wid);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__4__1__1__a)[0l]) > c[0l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)0] = de_thread_32__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__4__1__1__a)[1l]) > c[1l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)1] = de_thread_32__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__4__1__1__a)[2l]) > c[2l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)2] = de_thread_32__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__4__1__1__a)[3l]) > c[3l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)3] = de_thread_32__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(jj + j >= 0 && i + -ii >= 0 && !(jj + j >= hig) && !(i + -ii >= wid))
                      {
                        unsigned int (*de_thread_32__1__1__1__1__1__2__1__1__1__4__2__1__a)[4l] = dthp->accumulate + (signed long int)(i + -ii) + (signed long int)((j + jj) * wid);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__4__2__1__a)[0l]) > c[0l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)0] = de_thread_32__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__4__2__1__a)[1l]) > c[1l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)1] = de_thread_32__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__4__2__1__a)[2l]) > c[2l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)2] = de_thread_32__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__4__2__1__a)[3l]) > c[3l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)3] = de_thread_32__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(ii + i >= 0 && j + -jj >= 0 && !(ii + i >= wid) && !(j + -jj >= hig))
                      {
                        unsigned int (*de_thread_32__1__1__1__1__1__2__1__1__1__4__3__1__a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + -jj) * wid);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__4__3__1__a)[0l]) > c[0l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)0] = de_thread_32__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__4__3__1__a)[1l]) > c[1l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)1] = de_thread_32__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__4__3__1__a)[2l]) > c[2l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)2] = de_thread_32__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__4__3__1__a)[3l]) > c[3l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)3] = de_thread_32__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(i + -ii >= 0 && j + -jj >= 0 && !(i + -ii >= wid) && !(j + -jj >= hig))
                      {
                        unsigned int (*de_thread_32__1__1__1__1__1__2__1__1__1__4__4__1__a)[4l] = dthp->accumulate + (signed long int)(i + -ii) + (signed long int)((j + -jj) * wid);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__4__4__1__a)[0l]) > c[0l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)0] = de_thread_32__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__4__4__1__a)[1l]) > c[1l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)1] = de_thread_32__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__4__4__1__a)[2l]) > c[2l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)2] = de_thread_32__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__4__4__1__a)[3l]) > c[3l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)3] = de_thread_32__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                  }

                  else
                  {
                    do
                      if(ii + i >= 0 && jj + j >= 0 && !(ii + i >= wid) && !(jj + j >= hig))
                      {
                        unsigned int (*de_thread_32__1__1__1__1__1__2__1__1__1__5__1__1__a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + jj) * wid);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__1__1__a)[0l]) > c[0l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)0] = de_thread_32__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__1__1__a)[1l]) > c[1l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)1] = de_thread_32__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__1__1__a)[2l]) > c[2l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)2] = de_thread_32__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__1__1__a)[3l]) > c[3l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)3] = de_thread_32__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(jj + j >= 0 && i + -ii >= 0 && !(jj + j >= hig) && !(i + -ii >= wid))
                      {
                        unsigned int (*de_thread_32__1__1__1__1__1__2__1__1__1__5__2__1__a)[4l] = dthp->accumulate + (signed long int)(i + -ii) + (signed long int)((j + jj) * wid);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__2__1__a)[0l]) > c[0l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)0] = de_thread_32__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__2__1__a)[1l]) > c[1l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)1] = de_thread_32__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__2__1__a)[2l]) > c[2l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)2] = de_thread_32__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__2__1__a)[3l]) > c[3l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)3] = de_thread_32__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(ii + i >= 0 && j + -jj >= 0 && !(ii + i >= wid) && !(j + -jj >= hig))
                      {
                        unsigned int (*de_thread_32__1__1__1__1__1__2__1__1__1__5__3__1__a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + -jj) * wid);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__3__1__a)[0l]) > c[0l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)0] = de_thread_32__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__3__1__a)[1l]) > c[1l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)1] = de_thread_32__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__3__1__a)[2l]) > c[2l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)2] = de_thread_32__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__3__1__a)[3l]) > c[3l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)3] = de_thread_32__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(i + -ii >= 0 && j + -jj >= 0 && !(i + -ii >= wid) && !(j + -jj >= hig))
                      {
                        unsigned int (*de_thread_32__1__1__1__1__1__2__1__1__1__5__4__1__a)[4l] = dthp->accumulate + (signed long int)(i + -ii) + (signed long int)((j + -jj) * wid);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__4__1__a)[0l]) > c[0l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)0] = de_thread_32__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__4__1__a)[1l]) > c[1l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)1] = de_thread_32__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__4__1__a)[2l]) > c[2l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)2] = de_thread_32__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__4__1__a)[3l]) > c[3l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)3] = de_thread_32__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(ii + j >= 0 && jj + i >= 0 && !(ii + j >= hig) && !(jj + i >= wid))
                      {
                        unsigned int (*de_thread_32__1__1__1__1__1__2__1__1__1__5__5__1__a)[4l] = dthp->accumulate + (signed long int)(i + jj) + (signed long int)((j + ii) * wid);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__5__1__a)[0l]) > c[0l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)0] = de_thread_32__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__5__1__a)[1l]) > c[1l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)1] = de_thread_32__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__5__1__a)[2l]) > c[2l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)2] = de_thread_32__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__5__1__a)[3l]) > c[3l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)3] = de_thread_32__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(ii + j >= 0 && i + -jj >= 0 && !(ii + j >= hig) && !(i + -jj >= wid))
                      {
                        unsigned int (*de_thread_32__1__1__1__1__1__2__1__1__1__5__6__1__a)[4l] = dthp->accumulate + (signed long int)(i + -jj) + (signed long int)((j + ii) * wid);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__6__1__a)[0l]) > c[0l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)0] = de_thread_32__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__6__1__a)[1l]) > c[1l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)1] = de_thread_32__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__6__1__a)[2l]) > c[2l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)2] = de_thread_32__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__6__1__a)[3l]) > c[3l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)3] = de_thread_32__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(jj + i >= 0 && j + -ii >= 0 && !(jj + i >= wid) && !(j + -ii >= hig))
                      {
                        unsigned int (*de_thread_32__1__1__1__1__1__2__1__1__1__5__7__1__a)[4l] = dthp->accumulate + (signed long int)(i + jj) + (signed long int)((j + -ii) * wid);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__7__1__a)[0l]) > c[0l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)0] = de_thread_32__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__7__1__a)[1l]) > c[1l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)1] = de_thread_32__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__7__1__a)[2l]) > c[2l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)2] = de_thread_32__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__7__1__a)[3l]) > c[3l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)3] = de_thread_32__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(i + -jj >= 0 && j + -ii >= 0 && !(i + -jj >= wid) && !(j + -ii >= hig))
                      {
                        unsigned int (*de_thread_32__1__1__1__1__1__2__1__1__1__5__8__1__a)[4l] = dthp->accumulate + (signed long int)(i + -jj) + (signed long int)((j + -ii) * wid);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__8__1__a)[0l]) > c[0l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)0] = de_thread_32__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__8__1__a)[1l]) > c[1l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)1] = de_thread_32__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__8__1__a)[2l]) > c[2l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)2] = de_thread_32__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32__1__1__1__1__1__2__1__1__1__5__8__1__a)[3l]) > c[3l])
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)3] = de_thread_32__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                          else
                            de_thread_32__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                  }
              f_coef_idx = f_coef_idx + 1;
            }
        }
      }

    }
    pixel_num = ((j - str) + 1) * wid;
    if(!(dthp->last_thread == 0))
    {
      if(!(dthp->spec->verbose == 0))
      {
        return_value_time_8=time((signed long int *)(void *)0);
        if(!(return_value_time_8 == progress_timer))
        {
          progress_timer=time((signed long int *)(void *)0);
          fprintf(stderr, "\rdensity estimation: %d/%d          ", j - str, enr - str);
          fflush(stderr);
        }

      }

    }

    if(!(dthp->spec->progress == ((signed int (*)(void *, double, signed int, double))NULL)))
    {
      if(!(progress_count + ps >= pixel_num))
      {
        double return_value_floor_9;
        return_value_floor_9=floor((double)pixel_num / (double)ps);
        progress_count = (signed int)((double)ps * return_value_floor_9);
        if(!(dthp->last_thread == 0))
        {
          signed int rv;
          rv=dthp->spec->progress(dthp->spec->progress_parameter, (double)(100 * (j - str)) / (double)(enr - str), 1, (double)0);
          if(rv == 2)
          {
            *dthp->aborted = -1;
            nanosleep(&pauset, (struct timespec *)(void *)0);
            rv=dthp->spec->progress(dthp->spec->progress_parameter, (double)(100 * (j - str)) / (double)(enr - str), 1, (double)0);
            *dthp->aborted = 0;
          }

          if(rv == 1)
          {
            *dthp->aborted = 1;
            pthread_exit((void *)0);
          }

        }

        else
        {
          if(!(*dthp->aborted >= 0))
            do
              nanosleep(&pauset, (struct timespec *)(void *)0);
            while(!(*dthp->aborted >= 0));

          if(*dthp->aborted >= 1)
            pthread_exit((void *)0);

        }
      }

    }

  }
  pthread_exit((void *)0);
}

// de_thread_32_mt
// file rect.c line 57
static void de_thread_32_mt(void *dth)
{
  struct anonymous_16 *dthp = (struct anonymous_16 *)dth;
  signed int oversample = dthp->oversample;
  signed int ss;
  double return_value_floor_1;
  return_value_floor_1=floor((double)oversample / 2.0);
  ss = (signed int)return_value_floor_1;
  signed int scf = (signed int)!((oversample & 1) != 0);
  double scfact;
  scfact=pow((double)oversample / ((double)oversample + 1.0), 2.0);
  signed int wid = dthp->width;
  signed int hig = dthp->height;
  signed int ps = dthp->progress_size;
  signed int str = (oversample - 1) + dthp->start_row;
  signed int enr = (oversample - 1) + dthp->end_row;
  signed int i;
  signed int j;
  signed long int progress_timer = (signed long int)0;
  struct timespec pauset;
  signed int progress_count = 0;
  signed int pixel_num;
  pauset.tv_sec = (signed long int)0;
  pauset.tv_nsec = (signed long int)100000000;
  j = str;
  _Bool tmp_if_expr_2;
  double return_value_ceil_3;
  double return_value_pow_4;
  double return_value_floor_5;
  signed long int return_value_time_8;
  for( ; !(j >= enr); j = j + 1)
  {
    i = oversample - 1;
    for( ; !(i >= wid + -(oversample + -1)); i = i + 1)
    {
      signed int ii;
      signed int jj;
      double f_select = 0.0;
      signed int f_select_int;
      signed int f_coef_idx;
      signed int arr_filt_width;
      unsigned int (*b)[5l];
      double c[4l];
      double ls;
      b = dthp->b + (signed long int)i + (signed long int)(j * wid);
      if((*b)[4l] == 0u)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = b[(signed long int)0][(signed long int)3] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_2)
      {
        ii = -ss;
        for( ; ss >= ii; ii = ii + 1)
        {
          jj = -ss;
          for( ; ss >= jj; jj = jj + 1)
          {
            b = dthp->b + (signed long int)(i + ii) + (signed long int)((j + jj) * wid);
            f_select = f_select + (double)b[(signed long int)0][(signed long int)4] / 255.0;
          }
        }
        if(!(scf == 0))
          f_select = f_select * scfact;

        if(f_select > (double)dthp->de->max_filtered_counts)
          f_select_int = dthp->de->max_filter_index;

        else
          if(f_select <= 100.000000)
          {
            return_value_ceil_3=ceil(f_select);
            f_select_int = (signed int)return_value_ceil_3 - 1;
          }

          else
          {
            return_value_pow_4=pow(f_select - (double)100, dthp->curve);
            return_value_floor_5=floor(return_value_pow_4);
            f_select_int = (signed int)100 + (signed int)return_value_floor_5;
          }
        if(!(dthp->de->max_filter_index >= f_select_int))
          f_select_int = dthp->de->max_filter_index;

        f_coef_idx = f_select_int * dthp->de->kernel_size;
        double return_value_ceil_6;
        return_value_ceil_6=ceil(dthp->de->filter_widths[(signed long int)f_select_int]);
        arr_filt_width = (signed int)return_value_ceil_6 - 1;
        b = dthp->b + (signed long int)i + (signed long int)(j * wid);
        jj = 0;
        for( ; arr_filt_width >= jj; jj = jj + 1)
        {
          ii = 0;
          for( ; jj >= ii; ii = ii + 1)
            if(IEEE_FLOAT_EQUAL(dthp->de->filter_coefs[(signed long int)f_coef_idx], 0.0))
              f_coef_idx = f_coef_idx + 1;

            else
            {
              c[(signed long int)0] = (double)b[(signed long int)0][(signed long int)0];
              c[(signed long int)1] = (double)b[(signed long int)0][(signed long int)1];
              c[(signed long int)2] = (double)b[(signed long int)0][(signed long int)2];
              c[(signed long int)3] = (double)b[(signed long int)0][(signed long int)3];
              double return_value_log_7;
              return_value_log_7=log(1.0 + c[(signed long int)3] * dthp->k2);
              ls = (dthp->de->filter_coefs[(signed long int)f_coef_idx] * dthp->k1 * return_value_log_7) / c[(signed long int)3];
              c[(signed long int)0] = c[(signed long int)0] * ls;
              c[(signed long int)1] = c[(signed long int)1] * ls;
              c[(signed long int)2] = c[(signed long int)2] * ls;
              c[(signed long int)3] = c[(signed long int)3] * ls;
              if(ii == 0 && jj == 0)
                do
                  if(ii + i >= 0 && jj + j >= 0 && !(ii + i >= wid) && !(jj + j >= hig))
                  {
                    unsigned int (*a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + jj) * wid);
                    do
                      if((double)(1U + -(*a)[0l]) > c[0l])
                        a[(signed long int)0][(signed long int)0] = a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                      else
                        a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                    while((_Bool)0);
                    do
                      if((double)(1U + -(*a)[1l]) > c[1l])
                        a[(signed long int)0][(signed long int)1] = a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                      else
                        a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                    while((_Bool)0);
                    do
                      if((double)(1U + -(*a)[2l]) > c[2l])
                        a[(signed long int)0][(signed long int)2] = a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                      else
                        a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                    while((_Bool)0);
                    do
                      if((double)(1U + -(*a)[3l]) > c[3l])
                        a[(signed long int)0][(signed long int)3] = a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                      else
                        a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                    while((_Bool)0);
                  }

                while((_Bool)0);

              else
                if(ii == 0)
                {
                  do
                    if(jj + i >= 0 && j >= 0 && !(jj + i >= wid) && !(j >= hig))
                    {
                      unsigned int (*de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__1__1__a)[4l] = dthp->accumulate + (signed long int)(i + jj) + (signed long int)((j + 0) * wid);
                      do
                        if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__1__1__a)[0l]) > c[0l])
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)0] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                        else
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                      do
                        if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__1__1__a)[1l]) > c[1l])
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)1] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                        else
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                      do
                        if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__1__1__a)[2l]) > c[2l])
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)2] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                        else
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                      do
                        if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__1__1__a)[3l]) > c[3l])
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)3] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                        else
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                    }

                  while((_Bool)0);
                  do
                    if(i + -jj >= 0 && j >= 0 && !(i + -jj >= wid) && !(j >= hig))
                    {
                      unsigned int (*de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__2__1__a)[4l] = dthp->accumulate + (signed long int)(i + -jj) + (signed long int)((j + 0) * wid);
                      do
                        if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__2__1__a)[0l]) > c[0l])
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)0] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                        else
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                      do
                        if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__2__1__a)[1l]) > c[1l])
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)1] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                        else
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                      do
                        if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__2__1__a)[2l]) > c[2l])
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)2] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                        else
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                      do
                        if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__2__1__a)[3l]) > c[3l])
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)3] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                        else
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                    }

                  while((_Bool)0);
                  do
                    if(jj + j >= 0 && i >= 0 && !(jj + j >= hig) && !(i >= wid))
                    {
                      unsigned int (*de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__3__1__a)[4l] = dthp->accumulate + (signed long int)(i + 0) + (signed long int)((j + jj) * wid);
                      do
                        if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__3__1__a)[0l]) > c[0l])
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)0] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                        else
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                      do
                        if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__3__1__a)[1l]) > c[1l])
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)1] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                        else
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                      do
                        if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__3__1__a)[2l]) > c[2l])
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)2] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                        else
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                      do
                        if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__3__1__a)[3l]) > c[3l])
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)3] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                        else
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                    }

                  while((_Bool)0);
                  do
                    if(j + -jj >= 0 && i >= 0 && !(j + -jj >= hig) && !(i >= wid))
                    {
                      unsigned int (*de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__4__1__a)[4l] = dthp->accumulate + (signed long int)(i + 0) + (signed long int)((j + -jj) * wid);
                      do
                        if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__4__1__a)[0l]) > c[0l])
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)0] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                        else
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                      do
                        if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__4__1__a)[1l]) > c[1l])
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)1] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                        else
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                      do
                        if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__4__1__a)[2l]) > c[2l])
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)2] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                        else
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                      do
                        if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__4__1__a)[3l]) > c[3l])
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)3] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                        else
                          de_thread_32_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                      while((_Bool)0);
                    }

                  while((_Bool)0);
                }

                else
                  if(jj == ii)
                  {
                    do
                      if(ii + i >= 0 && jj + j >= 0 && !(ii + i >= wid) && !(jj + j >= hig))
                      {
                        unsigned int (*de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__1__1__a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + jj) * wid);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__1__1__a)[0l]) > c[0l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)0] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__1__1__a)[1l]) > c[1l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)1] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__1__1__a)[2l]) > c[2l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)2] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__1__1__a)[3l]) > c[3l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)3] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(jj + j >= 0 && i + -ii >= 0 && !(jj + j >= hig) && !(i + -ii >= wid))
                      {
                        unsigned int (*de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__2__1__a)[4l] = dthp->accumulate + (signed long int)(i + -ii) + (signed long int)((j + jj) * wid);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__2__1__a)[0l]) > c[0l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)0] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__2__1__a)[1l]) > c[1l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)1] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__2__1__a)[2l]) > c[2l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)2] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__2__1__a)[3l]) > c[3l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)3] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(ii + i >= 0 && j + -jj >= 0 && !(ii + i >= wid) && !(j + -jj >= hig))
                      {
                        unsigned int (*de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__3__1__a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + -jj) * wid);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__3__1__a)[0l]) > c[0l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)0] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__3__1__a)[1l]) > c[1l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)1] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__3__1__a)[2l]) > c[2l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)2] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__3__1__a)[3l]) > c[3l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)3] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(i + -ii >= 0 && j + -jj >= 0 && !(i + -ii >= wid) && !(j + -jj >= hig))
                      {
                        unsigned int (*de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__4__1__a)[4l] = dthp->accumulate + (signed long int)(i + -ii) + (signed long int)((j + -jj) * wid);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__4__1__a)[0l]) > c[0l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)0] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__4__1__a)[1l]) > c[1l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)1] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__4__1__a)[2l]) > c[2l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)2] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__4__1__a)[3l]) > c[3l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)3] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                  }

                  else
                  {
                    do
                      if(ii + i >= 0 && jj + j >= 0 && !(ii + i >= wid) && !(jj + j >= hig))
                      {
                        unsigned int (*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__1__1__a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + jj) * wid);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__1__1__a)[0l]) > c[0l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)0] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__1__1__a)[1l]) > c[1l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)1] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__1__1__a)[2l]) > c[2l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)2] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__1__1__a)[3l]) > c[3l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)3] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(jj + j >= 0 && i + -ii >= 0 && !(jj + j >= hig) && !(i + -ii >= wid))
                      {
                        unsigned int (*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__2__1__a)[4l] = dthp->accumulate + (signed long int)(i + -ii) + (signed long int)((j + jj) * wid);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__2__1__a)[0l]) > c[0l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)0] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__2__1__a)[1l]) > c[1l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)1] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__2__1__a)[2l]) > c[2l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)2] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__2__1__a)[3l]) > c[3l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)3] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(ii + i >= 0 && j + -jj >= 0 && !(ii + i >= wid) && !(j + -jj >= hig))
                      {
                        unsigned int (*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__3__1__a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + -jj) * wid);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__3__1__a)[0l]) > c[0l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)0] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__3__1__a)[1l]) > c[1l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)1] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__3__1__a)[2l]) > c[2l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)2] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__3__1__a)[3l]) > c[3l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)3] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(i + -ii >= 0 && j + -jj >= 0 && !(i + -ii >= wid) && !(j + -jj >= hig))
                      {
                        unsigned int (*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__4__1__a)[4l] = dthp->accumulate + (signed long int)(i + -ii) + (signed long int)((j + -jj) * wid);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__4__1__a)[0l]) > c[0l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)0] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__4__1__a)[1l]) > c[1l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)1] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__4__1__a)[2l]) > c[2l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)2] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__4__1__a)[3l]) > c[3l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)3] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(ii + j >= 0 && jj + i >= 0 && !(ii + j >= hig) && !(jj + i >= wid))
                      {
                        unsigned int (*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__5__1__a)[4l] = dthp->accumulate + (signed long int)(i + jj) + (signed long int)((j + ii) * wid);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__5__1__a)[0l]) > c[0l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)0] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__5__1__a)[1l]) > c[1l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)1] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__5__1__a)[2l]) > c[2l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)2] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__5__1__a)[3l]) > c[3l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)3] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(ii + j >= 0 && i + -jj >= 0 && !(ii + j >= hig) && !(i + -jj >= wid))
                      {
                        unsigned int (*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__6__1__a)[4l] = dthp->accumulate + (signed long int)(i + -jj) + (signed long int)((j + ii) * wid);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__6__1__a)[0l]) > c[0l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)0] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__6__1__a)[1l]) > c[1l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)1] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__6__1__a)[2l]) > c[2l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)2] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__6__1__a)[3l]) > c[3l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)3] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(jj + i >= 0 && j + -ii >= 0 && !(jj + i >= wid) && !(j + -ii >= hig))
                      {
                        unsigned int (*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__7__1__a)[4l] = dthp->accumulate + (signed long int)(i + jj) + (signed long int)((j + -ii) * wid);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__7__1__a)[0l]) > c[0l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)0] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__7__1__a)[1l]) > c[1l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)1] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__7__1__a)[2l]) > c[2l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)2] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__7__1__a)[3l]) > c[3l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)3] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(i + -jj >= 0 && j + -ii >= 0 && !(i + -jj >= wid) && !(j + -ii >= hig))
                      {
                        unsigned int (*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__8__1__a)[4l] = dthp->accumulate + (signed long int)(i + -jj) + (signed long int)((j + -ii) * wid);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__8__1__a)[0l]) > c[0l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)0] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__8__1__a)[1l]) > c[1l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)1] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__8__1__a)[2l]) > c[2l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)2] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                        do
                          if((double)(1U + -(*de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__8__1__a)[3l]) > c[3l])
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)3] = de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                          else
                            de_thread_32_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                  }
              f_coef_idx = f_coef_idx + 1;
            }
        }
      }

    }
    pixel_num = ((j - str) + 1) * wid;
    if(!(dthp->last_thread == 0))
    {
      if(!(dthp->spec->verbose == 0))
      {
        return_value_time_8=time((signed long int *)(void *)0);
        if(!(return_value_time_8 == progress_timer))
        {
          progress_timer=time((signed long int *)(void *)0);
          fprintf(stderr, "\rdensity estimation: %d/%d          ", j - str, enr - str);
          fflush(stderr);
        }

      }

    }

    if(!(dthp->spec->progress == ((signed int (*)(void *, double, signed int, double))NULL)))
    {
      if(!(progress_count + ps >= pixel_num))
      {
        double return_value_floor_9;
        return_value_floor_9=floor((double)pixel_num / (double)ps);
        progress_count = (signed int)((double)ps * return_value_floor_9);
        if(!(dthp->last_thread == 0))
        {
          signed int rv;
          rv=dthp->spec->progress(dthp->spec->progress_parameter, (double)(100 * (j - str)) / (double)(enr - str), 1, (double)0);
          if(rv == 2)
          {
            *dthp->aborted = -1;
            nanosleep(&pauset, (struct timespec *)(void *)0);
            rv=dthp->spec->progress(dthp->spec->progress_parameter, (double)(100 * (j - str)) / (double)(enr - str), 1, (double)0);
            *dthp->aborted = 0;
          }

          if(rv == 1)
          {
            *dthp->aborted = 1;
            pthread_exit((void *)0);
          }

        }

        else
        {
          if(!(*dthp->aborted >= 0))
            do
              nanosleep(&pauset, (struct timespec *)(void *)0);
            while(!(*dthp->aborted >= 0));

          if(*dthp->aborted >= 1)
            pthread_exit((void *)0);

        }
      }

    }

  }
  pthread_exit((void *)0);
}

// de_thread_33
// file rect.c line 57
static void de_thread_33(void *dth)
{
  struct anonymous_17 *dthp = (struct anonymous_17 *)dth;
  signed int oversample = dthp->oversample;
  signed int ss;
  double return_value_floor_1;
  return_value_floor_1=floor((double)oversample / 2.0);
  ss = (signed int)return_value_floor_1;
  signed int scf = (signed int)!((oversample & 1) != 0);
  double scfact;
  scfact=pow((double)oversample / ((double)oversample + 1.0), 2.0);
  signed int wid = dthp->width;
  signed int hig = dthp->height;
  signed int ps = dthp->progress_size;
  signed int str = (oversample - 1) + dthp->start_row;
  signed int enr = (oversample - 1) + dthp->end_row;
  signed int i;
  signed int j;
  signed long int progress_timer = (signed long int)0;
  struct timespec pauset;
  signed int progress_count = 0;
  signed int pixel_num;
  pauset.tv_sec = (signed long int)0;
  pauset.tv_nsec = (signed long int)100000000;
  j = str;
  _Bool tmp_if_expr_2;
  double return_value_ceil_3;
  double return_value_pow_4;
  double return_value_floor_5;
  signed long int return_value_time_8;
  for( ; !(j >= enr); j = j + 1)
  {
    i = oversample - 1;
    for( ; !(i >= wid + -(oversample + -1)); i = i + 1)
    {
      signed int ii;
      signed int jj;
      double f_select = 0.0;
      signed int f_select_int;
      signed int f_coef_idx;
      signed int arr_filt_width;
      unsigned int (*b)[5l];
      double c[4l];
      double ls;
      b = dthp->b + (signed long int)i + (signed long int)(j * wid);
      if((*b)[4l] == 0u)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = b[(signed long int)0][(signed long int)3] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_2)
      {
        ii = -ss;
        for( ; ss >= ii; ii = ii + 1)
        {
          jj = -ss;
          for( ; ss >= jj; jj = jj + 1)
          {
            b = dthp->b + (signed long int)(i + ii) + (signed long int)((j + jj) * wid);
            f_select = f_select + (double)b[(signed long int)0][(signed long int)4] / 255.0;
          }
        }
        if(!(scf == 0))
          f_select = f_select * scfact;

        if(f_select > (double)dthp->de->max_filtered_counts)
          f_select_int = dthp->de->max_filter_index;

        else
          if(f_select <= 100.000000)
          {
            return_value_ceil_3=ceil(f_select);
            f_select_int = (signed int)return_value_ceil_3 - 1;
          }

          else
          {
            return_value_pow_4=pow(f_select - (double)100, dthp->curve);
            return_value_floor_5=floor(return_value_pow_4);
            f_select_int = (signed int)100 + (signed int)return_value_floor_5;
          }
        if(!(dthp->de->max_filter_index >= f_select_int))
          f_select_int = dthp->de->max_filter_index;

        f_coef_idx = f_select_int * dthp->de->kernel_size;
        double return_value_ceil_6;
        return_value_ceil_6=ceil(dthp->de->filter_widths[(signed long int)f_select_int]);
        arr_filt_width = (signed int)return_value_ceil_6 - 1;
        b = dthp->b + (signed long int)i + (signed long int)(j * wid);
        jj = 0;
        for( ; arr_filt_width >= jj; jj = jj + 1)
        {
          ii = 0;
          for( ; jj >= ii; ii = ii + 1)
            if(IEEE_FLOAT_EQUAL(dthp->de->filter_coefs[(signed long int)f_coef_idx], 0.0))
              f_coef_idx = f_coef_idx + 1;

            else
            {
              c[(signed long int)0] = (double)b[(signed long int)0][(signed long int)0];
              c[(signed long int)1] = (double)b[(signed long int)0][(signed long int)1];
              c[(signed long int)2] = (double)b[(signed long int)0][(signed long int)2];
              c[(signed long int)3] = (double)b[(signed long int)0][(signed long int)3];
              double return_value_log_7;
              return_value_log_7=log(1.0 + c[(signed long int)3] * dthp->k2);
              ls = (dthp->de->filter_coefs[(signed long int)f_coef_idx] * dthp->k1 * return_value_log_7) / c[(signed long int)3];
              c[(signed long int)0] = c[(signed long int)0] * ls;
              c[(signed long int)1] = c[(signed long int)1] * ls;
              c[(signed long int)2] = c[(signed long int)2] * ls;
              c[(signed long int)3] = c[(signed long int)3] * ls;
              if(ii == 0 && jj == 0)
                do
                  if(ii + i >= 0 && jj + j >= 0 && !(ii + i >= wid) && !(jj + j >= hig))
                  {
                    float (*a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + jj) * wid);
                    do
                      a[(signed long int)0][(signed long int)0] = a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                    while((_Bool)0);
                    do
                      a[(signed long int)0][(signed long int)1] = a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                    while((_Bool)0);
                    do
                      a[(signed long int)0][(signed long int)2] = a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                    while((_Bool)0);
                    do
                      a[(signed long int)0][(signed long int)3] = a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                    while((_Bool)0);
                  }

                while((_Bool)0);

              else
                if(ii == 0)
                {
                  do
                    if(jj + i >= 0 && j >= 0 && !(jj + i >= wid) && !(j >= hig))
                    {
                      float (*de_thread_33__1__1__1__1__1__2__1__1__1__3__1__1__a)[4l] = dthp->accumulate + (signed long int)(i + jj) + (signed long int)((j + 0) * wid);
                      do
                        de_thread_33__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)0] = de_thread_33__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                      while((_Bool)0);
                      do
                        de_thread_33__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)1] = de_thread_33__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                      while((_Bool)0);
                      do
                        de_thread_33__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)2] = de_thread_33__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                      while((_Bool)0);
                      do
                        de_thread_33__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)3] = de_thread_33__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                      while((_Bool)0);
                    }

                  while((_Bool)0);
                  do
                    if(i + -jj >= 0 && j >= 0 && !(i + -jj >= wid) && !(j >= hig))
                    {
                      float (*de_thread_33__1__1__1__1__1__2__1__1__1__3__2__1__a)[4l] = dthp->accumulate + (signed long int)(i + -jj) + (signed long int)((j + 0) * wid);
                      do
                        de_thread_33__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)0] = de_thread_33__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                      while((_Bool)0);
                      do
                        de_thread_33__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)1] = de_thread_33__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                      while((_Bool)0);
                      do
                        de_thread_33__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)2] = de_thread_33__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                      while((_Bool)0);
                      do
                        de_thread_33__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)3] = de_thread_33__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                      while((_Bool)0);
                    }

                  while((_Bool)0);
                  do
                    if(jj + j >= 0 && i >= 0 && !(jj + j >= hig) && !(i >= wid))
                    {
                      float (*de_thread_33__1__1__1__1__1__2__1__1__1__3__3__1__a)[4l] = dthp->accumulate + (signed long int)(i + 0) + (signed long int)((j + jj) * wid);
                      do
                        de_thread_33__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)0] = de_thread_33__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                      while((_Bool)0);
                      do
                        de_thread_33__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)1] = de_thread_33__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                      while((_Bool)0);
                      do
                        de_thread_33__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)2] = de_thread_33__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                      while((_Bool)0);
                      do
                        de_thread_33__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)3] = de_thread_33__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                      while((_Bool)0);
                    }

                  while((_Bool)0);
                  do
                    if(j + -jj >= 0 && i >= 0 && !(j + -jj >= hig) && !(i >= wid))
                    {
                      float (*de_thread_33__1__1__1__1__1__2__1__1__1__3__4__1__a)[4l] = dthp->accumulate + (signed long int)(i + 0) + (signed long int)((j + -jj) * wid);
                      do
                        de_thread_33__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)0] = de_thread_33__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                      while((_Bool)0);
                      do
                        de_thread_33__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)1] = de_thread_33__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                      while((_Bool)0);
                      do
                        de_thread_33__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)2] = de_thread_33__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                      while((_Bool)0);
                      do
                        de_thread_33__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)3] = de_thread_33__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                      while((_Bool)0);
                    }

                  while((_Bool)0);
                }

                else
                  if(jj == ii)
                  {
                    do
                      if(ii + i >= 0 && jj + j >= 0 && !(ii + i >= wid) && !(jj + j >= hig))
                      {
                        float (*de_thread_33__1__1__1__1__1__2__1__1__1__4__1__1__a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + jj) * wid);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)0] = de_thread_33__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)1] = de_thread_33__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)2] = de_thread_33__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)3] = de_thread_33__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(jj + j >= 0 && i + -ii >= 0 && !(jj + j >= hig) && !(i + -ii >= wid))
                      {
                        float (*de_thread_33__1__1__1__1__1__2__1__1__1__4__2__1__a)[4l] = dthp->accumulate + (signed long int)(i + -ii) + (signed long int)((j + jj) * wid);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)0] = de_thread_33__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)1] = de_thread_33__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)2] = de_thread_33__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)3] = de_thread_33__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(ii + i >= 0 && j + -jj >= 0 && !(ii + i >= wid) && !(j + -jj >= hig))
                      {
                        float (*de_thread_33__1__1__1__1__1__2__1__1__1__4__3__1__a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + -jj) * wid);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)0] = de_thread_33__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)1] = de_thread_33__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)2] = de_thread_33__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)3] = de_thread_33__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(i + -ii >= 0 && j + -jj >= 0 && !(i + -ii >= wid) && !(j + -jj >= hig))
                      {
                        float (*de_thread_33__1__1__1__1__1__2__1__1__1__4__4__1__a)[4l] = dthp->accumulate + (signed long int)(i + -ii) + (signed long int)((j + -jj) * wid);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)0] = de_thread_33__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)1] = de_thread_33__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)2] = de_thread_33__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)3] = de_thread_33__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                  }

                  else
                  {
                    do
                      if(ii + i >= 0 && jj + j >= 0 && !(ii + i >= wid) && !(jj + j >= hig))
                      {
                        float (*de_thread_33__1__1__1__1__1__2__1__1__1__5__1__1__a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + jj) * wid);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)0] = de_thread_33__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)1] = de_thread_33__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)2] = de_thread_33__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)3] = de_thread_33__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(jj + j >= 0 && i + -ii >= 0 && !(jj + j >= hig) && !(i + -ii >= wid))
                      {
                        float (*de_thread_33__1__1__1__1__1__2__1__1__1__5__2__1__a)[4l] = dthp->accumulate + (signed long int)(i + -ii) + (signed long int)((j + jj) * wid);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)0] = de_thread_33__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)1] = de_thread_33__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)2] = de_thread_33__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)3] = de_thread_33__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(ii + i >= 0 && j + -jj >= 0 && !(ii + i >= wid) && !(j + -jj >= hig))
                      {
                        float (*de_thread_33__1__1__1__1__1__2__1__1__1__5__3__1__a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + -jj) * wid);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)0] = de_thread_33__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)1] = de_thread_33__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)2] = de_thread_33__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)3] = de_thread_33__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(i + -ii >= 0 && j + -jj >= 0 && !(i + -ii >= wid) && !(j + -jj >= hig))
                      {
                        float (*de_thread_33__1__1__1__1__1__2__1__1__1__5__4__1__a)[4l] = dthp->accumulate + (signed long int)(i + -ii) + (signed long int)((j + -jj) * wid);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)0] = de_thread_33__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)1] = de_thread_33__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)2] = de_thread_33__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)3] = de_thread_33__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(ii + j >= 0 && jj + i >= 0 && !(ii + j >= hig) && !(jj + i >= wid))
                      {
                        float (*de_thread_33__1__1__1__1__1__2__1__1__1__5__5__1__a)[4l] = dthp->accumulate + (signed long int)(i + jj) + (signed long int)((j + ii) * wid);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)0] = de_thread_33__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)1] = de_thread_33__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)2] = de_thread_33__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)3] = de_thread_33__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(ii + j >= 0 && i + -jj >= 0 && !(ii + j >= hig) && !(i + -jj >= wid))
                      {
                        float (*de_thread_33__1__1__1__1__1__2__1__1__1__5__6__1__a)[4l] = dthp->accumulate + (signed long int)(i + -jj) + (signed long int)((j + ii) * wid);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)0] = de_thread_33__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)1] = de_thread_33__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)2] = de_thread_33__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)3] = de_thread_33__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(jj + i >= 0 && j + -ii >= 0 && !(jj + i >= wid) && !(j + -ii >= hig))
                      {
                        float (*de_thread_33__1__1__1__1__1__2__1__1__1__5__7__1__a)[4l] = dthp->accumulate + (signed long int)(i + jj) + (signed long int)((j + -ii) * wid);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)0] = de_thread_33__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)1] = de_thread_33__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)2] = de_thread_33__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)3] = de_thread_33__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(i + -jj >= 0 && j + -ii >= 0 && !(i + -jj >= wid) && !(j + -ii >= hig))
                      {
                        float (*de_thread_33__1__1__1__1__1__2__1__1__1__5__8__1__a)[4l] = dthp->accumulate + (signed long int)(i + -jj) + (signed long int)((j + -ii) * wid);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)0] = de_thread_33__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)1] = de_thread_33__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)2] = de_thread_33__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_33__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)3] = de_thread_33__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                  }
              f_coef_idx = f_coef_idx + 1;
            }
        }
      }

    }
    pixel_num = ((j - str) + 1) * wid;
    if(!(dthp->last_thread == 0))
    {
      if(!(dthp->spec->verbose == 0))
      {
        return_value_time_8=time((signed long int *)(void *)0);
        if(!(return_value_time_8 == progress_timer))
        {
          progress_timer=time((signed long int *)(void *)0);
          fprintf(stderr, "\rdensity estimation: %d/%d          ", j - str, enr - str);
          fflush(stderr);
        }

      }

    }

    if(!(dthp->spec->progress == ((signed int (*)(void *, double, signed int, double))NULL)))
    {
      if(!(progress_count + ps >= pixel_num))
      {
        double return_value_floor_9;
        return_value_floor_9=floor((double)pixel_num / (double)ps);
        progress_count = (signed int)((double)ps * return_value_floor_9);
        if(!(dthp->last_thread == 0))
        {
          signed int rv;
          rv=dthp->spec->progress(dthp->spec->progress_parameter, (double)(100 * (j - str)) / (double)(enr - str), 1, (double)0);
          if(rv == 2)
          {
            *dthp->aborted = -1;
            nanosleep(&pauset, (struct timespec *)(void *)0);
            rv=dthp->spec->progress(dthp->spec->progress_parameter, (double)(100 * (j - str)) / (double)(enr - str), 1, (double)0);
            *dthp->aborted = 0;
          }

          if(rv == 1)
          {
            *dthp->aborted = 1;
            pthread_exit((void *)0);
          }

        }

        else
        {
          if(!(*dthp->aborted >= 0))
            do
              nanosleep(&pauset, (struct timespec *)(void *)0);
            while(!(*dthp->aborted >= 0));

          if(*dthp->aborted >= 1)
            pthread_exit((void *)0);

        }
      }

    }

  }
  pthread_exit((void *)0);
}

// de_thread_33_mt
// file rect.c line 57
static void de_thread_33_mt(void *dth)
{
  struct anonymous_17 *dthp = (struct anonymous_17 *)dth;
  signed int oversample = dthp->oversample;
  signed int ss;
  double return_value_floor_1;
  return_value_floor_1=floor((double)oversample / 2.0);
  ss = (signed int)return_value_floor_1;
  signed int scf = (signed int)!((oversample & 1) != 0);
  double scfact;
  scfact=pow((double)oversample / ((double)oversample + 1.0), 2.0);
  signed int wid = dthp->width;
  signed int hig = dthp->height;
  signed int ps = dthp->progress_size;
  signed int str = (oversample - 1) + dthp->start_row;
  signed int enr = (oversample - 1) + dthp->end_row;
  signed int i;
  signed int j;
  signed long int progress_timer = (signed long int)0;
  struct timespec pauset;
  signed int progress_count = 0;
  signed int pixel_num;
  pauset.tv_sec = (signed long int)0;
  pauset.tv_nsec = (signed long int)100000000;
  j = str;
  _Bool tmp_if_expr_2;
  double return_value_ceil_3;
  double return_value_pow_4;
  double return_value_floor_5;
  signed long int return_value_time_8;
  for( ; !(j >= enr); j = j + 1)
  {
    i = oversample - 1;
    for( ; !(i >= wid + -(oversample + -1)); i = i + 1)
    {
      signed int ii;
      signed int jj;
      double f_select = 0.0;
      signed int f_select_int;
      signed int f_coef_idx;
      signed int arr_filt_width;
      unsigned int (*b)[5l];
      double c[4l];
      double ls;
      b = dthp->b + (signed long int)i + (signed long int)(j * wid);
      if((*b)[4l] == 0u)
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = b[(signed long int)0][(signed long int)3] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_2)
      {
        ii = -ss;
        for( ; ss >= ii; ii = ii + 1)
        {
          jj = -ss;
          for( ; ss >= jj; jj = jj + 1)
          {
            b = dthp->b + (signed long int)(i + ii) + (signed long int)((j + jj) * wid);
            f_select = f_select + (double)b[(signed long int)0][(signed long int)4] / 255.0;
          }
        }
        if(!(scf == 0))
          f_select = f_select * scfact;

        if(f_select > (double)dthp->de->max_filtered_counts)
          f_select_int = dthp->de->max_filter_index;

        else
          if(f_select <= 100.000000)
          {
            return_value_ceil_3=ceil(f_select);
            f_select_int = (signed int)return_value_ceil_3 - 1;
          }

          else
          {
            return_value_pow_4=pow(f_select - (double)100, dthp->curve);
            return_value_floor_5=floor(return_value_pow_4);
            f_select_int = (signed int)100 + (signed int)return_value_floor_5;
          }
        if(!(dthp->de->max_filter_index >= f_select_int))
          f_select_int = dthp->de->max_filter_index;

        f_coef_idx = f_select_int * dthp->de->kernel_size;
        double return_value_ceil_6;
        return_value_ceil_6=ceil(dthp->de->filter_widths[(signed long int)f_select_int]);
        arr_filt_width = (signed int)return_value_ceil_6 - 1;
        b = dthp->b + (signed long int)i + (signed long int)(j * wid);
        jj = 0;
        for( ; arr_filt_width >= jj; jj = jj + 1)
        {
          ii = 0;
          for( ; jj >= ii; ii = ii + 1)
            if(IEEE_FLOAT_EQUAL(dthp->de->filter_coefs[(signed long int)f_coef_idx], 0.0))
              f_coef_idx = f_coef_idx + 1;

            else
            {
              c[(signed long int)0] = (double)b[(signed long int)0][(signed long int)0];
              c[(signed long int)1] = (double)b[(signed long int)0][(signed long int)1];
              c[(signed long int)2] = (double)b[(signed long int)0][(signed long int)2];
              c[(signed long int)3] = (double)b[(signed long int)0][(signed long int)3];
              double return_value_log_7;
              return_value_log_7=log(1.0 + c[(signed long int)3] * dthp->k2);
              ls = (dthp->de->filter_coefs[(signed long int)f_coef_idx] * dthp->k1 * return_value_log_7) / c[(signed long int)3];
              c[(signed long int)0] = c[(signed long int)0] * ls;
              c[(signed long int)1] = c[(signed long int)1] * ls;
              c[(signed long int)2] = c[(signed long int)2] * ls;
              c[(signed long int)3] = c[(signed long int)3] * ls;
              if(ii == 0 && jj == 0)
                do
                  if(ii + i >= 0 && jj + j >= 0 && !(ii + i >= wid) && !(jj + j >= hig))
                  {
                    float (*a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + jj) * wid);
                    do
                      a[(signed long int)0][(signed long int)0] = a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                    while((_Bool)0);
                    do
                      a[(signed long int)0][(signed long int)1] = a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                    while((_Bool)0);
                    do
                      a[(signed long int)0][(signed long int)2] = a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                    while((_Bool)0);
                    do
                      a[(signed long int)0][(signed long int)3] = a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                    while((_Bool)0);
                  }

                while((_Bool)0);

              else
                if(ii == 0)
                {
                  do
                    if(jj + i >= 0 && j >= 0 && !(jj + i >= wid) && !(j >= hig))
                    {
                      float (*de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__1__1__a)[4l] = dthp->accumulate + (signed long int)(i + jj) + (signed long int)((j + 0) * wid);
                      do
                        de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)0] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                      while((_Bool)0);
                      do
                        de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)1] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                      while((_Bool)0);
                      do
                        de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)2] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                      while((_Bool)0);
                      do
                        de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)3] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                      while((_Bool)0);
                    }

                  while((_Bool)0);
                  do
                    if(i + -jj >= 0 && j >= 0 && !(i + -jj >= wid) && !(j >= hig))
                    {
                      float (*de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__2__1__a)[4l] = dthp->accumulate + (signed long int)(i + -jj) + (signed long int)((j + 0) * wid);
                      do
                        de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)0] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                      while((_Bool)0);
                      do
                        de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)1] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                      while((_Bool)0);
                      do
                        de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)2] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                      while((_Bool)0);
                      do
                        de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)3] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                      while((_Bool)0);
                    }

                  while((_Bool)0);
                  do
                    if(jj + j >= 0 && i >= 0 && !(jj + j >= hig) && !(i >= wid))
                    {
                      float (*de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__3__1__a)[4l] = dthp->accumulate + (signed long int)(i + 0) + (signed long int)((j + jj) * wid);
                      do
                        de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)0] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                      while((_Bool)0);
                      do
                        de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)1] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                      while((_Bool)0);
                      do
                        de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)2] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                      while((_Bool)0);
                      do
                        de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)3] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                      while((_Bool)0);
                    }

                  while((_Bool)0);
                  do
                    if(j + -jj >= 0 && i >= 0 && !(j + -jj >= hig) && !(i >= wid))
                    {
                      float (*de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__4__1__a)[4l] = dthp->accumulate + (signed long int)(i + 0) + (signed long int)((j + -jj) * wid);
                      do
                        de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)0] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                      while((_Bool)0);
                      do
                        de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)1] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                      while((_Bool)0);
                      do
                        de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)2] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                      while((_Bool)0);
                      do
                        de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)3] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                      while((_Bool)0);
                    }

                  while((_Bool)0);
                }

                else
                  if(jj == ii)
                  {
                    do
                      if(ii + i >= 0 && jj + j >= 0 && !(ii + i >= wid) && !(jj + j >= hig))
                      {
                        float (*de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__1__1__a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + jj) * wid);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)0] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)1] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)2] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)3] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(jj + j >= 0 && i + -ii >= 0 && !(jj + j >= hig) && !(i + -ii >= wid))
                      {
                        float (*de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__2__1__a)[4l] = dthp->accumulate + (signed long int)(i + -ii) + (signed long int)((j + jj) * wid);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)0] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)1] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)2] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)3] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(ii + i >= 0 && j + -jj >= 0 && !(ii + i >= wid) && !(j + -jj >= hig))
                      {
                        float (*de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__3__1__a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + -jj) * wid);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)0] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)1] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)2] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)3] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(i + -ii >= 0 && j + -jj >= 0 && !(i + -ii >= wid) && !(j + -jj >= hig))
                      {
                        float (*de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__4__1__a)[4l] = dthp->accumulate + (signed long int)(i + -ii) + (signed long int)((j + -jj) * wid);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)0] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)1] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)2] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)3] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                  }

                  else
                  {
                    do
                      if(ii + i >= 0 && jj + j >= 0 && !(ii + i >= wid) && !(jj + j >= hig))
                      {
                        float (*de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__1__1__a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + jj) * wid);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)0] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)1] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)2] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)3] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(jj + j >= 0 && i + -ii >= 0 && !(jj + j >= hig) && !(i + -ii >= wid))
                      {
                        float (*de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__2__1__a)[4l] = dthp->accumulate + (signed long int)(i + -ii) + (signed long int)((j + jj) * wid);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)0] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)1] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)2] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)3] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(ii + i >= 0 && j + -jj >= 0 && !(ii + i >= wid) && !(j + -jj >= hig))
                      {
                        float (*de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__3__1__a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + -jj) * wid);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)0] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)1] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)2] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)3] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(i + -ii >= 0 && j + -jj >= 0 && !(i + -ii >= wid) && !(j + -jj >= hig))
                      {
                        float (*de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__4__1__a)[4l] = dthp->accumulate + (signed long int)(i + -ii) + (signed long int)((j + -jj) * wid);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)0] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)1] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)2] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)3] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(ii + j >= 0 && jj + i >= 0 && !(ii + j >= hig) && !(jj + i >= wid))
                      {
                        float (*de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__5__1__a)[4l] = dthp->accumulate + (signed long int)(i + jj) + (signed long int)((j + ii) * wid);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)0] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)1] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)2] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)3] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(ii + j >= 0 && i + -jj >= 0 && !(ii + j >= hig) && !(i + -jj >= wid))
                      {
                        float (*de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__6__1__a)[4l] = dthp->accumulate + (signed long int)(i + -jj) + (signed long int)((j + ii) * wid);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)0] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)1] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)2] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)3] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(jj + i >= 0 && j + -ii >= 0 && !(jj + i >= wid) && !(j + -ii >= hig))
                      {
                        float (*de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__7__1__a)[4l] = dthp->accumulate + (signed long int)(i + jj) + (signed long int)((j + -ii) * wid);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)0] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)1] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)2] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)3] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(i + -jj >= 0 && j + -ii >= 0 && !(i + -jj >= wid) && !(j + -ii >= hig))
                      {
                        float (*de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__8__1__a)[4l] = dthp->accumulate + (signed long int)(i + -jj) + (signed long int)((j + -ii) * wid);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)0] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)1] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)2] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)3] = de_thread_33_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                  }
              f_coef_idx = f_coef_idx + 1;
            }
        }
      }

    }
    pixel_num = ((j - str) + 1) * wid;
    if(!(dthp->last_thread == 0))
    {
      if(!(dthp->spec->verbose == 0))
      {
        return_value_time_8=time((signed long int *)(void *)0);
        if(!(return_value_time_8 == progress_timer))
        {
          progress_timer=time((signed long int *)(void *)0);
          fprintf(stderr, "\rdensity estimation: %d/%d          ", j - str, enr - str);
          fflush(stderr);
        }

      }

    }

    if(!(dthp->spec->progress == ((signed int (*)(void *, double, signed int, double))NULL)))
    {
      if(!(progress_count + ps >= pixel_num))
      {
        double return_value_floor_9;
        return_value_floor_9=floor((double)pixel_num / (double)ps);
        progress_count = (signed int)((double)ps * return_value_floor_9);
        if(!(dthp->last_thread == 0))
        {
          signed int rv;
          rv=dthp->spec->progress(dthp->spec->progress_parameter, (double)(100 * (j - str)) / (double)(enr - str), 1, (double)0);
          if(rv == 2)
          {
            *dthp->aborted = -1;
            nanosleep(&pauset, (struct timespec *)(void *)0);
            rv=dthp->spec->progress(dthp->spec->progress_parameter, (double)(100 * (j - str)) / (double)(enr - str), 1, (double)0);
            *dthp->aborted = 0;
          }

          if(rv == 1)
          {
            *dthp->aborted = 1;
            pthread_exit((void *)0);
          }

        }

        else
        {
          if(!(*dthp->aborted >= 0))
            do
              nanosleep(&pauset, (struct timespec *)(void *)0);
            while(!(*dthp->aborted >= 0));

          if(*dthp->aborted >= 1)
            pthread_exit((void *)0);

        }
      }

    }

  }
  pthread_exit((void *)0);
}

// de_thread_64
// file rect.c line 57
static void de_thread_64(void *dth)
{
  struct anonymous_15 *dthp = (struct anonymous_15 *)dth;
  signed int oversample = dthp->oversample;
  signed int ss;
  double return_value_floor_1;
  return_value_floor_1=floor((double)oversample / 2.0);
  ss = (signed int)return_value_floor_1;
  signed int scf = (signed int)!((oversample & 1) != 0);
  double scfact;
  scfact=pow((double)oversample / ((double)oversample + 1.0), 2.0);
  signed int wid = dthp->width;
  signed int hig = dthp->height;
  signed int ps = dthp->progress_size;
  signed int str = (oversample - 1) + dthp->start_row;
  signed int enr = (oversample - 1) + dthp->end_row;
  signed int i;
  signed int j;
  signed long int progress_timer = (signed long int)0;
  struct timespec pauset;
  signed int progress_count = 0;
  signed int pixel_num;
  pauset.tv_sec = (signed long int)0;
  pauset.tv_nsec = (signed long int)100000000;
  j = str;
  _Bool tmp_if_expr_2;
  double return_value_ceil_3;
  double return_value_pow_4;
  double return_value_floor_5;
  signed long int return_value_time_8;
  for( ; !(j >= enr); j = j + 1)
  {
    i = oversample - 1;
    for( ; !(i >= wid + -(oversample + -1)); i = i + 1)
    {
      signed int ii;
      signed int jj;
      double f_select = 0.0;
      signed int f_select_int;
      signed int f_coef_idx;
      signed int arr_filt_width;
      double (*b)[5l];
      double c[4l];
      double ls;
      b = dthp->b + (signed long int)i + (signed long int)(j * wid);
      if(IEEE_FLOAT_EQUAL((*b)[4l], 0.000000))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = IEEE_FLOAT_EQUAL(b[(signed long int)0][(signed long int)3], (double)0) ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_2)
      {
        ii = -ss;
        for( ; ss >= ii; ii = ii + 1)
        {
          jj = -ss;
          for( ; ss >= jj; jj = jj + 1)
          {
            b = dthp->b + (signed long int)(i + ii) + (signed long int)((j + jj) * wid);
            f_select = f_select + b[(signed long int)0][(signed long int)4] / 255.0;
          }
        }
        if(!(scf == 0))
          f_select = f_select * scfact;

        if(f_select > (double)dthp->de->max_filtered_counts)
          f_select_int = dthp->de->max_filter_index;

        else
          if(f_select <= 100.000000)
          {
            return_value_ceil_3=ceil(f_select);
            f_select_int = (signed int)return_value_ceil_3 - 1;
          }

          else
          {
            return_value_pow_4=pow(f_select - (double)100, dthp->curve);
            return_value_floor_5=floor(return_value_pow_4);
            f_select_int = (signed int)100 + (signed int)return_value_floor_5;
          }
        if(!(dthp->de->max_filter_index >= f_select_int))
          f_select_int = dthp->de->max_filter_index;

        f_coef_idx = f_select_int * dthp->de->kernel_size;
        double return_value_ceil_6;
        return_value_ceil_6=ceil(dthp->de->filter_widths[(signed long int)f_select_int]);
        arr_filt_width = (signed int)return_value_ceil_6 - 1;
        b = dthp->b + (signed long int)i + (signed long int)(j * wid);
        jj = 0;
        for( ; arr_filt_width >= jj; jj = jj + 1)
        {
          ii = 0;
          for( ; jj >= ii; ii = ii + 1)
            if(IEEE_FLOAT_EQUAL(dthp->de->filter_coefs[(signed long int)f_coef_idx], 0.0))
              f_coef_idx = f_coef_idx + 1;

            else
            {
              c[(signed long int)0] = (double)b[(signed long int)0][(signed long int)0];
              c[(signed long int)1] = (double)b[(signed long int)0][(signed long int)1];
              c[(signed long int)2] = (double)b[(signed long int)0][(signed long int)2];
              c[(signed long int)3] = (double)b[(signed long int)0][(signed long int)3];
              double return_value_log_7;
              return_value_log_7=log(1.0 + c[(signed long int)3] * dthp->k2);
              ls = (dthp->de->filter_coefs[(signed long int)f_coef_idx] * dthp->k1 * return_value_log_7) / c[(signed long int)3];
              c[(signed long int)0] = c[(signed long int)0] * ls;
              c[(signed long int)1] = c[(signed long int)1] * ls;
              c[(signed long int)2] = c[(signed long int)2] * ls;
              c[(signed long int)3] = c[(signed long int)3] * ls;
              if(ii == 0 && jj == 0)
                do
                  if(ii + i >= 0 && jj + j >= 0 && !(ii + i >= wid) && !(jj + j >= hig))
                  {
                    double (*de_thread_64__1__1__1__1__1__2__1__1__1__2__1__1__a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + jj) * wid);
                    do
                      de_thread_64__1__1__1__1__1__2__1__1__1__2__1__1__a[(signed long int)0][(signed long int)0] = de_thread_64__1__1__1__1__1__2__1__1__1__2__1__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                    while((_Bool)0);
                    do
                      de_thread_64__1__1__1__1__1__2__1__1__1__2__1__1__a[(signed long int)0][(signed long int)1] = de_thread_64__1__1__1__1__1__2__1__1__1__2__1__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                    while((_Bool)0);
                    do
                      de_thread_64__1__1__1__1__1__2__1__1__1__2__1__1__a[(signed long int)0][(signed long int)2] = de_thread_64__1__1__1__1__1__2__1__1__1__2__1__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                    while((_Bool)0);
                    do
                      de_thread_64__1__1__1__1__1__2__1__1__1__2__1__1__a[(signed long int)0][(signed long int)3] = de_thread_64__1__1__1__1__1__2__1__1__1__2__1__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                    while((_Bool)0);
                  }

                while((_Bool)0);

              else
                if(ii == 0)
                {
                  do
                    if(jj + i >= 0 && j >= 0 && !(jj + i >= wid) && !(j >= hig))
                    {
                      double (*a)[4l] = dthp->accumulate + (signed long int)(i + jj) + (signed long int)((j + 0) * wid);
                      do
                        a[(signed long int)0][(signed long int)0] = a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                      while((_Bool)0);
                      do
                        a[(signed long int)0][(signed long int)1] = a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                      while((_Bool)0);
                      do
                        a[(signed long int)0][(signed long int)2] = a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                      while((_Bool)0);
                      do
                        a[(signed long int)0][(signed long int)3] = a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                      while((_Bool)0);
                    }

                  while((_Bool)0);
                  do
                    if(i + -jj >= 0 && j >= 0 && !(i + -jj >= wid) && !(j >= hig))
                    {
                      double (*de_thread_64__1__1__1__1__1__2__1__1__1__3__2__1__a)[4l] = dthp->accumulate + (signed long int)(i + -jj) + (signed long int)((j + 0) * wid);
                      do
                        de_thread_64__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)0] = de_thread_64__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                      while((_Bool)0);
                      do
                        de_thread_64__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)1] = de_thread_64__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                      while((_Bool)0);
                      do
                        de_thread_64__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)2] = de_thread_64__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                      while((_Bool)0);
                      do
                        de_thread_64__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)3] = de_thread_64__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                      while((_Bool)0);
                    }

                  while((_Bool)0);
                  do
                    if(jj + j >= 0 && i >= 0 && !(jj + j >= hig) && !(i >= wid))
                    {
                      double (*de_thread_64__1__1__1__1__1__2__1__1__1__3__3__1__a)[4l] = dthp->accumulate + (signed long int)(i + 0) + (signed long int)((j + jj) * wid);
                      do
                        de_thread_64__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)0] = de_thread_64__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                      while((_Bool)0);
                      do
                        de_thread_64__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)1] = de_thread_64__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                      while((_Bool)0);
                      do
                        de_thread_64__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)2] = de_thread_64__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                      while((_Bool)0);
                      do
                        de_thread_64__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)3] = de_thread_64__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                      while((_Bool)0);
                    }

                  while((_Bool)0);
                  do
                    if(j + -jj >= 0 && i >= 0 && !(j + -jj >= hig) && !(i >= wid))
                    {
                      double (*de_thread_64__1__1__1__1__1__2__1__1__1__3__4__1__a)[4l] = dthp->accumulate + (signed long int)(i + 0) + (signed long int)((j + -jj) * wid);
                      do
                        de_thread_64__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)0] = de_thread_64__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                      while((_Bool)0);
                      do
                        de_thread_64__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)1] = de_thread_64__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                      while((_Bool)0);
                      do
                        de_thread_64__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)2] = de_thread_64__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                      while((_Bool)0);
                      do
                        de_thread_64__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)3] = de_thread_64__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                      while((_Bool)0);
                    }

                  while((_Bool)0);
                }

                else
                  if(jj == ii)
                  {
                    do
                      if(ii + i >= 0 && jj + j >= 0 && !(ii + i >= wid) && !(jj + j >= hig))
                      {
                        double (*de_thread_64__1__1__1__1__1__2__1__1__1__4__1__1__a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + jj) * wid);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)0] = de_thread_64__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)1] = de_thread_64__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)2] = de_thread_64__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)3] = de_thread_64__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(jj + j >= 0 && i + -ii >= 0 && !(jj + j >= hig) && !(i + -ii >= wid))
                      {
                        double (*de_thread_64__1__1__1__1__1__2__1__1__1__4__2__1__a)[4l] = dthp->accumulate + (signed long int)(i + -ii) + (signed long int)((j + jj) * wid);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)0] = de_thread_64__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)1] = de_thread_64__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)2] = de_thread_64__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)3] = de_thread_64__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(ii + i >= 0 && j + -jj >= 0 && !(ii + i >= wid) && !(j + -jj >= hig))
                      {
                        double (*de_thread_64__1__1__1__1__1__2__1__1__1__4__3__1__a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + -jj) * wid);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)0] = de_thread_64__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)1] = de_thread_64__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)2] = de_thread_64__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)3] = de_thread_64__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(i + -ii >= 0 && j + -jj >= 0 && !(i + -ii >= wid) && !(j + -jj >= hig))
                      {
                        double (*de_thread_64__1__1__1__1__1__2__1__1__1__4__4__1__a)[4l] = dthp->accumulate + (signed long int)(i + -ii) + (signed long int)((j + -jj) * wid);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)0] = de_thread_64__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)1] = de_thread_64__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)2] = de_thread_64__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)3] = de_thread_64__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                  }

                  else
                  {
                    do
                      if(ii + i >= 0 && jj + j >= 0 && !(ii + i >= wid) && !(jj + j >= hig))
                      {
                        double (*de_thread_64__1__1__1__1__1__2__1__1__1__5__1__1__a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + jj) * wid);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)0] = de_thread_64__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)1] = de_thread_64__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)2] = de_thread_64__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)3] = de_thread_64__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(jj + j >= 0 && i + -ii >= 0 && !(jj + j >= hig) && !(i + -ii >= wid))
                      {
                        double (*de_thread_64__1__1__1__1__1__2__1__1__1__5__2__1__a)[4l] = dthp->accumulate + (signed long int)(i + -ii) + (signed long int)((j + jj) * wid);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)0] = de_thread_64__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)1] = de_thread_64__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)2] = de_thread_64__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)3] = de_thread_64__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(ii + i >= 0 && j + -jj >= 0 && !(ii + i >= wid) && !(j + -jj >= hig))
                      {
                        double (*de_thread_64__1__1__1__1__1__2__1__1__1__5__3__1__a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + -jj) * wid);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)0] = de_thread_64__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)1] = de_thread_64__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)2] = de_thread_64__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)3] = de_thread_64__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(i + -ii >= 0 && j + -jj >= 0 && !(i + -ii >= wid) && !(j + -jj >= hig))
                      {
                        double (*de_thread_64__1__1__1__1__1__2__1__1__1__5__4__1__a)[4l] = dthp->accumulate + (signed long int)(i + -ii) + (signed long int)((j + -jj) * wid);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)0] = de_thread_64__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)1] = de_thread_64__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)2] = de_thread_64__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)3] = de_thread_64__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(ii + j >= 0 && jj + i >= 0 && !(ii + j >= hig) && !(jj + i >= wid))
                      {
                        double (*de_thread_64__1__1__1__1__1__2__1__1__1__5__5__1__a)[4l] = dthp->accumulate + (signed long int)(i + jj) + (signed long int)((j + ii) * wid);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)0] = de_thread_64__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)1] = de_thread_64__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)2] = de_thread_64__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)3] = de_thread_64__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(ii + j >= 0 && i + -jj >= 0 && !(ii + j >= hig) && !(i + -jj >= wid))
                      {
                        double (*de_thread_64__1__1__1__1__1__2__1__1__1__5__6__1__a)[4l] = dthp->accumulate + (signed long int)(i + -jj) + (signed long int)((j + ii) * wid);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)0] = de_thread_64__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)1] = de_thread_64__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)2] = de_thread_64__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)3] = de_thread_64__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(jj + i >= 0 && j + -ii >= 0 && !(jj + i >= wid) && !(j + -ii >= hig))
                      {
                        double (*de_thread_64__1__1__1__1__1__2__1__1__1__5__7__1__a)[4l] = dthp->accumulate + (signed long int)(i + jj) + (signed long int)((j + -ii) * wid);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)0] = de_thread_64__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)1] = de_thread_64__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)2] = de_thread_64__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)3] = de_thread_64__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(i + -jj >= 0 && j + -ii >= 0 && !(i + -jj >= wid) && !(j + -ii >= hig))
                      {
                        double (*de_thread_64__1__1__1__1__1__2__1__1__1__5__8__1__a)[4l] = dthp->accumulate + (signed long int)(i + -jj) + (signed long int)((j + -ii) * wid);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)0] = de_thread_64__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)1] = de_thread_64__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)2] = de_thread_64__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_64__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)3] = de_thread_64__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                  }
              f_coef_idx = f_coef_idx + 1;
            }
        }
      }

    }
    pixel_num = ((j - str) + 1) * wid;
    if(!(dthp->last_thread == 0))
    {
      if(!(dthp->spec->verbose == 0))
      {
        return_value_time_8=time((signed long int *)(void *)0);
        if(!(return_value_time_8 == progress_timer))
        {
          progress_timer=time((signed long int *)(void *)0);
          fprintf(stderr, "\rdensity estimation: %d/%d          ", j - str, enr - str);
          fflush(stderr);
        }

      }

    }

    if(!(dthp->spec->progress == ((signed int (*)(void *, double, signed int, double))NULL)))
    {
      if(!(progress_count + ps >= pixel_num))
      {
        double return_value_floor_9;
        return_value_floor_9=floor((double)pixel_num / (double)ps);
        progress_count = (signed int)((double)ps * return_value_floor_9);
        if(!(dthp->last_thread == 0))
        {
          signed int rv;
          rv=dthp->spec->progress(dthp->spec->progress_parameter, (double)(100 * (j - str)) / (double)(enr - str), 1, (double)0);
          if(rv == 2)
          {
            *dthp->aborted = -1;
            nanosleep(&pauset, (struct timespec *)(void *)0);
            rv=dthp->spec->progress(dthp->spec->progress_parameter, (double)(100 * (j - str)) / (double)(enr - str), 1, (double)0);
            *dthp->aborted = 0;
          }

          if(rv == 1)
          {
            *dthp->aborted = 1;
            pthread_exit((void *)0);
          }

        }

        else
        {
          if(!(*dthp->aborted >= 0))
            do
              nanosleep(&pauset, (struct timespec *)(void *)0);
            while(!(*dthp->aborted >= 0));

          if(*dthp->aborted >= 1)
            pthread_exit((void *)0);

        }
      }

    }

  }
  pthread_exit((void *)0);
}

// de_thread_64_mt
// file rect.c line 57
static void de_thread_64_mt(void *dth)
{
  struct anonymous_15 *dthp = (struct anonymous_15 *)dth;
  signed int oversample = dthp->oversample;
  signed int ss;
  double return_value_floor_1;
  return_value_floor_1=floor((double)oversample / 2.0);
  ss = (signed int)return_value_floor_1;
  signed int scf = (signed int)!((oversample & 1) != 0);
  double scfact;
  scfact=pow((double)oversample / ((double)oversample + 1.0), 2.0);
  signed int wid = dthp->width;
  signed int hig = dthp->height;
  signed int ps = dthp->progress_size;
  signed int str = (oversample - 1) + dthp->start_row;
  signed int enr = (oversample - 1) + dthp->end_row;
  signed int i;
  signed int j;
  signed long int progress_timer = (signed long int)0;
  struct timespec pauset;
  signed int progress_count = 0;
  signed int pixel_num;
  pauset.tv_sec = (signed long int)0;
  pauset.tv_nsec = (signed long int)100000000;
  j = str;
  _Bool tmp_if_expr_2;
  double return_value_ceil_3;
  double return_value_pow_4;
  double return_value_floor_5;
  signed long int return_value_time_8;
  for( ; !(j >= enr); j = j + 1)
  {
    i = oversample - 1;
    for( ; !(i >= wid + -(oversample + -1)); i = i + 1)
    {
      signed int ii;
      signed int jj;
      double f_select = 0.0;
      signed int f_select_int;
      signed int f_coef_idx;
      signed int arr_filt_width;
      double (*b)[5l];
      double c[4l];
      double ls;
      b = dthp->b + (signed long int)i + (signed long int)(j * wid);
      if(IEEE_FLOAT_EQUAL((*b)[4l], 0.000000))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = IEEE_FLOAT_EQUAL(b[(signed long int)0][(signed long int)3], (double)0) ? (_Bool)1 : (_Bool)0;
      if(!tmp_if_expr_2)
      {
        ii = -ss;
        for( ; ss >= ii; ii = ii + 1)
        {
          jj = -ss;
          for( ; ss >= jj; jj = jj + 1)
          {
            b = dthp->b + (signed long int)(i + ii) + (signed long int)((j + jj) * wid);
            f_select = f_select + b[(signed long int)0][(signed long int)4] / 255.0;
          }
        }
        if(!(scf == 0))
          f_select = f_select * scfact;

        if(f_select > (double)dthp->de->max_filtered_counts)
          f_select_int = dthp->de->max_filter_index;

        else
          if(f_select <= 100.000000)
          {
            return_value_ceil_3=ceil(f_select);
            f_select_int = (signed int)return_value_ceil_3 - 1;
          }

          else
          {
            return_value_pow_4=pow(f_select - (double)100, dthp->curve);
            return_value_floor_5=floor(return_value_pow_4);
            f_select_int = (signed int)100 + (signed int)return_value_floor_5;
          }
        if(!(dthp->de->max_filter_index >= f_select_int))
          f_select_int = dthp->de->max_filter_index;

        f_coef_idx = f_select_int * dthp->de->kernel_size;
        double return_value_ceil_6;
        return_value_ceil_6=ceil(dthp->de->filter_widths[(signed long int)f_select_int]);
        arr_filt_width = (signed int)return_value_ceil_6 - 1;
        b = dthp->b + (signed long int)i + (signed long int)(j * wid);
        jj = 0;
        for( ; arr_filt_width >= jj; jj = jj + 1)
        {
          ii = 0;
          for( ; jj >= ii; ii = ii + 1)
            if(IEEE_FLOAT_EQUAL(dthp->de->filter_coefs[(signed long int)f_coef_idx], 0.0))
              f_coef_idx = f_coef_idx + 1;

            else
            {
              c[(signed long int)0] = (double)b[(signed long int)0][(signed long int)0];
              c[(signed long int)1] = (double)b[(signed long int)0][(signed long int)1];
              c[(signed long int)2] = (double)b[(signed long int)0][(signed long int)2];
              c[(signed long int)3] = (double)b[(signed long int)0][(signed long int)3];
              double return_value_log_7;
              return_value_log_7=log(1.0 + c[(signed long int)3] * dthp->k2);
              ls = (dthp->de->filter_coefs[(signed long int)f_coef_idx] * dthp->k1 * return_value_log_7) / c[(signed long int)3];
              c[(signed long int)0] = c[(signed long int)0] * ls;
              c[(signed long int)1] = c[(signed long int)1] * ls;
              c[(signed long int)2] = c[(signed long int)2] * ls;
              c[(signed long int)3] = c[(signed long int)3] * ls;
              if(ii == 0 && jj == 0)
                do
                  if(ii + i >= 0 && jj + j >= 0 && !(ii + i >= wid) && !(jj + j >= hig))
                  {
                    double (*a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + jj) * wid);
                    do
                      a[(signed long int)0][(signed long int)0] = a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                    while((_Bool)0);
                    do
                      a[(signed long int)0][(signed long int)1] = a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                    while((_Bool)0);
                    do
                      a[(signed long int)0][(signed long int)2] = a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                    while((_Bool)0);
                    do
                      a[(signed long int)0][(signed long int)3] = a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                    while((_Bool)0);
                  }

                while((_Bool)0);

              else
                if(ii == 0)
                {
                  do
                    if(jj + i >= 0 && j >= 0 && !(jj + i >= wid) && !(j >= hig))
                    {
                      double (*de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__1__1__a)[4l] = dthp->accumulate + (signed long int)(i + jj) + (signed long int)((j + 0) * wid);
                      do
                        de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)0] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                      while((_Bool)0);
                      do
                        de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)1] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                      while((_Bool)0);
                      do
                        de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)2] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                      while((_Bool)0);
                      do
                        de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)3] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__1__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                      while((_Bool)0);
                    }

                  while((_Bool)0);
                  do
                    if(i + -jj >= 0 && j >= 0 && !(i + -jj >= wid) && !(j >= hig))
                    {
                      double (*de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__2__1__a)[4l] = dthp->accumulate + (signed long int)(i + -jj) + (signed long int)((j + 0) * wid);
                      do
                        de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)0] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                      while((_Bool)0);
                      do
                        de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)1] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                      while((_Bool)0);
                      do
                        de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)2] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                      while((_Bool)0);
                      do
                        de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)3] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__2__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                      while((_Bool)0);
                    }

                  while((_Bool)0);
                  do
                    if(jj + j >= 0 && i >= 0 && !(jj + j >= hig) && !(i >= wid))
                    {
                      double (*de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__3__1__a)[4l] = dthp->accumulate + (signed long int)(i + 0) + (signed long int)((j + jj) * wid);
                      do
                        de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)0] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                      while((_Bool)0);
                      do
                        de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)1] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                      while((_Bool)0);
                      do
                        de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)2] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                      while((_Bool)0);
                      do
                        de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)3] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__3__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                      while((_Bool)0);
                    }

                  while((_Bool)0);
                  do
                    if(j + -jj >= 0 && i >= 0 && !(j + -jj >= hig) && !(i >= wid))
                    {
                      double (*de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__4__1__a)[4l] = dthp->accumulate + (signed long int)(i + 0) + (signed long int)((j + -jj) * wid);
                      do
                        de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)0] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                      while((_Bool)0);
                      do
                        de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)1] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                      while((_Bool)0);
                      do
                        de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)2] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                      while((_Bool)0);
                      do
                        de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)3] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__3__4__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                      while((_Bool)0);
                    }

                  while((_Bool)0);
                }

                else
                  if(jj == ii)
                  {
                    do
                      if(ii + i >= 0 && jj + j >= 0 && !(ii + i >= wid) && !(jj + j >= hig))
                      {
                        double (*de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__1__1__a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + jj) * wid);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)0] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)1] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)2] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)3] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__1__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(jj + j >= 0 && i + -ii >= 0 && !(jj + j >= hig) && !(i + -ii >= wid))
                      {
                        double (*de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__2__1__a)[4l] = dthp->accumulate + (signed long int)(i + -ii) + (signed long int)((j + jj) * wid);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)0] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)1] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)2] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)3] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__2__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(ii + i >= 0 && j + -jj >= 0 && !(ii + i >= wid) && !(j + -jj >= hig))
                      {
                        double (*de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__3__1__a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + -jj) * wid);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)0] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)1] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)2] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)3] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__3__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(i + -ii >= 0 && j + -jj >= 0 && !(i + -ii >= wid) && !(j + -jj >= hig))
                      {
                        double (*de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__4__1__a)[4l] = dthp->accumulate + (signed long int)(i + -ii) + (signed long int)((j + -jj) * wid);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)0] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)1] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)2] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)3] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__4__4__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                  }

                  else
                  {
                    do
                      if(ii + i >= 0 && jj + j >= 0 && !(ii + i >= wid) && !(jj + j >= hig))
                      {
                        double (*de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__1__1__a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + jj) * wid);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)0] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)1] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)2] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)3] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__1__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(jj + j >= 0 && i + -ii >= 0 && !(jj + j >= hig) && !(i + -ii >= wid))
                      {
                        double (*de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__2__1__a)[4l] = dthp->accumulate + (signed long int)(i + -ii) + (signed long int)((j + jj) * wid);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)0] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)1] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)2] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)3] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__2__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(ii + i >= 0 && j + -jj >= 0 && !(ii + i >= wid) && !(j + -jj >= hig))
                      {
                        double (*de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__3__1__a)[4l] = dthp->accumulate + (signed long int)(i + ii) + (signed long int)((j + -jj) * wid);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)0] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)1] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)2] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)3] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__3__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(i + -ii >= 0 && j + -jj >= 0 && !(i + -ii >= wid) && !(j + -jj >= hig))
                      {
                        double (*de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__4__1__a)[4l] = dthp->accumulate + (signed long int)(i + -ii) + (signed long int)((j + -jj) * wid);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)0] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)1] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)2] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)3] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__4__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(ii + j >= 0 && jj + i >= 0 && !(ii + j >= hig) && !(jj + i >= wid))
                      {
                        double (*de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__5__1__a)[4l] = dthp->accumulate + (signed long int)(i + jj) + (signed long int)((j + ii) * wid);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)0] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)1] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)2] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)3] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__5__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(ii + j >= 0 && i + -jj >= 0 && !(ii + j >= hig) && !(i + -jj >= wid))
                      {
                        double (*de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__6__1__a)[4l] = dthp->accumulate + (signed long int)(i + -jj) + (signed long int)((j + ii) * wid);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)0] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)1] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)2] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)3] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__6__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(jj + i >= 0 && j + -ii >= 0 && !(jj + i >= wid) && !(j + -ii >= hig))
                      {
                        double (*de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__7__1__a)[4l] = dthp->accumulate + (signed long int)(i + jj) + (signed long int)((j + -ii) * wid);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)0] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)1] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)2] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)3] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__7__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                    do
                      if(i + -jj >= 0 && j + -ii >= 0 && !(i + -jj >= wid) && !(j + -ii >= hig))
                      {
                        double (*de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__8__1__a)[4l] = dthp->accumulate + (signed long int)(i + -jj) + (signed long int)((j + -ii) * wid);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)0] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)1] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)2] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                        while((_Bool)0);
                        do
                          de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)3] = de_thread_64_mt__1__1__1__1__1__2__1__1__1__5__8__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                        while((_Bool)0);
                      }

                    while((_Bool)0);
                  }
              f_coef_idx = f_coef_idx + 1;
            }
        }
      }

    }
    pixel_num = ((j - str) + 1) * wid;
    if(!(dthp->last_thread == 0))
    {
      if(!(dthp->spec->verbose == 0))
      {
        return_value_time_8=time((signed long int *)(void *)0);
        if(!(return_value_time_8 == progress_timer))
        {
          progress_timer=time((signed long int *)(void *)0);
          fprintf(stderr, "\rdensity estimation: %d/%d          ", j - str, enr - str);
          fflush(stderr);
        }

      }

    }

    if(!(dthp->spec->progress == ((signed int (*)(void *, double, signed int, double))NULL)))
    {
      if(!(progress_count + ps >= pixel_num))
      {
        double return_value_floor_9;
        return_value_floor_9=floor((double)pixel_num / (double)ps);
        progress_count = (signed int)((double)ps * return_value_floor_9);
        if(!(dthp->last_thread == 0))
        {
          signed int rv;
          rv=dthp->spec->progress(dthp->spec->progress_parameter, (double)(100 * (j - str)) / (double)(enr - str), 1, (double)0);
          if(rv == 2)
          {
            *dthp->aborted = -1;
            nanosleep(&pauset, (struct timespec *)(void *)0);
            rv=dthp->spec->progress(dthp->spec->progress_parameter, (double)(100 * (j - str)) / (double)(enr - str), 1, (double)0);
            *dthp->aborted = 0;
          }

          if(rv == 1)
          {
            *dthp->aborted = 1;
            pthread_exit((void *)0);
          }

        }

        else
        {
          if(!(*dthp->aborted >= 0))
            do
              nanosleep(&pauset, (struct timespec *)(void *)0);
            while(!(*dthp->aborted >= 0));

          if(*dthp->aborted >= 1)
            pthread_exit((void *)0);

        }
      }

    }

  }
  pthread_exit((void *)0);
}

// det_matrix
// file interpolation.c line 56
double det_matrix(double (*s)[2l])
{
  return s[(signed long int)0][(signed long int)0] * s[(signed long int)1][(signed long int)1] - s[(signed long int)0][(signed long int)1] * s[(signed long int)1][(signed long int)0];
}

// disc2_precalc
// file variations.c line 1962
void disc2_precalc(struct xform *xf)
{
  double add = xf->disc2_twist;
  double k;
  xf->disc2_timespi = xf->disc2_rot * 3.14159265358979323846;
  sincos(add, &xf->disc2_sinadd, &xf->disc2_cosadd);
  xf->disc2_cosadd = xf->disc2_cosadd - (double)1;
  if(add > 6.283185e+0)
  {
    k = ((double)1 + add) - (double)2 * 3.14159265358979323846;
    xf->disc2_cosadd = xf->disc2_cosadd * k;
    xf->disc2_sinadd = xf->disc2_sinadd * k;
  }

  if(add < -6.283185e+0)
  {
    k = (double)1 + add + (double)2 * 3.14159265358979323846;
    xf->disc2_cosadd = xf->disc2_cosadd * k;
    xf->disc2_sinadd = xf->disc2_sinadd * k;
  }

}

// docstring
// file private.h line 73
void docstring()
{
  signed int i;
  fputs(the_docstring0, stdout);
  char *return_value_flam3_version_1;
  return_value_flam3_version_1=flam3_version();
  fputs(return_value_flam3_version_1, stdout);
  fputs(the_docstring1, stdout);
  i = 0;
  for( ; !(i >= 98); i = i + 1)
    printf("  %2d. %s\n", i, flam3_variation_names[(signed long int)i]);
}

// double_atomic_add
// file flam3.c line 3507
static inline void double_atomic_add(double *dest, double delta)
{
  unsigned long int *int_ptr = (unsigned long int *)dest;
  /* tag-#anon#lUN[F64'dblval'||U64'intval'|] */
union anonymous_14
{
  // dblval
  double dblval;
  // intval
  unsigned long int intval;
};

/* */
  ;
  union anonymous_14 old_val;
  union anonymous_14 new_val;
  signed int success;
  do
  {
    old_val.dblval = *dest;
    new_val.dblval = old_val.dblval + delta;
    _Bool return_value___sync_bool_compare_and_swap_1;
    __CPROVER_atomic_begin();
    return_value___sync_bool_compare_and_swap_1 = *int_ptr == old_val.intval;
    *int_ptr = *int_ptr == old_val.intval ? new_val.intval : *int_ptr;
    FENCE(WRfence);
    __CPROVER_atomic_end();
    success = (signed int)return_value___sync_bool_compare_and_swap_1;
  }
  while(success == 0);
}

// establish_asymmetric_refangles
// file interpolation.h line 56
void establish_asymmetric_refangles(struct anonymous_0 *cp, signed int ncps)
{
  signed int k;
  signed int xfi;
  signed int col;
  double cxang[4l][2l];
  double d;
  double c1[2l];
  xfi = 0;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  for( ; !(xfi >= cp->num_xforms); xfi = xfi + 1)
  {
    if(cp->final_xform_enable == 1)
    {
      if(xfi == cp->final_xform_index)
        goto __CPROVER_DUMP_L18;

    }

    k = 0;
    for( ; !(k >= ncps); k = k + 1)
    {
      col = 0;
      for( ; !(col >= 2); col = col + 1)
      {
        c1[(signed long int)0] = ((cp + (signed long int)k)->xform + (signed long int)xfi)->c[(signed long int)col][(signed long int)0];
        c1[(signed long int)1] = ((cp + (signed long int)k)->xform + (signed long int)xfi)->c[(signed long int)col][(signed long int)1];
        cxang[(signed long int)k][(signed long int)col]=atan2(c1[(signed long int)1], c1[(signed long int)0]);
      }
    }
    k = 1;
    for( ; !(k >= ncps); k = k + 1)
    {
      col = 0;
      for( ; !(col >= 2); col = col + 1)
      {
        signed int sym0;
        signed int sym1;
        signed int padsymflag;
        d = cxang[(signed long int)k][(signed long int)col] - cxang[(signed long int)(k - 1)][(signed long int)col];
        if(d > 3.141593e+0)
          cxang[(signed long int)k][(signed long int)col] = cxang[(signed long int)k][(signed long int)col] - (double)2 * 3.14159265358979323846;

        else
          if(d < -3.141593e+0)
            cxang[(signed long int)k][(signed long int)col] = cxang[(signed long int)k][(signed long int)col] + (double)2 * 3.14159265358979323846;

        padsymflag = 0;
        if(IEEE_FLOAT_EQUAL(((cp + (signed long int)(k + -1))->xform + (signed long int)xfi)->animate, 0.000000))
          tmp_if_expr_1 = (_Bool)1;

        else
          tmp_if_expr_1 = (((cp + (signed long int)(k - 1))->xform + (signed long int)xfi)->padding == 1 ? (padsymflag != 0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
        sym0 = (signed int)tmp_if_expr_1;
        if(IEEE_FLOAT_EQUAL(((cp + (signed long int)k)->xform + (signed long int)xfi)->animate, 0.000000))
          tmp_if_expr_2 = (_Bool)1;

        else
          tmp_if_expr_2 = (((cp + (signed long int)k)->xform + (signed long int)xfi)->padding == 1 ? (padsymflag != 0 ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
        sym1 = (signed int)tmp_if_expr_2;
        if(sym0 == 0 && !(sym1 == 0))
          ((cp + (signed long int)k)->xform + (signed long int)xfi)->wind[(signed long int)col] = cxang[(signed long int)(k - 1)][(signed long int)col] + (double)2 * 3.14159265358979323846;

        else
          if(sym1 == 0 && !(sym0 == 0))
            ((cp + (signed long int)k)->xform + (signed long int)xfi)->wind[(signed long int)col] = cxang[(signed long int)k][(signed long int)col] + (double)2 * 3.14159265358979323846;

      }
    }

  __CPROVER_DUMP_L18:
    ;
  }
}

// flam3_add_motion_element
// file flam3.c line 981
void flam3_add_motion_element(struct xform *xf)
{
  xf->num_motion = xf->num_motion + 1;
  void *return_value_realloc_1;
  return_value_realloc_1=realloc((void *)xf->motion, (unsigned long int)xf->num_motion * sizeof(struct xform) /*3152ul*/ );
  xf->motion = (struct xform *)return_value_realloc_1;
  memset((void *)&xf->motion[(signed long int)(xf->num_motion - 1)], 0, sizeof(struct xform) /*3152ul*/ );
}

// flam3_add_symmetry
// file flam3.c line 2437
void flam3_add_symmetry(struct anonymous_0 *cp, signed int sym)
{
  signed int i;
  signed int j;
  signed int k;
  double a;
  signed int result = 0;
  signed long int return_value_random_4;
  if(sym == 0)
  {
    signed long int return_value_random_5;
    return_value_random_5=random();
    if(!((1l & return_value_random_5) == 0l))
    {
      signed long int return_value_random_1;
      return_value_random_1=random();
      static signed int sym_distrib[15l] = { -4, -3, -2, -2, -2, -1, -1, -1, 2, 2, 2, 3, 3, 4, 4 };
      sym = sym_distrib[(signed long int)((unsigned long int)return_value_random_1 % (sizeof(signed int [15l]) /*60ul*/  / sizeof(signed int) /*4ul*/ ))];
    }

    else
    {
      return_value_random_4=random();
      if(!((31l & return_value_random_4) == 0l))
      {
        signed long int return_value_random_2;
        return_value_random_2=random();
        sym = (signed int)(return_value_random_2 % (signed long int)13 - (signed long int)6);
      }

      else
      {
        signed long int return_value_random_3;
        return_value_random_3=random();
        sym = (signed int)(return_value_random_3 % (signed long int)51 - (signed long int)25);
      }
    }
  }

  if(!(sym == 0) && !(sym == 1))
  {
    cp->symmetry = sym;
    if(!(sym >= 0))
    {
      i = cp->num_xforms;
      flam3_add_xforms(cp, 1, 0, 0);
      (cp->xform + (signed long int)i)->density = 1.0;
      (cp->xform + (signed long int)i)->color_speed = 0.0;
      (cp->xform + (signed long int)i)->animate = 0.0;
      (cp->xform + (signed long int)i)->var[(signed long int)0] = 1.0;
      j = 1;
      for( ; !(j >= 98); j = j + 1)
        (cp->xform + (signed long int)i)->var[(signed long int)j] = (double)0;
      (cp->xform + (signed long int)i)->color = 1.0;
      (cp->xform + (signed long int)i)->c[(signed long int)0][(signed long int)0] = -1.0;
      (cp->xform + (signed long int)i)->c[(signed long int)0][(signed long int)1] = 0.0;
      (cp->xform + (signed long int)i)->c[(signed long int)1][(signed long int)0] = 0.0;
      (cp->xform + (signed long int)i)->c[(signed long int)1][(signed long int)1] = 1.0;
      (cp->xform + (signed long int)i)->c[(signed long int)2][(signed long int)0] = 0.0;
      (cp->xform + (signed long int)i)->c[(signed long int)2][(signed long int)1] = 0.0;
      result = result + 1;
      sym = -sym;
    }

    a = ((double)2 * 3.14159265358979323846) / (double)sym;
    k = 1;
    for( ; !(k >= sym); k = k + 1)
    {
      i = cp->num_xforms;
      flam3_add_xforms(cp, 1, 0, 0);
      (cp->xform + (signed long int)i)->density = 1.0;
      (cp->xform + (signed long int)i)->color_speed = 0.0;
      (cp->xform + (signed long int)i)->animate = 0.0;
      (cp->xform + (signed long int)i)->var[(signed long int)0] = 1.0;
      j = 1;
      for( ; !(j >= 98); j = j + 1)
        (cp->xform + (signed long int)i)->var[(signed long int)j] = (double)0;
      (cp->xform + (signed long int)i)->color = sym < 3 ? 0.0 : ((double)k - 1.0) / ((double)sym - 2.0);
      double return_value_cos_6;
      return_value_cos_6=cos((double)k * a);
      (cp->xform + (signed long int)i)->c[(signed long int)0][(signed long int)0]=round6(return_value_cos_6);
      double return_value_sin_7;
      return_value_sin_7=sin((double)k * a);
      (cp->xform + (signed long int)i)->c[(signed long int)0][(signed long int)1]=round6(return_value_sin_7);
      (cp->xform + (signed long int)i)->c[(signed long int)1][(signed long int)0]=round6(-(cp->xform + (signed long int)i)->c[(signed long int)0][(signed long int)1]);
      (cp->xform + (signed long int)i)->c[(signed long int)1][(signed long int)1] = (cp->xform + (signed long int)i)->c[(signed long int)0][(signed long int)0];
      (cp->xform + (signed long int)i)->c[(signed long int)2][(signed long int)0] = 0.0;
      (cp->xform + (signed long int)i)->c[(signed long int)2][(signed long int)1] = 0.0;
      result = result + 1;
    }
    qsort((void *)(char *)&cp->xform[(signed long int)(cp->num_xforms - result)], (unsigned long int)result, sizeof(struct xform) /*3152ul*/ , compare_xforms);
  }

}

// flam3_add_xforms
// file flam3.c line 1007
void flam3_add_xforms(struct anonymous_0 *thiscp, signed int num_to_add, signed int interp_padding, signed int final_flag)
{
  signed int i;
  signed int j;
  signed int old_num = thiscp->num_xforms;
  signed int oldstd;
  signed int numstd;
  struct xform tmp;
  oldstd = thiscp->num_xforms - (signed int)(thiscp->final_xform_index >= 0);
  void *return_value_realloc_1;
  return_value_realloc_1=realloc((void *)thiscp->xform, (unsigned long int)(thiscp->num_xforms + num_to_add) * sizeof(struct xform) /*3152ul*/ );
  thiscp->xform = (struct xform *)return_value_realloc_1;
  thiscp->num_xforms = thiscp->num_xforms + num_to_add;
  initialize_xforms(thiscp, old_num);
  if(!(interp_padding == 0))
  {
    i = old_num;
    for( ; !(i >= thiscp->num_xforms); i = i + 1)
      (thiscp->xform + (signed long int)i)->padding = 1;
  }

  if(thiscp->final_xform_index >= 0)
  {
    if(!(thiscp->final_xform_index == thiscp->num_xforms + -1))
    {
      tmp = thiscp->xform[(signed long int)thiscp->final_xform_index];
      i = thiscp->final_xform_index;
      for( ; !(i >= thiscp->num_xforms + -1); i = i + 1)
        thiscp->xform[(signed long int)i] = thiscp->xform[(signed long int)(i + 1)];
      thiscp->final_xform_index = thiscp->num_xforms - 1;
      thiscp->xform[(signed long int)thiscp->final_xform_index] = tmp;
    }

  }

  if(!(final_flag == 0))
  {
    thiscp->final_xform_enable = 1;
    thiscp->final_xform_index = thiscp->num_xforms - 1;
  }

  else
  {
    numstd = thiscp->num_xforms - (signed int)(thiscp->final_xform_index >= 0);
    i = 0;
    for( ; !(i >= oldstd); i = i + 1)
    {
      void *return_value_realloc_2;
      return_value_realloc_2=realloc((void *)thiscp->chaos[(signed long int)i], (unsigned long int)numstd * sizeof(double) /*8ul*/ );
      thiscp->chaos[(signed long int)i] = (double *)return_value_realloc_2;
      j = oldstd;
      for( ; !(j >= numstd); j = j + 1)
        thiscp->chaos[(signed long int)i][(signed long int)j] = 1.0;
    }
    void *return_value_realloc_3;
    return_value_realloc_3=realloc((void *)thiscp->chaos, (unsigned long int)numstd * sizeof(double *) /*8ul*/ );
    thiscp->chaos = (double **)return_value_realloc_3;
    i = oldstd;
    for( ; !(i >= numstd); i = i + 1)
    {
      void *return_value_malloc_4;
      return_value_malloc_4=malloc((unsigned long int)numstd * sizeof(double) /*8ul*/ );
      thiscp->chaos[(signed long int)i] = (double *)return_value_malloc_4;
      j = 0;
      for( ; !(j >= numstd); j = j + 1)
        thiscp->chaos[(signed long int)i][(signed long int)j] = 1.0;
    }
  }
}

// flam3_align
// file interpolation.h line 57
void flam3_align(struct anonymous_0 *dst, struct anonymous_0 *src, signed int nsrc)
{
  signed int i;
  signed int tfx;
  signed int tnx;
  signed int max_nx = 0;
  signed int max_fx = 0;
  signed int already_aligned = 1;
  signed int xf;
  signed int j;
  signed int ii;
  signed int fnd;
  double normed;
  signed int usethisone = nsrc / 2 - 1;
  max_nx = (src + (signed long int)0)->num_xforms - (signed int)((src + (signed long int)0)->final_xform_index >= 0);
  max_fx = (src + (signed long int)0)->final_xform_enable;
  i = 1;
  for( ; !(i >= nsrc); i = i + 1)
  {
    tnx = (src + (signed long int)i)->num_xforms - (signed int)((src + (signed long int)i)->final_xform_index >= 0);
    if(!(max_nx == tnx))
    {
      already_aligned = 0;
      if(!(max_nx >= tnx))
        max_nx = tnx;

    }

    tfx = (src + (signed long int)i)->final_xform_enable;
    if(!(max_fx == tfx))
    {
      already_aligned = 0;
      max_fx = max_fx | tfx;
    }

  }
  i = 0;
  for( ; !(i >= nsrc); i = i + 1)
    flam3_copyx(&dst[(signed long int)i], &src[(signed long int)i], max_nx, max_fx);
  _Bool tmp_if_expr_1;
  if((dst + (signed long int)usethisone)->interpolation_type == 2)
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = (dst + (signed long int)usethisone)->interpolation_type == 3 ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_9;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  if(!tmp_if_expr_1)
  {
    i = 0;
    for( ; !(i >= nsrc); i = i + 1)
    {
      xf = 0;
      for( ; !(xf >= max_fx + max_nx); xf = xf + 1)
      {
        j = 23;
        for( ; !(j >= 98); j = j + 1)
        {
          if(IEEE_FLOAT_EQUAL(((dst + (signed long int)i)->xform + (signed long int)xf)->var[(signed long int)j], 0.000000))
          {
            if(i >= 1)
            {
              if(IEEE_FLOAT_NOTEQUAL(((dst + (signed long int)(i + -1))->xform + (signed long int)xf)->var[(signed long int)j], 0.000000))
              {
                flam3_copy_params(&(dst + (signed long int)i)->xform[(signed long int)xf], &(dst + (signed long int)(i - 1))->xform[(signed long int)xf], j);
                goto __CPROVER_DUMP_L15;
              }

            }

            else
              if(!(i >= nsrc + -1))
              {
                if(IEEE_FLOAT_NOTEQUAL(((dst + (signed long int)(1 + i))->xform + (signed long int)xf)->var[(signed long int)j], 0.000000))
                  flam3_copy_params(&(dst + (signed long int)i)->xform[(signed long int)xf], &(dst + (signed long int)(i + 1))->xform[(signed long int)xf], j);

              }

          }


        __CPROVER_DUMP_L15:
          ;
        }
        if(((dst + (signed long int)i)->xform + (signed long int)xf)->padding == 1)
        {
          if(already_aligned == 0)
          {
            ((dst + (signed long int)i)->xform + (signed long int)xf)->var[(signed long int)0] = 0.0;
            fnd = 0;
            if(i == 0)
              tmp_if_expr_8 = (dst + (signed long int)i)->interpolation_type == 1 ? (_Bool)1 : (_Bool)0;

            else
              tmp_if_expr_8 = (_Bool)0;
            if(tmp_if_expr_8)
              tmp_if_expr_10 = (_Bool)1;

            else
            {
              if(i >= 1)
                tmp_if_expr_9 = (dst + (signed long int)(i - 1))->interpolation_type == 1 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_9 = (_Bool)0;
              tmp_if_expr_10 = tmp_if_expr_9 ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_10)
            {
              ii = -1;
              for( ; !(ii >= 2); ii = ii + 2)
                if(!(i + ii >= nsrc) && i + ii >= 0)
                {
                  if(!(((dst + (signed long int)(i + ii))->xform + (signed long int)xf)->padding == 1))
                  {
                    if(((dst + (signed long int)(i + ii))->xform + (signed long int)xf)->var[2l] > 0.000000)
                      tmp_if_expr_2 = (_Bool)1;

                    else
                      tmp_if_expr_2 = ((dst + (signed long int)(i + ii))->xform + (signed long int)xf)->var[(signed long int)38] > (double)0 ? (_Bool)1 : (_Bool)0;
                    if(tmp_if_expr_2)
                      tmp_if_expr_3 = (_Bool)1;

                    else
                      tmp_if_expr_3 = ((dst + (signed long int)(i + ii))->xform + (signed long int)xf)->var[(signed long int)32] > (double)0 ? (_Bool)1 : (_Bool)0;
                    if(tmp_if_expr_3)
                      tmp_if_expr_4 = (_Bool)1;

                    else
                      tmp_if_expr_4 = ((dst + (signed long int)(i + ii))->xform + (signed long int)xf)->var[(signed long int)33] > (double)0 ? (_Bool)1 : (_Bool)0;
                    if(tmp_if_expr_4)
                      tmp_if_expr_5 = (_Bool)1;

                    else
                      tmp_if_expr_5 = ((dst + (signed long int)(i + ii))->xform + (signed long int)xf)->var[(signed long int)5] > (double)0 ? (_Bool)1 : (_Bool)0;
                    if(tmp_if_expr_5)
                      tmp_if_expr_6 = (_Bool)1;

                    else
                      tmp_if_expr_6 = ((dst + (signed long int)(i + ii))->xform + (signed long int)xf)->var[(signed long int)79] > (double)0 ? (_Bool)1 : (_Bool)0;
                    if(tmp_if_expr_6)
                      tmp_if_expr_7 = (_Bool)1;

                    else
                      tmp_if_expr_7 = ((dst + (signed long int)(i + ii))->xform + (signed long int)xf)->var[(signed long int)78] > (double)0 ? (_Bool)1 : (_Bool)0;
                    if(tmp_if_expr_7)
                    {
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->var[(signed long int)0] = -1.0;
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->c[(signed long int)0][(signed long int)0] = -1.0;
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->c[(signed long int)0][(signed long int)1] = 0.0;
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->c[(signed long int)1][(signed long int)0] = 0.0;
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->c[(signed long int)1][(signed long int)1] = -1.0;
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->c[(signed long int)2][(signed long int)0] = 0.0;
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->c[(signed long int)2][(signed long int)1] = 0.0;
                      fnd = -1;
                    }

                  }

                }

            }

            if(fnd == 0)
            {
              ii = -1;
              for( ; !(ii >= 2); ii = ii + 2)
                if(!(i + ii >= nsrc) && i + ii >= 0)
                {
                  if(!(((dst + (signed long int)(i + ii))->xform + (signed long int)xf)->padding == 1))
                  {
                    if(((dst + (signed long int)(i + ii))->xform + (signed long int)xf)->var[40l] > 0.000000)
                    {
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->var[(signed long int)40] = 1.0;
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->rectangles_x = 0.0;
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->rectangles_y = 0.0;
                      fnd = fnd + 1;
                    }

                    if(((dst + (signed long int)(i + ii))->xform + (signed long int)xf)->var[26l] > 0.000000)
                    {
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->var[(signed long int)26] = 1.0;
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->rings2_val = 0.0;
                      fnd = fnd + 1;
                    }

                    if(((dst + (signed long int)(i + ii))->xform + (signed long int)xf)->var[25l] > 0.000000)
                    {
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->var[(signed long int)25] = 1.0;
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->fan2_x = 0.0;
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->fan2_y = 0.0;
                      fnd = fnd + 1;
                    }

                    if(((dst + (signed long int)(i + ii))->xform + (signed long int)xf)->var[23l] > 0.000000)
                    {
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->var[(signed long int)23] = 1.0;
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->blob_low = 1.0;
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->blob_high = 1.0;
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->blob_waves = 1.0;
                      fnd = fnd + 1;
                    }

                    if(((dst + (signed long int)(i + ii))->xform + (signed long int)xf)->var[30l] > 0.000000)
                    {
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->var[(signed long int)30] = 1.0;
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->perspective_angle = 0.0;
                      fnd = fnd + 1;
                    }

                    if(((dst + (signed long int)(i + ii))->xform + (signed long int)xf)->var[39l] > 0.000000)
                    {
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->var[(signed long int)39] = 1.0;
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->curl_c1 = 0.0;
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->curl_c2 = 0.0;
                      fnd = fnd + 1;
                    }

                    if(((dst + (signed long int)(i + ii))->xform + (signed long int)xf)->var[50l] > 0.000000)
                    {
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->var[(signed long int)50] = 1.0;
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->super_shape_n1 = 2.0;
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->super_shape_n2 = 2.0;
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->super_shape_n3 = 2.0;
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->super_shape_rnd = 0.0;
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->super_shape_holes = 0.0;
                      fnd = fnd + 1;
                    }

                  }

                }

            }

            if(fnd == 0)
            {
              ii = -1;
              for( ; !(ii >= 2); ii = ii + 2)
                if(!(i + ii >= nsrc) && i + ii >= 0)
                {
                  if(!(((dst + (signed long int)(i + ii))->xform + (signed long int)xf)->padding == 1))
                  {
                    if(((dst + (signed long int)(i + ii))->xform + (signed long int)xf)->var[22l] > 0.000000)
                    {
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->var[(signed long int)22] = 1.0;
                      fnd = fnd + 1;
                    }

                    if(((dst + (signed long int)(i + ii))->xform + (signed long int)xf)->var[21l] > 0.000000)
                    {
                      ((dst + (signed long int)i)->xform + (signed long int)xf)->var[(signed long int)21] = 1.0;
                      fnd = fnd + 1;
                    }

                  }

                }

              if(fnd >= 1)
              {
                ((dst + (signed long int)i)->xform + (signed long int)xf)->c[(signed long int)0][(signed long int)0] = 0.0;
                ((dst + (signed long int)i)->xform + (signed long int)xf)->c[(signed long int)0][(signed long int)1] = 1.0;
                ((dst + (signed long int)i)->xform + (signed long int)xf)->c[(signed long int)1][(signed long int)0] = 1.0;
                ((dst + (signed long int)i)->xform + (signed long int)xf)->c[(signed long int)1][(signed long int)1] = 0.0;
                ((dst + (signed long int)i)->xform + (signed long int)xf)->c[(signed long int)2][(signed long int)0] = 0.0;
                ((dst + (signed long int)i)->xform + (signed long int)xf)->c[(signed long int)2][(signed long int)1] = 0.0;
              }

            }

            if(fnd == 0)
              ((dst + (signed long int)i)->xform + (signed long int)xf)->var[(signed long int)0] = 1.0;

            else
              if(fnd >= 1)
              {
                normed = 0.0;
                j = 0;
                for( ; !(j >= 98); j = j + 1)
                  normed = normed + ((dst + (signed long int)i)->xform + (signed long int)xf)->var[(signed long int)j];
                j = 0;
                for( ; !(j >= 98); j = j + 1)
                  ((dst + (signed long int)i)->xform + (signed long int)xf)->var[(signed long int)j] = ((dst + (signed long int)i)->xform + (signed long int)xf)->var[(signed long int)j] / normed;
              }

          }

        }

      }
    }
  }

}

// flam3_apply_template
// file flam3.h line 585
void flam3_apply_template(struct anonymous_0 *cp, struct anonymous_0 *templ)
{
  if(templ->background[0l] >= 0.000000)
    cp->background[(signed long int)0] = templ->background[(signed long int)0];

  if(templ->background[1l] >= 0.000000)
    cp->background[(signed long int)1] = templ->background[(signed long int)1];

  if(templ->background[1l] >= 0.000000)
    cp->background[(signed long int)2] = templ->background[(signed long int)2];

  if(templ->zoom < 1.000000e+9)
    cp->zoom = templ->zoom;

  if(templ->spatial_oversample >= 1)
    cp->spatial_oversample = templ->spatial_oversample;

  if(templ->spatial_filter_radius >= 0.000000)
    cp->spatial_filter_radius = templ->spatial_filter_radius;

  if(templ->sample_density > 0.000000)
    cp->sample_density = templ->sample_density;

  if(templ->nbatches >= 1)
    cp->nbatches = templ->nbatches;

  if(templ->ntemporal_samples >= 1)
    cp->ntemporal_samples = templ->ntemporal_samples;

  if(templ->width >= 1)
  {
    cp->pixels_per_unit = (cp->pixels_per_unit * (double)templ->width) / (double)cp->width;
    cp->width = templ->width;
  }

  if(templ->height >= 1)
    cp->height = templ->height;

  if(templ->estimator >= 0.000000)
    cp->estimator = templ->estimator;

  if(templ->estimator_minimum >= 0.000000)
    cp->estimator_minimum = templ->estimator_minimum;

  if(templ->estimator_curve >= 0.000000)
    cp->estimator_curve = templ->estimator_curve;

  if(templ->gam_lin_thresh >= 0.000000)
    cp->gam_lin_thresh = templ->gam_lin_thresh;

  if(templ->nbatches >= 1)
    cp->nbatches = templ->nbatches;

  if(templ->ntemporal_samples >= 1)
    cp->ntemporal_samples = templ->ntemporal_samples;

  if(templ->spatial_filter_select >= 1)
    cp->spatial_filter_select = templ->spatial_filter_select;

  if(templ->interpolation >= 0)
    cp->interpolation = templ->interpolation;

  if(templ->interpolation_type >= 0)
    cp->interpolation_type = templ->interpolation_type;

  if(templ->temporal_filter_type >= 0)
    cp->temporal_filter_type = templ->temporal_filter_type;

  if(templ->temporal_filter_width > 0.000000)
    cp->temporal_filter_width = templ->temporal_filter_width;

  if(templ->temporal_filter_exp > -900.000000)
    cp->temporal_filter_exp = templ->temporal_filter_exp;

  if(templ->highlight_power >= 0.000000)
    cp->highlight_power = templ->highlight_power;

  if(templ->palette_mode >= 0)
    cp->palette_mode = templ->palette_mode;

}

// flam3_atof
// file parser.c line 50
double flam3_atof(char *nstr)
{
  double res;
  char *endp;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  res=strtod(nstr, &endp);
  unsigned long int return_value_strlen_2;
  return_value_strlen_2=strlen(nstr);
  if(!(endp == nstr + (signed long int)return_value_strlen_2))
  {
    flam3_conversion_failed = 1;
    fprintf(stderr, "flam3_atof: Error converting :%s: extra chars\n", nstr);
  }

  signed int *return_value___errno_location_3;
  return_value___errno_location_3=__errno_location();
  if(!(*return_value___errno_location_3 == 0))
  {
    flam3_conversion_failed = 1;
    fprintf(stderr, "flam3_atof: Error converting :%s:\n", nstr);
  }

  return res;
}

// flam3_atoi
// file parser.c line 26
signed int flam3_atoi(char *nstr)
{
  signed int res;
  char *endp;
  signed int *return_value___errno_location_1;
  return_value___errno_location_1=__errno_location();
  *return_value___errno_location_1 = 0;
  signed long int return_value_strtol_2;
  return_value_strtol_2=strtol(nstr, &endp, 10);
  res = (signed int)return_value_strtol_2;
  unsigned long int return_value_strlen_3;
  return_value_strlen_3=strlen(nstr);
  if(!(endp == nstr + (signed long int)return_value_strlen_3))
  {
    flam3_conversion_failed = 1;
    fprintf(stderr, "flam3_atoi : Error converting :%s: extra chars\n", nstr);
  }

  signed int *return_value___errno_location_4;
  return_value___errno_location_4=__errno_location();
  if(!(*return_value___errno_location_4 == 0))
  {
    flam3_conversion_failed = 1;
    fprintf(stderr, "flam3_atoi : Error converting :%s:\n", nstr);
  }

  return res;
}

// flam3_b_spline_filter
// file filters.c line 76
double flam3_b_spline_filter(double t)
{
  double tt;
  if(t < 0.000000)
    t = -t;

  if(t < 1.000000)
  {
    tt = t * t;
    return (.5 * tt * t - tt) + 2.0 / 3.0;
  }

  else
    if(t < 2.000000)
    {
      t = (double)2 - t;
      return (1.0 / 6.0) * t * t * t;
    }

  return 0.0;
}

// flam3_bell_filter
// file filters.c line 65
double flam3_bell_filter(double t)
{
  if(t < 0.000000)
    t = -t;

  if(t < .5)
    return .75 - t * t;

  else
    if(t < 1.5)
    {
      t = t - 1.5;
      return .5 * t * t;
    }

    else
      return 0.0;
}

// flam3_blackman_filter
// file filters.c line 98
double flam3_blackman_filter(double x)
{
  double return_value_cos_1;
  return_value_cos_1=cos(3.14159265358979323846 * x);
  double return_value_cos_2;
  return_value_cos_2=cos((double)2 * 3.14159265358979323846 * x);
  return 0.42 + 0.5 * return_value_cos_1 + 0.08 * return_value_cos_2;
}

// flam3_box_filter
// file filters.c line 54
double flam3_box_filter(double t)
{
  if(t <= 0.5 && t > -5.000000e-1)
    return 1.0;

  else
    return 0.0;
}

// flam3_calc_alpha
// file palettes.h line 33
double flam3_calc_alpha(double density, double gamma, double linrange)
{
  double dnorm = density;
  double funcval;
  funcval=pow(linrange, gamma);
  double frac;
  double alpha;
  if(dnorm > 0.000000)
  {
    if(dnorm < linrange)
    {
      frac = dnorm / linrange;
      double return_value_pow_1;
      return_value_pow_1=pow(dnorm, gamma);
      alpha = (1.0 - frac) * dnorm * (funcval / linrange) + frac * return_value_pow_1;
    }

    else
      alpha=pow(dnorm, gamma);
  }

  else
    alpha = (double)0;
  return alpha;
}

// flam3_calc_newrgb
// file palettes.h line 34
void flam3_calc_newrgb(double *cbuf, double ls, double highpow, double *newrgb)
{
  signed int rgbi;
  double newls;
  double lsratio;
  double newhsv[3l];
  double a;
  double maxa = -1.0;
  double maxc = (double)0;
  double adjhlp;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_2;
  if(IEEE_FLOAT_EQUAL(ls, 0.0))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    if(IEEE_FLOAT_EQUAL(*cbuf, 0.0))
      tmp_if_expr_1 = IEEE_FLOAT_EQUAL(cbuf[(signed long int)1], 0.0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      tmp_if_expr_2 = IEEE_FLOAT_EQUAL(cbuf[(signed long int)2], 0.0) ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
  {
    newrgb[(signed long int)0] = 0.0;
    newrgb[(signed long int)1] = 0.0;
    newrgb[(signed long int)2] = 0.0;
  }

  else
  {
    rgbi = 0;
    for( ; !(rgbi >= 3); rgbi = rgbi + 1)
    {
      a = ls * (cbuf[(signed long int)rgbi] / (double)255);
      if(a > maxa)
      {
        maxa = a;
        maxc = cbuf[(signed long int)rgbi] / (double)255;
      }

    }
    if(maxa > 255.000000 && highpow >= 0.0)
    {
      newls = 255.0 / maxc;
      lsratio=pow(newls / ls, highpow);
      rgbi = 0;
      for( ; !(rgbi >= 3); rgbi = rgbi + 1)
        newrgb[(signed long int)rgbi] = (newls * (cbuf[(signed long int)rgbi] / (double)255)) / 255.0;
      rgb2hsv(newrgb, newhsv);
      newhsv[(signed long int)1] = newhsv[(signed long int)1] * lsratio;
      hsv2rgb(newhsv, newrgb);
      rgbi = 0;
      for( ; !(rgbi >= 3); rgbi = rgbi + 1)
        newrgb[(signed long int)rgbi] = newrgb[(signed long int)rgbi] * 255.0;
    }

    else
    {
      newls = 255.0 / maxc;
      adjhlp = -highpow;
      if(adjhlp > 1.000000)
        adjhlp = (double)1;

      if(maxa <= 255.000000)
        adjhlp = 1.0;

      rgbi = 0;
      for( ; !(rgbi >= 3); rgbi = rgbi + 1)
        newrgb[(signed long int)rgbi] = ((1.0 - adjhlp) * newls + adjhlp * ls) * (cbuf[(signed long int)rgbi] / (double)255);
    }
  }
}

// flam3_catrom_filter
// file filters.c line 102
double flam3_catrom_filter(double x)
{
  if(x < -2.000000)
    return 0.0;

  else
    if(x < -1.000000)
      return 0.5 * (4.0 + x * (8.0 + x * (5.0 + x)));

    else
      if(x < 0.0)
        return 0.5 * (2.0 + x * x * (-5.0 - 3.0 * x));

      else
        if(x < 1.0)
          return 0.5 * (2.0 + x * x * (-5.0 + 3.0 * x));

        else
          if(x < 2.0)
            return 0.5 * (4.0 + x * (-8.0 + x * (5.0 - x)));

          else
            return 0.0;
}

// flam3_check_unity_chaos
// file flam3.c line 144
signed int flam3_check_unity_chaos(struct anonymous_0 *cp)
{
  signed int i;
  signed int j;
  signed int num_std;
  signed int unity = 1;
  num_std = cp->num_xforms - (signed int)(cp->final_xform_index >= 0);
  i = 0;
  for( ; !(i >= num_std); i = i + 1)
  {
    j = 0;
    for( ; !(j >= num_std); j = j + 1)
    {
      double return_value_fabs_1;
      return_value_fabs_1=fabs(cp->chaos[(signed long int)i][(signed long int)j] - 1.0);
      if(return_value_fabs_1 > 1e-10)
        unity = 0;

    }
  }
  return unity;
}

// flam3_colorhist
// file flam3.c line 346
signed int flam3_colorhist(struct anonymous_0 *cp, signed int num_batches, struct randctx *rc, double *hist)
{
  signed int lp;
  signed int plp;
  signed int mycolor;
  unsigned short int *xform_distrib;
  signed int sbs = 10000;
  double sub_batch[40000l];
  memset((void *)hist, 0, (unsigned long int)256 * sizeof(double) /*8ul*/ );
  signed int return_value_prepare_precalc_flags_1;
  return_value_prepare_precalc_flags_1=prepare_precalc_flags(cp);
  if(!(return_value_prepare_precalc_flags_1 == 0))
    return 1;

  else
  {
    xform_distrib=flam3_create_xform_distrib(cp);
    lp = 0;
    for( ; !(lp >= num_batches); lp = lp + 1)
    {
      sub_batch[(signed long int)0]=flam3_random_isaac_11(rc);
      sub_batch[(signed long int)1]=flam3_random_isaac_11(rc);
      sub_batch[(signed long int)2] = (double)0;
      sub_batch[(signed long int)3] = (double)0;
      if(xform_distrib == ((unsigned short int *)NULL))
        return 1;

      flam3_iterate(cp, sbs, 20, sub_batch, xform_distrib, rc);
      plp = 0;
      for( ; !(plp >= 4 * sbs); plp = plp + 4)
      {
        mycolor = (signed int)(sub_batch[(signed long int)(plp + 2)] * (double)256);
        if(!(mycolor >= 0))
          mycolor = 0;

        if(mycolor >= 256)
          mycolor = 255;

        hist[(signed long int)mycolor] = hist[(signed long int)mycolor] + (double)1;
      }
    }
    free((void *)xform_distrib);
    plp = 0;
    for( ; !(plp >= 256); plp = plp + 1)
      hist[(signed long int)plp] = hist[(signed long int)plp] / (double)(float)(num_batches * sbs);
    return 0;
  }
}

// flam3_copy
// file flam3.h line 529
void flam3_copy(struct anonymous_0 *dest, struct anonymous_0 *src)
{
  signed int i;
  signed int ii;
  signed int numstd;
  clear_cp(dest, 1);
  memcpy((void *)dest, (const void *)src, sizeof(struct anonymous_0) /*10712ul*/ );
  dest->num_xforms = 0;
  dest->final_xform_index = -1;
  dest->xform = (struct xform *)(void *)0;
  dest->chaos = (double **)(void *)0;
  numstd = src->num_xforms - (signed int)(src->final_xform_index >= 0);
  flam3_add_xforms(dest, numstd, 0, 0);
  i = 0;
  for( ; !(i >= numstd); i = i + 1)
    flam3_copy_xform(&dest->xform[(signed long int)i], &src->xform[(signed long int)i]);
  if(src->final_xform_index >= 0)
  {
    i = src->final_xform_index;
    flam3_add_xforms(dest, 1, 0, 1);
    ii = dest->final_xform_index;
    flam3_copy_xform(&dest->xform[(signed long int)ii], &src->xform[(signed long int)i]);
  }

  i = 0;
  for( ; !(i >= numstd); i = i + 1)
    memcpy((void *)dest->chaos[(signed long int)i], (const void *)src->chaos[(signed long int)i], (unsigned long int)numstd * sizeof(double) /*8ul*/ );
}

// flam3_copy_params
// file flam3.c line 788
void flam3_copy_params(struct xform *dest, struct xform *src, signed int varn)
{
  if(varn == 23)
  {
    dest->blob_low = src->blob_low;
    dest->blob_high = src->blob_high;
    dest->blob_waves = src->blob_waves;
  }

  else
    if(varn == 24)
    {
      dest->pdj_a = src->pdj_a;
      dest->pdj_b = src->pdj_b;
      dest->pdj_c = src->pdj_c;
      dest->pdj_d = src->pdj_d;
    }

    else
      if(varn == 25)
      {
        dest->fan2_x = src->fan2_x;
        dest->fan2_y = src->fan2_y;
      }

      else
        if(varn == 26)
          dest->rings2_val = src->rings2_val;

        else
          if(varn == 30)
          {
            dest->perspective_angle = src->perspective_angle;
            dest->perspective_dist = src->perspective_dist;
            dest->persp_vsin = src->persp_vsin;
            dest->persp_vfcos = src->persp_vfcos;
          }

          else
            if(varn == 32)
            {
              dest->julian_power = src->julian_power;
              dest->julian_dist = src->julian_dist;
              dest->julian_rN = src->julian_rN;
              dest->julian_cn = src->julian_cn;
            }

            else
              if(varn == 33)
              {
                dest->juliascope_power = src->juliascope_power;
                dest->juliascope_dist = src->juliascope_dist;
                dest->juliascope_rN = src->juliascope_rN;
                dest->juliascope_cn = src->juliascope_cn;
              }

              else
                if(varn == 36)
                  dest->radial_blur_angle = src->radial_blur_angle;

                else
                  if(varn == 37)
                  {
                    dest->pie_slices = src->pie_slices;
                    dest->pie_rotation = src->pie_rotation;
                    dest->pie_thickness = src->pie_thickness;
                  }

                  else
                    if(varn == 38)
                    {
                      dest->ngon_sides = src->ngon_sides;
                      dest->ngon_power = src->ngon_power;
                      dest->ngon_corners = src->ngon_corners;
                      dest->ngon_circle = src->ngon_circle;
                    }

                    else
                      if(varn == 39)
                      {
                        dest->curl_c1 = src->curl_c1;
                        dest->curl_c2 = src->curl_c2;
                      }

                      else
                        if(varn == 40)
                        {
                          dest->rectangles_x = src->rectangles_x;
                          dest->rectangles_y = src->rectangles_y;
                        }

                        else
                          if(varn == 49)
                          {
                            dest->disc2_rot = src->disc2_rot;
                            dest->disc2_twist = src->disc2_twist;
                          }

                          else
                            if(varn == 50)
                            {
                              dest->super_shape_rnd = src->super_shape_rnd;
                              dest->super_shape_m = src->super_shape_m;
                              dest->super_shape_n1 = src->super_shape_n1;
                              dest->super_shape_n2 = src->super_shape_n2;
                              dest->super_shape_n3 = src->super_shape_n3;
                              dest->super_shape_holes = src->super_shape_holes;
                            }

                            else
                              if(varn == 51)
                              {
                                dest->flower_petals = src->flower_petals;
                                dest->flower_petals = src->flower_petals;
                              }

                              else
                                if(varn == 52)
                                {
                                  dest->conic_eccentricity = src->conic_eccentricity;
                                  dest->conic_holes = src->conic_holes;
                                }

                                else
                                  if(varn == 53)
                                  {
                                    dest->parabola_height = src->parabola_height;
                                    dest->parabola_width = src->parabola_width;
                                  }

                                  else
                                    if(varn == 54)
                                    {
                                      dest->bent2_x = src->bent2_x;
                                      dest->bent2_y = src->bent2_y;
                                    }

                                    else
                                      if(varn == 55)
                                        dest->bipolar_shift = src->bipolar_shift;

                                      else
                                        if(varn == 58)
                                          dest->cell_size = src->cell_size;

                                        else
                                          if(varn == 59)
                                          {
                                            dest->cpow_i = src->cpow_i;
                                            dest->cpow_r = src->cpow_r;
                                            dest->cpow_power = src->cpow_power;
                                          }

                                          else
                                            if(varn == 60)
                                            {
                                              dest->curve_xamp = src->curve_xamp;
                                              dest->curve_yamp = src->curve_yamp;
                                              dest->curve_xlength = src->curve_xlength;
                                              dest->curve_ylength = src->curve_ylength;
                                            }

                                            else
                                              if(varn == 63)
                                                dest->escher_beta = src->escher_beta;

                                              else
                                                if(varn == 65)
                                                {
                                                  dest->lazysusan_x = src->lazysusan_x;
                                                  dest->lazysusan_y = src->lazysusan_y;
                                                  dest->lazysusan_spin = src->lazysusan_spin;
                                                  dest->lazysusan_space = src->lazysusan_space;
                                                  dest->lazysusan_twist = src->lazysusan_twist;
                                                }

                                                else
                                                  if(varn == 68)
                                                  {
                                                    dest->modulus_x = src->modulus_x;
                                                    dest->modulus_y = src->modulus_y;
                                                  }

                                                  else
                                                    if(varn == 69)
                                                    {
                                                      dest->oscope_separation = src->oscope_separation;
                                                      dest->oscope_frequency = src->oscope_frequency;
                                                      dest->oscope_amplitude = src->oscope_amplitude;
                                                      dest->oscope_damping = src->oscope_damping;
                                                    }

                                                    else
                                                      if(varn == 71)
                                                      {
                                                        dest->popcorn2_x = src->popcorn2_x;
                                                        dest->popcorn2_y = src->popcorn2_y;
                                                        dest->popcorn2_c = src->popcorn2_c;
                                                      }

                                                      else
                                                        if(varn == 73)
                                                        {
                                                          dest->separation_x = src->separation_x;
                                                          dest->separation_y = src->separation_y;
                                                          dest->separation_xinside = src->separation_xinside;
                                                          dest->separation_yinside = src->separation_yinside;
                                                        }

                                                        else
                                                          if(varn == 74)
                                                          {
                                                            dest->split_xsize = src->split_xsize;
                                                            dest->split_ysize = src->split_ysize;
                                                          }

                                                          else
                                                            if(varn == 75)
                                                            {
                                                              dest->splits_x = src->splits_x;
                                                              dest->splits_y = src->splits_y;
                                                            }

                                                            else
                                                              if(varn == 76)
                                                              {
                                                                dest->stripes_space = src->stripes_space;
                                                                dest->stripes_warp = src->stripes_warp;
                                                              }

                                                              else
                                                                if(varn == 77)
                                                                {
                                                                  dest->wedge_angle = src->wedge_angle;
                                                                  dest->wedge_hole = src->wedge_hole;
                                                                  dest->wedge_count = src->wedge_count;
                                                                  dest->wedge_swirl = src->wedge_swirl;
                                                                }

                                                                else
                                                                  if(varn == 78)
                                                                  {
                                                                    dest->wedge_julia_angle = src->wedge_julia_angle;
                                                                    dest->wedge_julia_count = src->wedge_julia_count;
                                                                    dest->wedge_julia_power = src->wedge_julia_power;
                                                                    dest->wedge_julia_dist = src->wedge_julia_dist;
                                                                    dest->wedgeJulia_cf = src->wedgeJulia_cf;
                                                                    dest->wedgeJulia_cn = src->wedgeJulia_cn;
                                                                    dest->wedgeJulia_rN = src->wedgeJulia_rN;
                                                                  }

                                                                  else
                                                                    if(varn == 79)
                                                                    {
                                                                      dest->wedge_sph_angle = src->wedge_sph_angle;
                                                                      dest->wedge_sph_hole = src->wedge_sph_hole;
                                                                      dest->wedge_sph_count = src->wedge_sph_count;
                                                                      dest->wedge_sph_swirl = src->wedge_sph_swirl;
                                                                    }

                                                                    else
                                                                      if(varn == 80)
                                                                      {
                                                                        dest->whorl_inside = src->whorl_inside;
                                                                        dest->whorl_outside = src->whorl_outside;
                                                                      }

                                                                      else
                                                                        if(varn == 81)
                                                                        {
                                                                          dest->waves2_scalex = src->waves2_scalex;
                                                                          dest->waves2_scaley = src->waves2_scaley;
                                                                          dest->waves2_freqx = src->waves2_freqx;
                                                                          dest->waves2_freqy = src->waves2_freqy;
                                                                        }

                                                                        else
                                                                          if(varn == 96)
                                                                          {
                                                                            dest->auger_sym = src->auger_sym;
                                                                            dest->auger_weight = src->auger_weight;
                                                                            dest->auger_freq = src->auger_freq;
                                                                            dest->auger_scale = src->auger_scale;
                                                                          }

                                                                          else
                                                                            if(varn == 97)
                                                                              dest->flux_spread = src->flux_spread;

}

// flam3_copy_xform
// file flam3.c line 1121
void flam3_copy_xform(struct xform *dest, struct xform *src)
{
  signed int j;
  if(dest->num_motion >= 1)
    flam3_delete_motion_elements(dest);

  *dest = *src;
  dest->num_motion = 0;
  dest->motion = (struct xform *)(void *)0;
  if(src->num_motion >= 1)
  {
    j = 0;
    for( ; !(j >= src->num_motion); j = j + 1)
      flam3_add_motion_element(dest);
    memcpy((void *)dest->motion, (const void *)src->motion, (unsigned long int)src->num_motion * sizeof(struct xform) /*3152ul*/ );
  }

}

// flam3_copyx
// file flam3.c line 1185
void flam3_copyx(struct anonymous_0 *dest, struct anonymous_0 *src, signed int dest_std_xforms, signed int dest_final_xform)
{
  signed int i;
  signed int numsrcstd;
  clear_cp(dest, 1);
  memcpy((void *)dest, (const void *)src, sizeof(struct anonymous_0) /*10712ul*/ );
  dest->num_xforms = 0;
  dest->xform = (struct xform *)(void *)0;
  dest->chaos = (double **)(void *)0;
  dest->final_xform_index = -1;
  flam3_add_xforms(dest, dest_std_xforms, 1, 0);
  numsrcstd = src->num_xforms - (signed int)(src->final_xform_index >= 0);
  i = 0;
  for( ; !(i >= numsrcstd); i = i + 1)
  {
    flam3_copy_xform(&dest->xform[(signed long int)i], &src->xform[(signed long int)i]);
    memcpy((void *)dest->chaos[(signed long int)i], (const void *)src->chaos[(signed long int)i], (unsigned long int)numsrcstd * sizeof(double) /*8ul*/ );
  }
  if(dest_final_xform >= 1)
  {
    flam3_add_xforms(dest, dest_final_xform, 1, 1);
    if(src->final_xform_enable >= 1)
    {
      i = src->final_xform_index;
      flam3_copy_xform(&dest->xform[(signed long int)(dest->num_xforms - 1)], &src->xform[(signed long int)i]);
    }

    else
    {
      (dest->xform + (signed long int)(dest->num_xforms - 1))->num_motion = 0;
      (dest->xform + (signed long int)(dest->num_xforms - 1))->motion = (struct xform *)(void *)0;
      (dest->xform + (signed long int)(dest->num_xforms - 1))->animate = 0.0;
      (dest->xform + (signed long int)(dest->num_xforms - 1))->color_speed = 0.0;
    }
  }

  else
  {
    dest->final_xform_index = -1;
    dest->final_xform_enable = 0;
  }
}

// flam3_count_nthreads
// file flam3.c line 1345
signed int flam3_count_nthreads(void)
{
  signed int nthreads;
  signed long int return_value_sysconf_1;
  return_value_sysconf_1=sysconf(84);
  nthreads = (signed int)return_value_sysconf_1;
  if(!(nthreads >= 1))
    nthreads = 1;

  return nthreads;
}

// flam3_create_chaos_distrib
// file flam3.c line 161
signed int flam3_create_chaos_distrib(struct anonymous_0 *cp, signed int xi, unsigned short int *xform_distrib)
{
  double t;
  double r;
  double dr;
  signed int i;
  signed int j;
  signed int num_std = cp->num_xforms - (signed int)(cp->final_xform_index >= 0);
  dr = 0.0;
  i = 0;
  for( ; !(i >= num_std); i = i + 1)
  {
    double d = (cp->xform + (signed long int)i)->density;
    if(xi >= 0)
      d = d * cp->chaos[(signed long int)xi][(signed long int)i];

    if(d < 0.0)
    {
      fprintf(stderr, "xform weight must be non-negative, not %g.\n", d);
      return 1;
    }

    dr = dr + d;
  }
  if(IEEE_FLOAT_EQUAL(dr, 0.0))
  {
    fprintf(stderr, "cannot iterate empty flame.\n");
    return 1;
  }

  else
  {
    dr = dr / (double)10000;
    j = 0;
    t = (cp->xform + (signed long int)0)->density;
    if(xi >= 0)
      t = t * cp->chaos[(signed long int)xi][(signed long int)0];

    r = 0.0;
    i = 0;
    for( ; !(i >= 10000); i = i + 1)
    {
      while(r >= t)
      {
        j = j + 1;
        if(xi >= 0)
          t = t + (cp->xform + (signed long int)j)->density * cp->chaos[(signed long int)xi][(signed long int)j];

        else
          t = t + (cp->xform + (signed long int)j)->density;
      }
      xform_distrib[(signed long int)i] = (unsigned short int)j;
      r = r + dr;
    }
    return 0;
  }
}

// flam3_create_de_filters
// file filters.h line 59
struct anonymous_6 flam3_create_de_filters(double max_rad, double min_rad, double curve, signed int ss)
{
  struct anonymous_6 de;
  double comp_max_radius;
  double comp_min_radius;
  double num_de_filters_d;
  signed int num_de_filters;
  signed int de_max_ind;
  signed int de_row_size;
  signed int de_half_size;
  signed int filtloop;
  signed int keep_thresh = 100;
  de.kernel_size = -1;
  double return_value_pow_8;
  if(curve <= 0.0)
  {
    fprintf(stderr, "estimator curve must be > 0\n");
    return de;
  }

  else
    if(max_rad < min_rad)
    {
      fprintf(stderr, "estimator must be larger than estimator_minimum.\n");
      fprintf(stderr, "(%f > %f) ? \n", max_rad, min_rad);
      return de;
    }

    else
    {
      comp_max_radius = max_rad * (double)ss + (double)1;
      comp_min_radius = min_rad * (double)ss + (double)1;
      num_de_filters_d=pow(comp_max_radius / comp_min_radius, 1.0 / curve);
      if(num_de_filters_d > 1e7)
      {
        fprintf(stderr, "too many filters required in this configuration (%g)\n", num_de_filters_d);
        return de;
      }

      else
      {
        double return_value_ceil_1;
        return_value_ceil_1=ceil(num_de_filters_d);
        num_de_filters = (signed int)return_value_ceil_1;
        if(!(keep_thresh >= num_de_filters))
        {
          double return_value_pow_2;
          return_value_pow_2=pow((double)(num_de_filters - 100), curve);
          double return_value_ceil_3;
          return_value_ceil_3=ceil((double)100 + return_value_pow_2);
          de_max_ind = (signed int)return_value_ceil_3 + 1;
          double return_value_pow_4;
          return_value_pow_4=pow((double)(de_max_ind - 100), 1.0 / curve);
          de.max_filtered_counts = (signed int)return_value_pow_4 + 100;
        }

        else
        {
          de_max_ind = num_de_filters;
          de.max_filtered_counts = de_max_ind;
        }
        double return_value_ceil_5;
        return_value_ceil_5=ceil(comp_max_radius);
        de_row_size = (signed int)((double)2 * return_value_ceil_5 - (double)1);
        de_half_size = (de_row_size - 1) / 2;
        de.kernel_size = ((de_half_size + 1) * (2 + de_half_size)) / 2;
        void *return_value_calloc_6;
        return_value_calloc_6=calloc((unsigned long int)(de_max_ind * de.kernel_size), sizeof(double) /*8ul*/ );
        de.filter_coefs = (double *)return_value_calloc_6;
        void *return_value_calloc_7;
        return_value_calloc_7=calloc((unsigned long int)de_max_ind, sizeof(double) /*8ul*/ );
        de.filter_widths = (double *)return_value_calloc_7;
        de.max_filter_index = 0;
        filtloop = 0;
        for( ; !(filtloop >= de_max_ind); filtloop = filtloop + 1)
        {
          double de_filt_sum = 0.0;
          double de_filt_d;
          double de_filt_h;
          signed int dej;
          signed int dek;
          double adjloop;
          signed int filter_coef_idx;
          if(!(filtloop >= keep_thresh))
          {
            return_value_pow_8=pow((double)(filtloop + 1), curve);
            de_filt_h = comp_max_radius / return_value_pow_8;
          }

          else
          {
            double return_value_pow_9;
            return_value_pow_9=pow((double)(filtloop - keep_thresh), 1.0 / curve);
            adjloop = return_value_pow_9 + (double)keep_thresh;
            double return_value_pow_10;
            return_value_pow_10=pow(adjloop + (double)1, curve);
            de_filt_h = comp_max_radius / return_value_pow_10;
          }
          if(de_filt_h <= comp_min_radius)
          {
            de_filt_h = comp_min_radius;
            de.max_filter_index = filtloop;
          }

          de.filter_widths[(signed long int)filtloop] = de_filt_h;
          dej = -de_half_size;
          for( ; de_half_size >= dej; dej = dej + 1)
          {
            dek = -de_half_size;
            for( ; de_half_size >= dek; dek = dek + 1)
            {
              double return_value_sqrt_11;
              return_value_sqrt_11=sqrt((double)(dej * dej + dek * dek));
              de_filt_d = return_value_sqrt_11 / de_filt_h;
              if(de_filt_d <= 1.0)
              {
                double return_value_flam3_spatial_filter_12;
                return_value_flam3_spatial_filter_12=flam3_spatial_filter(0, flam3_spatial_support[(signed long int)0] * de_filt_d);
                de_filt_sum = de_filt_sum + return_value_flam3_spatial_filter_12;
              }

            }
          }
          filter_coef_idx = filtloop * de.kernel_size;
          dej = 0;
          for( ; de_half_size >= dej; dej = dej + 1)
          {
            dek = 0;
            for( ; dej >= dek; dek = dek + 1)
            {
              double return_value_sqrt_13;
              return_value_sqrt_13=sqrt((double)(dej * dej + dek * dek));
              de_filt_d = return_value_sqrt_13 / de_filt_h;
              if(de_filt_d > 1.0)
                de.filter_coefs[(signed long int)filter_coef_idx] = 0.0;

              else
              {
                double return_value_flam3_spatial_filter_14;
                return_value_flam3_spatial_filter_14=flam3_spatial_filter(0, flam3_spatial_support[(signed long int)0] * de_filt_d);
                de.filter_coefs[(signed long int)filter_coef_idx] = return_value_flam3_spatial_filter_14 / de_filt_sum;
              }
              filter_coef_idx = filter_coef_idx + 1;
            }
          }
          if(de.max_filter_index >= 1)
            break;

        }
        if(de.max_filter_index == 0)
          de.max_filter_index = de_max_ind - 1;

        return de;
      }
    }
}

// flam3_create_spatial_filter
// file filters.h line 58
signed int flam3_create_spatial_filter(struct anonymous_4 *spec, signed int field, double **filter)
{
  signed int sf_kernel = (spec->genomes + (signed long int)0)->spatial_filter_select;
  signed int supersample = (spec->genomes + (signed long int)0)->spatial_oversample;
  double sf_radius = (spec->genomes + (signed long int)0)->spatial_filter_radius;
  double aspect_ratio = spec->pixel_aspect_ratio;
  double sf_supp = flam3_spatial_support[(signed long int)sf_kernel];
  double fw = (2.0 * sf_supp * (double)supersample * sf_radius) / aspect_ratio;
  double adjust;
  double ii;
  double jj;
  signed int fwidth = (signed int)fw + 1;
  signed int i;
  signed int j;
  if(!(((fwidth ^ supersample) & 1) == 0))
    fwidth = fwidth + 1;

  if(fw > 0.0)
    adjust = (sf_supp * (double)fwidth) / fw;

  else
    adjust = 1.0;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)(fwidth * fwidth), sizeof(double) /*8ul*/ );
  *filter = (double *)return_value_calloc_1;
  i = 0;
  for( ; !(i >= fwidth); i = i + 1)
  {
    j = 0;
    for( ; !(j >= fwidth); j = j + 1)
    {
      ii = ((2.0 * (double)i + 1.0) / (double)fwidth - 1.0) * adjust;
      jj = ((2.0 * (double)j + 1.0) / (double)fwidth - 1.0) * adjust;
      if(!(field == 0))
        jj = jj * 2.0;

      jj = jj / aspect_ratio;
      double return_value_flam3_spatial_filter_2;
      return_value_flam3_spatial_filter_2=flam3_spatial_filter(sf_kernel, ii);
      double return_value_flam3_spatial_filter_3;
      return_value_flam3_spatial_filter_3=flam3_spatial_filter(sf_kernel, jj);
      (*filter)[(signed long int)(i + j * fwidth)] = return_value_flam3_spatial_filter_2 * return_value_flam3_spatial_filter_3;
    }
  }
  signed int return_value_normalize_vector_4;
  return_value_normalize_vector_4=normalize_vector(*filter, fwidth * fwidth);
  if(!(return_value_normalize_vector_4 == 0))
  {
    fprintf(stderr, "Spatial filter value is too small: %g.  Terminating.\n", sf_radius);
    return -1;
  }

  else
    return fwidth;
}

// flam3_create_temporal_filter
// file filters.h line 60
double flam3_create_temporal_filter(signed int numsteps, signed int filter_type, double filter_exp, double filter_width, double **temporal_filter, double **temporal_deltas)
{
  double maxfilt = 0.0;
  double sumfilt = 0.0;
  double slpx;
  double halfsteps;
  double *deltas;
  double *filter;
  signed int i;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)numsteps * sizeof(double) /*8ul*/ );
  deltas = (double *)return_value_malloc_1;
  void *return_value_malloc_2;
  return_value_malloc_2=malloc((unsigned long int)numsteps * sizeof(double) /*8ul*/ );
  filter = (double *)return_value_malloc_2;
  if(numsteps == 1)
  {
    deltas[(signed long int)0] = (double)0;
    filter[(signed long int)0] = 1.0;
    *temporal_deltas = deltas;
    *temporal_filter = filter;
    return 1.0;
  }

  else
  {
    i = 0;
    for( ; !(i >= numsteps); i = i + 1)
      deltas[(signed long int)i] = ((double)i / (double)(numsteps - 1) - 0.5) * filter_width;
    if(filter_type == 2)
    {
      i = 0;
      for( ; !(i >= numsteps); i = i + 1)
      {
        if(filter_exp >= 0.000000)
          slpx = ((double)i + 1.0) / (double)numsteps;

        else
          slpx = (double)(numsteps - i) / (double)numsteps;
        double return_value_fabs_3;
        return_value_fabs_3=fabs(filter_exp);
        filter[(signed long int)i]=pow(slpx, return_value_fabs_3);
        if(filter[(signed long int)i] > maxfilt)
          maxfilt = filter[(signed long int)i];

      }
    }

    else
      if(filter_type == 1)
      {
        halfsteps = (double)numsteps / 2.0;
        i = 0;
        for( ; !(i >= numsteps); i = i + 1)
        {
          double return_value_fabs_4;
          return_value_fabs_4=fabs((double)i - halfsteps);
          filter[(signed long int)i]=flam3_spatial_filter(0, (flam3_spatial_support[(signed long int)0] * return_value_fabs_4) / halfsteps);
          if(filter[(signed long int)i] > maxfilt)
            maxfilt = filter[(signed long int)i];

        }
      }

      else
      {
        i = 0;
        for( ; !(i >= numsteps); i = i + 1)
          filter[(signed long int)i] = 1.0;
        maxfilt = 1.0;
      }
    i = 0;
    for( ; !(i >= numsteps); i = i + 1)
    {
      filter[(signed long int)i] = filter[(signed long int)i] / maxfilt;
      sumfilt = sumfilt + filter[(signed long int)i];
    }
    sumfilt = sumfilt / (double)numsteps;
    *temporal_deltas = deltas;
    *temporal_filter = filter;
    return sumfilt;
  }
}

// flam3_create_xform_distrib
// file flam3.c line 72
unsigned short int * flam3_create_xform_distrib(struct anonymous_0 *cp)
{
  signed int numrows;
  signed int dist_row;
  signed int i;
  unsigned short int *xform_distrib;
  numrows = (cp->num_xforms - (signed int)(cp->final_xform_index >= 0)) + 1;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)(numrows * 10000), sizeof(unsigned short int) /*2ul*/ );
  xform_distrib = (unsigned short int *)return_value_calloc_1;
  flam3_create_chaos_distrib(cp, -1, xform_distrib);
  signed int return_value_flam3_check_unity_chaos_2;
  return_value_flam3_check_unity_chaos_2=flam3_check_unity_chaos(cp);
  cp->chaos_enable = 1 - return_value_flam3_check_unity_chaos_2;
  if(!(cp->chaos_enable == 0))
  {
    dist_row = 0;
    i = 0;
    for( ; !(i >= cp->num_xforms); i = i + 1)
    {
      if(cp->final_xform_index == i)
        goto __CPROVER_DUMP_L5;

      else
        dist_row = dist_row + 1;
      signed int return_value_flam3_create_chaos_distrib_3;
      return_value_flam3_create_chaos_distrib_3=flam3_create_chaos_distrib(cp, i, &xform_distrib[(signed long int)(10000 * dist_row)]);
      if(!(return_value_flam3_create_chaos_distrib_3 == 0))
      {
        free((void *)xform_distrib);
        return (unsigned short int *)(void *)0;
      }


    __CPROVER_DUMP_L5:
      ;
    }
  }

  return xform_distrib;
}

// flam3_cross
// file flam3.h line 568
void flam3_cross(struct anonymous_0 *cp0, struct anonymous_0 *cp1, struct anonymous_0 *out, signed int cross_mode, struct randctx *rc, char *action)
{
  signed int i0;
  signed int i1;
  signed int i;
  signed int j;
  signed int rb;
  char ministr[10l];
  if(cross_mode == -1)
  {
    double s;
    s=flam3_random_isaac_01(rc);
    if(s < 0.1)
      cross_mode = 0;

    else
      if(s < 0.2)
        cross_mode = 1;

      else
        cross_mode = 2;
  }

  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(cross_mode == 0)
  {
    struct xform mycopy;
    flam3_copy(out, cp0);
    j = 0;
    for( ; !(j >= cp1->num_xforms); j = j + 1)
      if(!(cp1->final_xform_index == j))
      {
        flam3_add_xforms(out, 1, 0, 0);
        flam3_copy_xform(&out->xform[(signed long int)(out->num_xforms - 1)], &cp1->xform[(signed long int)j]);
      }

    if(out->final_xform_index >= 0)
    {
      mycopy = out->xform[(signed long int)out->final_xform_index];
      out->xform[(signed long int)out->final_xform_index] = out->xform[(signed long int)(out->num_xforms - 1)];
      out->xform[(signed long int)(out->num_xforms - 1)] = mycopy;
      out->final_xform_index = out->num_xforms - 1;
    }

    add_to_action(action, "cross union");
  }

  else
    if(cross_mode == 1)
    {
      struct anonymous_0 parents[2l];
      double t;
      t=flam3_random_isaac_01(rc);
      memset((void *)parents, 0, (unsigned long int)2 * sizeof(struct anonymous_0) /*10712ul*/ );
      flam3_copy(&parents[(signed long int)0], cp0);
      flam3_copy(&parents[(signed long int)1], cp1);
      parents[(signed long int)0].time = 0.0;
      parents[(signed long int)1].time = 1.0;
      flam3_interpolate(parents, 2, t, (double)0, out);
      i = 0;
      for( ; !(i >= out->num_xforms); i = i + 1)
        flam3_delete_motion_elements(&out->xform[(signed long int)i]);
      clear_cp(&parents[(signed long int)0], 1);
      clear_cp(&parents[(signed long int)1], 1);
      sprintf(ministr, "%7.5g", t);
      add_to_action(action, "cross interpolate ");
      add_to_action(action, ministr);
    }

    else
    {
      signed int got0;
      signed int got1;
      signed int used_parent;
      char *trystr;
      void *return_value_calloc_1;
      return_value_calloc_1=calloc((unsigned long int)(4 * (cp0->num_xforms + cp1->num_xforms)), sizeof(char) /*1ul*/ );
      trystr = (char *)return_value_calloc_1;
      do
      {
        trystr[(signed long int)0] = (char)0;
        got1 = 0;
        got0 = got1;
        rb=flam3_random_isaac_bit(rc);
        sprintf(ministr, "%d:", rb);
        strcat(trystr, ministr);
        if(!(rb == 0))
          flam3_copyx(out, cp1, cp1->num_xforms - (signed int)(cp1->final_xform_index > 0), cp1->final_xform_enable);

        else
          flam3_copyx(out, cp0, cp0->num_xforms - (signed int)(cp0->final_xform_index > 0), cp0->final_xform_enable);
        used_parent = rb;
        i = 0;
        for( ; !(i >= out->num_xforms + -out->final_xform_enable); i = i + 1)
        {
          rb=flam3_random_isaac_bit(rc);
          if(rb == 1)
          {
            if(used_parent == 0)
            {
              if(!(i >= cp1->num_xforms))
                tmp_if_expr_2 = (cp1->xform + (signed long int)i)->density > (double)0 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_2 = (_Bool)0;
              if(tmp_if_expr_2)
              {
                flam3_copy_xform(&out->xform[(signed long int)i], &cp1->xform[(signed long int)i]);
                sprintf(ministr, " 1");
                got1 = 1;
              }

              else
              {
                sprintf(ministr, " 0");
                got0 = 1;
              }
            }

            else
            {
              if(!(i >= cp0->num_xforms))
                tmp_if_expr_3 = (cp0->xform + (signed long int)i)->density > (double)0 ? (_Bool)1 : (_Bool)0;

              else
                tmp_if_expr_3 = (_Bool)0;
              if(tmp_if_expr_3)
              {
                flam3_copy_xform(&out->xform[(signed long int)i], &cp0->xform[(signed long int)i]);
                sprintf(ministr, " 0");
                got0 = 1;
              }

              else
              {
                sprintf(ministr, " 1");
                got1 = 1;
              }
            }
          }

          else
          {
            sprintf(ministr, " %d", used_parent);
            if(!(used_parent == 0))
              got1 = 1;

            else
              got0 = 1;
          }
          strcat(trystr, ministr);
        }
        if(used_parent == 0)
          tmp_if_expr_4 = cp0->final_xform_enable != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        if(tmp_if_expr_4)
          got0 = 1;

        else
          if(used_parent == 1)
          {
            if(!(cp1->final_xform_enable == 0))
              got1 = 1;

          }

      }
      while(i >= 2 && (got0 == 0 || got1 == 0));
      add_to_action(action, "cross alternate ");
      add_to_action(action, trystr);
      free((void *)trystr);
    }
  i = 0;
  for( ; !(i >= out->num_xforms); i = i + 1)
    (out->xform + (signed long int)i)->color = (double)(i & 1);
  double return_value_flam3_random_isaac_01_7;
  return_value_flam3_random_isaac_01_7=flam3_random_isaac_01(rc);
  struct anonymous_1 tmp_if_expr_6;
  if(return_value_flam3_random_isaac_01_7 < 0.4)
  {
    signed int startParent;
    startParent=flam3_random_isaac_bit(rc);
    signed int ci;
    add_to_action(action, " cmap_cross");
    sprintf(ministr, " %d:", startParent);
    add_to_action(action, ministr);
    ci = 0;
    for( ; !(ci >= 256); ci = ci + 1)
    {
      double return_value_flam3_random_isaac_01_5;
      return_value_flam3_random_isaac_01_5=flam3_random_isaac_01(rc);
      if(return_value_flam3_random_isaac_01_5 < .01)
      {
        startParent = 1 - startParent;
        sprintf(ministr, " %d", ci);
        add_to_action(action, ministr);
      }

      if(!(startParent == 0))
        tmp_if_expr_6 = cp1->palette[(signed long int)ci];

      else
        tmp_if_expr_6 = cp0->palette[(signed long int)ci];
      out->palette[(signed long int)ci] = tmp_if_expr_6;
    }
  }

}

// flam3_delete_motion_elements
// file flam3.h line 532
void flam3_delete_motion_elements(struct xform *xf)
{
  if(xf->num_motion >= 1)
  {
    free((void *)xf->motion);
    xf->num_motion = 0;
  }

}

// flam3_delete_xform
// file flam3.h line 527
void flam3_delete_xform(struct anonymous_0 *thiscp, signed int idx_to_delete)
{
  signed int i;
  signed int j;
  signed int num_std = thiscp->num_xforms - (signed int)(thiscp->final_xform_index >= 0);
  if(!(thiscp->final_xform_index == idx_to_delete))
  {
    free((void *)thiscp->chaos[(signed long int)idx_to_delete]);
    i = idx_to_delete + 1;
    for( ; !(i >= num_std); i = i + 1)
      thiscp->chaos[(signed long int)(i - 1)] = thiscp->chaos[(signed long int)i];
    void *return_value_realloc_1;
    return_value_realloc_1=realloc((void *)thiscp->chaos, (unsigned long int)(num_std - 1) * sizeof(double *) /*8ul*/ );
    thiscp->chaos = (double **)return_value_realloc_1;
    num_std = num_std - 1;
    i = 0;
    for( ; !(i >= num_std); i = i + 1)
    {
      j = idx_to_delete + 1;
      for( ; !(j >= 1 + num_std); j = j + 1)
        thiscp->chaos[(signed long int)i][(signed long int)(j - 1)] = thiscp->chaos[(signed long int)i][(signed long int)j];
      void *return_value_realloc_2;
      return_value_realloc_2=realloc((void *)thiscp->chaos[(signed long int)i], (unsigned long int)num_std * sizeof(double) /*8ul*/ );
      thiscp->chaos[(signed long int)i] = (double *)return_value_realloc_2;
    }
  }

  if(thiscp->final_xform_index == idx_to_delete)
  {
    thiscp->final_xform_index = -1;
    thiscp->final_xform_enable = 0;
  }

  else
    if(!(idx_to_delete >= thiscp->final_xform_index))
      thiscp->final_xform_index = thiscp->final_xform_index - 1;

  flam3_delete_motion_elements(&thiscp->xform[(signed long int)idx_to_delete]);
  i = idx_to_delete;
  for( ; !(i >= thiscp->num_xforms + -1); i = i + 1)
    thiscp->xform[(signed long int)i] = thiscp->xform[(signed long int)(i + 1)];
  thiscp->num_xforms = thiscp->num_xforms - 1;
  void *return_value_realloc_3;
  return_value_realloc_3=realloc((void *)thiscp->xform, sizeof(struct xform) /*3152ul*/  * (unsigned long int)thiscp->num_xforms);
  thiscp->xform = (struct xform *)return_value_realloc_3;
}

// flam3_dimension
// file flam3.c line 3807
double flam3_dimension(struct anonymous_0 *cp, signed int ntries, signed int clip_to_camera)
{
  double fd;
  double *hist;
  double bmin[2l];
  double bmax[2l];
  double d2max;
  signed int lp;
  signed long int default_isaac_seed;
  signed long int return_value_time_1;
  return_value_time_1=time(((signed long int *)NULL));
  default_isaac_seed = (signed long int)return_value_time_1;
  struct randctx rc;
  signed int SBS = 10000;
  signed int i;
  signed int n1 = 0;
  signed int n2 = 0;
  signed int got;
  signed int nclipped;
  lp = 0;
  for( ; !(lp >= 16); lp = lp + 1)
    rc.randrsl[(signed long int)lp] = (unsigned long int)default_isaac_seed;
  irandinit(&rc, 1);
  if(!(ntries >= 2))
    ntries = 3000 * 1000;

  if(!(clip_to_camera == 0))
  {
    double scale;
    double ppux;
    double corner0;
    double corner1;
    scale=pow(2.0, cp->zoom);
    ppux = cp->pixels_per_unit * scale;
    corner0 = cp->center[(signed long int)0] - ((double)cp->width / ppux) / 2.0;
    corner1 = cp->center[(signed long int)1] - ((double)cp->height / ppux) / 2.0;
    bmin[(signed long int)0] = corner0;
    bmin[(signed long int)1] = corner1;
    bmax[(signed long int)0] = corner0 + (double)cp->width / ppux;
    bmax[(signed long int)1] = corner1 + (double)cp->height / ppux;
  }

  else
  {
    signed int return_value_flam3_estimate_bounding_box_2;
    return_value_flam3_estimate_bounding_box_2=flam3_estimate_bounding_box(cp, 0.0, 0, bmin, bmax, &rc);
    if(!(return_value_flam3_estimate_bounding_box_2 >= 0))
      return -1.0;

  }
  d2max = (bmax[(signed long int)0] - bmin[(signed long int)0]) * (bmax[(signed long int)0] - bmin[(signed long int)0]) + (bmax[(signed long int)1] - bmin[(signed long int)1]) * (bmax[(signed long int)1] - bmin[(signed long int)1]);
  void *return_value_malloc_3;
  return_value_malloc_3=malloc((unsigned long int)(2 * ntries) * sizeof(double) /*8ul*/ );
  hist = (double *)return_value_malloc_3;
  got = 0;
  nclipped = 0;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  while(!(got >= 2 * ntries))
  {
    double subb[40000l];
    signed int i4;
    signed int clipped;
    unsigned short int *xform_distrib;
    subb[(signed long int)0]=flam3_random_isaac_11(&rc);
    subb[(signed long int)1]=flam3_random_isaac_11(&rc);
    subb[(signed long int)2] = 0.0;
    subb[(signed long int)3] = 0.0;
    signed int return_value_prepare_precalc_flags_4;
    return_value_prepare_precalc_flags_4=prepare_precalc_flags(cp);
    if(!(return_value_prepare_precalc_flags_4 == 0))
      return -1.0;

    xform_distrib=flam3_create_xform_distrib(cp);
    if(xform_distrib == ((unsigned short int *)NULL))
      return -1.0;

    flam3_iterate(cp, SBS, 20, subb, xform_distrib, &rc);
    free((void *)xform_distrib);
    i4 = 0;
    i = 0;
    for( ; !(i >= SBS); i = i + 1)
    {
      if(got == 2 * ntries)
        break;

      if(!(clip_to_camera == 0))
      {
        if(subb[(signed long int)i4] < bmin[0l])
          tmp_if_expr_5 = (_Bool)1;

        else
          tmp_if_expr_5 = subb[(signed long int)(i4 + 1)] < bmin[(signed long int)1] ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_5)
          tmp_if_expr_6 = (_Bool)1;

        else
          tmp_if_expr_6 = subb[(signed long int)i4] > bmax[(signed long int)0] ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_6)
          tmp_if_expr_7 = (_Bool)1;

        else
          tmp_if_expr_7 = subb[(signed long int)(i4 + 1)] > bmax[(signed long int)1] ? (_Bool)1 : (_Bool)0;
        tmp_if_expr_8 = tmp_if_expr_7 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_8 = (_Bool)0;
      clipped = (signed int)tmp_if_expr_8;
      if(clipped == 0)
      {
        hist[(signed long int)got] = subb[(signed long int)i4];
        hist[(signed long int)(got + 1)] = subb[(signed long int)(i4 + 1)];
        got = got + 2;
      }

      else
      {
        nclipped = nclipped + 1;
        if(!(10 * ntries >= nclipped))
        {
          fprintf(stderr, "warning: too much clipping, flam3_dimension giving up.\n");
          double return_value_sqrt_9;
          return_value_sqrt_9=sqrt(-1.0);
          return return_value_sqrt_9;
        }

      }
      i4 = i4 + 4;
    }
  }
  i = 0;
  for( ; !(i >= ntries); i = i + 1)
  {
    signed int ri;
    double dx;
    double dy;
    double d2;
    double tx;
    double ty;
    tx = hist[(signed long int)(2 * i)];
    ty = hist[(signed long int)(2 * i + 1)];
    do
    {
      signed long int return_value_random_10;
      return_value_random_10=random();
      ri = (signed int)((signed long int)2 * (return_value_random_10 % (signed long int)ntries));
    }
    while(ri == i);
    dx = hist[(signed long int)ri] - tx;
    dy = hist[(signed long int)(ri + 1)] - ty;
    d2 = dx * dx + dy * dy;
    if(d2 < 0.004 * d2max)
      n2 = n2 + 1;

    if(d2 < 0.00004 * d2max)
      n1 = n1 + 1;

  }
  double return_value_log_11;
  return_value_log_11=log((double)n2 / ((double)n1 - 0.5));
  fd = 0.434294 * return_value_log_11;
  free((void *)hist);
  return fd;
}

// flam3_edit_print
// file parser.h line 33
void flam3_edit_print(struct _IO_FILE *f, struct _xmlNode *editNode, signed int tabs, signed int formatting)
{
  char *tab_string = "   ";
  signed int ti;
  signed int strl;
  struct _xmlAttr *att_ptr = (struct _xmlAttr *)(void *)0;
  struct _xmlAttr *cur_att = (struct _xmlAttr *)(void *)0;
  struct _xmlNode *chld_ptr = (struct _xmlNode *)(void *)0;
  struct _xmlNode *cur_chld = (struct _xmlNode *)(void *)0;
  signed int edit_or_sheep = 0;
  signed int indent_printed = 0;
  char *ai;
  signed int tablim;
  ai=getenv("print_edit_depth");
  signed int tmp_if_expr_2;
  signed int return_value_atoi_1;
  if(!(ai == ((char *)NULL)))
  {
    return_value_atoi_1=atoi_link2(ai);
    tmp_if_expr_2 = return_value_atoi_1;
  }

  else
    tmp_if_expr_2 = 0;
  tablim = tmp_if_expr_2;
  char *att_str;
  char *cont_str;
  char *cpy_string;
  signed int return_value_xmlStrcmp_3;
  _Bool tmp_if_expr_10;
  signed int return_value_xmlStrcmp_7;
  _Bool tmp_if_expr_9;
  signed int return_value_xmlStrcmp_8;
  const unsigned short int **return_value___ctype_b_loc_12;
  const unsigned short int **return_value___ctype_b_loc_14;
  if(!(tablim >= 1) || tablim >= tabs)
  {
    if((signed int)editNode->type == XML_ELEMENT_NODE)
    {
      if(!(formatting == 0))
      {
        ti = 0;
        for( ; !(ti >= tabs); ti = ti + 1)
          fprintf(f, "%s", tab_string);
      }

      fprintf(f, "<%s", editNode->name);
      signed int return_value_xmlStrcmp_4;
      return_value_xmlStrcmp_4=xmlStrcmp(editNode->name, (const unsigned char *)"edit");
      if(return_value_xmlStrcmp_4 == 0)
      {
        edit_or_sheep = 1;
        tabs = tabs + 1;
      }

      else
      {
        return_value_xmlStrcmp_3=xmlStrcmp(editNode->name, (const unsigned char *)"sheep");
        if(return_value_xmlStrcmp_3 == 0)
          edit_or_sheep = 2;

        else
          edit_or_sheep = 0;
      }
      att_ptr = editNode->properties;
      cur_att = att_ptr;
      if(!(cur_att == ((struct _xmlAttr *)NULL)))
      {
        unsigned char *return_value_xmlGetProp_5;
        return_value_xmlGetProp_5=xmlGetProp(editNode, cur_att->name);
        att_str = (char *)return_value_xmlGetProp_5;
        fprintf(f, " %s=\"%s\"", cur_att->name, att_str);
        xmlFree((void *)att_str);
        cur_att = cur_att->next;
      }

      if(editNode->children == ((struct _xmlNode *)NULL) || !(tablim >= tabs) && tablim >= 1)
      {
        fprintf(f, "/>");
        if(!(formatting == 0))
          fprintf(f, "\n");

        tabs = tabs - 1;
        goto __CPROVER_DUMP_L31;
      }

      fprintf(f, ">");
      if(!(formatting == 0))
        fprintf(f, "\n");

      chld_ptr = editNode->children;
      indent_printed = 0;
      cur_chld = chld_ptr;
      for( ; !(cur_chld == ((struct _xmlNode *)NULL)); cur_chld = cur_chld->next)
      {
        if((signed int)cur_chld->type == XML_ELEMENT_NODE)
        {
          return_value_xmlStrcmp_7=xmlStrcmp(cur_chld->name, (const unsigned char *)"edit");
          if(return_value_xmlStrcmp_7 == 0)
            tmp_if_expr_9 = (_Bool)1;

          else
          {
            return_value_xmlStrcmp_8=xmlStrcmp(cur_chld->name, (const unsigned char *)"sheep");
            tmp_if_expr_9 = !(return_value_xmlStrcmp_8 != 0) ? (_Bool)1 : (_Bool)0;
          }
          tmp_if_expr_10 = tmp_if_expr_9 ? (_Bool)1 : (_Bool)0;
        }

        else
          tmp_if_expr_10 = (_Bool)0;
        if(tmp_if_expr_10)
        {
          if(!(indent_printed == 0))
          {
            indent_printed = 0;
            fprintf(f, "\n");
          }

          flam3_edit_print(f, cur_chld, tabs, 1);
        }

        else
        {
          signed int return_value_xmlIsBlankNode_6;
          return_value_xmlIsBlankNode_6=xmlIsBlankNode(cur_chld);
          if(!(return_value_xmlIsBlankNode_6 == 0))
            goto __CPROVER_DUMP_L26;

          if(indent_printed == 0 && formatting == 1)
          {
            ti = 0;
            for( ; !(ti >= tabs); ti = ti + 1)
              fprintf(f, "%s", tab_string);
            indent_printed = 1;
          }

          flam3_edit_print(f, cur_chld, tabs, 0);
        }

      __CPROVER_DUMP_L26:
        ;
      }
      if(!(indent_printed == 0) && !(formatting == 0))
        fprintf(f, "\n");

      tabs = tabs - 1;
      if(!(formatting == 0))
      {
        ti = 0;
        for( ; !(ti >= tabs); ti = ti + 1)
          fprintf(f, "%s", tab_string);
      }

      fprintf(f, "</%s>", editNode->name);
      if(!(formatting == 0))
        fprintf(f, "\n");

    }

    else
      if((signed int)editNode->type == XML_TEXT_NODE)
      {
        unsigned char *return_value_xmlNodeGetContent_11;
        return_value_xmlNodeGetContent_11=xmlNodeGetContent(editNode);
        cont_str = (char *)return_value_xmlNodeGetContent_11;
        cpy_string = &cont_str[(signed long int)0];
        do
        {
          return_value___ctype_b_loc_12=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc_12)[(signed long int)(signed int)*cpy_string]) == 0)
            break;

          cpy_string = cpy_string + 1l;
        }
        while((_Bool)1);
        unsigned long int return_value_strlen_13;
        return_value_strlen_13=strlen(cont_str);
        strl = (signed int)return_value_strlen_13 - 1;
        do
        {
          return_value___ctype_b_loc_14=__ctype_b_loc();
          if((8192 & (signed int)(*return_value___ctype_b_loc_14)[(signed long int)(signed int)cont_str[(signed long int)strl]]) == 0)
            break;

          strl = strl - 1;
        }
        while((_Bool)1);
        cont_str[(signed long int)(strl + 1)] = (char)0;
        fprintf(f, "%s", cpy_string);
      }

  }


__CPROVER_DUMP_L31:
  ;
}

// flam3_estimate_bounding_box
// file flam3.h line 578
signed int flam3_estimate_bounding_box(struct anonymous_0 *cp, double eps, signed int nsamples, double *bmin, double *bmax, struct randctx *rc)
{
  signed int i;
  signed int low_target;
  signed int high_target;
  double min[2l];
  double max[2l];
  double *points;
  signed int bv;
  unsigned short int *xform_distrib;
  if(!(nsamples >= 1))
    nsamples = 10000;

  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(double) /*8ul*/  * (unsigned long int)4 * (unsigned long int)nsamples);
  points = (double *)return_value_malloc_1;
  points[(signed long int)0]=flam3_random_isaac_11(rc);
  points[(signed long int)1]=flam3_random_isaac_11(rc);
  points[(signed long int)2] = 0.0;
  points[(signed long int)3] = 0.0;
  signed int return_value_prepare_precalc_flags_2;
  return_value_prepare_precalc_flags_2=prepare_precalc_flags(cp);
  if(!(return_value_prepare_precalc_flags_2 == 0))
    return -1;

  else
  {
    xform_distrib=flam3_create_xform_distrib(cp);
    if(xform_distrib == ((unsigned short int *)NULL))
      return -1;

    else
    {
      bv=flam3_iterate(cp, nsamples, 20, points, xform_distrib, rc);
      free((void *)xform_distrib);
      if((double)bv / (double)nsamples > eps)
        eps = (double)(3 * bv) / (double)nsamples;

      if(eps > 0.3)
        eps = 0.3;

      low_target = (signed int)((double)nsamples * eps);
      high_target = nsamples - low_target;
      min[(signed long int)1] = 1e10;
      min[(signed long int)0] = min[(signed long int)1];
      max[(signed long int)1] = -1e10;
      max[(signed long int)0] = max[(signed long int)1];
      i = 0;
      for( ; !(i >= nsamples); i = i + 1)
      {
        double *p = &points[(signed long int)(4 * i)];
        if(*p < min[0l])
          min[(signed long int)0] = p[(signed long int)0];

        if(p[1l] < min[1l])
          min[(signed long int)1] = p[(signed long int)1];

        if(*p > max[0l])
          max[(signed long int)0] = p[(signed long int)0];

        if(p[1l] > max[1l])
          max[(signed long int)1] = p[(signed long int)1];

      }
      if(low_target == 0)
      {
        bmin[(signed long int)0] = min[(signed long int)0];
        bmin[(signed long int)1] = min[(signed long int)1];
        bmax[(signed long int)0] = max[(signed long int)0];
        bmax[(signed long int)1] = max[(signed long int)1];
        free((void *)points);
        return bv;
      }

      else
      {
        qsort((void *)points, (unsigned long int)nsamples, sizeof(double) /*8ul*/  * (unsigned long int)4, sort_by_x);
        bmin[(signed long int)0] = points[(signed long int)(4 * low_target)];
        bmax[(signed long int)0] = points[(signed long int)(4 * high_target)];
        qsort((void *)points, (unsigned long int)nsamples, sizeof(double) /*8ul*/  * (unsigned long int)4, sort_by_y);
        bmin[(signed long int)1] = points[(signed long int)(4 * low_target + 1)];
        bmax[(signed long int)1] = points[(signed long int)(4 * high_target + 1)];
        free((void *)points);
        return bv;
      }
    }
  }
}

// flam3_free
// file flam3.c line 3420
void flam3_free(void *ptr)
{
  free(ptr);
}

// flam3_gaussian_filter
// file filters.c line 156
double flam3_gaussian_filter(double x)
{
  double return_value_exp_1;
  return_value_exp_1=exp(-2.0 * x * x);
  double return_value_sqrt_2;
  return_value_sqrt_2=sqrt(2.0 / 3.14159265358979323846);
  return return_value_exp_1 * return_value_sqrt_2;
}

// flam3_get_palette
// file flam3.h line 55
signed int flam3_get_palette(signed int n, struct anonymous_1 *c, double hue_rotation)
{
  signed int cmap_len = 256;
  signed int idx;
  signed int i;
  signed int j;
  signed int rcode;
  i = 0;
  for( ; !(i >= cmap_len); i = i + 1)
  {
    (c + (signed long int)i)->index = (double)i;
    j = 0;
    for( ; !(j >= 4); j = j + 1)
      (c + (signed long int)i)->color[(signed long int)j] = 1.0;
  }
  if(the_palettes == ((struct anonymous_18 *)NULL))
  {
    char *d;
    d=getenv("flam3_palettes");
    rcode=init_palettes(d != ((char *)NULL) ? d : "/usr/share/flam3/flam3-palettes.xml");
    if(!(rcode >= 0))
    {
      fprintf(stderr, "error reading xml palette file, setting to all white\n");
      return -1;
    }

  }

  signed long int return_value_random_1;
  if(n == -1)
  {
    return_value_random_1=random();
    n = (the_palettes + return_value_random_1 % (signed long int)npalettes)->number;
  }

  idx = 0;
  for( ; !(idx >= npalettes); idx = idx + 1)
    if(n == (the_palettes + (signed long int)idx)->number)
    {
      i = 0;
      for( ; !(i >= cmap_len); i = i + 1)
      {
        signed int ii = (i * 256) / cmap_len;
        double rgb[3l];
        double hsv[3l];
        j = 0;
        for( ; !(j >= 3); j = j + 1)
          rgb[(signed long int)j] = (double)(the_palettes + (signed long int)idx)->colors[(signed long int)ii][(signed long int)j] / 255.0;
        rgb2hsv(rgb, hsv);
        hsv[(signed long int)0] = hsv[(signed long int)0] + hue_rotation * 6.0;
        hsv2rgb(hsv, rgb);
        (c + (signed long int)i)->index = (double)i;
        j = 0;
        for( ; !(j >= 3); j = j + 1)
          (c + (signed long int)i)->color[(signed long int)j] = rgb[(signed long int)j];
        (c + (signed long int)i)->color[(signed long int)3] = 1.0;
      }
      return n;
    }

  fprintf(stderr, "warning: palette number %d not found, using white.\n", n);
  return -1;
}

// flam3_hamming_filter
// file filters.c line 140
double flam3_hamming_filter(double x)
{
  double return_value_cos_1;
  return_value_cos_1=cos(3.14159265358979323846 * x);
  return 0.54 + 0.46 * return_value_cos_1;
}

// flam3_hanning_filter
// file filters.c line 136
double flam3_hanning_filter(double x)
{
  double return_value_cos_1;
  return_value_cos_1=cos(3.14159265358979323846 * x);
  return 0.5 + 0.5 * return_value_cos_1;
}

// flam3_hermite_filter
// file filters.c line 47
double flam3_hermite_filter(double t)
{
  if(t < 0.0)
    t = -t;

  if(t < 1.0)
    return (2.0 * t - 3.0) * t * t + 1.0;

  else
    return 0.0;
}

// flam3_improve_colors
// file flam3.h line 576
void flam3_improve_colors(struct anonymous_0 *g, signed int ntries, signed int change_palette, signed int color_resolution)
{
  signed int i;
  double best;
  double b;
  struct anonymous_0 best_genome;
  memset((void *)&best_genome, 0, sizeof(struct anonymous_0) /*10712ul*/ );
  best=try_colors(g, color_resolution);
  if(best < 0.000000)
    fprintf(stderr, "error in try_colors, skipping flam3_improve_colors\n");

  else
  {
    flam3_copy(&best_genome, g);
    i = 0;
    for( ; !(i >= ntries); i = i + 1)
    {
      change_colors(g, change_palette);
      b=try_colors(g, color_resolution);
      if(b < 0.000000)
      {
        fprintf(stderr, "error in try_colors, aborting tries\n");
        break;
      }

      if(b > best)
      {
        best = b;
        flam3_copy(&best_genome, g);
      }

    }
    flam3_copy(g, &best_genome);
    clear_cp(&best_genome, 1);
  }
}

// flam3_init_frame
// file flam3.h line 629
void flam3_init_frame(struct anonymous_4 *f)
{
  char *ai;
  char *isaac_seed;
  ai=getenv("isaac_seed");
  isaac_seed = ai != ((char *)NULL) ? ai : (char *)(void *)0;
  signed long int default_isaac_seed;
  signed long int return_value_time_1;
  return_value_time_1=time(((signed long int *)NULL));
  default_isaac_seed = (signed long int)return_value_time_1;
  memset((void *)f->rc.randrsl, 0, (unsigned long int)(1 << 4) * sizeof(unsigned long int) /*8ul*/ );
  if(isaac_seed == ((char *)NULL))
  {
    signed int lp = 0;
    for( ; !(lp >= 16); lp = lp + 1)
      f->rc.randrsl[(signed long int)lp] = (unsigned long int)default_isaac_seed;
  }

  else
    __builtin_strncpy((char *)&f->rc.randrsl, (const char *)isaac_seed, (unsigned long int)(1 << 4) * sizeof(unsigned long int) /*8ul*/ );
  irandinit(&f->rc, 1);
}

// flam3_interp_missing_colors
// file parser.c line 135
signed int flam3_interp_missing_colors(struct anonymous_0 *cp)
{
  signed int minix;
  signed int maxix;
  signed int colorli;
  signed int colorri;
  signed int wrapmin;
  signed int wrapmax;
  signed int intl;
  signed int intr;
  signed int str;
  signed int enr;
  signed int i;
  signed int j;
  signed int k;
  double prcr;
  i = 0;
  for( ; !(i >= 256); i = i + 1)
    if(cp->palette[(signed long int)i].index >= 0.000000)
    {
      minix = i;
      break;
    }

  if(i == 256)
  {
    i = 0;
    for( ; !(i >= 256); i = i + 1)
      cp->palette[(signed long int)i].index = (double)i;
    return 1;
  }

  else
  {
    wrapmin = minix + 256;
    i = 255;
    for( ; i >= 0; i = i - 1)
      if(cp->palette[(signed long int)i].index >= 0.000000)
      {
        maxix = i;
        break;
      }

    wrapmax = maxix - 256;
    i = 0;
    while(!(i >= 256))
      if(cp->palette[(signed long int)i].index < 0.000000)
      {
        str = i;
        intl = i - 1;
        colorli = intl;
        for( ; cp->palette[(signed long int)i].index < 0.000000; i = i + 1)
        {
          if(i >= 256)
            break;

          enr = i;
          intr = i + 1;
          colorri = intr;
        }
        if(intl == -1)
        {
          intl = wrapmax;
          colorli = maxix;
        }

        if(intr == 256)
        {
          intr = wrapmin;
          colorri = minix;
        }

        j = str;
        for( ; enr >= j; j = j + 1)
        {
          prcr = (double)(j - intl) / (double)(intr - intl);
          k = 0;
          for( ; !(k >= 4); k = k + 1)
            cp->palette[(signed long int)j].color[(signed long int)k] = cp->palette[(signed long int)colorli].color[(signed long int)k] * (1.0 - prcr) + cp->palette[(signed long int)colorri].color[(signed long int)k] * prcr;
          cp->palette[(signed long int)j].index = (double)j;
        }
        i = colorri + 1;
      }

      else
        i = i + 1;
    return 0;
  }
}

// flam3_interpolate
// file flam3.h line 552
void flam3_interpolate(struct anonymous_0 *cps, signed int ncps, double time, double stagger, struct anonymous_0 *result)
{
  signed int i1;
  signed int i2;
  double c[2l];
  struct anonymous_0 cpi[4l];
  signed int smoothflag = 0;
  if(ncps == 1)
    flam3_copy(result, &cps[(signed long int)0]);

  else
  {
    if(cps->time >= time)
    {
      i1 = 0;
      i2 = 1;
    }

    else
      if((cps + (signed long int)(ncps + -1))->time <= time)
      {
        i1 = ncps - 2;
        i2 = ncps - 1;
      }

      else
      {
        i1 = 0;
        for( ; (cps + (signed long int)i1)->time < time; i1 = i1 + 1)
          ;
        i1 = i1 - 1;
        i2 = i1 + 1;
      }
    c[(signed long int)0] = ((cps + (signed long int)i2)->time - time) / ((cps + (signed long int)i2)->time - (cps + (signed long int)i1)->time);
    c[(signed long int)1] = 1.0 - c[(signed long int)0];
    memset((void *)cpi, 0, (unsigned long int)4 * sizeof(struct anonymous_0) /*10712ul*/ );
    if((cps + (signed long int)i1)->interpolation == 0)
    {
      flam3_align(&cpi[(signed long int)0], &cps[(signed long int)i1], 2);
      smoothflag = 0;
    }

    else
    {
      if(i1 == 0)
      {
        fprintf(stderr, "error: cannot use smooth interpolation on first segment.\n");
        fprintf(stderr, "reverting to linear interpolation.\n");
        flam3_align(&cpi[(signed long int)0], &cps[(signed long int)i1], 2);
        smoothflag = 0;
      }

      if(ncps + -1 == i2)
      {
        fprintf(stderr, "error: cannot use smooth interpolation on last segment.\n");
        fprintf(stderr, "reverting to linear interpolation.\n");
        flam3_align(&cpi[(signed long int)0], &cps[(signed long int)i1], 2);
        smoothflag = 0;
      }

      flam3_align(&cpi[(signed long int)0], &cps[(signed long int)(i1 - 1)], 4);
      smoothflag = 1;
    }
    clear_cp(result, 1);
    if(cpi[0l].final_xform_index >= 0)
    {
      flam3_add_xforms(result, cpi[(signed long int)0].num_xforms - 1, 0, 0);
      flam3_add_xforms(result, 1, 0, 1);
    }

    else
      flam3_add_xforms(result, cpi[(signed long int)0].num_xforms, 0, 0);
    result->time = time;
    result->interpolation = 0;
    result->interpolation_type = cpi[(signed long int)0].interpolation_type;
    result->palette_interpolation = 0;
    if(smoothflag == 0)
      flam3_interpolate_n(result, 2, cpi, c, stagger);

    else
    {
      interpolate_catmull_rom(cpi, c[(signed long int)1], result);
      clear_cp(&cpi[(signed long int)2], 0);
      clear_cp(&cpi[(signed long int)3], 0);
    }
    clear_cp(&cpi[(signed long int)0], 0);
    clear_cp(&cpi[(signed long int)1], 0);
  }
}

// flam3_interpolate_n
// file interpolation.h line 55
void flam3_interpolate_n(struct anonymous_0 *result, signed int ncp, struct anonymous_0 *cpi, double *c, double stagger)
{
  signed int i;
  signed int j;
  signed int k;
  signed int numstd;
  if(cpi->palette_interpolation == 0)
  {
    i = 0;
    for( ; !(i >= 256); i = i + 1)
    {
      double t[3l];
      double s[4l];
      s[(signed long int)4] = 0.0;
      s[(signed long int)3] = s[(signed long int)4];
      s[(signed long int)2] = s[(signed long int)3];
      s[(signed long int)1] = s[(signed long int)2];
      s[(signed long int)0] = s[(signed long int)1];
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
      {
        rgb2hsv((cpi + (signed long int)k)->palette[(signed long int)i].color, t);
        j = 0;
        for( ; !(j >= 3); j = j + 1)
          s[(signed long int)j] = s[(signed long int)j] + c[(signed long int)k] * t[(signed long int)j];
        s[(signed long int)3] = s[(signed long int)3] + c[(signed long int)k] * (cpi + (signed long int)k)->palette[(signed long int)i].color[(signed long int)3];
        s[(signed long int)4] = s[(signed long int)4] + c[(signed long int)k] * (cpi + (signed long int)k)->palette[(signed long int)i].index;
      }
      hsv2rgb(s, result->palette[(signed long int)i].color);
      result->palette[(signed long int)i].color[(signed long int)3] = s[(signed long int)3];
      result->palette[(signed long int)i].index = s[(signed long int)4];
      j = 0;
      for( ; !(j >= 4); j = j + 1)
      {
        if(result->palette[(signed long int)i].color[(signed long int)j] < 0.0)
          result->palette[(signed long int)i].color[(signed long int)j] = 0.0;

        if(result->palette[(signed long int)i].color[(signed long int)j] > 1.0)
          result->palette[(signed long int)i].color[(signed long int)j] = 1.0;

      }
      if(result->palette[(signed long int)i].index < 0.0)
        result->palette[(signed long int)i].index = 0.0;

      if(result->palette[(signed long int)i].index > 255.0)
        result->palette[(signed long int)i].index = 255.0;

    }
  }

  else
  {
    i = 0;
    for( ; !(i >= 256); i = i + 1)
    {
      j = (double)i < (double)256 * c[(signed long int)0] ? 0 : 1;
      result->palette[(signed long int)i] = (cpi + (signed long int)j)->palette[(signed long int)i];
    }
  }
  result->palette_index = -1;
  result->symmetry = 0;
  result->spatial_filter_select = (cpi + (signed long int)0)->spatial_filter_select;
  result->temporal_filter_type = (cpi + (signed long int)0)->temporal_filter_type;
  result->palette_mode = (cpi + (signed long int)0)->palette_mode;
  result->interpolation_type = (cpi + (signed long int)0)->interpolation_type;
  do
  {
    result->brightness = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      result->brightness = result->brightness + c[(signed long int)k] * (cpi + (signed long int)k)->brightness;
  }
  while((_Bool)0);
  do
  {
    result->contrast = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      result->contrast = result->contrast + c[(signed long int)k] * (cpi + (signed long int)k)->contrast;
  }
  while((_Bool)0);
  do
  {
    result->highlight_power = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      result->highlight_power = result->highlight_power + c[(signed long int)k] * (cpi + (signed long int)k)->highlight_power;
  }
  while((_Bool)0);
  do
  {
    result->gamma = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      result->gamma = result->gamma + c[(signed long int)k] * (cpi + (signed long int)k)->gamma;
  }
  while((_Bool)0);
  do
  {
    result->vibrancy = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      result->vibrancy = result->vibrancy + c[(signed long int)k] * (cpi + (signed long int)k)->vibrancy;
  }
  while((_Bool)0);
  do
  {
    result->hue_rotation = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      result->hue_rotation = result->hue_rotation + c[(signed long int)k] * (cpi + (signed long int)k)->hue_rotation;
  }
  while((_Bool)0);
  do
  {
    double tt = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      tt = tt + c[(signed long int)k] * (double)(cpi + (signed long int)k)->width;
    double return_value_rint_1;
    return_value_rint_1=rint(tt);
    result->width = (signed int)return_value_rint_1;
  }
  while((_Bool)0);
  do
  {
    double flam3_interpolate_n__1__10__tt = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      flam3_interpolate_n__1__10__tt = flam3_interpolate_n__1__10__tt + c[(signed long int)k] * (double)(cpi + (signed long int)k)->height;
    double return_value_rint_2;
    return_value_rint_2=rint(flam3_interpolate_n__1__10__tt);
    result->height = (signed int)return_value_rint_2;
  }
  while((_Bool)0);
  do
  {
    double flam3_interpolate_n__1__11__tt = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      flam3_interpolate_n__1__11__tt = flam3_interpolate_n__1__11__tt + c[(signed long int)k] * (double)(cpi + (signed long int)k)->spatial_oversample;
    double return_value_rint_3;
    return_value_rint_3=rint(flam3_interpolate_n__1__11__tt);
    result->spatial_oversample = (signed int)return_value_rint_3;
  }
  while((_Bool)0);
  do
  {
    result->center[(signed long int)0] = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      result->center[(signed long int)0] = result->center[(signed long int)0] + c[(signed long int)k] * (cpi + (signed long int)k)->center[(signed long int)0];
  }
  while((_Bool)0);
  do
  {
    result->center[(signed long int)1] = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      result->center[(signed long int)1] = result->center[(signed long int)1] + c[(signed long int)k] * (cpi + (signed long int)k)->center[(signed long int)1];
  }
  while((_Bool)0);
  do
  {
    result->rot_center[(signed long int)0] = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      result->rot_center[(signed long int)0] = result->rot_center[(signed long int)0] + c[(signed long int)k] * (cpi + (signed long int)k)->rot_center[(signed long int)0];
  }
  while((_Bool)0);
  do
  {
    result->rot_center[(signed long int)1] = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      result->rot_center[(signed long int)1] = result->rot_center[(signed long int)1] + c[(signed long int)k] * (cpi + (signed long int)k)->rot_center[(signed long int)1];
  }
  while((_Bool)0);
  do
  {
    result->background[(signed long int)0] = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      result->background[(signed long int)0] = result->background[(signed long int)0] + c[(signed long int)k] * (cpi + (signed long int)k)->background[(signed long int)0];
  }
  while((_Bool)0);
  do
  {
    result->background[(signed long int)1] = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      result->background[(signed long int)1] = result->background[(signed long int)1] + c[(signed long int)k] * (cpi + (signed long int)k)->background[(signed long int)1];
  }
  while((_Bool)0);
  do
  {
    result->background[(signed long int)2] = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      result->background[(signed long int)2] = result->background[(signed long int)2] + c[(signed long int)k] * (cpi + (signed long int)k)->background[(signed long int)2];
  }
  while((_Bool)0);
  do
  {
    result->pixels_per_unit = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      result->pixels_per_unit = result->pixels_per_unit + c[(signed long int)k] * (cpi + (signed long int)k)->pixels_per_unit;
  }
  while((_Bool)0);
  do
  {
    result->spatial_filter_radius = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      result->spatial_filter_radius = result->spatial_filter_radius + c[(signed long int)k] * (cpi + (signed long int)k)->spatial_filter_radius;
  }
  while((_Bool)0);
  do
  {
    result->temporal_filter_exp = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      result->temporal_filter_exp = result->temporal_filter_exp + c[(signed long int)k] * (cpi + (signed long int)k)->temporal_filter_exp;
  }
  while((_Bool)0);
  do
  {
    result->temporal_filter_width = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      result->temporal_filter_width = result->temporal_filter_width + c[(signed long int)k] * (cpi + (signed long int)k)->temporal_filter_width;
  }
  while((_Bool)0);
  do
  {
    result->sample_density = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      result->sample_density = result->sample_density + c[(signed long int)k] * (cpi + (signed long int)k)->sample_density;
  }
  while((_Bool)0);
  do
  {
    result->zoom = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      result->zoom = result->zoom + c[(signed long int)k] * (cpi + (signed long int)k)->zoom;
  }
  while((_Bool)0);
  do
  {
    result->rotate = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      result->rotate = result->rotate + c[(signed long int)k] * (cpi + (signed long int)k)->rotate;
  }
  while((_Bool)0);
  do
  {
    double flam3_interpolate_n__1__26__tt = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      flam3_interpolate_n__1__26__tt = flam3_interpolate_n__1__26__tt + c[(signed long int)k] * (double)(cpi + (signed long int)k)->nbatches;
    double return_value_rint_4;
    return_value_rint_4=rint(flam3_interpolate_n__1__26__tt);
    result->nbatches = (signed int)return_value_rint_4;
  }
  while((_Bool)0);
  do
  {
    double flam3_interpolate_n__1__27__tt = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      flam3_interpolate_n__1__27__tt = flam3_interpolate_n__1__27__tt + c[(signed long int)k] * (double)(cpi + (signed long int)k)->ntemporal_samples;
    double return_value_rint_5;
    return_value_rint_5=rint(flam3_interpolate_n__1__27__tt);
    result->ntemporal_samples = (signed int)return_value_rint_5;
  }
  while((_Bool)0);
  do
  {
    result->estimator = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      result->estimator = result->estimator + c[(signed long int)k] * (cpi + (signed long int)k)->estimator;
  }
  while((_Bool)0);
  do
  {
    result->estimator_minimum = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      result->estimator_minimum = result->estimator_minimum + c[(signed long int)k] * (cpi + (signed long int)k)->estimator_minimum;
  }
  while((_Bool)0);
  do
  {
    result->estimator_curve = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      result->estimator_curve = result->estimator_curve + c[(signed long int)k] * (cpi + (signed long int)k)->estimator_curve;
  }
  while((_Bool)0);
  do
  {
    result->gam_lin_thresh = 0.0;
    k = 0;
    for( ; !(k >= ncp); k = k + 1)
      result->gam_lin_thresh = result->gam_lin_thresh + c[(signed long int)k] * (cpi + (signed long int)k)->gam_lin_thresh;
  }
  while((_Bool)0);
  numstd = (cpi + (signed long int)0)->num_xforms - (signed int)((cpi + (signed long int)0)->final_xform_index >= 0);
  i = 0;
  for( ; !(i >= numstd); i = i + 1)
  {
    j = 0;
    for( ; !(j >= numstd); j = j + 1)
    {
      do
      {
        result->chaos[(signed long int)i][(signed long int)j] = 0.0;
        k = 0;
        for( ; !(k >= ncp); k = k + 1)
          result->chaos[(signed long int)i][(signed long int)j] = result->chaos[(signed long int)i][(signed long int)j] + c[(signed long int)k] * (cpi + (signed long int)k)->chaos[(signed long int)i][(signed long int)j];
      }
      while((_Bool)0);
      if(result->chaos[(signed long int)i][(signed long int)j] < 0.000000)
        result->chaos[(signed long int)i][(signed long int)j] = (double)0;

    }
  }
  i = 0;
  signed int return_value_id_matrix_6;
  for( ; !(i >= cpi->num_xforms); i = i + 1)
  {
    double csave[2l];
    double td;
    signed int all_id;
    signed int nx = (cpi + (signed long int)0)->num_xforms - (signed int)((cpi + (signed long int)0)->final_xform_index >= 0);
    if(ncp == 2 && stagger > 0.000000)
    {
      if(!(i == cpi->final_xform_index))
      {
        csave[(signed long int)0] = c[(signed long int)0];
        csave[(signed long int)1] = c[(signed long int)1];
        c[(signed long int)0]=get_stagger_coef(csave[(signed long int)0], stagger, nx, i);
        c[(signed long int)1] = 1.0 - c[(signed long int)0];
      }

    }

    do
    {
      (result->xform + (signed long int)i)->density = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->density = (result->xform + (signed long int)i)->density + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->density;
    }
    while((_Bool)0);
    td = (result->xform + (signed long int)i)->density;
    (result->xform + (signed long int)i)->density = td < 0.0 ? 0.0 : td;
    do
    {
      (result->xform + (signed long int)i)->color = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->color = (result->xform + (signed long int)i)->color + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->color;
    }
    while((_Bool)0);
    if((result->xform + (signed long int)i)->color < 0.000000)
      (result->xform + (signed long int)i)->color = (double)0;

    if((result->xform + (signed long int)i)->color > 1.000000)
      (result->xform + (signed long int)i)->color = (double)1;

    do
    {
      (result->xform + (signed long int)i)->color_speed = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->color_speed = (result->xform + (signed long int)i)->color_speed + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->color_speed;
    }
    while((_Bool)0);
    if((result->xform + (signed long int)i)->color_speed < 0.000000)
      (result->xform + (signed long int)i)->color_speed = (double)0;

    if((result->xform + (signed long int)i)->color_speed > 1.000000)
      (result->xform + (signed long int)i)->color_speed = (double)1;

    do
    {
      (result->xform + (signed long int)i)->opacity = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->opacity = (result->xform + (signed long int)i)->opacity + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->opacity;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->animate = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->animate = (result->xform + (signed long int)i)->animate + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->animate;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->blob_low = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->blob_low = (result->xform + (signed long int)i)->blob_low + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->blob_low;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->blob_high = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->blob_high = (result->xform + (signed long int)i)->blob_high + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->blob_high;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->blob_waves = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->blob_waves = (result->xform + (signed long int)i)->blob_waves + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->blob_waves;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->pdj_a = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->pdj_a = (result->xform + (signed long int)i)->pdj_a + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->pdj_a;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->pdj_b = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->pdj_b = (result->xform + (signed long int)i)->pdj_b + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->pdj_b;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->pdj_c = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->pdj_c = (result->xform + (signed long int)i)->pdj_c + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->pdj_c;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->pdj_d = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->pdj_d = (result->xform + (signed long int)i)->pdj_d + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->pdj_d;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->fan2_x = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->fan2_x = (result->xform + (signed long int)i)->fan2_x + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->fan2_x;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->fan2_y = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->fan2_y = (result->xform + (signed long int)i)->fan2_y + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->fan2_y;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->rings2_val = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->rings2_val = (result->xform + (signed long int)i)->rings2_val + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->rings2_val;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->perspective_angle = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->perspective_angle = (result->xform + (signed long int)i)->perspective_angle + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->perspective_angle;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->perspective_dist = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->perspective_dist = (result->xform + (signed long int)i)->perspective_dist + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->perspective_dist;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->julian_power = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->julian_power = (result->xform + (signed long int)i)->julian_power + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->julian_power;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->julian_dist = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->julian_dist = (result->xform + (signed long int)i)->julian_dist + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->julian_dist;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->juliascope_power = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->juliascope_power = (result->xform + (signed long int)i)->juliascope_power + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->juliascope_power;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->juliascope_dist = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->juliascope_dist = (result->xform + (signed long int)i)->juliascope_dist + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->juliascope_dist;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->radial_blur_angle = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->radial_blur_angle = (result->xform + (signed long int)i)->radial_blur_angle + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->radial_blur_angle;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->pie_slices = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->pie_slices = (result->xform + (signed long int)i)->pie_slices + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->pie_slices;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->pie_rotation = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->pie_rotation = (result->xform + (signed long int)i)->pie_rotation + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->pie_rotation;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->pie_thickness = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->pie_thickness = (result->xform + (signed long int)i)->pie_thickness + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->pie_thickness;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->ngon_sides = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->ngon_sides = (result->xform + (signed long int)i)->ngon_sides + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->ngon_sides;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->ngon_power = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->ngon_power = (result->xform + (signed long int)i)->ngon_power + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->ngon_power;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->ngon_circle = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->ngon_circle = (result->xform + (signed long int)i)->ngon_circle + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->ngon_circle;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->ngon_corners = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->ngon_corners = (result->xform + (signed long int)i)->ngon_corners + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->ngon_corners;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->curl_c1 = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->curl_c1 = (result->xform + (signed long int)i)->curl_c1 + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->curl_c1;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->curl_c2 = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->curl_c2 = (result->xform + (signed long int)i)->curl_c2 + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->curl_c2;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->rectangles_x = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->rectangles_x = (result->xform + (signed long int)i)->rectangles_x + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->rectangles_x;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->rectangles_y = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->rectangles_y = (result->xform + (signed long int)i)->rectangles_y + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->rectangles_y;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->amw_amp = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->amw_amp = (result->xform + (signed long int)i)->amw_amp + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->amw_amp;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->disc2_rot = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->disc2_rot = (result->xform + (signed long int)i)->disc2_rot + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->disc2_rot;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->disc2_twist = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->disc2_twist = (result->xform + (signed long int)i)->disc2_twist + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->disc2_twist;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->super_shape_rnd = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->super_shape_rnd = (result->xform + (signed long int)i)->super_shape_rnd + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->super_shape_rnd;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->super_shape_m = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->super_shape_m = (result->xform + (signed long int)i)->super_shape_m + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->super_shape_m;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->super_shape_n1 = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->super_shape_n1 = (result->xform + (signed long int)i)->super_shape_n1 + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->super_shape_n1;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->super_shape_n2 = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->super_shape_n2 = (result->xform + (signed long int)i)->super_shape_n2 + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->super_shape_n2;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->super_shape_n3 = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->super_shape_n3 = (result->xform + (signed long int)i)->super_shape_n3 + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->super_shape_n3;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->super_shape_holes = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->super_shape_holes = (result->xform + (signed long int)i)->super_shape_holes + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->super_shape_holes;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->flower_petals = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->flower_petals = (result->xform + (signed long int)i)->flower_petals + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->flower_petals;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->flower_holes = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->flower_holes = (result->xform + (signed long int)i)->flower_holes + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->flower_holes;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->conic_eccentricity = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->conic_eccentricity = (result->xform + (signed long int)i)->conic_eccentricity + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->conic_eccentricity;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->conic_holes = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->conic_holes = (result->xform + (signed long int)i)->conic_holes + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->conic_holes;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->parabola_height = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->parabola_height = (result->xform + (signed long int)i)->parabola_height + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->parabola_height;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->parabola_width = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->parabola_width = (result->xform + (signed long int)i)->parabola_width + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->parabola_width;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->bent2_x = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->bent2_x = (result->xform + (signed long int)i)->bent2_x + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->bent2_x;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->bent2_y = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->bent2_y = (result->xform + (signed long int)i)->bent2_y + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->bent2_y;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->bipolar_shift = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->bipolar_shift = (result->xform + (signed long int)i)->bipolar_shift + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->bipolar_shift;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->cell_size = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->cell_size = (result->xform + (signed long int)i)->cell_size + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->cell_size;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->cpow_r = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->cpow_r = (result->xform + (signed long int)i)->cpow_r + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->cpow_r;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->cpow_i = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->cpow_i = (result->xform + (signed long int)i)->cpow_i + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->cpow_i;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->cpow_power = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->cpow_power = (result->xform + (signed long int)i)->cpow_power + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->cpow_power;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->curve_xamp = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->curve_xamp = (result->xform + (signed long int)i)->curve_xamp + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->curve_xamp;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->curve_yamp = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->curve_yamp = (result->xform + (signed long int)i)->curve_yamp + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->curve_yamp;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->curve_xlength = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->curve_xlength = (result->xform + (signed long int)i)->curve_xlength + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->curve_xlength;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->curve_ylength = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->curve_ylength = (result->xform + (signed long int)i)->curve_ylength + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->curve_ylength;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->escher_beta = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->escher_beta = (result->xform + (signed long int)i)->escher_beta + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->escher_beta;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->lazysusan_x = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->lazysusan_x = (result->xform + (signed long int)i)->lazysusan_x + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->lazysusan_x;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->lazysusan_y = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->lazysusan_y = (result->xform + (signed long int)i)->lazysusan_y + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->lazysusan_y;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->lazysusan_twist = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->lazysusan_twist = (result->xform + (signed long int)i)->lazysusan_twist + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->lazysusan_twist;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->lazysusan_space = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->lazysusan_space = (result->xform + (signed long int)i)->lazysusan_space + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->lazysusan_space;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->lazysusan_spin = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->lazysusan_spin = (result->xform + (signed long int)i)->lazysusan_spin + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->lazysusan_spin;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->modulus_x = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->modulus_x = (result->xform + (signed long int)i)->modulus_x + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->modulus_x;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->modulus_y = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->modulus_y = (result->xform + (signed long int)i)->modulus_y + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->modulus_y;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->oscope_separation = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->oscope_separation = (result->xform + (signed long int)i)->oscope_separation + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->oscope_separation;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->oscope_frequency = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->oscope_frequency = (result->xform + (signed long int)i)->oscope_frequency + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->oscope_frequency;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->oscope_amplitude = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->oscope_amplitude = (result->xform + (signed long int)i)->oscope_amplitude + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->oscope_amplitude;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->oscope_damping = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->oscope_damping = (result->xform + (signed long int)i)->oscope_damping + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->oscope_damping;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->popcorn2_x = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->popcorn2_x = (result->xform + (signed long int)i)->popcorn2_x + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->popcorn2_x;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->popcorn2_y = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->popcorn2_y = (result->xform + (signed long int)i)->popcorn2_y + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->popcorn2_y;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->popcorn2_c = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->popcorn2_c = (result->xform + (signed long int)i)->popcorn2_c + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->popcorn2_c;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->separation_x = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->separation_x = (result->xform + (signed long int)i)->separation_x + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->separation_x;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->separation_xinside = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->separation_xinside = (result->xform + (signed long int)i)->separation_xinside + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->separation_xinside;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->separation_y = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->separation_y = (result->xform + (signed long int)i)->separation_y + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->separation_y;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->separation_yinside = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->separation_yinside = (result->xform + (signed long int)i)->separation_yinside + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->separation_yinside;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->split_xsize = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->split_xsize = (result->xform + (signed long int)i)->split_xsize + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->split_xsize;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->split_ysize = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->split_ysize = (result->xform + (signed long int)i)->split_ysize + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->split_ysize;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->splits_x = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->splits_x = (result->xform + (signed long int)i)->splits_x + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->splits_x;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->splits_y = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->splits_y = (result->xform + (signed long int)i)->splits_y + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->splits_y;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->stripes_space = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->stripes_space = (result->xform + (signed long int)i)->stripes_space + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->stripes_space;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->stripes_warp = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->stripes_warp = (result->xform + (signed long int)i)->stripes_warp + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->stripes_warp;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->wedge_angle = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->wedge_angle = (result->xform + (signed long int)i)->wedge_angle + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->wedge_angle;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->wedge_hole = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->wedge_hole = (result->xform + (signed long int)i)->wedge_hole + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->wedge_hole;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->wedge_count = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->wedge_count = (result->xform + (signed long int)i)->wedge_count + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->wedge_count;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->wedge_swirl = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->wedge_swirl = (result->xform + (signed long int)i)->wedge_swirl + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->wedge_swirl;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->wedge_julia_angle = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->wedge_julia_angle = (result->xform + (signed long int)i)->wedge_julia_angle + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->wedge_julia_angle;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->wedge_julia_count = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->wedge_julia_count = (result->xform + (signed long int)i)->wedge_julia_count + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->wedge_julia_count;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->wedge_julia_power = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->wedge_julia_power = (result->xform + (signed long int)i)->wedge_julia_power + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->wedge_julia_power;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->wedge_julia_dist = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->wedge_julia_dist = (result->xform + (signed long int)i)->wedge_julia_dist + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->wedge_julia_dist;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->wedge_sph_angle = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->wedge_sph_angle = (result->xform + (signed long int)i)->wedge_sph_angle + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->wedge_sph_angle;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->wedge_sph_hole = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->wedge_sph_hole = (result->xform + (signed long int)i)->wedge_sph_hole + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->wedge_sph_hole;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->wedge_sph_count = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->wedge_sph_count = (result->xform + (signed long int)i)->wedge_sph_count + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->wedge_sph_count;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->wedge_sph_swirl = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->wedge_sph_swirl = (result->xform + (signed long int)i)->wedge_sph_swirl + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->wedge_sph_swirl;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->whorl_inside = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->whorl_inside = (result->xform + (signed long int)i)->whorl_inside + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->whorl_inside;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->whorl_outside = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->whorl_outside = (result->xform + (signed long int)i)->whorl_outside + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->whorl_outside;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->waves2_scalex = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->waves2_scalex = (result->xform + (signed long int)i)->waves2_scalex + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->waves2_scalex;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->waves2_scaley = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->waves2_scaley = (result->xform + (signed long int)i)->waves2_scaley + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->waves2_scaley;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->waves2_freqx = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->waves2_freqx = (result->xform + (signed long int)i)->waves2_freqx + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->waves2_freqx;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->waves2_freqy = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->waves2_freqy = (result->xform + (signed long int)i)->waves2_freqy + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->waves2_freqy;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->auger_sym = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->auger_sym = (result->xform + (signed long int)i)->auger_sym + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->auger_sym;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->auger_weight = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->auger_weight = (result->xform + (signed long int)i)->auger_weight + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->auger_weight;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->auger_freq = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->auger_freq = (result->xform + (signed long int)i)->auger_freq + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->auger_freq;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->auger_scale = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->auger_scale = (result->xform + (signed long int)i)->auger_scale + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->auger_scale;
    }
    while((_Bool)0);
    do
    {
      (result->xform + (signed long int)i)->flux_spread = 0.0;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
        (result->xform + (signed long int)i)->flux_spread = (result->xform + (signed long int)i)->flux_spread + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->flux_spread;
    }
    while((_Bool)0);
    j = 0;
    for( ; !(j >= 98); j = j + 1)
      do
      {
        (result->xform + (signed long int)i)->var[(signed long int)j] = 0.0;
        k = 0;
        for( ; !(k >= ncp); k = k + 1)
          (result->xform + (signed long int)i)->var[(signed long int)j] = (result->xform + (signed long int)i)->var[(signed long int)j] + c[(signed long int)k] * ((cpi + (signed long int)k)->xform + (signed long int)i)->var[(signed long int)j];
      }
      while((_Bool)0);
    if(cpi->interpolation_type == 1)
    {
      double cxmag[4l][2l];
      double cxang[4l][2l];
      double cxtrn[4l][2l];
      clear_matrix((result->xform + (signed long int)i)->c);
      convert_linear_to_polar(cpi, ncp, i, 0, cxang, cxmag, cxtrn);
      interp_and_convert_back(c, ncp, i, cxang, cxmag, cxtrn, (result->xform + (signed long int)i)->c);
      all_id = 1;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
      {
        return_value_id_matrix_6=id_matrix(((cpi + (signed long int)k)->xform + (signed long int)i)->post);
        all_id = all_id & return_value_id_matrix_6;
      }
      clear_matrix((result->xform + (signed long int)i)->post);
      if(!(all_id == 0))
      {
        (result->xform + (signed long int)i)->post[(signed long int)0][(signed long int)0] = 1.0;
        (result->xform + (signed long int)i)->post[(signed long int)1][(signed long int)1] = 1.0;
      }

      else
      {
        convert_linear_to_polar(cpi, ncp, i, 1, cxang, cxmag, cxtrn);
        interp_and_convert_back(c, ncp, i, cxang, cxmag, cxtrn, (result->xform + (signed long int)i)->post);
      }
    }

    else
    {
      clear_matrix((result->xform + (signed long int)i)->c);
      clear_matrix((result->xform + (signed long int)i)->post);
      all_id = 1;
      k = 0;
      for( ; !(k >= ncp); k = k + 1)
      {
        sum_matrix(c[(signed long int)k], ((cpi + (signed long int)k)->xform + (signed long int)i)->c, (result->xform + (signed long int)i)->c);
        sum_matrix(c[(signed long int)k], ((cpi + (signed long int)k)->xform + (signed long int)i)->post, (result->xform + (signed long int)i)->post);
        signed int return_value_id_matrix_7;
        return_value_id_matrix_7=id_matrix(((cpi + (signed long int)k)->xform + (signed long int)i)->post);
        all_id = all_id & return_value_id_matrix_7;
      }
      if(!(all_id == 0))
      {
        clear_matrix((result->xform + (signed long int)i)->post);
        (result->xform + (signed long int)i)->post[(signed long int)0][(signed long int)0] = 1.0;
        (result->xform + (signed long int)i)->post[(signed long int)1][(signed long int)1] = 1.0;
      }

    }
    if(ncp == 2 && stagger > 0.000000)
    {
      if(!(i == cpi->final_xform_index))
      {
        c[(signed long int)0] = csave[(signed long int)0];
        c[(signed long int)1] = csave[(signed long int)1];
      }

    }

  }
}

// flam3_iterate
// file flam3.c line 228
signed int flam3_iterate(struct anonymous_0 *cp, signed int n, signed int fuse, double *samples, unsigned short int *xform_distrib, struct randctx *rc)
{
  signed int i;
  double p[4l];
  double q[4l];
  signed int consec = 0;
  signed int badvals = 0;
  signed int lastxf = 0;
  signed int fn;
  p[(signed long int)0] = samples[(signed long int)0];
  p[(signed long int)1] = samples[(signed long int)1];
  p[(signed long int)2] = samples[(signed long int)2];
  p[(signed long int)3] = samples[(signed long int)3];
  i = 0;
  for( ; !(i >= cp->num_xforms); i = i + 1)
    xform_precalc(cp, i);
  i = -4 * fuse;
  unsigned long int tmp_post_1;
  unsigned long int tmp_if_expr_2;
  unsigned long int tmp_post_3;
  unsigned long int tmp_if_expr_4;
  _Bool tmp_if_expr_7;
  double return_value_flam3_random_isaac_01_6;
  for( ; !(i >= 4 * n); i = i + 4)
  {
    if(!(cp->chaos_enable == 0))
    {
      tmp_post_1 = rc->randcnt;
      rc->randcnt = rc->randcnt - 1ul;
      if(tmp_post_1 == 0ul)
      {
        isaac(rc);
        rc->randcnt = (unsigned long int)((1 << 4) - 1);
        tmp_if_expr_2 = rc->randrsl[(signed long int)rc->randcnt];
      }

      else
        tmp_if_expr_2 = rc->randrsl[(signed long int)rc->randcnt];
      fn = (signed int)xform_distrib[(signed long int)((unsigned int)(lastxf * 10000) + (unsigned int)tmp_if_expr_2 % (unsigned int)10000)];
    }

    else
    {
      tmp_post_3 = rc->randcnt;
      rc->randcnt = rc->randcnt - 1ul;
      if(tmp_post_3 == 0ul)
      {
        isaac(rc);
        rc->randcnt = (unsigned long int)((1 << 4) - 1);
        tmp_if_expr_4 = rc->randrsl[(signed long int)rc->randcnt];
      }

      else
        tmp_if_expr_4 = rc->randrsl[(signed long int)rc->randcnt];
      fn = (signed int)xform_distrib[(signed long int)((unsigned int)tmp_if_expr_4 % (unsigned int)10000)];
    }
    signed int return_value_apply_xform_5;
    return_value_apply_xform_5=apply_xform(cp, fn, p, q, rc);
    if(return_value_apply_xform_5 >= 1)
    {
      consec = consec + 1;
      badvals = badvals + 1;
      if(!(consec >= 5))
      {
        p[(signed long int)0] = q[(signed long int)0];
        p[(signed long int)1] = q[(signed long int)1];
        p[(signed long int)2] = q[(signed long int)2];
        p[(signed long int)3] = q[(signed long int)3];
        i = i - 4;
        goto __CPROVER_DUMP_L19;
      }

      else
        consec = 0;
    }

    else
      consec = 0;
    lastxf = fn + 1;
    p[(signed long int)0] = q[(signed long int)0];
    p[(signed long int)1] = q[(signed long int)1];
    p[(signed long int)2] = q[(signed long int)2];
    p[(signed long int)3] = q[(signed long int)3];
    if(cp->final_xform_enable == 1)
    {
      if(IEEE_FLOAT_EQUAL((cp->xform + (signed long int)cp->final_xform_index)->opacity, 1.000000))
        tmp_if_expr_7 = (_Bool)1;

      else
      {
        return_value_flam3_random_isaac_01_6=flam3_random_isaac_01(rc);
        tmp_if_expr_7 = return_value_flam3_random_isaac_01_6 < (cp->xform + (signed long int)cp->final_xform_index)->opacity ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_7)
      {
        apply_xform(cp, cp->final_xform_index, p, q, rc);
        q[(signed long int)3] = p[(signed long int)3];
      }

    }

    if(i >= 0)
    {
      samples[(signed long int)i] = q[(signed long int)0];
      samples[(signed long int)(i + 1)] = q[(signed long int)1];
      samples[(signed long int)(i + 2)] = q[(signed long int)2];
      samples[(signed long int)(i + 3)] = q[(signed long int)3];
    }


  __CPROVER_DUMP_L19:
    ;
  }
  return badvals;
}

// flam3_lanczos2_filter
// file filters.c line 150
double flam3_lanczos2_filter(double t)
{
  if(t < 0.000000)
    t = -t;

  double return_value_flam3_sinc_1;
  double return_value_flam3_sinc_2;
  if(t < 2.0)
  {
    return_value_flam3_sinc_1=flam3_sinc(t);
    return_value_flam3_sinc_2=flam3_sinc(t / 2.0);
    return return_value_flam3_sinc_1 * return_value_flam3_sinc_2;
  }

  else
    return 0.0;
}

// flam3_lanczos3_filter
// file filters.c line 144
double flam3_lanczos3_filter(double t)
{
  if(t < 0.000000)
    t = -t;

  double return_value_flam3_sinc_1;
  double return_value_flam3_sinc_2;
  if(t < 3.0)
  {
    return_value_flam3_sinc_1=flam3_sinc(t);
    return_value_flam3_sinc_2=flam3_sinc(t / 3.0);
    return return_value_flam3_sinc_1 * return_value_flam3_sinc_2;
  }

  else
    return 0.0;
}

// flam3_lyapunov
// file flam3.c line 3923
double flam3_lyapunov(struct anonymous_0 *cp, signed int ntries)
{
  double p[4l];
  double x;
  double y;
  double xn;
  double yn;
  double xn2;
  double yn2;
  double dx;
  double dy;
  double r;
  double eps = 1e-5;
  signed int i;
  double sum = 0.0;
  unsigned short int *xform_distrib;
  signed int lp;
  signed long int default_isaac_seed;
  signed long int return_value_time_1;
  return_value_time_1=time(((signed long int *)NULL));
  default_isaac_seed = (signed long int)return_value_time_1;
  struct randctx rc;
  lp = 0;
  for( ; !(lp >= 16); lp = lp + 1)
    rc.randrsl[(signed long int)lp] = (unsigned long int)default_isaac_seed;
  irandinit(&rc, 1);
  if(!(ntries >= 1))
    ntries = 10000;

  i = 0;
  for( ; !(i >= ntries); i = i + 1)
  {
    x=flam3_random_isaac_11(&rc);
    y=flam3_random_isaac_11(&rc);
    p[(signed long int)0] = x;
    p[(signed long int)1] = y;
    p[(signed long int)2] = 0.0;
    p[(signed long int)3] = 0.0;
    signed int return_value_prepare_precalc_flags_2;
    return_value_prepare_precalc_flags_2=prepare_precalc_flags(cp);
    if(!(return_value_prepare_precalc_flags_2 == 0))
      return -1.0;

    xform_distrib=flam3_create_xform_distrib(cp);
    if(xform_distrib == ((unsigned short int *)NULL))
      return -1.0;

    signed long int return_value_random_3;
    return_value_random_3=random();
    flam3_iterate(cp, 1, (signed int)((signed long int)20 + return_value_random_3 % (signed long int)10), p, xform_distrib, &rc);
    free((void *)xform_distrib);
    x = p[(signed long int)0];
    y = p[(signed long int)1];
    srandom((unsigned int)i);
    signed int return_value_prepare_precalc_flags_4;
    return_value_prepare_precalc_flags_4=prepare_precalc_flags(cp);
    if(!(return_value_prepare_precalc_flags_4 == 0))
      return -1.0;

    xform_distrib=flam3_create_xform_distrib(cp);
    if(xform_distrib == ((unsigned short int *)NULL))
      return -1.0;

    flam3_iterate(cp, 1, 0, p, xform_distrib, &rc);
    free((void *)xform_distrib);
    xn = p[(signed long int)0];
    yn = p[(signed long int)1];
    do
    {
      dx=flam3_random_isaac_11(&rc);
      dy=flam3_random_isaac_11(&rc);
      r=sqrt(dx * dx + dy * dy);
    }
    while(IEEE_FLOAT_EQUAL(r, 0.0));
    dx = dx / r;
    dy = dy / r;
    dx = dx * eps;
    dy = dy * eps;
    p[(signed long int)0] = x + dx;
    p[(signed long int)1] = y + dy;
    p[(signed long int)2] = 0.0;
    srandom((unsigned int)i);
    signed int return_value_prepare_precalc_flags_5;
    return_value_prepare_precalc_flags_5=prepare_precalc_flags(cp);
    if(!(return_value_prepare_precalc_flags_5 == 0))
      return -1.0;

    xform_distrib=flam3_create_xform_distrib(cp);
    if(xform_distrib == ((unsigned short int *)NULL))
      return -1.0;

    flam3_iterate(cp, 1, 0, p, xform_distrib, &rc);
    free((void *)xform_distrib);
    xn2 = p[(signed long int)0];
    yn2 = p[(signed long int)1];
    r=sqrt((xn - xn2) * (xn - xn2) + (yn - yn2) * (yn - yn2));
    double return_value_log_6;
    return_value_log_6=log(r / eps);
    sum = sum + return_value_log_6;
  }
  double return_value_log_7;
  return_value_log_7=log(2.0);
  return sum / (return_value_log_7 * (double)ntries);
}

// flam3_make_strip
// file flam3.c line 110
signed int flam3_make_strip(struct anonymous_0 *cp, signed int nstrips, signed int stripnum)
{
  double old_center[2l];
  signed int j = 0;
  for( ; !(j >= cp->num_xforms); j = j + 1)
    flam3_delete_motion_elements(&cp->xform[(signed long int)j]);
  old_center[(signed long int)0] = cp->center[(signed long int)0];
  old_center[(signed long int)1] = cp->center[(signed long int)1];
  cp->height = cp->height / nstrips;
  double return_value_pow_1;
  return_value_pow_1=pow(2.0, cp->zoom);
  cp->center[(signed long int)1] = cp->center[(signed long int)1] - (double)((nstrips - 1) * cp->height) / ((double)2 * cp->pixels_per_unit * return_value_pow_1);
  double return_value_pow_2;
  return_value_pow_2=pow(2.0, cp->zoom);
  cp->center[(signed long int)1] = cp->center[(signed long int)1] + (double)(cp->height * stripnum) / (cp->pixels_per_unit * return_value_pow_2);
  rotate_by(cp->center, old_center, cp->rotate);
  return 0;
}

// flam3_malloc
// file flam3.c line 3414
void * flam3_malloc(unsigned long int size)
{
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(size);
  return return_value_malloc_1;
}

// flam3_mitchell_filter
// file filters.c line 116
double flam3_mitchell_filter(double t)
{
  double tt = t * t;
  if(t < 0.000000)
    t = -t;

  if(t < 1.0)
  {
    t = ((12.0 - 9.0 * (1.0 / 3.0)) - 6.0 * (1.0 / 3.0)) * t * tt + (-18.0 + 12.0 * (1.0 / 3.0) + 6.0 * (1.0 / 3.0)) * tt + (6.0 - (double)2 * (1.0 / 3.0));
    return t / 6.0;
  }

  else
    if(t < 2.0)
    {
      t = (-1.0 * (1.0 / 3.0) - 6.0 * (1.0 / 3.0)) * t * tt + (6.0 * (1.0 / 3.0) + 30.0 * (1.0 / 3.0)) * tt + (-12.0 * (1.0 / 3.0) - 48.0 * (1.0 / 3.0)) * t + 8.0 * (1.0 / 3.0) + (double)24 * (1.0 / 3.0);
      return t / 6.0;
    }

  return 0.0;
}

// flam3_mutate
// file flam3.h line 567
void flam3_mutate(struct anonymous_0 *cp, signed int mutate_mode, signed int *ivars, signed int ivars_n, signed int sym, double speed, struct randctx *rc, char *action)
{
  double randselect;
  struct anonymous_0 mutation;
  signed int i;
  signed int j;
  signed int done;
  char ministr[30l];
  if(mutate_mode == -1)
  {
    randselect=flam3_random_isaac_01(rc);
    if(randselect < 0.1)
      mutate_mode = 0;

    else
      if(randselect < 0.3)
        mutate_mode = 1;

      else
        if(randselect < 0.5)
          mutate_mode = 2;

        else
          if(randselect < 0.6)
            mutate_mode = 3;

          else
            if(randselect < 0.7)
              mutate_mode = 4;

            else
              if(randselect < 0.8)
                mutate_mode = 5;

              else
                mutate_mode = 6;
  }

  memset((void *)&mutation, 0, sizeof(struct anonymous_0) /*10712ul*/ );
  unsigned long int tmp_post_1;
  unsigned long int tmp_if_expr_2;
  unsigned long int tmp_post_3;
  unsigned long int tmp_if_expr_4;
  unsigned long int tmp_post_5;
  unsigned long int tmp_if_expr_6;
  unsigned long int tmp_post_29;
  unsigned long int tmp_if_expr_30;
  if(mutate_mode == 0)
  {
    add_to_action(action, "mutate all variations");
    do
    {
      flam3_random(&mutation, ivars, ivars_n, sym, cp->num_xforms);
      i = 0;
      for( ; !(i >= cp->num_xforms); i = i + 1)
      {
        j = 0;
        for( ; !(j >= 98); j = j + 1)
          if(IEEE_FLOAT_NOTEQUAL((cp->xform + (signed long int)i)->var[(signed long int)j], (mutation.xform + (signed long int)i)->var[(signed long int)j]))
          {
            (cp->xform + (signed long int)i)->var[(signed long int)j] = (mutation.xform + (signed long int)i)->var[(signed long int)j];
            flam3_copy_params(&cp->xform[(signed long int)i], &mutation.xform[(signed long int)i], j);
            done = 1;
          }

      }
    }
    while(done == 0);
  }

  else
    if(mutate_mode == 1)
    {
      signed int modxf;
      flam3_random(&mutation, ivars, ivars_n, sym, 2);
      tmp_post_1 = rc->randcnt;
      rc->randcnt = rc->randcnt - 1ul;
      if(tmp_post_1 == 0ul)
      {
        isaac(rc);
        rc->randcnt = (unsigned long int)((1 << 4) - 1);
        tmp_if_expr_2 = rc->randrsl[(signed long int)rc->randcnt];
      }

      else
        tmp_if_expr_2 = rc->randrsl[(signed long int)rc->randcnt];
      modxf = (signed int)((unsigned int)tmp_if_expr_2 % (unsigned int)cp->num_xforms);
      add_to_action(action, "mutate xform ");
      sprintf(ministr, "%d coefs", modxf);
      add_to_action(action, ministr);
      if(!(cp->num_xforms >= 3))
      {
        j = 0;
        for( ; !(j >= 2); j = j + 1)
          (cp->xform + (signed long int)modxf)->c[(signed long int)2][(signed long int)j] = (mutation.xform + (signed long int)0)->c[(signed long int)2][(signed long int)j];
      }

      else
      {
        i = 0;
        for( ; !(i >= 3); i = i + 1)
        {
          j = 0;
          for( ; !(j >= 2); j = j + 1)
            (cp->xform + (signed long int)modxf)->c[(signed long int)i][(signed long int)j] = (mutation.xform + (signed long int)0)->c[(signed long int)i][(signed long int)j];
        }
      }
    }

    else
      if(mutate_mode == 2)
      {
        add_to_action(action, "mutate symmetry");
        flam3_add_symmetry(cp, 0);
      }

      else
        if(mutate_mode == 3)
        {
          signed int b;
          tmp_post_3 = rc->randcnt;
          rc->randcnt = rc->randcnt - 1ul;
          if(tmp_post_3 == 0ul)
          {
            isaac(rc);
            rc->randcnt = (unsigned long int)((1 << 4) - 1);
            tmp_if_expr_4 = rc->randrsl[(signed long int)rc->randcnt];
          }

          else
            tmp_if_expr_4 = rc->randrsl[(signed long int)rc->randcnt];
          b = (signed int)((unsigned int)1 + (unsigned int)tmp_if_expr_4 % (unsigned int)6);
          signed int same;
          tmp_post_5 = rc->randcnt;
          rc->randcnt = rc->randcnt - 1ul;
          if(tmp_post_5 == 0ul)
          {
            isaac(rc);
            rc->randcnt = (unsigned long int)((1 << 4) - 1);
            tmp_if_expr_6 = rc->randrsl[(signed long int)rc->randcnt];
          }

          else
            tmp_if_expr_6 = rc->randrsl[(signed long int)rc->randcnt];
          same = (signed int)((unsigned int)tmp_if_expr_6 & (unsigned int)3);
          sprintf(ministr, "(%d%s)", b, same > 0 ? " same" : "");
          add_to_action(action, "mutate post xforms ");
          add_to_action(action, ministr);
          i = 0;
          for( ; !(i >= cp->num_xforms); i = i + 1)
          {
            signed int copy = (signed int)(i > 0 && same != 0);
            if(!(copy == 0))
            {
              j = 0;
              for( ; !(j >= 3); j = j + 1)
              {
                (cp->xform + (signed long int)i)->post[(signed long int)j][(signed long int)0] = (cp->xform + (signed long int)0)->post[(signed long int)j][(signed long int)0];
                (cp->xform + (signed long int)i)->post[(signed long int)j][(signed long int)1] = (cp->xform + (signed long int)0)->post[(signed long int)j][(signed long int)1];
              }
            }

            else
            {
              if(!((1 & b) == 0))
              {
                double flam3_mutate__1__5__1__1__2__1__f;
                double return_value_flam3_random_isaac_11_7;
                return_value_flam3_random_isaac_11_7=flam3_random_isaac_11(rc);
                flam3_mutate__1__5__1__1__2__1__f = 3.14159265358979323846 * return_value_flam3_random_isaac_11_7;
                double t[2l][2l];
                double return_value_cos_8;
                return_value_cos_8=cos(flam3_mutate__1__5__1__1__2__1__f);
                double return_value_sin_9;
                return_value_sin_9=sin(flam3_mutate__1__5__1__1__2__1__f);
                t[(signed long int)0][(signed long int)0] = (cp->xform + (signed long int)i)->c[(signed long int)0][(signed long int)0] * return_value_cos_8 + (cp->xform + (signed long int)i)->c[(signed long int)0][(signed long int)1] * -return_value_sin_9;
                double return_value_sin_10;
                return_value_sin_10=sin(flam3_mutate__1__5__1__1__2__1__f);
                double return_value_cos_11;
                return_value_cos_11=cos(flam3_mutate__1__5__1__1__2__1__f);
                t[(signed long int)0][(signed long int)1] = (cp->xform + (signed long int)i)->c[(signed long int)0][(signed long int)0] * return_value_sin_10 + (cp->xform + (signed long int)i)->c[(signed long int)0][(signed long int)1] * return_value_cos_11;
                double return_value_cos_12;
                return_value_cos_12=cos(flam3_mutate__1__5__1__1__2__1__f);
                double return_value_sin_13;
                return_value_sin_13=sin(flam3_mutate__1__5__1__1__2__1__f);
                t[(signed long int)1][(signed long int)0] = (cp->xform + (signed long int)i)->c[(signed long int)1][(signed long int)0] * return_value_cos_12 + (cp->xform + (signed long int)i)->c[(signed long int)1][(signed long int)1] * -return_value_sin_13;
                double return_value_sin_14;
                return_value_sin_14=sin(flam3_mutate__1__5__1__1__2__1__f);
                double return_value_cos_15;
                return_value_cos_15=cos(flam3_mutate__1__5__1__1__2__1__f);
                t[(signed long int)1][(signed long int)1] = (cp->xform + (signed long int)i)->c[(signed long int)1][(signed long int)0] * return_value_sin_14 + (cp->xform + (signed long int)i)->c[(signed long int)1][(signed long int)1] * return_value_cos_15;
                (cp->xform + (signed long int)i)->c[(signed long int)0][(signed long int)0] = t[(signed long int)0][(signed long int)0];
                (cp->xform + (signed long int)i)->c[(signed long int)0][(signed long int)1] = t[(signed long int)0][(signed long int)1];
                (cp->xform + (signed long int)i)->c[(signed long int)1][(signed long int)0] = t[(signed long int)1][(signed long int)0];
                (cp->xform + (signed long int)i)->c[(signed long int)1][(signed long int)1] = t[(signed long int)1][(signed long int)1];
                flam3_mutate__1__5__1__1__2__1__f = flam3_mutate__1__5__1__1__2__1__f * -1.0;
                double return_value_cos_16;
                return_value_cos_16=cos(flam3_mutate__1__5__1__1__2__1__f);
                double return_value_sin_17;
                return_value_sin_17=sin(flam3_mutate__1__5__1__1__2__1__f);
                t[(signed long int)0][(signed long int)0] = (cp->xform + (signed long int)i)->post[(signed long int)0][(signed long int)0] * return_value_cos_16 + (cp->xform + (signed long int)i)->post[(signed long int)0][(signed long int)1] * -return_value_sin_17;
                double return_value_sin_18;
                return_value_sin_18=sin(flam3_mutate__1__5__1__1__2__1__f);
                double return_value_cos_19;
                return_value_cos_19=cos(flam3_mutate__1__5__1__1__2__1__f);
                t[(signed long int)0][(signed long int)1] = (cp->xform + (signed long int)i)->post[(signed long int)0][(signed long int)0] * return_value_sin_18 + (cp->xform + (signed long int)i)->post[(signed long int)0][(signed long int)1] * return_value_cos_19;
                double return_value_cos_20;
                return_value_cos_20=cos(flam3_mutate__1__5__1__1__2__1__f);
                double return_value_sin_21;
                return_value_sin_21=sin(flam3_mutate__1__5__1__1__2__1__f);
                t[(signed long int)1][(signed long int)0] = (cp->xform + (signed long int)i)->post[(signed long int)1][(signed long int)0] * return_value_cos_20 + (cp->xform + (signed long int)i)->post[(signed long int)1][(signed long int)1] * -return_value_sin_21;
                double return_value_sin_22;
                return_value_sin_22=sin(flam3_mutate__1__5__1__1__2__1__f);
                double return_value_cos_23;
                return_value_cos_23=cos(flam3_mutate__1__5__1__1__2__1__f);
                t[(signed long int)1][(signed long int)1] = (cp->xform + (signed long int)i)->post[(signed long int)1][(signed long int)0] * return_value_sin_22 + (cp->xform + (signed long int)i)->post[(signed long int)1][(signed long int)1] * return_value_cos_23;
                (cp->xform + (signed long int)i)->post[(signed long int)0][(signed long int)0] = t[(signed long int)0][(signed long int)0];
                (cp->xform + (signed long int)i)->post[(signed long int)0][(signed long int)1] = t[(signed long int)0][(signed long int)1];
                (cp->xform + (signed long int)i)->post[(signed long int)1][(signed long int)0] = t[(signed long int)1][(signed long int)0];
                (cp->xform + (signed long int)i)->post[(signed long int)1][(signed long int)1] = t[(signed long int)1][(signed long int)1];
              }

              if(!((2 & b) == 0))
              {
                double f;
                double return_value_flam3_random_isaac_01_24;
                return_value_flam3_random_isaac_01_24=flam3_random_isaac_01(rc);
                f = 0.2 + return_value_flam3_random_isaac_01_24;
                double g;
                double return_value_flam3_random_isaac_01_25;
                return_value_flam3_random_isaac_01_25=flam3_random_isaac_01(rc);
                g = 0.2 + return_value_flam3_random_isaac_01_25;
                signed int return_value_flam3_random_isaac_bit_26;
                return_value_flam3_random_isaac_bit_26=flam3_random_isaac_bit(rc);
                if(!(return_value_flam3_random_isaac_bit_26 == 0))
                  f = 1.0 / f;

                signed int return_value_flam3_random_isaac_bit_28;
                return_value_flam3_random_isaac_bit_28=flam3_random_isaac_bit(rc);
                if(!(return_value_flam3_random_isaac_bit_28 == 0))
                  g = f;

                else
                {
                  signed int return_value_flam3_random_isaac_bit_27;
                  return_value_flam3_random_isaac_bit_27=flam3_random_isaac_bit(rc);
                  if(!(return_value_flam3_random_isaac_bit_27 == 0))
                    g = 1.0 / g;

                }
                (cp->xform + (signed long int)i)->c[(signed long int)0][(signed long int)0] = (cp->xform + (signed long int)i)->c[(signed long int)0][(signed long int)0] / f;
                (cp->xform + (signed long int)i)->c[(signed long int)0][(signed long int)1] = (cp->xform + (signed long int)i)->c[(signed long int)0][(signed long int)1] / f;
                (cp->xform + (signed long int)i)->c[(signed long int)1][(signed long int)1] = (cp->xform + (signed long int)i)->c[(signed long int)1][(signed long int)1] / g;
                (cp->xform + (signed long int)i)->c[(signed long int)1][(signed long int)0] = (cp->xform + (signed long int)i)->c[(signed long int)1][(signed long int)0] / g;
                (cp->xform + (signed long int)i)->post[(signed long int)0][(signed long int)0] = (cp->xform + (signed long int)i)->post[(signed long int)0][(signed long int)0] * f;
                (cp->xform + (signed long int)i)->post[(signed long int)1][(signed long int)0] = (cp->xform + (signed long int)i)->post[(signed long int)1][(signed long int)0] * f;
                (cp->xform + (signed long int)i)->post[(signed long int)0][(signed long int)1] = (cp->xform + (signed long int)i)->post[(signed long int)0][(signed long int)1] * g;
                (cp->xform + (signed long int)i)->post[(signed long int)1][(signed long int)1] = (cp->xform + (signed long int)i)->post[(signed long int)1][(signed long int)1] * g;
              }

              if(!((4 & b) == 0))
              {
                double flam3_mutate__1__5__1__1__2__3__f;
                flam3_mutate__1__5__1__1__2__3__f=flam3_random_isaac_11(rc);
                double flam3_mutate__1__5__1__1__2__3__g;
                flam3_mutate__1__5__1__1__2__3__g=flam3_random_isaac_11(rc);
                (cp->xform + (signed long int)i)->c[(signed long int)2][(signed long int)0] = (cp->xform + (signed long int)i)->c[(signed long int)2][(signed long int)0] - flam3_mutate__1__5__1__1__2__3__f;
                (cp->xform + (signed long int)i)->c[(signed long int)2][(signed long int)1] = (cp->xform + (signed long int)i)->c[(signed long int)2][(signed long int)1] - flam3_mutate__1__5__1__1__2__3__g;
                (cp->xform + (signed long int)i)->post[(signed long int)2][(signed long int)0] = (cp->xform + (signed long int)i)->post[(signed long int)2][(signed long int)0] + flam3_mutate__1__5__1__1__2__3__f;
                (cp->xform + (signed long int)i)->post[(signed long int)2][(signed long int)1] = (cp->xform + (signed long int)i)->post[(signed long int)2][(signed long int)1] + flam3_mutate__1__5__1__1__2__3__g;
              }

            }
          }
        }

        else
          if(mutate_mode == 4)
          {
            double s;
            s=flam3_random_isaac_01(rc);
            if(s < 0.4)
            {
              flam3_improve_colors(cp, 100, 0, 10);
              add_to_action(action, "mutate color coords");
            }

            else
              if(s < 0.8)
              {
                flam3_improve_colors(cp, 25, 1, 10);
                add_to_action(action, "mutate color all");
              }

              else
              {
                cp->palette_index=flam3_get_palette(-1, cp->palette, cp->hue_rotation);
                if(cp->palette_index >= 0)
                  add_to_action(action, "mutate color palette");

                else
                  fprintf(stderr, "failure getting random palette, palette set to white\n");
              }
          }

          else
            if(mutate_mode == 5)
            {
              signed int nx;
              tmp_post_29 = rc->randcnt;
              rc->randcnt = rc->randcnt - 1ul;
              if(tmp_post_29 == 0ul)
              {
                isaac(rc);
                rc->randcnt = (unsigned long int)((1 << 4) - 1);
                tmp_if_expr_30 = rc->randrsl[(signed long int)rc->randcnt];
              }

              else
                tmp_if_expr_30 = rc->randrsl[(signed long int)rc->randcnt];
              nx = (signed int)((unsigned int)tmp_if_expr_30 % (unsigned int)cp->num_xforms);
              sprintf(ministr, "%d", nx);
              add_to_action(action, "mutate delete xform ");
              add_to_action(action, ministr);
              if(cp->num_xforms >= 2)
                flam3_delete_xform(cp, nx);

            }

            else
            {
              signed int x;
              add_to_action(action, "mutate all coefs");
              flam3_random(&mutation, ivars, ivars_n, sym, cp->num_xforms);
              x = 0;
              for( ; !(x >= cp->num_xforms); x = x + 1)
              {
                i = 0;
                for( ; !(i >= 3); i = i + 1)
                {
                  j = 0;
                  for( ; !(j >= 2); j = j + 1)
                    (cp->xform + (signed long int)x)->c[(signed long int)i][(signed long int)j] = (cp->xform + (signed long int)x)->c[(signed long int)i][(signed long int)j] + speed * (mutation.xform + (signed long int)x)->c[(signed long int)i][(signed long int)j];
                }
              }
            }
  clear_cp(&mutation, 1);
}

// flam3_parse_from_file
// file flam3.h line 572
struct anonymous_0 * flam3_parse_from_file(struct _IO_FILE *f, char *fname, signed int default_flag, signed int *ncps)
{
  signed int i;
  signed int c;
  signed int slen = 5000;
  char *s;
  char *snew;
  struct anonymous_0 *ret;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc((unsigned long int)slen);
  s = (char *)return_value_malloc_1;
  i = 0;
  signed int tmp_post_2;
  do
  {
    c=_IO_getc(f);
    if(c == -1)
      break;

    tmp_post_2 = i;
    i = i + 1;
    s[(signed long int)tmp_post_2] = (char)c;
    if(i == slen + -1)
    {
      slen = slen * 2;
      void *return_value_realloc_3;
      return_value_realloc_3=realloc((void *)s, (unsigned long int)slen);
      snew = (char *)return_value_realloc_3;
      if(snew == ((char *)NULL))
      {
        fprintf(stderr, "XML file too large to be read. continuing with partial file.\n");
        break;
      }

      else
        s = snew;
    }

  }
  while((_Bool)1);
  s[(signed long int)i] = (char)0;
  if(!(fname == ((char *)NULL)))
    ret=flam3_parse_xml2(s, fname, default_flag, ncps);

  else
    ret=flam3_parse_xml2(s, "stdin", default_flag, ncps);
  free((void *)s);
  return ret;
}

// flam3_parse_hexformat_colors
// file parser.c line 83
signed int flam3_parse_hexformat_colors(char *colstr, struct anonymous_0 *cp, signed int numcolors, signed int chan)
{
  signed int c_idx = 0;
  signed int col_count = 0;
  signed int r;
  signed int g;
  signed int b;
  signed int a;
  signed int sscanf_ret;
  char tmps[2l];
  signed int skip;
  double return_value_fabs_1;
  return_value_fabs_1=fabs((double)chan);
  skip = (signed int)return_value_fabs_1;
  const unsigned short int **return_value___ctype_b_loc_2;
  do
  {
    return_value___ctype_b_loc_2=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)colstr[(signed long int)c_idx]]) == 0)
      break;

    c_idx = c_idx + 1;
  }
  while((_Bool)1);
  const unsigned short int **return_value___ctype_b_loc_3;
  do
  {
    a = 255;
    if(chan == 3)
      sscanf_ret=sscanf(&colstr[(signed long int)c_idx], "%2x%2x%2x", &r, &g, &b);

    else
      if(chan == -4)
        sscanf_ret=sscanf(&colstr[(signed long int)c_idx], "00%2x%2x%2x", &r, &g, &b);

      else
        sscanf_ret=sscanf(&colstr[(signed long int)c_idx], "%2x%2x%2x%2x", &r, &g, &b, &a);
    if(chan == 4 && !(sscanf_ret == 4) || !(sscanf_ret == 3) && !(chan == 4))
    {
      fprintf(stderr, "Error:  Problem reading hexadecimal color data.\n");
      return 1;
    }

    c_idx = c_idx + 2 * skip;
    do
    {
      return_value___ctype_b_loc_3=__ctype_b_loc();
      if((8192 & (signed int)(*return_value___ctype_b_loc_3)[(signed long int)(signed int)colstr[(signed long int)c_idx]]) == 0)
        break;

      c_idx = c_idx + 1;
    }
    while((_Bool)1);
    cp->palette[(signed long int)col_count].color[(signed long int)0] = (double)r / 255.0;
    cp->palette[(signed long int)col_count].color[(signed long int)1] = (double)g / 255.0;
    cp->palette[(signed long int)col_count].color[(signed long int)2] = (double)b / 255.0;
    cp->palette[(signed long int)col_count].color[(signed long int)3] = (double)a / 255.0;
    cp->palette[(signed long int)col_count].index = (double)col_count;
    col_count = col_count + 1;
  }
  while(!(col_count >= numcolors));
  signed int return_value_sscanf_4;
  return_value_sscanf_4=sscanf(&colstr[(signed long int)c_idx], "%1s", (const void *)tmps);
  if(return_value_sscanf_4 >= 1)
  {
    fprintf(stderr, "error: extra data at end of hex color data '%s'\n", &colstr[(signed long int)c_idx]);
    return 1;
  }

  else
    return 0;
}

// flam3_parse_xml2
// file flam3.c line 1396
struct anonymous_0 * flam3_parse_xml2(char *xmldata, char *xmlfilename, signed int default_flag, signed int *ncps)
{
  struct _xmlDoc *doc;
  struct _xmlNode *rootnode;
  char *bn;
  signed int i;
  signed int loc_all_ncps = 0;
  struct anonymous_0 *loc_all_cp = (struct anonymous_0 *)(void *)0;
  char *locale = (char *)(void *)0;
  char *lorig;
  lorig=setlocale(1, (const char *)(void *)0);
  unsigned long int return_value_strlen_1;
  return_value_strlen_1=strlen(xmldata);
  doc=xmlReadMemory(xmldata, (signed int)return_value_strlen_1, xmlfilename, (const char *)(void *)0, 2048);
  if(doc == ((struct _xmlDoc *)NULL))
  {
    fprintf(stderr, "Failed to parse %s\n", xmlfilename);
    return (struct anonymous_0 *)(void *)0;
  }

  else
  {
    rootnode=xmlDocGetRootElement(doc);
    if(lorig == ((char *)NULL))
      fprintf(stderr, "error: couldn't get current locale\n");

    else
    {
      signed int slen;
      unsigned long int return_value_strlen_2;
      return_value_strlen_2=strlen(lorig);
      slen = (signed int)(return_value_strlen_2 + (unsigned long int)1);
      void *return_value_malloc_3;
      return_value_malloc_3=malloc((unsigned long int)slen);
      locale = (char *)return_value_malloc_3;
      if(!(locale == ((char *)NULL)))
        memcpy((void *)locale, (const void *)lorig, (unsigned long int)slen);

    }
    char *return_value_setlocale_4;
    return_value_setlocale_4=setlocale(1, "C");
    if(return_value_setlocale_4 == ((char *)NULL))
      fprintf(stderr, "error: couldn't set C locale\n");

    bn=__xpg_basename(xmlfilename);
    scan_for_flame_nodes(rootnode, bn, default_flag, &loc_all_cp, &loc_all_ncps);
    if(!(locale == ((char *)NULL)))
    {
      char *return_value_setlocale_5;
      return_value_setlocale_5=setlocale(1, locale);
      if(return_value_setlocale_5 == ((char *)NULL))
        fprintf(stderr, "error: couldn't replace locale settings\n");

      free((void *)locale);
    }

    xmlFreeDoc(doc);
    *ncps = loc_all_ncps;
    if(loc_all_ncps >= 1)
    {
      if(loc_all_cp->interpolation == 1)
      {
        fprintf(stderr, "Warning: smooth interpolation cannot be used for first segment.\n         switching to linear.\n");
        (loc_all_cp + (signed long int)0)->interpolation = 0;
      }

    }

    if(loc_all_ncps >= 2)
    {
      if((loc_all_cp + (signed long int)(loc_all_ncps + -2))->interpolation == 1)
      {
        fprintf(stderr, "Warning: smooth interpolation cannot be used for last segment.\n         switching to linear.\n");
        (loc_all_cp + (signed long int)(loc_all_ncps - 2))->interpolation = 0;
      }

    }

    if(*ncps >= 2)
    {
      i = 1;
      for( ; !(i >= *ncps); i = i + 1)
        if(!((loc_all_cp + (signed long int)(i + -1))->interpolation_type == 2))
        {
          if(!((loc_all_cp + (signed long int)(i + -1))->interpolation_type == 3))
          {
            for( ; (loc_all_cp + (signed long int)i)->rotate < (loc_all_cp + (signed long int)(i + -1))->rotate + -180.000000; (loc_all_cp + (signed long int)i)->rotate = (loc_all_cp + (signed long int)i)->rotate + (double)360)
              ;
            for( ; (loc_all_cp + (signed long int)i)->rotate > (loc_all_cp + (signed long int)(i + -1))->rotate + 180.000000; (loc_all_cp + (signed long int)i)->rotate = (loc_all_cp + (signed long int)i)->rotate - (double)360)
              ;
          }

        }

    }

    return loc_all_cp;
  }
}

// flam3_print
// file flam3.h line 555
void flam3_print(struct _IO_FILE *f, struct anonymous_0 *cp, char *extra_attributes, signed int print_edits)
{
  signed int i;
  signed int numstd;
  signed int flam27_flag;
  char *ai;
  char *locale = (char *)(void *)0;
  char *lorig;
  lorig=setlocale(1, (const char *)(void *)0);
  if(lorig == ((char *)NULL))
    fprintf(stderr, "error: couldn't get current locale\n");

  else
  {
    signed int slen;
    unsigned long int return_value_strlen_1;
    return_value_strlen_1=strlen(lorig);
    slen = (signed int)(return_value_strlen_1 + (unsigned long int)1);
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)slen);
    locale = (char *)return_value_malloc_2;
    if(!(locale == ((char *)NULL)))
      memcpy((void *)locale, (const void *)lorig, (unsigned long int)slen);

  }
  char *return_value_setlocale_3;
  return_value_setlocale_3=setlocale(1, "C");
  if(return_value_setlocale_3 == ((char *)NULL))
    fprintf(stderr, "error: couldn't set C locale\n");

  ai=getenv("flam27");
  signed int tmp_if_expr_5;
  signed int return_value_atoi_4;
  if(!(ai == ((char *)NULL)))
  {
    return_value_atoi_4=atoi_link1(ai);
    tmp_if_expr_5 = return_value_atoi_4;
  }

  else
    tmp_if_expr_5 = 0;
  flam27_flag = tmp_if_expr_5;
  char *return_value_flam3_version_6;
  return_value_flam3_version_6=flam3_version();
  fprintf(f, "<flame version=\"FLAM3-%s\" time=\"%g\"", return_value_flam3_version_6, cp->time);
  if(!((signed int)cp->flame_name[0l] == 0))
    fprintf(f, " name=\"%s\"", (const void *)cp->flame_name);

  fprintf(f, " size=\"%d %d\"", cp->width, cp->height);
  fprintf(f, " center=\"%g %g\"", cp->center[(signed long int)0], cp->center[(signed long int)1]);
  fprintf(f, " scale=\"%g\"", cp->pixels_per_unit);
  if(IEEE_FLOAT_NOTEQUAL(cp->zoom, 0.0))
    fprintf(f, " zoom=\"%g\"", cp->zoom);

  fprintf(f, " rotate=\"%g\"", cp->rotate);
  fprintf(f, " supersample=\"%d\"", cp->spatial_oversample);
  fprintf(f, " filter=\"%g\"", cp->spatial_filter_radius);
  if(cp->spatial_filter_select == 0)
    fprintf(f, " filter_shape=\"gaussian\"");

  else
    if(cp->spatial_filter_select == 1)
      fprintf(f, " filter_shape=\"hermite\"");

    else
      if(cp->spatial_filter_select == 2)
        fprintf(f, " filter_shape=\"box\"");

      else
        if(cp->spatial_filter_select == 3)
          fprintf(f, " filter_shape=\"triangle\"");

        else
          if(cp->spatial_filter_select == 4)
            fprintf(f, " filter_shape=\"bell\"");

          else
            if(cp->spatial_filter_select == 5)
              fprintf(f, " filter_shape=\"bspline\"");

            else
              if(cp->spatial_filter_select == 8)
                fprintf(f, " filter_shape=\"mitchell\"");

              else
                if(cp->spatial_filter_select == 9)
                  fprintf(f, " filter_shape=\"blackman\"");

                else
                  if(cp->spatial_filter_select == 10)
                    fprintf(f, " filter_shape=\"catrom\"");

                  else
                    if(cp->spatial_filter_select == 12)
                      fprintf(f, " filter_shape=\"hanning\"");

                    else
                      if(cp->spatial_filter_select == 11)
                        fprintf(f, " filter_shape=\"hamming\"");

                      else
                        if(cp->spatial_filter_select == 6)
                          fprintf(f, " filter_shape=\"lanczos3\"");

                        else
                          if(cp->spatial_filter_select == 7)
                            fprintf(f, " filter_shape=\"lanczos2\"");

                          else
                            if(cp->spatial_filter_select == 13)
                              fprintf(f, " filter_shape=\"quadratic\"");

  if(cp->temporal_filter_type == 0)
    fprintf(f, " temporal_filter_type=\"box\"");

  else
    if(cp->temporal_filter_type == 1)
      fprintf(f, " temporal_filter_type=\"gaussian\"");

    else
      if(cp->temporal_filter_type == 2)
        fprintf(f, " temporal_filter_type=\"exp\" temporal_filter_exp=\"%g\"", cp->temporal_filter_exp);

  fprintf(f, " temporal_filter_width=\"%g\"", cp->temporal_filter_width);
  fprintf(f, " quality=\"%g\"", cp->sample_density);
  fprintf(f, " passes=\"%d\"", cp->nbatches);
  fprintf(f, " temporal_samples=\"%d\"", cp->ntemporal_samples);
  fprintf(f, " background=\"%g %g %g\"", cp->background[(signed long int)0], cp->background[(signed long int)1], cp->background[(signed long int)2]);
  fprintf(f, " brightness=\"%g\"", cp->brightness);
  fprintf(f, " gamma=\"%g\"", cp->gamma);
  if(flam27_flag == 0)
    fprintf(f, " highlight_power=\"%g\"", cp->highlight_power);

  fprintf(f, " vibrancy=\"%g\"", cp->vibrancy);
  fprintf(f, " estimator_radius=\"%g\" estimator_minimum=\"%g\" estimator_curve=\"%g\"", cp->estimator, cp->estimator_minimum, cp->estimator_curve);
  fprintf(f, " gamma_threshold=\"%g\"", cp->gam_lin_thresh);
  if(cp->palette_mode == 0)
    fprintf(f, " palette_mode=\"step\"");

  else
    if(cp->palette_mode == 1)
      fprintf(f, " palette_mode=\"linear\"");

  if(!(cp->interpolation == 0))
    fprintf(f, " interpolation=\"smooth\"");

  if(cp->interpolation_type == 0)
    fprintf(f, " interpolation_type=\"linear\"");

  else
    if(cp->interpolation_type == 1)
      fprintf(f, " interpolation_type=\"log\"");

    else
      if(cp->interpolation_type == 2)
        fprintf(f, " interpolation_type=\"old\"");

      else
        if(cp->interpolation_type == 3)
          fprintf(f, " interpolation_type=\"older\"");

  if(!(cp->palette_interpolation == 0))
    fprintf(f, " palette_interpolation=\"sweep\"");

  if(!(extra_attributes == ((char *)NULL)))
    fprintf(f, " %s", extra_attributes);

  fprintf(f, ">\n");
  if(!(cp->symmetry == 0))
    fprintf(f, "   <symmetry kind=\"%d\"/>\n", cp->symmetry);

  numstd = cp->num_xforms - (signed int)(cp->final_xform_index >= 0);
  i = 0;
  for( ; !(i >= cp->num_xforms); i = i + 1)
    if(i == cp->final_xform_index)
      flam3_print_xform(f, &cp->xform[(signed long int)i], 1, numstd, (double *)(void *)0, 0);

    else
      flam3_print_xform(f, &cp->xform[(signed long int)i], 0, numstd, cp->chaos[(signed long int)i], 0);
  i = 0;
  double return_value_rint_7;
  double return_value_rint_8;
  double return_value_rint_9;
  double return_value_rint_11;
  double return_value_rint_12;
  double return_value_rint_13;
  double return_value_rint_14;
  for( ; !(i >= 256); i = i + 1)
  {
    double r;
    double g;
    double b;
    double a;
    r = cp->palette[(signed long int)i].color[(signed long int)0] * 255.0;
    g = cp->palette[(signed long int)i].color[(signed long int)1] * 255.0;
    b = cp->palette[(signed long int)i].color[(signed long int)2] * 255.0;
    a = cp->palette[(signed long int)i].color[(signed long int)3] * 255.0;
    fprintf(f, "   ");
    if(IEEE_FLOAT_EQUAL(a, 255.0) || !(flam27_flag == 0))
    {
      if(IEEE_FLOAT_NOTEQUAL(a, 255.0) && !(flam27_flag == 0))
        fprintf(stderr, "alpha channel in palette cannot be stored in 2.7 compatibility mode; truncating\n");

      char *return_value_getenv_10;
      return_value_getenv_10=getenv("intpalette");
      if(!(return_value_getenv_10 == ((char *)NULL)))
      {
        return_value_rint_7=rint(r);
        return_value_rint_8=rint(g);
        return_value_rint_9=rint(b);
        fprintf(f, "<color index=\"%d\" rgb=\"%d %d %d\"/>", i, (signed int)return_value_rint_7, (signed int)return_value_rint_8, (signed int)return_value_rint_9);
      }

      else
        fprintf(f, "<color index=\"%d\" rgb=\"%.6g %.6g %.6g\"/>", i, r, g, b);
    }

    else
    {
      char *return_value_getenv_15;
      return_value_getenv_15=getenv("intpalette");
      if(!(return_value_getenv_15 == ((char *)NULL)))
      {
        return_value_rint_11=rint(r);
        return_value_rint_12=rint(g);
        return_value_rint_13=rint(b);
        return_value_rint_14=rint(a);
        fprintf(f, "   <color index=\"%d\" rgba=\"%d %d %d %d\"/>", i, (signed int)return_value_rint_11, (signed int)return_value_rint_12, (signed int)return_value_rint_13, (signed int)return_value_rint_14);
      }

      else
        fprintf(f, "   <color index=\"%d\" rgba=\"%.6g %.6g %.6g %.6g\"/>", i, r, g, b, a);
    }
    fprintf(f, "\n");
  }
  if(!(cp->edits == ((struct _xmlDoc *)NULL)))
  {
    if(print_edits == 1)
    {
      struct _xmlNode *elem_node;
      elem_node=xmlDocGetRootElement(cp->edits);
      flam3_edit_print(f, elem_node, 1, 1);
    }

  }

  fprintf(f, "</flame>\n");
  if(!(locale == ((char *)NULL)))
  {
    char *return_value_setlocale_16;
    return_value_setlocale_16=setlocale(1, locale);
    if(return_value_setlocale_16 == ((char *)NULL))
      fprintf(stderr, "error: couldn't restore locale settings\n");

    free((void *)locale);
  }

}

// flam3_print_to_string
// file flam3.c line 1596
char * flam3_print_to_string(struct anonymous_0 *cp)
{
  struct _IO_FILE *tmpflame;
  signed long int stringbytes;
  char *genome_string;
  tmpflame=tmpfile();
  flam3_print(tmpflame, cp, (char *)(void *)0, 0);
  stringbytes=ftell(tmpflame);
  fseek(tmpflame, 0L, 0);
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)(stringbytes + (signed long int)1), (unsigned long int)1);
  genome_string = (char *)return_value_calloc_1;
  unsigned long int return_value_fread_2;
  return_value_fread_2=fread((void *)genome_string, (unsigned long int)1, (unsigned long int)stringbytes, tmpflame);
  if(!((unsigned long int)stringbytes == return_value_fread_2))
    perror("FLAM3: reading string from temp file");

  fclose(tmpflame);
  return genome_string;
}

// flam3_print_xform
// file flam3.c line 1806
void flam3_print_xform(struct _IO_FILE *f, struct xform *x, signed int final_flag, signed int numstd, double *chaos_row, signed int motion_flag)
{
  signed int blob_var = 0;
  signed int pdj_var = 0;
  signed int fan2_var = 0;
  signed int rings2_var = 0;
  signed int perspective_var = 0;
  signed int juliaN_var = 0;
  signed int juliaScope_var = 0;
  signed int radialBlur_var = 0;
  signed int pie_var = 0;
  signed int disc2_var = 0;
  signed int ngon_var = 0;
  signed int curl_var = 0;
  signed int rectangles_var = 0;
  signed int supershape_var = 0;
  signed int flower_var = 0;
  signed int conic_var = 0;
  signed int parabola_var = 0;
  signed int bent2_var = 0;
  signed int bipolar_var = 0;
  signed int cell_var = 0;
  signed int cpow_var = 0;
  signed int curve_var = 0;
  signed int escher_var = 0;
  signed int lazys_var = 0;
  signed int modulus_var = 0;
  signed int oscope_var = 0;
  signed int popcorn2_var = 0;
  signed int separation_var = 0;
  signed int split_var = 0;
  signed int splits_var = 0;
  signed int stripes_var = 0;
  signed int wedge_var = 0;
  signed int wedgeJ_var = 0;
  signed int wedgeS_var = 0;
  signed int whorl_var = 0;
  signed int waves2_var = 0;
  signed int auger_var = 0;
  signed int flux_var = 0;
  signed int j;
  signed int lnv;
  signed int flam27_flag;
  char *ai;
  ai=getenv("flam27");
  signed int tmp_if_expr_2;
  signed int return_value_atoi_1;
  if(!(ai == ((char *)NULL)))
  {
    return_value_atoi_1=atoi_link1(ai);
    tmp_if_expr_2 = return_value_atoi_1;
  }

  else
    tmp_if_expr_2 = 0;
  flam27_flag = tmp_if_expr_2;
  if(!(motion_flag == 0))
  {
    fprintf(f, "      <motion motion_frequency=\"%d\" ", x->motion_freq);
    if(x->motion_func == 1)
      fprintf(f, "motion_function=\"sin\" ");

    else
      if(x->motion_func == 2)
        fprintf(f, "motion_function=\"triangle\" ");

      else
        if(x->motion_func == 3)
          fprintf(f, "motion_function=\"hill\" ");

  }

  else
    if(!(final_flag == 0))
      fprintf(f, "   <finalxform ");

    else
      fprintf(f, "   <xform weight=\"%g\" ", x->density);
  _Bool tmp_if_expr_3;
  if(motion_flag == 0)
    tmp_if_expr_3 = (_Bool)1;

  else
    tmp_if_expr_3 = IEEE_FLOAT_NOTEQUAL(x->color, 0.0) ? (_Bool)1 : (_Bool)0;
  if(tmp_if_expr_3)
    fprintf(f, "color=\"%g\" ", x->color);

  if(!(flam27_flag == 0))
    fprintf(f, "symmetry=\"%g\" ", 1.0 - 2.0 * x->color_speed);

  else
    if(motion_flag == 0)
      fprintf(f, "color_speed=\"%g\" ", x->color_speed);

  if(flam27_flag == 0 && final_flag == 0 && motion_flag == 0)
    fprintf(f, "animate=\"%g\" ", x->animate);

  lnv = flam27_flag != 0 ? 54 : 98;
  j = 0;
  for( ; !(j >= lnv); j = j + 1)
  {
    double v = x->var[(signed long int)j];
    if(IEEE_FLOAT_NOTEQUAL(0.0, v))
    {
      fprintf(f, "%s=\"%g\" ", flam3_variation_names[(signed long int)j], v);
      if(j == 23)
        blob_var = 1;

      else
        if(j == 24)
          pdj_var = 1;

        else
          if(j == 25)
            fan2_var = 1;

          else
            if(j == 26)
              rings2_var = 1;

            else
              if(j == 30)
                perspective_var = 1;

              else
                if(j == 32)
                  juliaN_var = 1;

                else
                  if(j == 33)
                    juliaScope_var = 1;

                  else
                    if(j == 36)
                      radialBlur_var = 1;

                    else
                      if(j == 37)
                        pie_var = 1;

                      else
                        if(j == 38)
                          ngon_var = 1;

                        else
                          if(j == 39)
                            curl_var = 1;

                          else
                            if(j == 40)
                              rectangles_var = 1;

                            else
                              if(j == 49)
                                disc2_var = 1;

                              else
                                if(j == 50)
                                  supershape_var = 1;

                                else
                                  if(j == 51)
                                    flower_var = 1;

                                  else
                                    if(j == 52)
                                      conic_var = 1;

                                    else
                                      if(j == 53)
                                        parabola_var = 1;

                                      else
                                        if(j == 54)
                                          bent2_var = 1;

                                        else
                                          if(j == 55)
                                            bipolar_var = 1;

                                          else
                                            if(j == 58)
                                              cell_var = 1;

                                            else
                                              if(j == 59)
                                                cpow_var = 1;

                                              else
                                                if(j == 60)
                                                  curve_var = 1;

                                                else
                                                  if(j == 63)
                                                    escher_var = 1;

                                                  else
                                                    if(j == 65)
                                                      lazys_var = 1;

                                                    else
                                                      if(j == 68)
                                                        modulus_var = 1;

                                                      else
                                                        if(j == 69)
                                                          oscope_var = 1;

                                                        else
                                                          if(j == 71)
                                                            popcorn2_var = 1;

                                                          else
                                                            if(j == 74)
                                                              split_var = 1;

                                                            else
                                                              if(j == 75)
                                                                splits_var = 1;

                                                              else
                                                                if(j == 76)
                                                                  stripes_var = 1;

                                                                else
                                                                  if(j == 77)
                                                                    wedge_var = 1;

                                                                  else
                                                                    if(j == 78)
                                                                      wedgeJ_var = 1;

                                                                    else
                                                                      if(j == 79)
                                                                        wedgeS_var = 1;

                                                                      else
                                                                        if(j == 80)
                                                                          whorl_var = 1;

                                                                        else
                                                                          if(j == 81)
                                                                            waves2_var = 1;

                                                                          else
                                                                            if(j == 96)
                                                                              auger_var = 1;

                                                                            else
                                                                              if(j == 97)
                                                                                flux_var = 1;

    }

  }
  if(motion_flag == 0)
  {
    if(blob_var == 1)
    {
      fprintf(f, "blob_low=\"%g\" ", x->blob_low);
      fprintf(f, "blob_high=\"%g\" ", x->blob_high);
      fprintf(f, "blob_waves=\"%g\" ", x->blob_waves);
    }

    if(pdj_var == 1)
    {
      fprintf(f, "pdj_a=\"%g\" ", x->pdj_a);
      fprintf(f, "pdj_b=\"%g\" ", x->pdj_b);
      fprintf(f, "pdj_c=\"%g\" ", x->pdj_c);
      fprintf(f, "pdj_d=\"%g\" ", x->pdj_d);
    }

    if(fan2_var == 1)
    {
      fprintf(f, "fan2_x=\"%g\" ", x->fan2_x);
      fprintf(f, "fan2_y=\"%g\" ", x->fan2_y);
    }

    if(rings2_var == 1)
      fprintf(f, "rings2_val=\"%g\" ", x->rings2_val);

    if(perspective_var == 1)
    {
      fprintf(f, "perspective_angle=\"%g\" ", x->perspective_angle);
      fprintf(f, "perspective_dist=\"%g\" ", x->perspective_dist);
    }

    if(juliaN_var == 1)
    {
      fprintf(f, "julian_power=\"%g\" ", x->julian_power);
      fprintf(f, "julian_dist=\"%g\" ", x->julian_dist);
    }

    if(juliaScope_var == 1)
    {
      fprintf(f, "juliascope_power=\"%g\" ", x->juliascope_power);
      fprintf(f, "juliascope_dist=\"%g\" ", x->juliascope_dist);
    }

    if(radialBlur_var == 1)
      fprintf(f, "radial_blur_angle=\"%g\" ", x->radial_blur_angle);

    if(pie_var == 1)
    {
      fprintf(f, "pie_slices=\"%g\" ", x->pie_slices);
      fprintf(f, "pie_rotation=\"%g\" ", x->pie_rotation);
      fprintf(f, "pie_thickness=\"%g\" ", x->pie_thickness);
    }

    if(ngon_var == 1)
    {
      fprintf(f, "ngon_sides=\"%g\" ", x->ngon_sides);
      fprintf(f, "ngon_power=\"%g\" ", x->ngon_power);
      fprintf(f, "ngon_corners=\"%g\" ", x->ngon_corners);
      fprintf(f, "ngon_circle=\"%g\" ", x->ngon_circle);
    }

    if(curl_var == 1)
    {
      fprintf(f, "curl_c1=\"%g\" ", x->curl_c1);
      fprintf(f, "curl_c2=\"%g\" ", x->curl_c2);
    }

    if(rectangles_var == 1)
    {
      fprintf(f, "rectangles_x=\"%g\" ", x->rectangles_x);
      fprintf(f, "rectangles_y=\"%g\" ", x->rectangles_y);
    }

    if(disc2_var == 1)
    {
      fprintf(f, "disc2_rot=\"%g\" ", x->disc2_rot);
      fprintf(f, "disc2_twist=\"%g\" ", x->disc2_twist);
    }

    if(supershape_var == 1)
    {
      fprintf(f, "super_shape_rnd=\"%g\" ", x->super_shape_rnd);
      fprintf(f, "super_shape_m=\"%g\" ", x->super_shape_m);
      fprintf(f, "super_shape_n1=\"%g\" ", x->super_shape_n1);
      fprintf(f, "super_shape_n2=\"%g\" ", x->super_shape_n2);
      fprintf(f, "super_shape_n3=\"%g\" ", x->super_shape_n3);
      fprintf(f, "super_shape_holes=\"%g\" ", x->super_shape_holes);
    }

    if(flower_var == 1)
    {
      fprintf(f, "flower_petals=\"%g\" ", x->flower_petals);
      fprintf(f, "flower_holes=\"%g\" ", x->flower_holes);
    }

    if(conic_var == 1)
    {
      fprintf(f, "conic_eccentricity=\"%g\" ", x->conic_eccentricity);
      fprintf(f, "conic_holes=\"%g\" ", x->conic_holes);
    }

    if(parabola_var == 1)
    {
      fprintf(f, "parabola_height=\"%g\" ", x->parabola_height);
      fprintf(f, "parabola_width=\"%g\" ", x->parabola_width);
    }

    if(bent2_var == 1)
    {
      fprintf(f, "bent2_x=\"%g\" ", x->bent2_x);
      fprintf(f, "bent2_y=\"%g\" ", x->bent2_y);
    }

    if(bipolar_var == 1)
      fprintf(f, "bipolar_shift=\"%g\" ", x->bipolar_shift);

    if(cell_var == 1)
      fprintf(f, "cell_size=\"%g\" ", x->cell_size);

    if(cpow_var == 1)
    {
      fprintf(f, "cpow_i=\"%g\" ", x->cpow_i);
      fprintf(f, "cpow_r=\"%g\" ", x->cpow_r);
      fprintf(f, "cpow_power=\"%g\" ", x->cpow_power);
    }

    if(curve_var == 1)
    {
      fprintf(f, "curve_xamp=\"%g\" ", x->curve_xamp);
      fprintf(f, "curve_yamp=\"%g\" ", x->curve_yamp);
      fprintf(f, "curve_xlength=\"%g\" ", x->curve_xlength);
      fprintf(f, "curve_ylength=\"%g\" ", x->curve_ylength);
    }

    if(escher_var == 1)
      fprintf(f, "escher_beta=\"%g\" ", x->escher_beta);

    if(lazys_var == 1)
    {
      fprintf(f, "lazysusan_x=\"%g\" ", x->lazysusan_x);
      fprintf(f, "lazysusan_y=\"%g\" ", x->lazysusan_y);
      fprintf(f, "lazysusan_spin=\"%g\" ", x->lazysusan_spin);
      fprintf(f, "lazysusan_space=\"%g\" ", x->lazysusan_space);
      fprintf(f, "lazysusan_twist=\"%g\" ", x->lazysusan_twist);
    }

    if(modulus_var == 1)
    {
      fprintf(f, "modulus_x=\"%g\" ", x->modulus_x);
      fprintf(f, "modulus_y=\"%g\" ", x->modulus_y);
    }

    if(oscope_var == 1)
    {
      fprintf(f, "oscilloscope_separation=\"%g\" ", x->oscope_separation);
      fprintf(f, "oscilloscope_frequency=\"%g\" ", x->oscope_frequency);
      fprintf(f, "oscilloscope_amplitude=\"%g\" ", x->oscope_amplitude);
      fprintf(f, "oscilloscope_damping=\"%g\" ", x->oscope_damping);
    }

    if(popcorn2_var == 1)
    {
      fprintf(f, "popcorn2_x=\"%g\" ", x->popcorn2_x);
      fprintf(f, "popcorn2_y=\"%g\" ", x->popcorn2_y);
      fprintf(f, "popcorn2_c=\"%g\" ", x->popcorn2_c);
    }

    if(separation_var == 1)
    {
      fprintf(f, "separation_x=\"%g\" ", x->separation_x);
      fprintf(f, "separation_y=\"%g\" ", x->separation_y);
      fprintf(f, "separation_xinside=\"%g\" ", x->separation_xinside);
      fprintf(f, "separation_yinside=\"%g\" ", x->separation_yinside);
    }

    if(split_var == 1)
    {
      fprintf(f, "split_xsize=\"%g\" ", x->split_xsize);
      fprintf(f, "split_ysize=\"%g\" ", x->split_ysize);
    }

    if(splits_var == 1)
    {
      fprintf(f, "splits_x=\"%g\" ", x->splits_x);
      fprintf(f, "splits_y=\"%g\" ", x->splits_y);
    }

    if(stripes_var == 1)
    {
      fprintf(f, "stripes_space=\"%g\" ", x->stripes_space);
      fprintf(f, "stripes_warp=\"%g\" ", x->stripes_warp);
    }

    if(wedge_var == 1)
    {
      fprintf(f, "wedge_angle=\"%g\" ", x->wedge_angle);
      fprintf(f, "wedge_hole=\"%g\" ", x->wedge_hole);
      fprintf(f, "wedge_count=\"%g\" ", x->wedge_count);
      fprintf(f, "wedge_swirl=\"%g\" ", x->wedge_swirl);
    }

    if(wedgeJ_var == 1)
    {
      fprintf(f, "wedge_julia_angle=\"%g\" ", x->wedge_julia_angle);
      fprintf(f, "wedge_julia_count=\"%g\" ", x->wedge_julia_count);
      fprintf(f, "wedge_julia_power=\"%g\" ", x->wedge_julia_power);
      fprintf(f, "wedge_julia_dist=\"%g\" ", x->wedge_julia_dist);
    }

    if(wedgeS_var == 1)
    {
      fprintf(f, "wedge_sph_angle=\"%g\" ", x->wedge_sph_angle);
      fprintf(f, "wedge_sph_hole=\"%g\" ", x->wedge_sph_hole);
      fprintf(f, "wedge_sph_count=\"%g\" ", x->wedge_sph_count);
      fprintf(f, "wedge_sph_swirl=\"%g\" ", x->wedge_sph_swirl);
    }

    if(whorl_var == 1)
    {
      fprintf(f, "whorl_inside=\"%g\" ", x->whorl_inside);
      fprintf(f, "whorl_outside=\"%g\" ", x->whorl_outside);
    }

    if(waves2_var == 1)
    {
      fprintf(f, "waves2_scalex=\"%g\" ", x->waves2_scalex);
      fprintf(f, "waves2_scaley=\"%g\" ", x->waves2_scaley);
      fprintf(f, "waves2_freqx=\"%g\" ", x->waves2_freqx);
      fprintf(f, "waves2_freqy=\"%g\" ", x->waves2_freqy);
    }

    if(auger_var == 1)
    {
      fprintf(f, "auger_sym=\"%g\" ", x->auger_sym);
      fprintf(f, "auger_weight=\"%g\" ", x->auger_weight);
      fprintf(f, "auger_freq=\"%g\" ", x->auger_freq);
      fprintf(f, "auger_scale=\"%g\" ", x->auger_scale);
    }

    if(flux_var == 1)
      fprintf(f, "flux_spread=\"%g\" ", x->flux_spread);

    fprintf(f, "coefs=\"");
    j = 0;
    for( ; !(j >= 3); j = j + 1)
    {
      if(!(j == 0))
        fprintf(f, " ");

      fprintf(f, "%g %g", x->c[(signed long int)j][(signed long int)0], x->c[(signed long int)j][(signed long int)1]);
    }
    fprintf(f, "\"");
    signed int return_value_id_matrix_4;
    return_value_id_matrix_4=id_matrix(x->post);
    if(return_value_id_matrix_4 == 0)
    {
      fprintf(f, " post=\"");
      j = 0;
      for( ; !(j >= 3); j = j + 1)
      {
        if(!(j == 0))
          fprintf(f, " ");

        fprintf(f, "%g %g", x->post[(signed long int)j][(signed long int)0], x->post[(signed long int)j][(signed long int)1]);
      }
      fprintf(f, "\"");
    }

  }

  else
  {
    do
      if(IEEE_FLOAT_NOTEQUAL(x->blob_low, 0.0))
        fprintf(f, "blob_low=\"%f\" ", x->blob_low);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->blob_high, 0.0))
        fprintf(f, "blob_high=\"%f\" ", x->blob_high);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->blob_waves, 0.0))
        fprintf(f, "blob_waves=\"%f\" ", x->blob_waves);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->pdj_a, 0.0))
        fprintf(f, "pdj_a=\"%f\" ", x->pdj_a);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->pdj_b, 0.0))
        fprintf(f, "pdj_b=\"%f\" ", x->pdj_b);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->pdj_c, 0.0))
        fprintf(f, "pdj_c=\"%f\" ", x->pdj_c);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->pdj_d, 0.0))
        fprintf(f, "pdj_d=\"%f\" ", x->pdj_d);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->fan2_x, 0.0))
        fprintf(f, "fan2_x=\"%f\" ", x->fan2_x);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->fan2_y, 0.0))
        fprintf(f, "fan2_y=\"%f\" ", x->fan2_y);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->rings2_val, 0.0))
        fprintf(f, "rings2_val=\"%f\" ", x->rings2_val);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->perspective_angle, 0.0))
        fprintf(f, "perspective_angle=\"%f\" ", x->perspective_angle);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->perspective_dist, 0.0))
        fprintf(f, "perspective_dist=\"%f\" ", x->perspective_dist);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->julian_power, 0.0))
        fprintf(f, "julian_power=\"%f\" ", x->julian_power);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->julian_dist, 0.0))
        fprintf(f, "julian_dist=\"%f\" ", x->julian_dist);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->juliascope_power, 0.0))
        fprintf(f, "juliascope_power=\"%f\" ", x->juliascope_power);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->juliascope_dist, 0.0))
        fprintf(f, "juliascope_dist=\"%f\" ", x->juliascope_dist);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->radial_blur_angle, 0.0))
        fprintf(f, "radial_blur_angle=\"%f\" ", x->radial_blur_angle);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->pie_slices, 0.0))
        fprintf(f, "pie_slices=\"%f\" ", x->pie_slices);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->pie_rotation, 0.0))
        fprintf(f, "pie_rotation=\"%f\" ", x->pie_rotation);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->pie_thickness, 0.0))
        fprintf(f, "pie_thickness=\"%f\" ", x->pie_thickness);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->ngon_sides, 0.0))
        fprintf(f, "ngon_sides=\"%f\" ", x->ngon_sides);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->ngon_power, 0.0))
        fprintf(f, "ngon_power=\"%f\" ", x->ngon_power);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->ngon_corners, 0.0))
        fprintf(f, "ngon_corners=\"%f\" ", x->ngon_corners);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->ngon_circle, 0.0))
        fprintf(f, "ngon_circle=\"%f\" ", x->ngon_circle);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->curl_c1, 0.0))
        fprintf(f, "curl_c1=\"%f\" ", x->curl_c1);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->curl_c2, 0.0))
        fprintf(f, "curl_c2=\"%f\" ", x->curl_c2);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->rectangles_x, 0.0))
        fprintf(f, "rectangles_x=\"%f\" ", x->rectangles_x);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->rectangles_y, 0.0))
        fprintf(f, "rectangles_y=\"%f\" ", x->rectangles_y);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->disc2_rot, 0.0))
        fprintf(f, "disc2_rot=\"%f\" ", x->disc2_rot);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->disc2_twist, 0.0))
        fprintf(f, "disc2_twist=\"%f\" ", x->disc2_twist);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->super_shape_rnd, 0.0))
        fprintf(f, "super_shape_rnd=\"%f\" ", x->super_shape_rnd);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->super_shape_m, 0.0))
        fprintf(f, "super_shape_m=\"%f\" ", x->super_shape_m);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->super_shape_n1, 0.0))
        fprintf(f, "super_shape_n1=\"%f\" ", x->super_shape_n1);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->super_shape_n2, 0.0))
        fprintf(f, "super_shape_n2=\"%f\" ", x->super_shape_n2);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->super_shape_n3, 0.0))
        fprintf(f, "super_shape_n3=\"%f\" ", x->super_shape_n3);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->super_shape_holes, 0.0))
        fprintf(f, "super_shape_holes=\"%f\" ", x->super_shape_holes);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->flower_petals, 0.0))
        fprintf(f, "flower_petals=\"%f\" ", x->flower_petals);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->flower_holes, 0.0))
        fprintf(f, "flower_holes=\"%f\" ", x->flower_holes);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->conic_eccentricity, 0.0))
        fprintf(f, "conic_eccentricity=\"%f\" ", x->conic_eccentricity);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->conic_holes, 0.0))
        fprintf(f, "conic_holes=\"%f\" ", x->conic_holes);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->parabola_height, 0.0))
        fprintf(f, "parabola_height=\"%f\" ", x->parabola_height);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->parabola_width, 0.0))
        fprintf(f, "parabola_width=\"%f\" ", x->parabola_width);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->bent2_x, 0.0))
        fprintf(f, "bent2_x=\"%f\" ", x->bent2_x);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->bent2_y, 0.0))
        fprintf(f, "bent2_y=\"%f\" ", x->bent2_y);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->bipolar_shift, 0.0))
        fprintf(f, "bipolar_shift=\"%f\" ", x->bipolar_shift);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->cell_size, 0.0))
        fprintf(f, "cell_size=\"%f\" ", x->cell_size);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->cpow_i, 0.0))
        fprintf(f, "cpow_i=\"%f\" ", x->cpow_i);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->cpow_r, 0.0))
        fprintf(f, "cpow_r=\"%f\" ", x->cpow_r);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->cpow_power, 0.0))
        fprintf(f, "cpow_power=\"%f\" ", x->cpow_power);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->curve_xamp, 0.0))
        fprintf(f, "curve_xamp=\"%f\" ", x->curve_xamp);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->curve_yamp, 0.0))
        fprintf(f, "curve_yamp=\"%f\" ", x->curve_yamp);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->curve_xlength, 0.0))
        fprintf(f, "curve_xlength=\"%f\" ", x->curve_xlength);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->curve_ylength, 0.0))
        fprintf(f, "curve_ylength=\"%f\" ", x->curve_ylength);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->escher_beta, 0.0))
        fprintf(f, "escher_beta=\"%f\" ", x->escher_beta);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->lazysusan_x, 0.0))
        fprintf(f, "lazysusan_x=\"%f\" ", x->lazysusan_x);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->lazysusan_y, 0.0))
        fprintf(f, "lazysusan_y=\"%f\" ", x->lazysusan_y);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->lazysusan_spin, 0.0))
        fprintf(f, "lazysusan_spin=\"%f\" ", x->lazysusan_spin);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->lazysusan_space, 0.0))
        fprintf(f, "lazysusan_space=\"%f\" ", x->lazysusan_space);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->lazysusan_twist, 0.0))
        fprintf(f, "lazysusan_twist=\"%f\" ", x->lazysusan_twist);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->modulus_x, 0.0))
        fprintf(f, "modulus_x=\"%f\" ", x->modulus_x);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->modulus_y, 0.0))
        fprintf(f, "modulus_y=\"%f\" ", x->modulus_y);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->oscope_separation, 0.0))
        fprintf(f, "oscope_separation=\"%f\" ", x->oscope_separation);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->oscope_frequency, 0.0))
        fprintf(f, "oscope_frequency=\"%f\" ", x->oscope_frequency);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->oscope_amplitude, 0.0))
        fprintf(f, "oscope_amplitude=\"%f\" ", x->oscope_amplitude);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->oscope_damping, 0.0))
        fprintf(f, "oscope_damping=\"%f\" ", x->oscope_damping);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->popcorn2_x, 0.0))
        fprintf(f, "popcorn2_x=\"%f\" ", x->popcorn2_x);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->popcorn2_y, 0.0))
        fprintf(f, "popcorn2_y=\"%f\" ", x->popcorn2_y);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->popcorn2_c, 0.0))
        fprintf(f, "popcorn2_c=\"%f\" ", x->popcorn2_c);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->separation_x, 0.0))
        fprintf(f, "separation_x=\"%f\" ", x->separation_x);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->separation_y, 0.0))
        fprintf(f, "separation_y=\"%f\" ", x->separation_y);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->separation_xinside, 0.0))
        fprintf(f, "separation_xinside=\"%f\" ", x->separation_xinside);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->separation_yinside, 0.0))
        fprintf(f, "separation_yinside=\"%f\" ", x->separation_yinside);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->split_xsize, 0.0))
        fprintf(f, "split_xsize=\"%f\" ", x->split_xsize);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->split_ysize, 0.0))
        fprintf(f, "split_ysize=\"%f\" ", x->split_ysize);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->splits_x, 0.0))
        fprintf(f, "splits_x=\"%f\" ", x->splits_x);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->splits_y, 0.0))
        fprintf(f, "splits_y=\"%f\" ", x->splits_y);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->stripes_space, 0.0))
        fprintf(f, "stripes_space=\"%f\" ", x->stripes_space);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->stripes_warp, 0.0))
        fprintf(f, "stripes_warp=\"%f\" ", x->stripes_warp);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->wedge_angle, 0.0))
        fprintf(f, "wedge_angle=\"%f\" ", x->wedge_angle);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->wedge_hole, 0.0))
        fprintf(f, "wedge_hole=\"%f\" ", x->wedge_hole);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->wedge_count, 0.0))
        fprintf(f, "wedge_count=\"%f\" ", x->wedge_count);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->wedge_swirl, 0.0))
        fprintf(f, "wedge_swirl=\"%f\" ", x->wedge_swirl);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->wedge_julia_angle, 0.0))
        fprintf(f, "wedge_julia_angle=\"%f\" ", x->wedge_julia_angle);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->wedge_julia_count, 0.0))
        fprintf(f, "wedge_julia_count=\"%f\" ", x->wedge_julia_count);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->wedge_julia_power, 0.0))
        fprintf(f, "wedge_julia_power=\"%f\" ", x->wedge_julia_power);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->wedge_julia_dist, 0.0))
        fprintf(f, "wedge_julia_dist=\"%f\" ", x->wedge_julia_dist);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->wedge_sph_angle, 0.0))
        fprintf(f, "wedge_sph_angle=\"%f\" ", x->wedge_sph_angle);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->wedge_sph_hole, 0.0))
        fprintf(f, "wedge_sph_hole=\"%f\" ", x->wedge_sph_hole);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->wedge_sph_count, 0.0))
        fprintf(f, "wedge_sph_count=\"%f\" ", x->wedge_sph_count);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->wedge_sph_swirl, 0.0))
        fprintf(f, "wedge_sph_swirl=\"%f\" ", x->wedge_sph_swirl);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->whorl_inside, 0.0))
        fprintf(f, "whorl_inside=\"%f\" ", x->whorl_inside);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->whorl_outside, 0.0))
        fprintf(f, "whorl_outside=\"%f\" ", x->whorl_outside);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->waves2_scalex, 0.0))
        fprintf(f, "waves2_scalex=\"%f\" ", x->waves2_scalex);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->waves2_scaley, 0.0))
        fprintf(f, "waves2_scaley=\"%f\" ", x->waves2_scaley);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->waves2_freqx, 0.0))
        fprintf(f, "waves2_freqx=\"%f\" ", x->waves2_freqx);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->waves2_freqy, 0.0))
        fprintf(f, "waves2_freqy=\"%f\" ", x->waves2_freqy);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->auger_sym, 0.0))
        fprintf(f, "auger_sym=\"%f\" ", x->auger_sym);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->auger_weight, 0.0))
        fprintf(f, "auger_weight=\"%f\" ", x->auger_weight);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->auger_freq, 0.0))
        fprintf(f, "auger_freq=\"%f\" ", x->auger_freq);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->auger_scale, 0.0))
        fprintf(f, "auger_scale=\"%f\" ", x->auger_scale);

    while((_Bool)0);
    do
      if(IEEE_FLOAT_NOTEQUAL(x->flux_spread, 0.0))
        fprintf(f, "flux_spread=\"%f\" ", x->flux_spread);

    while((_Bool)0);
    signed int return_value_zero_matrix_5;
    return_value_zero_matrix_5=zero_matrix(x->c);
    if(return_value_zero_matrix_5 == 0)
    {
      fprintf(f, "coefs=\"");
      j = 0;
      for( ; !(j >= 3); j = j + 1)
      {
        if(!(j == 0))
          fprintf(f, " ");

        fprintf(f, "%g %g", x->c[(signed long int)j][(signed long int)0], x->c[(signed long int)j][(signed long int)1]);
      }
      fprintf(f, "\"");
    }

    signed int return_value_zero_matrix_6;
    return_value_zero_matrix_6=zero_matrix(x->post);
    if(return_value_zero_matrix_6 == 0)
    {
      fprintf(f, " post=\"");
      j = 0;
      for( ; !(j >= 3); j = j + 1)
      {
        if(!(j == 0))
          fprintf(f, " ");

        fprintf(f, "%g %g", x->post[(signed long int)j][(signed long int)0], x->post[(signed long int)j][(signed long int)1]);
      }
      fprintf(f, "\"");
    }

  }
  if(flam27_flag == 0 && final_flag == 0 && motion_flag == 0)
  {
    signed int numcols = numstd;
    for( ; numcols >= 1; numcols = numcols - 1)
      if(!IEEE_FLOAT_EQUAL(chaos_row[(signed long int)(numcols + -1)], 1.0))
        break;

    if(numcols >= 1)
    {
      fprintf(f, " chaos=\"");
      j = 0;
      for( ; !(j >= numcols); j = j + 1)
        fprintf(f, "%g ", chaos_row[(signed long int)j]);
      fprintf(f, "\"");
    }

  }

  if(flam27_flag == 0 && motion_flag == 0)
    fprintf(f, " opacity=\"%g\"", x->opacity);

  _Bool tmp_if_expr_7;
  if(motion_flag == 0)
    tmp_if_expr_7 = x->num_motion > 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_7 = (_Bool)0;
  if(flam27_flag == 0 && tmp_if_expr_7)
  {
    signed int nm;
    fprintf(f, ">\n");
    nm = 0;
    for( ; !(nm >= x->num_motion); nm = nm + 1)
      flam3_print_xform(f, &x->motion[(signed long int)nm], 0, 0, (double *)(void *)0, 1);
    fprintf(f, "   </xform>\n");
  }

  else
    fprintf(f, "/>\n");
}

// flam3_quadratic_filter
// file filters.c line 160
double flam3_quadratic_filter(double x)
{
  if(x < -1.500000e+0)
    return 0.0;

  else
    if(x < -5.000000e-1)
      return 0.5 * (x + 1.5) * (x + 1.5);

    else
      if(x < 0.5)
        return 0.75 - x * x;

      else
        if(x < 1.5)
          return 0.5 * (x - 1.5) * (x - 1.5);

        else
          return 0.0;
}

// flam3_random
// file flam3.h line 563
void flam3_random(struct anonymous_0 *cp, signed int *ivars, signed int ivars_n, signed int sym, signed int spec_xforms)
{
  signed int i;
  signed int j;
  signed int nxforms;
  signed int var;
  signed int samed;
  signed int multid;
  signed int samepost;
  signed int postid;
  signed int addfinal = 0;
  signed int finum = -1;
  signed int n;
  char *ai;
  signed int f27;
  ai=getenv("flam27");
  signed int tmp_if_expr_2;
  signed int return_value_atoi_1;
  if(!(ai == ((char *)NULL)))
  {
    return_value_atoi_1=atoi_link1(ai);
    tmp_if_expr_2 = return_value_atoi_1;
  }

  else
    tmp_if_expr_2 = 0;
  f27 = tmp_if_expr_2;
  signed int mvar = f27 != 0 ? 54 : 98;
  double sum;
  clear_cp(cp, 1);
  signed long int return_value_random_3;
  return_value_random_3=random();
  double tmp_if_expr_5;
  double return_value_flam3_random01_4;
  if(!((7l & return_value_random_3) == 0l))
    tmp_if_expr_5 = 0.0;

  else
  {
    return_value_flam3_random01_4=flam3_random01();
    tmp_if_expr_5 = return_value_flam3_random01_4;
  }
  cp->hue_rotation = tmp_if_expr_5;
  cp->palette_index=flam3_get_palette(-1, cp->palette, cp->hue_rotation);
  if(!(cp->palette_index >= 0))
    fprintf(stderr, "error getting palette from xml file, setting to all white\n");

  cp->time = 0.0;
  cp->interpolation = 0;
  cp->palette_interpolation = 0;
  if(spec_xforms >= 1)
  {
    nxforms = spec_xforms;
    flam3_add_xforms(cp, nxforms, 0, 0);
  }

  else
  {
    signed long int return_value_random_6;
    return_value_random_6=random();
    static signed int xform_distrib[14l] = { 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 6 };
    nxforms = xform_distrib[(signed long int)((unsigned long int)return_value_random_6 % (sizeof(signed int [14l]) /*56ul*/  / sizeof(signed int) /*4ul*/ ))];
    flam3_add_xforms(cp, nxforms, 0, 0);
    double return_value_flam3_random01_7;
    return_value_flam3_random01_7=flam3_random01();
    addfinal = (signed int)(return_value_flam3_random01_7 < 0.15);
    if(!(addfinal == 0))
    {
      flam3_add_xforms(cp, 1, 0, 1);
      nxforms = nxforms + addfinal;
      finum = nxforms - 1;
    }

  }
  if(*ivars == -1)
  {
    signed int return_value_flam3_random_bit_8;
    return_value_flam3_random_bit_8=flam3_random_bit();
    if(!(return_value_flam3_random_bit_8 == 0))
      var=random_varn(mvar);

    else
      var = -1;
  }

  else
    var = -2;
  samed=flam3_random_bit();
  multid=flam3_random_bit();
  double return_value_flam3_random01_9;
  return_value_flam3_random01_9=flam3_random01();
  postid = (signed int)(return_value_flam3_random01_9 < 0.6);
  samepost=flam3_random_bit();
  i = 0;
  signed int return_value_flam3_random_bit_11;
  signed int return_value_random_varn_12;
  signed int return_value_random_varn_13;
  signed int return_value_random_var_14;
  signed int return_value_random_varn_16;
  signed int return_value_random_varn_17;
  signed int return_value_random_var_18;
  for( ; !(i >= nxforms); i = i + 1)
  {
    signed int flam3_random__1__5__1__j;
    signed int k;
    (cp->xform + (signed long int)i)->density = 1.0 / (double)nxforms;
    (cp->xform + (signed long int)i)->color = (double)(i & 1);
    (cp->xform + (signed long int)i)->color_speed = 0.5;
    (cp->xform + (signed long int)i)->animate = 1.0;
    flam3_random__1__5__1__j = 0;
    for( ; !(flam3_random__1__5__1__j >= 3); flam3_random__1__5__1__j = flam3_random__1__5__1__j + 1)
    {
      k = 0;
      for( ; !(k >= 2); k = k + 1)
      {
        (cp->xform + (signed long int)i)->c[(signed long int)flam3_random__1__5__1__j][(signed long int)k]=flam3_random11();
        (cp->xform + (signed long int)i)->post[(signed long int)flam3_random__1__5__1__j][(signed long int)k] = (double)(k == flam3_random__1__5__1__j);
      }
    }
    if(!(i == finum))
    {
      if(postid == 0)
      {
        flam3_random__1__5__1__j = 0;
        for( ; !(flam3_random__1__5__1__j >= 3); flam3_random__1__5__1__j = flam3_random__1__5__1__j + 1)
        {
          k = 0;
          for( ; !(k >= 2); k = k + 1)
            if(i == 0 || !(samepost == 0))
              (cp->xform + (signed long int)i)->post[(signed long int)flam3_random__1__5__1__j][(signed long int)k]=flam3_random11();

            else
              (cp->xform + (signed long int)i)->post[(signed long int)flam3_random__1__5__1__j][(signed long int)k] = (cp->xform + (signed long int)0)->post[(signed long int)flam3_random__1__5__1__j][(signed long int)k];
        }
      }

      flam3_random__1__5__1__j = 0;
      for( ; !(flam3_random__1__5__1__j >= 98); flam3_random__1__5__1__j = flam3_random__1__5__1__j + 1)
        (cp->xform + (signed long int)i)->var[(signed long int)flam3_random__1__5__1__j] = 0.0;
      if(!(var == -2) && !(var == -1))
        (cp->xform + (signed long int)i)->var[(signed long int)var] = 1.0;

      else
        if(var == -1 && !(multid == 0))
        {
          signed int return_value_random_varn_10;
          return_value_random_varn_10=random_varn(mvar);
          (cp->xform + (signed long int)i)->var[(signed long int)return_value_random_varn_10] = 1.0;
        }

        else
          if(i >= 1 && !(samed == 0))
          {
            flam3_random__1__5__1__j = 0;
            for( ; !(flam3_random__1__5__1__j >= 98); flam3_random__1__5__1__j = flam3_random__1__5__1__j + 1)
            {
              (cp->xform + (signed long int)i)->var[(signed long int)flam3_random__1__5__1__j] = (cp->xform + (signed long int)(i - 1))->var[(signed long int)flam3_random__1__5__1__j];
              flam3_copy_params(&cp->xform[(signed long int)i], &cp->xform[(signed long int)(i - 1)], flam3_random__1__5__1__j);
            }
          }

          else
          {
            n = 2;
            do
            {
              return_value_flam3_random_bit_11=flam3_random_bit();
              if(return_value_flam3_random_bit_11 == 0)
                break;

              if(n >= mvar)
                break;

              n = n + 1;
            }
            while((_Bool)1);
            flam3_random__1__5__1__j = 0;
            for( ; !(flam3_random__1__5__1__j >= n); flam3_random__1__5__1__j = flam3_random__1__5__1__j + 1)
              if(!(var == -2))
              {
                return_value_random_varn_12=random_varn(mvar);
                (cp->xform + (signed long int)i)->var[(signed long int)return_value_random_varn_12]=flam3_random01();
              }

              else
              {
                return_value_random_varn_13=random_varn(ivars_n);
                (cp->xform + (signed long int)i)->var[(signed long int)ivars[(signed long int)return_value_random_varn_13]]=flam3_random01();
              }
            sum = 0.0;
            flam3_random__1__5__1__j = 0;
            for( ; !(flam3_random__1__5__1__j >= 98); flam3_random__1__5__1__j = flam3_random__1__5__1__j + 1)
              sum = sum + (cp->xform + (signed long int)i)->var[(signed long int)flam3_random__1__5__1__j];
            if(IEEE_FLOAT_EQUAL(sum, 0.0))
            {
              return_value_random_var_14=random_var();
              (cp->xform + (signed long int)i)->var[(signed long int)return_value_random_var_14] = 1.0;
            }

            else
            {
              flam3_random__1__5__1__j = 0;
              for( ; !(flam3_random__1__5__1__j >= 98); flam3_random__1__5__1__j = flam3_random__1__5__1__j + 1)
                (cp->xform + (signed long int)i)->var[(signed long int)flam3_random__1__5__1__j] = (cp->xform + (signed long int)i)->var[(signed long int)flam3_random__1__5__1__j] / sum;
            }
          }
    }

    else
    {
      n = 1;
      signed int return_value_flam3_random_bit_15;
      return_value_flam3_random_bit_15=flam3_random_bit();
      if(!(return_value_flam3_random_bit_15 == 0))
        n = n + 1;

      flam3_random__1__5__1__j = 0;
      for( ; !(flam3_random__1__5__1__j >= n); flam3_random__1__5__1__j = flam3_random__1__5__1__j + 1)
        if(!(var == -2))
        {
          return_value_random_varn_16=random_varn(mvar);
          (cp->xform + (signed long int)i)->var[(signed long int)return_value_random_varn_16]=flam3_random01();
        }

        else
        {
          return_value_random_varn_17=random_varn(ivars_n);
          (cp->xform + (signed long int)i)->var[(signed long int)ivars[(signed long int)return_value_random_varn_17]]=flam3_random01();
        }
      sum = 0.0;
      flam3_random__1__5__1__j = 0;
      for( ; !(flam3_random__1__5__1__j >= 98); flam3_random__1__5__1__j = flam3_random__1__5__1__j + 1)
        sum = sum + (cp->xform + (signed long int)i)->var[(signed long int)flam3_random__1__5__1__j];
      if(IEEE_FLOAT_EQUAL(sum, 0.0))
      {
        return_value_random_var_18=random_var();
        (cp->xform + (signed long int)i)->var[(signed long int)return_value_random_var_18] = 1.0;
      }

      else
      {
        flam3_random__1__5__1__j = 0;
        for( ; !(flam3_random__1__5__1__j >= 98); flam3_random__1__5__1__j = flam3_random__1__5__1__j + 1)
          (cp->xform + (signed long int)i)->var[(signed long int)flam3_random__1__5__1__j] = (cp->xform + (signed long int)i)->var[(signed long int)flam3_random__1__5__1__j] / sum;
      }
    }
    if((cp->xform + (signed long int)i)->var[23l] > 0.000000)
    {
      double return_value_flam3_random01_19;
      return_value_flam3_random01_19=flam3_random01();
      (cp->xform + (signed long int)i)->blob_low = 0.2 + 0.5 * return_value_flam3_random01_19;
      double return_value_flam3_random01_20;
      return_value_flam3_random01_20=flam3_random01();
      (cp->xform + (signed long int)i)->blob_high = 0.8 + 0.4 * return_value_flam3_random01_20;
      double return_value_flam3_random01_21;
      return_value_flam3_random01_21=flam3_random01();
      (cp->xform + (signed long int)i)->blob_waves = (double)(signed int)((double)2 + (double)5 * return_value_flam3_random01_21);
    }

    if((cp->xform + (signed long int)i)->var[24l] > 0.000000)
    {
      double return_value_flam3_random11_22;
      return_value_flam3_random11_22=flam3_random11();
      (cp->xform + (signed long int)i)->pdj_a = 3.0 * return_value_flam3_random11_22;
      double return_value_flam3_random11_23;
      return_value_flam3_random11_23=flam3_random11();
      (cp->xform + (signed long int)i)->pdj_b = 3.0 * return_value_flam3_random11_23;
      double return_value_flam3_random11_24;
      return_value_flam3_random11_24=flam3_random11();
      (cp->xform + (signed long int)i)->pdj_c = 3.0 * return_value_flam3_random11_24;
      double return_value_flam3_random11_25;
      return_value_flam3_random11_25=flam3_random11();
      (cp->xform + (signed long int)i)->pdj_d = 3.0 * return_value_flam3_random11_25;
    }

    if((cp->xform + (signed long int)i)->var[25l] > 0.000000)
    {
      (cp->xform + (signed long int)i)->fan2_x=flam3_random11();
      (cp->xform + (signed long int)i)->fan2_y=flam3_random11();
    }

    if((cp->xform + (signed long int)i)->var[26l] > 0.000000)
    {
      double return_value_flam3_random01_26;
      return_value_flam3_random01_26=flam3_random01();
      (cp->xform + (signed long int)i)->rings2_val = (double)2 * return_value_flam3_random01_26;
    }

    if((cp->xform + (signed long int)i)->var[30l] > 0.000000)
    {
      (cp->xform + (signed long int)i)->perspective_angle=flam3_random01();
      double return_value_flam3_random01_27;
      return_value_flam3_random01_27=flam3_random01();
      (cp->xform + (signed long int)i)->perspective_dist = (double)2 * return_value_flam3_random01_27 + 1.0;
    }

    if((cp->xform + (signed long int)i)->var[32l] > 0.000000)
    {
      double return_value_flam3_random01_28;
      return_value_flam3_random01_28=flam3_random01();
      (cp->xform + (signed long int)i)->julian_power = (double)(signed int)((double)5 * return_value_flam3_random01_28 + (double)2);
      (cp->xform + (signed long int)i)->julian_dist = 1.0;
    }

    if((cp->xform + (signed long int)i)->var[33l] > 0.000000)
    {
      double return_value_flam3_random01_29;
      return_value_flam3_random01_29=flam3_random01();
      (cp->xform + (signed long int)i)->juliascope_power = (double)(signed int)((double)5 * return_value_flam3_random01_29 + (double)2);
      (cp->xform + (signed long int)i)->juliascope_dist = 1.0;
    }

    if((cp->xform + (signed long int)i)->var[36l] > 0.000000)
    {
      double return_value_flam3_random01_30;
      return_value_flam3_random01_30=flam3_random01();
      (cp->xform + (signed long int)i)->radial_blur_angle = (double)2 * return_value_flam3_random01_30 - (double)1;
    }

    if((cp->xform + (signed long int)i)->var[37l] > 0.000000)
    {
      double return_value_flam3_random01_31;
      return_value_flam3_random01_31=flam3_random01();
      (cp->xform + (signed long int)i)->pie_slices = (double)(signed int)10.0 * return_value_flam3_random01_31;
      (cp->xform + (signed long int)i)->pie_thickness=flam3_random01();
      double return_value_flam3_random11_32;
      return_value_flam3_random11_32=flam3_random11();
      (cp->xform + (signed long int)i)->pie_rotation = 2.0 * 3.14159265358979323846 * return_value_flam3_random11_32;
    }

    if((cp->xform + (signed long int)i)->var[38l] > 0.000000)
    {
      double return_value_flam3_random01_33;
      return_value_flam3_random01_33=flam3_random01();
      (cp->xform + (signed long int)i)->ngon_sides = (double)((signed int)return_value_flam3_random01_33 * 10 + 3);
      double return_value_flam3_random01_34;
      return_value_flam3_random01_34=flam3_random01();
      (cp->xform + (signed long int)i)->ngon_power = (double)3 * return_value_flam3_random01_34 + (double)1;
      double return_value_flam3_random01_35;
      return_value_flam3_random01_35=flam3_random01();
      (cp->xform + (signed long int)i)->ngon_circle = (double)3 * return_value_flam3_random01_35;
      double return_value_flam3_random01_36;
      return_value_flam3_random01_36=flam3_random01();
      (cp->xform + (signed long int)i)->ngon_corners = (double)2 * return_value_flam3_random01_36 * (cp->xform + (signed long int)i)->ngon_circle;
    }

    if((cp->xform + (signed long int)i)->var[39l] > 0.000000)
    {
      (cp->xform + (signed long int)i)->curl_c1=flam3_random01();
      (cp->xform + (signed long int)i)->curl_c2=flam3_random01();
    }

    if((cp->xform + (signed long int)i)->var[40l] > 0.000000)
    {
      (cp->xform + (signed long int)i)->rectangles_x=flam3_random01();
      (cp->xform + (signed long int)i)->rectangles_y=flam3_random01();
    }

    if((cp->xform + (signed long int)i)->var[49l] > 0.000000)
    {
      double return_value_flam3_random01_37;
      return_value_flam3_random01_37=flam3_random01();
      (cp->xform + (signed long int)i)->disc2_rot = 0.5 * return_value_flam3_random01_37;
      double return_value_flam3_random01_38;
      return_value_flam3_random01_38=flam3_random01();
      (cp->xform + (signed long int)i)->disc2_twist = 0.5 * return_value_flam3_random01_38;
    }

    if((cp->xform + (signed long int)i)->var[50l] > 0.000000)
    {
      (cp->xform + (signed long int)i)->super_shape_rnd=flam3_random01();
      double return_value_flam3_random01_39;
      return_value_flam3_random01_39=flam3_random01();
      (cp->xform + (signed long int)i)->super_shape_m = (double)((signed int)return_value_flam3_random01_39 * 6);
      double return_value_flam3_random01_40;
      return_value_flam3_random01_40=flam3_random01();
      (cp->xform + (signed long int)i)->super_shape_n1 = return_value_flam3_random01_40 * (double)40;
      double return_value_flam3_random01_41;
      return_value_flam3_random01_41=flam3_random01();
      (cp->xform + (signed long int)i)->super_shape_n2 = return_value_flam3_random01_41 * (double)20;
      (cp->xform + (signed long int)i)->super_shape_n3 = (cp->xform + (signed long int)i)->super_shape_n2;
      (cp->xform + (signed long int)i)->super_shape_holes = 0.0;
    }

    if((cp->xform + (signed long int)i)->var[51l] > 0.000000)
    {
      double return_value_flam3_random01_42;
      return_value_flam3_random01_42=flam3_random01();
      (cp->xform + (signed long int)i)->flower_petals = (double)4 * return_value_flam3_random01_42;
      (cp->xform + (signed long int)i)->flower_holes=flam3_random01();
    }

    if((cp->xform + (signed long int)i)->var[52l] > 0.000000)
    {
      (cp->xform + (signed long int)i)->conic_eccentricity=flam3_random01();
      (cp->xform + (signed long int)i)->conic_holes=flam3_random01();
    }

    if((cp->xform + (signed long int)i)->var[53l] > 0.000000)
    {
      double return_value_flam3_random01_43;
      return_value_flam3_random01_43=flam3_random01();
      (cp->xform + (signed long int)i)->parabola_height = 0.5 + return_value_flam3_random01_43;
      double return_value_flam3_random01_44;
      return_value_flam3_random01_44=flam3_random01();
      (cp->xform + (signed long int)i)->parabola_width = 0.5 + return_value_flam3_random01_44;
    }

    if((cp->xform + (signed long int)i)->var[54l] > 0.000000)
    {
      double return_value_flam3_random01_45;
      return_value_flam3_random01_45=flam3_random01();
      (cp->xform + (signed long int)i)->bent2_x = (double)3 * (-0.5 + return_value_flam3_random01_45);
      double return_value_flam3_random01_46;
      return_value_flam3_random01_46=flam3_random01();
      (cp->xform + (signed long int)i)->bent2_y = (double)3 * (-0.5 + return_value_flam3_random01_46);
    }

    if((cp->xform + (signed long int)i)->var[55l] > 0.000000)
    {
      double return_value_flam3_random01_47;
      return_value_flam3_random01_47=flam3_random01();
      (cp->xform + (signed long int)i)->bipolar_shift = 2.0 * return_value_flam3_random01_47 - (double)1;
    }

    if((cp->xform + (signed long int)i)->var[58l] > 0.000000)
    {
      double return_value_flam3_random01_48;
      return_value_flam3_random01_48=flam3_random01();
      (cp->xform + (signed long int)i)->cell_size = 2.0 * return_value_flam3_random01_48 + 0.5;
    }

    if((cp->xform + (signed long int)i)->var[59l] > 0.000000)
    {
      double return_value_flam3_random01_49;
      return_value_flam3_random01_49=flam3_random01();
      (cp->xform + (signed long int)i)->cpow_r = 3.0 * return_value_flam3_random01_49;
      double return_value_flam3_random01_50;
      return_value_flam3_random01_50=flam3_random01();
      (cp->xform + (signed long int)i)->cpow_i = return_value_flam3_random01_50 - 0.5;
      double return_value_flam3_random01_51;
      return_value_flam3_random01_51=flam3_random01();
      (cp->xform + (signed long int)i)->cpow_power = (double)(signed int)(5.0 * return_value_flam3_random01_51);
    }

    if((cp->xform + (signed long int)i)->var[60l] > 0.000000)
    {
      double return_value_flam3_random01_52;
      return_value_flam3_random01_52=flam3_random01();
      (cp->xform + (signed long int)i)->curve_xamp = (double)5 * (return_value_flam3_random01_52 - .5);
      double return_value_flam3_random01_53;
      return_value_flam3_random01_53=flam3_random01();
      (cp->xform + (signed long int)i)->curve_yamp = (double)4 * (return_value_flam3_random01_53 - .5);
      double return_value_flam3_random01_54;
      return_value_flam3_random01_54=flam3_random01();
      (cp->xform + (signed long int)i)->curve_xlength = (double)2 * (return_value_flam3_random01_54 + .5);
      double return_value_flam3_random01_55;
      return_value_flam3_random01_55=flam3_random01();
      (cp->xform + (signed long int)i)->curve_ylength = (double)2 * (return_value_flam3_random01_55 + .5);
    }

    if((cp->xform + (signed long int)i)->var[63l] > 0.000000)
    {
      double return_value_flam3_random11_56;
      return_value_flam3_random11_56=flam3_random11();
      (cp->xform + (signed long int)i)->escher_beta = 3.14159265358979323846 * return_value_flam3_random11_56;
    }

    if((cp->xform + (signed long int)i)->var[65l] > 0.000000)
    {
      double return_value_flam3_random11_57;
      return_value_flam3_random11_57=flam3_random11();
      (cp->xform + (signed long int)i)->lazysusan_x = 2.0 * return_value_flam3_random11_57;
      double return_value_flam3_random11_58;
      return_value_flam3_random11_58=flam3_random11();
      (cp->xform + (signed long int)i)->lazysusan_y = 2.0 * return_value_flam3_random11_58;
      double return_value_flam3_random11_59;
      return_value_flam3_random11_59=flam3_random11();
      (cp->xform + (signed long int)i)->lazysusan_spin = 3.14159265358979323846 * return_value_flam3_random11_59;
      double return_value_flam3_random11_60;
      return_value_flam3_random11_60=flam3_random11();
      (cp->xform + (signed long int)i)->lazysusan_space = 2.0 * return_value_flam3_random11_60;
      double return_value_flam3_random11_61;
      return_value_flam3_random11_61=flam3_random11();
      (cp->xform + (signed long int)i)->lazysusan_twist = 2.0 * return_value_flam3_random11_61;
    }

    if((cp->xform + (signed long int)i)->var[68l] > 0.000000)
    {
      (cp->xform + (signed long int)i)->modulus_x=flam3_random11();
      (cp->xform + (signed long int)i)->modulus_y=flam3_random11();
    }

    if((cp->xform + (signed long int)i)->var[69l] > 0.000000)
    {
      double return_value_flam3_random11_62;
      return_value_flam3_random11_62=flam3_random11();
      (cp->xform + (signed long int)i)->oscope_separation = 1.0 + return_value_flam3_random11_62;
      double return_value_flam3_random11_63;
      return_value_flam3_random11_63=flam3_random11();
      (cp->xform + (signed long int)i)->oscope_frequency = 3.14159265358979323846 * return_value_flam3_random11_63;
      double return_value_flam3_random01_64;
      return_value_flam3_random01_64=flam3_random01();
      (cp->xform + (signed long int)i)->oscope_amplitude = 1.0 + (double)2 * return_value_flam3_random01_64;
      (cp->xform + (signed long int)i)->oscope_damping=flam3_random01();
    }

    if((cp->xform + (signed long int)i)->var[71l] > 0.000000)
    {
      double return_value_flam3_random01_65;
      return_value_flam3_random01_65=flam3_random01();
      (cp->xform + (signed long int)i)->popcorn2_x = 0.2 * return_value_flam3_random01_65;
      double return_value_flam3_random01_66;
      return_value_flam3_random01_66=flam3_random01();
      (cp->xform + (signed long int)i)->popcorn2_y = 0.2 * return_value_flam3_random01_66;
      double return_value_flam3_random01_67;
      return_value_flam3_random01_67=flam3_random01();
      (cp->xform + (signed long int)i)->popcorn2_c = (double)5 * return_value_flam3_random01_67;
    }

    if((cp->xform + (signed long int)i)->var[73l] > 0.000000)
    {
      double return_value_flam3_random11_68;
      return_value_flam3_random11_68=flam3_random11();
      (cp->xform + (signed long int)i)->separation_x = (double)1 + return_value_flam3_random11_68;
      double return_value_flam3_random11_69;
      return_value_flam3_random11_69=flam3_random11();
      (cp->xform + (signed long int)i)->separation_y = (double)1 + return_value_flam3_random11_69;
      (cp->xform + (signed long int)i)->separation_xinside=flam3_random11();
      (cp->xform + (signed long int)i)->separation_yinside=flam3_random11();
    }

    if((cp->xform + (signed long int)i)->var[74l] > 0.000000)
    {
      (cp->xform + (signed long int)i)->split_xsize=flam3_random11();
      (cp->xform + (signed long int)i)->split_ysize=flam3_random11();
    }

    if((cp->xform + (signed long int)i)->var[75l] > 0.000000)
    {
      (cp->xform + (signed long int)i)->splits_x=flam3_random11();
      (cp->xform + (signed long int)i)->splits_y=flam3_random11();
    }

    if((cp->xform + (signed long int)i)->var[76l] > 0.000000)
    {
      (cp->xform + (signed long int)i)->stripes_space=flam3_random01();
      double return_value_flam3_random01_70;
      return_value_flam3_random01_70=flam3_random01();
      (cp->xform + (signed long int)i)->stripes_warp = (double)5 * return_value_flam3_random01_70;
    }

    if((cp->xform + (signed long int)i)->var[77l] > 0.000000)
    {
      double return_value_flam3_random01_71;
      return_value_flam3_random01_71=flam3_random01();
      (cp->xform + (signed long int)i)->wedge_angle = 3.14159265358979323846 * return_value_flam3_random01_71;
      double return_value_flam3_random11_72;
      return_value_flam3_random11_72=flam3_random11();
      (cp->xform + (signed long int)i)->wedge_hole = 0.5 * return_value_flam3_random11_72;
      double return_value_flam3_random01_73;
      return_value_flam3_random01_73=flam3_random01();
      double return_value_floor_74;
      return_value_floor_74=floor((double)5 * return_value_flam3_random01_73);
      (cp->xform + (signed long int)i)->wedge_count = return_value_floor_74 + (double)1;
      (cp->xform + (signed long int)i)->wedge_swirl=flam3_random01();
    }

    if((cp->xform + (signed long int)i)->var[78l] > 0.000000)
    {
      double return_value_flam3_random01_75;
      return_value_flam3_random01_75=flam3_random01();
      (cp->xform + (signed long int)i)->wedge_julia_power = (double)(signed int)((double)5 * return_value_flam3_random01_75 + (double)2);
      (cp->xform + (signed long int)i)->wedge_julia_dist = 1.0;
      double return_value_flam3_random01_76;
      return_value_flam3_random01_76=flam3_random01();
      (cp->xform + (signed long int)i)->wedge_julia_count = (double)(signed int)((double)3 * return_value_flam3_random01_76 + (double)1);
      double return_value_flam3_random01_77;
      return_value_flam3_random01_77=flam3_random01();
      (cp->xform + (signed long int)i)->wedge_julia_angle = 3.14159265358979323846 * return_value_flam3_random01_77;
    }

    if((cp->xform + (signed long int)i)->var[79l] > 0.000000)
    {
      double return_value_flam3_random01_78;
      return_value_flam3_random01_78=flam3_random01();
      (cp->xform + (signed long int)i)->wedge_sph_angle = 3.14159265358979323846 * return_value_flam3_random01_78;
      double return_value_flam3_random11_79;
      return_value_flam3_random11_79=flam3_random11();
      (cp->xform + (signed long int)i)->wedge_sph_hole = 0.5 * return_value_flam3_random11_79;
      double return_value_flam3_random01_80;
      return_value_flam3_random01_80=flam3_random01();
      double return_value_floor_81;
      return_value_floor_81=floor((double)5 * return_value_flam3_random01_80);
      (cp->xform + (signed long int)i)->wedge_sph_count = return_value_floor_81 + (double)1;
      (cp->xform + (signed long int)i)->wedge_sph_swirl=flam3_random01();
    }

    if((cp->xform + (signed long int)i)->var[80l] > 0.000000)
    {
      (cp->xform + (signed long int)i)->whorl_inside=flam3_random01();
      (cp->xform + (signed long int)i)->whorl_outside=flam3_random01();
    }

    if((cp->xform + (signed long int)i)->var[81l] > 0.000000)
    {
      double return_value_flam3_random01_82;
      return_value_flam3_random01_82=flam3_random01();
      (cp->xform + (signed long int)i)->waves2_scalex = 0.5 + return_value_flam3_random01_82;
      double return_value_flam3_random01_83;
      return_value_flam3_random01_83=flam3_random01();
      (cp->xform + (signed long int)i)->waves2_scaley = 0.5 + return_value_flam3_random01_83;
      double return_value_flam3_random01_84;
      return_value_flam3_random01_84=flam3_random01();
      (cp->xform + (signed long int)i)->waves2_freqx = (double)4 * return_value_flam3_random01_84;
      double return_value_flam3_random01_85;
      return_value_flam3_random01_85=flam3_random01();
      (cp->xform + (signed long int)i)->waves2_freqy = (double)4 * return_value_flam3_random01_85;
    }

    if((cp->xform + (signed long int)i)->var[96l] > 0.000000)
    {
      (cp->xform + (signed long int)i)->auger_sym = (double)0;
      double return_value_flam3_random01_86;
      return_value_flam3_random01_86=flam3_random01();
      (cp->xform + (signed long int)i)->auger_weight = 0.5 + return_value_flam3_random01_86 / 2.0;
      double return_value_flam3_random01_87;
      return_value_flam3_random01_87=flam3_random01();
      double return_value_floor_88;
      return_value_floor_88=floor((double)5 * return_value_flam3_random01_87);
      (cp->xform + (signed long int)i)->auger_freq = return_value_floor_88 + (double)1;
      (cp->xform + (signed long int)i)->auger_scale=flam3_random01();
    }

    if((cp->xform + (signed long int)i)->var[97l] > 0.000000)
    {
      double return_value_flam3_random01_89;
      return_value_flam3_random01_89=flam3_random01();
      (cp->xform + (signed long int)i)->flux_spread = 0.5 + return_value_flam3_random01_89 / 2.0;
    }

  }
  _Bool tmp_if_expr_91;
  signed long int return_value_random_90;
  if(!(sym == 0))
    tmp_if_expr_91 = (_Bool)1;

  else
  {
    return_value_random_90=random();
    tmp_if_expr_91 = (!(return_value_random_90 % (signed long int)4 != 0l) ? (!(addfinal != 0) ? (_Bool)1 : (_Bool)0) : (_Bool)0) ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_91)
    flam3_add_symmetry(cp, sym);

  else
    cp->symmetry = 0;
}

// flam3_random01
// file flam3.c line 2364
double flam3_random01()
{
  signed long int return_value_random_1;
  return_value_random_1=random();
  return (double)(return_value_random_1 & (signed long int)0xfffffff) / (double)0xfffffff;
}

// flam3_random11
// file flam3.c line 2368
double flam3_random11()
{
  signed long int return_value_random_1;
  return_value_random_1=random();
  return (double)((return_value_random_1 & (signed long int)0xfffffff) - (signed long int)0x7ffffff) / (double)0x7ffffff;
}

// flam3_random_bit
// file flam3.h line 622
signed int flam3_random_bit()
{
  static signed int l;
  static signed int n = 0;
  if(n == 0)
  {
    signed long int return_value_random_1;
    return_value_random_1=random();
    l = (signed int)return_value_random_1;
    n = 20;
  }

  else
  {
    l = l >> 1;
    n = n - 1;
  }
  return l & 1;
}

// flam3_random_isaac_01
// file flam3.h line 625
double flam3_random_isaac_01(struct randctx *ct)
{
  unsigned long int tmp_post_1 = ct->randcnt;
  ct->randcnt = ct->randcnt - 1ul;
  unsigned long int tmp_if_expr_2;
  if(tmp_post_1 == 0ul)
  {
    isaac(ct);
    ct->randcnt = (unsigned long int)((1 << 4) - 1);
    tmp_if_expr_2 = ct->randrsl[(signed long int)ct->randcnt];
  }

  else
    tmp_if_expr_2 = ct->randrsl[(signed long int)ct->randcnt];
  return (double)((signed int)tmp_if_expr_2 & 0xfffffff) / (double)0xfffffff;
}

// flam3_random_isaac_11
// file flam3.h line 626
double flam3_random_isaac_11(struct randctx *ct)
{
  unsigned long int tmp_post_1 = ct->randcnt;
  ct->randcnt = ct->randcnt - 1ul;
  unsigned long int tmp_if_expr_2;
  if(tmp_post_1 == 0ul)
  {
    isaac(ct);
    ct->randcnt = (unsigned long int)((1 << 4) - 1);
    tmp_if_expr_2 = ct->randrsl[(signed long int)ct->randcnt];
  }

  else
    tmp_if_expr_2 = ct->randrsl[(signed long int)ct->randcnt];
  return (double)(((signed int)tmp_if_expr_2 & 0xfffffff) - 0x7ffffff) / (double)0x7ffffff;
}

// flam3_random_isaac_bit
// file flam3.h line 627
signed int flam3_random_isaac_bit(struct randctx *ct)
{
  signed int tmp;
  unsigned long int tmp_post_1 = ct->randcnt;
  ct->randcnt = ct->randcnt - 1ul;
  unsigned long int tmp_if_expr_2;
  if(tmp_post_1 == 0ul)
  {
    isaac(ct);
    ct->randcnt = (unsigned long int)((1 << 4) - 1);
    tmp_if_expr_2 = ct->randrsl[(signed long int)ct->randcnt];
  }

  else
    tmp_if_expr_2 = ct->randrsl[(signed long int)ct->randcnt];
  tmp = (signed int)tmp_if_expr_2;
  return tmp & 1;
}

// flam3_render
// file flam3.h line 613
signed int flam3_render(struct anonymous_4 *spec, void *out, signed int field, signed int nchan, signed int trans, struct anonymous_8 *stats)
{
  signed int retval;
  if(!(spec->nthreads >= 3))
    switch(spec->bits)
    {
      case 32:
      {
        retval=render_rectangle_int(spec, out, field, nchan, trans, stats);
        return retval;
      }
      case 33:
      {
        retval=render_rectangle_float(spec, out, field, nchan, trans, stats);
        return retval;
      }
      case 64:
      {
        retval=render_rectangle_double(spec, out, field, nchan, trans, stats);
        return retval;
      }
      default:
      {
        bits_error(spec);
        return 1;
      }
    }

  else
    switch(spec->bits)
    {
      case 32:
      {
        retval=render_rectangle_int_mt(spec, out, field, nchan, trans, stats);
        return retval;
      }
      case 33:
      {
        retval=render_rectangle_float_mt(spec, out, field, nchan, trans, stats);
        return retval;
      }
      case 64:
      {
        retval=render_rectangle_double_mt(spec, out, field, nchan, trans, stats);
        return retval;
      }
      default:
      {
        bits_error(spec);
        return 1;
      }
    }
}

// flam3_render_memory_required
// file flam3.c line 3730
double flam3_render_memory_required(struct anonymous_4 *spec)
{
  struct anonymous_0 *cps = spec->genomes;
  signed int real_bits = spec->bits;
  if(real_bits == 33)
    real_bits = 32;

  return (double)(cps + (signed long int)0)->spatial_oversample * (double)(cps + (signed long int)0)->spatial_oversample * (double)(cps + (signed long int)0)->width * (double)(cps + (signed long int)0)->height * (double)real_bits;
}

// flam3_rotate
// file flam3.c line 505
void flam3_rotate(struct anonymous_0 *cp, double by, signed int interpolation_type)
{
  signed int i = 0;
  for( ; !(i >= cp->num_xforms); i = i + 1)
  {
    double r[2l][2l];
    double T[2l][2l];
    double U[2l][2l];
    double dtheta = (by * 2.0 * 3.14159265358979323846) / 360.0;
    if(!IEEE_FLOAT_EQUAL((cp->xform + (signed long int)i)->animate, 0.0))
    {
      if((cp->xform + (signed long int)i)->padding == 1)
      {
        if(interpolation_type == 2)
          goto __CPROVER_DUMP_L7;

        if(interpolation_type == 3)
          goto __CPROVER_DUMP_L7;

        if(!(interpolation_type == 0))
          goto __CPROVER_DUMP_L5;

      }

      else
      {

      __CPROVER_DUMP_L5:
        ;
        if(cp->final_xform_enable == 1)
        {
          if(!(cp->final_xform_index == i))
            goto __CPROVER_DUMP_L6;

        }

        else
        {

        __CPROVER_DUMP_L6:
          ;
          r[(signed long int)0][(signed long int)0]=cos(dtheta);
          r[(signed long int)1][(signed long int)1] = r[(signed long int)0][(signed long int)0];
          r[(signed long int)0][(signed long int)1]=sin(dtheta);
          r[(signed long int)1][(signed long int)0] = -r[(signed long int)0][(signed long int)1];
          T[(signed long int)0][(signed long int)0] = (cp->xform + (signed long int)i)->c[(signed long int)0][(signed long int)0];
          T[(signed long int)1][(signed long int)0] = (cp->xform + (signed long int)i)->c[(signed long int)1][(signed long int)0];
          T[(signed long int)0][(signed long int)1] = (cp->xform + (signed long int)i)->c[(signed long int)0][(signed long int)1];
          T[(signed long int)1][(signed long int)1] = (cp->xform + (signed long int)i)->c[(signed long int)1][(signed long int)1];
          mult_matrix(r, T, U);
          (cp->xform + (signed long int)i)->c[(signed long int)0][(signed long int)0] = U[(signed long int)0][(signed long int)0];
          (cp->xform + (signed long int)i)->c[(signed long int)1][(signed long int)0] = U[(signed long int)1][(signed long int)0];
          (cp->xform + (signed long int)i)->c[(signed long int)0][(signed long int)1] = U[(signed long int)0][(signed long int)1];
          (cp->xform + (signed long int)i)->c[(signed long int)1][(signed long int)1] = U[(signed long int)1][(signed long int)1];
        }
      }
    }


  __CPROVER_DUMP_L7:
    ;
  }
}

// flam3_sinc
// file filters.c line 92
double flam3_sinc(double x)
{
  x = x * 3.14159265358979323846;
  double return_value_sin_1;
  if(IEEE_FLOAT_NOTEQUAL(x, 0.000000))
  {
    return_value_sin_1=sin(x);
    return return_value_sin_1 / x;
  }

  else
    return 1.0;
}

// flam3_spatial_filter
// file filters.c line 172
double flam3_spatial_filter(signed int knum, double x)
{
  double return_value_flam3_gaussian_filter_1;
  double return_value_flam3_hermite_filter_2;
  double return_value_flam3_box_filter_3;
  double return_value_flam3_triangle_filter_4;
  double return_value_flam3_bell_filter_5;
  double return_value_flam3_b_spline_filter_6;
  double return_value_flam3_mitchell_filter_7;
  double return_value_flam3_sinc_8;
  double return_value_flam3_blackman_filter_9;
  double return_value_flam3_catrom_filter_10;
  double return_value_flam3_sinc_11;
  double return_value_flam3_hanning_filter_12;
  double return_value_flam3_sinc_13;
  double return_value_flam3_hamming_filter_14;
  double return_value_flam3_lanczos3_filter_15;
  double return_value_flam3_sinc_16;
  double return_value_flam3_lanczos2_filter_17;
  double return_value_flam3_sinc_18;
  double return_value_flam3_quadratic_filter_19;
  if(knum == 0)
  {
    return_value_flam3_gaussian_filter_1=flam3_gaussian_filter(x);
    return return_value_flam3_gaussian_filter_1;
  }

  else
    if(knum == 1)
    {
      return_value_flam3_hermite_filter_2=flam3_hermite_filter(x);
      return return_value_flam3_hermite_filter_2;
    }

    else
      if(knum == 2)
      {
        return_value_flam3_box_filter_3=flam3_box_filter(x);
        return return_value_flam3_box_filter_3;
      }

      else
        if(knum == 3)
        {
          return_value_flam3_triangle_filter_4=flam3_triangle_filter(x);
          return return_value_flam3_triangle_filter_4;
        }

        else
          if(knum == 4)
          {
            return_value_flam3_bell_filter_5=flam3_bell_filter(x);
            return return_value_flam3_bell_filter_5;
          }

          else
            if(knum == 5)
            {
              return_value_flam3_b_spline_filter_6=flam3_b_spline_filter(x);
              return return_value_flam3_b_spline_filter_6;
            }

            else
              if(knum == 6)
              {
                return_value_flam3_mitchell_filter_7=flam3_mitchell_filter(x);
                return return_value_flam3_mitchell_filter_7;
              }

              else
                if(knum == 7)
                {
                  return_value_flam3_sinc_8=flam3_sinc(x);
                  return_value_flam3_blackman_filter_9=flam3_blackman_filter(x);
                  return return_value_flam3_sinc_8 * return_value_flam3_blackman_filter_9;
                }

                else
                  if(knum == 8)
                  {
                    return_value_flam3_catrom_filter_10=flam3_catrom_filter(x);
                    return return_value_flam3_catrom_filter_10;
                  }

                  else
                    if(knum == 9)
                    {
                      return_value_flam3_sinc_11=flam3_sinc(x);
                      return_value_flam3_hanning_filter_12=flam3_hanning_filter(x);
                      return return_value_flam3_sinc_11 * return_value_flam3_hanning_filter_12;
                    }

                    else
                      if(knum == 10)
                      {
                        return_value_flam3_sinc_13=flam3_sinc(x);
                        return_value_flam3_hamming_filter_14=flam3_hamming_filter(x);
                        return return_value_flam3_sinc_13 * return_value_flam3_hamming_filter_14;
                      }

                      else
                        if(knum == 11)
                        {
                          return_value_flam3_lanczos3_filter_15=flam3_lanczos3_filter(x);
                          return_value_flam3_sinc_16=flam3_sinc(x / 3.0);
                          return return_value_flam3_lanczos3_filter_15 * return_value_flam3_sinc_16;
                        }

                        else
                          if(knum == 12)
                          {
                            return_value_flam3_lanczos2_filter_17=flam3_lanczos2_filter(x);
                            return_value_flam3_sinc_18=flam3_sinc(x / 2.0);
                            return return_value_flam3_lanczos2_filter_17 * return_value_flam3_sinc_18;
                          }

                          else
                            if(knum == 13)
                            {
                              return_value_flam3_quadratic_filter_19=flam3_quadratic_filter(x);
                              return return_value_flam3_quadratic_filter_19;
                            }

}

// flam3_srandom
// file flam3.h line 635
void flam3_srandom()
{
  unsigned int seed;
  char *s;
  s=getenv("seed");
  signed int return_value_atoi_1;
  signed long int return_value_time_2;
  signed int return_value_getpid_3;
  if(!(s == ((char *)NULL)))
  {
    return_value_atoi_1=atoi_link1(s);
    seed = (unsigned int)return_value_atoi_1;
  }

  else
  {
    return_value_time_2=time(((signed long int *)NULL));
    return_value_getpid_3=getpid();
    seed = (unsigned int)(return_value_time_2 + (signed long int)return_value_getpid_3);
  }
  srandom(seed);
}

// flam3_triangle_filter
// file filters.c line 59
double flam3_triangle_filter(double t)
{
  if(t < 0.0)
    t = -t;

  if(t < 1.0)
    return 1.0 - t;

  else
    return 0.0;
}

// flam3_version
// file flam3.h line 34
char * flam3_version()
{
  signed int tmp_statement_expression_1;
  unsigned long int __s1_len;
  unsigned long int __s2_len;
  signed int return_value___builtin_strcmp_2;
  return_value___builtin_strcmp_2=__builtin_strcmp("", "exported");
  tmp_statement_expression_1 = return_value___builtin_strcmp_2;
  if(!(tmp_statement_expression_1 == 0))
    return "LNX-3.0.";

  else
    return "3.0";
}

// flam3_xform_preview
// file flam3.c line 296
signed int flam3_xform_preview(struct anonymous_0 *cp, signed int xi, double range, signed int numvals, signed int depth, double *result, struct randctx *rc)
{
  double p[4l];
  double incr;
  signed int outi;
  signed int xx;
  signed int yy;
  signed int dd;
  double oldweight;
  outi = 0;
  oldweight = (cp->xform + (signed long int)xi)->density;
  (cp->xform + (signed long int)xi)->density = 1.0;
  signed int return_value_prepare_precalc_flags_1;
  return_value_prepare_precalc_flags_1=prepare_precalc_flags(cp);
  if(!(return_value_prepare_precalc_flags_1 == 0))
  {
    (cp->xform + (signed long int)xi)->density = oldweight;
    return 1;
  }

  else
  {
    incr = range / (double)numvals;
    xform_precalc(cp, xi);
    xx = -numvals;
    for( ; numvals >= xx; xx = xx + 1)
    {
      yy = -numvals;
      for( ; numvals >= yy; yy = yy + 1)
      {
        p[(signed long int)0] = (double)xx * incr;
        p[(signed long int)1] = (double)yy * incr;
        dd = 0;
        for( ; !(dd >= depth); dd = dd + 1)
          apply_xform(cp, xi, p, p, rc);
        result[(signed long int)outi] = p[(signed long int)0];
        result[(signed long int)(outi + 1)] = p[(signed long int)1];
        outi = outi + 2;
      }
    }
    (cp->xform + (signed long int)xi)->density = oldweight;
    return 0;
  }
}

// get_extras
// file flam3-genome.c line 25
char * get_extras()
{
  char *e;
  e=getenv("extras");
  return e;
}

// get_stagger_coef
// file interpolation.c line 332
double get_stagger_coef(double t, double stagger_prc, signed int num_xforms, signed int this_xform)
{
  double max_stag = (double)(num_xforms - 1) / (double)num_xforms;
  double stag_scaled = stagger_prc * max_stag;
  double st = (stag_scaled * (double)((num_xforms - 1) - this_xform)) / (double)(num_xforms - 1);
  double et = st + ((double)1 - stag_scaled);
  double return_value_smoother_1;
  if(t <= st)
    return (double)0;

  else
    if(t >= et)
      return (double)1;

    else
    {
      return_value_smoother_1=smoother((t - st) / ((double)1 - stag_scaled));
      return return_value_smoother_1;
    }
}

// golden_bit
// file flam3-genome.c line 372
static double golden_bit(struct randctx *rc)
{
  signed int return_value_flam3_random_isaac_bit_1;
  return_value_flam3_random_isaac_bit_1=flam3_random_isaac_bit(rc);
  return return_value_flam3_random_isaac_bit_1 != 0 ? 0.38196 : 0.61804;
}

// gprint
// file flam3-genome.c line 30
void gprint(struct anonymous_0 *cp, signed int extras)
{
  char *return_value_getenv_5;
  return_value_getenv_5=getenv("noedits");
  char *tmp_if_expr_2;
  char *return_value_get_extras_1;
  char *tmp_if_expr_4;
  char *return_value_get_extras_3;
  if(!(return_value_getenv_5 == ((char *)NULL)))
  {
    if(!(extras == 0))
    {
      return_value_get_extras_1=get_extras();
      tmp_if_expr_2 = return_value_get_extras_1;
    }

    else
      tmp_if_expr_2 = (char *)(void *)0;
    flam3_print(stdout, cp, tmp_if_expr_2, 0);
  }

  else
  {
    if(!(extras == 0))
    {
      return_value_get_extras_3=get_extras();
      tmp_if_expr_4 = return_value_get_extras_3;
    }

    else
      tmp_if_expr_4 = (char *)(void *)0;
    flam3_print(stdout, cp, tmp_if_expr_4, 1);
  }
}

// hsv2rgb
// file palettes.h line 31
void hsv2rgb(double *hsv, double *rgb)
{
  double h = hsv[(signed long int)0];
  double s = hsv[(signed long int)1];
  double v = hsv[(signed long int)2];
  signed int j;
  double rd;
  double gd;
  double bd;
  double f;
  double p;
  double q;
  double t;
  for( ; h >= 6.0; h = h - 6.0)
    ;
  for( ; h < 0.0; h = h + 6.0)
    ;
  double return_value_floor_1;
  return_value_floor_1=floor(h);
  j = (signed int)return_value_floor_1;
  f = h - (double)j;
  p = v * ((double)1 - s);
  q = v * ((double)1 - s * f);
  t = v * ((double)1 - s * ((double)1 - f));
  switch(j)
  {
    case 0:
    {
      rd = v;
      gd = t;
      bd = p;
      break;
    }
    case 1:
    {
      rd = q;
      gd = v;
      bd = p;
      break;
    }
    case 2:
    {
      rd = p;
      gd = v;
      bd = t;
      break;
    }
    case 3:
    {
      rd = p;
      gd = q;
      bd = v;
      break;
    }
    case 4:
    {
      rd = t;
      gd = p;
      bd = v;
      break;
    }
    case 5:
    {
      rd = v;
      gd = p;
      bd = q;
      break;
    }
    default:
    {
      rd = v;
      gd = t;
      bd = p;
    }
  }
  rgb[(signed long int)0] = rd;
  rgb[(signed long int)1] = gd;
  rgb[(signed long int)2] = bd;
}

// id_matrix
// file interpolation.h line 38
signed int id_matrix(double (*s)[2l])
{
  _Bool tmp_if_expr_1;
  if(IEEE_FLOAT_EQUAL((*s)[0l], 1.0))
    tmp_if_expr_1 = IEEE_FLOAT_EQUAL(s[(signed long int)0][(signed long int)1], 0.0) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = IEEE_FLOAT_EQUAL(s[(signed long int)1][(signed long int)0], 0.0) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    tmp_if_expr_3 = IEEE_FLOAT_EQUAL(s[(signed long int)1][(signed long int)1], 1.0) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_3 = (_Bool)0;
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_3)
    tmp_if_expr_4 = IEEE_FLOAT_EQUAL(s[(signed long int)2][(signed long int)0], 0.0) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_4 = (_Bool)0;
  _Bool tmp_if_expr_5;
  if(tmp_if_expr_4)
    tmp_if_expr_5 = IEEE_FLOAT_EQUAL(s[(signed long int)2][(signed long int)1], 0.0) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_5 = (_Bool)0;
  return (signed int)tmp_if_expr_5;
}

// init_palettes
// file palettes.c line 89
static signed int init_palettes(char *filename)
{
  struct _IO_FILE *fp;
  struct _xmlDoc *doc;
  struct _xmlNode *rootnode;
  signed int i;
  signed int c;
  signed int slen = 5000;
  char *s;
  fp=fopen(filename, "rb");
  signed int tmp_post_3;
  if(fp == ((struct _IO_FILE *)NULL))
  {
    fprintf(stderr, "flam3: could not open palette file ");
    perror(filename);
    return -1;
  }

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)slen);
    s = (char *)return_value_malloc_1;
    i = 0;
    do
    {
      c=_IO_getc(fp);
      if(c == -1)
      {
        signed int return_value_ferror_2;
        return_value_ferror_2=ferror(fp);
        if(!(return_value_ferror_2 == 0))
        {
          perror(filename);
          return -1;
        }

        break;
      }

      tmp_post_3 = i;
      i = i + 1;
      s[(signed long int)tmp_post_3] = (char)c;
      if(i == slen + -1)
      {
        slen = slen * 2;
        void *return_value_realloc_4;
        return_value_realloc_4=realloc((void *)s, (unsigned long int)slen);
        s = (char *)return_value_realloc_4;
      }

    }
    while((_Bool)1);
    fclose(fp);
    s[(signed long int)i] = (char)0;
    unsigned long int return_value_strlen_5;
    return_value_strlen_5=strlen(s);
    doc=xmlReadMemory(s, (signed int)return_value_strlen_5, filename, (const char *)(void *)0, 2048);
    if(doc == ((struct _xmlDoc *)NULL))
    {
      fprintf(stderr, "error parsing %s (%s).\n", filename, s);
      return -1;
    }

    else
    {
      rootnode=xmlDocGetRootElement(doc);
      void *return_value_malloc_6;
      return_value_malloc_6=malloc(sizeof(struct anonymous_18) /*836ul*/ );
      the_palettes = (struct anonymous_18 *)return_value_malloc_6;
      npalettes = 0;
      parse_palettes(rootnode);
      xmlFreeDoc(doc);
      free((void *)s);
      xmlCleanupParser();
      return 1;
    }
  }
}

// initialize_xforms
// file variations.h line 140
void initialize_xforms(struct anonymous_0 *thiscp, signed int start_here)
{
  signed int i;
  signed int j;
  i = start_here;
  for( ; !(i >= thiscp->num_xforms); i = i + 1)
  {
    (thiscp->xform + (signed long int)i)->padding = 0;
    (thiscp->xform + (signed long int)i)->density = 0.0;
    (thiscp->xform + (signed long int)i)->color_speed = 0.5;
    (thiscp->xform + (signed long int)i)->animate = 1.0;
    (thiscp->xform + (signed long int)i)->color = (double)(i & 1);
    (thiscp->xform + (signed long int)i)->opacity = 1.0;
    (thiscp->xform + (signed long int)i)->var[(signed long int)0] = 1.0;
    (thiscp->xform + (signed long int)i)->motion_freq = 0;
    (thiscp->xform + (signed long int)i)->motion_func = 0;
    (thiscp->xform + (signed long int)i)->num_motion = 0;
    (thiscp->xform + (signed long int)i)->motion = (struct xform *)(void *)0;
    j = 1;
    for( ; !(j >= 98); j = j + 1)
      (thiscp->xform + (signed long int)i)->var[(signed long int)j] = 0.0;
    (thiscp->xform + (signed long int)i)->c[(signed long int)0][(signed long int)0] = 1.0;
    (thiscp->xform + (signed long int)i)->c[(signed long int)0][(signed long int)1] = 0.0;
    (thiscp->xform + (signed long int)i)->c[(signed long int)1][(signed long int)0] = 0.0;
    (thiscp->xform + (signed long int)i)->c[(signed long int)1][(signed long int)1] = 1.0;
    (thiscp->xform + (signed long int)i)->c[(signed long int)2][(signed long int)0] = 0.0;
    (thiscp->xform + (signed long int)i)->c[(signed long int)2][(signed long int)1] = 0.0;
    (thiscp->xform + (signed long int)i)->post[(signed long int)0][(signed long int)0] = 1.0;
    (thiscp->xform + (signed long int)i)->post[(signed long int)0][(signed long int)1] = 0.0;
    (thiscp->xform + (signed long int)i)->post[(signed long int)1][(signed long int)0] = 0.0;
    (thiscp->xform + (signed long int)i)->post[(signed long int)1][(signed long int)1] = 1.0;
    (thiscp->xform + (signed long int)i)->post[(signed long int)2][(signed long int)0] = 0.0;
    (thiscp->xform + (signed long int)i)->post[(signed long int)2][(signed long int)1] = 0.0;
    (thiscp->xform + (signed long int)i)->wind[(signed long int)0] = 0.0;
    (thiscp->xform + (signed long int)i)->wind[(signed long int)1] = 0.0;
    (thiscp->xform + (signed long int)i)->blob_low = 0.0;
    (thiscp->xform + (signed long int)i)->blob_high = 1.0;
    (thiscp->xform + (signed long int)i)->blob_waves = 1.0;
    (thiscp->xform + (signed long int)i)->pdj_a = 0.0;
    (thiscp->xform + (signed long int)i)->pdj_b = 0.0;
    (thiscp->xform + (signed long int)i)->pdj_c = 0.0;
    (thiscp->xform + (signed long int)i)->pdj_d = 0.0;
    (thiscp->xform + (signed long int)i)->fan2_x = 0.0;
    (thiscp->xform + (signed long int)i)->fan2_y = 0.0;
    (thiscp->xform + (signed long int)i)->rings2_val = 0.0;
    (thiscp->xform + (signed long int)i)->perspective_angle = 0.0;
    (thiscp->xform + (signed long int)i)->perspective_dist = 0.0;
    (thiscp->xform + (signed long int)i)->persp_vsin = 0.0;
    (thiscp->xform + (signed long int)i)->persp_vfcos = 0.0;
    (thiscp->xform + (signed long int)i)->radial_blur_angle = 0.0;
    (thiscp->xform + (signed long int)i)->disc2_rot = 0.0;
    (thiscp->xform + (signed long int)i)->disc2_twist = 0.0;
    (thiscp->xform + (signed long int)i)->disc2_sinadd = 0.0;
    (thiscp->xform + (signed long int)i)->disc2_cosadd = 0.0;
    (thiscp->xform + (signed long int)i)->disc2_timespi = 0.0;
    (thiscp->xform + (signed long int)i)->flower_petals = 0.0;
    (thiscp->xform + (signed long int)i)->flower_holes = 0.0;
    (thiscp->xform + (signed long int)i)->parabola_height = 0.0;
    (thiscp->xform + (signed long int)i)->parabola_width = 0.0;
    (thiscp->xform + (signed long int)i)->bent2_x = 1.0;
    (thiscp->xform + (signed long int)i)->bent2_y = 1.0;
    (thiscp->xform + (signed long int)i)->bipolar_shift = 0.0;
    (thiscp->xform + (signed long int)i)->cell_size = 1.0;
    (thiscp->xform + (signed long int)i)->cpow_r = 1.0;
    (thiscp->xform + (signed long int)i)->cpow_i = 0.0;
    (thiscp->xform + (signed long int)i)->cpow_power = 1.0;
    (thiscp->xform + (signed long int)i)->curve_xamp = 0.0;
    (thiscp->xform + (signed long int)i)->curve_yamp = 0.0;
    (thiscp->xform + (signed long int)i)->curve_xlength = 1.0;
    (thiscp->xform + (signed long int)i)->curve_ylength = 1.0;
    (thiscp->xform + (signed long int)i)->escher_beta = 0.0;
    (thiscp->xform + (signed long int)i)->lazysusan_space = 0.0;
    (thiscp->xform + (signed long int)i)->lazysusan_twist = 0.0;
    (thiscp->xform + (signed long int)i)->lazysusan_spin = 0.0;
    (thiscp->xform + (signed long int)i)->lazysusan_x = 0.0;
    (thiscp->xform + (signed long int)i)->lazysusan_y = 0.0;
    (thiscp->xform + (signed long int)i)->modulus_x = 0.0;
    (thiscp->xform + (signed long int)i)->modulus_y = 0.0;
    (thiscp->xform + (signed long int)i)->oscope_separation = 1.0;
    (thiscp->xform + (signed long int)i)->oscope_frequency = 3.14159265358979323846;
    (thiscp->xform + (signed long int)i)->oscope_amplitude = 1.0;
    (thiscp->xform + (signed long int)i)->oscope_damping = 0.0;
    (thiscp->xform + (signed long int)i)->popcorn2_c = 0.0;
    (thiscp->xform + (signed long int)i)->popcorn2_x = 0.0;
    (thiscp->xform + (signed long int)i)->popcorn2_y = 0.0;
    (thiscp->xform + (signed long int)i)->separation_x = 0.0;
    (thiscp->xform + (signed long int)i)->separation_xinside = 0.0;
    (thiscp->xform + (signed long int)i)->separation_y = 0.0;
    (thiscp->xform + (signed long int)i)->separation_yinside = 0.0;
    (thiscp->xform + (signed long int)i)->split_xsize = 0.0;
    (thiscp->xform + (signed long int)i)->split_ysize = 0.0;
    (thiscp->xform + (signed long int)i)->splits_x = 0.0;
    (thiscp->xform + (signed long int)i)->splits_y = 0.0;
    (thiscp->xform + (signed long int)i)->stripes_space = 0.0;
    (thiscp->xform + (signed long int)i)->stripes_warp = 0.0;
    (thiscp->xform + (signed long int)i)->wedge_angle = 0.0;
    (thiscp->xform + (signed long int)i)->wedge_hole = 0.0;
    (thiscp->xform + (signed long int)i)->wedge_count = 1.0;
    (thiscp->xform + (signed long int)i)->wedge_swirl = 0.0;
    (thiscp->xform + (signed long int)i)->wedge_sph_angle = 0.0;
    (thiscp->xform + (signed long int)i)->wedge_sph_hole = 0.0;
    (thiscp->xform + (signed long int)i)->wedge_sph_count = 1.0;
    (thiscp->xform + (signed long int)i)->wedge_sph_swirl = 0.0;
    (thiscp->xform + (signed long int)i)->wedge_julia_power = 1.0;
    (thiscp->xform + (signed long int)i)->wedge_julia_dist = 0.0;
    (thiscp->xform + (signed long int)i)->wedge_julia_count = 1.0;
    (thiscp->xform + (signed long int)i)->wedge_julia_angle = 0.0;
    (thiscp->xform + (signed long int)i)->wedgeJulia_cf = 0.0;
    (thiscp->xform + (signed long int)i)->wedgeJulia_cn = 0.5;
    (thiscp->xform + (signed long int)i)->wedgeJulia_rN = 1.0;
    (thiscp->xform + (signed long int)i)->whorl_inside = 0.0;
    (thiscp->xform + (signed long int)i)->whorl_outside = 0.0;
    (thiscp->xform + (signed long int)i)->waves2_scalex = 0.0;
    (thiscp->xform + (signed long int)i)->waves2_scaley = 0.0;
    (thiscp->xform + (signed long int)i)->waves2_freqx = 0.0;
    (thiscp->xform + (signed long int)i)->waves2_freqy = 0.0;
    (thiscp->xform + (signed long int)i)->auger_freq = 1.0;
    (thiscp->xform + (signed long int)i)->auger_weight = 0.5;
    (thiscp->xform + (signed long int)i)->auger_sym = 0.0;
    (thiscp->xform + (signed long int)i)->auger_scale = 1.0;
    (thiscp->xform + (signed long int)i)->flux_spread = 0.0;
    (thiscp->xform + (signed long int)i)->julian_power = 1.0;
    (thiscp->xform + (signed long int)i)->julian_dist = 1.0;
    (thiscp->xform + (signed long int)i)->julian_rN = 1.0;
    (thiscp->xform + (signed long int)i)->julian_cn = 0.5;
    (thiscp->xform + (signed long int)i)->juliascope_power = 1.0;
    (thiscp->xform + (signed long int)i)->juliascope_dist = 1.0;
    (thiscp->xform + (signed long int)i)->juliascope_rN = 1.0;
    (thiscp->xform + (signed long int)i)->juliascope_cn = 0.5;
    (thiscp->xform + (signed long int)i)->radialBlur_spinvar = 0.0;
    (thiscp->xform + (signed long int)i)->radialBlur_zoomvar = 1.0;
    (thiscp->xform + (signed long int)i)->pie_slices = 6.0;
    (thiscp->xform + (signed long int)i)->pie_rotation = 0.0;
    (thiscp->xform + (signed long int)i)->pie_thickness = 0.5;
    (thiscp->xform + (signed long int)i)->ngon_sides = (double)5;
    (thiscp->xform + (signed long int)i)->ngon_power = (double)3;
    (thiscp->xform + (signed long int)i)->ngon_circle = (double)1;
    (thiscp->xform + (signed long int)i)->ngon_corners = (double)2;
    (thiscp->xform + (signed long int)i)->curl_c1 = 1.0;
    (thiscp->xform + (signed long int)i)->curl_c2 = 0.0;
    (thiscp->xform + (signed long int)i)->rectangles_x = 1.0;
    (thiscp->xform + (signed long int)i)->rectangles_y = 1.0;
    (thiscp->xform + (signed long int)i)->amw_amp = 1.0;
    (thiscp->xform + (signed long int)i)->super_shape_rnd = 0.0;
    (thiscp->xform + (signed long int)i)->super_shape_m = 0.0;
    (thiscp->xform + (signed long int)i)->super_shape_n1 = 1.0;
    (thiscp->xform + (signed long int)i)->super_shape_n2 = 1.0;
    (thiscp->xform + (signed long int)i)->super_shape_n3 = 1.0;
    (thiscp->xform + (signed long int)i)->super_shape_holes = 0.0;
    (thiscp->xform + (signed long int)i)->conic_eccentricity = 1.0;
    (thiscp->xform + (signed long int)i)->conic_holes = 0.0;
  }
}

// interp_and_convert_back
// file interpolation.c line 183
void interp_and_convert_back(double *c, signed int ncps, signed int xfi, double (*cxang)[2l], double (*cxmag)[2l], double (*cxtrn)[2l], double (*store_array)[2l])
{
  signed int i;
  signed int col;
  double accang[2l];
  double accmag[2l];
  double expmag;
  signed int accmode[2l];
  accang[(signed long int)0] = 0.0;
  accang[(signed long int)1] = 0.0;
  accmag[(signed long int)0] = 0.0;
  accmag[(signed long int)1] = 0.0;
  accmode[(signed long int)1] = 0;
  accmode[(signed long int)0] = accmode[(signed long int)1];
  col = 0;
  for( ; !(col >= 2); col = col + 1)
  {
    i = 0;
    for( ; !(i >= ncps); i = i + 1)
    {
      double return_value_log_1;
      return_value_log_1=log(cxmag[(signed long int)i][(signed long int)col]);
      if(return_value_log_1 < -10.000000)
        accmode[(signed long int)col] = 1;

    }
  }
  i = 0;
  double return_value_log_2;
  for( ; !(i >= ncps); i = i + 1)
  {
    col = 0;
    for( ; !(col >= 2); col = col + 1)
    {
      accang[(signed long int)col] = accang[(signed long int)col] + c[(signed long int)i] * cxang[(signed long int)i][(signed long int)col];
      if(accmode[(signed long int)col] == 0)
      {
        return_value_log_2=log(cxmag[(signed long int)i][(signed long int)col]);
        accmag[(signed long int)col] = accmag[(signed long int)col] + c[(signed long int)i] * return_value_log_2;
      }

      else
        accmag[(signed long int)col] = accmag[(signed long int)col] + c[(signed long int)i] * cxmag[(signed long int)i][(signed long int)col];
      store_array[(signed long int)2][(signed long int)col] = store_array[(signed long int)2][(signed long int)col] + c[(signed long int)i] * cxtrn[(signed long int)i][(signed long int)col];
    }
  }
  col = 0;
  for( ; !(col >= 2); col = col + 1)
  {
    if(accmode[(signed long int)col] == 0)
      expmag=exp(accmag[(signed long int)col]);

    else
      expmag = accmag[(signed long int)col];
    double return_value_cos_3;
    return_value_cos_3=cos(accang[(signed long int)col]);
    store_array[(signed long int)col][(signed long int)0] = expmag * return_value_cos_3;
    double return_value_sin_4;
    return_value_sin_4=sin(accang[(signed long int)col]);
    store_array[(signed long int)col][(signed long int)1] = expmag * return_value_sin_4;
  }
}

// interpolate_catmull_rom
// file interpolation.h line 54
void interpolate_catmull_rom(struct anonymous_0 *cps, double t, struct anonymous_0 *result)
{
  double t2 = t * t;
  double t3 = t2 * t;
  double cmc[4l];
  cmc[(signed long int)0] = (((double)2 * t2 - t) - t3) / (double)2;
  cmc[(signed long int)1] = (((double)3 * t3 - (double)5 * t2) + (double)2) / (double)2;
  cmc[(signed long int)2] = (((double)4 * t2 - (double)3 * t3) + t) / (double)2;
  cmc[(signed long int)3] = (t3 - t2) / (double)2;
  flam3_interpolate_n(result, 4, cps, cmc, (double)0);
}

// interpolate_cmap
// file interpolation.h line 47
void interpolate_cmap(struct anonymous_1 *cmap, double blend, signed int index0, double hue0, signed int index1, double hue1)
{
  struct anonymous_1 p0[256l];
  struct anonymous_1 p1[256l];
  signed int i;
  signed int j;
  signed int rcode;
  rcode=flam3_get_palette(index0, p0, hue0);
  if(!(rcode >= 0))
    fprintf(stderr, "unable to retrieve palette %d, setting to white\n", index0);

  rcode=flam3_get_palette(index1, p1, hue1);
  if(!(rcode >= 0))
    fprintf(stderr, "unable to retrieve palette %d, setting to white\n", index1);

  i = 0;
  for( ; !(i >= 256); i = i + 1)
  {
    double t[5l];
    double s[5l];
    rgb2hsv(p0[(signed long int)i].color, s);
    rgb2hsv(p1[(signed long int)i].color, t);
    s[(signed long int)3] = p0[(signed long int)i].color[(signed long int)3];
    t[(signed long int)3] = p1[(signed long int)i].color[(signed long int)3];
    s[(signed long int)4] = p0[(signed long int)i].index;
    t[(signed long int)4] = p1[(signed long int)i].index;
    j = 0;
    for( ; !(j >= 5); j = j + 1)
      t[(signed long int)j] = (1.0 - blend) * s[(signed long int)j] + blend * t[(signed long int)j];
    hsv2rgb(t, (cmap + (signed long int)i)->color);
    (cmap + (signed long int)i)->color[(signed long int)3] = t[(signed long int)3];
    (cmap + (signed long int)i)->index = t[(signed long int)4];
  }
}

// irandinit
// file isaac.h line 39
void irandinit(struct randctx *ctx, signed int flag)
{
  signed int i;
  unsigned long int a;
  unsigned long int b;
  unsigned long int c;
  unsigned long int d;
  unsigned long int e;
  unsigned long int f;
  unsigned long int g;
  unsigned long int h;
  unsigned long int *m;
  unsigned long int *r;
  ctx->randc = (unsigned long int)0;
  ctx->randb = ctx->randc;
  ctx->randa = ctx->randb;
  m = ctx->randmem;
  r = ctx->randrsl;
  h = (unsigned long int)0x9e3779b9;
  g = h;
  f = g;
  e = f;
  d = e;
  c = d;
  b = c;
  a = b;
  i = 0;
  for( ; !(i >= 4); i = i + 1)
  {
    a = a ^ b << 11;
    d = d + a;
    b = b + c;
    b = b ^ c >> 2;
    e = e + b;
    c = c + d;
    c = c ^ d << 8;
    f = f + c;
    d = d + e;
    d = d ^ e >> 16;
    g = g + d;
    e = e + f;
    e = e ^ f << 10;
    h = h + e;
    f = f + g;
    f = f ^ g >> 4;
    a = a + f;
    g = g + h;
    g = g ^ h << 8;
    b = b + g;
    h = h + a;
    h = h ^ a >> 9;
    c = c + h;
    a = a + b;
  }
  if(!(flag == 0))
  {
    i = 0;
    for( ; !(i >= 16); i = i + 8)
    {
      a = a + r[(signed long int)i];
      b = b + r[(signed long int)(i + 1)];
      c = c + r[(signed long int)(i + 2)];
      d = d + r[(signed long int)(i + 3)];
      e = e + r[(signed long int)(i + 4)];
      f = f + r[(signed long int)(i + 5)];
      g = g + r[(signed long int)(i + 6)];
      h = h + r[(signed long int)(i + 7)];
      a = a ^ b << 11;
      d = d + a;
      b = b + c;
      b = b ^ c >> 2;
      e = e + b;
      c = c + d;
      c = c ^ d << 8;
      f = f + c;
      d = d + e;
      d = d ^ e >> 16;
      g = g + d;
      e = e + f;
      e = e ^ f << 10;
      h = h + e;
      f = f + g;
      f = f ^ g >> 4;
      a = a + f;
      g = g + h;
      g = g ^ h << 8;
      b = b + g;
      h = h + a;
      h = h ^ a >> 9;
      c = c + h;
      a = a + b;
      m[(signed long int)i] = a;
      m[(signed long int)(i + 1)] = b;
      m[(signed long int)(i + 2)] = c;
      m[(signed long int)(i + 3)] = d;
      m[(signed long int)(i + 4)] = e;
      m[(signed long int)(i + 5)] = f;
      m[(signed long int)(i + 6)] = g;
      m[(signed long int)(i + 7)] = h;
    }
    i = 0;
    for( ; !(i >= 16); i = i + 8)
    {
      a = a + m[(signed long int)i];
      b = b + m[(signed long int)(i + 1)];
      c = c + m[(signed long int)(i + 2)];
      d = d + m[(signed long int)(i + 3)];
      e = e + m[(signed long int)(i + 4)];
      f = f + m[(signed long int)(i + 5)];
      g = g + m[(signed long int)(i + 6)];
      h = h + m[(signed long int)(i + 7)];
      a = a ^ b << 11;
      d = d + a;
      b = b + c;
      b = b ^ c >> 2;
      e = e + b;
      c = c + d;
      c = c ^ d << 8;
      f = f + c;
      d = d + e;
      d = d ^ e >> 16;
      g = g + d;
      e = e + f;
      e = e ^ f << 10;
      h = h + e;
      f = f + g;
      f = f ^ g >> 4;
      a = a + f;
      g = g + h;
      g = g ^ h << 8;
      b = b + g;
      h = h + a;
      h = h ^ a >> 9;
      c = c + h;
      a = a + b;
      m[(signed long int)i] = a;
      m[(signed long int)(i + 1)] = b;
      m[(signed long int)(i + 2)] = c;
      m[(signed long int)(i + 3)] = d;
      m[(signed long int)(i + 4)] = e;
      m[(signed long int)(i + 5)] = f;
      m[(signed long int)(i + 6)] = g;
      m[(signed long int)(i + 7)] = h;
    }
  }

  else
  {
    i = 0;
    for( ; !(i >= 16); i = i + 8)
    {
      a = a ^ b << 11;
      d = d + a;
      b = b + c;
      b = b ^ c >> 2;
      e = e + b;
      c = c + d;
      c = c ^ d << 8;
      f = f + c;
      d = d + e;
      d = d ^ e >> 16;
      g = g + d;
      e = e + f;
      e = e ^ f << 10;
      h = h + e;
      f = f + g;
      f = f ^ g >> 4;
      a = a + f;
      g = g + h;
      g = g ^ h << 8;
      b = b + g;
      h = h + a;
      h = h ^ a >> 9;
      c = c + h;
      a = a + b;
      m[(signed long int)i] = a;
      m[(signed long int)(i + 1)] = b;
      m[(signed long int)(i + 2)] = c;
      m[(signed long int)(i + 3)] = d;
      m[(signed long int)(i + 4)] = e;
      m[(signed long int)(i + 5)] = f;
      m[(signed long int)(i + 6)] = g;
      m[(signed long int)(i + 7)] = h;
    }
  }
  isaac(ctx);
  ctx->randcnt = (unsigned long int)(1 << 4);
}

// isaac
// file isaac.h line 41
void isaac(struct randctx *ctx)
{
  unsigned long int a;
  unsigned long int b;
  unsigned long int x;
  unsigned long int y;
  unsigned long int *m;
  unsigned long int *mm;
  unsigned long int *m2;
  unsigned long int *r;
  unsigned long int *mend;
  mm = ctx->randmem;
  r = ctx->randrsl;
  a = ctx->randa;
  ctx->randc = ctx->randc + 1ul;
  b = ctx->randb + ctx->randc & (unsigned long int)0xffffffff;
  m = mm;
  m2 = m + (signed long int)((1 << 4) / 2);
  mend = m2;
  unsigned long int *tmp_post_1;
  unsigned long int *tmp_post_2;
  unsigned long int *tmp_post_3;
  unsigned long int *tmp_post_4;
  unsigned long int *tmp_post_5;
  unsigned long int *tmp_post_6;
  unsigned long int *tmp_post_7;
  unsigned long int *tmp_post_8;
  unsigned long int *tmp_post_9;
  unsigned long int *tmp_post_10;
  unsigned long int *tmp_post_11;
  unsigned long int *tmp_post_12;
  for( ; !(m >= mend); *tmp_post_12 = b)
  {
    x = *m;
    tmp_post_1 = m2;
    m2 = m2 + 1l;
    a = (a ^ a << 13) + *tmp_post_1 & (unsigned long int)0xffffffff;
    tmp_post_2 = m;
    m = m + 1l;
    y = mm[(signed long int)(x >> 2 & (unsigned long int)((1 << 4) - 1))] + a + b & (unsigned long int)0xffffffff;
    *tmp_post_2 = y;
    tmp_post_3 = r;
    r = r + 1l;
    b = mm[(signed long int)((y >> 4) >> 2 & (unsigned long int)((1 << 4) - 1))] + x & (unsigned long int)0xffffffff;
    *tmp_post_3 = b;
    x = *m;
    tmp_post_4 = m2;
    m2 = m2 + 1l;
    a = (a ^ a >> 6) + *tmp_post_4 & (unsigned long int)0xffffffff;
    tmp_post_5 = m;
    m = m + 1l;
    y = mm[(signed long int)(x >> 2 & (unsigned long int)((1 << 4) - 1))] + a + b & (unsigned long int)0xffffffff;
    *tmp_post_5 = y;
    tmp_post_6 = r;
    r = r + 1l;
    b = mm[(signed long int)((y >> 4) >> 2 & (unsigned long int)((1 << 4) - 1))] + x & (unsigned long int)0xffffffff;
    *tmp_post_6 = b;
    x = *m;
    tmp_post_7 = m2;
    m2 = m2 + 1l;
    a = (a ^ a << 2) + *tmp_post_7 & (unsigned long int)0xffffffff;
    tmp_post_8 = m;
    m = m + 1l;
    y = mm[(signed long int)(x >> 2 & (unsigned long int)((1 << 4) - 1))] + a + b & (unsigned long int)0xffffffff;
    *tmp_post_8 = y;
    tmp_post_9 = r;
    r = r + 1l;
    b = mm[(signed long int)((y >> 4) >> 2 & (unsigned long int)((1 << 4) - 1))] + x & (unsigned long int)0xffffffff;
    *tmp_post_9 = b;
    x = *m;
    tmp_post_10 = m2;
    m2 = m2 + 1l;
    a = (a ^ a >> 16) + *tmp_post_10 & (unsigned long int)0xffffffff;
    tmp_post_11 = m;
    m = m + 1l;
    y = mm[(signed long int)(x >> 2 & (unsigned long int)((1 << 4) - 1))] + a + b & (unsigned long int)0xffffffff;
    *tmp_post_11 = y;
    tmp_post_12 = r;
    r = r + 1l;
    b = mm[(signed long int)((y >> 4) >> 2 & (unsigned long int)((1 << 4) - 1))] + x & (unsigned long int)0xffffffff;
  }
  m2 = mm;
  unsigned long int *tmp_post_13;
  unsigned long int *tmp_post_14;
  unsigned long int *tmp_post_15;
  unsigned long int *tmp_post_16;
  unsigned long int *tmp_post_17;
  unsigned long int *tmp_post_18;
  unsigned long int *tmp_post_19;
  unsigned long int *tmp_post_20;
  unsigned long int *tmp_post_21;
  unsigned long int *tmp_post_22;
  unsigned long int *tmp_post_23;
  unsigned long int *tmp_post_24;
  for( ; !(m2 >= mend); *tmp_post_24 = b)
  {
    x = *m;
    tmp_post_13 = m2;
    m2 = m2 + 1l;
    a = (a ^ a << 13) + *tmp_post_13 & (unsigned long int)0xffffffff;
    tmp_post_14 = m;
    m = m + 1l;
    y = mm[(signed long int)(x >> 2 & (unsigned long int)((1 << 4) - 1))] + a + b & (unsigned long int)0xffffffff;
    *tmp_post_14 = y;
    tmp_post_15 = r;
    r = r + 1l;
    b = mm[(signed long int)((y >> 4) >> 2 & (unsigned long int)((1 << 4) - 1))] + x & (unsigned long int)0xffffffff;
    *tmp_post_15 = b;
    x = *m;
    tmp_post_16 = m2;
    m2 = m2 + 1l;
    a = (a ^ a >> 6) + *tmp_post_16 & (unsigned long int)0xffffffff;
    tmp_post_17 = m;
    m = m + 1l;
    y = mm[(signed long int)(x >> 2 & (unsigned long int)((1 << 4) - 1))] + a + b & (unsigned long int)0xffffffff;
    *tmp_post_17 = y;
    tmp_post_18 = r;
    r = r + 1l;
    b = mm[(signed long int)((y >> 4) >> 2 & (unsigned long int)((1 << 4) - 1))] + x & (unsigned long int)0xffffffff;
    *tmp_post_18 = b;
    x = *m;
    tmp_post_19 = m2;
    m2 = m2 + 1l;
    a = (a ^ a << 2) + *tmp_post_19 & (unsigned long int)0xffffffff;
    tmp_post_20 = m;
    m = m + 1l;
    y = mm[(signed long int)(x >> 2 & (unsigned long int)((1 << 4) - 1))] + a + b & (unsigned long int)0xffffffff;
    *tmp_post_20 = y;
    tmp_post_21 = r;
    r = r + 1l;
    b = mm[(signed long int)((y >> 4) >> 2 & (unsigned long int)((1 << 4) - 1))] + x & (unsigned long int)0xffffffff;
    *tmp_post_21 = b;
    x = *m;
    tmp_post_22 = m2;
    m2 = m2 + 1l;
    a = (a ^ a >> 16) + *tmp_post_22 & (unsigned long int)0xffffffff;
    tmp_post_23 = m;
    m = m + 1l;
    y = mm[(signed long int)(x >> 2 & (unsigned long int)((1 << 4) - 1))] + a + b & (unsigned long int)0xffffffff;
    *tmp_post_23 = y;
    tmp_post_24 = r;
    r = r + 1l;
    b = mm[(signed long int)((y >> 4) >> 2 & (unsigned long int)((1 << 4) - 1))] + x & (unsigned long int)0xffffffff;
  }
  ctx->randb = b;
  ctx->randa = a;
}

// iter_thread_double
// file rect.c line 253
static void iter_thread_double(void *fth)
{
  double sub_batch;
  signed int j;
  struct anonymous_13 *fthp = (struct anonymous_13 *)fth;
  struct anonymous_12 *ficp = fthp->fic;
  struct timespec pauset;
  signed int SBS = ficp->spec->sub_batch_size;
  signed int fuse;
  double eta = 0.0;
  fuse = ficp->spec->earlyclip != 0 ? 100 : 15;
  pauset.tv_sec = (signed long int)0;
  pauset.tv_nsec = (signed long int)100000000;
  if(!(fthp->timer_initialize == 0))
  {
    *ficp->progress_timer = (signed long int)0;
    memset((void *)ficp->progress_timer_history, 0, (unsigned long int)64 * sizeof(signed long int) /*8ul*/ );
    memset((void *)ficp->progress_history, 0, (unsigned long int)64 * sizeof(double) /*8ul*/ );
    *ficp->progress_history_mark = 0;
  }

  sub_batch = (double)0;
  double tmp_if_expr_1;
  double return_value_ceil_2;
  for( ; sub_batch < ficp->batch_size; sub_batch = sub_batch + (double)SBS)
  {
    signed int sub_batch_size;
    signed int badcount;
    signed long int newt;
    newt=time((signed long int *)(void *)0);
    if(sub_batch + (double)SBS > ficp->batch_size)
      tmp_if_expr_1 = ficp->batch_size - sub_batch;

    else
      tmp_if_expr_1 = (double)SBS;
    sub_batch_size = (signed int)tmp_if_expr_1;
    if(!(fthp->first_thread == 0))
    {
      if(!(newt == *ficp->progress_timer))
      {
        double iter_thread_double__1__2__1__1__percent = (100.0 * ((sub_batch / (double)ficp->batch_size + (double)ficp->temporal_sample_num) / (double)ficp->ntemporal_samples + (double)ficp->batch_num)) / (double)ficp->nbatches;
        signed int old_mark = 0;
        signed int ticker;
        if(!(ficp->spec->verbose == 0))
          fprintf(stderr, "\rchaos: %5.1f%%", iter_thread_double__1__2__1__1__percent);

        *ficp->progress_timer = newt;
        if(!(ficp->progress_timer_history[(signed long int)*ficp->progress_history_mark] == 0l))
        {
          if(ficp->progress_history[(signed long int)*ficp->progress_history_mark] < iter_thread_double__1__2__1__1__percent)
            old_mark = *ficp->progress_history_mark;

        }

        if(iter_thread_double__1__2__1__1__percent > 0.000000)
        {
          eta = (((double)100 - iter_thread_double__1__2__1__1__percent) * (double)(*ficp->progress_timer - ficp->progress_timer_history[(signed long int)old_mark])) / (iter_thread_double__1__2__1__1__percent - ficp->progress_history[(signed long int)old_mark]);
          if(!(ficp->spec->verbose == 0))
          {
            ticker = (*ficp->progress_timer & (signed long int)1) != 0l ? 58 : 46;
            if(eta < 1000.000000)
              ticker = 58;

            if(eta > 100.000000)
              fprintf(stderr, "  ETA%c %.1f minutes", ticker, eta / (double)60);

            else
            {
              return_value_ceil_2=ceil(eta);
              fprintf(stderr, "  ETA%c %ld seconds ", ticker, (signed long int)return_value_ceil_2);
            }
            fprintf(stderr, "              \r");
            fflush(stderr);
          }

        }

        ficp->progress_timer_history[(signed long int)*ficp->progress_history_mark] = *ficp->progress_timer;
        ficp->progress_history[(signed long int)*ficp->progress_history_mark] = iter_thread_double__1__2__1__1__percent;
        *ficp->progress_history_mark = (*ficp->progress_history_mark + 1) % 64;
      }

    }

    if(!(ficp->spec->progress == ((signed int (*)(void *, double, signed int, double))NULL)))
    {
      if(!(fthp->first_thread == 0))
      {
        signed int rv;
        double percent = (100.0 * ((sub_batch / (double)ficp->batch_size + (double)ficp->temporal_sample_num) / (double)ficp->ntemporal_samples + (double)ficp->batch_num)) / (double)ficp->nbatches;
        rv=ficp->spec->progress(ficp->spec->progress_parameter, percent, 0, eta);
        if(rv == 2)
        {
          signed long int tnow;
          tnow=time((signed long int *)(void *)0);
          signed long int tend;
          signed int lastpt;
          ficp->aborted = -1;
          nanosleep(&pauset, (struct timespec *)(void *)0);
          rv=ficp->spec->progress(ficp->spec->progress_parameter, percent, 0, eta);
          signed long int return_value_time_3;
          return_value_time_3=time((signed long int *)(void *)0);
          tend = return_value_time_3 - tnow;
          ficp->aborted = 0;
          lastpt = 0;
          if(!(lastpt >= 64))
          {
            if(!(ficp->progress_timer_history[(signed long int)lastpt] == 0l))
              ficp->progress_timer_history[(signed long int)lastpt] = ficp->progress_timer_history[(signed long int)lastpt] + tend;

            lastpt = lastpt + 1;
          }

        }

        if(rv == 1)
        {
          ficp->aborted = 1;
          pthread_exit((void *)0);
        }

      }

      else
      {
        if(!(ficp->aborted >= 0))
          do
            nanosleep(&pauset, (struct timespec *)(void *)0);
          while(ficp->aborted == -1);

        if(ficp->aborted >= 1)
          pthread_exit((void *)0);

      }
    }

    fthp->iter_storage[(signed long int)0]=flam3_random_isaac_11(&fthp->rc);
    fthp->iter_storage[(signed long int)1]=flam3_random_isaac_11(&fthp->rc);
    fthp->iter_storage[(signed long int)2]=flam3_random_isaac_01(&fthp->rc);
    fthp->iter_storage[(signed long int)3]=flam3_random_isaac_01(&fthp->rc);
    badcount=flam3_iterate(&fthp->cp, sub_batch_size, fuse, fthp->iter_storage, ficp->xform_distrib, &fthp->rc);
    pthread_mutex_lock(&ficp->bucket_mutex);
    ficp->badvals = ficp->badvals + (double)badcount;
    j = 0;
    for( ; !(j >= 4 * sub_batch_size); j = j + 4)
    {
      double p0;
      double p1;
      double p00;
      double p11;
      double dbl_index0;
      double dbl_frac;
      double interpcolor[4l];
      signed int ci;
      signed int color_index0;
      double *p = &fthp->iter_storage[(signed long int)j];
      double (*b)[5l];
      if(IEEE_FLOAT_NOTEQUAL(fthp->cp.rotate, 0.0))
      {
        p00 = p[(signed long int)0] - fthp->cp.rot_center[(signed long int)0];
        p11 = p[(signed long int)1] - fthp->cp.rot_center[(signed long int)1];
        p0 = p00 * ficp->rot[(signed long int)0][(signed long int)0] + p11 * ficp->rot[(signed long int)0][(signed long int)1] + fthp->cp.rot_center[(signed long int)0];
        p1 = p00 * ficp->rot[(signed long int)1][(signed long int)0] + p11 * ficp->rot[(signed long int)1][(signed long int)1] + fthp->cp.rot_center[(signed long int)1];
      }

      else
      {
        p0 = p[(signed long int)0];
        p1 = p[(signed long int)1];
      }
      if(p0 >= ficp->bounds[0l])
      {
        if(p1 >= ficp->bounds[1l])
        {
          if(p0 <= ficp->bounds[2l])
          {
            if(p1 <= ficp->bounds[3l])
            {
              double logvis = 1.0;
              double (*buckets)[5l] = (double (*)[5l])ficp->buckets;
              if(IEEE_FLOAT_EQUAL(p[3l], 0.000000))
                goto __CPROVER_DUMP_L49;

              else
                logvis = p[(signed long int)3];
              b = buckets + (signed long int)(signed int)(ficp->ws0 * p0 - ficp->wb0s0) + (signed long int)(ficp->width * (signed int)(ficp->hs1 * p1 - ficp->hb1s1));
              dbl_index0 = p[(signed long int)2] * (double)256;
              color_index0 = (signed int)dbl_index0;
              if(fthp->cp.palette_mode == 1)
              {
                if(!(color_index0 >= 0))
                {
                  color_index0 = 0;
                  dbl_frac = (double)0;
                }

                else
                  if(color_index0 >= 255)
                  {
                    color_index0 = 255 - 1;
                    dbl_frac = 1.0;
                  }

                  else
                    dbl_frac = dbl_index0 - (double)color_index0;
                ci = 0;
                for( ; !(ci >= 4); ci = ci + 1)
                  interpcolor[(signed long int)ci] = (ficp->dmap + (signed long int)color_index0)->color[(signed long int)ci] * (1.0 - dbl_frac) + (ficp->dmap + (signed long int)(color_index0 + 1))->color[(signed long int)ci] * dbl_frac;
              }

              else
              {
                if(!(color_index0 >= 0))
                  color_index0 = 0;

                else
                  if(color_index0 >= 255)
                    color_index0 = 255;

                ci = 0;
                for( ; !(ci >= 4); ci = ci + 1)
                  interpcolor[(signed long int)ci] = (ficp->dmap + (signed long int)color_index0)->color[(signed long int)ci];
              }
              if(IEEE_FLOAT_EQUAL(p[3l], 1.0))
              {
                do
                  b[(signed long int)0][(signed long int)0] = b[(signed long int)0][(signed long int)0] + interpcolor[(signed long int)0];
                while((_Bool)0);
                do
                  b[(signed long int)0][(signed long int)1] = b[(signed long int)0][(signed long int)1] + interpcolor[(signed long int)1];
                while((_Bool)0);
                do
                  b[(signed long int)0][(signed long int)2] = b[(signed long int)0][(signed long int)2] + interpcolor[(signed long int)2];
                while((_Bool)0);
                do
                  b[(signed long int)0][(signed long int)3] = b[(signed long int)0][(signed long int)3] + interpcolor[(signed long int)3];
                while((_Bool)0);
                do
                  b[(signed long int)0][(signed long int)4] = b[(signed long int)0][(signed long int)4] + 255.0;
                while((_Bool)0);
              }

              else
              {
                do
                  b[(signed long int)0][(signed long int)0] = b[(signed long int)0][(signed long int)0] + logvis * interpcolor[(signed long int)0];
                while((_Bool)0);
                do
                  b[(signed long int)0][(signed long int)1] = b[(signed long int)0][(signed long int)1] + logvis * interpcolor[(signed long int)1];
                while((_Bool)0);
                do
                  b[(signed long int)0][(signed long int)2] = b[(signed long int)0][(signed long int)2] + logvis * interpcolor[(signed long int)2];
                while((_Bool)0);
                do
                  b[(signed long int)0][(signed long int)3] = b[(signed long int)0][(signed long int)3] + logvis * interpcolor[(signed long int)3];
                while((_Bool)0);
                do
                  b[(signed long int)0][(signed long int)4] = b[(signed long int)0][(signed long int)4] + logvis * 255.0;
                while((_Bool)0);
              }
            }

          }

        }

      }


    __CPROVER_DUMP_L49:
      ;
    }
    pthread_mutex_unlock(&ficp->bucket_mutex);
  }
  pthread_exit((void *)0);
}

// iter_thread_double_mt
// file rect.c line 253
static void iter_thread_double_mt(void *fth)
{
  double sub_batch;
  signed int j;
  struct anonymous_13 *fthp = (struct anonymous_13 *)fth;
  struct anonymous_12 *ficp = fthp->fic;
  struct timespec pauset;
  signed int SBS = ficp->spec->sub_batch_size;
  signed int fuse;
  double eta = 0.0;
  fuse = ficp->spec->earlyclip != 0 ? 100 : 15;
  pauset.tv_sec = (signed long int)0;
  pauset.tv_nsec = (signed long int)100000000;
  if(!(fthp->timer_initialize == 0))
  {
    *ficp->progress_timer = (signed long int)0;
    memset((void *)ficp->progress_timer_history, 0, (unsigned long int)64 * sizeof(signed long int) /*8ul*/ );
    memset((void *)ficp->progress_history, 0, (unsigned long int)64 * sizeof(double) /*8ul*/ );
    *ficp->progress_history_mark = 0;
  }

  sub_batch = (double)0;
  double tmp_if_expr_1;
  double return_value_ceil_2;
  for( ; sub_batch < ficp->batch_size; sub_batch = sub_batch + (double)SBS)
  {
    signed int sub_batch_size;
    signed int badcount;
    signed long int newt;
    newt=time((signed long int *)(void *)0);
    if(sub_batch + (double)SBS > ficp->batch_size)
      tmp_if_expr_1 = ficp->batch_size - sub_batch;

    else
      tmp_if_expr_1 = (double)SBS;
    sub_batch_size = (signed int)tmp_if_expr_1;
    if(!(fthp->first_thread == 0))
    {
      if(!(newt == *ficp->progress_timer))
      {
        double percent = (100.0 * ((sub_batch / (double)ficp->batch_size + (double)ficp->temporal_sample_num) / (double)ficp->ntemporal_samples + (double)ficp->batch_num)) / (double)ficp->nbatches;
        signed int old_mark = 0;
        signed int ticker;
        if(!(ficp->spec->verbose == 0))
          fprintf(stderr, "\rchaos: %5.1f%%", percent);

        *ficp->progress_timer = newt;
        if(!(ficp->progress_timer_history[(signed long int)*ficp->progress_history_mark] == 0l))
        {
          if(ficp->progress_history[(signed long int)*ficp->progress_history_mark] < percent)
            old_mark = *ficp->progress_history_mark;

        }

        if(percent > 0.000000)
        {
          eta = (((double)100 - percent) * (double)(*ficp->progress_timer - ficp->progress_timer_history[(signed long int)old_mark])) / (percent - ficp->progress_history[(signed long int)old_mark]);
          if(!(ficp->spec->verbose == 0))
          {
            ticker = (*ficp->progress_timer & (signed long int)1) != 0l ? 58 : 46;
            if(eta < 1000.000000)
              ticker = 58;

            if(eta > 100.000000)
              fprintf(stderr, "  ETA%c %.1f minutes", ticker, eta / (double)60);

            else
            {
              return_value_ceil_2=ceil(eta);
              fprintf(stderr, "  ETA%c %ld seconds ", ticker, (signed long int)return_value_ceil_2);
            }
            fprintf(stderr, "              \r");
            fflush(stderr);
          }

        }

        ficp->progress_timer_history[(signed long int)*ficp->progress_history_mark] = *ficp->progress_timer;
        ficp->progress_history[(signed long int)*ficp->progress_history_mark] = percent;
        *ficp->progress_history_mark = (*ficp->progress_history_mark + 1) % 64;
      }

    }

    if(!(ficp->spec->progress == ((signed int (*)(void *, double, signed int, double))NULL)))
    {
      if(!(fthp->first_thread == 0))
      {
        signed int rv;
        double iter_thread_double_mt__1__2__1__2__1__percent = (100.0 * ((sub_batch / (double)ficp->batch_size + (double)ficp->temporal_sample_num) / (double)ficp->ntemporal_samples + (double)ficp->batch_num)) / (double)ficp->nbatches;
        rv=ficp->spec->progress(ficp->spec->progress_parameter, iter_thread_double_mt__1__2__1__2__1__percent, 0, eta);
        if(rv == 2)
        {
          signed long int tnow;
          tnow=time((signed long int *)(void *)0);
          signed long int tend;
          signed int lastpt;
          ficp->aborted = -1;
          nanosleep(&pauset, (struct timespec *)(void *)0);
          rv=ficp->spec->progress(ficp->spec->progress_parameter, iter_thread_double_mt__1__2__1__2__1__percent, 0, eta);
          signed long int return_value_time_3;
          return_value_time_3=time((signed long int *)(void *)0);
          tend = return_value_time_3 - tnow;
          ficp->aborted = 0;
          lastpt = 0;
          if(!(lastpt >= 64))
          {
            if(!(ficp->progress_timer_history[(signed long int)lastpt] == 0l))
              ficp->progress_timer_history[(signed long int)lastpt] = ficp->progress_timer_history[(signed long int)lastpt] + tend;

            lastpt = lastpt + 1;
          }

        }

        if(rv == 1)
        {
          ficp->aborted = 1;
          pthread_exit((void *)0);
        }

      }

      else
      {
        if(!(ficp->aborted >= 0))
          do
            nanosleep(&pauset, (struct timespec *)(void *)0);
          while(ficp->aborted == -1);

        if(ficp->aborted >= 1)
          pthread_exit((void *)0);

      }
    }

    fthp->iter_storage[(signed long int)0]=flam3_random_isaac_11(&fthp->rc);
    fthp->iter_storage[(signed long int)1]=flam3_random_isaac_11(&fthp->rc);
    fthp->iter_storage[(signed long int)2]=flam3_random_isaac_01(&fthp->rc);
    fthp->iter_storage[(signed long int)3]=flam3_random_isaac_01(&fthp->rc);
    badcount=flam3_iterate(&fthp->cp, sub_batch_size, fuse, fthp->iter_storage, ficp->xform_distrib, &fthp->rc);
    ficp->badvals = ficp->badvals + (double)badcount;
    j = 0;
    for( ; !(j >= 4 * sub_batch_size); j = j + 4)
    {
      double p0;
      double p1;
      double p00;
      double p11;
      double dbl_index0;
      double dbl_frac;
      double interpcolor[4l];
      signed int ci;
      signed int color_index0;
      double *p = &fthp->iter_storage[(signed long int)j];
      double (*b)[5l];
      if(IEEE_FLOAT_NOTEQUAL(fthp->cp.rotate, 0.0))
      {
        p00 = p[(signed long int)0] - fthp->cp.rot_center[(signed long int)0];
        p11 = p[(signed long int)1] - fthp->cp.rot_center[(signed long int)1];
        p0 = p00 * ficp->rot[(signed long int)0][(signed long int)0] + p11 * ficp->rot[(signed long int)0][(signed long int)1] + fthp->cp.rot_center[(signed long int)0];
        p1 = p00 * ficp->rot[(signed long int)1][(signed long int)0] + p11 * ficp->rot[(signed long int)1][(signed long int)1] + fthp->cp.rot_center[(signed long int)1];
      }

      else
      {
        p0 = p[(signed long int)0];
        p1 = p[(signed long int)1];
      }
      if(p0 >= ficp->bounds[0l])
      {
        if(p1 >= ficp->bounds[1l])
        {
          if(p0 <= ficp->bounds[2l])
          {
            if(p1 <= ficp->bounds[3l])
            {
              double logvis = 1.0;
              double (*buckets)[5l] = (double (*)[5l])ficp->buckets;
              if(IEEE_FLOAT_EQUAL(p[3l], 0.000000))
                goto __CPROVER_DUMP_L40;

              else
                logvis = p[(signed long int)3];
              b = buckets + (signed long int)(signed int)(ficp->ws0 * p0 - ficp->wb0s0) + (signed long int)(ficp->width * (signed int)(ficp->hs1 * p1 - ficp->hb1s1));
              dbl_index0 = p[(signed long int)2] * (double)256;
              color_index0 = (signed int)dbl_index0;
              if(fthp->cp.palette_mode == 1)
              {
                if(!(color_index0 >= 0))
                {
                  color_index0 = 0;
                  dbl_frac = (double)0;
                }

                else
                  if(color_index0 >= 255)
                  {
                    color_index0 = 255 - 1;
                    dbl_frac = 1.0;
                  }

                  else
                    dbl_frac = dbl_index0 - (double)color_index0;
                ci = 0;
                for( ; !(ci >= 4); ci = ci + 1)
                  interpcolor[(signed long int)ci] = (ficp->dmap + (signed long int)color_index0)->color[(signed long int)ci] * (1.0 - dbl_frac) + (ficp->dmap + (signed long int)(color_index0 + 1))->color[(signed long int)ci] * dbl_frac;
              }

              else
              {
                if(!(color_index0 >= 0))
                  color_index0 = 0;

                else
                  if(color_index0 >= 255)
                    color_index0 = 255;

                ci = 0;
                for( ; !(ci >= 4); ci = ci + 1)
                  interpcolor[(signed long int)ci] = (ficp->dmap + (signed long int)color_index0)->color[(signed long int)ci];
              }
              if(IEEE_FLOAT_EQUAL(p[3l], 1.0))
              {
                double_atomic_add(&b[(signed long int)0][(signed long int)0], interpcolor[(signed long int)0]);
                double_atomic_add(&b[(signed long int)0][(signed long int)1], interpcolor[(signed long int)1]);
                double_atomic_add(&b[(signed long int)0][(signed long int)2], interpcolor[(signed long int)2]);
                double_atomic_add(&b[(signed long int)0][(signed long int)3], interpcolor[(signed long int)3]);
                double_atomic_add(&b[(signed long int)0][(signed long int)4], 255.0);
              }

              else
              {
                double_atomic_add(&b[(signed long int)0][(signed long int)0], logvis * interpcolor[(signed long int)0]);
                double_atomic_add(&b[(signed long int)0][(signed long int)1], logvis * interpcolor[(signed long int)1]);
                double_atomic_add(&b[(signed long int)0][(signed long int)2], logvis * interpcolor[(signed long int)2]);
                double_atomic_add(&b[(signed long int)0][(signed long int)3], logvis * interpcolor[(signed long int)3]);
                double_atomic_add(&b[(signed long int)0][(signed long int)4], logvis * 255.0);
              }
            }

          }

        }

      }


    __CPROVER_DUMP_L40:
      ;
    }
  }
  pthread_exit((void *)0);
}

// iter_thread_float
// file rect.c line 253
static void iter_thread_float(void *fth)
{
  double sub_batch;
  signed int j;
  struct anonymous_13 *fthp = (struct anonymous_13 *)fth;
  struct anonymous_12 *ficp = fthp->fic;
  struct timespec pauset;
  signed int SBS = ficp->spec->sub_batch_size;
  signed int fuse;
  double eta = 0.0;
  fuse = ficp->spec->earlyclip != 0 ? 100 : 15;
  pauset.tv_sec = (signed long int)0;
  pauset.tv_nsec = (signed long int)100000000;
  if(!(fthp->timer_initialize == 0))
  {
    *ficp->progress_timer = (signed long int)0;
    memset((void *)ficp->progress_timer_history, 0, (unsigned long int)64 * sizeof(signed long int) /*8ul*/ );
    memset((void *)ficp->progress_history, 0, (unsigned long int)64 * sizeof(double) /*8ul*/ );
    *ficp->progress_history_mark = 0;
  }

  sub_batch = (double)0;
  double tmp_if_expr_1;
  double return_value_ceil_2;
  for( ; sub_batch < ficp->batch_size; sub_batch = sub_batch + (double)SBS)
  {
    signed int sub_batch_size;
    signed int badcount;
    signed long int newt;
    newt=time((signed long int *)(void *)0);
    if(sub_batch + (double)SBS > ficp->batch_size)
      tmp_if_expr_1 = ficp->batch_size - sub_batch;

    else
      tmp_if_expr_1 = (double)SBS;
    sub_batch_size = (signed int)tmp_if_expr_1;
    if(!(fthp->first_thread == 0))
    {
      if(!(newt == *ficp->progress_timer))
      {
        double percent = (100.0 * ((sub_batch / (double)ficp->batch_size + (double)ficp->temporal_sample_num) / (double)ficp->ntemporal_samples + (double)ficp->batch_num)) / (double)ficp->nbatches;
        signed int old_mark = 0;
        signed int ticker;
        if(!(ficp->spec->verbose == 0))
          fprintf(stderr, "\rchaos: %5.1f%%", percent);

        *ficp->progress_timer = newt;
        if(!(ficp->progress_timer_history[(signed long int)*ficp->progress_history_mark] == 0l))
        {
          if(ficp->progress_history[(signed long int)*ficp->progress_history_mark] < percent)
            old_mark = *ficp->progress_history_mark;

        }

        if(percent > 0.000000)
        {
          eta = (((double)100 - percent) * (double)(*ficp->progress_timer - ficp->progress_timer_history[(signed long int)old_mark])) / (percent - ficp->progress_history[(signed long int)old_mark]);
          if(!(ficp->spec->verbose == 0))
          {
            ticker = (*ficp->progress_timer & (signed long int)1) != 0l ? 58 : 46;
            if(eta < 1000.000000)
              ticker = 58;

            if(eta > 100.000000)
              fprintf(stderr, "  ETA%c %.1f minutes", ticker, eta / (double)60);

            else
            {
              return_value_ceil_2=ceil(eta);
              fprintf(stderr, "  ETA%c %ld seconds ", ticker, (signed long int)return_value_ceil_2);
            }
            fprintf(stderr, "              \r");
            fflush(stderr);
          }

        }

        ficp->progress_timer_history[(signed long int)*ficp->progress_history_mark] = *ficp->progress_timer;
        ficp->progress_history[(signed long int)*ficp->progress_history_mark] = percent;
        *ficp->progress_history_mark = (*ficp->progress_history_mark + 1) % 64;
      }

    }

    if(!(ficp->spec->progress == ((signed int (*)(void *, double, signed int, double))NULL)))
    {
      if(!(fthp->first_thread == 0))
      {
        signed int rv;
        double iter_thread_float__1__2__1__2__1__percent = (100.0 * ((sub_batch / (double)ficp->batch_size + (double)ficp->temporal_sample_num) / (double)ficp->ntemporal_samples + (double)ficp->batch_num)) / (double)ficp->nbatches;
        rv=ficp->spec->progress(ficp->spec->progress_parameter, iter_thread_float__1__2__1__2__1__percent, 0, eta);
        if(rv == 2)
        {
          signed long int tnow;
          tnow=time((signed long int *)(void *)0);
          signed long int tend;
          signed int lastpt;
          ficp->aborted = -1;
          nanosleep(&pauset, (struct timespec *)(void *)0);
          rv=ficp->spec->progress(ficp->spec->progress_parameter, iter_thread_float__1__2__1__2__1__percent, 0, eta);
          signed long int return_value_time_3;
          return_value_time_3=time((signed long int *)(void *)0);
          tend = return_value_time_3 - tnow;
          ficp->aborted = 0;
          lastpt = 0;
          if(!(lastpt >= 64))
          {
            if(!(ficp->progress_timer_history[(signed long int)lastpt] == 0l))
              ficp->progress_timer_history[(signed long int)lastpt] = ficp->progress_timer_history[(signed long int)lastpt] + tend;

            lastpt = lastpt + 1;
          }

        }

        if(rv == 1)
        {
          ficp->aborted = 1;
          pthread_exit((void *)0);
        }

      }

      else
      {
        if(!(ficp->aborted >= 0))
          do
            nanosleep(&pauset, (struct timespec *)(void *)0);
          while(ficp->aborted == -1);

        if(ficp->aborted >= 1)
          pthread_exit((void *)0);

      }
    }

    fthp->iter_storage[(signed long int)0]=flam3_random_isaac_11(&fthp->rc);
    fthp->iter_storage[(signed long int)1]=flam3_random_isaac_11(&fthp->rc);
    fthp->iter_storage[(signed long int)2]=flam3_random_isaac_01(&fthp->rc);
    fthp->iter_storage[(signed long int)3]=flam3_random_isaac_01(&fthp->rc);
    badcount=flam3_iterate(&fthp->cp, sub_batch_size, fuse, fthp->iter_storage, ficp->xform_distrib, &fthp->rc);
    pthread_mutex_lock(&ficp->bucket_mutex);
    ficp->badvals = ficp->badvals + (double)badcount;
    j = 0;
    for( ; !(j >= 4 * sub_batch_size); j = j + 4)
    {
      double p0;
      double p1;
      double p00;
      double p11;
      double dbl_index0;
      double dbl_frac;
      double interpcolor[4l];
      signed int ci;
      signed int color_index0;
      double *p = &fthp->iter_storage[(signed long int)j];
      unsigned int (*b)[5l];
      if(IEEE_FLOAT_NOTEQUAL(fthp->cp.rotate, 0.0))
      {
        p00 = p[(signed long int)0] - fthp->cp.rot_center[(signed long int)0];
        p11 = p[(signed long int)1] - fthp->cp.rot_center[(signed long int)1];
        p0 = p00 * ficp->rot[(signed long int)0][(signed long int)0] + p11 * ficp->rot[(signed long int)0][(signed long int)1] + fthp->cp.rot_center[(signed long int)0];
        p1 = p00 * ficp->rot[(signed long int)1][(signed long int)0] + p11 * ficp->rot[(signed long int)1][(signed long int)1] + fthp->cp.rot_center[(signed long int)1];
      }

      else
      {
        p0 = p[(signed long int)0];
        p1 = p[(signed long int)1];
      }
      if(p0 >= ficp->bounds[0l])
      {
        if(p1 >= ficp->bounds[1l])
        {
          if(p0 <= ficp->bounds[2l])
          {
            if(p1 <= ficp->bounds[3l])
            {
              double logvis = 1.0;
              unsigned int (*buckets)[5l] = (unsigned int (*)[5l])ficp->buckets;
              if(IEEE_FLOAT_EQUAL(p[3l], 0.000000))
                goto __CPROVER_DUMP_L69;

              else
                logvis = p[(signed long int)3];
              b = buckets + (signed long int)(signed int)(ficp->ws0 * p0 - ficp->wb0s0) + (signed long int)(ficp->width * (signed int)(ficp->hs1 * p1 - ficp->hb1s1));
              dbl_index0 = p[(signed long int)2] * (double)256;
              color_index0 = (signed int)dbl_index0;
              if(fthp->cp.palette_mode == 1)
              {
                if(!(color_index0 >= 0))
                {
                  color_index0 = 0;
                  dbl_frac = (double)0;
                }

                else
                  if(color_index0 >= 255)
                  {
                    color_index0 = 255 - 1;
                    dbl_frac = 1.0;
                  }

                  else
                    dbl_frac = dbl_index0 - (double)color_index0;
                ci = 0;
                for( ; !(ci >= 4); ci = ci + 1)
                  interpcolor[(signed long int)ci] = (ficp->dmap + (signed long int)color_index0)->color[(signed long int)ci] * (1.0 - dbl_frac) + (ficp->dmap + (signed long int)(color_index0 + 1))->color[(signed long int)ci] * dbl_frac;
              }

              else
              {
                if(!(color_index0 >= 0))
                  color_index0 = 0;

                else
                  if(color_index0 >= 255)
                    color_index0 = 255;

                ci = 0;
                for( ; !(ci >= 4); ci = ci + 1)
                  interpcolor[(signed long int)ci] = (ficp->dmap + (signed long int)color_index0)->color[(signed long int)ci];
              }
              if(IEEE_FLOAT_EQUAL(p[3l], 1.0))
              {
                do
                  if((double)(1U + -(*b)[0l]) > interpcolor[0l])
                    b[(signed long int)0][(signed long int)0] = b[(signed long int)0][(signed long int)0] + (unsigned int)interpcolor[(signed long int)0];

                  else
                    b[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                while((_Bool)0);
                do
                  if((double)(1U + -(*b)[1l]) > interpcolor[1l])
                    b[(signed long int)0][(signed long int)1] = b[(signed long int)0][(signed long int)1] + (unsigned int)interpcolor[(signed long int)1];

                  else
                    b[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                while((_Bool)0);
                do
                  if((double)(1U + -(*b)[2l]) > interpcolor[2l])
                    b[(signed long int)0][(signed long int)2] = b[(signed long int)0][(signed long int)2] + (unsigned int)interpcolor[(signed long int)2];

                  else
                    b[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                while((_Bool)0);
                do
                  if((double)(1U + -(*b)[3l]) > interpcolor[3l])
                    b[(signed long int)0][(signed long int)3] = b[(signed long int)0][(signed long int)3] + (unsigned int)interpcolor[(signed long int)3];

                  else
                    b[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                while((_Bool)0);
                do
                  if((double)(1U + -(*b)[4l]) > 255.0)
                    b[(signed long int)0][(signed long int)4] = b[(signed long int)0][(signed long int)4] + (unsigned int)255.0;

                  else
                    b[(signed long int)0][(signed long int)4] = (unsigned int)0x7fffffff * 2U + 1U;
                while((_Bool)0);
              }

              else
              {
                do
                  if((double)(1U + -(*b)[0l]) > logvis * interpcolor[0l])
                    b[(signed long int)0][(signed long int)0] = b[(signed long int)0][(signed long int)0] + (unsigned int)(logvis * interpcolor[(signed long int)0]);

                  else
                    b[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                while((_Bool)0);
                do
                  if((double)(1U + -(*b)[1l]) > logvis * interpcolor[1l])
                    b[(signed long int)0][(signed long int)1] = b[(signed long int)0][(signed long int)1] + (unsigned int)(logvis * interpcolor[(signed long int)1]);

                  else
                    b[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                while((_Bool)0);
                do
                  if((double)(1U + -(*b)[2l]) > logvis * interpcolor[2l])
                    b[(signed long int)0][(signed long int)2] = b[(signed long int)0][(signed long int)2] + (unsigned int)(logvis * interpcolor[(signed long int)2]);

                  else
                    b[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                while((_Bool)0);
                do
                  if((double)(1U + -(*b)[3l]) > logvis * interpcolor[3l])
                    b[(signed long int)0][(signed long int)3] = b[(signed long int)0][(signed long int)3] + (unsigned int)(logvis * interpcolor[(signed long int)3]);

                  else
                    b[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                while((_Bool)0);
                do
                  if((double)(1U + -(*b)[4l]) > logvis * 255.0)
                    b[(signed long int)0][(signed long int)4] = b[(signed long int)0][(signed long int)4] + (unsigned int)(logvis * 255.0);

                  else
                    b[(signed long int)0][(signed long int)4] = (unsigned int)0x7fffffff * 2U + 1U;
                while((_Bool)0);
              }
            }

          }

        }

      }


    __CPROVER_DUMP_L69:
      ;
    }
    pthread_mutex_unlock(&ficp->bucket_mutex);
  }
  pthread_exit((void *)0);
}

// iter_thread_float_mt
// file rect.c line 253
static void iter_thread_float_mt(void *fth)
{
  double sub_batch;
  signed int j;
  struct anonymous_13 *fthp = (struct anonymous_13 *)fth;
  struct anonymous_12 *ficp = fthp->fic;
  struct timespec pauset;
  signed int SBS = ficp->spec->sub_batch_size;
  signed int fuse;
  double eta = 0.0;
  fuse = ficp->spec->earlyclip != 0 ? 100 : 15;
  pauset.tv_sec = (signed long int)0;
  pauset.tv_nsec = (signed long int)100000000;
  if(!(fthp->timer_initialize == 0))
  {
    *ficp->progress_timer = (signed long int)0;
    memset((void *)ficp->progress_timer_history, 0, (unsigned long int)64 * sizeof(signed long int) /*8ul*/ );
    memset((void *)ficp->progress_history, 0, (unsigned long int)64 * sizeof(double) /*8ul*/ );
    *ficp->progress_history_mark = 0;
  }

  sub_batch = (double)0;
  double tmp_if_expr_1;
  double return_value_ceil_2;
  for( ; sub_batch < ficp->batch_size; sub_batch = sub_batch + (double)SBS)
  {
    signed int sub_batch_size;
    signed int badcount;
    signed long int newt;
    newt=time((signed long int *)(void *)0);
    if(sub_batch + (double)SBS > ficp->batch_size)
      tmp_if_expr_1 = ficp->batch_size - sub_batch;

    else
      tmp_if_expr_1 = (double)SBS;
    sub_batch_size = (signed int)tmp_if_expr_1;
    if(!(fthp->first_thread == 0))
    {
      if(!(newt == *ficp->progress_timer))
      {
        double percent = (100.0 * ((sub_batch / (double)ficp->batch_size + (double)ficp->temporal_sample_num) / (double)ficp->ntemporal_samples + (double)ficp->batch_num)) / (double)ficp->nbatches;
        signed int old_mark = 0;
        signed int ticker;
        if(!(ficp->spec->verbose == 0))
          fprintf(stderr, "\rchaos: %5.1f%%", percent);

        *ficp->progress_timer = newt;
        if(!(ficp->progress_timer_history[(signed long int)*ficp->progress_history_mark] == 0l))
        {
          if(ficp->progress_history[(signed long int)*ficp->progress_history_mark] < percent)
            old_mark = *ficp->progress_history_mark;

        }

        if(percent > 0.000000)
        {
          eta = (((double)100 - percent) * (double)(*ficp->progress_timer - ficp->progress_timer_history[(signed long int)old_mark])) / (percent - ficp->progress_history[(signed long int)old_mark]);
          if(!(ficp->spec->verbose == 0))
          {
            ticker = (*ficp->progress_timer & (signed long int)1) != 0l ? 58 : 46;
            if(eta < 1000.000000)
              ticker = 58;

            if(eta > 100.000000)
              fprintf(stderr, "  ETA%c %.1f minutes", ticker, eta / (double)60);

            else
            {
              return_value_ceil_2=ceil(eta);
              fprintf(stderr, "  ETA%c %ld seconds ", ticker, (signed long int)return_value_ceil_2);
            }
            fprintf(stderr, "              \r");
            fflush(stderr);
          }

        }

        ficp->progress_timer_history[(signed long int)*ficp->progress_history_mark] = *ficp->progress_timer;
        ficp->progress_history[(signed long int)*ficp->progress_history_mark] = percent;
        *ficp->progress_history_mark = (*ficp->progress_history_mark + 1) % 64;
      }

    }

    if(!(ficp->spec->progress == ((signed int (*)(void *, double, signed int, double))NULL)))
    {
      if(!(fthp->first_thread == 0))
      {
        signed int rv;
        double iter_thread_float_mt__1__2__1__2__1__percent = (100.0 * ((sub_batch / (double)ficp->batch_size + (double)ficp->temporal_sample_num) / (double)ficp->ntemporal_samples + (double)ficp->batch_num)) / (double)ficp->nbatches;
        rv=ficp->spec->progress(ficp->spec->progress_parameter, iter_thread_float_mt__1__2__1__2__1__percent, 0, eta);
        if(rv == 2)
        {
          signed long int tnow;
          tnow=time((signed long int *)(void *)0);
          signed long int tend;
          signed int lastpt;
          ficp->aborted = -1;
          nanosleep(&pauset, (struct timespec *)(void *)0);
          rv=ficp->spec->progress(ficp->spec->progress_parameter, iter_thread_float_mt__1__2__1__2__1__percent, 0, eta);
          signed long int return_value_time_3;
          return_value_time_3=time((signed long int *)(void *)0);
          tend = return_value_time_3 - tnow;
          ficp->aborted = 0;
          lastpt = 0;
          if(!(lastpt >= 64))
          {
            if(!(ficp->progress_timer_history[(signed long int)lastpt] == 0l))
              ficp->progress_timer_history[(signed long int)lastpt] = ficp->progress_timer_history[(signed long int)lastpt] + tend;

            lastpt = lastpt + 1;
          }

        }

        if(rv == 1)
        {
          ficp->aborted = 1;
          pthread_exit((void *)0);
        }

      }

      else
      {
        if(!(ficp->aborted >= 0))
          do
            nanosleep(&pauset, (struct timespec *)(void *)0);
          while(ficp->aborted == -1);

        if(ficp->aborted >= 1)
          pthread_exit((void *)0);

      }
    }

    fthp->iter_storage[(signed long int)0]=flam3_random_isaac_11(&fthp->rc);
    fthp->iter_storage[(signed long int)1]=flam3_random_isaac_11(&fthp->rc);
    fthp->iter_storage[(signed long int)2]=flam3_random_isaac_01(&fthp->rc);
    fthp->iter_storage[(signed long int)3]=flam3_random_isaac_01(&fthp->rc);
    badcount=flam3_iterate(&fthp->cp, sub_batch_size, fuse, fthp->iter_storage, ficp->xform_distrib, &fthp->rc);
    ficp->badvals = ficp->badvals + (double)badcount;
    j = 0;
    for( ; !(j >= 4 * sub_batch_size); j = j + 4)
    {
      double p0;
      double p1;
      double p00;
      double p11;
      double dbl_index0;
      double dbl_frac;
      double interpcolor[4l];
      signed int ci;
      signed int color_index0;
      double *p = &fthp->iter_storage[(signed long int)j];
      unsigned int (*b)[5l];
      if(IEEE_FLOAT_NOTEQUAL(fthp->cp.rotate, 0.0))
      {
        p00 = p[(signed long int)0] - fthp->cp.rot_center[(signed long int)0];
        p11 = p[(signed long int)1] - fthp->cp.rot_center[(signed long int)1];
        p0 = p00 * ficp->rot[(signed long int)0][(signed long int)0] + p11 * ficp->rot[(signed long int)0][(signed long int)1] + fthp->cp.rot_center[(signed long int)0];
        p1 = p00 * ficp->rot[(signed long int)1][(signed long int)0] + p11 * ficp->rot[(signed long int)1][(signed long int)1] + fthp->cp.rot_center[(signed long int)1];
      }

      else
      {
        p0 = p[(signed long int)0];
        p1 = p[(signed long int)1];
      }
      if(p0 >= ficp->bounds[0l])
      {
        if(p1 >= ficp->bounds[1l])
        {
          if(p0 <= ficp->bounds[2l])
          {
            if(p1 <= ficp->bounds[3l])
            {
              double logvis = 1.0;
              unsigned int (*buckets)[5l] = (unsigned int (*)[5l])ficp->buckets;
              if(IEEE_FLOAT_EQUAL(p[3l], 0.000000))
                goto __CPROVER_DUMP_L40;

              else
                logvis = p[(signed long int)3];
              b = buckets + (signed long int)(signed int)(ficp->ws0 * p0 - ficp->wb0s0) + (signed long int)(ficp->width * (signed int)(ficp->hs1 * p1 - ficp->hb1s1));
              dbl_index0 = p[(signed long int)2] * (double)256;
              color_index0 = (signed int)dbl_index0;
              if(fthp->cp.palette_mode == 1)
              {
                if(!(color_index0 >= 0))
                {
                  color_index0 = 0;
                  dbl_frac = (double)0;
                }

                else
                  if(color_index0 >= 255)
                  {
                    color_index0 = 255 - 1;
                    dbl_frac = 1.0;
                  }

                  else
                    dbl_frac = dbl_index0 - (double)color_index0;
                ci = 0;
                for( ; !(ci >= 4); ci = ci + 1)
                  interpcolor[(signed long int)ci] = (ficp->dmap + (signed long int)color_index0)->color[(signed long int)ci] * (1.0 - dbl_frac) + (ficp->dmap + (signed long int)(color_index0 + 1))->color[(signed long int)ci] * dbl_frac;
              }

              else
              {
                if(!(color_index0 >= 0))
                  color_index0 = 0;

                else
                  if(color_index0 >= 255)
                    color_index0 = 255;

                ci = 0;
                for( ; !(ci >= 4); ci = ci + 1)
                  interpcolor[(signed long int)ci] = (ficp->dmap + (signed long int)color_index0)->color[(signed long int)ci];
              }
              if(IEEE_FLOAT_EQUAL(p[3l], 1.0))
              {
                uint_atomic_add(&b[(signed long int)0][(signed long int)0], (unsigned int)interpcolor[(signed long int)0]);
                uint_atomic_add(&b[(signed long int)0][(signed long int)1], (unsigned int)interpcolor[(signed long int)1]);
                uint_atomic_add(&b[(signed long int)0][(signed long int)2], (unsigned int)interpcolor[(signed long int)2]);
                uint_atomic_add(&b[(signed long int)0][(signed long int)3], (unsigned int)interpcolor[(signed long int)3]);
                uint_atomic_add(&b[(signed long int)0][(signed long int)4], (unsigned int)255.0);
              }

              else
              {
                uint_atomic_add(&b[(signed long int)0][(signed long int)0], (unsigned int)(logvis * interpcolor[(signed long int)0]));
                uint_atomic_add(&b[(signed long int)0][(signed long int)1], (unsigned int)(logvis * interpcolor[(signed long int)1]));
                uint_atomic_add(&b[(signed long int)0][(signed long int)2], (unsigned int)(logvis * interpcolor[(signed long int)2]));
                uint_atomic_add(&b[(signed long int)0][(signed long int)3], (unsigned int)(logvis * interpcolor[(signed long int)3]));
                uint_atomic_add(&b[(signed long int)0][(signed long int)4], (unsigned int)(logvis * 255.0));
              }
            }

          }

        }

      }


    __CPROVER_DUMP_L40:
      ;
    }
  }
  pthread_exit((void *)0);
}

// iter_thread_int
// file rect.c line 253
static void iter_thread_int(void *fth)
{
  double sub_batch;
  signed int j;
  struct anonymous_13 *fthp = (struct anonymous_13 *)fth;
  struct anonymous_12 *ficp = fthp->fic;
  struct timespec pauset;
  signed int SBS = ficp->spec->sub_batch_size;
  signed int fuse;
  double eta = 0.0;
  fuse = ficp->spec->earlyclip != 0 ? 100 : 15;
  pauset.tv_sec = (signed long int)0;
  pauset.tv_nsec = (signed long int)100000000;
  if(!(fthp->timer_initialize == 0))
  {
    *ficp->progress_timer = (signed long int)0;
    memset((void *)ficp->progress_timer_history, 0, (unsigned long int)64 * sizeof(signed long int) /*8ul*/ );
    memset((void *)ficp->progress_history, 0, (unsigned long int)64 * sizeof(double) /*8ul*/ );
    *ficp->progress_history_mark = 0;
  }

  sub_batch = (double)0;
  double tmp_if_expr_1;
  double return_value_ceil_2;
  for( ; sub_batch < ficp->batch_size; sub_batch = sub_batch + (double)SBS)
  {
    signed int sub_batch_size;
    signed int badcount;
    signed long int newt;
    newt=time((signed long int *)(void *)0);
    if(sub_batch + (double)SBS > ficp->batch_size)
      tmp_if_expr_1 = ficp->batch_size - sub_batch;

    else
      tmp_if_expr_1 = (double)SBS;
    sub_batch_size = (signed int)tmp_if_expr_1;
    if(!(fthp->first_thread == 0))
    {
      if(!(newt == *ficp->progress_timer))
      {
        double percent = (100.0 * ((sub_batch / (double)ficp->batch_size + (double)ficp->temporal_sample_num) / (double)ficp->ntemporal_samples + (double)ficp->batch_num)) / (double)ficp->nbatches;
        signed int old_mark = 0;
        signed int ticker;
        if(!(ficp->spec->verbose == 0))
          fprintf(stderr, "\rchaos: %5.1f%%", percent);

        *ficp->progress_timer = newt;
        if(!(ficp->progress_timer_history[(signed long int)*ficp->progress_history_mark] == 0l))
        {
          if(ficp->progress_history[(signed long int)*ficp->progress_history_mark] < percent)
            old_mark = *ficp->progress_history_mark;

        }

        if(percent > 0.000000)
        {
          eta = (((double)100 - percent) * (double)(*ficp->progress_timer - ficp->progress_timer_history[(signed long int)old_mark])) / (percent - ficp->progress_history[(signed long int)old_mark]);
          if(!(ficp->spec->verbose == 0))
          {
            ticker = (*ficp->progress_timer & (signed long int)1) != 0l ? 58 : 46;
            if(eta < 1000.000000)
              ticker = 58;

            if(eta > 100.000000)
              fprintf(stderr, "  ETA%c %.1f minutes", ticker, eta / (double)60);

            else
            {
              return_value_ceil_2=ceil(eta);
              fprintf(stderr, "  ETA%c %ld seconds ", ticker, (signed long int)return_value_ceil_2);
            }
            fprintf(stderr, "              \r");
            fflush(stderr);
          }

        }

        ficp->progress_timer_history[(signed long int)*ficp->progress_history_mark] = *ficp->progress_timer;
        ficp->progress_history[(signed long int)*ficp->progress_history_mark] = percent;
        *ficp->progress_history_mark = (*ficp->progress_history_mark + 1) % 64;
      }

    }

    if(!(ficp->spec->progress == ((signed int (*)(void *, double, signed int, double))NULL)))
    {
      if(!(fthp->first_thread == 0))
      {
        signed int rv;
        double iter_thread_int__1__2__1__2__1__percent = (100.0 * ((sub_batch / (double)ficp->batch_size + (double)ficp->temporal_sample_num) / (double)ficp->ntemporal_samples + (double)ficp->batch_num)) / (double)ficp->nbatches;
        rv=ficp->spec->progress(ficp->spec->progress_parameter, iter_thread_int__1__2__1__2__1__percent, 0, eta);
        if(rv == 2)
        {
          signed long int tnow;
          tnow=time((signed long int *)(void *)0);
          signed long int tend;
          signed int lastpt;
          ficp->aborted = -1;
          nanosleep(&pauset, (struct timespec *)(void *)0);
          rv=ficp->spec->progress(ficp->spec->progress_parameter, iter_thread_int__1__2__1__2__1__percent, 0, eta);
          signed long int return_value_time_3;
          return_value_time_3=time((signed long int *)(void *)0);
          tend = return_value_time_3 - tnow;
          ficp->aborted = 0;
          lastpt = 0;
          if(!(lastpt >= 64))
          {
            if(!(ficp->progress_timer_history[(signed long int)lastpt] == 0l))
              ficp->progress_timer_history[(signed long int)lastpt] = ficp->progress_timer_history[(signed long int)lastpt] + tend;

            lastpt = lastpt + 1;
          }

        }

        if(rv == 1)
        {
          ficp->aborted = 1;
          pthread_exit((void *)0);
        }

      }

      else
      {
        if(!(ficp->aborted >= 0))
          do
            nanosleep(&pauset, (struct timespec *)(void *)0);
          while(ficp->aborted == -1);

        if(ficp->aborted >= 1)
          pthread_exit((void *)0);

      }
    }

    fthp->iter_storage[(signed long int)0]=flam3_random_isaac_11(&fthp->rc);
    fthp->iter_storage[(signed long int)1]=flam3_random_isaac_11(&fthp->rc);
    fthp->iter_storage[(signed long int)2]=flam3_random_isaac_01(&fthp->rc);
    fthp->iter_storage[(signed long int)3]=flam3_random_isaac_01(&fthp->rc);
    badcount=flam3_iterate(&fthp->cp, sub_batch_size, fuse, fthp->iter_storage, ficp->xform_distrib, &fthp->rc);
    pthread_mutex_lock(&ficp->bucket_mutex);
    ficp->badvals = ficp->badvals + (double)badcount;
    j = 0;
    for( ; !(j >= 4 * sub_batch_size); j = j + 4)
    {
      double p0;
      double p1;
      double p00;
      double p11;
      double dbl_index0;
      double dbl_frac;
      double interpcolor[4l];
      signed int ci;
      signed int color_index0;
      double *p = &fthp->iter_storage[(signed long int)j];
      unsigned int (*b)[5l];
      if(IEEE_FLOAT_NOTEQUAL(fthp->cp.rotate, 0.0))
      {
        p00 = p[(signed long int)0] - fthp->cp.rot_center[(signed long int)0];
        p11 = p[(signed long int)1] - fthp->cp.rot_center[(signed long int)1];
        p0 = p00 * ficp->rot[(signed long int)0][(signed long int)0] + p11 * ficp->rot[(signed long int)0][(signed long int)1] + fthp->cp.rot_center[(signed long int)0];
        p1 = p00 * ficp->rot[(signed long int)1][(signed long int)0] + p11 * ficp->rot[(signed long int)1][(signed long int)1] + fthp->cp.rot_center[(signed long int)1];
      }

      else
      {
        p0 = p[(signed long int)0];
        p1 = p[(signed long int)1];
      }
      if(p0 >= ficp->bounds[0l])
      {
        if(p1 >= ficp->bounds[1l])
        {
          if(p0 <= ficp->bounds[2l])
          {
            if(p1 <= ficp->bounds[3l])
            {
              double logvis = 1.0;
              unsigned int (*buckets)[5l] = (unsigned int (*)[5l])ficp->buckets;
              if(IEEE_FLOAT_EQUAL(p[3l], 0.000000))
                goto __CPROVER_DUMP_L69;

              else
                logvis = p[(signed long int)3];
              b = buckets + (signed long int)(signed int)(ficp->ws0 * p0 - ficp->wb0s0) + (signed long int)(ficp->width * (signed int)(ficp->hs1 * p1 - ficp->hb1s1));
              dbl_index0 = p[(signed long int)2] * (double)256;
              color_index0 = (signed int)dbl_index0;
              if(fthp->cp.palette_mode == 1)
              {
                if(!(color_index0 >= 0))
                {
                  color_index0 = 0;
                  dbl_frac = (double)0;
                }

                else
                  if(color_index0 >= 255)
                  {
                    color_index0 = 255 - 1;
                    dbl_frac = 1.0;
                  }

                  else
                    dbl_frac = dbl_index0 - (double)color_index0;
                ci = 0;
                for( ; !(ci >= 4); ci = ci + 1)
                  interpcolor[(signed long int)ci] = (ficp->dmap + (signed long int)color_index0)->color[(signed long int)ci] * (1.0 - dbl_frac) + (ficp->dmap + (signed long int)(color_index0 + 1))->color[(signed long int)ci] * dbl_frac;
              }

              else
              {
                if(!(color_index0 >= 0))
                  color_index0 = 0;

                else
                  if(color_index0 >= 255)
                    color_index0 = 255;

                ci = 0;
                for( ; !(ci >= 4); ci = ci + 1)
                  interpcolor[(signed long int)ci] = (ficp->dmap + (signed long int)color_index0)->color[(signed long int)ci];
              }
              if(IEEE_FLOAT_EQUAL(p[3l], 1.0))
              {
                do
                  if((double)(1U + -(*b)[0l]) > interpcolor[0l])
                    b[(signed long int)0][(signed long int)0] = b[(signed long int)0][(signed long int)0] + (unsigned int)interpcolor[(signed long int)0];

                  else
                    b[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                while((_Bool)0);
                do
                  if((double)(1U + -(*b)[1l]) > interpcolor[1l])
                    b[(signed long int)0][(signed long int)1] = b[(signed long int)0][(signed long int)1] + (unsigned int)interpcolor[(signed long int)1];

                  else
                    b[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                while((_Bool)0);
                do
                  if((double)(1U + -(*b)[2l]) > interpcolor[2l])
                    b[(signed long int)0][(signed long int)2] = b[(signed long int)0][(signed long int)2] + (unsigned int)interpcolor[(signed long int)2];

                  else
                    b[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                while((_Bool)0);
                do
                  if((double)(1U + -(*b)[3l]) > interpcolor[3l])
                    b[(signed long int)0][(signed long int)3] = b[(signed long int)0][(signed long int)3] + (unsigned int)interpcolor[(signed long int)3];

                  else
                    b[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                while((_Bool)0);
                do
                  if((double)(1U + -(*b)[4l]) > 255.0)
                    b[(signed long int)0][(signed long int)4] = b[(signed long int)0][(signed long int)4] + (unsigned int)255.0;

                  else
                    b[(signed long int)0][(signed long int)4] = (unsigned int)0x7fffffff * 2U + 1U;
                while((_Bool)0);
              }

              else
              {
                do
                  if((double)(1U + -(*b)[0l]) > logvis * interpcolor[0l])
                    b[(signed long int)0][(signed long int)0] = b[(signed long int)0][(signed long int)0] + (unsigned int)(logvis * interpcolor[(signed long int)0]);

                  else
                    b[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                while((_Bool)0);
                do
                  if((double)(1U + -(*b)[1l]) > logvis * interpcolor[1l])
                    b[(signed long int)0][(signed long int)1] = b[(signed long int)0][(signed long int)1] + (unsigned int)(logvis * interpcolor[(signed long int)1]);

                  else
                    b[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                while((_Bool)0);
                do
                  if((double)(1U + -(*b)[2l]) > logvis * interpcolor[2l])
                    b[(signed long int)0][(signed long int)2] = b[(signed long int)0][(signed long int)2] + (unsigned int)(logvis * interpcolor[(signed long int)2]);

                  else
                    b[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                while((_Bool)0);
                do
                  if((double)(1U + -(*b)[3l]) > logvis * interpcolor[3l])
                    b[(signed long int)0][(signed long int)3] = b[(signed long int)0][(signed long int)3] + (unsigned int)(logvis * interpcolor[(signed long int)3]);

                  else
                    b[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                while((_Bool)0);
                do
                  if((double)(1U + -(*b)[4l]) > logvis * 255.0)
                    b[(signed long int)0][(signed long int)4] = b[(signed long int)0][(signed long int)4] + (unsigned int)(logvis * 255.0);

                  else
                    b[(signed long int)0][(signed long int)4] = (unsigned int)0x7fffffff * 2U + 1U;
                while((_Bool)0);
              }
            }

          }

        }

      }


    __CPROVER_DUMP_L69:
      ;
    }
    pthread_mutex_unlock(&ficp->bucket_mutex);
  }
  pthread_exit((void *)0);
}

// iter_thread_int_mt
// file rect.c line 253
static void iter_thread_int_mt(void *fth)
{
  double sub_batch;
  signed int j;
  struct anonymous_13 *fthp = (struct anonymous_13 *)fth;
  struct anonymous_12 *ficp = fthp->fic;
  struct timespec pauset;
  signed int SBS = ficp->spec->sub_batch_size;
  signed int fuse;
  double eta = 0.0;
  fuse = ficp->spec->earlyclip != 0 ? 100 : 15;
  pauset.tv_sec = (signed long int)0;
  pauset.tv_nsec = (signed long int)100000000;
  if(!(fthp->timer_initialize == 0))
  {
    *ficp->progress_timer = (signed long int)0;
    memset((void *)ficp->progress_timer_history, 0, (unsigned long int)64 * sizeof(signed long int) /*8ul*/ );
    memset((void *)ficp->progress_history, 0, (unsigned long int)64 * sizeof(double) /*8ul*/ );
    *ficp->progress_history_mark = 0;
  }

  sub_batch = (double)0;
  double tmp_if_expr_1;
  double return_value_ceil_2;
  for( ; sub_batch < ficp->batch_size; sub_batch = sub_batch + (double)SBS)
  {
    signed int sub_batch_size;
    signed int badcount;
    signed long int newt;
    newt=time((signed long int *)(void *)0);
    if(sub_batch + (double)SBS > ficp->batch_size)
      tmp_if_expr_1 = ficp->batch_size - sub_batch;

    else
      tmp_if_expr_1 = (double)SBS;
    sub_batch_size = (signed int)tmp_if_expr_1;
    if(!(fthp->first_thread == 0))
    {
      if(!(newt == *ficp->progress_timer))
      {
        double percent = (100.0 * ((sub_batch / (double)ficp->batch_size + (double)ficp->temporal_sample_num) / (double)ficp->ntemporal_samples + (double)ficp->batch_num)) / (double)ficp->nbatches;
        signed int old_mark = 0;
        signed int ticker;
        if(!(ficp->spec->verbose == 0))
          fprintf(stderr, "\rchaos: %5.1f%%", percent);

        *ficp->progress_timer = newt;
        if(!(ficp->progress_timer_history[(signed long int)*ficp->progress_history_mark] == 0l))
        {
          if(ficp->progress_history[(signed long int)*ficp->progress_history_mark] < percent)
            old_mark = *ficp->progress_history_mark;

        }

        if(percent > 0.000000)
        {
          eta = (((double)100 - percent) * (double)(*ficp->progress_timer - ficp->progress_timer_history[(signed long int)old_mark])) / (percent - ficp->progress_history[(signed long int)old_mark]);
          if(!(ficp->spec->verbose == 0))
          {
            ticker = (*ficp->progress_timer & (signed long int)1) != 0l ? 58 : 46;
            if(eta < 1000.000000)
              ticker = 58;

            if(eta > 100.000000)
              fprintf(stderr, "  ETA%c %.1f minutes", ticker, eta / (double)60);

            else
            {
              return_value_ceil_2=ceil(eta);
              fprintf(stderr, "  ETA%c %ld seconds ", ticker, (signed long int)return_value_ceil_2);
            }
            fprintf(stderr, "              \r");
            fflush(stderr);
          }

        }

        ficp->progress_timer_history[(signed long int)*ficp->progress_history_mark] = *ficp->progress_timer;
        ficp->progress_history[(signed long int)*ficp->progress_history_mark] = percent;
        *ficp->progress_history_mark = (*ficp->progress_history_mark + 1) % 64;
      }

    }

    if(!(ficp->spec->progress == ((signed int (*)(void *, double, signed int, double))NULL)))
    {
      if(!(fthp->first_thread == 0))
      {
        signed int rv;
        double iter_thread_int_mt__1__2__1__2__1__percent = (100.0 * ((sub_batch / (double)ficp->batch_size + (double)ficp->temporal_sample_num) / (double)ficp->ntemporal_samples + (double)ficp->batch_num)) / (double)ficp->nbatches;
        rv=ficp->spec->progress(ficp->spec->progress_parameter, iter_thread_int_mt__1__2__1__2__1__percent, 0, eta);
        if(rv == 2)
        {
          signed long int tnow;
          tnow=time((signed long int *)(void *)0);
          signed long int tend;
          signed int lastpt;
          ficp->aborted = -1;
          nanosleep(&pauset, (struct timespec *)(void *)0);
          rv=ficp->spec->progress(ficp->spec->progress_parameter, iter_thread_int_mt__1__2__1__2__1__percent, 0, eta);
          signed long int return_value_time_3;
          return_value_time_3=time((signed long int *)(void *)0);
          tend = return_value_time_3 - tnow;
          ficp->aborted = 0;
          lastpt = 0;
          if(!(lastpt >= 64))
          {
            if(!(ficp->progress_timer_history[(signed long int)lastpt] == 0l))
              ficp->progress_timer_history[(signed long int)lastpt] = ficp->progress_timer_history[(signed long int)lastpt] + tend;

            lastpt = lastpt + 1;
          }

        }

        if(rv == 1)
        {
          ficp->aborted = 1;
          pthread_exit((void *)0);
        }

      }

      else
      {
        if(!(ficp->aborted >= 0))
          do
            nanosleep(&pauset, (struct timespec *)(void *)0);
          while(ficp->aborted == -1);

        if(ficp->aborted >= 1)
          pthread_exit((void *)0);

      }
    }

    fthp->iter_storage[(signed long int)0]=flam3_random_isaac_11(&fthp->rc);
    fthp->iter_storage[(signed long int)1]=flam3_random_isaac_11(&fthp->rc);
    fthp->iter_storage[(signed long int)2]=flam3_random_isaac_01(&fthp->rc);
    fthp->iter_storage[(signed long int)3]=flam3_random_isaac_01(&fthp->rc);
    badcount=flam3_iterate(&fthp->cp, sub_batch_size, fuse, fthp->iter_storage, ficp->xform_distrib, &fthp->rc);
    ficp->badvals = ficp->badvals + (double)badcount;
    j = 0;
    for( ; !(j >= 4 * sub_batch_size); j = j + 4)
    {
      double p0;
      double p1;
      double p00;
      double p11;
      double dbl_index0;
      double dbl_frac;
      double interpcolor[4l];
      signed int ci;
      signed int color_index0;
      double *p = &fthp->iter_storage[(signed long int)j];
      unsigned int (*b)[5l];
      if(IEEE_FLOAT_NOTEQUAL(fthp->cp.rotate, 0.0))
      {
        p00 = p[(signed long int)0] - fthp->cp.rot_center[(signed long int)0];
        p11 = p[(signed long int)1] - fthp->cp.rot_center[(signed long int)1];
        p0 = p00 * ficp->rot[(signed long int)0][(signed long int)0] + p11 * ficp->rot[(signed long int)0][(signed long int)1] + fthp->cp.rot_center[(signed long int)0];
        p1 = p00 * ficp->rot[(signed long int)1][(signed long int)0] + p11 * ficp->rot[(signed long int)1][(signed long int)1] + fthp->cp.rot_center[(signed long int)1];
      }

      else
      {
        p0 = p[(signed long int)0];
        p1 = p[(signed long int)1];
      }
      if(p0 >= ficp->bounds[0l])
      {
        if(p1 >= ficp->bounds[1l])
        {
          if(p0 <= ficp->bounds[2l])
          {
            if(p1 <= ficp->bounds[3l])
            {
              double logvis = 1.0;
              unsigned int (*buckets)[5l] = (unsigned int (*)[5l])ficp->buckets;
              if(IEEE_FLOAT_EQUAL(p[3l], 0.000000))
                goto __CPROVER_DUMP_L40;

              else
                logvis = p[(signed long int)3];
              b = buckets + (signed long int)(signed int)(ficp->ws0 * p0 - ficp->wb0s0) + (signed long int)(ficp->width * (signed int)(ficp->hs1 * p1 - ficp->hb1s1));
              dbl_index0 = p[(signed long int)2] * (double)256;
              color_index0 = (signed int)dbl_index0;
              if(fthp->cp.palette_mode == 1)
              {
                if(!(color_index0 >= 0))
                {
                  color_index0 = 0;
                  dbl_frac = (double)0;
                }

                else
                  if(color_index0 >= 255)
                  {
                    color_index0 = 255 - 1;
                    dbl_frac = 1.0;
                  }

                  else
                    dbl_frac = dbl_index0 - (double)color_index0;
                ci = 0;
                for( ; !(ci >= 4); ci = ci + 1)
                  interpcolor[(signed long int)ci] = (ficp->dmap + (signed long int)color_index0)->color[(signed long int)ci] * (1.0 - dbl_frac) + (ficp->dmap + (signed long int)(color_index0 + 1))->color[(signed long int)ci] * dbl_frac;
              }

              else
              {
                if(!(color_index0 >= 0))
                  color_index0 = 0;

                else
                  if(color_index0 >= 255)
                    color_index0 = 255;

                ci = 0;
                for( ; !(ci >= 4); ci = ci + 1)
                  interpcolor[(signed long int)ci] = (ficp->dmap + (signed long int)color_index0)->color[(signed long int)ci];
              }
              if(IEEE_FLOAT_EQUAL(p[3l], 1.0))
              {
                uint_atomic_add(&b[(signed long int)0][(signed long int)0], (unsigned int)interpcolor[(signed long int)0]);
                uint_atomic_add(&b[(signed long int)0][(signed long int)1], (unsigned int)interpcolor[(signed long int)1]);
                uint_atomic_add(&b[(signed long int)0][(signed long int)2], (unsigned int)interpcolor[(signed long int)2]);
                uint_atomic_add(&b[(signed long int)0][(signed long int)3], (unsigned int)interpcolor[(signed long int)3]);
                uint_atomic_add(&b[(signed long int)0][(signed long int)4], (unsigned int)255.0);
              }

              else
              {
                uint_atomic_add(&b[(signed long int)0][(signed long int)0], (unsigned int)(logvis * interpcolor[(signed long int)0]));
                uint_atomic_add(&b[(signed long int)0][(signed long int)1], (unsigned int)(logvis * interpcolor[(signed long int)1]));
                uint_atomic_add(&b[(signed long int)0][(signed long int)2], (unsigned int)(logvis * interpcolor[(signed long int)2]));
                uint_atomic_add(&b[(signed long int)0][(signed long int)3], (unsigned int)(logvis * interpcolor[(signed long int)3]));
                uint_atomic_add(&b[(signed long int)0][(signed long int)4], (unsigned int)(logvis * 255.0));
              }
            }

          }

        }

      }


    __CPROVER_DUMP_L40:
      ;
    }
  }
  pthread_exit((void *)0);
}

// juliaN_precalc
// file variations.c line 1933
void juliaN_precalc(struct xform *xf)
{
  xf->julian_rN=fabs(xf->julian_power);
  xf->julian_cn = (xf->julian_dist / (double)xf->julian_power) / 2.0;
}

// juliaScope_precalc
// file variations.c line 1944
void juliaScope_precalc(struct xform *xf)
{
  xf->juliascope_rN=fabs(xf->juliascope_power);
  xf->juliascope_cn = (xf->juliascope_dist / (double)xf->juliascope_power) / 2.0;
}

// main
// file flam3-genome.c line 377
signed int main(signed int argc, char **argv)
{
  signed int debug = 0;
  signed int count;
  char *ai;
  unsigned char *image;
  struct anonymous_0 *templ = (struct anonymous_0 *)(void *)0;
  struct anonymous_0 cp_orig;
  struct anonymous_0 cp_save;
  signed int i;
  signed int j;
  double avg_pix;
  double fraction_black;
  double fraction_white;
  double avg_thresh;
  ai=getenv("avg");
  double tmp_if_expr_2;
  double return_value_atof_1;
  if(!(ai == ((char *)NULL)))
  {
    return_value_atof_1=atof(ai);
    tmp_if_expr_2 = return_value_atof_1;
  }

  else
    tmp_if_expr_2 = 20.0;
  avg_thresh = tmp_if_expr_2;
  double black_thresh;
  ai=getenv("black");
  double tmp_if_expr_4;
  double return_value_atof_3;
  if(!(ai == ((char *)NULL)))
  {
    return_value_atof_3=atof(ai);
    tmp_if_expr_4 = return_value_atof_3;
  }

  else
    tmp_if_expr_4 = 0.01;
  black_thresh = tmp_if_expr_4;
  double white_limit;
  ai=getenv("white");
  double tmp_if_expr_6;
  double return_value_atof_5;
  if(!(ai == ((char *)NULL)))
  {
    return_value_atof_5=atof(ai);
    tmp_if_expr_6 = return_value_atof_5;
  }

  else
    tmp_if_expr_6 = 0.05;
  white_limit = tmp_if_expr_6;
  signed int nframes;
  ai=getenv("nframes");
  signed int tmp_if_expr_8;
  signed int return_value_atoi_7;
  if(!(ai == ((char *)NULL)))
  {
    return_value_atoi_7=atoi(ai);
    tmp_if_expr_8 = return_value_atoi_7;
  }

  else
    tmp_if_expr_8 = 100;
  nframes = tmp_if_expr_8;
  signed int sym;
  ai=getenv("symmetry");
  signed int tmp_if_expr_10;
  signed int return_value_atoi_9;
  if(!(ai == ((char *)NULL)))
  {
    return_value_atoi_9=atoi(ai);
    tmp_if_expr_10 = return_value_atoi_9;
  }

  else
    tmp_if_expr_10 = 0;
  sym = tmp_if_expr_10;
  signed int enclosed;
  ai=getenv("enclosed");
  signed int tmp_if_expr_12;
  signed int return_value_atoi_11;
  if(!(ai == ((char *)NULL)))
  {
    return_value_atoi_11=atoi(ai);
    tmp_if_expr_12 = return_value_atoi_11;
  }

  else
    tmp_if_expr_12 = 1;
  enclosed = tmp_if_expr_12;
  char *clone;
  clone=getenv("clone");
  char *clone_all;
  clone_all=getenv("clone_all");
  char *animate;
  animate=getenv("animate");
  char *mutate;
  mutate=getenv("mutate");
  char *cross0;
  cross0=getenv("cross0");
  char *cross1;
  cross1=getenv("cross1");
  char *method;
  method=getenv("method");
  char *inter;
  inter=getenv("inter");
  char *rotate;
  rotate=getenv("rotate");
  char *strip;
  strip=getenv("strip");
  char *sequence;
  sequence=getenv("sequence");
  signed int loops;
  ai=getenv("loops");
  signed int tmp_if_expr_14;
  signed int return_value_atoi_13;
  if(!(ai == ((char *)NULL)))
  {
    return_value_atoi_13=atoi(ai);
    tmp_if_expr_14 = return_value_atoi_13;
  }

  else
    tmp_if_expr_14 = 1;
  loops = tmp_if_expr_14;
  signed int frame;
  ai=getenv("frame");
  signed int tmp_if_expr_16;
  signed int return_value_atoi_15;
  if(!(ai == ((char *)NULL)))
  {
    return_value_atoi_15=atoi(ai);
    tmp_if_expr_16 = return_value_atoi_15;
  }

  else
    tmp_if_expr_16 = 0;
  frame = tmp_if_expr_16;
  signed int rep;
  signed int repeat;
  ai=getenv("repeat");
  signed int tmp_if_expr_18;
  signed int return_value_atoi_17;
  if(!(ai == ((char *)NULL)))
  {
    return_value_atoi_17=atoi(ai);
    tmp_if_expr_18 = return_value_atoi_17;
  }

  else
    tmp_if_expr_18 = 1;
  repeat = tmp_if_expr_18;
  double speed;
  ai=getenv("speed");
  double tmp_if_expr_20;
  double return_value_atof_19;
  if(!(ai == ((char *)NULL)))
  {
    return_value_atof_19=atof(ai);
    tmp_if_expr_20 = return_value_atof_19;
  }

  else
    tmp_if_expr_20 = 0.1;
  speed = tmp_if_expr_20;
  signed int bits;
  ai=getenv("bits");
  signed int tmp_if_expr_22;
  signed int return_value_atoi_21;
  if(!(ai == ((char *)NULL)))
  {
    return_value_atoi_21=atoi(ai);
    tmp_if_expr_22 = return_value_atoi_21;
  }

  else
    tmp_if_expr_22 = 33;
  bits = tmp_if_expr_22;
  signed int ntries;
  ai=getenv("tries");
  signed int tmp_if_expr_24;
  signed int return_value_atoi_23;
  if(!(ai == ((char *)NULL)))
  {
    return_value_atoi_23=atoi(ai);
    tmp_if_expr_24 = return_value_atoi_23;
  }

  else
    tmp_if_expr_24 = 10;
  ntries = tmp_if_expr_24;
  char *use_vars;
  use_vars=getenv("use_vars");
  char *dont_use_vars;
  dont_use_vars=getenv("dont_use_vars");
  struct anonymous_0 *parent0 = (struct anonymous_0 *)(void *)0;
  struct anonymous_0 *parent1 = (struct anonymous_0 *)(void *)0;
  struct anonymous_0 selp0;
  struct anonymous_0 selp1;
  struct anonymous_0 *aselp0;
  struct anonymous_0 *aselp1;
  signed int parent0_n;
  signed int parent1_n;
  signed int num_threads = 1;
  struct anonymous_0 *cp;
  signed int ncp;
  signed int ivars[100l];
  signed int novars[100l];
  signed int num_ivars = 0;
  signed int num_novars = 0;
  char *var_tok;
  struct anonymous_4 f;
  char action[10000l];
  struct anonymous_8 stats;
  signed int tmp_statement_expression_26;
  if(argc >= 2)
  {
    unsigned long int main__1__1__1____s1_len;
    unsigned long int main__1__1__1____s2_len;
    signed int return_value___builtin_strcmp_27;
    return_value___builtin_strcmp_27=__builtin_strcmp("--version", argv[(signed long int)1]);
    tmp_statement_expression_26 = return_value___builtin_strcmp_27;
    if(tmp_statement_expression_26 == 0)
    {
      char *return_value_flam3_version_25;
      return_value_flam3_version_25=flam3_version();
      printf("FLAM3-%s\n", return_value_flam3_version_25);
      exit(0);
    }

    else
    {
      printf("unrecognized option %s, aborting.\n", argv[(signed long int)1]);
      exit(-1);
    }
  }

  ai=getenv("verbose");
  signed int tmp_if_expr_29;
  signed int return_value_atoi_28;
  if(!(ai == ((char *)NULL)))
  {
    return_value_atoi_28=atoi(ai);
    tmp_if_expr_29 = return_value_atoi_28;
  }

  else
    tmp_if_expr_29 = 0;
  verbose = tmp_if_expr_29;
  memset((void *)&cp_orig, 0, sizeof(struct anonymous_0) /*10712ul*/ );
  memset((void *)&cp_save, 0, sizeof(struct anonymous_0) /*10712ul*/ );
  memset((void *)&selp0, 0, sizeof(struct anonymous_0) /*10712ul*/ );
  memset((void *)&selp1, 0, sizeof(struct anonymous_0) /*10712ul*/ );
  if(!(argc == 1))
  {
    docstring();
    exit(0);
  }

  flam3_init_frame(&f);
  flam3_srandom();
  f.bits = bits;
  f.bytes_per_channel = 1;
  f.earlyclip = 1;
  f.verbose = 0;
  f.genomes = &cp_orig;
  f.ngenomes = 1;
  f.pixel_aspect_ratio = 1.0;
  f.progress = ((signed int (*)(void *, double, signed int, double))NULL);
  f.nthreads = num_threads;
  f.sub_batch_size = 10000;
  test_cp(&cp_orig);
  if(!(dont_use_vars == ((char *)NULL)) && !(use_vars == ((char *)NULL)))
  {
    fprintf(stderr, "use_vars and dont_use_vars cannot both be specified.  Terminating.\n");
    exit(-1);
  }

  signed int tmp_post_30;
  signed int tmp_post_31;
  signed int tmp_post_32;
  signed int tmp_post_33;
  signed int tmp_post_34;
  signed int tmp_post_35;
  signed int tmp_post_36;
  signed int tmp_post_37;
  signed int tmp_post_38;
  signed int tmp_post_39;
  signed int tmp_post_40;
  signed int tmp_post_41;
  signed int tmp_post_42;
  signed int tmp_post_43;
  signed int tmp_post_44;
  _Bool tmp_if_expr_45;
  signed int tmp_post_46;
  signed int tmp_post_47;
  signed int tmp_post_48;
  if(dont_use_vars == ((char *)NULL) && use_vars == ((char *)NULL))
  {
    tmp_post_30 = num_novars;
    num_novars = num_novars + 1;
    novars[(signed long int)tmp_post_30] = 31;
    tmp_post_31 = num_novars;
    num_novars = num_novars + 1;
    novars[(signed long int)tmp_post_31] = 34;
    tmp_post_32 = num_novars;
    num_novars = num_novars + 1;
    novars[(signed long int)tmp_post_32] = 35;
    tmp_post_33 = num_novars;
    num_novars = num_novars + 1;
    novars[(signed long int)tmp_post_33] = 36;
    tmp_post_34 = num_novars;
    num_novars = num_novars + 1;
    novars[(signed long int)tmp_post_34] = 38;
    tmp_post_35 = num_novars;
    num_novars = num_novars + 1;
    novars[(signed long int)tmp_post_35] = 43;
    tmp_post_36 = num_novars;
    num_novars = num_novars + 1;
    novars[(signed long int)tmp_post_36] = 44;
    tmp_post_37 = num_novars;
    num_novars = num_novars + 1;
    novars[(signed long int)tmp_post_37] = 48;
    tmp_post_38 = num_novars;
    num_novars = num_novars + 1;
    novars[(signed long int)tmp_post_38] = 67;
    tmp_post_39 = num_novars;
    num_novars = num_novars + 1;
    novars[(signed long int)tmp_post_39] = 73;
    tmp_post_40 = num_novars;
    num_novars = num_novars + 1;
    novars[(signed long int)tmp_post_40] = 74;
    tmp_post_41 = num_novars;
    num_novars = num_novars + 1;
    novars[(signed long int)tmp_post_41] = 75;
    i = 0;
    for( ; !(i >= 98); i = i + 1)
    {
      j = 0;
      for( ; !(j >= num_novars); j = j + 1)
        if(novars[(signed long int)j] == i)
          break;

      if(j == num_novars)
      {
        tmp_post_42 = num_ivars;
        num_ivars = num_ivars + 1;
        ivars[(signed long int)tmp_post_42] = i;
      }

    }
  }

  else
    if(!(use_vars == ((char *)NULL)))
    {
      var_tok=strtok(use_vars, ",");
      tmp_post_43 = num_ivars;
      num_ivars = num_ivars + 1;
      ivars[(signed long int)tmp_post_43]=atoi(var_tok);
      while((_Bool)1)
      {
        var_tok=strtok((char *)(void *)0, ",");
        if(var_tok == ((char *)NULL))
          break;

        tmp_post_44 = num_ivars;
        num_ivars = num_ivars + 1;
        ivars[(signed long int)tmp_post_44]=atoi(var_tok);
        if(num_ivars == 100)
        {
          fprintf(stderr, "Maximum number of user-specified variations exceeded.  Truncating.\n");
          break;
        }

      }
      i = 0;
      for( ; !(i >= num_ivars); i = i + 1)
      {
        if(!(ivars[(signed long int)i] >= 0))
          tmp_if_expr_45 = (_Bool)1;

        else
          tmp_if_expr_45 = ivars[(signed long int)i] >= 98 ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_45)
        {
          fprintf(stderr, "specified variation list includes bad value. (%d)\n", ivars[(signed long int)i]);
          exit(1);
        }

      }
    }

    else
      if(!(dont_use_vars == ((char *)NULL)))
      {
        var_tok=strtok(dont_use_vars, ",");
        tmp_post_46 = num_novars;
        num_novars = num_novars + 1;
        novars[(signed long int)tmp_post_46]=atoi(var_tok);
        while((_Bool)1)
        {
          var_tok=strtok((char *)(void *)0, ",");
          if(var_tok == ((char *)NULL))
            break;

          tmp_post_47 = num_novars;
          num_novars = num_novars + 1;
          novars[(signed long int)tmp_post_47]=atoi(var_tok);
          if(num_novars == 100)
          {
            fprintf(stderr, "Maximum number of user-specified variations exceeded.  Truncating.\n");
            break;
          }

        }
        i = 0;
        for( ; !(i >= 98); i = i + 1)
        {
          j = 0;
          for( ; !(j >= num_novars); j = j + 1)
            if(novars[(signed long int)j] == i)
              break;

          if(j == num_novars)
          {
            tmp_post_48 = num_ivars;
            num_ivars = num_ivars + 1;
            ivars[(signed long int)tmp_post_48] = i;
          }

        }
      }

  if((signed int)!(clone == ((char *)NULL)) + (signed int)!(inter == ((char *)NULL)) + (signed int)!(mutate == ((char *)NULL)) + (signed int)!(rotate == ((char *)NULL)) + (signed int)!(strip == ((char *)NULL)) + (signed int)(!(cross0 == ((char *)NULL)) || !(cross1 == ((char *)NULL))) >= 2)
  {
    fprintf(stderr, "can only specify one of mutate, clone, cross, rotate, strip, or inter.\n");
    exit(1);
  }

  if(cross0 == ((char *)NULL) ^ cross1 == ((char *)NULL))
  {
    fprintf(stderr, "must specify both crossover arguments.\n");
    exit(1);
  }

  if(cross0 == ((char *)NULL) && mutate == ((char *)NULL) && !(method == ((char *)NULL)))
  {
    fprintf(stderr, "cannot specify method unless doing crossover or mutate.\n");
    exit(1);
  }

  char *return_value_getenv_49;
  return_value_getenv_49=getenv("template");
  if(!(return_value_getenv_49 == ((char *)NULL)))
  {
    char *tf;
    tf=getenv("template");
    templ=string_to_cp(tf, &ncp);
    if(ncp >= 2)
      fprintf(stderr, "more than one control point in template, ignoring all but first.\n");

    else
      if(ncp == 0)
      {
        fprintf(stderr, "no control points in template.\n");
        exit(1);
      }

  }

  if(!(clone_all == ((char *)NULL)))
  {
    cp=string_to_cp(clone_all, &ncp);
    char *return_value_flam3_version_50;
    return_value_flam3_version_50=flam3_version();
    printf("<clone_all version=\"FLAM3-%s\">\n", return_value_flam3_version_50);
    i = 0;
    for( ; !(i >= ncp); i = i + 1)
    {
      if(!(templ == ((struct anonymous_0 *)NULL)))
        flam3_apply_template(&cp[(signed long int)i], templ);

      offset(&cp[(signed long int)i]);
      gprint(&cp[(signed long int)i], 1);
    }
    printf("</clone_all>\n");
    exit(0);
  }

  double tmp_if_expr_52;
  double return_value_atof_51;
  signed int tmp_if_expr_54;
  signed int return_value_atoi_53;
  signed int tmp_if_expr_57;
  signed int return_value_atoi_56;
  if(!(animate == ((char *)NULL)))
  {
    struct anonymous_0 interpolated;
    signed int first_frame;
    signed int last_frame;
    signed int ftime;
    signed int iscp;
    double stagger;
    ai=getenv("stagger");
    if(!(ai == ((char *)NULL)))
    {
      return_value_atof_51=atof(ai);
      tmp_if_expr_52 = return_value_atof_51;
    }

    else
      tmp_if_expr_52 = 0.0;
    stagger = tmp_if_expr_52;
    cp=string_to_cp(animate, &ncp);
    i = 0;
    for( ; !(i >= ncp); i = i + 1)
    {
      if(i >= 1)
      {
        if((cp + (signed long int)i)->time <= (cp + (signed long int)(i + -1))->time)
        {
          fprintf(stderr, "error: control points must be sorted by time, but %g <= %g, index %d.\n", (cp + (signed long int)i)->time, (cp + (signed long int)(i - 1))->time, i);
          exit(1);
        }

      }

      j = 0;
      for( ; !(j >= (cp + (signed long int)i)->num_xforms); j = j + 1)
        flam3_delete_motion_elements(&(cp + (signed long int)i)->xform[(signed long int)j]);
    }
    char *return_value_getenv_55;
    return_value_getenv_55=getenv("begin");
    if(return_value_getenv_55 == ((char *)NULL))
      first_frame = (signed int)(cp + (signed long int)0)->time;

    else
    {
      ai=getenv("begin");
      if(!(ai == ((char *)NULL)))
      {
        return_value_atoi_53=atoi(ai);
        tmp_if_expr_54 = return_value_atoi_53;
      }

      else
        tmp_if_expr_54 = 0;
      first_frame = tmp_if_expr_54;
    }
    char *return_value_getenv_58;
    return_value_getenv_58=getenv("end");
    if(return_value_getenv_58 == ((char *)NULL))
      last_frame = (signed int)(cp + (signed long int)(ncp - 1))->time;

    else
    {
      ai=getenv("end");
      if(!(ai == ((char *)NULL)))
      {
        return_value_atoi_56=atoi(ai);
        tmp_if_expr_57 = return_value_atoi_56;
      }

      else
        tmp_if_expr_57 = 0;
      last_frame = tmp_if_expr_57;
    }
    if(!(last_frame >= first_frame))
      last_frame = first_frame;

    char *return_value_flam3_version_59;
    return_value_flam3_version_59=flam3_version();
    printf("<animate version=\"FLAM3-%s\">\n", return_value_flam3_version_59);
    ftime = first_frame;
    for( ; last_frame >= ftime; ftime = ftime + 1)
    {
      iscp = 0;
      i = 0;
      for( ; !(i >= ncp); i = i + 1)
        if(IEEE_FLOAT_EQUAL((double)ftime, (cp + (signed long int)i)->time))
        {
          flam3_copy(&interpolated, &cp[(signed long int)i]);
          iscp = 1;
        }

      if(iscp == 0)
      {
        flam3_interpolate(cp, ncp, (double)ftime, stagger, &interpolated);
        i = 0;
        for( ; !(i >= ncp); i = i + 1)
          if(IEEE_FLOAT_EQUAL((double)ftime, (cp + (signed long int)i)->time + -1.000000))
            iscp = 1;

        if(iscp == 0)
          interpolated.interpolation_type = 0;

      }

      if(!(templ == ((struct anonymous_0 *)NULL)))
        flam3_apply_template(&interpolated, templ);

      gprint(&interpolated, 1);
    }
    printf("</animate>\n");
    exit(0);
  }

  char *return_value_flam3_version_60;
  signed int tmp_post_61;
  signed int tmp_post_62;
  if(!(sequence == ((char *)NULL)))
  {
    double blend;
    double spread;
    signed int seqflag;
    signed int framecount;
    if(!(nframes >= 1))
    {
      fprintf(stderr, "nframes must be positive, not %d.\n", nframes);
      exit(1);
    }

    cp=string_to_cp(sequence, &ncp);
    if(!(enclosed == 0))
    {
      return_value_flam3_version_60=flam3_version();
      printf("<sequence version=\"FLAM3-%s\">\n", return_value_flam3_version_60);
    }

    spread = 1.0 / (double)nframes;
    framecount = 0;
    i = 0;
    for( ; !(i >= ncp); i = i + 1)
    {
      if(!(loops == 0))
      {
        frame = 0;
        for( ; !(frame >= nframes); frame = frame + 1)
        {
          blend = (double)frame / (double)nframes;
          tmp_post_61 = framecount;
          framecount = framecount + 1;
          spin(tmp_post_61, blend, &cp[(signed long int)i], templ);
        }
      }

      if(!(i >= ncp + -1))
      {
        frame = 0;
        for( ; !(frame >= nframes); frame = frame + 1)
        {
          if(nframes + -1 == frame || frame == 0)
            seqflag = 1;

          else
            seqflag = 0;
          blend = (double)frame / (double)nframes;
          tmp_post_62 = framecount;
          framecount = framecount + 1;
          spin_inter(tmp_post_62, blend, seqflag, &cp[(signed long int)i], templ);
        }
      }

    }
    spin(framecount, 0.0, &cp[(signed long int)(ncp - 1)], templ);
    if(!(enclosed == 0))
      printf("</sequence>\n");

    exit(0);
  }

  char *return_value_flam3_version_63;
  if(!(inter == ((char *)NULL)) || !(rotate == ((char *)NULL)))
  {
    double main__1__13__blend;
    double main__1__13__spread;
    char *fname = inter != ((char *)NULL) ? inter : rotate;
    signed int ni;
    if(!(nframes >= 1))
    {
      fprintf(stderr, "nframes must be positive, not %d.\n", nframes);
      exit(1);
    }

    main__1__13__blend = (double)frame / (double)nframes;
    main__1__13__spread = 1.0 / (double)nframes;
    cp=string_to_cp(fname, &ncp);
    if(!(enclosed == 0))
    {
      return_value_flam3_version_63=flam3_version();
      printf("<pick version=\"FLAM3-%s\">\n", return_value_flam3_version_63);
    }

    if(!(rotate == ((char *)NULL)))
    {
      if(!(ncp == 1))
      {
        fprintf(stderr, "rotation requires one control point, not %d.\n", ncp);
        exit(1);
      }

      spin(frame - 1, main__1__13__blend - main__1__13__spread, cp, templ);
      spin(frame, main__1__13__blend, cp, templ);
      spin(frame + 1, main__1__13__blend + main__1__13__spread, cp, templ);
    }

    else
    {
      if(!(ncp == 2))
      {
        fprintf(stderr, "interpolation requires two control points, not %d.\n", ncp);
        exit(1);
      }

      spin_inter(frame - 1, main__1__13__blend - main__1__13__spread, 0, cp, templ);
      spin_inter(frame, main__1__13__blend, 0, cp, templ);
      spin_inter(frame + 1, main__1__13__blend + main__1__13__spread, 0, cp, templ);
    }
    if(!(enclosed == 0))
      printf("</pick>\n");

    ni = 0;
    for( ; !(ni >= ncp); ni = ni + 1)
    {
      xmlFreeDoc((cp + (signed long int)ni)->edits);
      clear_cp(&cp[(signed long int)ni], 1);
    }
    free((void *)cp);
    exit(0);
  }

  char *return_value_flam3_version_64;
  if(!(strip == ((char *)NULL)))
  {
    cp=string_to_cp(strip, &ncp);
    if(!(enclosed == 0))
    {
      return_value_flam3_version_64=flam3_version();
      printf("<pick version=\"FLAM3-%s\">\n", return_value_flam3_version_64);
    }

    i = 0;
    for( ; !(i >= ncp); i = i + 1)
    {
      double old_center[2l];
      j = 0;
      for( ; !(j >= (cp + (signed long int)i)->num_xforms); j = j + 1)
        flam3_delete_motion_elements(&(cp + (signed long int)i)->xform[(signed long int)j]);
      old_center[(signed long int)0] = (cp + (signed long int)i)->center[(signed long int)0];
      old_center[(signed long int)1] = (cp + (signed long int)i)->center[(signed long int)1];
      (cp + (signed long int)i)->height = (cp + (signed long int)i)->height / nframes;
      double return_value_pow_65;
      return_value_pow_65=pow(2.0, (cp + (signed long int)i)->zoom);
      (cp + (signed long int)i)->center[(signed long int)1] = (cp + (signed long int)i)->center[(signed long int)1] - (double)((nframes - 1) * (cp + (signed long int)i)->height) / ((double)2 * (cp + (signed long int)i)->pixels_per_unit * return_value_pow_65);
      double return_value_pow_66;
      return_value_pow_66=pow(2.0, (cp + (signed long int)i)->zoom);
      (cp + (signed long int)i)->center[(signed long int)1] = (cp + (signed long int)i)->center[(signed long int)1] + (double)((cp + (signed long int)i)->height * frame) / ((cp + (signed long int)i)->pixels_per_unit * return_value_pow_66);
      rotate_by((cp + (signed long int)i)->center, old_center, (cp + (signed long int)i)->rotate);
      if(!(templ == ((struct anonymous_0 *)NULL)))
        flam3_apply_template(&cp[(signed long int)i], templ);

      offset(&cp[(signed long int)i]);
      gprint(&cp[(signed long int)i], 1);
    }
    if(!(enclosed == 0))
      printf("</pick>\n");

    exit(0);
  }

  if(!(repeat >= 1))
  {
    fprintf(stderr, "repeat must be positive, not %d.\n", repeat);
    exit(1);
  }

  char *return_value_flam3_version_67;
  if(!(enclosed == 0))
  {
    return_value_flam3_version_67=flam3_version();
    printf("<pick version=\"FLAM3-%s\">\n", return_value_flam3_version_67);
  }

  void *return_value_malloc_68;
  return_value_malloc_68=malloc((unsigned long int)(3 * cp_orig.width * cp_orig.height));
  image = (unsigned char *)return_value_malloc_68;
  rep = 0;
  char *return_value_getenv_69;
  unsigned long int tmp_post_72;
  unsigned long int tmp_if_expr_73;
  signed int tmp_statement_expression_86;
  signed int tmp_statement_expression_84;
  signed int tmp_statement_expression_82;
  signed int tmp_statement_expression_80;
  signed int tmp_statement_expression_78;
  signed int tmp_statement_expression_76;
  signed int tmp_statement_expression_74;
  unsigned long int tmp_post_90;
  unsigned long int tmp_if_expr_91;
  unsigned long int tmp_post_92;
  unsigned long int tmp_if_expr_93;
  signed int tmp_statement_expression_98;
  signed int tmp_statement_expression_96;
  signed int tmp_statement_expression_94;
  _Bool tmp_if_expr_101;
  signed int return_value_flam3_random_isaac_bit_110;
  signed long int return_value_random_114;
  signed int return_value_atoi_117;
  signed int return_value_atoi_116;
  for( ; !(rep >= repeat); rep = rep + 1)
  {
    if(!(verbose == 0))
      fprintf(stderr, "flame = %d/%d..", rep + 1, repeat);

    count = 0;
    if(!(clone == ((char *)NULL)))
    {
      parent0=string_to_cp(clone, &parent0_n);
      sprintf(action, "clone");
      char *return_value_getenv_70;
      return_value_getenv_70=getenv("clone_action");
      if(!(return_value_getenv_70 == ((char *)NULL)))
      {
        return_value_getenv_69=getenv("clone_action");
        sprintf(action, "clone %s", return_value_getenv_69);
      }

      signed long int return_value_random_71;
      return_value_random_71=random();
      flam3_copy(&selp0, &parent0[return_value_random_71 % (signed long int)parent0_n]);
      flam3_copy(&cp_save, &selp0);
      aselp0 = &selp0;
      aselp1 = (struct anonymous_0 *)(void *)0;
      truncate_variations(&cp_save, 5, action);
      cp_save.edits=create_new_editdoc(action, aselp0, aselp1);
    }

    else
    {
      signed int did_color;
      do
      {
        signed int random_mode = 0;
        if(!(verbose == 0))
          fprintf(stderr, ".");

        did_color = 0;
        f.time = (double)0.0;
        action[(signed long int)0] = (char)0;
        if(!(mutate == ((char *)NULL)))
        {
          signed int mutmeth;
          parent0=string_to_cp(mutate, &parent0_n);
          tmp_post_72 = (&f.rc)->randcnt;
          (&f.rc)->randcnt = (&f.rc)->randcnt - 1ul;
          if(tmp_post_72 == 0ul)
          {
            isaac(&f.rc);
            (&f.rc)->randcnt = (unsigned long int)((1 << 4) - 1);
            tmp_if_expr_73 = (&f.rc)->randrsl[(signed long int)(&f.rc)->randcnt];
          }

          else
            tmp_if_expr_73 = (&f.rc)->randrsl[(signed long int)(&f.rc)->randcnt];
          flam3_copy(&selp0, &parent0[(signed long int)((unsigned int)tmp_if_expr_73 % (unsigned int)parent0_n)]);
          flam3_copy(&cp_orig, &selp0);
          aselp0 = &selp0;
          aselp1 = (struct anonymous_0 *)(void *)0;
          char *return_value_getenv_88;
          return_value_getenv_88=getenv("method");
          if(return_value_getenv_88 == ((char *)NULL))
            mutmeth = -1;

          else
          {
            unsigned long int __s1_len;
            unsigned long int __s2_len;
            signed int return_value___builtin_strcmp_87;
            return_value___builtin_strcmp_87=__builtin_strcmp(method, "all_vars");
            tmp_statement_expression_86 = return_value___builtin_strcmp_87;
            if(tmp_statement_expression_86 == 0)
              mutmeth = 0;

            else
            {
              unsigned long int main__1__16__1__2__1__1__2____s1_len;
              unsigned long int main__1__16__1__2__1__1__2____s2_len;
              signed int return_value___builtin_strcmp_85;
              return_value___builtin_strcmp_85=__builtin_strcmp(method, "one_xform");
              tmp_statement_expression_84 = return_value___builtin_strcmp_85;
              if(tmp_statement_expression_84 == 0)
                mutmeth = 1;

              else
              {
                unsigned long int main__1__16__1__2__1__1__3____s1_len;
                unsigned long int main__1__16__1__2__1__1__3____s2_len;
                signed int return_value___builtin_strcmp_83;
                return_value___builtin_strcmp_83=__builtin_strcmp(method, "add_symmetry");
                tmp_statement_expression_82 = return_value___builtin_strcmp_83;
                if(tmp_statement_expression_82 == 0)
                  mutmeth = 2;

                else
                {
                  unsigned long int main__1__16__1__2__1__1__4____s1_len;
                  unsigned long int main__1__16__1__2__1__1__4____s2_len;
                  signed int return_value___builtin_strcmp_81;
                  return_value___builtin_strcmp_81=__builtin_strcmp(method, "post_xforms");
                  tmp_statement_expression_80 = return_value___builtin_strcmp_81;
                  if(tmp_statement_expression_80 == 0)
                    mutmeth = 3;

                  else
                  {
                    unsigned long int main__1__16__1__2__1__1__5____s1_len;
                    unsigned long int main__1__16__1__2__1__1__5____s2_len;
                    signed int return_value___builtin_strcmp_79;
                    return_value___builtin_strcmp_79=__builtin_strcmp(method, "color_palette");
                    tmp_statement_expression_78 = return_value___builtin_strcmp_79;
                    if(tmp_statement_expression_78 == 0)
                      mutmeth = 4;

                    else
                    {
                      unsigned long int main__1__16__1__2__1__1__6____s1_len;
                      unsigned long int main__1__16__1__2__1__1__6____s2_len;
                      signed int return_value___builtin_strcmp_77;
                      return_value___builtin_strcmp_77=__builtin_strcmp(method, "delete_xform");
                      tmp_statement_expression_76 = return_value___builtin_strcmp_77;
                      if(tmp_statement_expression_76 == 0)
                        mutmeth = 5;

                      else
                      {
                        unsigned long int main__1__16__1__2__1__1__7____s1_len;
                        unsigned long int main__1__16__1__2__1__1__7____s2_len;
                        signed int return_value___builtin_strcmp_75;
                        return_value___builtin_strcmp_75=__builtin_strcmp(method, "all_coefs");
                        tmp_statement_expression_74 = return_value___builtin_strcmp_75;
                        if(tmp_statement_expression_74 == 0)
                          mutmeth = 6;

                        else
                        {
                          fprintf(stderr, "method '%s' not defined for mutate.  defaulting to random.\n", method);
                          mutmeth = -1;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          flam3_mutate(&cp_orig, mutmeth, ivars, num_ivars, sym, speed, &f.rc, action);
          char *return_value_strstr_89;
          return_value_strstr_89=strstr(action, "mutate color");
          if(!(return_value_strstr_89 == ((char *)NULL)))
            did_color = 1;

          if(!(cp_orig.flame_name[0l] == 0))
          {
            char tm[65l];
            __builtin_strncpy(tm, cp_orig.flame_name, (unsigned long int)64);
            snprintf(cp_orig.flame_name, (unsigned long int)64, "mutation %d of %s", rep, (const void *)tm);
          }

        }

        else
          if(!(cross0 == ((char *)NULL)))
          {
            signed int i0;
            signed int i1;
            signed int crossmeth;
            parent0=string_to_cp(cross0, &parent0_n);
            parent1=string_to_cp(cross1, &parent1_n);
            tmp_post_90 = (&f.rc)->randcnt;
            (&f.rc)->randcnt = (&f.rc)->randcnt - 1ul;
            if(tmp_post_90 == 0ul)
            {
              isaac(&f.rc);
              (&f.rc)->randcnt = (unsigned long int)((1 << 4) - 1);
              tmp_if_expr_91 = (&f.rc)->randrsl[(signed long int)(&f.rc)->randcnt];
            }

            else
              tmp_if_expr_91 = (&f.rc)->randrsl[(signed long int)(&f.rc)->randcnt];
            i0 = (signed int)((unsigned int)tmp_if_expr_91 % (unsigned int)parent0_n);
            tmp_post_92 = (&f.rc)->randcnt;
            (&f.rc)->randcnt = (&f.rc)->randcnt - 1ul;
            if(tmp_post_92 == 0ul)
            {
              isaac(&f.rc);
              (&f.rc)->randcnt = (unsigned long int)((1 << 4) - 1);
              tmp_if_expr_93 = (&f.rc)->randrsl[(signed long int)(&f.rc)->randcnt];
            }

            else
              tmp_if_expr_93 = (&f.rc)->randrsl[(signed long int)(&f.rc)->randcnt];
            i1 = (signed int)((unsigned int)tmp_if_expr_93 % (unsigned int)parent1_n);
            flam3_copy(&selp0, &parent0[(signed long int)i0]);
            flam3_copy(&selp1, &parent1[(signed long int)i1]);
            aselp0 = &selp0;
            aselp1 = &selp1;
            char *return_value_getenv_100;
            return_value_getenv_100=getenv("method");
            if(return_value_getenv_100 == ((char *)NULL))
              crossmeth = -1;

            else
            {
              unsigned long int main__1__16__1__2__1__2__1____s1_len;
              unsigned long int main__1__16__1__2__1__2__1____s2_len;
              signed int return_value___builtin_strcmp_99;
              return_value___builtin_strcmp_99=__builtin_strcmp(method, "union");
              tmp_statement_expression_98 = return_value___builtin_strcmp_99;
              if(tmp_statement_expression_98 == 0)
                crossmeth = 0;

              else
              {
                unsigned long int main__1__16__1__2__1__2__2____s1_len;
                unsigned long int main__1__16__1__2__1__2__2____s2_len;
                signed int return_value___builtin_strcmp_97;
                return_value___builtin_strcmp_97=__builtin_strcmp(method, "interpolate");
                tmp_statement_expression_96 = return_value___builtin_strcmp_97;
                if(tmp_statement_expression_96 == 0)
                  crossmeth = 1;

                else
                {
                  unsigned long int main__1__16__1__2__1__2__3____s1_len;
                  unsigned long int main__1__16__1__2__1__2__3____s2_len;
                  signed int return_value___builtin_strcmp_95;
                  return_value___builtin_strcmp_95=__builtin_strcmp(method, "alternate");
                  tmp_statement_expression_94 = return_value___builtin_strcmp_95;
                  if(tmp_statement_expression_94 == 0)
                    crossmeth = 2;

                  else
                  {
                    fprintf(stderr, "method '%s' not defined for cross.  defaulting to random.\n", method);
                    crossmeth = -1;
                  }
                }
              }
            }
            flam3_cross(&parent0[(signed long int)i0], &parent1[(signed long int)i1], &cp_orig, crossmeth, &f.rc, action);
            if(!((parent0 + (signed long int)i0)->flame_name[0l] == 0))
              tmp_if_expr_101 = (_Bool)1;

            else
              tmp_if_expr_101 = (parent1 + (signed long int)i1)->flame_name[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;
            if(tmp_if_expr_101)
              snprintf(cp_orig.flame_name, (unsigned long int)64, "%d of %s x %s", rep, (const void *)(parent0 + (signed long int)i0)->flame_name, (const void *)(parent1 + (signed long int)i1)->flame_name);

          }

          else
          {
            sprintf(action, "random");
            random_mode = 1;
            flam3_random(&cp_orig, ivars, num_ivars, sym, 0);
            aselp0 = (struct anonymous_0 *)(void *)0;
            aselp1 = (struct anonymous_0 *)(void *)0;
          }
        signed int return_value_flam3_random_bit_113;
        return_value_flam3_random_bit_113=flam3_random_bit(&f.rc);
        if(!(return_value_flam3_random_bit_113 == 0) || !(random_mode == 0))
        {
          double bmin[2l];
          double bmax[2l];
          flam3_estimate_bounding_box(&cp_orig, 0.01, 100000, bmin, bmax, &f.rc);
          double return_value_flam3_random_isaac_01_112;
          return_value_flam3_random_isaac_01_112=flam3_random_isaac_01(&f.rc);
          if(return_value_flam3_random_isaac_01_112 < 0.3)
          {
            cp_orig.center[(signed long int)0] = (bmin[(signed long int)0] + bmax[(signed long int)0]) / 2.0;
            cp_orig.center[(signed long int)1] = (bmin[(signed long int)1] + bmax[(signed long int)1]) / 2.0;
            add_to_action(action, " recentered");
          }

          else
          {
            double mix0;
            double mix1;
            signed int return_value_flam3_random_isaac_bit_111;
            return_value_flam3_random_isaac_bit_111=flam3_random_isaac_bit(&f.rc);
            if(!(return_value_flam3_random_isaac_bit_111 == 0))
            {
              double return_value_golden_bit_102;
              return_value_golden_bit_102=golden_bit(&f.rc);
              double return_value_flam3_random_isaac_11_103;
              return_value_flam3_random_isaac_11_103=flam3_random_isaac_11(&f.rc);
              mix0 = return_value_golden_bit_102 + return_value_flam3_random_isaac_11_103 / (double)5;
              mix1=golden_bit(&f.rc);
              add_to_action(action, " reframed0");
            }

            else
            {
              return_value_flam3_random_isaac_bit_110=flam3_random_isaac_bit(&f.rc);
              if(!(return_value_flam3_random_isaac_bit_110 == 0))
              {
                mix0=golden_bit(&f.rc);
                double return_value_golden_bit_104;
                return_value_golden_bit_104=golden_bit(&f.rc);
                double return_value_flam3_random_isaac_11_105;
                return_value_flam3_random_isaac_11_105=flam3_random_isaac_11(&f.rc);
                mix1 = return_value_golden_bit_104 + return_value_flam3_random_isaac_11_105 / (double)5;
                add_to_action(action, " reframed1");
              }

              else
              {
                double return_value_golden_bit_106;
                return_value_golden_bit_106=golden_bit(&f.rc);
                double return_value_flam3_random_isaac_11_107;
                return_value_flam3_random_isaac_11_107=flam3_random_isaac_11(&f.rc);
                mix0 = return_value_golden_bit_106 + return_value_flam3_random_isaac_11_107 / (double)5;
                double return_value_golden_bit_108;
                return_value_golden_bit_108=golden_bit(&f.rc);
                double return_value_flam3_random_isaac_11_109;
                return_value_flam3_random_isaac_11_109=flam3_random_isaac_11(&f.rc);
                mix1 = return_value_golden_bit_108 + return_value_flam3_random_isaac_11_109 / (double)5;
                add_to_action(action, " reframed2");
              }
            }
            cp_orig.center[(signed long int)0] = mix0 * bmin[(signed long int)0] + ((double)1 - mix0) * bmax[(signed long int)0];
            cp_orig.center[(signed long int)1] = mix1 * bmin[(signed long int)1] + ((double)1 - mix1) * bmax[(signed long int)1];
          }
          cp_orig.rot_center[(signed long int)0] = cp_orig.center[(signed long int)0];
          cp_orig.rot_center[(signed long int)1] = cp_orig.center[(signed long int)1];
          cp_orig.pixels_per_unit = (double)cp_orig.width / (bmax[(signed long int)0] - bmin[(signed long int)0]);
        }

        truncate_variations(&cp_orig, 5, action);
        if(did_color == 0)
        {
          return_value_random_114=random();
          if(!((1l & return_value_random_114) == 0l))
          {
            if(!(debug == 0))
              fprintf(stderr, "improving colors...\n");

            flam3_improve_colors(&cp_orig, 100, 0, 10);
            add_to_action(action, " improved colors");
          }

        }

        cp_orig.edits=create_new_editdoc(action, aselp0, aselp1);
        flam3_copy(&cp_save, &cp_orig);
        test_cp(&cp_orig);
        signed int return_value_flam3_render_115;
        return_value_flam3_render_115=flam3_render(&f, (void *)image, 0, 3, 0, &stats);
        if(!(return_value_flam3_render_115 == 0))
        {
          fprintf(stderr, "error rendering test image: aborting.\n");
          exit(1);
        }

        {
          signed int n;
          signed int tot;
          signed int totb;
          signed int totw;
          n = cp_orig.width * cp_orig.height;
          tot = 0;
          totb = 0;
          totw = 0;
          i = 0;
          for( ; !(i >= 3 * n); i = i + 3)
          {
            tot = tot + (signed int)image[(signed long int)i] + (signed int)image[(signed long int)(i + 1)] + (signed int)image[(signed long int)(i + 2)];
            if((signed int)image[(signed long int)i] == 0)
            {
              if((signed int)image[(signed long int)(1 + i)] == 0)
              {
                if((signed int)image[(signed long int)(2 + i)] == 0)
                  totb = totb + 1;

              }

            }

            if((signed int)image[(signed long int)i] == 255)
            {
              if((signed int)image[(signed long int)(1 + i)] == 255)
              {
                if((signed int)image[(signed long int)(2 + i)] == 255)
                  totw = totw + 1;

              }

            }

          }
          avg_pix = (double)tot / (double)(3 * n);
          fraction_black = (double)totb / (double)n;
          fraction_white = (double)totw / (double)n;
          if(!(debug == 0))
            fprintf(stderr, "avg_pix=%g fraction_black=%g fraction_white=%g n=%g\n", avg_pix, fraction_black, fraction_white, (double)n);

        }
        clear_cp(&cp_orig, 1);
        count = count + 1;
      }
      while(!(count >= ntries) && (avg_pix < avg_thresh || fraction_black < black_thresh || fraction_white > white_limit));
      if(ntries == count)
        fprintf(stderr, "warning: reached maximum attempts, giving up.\n");

    }
    if(!(templ == ((struct anonymous_0 *)NULL)))
      flam3_apply_template(&cp_save, templ);

    cp_save.time = (double)rep;
    {
      char *maxforms;
      maxforms=getenv("maxforms");
      if(!(maxforms == ((char *)NULL)))
      {
        return_value_atoi_117=atoi(maxforms);
        if(!(return_value_atoi_117 == 0))
        {
          cp_save.symmetry = 0;
          do
          {
            return_value_atoi_116=atoi(maxforms);
            if(return_value_atoi_116 >= cp_save.num_xforms)
              break;

            flam3_delete_xform(&cp_save, cp_save.num_xforms - 1);
          }
          while((_Bool)1);
        }

      }

    }
    gprint(&cp_save, 1);
    fflush(stdout);
    xmlFreeDoc(cp_save.edits);
    clear_cp(&cp_save, 0);
    if(!(verbose == 0))
      fprintf(stderr, "\ndone.  action = %s\n", (const void *)action);

  }
  if(!(enclosed == 0))
    printf("</pick>\n");

  free((void *)image);
  return 0;
}

// motion_funcs
// file interpolation.h line 32
double motion_funcs(signed int funcnum, double timeval)
{
  if(funcnum == 1)
  {
    double return_value_sin_1;
    return_value_sin_1=sin(2.0 * 3.14159265358979323846 * timeval);
    return return_value_sin_1;
  }

  else
    if(funcnum == 2)
    {
      double fr;
      fr=fmod(timeval, 1.0);
      if(fr < 0.000000)
        fr = fr + 1.0;

      if(fr <= .25)
        fr = 4.0 * fr;

      else
        if(fr <= .75)
          fr = -4.0 * fr + 2.0;

        else
          fr = 4.0 * fr - 4.0;
      return fr;
    }

    else
    {
      double return_value_cos_2;
      return_value_cos_2=cos(2.0 * 3.14159265358979323846 * timeval);
      return (1.0 - return_value_cos_2) * 0.5;
    }
}

// mult_matrix
// file interpolation.h line 43
void mult_matrix(double (*s1)[2l], double (*s2)[2l], double (*d)[2l])
{
  d[(signed long int)0][(signed long int)0] = s1[(signed long int)0][(signed long int)0] * s2[(signed long int)0][(signed long int)0] + s1[(signed long int)1][(signed long int)0] * s2[(signed long int)0][(signed long int)1];
  d[(signed long int)1][(signed long int)0] = s1[(signed long int)0][(signed long int)0] * s2[(signed long int)1][(signed long int)0] + s1[(signed long int)1][(signed long int)0] * s2[(signed long int)1][(signed long int)1];
  d[(signed long int)0][(signed long int)1] = s1[(signed long int)0][(signed long int)1] * s2[(signed long int)0][(signed long int)0] + s1[(signed long int)1][(signed long int)1] * s2[(signed long int)0][(signed long int)1];
  d[(signed long int)1][(signed long int)1] = s1[(signed long int)0][(signed long int)1] * s2[(signed long int)1][(signed long int)0] + s1[(signed long int)1][(signed long int)1] * s2[(signed long int)1][(signed long int)1];
}

// normalize_vector
// file filters.c line 204
signed int normalize_vector(double *v, signed int n)
{
  double t = 0.0;
  signed int i = 0;
  for( ; !(i >= n); i = i + 1)
    t = t + v[(signed long int)i];
  if(IEEE_FLOAT_EQUAL(0.0, t))
    return 1;

  else
  {
    t = 1.0 / t;
    i = 0;
    for( ; !(i >= n); i = i + 1)
      v[(signed long int)i] = v[(signed long int)i] * t;
    return 0;
  }
}

// offset
// file flam3-genome.c line 220
void offset(struct anonymous_0 *g)
{
  char *os;
  os=getenv("offset");
  double ox;
  double oy;
  if(!(os == ((char *)NULL)))
  {
    sscanf(os, "%lf:%lf", &ox, &oy);
    g->center[(signed long int)0] = g->center[(signed long int)0] + ox / (g->pixels_per_unit * (double)g->spatial_oversample);
    g->center[(signed long int)1] = g->center[(signed long int)1] + oy / (g->pixels_per_unit * (double)g->spatial_oversample);
  }

}

// parse_flame_element
// file parser.c line 284
signed int parse_flame_element(struct _xmlNode *flame_node, struct anonymous_0 *loc_current_cp)
{
  struct anonymous_0 *cp = loc_current_cp;
  struct _xmlNode *chld_node;
  struct _xmlNode *motion_node;
  struct _xmlNode *edit_node;
  struct _xmlAttr *att_ptr;
  struct _xmlAttr *cur_att;
  signed int solo_xform = -1;
  char *att_str;
  signed int num_std_xforms = -1;
  char tmps[2l];
  signed int i;
  signed int j;
  struct xform tmpcpy;
  struct anonymous_7 *xaos = (struct anonymous_7 *)(void *)0;
  signed int num_xaos = 0;
  flam3_conversion_failed = 0;
  i = 0;
  for( ; !(i >= 256); i = i + 1)
  {
    cp->palette[(signed long int)i].color[(signed long int)0] = (double)0;
    cp->palette[(signed long int)i].color[(signed long int)1] = (double)0;
    cp->palette[(signed long int)i].color[(signed long int)2] = (double)0;
    cp->palette[(signed long int)i].color[(signed long int)3] = (double)0;
    cp->palette[(signed long int)i].index = (double)-1;
  }
  att_ptr = flame_node->properties;
  signed int return_value_xmlStrcmp_97;
  signed int tmp_statement_expression_4;
  signed int tmp_statement_expression_2;
  signed int return_value_xmlStrcmp_96;
  signed int tmp_statement_expression_8;
  signed int tmp_statement_expression_6;
  signed int return_value_xmlStrcmp_93;
  _Bool tmp_if_expr_95;
  signed int return_value_xmlStrcmp_94;
  signed int tmp_statement_expression_16;
  signed int tmp_statement_expression_14;
  signed int tmp_statement_expression_12;
  signed int tmp_statement_expression_10;
  signed int return_value_xmlStrcmp_92;
  signed int tmp_post_19;
  signed int return_value_xmlStrcmp_91;
  signed int return_value_xmlStrcmp_90;
  signed int return_value_xmlStrcmp_89;
  signed int return_value_xmlStrcmp_88;
  signed int return_value_xmlStrcmp_87;
  signed int return_value_xmlStrcmp_86;
  signed int return_value_xmlStrcmp_85;
  signed int return_value_xmlStrcmp_84;
  signed int return_value_xmlStrcmp_83;
  signed int return_value_xmlStrcmp_82;
  signed int tmp_statement_expression_49;
  signed int tmp_statement_expression_47;
  signed int tmp_statement_expression_45;
  signed int tmp_statement_expression_43;
  signed int tmp_statement_expression_41;
  signed int tmp_statement_expression_39;
  signed int tmp_statement_expression_37;
  signed int tmp_statement_expression_35;
  signed int tmp_statement_expression_33;
  signed int tmp_statement_expression_31;
  signed int tmp_statement_expression_29;
  signed int tmp_statement_expression_27;
  signed int tmp_statement_expression_25;
  signed int tmp_statement_expression_23;
  signed int return_value_xmlStrcmp_81;
  signed int tmp_statement_expression_55;
  signed int tmp_statement_expression_53;
  signed int tmp_statement_expression_51;
  signed int return_value_xmlStrcmp_80;
  signed int return_value_xmlStrcmp_79;
  signed int return_value_xmlStrcmp_78;
  signed int tmp_statement_expression_59;
  signed int tmp_statement_expression_57;
  signed int return_value_xmlStrcmp_77;
  signed int return_value_xmlStrcmp_76;
  signed int return_value_xmlStrcmp_75;
  signed int return_value_xmlStrcmp_74;
  signed int return_value_xmlStrcmp_73;
  signed int return_value_xmlStrcmp_72;
  signed int return_value_xmlStrcmp_71;
  signed int return_value_xmlStrcmp_70;
  signed int return_value_xmlStrcmp_69;
  signed int return_value_xmlStrcmp_68;
  signed int return_value_xmlStrcmp_67;
  signed int return_value_xmlStrcmp_66;
  signed int return_value_xmlStrcmp_65;
  signed int return_value_xmlStrcmp_64;
  signed int return_value_xmlStrcmp_105;
  signed int return_value_xmlStrcmp_104;
  signed int return_value_xmlStrcmp_103;
  signed int return_value_xmlStrcmp_138;
  signed int return_value_xmlStrcmp_109;
  signed int return_value_xmlStrcmp_137;
  signed int return_value_xmlStrcmp_121;
  signed int return_value_xmlStrcmp_120;
  signed int return_value_xmlStrcmp_119;
  signed int return_value_xmlStrcmp_118;
  signed int return_value_xmlStrcmp_117;
  signed int return_value_xmlStrcmp_116;
  signed int tmp_statement_expression_114;
  signed int tmp_statement_expression_112;
  signed int return_value_xmlStrcmp_136;
  signed int return_value_xmlStrcmp_133;
  _Bool tmp_if_expr_135;
  signed int return_value_xmlStrcmp_134;
  _Bool tmp_if_expr_129;
  signed int return_value_xmlStrcmp_132;
  if(att_ptr == ((struct _xmlAttr *)NULL))
  {
    fprintf(stderr, "Error : <flame> element has no attributes.\n");
    return 1;
  }

  else
  {
    memset((void *)cp->flame_name, 0, (unsigned long int)(64 + 1));
    cur_att = att_ptr;
    if(!(cur_att == ((struct _xmlAttr *)NULL)))
    {
      unsigned char *return_value_xmlGetProp_1;
      return_value_xmlGetProp_1=xmlGetProp(flame_node, cur_att->name);
      att_str = (char *)return_value_xmlGetProp_1;
      signed int return_value_xmlStrcmp_98;
      return_value_xmlStrcmp_98=xmlStrcmp(cur_att->name, (const unsigned char *)"time");
      if(return_value_xmlStrcmp_98 == 0)
        cp->time=flam3_atof(att_str);

      else
      {
        return_value_xmlStrcmp_97=xmlStrcmp(cur_att->name, (const unsigned char *)"interpolation");
        if(return_value_xmlStrcmp_97 == 0)
        {
          unsigned long int parse_flame_element__1__3__1__2__1____s1_len;
          unsigned long int parse_flame_element__1__3__1__2__1____s2_len;
          signed int return_value___builtin_strcmp_5;
          return_value___builtin_strcmp_5=__builtin_strcmp("linear", att_str);
          tmp_statement_expression_4 = return_value___builtin_strcmp_5;
          if(tmp_statement_expression_4 == 0)
            cp->interpolation = 0;

          else
          {
            unsigned long int parse_flame_element__1__3__1__2__3____s1_len;
            unsigned long int parse_flame_element__1__3__1__2__3____s2_len;
            signed int return_value___builtin_strcmp_3;
            return_value___builtin_strcmp_3=__builtin_strcmp("smooth", att_str);
            tmp_statement_expression_2 = return_value___builtin_strcmp_3;
            if(tmp_statement_expression_2 == 0)
              cp->interpolation = 1;

            else
              fprintf(stderr, "warning: unrecognized interpolation type %s.\n", att_str);
          }
        }

        else
        {
          return_value_xmlStrcmp_96=xmlStrcmp(cur_att->name, (const unsigned char *)"palette_interpolation");
          if(return_value_xmlStrcmp_96 == 0)
          {
            unsigned long int parse_flame_element__1__3__1__3__1____s1_len;
            unsigned long int parse_flame_element__1__3__1__3__1____s2_len;
            signed int return_value___builtin_strcmp_9;
            return_value___builtin_strcmp_9=__builtin_strcmp("hsv", att_str);
            tmp_statement_expression_8 = return_value___builtin_strcmp_9;
            if(tmp_statement_expression_8 == 0)
              cp->palette_interpolation = 0;

            else
            {
              unsigned long int parse_flame_element__1__3__1__3__3____s1_len;
              unsigned long int parse_flame_element__1__3__1__3__3____s2_len;
              signed int return_value___builtin_strcmp_7;
              return_value___builtin_strcmp_7=__builtin_strcmp("sweep", att_str);
              tmp_statement_expression_6 = return_value___builtin_strcmp_7;
              if(tmp_statement_expression_6 == 0)
                cp->palette_interpolation = 1;

              else
                fprintf(stderr, "warning: unrecognized palette interpolation type %s.\n", att_str);
            }
          }

          else
          {
            return_value_xmlStrcmp_93=xmlStrcmp(cur_att->name, (const unsigned char *)"interpolation_space");
            if(return_value_xmlStrcmp_93 == 0)
              tmp_if_expr_95 = (_Bool)1;

            else
            {
              return_value_xmlStrcmp_94=xmlStrcmp(cur_att->name, (const unsigned char *)"interpolation_type");
              tmp_if_expr_95 = !(return_value_xmlStrcmp_94 != 0) ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_95)
            {
              unsigned long int parse_flame_element__1__3__1__4__1____s1_len;
              unsigned long int parse_flame_element__1__3__1__4__1____s2_len;
              signed int return_value___builtin_strcmp_17;
              return_value___builtin_strcmp_17=__builtin_strcmp("linear", att_str);
              tmp_statement_expression_16 = return_value___builtin_strcmp_17;
              if(tmp_statement_expression_16 == 0)
                cp->interpolation_type = 0;

              else
              {
                unsigned long int parse_flame_element__1__3__1__4__2____s1_len;
                unsigned long int parse_flame_element__1__3__1__4__2____s2_len;
                signed int return_value___builtin_strcmp_15;
                return_value___builtin_strcmp_15=__builtin_strcmp("log", att_str);
                tmp_statement_expression_14 = return_value___builtin_strcmp_15;
                if(tmp_statement_expression_14 == 0)
                  cp->interpolation_type = 1;

                else
                {
                  unsigned long int parse_flame_element__1__3__1__4__3____s1_len;
                  unsigned long int parse_flame_element__1__3__1__4__3____s2_len;
                  signed int return_value___builtin_strcmp_13;
                  return_value___builtin_strcmp_13=__builtin_strcmp("old", att_str);
                  tmp_statement_expression_12 = return_value___builtin_strcmp_13;
                  if(tmp_statement_expression_12 == 0)
                    cp->interpolation_type = 2;

                  else
                  {
                    unsigned long int parse_flame_element__1__3__1__4__4____s1_len;
                    unsigned long int parse_flame_element__1__3__1__4__4____s2_len;
                    signed int return_value___builtin_strcmp_11;
                    return_value___builtin_strcmp_11=__builtin_strcmp("older", att_str);
                    tmp_statement_expression_10 = return_value___builtin_strcmp_11;
                    if(tmp_statement_expression_10 == 0)
                      cp->interpolation_type = 3;

                    else
                      fprintf(stderr, "warning: unrecognized interpolation_type %s.\n", att_str);
                  }
                }
              }
            }

            else
            {
              return_value_xmlStrcmp_92=xmlStrcmp(cur_att->name, (const unsigned char *)"name");
              if(return_value_xmlStrcmp_92 == 0)
              {
                __builtin_strncpy(cp->flame_name, att_str, (unsigned long int)64);
                unsigned long int return_value_strlen_18;
                return_value_strlen_18=strlen(cp->flame_name);
                i = (signed int)return_value_strlen_18 - 1;
                do
                {
                  tmp_post_19 = i;
                  i = i - 1;
                  if(!(tmp_post_19 >= 1))
                    break;

                  const unsigned short int **return_value___ctype_b_loc_20;
                  return_value___ctype_b_loc_20=__ctype_b_loc();
                  if(!((8192 & (signed int)(*return_value___ctype_b_loc_20)[(signed long int)(signed int)cp->flame_name[(signed long int)i]]) == 0))
                    cp->flame_name[(signed long int)i] = (char)95;

                }
                while((_Bool)1);
              }

              else
              {
                return_value_xmlStrcmp_91=xmlStrcmp(cur_att->name, (const unsigned char *)"palette");
                if(return_value_xmlStrcmp_91 == 0)
                  cp->palette_index=flam3_atoi(att_str);

                else
                {
                  return_value_xmlStrcmp_90=xmlStrcmp(cur_att->name, (const unsigned char *)"size");
                  if(return_value_xmlStrcmp_90 == 0)
                  {
                    signed int return_value_sscanf_21;
                    return_value_sscanf_21=sscanf(att_str, "%d %d%1s", &cp->width, &cp->height, (const void *)tmps);
                    if(!(return_value_sscanf_21 == 2))
                    {
                      fprintf(stderr, "error: invalid size attribute '%s'\n", att_str);
                      xmlFree((void *)att_str);
                      return 1;
                    }

                  }

                  else
                  {
                    return_value_xmlStrcmp_89=xmlStrcmp(cur_att->name, (const unsigned char *)"center");
                    if(return_value_xmlStrcmp_89 == 0)
                    {
                      signed int return_value_sscanf_22;
                      return_value_sscanf_22=sscanf(att_str, "%lf %lf%1s", &cp->center[(signed long int)0], &cp->center[(signed long int)1], (const void *)tmps);
                      if(!(return_value_sscanf_22 == 2))
                      {
                        fprintf(stderr, "error: invalid center attribute '%s'\n", att_str);
                        xmlFree((void *)att_str);
                        return 1;
                      }

                      cp->rot_center[(signed long int)0] = cp->center[(signed long int)0];
                      cp->rot_center[(signed long int)1] = cp->center[(signed long int)1];
                    }

                    else
                    {
                      return_value_xmlStrcmp_88=xmlStrcmp(cur_att->name, (const unsigned char *)"scale");
                      if(return_value_xmlStrcmp_88 == 0)
                        cp->pixels_per_unit=flam3_atof(att_str);

                      else
                      {
                        return_value_xmlStrcmp_87=xmlStrcmp(cur_att->name, (const unsigned char *)"rotate");
                        if(return_value_xmlStrcmp_87 == 0)
                          cp->rotate=flam3_atof(att_str);

                        else
                        {
                          return_value_xmlStrcmp_86=xmlStrcmp(cur_att->name, (const unsigned char *)"zoom");
                          if(return_value_xmlStrcmp_86 == 0)
                            cp->zoom=flam3_atof(att_str);

                          else
                          {
                            return_value_xmlStrcmp_85=xmlStrcmp(cur_att->name, (const unsigned char *)"oversample");
                            if(return_value_xmlStrcmp_85 == 0)
                              cp->spatial_oversample=flam3_atoi(att_str);

                            else
                            {
                              return_value_xmlStrcmp_84=xmlStrcmp(cur_att->name, (const unsigned char *)"supersample");
                              if(return_value_xmlStrcmp_84 == 0)
                                cp->spatial_oversample=flam3_atoi(att_str);

                              else
                              {
                                return_value_xmlStrcmp_83=xmlStrcmp(cur_att->name, (const unsigned char *)"filter");
                                if(return_value_xmlStrcmp_83 == 0)
                                  cp->spatial_filter_radius=flam3_atof(att_str);

                                else
                                {
                                  return_value_xmlStrcmp_82=xmlStrcmp(cur_att->name, (const unsigned char *)"filter_shape");
                                  if(return_value_xmlStrcmp_82 == 0)
                                  {
                                    unsigned long int parse_flame_element__1__3__1__15__1____s1_len;
                                    unsigned long int parse_flame_element__1__3__1__15__1____s2_len;
                                    signed int return_value___builtin_strcmp_50;
                                    return_value___builtin_strcmp_50=__builtin_strcmp("gaussian", att_str);
                                    tmp_statement_expression_49 = return_value___builtin_strcmp_50;
                                    if(tmp_statement_expression_49 == 0)
                                      cp->spatial_filter_select = 0;

                                    else
                                    {
                                      unsigned long int parse_flame_element__1__3__1__15__2____s1_len;
                                      unsigned long int parse_flame_element__1__3__1__15__2____s2_len;
                                      signed int return_value___builtin_strcmp_48;
                                      return_value___builtin_strcmp_48=__builtin_strcmp("hermite", att_str);
                                      tmp_statement_expression_47 = return_value___builtin_strcmp_48;
                                      if(tmp_statement_expression_47 == 0)
                                        cp->spatial_filter_select = 1;

                                      else
                                      {
                                        unsigned long int parse_flame_element__1__3__1__15__3____s1_len;
                                        unsigned long int parse_flame_element__1__3__1__15__3____s2_len;
                                        signed int return_value___builtin_strcmp_46;
                                        return_value___builtin_strcmp_46=__builtin_strcmp("box", att_str);
                                        tmp_statement_expression_45 = return_value___builtin_strcmp_46;
                                        if(tmp_statement_expression_45 == 0)
                                          cp->spatial_filter_select = 2;

                                        else
                                        {
                                          unsigned long int parse_flame_element__1__3__1__15__4____s1_len;
                                          unsigned long int parse_flame_element__1__3__1__15__4____s2_len;
                                          signed int return_value___builtin_strcmp_44;
                                          return_value___builtin_strcmp_44=__builtin_strcmp("triangle", att_str);
                                          tmp_statement_expression_43 = return_value___builtin_strcmp_44;
                                          if(tmp_statement_expression_43 == 0)
                                            cp->spatial_filter_select = 3;

                                          else
                                          {
                                            unsigned long int parse_flame_element__1__3__1__15__5____s1_len;
                                            unsigned long int parse_flame_element__1__3__1__15__5____s2_len;
                                            signed int return_value___builtin_strcmp_42;
                                            return_value___builtin_strcmp_42=__builtin_strcmp("bell", att_str);
                                            tmp_statement_expression_41 = return_value___builtin_strcmp_42;
                                            if(tmp_statement_expression_41 == 0)
                                              cp->spatial_filter_select = 4;

                                            else
                                            {
                                              unsigned long int parse_flame_element__1__3__1__15__6____s1_len;
                                              unsigned long int parse_flame_element__1__3__1__15__6____s2_len;
                                              signed int return_value___builtin_strcmp_40;
                                              return_value___builtin_strcmp_40=__builtin_strcmp("bspline", att_str);
                                              tmp_statement_expression_39 = return_value___builtin_strcmp_40;
                                              if(tmp_statement_expression_39 == 0)
                                                cp->spatial_filter_select = 5;

                                              else
                                              {
                                                unsigned long int parse_flame_element__1__3__1__15__7____s1_len;
                                                unsigned long int parse_flame_element__1__3__1__15__7____s2_len;
                                                signed int return_value___builtin_strcmp_38;
                                                return_value___builtin_strcmp_38=__builtin_strcmp("mitchell", att_str);
                                                tmp_statement_expression_37 = return_value___builtin_strcmp_38;
                                                if(tmp_statement_expression_37 == 0)
                                                  cp->spatial_filter_select = 8;

                                                else
                                                {
                                                  unsigned long int parse_flame_element__1__3__1__15__8____s1_len;
                                                  unsigned long int parse_flame_element__1__3__1__15__8____s2_len;
                                                  signed int return_value___builtin_strcmp_36;
                                                  return_value___builtin_strcmp_36=__builtin_strcmp("blackman", att_str);
                                                  tmp_statement_expression_35 = return_value___builtin_strcmp_36;
                                                  if(tmp_statement_expression_35 == 0)
                                                    cp->spatial_filter_select = 9;

                                                  else
                                                  {
                                                    unsigned long int parse_flame_element__1__3__1__15__9____s1_len;
                                                    unsigned long int parse_flame_element__1__3__1__15__9____s2_len;
                                                    signed int return_value___builtin_strcmp_34;
                                                    return_value___builtin_strcmp_34=__builtin_strcmp("catrom", att_str);
                                                    tmp_statement_expression_33 = return_value___builtin_strcmp_34;
                                                    if(tmp_statement_expression_33 == 0)
                                                      cp->spatial_filter_select = 10;

                                                    else
                                                    {
                                                      unsigned long int parse_flame_element__1__3__1__15__10____s1_len;
                                                      unsigned long int parse_flame_element__1__3__1__15__10____s2_len;
                                                      signed int return_value___builtin_strcmp_32;
                                                      return_value___builtin_strcmp_32=__builtin_strcmp("hanning", att_str);
                                                      tmp_statement_expression_31 = return_value___builtin_strcmp_32;
                                                      if(tmp_statement_expression_31 == 0)
                                                        cp->spatial_filter_select = 12;

                                                      else
                                                      {
                                                        unsigned long int parse_flame_element__1__3__1__15__11____s1_len;
                                                        unsigned long int parse_flame_element__1__3__1__15__11____s2_len;
                                                        signed int return_value___builtin_strcmp_30;
                                                        return_value___builtin_strcmp_30=__builtin_strcmp("hamming", att_str);
                                                        tmp_statement_expression_29 = return_value___builtin_strcmp_30;
                                                        if(tmp_statement_expression_29 == 0)
                                                          cp->spatial_filter_select = 11;

                                                        else
                                                        {
                                                          unsigned long int parse_flame_element__1__3__1__15__12____s1_len;
                                                          unsigned long int parse_flame_element__1__3__1__15__12____s2_len;
                                                          signed int return_value___builtin_strcmp_28;
                                                          return_value___builtin_strcmp_28=__builtin_strcmp("lanczos3", att_str);
                                                          tmp_statement_expression_27 = return_value___builtin_strcmp_28;
                                                          if(tmp_statement_expression_27 == 0)
                                                            cp->spatial_filter_select = 6;

                                                          else
                                                          {
                                                            unsigned long int parse_flame_element__1__3__1__15__13____s1_len;
                                                            unsigned long int parse_flame_element__1__3__1__15__13____s2_len;
                                                            signed int return_value___builtin_strcmp_26;
                                                            return_value___builtin_strcmp_26=__builtin_strcmp("lanczos2", att_str);
                                                            tmp_statement_expression_25 = return_value___builtin_strcmp_26;
                                                            if(tmp_statement_expression_25 == 0)
                                                              cp->spatial_filter_select = 7;

                                                            else
                                                            {
                                                              unsigned long int parse_flame_element__1__3__1__15__14____s1_len;
                                                              unsigned long int parse_flame_element__1__3__1__15__14____s2_len;
                                                              signed int return_value___builtin_strcmp_24;
                                                              return_value___builtin_strcmp_24=__builtin_strcmp("quadratic", att_str);
                                                              tmp_statement_expression_23 = return_value___builtin_strcmp_24;
                                                              if(tmp_statement_expression_23 == 0)
                                                                cp->spatial_filter_select = 13;

                                                              else
                                                                fprintf(stderr, "warning: unrecognized kernel shape %s.  Using gaussian.\n", att_str);
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }

                                  else
                                  {
                                    return_value_xmlStrcmp_81=xmlStrcmp(cur_att->name, (const unsigned char *)"temporal_filter_type");
                                    if(return_value_xmlStrcmp_81 == 0)
                                    {
                                      unsigned long int parse_flame_element__1__3__1__16__1____s1_len;
                                      unsigned long int parse_flame_element__1__3__1__16__1____s2_len;
                                      signed int return_value___builtin_strcmp_56;
                                      return_value___builtin_strcmp_56=__builtin_strcmp("box", att_str);
                                      tmp_statement_expression_55 = return_value___builtin_strcmp_56;
                                      if(tmp_statement_expression_55 == 0)
                                        cp->temporal_filter_type = 0;

                                      else
                                      {
                                        unsigned long int parse_flame_element__1__3__1__16__2____s1_len;
                                        unsigned long int parse_flame_element__1__3__1__16__2____s2_len;
                                        signed int return_value___builtin_strcmp_54;
                                        return_value___builtin_strcmp_54=__builtin_strcmp("gaussian", att_str);
                                        tmp_statement_expression_53 = return_value___builtin_strcmp_54;
                                        if(tmp_statement_expression_53 == 0)
                                          cp->temporal_filter_type = 1;

                                        else
                                        {
                                          unsigned long int parse_flame_element__1__3__1__16__3____s1_len;
                                          unsigned long int parse_flame_element__1__3__1__16__3____s2_len;
                                          signed int return_value___builtin_strcmp_52;
                                          return_value___builtin_strcmp_52=__builtin_strcmp("exp", att_str);
                                          tmp_statement_expression_51 = return_value___builtin_strcmp_52;
                                          if(tmp_statement_expression_51 == 0)
                                            cp->temporal_filter_type = 2;

                                          else
                                            fprintf(stderr, "warning: unrecognized temporal filter %s.  Using box.\n", att_str);
                                        }
                                      }
                                    }

                                    else
                                    {
                                      return_value_xmlStrcmp_80=xmlStrcmp(cur_att->name, (const unsigned char *)"temporal_filter_width");
                                      if(return_value_xmlStrcmp_80 == 0)
                                        cp->temporal_filter_width=flam3_atof(att_str);

                                      else
                                      {
                                        return_value_xmlStrcmp_79=xmlStrcmp(cur_att->name, (const unsigned char *)"temporal_filter_exp");
                                        if(return_value_xmlStrcmp_79 == 0)
                                          cp->temporal_filter_exp=flam3_atof(att_str);

                                        else
                                        {
                                          return_value_xmlStrcmp_78=xmlStrcmp(cur_att->name, (const unsigned char *)"palette_mode");
                                          if(return_value_xmlStrcmp_78 == 0)
                                          {
                                            unsigned long int parse_flame_element__1__3__1__19__1____s1_len;
                                            unsigned long int parse_flame_element__1__3__1__19__1____s2_len;
                                            signed int return_value___builtin_strcmp_60;
                                            return_value___builtin_strcmp_60=__builtin_strcmp("step", att_str);
                                            tmp_statement_expression_59 = return_value___builtin_strcmp_60;
                                            if(tmp_statement_expression_59 == 0)
                                              cp->palette_mode = 0;

                                            else
                                            {
                                              unsigned long int parse_flame_element__1__3__1__19__2____s1_len;
                                              unsigned long int parse_flame_element__1__3__1__19__2____s2_len;
                                              signed int return_value___builtin_strcmp_58;
                                              return_value___builtin_strcmp_58=__builtin_strcmp("linear", att_str);
                                              tmp_statement_expression_57 = return_value___builtin_strcmp_58;
                                              if(tmp_statement_expression_57 == 0)
                                                cp->palette_mode = 1;

                                              else
                                                fprintf(stderr, "warning: unrecognized palette mode %s.  Using step.\n", att_str);
                                            }
                                          }

                                          else
                                          {
                                            return_value_xmlStrcmp_77=xmlStrcmp(cur_att->name, (const unsigned char *)"quality");
                                            if(return_value_xmlStrcmp_77 == 0)
                                              cp->sample_density=flam3_atof(att_str);

                                            else
                                            {
                                              return_value_xmlStrcmp_76=xmlStrcmp(cur_att->name, (const unsigned char *)"passes");
                                              if(return_value_xmlStrcmp_76 == 0)
                                                cp->nbatches=flam3_atoi(att_str);

                                              else
                                              {
                                                return_value_xmlStrcmp_75=xmlStrcmp(cur_att->name, (const unsigned char *)"temporal_samples");
                                                if(return_value_xmlStrcmp_75 == 0)
                                                  cp->ntemporal_samples=flam3_atoi(att_str);

                                                else
                                                {
                                                  return_value_xmlStrcmp_74=xmlStrcmp(cur_att->name, (const unsigned char *)"background");
                                                  if(return_value_xmlStrcmp_74 == 0)
                                                  {
                                                    signed int return_value_sscanf_61;
                                                    return_value_sscanf_61=sscanf(att_str, "%lf %lf %lf%1s", &cp->background[(signed long int)0], &cp->background[(signed long int)1], &cp->background[(signed long int)2], (const void *)tmps);
                                                    if(!(return_value_sscanf_61 == 3))
                                                    {
                                                      fprintf(stderr, "error: invalid background attribute '%s'\n", att_str);
                                                      xmlFree((void *)att_str);
                                                      return 1;
                                                    }

                                                  }

                                                  else
                                                  {
                                                    return_value_xmlStrcmp_73=xmlStrcmp(cur_att->name, (const unsigned char *)"brightness");
                                                    if(return_value_xmlStrcmp_73 == 0)
                                                      cp->brightness=flam3_atof(att_str);

                                                    else
                                                    {
                                                      return_value_xmlStrcmp_72=xmlStrcmp(cur_att->name, (const unsigned char *)"gamma");
                                                      if(return_value_xmlStrcmp_72 == 0)
                                                        cp->gamma=flam3_atof(att_str);

                                                      else
                                                      {
                                                        return_value_xmlStrcmp_71=xmlStrcmp(cur_att->name, (const unsigned char *)"highlight_power");
                                                        if(return_value_xmlStrcmp_71 == 0)
                                                          cp->highlight_power=atof_link1(att_str);

                                                        else
                                                        {
                                                          return_value_xmlStrcmp_70=xmlStrcmp(cur_att->name, (const unsigned char *)"vibrancy");
                                                          if(return_value_xmlStrcmp_70 == 0)
                                                            cp->vibrancy=flam3_atof(att_str);

                                                          else
                                                          {
                                                            return_value_xmlStrcmp_69=xmlStrcmp(cur_att->name, (const unsigned char *)"hue");
                                                            if(return_value_xmlStrcmp_69 == 0)
                                                            {
                                                              double return_value_flam3_atof_62;
                                                              return_value_flam3_atof_62=flam3_atof(att_str);
                                                              cp->hue_rotation=fmod(return_value_flam3_atof_62, 1.0);
                                                            }

                                                            else
                                                            {
                                                              return_value_xmlStrcmp_68=xmlStrcmp(cur_att->name, (const unsigned char *)"estimator_radius");
                                                              if(return_value_xmlStrcmp_68 == 0)
                                                                cp->estimator=flam3_atof(att_str);

                                                              else
                                                              {
                                                                return_value_xmlStrcmp_67=xmlStrcmp(cur_att->name, (const unsigned char *)"estimator_minimum");
                                                                if(return_value_xmlStrcmp_67 == 0)
                                                                  cp->estimator_minimum=flam3_atof(att_str);

                                                                else
                                                                {
                                                                  return_value_xmlStrcmp_66=xmlStrcmp(cur_att->name, (const unsigned char *)"estimator_curve");
                                                                  if(return_value_xmlStrcmp_66 == 0)
                                                                    cp->estimator_curve=flam3_atof(att_str);

                                                                  else
                                                                  {
                                                                    return_value_xmlStrcmp_65=xmlStrcmp(cur_att->name, (const unsigned char *)"gamma_threshold");
                                                                    if(return_value_xmlStrcmp_65 == 0)
                                                                      cp->gam_lin_thresh=flam3_atof(att_str);

                                                                    else
                                                                    {
                                                                      return_value_xmlStrcmp_64=xmlStrcmp(cur_att->name, (const unsigned char *)"soloxform");
                                                                      if(return_value_xmlStrcmp_64 == 0)
                                                                      {
                                                                        double return_value_flam3_atof_63;
                                                                        return_value_flam3_atof_63=flam3_atof(att_str);
                                                                        solo_xform = (signed int)return_value_flam3_atof_63;
                                                                      }

                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      xmlFree((void *)att_str);
      cur_att = cur_att->next;
    }

    chld_node = flame_node->children;
    for( ; !(chld_node == ((struct _xmlNode *)NULL)); chld_node = chld_node->next)
    {
      signed int return_value_xmlStrcmp_139;
      return_value_xmlStrcmp_139=xmlStrcmp(chld_node->name, (const unsigned char *)"color");
      if(return_value_xmlStrcmp_139 == 0)
      {
        signed int index = -1;
        double r = 0.0;
        double g = 0.0;
        double b = 0.0;
        double a = 0.0;
        att_ptr = chld_node->properties;
        if(att_ptr == ((struct _xmlAttr *)NULL))
        {
          fprintf(stderr, "Error:  No attributes for color element.\n");
          return 1;
        }

        cur_att = att_ptr;
        if(!(cur_att == ((struct _xmlAttr *)NULL)))
        {
          unsigned char *return_value_xmlGetProp_99;
          return_value_xmlGetProp_99=xmlGetProp(chld_node, cur_att->name);
          att_str = (char *)return_value_xmlGetProp_99;
          a = 255.0;
          signed int return_value_xmlStrcmp_106;
          return_value_xmlStrcmp_106=xmlStrcmp(cur_att->name, (const unsigned char *)"index");
          if(return_value_xmlStrcmp_106 == 0)
            index=flam3_atoi(att_str);

          else
          {
            return_value_xmlStrcmp_105=xmlStrcmp(cur_att->name, (const unsigned char *)"rgb");
            if(return_value_xmlStrcmp_105 == 0)
            {
              signed int return_value_sscanf_100;
              return_value_sscanf_100=sscanf(att_str, "%lf %lf %lf%1s", &r, &g, &b, (const void *)tmps);
              if(!(return_value_sscanf_100 == 3))
              {
                fprintf(stderr, "error: invalid rgb attribute '%s'\n", att_str);
                xmlFree((void *)att_str);
                return 1;
              }

            }

            else
            {
              return_value_xmlStrcmp_104=xmlStrcmp(cur_att->name, (const unsigned char *)"rgba");
              if(return_value_xmlStrcmp_104 == 0)
              {
                signed int return_value_sscanf_101;
                return_value_sscanf_101=sscanf(att_str, "%lf %lf %lf %lf%1s", &r, &g, &b, &a, (const void *)tmps);
                if(!(return_value_sscanf_101 == 4))
                {
                  fprintf(stderr, "error: invalid rgba attribute '%s'\n", att_str);
                  xmlFree((void *)att_str);
                  return 1;
                }

              }

              else
              {
                return_value_xmlStrcmp_103=xmlStrcmp(cur_att->name, (const unsigned char *)"a");
                if(return_value_xmlStrcmp_103 == 0)
                {
                  signed int return_value_sscanf_102;
                  return_value_sscanf_102=sscanf(att_str, "%lf%1s", &a, (const void *)tmps);
                  if(!(return_value_sscanf_102 == 1))
                  {
                    fprintf(stderr, "error: invalid a attribute '%s'\n", att_str);
                    xmlFree((void *)att_str);
                    return 1;
                  }

                }

                else
                {
                  fprintf(stderr, "Error:  Unknown color attribute '%s'\n", cur_att->name);
                  xmlFree((void *)att_str);
                  return 1;
                }
              }
            }
          }
          xmlFree((void *)att_str);
          cur_att = cur_att->next;
        }

        if(index >= 0 && !(index >= 256))
        {
          cp->palette[(signed long int)index].color[(signed long int)3] = a / 255.0;
          cp->palette[(signed long int)index].color[(signed long int)0] = (cp->palette[(signed long int)index].color[(signed long int)3] * r) / 255.0;
          cp->palette[(signed long int)index].color[(signed long int)1] = (cp->palette[(signed long int)index].color[(signed long int)3] * g) / 255.0;
          cp->palette[(signed long int)index].color[(signed long int)2] = (cp->palette[(signed long int)index].color[(signed long int)3] * b) / 255.0;
          cp->palette[(signed long int)index].index = (double)index;
        }

        else
        {
          fprintf(stderr, "Error:  Color element with bad/missing index attribute (%d)\n", index);
          return 1;
        }
      }

      else
      {
        return_value_xmlStrcmp_138=xmlStrcmp(chld_node->name, (const unsigned char *)"colors");
        if(return_value_xmlStrcmp_138 == 0)
        {
          signed int count;
          att_ptr = chld_node->properties;
          if(att_ptr == ((struct _xmlAttr *)NULL))
          {
            fprintf(stderr, "Error: No attributes for colors element.\n");
            return 1;
          }

          cur_att = att_ptr;
          if(!(cur_att == ((struct _xmlAttr *)NULL)))
          {
            unsigned char *return_value_xmlGetProp_107;
            return_value_xmlGetProp_107=xmlGetProp(chld_node, cur_att->name);
            att_str = (char *)return_value_xmlGetProp_107;
            signed int return_value_xmlStrcmp_110;
            return_value_xmlStrcmp_110=xmlStrcmp(cur_att->name, (const unsigned char *)"count");
            if(return_value_xmlStrcmp_110 == 0)
              count=flam3_atoi(att_str);

            else
            {
              return_value_xmlStrcmp_109=xmlStrcmp(cur_att->name, (const unsigned char *)"data");
              if(return_value_xmlStrcmp_109 == 0)
              {
                signed int return_value_flam3_parse_hexformat_colors_108;
                return_value_flam3_parse_hexformat_colors_108=flam3_parse_hexformat_colors(att_str, cp, count, -4);
                if(return_value_flam3_parse_hexformat_colors_108 >= 1)
                {
                  fprintf(stderr, "error parsing hexformatted colors\n");
                  xmlFree((void *)att_str);
                  return 1;
                }

              }

              else
              {
                fprintf(stderr, "Error:  Unknown color attribute '%s'\n", cur_att->name);
                xmlFree((void *)att_str);
                return 1;
              }
            }
            xmlFree((void *)att_str);
            cur_att = cur_att->next;
          }

        }

        else
        {
          return_value_xmlStrcmp_137=xmlStrcmp(chld_node->name, (const unsigned char *)"palette");
          if(return_value_xmlStrcmp_137 == 0)
          {
            signed int numcolors = 0;
            signed int numbytes = 0;
            signed int old_format = 0;
            signed int new_format = 0;
            signed int index0;
            signed int index1;
            double hue0;
            double hue1;
            double blend = 0.5;
            index1 = -1;
            index0 = index1;
            hue1 = 0.0;
            hue0 = hue1;
            att_ptr = chld_node->properties;
            if(att_ptr == ((struct _xmlAttr *)NULL))
            {
              fprintf(stderr, "Error:  No attributes for palette element.\n");
              return 1;
            }

            cur_att = att_ptr;
            if(!(cur_att == ((struct _xmlAttr *)NULL)))
            {
              unsigned char *return_value_xmlGetProp_111;
              return_value_xmlGetProp_111=xmlGetProp(chld_node, cur_att->name);
              att_str = (char *)return_value_xmlGetProp_111;
              signed int return_value_xmlStrcmp_122;
              return_value_xmlStrcmp_122=xmlStrcmp(cur_att->name, (const unsigned char *)"index0");
              if(return_value_xmlStrcmp_122 == 0)
              {
                old_format = old_format + 1;
                index0=flam3_atoi(att_str);
              }

              else
              {
                return_value_xmlStrcmp_121=xmlStrcmp(cur_att->name, (const unsigned char *)"index1");
                if(return_value_xmlStrcmp_121 == 0)
                {
                  old_format = old_format + 1;
                  index1=flam3_atoi(att_str);
                }

                else
                {
                  return_value_xmlStrcmp_120=xmlStrcmp(cur_att->name, (const unsigned char *)"hue0");
                  if(return_value_xmlStrcmp_120 == 0)
                  {
                    old_format = old_format + 1;
                    hue0=flam3_atof(att_str);
                  }

                  else
                  {
                    return_value_xmlStrcmp_119=xmlStrcmp(cur_att->name, (const unsigned char *)"hue1");
                    if(return_value_xmlStrcmp_119 == 0)
                    {
                      old_format = old_format + 1;
                      hue1=flam3_atof(att_str);
                    }

                    else
                    {
                      return_value_xmlStrcmp_118=xmlStrcmp(cur_att->name, (const unsigned char *)"blend");
                      if(return_value_xmlStrcmp_118 == 0)
                      {
                        old_format = old_format + 1;
                        blend=flam3_atof(att_str);
                      }

                      else
                      {
                        return_value_xmlStrcmp_117=xmlStrcmp(cur_att->name, (const unsigned char *)"count");
                        if(return_value_xmlStrcmp_117 == 0)
                        {
                          new_format = new_format + 1;
                          numcolors=flam3_atoi(att_str);
                        }

                        else
                        {
                          return_value_xmlStrcmp_116=xmlStrcmp(cur_att->name, (const unsigned char *)"format");
                          if(return_value_xmlStrcmp_116 == 0)
                          {
                            new_format = new_format + 1;
                            unsigned long int parse_flame_element__1__4__1__3__2__1__7__1____s1_len;
                            unsigned long int parse_flame_element__1__4__1__3__2__1__7__1____s2_len;
                            signed int return_value___builtin_strcmp_115;
                            return_value___builtin_strcmp_115=__builtin_strcmp(att_str, "RGB");
                            tmp_statement_expression_114 = return_value___builtin_strcmp_115;
                            if(tmp_statement_expression_114 == 0)
                              numbytes = 3;

                            else
                            {
                              unsigned long int __s1_len;
                              unsigned long int __s2_len;
                              signed int return_value___builtin_strcmp_113;
                              return_value___builtin_strcmp_113=__builtin_strcmp(att_str, "RGBA");
                              tmp_statement_expression_112 = return_value___builtin_strcmp_113;
                              if(tmp_statement_expression_112 == 0)
                                numbytes = 4;

                              else
                              {
                                fprintf(stderr, "Error: Unrecognized palette format string (%s)\n", att_str);
                                xmlFree((void *)att_str);
                                return 1;
                              }
                            }
                          }

                          else
                          {
                            fprintf(stderr, "Error:  Unknown palette attribute '%s'\n", cur_att->name);
                            xmlFree((void *)att_str);
                            return 1;
                          }
                        }
                      }
                    }
                  }
                }
              }
              xmlFree((void *)att_str);
              cur_att = cur_att->next;
            }

            if(new_format >= 1 && old_format >= 1)
            {
              fprintf(stderr, "Error: mixing of old and new palette tag syntax not allowed.\n");
              return 1;
            }

            if(old_format >= 1)
              interpolate_cmap(cp->palette, blend, index0, hue0, index1, hue1);

            else
            {
              char *pal_str;
              unsigned char *return_value_xmlNodeGetContent_123;
              return_value_xmlNodeGetContent_123=xmlNodeGetContent(chld_node);
              pal_str = (char *)return_value_xmlNodeGetContent_123;
              signed int return_value_flam3_parse_hexformat_colors_124;
              return_value_flam3_parse_hexformat_colors_124=flam3_parse_hexformat_colors(pal_str, cp, numcolors, numbytes);
              if(return_value_flam3_parse_hexformat_colors_124 >= 1)
              {
                fprintf(stderr, "error reading hexformatted colors\n");
                xmlFree((void *)pal_str);
                return 1;
              }

              xmlFree((void *)pal_str);
            }
          }

          else
          {
            return_value_xmlStrcmp_136=xmlStrcmp(chld_node->name, (const unsigned char *)"symmetry");
            if(return_value_xmlStrcmp_136 == 0)
            {
              signed int kind = 0;
              signed int bef;
              signed int aft;
              att_ptr = chld_node->properties;
              if(att_ptr == ((struct _xmlAttr *)NULL))
              {
                fprintf(stderr, "Error:  No attributes for symmetry element.\n");
                return 1;
              }

              cur_att = att_ptr;
              if(!(cur_att == ((struct _xmlAttr *)NULL)))
              {
                unsigned char *return_value_xmlGetProp_125;
                return_value_xmlGetProp_125=xmlGetProp(chld_node, cur_att->name);
                att_str = (char *)return_value_xmlGetProp_125;
                signed int return_value_xmlStrcmp_126;
                return_value_xmlStrcmp_126=xmlStrcmp(cur_att->name, (const unsigned char *)"kind");
                if(return_value_xmlStrcmp_126 == 0)
                  kind=flam3_atoi(att_str);

                else
                {
                  fprintf(stderr, "Error:  Unknown symmetry attribute '%s'\n", cur_att->name);
                  xmlFree((void *)att_str);
                  return 1;
                }
                xmlFree((void *)att_str);
                cur_att = cur_att->next;
              }

              bef = cp->num_xforms;
              flam3_add_symmetry(cp, kind);
              aft = cp->num_xforms;
              num_std_xforms = num_std_xforms + (aft - bef);
            }

            else
            {
              return_value_xmlStrcmp_133=xmlStrcmp(chld_node->name, (const unsigned char *)"xform");
              if(return_value_xmlStrcmp_133 == 0)
                tmp_if_expr_135 = (_Bool)1;

              else
              {
                return_value_xmlStrcmp_134=xmlStrcmp(chld_node->name, (const unsigned char *)"finalxform");
                tmp_if_expr_135 = !(return_value_xmlStrcmp_134 != 0) ? (_Bool)1 : (_Bool)0;
              }
              if(tmp_if_expr_135)
              {
                signed int xf = cp->num_xforms;
                signed int return_value_xmlStrcmp_127;
                return_value_xmlStrcmp_127=xmlStrcmp(chld_node->name, (const unsigned char *)"finalxform");
                if(return_value_xmlStrcmp_127 == 0)
                {
                  if(cp->final_xform_index >= 0)
                  {
                    fprintf(stderr, "Error:  Cannot specify more than one final xform.\n");
                    return 1;
                  }

                  flam3_add_xforms(cp, 1, 0, 1);
                  (cp->xform + (signed long int)xf)->var[(signed long int)0] = 0.0;
                  cp->final_xform_index = xf;
                  cp->final_xform_enable = 1;
                }

                else
                {
                  flam3_add_xforms(cp, 1, 0, 0);
                  if(cp->final_xform_index >= 0)
                    xf = xf - 1;

                  (cp->xform + (signed long int)xf)->var[(signed long int)0] = 0.0;
                  num_std_xforms = num_std_xforms + 1;
                }
                signed int return_value_parse_xform_xml_128;
                return_value_parse_xform_xml_128=parse_xform_xml(chld_node, &cp->xform[(signed long int)xf], &num_xaos, &xaos, num_std_xforms, 0);
                if(!(return_value_parse_xform_xml_128 == 0))
                  return 1;

                if(cp->final_xform_index == xf)
                {
                  if(IEEE_FLOAT_NOTEQUAL((cp->xform + (signed long int)xf)->density, 0.0))
                  {
                    fprintf(stderr, "Error: Final xforms should not have weight specified.\n");
                    return 1;
                  }

                }

                if(!((cp->xform + (signed long int)xf)->motion_freq == 0))
                  tmp_if_expr_129 = (_Bool)1;

                else
                  tmp_if_expr_129 = (cp->xform + (signed long int)xf)->motion_func != 0 ? (_Bool)1 : (_Bool)0;
                if(tmp_if_expr_129)
                {
                  fprintf(stderr, "Error: Motion parameters should not be specified in xforms.\n");
                  return 1;
                }

                motion_node = chld_node->children;
                for( ; !(motion_node == ((struct _xmlNode *)NULL)); motion_node = motion_node->next)
                {
                  signed int return_value_xmlStrcmp_131;
                  return_value_xmlStrcmp_131=xmlStrcmp(motion_node->name, (const unsigned char *)"motion");
                  if(return_value_xmlStrcmp_131 == 0)
                  {
                    signed int nm = (cp->xform + (signed long int)xf)->num_motion;
                    flam3_add_motion_element(&cp->xform[(signed long int)xf]);
                    signed int return_value_parse_xform_xml_130;
                    return_value_parse_xform_xml_130=parse_xform_xml(motion_node, &(cp->xform + (signed long int)xf)->motion[(signed long int)nm], (signed int *)(void *)0, (struct anonymous_7 **)(void *)0, 0, 1);
                    if(!(return_value_parse_xform_xml_130 == 0))
                      return 1;

                  }

                }
              }

              else
              {
                return_value_xmlStrcmp_132=xmlStrcmp(chld_node->name, (const unsigned char *)"edit");
                if(return_value_xmlStrcmp_132 == 0)
                {
                  cp->edits=xmlNewDoc((const unsigned char *)"1.0");
                  edit_node=xmlCopyNode(chld_node, 1);
                  xmlDocSetRootElement(cp->edits, edit_node);
                }

              }
            }
          }
        }
      }
    }
    num_std_xforms = num_std_xforms + 1;
    i = 0;
    for( ; !(i >= num_std_xforms); i = i + 1)
      if(solo_xform >= 0 && !(i == solo_xform))
        (cp->xform + (signed long int)i)->opacity = 0.0;

    i = 0;
    for( ; !(i >= num_xaos); i = i + 1)
      cp->chaos[(signed long int)(xaos + (signed long int)i)->from][(signed long int)(xaos + (signed long int)i)->to] = (xaos + (signed long int)i)->scalar;
    free((void *)xaos);
    if(cp->final_xform_index >= 0)
    {
      if(!(cp->final_xform_index == cp->num_xforms + -1))
      {
        tmpcpy = cp->xform[(signed long int)cp->final_xform_index];
        i = cp->final_xform_index + 1;
        for( ; !(i >= cp->num_xforms); i = i + 1)
          cp->xform[(signed long int)(i - 1)] = cp->xform[(signed long int)i];
        cp->xform[(signed long int)(cp->num_xforms - 1)] = tmpcpy;
        cp->final_xform_index = cp->num_xforms - 1;
      }

    }

    if(!(flam3_conversion_failed == 0))
    {
      fprintf(stderr, "error: parsing a double or int attribute's value.\n");
      return 1;
    }

    else
      return 0;
  }
}

// parse_palettes
// file palettes.c line 25
static void parse_palettes(struct _xmlNode *node)
{
  struct _xmlAttr *attr;
  char *val;
  struct anonymous_18 *pal;
  signed int hex_error;
  _Bool tmp_if_expr_8;
  signed int return_value_xmlStrcmp_7;
  const unsigned short int **return_value___ctype_b_loc_2;
  signed int return_value_xmlStrcmp_4;
  signed int return_value_xmlStrcmp_3;
  while(!(node == ((struct _xmlNode *)NULL)))
  {
    if((signed int)node->type == XML_ELEMENT_NODE)
    {
      return_value_xmlStrcmp_7=xmlStrcmp(node->name, (const unsigned char *)"palette");
      tmp_if_expr_8 = !(return_value_xmlStrcmp_7 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_8 = (_Bool)0;
    if(tmp_if_expr_8)
    {
      attr = node->properties;
      pal = &the_palettes[(signed long int)npalettes];
      memset((void *)pal, 0, sizeof(struct anonymous_18) /*836ul*/ );
      if(!(attr == ((struct _xmlAttr *)NULL)))
      {
        unsigned char *return_value_xmlGetProp_1;
        return_value_xmlGetProp_1=xmlGetProp(node, attr->name);
        val = (char *)return_value_xmlGetProp_1;
        signed int return_value_xmlStrcmp_5;
        return_value_xmlStrcmp_5=xmlStrcmp(attr->name, (const unsigned char *)"data");
        if(return_value_xmlStrcmp_5 == 0)
        {
          signed int count = 256;
          signed int c_idx = 0;
          signed int r;
          signed int g;
          signed int b;
          signed int col_count = 0;
          signed int sscanf_ret;
          c_idx = 0;
          col_count = 0;
          hex_error = 0;
          do
          {
            sscanf_ret=sscanf((char *)&val[(signed long int)c_idx], "00%2x%2x%2x", &r, &g, &b);
            if(!(sscanf_ret == 3))
            {
              fprintf(stderr, "error:  problem reading hexadecimal color data '%8s'\n", &val[(signed long int)c_idx]);
              hex_error = 1;
              break;
            }

            c_idx = c_idx + 8;
            do
            {
              return_value___ctype_b_loc_2=__ctype_b_loc();
              if((8192 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)val[(signed long int)c_idx]]) == 0)
                break;

              c_idx = c_idx + 1;
            }
            while((_Bool)1);
            pal->colors[(signed long int)col_count][(signed long int)0] = (unsigned char)r;
            pal->colors[(signed long int)col_count][(signed long int)1] = (unsigned char)g;
            pal->colors[(signed long int)col_count][(signed long int)2] = (unsigned char)b;
            col_count = col_count + 1;
          }
          while(!(col_count >= count));
        }

        else
        {
          return_value_xmlStrcmp_4=xmlStrcmp(attr->name, (const unsigned char *)"number");
          if(return_value_xmlStrcmp_4 == 0)
            pal->number=atoi_link3(val);

          else
          {
            return_value_xmlStrcmp_3=xmlStrcmp(attr->name, (const unsigned char *)"name");
            if(return_value_xmlStrcmp_3 == 0)
            {
              __builtin_strncpy(pal->name, val, (unsigned long int)64);
              pal->name[(signed long int)(64 - 1)] = (char)0;
            }

          }
        }
        xmlFree((void *)val);
        attr = attr->next;
      }

      if(hex_error == 0)
      {
        npalettes = npalettes + 1;
        void *return_value_realloc_6;
        return_value_realloc_6=realloc((void *)the_palettes, (unsigned long int)(1 + npalettes) * sizeof(struct anonymous_18) /*836ul*/ );
        the_palettes = (struct anonymous_18 *)return_value_realloc_6;
      }

    }

    else
      parse_palettes(node->children);
    node = node->next;
  }
}

// parse_xform_xml
// file parser.c line 823
signed int parse_xform_xml(struct _xmlNode *chld_node, struct xform *this_xform, signed int *num_xaos, struct anonymous_7 **xaos, signed int numstd, signed int motionxf)
{
  struct _xmlAttr *att_ptr;
  struct _xmlAttr *cur_att;
  char *att_str;
  char *cpy;
  char tmps[2l];
  signed int j;
  signed int k;
  att_ptr = chld_node->properties;
  signed int return_value_xmlStrcmp_142;
  signed int return_value_xmlStrcmp_141;
  signed int return_value_xmlStrcmp_140;
  signed int return_value_xmlStrcmp_139;
  signed int return_value_xmlStrcmp_138;
  signed int tmp_statement_expression_8;
  signed int tmp_statement_expression_6;
  signed int tmp_statement_expression_4;
  signed int return_value_xmlStrcmp_137;
  signed int return_value_xmlStrcmp_136;
  signed int return_value_xmlStrcmp_135;
  signed int return_value_xmlStrcmp_134;
  signed int return_value_xmlStrcmp_133;
  signed int tmp_statement_expression_16;
  signed int return_value_xmlStrcmp_132;
  signed int return_value_xmlStrcmp_131;
  signed int return_value_xmlStrcmp_130;
  signed int return_value_xmlStrcmp_129;
  signed int return_value_xmlStrcmp_128;
  signed int return_value_xmlStrcmp_127;
  signed int return_value_xmlStrcmp_126;
  signed int return_value_xmlStrcmp_125;
  signed int return_value_xmlStrcmp_124;
  signed int return_value_xmlStrcmp_123;
  signed int return_value_xmlStrcmp_122;
  signed int return_value_xmlStrcmp_121;
  signed int return_value_xmlStrcmp_120;
  signed int return_value_xmlStrcmp_119;
  signed int return_value_xmlStrcmp_118;
  signed int return_value_xmlStrcmp_117;
  signed int return_value_xmlStrcmp_116;
  signed int return_value_xmlStrcmp_115;
  signed int return_value_xmlStrcmp_114;
  signed int return_value_xmlStrcmp_113;
  signed int return_value_xmlStrcmp_112;
  signed int return_value_xmlStrcmp_111;
  signed int return_value_xmlStrcmp_110;
  signed int return_value_xmlStrcmp_109;
  signed int return_value_xmlStrcmp_108;
  signed int return_value_xmlStrcmp_107;
  signed int return_value_xmlStrcmp_106;
  signed int return_value_xmlStrcmp_105;
  signed int return_value_xmlStrcmp_104;
  signed int return_value_xmlStrcmp_103;
  signed int return_value_xmlStrcmp_102;
  signed int return_value_xmlStrcmp_101;
  signed int return_value_xmlStrcmp_100;
  signed int return_value_xmlStrcmp_99;
  signed int return_value_xmlStrcmp_98;
  signed int return_value_xmlStrcmp_97;
  signed int return_value_xmlStrcmp_96;
  signed int return_value_xmlStrcmp_95;
  signed int return_value_xmlStrcmp_94;
  signed int return_value_xmlStrcmp_93;
  signed int return_value_xmlStrcmp_92;
  signed int return_value_xmlStrcmp_91;
  signed int return_value_xmlStrcmp_90;
  signed int return_value_xmlStrcmp_89;
  signed int return_value_xmlStrcmp_88;
  signed int return_value_xmlStrcmp_87;
  signed int return_value_xmlStrcmp_86;
  signed int return_value_xmlStrcmp_85;
  signed int return_value_xmlStrcmp_84;
  signed int return_value_xmlStrcmp_83;
  signed int return_value_xmlStrcmp_82;
  signed int return_value_xmlStrcmp_81;
  signed int return_value_xmlStrcmp_80;
  signed int return_value_xmlStrcmp_79;
  signed int return_value_xmlStrcmp_78;
  signed int return_value_xmlStrcmp_77;
  signed int return_value_xmlStrcmp_76;
  signed int return_value_xmlStrcmp_75;
  signed int return_value_xmlStrcmp_74;
  signed int return_value_xmlStrcmp_73;
  signed int return_value_xmlStrcmp_72;
  signed int return_value_xmlStrcmp_71;
  signed int return_value_xmlStrcmp_70;
  signed int return_value_xmlStrcmp_69;
  signed int return_value_xmlStrcmp_68;
  signed int return_value_xmlStrcmp_67;
  signed int return_value_xmlStrcmp_66;
  signed int return_value_xmlStrcmp_65;
  signed int return_value_xmlStrcmp_64;
  signed int return_value_xmlStrcmp_63;
  signed int return_value_xmlStrcmp_62;
  signed int return_value_xmlStrcmp_61;
  signed int return_value_xmlStrcmp_60;
  signed int return_value_xmlStrcmp_59;
  signed int return_value_xmlStrcmp_58;
  signed int return_value_xmlStrcmp_57;
  signed int return_value_xmlStrcmp_56;
  signed int return_value_xmlStrcmp_55;
  signed int return_value_xmlStrcmp_54;
  signed int return_value_xmlStrcmp_53;
  signed int return_value_xmlStrcmp_52;
  signed int return_value_xmlStrcmp_51;
  signed int return_value_xmlStrcmp_50;
  signed int return_value_xmlStrcmp_49;
  signed int return_value_xmlStrcmp_48;
  signed int return_value_xmlStrcmp_47;
  signed int return_value_xmlStrcmp_46;
  signed int return_value_xmlStrcmp_45;
  signed int return_value_xmlStrcmp_44;
  signed int return_value_xmlStrcmp_43;
  signed int return_value_xmlStrcmp_42;
  signed int return_value_xmlStrcmp_41;
  signed int return_value_xmlStrcmp_40;
  signed int return_value_xmlStrcmp_39;
  signed int return_value_xmlStrcmp_38;
  signed int return_value_xmlStrcmp_37;
  signed int return_value_xmlStrcmp_36;
  signed int return_value_xmlStrcmp_35;
  signed int return_value_xmlStrcmp_34;
  signed int return_value_xmlStrcmp_33;
  signed int return_value_xmlStrcmp_32;
  signed int return_value_xmlStrcmp_31;
  signed int return_value_xmlStrcmp_30;
  signed int return_value_xmlStrcmp_29;
  signed int return_value_xmlStrcmp_28;
  signed int return_value_xmlStrcmp_27;
  signed int return_value_xmlStrcmp_26;
  signed int return_value_xmlStrcmp_25;
  signed int return_value_xmlStrcmp_24;
  if(att_ptr == ((struct _xmlAttr *)NULL))
  {
    fprintf(stderr, "Error: No attributes for element.\n");
    return 1;
  }

  else
  {
    cur_att = att_ptr;
    if(!(cur_att == ((struct _xmlAttr *)NULL)))
    {
      unsigned char *return_value_xmlGetProp_1;
      return_value_xmlGetProp_1=xmlGetProp(chld_node, cur_att->name);
      att_str = (char *)return_value_xmlGetProp_1;
      cpy = att_str;
      signed int return_value_xmlStrcmp_143;
      return_value_xmlStrcmp_143=xmlStrcmp(cur_att->name, (const unsigned char *)"weight");
      if(return_value_xmlStrcmp_143 == 0)
        this_xform->density=flam3_atof(att_str);

      else
      {
        return_value_xmlStrcmp_142=xmlStrcmp(cur_att->name, (const unsigned char *)"symmetry");
        if(return_value_xmlStrcmp_142 == 0)
        {
          double return_value_flam3_atof_2;
          return_value_flam3_atof_2=flam3_atof(att_str);
          this_xform->color_speed = (1.0 - return_value_flam3_atof_2) / 2.0;
          double return_value_flam3_atof_3;
          return_value_flam3_atof_3=flam3_atof(att_str);
          this_xform->animate = (double)(return_value_flam3_atof_3 > (double)0 ? 0 : 1);
        }

        else
        {
          return_value_xmlStrcmp_141=xmlStrcmp(cur_att->name, (const unsigned char *)"color_speed");
          if(return_value_xmlStrcmp_141 == 0)
            this_xform->color_speed=flam3_atof(att_str);

          else
          {
            return_value_xmlStrcmp_140=xmlStrcmp(cur_att->name, (const unsigned char *)"animate");
            if(return_value_xmlStrcmp_140 == 0)
              this_xform->animate=flam3_atof(att_str);

            else
            {
              return_value_xmlStrcmp_139=xmlStrcmp(cur_att->name, (const unsigned char *)"motion_frequency");
              if(return_value_xmlStrcmp_139 == 0)
                this_xform->motion_freq=flam3_atoi(att_str);

              else
              {
                return_value_xmlStrcmp_138=xmlStrcmp(cur_att->name, (const unsigned char *)"motion_function");
                if(return_value_xmlStrcmp_138 == 0)
                {
                  unsigned long int parse_xform_xml__1__2__1__6__1____s1_len;
                  unsigned long int parse_xform_xml__1__2__1__6__1____s2_len;
                  signed int return_value___builtin_strcmp_9;
                  return_value___builtin_strcmp_9=__builtin_strcmp("sin", att_str);
                  tmp_statement_expression_8 = return_value___builtin_strcmp_9;
                  if(tmp_statement_expression_8 == 0)
                    this_xform->motion_func = 1;

                  else
                  {
                    unsigned long int parse_xform_xml__1__2__1__6__3____s1_len;
                    unsigned long int parse_xform_xml__1__2__1__6__3____s2_len;
                    signed int return_value___builtin_strcmp_7;
                    return_value___builtin_strcmp_7=__builtin_strcmp("triangle", att_str);
                    tmp_statement_expression_6 = return_value___builtin_strcmp_7;
                    if(tmp_statement_expression_6 == 0)
                      this_xform->motion_func = 2;

                    else
                    {
                      unsigned long int parse_xform_xml__1__2__1__6__5____s1_len;
                      unsigned long int parse_xform_xml__1__2__1__6__5____s2_len;
                      signed int return_value___builtin_strcmp_5;
                      return_value___builtin_strcmp_5=__builtin_strcmp("hill", att_str);
                      tmp_statement_expression_4 = return_value___builtin_strcmp_5;
                      if(tmp_statement_expression_4 == 0)
                        this_xform->motion_func = 3;

                      else
                      {
                        fprintf(stderr, "Error: unknown motion function '%s'\n", att_str);
                        xmlFree((void *)att_str);
                        return 1;
                      }
                    }
                  }
                }

                else
                {
                  return_value_xmlStrcmp_137=xmlStrcmp(cur_att->name, (const unsigned char *)"color");
                  if(return_value_xmlStrcmp_137 == 0)
                  {
                    double tmpc1;
                    this_xform->color = 0.0;
                    signed int return_value_sscanf_11;
                    return_value_sscanf_11=sscanf(att_str, "%lf %lf%1s", &this_xform->color, &tmpc1, (const void *)tmps);
                    if(!(return_value_sscanf_11 == 2))
                    {
                      signed int return_value_sscanf_10;
                      return_value_sscanf_10=sscanf(att_str, "%lf%1s", &this_xform->color, (const void *)tmps);
                      if(!(return_value_sscanf_10 == 1))
                      {
                        fprintf(stderr, "Error: malformed xform color attribute '%s'\n", att_str);
                        xmlFree((void *)att_str);
                        return 1;
                      }

                    }

                  }

                  else
                  {
                    return_value_xmlStrcmp_136=xmlStrcmp(cur_att->name, (const unsigned char *)"var1");
                    if(return_value_xmlStrcmp_136 == 0)
                    {
                      j = 0;
                      for( ; !(j >= 98); j = j + 1)
                        this_xform->var[(signed long int)j] = 0.0;
                      j=flam3_atoi(att_str);
                      if(j >= 98 || !(j >= 0))
                      {
                        fprintf(stderr, "Error:  Bad variation (%d)\n", j);
                        xmlFree((void *)att_str);
                        return 1;
                      }

                      this_xform->var[(signed long int)j] = 1.0;
                    }

                    else
                    {
                      return_value_xmlStrcmp_135=xmlStrcmp(cur_att->name, (const unsigned char *)"var");
                      if(return_value_xmlStrcmp_135 == 0)
                      {
                        j = 0;
                        for( ; !(j >= 98); j = j + 1)
                        {
                          char *cpy2;
                          signed int *return_value___errno_location_12;
                          return_value___errno_location_12=__errno_location();
                          *return_value___errno_location_12 = 0;
                          this_xform->var[(signed long int)j]=strtod(cpy, &cpy2);
                          signed int *return_value___errno_location_13;
                          return_value___errno_location_13=__errno_location();
                          if(cpy == cpy2 || !(*return_value___errno_location_13 == 0))
                          {
                            fprintf(stderr, "error: bad value in var attribute '%s'\n", att_str);
                            xmlFree((void *)att_str);
                            return 1;
                          }

                          cpy = cpy2;
                        }
                        unsigned long int return_value_strlen_14;
                        return_value_strlen_14=strlen(att_str);
                        if(!(cpy == att_str + (signed long int)return_value_strlen_14))
                        {
                          fprintf(stderr, "error: extra chars at the end of var attribute '%s'\n", att_str);
                          xmlFree((void *)att_str);
                          return 1;
                        }

                      }

                      else
                      {
                        return_value_xmlStrcmp_134=xmlStrcmp(cur_att->name, (const unsigned char *)"chaos");
                        if(return_value_xmlStrcmp_134 == 0)
                        {
                          char *tok;
                          double scal;
                          signed int toi = 0;
                          if(motionxf == 1)
                          {
                            fprintf(stderr, "error: motion element cannot have a chaos attribute.\n");
                            xmlFree((void *)att_str);
                            return 1;
                          }

                          tok=strtok(cpy, " ");
                          while(!(tok == ((char *)NULL)))
                          {
                            scal=flam3_atof(tok);
                            if(IEEE_FLOAT_EQUAL(scal, 1.0))
                            {
                              toi = toi + 1;
                              tok=strtok((char *)(void *)0, " ");
                            }

                            else
                            {
                              void *return_value_realloc_15;
                              return_value_realloc_15=realloc((void *)*xaos, (unsigned long int)(*num_xaos + 1) * sizeof(struct anonymous_7) /*16ul*/ );
                              *xaos = (struct anonymous_7 *)return_value_realloc_15;
                              (*xaos + (signed long int)*num_xaos)->from = numstd;
                              (*xaos + (signed long int)*num_xaos)->to = toi;
                              (*xaos + (signed long int)*num_xaos)->scalar = scal;
                              toi = toi + 1;
                              *num_xaos = *num_xaos + 1;
                              tok=strtok((char *)(void *)0, " ");
                            }
                          }
                        }

                        else
                        {
                          return_value_xmlStrcmp_133=xmlStrcmp(cur_att->name, (const unsigned char *)"plotmode");
                          if(return_value_xmlStrcmp_133 == 0)
                          {
                            if(motionxf == 1)
                            {
                              fprintf(stderr, "error: motion element cannot have a plotmode attribute.\n");
                              xmlFree((void *)att_str);
                              return 1;
                            }

                            unsigned long int __s1_len;
                            unsigned long int __s2_len;
                            signed int return_value___builtin_strcmp_17;
                            return_value___builtin_strcmp_17=__builtin_strcmp("off", att_str);
                            tmp_statement_expression_16 = return_value___builtin_strcmp_17;
                            if(tmp_statement_expression_16 == 0)
                              this_xform->opacity = 0.0;

                          }

                          else
                          {
                            return_value_xmlStrcmp_132=xmlStrcmp(cur_att->name, (const unsigned char *)"opacity");
                            if(return_value_xmlStrcmp_132 == 0)
                              this_xform->opacity=flam3_atof(att_str);

                            else
                            {
                              return_value_xmlStrcmp_131=xmlStrcmp(cur_att->name, (const unsigned char *)"coefs");
                              if(return_value_xmlStrcmp_131 == 0)
                              {
                                k = 0;
                                for( ; !(k >= 3); k = k + 1)
                                {
                                  j = 0;
                                  for( ; !(j >= 2); j = j + 1)
                                  {
                                    char *parse_xform_xml__1__2__1__13__1__1__1__1__cpy2;
                                    signed int *return_value___errno_location_18;
                                    return_value___errno_location_18=__errno_location();
                                    *return_value___errno_location_18 = 0;
                                    this_xform->c[(signed long int)k][(signed long int)j]=strtod(cpy, &parse_xform_xml__1__2__1__13__1__1__1__1__cpy2);
                                    signed int *return_value___errno_location_19;
                                    return_value___errno_location_19=__errno_location();
                                    if(cpy == parse_xform_xml__1__2__1__13__1__1__1__1__cpy2 || !(*return_value___errno_location_19 == 0))
                                    {
                                      fprintf(stderr, "error: bad value in coefs attribute '%s'\n", att_str);
                                      xmlFree((void *)att_str);
                                      return 1;
                                    }

                                    cpy = parse_xform_xml__1__2__1__13__1__1__1__1__cpy2;
                                  }
                                }
                                unsigned long int return_value_strlen_20;
                                return_value_strlen_20=strlen(att_str);
                                if(!(cpy == att_str + (signed long int)return_value_strlen_20))
                                {
                                  fprintf(stderr, "error: extra chars at the end of coefs attribute '%s'\n", att_str);
                                  xmlFree((void *)att_str);
                                  return 1;
                                }

                              }

                              else
                              {
                                return_value_xmlStrcmp_130=xmlStrcmp(cur_att->name, (const unsigned char *)"post");
                                if(return_value_xmlStrcmp_130 == 0)
                                {
                                  k = 0;
                                  for( ; !(k >= 3); k = k + 1)
                                  {
                                    j = 0;
                                    for( ; !(j >= 2); j = j + 1)
                                    {
                                      char *parse_xform_xml__1__2__1__14__1__1__1__1__cpy2;
                                      signed int *return_value___errno_location_21;
                                      return_value___errno_location_21=__errno_location();
                                      *return_value___errno_location_21 = 0;
                                      this_xform->post[(signed long int)k][(signed long int)j]=strtod(cpy, &parse_xform_xml__1__2__1__14__1__1__1__1__cpy2);
                                      signed int *return_value___errno_location_22;
                                      return_value___errno_location_22=__errno_location();
                                      if(cpy == parse_xform_xml__1__2__1__14__1__1__1__1__cpy2 || !(*return_value___errno_location_22 == 0))
                                      {
                                        fprintf(stderr, "error: bad value in post attribute '%s'\n", att_str);
                                        xmlFree((void *)att_str);
                                        return 1;
                                      }

                                      cpy = parse_xform_xml__1__2__1__14__1__1__1__1__cpy2;
                                    }
                                  }
                                  unsigned long int return_value_strlen_23;
                                  return_value_strlen_23=strlen(att_str);
                                  if(!(cpy == att_str + (signed long int)return_value_strlen_23))
                                  {
                                    fprintf(stderr, "error: extra chars at end of post attribute '%s'\n", att_str);
                                    xmlFree((void *)att_str);
                                    return 1;
                                  }

                                }

                                else
                                {
                                  return_value_xmlStrcmp_129=xmlStrcmp(cur_att->name, (const unsigned char *)"blob_low");
                                  if(return_value_xmlStrcmp_129 == 0)
                                    this_xform->blob_low=flam3_atof(att_str);

                                  else
                                  {
                                    return_value_xmlStrcmp_128=xmlStrcmp(cur_att->name, (const unsigned char *)"blob_high");
                                    if(return_value_xmlStrcmp_128 == 0)
                                      this_xform->blob_high=flam3_atof(att_str);

                                    else
                                    {
                                      return_value_xmlStrcmp_127=xmlStrcmp(cur_att->name, (const unsigned char *)"blob_waves");
                                      if(return_value_xmlStrcmp_127 == 0)
                                        this_xform->blob_waves=flam3_atof(att_str);

                                      else
                                      {
                                        return_value_xmlStrcmp_126=xmlStrcmp(cur_att->name, (const unsigned char *)"pdj_a");
                                        if(return_value_xmlStrcmp_126 == 0)
                                          this_xform->pdj_a=flam3_atof(att_str);

                                        else
                                        {
                                          return_value_xmlStrcmp_125=xmlStrcmp(cur_att->name, (const unsigned char *)"pdj_b");
                                          if(return_value_xmlStrcmp_125 == 0)
                                            this_xform->pdj_b=flam3_atof(att_str);

                                          else
                                          {
                                            return_value_xmlStrcmp_124=xmlStrcmp(cur_att->name, (const unsigned char *)"pdj_c");
                                            if(return_value_xmlStrcmp_124 == 0)
                                              this_xform->pdj_c=flam3_atof(att_str);

                                            else
                                            {
                                              return_value_xmlStrcmp_123=xmlStrcmp(cur_att->name, (const unsigned char *)"pdj_d");
                                              if(return_value_xmlStrcmp_123 == 0)
                                                this_xform->pdj_d=flam3_atof(att_str);

                                              else
                                              {
                                                return_value_xmlStrcmp_122=xmlStrcmp(cur_att->name, (const unsigned char *)"fan2_x");
                                                if(return_value_xmlStrcmp_122 == 0)
                                                  this_xform->fan2_x=flam3_atof(att_str);

                                                else
                                                {
                                                  return_value_xmlStrcmp_121=xmlStrcmp(cur_att->name, (const unsigned char *)"fan2_y");
                                                  if(return_value_xmlStrcmp_121 == 0)
                                                    this_xform->fan2_y=flam3_atof(att_str);

                                                  else
                                                  {
                                                    return_value_xmlStrcmp_120=xmlStrcmp(cur_att->name, (const unsigned char *)"rings2_val");
                                                    if(return_value_xmlStrcmp_120 == 0)
                                                      this_xform->rings2_val=flam3_atof(att_str);

                                                    else
                                                    {
                                                      return_value_xmlStrcmp_119=xmlStrcmp(cur_att->name, (const unsigned char *)"perspective_angle");
                                                      if(return_value_xmlStrcmp_119 == 0)
                                                        this_xform->perspective_angle=flam3_atof(att_str);

                                                      else
                                                      {
                                                        return_value_xmlStrcmp_118=xmlStrcmp(cur_att->name, (const unsigned char *)"perspective_dist");
                                                        if(return_value_xmlStrcmp_118 == 0)
                                                          this_xform->perspective_dist=flam3_atof(att_str);

                                                        else
                                                        {
                                                          return_value_xmlStrcmp_117=xmlStrcmp(cur_att->name, (const unsigned char *)"julian_power");
                                                          if(return_value_xmlStrcmp_117 == 0)
                                                            this_xform->julian_power=flam3_atof(att_str);

                                                          else
                                                          {
                                                            return_value_xmlStrcmp_116=xmlStrcmp(cur_att->name, (const unsigned char *)"julian_dist");
                                                            if(return_value_xmlStrcmp_116 == 0)
                                                              this_xform->julian_dist=flam3_atof(att_str);

                                                            else
                                                            {
                                                              return_value_xmlStrcmp_115=xmlStrcmp(cur_att->name, (const unsigned char *)"juliascope_power");
                                                              if(return_value_xmlStrcmp_115 == 0)
                                                                this_xform->juliascope_power=flam3_atof(att_str);

                                                              else
                                                              {
                                                                return_value_xmlStrcmp_114=xmlStrcmp(cur_att->name, (const unsigned char *)"juliascope_dist");
                                                                if(return_value_xmlStrcmp_114 == 0)
                                                                  this_xform->juliascope_dist=flam3_atof(att_str);

                                                                else
                                                                {
                                                                  return_value_xmlStrcmp_113=xmlStrcmp(cur_att->name, (const unsigned char *)"radial_blur_angle");
                                                                  if(return_value_xmlStrcmp_113 == 0)
                                                                    this_xform->radial_blur_angle=flam3_atof(att_str);

                                                                  else
                                                                  {
                                                                    return_value_xmlStrcmp_112=xmlStrcmp(cur_att->name, (const unsigned char *)"pie_slices");
                                                                    if(return_value_xmlStrcmp_112 == 0)
                                                                      this_xform->pie_slices=flam3_atof(att_str);

                                                                    else
                                                                    {
                                                                      return_value_xmlStrcmp_111=xmlStrcmp(cur_att->name, (const unsigned char *)"pie_rotation");
                                                                      if(return_value_xmlStrcmp_111 == 0)
                                                                        this_xform->pie_rotation=flam3_atof(att_str);

                                                                      else
                                                                      {
                                                                        return_value_xmlStrcmp_110=xmlStrcmp(cur_att->name, (const unsigned char *)"pie_thickness");
                                                                        if(return_value_xmlStrcmp_110 == 0)
                                                                          this_xform->pie_thickness=flam3_atof(att_str);

                                                                        else
                                                                        {
                                                                          return_value_xmlStrcmp_109=xmlStrcmp(cur_att->name, (const unsigned char *)"ngon_sides");
                                                                          if(return_value_xmlStrcmp_109 == 0)
                                                                            this_xform->ngon_sides=flam3_atof(att_str);

                                                                          else
                                                                          {
                                                                            return_value_xmlStrcmp_108=xmlStrcmp(cur_att->name, (const unsigned char *)"ngon_power");
                                                                            if(return_value_xmlStrcmp_108 == 0)
                                                                              this_xform->ngon_power=flam3_atof(att_str);

                                                                            else
                                                                            {
                                                                              return_value_xmlStrcmp_107=xmlStrcmp(cur_att->name, (const unsigned char *)"ngon_circle");
                                                                              if(return_value_xmlStrcmp_107 == 0)
                                                                                this_xform->ngon_circle=flam3_atof(att_str);

                                                                              else
                                                                              {
                                                                                return_value_xmlStrcmp_106=xmlStrcmp(cur_att->name, (const unsigned char *)"ngon_corners");
                                                                                if(return_value_xmlStrcmp_106 == 0)
                                                                                  this_xform->ngon_corners=flam3_atof(att_str);

                                                                                else
                                                                                {
                                                                                  return_value_xmlStrcmp_105=xmlStrcmp(cur_att->name, (const unsigned char *)"curl_c1");
                                                                                  if(return_value_xmlStrcmp_105 == 0)
                                                                                    this_xform->curl_c1=flam3_atof(att_str);

                                                                                  else
                                                                                  {
                                                                                    return_value_xmlStrcmp_104=xmlStrcmp(cur_att->name, (const unsigned char *)"curl_c2");
                                                                                    if(return_value_xmlStrcmp_104 == 0)
                                                                                      this_xform->curl_c2=flam3_atof(att_str);

                                                                                    else
                                                                                    {
                                                                                      return_value_xmlStrcmp_103=xmlStrcmp(cur_att->name, (const unsigned char *)"rectangles_x");
                                                                                      if(return_value_xmlStrcmp_103 == 0)
                                                                                        this_xform->rectangles_x=flam3_atof(att_str);

                                                                                      else
                                                                                      {
                                                                                        return_value_xmlStrcmp_102=xmlStrcmp(cur_att->name, (const unsigned char *)"rectangles_y");
                                                                                        if(return_value_xmlStrcmp_102 == 0)
                                                                                          this_xform->rectangles_y=flam3_atof(att_str);

                                                                                        else
                                                                                        {
                                                                                          return_value_xmlStrcmp_101=xmlStrcmp(cur_att->name, (const unsigned char *)"amw_amp");
                                                                                          if(return_value_xmlStrcmp_101 == 0)
                                                                                            this_xform->amw_amp=flam3_atof(att_str);

                                                                                          else
                                                                                          {
                                                                                            return_value_xmlStrcmp_100=xmlStrcmp(cur_att->name, (const unsigned char *)"disc2_rot");
                                                                                            if(return_value_xmlStrcmp_100 == 0)
                                                                                              this_xform->disc2_rot=flam3_atof(att_str);

                                                                                            else
                                                                                            {
                                                                                              return_value_xmlStrcmp_99=xmlStrcmp(cur_att->name, (const unsigned char *)"disc2_twist");
                                                                                              if(return_value_xmlStrcmp_99 == 0)
                                                                                                this_xform->disc2_twist=flam3_atof(att_str);

                                                                                              else
                                                                                              {
                                                                                                return_value_xmlStrcmp_98=xmlStrcmp(cur_att->name, (const unsigned char *)"super_shape_rnd");
                                                                                                if(return_value_xmlStrcmp_98 == 0)
                                                                                                {
                                                                                                  this_xform->super_shape_rnd=flam3_atof(att_str);
                                                                                                  if(this_xform->super_shape_rnd < 0.000000)
                                                                                                    this_xform->super_shape_rnd = (double)0;

                                                                                                  else
                                                                                                    if(this_xform->super_shape_rnd > 1.000000)
                                                                                                      this_xform->super_shape_rnd = (double)1;

                                                                                                }

                                                                                                else
                                                                                                {
                                                                                                  return_value_xmlStrcmp_97=xmlStrcmp(cur_att->name, (const unsigned char *)"super_shape_m");
                                                                                                  if(return_value_xmlStrcmp_97 == 0)
                                                                                                    this_xform->super_shape_m=flam3_atof(att_str);

                                                                                                  else
                                                                                                  {
                                                                                                    return_value_xmlStrcmp_96=xmlStrcmp(cur_att->name, (const unsigned char *)"super_shape_n1");
                                                                                                    if(return_value_xmlStrcmp_96 == 0)
                                                                                                      this_xform->super_shape_n1=flam3_atof(att_str);

                                                                                                    else
                                                                                                    {
                                                                                                      return_value_xmlStrcmp_95=xmlStrcmp(cur_att->name, (const unsigned char *)"super_shape_n2");
                                                                                                      if(return_value_xmlStrcmp_95 == 0)
                                                                                                        this_xform->super_shape_n2=flam3_atof(att_str);

                                                                                                      else
                                                                                                      {
                                                                                                        return_value_xmlStrcmp_94=xmlStrcmp(cur_att->name, (const unsigned char *)"super_shape_n3");
                                                                                                        if(return_value_xmlStrcmp_94 == 0)
                                                                                                          this_xform->super_shape_n3=flam3_atof(att_str);

                                                                                                        else
                                                                                                        {
                                                                                                          return_value_xmlStrcmp_93=xmlStrcmp(cur_att->name, (const unsigned char *)"super_shape_holes");
                                                                                                          if(return_value_xmlStrcmp_93 == 0)
                                                                                                            this_xform->super_shape_holes=flam3_atof(att_str);

                                                                                                          else
                                                                                                          {
                                                                                                            return_value_xmlStrcmp_92=xmlStrcmp(cur_att->name, (const unsigned char *)"flower_petals");
                                                                                                            if(return_value_xmlStrcmp_92 == 0)
                                                                                                              this_xform->flower_petals=flam3_atof(att_str);

                                                                                                            else
                                                                                                            {
                                                                                                              return_value_xmlStrcmp_91=xmlStrcmp(cur_att->name, (const unsigned char *)"flower_holes");
                                                                                                              if(return_value_xmlStrcmp_91 == 0)
                                                                                                                this_xform->flower_holes=flam3_atof(att_str);

                                                                                                              else
                                                                                                              {
                                                                                                                return_value_xmlStrcmp_90=xmlStrcmp(cur_att->name, (const unsigned char *)"conic_eccentricity");
                                                                                                                if(return_value_xmlStrcmp_90 == 0)
                                                                                                                  this_xform->conic_eccentricity=flam3_atof(att_str);

                                                                                                                else
                                                                                                                {
                                                                                                                  return_value_xmlStrcmp_89=xmlStrcmp(cur_att->name, (const unsigned char *)"conic_holes");
                                                                                                                  if(return_value_xmlStrcmp_89 == 0)
                                                                                                                    this_xform->conic_holes=flam3_atof(att_str);

                                                                                                                  else
                                                                                                                  {
                                                                                                                    return_value_xmlStrcmp_88=xmlStrcmp(cur_att->name, (const unsigned char *)"parabola_height");
                                                                                                                    if(return_value_xmlStrcmp_88 == 0)
                                                                                                                      this_xform->parabola_height=flam3_atof(att_str);

                                                                                                                    else
                                                                                                                    {
                                                                                                                      return_value_xmlStrcmp_87=xmlStrcmp(cur_att->name, (const unsigned char *)"parabola_width");
                                                                                                                      if(return_value_xmlStrcmp_87 == 0)
                                                                                                                        this_xform->parabola_width=flam3_atof(att_str);

                                                                                                                      else
                                                                                                                      {
                                                                                                                        return_value_xmlStrcmp_86=xmlStrcmp(cur_att->name, (const unsigned char *)"bent2_x");
                                                                                                                        if(return_value_xmlStrcmp_86 == 0)
                                                                                                                          this_xform->bent2_x=flam3_atof(att_str);

                                                                                                                        else
                                                                                                                        {
                                                                                                                          return_value_xmlStrcmp_85=xmlStrcmp(cur_att->name, (const unsigned char *)"bent2_y");
                                                                                                                          if(return_value_xmlStrcmp_85 == 0)
                                                                                                                            this_xform->bent2_y=flam3_atof(att_str);

                                                                                                                          else
                                                                                                                          {
                                                                                                                            return_value_xmlStrcmp_84=xmlStrcmp(cur_att->name, (const unsigned char *)"bipolar_shift");
                                                                                                                            if(return_value_xmlStrcmp_84 == 0)
                                                                                                                              this_xform->bipolar_shift=flam3_atof(att_str);

                                                                                                                            else
                                                                                                                            {
                                                                                                                              return_value_xmlStrcmp_83=xmlStrcmp(cur_att->name, (const unsigned char *)"cell_size");
                                                                                                                              if(return_value_xmlStrcmp_83 == 0)
                                                                                                                                this_xform->cell_size=flam3_atof(att_str);

                                                                                                                              else
                                                                                                                              {
                                                                                                                                return_value_xmlStrcmp_82=xmlStrcmp(cur_att->name, (const unsigned char *)"cpow_i");
                                                                                                                                if(return_value_xmlStrcmp_82 == 0)
                                                                                                                                  this_xform->cpow_i=flam3_atof(att_str);

                                                                                                                                else
                                                                                                                                {
                                                                                                                                  return_value_xmlStrcmp_81=xmlStrcmp(cur_att->name, (const unsigned char *)"cpow_r");
                                                                                                                                  if(return_value_xmlStrcmp_81 == 0)
                                                                                                                                    this_xform->cpow_r=flam3_atof(att_str);

                                                                                                                                  else
                                                                                                                                  {
                                                                                                                                    return_value_xmlStrcmp_80=xmlStrcmp(cur_att->name, (const unsigned char *)"cpow_power");
                                                                                                                                    if(return_value_xmlStrcmp_80 == 0)
                                                                                                                                      this_xform->cpow_power=flam3_atof(att_str);

                                                                                                                                    else
                                                                                                                                    {
                                                                                                                                      return_value_xmlStrcmp_79=xmlStrcmp(cur_att->name, (const unsigned char *)"curve_xamp");
                                                                                                                                      if(return_value_xmlStrcmp_79 == 0)
                                                                                                                                        this_xform->curve_xamp=flam3_atof(att_str);

                                                                                                                                      else
                                                                                                                                      {
                                                                                                                                        return_value_xmlStrcmp_78=xmlStrcmp(cur_att->name, (const unsigned char *)"curve_yamp");
                                                                                                                                        if(return_value_xmlStrcmp_78 == 0)
                                                                                                                                          this_xform->curve_yamp=flam3_atof(att_str);

                                                                                                                                        else
                                                                                                                                        {
                                                                                                                                          return_value_xmlStrcmp_77=xmlStrcmp(cur_att->name, (const unsigned char *)"curve_xlength");
                                                                                                                                          if(return_value_xmlStrcmp_77 == 0)
                                                                                                                                            this_xform->curve_xlength=flam3_atof(att_str);

                                                                                                                                          else
                                                                                                                                          {
                                                                                                                                            return_value_xmlStrcmp_76=xmlStrcmp(cur_att->name, (const unsigned char *)"curve_ylength");
                                                                                                                                            if(return_value_xmlStrcmp_76 == 0)
                                                                                                                                              this_xform->curve_ylength=flam3_atof(att_str);

                                                                                                                                            else
                                                                                                                                            {
                                                                                                                                              return_value_xmlStrcmp_75=xmlStrcmp(cur_att->name, (const unsigned char *)"escher_beta");
                                                                                                                                              if(return_value_xmlStrcmp_75 == 0)
                                                                                                                                                this_xform->escher_beta=flam3_atof(att_str);

                                                                                                                                              else
                                                                                                                                              {
                                                                                                                                                return_value_xmlStrcmp_74=xmlStrcmp(cur_att->name, (const unsigned char *)"lazysusan_x");
                                                                                                                                                if(return_value_xmlStrcmp_74 == 0)
                                                                                                                                                  this_xform->lazysusan_x=flam3_atof(att_str);

                                                                                                                                                else
                                                                                                                                                {
                                                                                                                                                  return_value_xmlStrcmp_73=xmlStrcmp(cur_att->name, (const unsigned char *)"lazysusan_y");
                                                                                                                                                  if(return_value_xmlStrcmp_73 == 0)
                                                                                                                                                    this_xform->lazysusan_y=flam3_atof(att_str);

                                                                                                                                                  else
                                                                                                                                                  {
                                                                                                                                                    return_value_xmlStrcmp_72=xmlStrcmp(cur_att->name, (const unsigned char *)"lazysusan_spin");
                                                                                                                                                    if(return_value_xmlStrcmp_72 == 0)
                                                                                                                                                      this_xform->lazysusan_spin=flam3_atof(att_str);

                                                                                                                                                    else
                                                                                                                                                    {
                                                                                                                                                      return_value_xmlStrcmp_71=xmlStrcmp(cur_att->name, (const unsigned char *)"lazysusan_space");
                                                                                                                                                      if(return_value_xmlStrcmp_71 == 0)
                                                                                                                                                        this_xform->lazysusan_space=flam3_atof(att_str);

                                                                                                                                                      else
                                                                                                                                                      {
                                                                                                                                                        return_value_xmlStrcmp_70=xmlStrcmp(cur_att->name, (const unsigned char *)"lazysusan_twist");
                                                                                                                                                        if(return_value_xmlStrcmp_70 == 0)
                                                                                                                                                          this_xform->lazysusan_twist=flam3_atof(att_str);

                                                                                                                                                        else
                                                                                                                                                        {
                                                                                                                                                          return_value_xmlStrcmp_69=xmlStrcmp(cur_att->name, (const unsigned char *)"modulus_x");
                                                                                                                                                          if(return_value_xmlStrcmp_69 == 0)
                                                                                                                                                            this_xform->modulus_x=flam3_atof(att_str);

                                                                                                                                                          else
                                                                                                                                                          {
                                                                                                                                                            return_value_xmlStrcmp_68=xmlStrcmp(cur_att->name, (const unsigned char *)"modulus_y");
                                                                                                                                                            if(return_value_xmlStrcmp_68 == 0)
                                                                                                                                                              this_xform->modulus_y=flam3_atof(att_str);

                                                                                                                                                            else
                                                                                                                                                            {
                                                                                                                                                              return_value_xmlStrcmp_67=xmlStrcmp(cur_att->name, (const unsigned char *)"oscilloscope_separation");
                                                                                                                                                              if(return_value_xmlStrcmp_67 == 0)
                                                                                                                                                                this_xform->oscope_separation=flam3_atof(att_str);

                                                                                                                                                              else
                                                                                                                                                              {
                                                                                                                                                                return_value_xmlStrcmp_66=xmlStrcmp(cur_att->name, (const unsigned char *)"oscilloscope_frequency");
                                                                                                                                                                if(return_value_xmlStrcmp_66 == 0)
                                                                                                                                                                  this_xform->oscope_frequency=flam3_atof(att_str);

                                                                                                                                                                else
                                                                                                                                                                {
                                                                                                                                                                  return_value_xmlStrcmp_65=xmlStrcmp(cur_att->name, (const unsigned char *)"oscilloscope_amplitude");
                                                                                                                                                                  if(return_value_xmlStrcmp_65 == 0)
                                                                                                                                                                    this_xform->oscope_amplitude=flam3_atof(att_str);

                                                                                                                                                                  else
                                                                                                                                                                  {
                                                                                                                                                                    return_value_xmlStrcmp_64=xmlStrcmp(cur_att->name, (const unsigned char *)"oscilloscope_damping");
                                                                                                                                                                    if(return_value_xmlStrcmp_64 == 0)
                                                                                                                                                                      this_xform->oscope_damping=flam3_atof(att_str);

                                                                                                                                                                    else
                                                                                                                                                                    {
                                                                                                                                                                      return_value_xmlStrcmp_63=xmlStrcmp(cur_att->name, (const unsigned char *)"oscope_separation");
                                                                                                                                                                      if(return_value_xmlStrcmp_63 == 0)
                                                                                                                                                                        this_xform->oscope_separation=flam3_atof(att_str);

                                                                                                                                                                      else
                                                                                                                                                                      {
                                                                                                                                                                        return_value_xmlStrcmp_62=xmlStrcmp(cur_att->name, (const unsigned char *)"oscope_frequency");
                                                                                                                                                                        if(return_value_xmlStrcmp_62 == 0)
                                                                                                                                                                          this_xform->oscope_frequency=flam3_atof(att_str);

                                                                                                                                                                        else
                                                                                                                                                                        {
                                                                                                                                                                          return_value_xmlStrcmp_61=xmlStrcmp(cur_att->name, (const unsigned char *)"oscope_amplitude");
                                                                                                                                                                          if(return_value_xmlStrcmp_61 == 0)
                                                                                                                                                                            this_xform->oscope_amplitude=flam3_atof(att_str);

                                                                                                                                                                          else
                                                                                                                                                                          {
                                                                                                                                                                            return_value_xmlStrcmp_60=xmlStrcmp(cur_att->name, (const unsigned char *)"oscope_damping");
                                                                                                                                                                            if(return_value_xmlStrcmp_60 == 0)
                                                                                                                                                                              this_xform->oscope_damping=flam3_atof(att_str);

                                                                                                                                                                            else
                                                                                                                                                                            {
                                                                                                                                                                              return_value_xmlStrcmp_59=xmlStrcmp(cur_att->name, (const unsigned char *)"popcorn2_x");
                                                                                                                                                                              if(return_value_xmlStrcmp_59 == 0)
                                                                                                                                                                                this_xform->popcorn2_x=flam3_atof(att_str);

                                                                                                                                                                              else
                                                                                                                                                                              {
                                                                                                                                                                                return_value_xmlStrcmp_58=xmlStrcmp(cur_att->name, (const unsigned char *)"popcorn2_y");
                                                                                                                                                                                if(return_value_xmlStrcmp_58 == 0)
                                                                                                                                                                                  this_xform->popcorn2_y=flam3_atof(att_str);

                                                                                                                                                                                else
                                                                                                                                                                                {
                                                                                                                                                                                  return_value_xmlStrcmp_57=xmlStrcmp(cur_att->name, (const unsigned char *)"popcorn2_c");
                                                                                                                                                                                  if(return_value_xmlStrcmp_57 == 0)
                                                                                                                                                                                    this_xform->popcorn2_c=flam3_atof(att_str);

                                                                                                                                                                                  else
                                                                                                                                                                                  {
                                                                                                                                                                                    return_value_xmlStrcmp_56=xmlStrcmp(cur_att->name, (const unsigned char *)"separation_x");
                                                                                                                                                                                    if(return_value_xmlStrcmp_56 == 0)
                                                                                                                                                                                      this_xform->separation_x=flam3_atof(att_str);

                                                                                                                                                                                    else
                                                                                                                                                                                    {
                                                                                                                                                                                      return_value_xmlStrcmp_55=xmlStrcmp(cur_att->name, (const unsigned char *)"separation_xinside");
                                                                                                                                                                                      if(return_value_xmlStrcmp_55 == 0)
                                                                                                                                                                                        this_xform->separation_xinside=flam3_atof(att_str);

                                                                                                                                                                                      else
                                                                                                                                                                                      {
                                                                                                                                                                                        return_value_xmlStrcmp_54=xmlStrcmp(cur_att->name, (const unsigned char *)"separation_y");
                                                                                                                                                                                        if(return_value_xmlStrcmp_54 == 0)
                                                                                                                                                                                          this_xform->separation_y=flam3_atof(att_str);

                                                                                                                                                                                        else
                                                                                                                                                                                        {
                                                                                                                                                                                          return_value_xmlStrcmp_53=xmlStrcmp(cur_att->name, (const unsigned char *)"separation_yinside");
                                                                                                                                                                                          if(return_value_xmlStrcmp_53 == 0)
                                                                                                                                                                                            this_xform->separation_yinside=flam3_atof(att_str);

                                                                                                                                                                                          else
                                                                                                                                                                                          {
                                                                                                                                                                                            return_value_xmlStrcmp_52=xmlStrcmp(cur_att->name, (const unsigned char *)"split_xsize");
                                                                                                                                                                                            if(return_value_xmlStrcmp_52 == 0)
                                                                                                                                                                                              this_xform->split_xsize=flam3_atof(att_str);

                                                                                                                                                                                            else
                                                                                                                                                                                            {
                                                                                                                                                                                              return_value_xmlStrcmp_51=xmlStrcmp(cur_att->name, (const unsigned char *)"split_ysize");
                                                                                                                                                                                              if(return_value_xmlStrcmp_51 == 0)
                                                                                                                                                                                                this_xform->split_ysize=flam3_atof(att_str);

                                                                                                                                                                                              else
                                                                                                                                                                                              {
                                                                                                                                                                                                return_value_xmlStrcmp_50=xmlStrcmp(cur_att->name, (const unsigned char *)"splits_x");
                                                                                                                                                                                                if(return_value_xmlStrcmp_50 == 0)
                                                                                                                                                                                                  this_xform->splits_x=flam3_atof(att_str);

                                                                                                                                                                                                else
                                                                                                                                                                                                {
                                                                                                                                                                                                  return_value_xmlStrcmp_49=xmlStrcmp(cur_att->name, (const unsigned char *)"splits_y");
                                                                                                                                                                                                  if(return_value_xmlStrcmp_49 == 0)
                                                                                                                                                                                                    this_xform->splits_y=flam3_atof(att_str);

                                                                                                                                                                                                  else
                                                                                                                                                                                                  {
                                                                                                                                                                                                    return_value_xmlStrcmp_48=xmlStrcmp(cur_att->name, (const unsigned char *)"stripes_space");
                                                                                                                                                                                                    if(return_value_xmlStrcmp_48 == 0)
                                                                                                                                                                                                      this_xform->stripes_space=flam3_atof(att_str);

                                                                                                                                                                                                    else
                                                                                                                                                                                                    {
                                                                                                                                                                                                      return_value_xmlStrcmp_47=xmlStrcmp(cur_att->name, (const unsigned char *)"stripes_warp");
                                                                                                                                                                                                      if(return_value_xmlStrcmp_47 == 0)
                                                                                                                                                                                                        this_xform->stripes_warp=flam3_atof(att_str);

                                                                                                                                                                                                      else
                                                                                                                                                                                                      {
                                                                                                                                                                                                        return_value_xmlStrcmp_46=xmlStrcmp(cur_att->name, (const unsigned char *)"wedge_angle");
                                                                                                                                                                                                        if(return_value_xmlStrcmp_46 == 0)
                                                                                                                                                                                                          this_xform->wedge_angle=flam3_atof(att_str);

                                                                                                                                                                                                        else
                                                                                                                                                                                                        {
                                                                                                                                                                                                          return_value_xmlStrcmp_45=xmlStrcmp(cur_att->name, (const unsigned char *)"wedge_hole");
                                                                                                                                                                                                          if(return_value_xmlStrcmp_45 == 0)
                                                                                                                                                                                                            this_xform->wedge_hole=flam3_atof(att_str);

                                                                                                                                                                                                          else
                                                                                                                                                                                                          {
                                                                                                                                                                                                            return_value_xmlStrcmp_44=xmlStrcmp(cur_att->name, (const unsigned char *)"wedge_count");
                                                                                                                                                                                                            if(return_value_xmlStrcmp_44 == 0)
                                                                                                                                                                                                              this_xform->wedge_count=flam3_atof(att_str);

                                                                                                                                                                                                            else
                                                                                                                                                                                                            {
                                                                                                                                                                                                              return_value_xmlStrcmp_43=xmlStrcmp(cur_att->name, (const unsigned char *)"wedge_swirl");
                                                                                                                                                                                                              if(return_value_xmlStrcmp_43 == 0)
                                                                                                                                                                                                                this_xform->wedge_swirl=flam3_atof(att_str);

                                                                                                                                                                                                              else
                                                                                                                                                                                                              {
                                                                                                                                                                                                                return_value_xmlStrcmp_42=xmlStrcmp(cur_att->name, (const unsigned char *)"wedge_julia_angle");
                                                                                                                                                                                                                if(return_value_xmlStrcmp_42 == 0)
                                                                                                                                                                                                                  this_xform->wedge_julia_angle=flam3_atof(att_str);

                                                                                                                                                                                                                else
                                                                                                                                                                                                                {
                                                                                                                                                                                                                  return_value_xmlStrcmp_41=xmlStrcmp(cur_att->name, (const unsigned char *)"wedge_julia_count");
                                                                                                                                                                                                                  if(return_value_xmlStrcmp_41 == 0)
                                                                                                                                                                                                                    this_xform->wedge_julia_count=flam3_atof(att_str);

                                                                                                                                                                                                                  else
                                                                                                                                                                                                                  {
                                                                                                                                                                                                                    return_value_xmlStrcmp_40=xmlStrcmp(cur_att->name, (const unsigned char *)"wedge_julia_power");
                                                                                                                                                                                                                    if(return_value_xmlStrcmp_40 == 0)
                                                                                                                                                                                                                      this_xform->wedge_julia_power=flam3_atof(att_str);

                                                                                                                                                                                                                    else
                                                                                                                                                                                                                    {
                                                                                                                                                                                                                      return_value_xmlStrcmp_39=xmlStrcmp(cur_att->name, (const unsigned char *)"wedge_julia_dist");
                                                                                                                                                                                                                      if(return_value_xmlStrcmp_39 == 0)
                                                                                                                                                                                                                        this_xform->wedge_julia_dist=flam3_atof(att_str);

                                                                                                                                                                                                                      else
                                                                                                                                                                                                                      {
                                                                                                                                                                                                                        return_value_xmlStrcmp_38=xmlStrcmp(cur_att->name, (const unsigned char *)"wedge_sph_angle");
                                                                                                                                                                                                                        if(return_value_xmlStrcmp_38 == 0)
                                                                                                                                                                                                                          this_xform->wedge_sph_angle=flam3_atof(att_str);

                                                                                                                                                                                                                        else
                                                                                                                                                                                                                        {
                                                                                                                                                                                                                          return_value_xmlStrcmp_37=xmlStrcmp(cur_att->name, (const unsigned char *)"wedge_sph_hole");
                                                                                                                                                                                                                          if(return_value_xmlStrcmp_37 == 0)
                                                                                                                                                                                                                            this_xform->wedge_sph_hole=flam3_atof(att_str);

                                                                                                                                                                                                                          else
                                                                                                                                                                                                                          {
                                                                                                                                                                                                                            return_value_xmlStrcmp_36=xmlStrcmp(cur_att->name, (const unsigned char *)"wedge_sph_count");
                                                                                                                                                                                                                            if(return_value_xmlStrcmp_36 == 0)
                                                                                                                                                                                                                              this_xform->wedge_sph_count=flam3_atof(att_str);

                                                                                                                                                                                                                            else
                                                                                                                                                                                                                            {
                                                                                                                                                                                                                              return_value_xmlStrcmp_35=xmlStrcmp(cur_att->name, (const unsigned char *)"wedge_sph_swirl");
                                                                                                                                                                                                                              if(return_value_xmlStrcmp_35 == 0)
                                                                                                                                                                                                                                this_xform->wedge_sph_swirl=flam3_atof(att_str);

                                                                                                                                                                                                                              else
                                                                                                                                                                                                                              {
                                                                                                                                                                                                                                return_value_xmlStrcmp_34=xmlStrcmp(cur_att->name, (const unsigned char *)"whorl_inside");
                                                                                                                                                                                                                                if(return_value_xmlStrcmp_34 == 0)
                                                                                                                                                                                                                                  this_xform->whorl_inside=flam3_atof(att_str);

                                                                                                                                                                                                                                else
                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                  return_value_xmlStrcmp_33=xmlStrcmp(cur_att->name, (const unsigned char *)"whorl_outside");
                                                                                                                                                                                                                                  if(return_value_xmlStrcmp_33 == 0)
                                                                                                                                                                                                                                    this_xform->whorl_outside=flam3_atof(att_str);

                                                                                                                                                                                                                                  else
                                                                                                                                                                                                                                  {
                                                                                                                                                                                                                                    return_value_xmlStrcmp_32=xmlStrcmp(cur_att->name, (const unsigned char *)"waves2_scalex");
                                                                                                                                                                                                                                    if(return_value_xmlStrcmp_32 == 0)
                                                                                                                                                                                                                                      this_xform->waves2_scalex=flam3_atof(att_str);

                                                                                                                                                                                                                                    else
                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                      return_value_xmlStrcmp_31=xmlStrcmp(cur_att->name, (const unsigned char *)"waves2_scaley");
                                                                                                                                                                                                                                      if(return_value_xmlStrcmp_31 == 0)
                                                                                                                                                                                                                                        this_xform->waves2_scaley=flam3_atof(att_str);

                                                                                                                                                                                                                                      else
                                                                                                                                                                                                                                      {
                                                                                                                                                                                                                                        return_value_xmlStrcmp_30=xmlStrcmp(cur_att->name, (const unsigned char *)"waves2_freqx");
                                                                                                                                                                                                                                        if(return_value_xmlStrcmp_30 == 0)
                                                                                                                                                                                                                                          this_xform->waves2_freqx=flam3_atof(att_str);

                                                                                                                                                                                                                                        else
                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                          return_value_xmlStrcmp_29=xmlStrcmp(cur_att->name, (const unsigned char *)"waves2_freqy");
                                                                                                                                                                                                                                          if(return_value_xmlStrcmp_29 == 0)
                                                                                                                                                                                                                                            this_xform->waves2_freqy=flam3_atof(att_str);

                                                                                                                                                                                                                                          else
                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                            return_value_xmlStrcmp_28=xmlStrcmp(cur_att->name, (const unsigned char *)"auger_freq");
                                                                                                                                                                                                                                            if(return_value_xmlStrcmp_28 == 0)
                                                                                                                                                                                                                                              this_xform->auger_freq=flam3_atof(att_str);

                                                                                                                                                                                                                                            else
                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                              return_value_xmlStrcmp_27=xmlStrcmp(cur_att->name, (const unsigned char *)"auger_weight");
                                                                                                                                                                                                                                              if(return_value_xmlStrcmp_27 == 0)
                                                                                                                                                                                                                                                this_xform->auger_weight=flam3_atof(att_str);

                                                                                                                                                                                                                                              else
                                                                                                                                                                                                                                              {
                                                                                                                                                                                                                                                return_value_xmlStrcmp_26=xmlStrcmp(cur_att->name, (const unsigned char *)"auger_sym");
                                                                                                                                                                                                                                                if(return_value_xmlStrcmp_26 == 0)
                                                                                                                                                                                                                                                  this_xform->auger_sym=flam3_atof(att_str);

                                                                                                                                                                                                                                                else
                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                  return_value_xmlStrcmp_25=xmlStrcmp(cur_att->name, (const unsigned char *)"auger_scale");
                                                                                                                                                                                                                                                  if(return_value_xmlStrcmp_25 == 0)
                                                                                                                                                                                                                                                    this_xform->auger_scale=flam3_atof(att_str);

                                                                                                                                                                                                                                                  else
                                                                                                                                                                                                                                                  {
                                                                                                                                                                                                                                                    return_value_xmlStrcmp_24=xmlStrcmp(cur_att->name, (const unsigned char *)"flux_spread");
                                                                                                                                                                                                                                                    if(return_value_xmlStrcmp_24 == 0)
                                                                                                                                                                                                                                                      this_xform->flux_spread=flam3_atof(att_str);

                                                                                                                                                                                                                                                    else
                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                      signed int v;
                                                                                                                                                                                                                                                      v=var2n((char *)cur_att->name);
                                                                                                                                                                                                                                                      if(!(v == -1))
                                                                                                                                                                                                                                                        this_xform->var[(signed long int)v]=flam3_atof(att_str);

                                                                                                                                                                                                                                                      else
                                                                                                                                                                                                                                                        fprintf(stderr, "Warning: unrecognized variation %s.  Ignoring.\n", (char *)cur_att->name);
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                              }
                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                          }
                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                      }
                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                  }
                                                                                                                                                                                                                                }
                                                                                                                                                                                                                              }
                                                                                                                                                                                                                            }
                                                                                                                                                                                                                          }
                                                                                                                                                                                                                        }
                                                                                                                                                                                                                      }
                                                                                                                                                                                                                    }
                                                                                                                                                                                                                  }
                                                                                                                                                                                                                }
                                                                                                                                                                                                              }
                                                                                                                                                                                                            }
                                                                                                                                                                                                          }
                                                                                                                                                                                                        }
                                                                                                                                                                                                      }
                                                                                                                                                                                                    }
                                                                                                                                                                                                  }
                                                                                                                                                                                                }
                                                                                                                                                                                              }
                                                                                                                                                                                            }
                                                                                                                                                                                          }
                                                                                                                                                                                        }
                                                                                                                                                                                      }
                                                                                                                                                                                    }
                                                                                                                                                                                  }
                                                                                                                                                                                }
                                                                                                                                                                              }
                                                                                                                                                                            }
                                                                                                                                                                          }
                                                                                                                                                                        }
                                                                                                                                                                      }
                                                                                                                                                                    }
                                                                                                                                                                  }
                                                                                                                                                                }
                                                                                                                                                              }
                                                                                                                                                            }
                                                                                                                                                          }
                                                                                                                                                        }
                                                                                                                                                      }
                                                                                                                                                    }
                                                                                                                                                  }
                                                                                                                                                }
                                                                                                                                              }
                                                                                                                                            }
                                                                                                                                          }
                                                                                                                                        }
                                                                                                                                      }
                                                                                                                                    }
                                                                                                                                  }
                                                                                                                                }
                                                                                                                              }
                                                                                                                            }
                                                                                                                          }
                                                                                                                        }
                                                                                                                      }
                                                                                                                    }
                                                                                                                  }
                                                                                                                }
                                                                                                              }
                                                                                                            }
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      xmlFree((void *)att_str);
      cur_att = cur_att->next;
    }

    return 0;
  }
}

// perspective_precalc
// file variations.c line 1927
void perspective_precalc(struct xform *xf)
{
  double ang = (xf->perspective_angle * 3.14159265358979323846) / 2.0;
  xf->persp_vsin=sin(ang);
  double return_value_cos_1;
  return_value_cos_1=cos(ang);
  xf->persp_vfcos = xf->perspective_dist * return_value_cos_1;
}

// prepare_precalc_flags
// file variations.h line 137
signed int prepare_precalc_flags(struct anonymous_0 *cp)
{
  double d;
  signed int i;
  signed int j;
  signed int totnum;
  i = 0;
  for( ; !(i >= cp->num_xforms); i = i + 1)
  {
    d = (cp->xform + (signed long int)i)->density;
    if(d < 0.0)
    {
      fprintf(stderr, "xform %d weight must be non-negative, not %g.\n", i, d);
      return 1;
    }

    if(!(i == cp->final_xform_index))
    {
      if(IEEE_FLOAT_EQUAL(d, 0.0))
        goto __CPROVER_DUMP_L39;

    }

    totnum = 0;
    (cp->xform + (signed long int)i)->vis_adjusted=adjust_percentage((cp->xform + (signed long int)i)->opacity);
    (cp->xform + (signed long int)i)->precalc_angles_flag = 0;
    (cp->xform + (signed long int)i)->precalc_atan_xy_flag = 0;
    (cp->xform + (signed long int)i)->precalc_atan_yx_flag = 0;
    (cp->xform + (signed long int)i)->has_preblur = (double)0;
    signed int return_value_id_matrix_1;
    return_value_id_matrix_1=id_matrix((cp->xform + (signed long int)i)->post);
    (cp->xform + (signed long int)i)->has_post = (signed int)!(return_value_id_matrix_1 != 0);
    j = 0;
    for( ; !(j >= 98); j = j + 1)
      if(IEEE_FLOAT_NOTEQUAL((cp->xform + (signed long int)i)->var[(signed long int)j], 0.000000))
      {
        (cp->xform + (signed long int)i)->varFunc[(signed long int)totnum] = j;
        (cp->xform + (signed long int)i)->active_var_weights[(signed long int)totnum] = (cp->xform + (signed long int)i)->var[(signed long int)j];
        if(j == 5)
          (cp->xform + (signed long int)i)->precalc_atan_xy_flag = 1;

        else
          if(j == 6)
            (cp->xform + (signed long int)i)->precalc_atan_xy_flag = 1;

          else
            if(j == 7)
              (cp->xform + (signed long int)i)->precalc_atan_xy_flag = 1;

            else
              if(j == 8)
                (cp->xform + (signed long int)i)->precalc_atan_xy_flag = 1;

              else
                if(j == 9)
                  (cp->xform + (signed long int)i)->precalc_angles_flag = 1;

                else
                  if(j == 10)
                    (cp->xform + (signed long int)i)->precalc_angles_flag = 1;

                  else
                    if(j == 11)
                      (cp->xform + (signed long int)i)->precalc_angles_flag = 1;

                    else
                      if(j == 12)
                        (cp->xform + (signed long int)i)->precalc_atan_xy_flag = 1;

                      else
                        if(j == 13)
                          (cp->xform + (signed long int)i)->precalc_atan_xy_flag = 1;

                        else
                          if(j == 19)
                            (cp->xform + (signed long int)i)->precalc_angles_flag = 1;

                          else
                            if(j == 21)
                              (cp->xform + (signed long int)i)->precalc_angles_flag = 1;

                            else
                              if(j == 22)
                                (cp->xform + (signed long int)i)->precalc_atan_xy_flag = 1;

                              else
                                if(j == 23)
                                {
                                  (cp->xform + (signed long int)i)->precalc_atan_xy_flag = 1;
                                  (cp->xform + (signed long int)i)->precalc_angles_flag = 1;
                                }

                                else
                                  if(j == 25)
                                    (cp->xform + (signed long int)i)->precalc_atan_xy_flag = 1;

                                  else
                                    if(j == 26)
                                      (cp->xform + (signed long int)i)->precalc_angles_flag = 1;

                                    else
                                      if(j == 32)
                                        (cp->xform + (signed long int)i)->precalc_atan_yx_flag = 1;

                                      else
                                        if(j == 33)
                                          (cp->xform + (signed long int)i)->precalc_atan_yx_flag = 1;

                                        else
                                          if(j == 36)
                                            (cp->xform + (signed long int)i)->precalc_atan_yx_flag = 1;

                                          else
                                            if(j == 38)
                                              (cp->xform + (signed long int)i)->precalc_atan_yx_flag = 1;

                                            else
                                              if(j == 49)
                                                (cp->xform + (signed long int)i)->precalc_atan_xy_flag = 1;

                                              else
                                                if(j == 50)
                                                  (cp->xform + (signed long int)i)->precalc_atan_yx_flag = 1;

                                                else
                                                  if(j == 51)
                                                    (cp->xform + (signed long int)i)->precalc_atan_yx_flag = 1;

                                                  else
                                                    if(j == 52)
                                                      (cp->xform + (signed long int)i)->precalc_atan_yx_flag = 1;

                                                    else
                                                      if(j == 59)
                                                        (cp->xform + (signed long int)i)->precalc_atan_yx_flag = 1;

                                                      else
                                                        if(j == 63)
                                                          (cp->xform + (signed long int)i)->precalc_atan_yx_flag = 1;

                                                        else
                                                          if(j == 67)
                                                            (cp->xform + (signed long int)i)->has_preblur = (cp->xform + (signed long int)i)->var[(signed long int)j];

                                                          else
                                                            if(j == 70)
                                                              (cp->xform + (signed long int)i)->precalc_atan_xy_flag = 1;

                                                            else
                                                              if(j == 77)
                                                                (cp->xform + (signed long int)i)->precalc_atan_yx_flag = 1;

                                                              else
                                                                if(j == 78)
                                                                  (cp->xform + (signed long int)i)->precalc_atan_yx_flag = 1;

                                                                else
                                                                  if(j == 79)
                                                                    (cp->xform + (signed long int)i)->precalc_atan_yx_flag = 1;

                                                                  else
                                                                    if(j == 80)
                                                                      (cp->xform + (signed long int)i)->precalc_atan_yx_flag = 1;

                                                                    else
                                                                      if(j == 83)
                                                                        (cp->xform + (signed long int)i)->precalc_atan_yx_flag = 1;

        totnum = totnum + 1;
      }

    (cp->xform + (signed long int)i)->num_active_vars = totnum;

  __CPROVER_DUMP_L39:
    ;
  }
  return 0;
}

// radial_blur_precalc
// file variations.c line 1949
void radial_blur_precalc(struct xform *xf)
{
  sincos((xf->radial_blur_angle * 3.14159265358979323846) / 2.0, &xf->radialBlur_spinvar, &xf->radialBlur_zoomvar);
}

// random_var
// file flam3.c line 2933
static signed int random_var()
{
  signed long int return_value_random_1;
  return_value_random_1=random();
  return (signed int)(return_value_random_1 % (signed long int)98);
}

// random_varn
// file flam3.c line 2937
static signed int random_varn(signed int n)
{
  signed long int return_value_random_1;
  return_value_random_1=random();
  return (signed int)(return_value_random_1 % (signed long int)n);
}

// random_xform
// file palettes.c line 351
static signed int random_xform(struct anonymous_0 *g, signed int excluded)
{
  signed int ntries = 0;
  signed int tmp_post_1;
  do
  {
    tmp_post_1 = ntries;
    ntries = ntries + 1;
    if(tmp_post_1 >= 100)
      break;

    signed int i;
    signed long int return_value_random_2;
    return_value_random_2=random();
    i = (signed int)(return_value_random_2 % (signed long int)g->num_xforms);
    if((g->xform + (signed long int)i)->density > 0.0)
    {
      if(!(i == excluded))
        return i;

    }

  }
  while((_Bool)1);
  return -1;
}

// read_jpeg
// file jpeg.c line 102
unsigned char * read_jpeg(struct _IO_FILE *ifp, signed int *width, signed int *height)
{
  struct jpeg_decompress_struct cinfo;
  struct jpeg_error_mgr jerr;
  signed int num_scanlines;
  unsigned char *p;
  unsigned char *q;
  unsigned char *t;
  cinfo.err=jpeg_std_error(&jerr);
  jpeg_CreateDecompress(&cinfo, 62, (unsigned long int)sizeof(struct jpeg_decompress_struct) /*632ul*/ );
  jpeg_stdio_src(&cinfo, ifp);
  jpeg_read_header(&cinfo, 1);
  jpeg_start_decompress(&cinfo);
  *width = (signed int)cinfo.output_width;
  *height = (signed int)cinfo.output_height;
  if(!(cinfo.output_components == 3))
  {
    printf("can only read RGB JPEG files, not %d components.\n", cinfo.output_components);
    return ((unsigned char *)NULL);
  }

  else
  {
    void *return_value_malloc_1;
    return_value_malloc_1=malloc((unsigned long int)(4 * *width * *height));
    q = (unsigned char *)return_value_malloc_1;
    p = q;
    void *return_value_malloc_2;
    return_value_malloc_2=malloc((unsigned long int)(3 * *width));
    t = (unsigned char *)return_value_malloc_2;
    while(!(cinfo.output_scanline >= cinfo.output_height))
    {
      unsigned char *s = t;
      signed int i;
      unsigned int return_value_jpeg_read_scanlines_3;
      return_value_jpeg_read_scanlines_3=jpeg_read_scanlines(&cinfo, &t, (unsigned int)1);
      num_scanlines = (signed int)return_value_jpeg_read_scanlines_3;
      i = 0;
      for( ; !(i >= *width); i = i + 1)
      {
        p[(signed long int)0] = s[(signed long int)0];
        p[(signed long int)1] = s[(signed long int)1];
        p[(signed long int)2] = s[(signed long int)2];
        p[(signed long int)3] = (unsigned char)255;
        s = s + (signed long int)3;
        p = p + (signed long int)4;
      }
    }
    jpeg_finish_decompress(&cinfo);
    jpeg_destroy_decompress(&cinfo);
    free((void *)t);
    return q;
  }
}

// read_png
// file png.c line 121
unsigned char * read_png(struct _IO_FILE *ifp, signed int *width, signed int *height)
{
  unsigned char sig_buf[8l];
  struct png_struct_def *png_ptr;
  struct png_info_struct *info_ptr;
  unsigned char **png_image = (unsigned char **)(void *)0;
  unsigned int linesize;
  unsigned int x;
  unsigned int y;
  unsigned char *p;
  unsigned char *q;
  signed int bit_depth;
  signed int color_type;
  unsigned long int return_value_fread_1;
  return_value_fread_1=fread((void *)sig_buf, (unsigned long int)1, (unsigned long int)8, ifp);
  if(!(return_value_fread_1 == 8ul))
  {
    fprintf(stderr, "input file empty or too short\n");
    return ((unsigned char *)NULL);
  }

  else
  {
    signed int return_value_png_sig_cmp_2;
    return_value_png_sig_cmp_2=png_sig_cmp(sig_buf, (unsigned long int)0, (unsigned long int)8);
    if(!(return_value_png_sig_cmp_2 == 0))
    {
      fprintf(stderr, "input file not a PNG file\n");
      return ((unsigned char *)NULL);
    }

    else
    {
      png_ptr=png_create_read_struct("1.2.54", (void *)0, (void (*)(struct png_struct_def *, const char *))(void *)0, (void (*)(struct png_struct_def *, const char *))(void *)0);
      if(png_ptr == ((struct png_struct_def *)NULL))
      {
        fprintf(stderr, "cannot allocate LIBPNG structure\n");
        return ((unsigned char *)NULL);
      }

      else
      {
        signed int return_value__setjmp_4;
        return_value__setjmp_4=_setjmp(png_ptr->jmpbuf);
        if(!(return_value__setjmp_4 == 0))
        {
          signed int height_temp;
          unsigned long int return_value_png_get_image_height_3;
          return_value_png_get_image_height_3=png_get_image_height(png_ptr, info_ptr);
          height_temp = (signed int)return_value_png_get_image_height_3;
          if(!(png_image == ((unsigned char **)NULL)))
          {
            y = (unsigned int)0;
            for( ; !(y >= (unsigned int)height_temp); y = y + 1u)
              free((void *)png_image[(signed long int)y]);
            free((void *)png_image);
          }

          png_destroy_read_struct(&png_ptr, &info_ptr, (struct png_info_struct **)(void *)0);
          perror("reading file");
          return ((unsigned char *)NULL);
        }

        info_ptr=png_create_info_struct(png_ptr);
        if(info_ptr == ((struct png_info_struct *)NULL))
        {
          png_destroy_read_struct(&png_ptr, (struct png_info_struct **)(void *)0, (struct png_info_struct **)(void *)0);
          fprintf(stderr, "cannot allocate LIBPNG structures\n");
          return ((unsigned char *)NULL);
        }

        else
        {
          png_init_io(png_ptr, ifp);
          png_set_sig_bytes(png_ptr, 8);
          png_read_info(png_ptr, info_ptr);
          unsigned char return_value_png_get_bit_depth_5;
          return_value_png_get_bit_depth_5=png_get_bit_depth(png_ptr, info_ptr);
          bit_depth = (signed int)return_value_png_get_bit_depth_5;
          if(!(bit_depth == 8))
          {
            fprintf(stderr, "bit depth type must be 8, not %d.\n", bit_depth);
            return ((unsigned char *)NULL);
          }

          else
          {
            unsigned long int return_value_png_get_image_width_6;
            return_value_png_get_image_width_6=png_get_image_width(png_ptr, info_ptr);
            *width = (signed int)return_value_png_get_image_width_6;
            unsigned long int return_value_png_get_image_height_7;
            return_value_png_get_image_height_7=png_get_image_height(png_ptr, info_ptr);
            *height = (signed int)return_value_png_get_image_height_7;
            linesize = (unsigned int)*height;
            void *return_value_malloc_8;
            return_value_malloc_8=malloc((unsigned long int)(4 * *width * *height));
            q = (unsigned char *)return_value_malloc_8;
            p = q;
            void *return_value_malloc_9;
            return_value_malloc_9=malloc((unsigned long int)*height * sizeof(unsigned char *) /*8ul*/ );
            png_image = (unsigned char **)return_value_malloc_9;
            unsigned char return_value_png_get_color_type_10;
            return_value_png_get_color_type_10=png_get_color_type(png_ptr, info_ptr);
            color_type = (signed int)return_value_png_get_color_type_10;
            if(!(color_type == 2))
            {
              if(color_type == 6)
                goto __CPROVER_DUMP_L11;

            }

            else
            {
              linesize = linesize * (unsigned int)3;
              goto __CPROVER_DUMP_L13;

            __CPROVER_DUMP_L11:
              ;
              linesize = linesize * (unsigned int)4;
              goto __CPROVER_DUMP_L13;
            }
            fprintf(stderr, "color type must be RGB or RGBA not %d.\n", color_type);
            return ((unsigned char *)NULL);

          __CPROVER_DUMP_L13:
            ;
            y = (unsigned int)0;
            for( ; !(y >= (unsigned int)*height); y = y + 1u)
            {
              void *return_value_malloc_11;
              return_value_malloc_11=malloc((unsigned long int)linesize);
              png_image[(signed long int)y] = (unsigned char *)return_value_malloc_11;
            }
            png_read_image(png_ptr, png_image);
            png_read_end(png_ptr, info_ptr);
            y = (unsigned int)0;
            for( ; !(y >= (unsigned int)*height); y = y + 1u)
            {
              unsigned char *s = png_image[(signed long int)y];
              x = (unsigned int)0;
              for( ; !(x >= (unsigned int)*width); x = x + 1u)
              {
                if(!(color_type == 2))
                {
                  if(color_type == 6)
                    goto __CPROVER_DUMP_L19;

                }

                else
                {
                  p[(signed long int)0] = s[(signed long int)0];
                  p[(signed long int)1] = s[(signed long int)1];
                  p[(signed long int)2] = s[(signed long int)2];
                  p[(signed long int)3] = (unsigned char)255;
                  s = s + (signed long int)3;
                  p = p + (signed long int)4;
                  goto __CPROVER_DUMP_L20;

                __CPROVER_DUMP_L19:
                  ;
                  p[(signed long int)0] = s[(signed long int)0];
                  p[(signed long int)1] = s[(signed long int)1];
                  p[(signed long int)2] = s[(signed long int)2];
                  p[(signed long int)3] = s[(signed long int)3];
                  s = s + (signed long int)4;
                  p = p + (signed long int)4;
                }

              __CPROVER_DUMP_L20:
                ;
              }
            }
            y = (unsigned int)0;
            for( ; !(y >= (unsigned int)*height); y = y + 1u)
              free((void *)png_image[(signed long int)y]);
            free((void *)png_image);
            png_destroy_read_struct(&png_ptr, &info_ptr, (struct png_info_struct **)(void *)0);
            return q;
          }
        }
      }
    }
  }
}

// render_rectangle_double
// file rect.c line 527
static signed int render_rectangle_double(struct anonymous_4 *spec, void *out, signed int field, signed int nchan, signed int transp, struct anonymous_8 *stats)
{
  signed long int nbuckets;
  signed int i;
  signed int j;
  signed int render_rectangle_double__1__k;
  signed int batch_num;
  signed int temporal_sample_num;
  double nsamples;
  double batch_size;
  double (*buckets)[5l];
  double (*accumulate)[4l];
  double *points;
  double *filter;
  double *temporal_filter;
  double *temporal_deltas;
  double *batch_filter;
  double ppux = (double)0;
  double ppuy = (double)0;
  signed int image_width;
  signed int image_height;
  signed int out_width;
  signed int filter_width = 0;
  signed int bytes_per_channel = spec->bytes_per_channel;
  signed int oversample;
  double highpow;
  signed int nbatches;
  signed int ntemporal_samples;
  struct anonymous_1 dmap[256l];
  signed int gutter_width;
  double vibrancy = 0.0;
  double gamma = 0.0;
  double background[3l];
  signed int vib_gam_n = 0;
  signed long int progress_began = (signed long int)0;
  signed int render_rectangle_double__1__verbose = spec->verbose;
  signed int gnm_idx;
  signed int max_gnm_de_fw;
  signed int de_offset;
  struct anonymous_0 cp;
  unsigned short int *xform_distrib;
  struct anonymous_12 fic;
  struct anonymous_13 *fth;
  union pthread_attr_t pt_attr;
  unsigned long int *myThreads = (unsigned long int *)(void *)0;
  signed int thread_status;
  signed int thi;
  signed long int tstart;
  signed long int tend;
  double sumfilt;
  char *last_block;
  unsigned long int memory_rqd;
  signed long int progress_timer = (signed long int)0;
  signed long int progress_timer_history[64l];
  double progress_history[64l];
  signed int progress_history_mark = 0;
  tstart=time((signed long int *)(void *)0);
  fic.badvals = (double)0;
  fic.aborted = 0;
  stats->num_iters = (signed long int)0;
  memset((void *)&cp, 0, sizeof(struct anonymous_0) /*10712ul*/ );
  flam3_interpolate(spec->genomes, spec->ngenomes, spec->time, (double)0, &cp);
  oversample = cp.spatial_oversample;
  highpow = cp.highlight_power;
  nbatches = cp.nbatches;
  ntemporal_samples = cp.ntemporal_samples;
  unsigned long int tmp_post_7;
  unsigned long int tmp_if_expr_8;
  if(!(nbatches >= 1))
  {
    fprintf(stderr, "nbatches must be positive, not %d.\n", nbatches);
    return 1;
  }

  else
    if(!(oversample >= 1))
    {
      fprintf(stderr, "oversample must be positive, not %d.\n", oversample);
      return 1;
    }

    else
    {
      void *return_value_calloc_1;
      return_value_calloc_1=calloc((unsigned long int)spec->nthreads, sizeof(struct anonymous_13) /*11024ul*/ );
      fth = (struct anonymous_13 *)return_value_calloc_1;
      i = 0;
      for( ; !(i >= spec->nthreads); i = i + 1)
        (fth + (signed long int)i)->cp.final_xform_index = -1;
      image_width = cp.width;
      out_width = image_width;
      if(!(field == 0))
      {
        image_height = cp.height / 2;
        if(field == 2)
          out = (void *)((unsigned char *)out + (signed long int)(nchan * bytes_per_channel * out_width));

        out_width = out_width * 2;
      }

      else
        image_height = cp.height;
      filter_width=flam3_create_spatial_filter(spec, field, &filter);
      if(!(filter_width >= 0))
      {
        fprintf(stderr, "flam3_create_spatial_filter returned error: aborting\n");
        return 1;
      }

      else
      {
        void *return_value_malloc_2;
        return_value_malloc_2=malloc(sizeof(double) /*8ul*/  * (unsigned long int)nbatches);
        batch_filter = (double *)return_value_malloc_2;
        i = 0;
        for( ; !(i >= nbatches); i = i + 1)
          batch_filter[(signed long int)i] = 1.0 / (double)nbatches;
        sumfilt=flam3_create_temporal_filter(nbatches * ntemporal_samples, cp.temporal_filter_type, cp.temporal_filter_exp, cp.temporal_filter_width, &temporal_filter, &temporal_deltas);
        gutter_width = (filter_width - oversample) / 2;
        max_gnm_de_fw = 0;
        gnm_idx = 0;
        for( ; !(gnm_idx >= spec->ngenomes); gnm_idx = gnm_idx + 1)
        {
          signed int this_width;
          double return_value_ceil_3;
          return_value_ceil_3=ceil((spec->genomes + (signed long int)gnm_idx)->estimator);
          this_width = (signed int)return_value_ceil_3 * oversample;
          if(!(max_gnm_de_fw >= this_width))
            max_gnm_de_fw = this_width;

        }
        if(max_gnm_de_fw >= 1)
          max_gnm_de_fw = max_gnm_de_fw + (oversample - 1);

        if(!(gutter_width >= max_gnm_de_fw))
        {
          de_offset = max_gnm_de_fw - gutter_width;
          gutter_width = max_gnm_de_fw;
        }

        else
          de_offset = 0;
        fic.height = oversample * image_height + 2 * gutter_width;
        fic.width = oversample * image_width + 2 * gutter_width;
        nbuckets = (signed long int)fic.width * (signed long int)fic.height;
        memory_rqd = sizeof(double [5l]) /*40ul*/  * (unsigned long int)nbuckets + sizeof(double [4l]) /*32ul*/  * (unsigned long int)nbuckets + (unsigned long int)4 * sizeof(double) /*8ul*/  * (unsigned long int)spec->sub_batch_size * (unsigned long int)spec->nthreads;
        void *return_value_malloc_4;
        return_value_malloc_4=malloc(memory_rqd);
        last_block = (char *)return_value_malloc_4;
        if(last_block == ((char *)NULL))
        {
          fprintf(stderr, "render_rectangle: cannot malloc %g bytes.\n", (double)memory_rqd);
          fprintf(stderr, "render_rectangle: w=%d h=%d nb=%ld.\n", fic.width, fic.height, nbuckets);
          return 1;
        }

        else
        {
          buckets = (double (*)[5l])last_block;
          accumulate = (double (*)[4l])(last_block + (signed long int)(sizeof(double [5l]) /*40ul*/  * (unsigned long int)nbuckets));
          points = (double *)(last_block + (signed long int)((sizeof(double [5l]) /*40ul*/  + sizeof(double [4l]) /*32ul*/ ) * (unsigned long int)nbuckets));
          if(!(render_rectangle_double__1__verbose == 0))
          {
            fprintf(stderr, "chaos: ");
            progress_began=time((signed long int *)(void *)0);
          }

          background[(signed long int)2] = 0.0;
          background[(signed long int)1] = background[(signed long int)2];
          background[(signed long int)0] = background[(signed long int)1];
          memset((void *)(char *)accumulate, 0, sizeof(double [4l]) /*32ul*/  * (unsigned long int)nbuckets);
          batch_num = 0;
          for( ; !(batch_num >= nbatches); batch_num = batch_num + 1)
          {
            double de_time;
            double sample_density = 0.0;
            double k1;
            double area;
            double k2;
            struct anonymous_6 de;
            de_time = spec->time + temporal_deltas[(signed long int)(batch_num * ntemporal_samples)];
            memset((void *)(char *)buckets, 0, sizeof(double [5l]) /*40ul*/  * (unsigned long int)nbuckets);
            flam3_interpolate(spec->genomes, spec->ngenomes, de_time, (double)0, &cp);
            if(cp.estimator < 0.0 || cp.estimator_minimum < 0.0)
            {
              fprintf(stderr, "density estimator filter widths must be >= 0\n");
              return 1;
            }

            if(!(spec->bits >= 33))
            {
              if(cp.estimator > 0.0)
              {
                fprintf(stderr, "warning: density estimation disabled with %d bit buffers.\n", spec->bits);
                cp.estimator = 0.0;
              }

            }

            if(cp.estimator > 0.0)
            {
              de=flam3_create_de_filters(cp.estimator, cp.estimator_minimum, cp.estimator_curve, oversample);
              if(!(de.kernel_size >= 0))
              {
                fprintf(stderr, "de.kernel_size returned 0 - aborting.\n");
                return 1;
              }

            }

            else
              de.max_filter_index = 0;
            temporal_sample_num = 0;
            for( ; !(temporal_sample_num >= ntemporal_samples); temporal_sample_num = temporal_sample_num + 1)
            {
              double temporal_sample_time;
              double color_scalar = temporal_filter[(signed long int)(batch_num * ntemporal_samples + temporal_sample_num)];
              temporal_sample_time = spec->time + temporal_deltas[(signed long int)(batch_num * ntemporal_samples + temporal_sample_num)];
              flam3_interpolate(spec->genomes, spec->ngenomes, temporal_sample_time, (double)0, &cp);
              signed int return_value_prepare_precalc_flags_5;
              return_value_prepare_precalc_flags_5=prepare_precalc_flags(&cp);
              if(!(return_value_prepare_precalc_flags_5 == 0))
              {
                fprintf(stderr, "prepare xform pointers returned error: aborting.\n");
                return 1;
              }

              xform_distrib=flam3_create_xform_distrib(&cp);
              if(xform_distrib == ((unsigned short int *)NULL))
              {
                fprintf(stderr, "create xform distrib returned error: aborting.\n");
                return 1;
              }

              j = 0;
              for( ; !(j >= 256); j = j + 1)
              {
                dmap[(signed long int)j].index = cp.palette[(signed long int)((j * 256) / 256)].index / 256.0;
                render_rectangle_double__1__k = 0;
                for( ; !(render_rectangle_double__1__k >= 4); render_rectangle_double__1__k = render_rectangle_double__1__k + 1)
                  dmap[(signed long int)j].color[(signed long int)render_rectangle_double__1__k] = cp.palette[(signed long int)((j * 256) / 256)].color[(signed long int)render_rectangle_double__1__k] * (double)255 * color_scalar;
              }
              {
                double t0;
                double t1;
                double shift = 0.0;
                double corner0;
                double corner1;
                double scale;
                if(cp.sample_density <= 0.0)
                {
                  fprintf(stderr, "sample density (quality) must be greater than zero, not %g.\n", cp.sample_density);
                  return 1;
                }

                scale=pow(2.0, cp.zoom);
                sample_density = cp.sample_density * scale * scale;
                ppux = cp.pixels_per_unit * scale;
                ppuy = field != 0 ? ppux / 2.0 : ppux;
                ppux = ppux / spec->pixel_aspect_ratio;
                switch(field)
                {
                  case 0:
                  {
                    shift = 0.0;
                    break;
                  }
                  case 1:
                  {
                    shift = -0.5;
                    break;
                  }
                  case 2:
                    shift = 0.5;
                }
                shift = shift / ppux;
                t0 = (double)gutter_width / ((double)oversample * ppux);
                t1 = (double)gutter_width / ((double)oversample * ppuy);
                corner0 = cp.center[(signed long int)0] - ((double)image_width / ppux) / 2.0;
                corner1 = cp.center[(signed long int)1] - ((double)image_height / ppuy) / 2.0;
                fic.bounds[(signed long int)0] = corner0 - t0;
                fic.bounds[(signed long int)1] = (corner1 - t1) + shift;
                fic.bounds[(signed long int)2] = corner0 + (double)image_width / ppux + t0;
                fic.bounds[(signed long int)3] = corner1 + (double)image_height / ppuy + t1 + shift;
                fic.size[(signed long int)0] = 1.0 / (fic.bounds[(signed long int)2] - fic.bounds[(signed long int)0]);
                fic.size[(signed long int)1] = 1.0 / (fic.bounds[(signed long int)3] - fic.bounds[(signed long int)1]);
                fic.rot[(signed long int)0][(signed long int)0]=cos((cp.rotate * (double)2 * 3.14159265358979323846) / 360.0);
                double return_value_sin_6;
                return_value_sin_6=sin((cp.rotate * (double)2 * 3.14159265358979323846) / 360.0);
                fic.rot[(signed long int)0][(signed long int)1] = -return_value_sin_6;
                fic.rot[(signed long int)1][(signed long int)0] = -fic.rot[(signed long int)0][(signed long int)1];
                fic.rot[(signed long int)1][(signed long int)1] = fic.rot[(signed long int)0][(signed long int)0];
                fic.ws0 = (double)fic.width * fic.size[(signed long int)0];
                fic.wb0s0 = fic.ws0 * fic.bounds[(signed long int)0];
                fic.hs1 = (double)fic.height * fic.size[(signed long int)1];
                fic.hb1s1 = fic.hs1 * fic.bounds[(signed long int)1];
              }
              nsamples = sample_density * (double)image_width * (double)image_height;
              batch_size = nsamples / (double)(nbatches * ntemporal_samples);
              stats->num_iters = stats->num_iters + (signed long int)batch_size;
              fic.xform_distrib = xform_distrib;
              fic.spec = spec;
              fic.batch_size = batch_size / (double)spec->nthreads;
              fic.temporal_sample_num = temporal_sample_num;
              fic.ntemporal_samples = ntemporal_samples;
              fic.batch_num = batch_num;
              fic.nbatches = nbatches;
              fic.dmap = (struct anonymous_1 *)dmap;
              fic.color_scalar = color_scalar;
              fic.buckets = (void *)buckets;
              fic.progress_timer = &progress_timer;
              fic.progress_timer_history = &progress_timer_history[(signed long int)0];
              fic.progress_history = &progress_history[(signed long int)0];
              fic.progress_history_mark = &progress_history_mark;
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
              {
                signed int rk = 0;
                for( ; !(rk >= 16); rk = rk + 1)
                {
                  tmp_post_7 = (&spec->rc)->randcnt;
                  (&spec->rc)->randcnt = (&spec->rc)->randcnt - 1ul;
                  if(tmp_post_7 == 0ul)
                  {
                    isaac(&spec->rc);
                    (&spec->rc)->randcnt = (unsigned long int)((1 << 4) - 1);
                    tmp_if_expr_8 = (&spec->rc)->randrsl[(signed long int)(&spec->rc)->randcnt];
                  }

                  else
                    tmp_if_expr_8 = (&spec->rc)->randrsl[(signed long int)(&spec->rc)->randcnt];
                  (fth + (signed long int)thi)->rc.randrsl[(signed long int)rk] = tmp_if_expr_8;
                }
                irandinit(&(fth + (signed long int)thi)->rc, 1);
                if(thi == 0)
                {
                  (fth + (signed long int)thi)->first_thread = 1;
                  if(batch_num == 0 && temporal_sample_num == 0)
                    (fth + (signed long int)thi)->timer_initialize = 1;

                  else
                    (fth + (signed long int)thi)->timer_initialize = 0;
                }

                else
                {
                  (fth + (signed long int)thi)->first_thread = 0;
                  (fth + (signed long int)thi)->timer_initialize = 0;
                }
                (fth + (signed long int)thi)->iter_storage = &points[(signed long int)(thi * spec->sub_batch_size * 4)];
                (fth + (signed long int)thi)->fic = &fic;
                flam3_copy(&(fth + (signed long int)thi)->cp, &cp);
              }
              void *return_value_malloc_9;
              return_value_malloc_9=malloc((unsigned long int)spec->nthreads * sizeof(unsigned long int) /*8ul*/ );
              myThreads = (unsigned long int *)return_value_malloc_9;
              pthread_mutex_init(&fic.bucket_mutex, (const union anonymous_11 *)(void *)0);
              pthread_attr_init(&pt_attr);
              pthread_attr_setdetachstate(&pt_attr, 0);
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
                pthread_create(&myThreads[(signed long int)thi], &pt_attr, (void * (*)(void *))(void *)iter_thread_double, (void *)&fth[(signed long int)thi]);
              pthread_attr_destroy(&pt_attr);
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
                pthread_join(myThreads[(signed long int)thi], (void **)&thread_status);
              pthread_mutex_destroy(&fic.bucket_mutex);
              free((void *)myThreads);
              free((void *)xform_distrib);
              if(!(fic.aborted == 0))
              {
                if(!(render_rectangle_double__1__verbose == 0))
                  fprintf(stderr, "\naborted!\n");

                goto done;
              }

              vibrancy = vibrancy + cp.vibrancy;
              gamma = gamma + cp.gamma;
              background[(signed long int)0] = background[(signed long int)0] + cp.background[(signed long int)0];
              background[(signed long int)1] = background[(signed long int)1] + cp.background[(signed long int)1];
              background[(signed long int)2] = background[(signed long int)2] + cp.background[(signed long int)2];
              vib_gam_n = vib_gam_n + 1;
            }
            k1 = (cp.contrast * cp.brightness * (double)255 * 268.0 * batch_filter[(signed long int)batch_num]) / (double)256;
            area = (double)(image_width * image_height) / (ppux * ppuy);
            k2 = (double)(oversample * oversample * nbatches) / (cp.contrast * area * (double)255 * sample_density * sumfilt);
            if(de.max_filter_index == 0)
            {
              j = 0;
              for( ; !(j >= fic.height); j = j + 1)
              {
                i = 0;
                for( ; !(i >= fic.width); i = i + 1)
                {
                  double (*render_rectangle_double__1__11__1__5__1__1__1__1__a)[4l] = accumulate + (signed long int)i + (signed long int)(j * fic.width);
                  double (*b)[5l] = buckets + (signed long int)i + (signed long int)(j * fic.width);
                  double c[4l];
                  double render_rectangle_double__1__11__1__5__1__1__1__1__ls;
                  c[(signed long int)0] = (double)b[(signed long int)0][(signed long int)0];
                  c[(signed long int)1] = (double)b[(signed long int)0][(signed long int)1];
                  c[(signed long int)2] = (double)b[(signed long int)0][(signed long int)2];
                  c[(signed long int)3] = (double)b[(signed long int)0][(signed long int)3];
                  if(!IEEE_FLOAT_EQUAL(0.0, c[3l]))
                  {
                    double return_value_log_10;
                    return_value_log_10=log(1.0 + c[(signed long int)3] * k2);
                    render_rectangle_double__1__11__1__5__1__1__1__1__ls = (k1 * return_value_log_10) / c[(signed long int)3];
                    c[(signed long int)0] = c[(signed long int)0] * render_rectangle_double__1__11__1__5__1__1__1__1__ls;
                    c[(signed long int)1] = c[(signed long int)1] * render_rectangle_double__1__11__1__5__1__1__1__1__ls;
                    c[(signed long int)2] = c[(signed long int)2] * render_rectangle_double__1__11__1__5__1__1__1__1__ls;
                    c[(signed long int)3] = c[(signed long int)3] * render_rectangle_double__1__11__1__5__1__1__1__1__ls;
                    do
                      render_rectangle_double__1__11__1__5__1__1__1__1__a[(signed long int)0][(signed long int)0] = render_rectangle_double__1__11__1__5__1__1__1__1__a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                    while((_Bool)0);
                    do
                      render_rectangle_double__1__11__1__5__1__1__1__1__a[(signed long int)0][(signed long int)1] = render_rectangle_double__1__11__1__5__1__1__1__1__a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                    while((_Bool)0);
                    do
                      render_rectangle_double__1__11__1__5__1__1__1__1__a[(signed long int)0][(signed long int)2] = render_rectangle_double__1__11__1__5__1__1__1__1__a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                    while((_Bool)0);
                    do
                      render_rectangle_double__1__11__1__5__1__1__1__1__a[(signed long int)0][(signed long int)3] = render_rectangle_double__1__11__1__5__1__1__1__1__a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                    while((_Bool)0);
                  }

                }
              }
            }

            else
            {
              struct anonymous_15 *deth;
              signed int de_aborted = 0;
              signed int myspan = (fic.height - 2 * (oversample - 1)) + 1;
              signed int swath = myspan / spec->nthreads;
              void *return_value_calloc_11;
              return_value_calloc_11=calloc((unsigned long int)spec->nthreads, sizeof(struct anonymous_15) /*104ul*/ );
              deth = (struct anonymous_15 *)return_value_calloc_11;
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
              {
                (deth + (signed long int)thi)->b = buckets;
                (deth + (signed long int)thi)->accumulate = accumulate;
                (deth + (signed long int)thi)->width = fic.width;
                (deth + (signed long int)thi)->height = fic.height;
                (deth + (signed long int)thi)->oversample = oversample;
                (deth + (signed long int)thi)->progress_size = spec->sub_batch_size / 10;
                (deth + (signed long int)thi)->de = &de;
                (deth + (signed long int)thi)->k1 = k1;
                (deth + (signed long int)thi)->k2 = k2;
                (deth + (signed long int)thi)->curve = cp.estimator_curve;
                (deth + (signed long int)thi)->spec = spec;
                (deth + (signed long int)thi)->aborted = &de_aborted;
                if(!(myspan >= spec->nthreads))
                {
                  (deth + (signed long int)thi)->start_row = 0;
                  if(thi == spec->nthreads + -1)
                  {
                    (deth + (signed long int)thi)->end_row = myspan;
                    (deth + (signed long int)thi)->last_thread = 1;
                  }

                  else
                  {
                    (deth + (signed long int)thi)->end_row = -1;
                    (deth + (signed long int)thi)->last_thread = 0;
                  }
                }

                else
                {
                  (deth + (signed long int)thi)->start_row = thi * swath;
                  (deth + (signed long int)thi)->end_row = (thi + 1) * swath;
                  if(thi == spec->nthreads + -1)
                  {
                    (deth + (signed long int)thi)->end_row = myspan;
                    (deth + (signed long int)thi)->last_thread = 1;
                  }

                  else
                    (deth + (signed long int)thi)->last_thread = 0;
                }
              }
              void *return_value_malloc_12;
              return_value_malloc_12=malloc((unsigned long int)spec->nthreads * sizeof(unsigned long int) /*8ul*/ );
              myThreads = (unsigned long int *)return_value_malloc_12;
              pthread_attr_init(&pt_attr);
              pthread_attr_setdetachstate(&pt_attr, 0);
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
                pthread_create(&myThreads[(signed long int)thi], &pt_attr, (void * (*)(void *))(void *)de_thread_64, (void *)&deth[(signed long int)thi]);
              pthread_attr_destroy(&pt_attr);
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
                pthread_join(myThreads[(signed long int)thi], (void **)&thread_status);
              free((void *)myThreads);
              free((void *)deth);
              if(!(de_aborted == 0))
              {
                if(!(render_rectangle_double__1__verbose == 0))
                  fprintf(stderr, "\naborted!\n");

                goto done;
              }

            }
            if(de.max_filter_index >= 1)
            {
              free((void *)de.filter_coefs);
              free((void *)de.filter_widths);
            }

          }
          if(!(render_rectangle_double__1__verbose == 0))
          {
            signed long int return_value_time_13;
            return_value_time_13=time((signed long int *)(void *)0);
            fprintf(stderr, "\rchaos: 100.0%%  took: %ld seconds   \n", return_value_time_13 - progress_began);
            fprintf(stderr, "filtering...");
          }

          {
            signed int x;
            signed int y;
            double t[4l];
            double newrgb[3l];
            double g = 1.0 / (gamma / (double)vib_gam_n);
            double tmp;
            double a;
            double alpha;
            double ls;
            signed int rgbi;
            double linrange = cp.gam_lin_thresh;
            vibrancy = vibrancy / (double)vib_gam_n;
            background[(signed long int)0] = background[(signed long int)0] / ((double)vib_gam_n / 256.0);
            background[(signed long int)1] = background[(signed long int)1] / ((double)vib_gam_n / 256.0);
            background[(signed long int)2] = background[(signed long int)2] / ((double)vib_gam_n / 256.0);
            if(!(spec->earlyclip == 0))
            {
              j = 0;
              for( ; !(j >= fic.height); j = j + 1)
              {
                i = 0;
                for( ; !(i >= fic.width); i = i + 1)
                {
                  double (*ac)[4l] = accumulate + (signed long int)i + (signed long int)(j * fic.width);
                  if((*ac)[3l] <= 0.000000)
                  {
                    alpha = 0.0;
                    ls = 0.0;
                  }

                  else
                  {
                    tmp = ac[(signed long int)0][(signed long int)3] / (double)255;
                    alpha=flam3_calc_alpha(tmp, g, linrange);
                    ls = (vibrancy * 256.0 * alpha) / tmp;
                    if(alpha < 0.0)
                      alpha = 0.0;

                    if(alpha > 1.0)
                      alpha = 1.0;

                  }
                  t[(signed long int)0] = (double)ac[(signed long int)0][(signed long int)0];
                  t[(signed long int)1] = (double)ac[(signed long int)0][(signed long int)1];
                  t[(signed long int)2] = (double)ac[(signed long int)0][(signed long int)2];
                  t[(signed long int)3] = (double)ac[(signed long int)0][(signed long int)3];
                  flam3_calc_newrgb(t, ls, highpow, newrgb);
                  rgbi = 0;
                  for( ; !(rgbi >= 3); rgbi = rgbi + 1)
                  {
                    a = newrgb[(signed long int)rgbi];
                    double return_value_pow_14;
                    return_value_pow_14=pow(t[(signed long int)rgbi] / (double)255, g);
                    a = a + (1.0 - vibrancy) * 256.0 * return_value_pow_14;
                    if(transp == 0 || !(nchan >= 4))
                      a = a + (1.0 - alpha) * background[(signed long int)rgbi];

                    else
                      if(alpha > 0.000000)
                        a = a / alpha;

                      else
                        a = (double)0;
                    if(a > 255.000000)
                      a = (double)255;

                    if(a < 0.000000)
                      a = (double)0;

                    ac[(signed long int)0][(signed long int)rgbi] = a;
                  }
                  ac[(signed long int)0][(signed long int)3] = alpha;
                }
              }
            }

            y = de_offset;
            j = 0;
            for( ; !(j >= image_height); j = j + 1)
            {
              x = de_offset;
              i = 0;
              for( ; !(i >= image_width); i = i + 1)
              {
                signed int ii;
                signed int jj;
                signed int render_rectangle_double__1__13__2__1__1__1__rgbi;
                void *p;
                unsigned short int *p16;
                unsigned char *p8;
                t[(signed long int)3] = 0.0;
                t[(signed long int)2] = t[(signed long int)3];
                t[(signed long int)1] = t[(signed long int)2];
                t[(signed long int)0] = t[(signed long int)1];
                ii = 0;
                for( ; !(ii >= filter_width); ii = ii + 1)
                {
                  jj = 0;
                  for( ; !(jj >= filter_width); jj = jj + 1)
                  {
                    double k = filter[(signed long int)(ii + jj * filter_width)];
                    double (*render_rectangle_double__1__13__2__1__1__1__1__1__1__1__ac)[4l] = accumulate + (signed long int)x + (signed long int)ii + (signed long int)((y + jj) * fic.width);
                    t[(signed long int)0] = t[(signed long int)0] + k * render_rectangle_double__1__13__2__1__1__1__1__1__1__1__ac[(signed long int)0][(signed long int)0];
                    t[(signed long int)1] = t[(signed long int)1] + k * render_rectangle_double__1__13__2__1__1__1__1__1__1__1__ac[(signed long int)0][(signed long int)1];
                    t[(signed long int)2] = t[(signed long int)2] + k * render_rectangle_double__1__13__2__1__1__1__1__1__1__1__ac[(signed long int)0][(signed long int)2];
                    t[(signed long int)3] = t[(signed long int)3] + k * render_rectangle_double__1__13__2__1__1__1__1__1__1__1__ac[(signed long int)0][(signed long int)3];
                  }
                }
                p = (void *)((unsigned char *)out + (signed long int)(nchan * bytes_per_channel * (i + j * out_width)));
                p8 = (unsigned char *)p;
                p16 = (unsigned short int *)p;
                if(spec->earlyclip == 0)
                {
                  tmp = t[(signed long int)3] / (double)255;
                  if(t[3l] <= 0.000000)
                  {
                    alpha = 0.0;
                    ls = 0.0;
                  }

                  else
                  {
                    alpha=flam3_calc_alpha(tmp, g, linrange);
                    ls = (vibrancy * 256.0 * alpha) / tmp;
                    if(alpha < 0.0)
                      alpha = 0.0;

                    if(alpha > 1.0)
                      alpha = 1.0;

                  }
                  flam3_calc_newrgb(t, ls, highpow, newrgb);
                  render_rectangle_double__1__13__2__1__1__1__rgbi = 0;
                  for( ; !(render_rectangle_double__1__13__2__1__1__1__rgbi >= 3); render_rectangle_double__1__13__2__1__1__1__rgbi = render_rectangle_double__1__13__2__1__1__1__rgbi + 1)
                  {
                    a = newrgb[(signed long int)render_rectangle_double__1__13__2__1__1__1__rgbi];
                    double return_value_pow_15;
                    return_value_pow_15=pow(t[(signed long int)render_rectangle_double__1__13__2__1__1__1__rgbi] / (double)255, g);
                    a = a + (1.0 - vibrancy) * 256.0 * return_value_pow_15;
                    if(transp == 0 || !(nchan >= 4))
                      a = a + (1.0 - alpha) * background[(signed long int)render_rectangle_double__1__13__2__1__1__1__rgbi];

                    else
                      if(alpha > 0.000000)
                        a = a / alpha;

                      else
                        a = (double)0;
                    if(a > 255.000000)
                      a = (double)255;

                    if(a < 0.000000)
                      a = (double)0;

                    t[(signed long int)render_rectangle_double__1__13__2__1__1__1__rgbi] = a;
                  }
                  t[(signed long int)3] = alpha;
                }

                render_rectangle_double__1__13__2__1__1__1__rgbi = 0;
                for( ; !(render_rectangle_double__1__13__2__1__1__1__rgbi >= 3); render_rectangle_double__1__13__2__1__1__1__rgbi = render_rectangle_double__1__13__2__1__1__1__rgbi + 1)
                {
                  a = t[(signed long int)render_rectangle_double__1__13__2__1__1__1__rgbi];
                  if(a > 255.000000)
                    a = (double)255;

                  if(a < 0.000000)
                    a = (double)0;

                  if(bytes_per_channel == 2)
                  {
                    a = a * 256.0;
                    p16[(signed long int)render_rectangle_double__1__13__2__1__1__1__rgbi] = (unsigned short int)a;
                  }

                  else
                    p8[(signed long int)render_rectangle_double__1__13__2__1__1__1__rgbi] = (unsigned char)a;
                }
                if(t[3l] > 1.000000)
                  t[(signed long int)3] = (double)1;

                if(t[3l] < 0.000000)
                  t[(signed long int)3] = (double)0;

                if(nchan >= 4)
                {
                  if(transp == 1)
                  {
                    if(bytes_per_channel == 2)
                      p16[(signed long int)3] = (unsigned short int)(t[(signed long int)3] * (double)65535);

                    else
                      p8[(signed long int)3] = (unsigned char)(t[(signed long int)3] * (double)255);
                  }

                  else
                    if(bytes_per_channel == 2)
                      p16[(signed long int)3] = (unsigned short int)65535;

                    else
                      p8[(signed long int)3] = (unsigned char)255;
                }

                x = x + oversample;
              }
              y = y + oversample;
            }
          }

        done:
          ;
          stats->badvals = fic.badvals;
          free((void *)temporal_filter);
          free((void *)temporal_deltas);
          free((void *)batch_filter);
          free((void *)filter);
          free((void *)buckets);
          thi = 0;
          for( ; !(thi >= spec->nthreads); thi = thi + 1)
            clear_cp(&(fth + (signed long int)thi)->cp, 0);
          free((void *)fth);
          clear_cp(&cp, 0);
          char *return_value_getenv_16;
          return_value_getenv_16=getenv("insert_palette");
          if(!(return_value_getenv_16 == ((char *)NULL)))
          {
            signed int ph = 100;
            if(ph >= image_height)
              ph = image_height;

            j = 0;
            for( ; !(j >= ph); j = j + 1)
            {
              i = 0;
              for( ; !(i >= image_width); i = i + 1)
              {
                unsigned char *render_rectangle_double__1__15__1__1__1__1__p = (unsigned char *)out + (signed long int)(nchan * (i + j * out_width));
                render_rectangle_double__1__15__1__1__1__1__p[(signed long int)0] = (unsigned char)dmap[(signed long int)((i * 256) / image_width)].color[(signed long int)0];
                render_rectangle_double__1__15__1__1__1__1__p[(signed long int)1] = (unsigned char)dmap[(signed long int)((i * 256) / image_width)].color[(signed long int)1];
                render_rectangle_double__1__15__1__1__1__1__p[(signed long int)2] = (unsigned char)dmap[(signed long int)((i * 256) / image_width)].color[(signed long int)2];
              }
            }
          }

          tend=time((signed long int *)(void *)0);
          stats->render_seconds = (signed int)(tend - tstart);
          return 0;
        }
      }
    }
}

// render_rectangle_double_mt
// file rect.c line 527
static signed int render_rectangle_double_mt(struct anonymous_4 *spec, void *out, signed int field, signed int nchan, signed int transp, struct anonymous_8 *stats)
{
  signed long int nbuckets;
  signed int i;
  signed int j;
  signed int render_rectangle_double_mt__1__k;
  signed int batch_num;
  signed int temporal_sample_num;
  double nsamples;
  double batch_size;
  double (*buckets)[5l];
  double (*accumulate)[4l];
  double *points;
  double *filter;
  double *temporal_filter;
  double *temporal_deltas;
  double *batch_filter;
  double ppux = (double)0;
  double ppuy = (double)0;
  signed int image_width;
  signed int image_height;
  signed int out_width;
  signed int filter_width = 0;
  signed int bytes_per_channel = spec->bytes_per_channel;
  signed int oversample;
  double highpow;
  signed int nbatches;
  signed int ntemporal_samples;
  struct anonymous_1 dmap[256l];
  signed int gutter_width;
  double vibrancy = 0.0;
  double gamma = 0.0;
  double background[3l];
  signed int vib_gam_n = 0;
  signed long int progress_began = (signed long int)0;
  signed int render_rectangle_double_mt__1__verbose = spec->verbose;
  signed int gnm_idx;
  signed int max_gnm_de_fw;
  signed int de_offset;
  struct anonymous_0 cp;
  unsigned short int *xform_distrib;
  struct anonymous_12 fic;
  struct anonymous_13 *fth;
  union pthread_attr_t pt_attr;
  unsigned long int *myThreads = (unsigned long int *)(void *)0;
  signed int thread_status;
  signed int thi;
  signed long int tstart;
  signed long int tend;
  double sumfilt;
  char *last_block;
  unsigned long int memory_rqd;
  signed long int progress_timer = (signed long int)0;
  signed long int progress_timer_history[64l];
  double progress_history[64l];
  signed int progress_history_mark = 0;
  tstart=time((signed long int *)(void *)0);
  fic.badvals = (double)0;
  fic.aborted = 0;
  stats->num_iters = (signed long int)0;
  memset((void *)&cp, 0, sizeof(struct anonymous_0) /*10712ul*/ );
  flam3_interpolate(spec->genomes, spec->ngenomes, spec->time, (double)0, &cp);
  oversample = cp.spatial_oversample;
  highpow = cp.highlight_power;
  nbatches = cp.nbatches;
  ntemporal_samples = cp.ntemporal_samples;
  unsigned long int tmp_post_7;
  unsigned long int tmp_if_expr_8;
  if(!(nbatches >= 1))
  {
    fprintf(stderr, "nbatches must be positive, not %d.\n", nbatches);
    return 1;
  }

  else
    if(!(oversample >= 1))
    {
      fprintf(stderr, "oversample must be positive, not %d.\n", oversample);
      return 1;
    }

    else
    {
      void *return_value_calloc_1;
      return_value_calloc_1=calloc((unsigned long int)spec->nthreads, sizeof(struct anonymous_13) /*11024ul*/ );
      fth = (struct anonymous_13 *)return_value_calloc_1;
      i = 0;
      for( ; !(i >= spec->nthreads); i = i + 1)
        (fth + (signed long int)i)->cp.final_xform_index = -1;
      image_width = cp.width;
      out_width = image_width;
      if(!(field == 0))
      {
        image_height = cp.height / 2;
        if(field == 2)
          out = (void *)((unsigned char *)out + (signed long int)(nchan * bytes_per_channel * out_width));

        out_width = out_width * 2;
      }

      else
        image_height = cp.height;
      filter_width=flam3_create_spatial_filter(spec, field, &filter);
      if(!(filter_width >= 0))
      {
        fprintf(stderr, "flam3_create_spatial_filter returned error: aborting\n");
        return 1;
      }

      else
      {
        void *return_value_malloc_2;
        return_value_malloc_2=malloc(sizeof(double) /*8ul*/  * (unsigned long int)nbatches);
        batch_filter = (double *)return_value_malloc_2;
        i = 0;
        for( ; !(i >= nbatches); i = i + 1)
          batch_filter[(signed long int)i] = 1.0 / (double)nbatches;
        sumfilt=flam3_create_temporal_filter(nbatches * ntemporal_samples, cp.temporal_filter_type, cp.temporal_filter_exp, cp.temporal_filter_width, &temporal_filter, &temporal_deltas);
        gutter_width = (filter_width - oversample) / 2;
        max_gnm_de_fw = 0;
        gnm_idx = 0;
        for( ; !(gnm_idx >= spec->ngenomes); gnm_idx = gnm_idx + 1)
        {
          signed int this_width;
          double return_value_ceil_3;
          return_value_ceil_3=ceil((spec->genomes + (signed long int)gnm_idx)->estimator);
          this_width = (signed int)return_value_ceil_3 * oversample;
          if(!(max_gnm_de_fw >= this_width))
            max_gnm_de_fw = this_width;

        }
        if(max_gnm_de_fw >= 1)
          max_gnm_de_fw = max_gnm_de_fw + (oversample - 1);

        if(!(gutter_width >= max_gnm_de_fw))
        {
          de_offset = max_gnm_de_fw - gutter_width;
          gutter_width = max_gnm_de_fw;
        }

        else
          de_offset = 0;
        fic.height = oversample * image_height + 2 * gutter_width;
        fic.width = oversample * image_width + 2 * gutter_width;
        nbuckets = (signed long int)fic.width * (signed long int)fic.height;
        memory_rqd = sizeof(double [5l]) /*40ul*/  * (unsigned long int)nbuckets + sizeof(double [4l]) /*32ul*/  * (unsigned long int)nbuckets + (unsigned long int)4 * sizeof(double) /*8ul*/  * (unsigned long int)spec->sub_batch_size * (unsigned long int)spec->nthreads;
        void *return_value_malloc_4;
        return_value_malloc_4=malloc(memory_rqd);
        last_block = (char *)return_value_malloc_4;
        if(last_block == ((char *)NULL))
        {
          fprintf(stderr, "render_rectangle: cannot malloc %g bytes.\n", (double)memory_rqd);
          fprintf(stderr, "render_rectangle: w=%d h=%d nb=%ld.\n", fic.width, fic.height, nbuckets);
          return 1;
        }

        else
        {
          buckets = (double (*)[5l])last_block;
          accumulate = (double (*)[4l])(last_block + (signed long int)(sizeof(double [5l]) /*40ul*/  * (unsigned long int)nbuckets));
          points = (double *)(last_block + (signed long int)((sizeof(double [5l]) /*40ul*/  + sizeof(double [4l]) /*32ul*/ ) * (unsigned long int)nbuckets));
          if(!(render_rectangle_double_mt__1__verbose == 0))
          {
            fprintf(stderr, "chaos: ");
            progress_began=time((signed long int *)(void *)0);
          }

          background[(signed long int)2] = 0.0;
          background[(signed long int)1] = background[(signed long int)2];
          background[(signed long int)0] = background[(signed long int)1];
          memset((void *)(char *)accumulate, 0, sizeof(double [4l]) /*32ul*/  * (unsigned long int)nbuckets);
          batch_num = 0;
          for( ; !(batch_num >= nbatches); batch_num = batch_num + 1)
          {
            double de_time;
            double sample_density = 0.0;
            double k1;
            double area;
            double k2;
            struct anonymous_6 de;
            de_time = spec->time + temporal_deltas[(signed long int)(batch_num * ntemporal_samples)];
            memset((void *)(char *)buckets, 0, sizeof(double [5l]) /*40ul*/  * (unsigned long int)nbuckets);
            flam3_interpolate(spec->genomes, spec->ngenomes, de_time, (double)0, &cp);
            if(cp.estimator < 0.0 || cp.estimator_minimum < 0.0)
            {
              fprintf(stderr, "density estimator filter widths must be >= 0\n");
              return 1;
            }

            if(!(spec->bits >= 33))
            {
              if(cp.estimator > 0.0)
              {
                fprintf(stderr, "warning: density estimation disabled with %d bit buffers.\n", spec->bits);
                cp.estimator = 0.0;
              }

            }

            if(cp.estimator > 0.0)
            {
              de=flam3_create_de_filters(cp.estimator, cp.estimator_minimum, cp.estimator_curve, oversample);
              if(!(de.kernel_size >= 0))
              {
                fprintf(stderr, "de.kernel_size returned 0 - aborting.\n");
                return 1;
              }

            }

            else
              de.max_filter_index = 0;
            temporal_sample_num = 0;
            for( ; !(temporal_sample_num >= ntemporal_samples); temporal_sample_num = temporal_sample_num + 1)
            {
              double temporal_sample_time;
              double color_scalar = temporal_filter[(signed long int)(batch_num * ntemporal_samples + temporal_sample_num)];
              temporal_sample_time = spec->time + temporal_deltas[(signed long int)(batch_num * ntemporal_samples + temporal_sample_num)];
              flam3_interpolate(spec->genomes, spec->ngenomes, temporal_sample_time, (double)0, &cp);
              signed int return_value_prepare_precalc_flags_5;
              return_value_prepare_precalc_flags_5=prepare_precalc_flags(&cp);
              if(!(return_value_prepare_precalc_flags_5 == 0))
              {
                fprintf(stderr, "prepare xform pointers returned error: aborting.\n");
                return 1;
              }

              xform_distrib=flam3_create_xform_distrib(&cp);
              if(xform_distrib == ((unsigned short int *)NULL))
              {
                fprintf(stderr, "create xform distrib returned error: aborting.\n");
                return 1;
              }

              j = 0;
              for( ; !(j >= 256); j = j + 1)
              {
                dmap[(signed long int)j].index = cp.palette[(signed long int)((j * 256) / 256)].index / 256.0;
                render_rectangle_double_mt__1__k = 0;
                for( ; !(render_rectangle_double_mt__1__k >= 4); render_rectangle_double_mt__1__k = render_rectangle_double_mt__1__k + 1)
                  dmap[(signed long int)j].color[(signed long int)render_rectangle_double_mt__1__k] = cp.palette[(signed long int)((j * 256) / 256)].color[(signed long int)render_rectangle_double_mt__1__k] * (double)255 * color_scalar;
              }
              {
                double t0;
                double t1;
                double shift = 0.0;
                double corner0;
                double corner1;
                double scale;
                if(cp.sample_density <= 0.0)
                {
                  fprintf(stderr, "sample density (quality) must be greater than zero, not %g.\n", cp.sample_density);
                  return 1;
                }

                scale=pow(2.0, cp.zoom);
                sample_density = cp.sample_density * scale * scale;
                ppux = cp.pixels_per_unit * scale;
                ppuy = field != 0 ? ppux / 2.0 : ppux;
                ppux = ppux / spec->pixel_aspect_ratio;
                switch(field)
                {
                  case 0:
                  {
                    shift = 0.0;
                    break;
                  }
                  case 1:
                  {
                    shift = -0.5;
                    break;
                  }
                  case 2:
                    shift = 0.5;
                }
                shift = shift / ppux;
                t0 = (double)gutter_width / ((double)oversample * ppux);
                t1 = (double)gutter_width / ((double)oversample * ppuy);
                corner0 = cp.center[(signed long int)0] - ((double)image_width / ppux) / 2.0;
                corner1 = cp.center[(signed long int)1] - ((double)image_height / ppuy) / 2.0;
                fic.bounds[(signed long int)0] = corner0 - t0;
                fic.bounds[(signed long int)1] = (corner1 - t1) + shift;
                fic.bounds[(signed long int)2] = corner0 + (double)image_width / ppux + t0;
                fic.bounds[(signed long int)3] = corner1 + (double)image_height / ppuy + t1 + shift;
                fic.size[(signed long int)0] = 1.0 / (fic.bounds[(signed long int)2] - fic.bounds[(signed long int)0]);
                fic.size[(signed long int)1] = 1.0 / (fic.bounds[(signed long int)3] - fic.bounds[(signed long int)1]);
                fic.rot[(signed long int)0][(signed long int)0]=cos((cp.rotate * (double)2 * 3.14159265358979323846) / 360.0);
                double return_value_sin_6;
                return_value_sin_6=sin((cp.rotate * (double)2 * 3.14159265358979323846) / 360.0);
                fic.rot[(signed long int)0][(signed long int)1] = -return_value_sin_6;
                fic.rot[(signed long int)1][(signed long int)0] = -fic.rot[(signed long int)0][(signed long int)1];
                fic.rot[(signed long int)1][(signed long int)1] = fic.rot[(signed long int)0][(signed long int)0];
                fic.ws0 = (double)fic.width * fic.size[(signed long int)0];
                fic.wb0s0 = fic.ws0 * fic.bounds[(signed long int)0];
                fic.hs1 = (double)fic.height * fic.size[(signed long int)1];
                fic.hb1s1 = fic.hs1 * fic.bounds[(signed long int)1];
              }
              nsamples = sample_density * (double)image_width * (double)image_height;
              batch_size = nsamples / (double)(nbatches * ntemporal_samples);
              stats->num_iters = stats->num_iters + (signed long int)batch_size;
              fic.xform_distrib = xform_distrib;
              fic.spec = spec;
              fic.batch_size = batch_size / (double)spec->nthreads;
              fic.temporal_sample_num = temporal_sample_num;
              fic.ntemporal_samples = ntemporal_samples;
              fic.batch_num = batch_num;
              fic.nbatches = nbatches;
              fic.dmap = (struct anonymous_1 *)dmap;
              fic.color_scalar = color_scalar;
              fic.buckets = (void *)buckets;
              fic.progress_timer = &progress_timer;
              fic.progress_timer_history = &progress_timer_history[(signed long int)0];
              fic.progress_history = &progress_history[(signed long int)0];
              fic.progress_history_mark = &progress_history_mark;
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
              {
                signed int rk = 0;
                for( ; !(rk >= 16); rk = rk + 1)
                {
                  tmp_post_7 = (&spec->rc)->randcnt;
                  (&spec->rc)->randcnt = (&spec->rc)->randcnt - 1ul;
                  if(tmp_post_7 == 0ul)
                  {
                    isaac(&spec->rc);
                    (&spec->rc)->randcnt = (unsigned long int)((1 << 4) - 1);
                    tmp_if_expr_8 = (&spec->rc)->randrsl[(signed long int)(&spec->rc)->randcnt];
                  }

                  else
                    tmp_if_expr_8 = (&spec->rc)->randrsl[(signed long int)(&spec->rc)->randcnt];
                  (fth + (signed long int)thi)->rc.randrsl[(signed long int)rk] = tmp_if_expr_8;
                }
                irandinit(&(fth + (signed long int)thi)->rc, 1);
                if(thi == 0)
                {
                  (fth + (signed long int)thi)->first_thread = 1;
                  if(batch_num == 0 && temporal_sample_num == 0)
                    (fth + (signed long int)thi)->timer_initialize = 1;

                  else
                    (fth + (signed long int)thi)->timer_initialize = 0;
                }

                else
                {
                  (fth + (signed long int)thi)->first_thread = 0;
                  (fth + (signed long int)thi)->timer_initialize = 0;
                }
                (fth + (signed long int)thi)->iter_storage = &points[(signed long int)(thi * spec->sub_batch_size * 4)];
                (fth + (signed long int)thi)->fic = &fic;
                flam3_copy(&(fth + (signed long int)thi)->cp, &cp);
              }
              void *return_value_malloc_9;
              return_value_malloc_9=malloc((unsigned long int)spec->nthreads * sizeof(unsigned long int) /*8ul*/ );
              myThreads = (unsigned long int *)return_value_malloc_9;
              pthread_attr_init(&pt_attr);
              pthread_attr_setdetachstate(&pt_attr, 0);
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
                pthread_create(&myThreads[(signed long int)thi], &pt_attr, (void * (*)(void *))(void *)iter_thread_double_mt, (void *)&fth[(signed long int)thi]);
              pthread_attr_destroy(&pt_attr);
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
                pthread_join(myThreads[(signed long int)thi], (void **)&thread_status);
              free((void *)myThreads);
              free((void *)xform_distrib);
              if(!(fic.aborted == 0))
              {
                if(!(render_rectangle_double_mt__1__verbose == 0))
                  fprintf(stderr, "\naborted!\n");

                goto done;
              }

              vibrancy = vibrancy + cp.vibrancy;
              gamma = gamma + cp.gamma;
              background[(signed long int)0] = background[(signed long int)0] + cp.background[(signed long int)0];
              background[(signed long int)1] = background[(signed long int)1] + cp.background[(signed long int)1];
              background[(signed long int)2] = background[(signed long int)2] + cp.background[(signed long int)2];
              vib_gam_n = vib_gam_n + 1;
            }
            k1 = (cp.contrast * cp.brightness * (double)255 * 268.0 * batch_filter[(signed long int)batch_num]) / (double)256;
            area = (double)(image_width * image_height) / (ppux * ppuy);
            k2 = (double)(oversample * oversample * nbatches) / (cp.contrast * area * (double)255 * sample_density * sumfilt);
            if(de.max_filter_index == 0)
            {
              j = 0;
              for( ; !(j >= fic.height); j = j + 1)
              {
                i = 0;
                for( ; !(i >= fic.width); i = i + 1)
                {
                  double (*a)[4l] = accumulate + (signed long int)i + (signed long int)(j * fic.width);
                  double (*b)[5l] = buckets + (signed long int)i + (signed long int)(j * fic.width);
                  double c[4l];
                  double render_rectangle_double_mt__1__11__1__5__1__1__1__1__ls;
                  c[(signed long int)0] = (double)b[(signed long int)0][(signed long int)0];
                  c[(signed long int)1] = (double)b[(signed long int)0][(signed long int)1];
                  c[(signed long int)2] = (double)b[(signed long int)0][(signed long int)2];
                  c[(signed long int)3] = (double)b[(signed long int)0][(signed long int)3];
                  if(!IEEE_FLOAT_EQUAL(0.0, c[3l]))
                  {
                    double return_value_log_10;
                    return_value_log_10=log(1.0 + c[(signed long int)3] * k2);
                    render_rectangle_double_mt__1__11__1__5__1__1__1__1__ls = (k1 * return_value_log_10) / c[(signed long int)3];
                    c[(signed long int)0] = c[(signed long int)0] * render_rectangle_double_mt__1__11__1__5__1__1__1__1__ls;
                    c[(signed long int)1] = c[(signed long int)1] * render_rectangle_double_mt__1__11__1__5__1__1__1__1__ls;
                    c[(signed long int)2] = c[(signed long int)2] * render_rectangle_double_mt__1__11__1__5__1__1__1__1__ls;
                    c[(signed long int)3] = c[(signed long int)3] * render_rectangle_double_mt__1__11__1__5__1__1__1__1__ls;
                    do
                      a[(signed long int)0][(signed long int)0] = a[(signed long int)0][(signed long int)0] + c[(signed long int)0];
                    while((_Bool)0);
                    do
                      a[(signed long int)0][(signed long int)1] = a[(signed long int)0][(signed long int)1] + c[(signed long int)1];
                    while((_Bool)0);
                    do
                      a[(signed long int)0][(signed long int)2] = a[(signed long int)0][(signed long int)2] + c[(signed long int)2];
                    while((_Bool)0);
                    do
                      a[(signed long int)0][(signed long int)3] = a[(signed long int)0][(signed long int)3] + c[(signed long int)3];
                    while((_Bool)0);
                  }

                }
              }
            }

            else
            {
              struct anonymous_15 *deth;
              signed int de_aborted = 0;
              signed int myspan = (fic.height - 2 * (oversample - 1)) + 1;
              signed int swath = myspan / spec->nthreads;
              void *return_value_calloc_11;
              return_value_calloc_11=calloc((unsigned long int)spec->nthreads, sizeof(struct anonymous_15) /*104ul*/ );
              deth = (struct anonymous_15 *)return_value_calloc_11;
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
              {
                (deth + (signed long int)thi)->b = buckets;
                (deth + (signed long int)thi)->accumulate = accumulate;
                (deth + (signed long int)thi)->width = fic.width;
                (deth + (signed long int)thi)->height = fic.height;
                (deth + (signed long int)thi)->oversample = oversample;
                (deth + (signed long int)thi)->progress_size = spec->sub_batch_size / 10;
                (deth + (signed long int)thi)->de = &de;
                (deth + (signed long int)thi)->k1 = k1;
                (deth + (signed long int)thi)->k2 = k2;
                (deth + (signed long int)thi)->curve = cp.estimator_curve;
                (deth + (signed long int)thi)->spec = spec;
                (deth + (signed long int)thi)->aborted = &de_aborted;
                if(!(myspan >= spec->nthreads))
                {
                  (deth + (signed long int)thi)->start_row = 0;
                  if(thi == spec->nthreads + -1)
                  {
                    (deth + (signed long int)thi)->end_row = myspan;
                    (deth + (signed long int)thi)->last_thread = 1;
                  }

                  else
                  {
                    (deth + (signed long int)thi)->end_row = -1;
                    (deth + (signed long int)thi)->last_thread = 0;
                  }
                }

                else
                {
                  (deth + (signed long int)thi)->start_row = thi * swath;
                  (deth + (signed long int)thi)->end_row = (thi + 1) * swath;
                  if(thi == spec->nthreads + -1)
                  {
                    (deth + (signed long int)thi)->end_row = myspan;
                    (deth + (signed long int)thi)->last_thread = 1;
                  }

                  else
                    (deth + (signed long int)thi)->last_thread = 0;
                }
              }
              void *return_value_malloc_12;
              return_value_malloc_12=malloc((unsigned long int)spec->nthreads * sizeof(unsigned long int) /*8ul*/ );
              myThreads = (unsigned long int *)return_value_malloc_12;
              pthread_attr_init(&pt_attr);
              pthread_attr_setdetachstate(&pt_attr, 0);
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
                pthread_create(&myThreads[(signed long int)thi], &pt_attr, (void * (*)(void *))(void *)de_thread_64_mt, (void *)&deth[(signed long int)thi]);
              pthread_attr_destroy(&pt_attr);
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
                pthread_join(myThreads[(signed long int)thi], (void **)&thread_status);
              free((void *)myThreads);
              free((void *)deth);
              if(!(de_aborted == 0))
              {
                if(!(render_rectangle_double_mt__1__verbose == 0))
                  fprintf(stderr, "\naborted!\n");

                goto done;
              }

            }
            if(de.max_filter_index >= 1)
            {
              free((void *)de.filter_coefs);
              free((void *)de.filter_widths);
            }

          }
          if(!(render_rectangle_double_mt__1__verbose == 0))
          {
            signed long int return_value_time_13;
            return_value_time_13=time((signed long int *)(void *)0);
            fprintf(stderr, "\rchaos: 100.0%%  took: %ld seconds   \n", return_value_time_13 - progress_began);
            fprintf(stderr, "filtering...");
          }

          {
            signed int x;
            signed int y;
            double t[4l];
            double newrgb[3l];
            double g = 1.0 / (gamma / (double)vib_gam_n);
            double tmp;
            double render_rectangle_double_mt__1__13__a;
            double alpha;
            double ls;
            signed int rgbi;
            double linrange = cp.gam_lin_thresh;
            vibrancy = vibrancy / (double)vib_gam_n;
            background[(signed long int)0] = background[(signed long int)0] / ((double)vib_gam_n / 256.0);
            background[(signed long int)1] = background[(signed long int)1] / ((double)vib_gam_n / 256.0);
            background[(signed long int)2] = background[(signed long int)2] / ((double)vib_gam_n / 256.0);
            if(!(spec->earlyclip == 0))
            {
              j = 0;
              for( ; !(j >= fic.height); j = j + 1)
              {
                i = 0;
                for( ; !(i >= fic.width); i = i + 1)
                {
                  double (*ac)[4l] = accumulate + (signed long int)i + (signed long int)(j * fic.width);
                  if((*ac)[3l] <= 0.000000)
                  {
                    alpha = 0.0;
                    ls = 0.0;
                  }

                  else
                  {
                    tmp = ac[(signed long int)0][(signed long int)3] / (double)255;
                    alpha=flam3_calc_alpha(tmp, g, linrange);
                    ls = (vibrancy * 256.0 * alpha) / tmp;
                    if(alpha < 0.0)
                      alpha = 0.0;

                    if(alpha > 1.0)
                      alpha = 1.0;

                  }
                  t[(signed long int)0] = (double)ac[(signed long int)0][(signed long int)0];
                  t[(signed long int)1] = (double)ac[(signed long int)0][(signed long int)1];
                  t[(signed long int)2] = (double)ac[(signed long int)0][(signed long int)2];
                  t[(signed long int)3] = (double)ac[(signed long int)0][(signed long int)3];
                  flam3_calc_newrgb(t, ls, highpow, newrgb);
                  rgbi = 0;
                  for( ; !(rgbi >= 3); rgbi = rgbi + 1)
                  {
                    render_rectangle_double_mt__1__13__a = newrgb[(signed long int)rgbi];
                    double return_value_pow_14;
                    return_value_pow_14=pow(t[(signed long int)rgbi] / (double)255, g);
                    render_rectangle_double_mt__1__13__a = render_rectangle_double_mt__1__13__a + (1.0 - vibrancy) * 256.0 * return_value_pow_14;
                    if(transp == 0 || !(nchan >= 4))
                      render_rectangle_double_mt__1__13__a = render_rectangle_double_mt__1__13__a + (1.0 - alpha) * background[(signed long int)rgbi];

                    else
                      if(alpha > 0.000000)
                        render_rectangle_double_mt__1__13__a = render_rectangle_double_mt__1__13__a / alpha;

                      else
                        render_rectangle_double_mt__1__13__a = (double)0;
                    if(render_rectangle_double_mt__1__13__a > 255.000000)
                      render_rectangle_double_mt__1__13__a = (double)255;

                    if(render_rectangle_double_mt__1__13__a < 0.000000)
                      render_rectangle_double_mt__1__13__a = (double)0;

                    ac[(signed long int)0][(signed long int)rgbi] = render_rectangle_double_mt__1__13__a;
                  }
                  ac[(signed long int)0][(signed long int)3] = alpha;
                }
              }
            }

            y = de_offset;
            j = 0;
            for( ; !(j >= image_height); j = j + 1)
            {
              x = de_offset;
              i = 0;
              for( ; !(i >= image_width); i = i + 1)
              {
                signed int ii;
                signed int jj;
                signed int render_rectangle_double_mt__1__13__2__1__1__1__rgbi;
                void *p;
                unsigned short int *p16;
                unsigned char *p8;
                t[(signed long int)3] = 0.0;
                t[(signed long int)2] = t[(signed long int)3];
                t[(signed long int)1] = t[(signed long int)2];
                t[(signed long int)0] = t[(signed long int)1];
                ii = 0;
                for( ; !(ii >= filter_width); ii = ii + 1)
                {
                  jj = 0;
                  for( ; !(jj >= filter_width); jj = jj + 1)
                  {
                    double k = filter[(signed long int)(ii + jj * filter_width)];
                    double (*render_rectangle_double_mt__1__13__2__1__1__1__1__1__1__1__ac)[4l] = accumulate + (signed long int)x + (signed long int)ii + (signed long int)((y + jj) * fic.width);
                    t[(signed long int)0] = t[(signed long int)0] + k * render_rectangle_double_mt__1__13__2__1__1__1__1__1__1__1__ac[(signed long int)0][(signed long int)0];
                    t[(signed long int)1] = t[(signed long int)1] + k * render_rectangle_double_mt__1__13__2__1__1__1__1__1__1__1__ac[(signed long int)0][(signed long int)1];
                    t[(signed long int)2] = t[(signed long int)2] + k * render_rectangle_double_mt__1__13__2__1__1__1__1__1__1__1__ac[(signed long int)0][(signed long int)2];
                    t[(signed long int)3] = t[(signed long int)3] + k * render_rectangle_double_mt__1__13__2__1__1__1__1__1__1__1__ac[(signed long int)0][(signed long int)3];
                  }
                }
                p = (void *)((unsigned char *)out + (signed long int)(nchan * bytes_per_channel * (i + j * out_width)));
                p8 = (unsigned char *)p;
                p16 = (unsigned short int *)p;
                if(spec->earlyclip == 0)
                {
                  tmp = t[(signed long int)3] / (double)255;
                  if(t[3l] <= 0.000000)
                  {
                    alpha = 0.0;
                    ls = 0.0;
                  }

                  else
                  {
                    alpha=flam3_calc_alpha(tmp, g, linrange);
                    ls = (vibrancy * 256.0 * alpha) / tmp;
                    if(alpha < 0.0)
                      alpha = 0.0;

                    if(alpha > 1.0)
                      alpha = 1.0;

                  }
                  flam3_calc_newrgb(t, ls, highpow, newrgb);
                  render_rectangle_double_mt__1__13__2__1__1__1__rgbi = 0;
                  for( ; !(render_rectangle_double_mt__1__13__2__1__1__1__rgbi >= 3); render_rectangle_double_mt__1__13__2__1__1__1__rgbi = render_rectangle_double_mt__1__13__2__1__1__1__rgbi + 1)
                  {
                    render_rectangle_double_mt__1__13__a = newrgb[(signed long int)render_rectangle_double_mt__1__13__2__1__1__1__rgbi];
                    double return_value_pow_15;
                    return_value_pow_15=pow(t[(signed long int)render_rectangle_double_mt__1__13__2__1__1__1__rgbi] / (double)255, g);
                    render_rectangle_double_mt__1__13__a = render_rectangle_double_mt__1__13__a + (1.0 - vibrancy) * 256.0 * return_value_pow_15;
                    if(transp == 0 || !(nchan >= 4))
                      render_rectangle_double_mt__1__13__a = render_rectangle_double_mt__1__13__a + (1.0 - alpha) * background[(signed long int)render_rectangle_double_mt__1__13__2__1__1__1__rgbi];

                    else
                      if(alpha > 0.000000)
                        render_rectangle_double_mt__1__13__a = render_rectangle_double_mt__1__13__a / alpha;

                      else
                        render_rectangle_double_mt__1__13__a = (double)0;
                    if(render_rectangle_double_mt__1__13__a > 255.000000)
                      render_rectangle_double_mt__1__13__a = (double)255;

                    if(render_rectangle_double_mt__1__13__a < 0.000000)
                      render_rectangle_double_mt__1__13__a = (double)0;

                    t[(signed long int)render_rectangle_double_mt__1__13__2__1__1__1__rgbi] = render_rectangle_double_mt__1__13__a;
                  }
                  t[(signed long int)3] = alpha;
                }

                render_rectangle_double_mt__1__13__2__1__1__1__rgbi = 0;
                for( ; !(render_rectangle_double_mt__1__13__2__1__1__1__rgbi >= 3); render_rectangle_double_mt__1__13__2__1__1__1__rgbi = render_rectangle_double_mt__1__13__2__1__1__1__rgbi + 1)
                {
                  render_rectangle_double_mt__1__13__a = t[(signed long int)render_rectangle_double_mt__1__13__2__1__1__1__rgbi];
                  if(render_rectangle_double_mt__1__13__a > 255.000000)
                    render_rectangle_double_mt__1__13__a = (double)255;

                  if(render_rectangle_double_mt__1__13__a < 0.000000)
                    render_rectangle_double_mt__1__13__a = (double)0;

                  if(bytes_per_channel == 2)
                  {
                    render_rectangle_double_mt__1__13__a = render_rectangle_double_mt__1__13__a * 256.0;
                    p16[(signed long int)render_rectangle_double_mt__1__13__2__1__1__1__rgbi] = (unsigned short int)render_rectangle_double_mt__1__13__a;
                  }

                  else
                    p8[(signed long int)render_rectangle_double_mt__1__13__2__1__1__1__rgbi] = (unsigned char)render_rectangle_double_mt__1__13__a;
                }
                if(t[3l] > 1.000000)
                  t[(signed long int)3] = (double)1;

                if(t[3l] < 0.000000)
                  t[(signed long int)3] = (double)0;

                if(nchan >= 4)
                {
                  if(transp == 1)
                  {
                    if(bytes_per_channel == 2)
                      p16[(signed long int)3] = (unsigned short int)(t[(signed long int)3] * (double)65535);

                    else
                      p8[(signed long int)3] = (unsigned char)(t[(signed long int)3] * (double)255);
                  }

                  else
                    if(bytes_per_channel == 2)
                      p16[(signed long int)3] = (unsigned short int)65535;

                    else
                      p8[(signed long int)3] = (unsigned char)255;
                }

                x = x + oversample;
              }
              y = y + oversample;
            }
          }

        done:
          ;
          stats->badvals = fic.badvals;
          free((void *)temporal_filter);
          free((void *)temporal_deltas);
          free((void *)batch_filter);
          free((void *)filter);
          free((void *)buckets);
          thi = 0;
          for( ; !(thi >= spec->nthreads); thi = thi + 1)
            clear_cp(&(fth + (signed long int)thi)->cp, 0);
          free((void *)fth);
          clear_cp(&cp, 0);
          char *return_value_getenv_16;
          return_value_getenv_16=getenv("insert_palette");
          if(!(return_value_getenv_16 == ((char *)NULL)))
          {
            signed int ph = 100;
            if(ph >= image_height)
              ph = image_height;

            j = 0;
            for( ; !(j >= ph); j = j + 1)
            {
              i = 0;
              for( ; !(i >= image_width); i = i + 1)
              {
                unsigned char *render_rectangle_double_mt__1__15__1__1__1__1__p = (unsigned char *)out + (signed long int)(nchan * (i + j * out_width));
                render_rectangle_double_mt__1__15__1__1__1__1__p[(signed long int)0] = (unsigned char)dmap[(signed long int)((i * 256) / image_width)].color[(signed long int)0];
                render_rectangle_double_mt__1__15__1__1__1__1__p[(signed long int)1] = (unsigned char)dmap[(signed long int)((i * 256) / image_width)].color[(signed long int)1];
                render_rectangle_double_mt__1__15__1__1__1__1__p[(signed long int)2] = (unsigned char)dmap[(signed long int)((i * 256) / image_width)].color[(signed long int)2];
              }
            }
          }

          tend=time((signed long int *)(void *)0);
          stats->render_seconds = (signed int)(tend - tstart);
          return 0;
        }
      }
    }
}

// render_rectangle_float
// file rect.c line 527
static signed int render_rectangle_float(struct anonymous_4 *spec, void *out, signed int field, signed int nchan, signed int transp, struct anonymous_8 *stats)
{
  signed long int nbuckets;
  signed int i;
  signed int j;
  signed int render_rectangle_float__1__k;
  signed int batch_num;
  signed int temporal_sample_num;
  double nsamples;
  double batch_size;
  unsigned int (*buckets)[5l];
  float (*accumulate)[4l];
  double *points;
  double *filter;
  double *temporal_filter;
  double *temporal_deltas;
  double *batch_filter;
  double ppux = (double)0;
  double ppuy = (double)0;
  signed int image_width;
  signed int image_height;
  signed int out_width;
  signed int filter_width = 0;
  signed int bytes_per_channel = spec->bytes_per_channel;
  signed int oversample;
  double highpow;
  signed int nbatches;
  signed int ntemporal_samples;
  struct anonymous_1 dmap[256l];
  signed int gutter_width;
  double vibrancy = 0.0;
  double gamma = 0.0;
  double background[3l];
  signed int vib_gam_n = 0;
  signed long int progress_began = (signed long int)0;
  signed int render_rectangle_float__1__verbose = spec->verbose;
  signed int gnm_idx;
  signed int max_gnm_de_fw;
  signed int de_offset;
  struct anonymous_0 cp;
  unsigned short int *xform_distrib;
  struct anonymous_12 fic;
  struct anonymous_13 *fth;
  union pthread_attr_t pt_attr;
  unsigned long int *myThreads = (unsigned long int *)(void *)0;
  signed int thread_status;
  signed int thi;
  signed long int tstart;
  signed long int tend;
  double sumfilt;
  char *last_block;
  unsigned long int memory_rqd;
  signed long int progress_timer = (signed long int)0;
  signed long int progress_timer_history[64l];
  double progress_history[64l];
  signed int progress_history_mark = 0;
  tstart=time((signed long int *)(void *)0);
  fic.badvals = (double)0;
  fic.aborted = 0;
  stats->num_iters = (signed long int)0;
  memset((void *)&cp, 0, sizeof(struct anonymous_0) /*10712ul*/ );
  flam3_interpolate(spec->genomes, spec->ngenomes, spec->time, (double)0, &cp);
  oversample = cp.spatial_oversample;
  highpow = cp.highlight_power;
  nbatches = cp.nbatches;
  ntemporal_samples = cp.ntemporal_samples;
  unsigned long int tmp_post_7;
  unsigned long int tmp_if_expr_8;
  if(!(nbatches >= 1))
  {
    fprintf(stderr, "nbatches must be positive, not %d.\n", nbatches);
    return 1;
  }

  else
    if(!(oversample >= 1))
    {
      fprintf(stderr, "oversample must be positive, not %d.\n", oversample);
      return 1;
    }

    else
    {
      void *return_value_calloc_1;
      return_value_calloc_1=calloc((unsigned long int)spec->nthreads, sizeof(struct anonymous_13) /*11024ul*/ );
      fth = (struct anonymous_13 *)return_value_calloc_1;
      i = 0;
      for( ; !(i >= spec->nthreads); i = i + 1)
        (fth + (signed long int)i)->cp.final_xform_index = -1;
      image_width = cp.width;
      out_width = image_width;
      if(!(field == 0))
      {
        image_height = cp.height / 2;
        if(field == 2)
          out = (void *)((unsigned char *)out + (signed long int)(nchan * bytes_per_channel * out_width));

        out_width = out_width * 2;
      }

      else
        image_height = cp.height;
      filter_width=flam3_create_spatial_filter(spec, field, &filter);
      if(!(filter_width >= 0))
      {
        fprintf(stderr, "flam3_create_spatial_filter returned error: aborting\n");
        return 1;
      }

      else
      {
        void *return_value_malloc_2;
        return_value_malloc_2=malloc(sizeof(double) /*8ul*/  * (unsigned long int)nbatches);
        batch_filter = (double *)return_value_malloc_2;
        i = 0;
        for( ; !(i >= nbatches); i = i + 1)
          batch_filter[(signed long int)i] = 1.0 / (double)nbatches;
        sumfilt=flam3_create_temporal_filter(nbatches * ntemporal_samples, cp.temporal_filter_type, cp.temporal_filter_exp, cp.temporal_filter_width, &temporal_filter, &temporal_deltas);
        gutter_width = (filter_width - oversample) / 2;
        max_gnm_de_fw = 0;
        gnm_idx = 0;
        for( ; !(gnm_idx >= spec->ngenomes); gnm_idx = gnm_idx + 1)
        {
          signed int this_width;
          double return_value_ceil_3;
          return_value_ceil_3=ceil((spec->genomes + (signed long int)gnm_idx)->estimator);
          this_width = (signed int)return_value_ceil_3 * oversample;
          if(!(max_gnm_de_fw >= this_width))
            max_gnm_de_fw = this_width;

        }
        if(max_gnm_de_fw >= 1)
          max_gnm_de_fw = max_gnm_de_fw + (oversample - 1);

        if(!(gutter_width >= max_gnm_de_fw))
        {
          de_offset = max_gnm_de_fw - gutter_width;
          gutter_width = max_gnm_de_fw;
        }

        else
          de_offset = 0;
        fic.height = oversample * image_height + 2 * gutter_width;
        fic.width = oversample * image_width + 2 * gutter_width;
        nbuckets = (signed long int)fic.width * (signed long int)fic.height;
        memory_rqd = sizeof(unsigned int [5l]) /*20ul*/  * (unsigned long int)nbuckets + sizeof(float [4l]) /*16ul*/  * (unsigned long int)nbuckets + (unsigned long int)4 * sizeof(double) /*8ul*/  * (unsigned long int)spec->sub_batch_size * (unsigned long int)spec->nthreads;
        void *return_value_malloc_4;
        return_value_malloc_4=malloc(memory_rqd);
        last_block = (char *)return_value_malloc_4;
        if(last_block == ((char *)NULL))
        {
          fprintf(stderr, "render_rectangle: cannot malloc %g bytes.\n", (double)memory_rqd);
          fprintf(stderr, "render_rectangle: w=%d h=%d nb=%ld.\n", fic.width, fic.height, nbuckets);
          return 1;
        }

        else
        {
          buckets = (unsigned int (*)[5l])last_block;
          accumulate = (float (*)[4l])(last_block + (signed long int)(sizeof(unsigned int [5l]) /*20ul*/  * (unsigned long int)nbuckets));
          points = (double *)(last_block + (signed long int)((sizeof(unsigned int [5l]) /*20ul*/  + sizeof(float [4l]) /*16ul*/ ) * (unsigned long int)nbuckets));
          if(!(render_rectangle_float__1__verbose == 0))
          {
            fprintf(stderr, "chaos: ");
            progress_began=time((signed long int *)(void *)0);
          }

          background[(signed long int)2] = 0.0;
          background[(signed long int)1] = background[(signed long int)2];
          background[(signed long int)0] = background[(signed long int)1];
          memset((void *)(char *)accumulate, 0, sizeof(float [4l]) /*16ul*/  * (unsigned long int)nbuckets);
          batch_num = 0;
          for( ; !(batch_num >= nbatches); batch_num = batch_num + 1)
          {
            double de_time;
            double sample_density = 0.0;
            double k1;
            double area;
            double k2;
            struct anonymous_6 de;
            de_time = spec->time + temporal_deltas[(signed long int)(batch_num * ntemporal_samples)];
            memset((void *)(char *)buckets, 0, sizeof(unsigned int [5l]) /*20ul*/  * (unsigned long int)nbuckets);
            flam3_interpolate(spec->genomes, spec->ngenomes, de_time, (double)0, &cp);
            if(cp.estimator < 0.0 || cp.estimator_minimum < 0.0)
            {
              fprintf(stderr, "density estimator filter widths must be >= 0\n");
              return 1;
            }

            if(!(spec->bits >= 33))
            {
              if(cp.estimator > 0.0)
              {
                fprintf(stderr, "warning: density estimation disabled with %d bit buffers.\n", spec->bits);
                cp.estimator = 0.0;
              }

            }

            if(cp.estimator > 0.0)
            {
              de=flam3_create_de_filters(cp.estimator, cp.estimator_minimum, cp.estimator_curve, oversample);
              if(!(de.kernel_size >= 0))
              {
                fprintf(stderr, "de.kernel_size returned 0 - aborting.\n");
                return 1;
              }

            }

            else
              de.max_filter_index = 0;
            temporal_sample_num = 0;
            for( ; !(temporal_sample_num >= ntemporal_samples); temporal_sample_num = temporal_sample_num + 1)
            {
              double temporal_sample_time;
              double color_scalar = temporal_filter[(signed long int)(batch_num * ntemporal_samples + temporal_sample_num)];
              temporal_sample_time = spec->time + temporal_deltas[(signed long int)(batch_num * ntemporal_samples + temporal_sample_num)];
              flam3_interpolate(spec->genomes, spec->ngenomes, temporal_sample_time, (double)0, &cp);
              signed int return_value_prepare_precalc_flags_5;
              return_value_prepare_precalc_flags_5=prepare_precalc_flags(&cp);
              if(!(return_value_prepare_precalc_flags_5 == 0))
              {
                fprintf(stderr, "prepare xform pointers returned error: aborting.\n");
                return 1;
              }

              xform_distrib=flam3_create_xform_distrib(&cp);
              if(xform_distrib == ((unsigned short int *)NULL))
              {
                fprintf(stderr, "create xform distrib returned error: aborting.\n");
                return 1;
              }

              j = 0;
              for( ; !(j >= 256); j = j + 1)
              {
                dmap[(signed long int)j].index = cp.palette[(signed long int)((j * 256) / 256)].index / 256.0;
                render_rectangle_float__1__k = 0;
                for( ; !(render_rectangle_float__1__k >= 4); render_rectangle_float__1__k = render_rectangle_float__1__k + 1)
                  dmap[(signed long int)j].color[(signed long int)render_rectangle_float__1__k] = cp.palette[(signed long int)((j * 256) / 256)].color[(signed long int)render_rectangle_float__1__k] * (double)255 * color_scalar;
              }
              {
                double t0;
                double t1;
                double shift = 0.0;
                double corner0;
                double corner1;
                double scale;
                if(cp.sample_density <= 0.0)
                {
                  fprintf(stderr, "sample density (quality) must be greater than zero, not %g.\n", cp.sample_density);
                  return 1;
                }

                scale=pow(2.0, cp.zoom);
                sample_density = cp.sample_density * scale * scale;
                ppux = cp.pixels_per_unit * scale;
                ppuy = field != 0 ? ppux / 2.0 : ppux;
                ppux = ppux / spec->pixel_aspect_ratio;
                switch(field)
                {
                  case 0:
                  {
                    shift = 0.0;
                    break;
                  }
                  case 1:
                  {
                    shift = -0.5;
                    break;
                  }
                  case 2:
                    shift = 0.5;
                }
                shift = shift / ppux;
                t0 = (double)gutter_width / ((double)oversample * ppux);
                t1 = (double)gutter_width / ((double)oversample * ppuy);
                corner0 = cp.center[(signed long int)0] - ((double)image_width / ppux) / 2.0;
                corner1 = cp.center[(signed long int)1] - ((double)image_height / ppuy) / 2.0;
                fic.bounds[(signed long int)0] = corner0 - t0;
                fic.bounds[(signed long int)1] = (corner1 - t1) + shift;
                fic.bounds[(signed long int)2] = corner0 + (double)image_width / ppux + t0;
                fic.bounds[(signed long int)3] = corner1 + (double)image_height / ppuy + t1 + shift;
                fic.size[(signed long int)0] = 1.0 / (fic.bounds[(signed long int)2] - fic.bounds[(signed long int)0]);
                fic.size[(signed long int)1] = 1.0 / (fic.bounds[(signed long int)3] - fic.bounds[(signed long int)1]);
                fic.rot[(signed long int)0][(signed long int)0]=cos((cp.rotate * (double)2 * 3.14159265358979323846) / 360.0);
                double return_value_sin_6;
                return_value_sin_6=sin((cp.rotate * (double)2 * 3.14159265358979323846) / 360.0);
                fic.rot[(signed long int)0][(signed long int)1] = -return_value_sin_6;
                fic.rot[(signed long int)1][(signed long int)0] = -fic.rot[(signed long int)0][(signed long int)1];
                fic.rot[(signed long int)1][(signed long int)1] = fic.rot[(signed long int)0][(signed long int)0];
                fic.ws0 = (double)fic.width * fic.size[(signed long int)0];
                fic.wb0s0 = fic.ws0 * fic.bounds[(signed long int)0];
                fic.hs1 = (double)fic.height * fic.size[(signed long int)1];
                fic.hb1s1 = fic.hs1 * fic.bounds[(signed long int)1];
              }
              nsamples = sample_density * (double)image_width * (double)image_height;
              batch_size = nsamples / (double)(nbatches * ntemporal_samples);
              stats->num_iters = stats->num_iters + (signed long int)batch_size;
              fic.xform_distrib = xform_distrib;
              fic.spec = spec;
              fic.batch_size = batch_size / (double)spec->nthreads;
              fic.temporal_sample_num = temporal_sample_num;
              fic.ntemporal_samples = ntemporal_samples;
              fic.batch_num = batch_num;
              fic.nbatches = nbatches;
              fic.dmap = (struct anonymous_1 *)dmap;
              fic.color_scalar = color_scalar;
              fic.buckets = (void *)buckets;
              fic.progress_timer = &progress_timer;
              fic.progress_timer_history = &progress_timer_history[(signed long int)0];
              fic.progress_history = &progress_history[(signed long int)0];
              fic.progress_history_mark = &progress_history_mark;
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
              {
                signed int rk = 0;
                for( ; !(rk >= 16); rk = rk + 1)
                {
                  tmp_post_7 = (&spec->rc)->randcnt;
                  (&spec->rc)->randcnt = (&spec->rc)->randcnt - 1ul;
                  if(tmp_post_7 == 0ul)
                  {
                    isaac(&spec->rc);
                    (&spec->rc)->randcnt = (unsigned long int)((1 << 4) - 1);
                    tmp_if_expr_8 = (&spec->rc)->randrsl[(signed long int)(&spec->rc)->randcnt];
                  }

                  else
                    tmp_if_expr_8 = (&spec->rc)->randrsl[(signed long int)(&spec->rc)->randcnt];
                  (fth + (signed long int)thi)->rc.randrsl[(signed long int)rk] = tmp_if_expr_8;
                }
                irandinit(&(fth + (signed long int)thi)->rc, 1);
                if(thi == 0)
                {
                  (fth + (signed long int)thi)->first_thread = 1;
                  if(batch_num == 0 && temporal_sample_num == 0)
                    (fth + (signed long int)thi)->timer_initialize = 1;

                  else
                    (fth + (signed long int)thi)->timer_initialize = 0;
                }

                else
                {
                  (fth + (signed long int)thi)->first_thread = 0;
                  (fth + (signed long int)thi)->timer_initialize = 0;
                }
                (fth + (signed long int)thi)->iter_storage = &points[(signed long int)(thi * spec->sub_batch_size * 4)];
                (fth + (signed long int)thi)->fic = &fic;
                flam3_copy(&(fth + (signed long int)thi)->cp, &cp);
              }
              void *return_value_malloc_9;
              return_value_malloc_9=malloc((unsigned long int)spec->nthreads * sizeof(unsigned long int) /*8ul*/ );
              myThreads = (unsigned long int *)return_value_malloc_9;
              pthread_mutex_init(&fic.bucket_mutex, (const union anonymous_11 *)(void *)0);
              pthread_attr_init(&pt_attr);
              pthread_attr_setdetachstate(&pt_attr, 0);
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
                pthread_create(&myThreads[(signed long int)thi], &pt_attr, (void * (*)(void *))(void *)iter_thread_float, (void *)&fth[(signed long int)thi]);
              pthread_attr_destroy(&pt_attr);
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
                pthread_join(myThreads[(signed long int)thi], (void **)&thread_status);
              pthread_mutex_destroy(&fic.bucket_mutex);
              free((void *)myThreads);
              free((void *)xform_distrib);
              if(!(fic.aborted == 0))
              {
                if(!(render_rectangle_float__1__verbose == 0))
                  fprintf(stderr, "\naborted!\n");

                goto done;
              }

              vibrancy = vibrancy + cp.vibrancy;
              gamma = gamma + cp.gamma;
              background[(signed long int)0] = background[(signed long int)0] + cp.background[(signed long int)0];
              background[(signed long int)1] = background[(signed long int)1] + cp.background[(signed long int)1];
              background[(signed long int)2] = background[(signed long int)2] + cp.background[(signed long int)2];
              vib_gam_n = vib_gam_n + 1;
            }
            k1 = (cp.contrast * cp.brightness * (double)255 * 268.0 * batch_filter[(signed long int)batch_num]) / (double)256;
            area = (double)(image_width * image_height) / (ppux * ppuy);
            k2 = (double)(oversample * oversample * nbatches) / (cp.contrast * area * (double)255 * sample_density * sumfilt);
            if(de.max_filter_index == 0)
            {
              j = 0;
              for( ; !(j >= fic.height); j = j + 1)
              {
                i = 0;
                for( ; !(i >= fic.width); i = i + 1)
                {
                  float (*a)[4l] = accumulate + (signed long int)i + (signed long int)(j * fic.width);
                  unsigned int (*b)[5l] = buckets + (signed long int)i + (signed long int)(j * fic.width);
                  double c[4l];
                  double ls;
                  c[(signed long int)0] = (double)b[(signed long int)0][(signed long int)0];
                  c[(signed long int)1] = (double)b[(signed long int)0][(signed long int)1];
                  c[(signed long int)2] = (double)b[(signed long int)0][(signed long int)2];
                  c[(signed long int)3] = (double)b[(signed long int)0][(signed long int)3];
                  if(!IEEE_FLOAT_EQUAL(0.0, c[3l]))
                  {
                    double return_value_log_10;
                    return_value_log_10=log(1.0 + c[(signed long int)3] * k2);
                    ls = (k1 * return_value_log_10) / c[(signed long int)3];
                    c[(signed long int)0] = c[(signed long int)0] * ls;
                    c[(signed long int)1] = c[(signed long int)1] * ls;
                    c[(signed long int)2] = c[(signed long int)2] * ls;
                    c[(signed long int)3] = c[(signed long int)3] * ls;
                    do
                      a[(signed long int)0][(signed long int)0] = a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                    while((_Bool)0);
                    do
                      a[(signed long int)0][(signed long int)1] = a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                    while((_Bool)0);
                    do
                      a[(signed long int)0][(signed long int)2] = a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                    while((_Bool)0);
                    do
                      a[(signed long int)0][(signed long int)3] = a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                    while((_Bool)0);
                  }

                }
              }
            }

            else
            {
              struct anonymous_17 *deth;
              signed int de_aborted = 0;
              signed int myspan = (fic.height - 2 * (oversample - 1)) + 1;
              signed int swath = myspan / spec->nthreads;
              void *return_value_calloc_11;
              return_value_calloc_11=calloc((unsigned long int)spec->nthreads, sizeof(struct anonymous_17) /*104ul*/ );
              deth = (struct anonymous_17 *)return_value_calloc_11;
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
              {
                (deth + (signed long int)thi)->b = buckets;
                (deth + (signed long int)thi)->accumulate = accumulate;
                (deth + (signed long int)thi)->width = fic.width;
                (deth + (signed long int)thi)->height = fic.height;
                (deth + (signed long int)thi)->oversample = oversample;
                (deth + (signed long int)thi)->progress_size = spec->sub_batch_size / 10;
                (deth + (signed long int)thi)->de = &de;
                (deth + (signed long int)thi)->k1 = k1;
                (deth + (signed long int)thi)->k2 = k2;
                (deth + (signed long int)thi)->curve = cp.estimator_curve;
                (deth + (signed long int)thi)->spec = spec;
                (deth + (signed long int)thi)->aborted = &de_aborted;
                if(!(myspan >= spec->nthreads))
                {
                  (deth + (signed long int)thi)->start_row = 0;
                  if(thi == spec->nthreads + -1)
                  {
                    (deth + (signed long int)thi)->end_row = myspan;
                    (deth + (signed long int)thi)->last_thread = 1;
                  }

                  else
                  {
                    (deth + (signed long int)thi)->end_row = -1;
                    (deth + (signed long int)thi)->last_thread = 0;
                  }
                }

                else
                {
                  (deth + (signed long int)thi)->start_row = thi * swath;
                  (deth + (signed long int)thi)->end_row = (thi + 1) * swath;
                  if(thi == spec->nthreads + -1)
                  {
                    (deth + (signed long int)thi)->end_row = myspan;
                    (deth + (signed long int)thi)->last_thread = 1;
                  }

                  else
                    (deth + (signed long int)thi)->last_thread = 0;
                }
              }
              void *return_value_malloc_12;
              return_value_malloc_12=malloc((unsigned long int)spec->nthreads * sizeof(unsigned long int) /*8ul*/ );
              myThreads = (unsigned long int *)return_value_malloc_12;
              pthread_attr_init(&pt_attr);
              pthread_attr_setdetachstate(&pt_attr, 0);
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
                pthread_create(&myThreads[(signed long int)thi], &pt_attr, (void * (*)(void *))(void *)de_thread_33, (void *)&deth[(signed long int)thi]);
              pthread_attr_destroy(&pt_attr);
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
                pthread_join(myThreads[(signed long int)thi], (void **)&thread_status);
              free((void *)myThreads);
              free((void *)deth);
              if(!(de_aborted == 0))
              {
                if(!(render_rectangle_float__1__verbose == 0))
                  fprintf(stderr, "\naborted!\n");

                goto done;
              }

            }
            if(de.max_filter_index >= 1)
            {
              free((void *)de.filter_coefs);
              free((void *)de.filter_widths);
            }

          }
          if(!(render_rectangle_float__1__verbose == 0))
          {
            signed long int return_value_time_13;
            return_value_time_13=time((signed long int *)(void *)0);
            fprintf(stderr, "\rchaos: 100.0%%  took: %ld seconds   \n", return_value_time_13 - progress_began);
            fprintf(stderr, "filtering...");
          }

          {
            signed int x;
            signed int y;
            double t[4l];
            double newrgb[3l];
            double g = 1.0 / (gamma / (double)vib_gam_n);
            double tmp;
            double render_rectangle_float__1__13__a;
            double alpha;
            double render_rectangle_float__1__13__ls;
            signed int rgbi;
            double linrange = cp.gam_lin_thresh;
            vibrancy = vibrancy / (double)vib_gam_n;
            background[(signed long int)0] = background[(signed long int)0] / ((double)vib_gam_n / 256.0);
            background[(signed long int)1] = background[(signed long int)1] / ((double)vib_gam_n / 256.0);
            background[(signed long int)2] = background[(signed long int)2] / ((double)vib_gam_n / 256.0);
            if(!(spec->earlyclip == 0))
            {
              j = 0;
              for( ; !(j >= fic.height); j = j + 1)
              {
                i = 0;
                for( ; !(i >= fic.width); i = i + 1)
                {
                  float (*ac)[4l] = accumulate + (signed long int)i + (signed long int)(j * fic.width);
                  if((*ac)[3l] <= 0.000000f)
                  {
                    alpha = 0.0;
                    render_rectangle_float__1__13__ls = 0.0;
                  }

                  else
                  {
                    tmp = (double)(ac[(signed long int)0][(signed long int)3] / (float)255);
                    alpha=flam3_calc_alpha(tmp, g, linrange);
                    render_rectangle_float__1__13__ls = (vibrancy * 256.0 * alpha) / tmp;
                    if(alpha < 0.0)
                      alpha = 0.0;

                    if(alpha > 1.0)
                      alpha = 1.0;

                  }
                  t[(signed long int)0] = (double)ac[(signed long int)0][(signed long int)0];
                  t[(signed long int)1] = (double)ac[(signed long int)0][(signed long int)1];
                  t[(signed long int)2] = (double)ac[(signed long int)0][(signed long int)2];
                  t[(signed long int)3] = (double)ac[(signed long int)0][(signed long int)3];
                  flam3_calc_newrgb(t, render_rectangle_float__1__13__ls, highpow, newrgb);
                  rgbi = 0;
                  for( ; !(rgbi >= 3); rgbi = rgbi + 1)
                  {
                    render_rectangle_float__1__13__a = newrgb[(signed long int)rgbi];
                    double return_value_pow_14;
                    return_value_pow_14=pow(t[(signed long int)rgbi] / (double)255, g);
                    render_rectangle_float__1__13__a = render_rectangle_float__1__13__a + (1.0 - vibrancy) * 256.0 * return_value_pow_14;
                    if(transp == 0 || !(nchan >= 4))
                      render_rectangle_float__1__13__a = render_rectangle_float__1__13__a + (1.0 - alpha) * background[(signed long int)rgbi];

                    else
                      if(alpha > 0.000000)
                        render_rectangle_float__1__13__a = render_rectangle_float__1__13__a / alpha;

                      else
                        render_rectangle_float__1__13__a = (double)0;
                    if(render_rectangle_float__1__13__a > 255.000000)
                      render_rectangle_float__1__13__a = (double)255;

                    if(render_rectangle_float__1__13__a < 0.000000)
                      render_rectangle_float__1__13__a = (double)0;

                    ac[(signed long int)0][(signed long int)rgbi] = (float)render_rectangle_float__1__13__a;
                  }
                  ac[(signed long int)0][(signed long int)3] = (float)alpha;
                }
              }
            }

            y = de_offset;
            j = 0;
            for( ; !(j >= image_height); j = j + 1)
            {
              x = de_offset;
              i = 0;
              for( ; !(i >= image_width); i = i + 1)
              {
                signed int ii;
                signed int jj;
                signed int render_rectangle_float__1__13__2__1__1__1__rgbi;
                void *p;
                unsigned short int *p16;
                unsigned char *p8;
                t[(signed long int)3] = 0.0;
                t[(signed long int)2] = t[(signed long int)3];
                t[(signed long int)1] = t[(signed long int)2];
                t[(signed long int)0] = t[(signed long int)1];
                ii = 0;
                for( ; !(ii >= filter_width); ii = ii + 1)
                {
                  jj = 0;
                  for( ; !(jj >= filter_width); jj = jj + 1)
                  {
                    double k = filter[(signed long int)(ii + jj * filter_width)];
                    float (*render_rectangle_float__1__13__2__1__1__1__1__1__1__1__ac)[4l] = accumulate + (signed long int)x + (signed long int)ii + (signed long int)((y + jj) * fic.width);
                    t[(signed long int)0] = t[(signed long int)0] + k * (double)render_rectangle_float__1__13__2__1__1__1__1__1__1__1__ac[(signed long int)0][(signed long int)0];
                    t[(signed long int)1] = t[(signed long int)1] + k * (double)render_rectangle_float__1__13__2__1__1__1__1__1__1__1__ac[(signed long int)0][(signed long int)1];
                    t[(signed long int)2] = t[(signed long int)2] + k * (double)render_rectangle_float__1__13__2__1__1__1__1__1__1__1__ac[(signed long int)0][(signed long int)2];
                    t[(signed long int)3] = t[(signed long int)3] + k * (double)render_rectangle_float__1__13__2__1__1__1__1__1__1__1__ac[(signed long int)0][(signed long int)3];
                  }
                }
                p = (void *)((unsigned char *)out + (signed long int)(nchan * bytes_per_channel * (i + j * out_width)));
                p8 = (unsigned char *)p;
                p16 = (unsigned short int *)p;
                if(spec->earlyclip == 0)
                {
                  tmp = t[(signed long int)3] / (double)255;
                  if(t[3l] <= 0.000000)
                  {
                    alpha = 0.0;
                    render_rectangle_float__1__13__ls = 0.0;
                  }

                  else
                  {
                    alpha=flam3_calc_alpha(tmp, g, linrange);
                    render_rectangle_float__1__13__ls = (vibrancy * 256.0 * alpha) / tmp;
                    if(alpha < 0.0)
                      alpha = 0.0;

                    if(alpha > 1.0)
                      alpha = 1.0;

                  }
                  flam3_calc_newrgb(t, render_rectangle_float__1__13__ls, highpow, newrgb);
                  render_rectangle_float__1__13__2__1__1__1__rgbi = 0;
                  for( ; !(render_rectangle_float__1__13__2__1__1__1__rgbi >= 3); render_rectangle_float__1__13__2__1__1__1__rgbi = render_rectangle_float__1__13__2__1__1__1__rgbi + 1)
                  {
                    render_rectangle_float__1__13__a = newrgb[(signed long int)render_rectangle_float__1__13__2__1__1__1__rgbi];
                    double return_value_pow_15;
                    return_value_pow_15=pow(t[(signed long int)render_rectangle_float__1__13__2__1__1__1__rgbi] / (double)255, g);
                    render_rectangle_float__1__13__a = render_rectangle_float__1__13__a + (1.0 - vibrancy) * 256.0 * return_value_pow_15;
                    if(transp == 0 || !(nchan >= 4))
                      render_rectangle_float__1__13__a = render_rectangle_float__1__13__a + (1.0 - alpha) * background[(signed long int)render_rectangle_float__1__13__2__1__1__1__rgbi];

                    else
                      if(alpha > 0.000000)
                        render_rectangle_float__1__13__a = render_rectangle_float__1__13__a / alpha;

                      else
                        render_rectangle_float__1__13__a = (double)0;
                    if(render_rectangle_float__1__13__a > 255.000000)
                      render_rectangle_float__1__13__a = (double)255;

                    if(render_rectangle_float__1__13__a < 0.000000)
                      render_rectangle_float__1__13__a = (double)0;

                    t[(signed long int)render_rectangle_float__1__13__2__1__1__1__rgbi] = render_rectangle_float__1__13__a;
                  }
                  t[(signed long int)3] = alpha;
                }

                render_rectangle_float__1__13__2__1__1__1__rgbi = 0;
                for( ; !(render_rectangle_float__1__13__2__1__1__1__rgbi >= 3); render_rectangle_float__1__13__2__1__1__1__rgbi = render_rectangle_float__1__13__2__1__1__1__rgbi + 1)
                {
                  render_rectangle_float__1__13__a = t[(signed long int)render_rectangle_float__1__13__2__1__1__1__rgbi];
                  if(render_rectangle_float__1__13__a > 255.000000)
                    render_rectangle_float__1__13__a = (double)255;

                  if(render_rectangle_float__1__13__a < 0.000000)
                    render_rectangle_float__1__13__a = (double)0;

                  if(bytes_per_channel == 2)
                  {
                    render_rectangle_float__1__13__a = render_rectangle_float__1__13__a * 256.0;
                    p16[(signed long int)render_rectangle_float__1__13__2__1__1__1__rgbi] = (unsigned short int)render_rectangle_float__1__13__a;
                  }

                  else
                    p8[(signed long int)render_rectangle_float__1__13__2__1__1__1__rgbi] = (unsigned char)render_rectangle_float__1__13__a;
                }
                if(t[3l] > 1.000000)
                  t[(signed long int)3] = (double)1;

                if(t[3l] < 0.000000)
                  t[(signed long int)3] = (double)0;

                if(nchan >= 4)
                {
                  if(transp == 1)
                  {
                    if(bytes_per_channel == 2)
                      p16[(signed long int)3] = (unsigned short int)(t[(signed long int)3] * (double)65535);

                    else
                      p8[(signed long int)3] = (unsigned char)(t[(signed long int)3] * (double)255);
                  }

                  else
                    if(bytes_per_channel == 2)
                      p16[(signed long int)3] = (unsigned short int)65535;

                    else
                      p8[(signed long int)3] = (unsigned char)255;
                }

                x = x + oversample;
              }
              y = y + oversample;
            }
          }

        done:
          ;
          stats->badvals = fic.badvals;
          free((void *)temporal_filter);
          free((void *)temporal_deltas);
          free((void *)batch_filter);
          free((void *)filter);
          free((void *)buckets);
          thi = 0;
          for( ; !(thi >= spec->nthreads); thi = thi + 1)
            clear_cp(&(fth + (signed long int)thi)->cp, 0);
          free((void *)fth);
          clear_cp(&cp, 0);
          char *return_value_getenv_16;
          return_value_getenv_16=getenv("insert_palette");
          if(!(return_value_getenv_16 == ((char *)NULL)))
          {
            signed int ph = 100;
            if(ph >= image_height)
              ph = image_height;

            j = 0;
            for( ; !(j >= ph); j = j + 1)
            {
              i = 0;
              for( ; !(i >= image_width); i = i + 1)
              {
                unsigned char *render_rectangle_float__1__15__1__1__1__1__p = (unsigned char *)out + (signed long int)(nchan * (i + j * out_width));
                render_rectangle_float__1__15__1__1__1__1__p[(signed long int)0] = (unsigned char)dmap[(signed long int)((i * 256) / image_width)].color[(signed long int)0];
                render_rectangle_float__1__15__1__1__1__1__p[(signed long int)1] = (unsigned char)dmap[(signed long int)((i * 256) / image_width)].color[(signed long int)1];
                render_rectangle_float__1__15__1__1__1__1__p[(signed long int)2] = (unsigned char)dmap[(signed long int)((i * 256) / image_width)].color[(signed long int)2];
              }
            }
          }

          tend=time((signed long int *)(void *)0);
          stats->render_seconds = (signed int)(tend - tstart);
          return 0;
        }
      }
    }
}

// render_rectangle_float_mt
// file rect.c line 527
static signed int render_rectangle_float_mt(struct anonymous_4 *spec, void *out, signed int field, signed int nchan, signed int transp, struct anonymous_8 *stats)
{
  signed long int nbuckets;
  signed int i;
  signed int j;
  signed int render_rectangle_float_mt__1__k;
  signed int batch_num;
  signed int temporal_sample_num;
  double nsamples;
  double batch_size;
  unsigned int (*buckets)[5l];
  float (*accumulate)[4l];
  double *points;
  double *filter;
  double *temporal_filter;
  double *temporal_deltas;
  double *batch_filter;
  double ppux = (double)0;
  double ppuy = (double)0;
  signed int image_width;
  signed int image_height;
  signed int out_width;
  signed int filter_width = 0;
  signed int bytes_per_channel = spec->bytes_per_channel;
  signed int oversample;
  double highpow;
  signed int nbatches;
  signed int ntemporal_samples;
  struct anonymous_1 dmap[256l];
  signed int gutter_width;
  double vibrancy = 0.0;
  double gamma = 0.0;
  double background[3l];
  signed int vib_gam_n = 0;
  signed long int progress_began = (signed long int)0;
  signed int render_rectangle_float_mt__1__verbose = spec->verbose;
  signed int gnm_idx;
  signed int max_gnm_de_fw;
  signed int de_offset;
  struct anonymous_0 cp;
  unsigned short int *xform_distrib;
  struct anonymous_12 fic;
  struct anonymous_13 *fth;
  union pthread_attr_t pt_attr;
  unsigned long int *myThreads = (unsigned long int *)(void *)0;
  signed int thread_status;
  signed int thi;
  signed long int tstart;
  signed long int tend;
  double sumfilt;
  char *last_block;
  unsigned long int memory_rqd;
  signed long int progress_timer = (signed long int)0;
  signed long int progress_timer_history[64l];
  double progress_history[64l];
  signed int progress_history_mark = 0;
  tstart=time((signed long int *)(void *)0);
  fic.badvals = (double)0;
  fic.aborted = 0;
  stats->num_iters = (signed long int)0;
  memset((void *)&cp, 0, sizeof(struct anonymous_0) /*10712ul*/ );
  flam3_interpolate(spec->genomes, spec->ngenomes, spec->time, (double)0, &cp);
  oversample = cp.spatial_oversample;
  highpow = cp.highlight_power;
  nbatches = cp.nbatches;
  ntemporal_samples = cp.ntemporal_samples;
  unsigned long int tmp_post_7;
  unsigned long int tmp_if_expr_8;
  if(!(nbatches >= 1))
  {
    fprintf(stderr, "nbatches must be positive, not %d.\n", nbatches);
    return 1;
  }

  else
    if(!(oversample >= 1))
    {
      fprintf(stderr, "oversample must be positive, not %d.\n", oversample);
      return 1;
    }

    else
    {
      void *return_value_calloc_1;
      return_value_calloc_1=calloc((unsigned long int)spec->nthreads, sizeof(struct anonymous_13) /*11024ul*/ );
      fth = (struct anonymous_13 *)return_value_calloc_1;
      i = 0;
      for( ; !(i >= spec->nthreads); i = i + 1)
        (fth + (signed long int)i)->cp.final_xform_index = -1;
      image_width = cp.width;
      out_width = image_width;
      if(!(field == 0))
      {
        image_height = cp.height / 2;
        if(field == 2)
          out = (void *)((unsigned char *)out + (signed long int)(nchan * bytes_per_channel * out_width));

        out_width = out_width * 2;
      }

      else
        image_height = cp.height;
      filter_width=flam3_create_spatial_filter(spec, field, &filter);
      if(!(filter_width >= 0))
      {
        fprintf(stderr, "flam3_create_spatial_filter returned error: aborting\n");
        return 1;
      }

      else
      {
        void *return_value_malloc_2;
        return_value_malloc_2=malloc(sizeof(double) /*8ul*/  * (unsigned long int)nbatches);
        batch_filter = (double *)return_value_malloc_2;
        i = 0;
        for( ; !(i >= nbatches); i = i + 1)
          batch_filter[(signed long int)i] = 1.0 / (double)nbatches;
        sumfilt=flam3_create_temporal_filter(nbatches * ntemporal_samples, cp.temporal_filter_type, cp.temporal_filter_exp, cp.temporal_filter_width, &temporal_filter, &temporal_deltas);
        gutter_width = (filter_width - oversample) / 2;
        max_gnm_de_fw = 0;
        gnm_idx = 0;
        for( ; !(gnm_idx >= spec->ngenomes); gnm_idx = gnm_idx + 1)
        {
          signed int this_width;
          double return_value_ceil_3;
          return_value_ceil_3=ceil((spec->genomes + (signed long int)gnm_idx)->estimator);
          this_width = (signed int)return_value_ceil_3 * oversample;
          if(!(max_gnm_de_fw >= this_width))
            max_gnm_de_fw = this_width;

        }
        if(max_gnm_de_fw >= 1)
          max_gnm_de_fw = max_gnm_de_fw + (oversample - 1);

        if(!(gutter_width >= max_gnm_de_fw))
        {
          de_offset = max_gnm_de_fw - gutter_width;
          gutter_width = max_gnm_de_fw;
        }

        else
          de_offset = 0;
        fic.height = oversample * image_height + 2 * gutter_width;
        fic.width = oversample * image_width + 2 * gutter_width;
        nbuckets = (signed long int)fic.width * (signed long int)fic.height;
        memory_rqd = sizeof(unsigned int [5l]) /*20ul*/  * (unsigned long int)nbuckets + sizeof(float [4l]) /*16ul*/  * (unsigned long int)nbuckets + (unsigned long int)4 * sizeof(double) /*8ul*/  * (unsigned long int)spec->sub_batch_size * (unsigned long int)spec->nthreads;
        void *return_value_malloc_4;
        return_value_malloc_4=malloc(memory_rqd);
        last_block = (char *)return_value_malloc_4;
        if(last_block == ((char *)NULL))
        {
          fprintf(stderr, "render_rectangle: cannot malloc %g bytes.\n", (double)memory_rqd);
          fprintf(stderr, "render_rectangle: w=%d h=%d nb=%ld.\n", fic.width, fic.height, nbuckets);
          return 1;
        }

        else
        {
          buckets = (unsigned int (*)[5l])last_block;
          accumulate = (float (*)[4l])(last_block + (signed long int)(sizeof(unsigned int [5l]) /*20ul*/  * (unsigned long int)nbuckets));
          points = (double *)(last_block + (signed long int)((sizeof(unsigned int [5l]) /*20ul*/  + sizeof(float [4l]) /*16ul*/ ) * (unsigned long int)nbuckets));
          if(!(render_rectangle_float_mt__1__verbose == 0))
          {
            fprintf(stderr, "chaos: ");
            progress_began=time((signed long int *)(void *)0);
          }

          background[(signed long int)2] = 0.0;
          background[(signed long int)1] = background[(signed long int)2];
          background[(signed long int)0] = background[(signed long int)1];
          memset((void *)(char *)accumulate, 0, sizeof(float [4l]) /*16ul*/  * (unsigned long int)nbuckets);
          batch_num = 0;
          for( ; !(batch_num >= nbatches); batch_num = batch_num + 1)
          {
            double de_time;
            double sample_density = 0.0;
            double k1;
            double area;
            double k2;
            struct anonymous_6 de;
            de_time = spec->time + temporal_deltas[(signed long int)(batch_num * ntemporal_samples)];
            memset((void *)(char *)buckets, 0, sizeof(unsigned int [5l]) /*20ul*/  * (unsigned long int)nbuckets);
            flam3_interpolate(spec->genomes, spec->ngenomes, de_time, (double)0, &cp);
            if(cp.estimator < 0.0 || cp.estimator_minimum < 0.0)
            {
              fprintf(stderr, "density estimator filter widths must be >= 0\n");
              return 1;
            }

            if(!(spec->bits >= 33))
            {
              if(cp.estimator > 0.0)
              {
                fprintf(stderr, "warning: density estimation disabled with %d bit buffers.\n", spec->bits);
                cp.estimator = 0.0;
              }

            }

            if(cp.estimator > 0.0)
            {
              de=flam3_create_de_filters(cp.estimator, cp.estimator_minimum, cp.estimator_curve, oversample);
              if(!(de.kernel_size >= 0))
              {
                fprintf(stderr, "de.kernel_size returned 0 - aborting.\n");
                return 1;
              }

            }

            else
              de.max_filter_index = 0;
            temporal_sample_num = 0;
            for( ; !(temporal_sample_num >= ntemporal_samples); temporal_sample_num = temporal_sample_num + 1)
            {
              double temporal_sample_time;
              double color_scalar = temporal_filter[(signed long int)(batch_num * ntemporal_samples + temporal_sample_num)];
              temporal_sample_time = spec->time + temporal_deltas[(signed long int)(batch_num * ntemporal_samples + temporal_sample_num)];
              flam3_interpolate(spec->genomes, spec->ngenomes, temporal_sample_time, (double)0, &cp);
              signed int return_value_prepare_precalc_flags_5;
              return_value_prepare_precalc_flags_5=prepare_precalc_flags(&cp);
              if(!(return_value_prepare_precalc_flags_5 == 0))
              {
                fprintf(stderr, "prepare xform pointers returned error: aborting.\n");
                return 1;
              }

              xform_distrib=flam3_create_xform_distrib(&cp);
              if(xform_distrib == ((unsigned short int *)NULL))
              {
                fprintf(stderr, "create xform distrib returned error: aborting.\n");
                return 1;
              }

              j = 0;
              for( ; !(j >= 256); j = j + 1)
              {
                dmap[(signed long int)j].index = cp.palette[(signed long int)((j * 256) / 256)].index / 256.0;
                render_rectangle_float_mt__1__k = 0;
                for( ; !(render_rectangle_float_mt__1__k >= 4); render_rectangle_float_mt__1__k = render_rectangle_float_mt__1__k + 1)
                  dmap[(signed long int)j].color[(signed long int)render_rectangle_float_mt__1__k] = cp.palette[(signed long int)((j * 256) / 256)].color[(signed long int)render_rectangle_float_mt__1__k] * (double)255 * color_scalar;
              }
              {
                double t0;
                double t1;
                double shift = 0.0;
                double corner0;
                double corner1;
                double scale;
                if(cp.sample_density <= 0.0)
                {
                  fprintf(stderr, "sample density (quality) must be greater than zero, not %g.\n", cp.sample_density);
                  return 1;
                }

                scale=pow(2.0, cp.zoom);
                sample_density = cp.sample_density * scale * scale;
                ppux = cp.pixels_per_unit * scale;
                ppuy = field != 0 ? ppux / 2.0 : ppux;
                ppux = ppux / spec->pixel_aspect_ratio;
                switch(field)
                {
                  case 0:
                  {
                    shift = 0.0;
                    break;
                  }
                  case 1:
                  {
                    shift = -0.5;
                    break;
                  }
                  case 2:
                    shift = 0.5;
                }
                shift = shift / ppux;
                t0 = (double)gutter_width / ((double)oversample * ppux);
                t1 = (double)gutter_width / ((double)oversample * ppuy);
                corner0 = cp.center[(signed long int)0] - ((double)image_width / ppux) / 2.0;
                corner1 = cp.center[(signed long int)1] - ((double)image_height / ppuy) / 2.0;
                fic.bounds[(signed long int)0] = corner0 - t0;
                fic.bounds[(signed long int)1] = (corner1 - t1) + shift;
                fic.bounds[(signed long int)2] = corner0 + (double)image_width / ppux + t0;
                fic.bounds[(signed long int)3] = corner1 + (double)image_height / ppuy + t1 + shift;
                fic.size[(signed long int)0] = 1.0 / (fic.bounds[(signed long int)2] - fic.bounds[(signed long int)0]);
                fic.size[(signed long int)1] = 1.0 / (fic.bounds[(signed long int)3] - fic.bounds[(signed long int)1]);
                fic.rot[(signed long int)0][(signed long int)0]=cos((cp.rotate * (double)2 * 3.14159265358979323846) / 360.0);
                double return_value_sin_6;
                return_value_sin_6=sin((cp.rotate * (double)2 * 3.14159265358979323846) / 360.0);
                fic.rot[(signed long int)0][(signed long int)1] = -return_value_sin_6;
                fic.rot[(signed long int)1][(signed long int)0] = -fic.rot[(signed long int)0][(signed long int)1];
                fic.rot[(signed long int)1][(signed long int)1] = fic.rot[(signed long int)0][(signed long int)0];
                fic.ws0 = (double)fic.width * fic.size[(signed long int)0];
                fic.wb0s0 = fic.ws0 * fic.bounds[(signed long int)0];
                fic.hs1 = (double)fic.height * fic.size[(signed long int)1];
                fic.hb1s1 = fic.hs1 * fic.bounds[(signed long int)1];
              }
              nsamples = sample_density * (double)image_width * (double)image_height;
              batch_size = nsamples / (double)(nbatches * ntemporal_samples);
              stats->num_iters = stats->num_iters + (signed long int)batch_size;
              fic.xform_distrib = xform_distrib;
              fic.spec = spec;
              fic.batch_size = batch_size / (double)spec->nthreads;
              fic.temporal_sample_num = temporal_sample_num;
              fic.ntemporal_samples = ntemporal_samples;
              fic.batch_num = batch_num;
              fic.nbatches = nbatches;
              fic.dmap = (struct anonymous_1 *)dmap;
              fic.color_scalar = color_scalar;
              fic.buckets = (void *)buckets;
              fic.progress_timer = &progress_timer;
              fic.progress_timer_history = &progress_timer_history[(signed long int)0];
              fic.progress_history = &progress_history[(signed long int)0];
              fic.progress_history_mark = &progress_history_mark;
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
              {
                signed int rk = 0;
                for( ; !(rk >= 16); rk = rk + 1)
                {
                  tmp_post_7 = (&spec->rc)->randcnt;
                  (&spec->rc)->randcnt = (&spec->rc)->randcnt - 1ul;
                  if(tmp_post_7 == 0ul)
                  {
                    isaac(&spec->rc);
                    (&spec->rc)->randcnt = (unsigned long int)((1 << 4) - 1);
                    tmp_if_expr_8 = (&spec->rc)->randrsl[(signed long int)(&spec->rc)->randcnt];
                  }

                  else
                    tmp_if_expr_8 = (&spec->rc)->randrsl[(signed long int)(&spec->rc)->randcnt];
                  (fth + (signed long int)thi)->rc.randrsl[(signed long int)rk] = tmp_if_expr_8;
                }
                irandinit(&(fth + (signed long int)thi)->rc, 1);
                if(thi == 0)
                {
                  (fth + (signed long int)thi)->first_thread = 1;
                  if(batch_num == 0 && temporal_sample_num == 0)
                    (fth + (signed long int)thi)->timer_initialize = 1;

                  else
                    (fth + (signed long int)thi)->timer_initialize = 0;
                }

                else
                {
                  (fth + (signed long int)thi)->first_thread = 0;
                  (fth + (signed long int)thi)->timer_initialize = 0;
                }
                (fth + (signed long int)thi)->iter_storage = &points[(signed long int)(thi * spec->sub_batch_size * 4)];
                (fth + (signed long int)thi)->fic = &fic;
                flam3_copy(&(fth + (signed long int)thi)->cp, &cp);
              }
              void *return_value_malloc_9;
              return_value_malloc_9=malloc((unsigned long int)spec->nthreads * sizeof(unsigned long int) /*8ul*/ );
              myThreads = (unsigned long int *)return_value_malloc_9;
              pthread_attr_init(&pt_attr);
              pthread_attr_setdetachstate(&pt_attr, 0);
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
                pthread_create(&myThreads[(signed long int)thi], &pt_attr, (void * (*)(void *))(void *)iter_thread_float_mt, (void *)&fth[(signed long int)thi]);
              pthread_attr_destroy(&pt_attr);
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
                pthread_join(myThreads[(signed long int)thi], (void **)&thread_status);
              free((void *)myThreads);
              free((void *)xform_distrib);
              if(!(fic.aborted == 0))
              {
                if(!(render_rectangle_float_mt__1__verbose == 0))
                  fprintf(stderr, "\naborted!\n");

                goto done;
              }

              vibrancy = vibrancy + cp.vibrancy;
              gamma = gamma + cp.gamma;
              background[(signed long int)0] = background[(signed long int)0] + cp.background[(signed long int)0];
              background[(signed long int)1] = background[(signed long int)1] + cp.background[(signed long int)1];
              background[(signed long int)2] = background[(signed long int)2] + cp.background[(signed long int)2];
              vib_gam_n = vib_gam_n + 1;
            }
            k1 = (cp.contrast * cp.brightness * (double)255 * 268.0 * batch_filter[(signed long int)batch_num]) / (double)256;
            area = (double)(image_width * image_height) / (ppux * ppuy);
            k2 = (double)(oversample * oversample * nbatches) / (cp.contrast * area * (double)255 * sample_density * sumfilt);
            if(de.max_filter_index == 0)
            {
              j = 0;
              for( ; !(j >= fic.height); j = j + 1)
              {
                i = 0;
                for( ; !(i >= fic.width); i = i + 1)
                {
                  float (*a)[4l] = accumulate + (signed long int)i + (signed long int)(j * fic.width);
                  unsigned int (*b)[5l] = buckets + (signed long int)i + (signed long int)(j * fic.width);
                  double c[4l];
                  double ls;
                  c[(signed long int)0] = (double)b[(signed long int)0][(signed long int)0];
                  c[(signed long int)1] = (double)b[(signed long int)0][(signed long int)1];
                  c[(signed long int)2] = (double)b[(signed long int)0][(signed long int)2];
                  c[(signed long int)3] = (double)b[(signed long int)0][(signed long int)3];
                  if(!IEEE_FLOAT_EQUAL(0.0, c[3l]))
                  {
                    double return_value_log_10;
                    return_value_log_10=log(1.0 + c[(signed long int)3] * k2);
                    ls = (k1 * return_value_log_10) / c[(signed long int)3];
                    c[(signed long int)0] = c[(signed long int)0] * ls;
                    c[(signed long int)1] = c[(signed long int)1] * ls;
                    c[(signed long int)2] = c[(signed long int)2] * ls;
                    c[(signed long int)3] = c[(signed long int)3] * ls;
                    do
                      a[(signed long int)0][(signed long int)0] = a[(signed long int)0][(signed long int)0] + (float)c[(signed long int)0];
                    while((_Bool)0);
                    do
                      a[(signed long int)0][(signed long int)1] = a[(signed long int)0][(signed long int)1] + (float)c[(signed long int)1];
                    while((_Bool)0);
                    do
                      a[(signed long int)0][(signed long int)2] = a[(signed long int)0][(signed long int)2] + (float)c[(signed long int)2];
                    while((_Bool)0);
                    do
                      a[(signed long int)0][(signed long int)3] = a[(signed long int)0][(signed long int)3] + (float)c[(signed long int)3];
                    while((_Bool)0);
                  }

                }
              }
            }

            else
            {
              struct anonymous_17 *deth;
              signed int de_aborted = 0;
              signed int myspan = (fic.height - 2 * (oversample - 1)) + 1;
              signed int swath = myspan / spec->nthreads;
              void *return_value_calloc_11;
              return_value_calloc_11=calloc((unsigned long int)spec->nthreads, sizeof(struct anonymous_17) /*104ul*/ );
              deth = (struct anonymous_17 *)return_value_calloc_11;
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
              {
                (deth + (signed long int)thi)->b = buckets;
                (deth + (signed long int)thi)->accumulate = accumulate;
                (deth + (signed long int)thi)->width = fic.width;
                (deth + (signed long int)thi)->height = fic.height;
                (deth + (signed long int)thi)->oversample = oversample;
                (deth + (signed long int)thi)->progress_size = spec->sub_batch_size / 10;
                (deth + (signed long int)thi)->de = &de;
                (deth + (signed long int)thi)->k1 = k1;
                (deth + (signed long int)thi)->k2 = k2;
                (deth + (signed long int)thi)->curve = cp.estimator_curve;
                (deth + (signed long int)thi)->spec = spec;
                (deth + (signed long int)thi)->aborted = &de_aborted;
                if(!(myspan >= spec->nthreads))
                {
                  (deth + (signed long int)thi)->start_row = 0;
                  if(thi == spec->nthreads + -1)
                  {
                    (deth + (signed long int)thi)->end_row = myspan;
                    (deth + (signed long int)thi)->last_thread = 1;
                  }

                  else
                  {
                    (deth + (signed long int)thi)->end_row = -1;
                    (deth + (signed long int)thi)->last_thread = 0;
                  }
                }

                else
                {
                  (deth + (signed long int)thi)->start_row = thi * swath;
                  (deth + (signed long int)thi)->end_row = (thi + 1) * swath;
                  if(thi == spec->nthreads + -1)
                  {
                    (deth + (signed long int)thi)->end_row = myspan;
                    (deth + (signed long int)thi)->last_thread = 1;
                  }

                  else
                    (deth + (signed long int)thi)->last_thread = 0;
                }
              }
              void *return_value_malloc_12;
              return_value_malloc_12=malloc((unsigned long int)spec->nthreads * sizeof(unsigned long int) /*8ul*/ );
              myThreads = (unsigned long int *)return_value_malloc_12;
              pthread_attr_init(&pt_attr);
              pthread_attr_setdetachstate(&pt_attr, 0);
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
                pthread_create(&myThreads[(signed long int)thi], &pt_attr, (void * (*)(void *))(void *)de_thread_33_mt, (void *)&deth[(signed long int)thi]);
              pthread_attr_destroy(&pt_attr);
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
                pthread_join(myThreads[(signed long int)thi], (void **)&thread_status);
              free((void *)myThreads);
              free((void *)deth);
              if(!(de_aborted == 0))
              {
                if(!(render_rectangle_float_mt__1__verbose == 0))
                  fprintf(stderr, "\naborted!\n");

                goto done;
              }

            }
            if(de.max_filter_index >= 1)
            {
              free((void *)de.filter_coefs);
              free((void *)de.filter_widths);
            }

          }
          if(!(render_rectangle_float_mt__1__verbose == 0))
          {
            signed long int return_value_time_13;
            return_value_time_13=time((signed long int *)(void *)0);
            fprintf(stderr, "\rchaos: 100.0%%  took: %ld seconds   \n", return_value_time_13 - progress_began);
            fprintf(stderr, "filtering...");
          }

          {
            signed int x;
            signed int y;
            double t[4l];
            double newrgb[3l];
            double g = 1.0 / (gamma / (double)vib_gam_n);
            double tmp;
            double render_rectangle_float_mt__1__13__a;
            double alpha;
            double render_rectangle_float_mt__1__13__ls;
            signed int render_rectangle_float_mt__1__13__rgbi;
            double linrange = cp.gam_lin_thresh;
            vibrancy = vibrancy / (double)vib_gam_n;
            background[(signed long int)0] = background[(signed long int)0] / ((double)vib_gam_n / 256.0);
            background[(signed long int)1] = background[(signed long int)1] / ((double)vib_gam_n / 256.0);
            background[(signed long int)2] = background[(signed long int)2] / ((double)vib_gam_n / 256.0);
            if(!(spec->earlyclip == 0))
            {
              j = 0;
              for( ; !(j >= fic.height); j = j + 1)
              {
                i = 0;
                for( ; !(i >= fic.width); i = i + 1)
                {
                  float (*ac)[4l] = accumulate + (signed long int)i + (signed long int)(j * fic.width);
                  if((*ac)[3l] <= 0.000000f)
                  {
                    alpha = 0.0;
                    render_rectangle_float_mt__1__13__ls = 0.0;
                  }

                  else
                  {
                    tmp = (double)(ac[(signed long int)0][(signed long int)3] / (float)255);
                    alpha=flam3_calc_alpha(tmp, g, linrange);
                    render_rectangle_float_mt__1__13__ls = (vibrancy * 256.0 * alpha) / tmp;
                    if(alpha < 0.0)
                      alpha = 0.0;

                    if(alpha > 1.0)
                      alpha = 1.0;

                  }
                  t[(signed long int)0] = (double)ac[(signed long int)0][(signed long int)0];
                  t[(signed long int)1] = (double)ac[(signed long int)0][(signed long int)1];
                  t[(signed long int)2] = (double)ac[(signed long int)0][(signed long int)2];
                  t[(signed long int)3] = (double)ac[(signed long int)0][(signed long int)3];
                  flam3_calc_newrgb(t, render_rectangle_float_mt__1__13__ls, highpow, newrgb);
                  render_rectangle_float_mt__1__13__rgbi = 0;
                  for( ; !(render_rectangle_float_mt__1__13__rgbi >= 3); render_rectangle_float_mt__1__13__rgbi = render_rectangle_float_mt__1__13__rgbi + 1)
                  {
                    render_rectangle_float_mt__1__13__a = newrgb[(signed long int)render_rectangle_float_mt__1__13__rgbi];
                    double return_value_pow_14;
                    return_value_pow_14=pow(t[(signed long int)render_rectangle_float_mt__1__13__rgbi] / (double)255, g);
                    render_rectangle_float_mt__1__13__a = render_rectangle_float_mt__1__13__a + (1.0 - vibrancy) * 256.0 * return_value_pow_14;
                    if(transp == 0 || !(nchan >= 4))
                      render_rectangle_float_mt__1__13__a = render_rectangle_float_mt__1__13__a + (1.0 - alpha) * background[(signed long int)render_rectangle_float_mt__1__13__rgbi];

                    else
                      if(alpha > 0.000000)
                        render_rectangle_float_mt__1__13__a = render_rectangle_float_mt__1__13__a / alpha;

                      else
                        render_rectangle_float_mt__1__13__a = (double)0;
                    if(render_rectangle_float_mt__1__13__a > 255.000000)
                      render_rectangle_float_mt__1__13__a = (double)255;

                    if(render_rectangle_float_mt__1__13__a < 0.000000)
                      render_rectangle_float_mt__1__13__a = (double)0;

                    ac[(signed long int)0][(signed long int)render_rectangle_float_mt__1__13__rgbi] = (float)render_rectangle_float_mt__1__13__a;
                  }
                  ac[(signed long int)0][(signed long int)3] = (float)alpha;
                }
              }
            }

            y = de_offset;
            j = 0;
            for( ; !(j >= image_height); j = j + 1)
            {
              x = de_offset;
              i = 0;
              for( ; !(i >= image_width); i = i + 1)
              {
                signed int ii;
                signed int jj;
                signed int rgbi;
                void *p;
                unsigned short int *p16;
                unsigned char *p8;
                t[(signed long int)3] = 0.0;
                t[(signed long int)2] = t[(signed long int)3];
                t[(signed long int)1] = t[(signed long int)2];
                t[(signed long int)0] = t[(signed long int)1];
                ii = 0;
                for( ; !(ii >= filter_width); ii = ii + 1)
                {
                  jj = 0;
                  for( ; !(jj >= filter_width); jj = jj + 1)
                  {
                    double k = filter[(signed long int)(ii + jj * filter_width)];
                    float (*render_rectangle_float_mt__1__13__2__1__1__1__1__1__1__1__ac)[4l] = accumulate + (signed long int)x + (signed long int)ii + (signed long int)((y + jj) * fic.width);
                    t[(signed long int)0] = t[(signed long int)0] + k * (double)render_rectangle_float_mt__1__13__2__1__1__1__1__1__1__1__ac[(signed long int)0][(signed long int)0];
                    t[(signed long int)1] = t[(signed long int)1] + k * (double)render_rectangle_float_mt__1__13__2__1__1__1__1__1__1__1__ac[(signed long int)0][(signed long int)1];
                    t[(signed long int)2] = t[(signed long int)2] + k * (double)render_rectangle_float_mt__1__13__2__1__1__1__1__1__1__1__ac[(signed long int)0][(signed long int)2];
                    t[(signed long int)3] = t[(signed long int)3] + k * (double)render_rectangle_float_mt__1__13__2__1__1__1__1__1__1__1__ac[(signed long int)0][(signed long int)3];
                  }
                }
                p = (void *)((unsigned char *)out + (signed long int)(nchan * bytes_per_channel * (i + j * out_width)));
                p8 = (unsigned char *)p;
                p16 = (unsigned short int *)p;
                if(spec->earlyclip == 0)
                {
                  tmp = t[(signed long int)3] / (double)255;
                  if(t[3l] <= 0.000000)
                  {
                    alpha = 0.0;
                    render_rectangle_float_mt__1__13__ls = 0.0;
                  }

                  else
                  {
                    alpha=flam3_calc_alpha(tmp, g, linrange);
                    render_rectangle_float_mt__1__13__ls = (vibrancy * 256.0 * alpha) / tmp;
                    if(alpha < 0.0)
                      alpha = 0.0;

                    if(alpha > 1.0)
                      alpha = 1.0;

                  }
                  flam3_calc_newrgb(t, render_rectangle_float_mt__1__13__ls, highpow, newrgb);
                  rgbi = 0;
                  for( ; !(rgbi >= 3); rgbi = rgbi + 1)
                  {
                    render_rectangle_float_mt__1__13__a = newrgb[(signed long int)rgbi];
                    double return_value_pow_15;
                    return_value_pow_15=pow(t[(signed long int)rgbi] / (double)255, g);
                    render_rectangle_float_mt__1__13__a = render_rectangle_float_mt__1__13__a + (1.0 - vibrancy) * 256.0 * return_value_pow_15;
                    if(transp == 0 || !(nchan >= 4))
                      render_rectangle_float_mt__1__13__a = render_rectangle_float_mt__1__13__a + (1.0 - alpha) * background[(signed long int)rgbi];

                    else
                      if(alpha > 0.000000)
                        render_rectangle_float_mt__1__13__a = render_rectangle_float_mt__1__13__a / alpha;

                      else
                        render_rectangle_float_mt__1__13__a = (double)0;
                    if(render_rectangle_float_mt__1__13__a > 255.000000)
                      render_rectangle_float_mt__1__13__a = (double)255;

                    if(render_rectangle_float_mt__1__13__a < 0.000000)
                      render_rectangle_float_mt__1__13__a = (double)0;

                    t[(signed long int)rgbi] = render_rectangle_float_mt__1__13__a;
                  }
                  t[(signed long int)3] = alpha;
                }

                rgbi = 0;
                for( ; !(rgbi >= 3); rgbi = rgbi + 1)
                {
                  render_rectangle_float_mt__1__13__a = t[(signed long int)rgbi];
                  if(render_rectangle_float_mt__1__13__a > 255.000000)
                    render_rectangle_float_mt__1__13__a = (double)255;

                  if(render_rectangle_float_mt__1__13__a < 0.000000)
                    render_rectangle_float_mt__1__13__a = (double)0;

                  if(bytes_per_channel == 2)
                  {
                    render_rectangle_float_mt__1__13__a = render_rectangle_float_mt__1__13__a * 256.0;
                    p16[(signed long int)rgbi] = (unsigned short int)render_rectangle_float_mt__1__13__a;
                  }

                  else
                    p8[(signed long int)rgbi] = (unsigned char)render_rectangle_float_mt__1__13__a;
                }
                if(t[3l] > 1.000000)
                  t[(signed long int)3] = (double)1;

                if(t[3l] < 0.000000)
                  t[(signed long int)3] = (double)0;

                if(nchan >= 4)
                {
                  if(transp == 1)
                  {
                    if(bytes_per_channel == 2)
                      p16[(signed long int)3] = (unsigned short int)(t[(signed long int)3] * (double)65535);

                    else
                      p8[(signed long int)3] = (unsigned char)(t[(signed long int)3] * (double)255);
                  }

                  else
                    if(bytes_per_channel == 2)
                      p16[(signed long int)3] = (unsigned short int)65535;

                    else
                      p8[(signed long int)3] = (unsigned char)255;
                }

                x = x + oversample;
              }
              y = y + oversample;
            }
          }

        done:
          ;
          stats->badvals = fic.badvals;
          free((void *)temporal_filter);
          free((void *)temporal_deltas);
          free((void *)batch_filter);
          free((void *)filter);
          free((void *)buckets);
          thi = 0;
          for( ; !(thi >= spec->nthreads); thi = thi + 1)
            clear_cp(&(fth + (signed long int)thi)->cp, 0);
          free((void *)fth);
          clear_cp(&cp, 0);
          char *return_value_getenv_16;
          return_value_getenv_16=getenv("insert_palette");
          if(!(return_value_getenv_16 == ((char *)NULL)))
          {
            signed int ph = 100;
            if(ph >= image_height)
              ph = image_height;

            j = 0;
            for( ; !(j >= ph); j = j + 1)
            {
              i = 0;
              for( ; !(i >= image_width); i = i + 1)
              {
                unsigned char *render_rectangle_float_mt__1__15__1__1__1__1__p = (unsigned char *)out + (signed long int)(nchan * (i + j * out_width));
                render_rectangle_float_mt__1__15__1__1__1__1__p[(signed long int)0] = (unsigned char)dmap[(signed long int)((i * 256) / image_width)].color[(signed long int)0];
                render_rectangle_float_mt__1__15__1__1__1__1__p[(signed long int)1] = (unsigned char)dmap[(signed long int)((i * 256) / image_width)].color[(signed long int)1];
                render_rectangle_float_mt__1__15__1__1__1__1__p[(signed long int)2] = (unsigned char)dmap[(signed long int)((i * 256) / image_width)].color[(signed long int)2];
              }
            }
          }

          tend=time((signed long int *)(void *)0);
          stats->render_seconds = (signed int)(tend - tstart);
          return 0;
        }
      }
    }
}

// render_rectangle_int
// file rect.c line 527
static signed int render_rectangle_int(struct anonymous_4 *spec, void *out, signed int field, signed int nchan, signed int transp, struct anonymous_8 *stats)
{
  signed long int nbuckets;
  signed int i;
  signed int j;
  signed int render_rectangle_int__1__k;
  signed int batch_num;
  signed int temporal_sample_num;
  double nsamples;
  double batch_size;
  unsigned int (*buckets)[5l];
  unsigned int (*accumulate)[4l];
  double *points;
  double *filter;
  double *temporal_filter;
  double *temporal_deltas;
  double *batch_filter;
  double ppux = (double)0;
  double ppuy = (double)0;
  signed int image_width;
  signed int image_height;
  signed int out_width;
  signed int filter_width = 0;
  signed int bytes_per_channel = spec->bytes_per_channel;
  signed int oversample;
  double highpow;
  signed int nbatches;
  signed int ntemporal_samples;
  struct anonymous_1 dmap[256l];
  signed int gutter_width;
  double vibrancy = 0.0;
  double gamma = 0.0;
  double background[3l];
  signed int vib_gam_n = 0;
  signed long int progress_began = (signed long int)0;
  signed int render_rectangle_int__1__verbose = spec->verbose;
  signed int gnm_idx;
  signed int max_gnm_de_fw;
  signed int de_offset;
  struct anonymous_0 cp;
  unsigned short int *xform_distrib;
  struct anonymous_12 fic;
  struct anonymous_13 *fth;
  union pthread_attr_t pt_attr;
  unsigned long int *myThreads = (unsigned long int *)(void *)0;
  signed int thread_status;
  signed int thi;
  signed long int tstart;
  signed long int tend;
  double sumfilt;
  char *last_block;
  unsigned long int memory_rqd;
  signed long int progress_timer = (signed long int)0;
  signed long int progress_timer_history[64l];
  double progress_history[64l];
  signed int progress_history_mark = 0;
  tstart=time((signed long int *)(void *)0);
  fic.badvals = (double)0;
  fic.aborted = 0;
  stats->num_iters = (signed long int)0;
  memset((void *)&cp, 0, sizeof(struct anonymous_0) /*10712ul*/ );
  flam3_interpolate(spec->genomes, spec->ngenomes, spec->time, (double)0, &cp);
  oversample = cp.spatial_oversample;
  highpow = cp.highlight_power;
  nbatches = cp.nbatches;
  ntemporal_samples = cp.ntemporal_samples;
  unsigned long int tmp_post_7;
  unsigned long int tmp_if_expr_8;
  if(!(nbatches >= 1))
  {
    fprintf(stderr, "nbatches must be positive, not %d.\n", nbatches);
    return 1;
  }

  else
    if(!(oversample >= 1))
    {
      fprintf(stderr, "oversample must be positive, not %d.\n", oversample);
      return 1;
    }

    else
    {
      void *return_value_calloc_1;
      return_value_calloc_1=calloc((unsigned long int)spec->nthreads, sizeof(struct anonymous_13) /*11024ul*/ );
      fth = (struct anonymous_13 *)return_value_calloc_1;
      i = 0;
      for( ; !(i >= spec->nthreads); i = i + 1)
        (fth + (signed long int)i)->cp.final_xform_index = -1;
      image_width = cp.width;
      out_width = image_width;
      if(!(field == 0))
      {
        image_height = cp.height / 2;
        if(field == 2)
          out = (void *)((unsigned char *)out + (signed long int)(nchan * bytes_per_channel * out_width));

        out_width = out_width * 2;
      }

      else
        image_height = cp.height;
      filter_width=flam3_create_spatial_filter(spec, field, &filter);
      if(!(filter_width >= 0))
      {
        fprintf(stderr, "flam3_create_spatial_filter returned error: aborting\n");
        return 1;
      }

      else
      {
        void *return_value_malloc_2;
        return_value_malloc_2=malloc(sizeof(double) /*8ul*/  * (unsigned long int)nbatches);
        batch_filter = (double *)return_value_malloc_2;
        i = 0;
        for( ; !(i >= nbatches); i = i + 1)
          batch_filter[(signed long int)i] = 1.0 / (double)nbatches;
        sumfilt=flam3_create_temporal_filter(nbatches * ntemporal_samples, cp.temporal_filter_type, cp.temporal_filter_exp, cp.temporal_filter_width, &temporal_filter, &temporal_deltas);
        gutter_width = (filter_width - oversample) / 2;
        max_gnm_de_fw = 0;
        gnm_idx = 0;
        for( ; !(gnm_idx >= spec->ngenomes); gnm_idx = gnm_idx + 1)
        {
          signed int this_width;
          double return_value_ceil_3;
          return_value_ceil_3=ceil((spec->genomes + (signed long int)gnm_idx)->estimator);
          this_width = (signed int)return_value_ceil_3 * oversample;
          if(!(max_gnm_de_fw >= this_width))
            max_gnm_de_fw = this_width;

        }
        if(max_gnm_de_fw >= 1)
          max_gnm_de_fw = max_gnm_de_fw + (oversample - 1);

        if(!(gutter_width >= max_gnm_de_fw))
        {
          de_offset = max_gnm_de_fw - gutter_width;
          gutter_width = max_gnm_de_fw;
        }

        else
          de_offset = 0;
        fic.height = oversample * image_height + 2 * gutter_width;
        fic.width = oversample * image_width + 2 * gutter_width;
        nbuckets = (signed long int)fic.width * (signed long int)fic.height;
        memory_rqd = sizeof(unsigned int [5l]) /*20ul*/  * (unsigned long int)nbuckets + sizeof(unsigned int [4l]) /*16ul*/  * (unsigned long int)nbuckets + (unsigned long int)4 * sizeof(double) /*8ul*/  * (unsigned long int)spec->sub_batch_size * (unsigned long int)spec->nthreads;
        void *return_value_malloc_4;
        return_value_malloc_4=malloc(memory_rqd);
        last_block = (char *)return_value_malloc_4;
        if(last_block == ((char *)NULL))
        {
          fprintf(stderr, "render_rectangle: cannot malloc %g bytes.\n", (double)memory_rqd);
          fprintf(stderr, "render_rectangle: w=%d h=%d nb=%ld.\n", fic.width, fic.height, nbuckets);
          return 1;
        }

        else
        {
          buckets = (unsigned int (*)[5l])last_block;
          accumulate = (unsigned int (*)[4l])(last_block + (signed long int)(sizeof(unsigned int [5l]) /*20ul*/  * (unsigned long int)nbuckets));
          points = (double *)(last_block + (signed long int)((sizeof(unsigned int [5l]) /*20ul*/  + sizeof(unsigned int [4l]) /*16ul*/ ) * (unsigned long int)nbuckets));
          if(!(render_rectangle_int__1__verbose == 0))
          {
            fprintf(stderr, "chaos: ");
            progress_began=time((signed long int *)(void *)0);
          }

          background[(signed long int)2] = 0.0;
          background[(signed long int)1] = background[(signed long int)2];
          background[(signed long int)0] = background[(signed long int)1];
          memset((void *)(char *)accumulate, 0, sizeof(unsigned int [4l]) /*16ul*/  * (unsigned long int)nbuckets);
          batch_num = 0;
          for( ; !(batch_num >= nbatches); batch_num = batch_num + 1)
          {
            double de_time;
            double sample_density = 0.0;
            double k1;
            double area;
            double k2;
            struct anonymous_6 de;
            de_time = spec->time + temporal_deltas[(signed long int)(batch_num * ntemporal_samples)];
            memset((void *)(char *)buckets, 0, sizeof(unsigned int [5l]) /*20ul*/  * (unsigned long int)nbuckets);
            flam3_interpolate(spec->genomes, spec->ngenomes, de_time, (double)0, &cp);
            if(cp.estimator < 0.0 || cp.estimator_minimum < 0.0)
            {
              fprintf(stderr, "density estimator filter widths must be >= 0\n");
              return 1;
            }

            if(!(spec->bits >= 33))
            {
              if(cp.estimator > 0.0)
              {
                fprintf(stderr, "warning: density estimation disabled with %d bit buffers.\n", spec->bits);
                cp.estimator = 0.0;
              }

            }

            if(cp.estimator > 0.0)
            {
              de=flam3_create_de_filters(cp.estimator, cp.estimator_minimum, cp.estimator_curve, oversample);
              if(!(de.kernel_size >= 0))
              {
                fprintf(stderr, "de.kernel_size returned 0 - aborting.\n");
                return 1;
              }

            }

            else
              de.max_filter_index = 0;
            temporal_sample_num = 0;
            for( ; !(temporal_sample_num >= ntemporal_samples); temporal_sample_num = temporal_sample_num + 1)
            {
              double temporal_sample_time;
              double color_scalar = temporal_filter[(signed long int)(batch_num * ntemporal_samples + temporal_sample_num)];
              temporal_sample_time = spec->time + temporal_deltas[(signed long int)(batch_num * ntemporal_samples + temporal_sample_num)];
              flam3_interpolate(spec->genomes, spec->ngenomes, temporal_sample_time, (double)0, &cp);
              signed int return_value_prepare_precalc_flags_5;
              return_value_prepare_precalc_flags_5=prepare_precalc_flags(&cp);
              if(!(return_value_prepare_precalc_flags_5 == 0))
              {
                fprintf(stderr, "prepare xform pointers returned error: aborting.\n");
                return 1;
              }

              xform_distrib=flam3_create_xform_distrib(&cp);
              if(xform_distrib == ((unsigned short int *)NULL))
              {
                fprintf(stderr, "create xform distrib returned error: aborting.\n");
                return 1;
              }

              j = 0;
              for( ; !(j >= 256); j = j + 1)
              {
                dmap[(signed long int)j].index = cp.palette[(signed long int)((j * 256) / 256)].index / 256.0;
                render_rectangle_int__1__k = 0;
                for( ; !(render_rectangle_int__1__k >= 4); render_rectangle_int__1__k = render_rectangle_int__1__k + 1)
                  dmap[(signed long int)j].color[(signed long int)render_rectangle_int__1__k] = cp.palette[(signed long int)((j * 256) / 256)].color[(signed long int)render_rectangle_int__1__k] * (double)255 * color_scalar;
              }
              {
                double t0;
                double t1;
                double shift = 0.0;
                double corner0;
                double corner1;
                double scale;
                if(cp.sample_density <= 0.0)
                {
                  fprintf(stderr, "sample density (quality) must be greater than zero, not %g.\n", cp.sample_density);
                  return 1;
                }

                scale=pow(2.0, cp.zoom);
                sample_density = cp.sample_density * scale * scale;
                ppux = cp.pixels_per_unit * scale;
                ppuy = field != 0 ? ppux / 2.0 : ppux;
                ppux = ppux / spec->pixel_aspect_ratio;
                switch(field)
                {
                  case 0:
                  {
                    shift = 0.0;
                    break;
                  }
                  case 1:
                  {
                    shift = -0.5;
                    break;
                  }
                  case 2:
                    shift = 0.5;
                }
                shift = shift / ppux;
                t0 = (double)gutter_width / ((double)oversample * ppux);
                t1 = (double)gutter_width / ((double)oversample * ppuy);
                corner0 = cp.center[(signed long int)0] - ((double)image_width / ppux) / 2.0;
                corner1 = cp.center[(signed long int)1] - ((double)image_height / ppuy) / 2.0;
                fic.bounds[(signed long int)0] = corner0 - t0;
                fic.bounds[(signed long int)1] = (corner1 - t1) + shift;
                fic.bounds[(signed long int)2] = corner0 + (double)image_width / ppux + t0;
                fic.bounds[(signed long int)3] = corner1 + (double)image_height / ppuy + t1 + shift;
                fic.size[(signed long int)0] = 1.0 / (fic.bounds[(signed long int)2] - fic.bounds[(signed long int)0]);
                fic.size[(signed long int)1] = 1.0 / (fic.bounds[(signed long int)3] - fic.bounds[(signed long int)1]);
                fic.rot[(signed long int)0][(signed long int)0]=cos((cp.rotate * (double)2 * 3.14159265358979323846) / 360.0);
                double return_value_sin_6;
                return_value_sin_6=sin((cp.rotate * (double)2 * 3.14159265358979323846) / 360.0);
                fic.rot[(signed long int)0][(signed long int)1] = -return_value_sin_6;
                fic.rot[(signed long int)1][(signed long int)0] = -fic.rot[(signed long int)0][(signed long int)1];
                fic.rot[(signed long int)1][(signed long int)1] = fic.rot[(signed long int)0][(signed long int)0];
                fic.ws0 = (double)fic.width * fic.size[(signed long int)0];
                fic.wb0s0 = fic.ws0 * fic.bounds[(signed long int)0];
                fic.hs1 = (double)fic.height * fic.size[(signed long int)1];
                fic.hb1s1 = fic.hs1 * fic.bounds[(signed long int)1];
              }
              nsamples = sample_density * (double)image_width * (double)image_height;
              batch_size = nsamples / (double)(nbatches * ntemporal_samples);
              stats->num_iters = stats->num_iters + (signed long int)batch_size;
              fic.xform_distrib = xform_distrib;
              fic.spec = spec;
              fic.batch_size = batch_size / (double)spec->nthreads;
              fic.temporal_sample_num = temporal_sample_num;
              fic.ntemporal_samples = ntemporal_samples;
              fic.batch_num = batch_num;
              fic.nbatches = nbatches;
              fic.dmap = (struct anonymous_1 *)dmap;
              fic.color_scalar = color_scalar;
              fic.buckets = (void *)buckets;
              fic.progress_timer = &progress_timer;
              fic.progress_timer_history = &progress_timer_history[(signed long int)0];
              fic.progress_history = &progress_history[(signed long int)0];
              fic.progress_history_mark = &progress_history_mark;
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
              {
                signed int rk = 0;
                for( ; !(rk >= 16); rk = rk + 1)
                {
                  tmp_post_7 = (&spec->rc)->randcnt;
                  (&spec->rc)->randcnt = (&spec->rc)->randcnt - 1ul;
                  if(tmp_post_7 == 0ul)
                  {
                    isaac(&spec->rc);
                    (&spec->rc)->randcnt = (unsigned long int)((1 << 4) - 1);
                    tmp_if_expr_8 = (&spec->rc)->randrsl[(signed long int)(&spec->rc)->randcnt];
                  }

                  else
                    tmp_if_expr_8 = (&spec->rc)->randrsl[(signed long int)(&spec->rc)->randcnt];
                  (fth + (signed long int)thi)->rc.randrsl[(signed long int)rk] = tmp_if_expr_8;
                }
                irandinit(&(fth + (signed long int)thi)->rc, 1);
                if(thi == 0)
                {
                  (fth + (signed long int)thi)->first_thread = 1;
                  if(batch_num == 0 && temporal_sample_num == 0)
                    (fth + (signed long int)thi)->timer_initialize = 1;

                  else
                    (fth + (signed long int)thi)->timer_initialize = 0;
                }

                else
                {
                  (fth + (signed long int)thi)->first_thread = 0;
                  (fth + (signed long int)thi)->timer_initialize = 0;
                }
                (fth + (signed long int)thi)->iter_storage = &points[(signed long int)(thi * spec->sub_batch_size * 4)];
                (fth + (signed long int)thi)->fic = &fic;
                flam3_copy(&(fth + (signed long int)thi)->cp, &cp);
              }
              void *return_value_malloc_9;
              return_value_malloc_9=malloc((unsigned long int)spec->nthreads * sizeof(unsigned long int) /*8ul*/ );
              myThreads = (unsigned long int *)return_value_malloc_9;
              pthread_mutex_init(&fic.bucket_mutex, (const union anonymous_11 *)(void *)0);
              pthread_attr_init(&pt_attr);
              pthread_attr_setdetachstate(&pt_attr, 0);
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
                pthread_create(&myThreads[(signed long int)thi], &pt_attr, (void * (*)(void *))(void *)iter_thread_int, (void *)&fth[(signed long int)thi]);
              pthread_attr_destroy(&pt_attr);
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
                pthread_join(myThreads[(signed long int)thi], (void **)&thread_status);
              pthread_mutex_destroy(&fic.bucket_mutex);
              free((void *)myThreads);
              free((void *)xform_distrib);
              if(!(fic.aborted == 0))
              {
                if(!(render_rectangle_int__1__verbose == 0))
                  fprintf(stderr, "\naborted!\n");

                goto done;
              }

              vibrancy = vibrancy + cp.vibrancy;
              gamma = gamma + cp.gamma;
              background[(signed long int)0] = background[(signed long int)0] + cp.background[(signed long int)0];
              background[(signed long int)1] = background[(signed long int)1] + cp.background[(signed long int)1];
              background[(signed long int)2] = background[(signed long int)2] + cp.background[(signed long int)2];
              vib_gam_n = vib_gam_n + 1;
            }
            k1 = (cp.contrast * cp.brightness * (double)255 * 268.0 * batch_filter[(signed long int)batch_num]) / (double)256;
            area = (double)(image_width * image_height) / (ppux * ppuy);
            k2 = (double)(oversample * oversample * nbatches) / (cp.contrast * area * (double)255 * sample_density * sumfilt);
            if(de.max_filter_index == 0)
            {
              j = 0;
              for( ; !(j >= fic.height); j = j + 1)
              {
                i = 0;
                for( ; !(i >= fic.width); i = i + 1)
                {
                  unsigned int (*a)[4l] = accumulate + (signed long int)i + (signed long int)(j * fic.width);
                  unsigned int (*b)[5l] = buckets + (signed long int)i + (signed long int)(j * fic.width);
                  double c[4l];
                  double ls;
                  c[(signed long int)0] = (double)b[(signed long int)0][(signed long int)0];
                  c[(signed long int)1] = (double)b[(signed long int)0][(signed long int)1];
                  c[(signed long int)2] = (double)b[(signed long int)0][(signed long int)2];
                  c[(signed long int)3] = (double)b[(signed long int)0][(signed long int)3];
                  if(!IEEE_FLOAT_EQUAL(0.0, c[3l]))
                  {
                    double return_value_log_10;
                    return_value_log_10=log(1.0 + c[(signed long int)3] * k2);
                    ls = (k1 * return_value_log_10) / c[(signed long int)3];
                    c[(signed long int)0] = c[(signed long int)0] * ls;
                    c[(signed long int)1] = c[(signed long int)1] * ls;
                    c[(signed long int)2] = c[(signed long int)2] * ls;
                    c[(signed long int)3] = c[(signed long int)3] * ls;
                    do
                      if((double)(1U + -(*a)[0l]) > c[0l])
                        a[(signed long int)0][(signed long int)0] = a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                      else
                        a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                    while((_Bool)0);
                    do
                      if((double)(1U + -(*a)[1l]) > c[1l])
                        a[(signed long int)0][(signed long int)1] = a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                      else
                        a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                    while((_Bool)0);
                    do
                      if((double)(1U + -(*a)[2l]) > c[2l])
                        a[(signed long int)0][(signed long int)2] = a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                      else
                        a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                    while((_Bool)0);
                    do
                      if((double)(1U + -(*a)[3l]) > c[3l])
                        a[(signed long int)0][(signed long int)3] = a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                      else
                        a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                    while((_Bool)0);
                  }

                }
              }
            }

            else
            {
              struct anonymous_16 *deth;
              signed int de_aborted = 0;
              signed int myspan = (fic.height - 2 * (oversample - 1)) + 1;
              signed int swath = myspan / spec->nthreads;
              void *return_value_calloc_11;
              return_value_calloc_11=calloc((unsigned long int)spec->nthreads, sizeof(struct anonymous_16) /*104ul*/ );
              deth = (struct anonymous_16 *)return_value_calloc_11;
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
              {
                (deth + (signed long int)thi)->b = buckets;
                (deth + (signed long int)thi)->accumulate = accumulate;
                (deth + (signed long int)thi)->width = fic.width;
                (deth + (signed long int)thi)->height = fic.height;
                (deth + (signed long int)thi)->oversample = oversample;
                (deth + (signed long int)thi)->progress_size = spec->sub_batch_size / 10;
                (deth + (signed long int)thi)->de = &de;
                (deth + (signed long int)thi)->k1 = k1;
                (deth + (signed long int)thi)->k2 = k2;
                (deth + (signed long int)thi)->curve = cp.estimator_curve;
                (deth + (signed long int)thi)->spec = spec;
                (deth + (signed long int)thi)->aborted = &de_aborted;
                if(!(myspan >= spec->nthreads))
                {
                  (deth + (signed long int)thi)->start_row = 0;
                  if(thi == spec->nthreads + -1)
                  {
                    (deth + (signed long int)thi)->end_row = myspan;
                    (deth + (signed long int)thi)->last_thread = 1;
                  }

                  else
                  {
                    (deth + (signed long int)thi)->end_row = -1;
                    (deth + (signed long int)thi)->last_thread = 0;
                  }
                }

                else
                {
                  (deth + (signed long int)thi)->start_row = thi * swath;
                  (deth + (signed long int)thi)->end_row = (thi + 1) * swath;
                  if(thi == spec->nthreads + -1)
                  {
                    (deth + (signed long int)thi)->end_row = myspan;
                    (deth + (signed long int)thi)->last_thread = 1;
                  }

                  else
                    (deth + (signed long int)thi)->last_thread = 0;
                }
              }
              void *return_value_malloc_12;
              return_value_malloc_12=malloc((unsigned long int)spec->nthreads * sizeof(unsigned long int) /*8ul*/ );
              myThreads = (unsigned long int *)return_value_malloc_12;
              pthread_attr_init(&pt_attr);
              pthread_attr_setdetachstate(&pt_attr, 0);
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
                pthread_create(&myThreads[(signed long int)thi], &pt_attr, (void * (*)(void *))(void *)de_thread_32, (void *)&deth[(signed long int)thi]);
              pthread_attr_destroy(&pt_attr);
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
                pthread_join(myThreads[(signed long int)thi], (void **)&thread_status);
              free((void *)myThreads);
              free((void *)deth);
              if(!(de_aborted == 0))
              {
                if(!(render_rectangle_int__1__verbose == 0))
                  fprintf(stderr, "\naborted!\n");

                goto done;
              }

            }
            if(de.max_filter_index >= 1)
            {
              free((void *)de.filter_coefs);
              free((void *)de.filter_widths);
            }

          }
          if(!(render_rectangle_int__1__verbose == 0))
          {
            signed long int return_value_time_13;
            return_value_time_13=time((signed long int *)(void *)0);
            fprintf(stderr, "\rchaos: 100.0%%  took: %ld seconds   \n", return_value_time_13 - progress_began);
            fprintf(stderr, "filtering...");
          }

          {
            signed int x;
            signed int y;
            double t[4l];
            double newrgb[3l];
            double g = 1.0 / (gamma / (double)vib_gam_n);
            double tmp;
            double render_rectangle_int__1__13__a;
            double alpha;
            double render_rectangle_int__1__13__ls;
            signed int rgbi;
            double linrange = cp.gam_lin_thresh;
            vibrancy = vibrancy / (double)vib_gam_n;
            background[(signed long int)0] = background[(signed long int)0] / ((double)vib_gam_n / 256.0);
            background[(signed long int)1] = background[(signed long int)1] / ((double)vib_gam_n / 256.0);
            background[(signed long int)2] = background[(signed long int)2] / ((double)vib_gam_n / 256.0);
            if(!(spec->earlyclip == 0))
            {
              j = 0;
              for( ; !(j >= fic.height); j = j + 1)
              {
                i = 0;
                for( ; !(i >= fic.width); i = i + 1)
                {
                  unsigned int (*ac)[4l] = accumulate + (signed long int)i + (signed long int)(j * fic.width);
                  if(!((*ac)[3l] >= 1u))
                  {
                    alpha = 0.0;
                    render_rectangle_int__1__13__ls = 0.0;
                  }

                  else
                  {
                    tmp = (double)(ac[(signed long int)0][(signed long int)3] / (unsigned int)255);
                    alpha=flam3_calc_alpha(tmp, g, linrange);
                    render_rectangle_int__1__13__ls = (vibrancy * 256.0 * alpha) / tmp;
                    if(alpha < 0.0)
                      alpha = 0.0;

                    if(alpha > 1.0)
                      alpha = 1.0;

                  }
                  t[(signed long int)0] = (double)ac[(signed long int)0][(signed long int)0];
                  t[(signed long int)1] = (double)ac[(signed long int)0][(signed long int)1];
                  t[(signed long int)2] = (double)ac[(signed long int)0][(signed long int)2];
                  t[(signed long int)3] = (double)ac[(signed long int)0][(signed long int)3];
                  flam3_calc_newrgb(t, render_rectangle_int__1__13__ls, highpow, newrgb);
                  rgbi = 0;
                  for( ; !(rgbi >= 3); rgbi = rgbi + 1)
                  {
                    render_rectangle_int__1__13__a = newrgb[(signed long int)rgbi];
                    double return_value_pow_14;
                    return_value_pow_14=pow(t[(signed long int)rgbi] / (double)255, g);
                    render_rectangle_int__1__13__a = render_rectangle_int__1__13__a + (1.0 - vibrancy) * 256.0 * return_value_pow_14;
                    if(transp == 0 || !(nchan >= 4))
                      render_rectangle_int__1__13__a = render_rectangle_int__1__13__a + (1.0 - alpha) * background[(signed long int)rgbi];

                    else
                      if(alpha > 0.000000)
                        render_rectangle_int__1__13__a = render_rectangle_int__1__13__a / alpha;

                      else
                        render_rectangle_int__1__13__a = (double)0;
                    if(render_rectangle_int__1__13__a > 255.000000)
                      render_rectangle_int__1__13__a = (double)255;

                    if(render_rectangle_int__1__13__a < 0.000000)
                      render_rectangle_int__1__13__a = (double)0;

                    ac[(signed long int)0][(signed long int)rgbi] = (unsigned int)render_rectangle_int__1__13__a;
                  }
                  ac[(signed long int)0][(signed long int)3] = (unsigned int)alpha;
                }
              }
            }

            y = de_offset;
            j = 0;
            for( ; !(j >= image_height); j = j + 1)
            {
              x = de_offset;
              i = 0;
              for( ; !(i >= image_width); i = i + 1)
              {
                signed int ii;
                signed int jj;
                signed int render_rectangle_int__1__13__2__1__1__1__rgbi;
                void *p;
                unsigned short int *p16;
                unsigned char *p8;
                t[(signed long int)3] = 0.0;
                t[(signed long int)2] = t[(signed long int)3];
                t[(signed long int)1] = t[(signed long int)2];
                t[(signed long int)0] = t[(signed long int)1];
                ii = 0;
                for( ; !(ii >= filter_width); ii = ii + 1)
                {
                  jj = 0;
                  for( ; !(jj >= filter_width); jj = jj + 1)
                  {
                    double k = filter[(signed long int)(ii + jj * filter_width)];
                    unsigned int (*render_rectangle_int__1__13__2__1__1__1__1__1__1__1__ac)[4l] = accumulate + (signed long int)x + (signed long int)ii + (signed long int)((y + jj) * fic.width);
                    t[(signed long int)0] = t[(signed long int)0] + k * (double)render_rectangle_int__1__13__2__1__1__1__1__1__1__1__ac[(signed long int)0][(signed long int)0];
                    t[(signed long int)1] = t[(signed long int)1] + k * (double)render_rectangle_int__1__13__2__1__1__1__1__1__1__1__ac[(signed long int)0][(signed long int)1];
                    t[(signed long int)2] = t[(signed long int)2] + k * (double)render_rectangle_int__1__13__2__1__1__1__1__1__1__1__ac[(signed long int)0][(signed long int)2];
                    t[(signed long int)3] = t[(signed long int)3] + k * (double)render_rectangle_int__1__13__2__1__1__1__1__1__1__1__ac[(signed long int)0][(signed long int)3];
                  }
                }
                p = (void *)((unsigned char *)out + (signed long int)(nchan * bytes_per_channel * (i + j * out_width)));
                p8 = (unsigned char *)p;
                p16 = (unsigned short int *)p;
                if(spec->earlyclip == 0)
                {
                  tmp = t[(signed long int)3] / (double)255;
                  if(t[3l] <= 0.000000)
                  {
                    alpha = 0.0;
                    render_rectangle_int__1__13__ls = 0.0;
                  }

                  else
                  {
                    alpha=flam3_calc_alpha(tmp, g, linrange);
                    render_rectangle_int__1__13__ls = (vibrancy * 256.0 * alpha) / tmp;
                    if(alpha < 0.0)
                      alpha = 0.0;

                    if(alpha > 1.0)
                      alpha = 1.0;

                  }
                  flam3_calc_newrgb(t, render_rectangle_int__1__13__ls, highpow, newrgb);
                  render_rectangle_int__1__13__2__1__1__1__rgbi = 0;
                  for( ; !(render_rectangle_int__1__13__2__1__1__1__rgbi >= 3); render_rectangle_int__1__13__2__1__1__1__rgbi = render_rectangle_int__1__13__2__1__1__1__rgbi + 1)
                  {
                    render_rectangle_int__1__13__a = newrgb[(signed long int)render_rectangle_int__1__13__2__1__1__1__rgbi];
                    double return_value_pow_15;
                    return_value_pow_15=pow(t[(signed long int)render_rectangle_int__1__13__2__1__1__1__rgbi] / (double)255, g);
                    render_rectangle_int__1__13__a = render_rectangle_int__1__13__a + (1.0 - vibrancy) * 256.0 * return_value_pow_15;
                    if(transp == 0 || !(nchan >= 4))
                      render_rectangle_int__1__13__a = render_rectangle_int__1__13__a + (1.0 - alpha) * background[(signed long int)render_rectangle_int__1__13__2__1__1__1__rgbi];

                    else
                      if(alpha > 0.000000)
                        render_rectangle_int__1__13__a = render_rectangle_int__1__13__a / alpha;

                      else
                        render_rectangle_int__1__13__a = (double)0;
                    if(render_rectangle_int__1__13__a > 255.000000)
                      render_rectangle_int__1__13__a = (double)255;

                    if(render_rectangle_int__1__13__a < 0.000000)
                      render_rectangle_int__1__13__a = (double)0;

                    t[(signed long int)render_rectangle_int__1__13__2__1__1__1__rgbi] = render_rectangle_int__1__13__a;
                  }
                  t[(signed long int)3] = alpha;
                }

                render_rectangle_int__1__13__2__1__1__1__rgbi = 0;
                for( ; !(render_rectangle_int__1__13__2__1__1__1__rgbi >= 3); render_rectangle_int__1__13__2__1__1__1__rgbi = render_rectangle_int__1__13__2__1__1__1__rgbi + 1)
                {
                  render_rectangle_int__1__13__a = t[(signed long int)render_rectangle_int__1__13__2__1__1__1__rgbi];
                  if(render_rectangle_int__1__13__a > 255.000000)
                    render_rectangle_int__1__13__a = (double)255;

                  if(render_rectangle_int__1__13__a < 0.000000)
                    render_rectangle_int__1__13__a = (double)0;

                  if(bytes_per_channel == 2)
                  {
                    render_rectangle_int__1__13__a = render_rectangle_int__1__13__a * 256.0;
                    p16[(signed long int)render_rectangle_int__1__13__2__1__1__1__rgbi] = (unsigned short int)render_rectangle_int__1__13__a;
                  }

                  else
                    p8[(signed long int)render_rectangle_int__1__13__2__1__1__1__rgbi] = (unsigned char)render_rectangle_int__1__13__a;
                }
                if(t[3l] > 1.000000)
                  t[(signed long int)3] = (double)1;

                if(t[3l] < 0.000000)
                  t[(signed long int)3] = (double)0;

                if(nchan >= 4)
                {
                  if(transp == 1)
                  {
                    if(bytes_per_channel == 2)
                      p16[(signed long int)3] = (unsigned short int)(t[(signed long int)3] * (double)65535);

                    else
                      p8[(signed long int)3] = (unsigned char)(t[(signed long int)3] * (double)255);
                  }

                  else
                    if(bytes_per_channel == 2)
                      p16[(signed long int)3] = (unsigned short int)65535;

                    else
                      p8[(signed long int)3] = (unsigned char)255;
                }

                x = x + oversample;
              }
              y = y + oversample;
            }
          }

        done:
          ;
          stats->badvals = fic.badvals;
          free((void *)temporal_filter);
          free((void *)temporal_deltas);
          free((void *)batch_filter);
          free((void *)filter);
          free((void *)buckets);
          thi = 0;
          for( ; !(thi >= spec->nthreads); thi = thi + 1)
            clear_cp(&(fth + (signed long int)thi)->cp, 0);
          free((void *)fth);
          clear_cp(&cp, 0);
          char *return_value_getenv_16;
          return_value_getenv_16=getenv("insert_palette");
          if(!(return_value_getenv_16 == ((char *)NULL)))
          {
            signed int ph = 100;
            if(ph >= image_height)
              ph = image_height;

            j = 0;
            for( ; !(j >= ph); j = j + 1)
            {
              i = 0;
              for( ; !(i >= image_width); i = i + 1)
              {
                unsigned char *render_rectangle_int__1__15__1__1__1__1__p = (unsigned char *)out + (signed long int)(nchan * (i + j * out_width));
                render_rectangle_int__1__15__1__1__1__1__p[(signed long int)0] = (unsigned char)dmap[(signed long int)((i * 256) / image_width)].color[(signed long int)0];
                render_rectangle_int__1__15__1__1__1__1__p[(signed long int)1] = (unsigned char)dmap[(signed long int)((i * 256) / image_width)].color[(signed long int)1];
                render_rectangle_int__1__15__1__1__1__1__p[(signed long int)2] = (unsigned char)dmap[(signed long int)((i * 256) / image_width)].color[(signed long int)2];
              }
            }
          }

          tend=time((signed long int *)(void *)0);
          stats->render_seconds = (signed int)(tend - tstart);
          return 0;
        }
      }
    }
}

// render_rectangle_int_mt
// file rect.c line 527
static signed int render_rectangle_int_mt(struct anonymous_4 *spec, void *out, signed int field, signed int nchan, signed int transp, struct anonymous_8 *stats)
{
  signed long int nbuckets;
  signed int i;
  signed int j;
  signed int render_rectangle_int_mt__1__k;
  signed int batch_num;
  signed int temporal_sample_num;
  double nsamples;
  double batch_size;
  unsigned int (*buckets)[5l];
  unsigned int (*accumulate)[4l];
  double *points;
  double *filter;
  double *temporal_filter;
  double *temporal_deltas;
  double *batch_filter;
  double ppux = (double)0;
  double ppuy = (double)0;
  signed int image_width;
  signed int image_height;
  signed int out_width;
  signed int filter_width = 0;
  signed int bytes_per_channel = spec->bytes_per_channel;
  signed int oversample;
  double highpow;
  signed int nbatches;
  signed int ntemporal_samples;
  struct anonymous_1 dmap[256l];
  signed int gutter_width;
  double vibrancy = 0.0;
  double gamma = 0.0;
  double background[3l];
  signed int vib_gam_n = 0;
  signed long int progress_began = (signed long int)0;
  signed int render_rectangle_int_mt__1__verbose = spec->verbose;
  signed int gnm_idx;
  signed int max_gnm_de_fw;
  signed int de_offset;
  struct anonymous_0 cp;
  unsigned short int *xform_distrib;
  struct anonymous_12 fic;
  struct anonymous_13 *fth;
  union pthread_attr_t pt_attr;
  unsigned long int *myThreads = (unsigned long int *)(void *)0;
  signed int thread_status;
  signed int thi;
  signed long int tstart;
  signed long int tend;
  double sumfilt;
  char *last_block;
  unsigned long int memory_rqd;
  signed long int progress_timer = (signed long int)0;
  signed long int progress_timer_history[64l];
  double progress_history[64l];
  signed int progress_history_mark = 0;
  tstart=time((signed long int *)(void *)0);
  fic.badvals = (double)0;
  fic.aborted = 0;
  stats->num_iters = (signed long int)0;
  memset((void *)&cp, 0, sizeof(struct anonymous_0) /*10712ul*/ );
  flam3_interpolate(spec->genomes, spec->ngenomes, spec->time, (double)0, &cp);
  oversample = cp.spatial_oversample;
  highpow = cp.highlight_power;
  nbatches = cp.nbatches;
  ntemporal_samples = cp.ntemporal_samples;
  unsigned long int tmp_post_7;
  unsigned long int tmp_if_expr_8;
  if(!(nbatches >= 1))
  {
    fprintf(stderr, "nbatches must be positive, not %d.\n", nbatches);
    return 1;
  }

  else
    if(!(oversample >= 1))
    {
      fprintf(stderr, "oversample must be positive, not %d.\n", oversample);
      return 1;
    }

    else
    {
      void *return_value_calloc_1;
      return_value_calloc_1=calloc((unsigned long int)spec->nthreads, sizeof(struct anonymous_13) /*11024ul*/ );
      fth = (struct anonymous_13 *)return_value_calloc_1;
      i = 0;
      for( ; !(i >= spec->nthreads); i = i + 1)
        (fth + (signed long int)i)->cp.final_xform_index = -1;
      image_width = cp.width;
      out_width = image_width;
      if(!(field == 0))
      {
        image_height = cp.height / 2;
        if(field == 2)
          out = (void *)((unsigned char *)out + (signed long int)(nchan * bytes_per_channel * out_width));

        out_width = out_width * 2;
      }

      else
        image_height = cp.height;
      filter_width=flam3_create_spatial_filter(spec, field, &filter);
      if(!(filter_width >= 0))
      {
        fprintf(stderr, "flam3_create_spatial_filter returned error: aborting\n");
        return 1;
      }

      else
      {
        void *return_value_malloc_2;
        return_value_malloc_2=malloc(sizeof(double) /*8ul*/  * (unsigned long int)nbatches);
        batch_filter = (double *)return_value_malloc_2;
        i = 0;
        for( ; !(i >= nbatches); i = i + 1)
          batch_filter[(signed long int)i] = 1.0 / (double)nbatches;
        sumfilt=flam3_create_temporal_filter(nbatches * ntemporal_samples, cp.temporal_filter_type, cp.temporal_filter_exp, cp.temporal_filter_width, &temporal_filter, &temporal_deltas);
        gutter_width = (filter_width - oversample) / 2;
        max_gnm_de_fw = 0;
        gnm_idx = 0;
        for( ; !(gnm_idx >= spec->ngenomes); gnm_idx = gnm_idx + 1)
        {
          signed int this_width;
          double return_value_ceil_3;
          return_value_ceil_3=ceil((spec->genomes + (signed long int)gnm_idx)->estimator);
          this_width = (signed int)return_value_ceil_3 * oversample;
          if(!(max_gnm_de_fw >= this_width))
            max_gnm_de_fw = this_width;

        }
        if(max_gnm_de_fw >= 1)
          max_gnm_de_fw = max_gnm_de_fw + (oversample - 1);

        if(!(gutter_width >= max_gnm_de_fw))
        {
          de_offset = max_gnm_de_fw - gutter_width;
          gutter_width = max_gnm_de_fw;
        }

        else
          de_offset = 0;
        fic.height = oversample * image_height + 2 * gutter_width;
        fic.width = oversample * image_width + 2 * gutter_width;
        nbuckets = (signed long int)fic.width * (signed long int)fic.height;
        memory_rqd = sizeof(unsigned int [5l]) /*20ul*/  * (unsigned long int)nbuckets + sizeof(unsigned int [4l]) /*16ul*/  * (unsigned long int)nbuckets + (unsigned long int)4 * sizeof(double) /*8ul*/  * (unsigned long int)spec->sub_batch_size * (unsigned long int)spec->nthreads;
        void *return_value_malloc_4;
        return_value_malloc_4=malloc(memory_rqd);
        last_block = (char *)return_value_malloc_4;
        if(last_block == ((char *)NULL))
        {
          fprintf(stderr, "render_rectangle: cannot malloc %g bytes.\n", (double)memory_rqd);
          fprintf(stderr, "render_rectangle: w=%d h=%d nb=%ld.\n", fic.width, fic.height, nbuckets);
          return 1;
        }

        else
        {
          buckets = (unsigned int (*)[5l])last_block;
          accumulate = (unsigned int (*)[4l])(last_block + (signed long int)(sizeof(unsigned int [5l]) /*20ul*/  * (unsigned long int)nbuckets));
          points = (double *)(last_block + (signed long int)((sizeof(unsigned int [5l]) /*20ul*/  + sizeof(unsigned int [4l]) /*16ul*/ ) * (unsigned long int)nbuckets));
          if(!(render_rectangle_int_mt__1__verbose == 0))
          {
            fprintf(stderr, "chaos: ");
            progress_began=time((signed long int *)(void *)0);
          }

          background[(signed long int)2] = 0.0;
          background[(signed long int)1] = background[(signed long int)2];
          background[(signed long int)0] = background[(signed long int)1];
          memset((void *)(char *)accumulate, 0, sizeof(unsigned int [4l]) /*16ul*/  * (unsigned long int)nbuckets);
          batch_num = 0;
          for( ; !(batch_num >= nbatches); batch_num = batch_num + 1)
          {
            double de_time;
            double sample_density = 0.0;
            double k1;
            double area;
            double k2;
            struct anonymous_6 de;
            de_time = spec->time + temporal_deltas[(signed long int)(batch_num * ntemporal_samples)];
            memset((void *)(char *)buckets, 0, sizeof(unsigned int [5l]) /*20ul*/  * (unsigned long int)nbuckets);
            flam3_interpolate(spec->genomes, spec->ngenomes, de_time, (double)0, &cp);
            if(cp.estimator < 0.0 || cp.estimator_minimum < 0.0)
            {
              fprintf(stderr, "density estimator filter widths must be >= 0\n");
              return 1;
            }

            if(!(spec->bits >= 33))
            {
              if(cp.estimator > 0.0)
              {
                fprintf(stderr, "warning: density estimation disabled with %d bit buffers.\n", spec->bits);
                cp.estimator = 0.0;
              }

            }

            if(cp.estimator > 0.0)
            {
              de=flam3_create_de_filters(cp.estimator, cp.estimator_minimum, cp.estimator_curve, oversample);
              if(!(de.kernel_size >= 0))
              {
                fprintf(stderr, "de.kernel_size returned 0 - aborting.\n");
                return 1;
              }

            }

            else
              de.max_filter_index = 0;
            temporal_sample_num = 0;
            for( ; !(temporal_sample_num >= ntemporal_samples); temporal_sample_num = temporal_sample_num + 1)
            {
              double temporal_sample_time;
              double color_scalar = temporal_filter[(signed long int)(batch_num * ntemporal_samples + temporal_sample_num)];
              temporal_sample_time = spec->time + temporal_deltas[(signed long int)(batch_num * ntemporal_samples + temporal_sample_num)];
              flam3_interpolate(spec->genomes, spec->ngenomes, temporal_sample_time, (double)0, &cp);
              signed int return_value_prepare_precalc_flags_5;
              return_value_prepare_precalc_flags_5=prepare_precalc_flags(&cp);
              if(!(return_value_prepare_precalc_flags_5 == 0))
              {
                fprintf(stderr, "prepare xform pointers returned error: aborting.\n");
                return 1;
              }

              xform_distrib=flam3_create_xform_distrib(&cp);
              if(xform_distrib == ((unsigned short int *)NULL))
              {
                fprintf(stderr, "create xform distrib returned error: aborting.\n");
                return 1;
              }

              j = 0;
              for( ; !(j >= 256); j = j + 1)
              {
                dmap[(signed long int)j].index = cp.palette[(signed long int)((j * 256) / 256)].index / 256.0;
                render_rectangle_int_mt__1__k = 0;
                for( ; !(render_rectangle_int_mt__1__k >= 4); render_rectangle_int_mt__1__k = render_rectangle_int_mt__1__k + 1)
                  dmap[(signed long int)j].color[(signed long int)render_rectangle_int_mt__1__k] = cp.palette[(signed long int)((j * 256) / 256)].color[(signed long int)render_rectangle_int_mt__1__k] * (double)255 * color_scalar;
              }
              {
                double t0;
                double t1;
                double shift = 0.0;
                double corner0;
                double corner1;
                double scale;
                if(cp.sample_density <= 0.0)
                {
                  fprintf(stderr, "sample density (quality) must be greater than zero, not %g.\n", cp.sample_density);
                  return 1;
                }

                scale=pow(2.0, cp.zoom);
                sample_density = cp.sample_density * scale * scale;
                ppux = cp.pixels_per_unit * scale;
                ppuy = field != 0 ? ppux / 2.0 : ppux;
                ppux = ppux / spec->pixel_aspect_ratio;
                switch(field)
                {
                  case 0:
                  {
                    shift = 0.0;
                    break;
                  }
                  case 1:
                  {
                    shift = -0.5;
                    break;
                  }
                  case 2:
                    shift = 0.5;
                }
                shift = shift / ppux;
                t0 = (double)gutter_width / ((double)oversample * ppux);
                t1 = (double)gutter_width / ((double)oversample * ppuy);
                corner0 = cp.center[(signed long int)0] - ((double)image_width / ppux) / 2.0;
                corner1 = cp.center[(signed long int)1] - ((double)image_height / ppuy) / 2.0;
                fic.bounds[(signed long int)0] = corner0 - t0;
                fic.bounds[(signed long int)1] = (corner1 - t1) + shift;
                fic.bounds[(signed long int)2] = corner0 + (double)image_width / ppux + t0;
                fic.bounds[(signed long int)3] = corner1 + (double)image_height / ppuy + t1 + shift;
                fic.size[(signed long int)0] = 1.0 / (fic.bounds[(signed long int)2] - fic.bounds[(signed long int)0]);
                fic.size[(signed long int)1] = 1.0 / (fic.bounds[(signed long int)3] - fic.bounds[(signed long int)1]);
                fic.rot[(signed long int)0][(signed long int)0]=cos((cp.rotate * (double)2 * 3.14159265358979323846) / 360.0);
                double return_value_sin_6;
                return_value_sin_6=sin((cp.rotate * (double)2 * 3.14159265358979323846) / 360.0);
                fic.rot[(signed long int)0][(signed long int)1] = -return_value_sin_6;
                fic.rot[(signed long int)1][(signed long int)0] = -fic.rot[(signed long int)0][(signed long int)1];
                fic.rot[(signed long int)1][(signed long int)1] = fic.rot[(signed long int)0][(signed long int)0];
                fic.ws0 = (double)fic.width * fic.size[(signed long int)0];
                fic.wb0s0 = fic.ws0 * fic.bounds[(signed long int)0];
                fic.hs1 = (double)fic.height * fic.size[(signed long int)1];
                fic.hb1s1 = fic.hs1 * fic.bounds[(signed long int)1];
              }
              nsamples = sample_density * (double)image_width * (double)image_height;
              batch_size = nsamples / (double)(nbatches * ntemporal_samples);
              stats->num_iters = stats->num_iters + (signed long int)batch_size;
              fic.xform_distrib = xform_distrib;
              fic.spec = spec;
              fic.batch_size = batch_size / (double)spec->nthreads;
              fic.temporal_sample_num = temporal_sample_num;
              fic.ntemporal_samples = ntemporal_samples;
              fic.batch_num = batch_num;
              fic.nbatches = nbatches;
              fic.dmap = (struct anonymous_1 *)dmap;
              fic.color_scalar = color_scalar;
              fic.buckets = (void *)buckets;
              fic.progress_timer = &progress_timer;
              fic.progress_timer_history = &progress_timer_history[(signed long int)0];
              fic.progress_history = &progress_history[(signed long int)0];
              fic.progress_history_mark = &progress_history_mark;
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
              {
                signed int rk = 0;
                for( ; !(rk >= 16); rk = rk + 1)
                {
                  tmp_post_7 = (&spec->rc)->randcnt;
                  (&spec->rc)->randcnt = (&spec->rc)->randcnt - 1ul;
                  if(tmp_post_7 == 0ul)
                  {
                    isaac(&spec->rc);
                    (&spec->rc)->randcnt = (unsigned long int)((1 << 4) - 1);
                    tmp_if_expr_8 = (&spec->rc)->randrsl[(signed long int)(&spec->rc)->randcnt];
                  }

                  else
                    tmp_if_expr_8 = (&spec->rc)->randrsl[(signed long int)(&spec->rc)->randcnt];
                  (fth + (signed long int)thi)->rc.randrsl[(signed long int)rk] = tmp_if_expr_8;
                }
                irandinit(&(fth + (signed long int)thi)->rc, 1);
                if(thi == 0)
                {
                  (fth + (signed long int)thi)->first_thread = 1;
                  if(batch_num == 0 && temporal_sample_num == 0)
                    (fth + (signed long int)thi)->timer_initialize = 1;

                  else
                    (fth + (signed long int)thi)->timer_initialize = 0;
                }

                else
                {
                  (fth + (signed long int)thi)->first_thread = 0;
                  (fth + (signed long int)thi)->timer_initialize = 0;
                }
                (fth + (signed long int)thi)->iter_storage = &points[(signed long int)(thi * spec->sub_batch_size * 4)];
                (fth + (signed long int)thi)->fic = &fic;
                flam3_copy(&(fth + (signed long int)thi)->cp, &cp);
              }
              void *return_value_malloc_9;
              return_value_malloc_9=malloc((unsigned long int)spec->nthreads * sizeof(unsigned long int) /*8ul*/ );
              myThreads = (unsigned long int *)return_value_malloc_9;
              pthread_attr_init(&pt_attr);
              pthread_attr_setdetachstate(&pt_attr, 0);
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
                pthread_create(&myThreads[(signed long int)thi], &pt_attr, (void * (*)(void *))(void *)iter_thread_int_mt, (void *)&fth[(signed long int)thi]);
              pthread_attr_destroy(&pt_attr);
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
                pthread_join(myThreads[(signed long int)thi], (void **)&thread_status);
              free((void *)myThreads);
              free((void *)xform_distrib);
              if(!(fic.aborted == 0))
              {
                if(!(render_rectangle_int_mt__1__verbose == 0))
                  fprintf(stderr, "\naborted!\n");

                goto done;
              }

              vibrancy = vibrancy + cp.vibrancy;
              gamma = gamma + cp.gamma;
              background[(signed long int)0] = background[(signed long int)0] + cp.background[(signed long int)0];
              background[(signed long int)1] = background[(signed long int)1] + cp.background[(signed long int)1];
              background[(signed long int)2] = background[(signed long int)2] + cp.background[(signed long int)2];
              vib_gam_n = vib_gam_n + 1;
            }
            k1 = (cp.contrast * cp.brightness * (double)255 * 268.0 * batch_filter[(signed long int)batch_num]) / (double)256;
            area = (double)(image_width * image_height) / (ppux * ppuy);
            k2 = (double)(oversample * oversample * nbatches) / (cp.contrast * area * (double)255 * sample_density * sumfilt);
            if(de.max_filter_index == 0)
            {
              j = 0;
              for( ; !(j >= fic.height); j = j + 1)
              {
                i = 0;
                for( ; !(i >= fic.width); i = i + 1)
                {
                  unsigned int (*a)[4l] = accumulate + (signed long int)i + (signed long int)(j * fic.width);
                  unsigned int (*b)[5l] = buckets + (signed long int)i + (signed long int)(j * fic.width);
                  double c[4l];
                  double ls;
                  c[(signed long int)0] = (double)b[(signed long int)0][(signed long int)0];
                  c[(signed long int)1] = (double)b[(signed long int)0][(signed long int)1];
                  c[(signed long int)2] = (double)b[(signed long int)0][(signed long int)2];
                  c[(signed long int)3] = (double)b[(signed long int)0][(signed long int)3];
                  if(!IEEE_FLOAT_EQUAL(0.0, c[3l]))
                  {
                    double return_value_log_10;
                    return_value_log_10=log(1.0 + c[(signed long int)3] * k2);
                    ls = (k1 * return_value_log_10) / c[(signed long int)3];
                    c[(signed long int)0] = c[(signed long int)0] * ls;
                    c[(signed long int)1] = c[(signed long int)1] * ls;
                    c[(signed long int)2] = c[(signed long int)2] * ls;
                    c[(signed long int)3] = c[(signed long int)3] * ls;
                    do
                      if((double)(1U + -(*a)[0l]) > c[0l])
                        a[(signed long int)0][(signed long int)0] = a[(signed long int)0][(signed long int)0] + (unsigned int)c[(signed long int)0];

                      else
                        a[(signed long int)0][(signed long int)0] = (unsigned int)0x7fffffff * 2U + 1U;
                    while((_Bool)0);
                    do
                      if((double)(1U + -(*a)[1l]) > c[1l])
                        a[(signed long int)0][(signed long int)1] = a[(signed long int)0][(signed long int)1] + (unsigned int)c[(signed long int)1];

                      else
                        a[(signed long int)0][(signed long int)1] = (unsigned int)0x7fffffff * 2U + 1U;
                    while((_Bool)0);
                    do
                      if((double)(1U + -(*a)[2l]) > c[2l])
                        a[(signed long int)0][(signed long int)2] = a[(signed long int)0][(signed long int)2] + (unsigned int)c[(signed long int)2];

                      else
                        a[(signed long int)0][(signed long int)2] = (unsigned int)0x7fffffff * 2U + 1U;
                    while((_Bool)0);
                    do
                      if((double)(1U + -(*a)[3l]) > c[3l])
                        a[(signed long int)0][(signed long int)3] = a[(signed long int)0][(signed long int)3] + (unsigned int)c[(signed long int)3];

                      else
                        a[(signed long int)0][(signed long int)3] = (unsigned int)0x7fffffff * 2U + 1U;
                    while((_Bool)0);
                  }

                }
              }
            }

            else
            {
              struct anonymous_16 *deth;
              signed int de_aborted = 0;
              signed int myspan = (fic.height - 2 * (oversample - 1)) + 1;
              signed int swath = myspan / spec->nthreads;
              void *return_value_calloc_11;
              return_value_calloc_11=calloc((unsigned long int)spec->nthreads, sizeof(struct anonymous_16) /*104ul*/ );
              deth = (struct anonymous_16 *)return_value_calloc_11;
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
              {
                (deth + (signed long int)thi)->b = buckets;
                (deth + (signed long int)thi)->accumulate = accumulate;
                (deth + (signed long int)thi)->width = fic.width;
                (deth + (signed long int)thi)->height = fic.height;
                (deth + (signed long int)thi)->oversample = oversample;
                (deth + (signed long int)thi)->progress_size = spec->sub_batch_size / 10;
                (deth + (signed long int)thi)->de = &de;
                (deth + (signed long int)thi)->k1 = k1;
                (deth + (signed long int)thi)->k2 = k2;
                (deth + (signed long int)thi)->curve = cp.estimator_curve;
                (deth + (signed long int)thi)->spec = spec;
                (deth + (signed long int)thi)->aborted = &de_aborted;
                if(!(myspan >= spec->nthreads))
                {
                  (deth + (signed long int)thi)->start_row = 0;
                  if(thi == spec->nthreads + -1)
                  {
                    (deth + (signed long int)thi)->end_row = myspan;
                    (deth + (signed long int)thi)->last_thread = 1;
                  }

                  else
                  {
                    (deth + (signed long int)thi)->end_row = -1;
                    (deth + (signed long int)thi)->last_thread = 0;
                  }
                }

                else
                {
                  (deth + (signed long int)thi)->start_row = thi * swath;
                  (deth + (signed long int)thi)->end_row = (thi + 1) * swath;
                  if(thi == spec->nthreads + -1)
                  {
                    (deth + (signed long int)thi)->end_row = myspan;
                    (deth + (signed long int)thi)->last_thread = 1;
                  }

                  else
                    (deth + (signed long int)thi)->last_thread = 0;
                }
              }
              void *return_value_malloc_12;
              return_value_malloc_12=malloc((unsigned long int)spec->nthreads * sizeof(unsigned long int) /*8ul*/ );
              myThreads = (unsigned long int *)return_value_malloc_12;
              pthread_attr_init(&pt_attr);
              pthread_attr_setdetachstate(&pt_attr, 0);
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
                pthread_create(&myThreads[(signed long int)thi], &pt_attr, (void * (*)(void *))(void *)de_thread_32_mt, (void *)&deth[(signed long int)thi]);
              pthread_attr_destroy(&pt_attr);
              thi = 0;
              for( ; !(thi >= spec->nthreads); thi = thi + 1)
                pthread_join(myThreads[(signed long int)thi], (void **)&thread_status);
              free((void *)myThreads);
              free((void *)deth);
              if(!(de_aborted == 0))
              {
                if(!(render_rectangle_int_mt__1__verbose == 0))
                  fprintf(stderr, "\naborted!\n");

                goto done;
              }

            }
            if(de.max_filter_index >= 1)
            {
              free((void *)de.filter_coefs);
              free((void *)de.filter_widths);
            }

          }
          if(!(render_rectangle_int_mt__1__verbose == 0))
          {
            signed long int return_value_time_13;
            return_value_time_13=time((signed long int *)(void *)0);
            fprintf(stderr, "\rchaos: 100.0%%  took: %ld seconds   \n", return_value_time_13 - progress_began);
            fprintf(stderr, "filtering...");
          }

          {
            signed int x;
            signed int y;
            double t[4l];
            double newrgb[3l];
            double g = 1.0 / (gamma / (double)vib_gam_n);
            double tmp;
            double render_rectangle_int_mt__1__13__a;
            double alpha;
            double render_rectangle_int_mt__1__13__ls;
            signed int rgbi;
            double linrange = cp.gam_lin_thresh;
            vibrancy = vibrancy / (double)vib_gam_n;
            background[(signed long int)0] = background[(signed long int)0] / ((double)vib_gam_n / 256.0);
            background[(signed long int)1] = background[(signed long int)1] / ((double)vib_gam_n / 256.0);
            background[(signed long int)2] = background[(signed long int)2] / ((double)vib_gam_n / 256.0);
            if(!(spec->earlyclip == 0))
            {
              j = 0;
              for( ; !(j >= fic.height); j = j + 1)
              {
                i = 0;
                for( ; !(i >= fic.width); i = i + 1)
                {
                  unsigned int (*ac)[4l] = accumulate + (signed long int)i + (signed long int)(j * fic.width);
                  if(!((*ac)[3l] >= 1u))
                  {
                    alpha = 0.0;
                    render_rectangle_int_mt__1__13__ls = 0.0;
                  }

                  else
                  {
                    tmp = (double)(ac[(signed long int)0][(signed long int)3] / (unsigned int)255);
                    alpha=flam3_calc_alpha(tmp, g, linrange);
                    render_rectangle_int_mt__1__13__ls = (vibrancy * 256.0 * alpha) / tmp;
                    if(alpha < 0.0)
                      alpha = 0.0;

                    if(alpha > 1.0)
                      alpha = 1.0;

                  }
                  t[(signed long int)0] = (double)ac[(signed long int)0][(signed long int)0];
                  t[(signed long int)1] = (double)ac[(signed long int)0][(signed long int)1];
                  t[(signed long int)2] = (double)ac[(signed long int)0][(signed long int)2];
                  t[(signed long int)3] = (double)ac[(signed long int)0][(signed long int)3];
                  flam3_calc_newrgb(t, render_rectangle_int_mt__1__13__ls, highpow, newrgb);
                  rgbi = 0;
                  for( ; !(rgbi >= 3); rgbi = rgbi + 1)
                  {
                    render_rectangle_int_mt__1__13__a = newrgb[(signed long int)rgbi];
                    double return_value_pow_14;
                    return_value_pow_14=pow(t[(signed long int)rgbi] / (double)255, g);
                    render_rectangle_int_mt__1__13__a = render_rectangle_int_mt__1__13__a + (1.0 - vibrancy) * 256.0 * return_value_pow_14;
                    if(transp == 0 || !(nchan >= 4))
                      render_rectangle_int_mt__1__13__a = render_rectangle_int_mt__1__13__a + (1.0 - alpha) * background[(signed long int)rgbi];

                    else
                      if(alpha > 0.000000)
                        render_rectangle_int_mt__1__13__a = render_rectangle_int_mt__1__13__a / alpha;

                      else
                        render_rectangle_int_mt__1__13__a = (double)0;
                    if(render_rectangle_int_mt__1__13__a > 255.000000)
                      render_rectangle_int_mt__1__13__a = (double)255;

                    if(render_rectangle_int_mt__1__13__a < 0.000000)
                      render_rectangle_int_mt__1__13__a = (double)0;

                    ac[(signed long int)0][(signed long int)rgbi] = (unsigned int)render_rectangle_int_mt__1__13__a;
                  }
                  ac[(signed long int)0][(signed long int)3] = (unsigned int)alpha;
                }
              }
            }

            y = de_offset;
            j = 0;
            for( ; !(j >= image_height); j = j + 1)
            {
              x = de_offset;
              i = 0;
              for( ; !(i >= image_width); i = i + 1)
              {
                signed int ii;
                signed int jj;
                signed int render_rectangle_int_mt__1__13__2__1__1__1__rgbi;
                void *p;
                unsigned short int *p16;
                unsigned char *p8;
                t[(signed long int)3] = 0.0;
                t[(signed long int)2] = t[(signed long int)3];
                t[(signed long int)1] = t[(signed long int)2];
                t[(signed long int)0] = t[(signed long int)1];
                ii = 0;
                for( ; !(ii >= filter_width); ii = ii + 1)
                {
                  jj = 0;
                  for( ; !(jj >= filter_width); jj = jj + 1)
                  {
                    double k = filter[(signed long int)(ii + jj * filter_width)];
                    unsigned int (*render_rectangle_int_mt__1__13__2__1__1__1__1__1__1__1__ac)[4l] = accumulate + (signed long int)x + (signed long int)ii + (signed long int)((y + jj) * fic.width);
                    t[(signed long int)0] = t[(signed long int)0] + k * (double)render_rectangle_int_mt__1__13__2__1__1__1__1__1__1__1__ac[(signed long int)0][(signed long int)0];
                    t[(signed long int)1] = t[(signed long int)1] + k * (double)render_rectangle_int_mt__1__13__2__1__1__1__1__1__1__1__ac[(signed long int)0][(signed long int)1];
                    t[(signed long int)2] = t[(signed long int)2] + k * (double)render_rectangle_int_mt__1__13__2__1__1__1__1__1__1__1__ac[(signed long int)0][(signed long int)2];
                    t[(signed long int)3] = t[(signed long int)3] + k * (double)render_rectangle_int_mt__1__13__2__1__1__1__1__1__1__1__ac[(signed long int)0][(signed long int)3];
                  }
                }
                p = (void *)((unsigned char *)out + (signed long int)(nchan * bytes_per_channel * (i + j * out_width)));
                p8 = (unsigned char *)p;
                p16 = (unsigned short int *)p;
                if(spec->earlyclip == 0)
                {
                  tmp = t[(signed long int)3] / (double)255;
                  if(t[3l] <= 0.000000)
                  {
                    alpha = 0.0;
                    render_rectangle_int_mt__1__13__ls = 0.0;
                  }

                  else
                  {
                    alpha=flam3_calc_alpha(tmp, g, linrange);
                    render_rectangle_int_mt__1__13__ls = (vibrancy * 256.0 * alpha) / tmp;
                    if(alpha < 0.0)
                      alpha = 0.0;

                    if(alpha > 1.0)
                      alpha = 1.0;

                  }
                  flam3_calc_newrgb(t, render_rectangle_int_mt__1__13__ls, highpow, newrgb);
                  render_rectangle_int_mt__1__13__2__1__1__1__rgbi = 0;
                  for( ; !(render_rectangle_int_mt__1__13__2__1__1__1__rgbi >= 3); render_rectangle_int_mt__1__13__2__1__1__1__rgbi = render_rectangle_int_mt__1__13__2__1__1__1__rgbi + 1)
                  {
                    render_rectangle_int_mt__1__13__a = newrgb[(signed long int)render_rectangle_int_mt__1__13__2__1__1__1__rgbi];
                    double return_value_pow_15;
                    return_value_pow_15=pow(t[(signed long int)render_rectangle_int_mt__1__13__2__1__1__1__rgbi] / (double)255, g);
                    render_rectangle_int_mt__1__13__a = render_rectangle_int_mt__1__13__a + (1.0 - vibrancy) * 256.0 * return_value_pow_15;
                    if(transp == 0 || !(nchan >= 4))
                      render_rectangle_int_mt__1__13__a = render_rectangle_int_mt__1__13__a + (1.0 - alpha) * background[(signed long int)render_rectangle_int_mt__1__13__2__1__1__1__rgbi];

                    else
                      if(alpha > 0.000000)
                        render_rectangle_int_mt__1__13__a = render_rectangle_int_mt__1__13__a / alpha;

                      else
                        render_rectangle_int_mt__1__13__a = (double)0;
                    if(render_rectangle_int_mt__1__13__a > 255.000000)
                      render_rectangle_int_mt__1__13__a = (double)255;

                    if(render_rectangle_int_mt__1__13__a < 0.000000)
                      render_rectangle_int_mt__1__13__a = (double)0;

                    t[(signed long int)render_rectangle_int_mt__1__13__2__1__1__1__rgbi] = render_rectangle_int_mt__1__13__a;
                  }
                  t[(signed long int)3] = alpha;
                }

                render_rectangle_int_mt__1__13__2__1__1__1__rgbi = 0;
                for( ; !(render_rectangle_int_mt__1__13__2__1__1__1__rgbi >= 3); render_rectangle_int_mt__1__13__2__1__1__1__rgbi = render_rectangle_int_mt__1__13__2__1__1__1__rgbi + 1)
                {
                  render_rectangle_int_mt__1__13__a = t[(signed long int)render_rectangle_int_mt__1__13__2__1__1__1__rgbi];
                  if(render_rectangle_int_mt__1__13__a > 255.000000)
                    render_rectangle_int_mt__1__13__a = (double)255;

                  if(render_rectangle_int_mt__1__13__a < 0.000000)
                    render_rectangle_int_mt__1__13__a = (double)0;

                  if(bytes_per_channel == 2)
                  {
                    render_rectangle_int_mt__1__13__a = render_rectangle_int_mt__1__13__a * 256.0;
                    p16[(signed long int)render_rectangle_int_mt__1__13__2__1__1__1__rgbi] = (unsigned short int)render_rectangle_int_mt__1__13__a;
                  }

                  else
                    p8[(signed long int)render_rectangle_int_mt__1__13__2__1__1__1__rgbi] = (unsigned char)render_rectangle_int_mt__1__13__a;
                }
                if(t[3l] > 1.000000)
                  t[(signed long int)3] = (double)1;

                if(t[3l] < 0.000000)
                  t[(signed long int)3] = (double)0;

                if(nchan >= 4)
                {
                  if(transp == 1)
                  {
                    if(bytes_per_channel == 2)
                      p16[(signed long int)3] = (unsigned short int)(t[(signed long int)3] * (double)65535);

                    else
                      p8[(signed long int)3] = (unsigned char)(t[(signed long int)3] * (double)255);
                  }

                  else
                    if(bytes_per_channel == 2)
                      p16[(signed long int)3] = (unsigned short int)65535;

                    else
                      p8[(signed long int)3] = (unsigned char)255;
                }

                x = x + oversample;
              }
              y = y + oversample;
            }
          }

        done:
          ;
          stats->badvals = fic.badvals;
          free((void *)temporal_filter);
          free((void *)temporal_deltas);
          free((void *)batch_filter);
          free((void *)filter);
          free((void *)buckets);
          thi = 0;
          for( ; !(thi >= spec->nthreads); thi = thi + 1)
            clear_cp(&(fth + (signed long int)thi)->cp, 0);
          free((void *)fth);
          clear_cp(&cp, 0);
          char *return_value_getenv_16;
          return_value_getenv_16=getenv("insert_palette");
          if(!(return_value_getenv_16 == ((char *)NULL)))
          {
            signed int ph = 100;
            if(ph >= image_height)
              ph = image_height;

            j = 0;
            for( ; !(j >= ph); j = j + 1)
            {
              i = 0;
              for( ; !(i >= image_width); i = i + 1)
              {
                unsigned char *render_rectangle_int_mt__1__15__1__1__1__1__p = (unsigned char *)out + (signed long int)(nchan * (i + j * out_width));
                render_rectangle_int_mt__1__15__1__1__1__1__p[(signed long int)0] = (unsigned char)dmap[(signed long int)((i * 256) / image_width)].color[(signed long int)0];
                render_rectangle_int_mt__1__15__1__1__1__1__p[(signed long int)1] = (unsigned char)dmap[(signed long int)((i * 256) / image_width)].color[(signed long int)1];
                render_rectangle_int_mt__1__15__1__1__1__1__p[(signed long int)2] = (unsigned char)dmap[(signed long int)((i * 256) / image_width)].color[(signed long int)2];
              }
            }
          }

          tend=time((signed long int *)(void *)0);
          stats->render_seconds = (signed int)(tend - tstart);
          return 0;
        }
      }
    }
}

// rgb2hsv
// file palettes.h line 30
void rgb2hsv(double *rgb, double *hsv)
{
  double rd;
  double gd;
  double bd;
  double h;
  double s;
  double v;
  double max;
  double min;
  double del;
  double rc;
  double gc;
  double bc;
  rd = rgb[(signed long int)0];
  gd = rgb[(signed long int)1];
  bd = rgb[(signed long int)2];
  if(rd >= gd)
  {
    if(rd >= bd)
      max = rd;

    else
      max = bd;
  }

  else
    if(gd >= bd)
      max = gd;

    else
      max = bd;
  if(rd <= gd)
  {
    if(rd <= bd)
      min = rd;

    else
      min = bd;
  }

  else
    if(gd <= bd)
      min = gd;

    else
      min = bd;
  del = max - min;
  v = max;
  if(IEEE_FLOAT_NOTEQUAL(max, 0.0))
    s = del / max;

  else
    s = 0.0;
  h = (double)0;
  if(IEEE_FLOAT_NOTEQUAL(s, 0.0))
  {
    rc = (max - rd) / del;
    gc = (max - gd) / del;
    bc = (max - bd) / del;
    if(IEEE_FLOAT_EQUAL(rd, max))
      h = bc - gc;

    else
      if(IEEE_FLOAT_EQUAL(gd, max))
        h = ((double)2 + rc) - bc;

      else
        if(IEEE_FLOAT_EQUAL(bd, max))
          h = ((double)4 + gc) - rc;

    if(h < 0.000000)
      h = h + (double)6;

  }

  hsv[(signed long int)0] = h;
  hsv[(signed long int)1] = s;
  hsv[(signed long int)2] = v;
}

// rotate_by
// file flam3.h line 617
void rotate_by(double *p, double *center, double by)
{
  double r[2l];
  double th = (by * (double)2 * 3.14159265358979323846) / 360.0;
  double c;
  c=cos(th);
  double s;
  double return_value_sin_1;
  return_value_sin_1=sin(th);
  s = -return_value_sin_1;
  p[(signed long int)0] = p[(signed long int)0] - center[(signed long int)0];
  p[(signed long int)1] = p[(signed long int)1] - center[(signed long int)1];
  r[(signed long int)0] = c * p[(signed long int)0] - s * p[(signed long int)1];
  r[(signed long int)1] = s * p[(signed long int)0] + c * p[(signed long int)1];
  p[(signed long int)0] = r[(signed long int)0] + center[(signed long int)0];
  p[(signed long int)1] = r[(signed long int)1] + center[(signed long int)1];
}

// round6
// file flam3.c line 2425
static double round6(double x)
{
  x = x * 1e6;
  if(x < 0.000000)
    x = x - 1.0;

  return 1e-6 * (double)(signed int)(x + 0.5);
}

// scan_for_flame_nodes
// file parser.h line 29
void scan_for_flame_nodes(struct _xmlNode *cur_node, char *parent_file, signed int default_flag, struct anonymous_0 **all_cps, signed int *all_ncps)
{
  struct _xmlNode *this_node = (struct _xmlNode *)(void *)0;
  struct anonymous_0 loc_current_cp;
  struct anonymous_0 *genome_storage = *all_cps;
  unsigned long int f3_storage;
  signed int pfe_success;
  signed int col_success;
  memset((void *)&loc_current_cp, 0, sizeof(struct anonymous_0) /*10712ul*/ );
  this_node = cur_node;
  _Bool tmp_if_expr_3;
  signed int return_value_xmlStrcmp_2;
  for( ; !(this_node == ((struct _xmlNode *)NULL)); this_node = this_node->next)
  {
    if((signed int)this_node->type == XML_ELEMENT_NODE)
    {
      return_value_xmlStrcmp_2=xmlStrcmp(this_node->name, (const unsigned char *)"flame");
      tmp_if_expr_3 = !(return_value_xmlStrcmp_2 != 0) ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
    {
      clear_cp(&loc_current_cp, default_flag);
      pfe_success=parse_flame_element(this_node, &loc_current_cp);
      if(pfe_success >= 1)
      {
        fprintf(stderr, "error parsing flame element\n");
        all_cps = (struct anonymous_0 **)(void *)0;
        *all_ncps = 0;
        goto __CPROVER_DUMP_L9;
      }

      f3_storage = (unsigned long int)(1 + *all_ncps) * sizeof(struct anonymous_0) /*10712ul*/ ;
      void *return_value_realloc_1;
      return_value_realloc_1=realloc((void *)genome_storage, f3_storage);
      genome_storage = (struct anonymous_0 *)return_value_realloc_1;
      *all_cps = genome_storage;
      memset((void *)&genome_storage[(signed long int)*all_ncps], 0, sizeof(struct anonymous_0) /*10712ul*/ );
      if(!(loc_current_cp.palette_index == -1))
      {
        col_success=flam3_get_palette(loc_current_cp.palette_index, loc_current_cp.palette, loc_current_cp.hue_rotation);
        if(!(col_success >= 0))
          fprintf(stderr, "error retrieving palette %d, setting to all white\n", loc_current_cp.palette_index);

      }

      col_success=flam3_interp_missing_colors(&loc_current_cp);
      loc_current_cp.genome_index = *all_ncps;
      memset((void *)loc_current_cp.parent_fname, 0, (unsigned long int)30);
      __builtin_strncpy(loc_current_cp.parent_fname, parent_file, (unsigned long int)(30 - 1));
      flam3_copy(&genome_storage[(signed long int)*all_ncps], &loc_current_cp);
      *all_ncps = *all_ncps + 1;
    }

    else
      scan_for_flame_nodes(this_node->children, parent_file, default_flag, all_cps, all_ncps);
  }
  clear_cp(&loc_current_cp, default_flag);

__CPROVER_DUMP_L9:
  ;
}

// sheep_edge
// file flam3.h line 638
struct anonymous_0 * sheep_edge(struct anonymous_0 *cp, double blend, signed int seqflag, double stagger)
{
  struct anonymous_0 spun[2l];
  struct anonymous_0 prealign[2l];
  struct anonymous_0 *result;
  signed int i;
  signed int si;
  char *ai;
  memset((void *)spun, 0, (unsigned long int)2 * sizeof(struct anonymous_0) /*10712ul*/ );
  memset((void *)prealign, 0, (unsigned long int)2 * sizeof(struct anonymous_0) /*10712ul*/ );
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_0) /*10712ul*/ );
  result = (struct anonymous_0 *)return_value_calloc_1;
  si = 0;
  for( ; !(si >= 2); si = si + 1)
  {
    flam3_copy(&prealign[(signed long int)si], &cp[(signed long int)si]);
    i = 0;
    for( ; !(i >= (cp + (signed long int)si)->num_xforms); i = i + 1)
      if(((cp + (signed long int)si)->xform + (signed long int)i)->num_motion >= 1)
        apply_motion_parameters(&(cp + (signed long int)si)->xform[(signed long int)i], &prealign[(signed long int)si].xform[(signed long int)i], blend);

  }
  signed int tmp_if_expr_4;
  signed int return_value_atoi_3;
  double return_value_smoother_2;
  if(IEEE_FLOAT_EQUAL(0.0, blend) && !(seqflag == 0))
    flam3_copy(result, &prealign[(signed long int)0]);

  else
  {
    flam3_align(spun, prealign, 2);
    spun[(signed long int)0].time = 0.0;
    spun[(signed long int)1].time = 1.0;
    establish_asymmetric_refangles(spun, 2);
    flam3_rotate(&spun[(signed long int)0], blend * 360.0, spun[(signed long int)0].interpolation_type);
    flam3_rotate(&spun[(signed long int)1], blend * 360.0, spun[(signed long int)0].interpolation_type);
    ai=getenv("unsmoother");
    if(!(ai == ((char *)NULL)))
    {
      return_value_atoi_3=atoi_link1(ai);
      tmp_if_expr_4 = return_value_atoi_3;
    }

    else
      tmp_if_expr_4 = 0;
    if(tmp_if_expr_4 == 0)
    {
      return_value_smoother_2=smoother(blend);
      flam3_interpolate(spun, 2, return_value_smoother_2, stagger, result);
    }

    else
      flam3_interpolate(spun, 2, blend, stagger, result);
  }
  clear_cp(&spun[(signed long int)0], 1);
  clear_cp(&spun[(signed long int)1], 1);
  clear_cp(&prealign[(signed long int)0], 1);
  clear_cp(&prealign[(signed long int)1], 1);
  i = 0;
  for( ; !(i >= result->num_xforms); i = i + 1)
    flam3_delete_motion_elements(&result->xform[(signed long int)i]);
  return result;
}

// sheep_loop
// file flam3.h line 637
struct anonymous_0 * sheep_loop(struct anonymous_0 *cp, double blend)
{
  struct anonymous_0 *result;
  signed int i;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)1, sizeof(struct anonymous_0) /*10712ul*/ );
  result = (struct anonymous_0 *)return_value_calloc_1;
  clear_cp(result, 1);
  flam3_copy(result, cp);
  i = 0;
  for( ; !(i >= cp->num_xforms); i = i + 1)
  {
    if((cp->xform + (signed long int)i)->num_motion >= 1)
      apply_motion_parameters(&cp->xform[(signed long int)i], &result->xform[(signed long int)i], blend);

    flam3_delete_motion_elements(&result->xform[(signed long int)i]);
  }
  flam3_rotate(result, blend * 360.0, result->interpolation_type);
  return result;
}

// smoother
// file interpolation.h line 34
double smoother(double t)
{
  return (double)3 * t * t - (double)2 * t * t * t;
}

// sort_by_x
// file flam3.c line 3392
static signed int sort_by_x(const void *av, const void *bv)
{
  double *a = (double *)av;
  double *b = (double *)bv;
  if(*a < *b)
    return -1;

  else
    if(*a > *b)
      return 1;

    else
      return 0;
}

// sort_by_y
// file flam3.c line 3400
static signed int sort_by_y(const void *av, const void *bv)
{
  double *a = (double *)av;
  double *b = (double *)bv;
  if(a[1l] < b[1l])
    return -1;

  else
    if(a[1l] > b[1l])
      return 1;

    else
      return 0;
}

// spin
// file flam3-genome.c line 229
void spin(signed int frame, double blend, struct anonymous_0 *parent, struct anonymous_0 *templ)
{
  struct anonymous_0 *result;
  char action[50l];
  struct _xmlDoc *doc;
  result=sheep_loop(parent, blend);
  if(!(templ == ((struct anonymous_0 *)NULL)))
    flam3_apply_template(result, templ);

  result->time = (double)frame;
  result->interpolation = 0;
  result->palette_interpolation = 0;
  sprintf(action, "rotate %g", blend * 360.0);
  doc=create_new_editdoc(action, parent, (struct anonymous_0 *)(void *)0);
  result->edits = doc;
  offset(result);
  sprintf(result->flame_name, "%f", result->time);
  gprint(result, 1);
  xmlFreeDoc(result->edits);
  clear_cp(result, 1);
  free((void *)result);
}

// spin_inter
// file flam3-genome.c line 275
void spin_inter(signed int frame, double blend, signed int seqflag, struct anonymous_0 *parents, struct anonymous_0 *templ)
{
  struct anonymous_0 *result;
  char action[50l];
  struct _xmlDoc *doc;
  char *ai;
  double stagger;
  ai=getenv("stagger");
  double tmp_if_expr_2;
  double return_value_atof_1;
  if(!(ai == ((char *)NULL)))
  {
    return_value_atof_1=atof(ai);
    tmp_if_expr_2 = return_value_atof_1;
  }

  else
    tmp_if_expr_2 = 0.0;
  stagger = tmp_if_expr_2;
  result=sheep_edge(parents, blend, seqflag, stagger);
  if(!(parents->palette_index == -1))
  {
    if(!((parents + 1l)->palette_index == -1))
    {
      result->palette_index = -2;
      result->palette_index0 = (parents + (signed long int)0)->palette_index;
      result->hue_rotation0 = (parents + (signed long int)0)->hue_rotation;
      result->palette_index1 = (parents + (signed long int)1)->palette_index;
      result->hue_rotation1 = (parents + (signed long int)1)->hue_rotation;
      result->palette_blend = blend;
    }

  }

  if(!(templ == ((struct anonymous_0 *)NULL)))
    flam3_apply_template(result, templ);

  result->time = (double)frame;
  sprintf(action, "interpolate %g", blend * 360.0);
  doc=create_new_editdoc(action, &parents[(signed long int)0], &parents[(signed long int)1]);
  result->edits = doc;
  offset(result);
  sprintf(result->flame_name, "%f", result->time);
  gprint(result, 1);
  xmlFreeDoc(result->edits);
  clear_cp(result, 1);
  free((void *)result);
}

// string_to_cp
// file flam3-genome.c line 63
struct anonymous_0 * string_to_cp(char *s, signed int *n)
{
  struct anonymous_0 *cp;
  struct _IO_FILE *fp;
  fp=fopen(s, "rb");
  if(fp == ((struct _IO_FILE *)NULL))
  {
    perror(s);
    exit(1);
  }

  cp=flam3_parse_from_file(fp, s, 1, n);
  if(cp == ((struct anonymous_0 *)NULL))
  {
    fprintf(stderr, "could not read genome from %s.\n", s);
    exit(1);
  }

  return cp;
}

// sum_matrix
// file interpolation.c line 100
void sum_matrix(double s, double (*m1)[2l], double (*m2)[2l])
{
  m2[(signed long int)0][(signed long int)0] = m2[(signed long int)0][(signed long int)0] + s * m1[(signed long int)0][(signed long int)0];
  m2[(signed long int)0][(signed long int)1] = m2[(signed long int)0][(signed long int)1] + s * m1[(signed long int)0][(signed long int)1];
  m2[(signed long int)1][(signed long int)0] = m2[(signed long int)1][(signed long int)0] + s * m1[(signed long int)1][(signed long int)0];
  m2[(signed long int)1][(signed long int)1] = m2[(signed long int)1][(signed long int)1] + s * m1[(signed long int)1][(signed long int)1];
  m2[(signed long int)2][(signed long int)0] = m2[(signed long int)2][(signed long int)0] + s * m1[(signed long int)2][(signed long int)0];
  m2[(signed long int)2][(signed long int)1] = m2[(signed long int)2][(signed long int)1] + s * m1[(signed long int)2][(signed long int)1];
}

// supershape_precalc
// file variations.c line 1984
void supershape_precalc(struct xform *xf)
{
  xf->super_shape_pm_4 = xf->super_shape_m / 4.0;
  xf->super_shape_pneg1_n1 = -1.0 / xf->super_shape_n1;
}

// test_cp
// file flam3-genome.c line 38
void test_cp(struct anonymous_0 *cp)
{
  cp->time = 0.0;
  cp->interpolation = 0;
  cp->palette_interpolation = 0;
  cp->background[(signed long int)0] = 0.0;
  cp->background[(signed long int)1] = 0.0;
  cp->background[(signed long int)2] = 0.0;
  cp->center[(signed long int)0] = 0.0;
  cp->center[(signed long int)1] = 0.0;
  cp->rotate = 0.0;
  cp->pixels_per_unit = (double)64;
  cp->width = 128;
  cp->height = 128;
  cp->spatial_oversample = 1;
  cp->spatial_filter_radius = 0.5;
  cp->spatial_filter_select = 0;
  cp->zoom = 0.0;
  cp->sample_density = (double)1;
  cp->nbatches = 1;
  cp->ntemporal_samples = 1;
  cp->estimator = 0.0;
  cp->estimator_minimum = 0.0;
  cp->estimator_curve = 0.6;
}

// truncate_variations
// file flam3-genome.c line 328
void truncate_variations(struct anonymous_0 *g, signed int max_vars, char *action)
{
  signed int i;
  signed int j;
  signed int nvars;
  signed int smallest;
  double sv = (double)0;
  char trunc_note[30l];
  i = 0;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  double return_value_fabs_1;
  for( ; !(i >= g->num_xforms); i = i + 1)
  {
    double d = (g->xform + (signed long int)i)->density;
    if(d < 0.001)
      tmp_if_expr_3 = g->final_xform_index != i ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
    {
      sprintf(trunc_note, " trunc_density %d", i);
      add_to_action(action, trunc_note);
      flam3_delete_xform(g, i);
    }

    else
      do
      {
        nvars = 0;
        smallest = -1;
        j = 0;
        for( ; !(j >= 98); j = j + 1)
        {
          double v = (g->xform + (signed long int)i)->var[(signed long int)j];
          if(IEEE_FLOAT_NOTEQUAL(v, 0.0))
          {
            nvars = nvars + 1;
            if(smallest == -1)
              tmp_if_expr_2 = (_Bool)1;

            else
            {
              return_value_fabs_1=fabs(v);
              tmp_if_expr_2 = return_value_fabs_1 < sv ? (_Bool)1 : (_Bool)0;
            }
            if(tmp_if_expr_2)
            {
              smallest = j;
              sv=fabs(v);
            }

          }

        }
        if(!(max_vars >= nvars))
        {
          sprintf(trunc_note, " trunc %d %d", i, smallest);
          add_to_action(action, trunc_note);
          (g->xform + (signed long int)i)->var[(signed long int)smallest] = 0.0;
        }

      }
      while(!(max_vars >= nvars));
  }
}

// try_colors
// file palettes.c line 362
static double try_colors(struct anonymous_0 *g, signed int color_resolution)
{
  signed int *hist;
  signed int i;
  signed int hits;
  signed int res = color_resolution;
  signed int res3 = res * res * res;
  struct anonymous_4 f;
  unsigned char *image;
  unsigned char *p;
  struct anonymous_0 saved;
  double scalar;
  signed int pixtotal;
  struct anonymous_8 stats;
  memset((void *)&saved, 0, sizeof(struct anonymous_0) /*10712ul*/ );
  flam3_copy(&saved, g);
  g->sample_density = (double)1;
  g->spatial_oversample = 1;
  g->estimator = 0.0;
  pixtotal = g->width * g->height;
  scalar=sqrt(10000.0 / (double)pixtotal);
  g->width = g->width * (signed int)scalar;
  g->height = g->height * (signed int)scalar;
  g->pixels_per_unit = g->pixels_per_unit * scalar;
  g->nbatches = 1;
  g->ntemporal_samples = 1;
  flam3_init_frame(&f);
  f.bits = 33;
  f.bytes_per_channel = 1;
  f.verbose = 0;
  f.genomes = g;
  f.ngenomes = 1;
  f.earlyclip = 1;
  f.pixel_aspect_ratio = 1.0;
  f.progress = ((signed int (*)(void *, double, signed int, double))NULL);
  f.nthreads = 1;
  f.sub_batch_size = 10000;
  void *return_value_calloc_1;
  return_value_calloc_1=calloc((unsigned long int)(g->width * g->height), (unsigned long int)3);
  image = (unsigned char *)return_value_calloc_1;
  signed int return_value_flam3_render_2;
  return_value_flam3_render_2=flam3_render(&f, (void *)image, 0, 3, 0, &stats);
  if(!(return_value_flam3_render_2 == 0))
  {
    fprintf(stderr, "Error rendering test image for trycolors.  Aborting.\n");
    return (double)-1;
  }

  else
  {
    void *return_value_calloc_3;
    return_value_calloc_3=calloc(sizeof(signed int) /*4ul*/ , (unsigned long int)res3);
    hist = (signed int *)return_value_calloc_3;
    p = image;
    i = 0;
    for( ; !(i >= g->height * g->width); i = i + 1)
    {
      hist[(signed long int)(((signed int)p[(signed long int)0] * res) / 256 + (((signed int)p[(signed long int)1] * res) / 256) * res + (((signed int)p[(signed long int)2] * res) / 256) * res * res)] = hist[(signed long int)(((signed int)p[(signed long int)0] * res) / 256 + (((signed int)p[(signed long int)1] * res) / 256) * res + (((signed int)p[(signed long int)2] * res) / 256) * res * res)] + 1;
      p = p + (signed long int)3;
    }
    hits = 0;
    i = 0;
    for( ; !(i >= res3); i = i + 1)
      if(!(hist[(signed long int)i] == 0))
        hits = hits + 1;

    free((void *)hist);
    free((void *)image);
    g->sample_density = saved.sample_density;
    g->width = saved.width;
    g->height = saved.height;
    g->spatial_oversample = saved.spatial_oversample;
    g->pixels_per_unit = saved.pixels_per_unit;
    g->nbatches = saved.nbatches;
    g->ntemporal_samples = saved.ntemporal_samples;
    g->estimator = saved.estimator;
    clear_cp(&saved, 1);
    return (double)(hits / res3);
  }
}

// uint_atomic_add
// file flam3.c line 3545
static inline void uint_atomic_add(unsigned int *dest, unsigned int delta)
{
  unsigned int old_val;
  unsigned int new_val;
  signed int success;
  do
  {
    old_val = *dest;
    if(!(delta >= 1U + -old_val))
      new_val = old_val + delta;

    else
      new_val = (unsigned int)0x7fffffff * 2U + 1U;
    _Bool return_value___sync_bool_compare_and_swap_1;
    __CPROVER_atomic_begin();
    return_value___sync_bool_compare_and_swap_1 = *dest == old_val;
    *dest = *dest == old_val ? new_val : *dest;
    FENCE(WRfence);
    __CPROVER_atomic_end();
    success = (signed int)return_value___sync_bool_compare_and_swap_1;
  }
  while(success == 0);
}

// var0_linear
// file variations.c line 141
void var0_linear(struct anonymous_9 *f, double weight)
{
  f->p0 = f->p0 + weight * f->tx;
  f->p1 = f->p1 + weight * f->ty;
}

// var10_hyperbolic
// file variations.c line 297
void var10_hyperbolic(struct anonymous_9 *f, double weight)
{
  double r = f->precalc_sqrt + 1e-10;
  f->p0 = f->p0 + (weight * f->precalc_sina) / r;
  f->p1 = f->p1 + weight * f->precalc_cosa * r;
}

// var11_diamond
// file variations.c line 310
void var11_diamond(struct anonymous_9 *f, double weight)
{
  double r = f->precalc_sqrt;
  double sr;
  double cr;
  sincos(r, &sr, &cr);
  f->p0 = f->p0 + weight * f->precalc_sina * cr;
  f->p1 = f->p1 + weight * f->precalc_cosa * sr;
}

// var12_ex
// file variations.c line 325
void var12_ex(struct anonymous_9 *f, double weight)
{
  double a = f->precalc_atan;
  double r = f->precalc_sqrt;
  double n0;
  n0=sin(a + r);
  double n1;
  n1=cos(a - r);
  double m0 = n0 * n0 * n0 * r;
  double m1 = n1 * n1 * n1 * r;
  f->p0 = f->p0 + weight * (m0 + m1);
  f->p1 = f->p1 + weight * (m0 - m1);
}

// var13_julia
// file variations.c line 349
void var13_julia(struct anonymous_9 *f, double weight)
{
  double r;
  double a = 0.5 * f->precalc_atan;
  double sa;
  double ca;
  signed int return_value_flam3_random_isaac_bit_1;
  return_value_flam3_random_isaac_bit_1=flam3_random_isaac_bit(f->rc);
  if(!(return_value_flam3_random_isaac_bit_1 == 0))
    a = a + 3.14159265358979323846;

  double return_value_sqrt_2;
  return_value_sqrt_2=sqrt(f->precalc_sqrt);
  r = weight * return_value_sqrt_2;
  sincos(a, &sa, &ca);
  f->p0 = f->p0 + r * ca;
  f->p1 = f->p1 + r * sa;
}

// var14_bent
// file variations.c line 374
void var14_bent(struct anonymous_9 *f, double weight)
{
  double nx = f->tx;
  double ny = f->ty;
  if(nx < 0.0)
    nx = nx * 2.0;

  if(ny < 0.0)
    ny = ny / 2.0;

  f->p0 = f->p0 + weight * nx;
  f->p1 = f->p1 + weight * ny;
}

// var15_waves
// file variations.c line 395
void var15_waves(struct anonymous_9 *f, double weight)
{
  double c10 = f->xform->c[(signed long int)1][(signed long int)0];
  double c11 = f->xform->c[(signed long int)1][(signed long int)1];
  double nx;
  double return_value_sin_1;
  return_value_sin_1=sin(f->ty * f->xform->waves_dx2);
  nx = f->tx + c10 * return_value_sin_1;
  double ny;
  double return_value_sin_2;
  return_value_sin_2=sin(f->tx * f->xform->waves_dy2);
  ny = f->ty + c11 * return_value_sin_2;
  f->p0 = f->p0 + weight * nx;
  f->p1 = f->p1 + weight * ny;
}

// var16_fisheye
// file variations.c line 414
void var16_fisheye(struct anonymous_9 *f, double weight)
{
  double r = f->precalc_sqrt;
  r = ((double)2 * weight) / (r + (double)1);
  f->p0 = f->p0 + r * f->ty;
  f->p1 = f->p1 + r * f->tx;
}

// var17_popcorn
// file variations.c line 432
void var17_popcorn(struct anonymous_9 *f, double weight)
{
  double dx;
  dx=tan((double)3 * f->ty);
  double dy;
  dy=tan((double)3 * f->tx);
  double nx;
  double return_value_sin_1;
  return_value_sin_1=sin(dx);
  nx = f->tx + f->xform->c[(signed long int)2][(signed long int)0] * return_value_sin_1;
  double ny;
  double return_value_sin_2;
  return_value_sin_2=sin(dy);
  ny = f->ty + f->xform->c[(signed long int)2][(signed long int)1] * return_value_sin_2;
  f->p0 = f->p0 + weight * nx;
  f->p1 = f->p1 + weight * ny;
}

// var18_exponential
// file variations.c line 451
void var18_exponential(struct anonymous_9 *f, double weight)
{
  double dx;
  double return_value_exp_1;
  return_value_exp_1=exp(f->tx - 1.0);
  dx = weight * return_value_exp_1;
  double dy = 3.14159265358979323846 * f->ty;
  double sdy;
  double cdy;
  sincos(dy, &sdy, &cdy);
  f->p0 = f->p0 + dx * cdy;
  f->p1 = f->p1 + dx * sdy;
}

// var19_power
// file variations.c line 471
void var19_power(struct anonymous_9 *f, double weight)
{
  double r;
  double return_value_pow_1;
  return_value_pow_1=pow(f->precalc_sqrt, f->precalc_sina);
  r = weight * return_value_pow_1;
  f->p0 = f->p0 + r * f->precalc_cosa;
  f->p1 = f->p1 + r * f->precalc_sina;
}

// var1_sinusoidal
// file variations.c line 152
void var1_sinusoidal(struct anonymous_9 *f, double weight)
{
  double return_value_sin_1;
  return_value_sin_1=sin(f->tx);
  f->p0 = f->p0 + weight * return_value_sin_1;
  double return_value_sin_2;
  return_value_sin_2=sin(f->ty);
  f->p1 = f->p1 + weight * return_value_sin_2;
}

// var20_cosine
// file variations.c line 488
void var20_cosine(struct anonymous_9 *f, double weight)
{
  double a = f->tx * 3.14159265358979323846;
  double sa;
  double ca;
  double nx;
  double ny;
  sincos(a, &sa, &ca);
  double return_value_cosh_1;
  return_value_cosh_1=cosh(f->ty);
  nx = ca * return_value_cosh_1;
  double return_value_sinh_2;
  return_value_sinh_2=sinh(f->ty);
  ny = -sa * return_value_sinh_2;
  f->p0 = f->p0 + weight * nx;
  f->p1 = f->p1 + weight * ny;
}

// var21_rings
// file variations.c line 507
void var21_rings(struct anonymous_9 *f, double weight)
{
  double dx = f->xform->c[(signed long int)2][(signed long int)0] * f->xform->c[(signed long int)2][(signed long int)0] + 1e-10;
  double r = f->precalc_sqrt;
  double return_value_fmod_1;
  return_value_fmod_1=fmod(r + dx, (double)2 * dx);
  r = weight * ((return_value_fmod_1 - dx) + r * ((double)1 - dx));
  f->p0 = f->p0 + r * f->precalc_cosa;
  f->p1 = f->p1 + r * f->precalc_sina;
}

// var22_fan
// file variations.c line 527
void var22_fan(struct anonymous_9 *f, double weight)
{
  double dx = 3.14159265358979323846 * (f->xform->c[(signed long int)2][(signed long int)0] * f->xform->c[(signed long int)2][(signed long int)0] + 1e-10);
  double dy = f->xform->c[(signed long int)2][(signed long int)1];
  double dx2 = 0.5 * dx;
  double a = f->precalc_atan;
  double r = weight * f->precalc_sqrt;
  double sa;
  double ca;
  double return_value_fmod_1;
  return_value_fmod_1=fmod(a + dy, dx);
  a = a + (return_value_fmod_1 > dx2 ? -dx2 : dx2);
  sincos(a, &sa, &ca);
  f->p0 = f->p0 + r * ca;
  f->p1 = f->p1 + r * sa;
}

// var23_blob
// file variations.c line 556
void var23_blob(struct anonymous_9 *f, double weight)
{
  double r = f->precalc_sqrt;
  double a = f->precalc_atan;
  double bdiff = f->xform->blob_high - f->xform->blob_low;
  double return_value_sin_1;
  return_value_sin_1=sin(f->xform->blob_waves * a);
  r = r * (f->xform->blob_low + bdiff * (0.5 + 0.5 * return_value_sin_1));
  f->p0 = f->p0 + weight * f->precalc_sina * r;
  f->p1 = f->p1 + weight * f->precalc_cosa * r;
}

// var24_pdj
// file variations.c line 578
void var24_pdj(struct anonymous_9 *f, double weight)
{
  double nx1;
  nx1=cos(f->xform->pdj_b * f->tx);
  double nx2;
  nx2=sin(f->xform->pdj_c * f->tx);
  double ny1;
  ny1=sin(f->xform->pdj_a * f->ty);
  double ny2;
  ny2=cos(f->xform->pdj_d * f->ty);
  f->p0 = f->p0 + weight * (ny1 - nx1);
  f->p1 = f->p1 + weight * (nx2 - ny2);
}

// var25_fan2
// file variations.c line 597
void var25_fan2(struct anonymous_9 *f, double weight)
{
  double dy = f->xform->fan2_y;
  double dx = 3.14159265358979323846 * (f->xform->fan2_x * f->xform->fan2_x + 1e-10);
  double dx2 = 0.5 * dx;
  double a = f->precalc_atan;
  double sa;
  double ca;
  double r = weight * f->precalc_sqrt;
  double t = (a + dy) - dx * (double)(signed int)((a + dy) / dx);
  if(t > dx2)
    a = a - dx2;

  else
    a = a + dx2;
  sincos(a, &sa, &ca);
  f->p0 = f->p0 + r * sa;
  f->p1 = f->p1 + r * ca;
}

// var26_rings2
// file variations.c line 639
void var26_rings2(struct anonymous_9 *f, double weight)
{
  double r = f->precalc_sqrt;
  double dx = f->xform->rings2_val * f->xform->rings2_val + 1e-10;
  r = r + -2.0 * dx * (double)(signed int)((r + dx) / (2.0 * dx)) + r * (1.0 - dx);
  f->p0 = f->p0 + weight * f->precalc_sina * r;
  f->p1 = f->p1 + weight * f->precalc_cosa * r;
}

// var27_eyefish
// file variations.c line 658
void var27_eyefish(struct anonymous_9 *f, double weight)
{
  double r = (weight * 2.0) / (f->precalc_sqrt + 1.0);
  f->p0 = f->p0 + r * f->tx;
  f->p1 = f->p1 + r * f->ty;
}

// var28_bubble
// file variations.c line 670
void var28_bubble(struct anonymous_9 *f, double weight)
{
  double r = weight / (0.25 * f->precalc_sumsq + (double)1);
  f->p0 = f->p0 + r * f->tx;
  f->p1 = f->p1 + r * f->ty;
}

// var29_cylinder
// file variations.c line 679
void var29_cylinder(struct anonymous_9 *f, double weight)
{
  double return_value_sin_1;
  return_value_sin_1=sin(f->tx);
  f->p0 = f->p0 + weight * return_value_sin_1;
  f->p1 = f->p1 + weight * f->ty;
}

// var2_spherical
// file variations.c line 163
void var2_spherical(struct anonymous_9 *f, double weight)
{
  double r2 = weight / (f->precalc_sumsq + 1e-10);
  f->p0 = f->p0 + r2 * f->tx;
  f->p1 = f->p1 + r2 * f->ty;
}

// var2n
// file parser.c line 74
signed int var2n(const char *s)
{
  signed int i = 0;
  signed int tmp_statement_expression_1;
  for( ; !(i >= 98); i = i + 1)
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp_2;
    return_value___builtin_strcmp_2=__builtin_strcmp(s, flam3_variation_names[(signed long int)i]);
    tmp_statement_expression_1 = return_value___builtin_strcmp_2;
    if(tmp_statement_expression_1 == 0)
      return i;

  }
  return -1;
}

// var30_perspective
// file variations.c line 686
void var30_perspective(struct anonymous_9 *f, double weight)
{
  double t = 1.0 / (f->xform->perspective_dist - f->ty * f->xform->persp_vsin);
  f->p0 = f->p0 + weight * f->xform->perspective_dist * f->tx * t;
  f->p1 = f->p1 + weight * f->xform->persp_vfcos * f->ty * t;
}

// var31_noise
// file variations.c line 695
void var31_noise(struct anonymous_9 *f, double weight)
{
  double tmpr;
  double sinr;
  double cosr;
  double r;
  double return_value_flam3_random_isaac_01_1;
  return_value_flam3_random_isaac_01_1=flam3_random_isaac_01(f->rc);
  tmpr = return_value_flam3_random_isaac_01_1 * (double)2 * 3.14159265358979323846;
  sincos(tmpr, &sinr, &cosr);
  double return_value_flam3_random_isaac_01_2;
  return_value_flam3_random_isaac_01_2=flam3_random_isaac_01(f->rc);
  r = weight * return_value_flam3_random_isaac_01_2;
  f->p0 = f->p0 + f->tx * r * cosr;
  f->p1 = f->p1 + f->ty * r * sinr;
}

// var32_juliaN_generic
// file variations.c line 709
void var32_juliaN_generic(struct anonymous_9 *f, double weight)
{
  signed int t_rnd;
  double return_value_flam3_random_isaac_01_1;
  return_value_flam3_random_isaac_01_1=flam3_random_isaac_01(f->rc);
  double return_value_trunc_2;
  return_value_trunc_2=trunc(f->xform->julian_rN * return_value_flam3_random_isaac_01_1);
  t_rnd = (signed int)return_value_trunc_2;
  double tmpr = (f->precalc_atanyx + (double)2 * 3.14159265358979323846 * (double)t_rnd) / f->xform->julian_power;
  double r;
  double return_value_pow_3;
  return_value_pow_3=pow(f->precalc_sumsq, f->xform->julian_cn);
  r = weight * return_value_pow_3;
  double sina;
  double cosa;
  sincos(tmpr, &sina, &cosa);
  f->p0 = f->p0 + r * cosa;
  f->p1 = f->p1 + r * sina;
}

// var33_juliaScope_generic
// file variations.c line 724
void var33_juliaScope_generic(struct anonymous_9 *f, double weight)
{
  signed int t_rnd;
  double return_value_flam3_random_isaac_01_1;
  return_value_flam3_random_isaac_01_1=flam3_random_isaac_01(f->rc);
  double return_value_trunc_2;
  return_value_trunc_2=trunc(f->xform->juliascope_rN * return_value_flam3_random_isaac_01_1);
  t_rnd = (signed int)return_value_trunc_2;
  double tmpr;
  double r;
  double sina;
  double cosa;
  if((1 & t_rnd) == 0)
    tmpr = ((double)2 * 3.14159265358979323846 * (double)t_rnd + f->precalc_atanyx) / f->xform->juliascope_power;

  else
    tmpr = ((double)2 * 3.14159265358979323846 * (double)t_rnd - f->precalc_atanyx) / f->xform->juliascope_power;
  sincos(tmpr, &sina, &cosa);
  double return_value_pow_3;
  return_value_pow_3=pow(f->precalc_sumsq, f->xform->juliascope_cn);
  r = weight * return_value_pow_3;
  f->p0 = f->p0 + r * cosa;
  f->p1 = f->p1 + r * sina;
}

// var34_blur
// file variations.c line 745
void var34_blur(struct anonymous_9 *f, double weight)
{
  double tmpr;
  double sinr;
  double cosr;
  double r;
  double return_value_flam3_random_isaac_01_1;
  return_value_flam3_random_isaac_01_1=flam3_random_isaac_01(f->rc);
  tmpr = return_value_flam3_random_isaac_01_1 * (double)2 * 3.14159265358979323846;
  sincos(tmpr, &sinr, &cosr);
  double return_value_flam3_random_isaac_01_2;
  return_value_flam3_random_isaac_01_2=flam3_random_isaac_01(f->rc);
  r = weight * return_value_flam3_random_isaac_01_2;
  f->p0 = f->p0 + r * cosr;
  f->p1 = f->p1 + r * sinr;
}

// var35_gaussian
// file variations.c line 759
void var35_gaussian(struct anonymous_9 *f, double weight)
{
  double ang;
  double r;
  double sina;
  double cosa;
  double return_value_flam3_random_isaac_01_1;
  return_value_flam3_random_isaac_01_1=flam3_random_isaac_01(f->rc);
  ang = return_value_flam3_random_isaac_01_1 * (double)2 * 3.14159265358979323846;
  sincos(ang, &sina, &cosa);
  double return_value_flam3_random_isaac_01_2;
  return_value_flam3_random_isaac_01_2=flam3_random_isaac_01(f->rc);
  double return_value_flam3_random_isaac_01_3;
  return_value_flam3_random_isaac_01_3=flam3_random_isaac_01(f->rc);
  double return_value_flam3_random_isaac_01_4;
  return_value_flam3_random_isaac_01_4=flam3_random_isaac_01(f->rc);
  double return_value_flam3_random_isaac_01_5;
  return_value_flam3_random_isaac_01_5=flam3_random_isaac_01(f->rc);
  r = weight * ((return_value_flam3_random_isaac_01_2 + return_value_flam3_random_isaac_01_3 + return_value_flam3_random_isaac_01_4 + return_value_flam3_random_isaac_01_5) - 2.0);
  f->p0 = f->p0 + r * cosa;
  f->p1 = f->p1 + r * sina;
}

// var36_radial_blur
// file variations.c line 774
void var36_radial_blur(struct anonymous_9 *f, double weight)
{
  double rndG;
  double ra;
  double rz;
  double tmpa;
  double sa;
  double ca;
  double return_value_flam3_random_isaac_01_1;
  return_value_flam3_random_isaac_01_1=flam3_random_isaac_01(f->rc);
  double return_value_flam3_random_isaac_01_2;
  return_value_flam3_random_isaac_01_2=flam3_random_isaac_01(f->rc);
  double return_value_flam3_random_isaac_01_3;
  return_value_flam3_random_isaac_01_3=flam3_random_isaac_01(f->rc);
  double return_value_flam3_random_isaac_01_4;
  return_value_flam3_random_isaac_01_4=flam3_random_isaac_01(f->rc);
  rndG = weight * ((return_value_flam3_random_isaac_01_1 + return_value_flam3_random_isaac_01_2 + return_value_flam3_random_isaac_01_3 + return_value_flam3_random_isaac_01_4) - 2.0);
  ra = f->precalc_sqrt;
  tmpa = f->precalc_atanyx + f->xform->radialBlur_spinvar * rndG;
  sincos(tmpa, &sa, &ca);
  rz = f->xform->radialBlur_zoomvar * rndG - (double)1;
  f->p0 = f->p0 + ra * ca + rz * f->tx;
  f->p1 = f->p1 + ra * sa + rz * f->ty;
}

// var37_pie
// file variations.c line 794
void var37_pie(struct anonymous_9 *f, double weight)
{
  double a;
  double r;
  double sa;
  double ca;
  signed int sl;
  double return_value_flam3_random_isaac_01_1;
  return_value_flam3_random_isaac_01_1=flam3_random_isaac_01(f->rc);
  sl = (signed int)(return_value_flam3_random_isaac_01_1 * f->xform->pie_slices + 0.5);
  double return_value_flam3_random_isaac_01_2;
  return_value_flam3_random_isaac_01_2=flam3_random_isaac_01(f->rc);
  a = f->xform->pie_rotation + (2.0 * 3.14159265358979323846 * ((double)sl + return_value_flam3_random_isaac_01_2 * f->xform->pie_thickness)) / f->xform->pie_slices;
  double return_value_flam3_random_isaac_01_3;
  return_value_flam3_random_isaac_01_3=flam3_random_isaac_01(f->rc);
  r = weight * return_value_flam3_random_isaac_01_3;
  sincos(a, &sa, &ca);
  f->p0 = f->p0 + r * ca;
  f->p1 = f->p1 + r * sa;
}

// var38_ngon
// file variations.c line 810
void var38_ngon(struct anonymous_9 *f, double weight)
{
  double r_factor;
  double theta;
  double phi;
  double b;
  double amp;
  r_factor=pow(f->precalc_sumsq, f->xform->ngon_power / 2.0);
  theta = f->precalc_atanyx;
  b = ((double)2 * 3.14159265358979323846) / f->xform->ngon_sides;
  double return_value_floor_1;
  return_value_floor_1=floor(theta / b);
  phi = theta - b * return_value_floor_1;
  if(phi > b / 2.000000)
    phi = phi - b;

  double return_value_cos_2;
  return_value_cos_2=cos(phi);
  amp = f->xform->ngon_corners * (1.0 / (return_value_cos_2 + 1e-10) - 1.0) + f->xform->ngon_circle;
  amp = amp / (r_factor + 1e-10);
  f->p0 = f->p0 + weight * f->tx * amp;
  f->p1 = f->p1 + weight * f->ty * amp;
}

// var39_curl
// file variations.c line 831
void var39_curl(struct anonymous_9 *f, double weight)
{
  double re = 1.0 + f->xform->curl_c1 * f->tx + f->xform->curl_c2 * (f->tx * f->tx - f->ty * f->ty);
  double im = f->xform->curl_c1 * f->ty + 2.0 * f->xform->curl_c2 * f->tx * f->ty;
  double r = weight / (re * re + im * im);
  f->p0 = f->p0 + (f->tx * re + f->ty * im) * r;
  f->p1 = f->p1 + (f->ty * re - f->tx * im) * r;
}

// var3_swirl
// file variations.c line 177
void var3_swirl(struct anonymous_9 *f, double weight)
{
  double r2 = f->precalc_sumsq;
  double c1;
  double c2;
  double nx;
  double ny;
  sincos(r2, &c1, &c2);
  nx = c1 * f->tx - c2 * f->ty;
  ny = c2 * f->tx + c1 * f->ty;
  f->p0 = f->p0 + weight * nx;
  f->p1 = f->p1 + weight * ny;
}

// var40_rectangles
// file variations.c line 842
void var40_rectangles(struct anonymous_9 *f, double weight)
{
  double return_value_floor_1;
  if(IEEE_FLOAT_EQUAL(f->xform->rectangles_x, 0.000000))
    f->p0 = f->p0 + weight * f->tx;

  else
  {
    return_value_floor_1=floor(f->tx / f->xform->rectangles_x);
    f->p0 = f->p0 + weight * (((double)2 * return_value_floor_1 + (double)1) * f->xform->rectangles_x - f->tx);
  }
  double return_value_floor_2;
  if(IEEE_FLOAT_EQUAL(f->xform->rectangles_y, 0.000000))
    f->p1 = f->p1 + weight * f->ty;

  else
  {
    return_value_floor_2=floor(f->ty / f->xform->rectangles_y);
    f->p1 = f->p1 + weight * (((double)2 * return_value_floor_2 + (double)1) * f->xform->rectangles_y - f->ty);
  }
}

// var41_arch
// file variations.c line 856
void var41_arch(struct anonymous_9 *f, double weight)
{
  double ang;
  double return_value_flam3_random_isaac_01_1;
  return_value_flam3_random_isaac_01_1=flam3_random_isaac_01(f->rc);
  ang = return_value_flam3_random_isaac_01_1 * weight * 3.14159265358979323846;
  double sinr;
  double cosr;
  sincos(ang, &sinr, &cosr);
  f->p0 = f->p0 + weight * sinr;
  f->p1 = f->p1 + (weight * sinr * sinr) / cosr;
}

// var42_tangent
// file variations.c line 884
void var42_tangent(struct anonymous_9 *f, double weight)
{
  double return_value_sin_1;
  return_value_sin_1=sin(f->tx);
  double return_value_cos_2;
  return_value_cos_2=cos(f->ty);
  f->p0 = f->p0 + (weight * return_value_sin_1) / return_value_cos_2;
  double return_value_tan_3;
  return_value_tan_3=tan(f->ty);
  f->p1 = f->p1 + weight * return_value_tan_3;
}

// var43_square
// file variations.c line 899
void var43_square(struct anonymous_9 *f, double weight)
{
  double return_value_flam3_random_isaac_01_1;
  return_value_flam3_random_isaac_01_1=flam3_random_isaac_01(f->rc);
  f->p0 = f->p0 + weight * (return_value_flam3_random_isaac_01_1 - 0.5);
  double return_value_flam3_random_isaac_01_2;
  return_value_flam3_random_isaac_01_2=flam3_random_isaac_01(f->rc);
  f->p1 = f->p1 + weight * (return_value_flam3_random_isaac_01_2 - 0.5);
}

// var44_rays
// file variations.c line 914
void var44_rays(struct anonymous_9 *f, double weight)
{
  double ang;
  double return_value_flam3_random_isaac_01_1;
  return_value_flam3_random_isaac_01_1=flam3_random_isaac_01(f->rc);
  ang = weight * return_value_flam3_random_isaac_01_1 * 3.14159265358979323846;
  double r = weight / (f->precalc_sumsq + 1e-10);
  double tanr;
  double return_value_tan_2;
  return_value_tan_2=tan(ang);
  tanr = weight * return_value_tan_2 * r;
  double return_value_cos_3;
  return_value_cos_3=cos(f->tx);
  f->p0 = f->p0 + tanr * return_value_cos_3;
  double return_value_sin_4;
  return_value_sin_4=sin(f->ty);
  f->p1 = f->p1 + tanr * return_value_sin_4;
}

// var45_blade
// file variations.c line 945
void var45_blade(struct anonymous_9 *f, double weight)
{
  double r;
  double return_value_flam3_random_isaac_01_1;
  return_value_flam3_random_isaac_01_1=flam3_random_isaac_01(f->rc);
  r = return_value_flam3_random_isaac_01_1 * weight * f->precalc_sqrt;
  double sinr;
  double cosr;
  sincos(r, &sinr, &cosr);
  f->p0 = f->p0 + weight * f->tx * (cosr + sinr);
  f->p1 = f->p1 + weight * f->tx * (cosr - sinr);
}

// var46_secant2
// file variations.c line 975
void var46_secant2(struct anonymous_9 *f, double weight)
{
  double r = weight * f->precalc_sqrt;
  double cr;
  cr=cos(r);
  double icr = 1.0 / cr;
  f->p0 = f->p0 + weight * f->tx;
  if(cr < 0.000000)
    f->p1 = f->p1 + weight * (icr + (double)1);

  else
    f->p1 = f->p1 + weight * (icr - (double)1);
}

// var47_twintrian
// file variations.c line 997
void var47_twintrian(struct anonymous_9 *f, double weight)
{
  double r;
  double return_value_flam3_random_isaac_01_1;
  return_value_flam3_random_isaac_01_1=flam3_random_isaac_01(f->rc);
  r = return_value_flam3_random_isaac_01_1 * weight * f->precalc_sqrt;
  double sinr;
  double cosr;
  double diff;
  sincos(r, &sinr, &cosr);
  double return_value_log10_2;
  return_value_log10_2=log10(sinr * sinr);
  diff = return_value_log10_2 + cosr;
  if(diff < -1.000000e+10 || diff > 1e10 || isnan(diff))
    diff = -30.0;

  f->p0 = f->p0 + weight * f->tx * diff;
  f->p1 = f->p1 + weight * f->tx * (diff - sinr * 3.14159265358979323846);
}

// var48_cross
// file variations.c line 1032
void var48_cross(struct anonymous_9 *f, double weight)
{
  double s = f->tx * f->tx - f->ty * f->ty;
  double r;
  double return_value_sqrt_1;
  return_value_sqrt_1=sqrt(1.0 / (s * s + 1e-10));
  r = weight * return_value_sqrt_1;
  f->p0 = f->p0 + f->tx * r;
  f->p1 = f->p1 + f->ty * r;
}

// var49_disc2
// file variations.c line 1053
void var49_disc2(struct anonymous_9 *f, double weight)
{
  double r;
  double t;
  double sinr;
  double cosr;
  t = f->xform->disc2_timespi * (f->tx + f->ty);
  sincos(t, &sinr, &cosr);
  r = (weight * f->precalc_atan) / 3.14159265358979323846;
  f->p0 = f->p0 + (sinr + f->xform->disc2_cosadd) * r;
  f->p1 = f->p1 + (cosr + f->xform->disc2_sinadd) * r;
}

// var4_horseshoe
// file variations.c line 201
void var4_horseshoe(struct anonymous_9 *f, double weight)
{
  double r = weight / (f->precalc_sqrt + 1e-10);
  f->p0 = f->p0 + (f->tx - f->ty) * (f->tx + f->ty) * r;
  f->p1 = f->p1 + 2.0 * f->tx * f->ty * r;
}

// var50_supershape
// file variations.c line 1091
void var50_supershape(struct anonymous_9 *f, double weight)
{
  double theta;
  double t1;
  double t2;
  double r;
  double st;
  double ct;
  double myrnd;
  theta = f->xform->super_shape_pm_4 * f->precalc_atanyx + 0.78539816339744830962;
  sincos(theta, &st, &ct);
  t1=fabs(ct);
  t1=pow(t1, f->xform->super_shape_n2);
  t2=fabs(st);
  t2=pow(t2, f->xform->super_shape_n3);
  myrnd = f->xform->super_shape_rnd;
  double return_value_flam3_random_isaac_01_1;
  return_value_flam3_random_isaac_01_1=flam3_random_isaac_01(f->rc);
  double return_value_pow_2;
  return_value_pow_2=pow(t1 + t2, f->xform->super_shape_pneg1_n1);
  r = (weight * ((myrnd * return_value_flam3_random_isaac_01_1 + (1.0 - myrnd) * f->precalc_sqrt) - f->xform->super_shape_holes) * return_value_pow_2) / f->precalc_sqrt;
  f->p0 = f->p0 + r * f->tx;
  f->p1 = f->p1 + r * f->ty;
}

// var51_flower
// file variations.c line 1117
void var51_flower(struct anonymous_9 *f, double weight)
{
  double theta = f->precalc_atanyx;
  double r;
  double return_value_flam3_random_isaac_01_1;
  return_value_flam3_random_isaac_01_1=flam3_random_isaac_01(f->rc);
  double return_value_cos_2;
  return_value_cos_2=cos(f->xform->flower_petals * theta);
  r = (weight * (return_value_flam3_random_isaac_01_1 - f->xform->flower_holes) * return_value_cos_2) / f->precalc_sqrt;
  f->p0 = f->p0 + r * f->tx;
  f->p1 = f->p1 + r * f->ty;
}

// var52_conic
// file variations.c line 1132
void var52_conic(struct anonymous_9 *f, double weight)
{
  double ct = f->tx / f->precalc_sqrt;
  double r;
  double return_value_flam3_random_isaac_01_1;
  return_value_flam3_random_isaac_01_1=flam3_random_isaac_01(f->rc);
  r = ((weight * (return_value_flam3_random_isaac_01_1 - f->xform->conic_holes) * f->xform->conic_eccentricity) / ((double)1 + f->xform->conic_eccentricity * ct)) / f->precalc_sqrt;
  f->p0 = f->p0 + r * f->tx;
  f->p1 = f->p1 + r * f->ty;
}

// var53_parabola
// file variations.c line 1147
void var53_parabola(struct anonymous_9 *f, double weight)
{
  double r = f->precalc_sqrt;
  double sr;
  double cr;
  sincos(r, &sr, &cr);
  double return_value_flam3_random_isaac_01_1;
  return_value_flam3_random_isaac_01_1=flam3_random_isaac_01(f->rc);
  f->p0 = f->p0 + f->xform->parabola_height * weight * sr * sr * return_value_flam3_random_isaac_01_1;
  double return_value_flam3_random_isaac_01_2;
  return_value_flam3_random_isaac_01_2=flam3_random_isaac_01(f->rc);
  f->p1 = f->p1 + f->xform->parabola_width * weight * cr * return_value_flam3_random_isaac_01_2;
}

// var54_bent2
// file variations.c line 1163
void var54_bent2(struct anonymous_9 *f, double weight)
{
  double nx = f->tx;
  double ny = f->ty;
  if(nx < 0.0)
    nx = nx * f->xform->bent2_x;

  if(ny < 0.0)
    ny = ny * f->xform->bent2_y;

  f->p0 = f->p0 + weight * nx;
  f->p1 = f->p1 + weight * ny;
}

// var55_bipolar
// file variations.c line 1179
void var55_bipolar(struct anonymous_9 *f, double weight)
{
  double x2y2 = f->precalc_sumsq;
  double t = x2y2 + (double)1;
  double x2 = (double)2 * f->tx;
  double ps = -1.57079632679489661923 * f->xform->bipolar_shift;
  double y;
  double return_value_atan2_1;
  return_value_atan2_1=atan2(2.0 * f->ty, x2y2 - 1.0);
  y = 0.5 * return_value_atan2_1 + ps;
  double return_value_fmod_2;
  double return_value_fmod_3;
  if(y > 1.57079632679489661923)
  {
    return_value_fmod_2=fmod(y + 1.57079632679489661923, 3.14159265358979323846);
    y = -1.57079632679489661923 + return_value_fmod_2;
  }

  else
    if(y < -1.570796e+0)
    {
      return_value_fmod_3=fmod(1.57079632679489661923 - y, 3.14159265358979323846);
      y = 1.57079632679489661923 - return_value_fmod_3;
    }

  double return_value_log_4;
  return_value_log_4=log((t + x2) / (t - x2));
  f->p0 = f->p0 + weight * 0.25 * 0.63661977236758134308 * return_value_log_4;
  f->p1 = f->p1 + weight * 0.63661977236758134308 * y;
}

// var56_boarders
// file variations.c line 1198
void var56_boarders(struct anonymous_9 *f, double weight)
{
  double roundX;
  double roundY;
  double offsetX;
  double offsetY;
  roundX=rint(f->tx);
  roundY=rint(f->ty);
  offsetX = f->tx - roundX;
  offsetY = f->ty - roundY;
  double return_value_flam3_random_isaac_01_3;
  return_value_flam3_random_isaac_01_3=flam3_random_isaac_01(f->rc);
  if(return_value_flam3_random_isaac_01_3 >= 0.75)
  {
    f->p0 = f->p0 + weight * (offsetX * 0.5 + roundX);
    f->p1 = f->p1 + weight * (offsetY * 0.5 + roundY);
  }

  else
  {
    double return_value_fabs_1;
    return_value_fabs_1=fabs(offsetX);
    double return_value_fabs_2;
    return_value_fabs_2=fabs(offsetY);
    if(return_value_fabs_1 >= return_value_fabs_2)
    {
      if(offsetX >= 0.0)
      {
        f->p0 = f->p0 + weight * (offsetX * 0.5 + roundX + 0.25);
        f->p1 = f->p1 + weight * (offsetY * 0.5 + roundY + (0.25 * offsetY) / offsetX);
      }

      else
      {
        f->p0 = f->p0 + weight * ((offsetX * 0.5 + roundX) - 0.25);
        f->p1 = f->p1 + weight * ((offsetY * 0.5 + roundY) - (0.25 * offsetY) / offsetX);
      }
    }

    else
      if(offsetY >= 0.0)
      {
        f->p1 = f->p1 + weight * (offsetY * 0.5 + roundY + 0.25);
        f->p0 = f->p0 + weight * (offsetX * 0.5 + roundX + (offsetX / offsetY) * 0.25);
      }

      else
      {
        f->p1 = f->p1 + weight * ((offsetY * 0.5 + roundY) - 0.25);
        f->p0 = f->p0 + weight * ((offsetX * 0.5 + roundX) - (offsetX / offsetY) * 0.25);
      }
  }
}

// var57_butterfly
// file variations.c line 1237
void var57_butterfly(struct anonymous_9 *f, double weight)
{
  double wx = weight * 1.3029400317411197908970256609023;
  double y2 = f->ty * 2.0;
  double r;
  double return_value_fabs_1;
  return_value_fabs_1=fabs(f->ty * f->tx);
  double return_value_sqrt_2;
  return_value_sqrt_2=sqrt(return_value_fabs_1 / (1e-10 + f->tx * f->tx + y2 * y2));
  r = wx * return_value_sqrt_2;
  f->p0 = f->p0 + r * f->tx;
  f->p1 = f->p1 + r * y2;
}

// var58_cell
// file variations.c line 1252
void var58_cell(struct anonymous_9 *f, double weight)
{
  double inv_cell_size = 1.0 / f->xform->cell_size;
  signed int x;
  double return_value_floor_1;
  return_value_floor_1=floor(f->tx * inv_cell_size);
  x = (signed int)return_value_floor_1;
  signed int y;
  double return_value_floor_2;
  return_value_floor_2=floor(f->ty * inv_cell_size);
  y = (signed int)return_value_floor_2;
  double dx = f->tx - (double)x * f->xform->cell_size;
  double dy = f->ty - (double)y * f->xform->cell_size;
  if(y >= 0)
  {
    if(x >= 0)
    {
      y = y * 2;
      x = x * 2;
    }

    else
    {
      y = y * 2;
      x = -(2 * x + 1);
    }
  }

  else
    if(x >= 0)
    {
      y = -(2 * y + 1);
      x = x * 2;
    }

    else
    {
      y = -(2 * y + 1);
      x = -(2 * x + 1);
    }
  f->p0 = f->p0 + weight * (dx + (double)x * f->xform->cell_size);
  f->p1 = f->p1 - weight * (dy + (double)y * f->xform->cell_size);
}

// var59_cpow
// file variations.c line 1290
void var59_cpow(struct anonymous_9 *f, double weight)
{
  double a = f->precalc_atanyx;
  double lnr;
  double return_value_log_1;
  return_value_log_1=log(f->precalc_sumsq);
  lnr = 0.5 * return_value_log_1;
  double va = (2.0 * 3.14159265358979323846) / f->xform->cpow_power;
  double vc = f->xform->cpow_r / f->xform->cpow_power;
  double vd = f->xform->cpow_i / f->xform->cpow_power;
  double ang;
  double return_value_flam3_random_isaac_01_2;
  return_value_flam3_random_isaac_01_2=flam3_random_isaac_01(f->rc);
  double return_value_floor_3;
  return_value_floor_3=floor(f->xform->cpow_power * return_value_flam3_random_isaac_01_2);
  ang = vc * a + vd * lnr + va * return_value_floor_3;
  double sa;
  double ca;
  double m;
  double return_value_exp_4;
  return_value_exp_4=exp(vc * lnr - vd * a);
  m = weight * return_value_exp_4;
  sincos(ang, &sa, &ca);
  f->p0 = f->p0 + m * ca;
  f->p1 = f->p1 + m * sa;
}

// var5_polar
// file variations.c line 217
void var5_polar(struct anonymous_9 *f, double weight)
{
  double nx = f->precalc_atan * 0.31830988618379067154;
  double ny = f->precalc_sqrt - 1.0;
  f->p0 = f->p0 + weight * nx;
  f->p1 = f->p1 + weight * ny;
}

// var60_curve
// file variations.c line 1311
void var60_curve(struct anonymous_9 *f, double weight)
{
  double pc_xlen = f->xform->curve_xlength * f->xform->curve_xlength;
  double pc_ylen = f->xform->curve_ylength * f->xform->curve_ylength;
  if(pc_xlen < 1E-20)
    pc_xlen = 1E-20;

  if(pc_ylen < 1E-20)
    pc_ylen = 1E-20;

  double return_value_exp_1;
  return_value_exp_1=exp((-f->ty * f->ty) / pc_xlen);
  f->p0 = f->p0 + weight * (f->tx + f->xform->curve_xamp * return_value_exp_1);
  double return_value_exp_2;
  return_value_exp_2=exp((-f->tx * f->tx) / pc_ylen);
  f->p1 = f->p1 + weight * (f->ty + f->xform->curve_yamp * return_value_exp_2);
}

// var61_edisc
// file variations.c line 1327
void var61_edisc(struct anonymous_9 *f, double weight)
{
  double tmp = f->precalc_sumsq + 1.0;
  double tmp2 = 2.0 * f->tx;
  double r1;
  r1=sqrt(tmp + tmp2);
  double r2;
  r2=sqrt(tmp - tmp2);
  double xmax = (r1 + r2) * 0.5;
  double a1;
  double return_value_sqrt_1;
  return_value_sqrt_1=sqrt(xmax - 1.0);
  a1=log(xmax + return_value_sqrt_1);
  double a2;
  double return_value_acos_2;
  return_value_acos_2=acos(f->tx / xmax);
  a2 = -return_value_acos_2;
  double w = weight / 11.57034632;
  double snv;
  double csv;
  double snhu;
  double cshu;
  sincos(a1, &snv, &csv);
  snhu=sinh(a2);
  cshu=cosh(a2);
  if(f->ty > 0.0)
    snv = -snv;

  f->p0 = f->p0 + w * cshu * csv;
  f->p1 = f->p1 + w * snhu * snv;
}

// var62_elliptic
// file variations.c line 1353
void var62_elliptic(struct anonymous_9 *f, double weight)
{
  double tmp = f->precalc_sumsq + 1.0;
  double x2 = 2.0 * f->tx;
  double xmax;
  double return_value_sqrt_1;
  return_value_sqrt_1=sqrt(tmp + x2);
  double return_value_sqrt_2;
  return_value_sqrt_2=sqrt(tmp - x2);
  xmax = 0.5 * (return_value_sqrt_1 + return_value_sqrt_2);
  double a = f->tx / xmax;
  double b = 1.0 - a * a;
  double ssx = xmax - 1.0;
  double w = weight / 1.57079632679489661923;
  if(b < 0.000000)
    b = (double)0;

  else
    b=sqrt(b);
  if(ssx < 0.000000)
    ssx = (double)0;

  else
    ssx=sqrt(ssx);
  double return_value_atan2_3;
  return_value_atan2_3=atan2(a, b);
  f->p0 = f->p0 + w * return_value_atan2_3;
  double return_value_log_4;
  double return_value_log_5;
  if(f->ty > 0.000000)
  {
    return_value_log_4=log(xmax + ssx);
    f->p1 = f->p1 + w * return_value_log_4;
  }

  else
  {
    return_value_log_5=log(xmax + ssx);
    f->p1 = f->p1 - w * return_value_log_5;
  }
}

// var63_escher
// file variations.c line 1384
void var63_escher(struct anonymous_9 *f, double weight)
{
  double seb;
  double ceb;
  double vc;
  double vd;
  double m;
  double n;
  double sn;
  double cn;
  double a = f->precalc_atanyx;
  double lnr;
  double return_value_log_1;
  return_value_log_1=log(f->precalc_sumsq);
  lnr = 0.5 * return_value_log_1;
  sincos(f->xform->escher_beta, &seb, &ceb);
  vc = 0.5 * (1.0 + ceb);
  vd = 0.5 * seb;
  double return_value_exp_2;
  return_value_exp_2=exp(vc * lnr - vd * a);
  m = weight * return_value_exp_2;
  n = vc * a + vd * lnr;
  sincos(n, &sn, &cn);
  f->p0 = f->p0 + m * cn;
  f->p1 = f->p1 + m * sn;
}

// var64_foci
// file variations.c line 1411
void var64_foci(struct anonymous_9 *f, double weight)
{
  double expx;
  double return_value_exp_1;
  return_value_exp_1=exp(f->tx);
  expx = return_value_exp_1 * 0.5;
  double expnx = 0.25 / expx;
  double sn;
  double cn;
  double tmp;
  sincos(f->ty, &sn, &cn);
  tmp = weight / ((expx + expnx) - cn);
  f->p0 = f->p0 + tmp * (expx - expnx);
  f->p1 = f->p1 + tmp * sn;
}

// var65_lazysusan
// file variations.c line 1427
void var65_lazysusan(struct anonymous_9 *f, double weight)
{
  double x = f->tx - f->xform->lazysusan_x;
  double y = f->ty + f->xform->lazysusan_y;
  double r;
  r=sqrt(x * x + y * y);
  double sina;
  double cosa;
  if(r < weight)
  {
    double a;
    double return_value_atan2_1;
    return_value_atan2_1=atan2(y, x);
    a = return_value_atan2_1 + f->xform->lazysusan_spin + f->xform->lazysusan_twist * (weight - r);
    sincos(a, &sina, &cosa);
    r = weight * r;
    f->p0 = f->p0 + r * cosa + f->xform->lazysusan_x;
    f->p1 = f->p1 + (r * sina - f->xform->lazysusan_y);
  }

  else
  {
    r = weight * (1.0 + f->xform->lazysusan_space / r);
    f->p0 = f->p0 + r * x + f->xform->lazysusan_x;
    f->p1 = f->p1 + (r * y - f->xform->lazysusan_y);
  }
}

// var66_loonie
// file variations.c line 1455
void var66_loonie(struct anonymous_9 *f, double weight)
{
  double r2 = f->precalc_sumsq;
  double w2 = weight * weight;
  if(r2 < w2)
  {
    double r;
    double return_value_sqrt_1;
    return_value_sqrt_1=sqrt(w2 / r2 - 1.0);
    r = weight * return_value_sqrt_1;
    f->p0 = f->p0 + r * f->tx;
    f->p1 = f->p1 + r * f->ty;
  }

  else
  {
    f->p0 = f->p0 + weight * f->tx;
    f->p1 = f->p1 + weight * f->ty;
  }
}

// var67_pre_blur
// file variations.c line 1479
void var67_pre_blur(struct anonymous_9 *f, double weight)
{
  double rndG;
  double return_value_flam3_random_isaac_01_1;
  return_value_flam3_random_isaac_01_1=flam3_random_isaac_01(f->rc);
  double return_value_flam3_random_isaac_01_2;
  return_value_flam3_random_isaac_01_2=flam3_random_isaac_01(f->rc);
  double return_value_flam3_random_isaac_01_3;
  return_value_flam3_random_isaac_01_3=flam3_random_isaac_01(f->rc);
  double return_value_flam3_random_isaac_01_4;
  return_value_flam3_random_isaac_01_4=flam3_random_isaac_01(f->rc);
  rndG = weight * ((return_value_flam3_random_isaac_01_1 + return_value_flam3_random_isaac_01_2 + return_value_flam3_random_isaac_01_3 + return_value_flam3_random_isaac_01_4) - 2.0);
  double rndA;
  double return_value_flam3_random_isaac_01_5;
  return_value_flam3_random_isaac_01_5=flam3_random_isaac_01(f->rc);
  rndA = return_value_flam3_random_isaac_01_5 * 2.0 * 3.14159265358979323846;
  double sinA;
  double cosA;
  sincos(rndA, &sinA, &cosA);
  f->tx = f->tx + rndG * cosA;
  f->ty = f->ty + rndG * sinA;
}

// var68_modulus
// file variations.c line 1497
void var68_modulus(struct anonymous_9 *f, double weight)
{
  double xr = (double)2 * f->xform->modulus_x;
  double yr = (double)2 * f->xform->modulus_y;
  double return_value_fmod_1;
  double return_value_fmod_2;
  if(f->tx > f->xform->modulus_x)
  {
    return_value_fmod_1=fmod(f->tx + f->xform->modulus_x, xr);
    f->p0 = f->p0 + weight * (-f->xform->modulus_x + return_value_fmod_1);
  }

  else
    if(f->tx < -f->xform->modulus_x)
    {
      return_value_fmod_2=fmod(f->xform->modulus_x - f->tx, xr);
      f->p0 = f->p0 + weight * (f->xform->modulus_x - return_value_fmod_2);
    }

    else
      f->p0 = f->p0 + weight * f->tx;
  double return_value_fmod_3;
  double return_value_fmod_4;
  if(f->ty > f->xform->modulus_y)
  {
    return_value_fmod_3=fmod(f->ty + f->xform->modulus_y, yr);
    f->p1 = f->p1 + weight * (-f->xform->modulus_y + return_value_fmod_3);
  }

  else
    if(f->ty < -f->xform->modulus_y)
    {
      return_value_fmod_4=fmod(f->xform->modulus_y - f->ty, yr);
      f->p1 = f->p1 + weight * (f->xform->modulus_y - return_value_fmod_4);
    }

    else
      f->p1 = f->p1 + weight * f->ty;
}

// var69_oscope
// file variations.c line 1520
void var69_oscope(struct anonymous_9 *f, double weight)
{
  double tpf = (double)2 * 3.14159265358979323846 * f->xform->oscope_frequency;
  double t;
  double return_value_cos_1;
  if(IEEE_FLOAT_EQUAL(f->xform->oscope_damping, 0.0))
  {
    return_value_cos_1=cos(tpf * f->tx);
    t = f->xform->oscope_amplitude * return_value_cos_1 + f->xform->oscope_separation;
  }

  else
  {
    double return_value_fabs_2;
    return_value_fabs_2=fabs(f->tx);
    double return_value_exp_3;
    return_value_exp_3=exp(-return_value_fabs_2 * f->xform->oscope_damping);
    double return_value_cos_4;
    return_value_cos_4=cos(tpf * f->tx);
    t = f->xform->oscope_amplitude * return_value_exp_3 * return_value_cos_4 + f->xform->oscope_separation;
  }
  double return_value_fabs_5;
  return_value_fabs_5=fabs(f->ty);
  if(return_value_fabs_5 <= t)
  {
    f->p0 = f->p0 + weight * f->tx;
    f->p1 = f->p1 - weight * f->ty;
  }

  else
  {
    f->p0 = f->p0 + weight * f->tx;
    f->p1 = f->p1 + weight * f->ty;
  }
}

// var6_handkerchief
// file variations.c line 231
void var6_handkerchief(struct anonymous_9 *f, double weight)
{
  double a = f->precalc_atan;
  double r = f->precalc_sqrt;
  double return_value_sin_1;
  return_value_sin_1=sin(a + r);
  f->p0 = f->p0 + weight * r * return_value_sin_1;
  double return_value_cos_2;
  return_value_cos_2=cos(a - r);
  f->p1 = f->p1 + weight * r * return_value_cos_2;
}

// var70_polar2
// file variations.c line 1543
void var70_polar2(struct anonymous_9 *f, double weight)
{
  double p2v = weight / 3.14159265358979323846;
  f->p0 = f->p0 + p2v * f->precalc_atan;
  double return_value_log_1;
  return_value_log_1=log(f->precalc_sumsq);
  f->p1 = f->p1 + (p2v / 2.0) * return_value_log_1;
}

// var71_popcorn2
// file variations.c line 1553
void var71_popcorn2(struct anonymous_9 *f, double weight)
{
  double return_value_tan_1;
  return_value_tan_1=tan(f->ty * f->xform->popcorn2_c);
  double return_value_sin_2;
  return_value_sin_2=sin(return_value_tan_1);
  f->p0 = f->p0 + weight * (f->tx + f->xform->popcorn2_x * return_value_sin_2);
  double return_value_tan_3;
  return_value_tan_3=tan(f->tx * f->xform->popcorn2_c);
  double return_value_sin_4;
  return_value_sin_4=sin(return_value_tan_3);
  f->p1 = f->p1 + weight * (f->ty + f->xform->popcorn2_y * return_value_sin_4);
}

// var72_scry
// file variations.c line 1562
void var72_scry(struct anonymous_9 *f, double weight)
{
  double t = f->precalc_sumsq;
  double r = 1.0 / (f->precalc_sqrt * (t + 1.0 / (weight + 1e-10)));
  f->p0 = f->p0 + f->tx * r;
  f->p1 = f->p1 + f->ty * r;
}

// var73_separation
// file variations.c line 1583
void var73_separation(struct anonymous_9 *f, double weight)
{
  double sx2 = f->xform->separation_x * f->xform->separation_x;
  double sy2 = f->xform->separation_y * f->xform->separation_y;
  double return_value_sqrt_1;
  double return_value_sqrt_2;
  if(f->tx > 0.0)
  {
    return_value_sqrt_1=sqrt(f->tx * f->tx + sx2);
    f->p0 = f->p0 + weight * (return_value_sqrt_1 - f->tx * f->xform->separation_xinside);
  }

  else
  {
    return_value_sqrt_2=sqrt(f->tx * f->tx + sx2);
    f->p0 = f->p0 - weight * (return_value_sqrt_2 + f->tx * f->xform->separation_xinside);
  }
  double return_value_sqrt_3;
  double return_value_sqrt_4;
  if(f->ty > 0.0)
  {
    return_value_sqrt_3=sqrt(f->ty * f->ty + sy2);
    f->p1 = f->p1 + weight * (return_value_sqrt_3 - f->ty * f->xform->separation_yinside);
  }

  else
  {
    return_value_sqrt_4=sqrt(f->ty * f->ty + sy2);
    f->p1 = f->p1 - weight * (return_value_sqrt_4 + f->ty * f->xform->separation_yinside);
  }
}

// var74_split
// file variations.c line 1602
void var74_split(struct anonymous_9 *f, double weight)
{
  double return_value_cos_1;
  return_value_cos_1=cos(f->tx * f->xform->split_xsize * 3.14159265358979323846);
  if(return_value_cos_1 >= 0.000000)
    f->p1 = f->p1 + weight * f->ty;

  else
    f->p1 = f->p1 - weight * f->ty;
  double return_value_cos_2;
  return_value_cos_2=cos(f->ty * f->xform->split_ysize * 3.14159265358979323846);
  if(return_value_cos_2 >= 0.000000)
    f->p0 = f->p0 + weight * f->tx;

  else
    f->p0 = f->p0 - weight * f->tx;
}

// var75_splits
// file variations.c line 1618
void var75_splits(struct anonymous_9 *f, double weight)
{
  if(f->tx >= 0.000000)
    f->p0 = f->p0 + weight * (f->tx + f->xform->splits_x);

  else
    f->p0 = f->p0 + weight * (f->tx - f->xform->splits_x);
  if(f->ty >= 0.000000)
    f->p1 = f->p1 + weight * (f->ty + f->xform->splits_y);

  else
    f->p1 = f->p1 + weight * (f->ty - f->xform->splits_y);
}

// var76_stripes
// file variations.c line 1634
void var76_stripes(struct anonymous_9 *f, double weight)
{
  double roundx;
  double offsetx;
  roundx=floor(f->tx + 0.5);
  offsetx = f->tx - roundx;
  f->p0 = f->p0 + weight * (offsetx * (1.0 - f->xform->stripes_space) + roundx);
  f->p1 = f->p1 + weight * (f->ty + offsetx * offsetx * f->xform->stripes_warp);
}

// var77_wedge
// file variations.c line 1648
void var77_wedge(struct anonymous_9 *f, double weight)
{
  double r = f->precalc_sqrt;
  double a = f->precalc_atanyx + f->xform->wedge_swirl * r;
  double c;
  c=floor((f->xform->wedge_count * a + 3.14159265358979323846) * 0.31830988618379067154 * 0.5);
  double comp_fac = (double)1 - f->xform->wedge_angle * f->xform->wedge_count * 0.31830988618379067154 * 0.5;
  double sa;
  double ca;
  a = a * comp_fac + c * f->xform->wedge_angle;
  sincos(a, &sa, &ca);
  r = weight * (r + f->xform->wedge_hole);
  f->p0 = f->p0 + r * ca;
  f->p1 = f->p1 + r * sa;
}

// var78_wedge_julia
// file variations.c line 1670
void var78_wedge_julia(struct anonymous_9 *f, double weight)
{
  double r;
  double return_value_pow_1;
  return_value_pow_1=pow(f->precalc_sumsq, f->xform->wedgeJulia_cn);
  r = weight * return_value_pow_1;
  signed int t_rnd;
  double return_value_flam3_random_isaac_01_2;
  return_value_flam3_random_isaac_01_2=flam3_random_isaac_01(f->rc);
  t_rnd = (signed int)(f->xform->wedgeJulia_rN * return_value_flam3_random_isaac_01_2);
  double a = (f->precalc_atanyx + (double)2 * 3.14159265358979323846 * (double)t_rnd) / f->xform->wedge_julia_power;
  double c;
  c=floor((f->xform->wedge_julia_count * a + 3.14159265358979323846) * 0.31830988618379067154 * 0.5);
  double sa;
  double ca;
  a = a * f->xform->wedgeJulia_cf + c * f->xform->wedge_julia_angle;
  sincos(a, &sa, &ca);
  f->p0 = f->p0 + r * ca;
  f->p1 = f->p1 + r * sa;
}

// var79_wedge_sph
// file variations.c line 1688
void var79_wedge_sph(struct anonymous_9 *f, double weight)
{
  double r = 1.0 / (f->precalc_sqrt + 1e-10);
  double a = f->precalc_atanyx + f->xform->wedge_sph_swirl * r;
  double c;
  c=floor((f->xform->wedge_sph_count * a + 3.14159265358979323846) * 0.31830988618379067154 * 0.5);
  double comp_fac = (double)1 - f->xform->wedge_sph_angle * f->xform->wedge_sph_count * 0.31830988618379067154 * 0.5;
  double sa;
  double ca;
  a = a * comp_fac + c * f->xform->wedge_sph_angle;
  sincos(a, &sa, &ca);
  r = weight * (r + f->xform->wedge_sph_hole);
  f->p0 = f->p0 + r * ca;
  f->p1 = f->p1 + r * sa;
}

// var7_heart
// file variations.c line 245
void var7_heart(struct anonymous_9 *f, double weight)
{
  double a = f->precalc_sqrt * f->precalc_atan;
  double ca;
  double sa;
  double r = weight * f->precalc_sqrt;
  sincos(a, &sa, &ca);
  f->p0 = f->p0 + r * sa;
  f->p1 = f->p1 + -r * ca;
}

// var80_whorl
// file variations.c line 1709
void var80_whorl(struct anonymous_9 *f, double weight)
{
  double r = f->precalc_sqrt;
  double a;
  double sa;
  double ca;
  if(r < weight)
    a = f->precalc_atanyx + f->xform->whorl_inside / (weight - r);

  else
    a = f->precalc_atanyx + f->xform->whorl_outside / (weight - r);
  sincos(a, &sa, &ca);
  f->p0 = f->p0 + weight * r * ca;
  f->p1 = f->p1 + weight * r * sa;
}

// var81_waves2
// file variations.c line 1734
void var81_waves2(struct anonymous_9 *f, double weight)
{
  double return_value_sin_1;
  return_value_sin_1=sin(f->ty * f->xform->waves2_freqx);
  f->p0 = f->p0 + weight * (f->tx + f->xform->waves2_scalex * return_value_sin_1);
  double return_value_sin_2;
  return_value_sin_2=sin(f->tx * f->xform->waves2_freqy);
  f->p1 = f->p1 + weight * (f->ty + f->xform->waves2_scaley * return_value_sin_2);
}

// var82_exp
// file variations.c line 1746
void var82_exp(struct anonymous_9 *f, double weight)
{
  double expe;
  expe=exp(f->tx);
  double expcos;
  double expsin;
  sincos(f->ty, &expsin, &expcos);
  f->p0 = f->p0 + weight * expe * expcos;
  f->p1 = f->p1 + weight * expe * expsin;
}

// var83_log
// file variations.c line 1755
void var83_log(struct anonymous_9 *f, double weight)
{
  double return_value_log_1;
  return_value_log_1=log(f->precalc_sumsq);
  f->p0 = f->p0 + weight * 0.5 * return_value_log_1;
  f->p1 = f->p1 + weight * f->precalc_atanyx;
}

// var84_sin
// file variations.c line 1762
void var84_sin(struct anonymous_9 *f, double weight)
{
  double sinsin;
  double sinacos;
  double sinsinh;
  double sincosh;
  sincos(f->tx, &sinsin, &sinacos);
  sinsinh=sinh(f->ty);
  sincosh=cosh(f->ty);
  f->p0 = f->p0 + weight * sinsin * sincosh;
  f->p1 = f->p1 + weight * sinacos * sinsinh;
}

// var85_cos
// file variations.c line 1772
void var85_cos(struct anonymous_9 *f, double weight)
{
  double cossin;
  double coscos;
  double cossinh;
  double coscosh;
  sincos(f->tx, &cossin, &coscos);
  cossinh=sinh(f->ty);
  coscosh=cosh(f->ty);
  f->p0 = f->p0 + weight * coscos * coscosh;
  f->p1 = f->p1 - weight * cossin * cossinh;
}

// var86_tan
// file variations.c line 1782
void var86_tan(struct anonymous_9 *f, double weight)
{
  double tansin;
  double tancos;
  double tansinh;
  double tancosh;
  double tanden;
  sincos((double)2 * f->tx, &tansin, &tancos);
  tansinh=sinh(2.0 * f->ty);
  tancosh=cosh(2.0 * f->ty);
  tanden = 1.0 / (tancos + tancosh);
  f->p0 = f->p0 + weight * tanden * tansin;
  f->p1 = f->p1 + weight * tanden * tansinh;
}

// var87_sec
// file variations.c line 1794
void var87_sec(struct anonymous_9 *f, double weight)
{
  double secsin;
  double seccos;
  double secsinh;
  double seccosh;
  double secden;
  sincos(f->tx, &secsin, &seccos);
  secsinh=sinh(f->ty);
  seccosh=cosh(f->ty);
  double return_value_cos_1;
  return_value_cos_1=cos((double)2 * f->tx);
  double return_value_cosh_2;
  return_value_cosh_2=cosh((double)2 * f->ty);
  secden = 2.0 / (return_value_cos_1 + return_value_cosh_2);
  f->p0 = f->p0 + weight * secden * seccos * seccosh;
  f->p1 = f->p1 + weight * secden * secsin * secsinh;
}

// var88_csc
// file variations.c line 1806
void var88_csc(struct anonymous_9 *f, double weight)
{
  double cscsin;
  double csccos;
  double cscsinh;
  double csccosh;
  double cscden;
  sincos(f->tx, &cscsin, &csccos);
  cscsinh=sinh(f->ty);
  csccosh=cosh(f->ty);
  double return_value_cosh_1;
  return_value_cosh_1=cosh(2.0 * f->ty);
  double return_value_cos_2;
  return_value_cos_2=cos(2.0 * f->tx);
  cscden = 2.0 / (return_value_cosh_1 - return_value_cos_2);
  f->p0 = f->p0 + weight * cscden * cscsin * csccosh;
  f->p1 = f->p1 - weight * cscden * csccos * cscsinh;
}

// var89_cot
// file variations.c line 1818
void var89_cot(struct anonymous_9 *f, double weight)
{
  double cotsin;
  double cotcos;
  double cotsinh;
  double cotcosh;
  double cotden;
  sincos(2.0 * f->tx, &cotsin, &cotcos);
  cotsinh=sinh(2.0 * f->ty);
  cotcosh=cosh(2.0 * f->ty);
  cotden = 1.0 / (cotcosh - cotcos);
  f->p0 = f->p0 + weight * cotden * cotsin;
  f->p1 = f->p1 + weight * cotden * (double)-1 * cotsinh;
}

// var8_disc
// file variations.c line 263
void var8_disc(struct anonymous_9 *f, double weight)
{
  double a = f->precalc_atan * 0.31830988618379067154;
  double r = 3.14159265358979323846 * f->precalc_sqrt;
  double sr;
  double cr;
  sincos(r, &sr, &cr);
  f->p0 = f->p0 + weight * sr * a;
  f->p1 = f->p1 + weight * cr * a;
}

// var90_sinh
// file variations.c line 1830
void var90_sinh(struct anonymous_9 *f, double weight)
{
  double sinhsin;
  double sinhcos;
  double sinhsinh;
  double sinhcosh;
  sincos(f->ty, &sinhsin, &sinhcos);
  sinhsinh=sinh(f->tx);
  sinhcosh=cosh(f->tx);
  f->p0 = f->p0 + weight * sinhsinh * sinhcos;
  f->p1 = f->p1 + weight * sinhcosh * sinhsin;
}

// var91_cosh
// file variations.c line 1840
void var91_cosh(struct anonymous_9 *f, double weight)
{
  double coshsin;
  double coshcos;
  double coshsinh;
  double coshcosh;
  sincos(f->ty, &coshsin, &coshcos);
  coshsinh=sinh(f->tx);
  coshcosh=cosh(f->tx);
  f->p0 = f->p0 + weight * coshcosh * coshcos;
  f->p1 = f->p1 + weight * coshsinh * coshsin;
}

// var92_tanh
// file variations.c line 1850
void var92_tanh(struct anonymous_9 *f, double weight)
{
  double tanhsin;
  double tanhcos;
  double tanhsinh;
  double tanhcosh;
  double tanhden;
  sincos(2.0 * f->ty, &tanhsin, &tanhcos);
  tanhsinh=sinh(2.0 * f->tx);
  tanhcosh=cosh(2.0 * f->tx);
  tanhden = 1.0 / (tanhcos + tanhcosh);
  f->p0 = f->p0 + weight * tanhden * tanhsinh;
  f->p1 = f->p1 + weight * tanhden * tanhsin;
}

// var93_sech
// file variations.c line 1862
void var93_sech(struct anonymous_9 *f, double weight)
{
  double sechsin;
  double sechcos;
  double sechsinh;
  double sechcosh;
  double sechden;
  sincos(f->ty, &sechsin, &sechcos);
  sechsinh=sinh(f->tx);
  sechcosh=cosh(f->tx);
  double return_value_cos_1;
  return_value_cos_1=cos(2.0 * f->ty);
  double return_value_cosh_2;
  return_value_cosh_2=cosh(2.0 * f->tx);
  sechden = 2.0 / (return_value_cos_1 + return_value_cosh_2);
  f->p0 = f->p0 + weight * sechden * sechcos * sechcosh;
  f->p1 = f->p1 - weight * sechden * sechsin * sechsinh;
}

// var94_csch
// file variations.c line 1874
void var94_csch(struct anonymous_9 *f, double weight)
{
  double cschsin;
  double cschcos;
  double cschsinh;
  double cschcosh;
  double cschden;
  sincos(f->ty, &cschsin, &cschcos);
  cschsinh=sinh(f->tx);
  cschcosh=cosh(f->tx);
  double return_value_cosh_1;
  return_value_cosh_1=cosh(2.0 * f->tx);
  double return_value_cos_2;
  return_value_cos_2=cos(2.0 * f->ty);
  cschden = 2.0 / (return_value_cosh_1 - return_value_cos_2);
  f->p0 = f->p0 + weight * cschden * cschsinh * cschcos;
  f->p1 = f->p1 - weight * cschden * cschcosh * cschsin;
}

// var95_coth
// file variations.c line 1886
void var95_coth(struct anonymous_9 *f, double weight)
{
  double cothsin;
  double cothcos;
  double cothsinh;
  double cothcosh;
  double cothden;
  sincos(2.0 * f->ty, &cothsin, &cothcos);
  cothsinh=sinh(2.0 * f->tx);
  cothcosh=cosh(2.0 * f->tx);
  cothden = 1.0 / (cothcosh - cothcos);
  f->p0 = f->p0 + weight * cothden * cothsinh;
  f->p1 = f->p1 + weight * cothden * cothsin;
}

// var96_auger
// file variations.c line 1898
void var96_auger(struct anonymous_9 *f, double weight)
{
  double s;
  s=sin(f->xform->auger_freq * f->tx);
  double t;
  t=sin(f->xform->auger_freq * f->ty);
  double dy;
  double return_value_fabs_1;
  return_value_fabs_1=fabs(f->ty);
  dy = f->ty + f->xform->auger_weight * ((f->xform->auger_scale * s) / 2.0 + return_value_fabs_1 * s);
  double dx;
  double return_value_fabs_2;
  return_value_fabs_2=fabs(f->tx);
  dx = f->tx + f->xform->auger_weight * ((f->xform->auger_scale * t) / 2.0 + return_value_fabs_2 * t);
  f->p0 = f->p0 + weight * (f->tx + f->xform->auger_sym * (dx - f->tx));
  f->p1 = f->p1 + weight * dy;
}

// var97_flux
// file variations.c line 1910
void var97_flux(struct anonymous_9 *f, double weight)
{
  double xpw = f->tx + weight;
  double xmw = f->tx - weight;
  double avgr;
  double return_value_sqrt_1;
  return_value_sqrt_1=sqrt(f->ty * f->ty + xpw * xpw);
  double return_value_sqrt_2;
  return_value_sqrt_2=sqrt(f->ty * f->ty + xmw * xmw);
  double return_value_sqrt_3;
  return_value_sqrt_3=sqrt(return_value_sqrt_1 / return_value_sqrt_2);
  avgr = weight * ((double)2 + f->xform->flux_spread) * return_value_sqrt_3;
  double avga;
  double return_value_atan2_4;
  return_value_atan2_4=atan2(f->ty, xmw);
  double return_value_atan2_5;
  return_value_atan2_5=atan2(f->ty, xpw);
  avga = (return_value_atan2_4 - return_value_atan2_5) * 0.5;
  double s;
  s=sin(avga);
  double c;
  c=cos(avga);
  double return_value_cos_6;
  return_value_cos_6=cos(avga);
  f->p0 = f->p0 + avgr * return_value_cos_6;
  double return_value_sin_7;
  return_value_sin_7=sin(avga);
  f->p1 = f->p1 + avgr * return_value_sin_7;
}

// var9_spiral
// file variations.c line 281
void var9_spiral(struct anonymous_9 *f, double weight)
{
  double r = f->precalc_sqrt + 1e-10;
  double r1 = weight / r;
  double sr;
  double cr;
  sincos(r, &sr, &cr);
  f->p0 = f->p0 + r1 * (f->precalc_cosa + sr);
  f->p1 = f->p1 + r1 * (f->precalc_sina - cr);
}

// waves_precalc
// file variations.c line 1954
void waves_precalc(struct xform *xf)
{
  double dx = xf->c[(signed long int)2][(signed long int)0];
  double dy = xf->c[(signed long int)2][(signed long int)1];
  xf->waves_dx2 = 1.0 / (dx * dx + 1e-10);
  xf->waves_dy2 = 1.0 / (dy * dy + 1e-10);
}

// wedgeJulia_precalc
// file variations.c line 1938
void wedgeJulia_precalc(struct xform *xf)
{
  xf->wedgeJulia_cf = 1.0 - xf->wedge_julia_angle * xf->wedge_julia_count * 0.31830988618379067154 * 0.5;
  xf->wedgeJulia_rN=fabs(xf->wedge_julia_power);
  xf->wedgeJulia_cn = (xf->wedge_julia_dist / xf->wedge_julia_power) / 2.0;
}

// write_jpeg
// file jpeg.c line 31
void write_jpeg(struct _IO_FILE *file, unsigned char *image, signed int width, signed int height, struct anonymous_19 *fpc)
{
  struct jpeg_compress_struct info;
  struct jpeg_error_mgr jerr;
  unsigned long int i;
  char *nick;
  nick=getenv("nick");
  char *url;
  url=getenv("url");
  char *id;
  id=getenv("id");
  char *ai;
  signed int jpegcom_enable;
  ai=getenv("enable_jpeg_comments");
  signed int tmp_if_expr_2;
  signed int return_value_atoi_1;
  if(!(ai == ((char *)NULL)))
  {
    return_value_atoi_1=atoi_link4(ai);
    tmp_if_expr_2 = return_value_atoi_1;
  }

  else
    tmp_if_expr_2 = 1;
  jpegcom_enable = tmp_if_expr_2;
  char nick_string[64l];
  char url_string[128l];
  char id_string[128l];
  char bv_string[64l];
  char ni_string[64l];
  char rt_string[64l];
  char genome_string[65536l];
  char ver_string[64l];
  snprintf(genome_string, (unsigned long int)65536, "flam3_genome: %s", fpc->genome);
  snprintf(bv_string, (unsigned long int)64, "flam3_error_rate: %s", fpc->badvals);
  snprintf(ni_string, (unsigned long int)64, "flam3_samples: %s", fpc->numiters);
  snprintf(rt_string, (unsigned long int)64, "flam3_time: %s", fpc->rtime);
  char *return_value_flam3_version_3;
  return_value_flam3_version_3=flam3_version();
  snprintf(ver_string, (unsigned long int)64, "flam3_version: %s", return_value_flam3_version_3);
  info.err=jpeg_std_error(&jerr);
  jpeg_CreateCompress(&info, 62, (unsigned long int)sizeof(struct jpeg_compress_struct) /*520ul*/ );
  jpeg_stdio_dest(&info, file);
  info.in_color_space = (enum anonymous_20)JCS_RGB;
  info.input_components = 3;
  info.image_width = (unsigned int)width;
  info.image_height = (unsigned int)height;
  jpeg_set_defaults(&info);
  char *return_value_getenv_5;
  return_value_getenv_5=getenv("jpeg");
  if(!(return_value_getenv_5 == ((char *)NULL)))
  {
    signed int quality;
    char *return_value_getenv_4;
    return_value_getenv_4=getenv("jpeg");
    quality=atoi_link4(return_value_getenv_4);
    jpeg_set_quality(&info, quality, 1);
  }

  jpeg_start_compress(&info, 1);
  if(jpegcom_enable == 1)
  {
    unsigned long int return_value_strlen_6;
    return_value_strlen_6=strlen(ver_string);
    jpeg_write_marker(&info, 0xFE, (unsigned char *)ver_string, (unsigned int)(signed int)return_value_strlen_6);
    if(!(nick == ((char *)NULL)))
    {
      snprintf(nick_string, (unsigned long int)64, "flam3_nickname: %s", nick);
      unsigned long int return_value_strlen_7;
      return_value_strlen_7=strlen(nick_string);
      jpeg_write_marker(&info, 0xFE, (unsigned char *)nick_string, (unsigned int)(signed int)return_value_strlen_7);
    }

    if(!(url == ((char *)NULL)))
    {
      snprintf(url_string, (unsigned long int)128, "flam3_url: %s", url);
      unsigned long int return_value_strlen_8;
      return_value_strlen_8=strlen(url_string);
      jpeg_write_marker(&info, 0xFE, (unsigned char *)url_string, (unsigned int)(signed int)return_value_strlen_8);
    }

    if(!(id == ((char *)NULL)))
    {
      snprintf(id_string, (unsigned long int)128, "flam3_id: %s", id);
      unsigned long int return_value_strlen_9;
      return_value_strlen_9=strlen(id_string);
      jpeg_write_marker(&info, 0xFE, (unsigned char *)id_string, (unsigned int)(signed int)return_value_strlen_9);
    }

    unsigned long int return_value_strlen_10;
    return_value_strlen_10=strlen(bv_string);
    jpeg_write_marker(&info, 0xFE, (unsigned char *)bv_string, (unsigned int)(signed int)return_value_strlen_10);
    unsigned long int return_value_strlen_11;
    return_value_strlen_11=strlen(ni_string);
    jpeg_write_marker(&info, 0xFE, (unsigned char *)ni_string, (unsigned int)(signed int)return_value_strlen_11);
    unsigned long int return_value_strlen_12;
    return_value_strlen_12=strlen(rt_string);
    jpeg_write_marker(&info, 0xFE, (unsigned char *)rt_string, (unsigned int)(signed int)return_value_strlen_12);
    unsigned long int return_value_strlen_13;
    return_value_strlen_13=strlen(genome_string);
    jpeg_write_marker(&info, 0xFE, (unsigned char *)genome_string, (unsigned int)(signed int)return_value_strlen_13);
  }

  i = (unsigned long int)0;
  for( ; !(i >= (unsigned long int)height); i = i + 1ul)
  {
    unsigned char *row_pointer[1l];
    row_pointer[(signed long int)0] = (unsigned char *)image + (signed long int)((unsigned long int)(3 * width) * i);
    jpeg_write_scanlines(&info, row_pointer, (unsigned int)1);
  }
  jpeg_finish_compress(&info);
  jpeg_destroy_compress(&info);
}

// write_png
// file png.c line 36
void write_png(struct _IO_FILE *file, void *image, signed int width, signed int height, struct anonymous_19 *fpc, signed int bpc)
{
  struct png_struct_def *png_ptr;
  struct png_info_struct *info_ptr;
  struct png_text_struct text[8l];
  unsigned long int i;
  unsigned short int testbe = (unsigned short int)1;
  void **rows;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(void *) /*8ul*/  * (unsigned long int)height);
  rows = (void **)return_value_malloc_1;
  char *nick;
  nick=getenv("nick");
  char *url;
  url=getenv("url");
  char *id;
  id=getenv("id");
  char *ai;
  signed int pngcom_enable;
  ai=getenv("enable_png_comments");
  signed int tmp_if_expr_3;
  signed int return_value_atoi_2;
  if(!(ai == ((char *)NULL)))
  {
    return_value_atoi_2=atoi_link5(ai);
    tmp_if_expr_3 = return_value_atoi_2;
  }

  else
    tmp_if_expr_3 = 1;
  pngcom_enable = tmp_if_expr_3;
  text[(signed long int)0].compression = -1;
  text[(signed long int)0].key = "flam3_version";
  text[(signed long int)0].text=flam3_version();
  text[(signed long int)1].compression = -1;
  text[(signed long int)1].key = "flam3_nickname";
  text[(signed long int)1].text = nick;
  text[(signed long int)2].compression = -1;
  text[(signed long int)2].key = "flam3_url";
  text[(signed long int)2].text = url;
  text[(signed long int)3].compression = -1;
  text[(signed long int)3].key = "flam3_id";
  text[(signed long int)3].text = id;
  text[(signed long int)4].compression = -1;
  text[(signed long int)4].key = "flam3_error_rate";
  text[(signed long int)4].text = fpc->badvals;
  text[(signed long int)5].compression = -1;
  text[(signed long int)5].key = "flam3_samples";
  text[(signed long int)5].text = fpc->numiters;
  text[(signed long int)6].compression = -1;
  text[(signed long int)6].key = "flam3_time";
  text[(signed long int)6].text = fpc->rtime;
  text[(signed long int)7].compression = 0;
  text[(signed long int)7].key = "flam3_genome";
  text[(signed long int)7].text = fpc->genome;
  i = (unsigned long int)0;
  for( ; !(i >= (unsigned long int)height); i = i + 1ul)
    rows[(signed long int)i] = (void *)((unsigned char *)image + (signed long int)(i * (unsigned long int)width * (unsigned long int)4 * (unsigned long int)bpc));
  png_ptr=png_create_write_struct("1.2.54", (void *)0, (void (*)(struct png_struct_def *, const char *))(void *)0, (void (*)(struct png_struct_def *, const char *))(void *)0);
  info_ptr=png_create_info_struct(png_ptr);
  signed int return_value__setjmp_4;
  return_value__setjmp_4=_setjmp(png_ptr->jmpbuf);
  unsigned short int tmp_statement_expression_5;
  if(!(return_value__setjmp_4 == 0))
  {
    fclose(file);
    png_destroy_write_struct(&png_ptr, &info_ptr);
    perror("writing file");
  }

  else
  {
    png_init_io(png_ptr, file);
    png_set_IHDR(png_ptr, info_ptr, (unsigned long int)width, (unsigned long int)height, 8 * bpc, 2 | 4, 0, 0, 0);
    if(pngcom_enable == 1)
      png_set_text(png_ptr, info_ptr, text, 8);

    png_write_info(png_ptr, info_ptr);
    if(bpc == 2)
    {
      unsigned short int __v;
      unsigned short int __x = (unsigned short int)testbe;
      asm("rorw _8, %w0" : "=r"(__v) : "0"(__x) : "cc");
      tmp_statement_expression_5 = __v;
      if(!(testbe == tmp_statement_expression_5))
        png_set_swap(png_ptr);

    }

    png_write_image(png_ptr, (unsigned char **)rows);
    png_write_end(png_ptr, info_ptr);
    png_destroy_write_struct(&png_ptr, &info_ptr);
    free((void *)rows);
  }
}

// xform_precalc
// file variations.h line 136
void xform_precalc(struct anonymous_0 *cp, signed int xi)
{
  perspective_precalc(&cp->xform[(signed long int)xi]);
  juliaN_precalc(&cp->xform[(signed long int)xi]);
  juliaScope_precalc(&cp->xform[(signed long int)xi]);
  radial_blur_precalc(&cp->xform[(signed long int)xi]);
  waves_precalc(&cp->xform[(signed long int)xi]);
  disc2_precalc(&cp->xform[(signed long int)xi]);
  supershape_precalc(&cp->xform[(signed long int)xi]);
  wedgeJulia_precalc(&cp->xform[(signed long int)xi]);
}

// zero_matrix
// file interpolation.h line 39
signed int zero_matrix(double (*s)[2l])
{
  _Bool tmp_if_expr_1;
  if(IEEE_FLOAT_EQUAL((*s)[0l], 0.0))
    tmp_if_expr_1 = IEEE_FLOAT_EQUAL(s[(signed long int)0][(signed long int)1], 0.0) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  _Bool tmp_if_expr_2;
  if(tmp_if_expr_1)
    tmp_if_expr_2 = IEEE_FLOAT_EQUAL(s[(signed long int)1][(signed long int)0], 0.0) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  _Bool tmp_if_expr_3;
  if(tmp_if_expr_2)
    tmp_if_expr_3 = IEEE_FLOAT_EQUAL(s[(signed long int)1][(signed long int)1], 0.0) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_3 = (_Bool)0;
  _Bool tmp_if_expr_4;
  if(tmp_if_expr_3)
    tmp_if_expr_4 = IEEE_FLOAT_EQUAL(s[(signed long int)2][(signed long int)0], 0.0) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_4 = (_Bool)0;
  _Bool tmp_if_expr_5;
  if(tmp_if_expr_4)
    tmp_if_expr_5 = IEEE_FLOAT_EQUAL(s[(signed long int)2][(signed long int)1], 0.0) ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_5 = (_Bool)0;
  return (signed int)tmp_if_expr_5;
}

