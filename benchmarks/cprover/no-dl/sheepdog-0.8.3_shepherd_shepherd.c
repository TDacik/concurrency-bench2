// tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 121
struct anonymous_15;

// tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 107
struct anonymous_12;

// tag-#anon#ST[ARR16{U64}_U64_'__val'|]
// file /usr/include/x86_64-linux-gnu/bits/sigset.h line 27
struct anonymous_0;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_24;

// tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}_U8_'__pad1'||U64'__pad2'||U32'__flags'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 177
struct anonymous_27;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 74
struct anonymous_8;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 97
struct anonymous_11;

// tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 89
struct anonymous_10;

// tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 62
struct anonymous_1;

// tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 81
struct anonymous_9;

// tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 114
struct anonymous_14;

// tag-#anon#ST[U32'__pad'||U32'nr_nodes'||ARR2{U32}_U32_'__reserved'||U64'store_size'||U64'store_free'|]
// file ../include/sheepdog_proto.h line 200
struct anonymous_4;

// tag-#anon#ST[U32'__pad'||U32'rsvd'||U32'vdi_id'||U32'attr_id'||U8'copies'||ARR3{U8}_U8_'reserved'|]
// file ../include/sheepdog_proto.h line 190
struct anonymous_3;

// tag-#anon#ST[U32'__pad'||U8'copies'||ARR3{U8}_U8_'reserved'||U64'offset'|]
// file ../include/sheepdog_proto.h line 184
struct anonymous_2;

// tag-#anon#ST[U32'__pad1'||U32'__pad2'||ARR20{U8}_U8_'digest'|]
// file ../include/sheepdog_proto.h line 207
struct anonymous_5;

// tag-#anon#ST[U32'old_vid'||U32'new_vid'||U8'copies'||U8'set_bitmap'||U8'copy_policy'||U8'_pad0'|]
// file ../include/sheepdog_proto.h line 162
struct anonymous_20;

// tag-#anon#ST[U64'oid'||U64'cow_oid'||U8'copies'||U8'copy_policy'||U8'ec_index'||U8'reserved'||U32'tgt_epoch'||U32'offset'||U32'__pad'|]
// file ../include/sheepdog_proto.h line 132
struct anonymous_17;

// tag-#anon#ST[U64'oid'||U64'ctime'||U8'copies'||U8'copy_policy'||U16'flags'||U32'tag'|]
// file ../include/sheepdog_proto.h line 154
struct anonymous_19;

// tag-#anon#ST[U64'val'|]
// file ../include/util.h line 204
struct anonymous_29;

// tag-#anon#ST[U64'vdi_size'||U32'base_vdi_id'||U8'copies'||U8'copy_policy'||U8'store_policy'||U8'reserved'||U32'snapid'||U32'_pad0'|]
// file ../include/sheepdog_proto.h line 143
struct anonymous_18;

// tag-#anon#UN[*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'ifu_broadaddr'||*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'ifu_dstaddr'|]
// file /usr/include/ifaddrs.h line 38
union anonymous_13;

// tag-#anon#UN[*{V(S32)->V}_V(S32)->V_'sa_handler'||*{V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V}_V(S32|*{SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#}_SYM#tag-#anon#ST[S32'si_signo'||S32'si_errno'||S32'si_code'||U32'_pad0'||SYM#tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]#'_sifields'|]#_|*{V}_V_)->V_'sa_sigaction'|]
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 28
union anonymous;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous_21;

// tag-#anon#UN[ARR28{S32}_S32_'_pad'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'|]#'_kill'||SYM#tag-#anon#ST[S32'si_tid'||S32'si_overrun'||SYM#tag-sigval#'si_sigval'|]#'_timer'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||SYM#tag-sigval#'si_sigval'|]#'_rt'||SYM#tag-#anon#ST[S32'si_pid'||U32'si_uid'||S32'si_status'||U32'_pad0'||S64'si_utime'||S64'si_stime'|]#'_sigchld'||SYM#tag-#anon#ST[*{V}_V_'si_addr'||S16'si_addr_lsb'||U48'_pad0'|]#'_sigfault'||SYM#tag-#anon#ST[S64'si_band'||S32'si_fd'||U32'_pad0'|]#'_sigpoll'||SYM#tag-#anon#ST[*{V}_V_'_call_addr'||S32'_syscall'||U32'_arch'|]#'_sigsys'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 69
union anonymous_16;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_23;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_25;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}_U8_'__pad1'||U64'__pad2'||U32'__flags'||U32'_pad0'|]#'__data'||ARR56{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 174
union anonymous_28;

// tag-#anon#UN[SYM#tag-#anon#ST[U64'oid'||U64'cow_oid'||U8'copies'||U8'copy_policy'||U8'ec_index'||U8'reserved'||U32'tgt_epoch'||U32'offset'||U32'__pad'|]#'obj'||SYM#tag-#anon#ST[U64'vdi_size'||U32'base_vdi_id'||U8'copies'||U8'copy_policy'||U8'store_policy'||U8'reserved'||U32'snapid'||U32'_pad0'|]#'vdi'||SYM#tag-#anon#ST[U64'oid'||U64'ctime'||U8'copies'||U8'copy_policy'||U16'flags'||U32'tag'|]#'cluster'||SYM#tag-#anon#ST[U32'old_vid'||U32'new_vid'||U8'copies'||U8'set_bitmap'||U8'copy_policy'||U8'_pad0'|]#'vdi_state'||ARR8{U32}_U32_'__pad'|]
// file ../include/sheepdog_proto.h line 131
union anonymous_7;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_22;

// tag-#anon#UN[U32'result'||SYM#tag-#anon#ST[U32'__pad'||U8'copies'||ARR3{U8}_U8_'reserved'||U64'offset'|]#'obj'||SYM#tag-#anon#ST[U32'__pad'||U32'rsvd'||U32'vdi_id'||U32'attr_id'||U8'copies'||ARR3{U8}_U8_'reserved'|]#'vdi'||SYM#tag-#anon#ST[U32'__pad'||U32'nr_nodes'||ARR2{U32}_U32_'__reserved'||U64'store_size'||U64'store_free'|]#'node'||SYM#tag-#anon#ST[U32'__pad1'||U32'__pad2'||ARR20{U8}_U8_'digest'|]#'hash'||ARR8{U32}_U32_'__pad'|]
// file ../include/sheepdog_proto.h line 182
union anonymous_6;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_30;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_31;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__dirstream
// file /usr/include/dirent.h line 127
struct __dirstream;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-__uatomic_dummy
// file /usr/include/urcu/uatomic.h line 37
struct __uatomic_dummy;

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-btree_node_type
// file ../include/sheepdog_proto.h line 255
enum btree_node_type { BTREE_HEAD=1, BTREE_EXT=2, BTREE_IDX=3 };

// tag-connection
// file ../include/net.h line 28
struct connection;

// tag-dirent
// file /usr/include/x86_64-linux-gnu/bits/dirent.h line 22
struct dirent;

// tag-epoll_data
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 79
union epoll_data;

// tag-epoll_event
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 87
struct epoll_event;

// tag-event_info
// file ../include/event.h line 7
struct event_info;

// tag-fec
// file ../include/fec.h line 68
struct fec;

// tag-find_path
// file sd_inode.c line 98
struct find_path;

// tag-ifaddrs
// file /usr/include/ifaddrs.h line 29
struct ifaddrs;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-iovec
// file /usr/include/x86_64-linux-gnu/bits/uio.h line 43
struct iovec;

// tag-ipc_perm
// file /usr/include/x86_64-linux-gnu/bits/ipc.h line 42
struct ipc_perm;

// tag-itimerspec
// file /usr/include/time.h line 161
struct itimerspec;

// tag-linger
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 379
struct linger;

// tag-list_head
// file ../include/list.h line 15
struct list_head;

// tag-list_node
// file ../include/list.h line 10
struct list_node;

// tag-log_dst_type
// file ../include/logger.h line 33
enum log_dst_type { LOG_DST_DEFAULT=0, LOG_DST_STDOUT=1, LOG_DST_SYSLOG=2 };

// tag-log_format
// file logger.c line 100
struct log_format;

// tag-logarea
// file logger.c line 75
struct logarea;

// tag-logger_user_info
// file ../include/logger.h line 27
struct logger_user_info;

// tag-logmsg
// file logger.c line 86
struct logmsg;

// tag-msghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 224
struct msghdr;

// tag-node_id
// file ../include/internal_proto.h line 138
struct node_id;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-option_parser
// file ../include/option.h line 25
struct option_parser;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-rb_node
// file ../include/rbtree.h line 7
struct rb_node;

// tag-rb_root
// file ../include/rbtree.h line 15
struct rb_root;

// tag-sd_cond
// file ../include/util.h line 344
struct sd_cond;

// tag-sd_extent
// file ../include/sheepdog_proto.h line 237
struct sd_extent;

// tag-sd_extent_header
// file ../include/sheepdog_proto.h line 249
struct sd_extent_header;

// tag-sd_extent_idx
// file ../include/sheepdog_proto.h line 242
struct sd_extent_idx;

// tag-sd_inode
// file ../include/sheepdog_proto.h line 217
struct sd_inode;

// tag-sd_mutex
// file ../include/util.h line 269
struct sd_mutex;

// tag-sd_node
// file ../include/internal_proto.h line 148
struct sd_node;

// tag-sd_option
// file ../include/option.h line 17
struct sd_option;

// tag-sd_req
// file ../include/sheepdog_proto.h line 124
struct sd_req;

// tag-sd_rsp
// file ../include/sheepdog_proto.h line 175
struct sd_rsp;

// tag-sd_rw_lock
// file ../include/util.h line 401
struct sd_rw_lock;

// tag-sembuf
// file /usr/include/x86_64-linux-gnu/sys/sem.h line 41
struct sembuf;

// tag-semid_ds
// file /usr/include/x86_64-linux-gnu/bits/sem.h line 38
struct semid_ds;

// tag-seminfo
// file /usr/include/x86_64-linux-gnu/bits/sem.h line 72
struct seminfo;

// tag-semun
// file logger.c line 68
union semun;

// tag-sha1_ctx
// file ../include/sha1.h line 20
struct sha1_ctx;

// tag-sheep
// file shepherd.c line 52
struct sheep;

// tag-sheep_state
// file shepherd.c line 46
enum sheep_state { SHEEP_STATE_CONNECTED=0, SHEEP_STATE_JOINED=1, SHEEP_STATE_LEAVING=2 };

// tag-shepherd_state
// file shepherd.c line 39
enum shepherd_state { SPH_STATE_DEFAULT=0, SPH_STATE_JOINING=1 };

// tag-shmid_ds
// file /usr/include/x86_64-linux-gnu/bits/shm.h line 49
struct shmid_ds;

// tag-sigaction
// file /usr/include/x86_64-linux-gnu/bits/sigaction.h line 24
struct sigaction;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-sockfd
// file ../include/sockfd_cache.h line 7
struct sockfd;

// tag-sockfd_cache
// file sockfd_cache.c line 38
struct sockfd_cache;

// tag-sockfd_cache_entry
// file sockfd_cache.c line 69
struct sockfd_cache_entry;

// tag-sockfd_cache_fd
// file sockfd_cache.c line 64
struct sockfd_cache_fd;

// tag-sph_cli_msg_type
// file ../include/shepherd.h line 4
enum sph_cli_msg_type { SPH_CLI_MSG_JOIN=0, SPH_CLI_MSG_ACCEPT=1, SPH_CLI_MSG_NOTIFY=2, SPH_CLI_MSG_BLOCK=3, SPH_CLI_MSG_LEAVE=4 };

// tag-sph_msg
// file ../include/shepherd.h line 28
struct sph_msg;

// tag-sph_msg_join
// file ../include/shepherd.h line 39
struct sph_msg_join;

// tag-sph_msg_join_node_finish
// file ../include/shepherd.h line 53
struct sph_msg_join_node_finish;

// tag-sph_msg_join_reply
// file ../include/shepherd.h line 47
struct sph_msg_join_reply;

// tag-sph_msg_notify
// file ../include/shepherd.h line 61
struct sph_msg_notify;

// tag-sph_msg_notify_forward
// file ../include/shepherd.h line 66
struct sph_msg_notify_forward;

// tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// tag-strbuf
// file ../include/strbuf.h line 12
struct strbuf;

// tag-timer
// file ../include/event.h line 19
struct timer;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 55
struct timezone;

// tag-tm
// file /usr/include/time.h line 133
struct tm;

// tag-work
// file ../include/work.h line 9
struct work;

// tag-work_queue
// file ../include/work.h line 19
struct work_queue;

// tag-wq_info
// file work.c line 43
struct wq_info;

// tag-wq_thread_control
// file ../include/work.h line 24
enum wq_thread_control { WQ_ORDERED=0, WQ_DYNAMIC=1, WQ_UNLIMITED=2 };

#ifndef NULL
#define NULL ((void*)0)
#endif

// INIT_LIST_HEAD
// file ../include/list.h line 27
static inline void INIT_LIST_HEAD(struct list_head *list);
// __ctype_b_loc
// file /usr/include/ctype.h line 79
extern const unsigned short int ** __ctype_b_loc(void);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __list_add
// file ../include/list.h line 72
static inline void __list_add(struct list_node *new, struct list_node *prev, struct list_node *next);
// __list_add_link1
// file ../include/list.h line 72
static inline void __list_add_link1(struct list_node *new_link1, struct list_node *prev_link1, struct list_node *next_link1);
// __list_del
// file ../include/list.h line 92
static inline void __list_del(struct list_node *prev, struct list_node *next);
// __list_del_link1
// file ../include/list.h line 92
static inline void __list_del_link1(struct list_node *prev_link1, struct list_node *next_link1);
// __list_splice
// file ../include/list.h line 122
static inline void __list_splice(struct list_head *list, struct list_node *prev, struct list_node *next);
// __rb_erase_color
// file rbtree.c line 124
static void __rb_erase_color(struct rb_node *node, struct rb_node *parent, struct rb_root *root);
// __rb_rotate_left
// file rbtree.c line 25
static void __rb_rotate_left(struct rb_node *node, struct rb_root *root);
// __rb_rotate_right
// file rbtree.c line 47
static void __rb_rotate_right(struct rb_node *node, struct rb_root *root);
// __sd_dump_variable
// file logger.c line 791
signed int __sd_dump_variable(const char *var);
// __uatomic_add_return
// file /usr/include/urcu/uatomic.h line 178
static inline unsigned long int __uatomic_add_return(void *addr, unsigned long int val, signed int len);
// __uatomic_cmpxchg
// file /usr/include/urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg(void *addr, unsigned long int old, unsigned long int _new, signed int len);
// __uatomic_dec
// file /usr/include/urcu/uatomic.h line 467
static inline void __uatomic_dec(void *addr, signed int len);
// __uatomic_inc
// file /usr/include/urcu/uatomic.h line 414
static inline void __uatomic_inc(void *addr, signed int len);
// _addmul1
// file fec.c line 216
static void _addmul1(unsigned char *dst, const unsigned char *src, unsigned char c, unsigned long int sz);
// _init_mul_table
// file fec.c line 127
static void _init_mul_table(void);
// _invert_mat
// file fec.c line 278
static void _invert_mat(unsigned char *src, unsigned int d);
// _invert_vdm
// file fec.c line 386
static void _invert_vdm(unsigned char *src, unsigned int d);
// _matmul
// file fec.c line 255
static void _matmul(unsigned char *a, unsigned char *b, unsigned char *c, unsigned int dp, unsigned int d, unsigned int m);
// _pread
// file util.c line 168
static signed long int _pread(signed int fd, void *buf, unsigned long int len, signed long int offset);
// _pwrite
// file util.c line 179
static signed long int _pwrite(signed int fd, const void *buf, unsigned long int len, signed long int offset);
// _read
// file util.c line 106
static signed long int _read(signed int fd, void *buf, unsigned long int len);
// _write
// file util.c line 117
static signed long int _write(signed int fd, const void *buf, unsigned long int len);
// abort
// file /usr/include/stdlib.h line 515
extern void abort(void);
// accept
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 243
extern signed int accept(signed int, union anonymous_31, unsigned int *);
// access
// file /usr/include/unistd.h line 287
extern signed int access(const char *, signed int);
// add_timer
// file event.c line 39
void add_timer(struct timer *t, unsigned int mseconds);
// addr_to_str
// file ../include/net.h line 56
const char * addr_to_str(const unsigned char *addr, unsigned short int port);
// atexit
// file /usr/include/stdlib.h line 519
extern signed int atexit(void (*)(void));
// atomic_create_and_write
// file util.c line 567
signed int atomic_create_and_write(const char *path, const char *buf, unsigned long int len, _Bool force_create);
// backtrace
// file /usr/include/execinfo.h line 27
extern signed int backtrace(void **, signed int);
// backtrace_symbols
// file /usr/include/execinfo.h line 32
extern char ** backtrace_symbols(void * const *, signed int);
// binary_search
// file sd_inode.c line 222
static void * binary_search(void *first, void *last, void *key, unsigned long int obj_size, signed int (*cmp)(void *, void *));
// binary_search::cmp_object
//
signed int cmp_object(void *, void *);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, union anonymous_31, unsigned int);
// block_sighup
// file logger.c line 130
static void block_sighup(void);
// build_decode_matrix_into_space
// file fec.c line 538
static void build_decode_matrix_into_space(struct fec * const code, const signed int * const idx, const unsigned int d, unsigned char * const matrix);
// build_long_options
// file ../include/option.h line 31
struct option * build_long_options(struct sd_option *sd_opts);
// build_node_array
// file shepherd.c line 74
static signed int build_node_array(struct sd_node *nodes);
// build_short_options
// file ../include/option.h line 30
char * build_short_options(struct sd_option *sd_opts);
// calloc
// file /usr/include/stdlib.h line 468
extern void * calloc(unsigned long int, unsigned long int);
// chdir
// file /usr/include/unistd.h line 497
extern signed int chdir(const char *);
// check_gdb
// file logger.c line 753
static _Bool check_gdb(void);
// check_idx
// file sockfd_cache.c line 277
static inline void check_idx(signed int idx);
// chomp
// file ../include/util.h line 106
char * chomp(char *str);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closedir
// file /usr/include/dirent.h line 149
extern signed int closedir(struct __dirstream *);
// closelog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 175
extern void closelog(void);
// conn_rx_off
// file net.c line 50
signed int conn_rx_off(struct connection *conn);
// conn_rx_on
// file net.c line 57
signed int conn_rx_on(struct connection *conn);
// conn_tx_off
// file net.c line 36
signed int conn_tx_off(struct connection *conn);
// conn_tx_on
// file net.c line 43
signed int conn_tx_on(struct connection *conn);
// connect
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 137
extern signed int connect(signed int, union anonymous_31, unsigned int);
// connect_to
// file net.c line 137
signed int connect_to(const char *name, signed int port);
// connect_to_addr
// file ../include/net.h line 71
static inline signed int connect_to_addr(const unsigned char *addr, signed int port);
// count_data_objs
// file ../include/sheepdog_proto.h line 411
static inline unsigned long int count_data_objs(struct sd_inode *inode);
// crash_handler
// file shepherd.c line 640
static void crash_handler(signed int signo);
// crash_handler_link1
// file logger.c line 534
static void crash_handler_link1(signed int signo_link1);
// create_listen_ports
// file ../include/net.h line 51
signed int create_listen_ports(const char *bindaddr, signed int port, signed int (*callback)(signed int, void *), void *data);
// create_listen_ports::callback_object
//
signed int callback_object(signed int, void *);
// create_ordered_work_queue
// file work.c line 440
struct work_queue * create_ordered_work_queue(const char *name);
// create_unix_domain_socket
// file net.c line 536
signed int create_unix_domain_socket(const char *unix_path, signed int (*callback)(signed int, void *), void *data);
// create_unix_domain_socket::callback_object
//
signed int callback_object(signed int, void *);
// create_work_queue
// file work.c line 404
struct work_queue * create_work_queue(const char *name, enum wq_thread_control tc);
// create_worker_threads
// file work.c line 249
static signed int create_worker_threads(struct wq_info *wi, unsigned long int nr_threads);
// daemon
// file /usr/include/unistd.h line 937
extern signed int daemon(signed int, signed int);
// data_is_missing
// file fec.c line 618
static inline _Bool data_is_missing(const unsigned char **dp, signed int d);
// data_to_str
// file util.c line 417
const char * data_to_str(void *data, unsigned long int data_length);
// decode_prepare
// file fec.c line 591
static inline void decode_prepare(struct fec *ctx, const unsigned char **dp, const unsigned char **out, signed int *outidx);
// destroy_all_slots
// file sockfd_cache.c line 141
static inline void destroy_all_slots(struct sockfd_cache_entry *entry);
// dirname
// file /usr/include/libgen.h line 26
extern char * dirname(char *);
// do_event_loop
// file event.c line 190
static void do_event_loop(signed int timeout, _Bool sort_with_prio);
// do_grow_fds
// file sockfd_cache.c line 247
static void do_grow_fds(struct work *work);
// do_nothing
// file util.c line 28
static void do_nothing(unsigned long int size);
// do_read
// file net.c line 213
signed int do_read(signed int sockfd, void *buf, signed int len, _Bool (*need_retry)(unsigned int), unsigned int epoch, unsigned int max_count);
// do_read::need_retry_object
//
_Bool need_retry_object(unsigned int);
// do_write
// file net.c line 261
static signed int do_write(signed int sockfd, struct msghdr *msg, signed int len, _Bool (*need_retry)(unsigned int), unsigned int epoch, unsigned int max_count);
// do_write::need_retry_object
//
_Bool need_retry_object(unsigned int);
// do_writev2
// file ../include/net.h line 65
signed int do_writev2(signed int fd, void *hdr, unsigned long int hdr_len, void *body, unsigned long int body_len);
// dolog
// file logger.c line 395
static void dolog(signed int prio, const char *func, signed int line, const char *fmt, void **ap);
// dump_btree
// file sd_inode.c line 209
static void dump_btree(signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode);
// dump_btree::reader_object
//
signed int reader_object(unsigned long int, void **, unsigned int, unsigned long int);
// dump_stack_frames
// file logger.c line 800
static signed int dump_stack_frames(void);
// dup2
// file /usr/include/unistd.h line 534
extern signed int dup2(signed int, signed int);
// early_log_init
// file ../include/logger.h line 39
void early_log_init(const char *format_name, struct logger_user_info *user_info);
// ec_decode
// file fec.c line 635
void ec_decode(struct fec *ctx, const unsigned char **input, const signed int *inidx, unsigned char *output, signed int idx);
// ec_decode_buffer
// file fec.c line 690
void ec_decode_buffer(struct fec *ctx, unsigned char **input, const signed int *in_idx, char *buf, signed int idx);
// ec_encode
// file ../include/fec.h line 169
static inline void ec_encode(struct fec *ctx, const unsigned char **ds, unsigned char **ps);
// epoll_create
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 100
extern signed int epoll_create(signed int);
// epoll_ctl
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 113
extern signed int epoll_ctl(signed int, signed int, signed int, struct epoll_event *);
// epoll_event_cmp
// file event.c line 179
static signed int epoll_event_cmp(struct epoll_event *_a, struct epoll_event *_b);
// epoll_wait
// file /usr/include/x86_64-linux-gnu/sys/epoll.h line 127
extern signed int epoll_wait(signed int, struct epoll_event *, signed int, signed int);
// event_cmp
// file event.c line 74
static signed int event_cmp(struct event_info *e1, struct event_info *e2);
// event_force_refresh
// file ../include/event.h line 17
void event_force_refresh(void);
// event_loop
// file event.c line 218
void event_loop(signed int timeout);
// event_loop_prio
// file ../include/event.h line 16
void event_loop_prio(signed int timeout);
// eventfd
// file /usr/include/x86_64-linux-gnu/sys/eventfd.h line 34
extern signed int eventfd(unsigned int, signed int);
// eventfd_read
// file /usr/include/x86_64-linux-gnu/sys/eventfd.h line 37
extern signed int eventfd_read(signed int, unsigned long int *);
// eventfd_write
// file /usr/include/x86_64-linux-gnu/sys/eventfd.h line 40
extern signed int eventfd_write(signed int, unsigned long int);
// eventfd_xread
// file ../include/util.h line 103
signed int eventfd_xread(signed int efd);
// eventfd_xwrite
// file ../include/util.h line 104
void eventfd_xwrite(signed int efd, signed int value);
// exec_req
// file net.c line 326
signed int exec_req(signed int sockfd, struct sd_req *hdr, void *data, _Bool (*need_retry)(unsigned int), unsigned int epoch, unsigned int max_count);
// exec_req::need_retry_object
//
_Bool need_retry_object(unsigned int);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// exit_handler
// file shepherd.c line 624
static void exit_handler(void);
// ext_in_range
// file sd_inode.c line 252
static _Bool ext_in_range(struct sd_extent_header *header, struct sd_extent *ext);
// extent_comp
// file sd_inode.c line 108
static signed int extent_comp(void *a, void *b);
// fallocate
// file /usr/include/x86_64-linux-gnu/bits/fcntl-linux.h line 407
extern signed int fallocate(signed int, signed int, signed long int, signed long int);
// fec_decode
// file fec.c line 555
void fec_decode(struct fec *code, const unsigned char * const * const inpkts, unsigned char * const * const outpkts, const signed int * const idx, unsigned long int sz);
// fec_encode
// file fec.c line 508
void fec_encode(struct fec *code, const unsigned char * const * const src, unsigned char * const * const fecs, const signed int * const block_nums, unsigned long int num_block_nums, unsigned long int sz);
// fec_free
// file fec.c line 452
void fec_free(struct fec *p);
// fec_new
// file fec.c line 460
struct fec * fec_new(unsigned short int d, unsigned short int dp);
// feof
// file /usr/include/stdio.h line 828
extern signed int feof(struct _IO_FILE *);
// fflush
// file /usr/include/stdio.h line 242
extern signed int fflush(struct _IO_FILE *);
// fgetc
// file /usr/include/stdio.h line 531
extern signed int fgetc(struct _IO_FILE *);
// fgets
// file /usr/include/stdio.h line 622
extern char * fgets(char *, signed int, struct _IO_FILE *);
// fileno
// file /usr/include/stdio.h line 858
extern signed int fileno(struct _IO_FILE *);
// find_sheep_by_nid
// file shepherd.c line 90
static struct sheep * find_sheep_by_nid(struct node_id *id);
// fork
// file /usr/include/unistd.h line 756
extern signed int fork(void);
// format_thread_name
// file logger.c line 156
static const char * format_thread_name(char *str, unsigned long int size, const char *name, signed int idx);
// forward_iov
// file net.c line 248
static void forward_iov(struct msghdr *msg, signed int len);
// fread
// file /usr/include/stdio.h line 709
extern unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// free_cache_entry
// file sockfd_cache.c line 149
static void free_cache_entry(struct sockfd_cache_entry *entry);
// free_logarea
// file logger.c line 350
static void free_logarea(void);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// freeifaddrs
// file /usr/include/ifaddrs.h line 69
extern void freeifaddrs(struct ifaddrs *);
// ftruncate
// file /usr/include/unistd.h line 1016
extern signed int ftruncate(signed int, signed long int);
// gdb_cmd
// file logger.c line 760
static signed int gdb_cmd(const char *cmd);
// generate_gf
// file fec.c line 143
static void generate_gf(void);
// get_buffer_sha1
// file sha1.c line 337
void get_buffer_sha1(unsigned char *buf, unsigned int len, unsigned char *sha1);
// get_free_slot
// file sockfd_cache.c line 94
static inline signed int get_free_slot(struct sockfd_cache_entry *entry);
// get_local_addr
// file net.c line 493
signed int get_local_addr(unsigned char *bytes);
// get_loglevel
// file logger.c line 861
signed int get_loglevel(void);
// get_msec_time
// file work.c line 194
static unsigned long int get_msec_time(void);
// get_thread_name
// file logger.c line 745
void get_thread_name(char *name);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getifaddrs
// file /usr/include/ifaddrs.h line 66
extern signed int getifaddrs(struct ifaddrs **);
// getnameinfo
// file /usr/include/netdb.h line 677
extern signed int getnameinfo(struct sockaddr *, unsigned int, char *, unsigned int, char *, unsigned int, signed int);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getppid
// file /usr/include/unistd.h line 631
extern signed int getppid(void);
// gettid
// file ../include/util.h line 114
signed int gettid(void);
// gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 71
extern signed int gettimeofday(struct timeval *, struct timezone *);
// getxattr
// file /usr/include/x86_64-linux-gnu/sys/xattr.h line 59
extern signed long int getxattr(const char *, const char *, void *, unsigned long int);
// grow_fds_done
// file sockfd_cache.c line 270
static void grow_fds_done(struct work *work);
// idx_in_range
// file sd_inode.c line 261
static _Bool idx_in_range(struct sd_extent_header *header, struct sd_extent_idx *idx);
// index_comp
// file sd_inode.c line 122
static signed int index_comp(void *a, void *b);
// inet_ntop
// file /usr/include/arpa/inet.h line 64
extern const char * inet_ntop(signed int, const void *, char *, unsigned int);
// inet_pton
// file /usr/include/arpa/inet.h line 58
extern signed int inet_pton(signed int, const char *, void *);
// inetaddr_is_valid
// file net.c line 574
_Bool inetaddr_is_valid(char *addr);
// init_event
// file ../include/event.h line 11
signed int init_event(signed int nr);
// init_fec
// file fec.c line 438
void init_fec(void);
// init_logmsg
// file logger.c line 381
static void init_logmsg(struct logmsg *msg, struct timeval *tv, signed int prio, const char *func, signed int line);
// init_work_queue
// file work.c line 364
signed int init_work_queue(unsigned long int (*get_nr_nodes)(void));
// init_work_queue::get_nr_nodes_object
//
unsigned long int get_nr_nodes_object(void);
// insert_ext_entry_nosearch
// file sd_inode.c line 290
static void insert_ext_entry_nosearch(struct sd_extent_header *header, struct sd_extent *ext, unsigned int idx, unsigned int vdi_id);
// insert_idx_entry
// file sd_inode.c line 314
static void insert_idx_entry(struct sd_extent_header *header, unsigned int idx, unsigned long int oid);
// insert_idx_entry_nosearch
// file sd_inode.c line 302
static void insert_idx_entry_nosearch(struct sd_extent_header *header, struct sd_extent_idx *idx_ext, unsigned int idx, unsigned long int oid);
// insert_new_node
// file sd_inode.c line 499
static signed int insert_new_node(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, struct find_path *path, unsigned int idx, unsigned int vdi_id);
// insert_new_node::reader_object
//
signed int reader_object(unsigned long int, void **, unsigned int, unsigned long int);
// insert_new_node::writer_object
//
signed int writer_object(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool);
// install_crash_handler
// file ../include/util.h line 112
signed int install_crash_handler(void (*handler)(signed int));
// install_crash_handler::handler_object
//
void handler_object(signed int);
// install_sighandler
// file ../include/util.h line 111
signed int install_sighandler(signed int signum, void (*handler)(signed int), _Bool once);
// install_sighandler::handler_object
//
void handler_object(signed int);
// is_numeric
// file util.c line 399
_Bool is_numeric(const char *s);
// is_sd_node_zero
// file shepherd.c line 68
static _Bool is_sd_node_zero(struct sd_node *node);
// is_sheep_dead
// file logger.c line 529
static _Bool is_sheep_dead(signed int signo);
// is_stdout_console
// file ../include/util.h line 493
static inline _Bool is_stdout_console(void);
// is_xattr_enabled
// file util.c line 487
_Bool is_xattr_enabled(const char *path);
// isatty
// file /usr/include/unistd.h line 779
extern signed int isatty(signed int);
// kill
// file /usr/include/signal.h line 127
extern signed int kill(signed int, signed int);
// list_add
// file ../include/list.h line 82
static inline void list_add(struct list_node *new, struct list_head *head);
// list_add_link1
// file ../include/list.h line 82
static inline void list_add_link1(struct list_node *new_link1, struct list_head *head_link1);
// list_add_tail
// file ../include/list.h line 87
static inline void list_add_tail(struct list_node *new, struct list_head *head);
// list_add_tail_link1
// file ../include/list.h line 87
static inline void list_add_tail_link1(struct list_node *new_link1, struct list_head *head_link1);
// list_del
// file ../include/list.h line 103
static inline void list_del(struct list_node *entry);
// list_del_link1
// file ../include/list.h line 103
static inline void list_del_link1(struct list_node *entry_link1);
// list_empty
// file ../include/list.h line 42
static inline _Bool list_empty(struct list_head *head);
// list_empty_link1
// file ../include/list.h line 42
static inline _Bool list_empty_link1(struct list_head *head_link1);
// list_empty_link2
// file ../include/list.h line 42
static inline _Bool list_empty_link2(struct list_head *head_link2);
// list_sort
// file util.c line 700
void list_sort(void *priv, struct list_head *head, signed int (*cmp)(void *, struct list_node *, struct list_node *));
// list_sort::cmp_object
//
signed int cmp_object(void *, struct list_node *, struct list_node *);
// list_splice_init
// file ../include/list.h line 136
static inline void list_splice_init(struct list_head *list, struct list_head *head);
// listen
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 233
extern signed int listen(signed int, signed int);
// localtime_r
// file /usr/include/time.h line 254
extern struct tm * localtime_r(const signed long int *, struct tm *);
// log_close
// file logger.c line 712
void log_close(void);
// log_flush
// file logger.c line 494
static void log_flush(void);
// log_init
// file ../include/logger.h line 41
signed int log_init(const char *program_name, enum log_dst_type type, signed int level, char *outfile);
// log_syslog
// file logger.c line 360
static void log_syslog(struct logmsg *msg);
// log_write
// file ../include/logger.h line 45
void log_write(signed int prio, const char *func, signed int line, const char *fmt, ...);
// logarea_init
// file logger.c line 289
static signed int logarea_init(signed int size);
// logger
// file logger.c line 560
static void logger(char *log_dir, char *outfile);
// lookup_event
// file event.c line 92
static struct event_info * lookup_event(signed int fd);
// lseek
// file /usr/include/unistd.h line 334
extern signed long int lseek(signed int, signed long int, signed int);
// make_path
// file util.c line 554
void make_path(char *path, unsigned long int size, unsigned long int nr_segs, const char **segs);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// memchr
// file /usr/include/string.h line 96
extern void * memchr(const void *, signed int, unsigned long int);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// mempcpy
// file /usr/include/string.h line 390
extern void * mempcpy(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// merge
// file util.c line 616
static struct list_node * merge(void *priv, signed int (*cmp)(void *, struct list_node *, struct list_node *), struct list_node *a, struct list_node *b);
// merge::cmp_object
//
signed int cmp_object(void *, struct list_node *, struct list_node *);
// merge_and_restore_back_links
// file util.c line 646
static void merge_and_restore_back_links(void *priv, signed int (*cmp)(void *, struct list_node *, struct list_node *), struct list_head *head, struct list_node *a, struct list_node *b);
// merge_and_restore_back_links::cmp_object
//
signed int cmp_object(void *, struct list_node *, struct list_node *);
// mkdir
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 320
extern signed int mkdir(const char *, unsigned int);
// modify_event
// file event.c line 148
signed int modify_event(signed int fd, unsigned int new_events);
// modnn
// file fec.c line 89
static unsigned char modnn(signed int x);
// my_exe_path
// file ../include/util.h line 117
const char * my_exe_path(void);
// node_id_cmp
// file ../include/sheep.h line 186
static inline signed int node_id_cmp(struct node_id *node1, struct node_id *node2);
// node_id_cmp_link1
// file ../include/sheep.h line 186
static inline signed int node_id_cmp_link1(struct node_id *node1_link1, struct node_id *node2_link1);
// node_to_str
// file ../include/sheep.h line 244
static inline const char * node_to_str(struct sd_node *id);
// notify_remove_sheep
// file shepherd.c line 115
static signed int notify_remove_sheep(struct sheep *leaving);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// opendir
// file /usr/include/dirent.h line 134
extern struct __dirstream * opendir(const char *);
// openlog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 181
extern void openlog(const char *, signed int, signed int);
// option_get_help
// file option.c line 53
const char * option_get_help(struct sd_option *sd_opts, signed int ch);
// option_parse
// file option.c line 104
signed int option_parse(char *arg, const char *delim, struct option_parser *parsers);
// option_parse_size
// file option.c line 64
signed int option_parse_size(const char *value, unsigned long int *ret);
// pclose
// file /usr/include/stdio.h line 878
extern signed int pclose(struct _IO_FILE *);
// popen
// file /usr/include/stdio.h line 872
extern struct _IO_FILE * popen(const char *, const char *);
// pread
// file /usr/include/unistd.h line 376
extern signed long int pread(signed int, void *, unsigned long int, signed long int);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// pstrcpy
// file ../include/util.h line 105
void pstrcpy(char *buf, signed int buf_size, const char *str);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous_25 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_25 *, const union anonymous_23 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_25 *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_25 *, union anonymous_22 *);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_detach
// file /usr/include/pthread.h line 273
extern signed int pthread_detach(unsigned long int);
// pthread_exit
// file /usr/include/pthread.h line 244
extern void pthread_exit(void *);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_22 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_22 *, const union anonymous_23 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_22 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_22 *);
// pthread_rwlock_rdlock
// file /usr/include/pthread.h line 899
extern signed int pthread_rwlock_rdlock(union anonymous_28 *);
// pthread_rwlock_unlock
// file /usr/include/pthread.h line 929
extern signed int pthread_rwlock_unlock(union anonymous_28 *);
// pthread_rwlock_wrlock
// file /usr/include/pthread.h line 914
extern signed int pthread_rwlock_wrlock(union anonymous_28 *);
// pthread_self
// file /usr/include/pthread.h line 277
extern unsigned long int pthread_self(void);
// purge_directory
// file util.c line 346
signed int purge_directory(const char *dir_path);
// pwrite
// file /usr/include/unistd.h line 384
extern signed long int pwrite(signed int, const void *, unsigned long int, signed long int);
// qsort
// file /usr/include/stdlib.h line 764
extern void qsort(void *, unsigned long int, unsigned long int, signed int (*)(const void *, const void *));
// queue_work
// file work.c line 270
void queue_work(struct work_queue *q, struct work *work);
// raise
// file /usr/include/signal.h line 139
extern signed int raise(signed int);
// rand
// file /usr/include/stdlib.h line 374
extern signed int rand(void);
// random
// file /usr/include/stdlib.h line 321
extern signed long int random(void);
// rb_erase
// file ../include/rbtree.h line 57
void rb_erase(struct rb_node *node, struct rb_root *root);
// rb_first
// file rbtree.c line 255
struct rb_node * rb_first(struct rb_root *root);
// rb_insert_color
// file ../include/rbtree.h line 56
void rb_insert_color(struct rb_node *node, struct rb_root *root);
// rb_last
// file rbtree.c line 267
struct rb_node * rb_last(struct rb_root *root);
// rb_link_node
// file ../include/rbtree.h line 69
static inline void rb_link_node(struct rb_node *node, struct rb_node *parent, struct rb_node **rb_link);
// rb_link_node_link1
// file ../include/rbtree.h line 69
static inline void rb_link_node_link1(struct rb_node *node_link1, struct rb_node *parent_link1, struct rb_node **rb_link_link1);
// rb_next
// file rbtree.c line 279
struct rb_node * rb_next(struct rb_node *node);
// rb_prev
// file rbtree.c line 311
struct rb_node * rb_prev(struct rb_node *node);
// rb_replace_node
// file rbtree.c line 339
void rb_replace_node(struct rb_node *victim, struct rb_node *new, struct rb_root *root);
// rb_set_color
// file ../include/rbtree.h line 31
static inline void rb_set_color(struct rb_node *rb, signed int color);
// rb_set_parent
// file ../include/rbtree.h line 27
static inline void rb_set_parent(struct rb_node *rb, struct rb_node *p);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// read_msg_from_sheep
// file shepherd.c line 519
static void read_msg_from_sheep(struct sheep *sheep);
// readdir
// file /usr/include/dirent.h line 162
extern struct dirent * readdir(struct __dirstream *);
// readlink
// file /usr/include/unistd.h line 809
extern signed long int readlink(const char *, char *, unsigned long int);
// realloc
// file /usr/include/stdlib.h line 480
extern void * realloc(void *, unsigned long int);
// register_event
// file ../include/event.h line 30
static inline signed int register_event(signed int fd, void (*h)(signed int, signed int, void *), void *data);
// register_event_link1
// file ../include/event.h line 30
static inline signed int register_event_link1(signed int fd_link1, void (*h_link1)(signed int, signed int, void *), void *data_link1);
// register_event_link2
// file ../include/event.h line 30
static inline signed int register_event_link2(signed int fd_link2, void (*h_link2)(signed int, signed int, void *), void *data_link2);
// register_event::h_link1_object
//
void h_link1_object(signed int, signed int, void *);
// register_event::h_link2_object
//
void h_link2_object(signed int, signed int, void *);
// register_event::h_object
//
void h_object(signed int, signed int, void *);
// register_event_prio
// file ../include/event.h line 12
signed int register_event_prio(signed int fd, void (*h)(signed int, signed int, void *), void *data, signed int prio);
// register_event_prio::h_object
//
void h_object(signed int, signed int, void *);
// release_joining_sheep
// file shepherd.c line 195
static signed int release_joining_sheep(void);
// remove_handler
// file shepherd.c line 142
static void remove_handler(signed int fd, signed int events, void *data);
// remove_sheep
// file shepherd.c line 104
static inline void remove_sheep(struct sheep *sheep);
// rename
// file /usr/include/stdio.h line 180
extern signed int rename(const char *, const char *);
// reraise_crash_signal
// file ../include/util.h line 113
void reraise_crash_signal(signed int signo, signed int status);
// revalidate_node
// file sockfd_cache.c line 293
static inline signed int revalidate_node(struct node_id *nid);
// rmdir
// file /usr/include/unistd.h line 835
extern signed int rmdir(const char *);
// rmdir_r
// file util.c line 388
signed int rmdir_r(const char *dir_path);
// rotate_log
// file logger.c line 453
static void rotate_log(void);
// sd_backtrace
// file ../include/logger.h line 54
void sd_backtrace(void);
// sd_cond_init
// file ../include/util.h line 348
static inline void sd_cond_init(struct sd_cond *cond);
// sd_cond_signal
// file ../include/util.h line 373
static inline signed int sd_cond_signal(struct sd_cond *cond);
// sd_cond_wait
// file ../include/util.h line 378
static inline signed int sd_cond_wait(struct sd_cond *cond, struct sd_mutex *mutex);
// sd_destroy_cond
// file ../include/util.h line 361
static inline void sd_destroy_cond(struct sd_cond *cond);
// sd_destroy_mutex
// file ../include/util.h line 299
static inline void sd_destroy_mutex(struct sd_mutex *mutex);
// sd_init_mutex
// file ../include/util.h line 273
static inline void sd_init_mutex(struct sd_mutex *mutex);
// sd_inode_copy_vdis
// file sd_inode.c line 700
extern void sd_inode_copy_vdis(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), unsigned int *data_vdi_id, unsigned char store_policy, unsigned char nr_copies, unsigned char copy_policy, struct sd_inode *newi);
// sd_inode_copy_vdis::reader_object
//
signed int reader_object(unsigned long int, void **, unsigned int, unsigned long int);
// sd_inode_copy_vdis::writer_object
//
signed int writer_object(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool);
// sd_inode_get_meta_size
// file sd_inode.c line 626
extern unsigned int sd_inode_get_meta_size(struct sd_inode *inode, unsigned long int size);
// sd_inode_get_vid
// file sd_inode.c line 443
extern unsigned int sd_inode_get_vid(signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, unsigned int idx);
// sd_inode_get_vid::reader_object
//
signed int reader_object(unsigned long int, void **, unsigned int, unsigned long int);
// sd_inode_init
// file sd_inode.c line 243
extern void sd_inode_init(void *data, signed int depth);
// sd_inode_set_vid
// file sd_inode.c line 566
extern void sd_inode_set_vid(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, unsigned int idx, unsigned int vdi_id);
// sd_inode_set_vid::reader_object
//
signed int reader_object(unsigned long int, void **, unsigned int, unsigned long int);
// sd_inode_set_vid::writer_object
//
signed int writer_object(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool);
// sd_inode_write
// file sd_inode.c line 650
extern signed int sd_inode_write(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), struct sd_inode *inode, signed int flags, _Bool create, _Bool direct);
// sd_inode_write::writer_object
//
signed int writer_object(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool);
// sd_inode_write_vid
// file sd_inode.c line 679
extern signed int sd_inode_write_vid(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), struct sd_inode *inode, unsigned int idx, unsigned int vid, unsigned int value, signed int flags, _Bool create, _Bool direct);
// sd_inode_write_vid::writer_object
//
signed int writer_object(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool);
// sd_mutex_lock
// file ../include/util.h line 311
static inline void sd_mutex_lock(struct sd_mutex *mutex);
// sd_mutex_unlock
// file ../include/util.h line 328
static inline void sd_mutex_unlock(struct sd_mutex *mutex);
// sd_read_lock
// file ../include/util.h line 429
static inline void sd_read_lock(struct sd_rw_lock *lock);
// sd_rw_unlock
// file ../include/util.h line 457
static inline void sd_rw_unlock(struct sd_rw_lock *lock);
// sd_write_lock
// file ../include/util.h line 445
static inline void sd_write_lock(struct sd_rw_lock *lock);
// search_ext_entry
// file sd_inode.c line 271
static struct sd_extent * search_ext_entry(struct sd_extent_header *header, unsigned int idx);
// search_idx_entry
// file sd_inode.c line 281
static struct sd_extent_idx * search_idx_entry(struct sd_extent_header *header, unsigned int idx);
// search_whole_btree
// file sd_inode.c line 392
static signed int search_whole_btree(signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, unsigned int idx, struct find_path *path);
// search_whole_btree::reader_object
//
signed int reader_object(unsigned long int, void **, unsigned int, unsigned long int);
// semctl
// file /usr/include/x86_64-linux-gnu/sys/sem.h line 52
extern signed int semctl(signed int, signed int, signed int, ...);
// semget
// file /usr/include/x86_64-linux-gnu/sys/sem.h line 55
extern signed int semget(signed int, signed int, signed int);
// semop
// file /usr/include/x86_64-linux-gnu/sys/sem.h line 58
extern signed int semop(signed int, struct sembuf *, unsigned long int);
// send_req
// file net.c line 294
signed int send_req(signed int sockfd, struct sd_req *hdr, void *data, unsigned int wlen, _Bool (*need_retry)(unsigned int), unsigned int epoch, unsigned int max_count);
// send_req::need_retry_object
//
_Bool need_retry_object(unsigned int);
// sendmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 184
extern signed long int sendmsg(signed int, struct msghdr *, signed int);
// set_keepalive
// file ../include/net.h line 60
signed int set_keepalive(signed int fd);
// set_listen_fd_cb
// file shepherd.c line 629
static signed int set_listen_fd_cb(signed int fd, void *data);
// set_loglevel
// file logger.c line 855
void set_loglevel(signed int new_loglevel);
// set_nodelay
// file net.c line 452
signed int set_nodelay(signed int fd);
// set_rcv_timeout
// file net.c line 438
signed int set_rcv_timeout(signed int fd);
// set_snd_timeout
// file net.c line 427
signed int set_snd_timeout(signed int fd);
// set_thread_name
// file logger.c line 738
void set_thread_name(const char *name, _Bool show_idx);
// set_try_to_free_routine
// file util.c line 34
void (*set_try_to_free_routine(void (*routine)(unsigned long int)))(unsigned long int);
// set_try_to_free_routine::1::old_object
//
void old_object(unsigned long int);
// set_try_to_free_routine::routine_object
//
void routine_object(unsigned long int);
// setsid
// file /usr/include/unistd.h line 667
extern signed int setsid(void);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// sha1_final_object
//
void sha1_final_object(void *, unsigned char *);
// sha1_init_object
//
void sha1_init_object(void *);
// sha1_to_hex
// file sha1.c line 322
const char * sha1_to_hex(const unsigned char *sha1);
// sha1_update_object
//
void sha1_update_object(void *, const unsigned char *, unsigned int);
// sheep_accept_handler
// file shepherd.c line 561
static void sheep_accept_handler(signed int fd, signed int events, void *data);
// sheep_comm_handler
// file shepherd.c line 550
static void sheep_comm_handler(signed int fd, signed int events, void *data);
// shmat
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 56
extern void * shmat(signed int, const void *, signed int);
// shmctl
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 50
extern signed int shmctl(signed int, signed int, struct shmid_ds *);
// shmdt
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 60
extern signed int shmdt(const void *);
// shmget
// file /usr/include/x86_64-linux-gnu/sys/shm.h line 53
extern signed int shmget(signed int, unsigned long int, signed int);
// sigaction
// file /usr/include/signal.h line 259
extern signed int sigaction(signed int, struct sigaction *, struct sigaction *);
// sigaddset
// file /usr/include/signal.h line 221
extern signed int sigaddset(struct anonymous_0 *, signed int);
// sigemptyset
// file /usr/include/signal.h line 215
extern signed int sigemptyset(struct anonymous_0 *);
// sighup_handler
// file logger.c line 555
static void sighup_handler(signed int signo);
// sigprocmask
// file /usr/include/signal.h line 248
extern signed int sigprocmask(signed int, const struct anonymous_0 *, struct anonymous_0 *);
// sleep
// file /usr/include/unistd.h line 444
extern unsigned int sleep(unsigned int);
// slots_all_free
// file sockfd_cache.c line 132
static inline _Bool slots_all_free(struct sockfd_cache_entry *entry);
// snprintf
// file /usr/include/stdio.h line 386
extern signed int snprintf(char *, unsigned long int, const char *, ...);
// sockaddr_in_to_str
// file ../include/net.h line 58
char * sockaddr_in_to_str(struct sockaddr_in *sockaddr);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// sockfd_cache_add
// file sockfd_cache.c line 220
void sockfd_cache_add(struct node_id *nid);
// sockfd_cache_add_group
// file sockfd_cache.c line 208
void sockfd_cache_add_group(struct rb_root *nroot);
// sockfd_cache_add_nolock
// file sockfd_cache.c line 190
static void sockfd_cache_add_nolock(struct node_id *nid);
// sockfd_cache_close
// file sockfd_cache.c line 381
static void sockfd_cache_close(struct node_id *nid, signed int idx);
// sockfd_cache_cmp
// file sockfd_cache.c line 75
static signed int sockfd_cache_cmp(struct sockfd_cache_entry *a, struct sockfd_cache_entry *b);
// sockfd_cache_del
// file sockfd_cache.c line 485
void sockfd_cache_del(struct node_id *nid, struct sockfd *sfd);
// sockfd_cache_del_node
// file sockfd_cache.c line 467
void sockfd_cache_del_node(struct node_id *nid);
// sockfd_cache_destroy
// file sockfd_cache.c line 162
static _Bool sockfd_cache_destroy(struct node_id *nid);
// sockfd_cache_get
// file sockfd_cache.c line 425
struct sockfd * sockfd_cache_get(struct node_id *nid);
// sockfd_cache_get_long
// file sockfd_cache.c line 313
static struct sockfd * sockfd_cache_get_long(struct node_id *nid);
// sockfd_cache_grab
// file sockfd_cache.c line 112
static struct sockfd_cache_entry * sockfd_cache_grab(struct node_id *nid, signed int *ret_idx);
// sockfd_cache_insert
// file sockfd_cache.c line 82
static struct sockfd_cache_entry * sockfd_cache_insert(struct sockfd_cache_entry *new);
// sockfd_cache_put
// file sockfd_cache.c line 453
void sockfd_cache_put(struct node_id *nid, struct sockfd *sfd);
// sockfd_cache_put_long
// file sockfd_cache.c line 365
static void sockfd_cache_put_long(struct node_id *nid, signed int idx);
// sockfd_cache_search
// file sockfd_cache.c line 87
static struct sockfd_cache_entry * sockfd_cache_search(struct node_id *nid);
// sockfd_init
// file sockfd_cache.c line 404
signed int sockfd_init(void);
// sph_cli_msg_to_str
// file ../include/shepherd.h line 74
static inline const char * sph_cli_msg_to_str(enum sph_cli_msg_type msg);
// sph_handle_accept
// file shepherd.c line 289
static void sph_handle_accept(struct sph_msg *msg, struct sheep *sheep);
// sph_handle_block
// file shepherd.c line 447
static void sph_handle_block(struct sph_msg *msg, struct sheep *sheep);
// sph_handle_join
// file shepherd.c line 228
static void sph_handle_join(struct sph_msg *msg, struct sheep *sheep);
// sph_handle_leave
// file shepherd.c line 480
static void sph_handle_leave(struct sph_msg *msg, struct sheep *sheep);
// sph_handle_notify
// file shepherd.c line 392
static void sph_handle_notify(struct sph_msg *msg, struct sheep *sheep);
// split_ext_node
// file sd_inode.c line 471
static void split_ext_node(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), struct sd_inode *inode, struct find_path *path);
// split_ext_node::writer_object
//
signed int writer_object(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool);
// split_path
// file util.c line 525
signed int split_path(const char *path, unsigned long int nr_segs, char **segs);
// split_to_nodes
// file sd_inode.c line 335
static void split_to_nodes(struct sd_extent_header *src, struct sd_extent_header *left, struct sd_extent_header *right, signed int num);
// stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 208
extern signed int stat(const char *, struct stat *);
// str_to_addr
// file net.c line 413
unsigned char * str_to_addr(const char *ipstr, unsigned char *addr);
// strbuf_add
// file strbuf.c line 101
void strbuf_add(struct strbuf *sb, const void *data, unsigned long int len);
// strbuf_addf
// file strbuf.c line 108
void strbuf_addf(struct strbuf *sb, const char *fmt, ...);
// strbuf_attach
// file strbuf.c line 43
void strbuf_attach(struct strbuf *sb, void *buf, unsigned long int len, unsigned long int alloc);
// strbuf_avail
// file ../include/strbuf.h line 49
static inline unsigned long int strbuf_avail(struct strbuf *sb);
// strbuf_copyout
// file strbuf.c line 193
signed int strbuf_copyout(struct strbuf *sb, void *buf, unsigned long int len);
// strbuf_detach
// file strbuf.c line 36
char * strbuf_detach(struct strbuf *sb);
// strbuf_fread
// file strbuf.c line 129
unsigned long int strbuf_fread(struct strbuf *sb, unsigned long int size, struct _IO_FILE *f);
// strbuf_getline
// file strbuf.c line 184
signed int strbuf_getline(struct strbuf *sb, struct _IO_FILE *fp, signed int term);
// strbuf_getwholeline
// file strbuf.c line 163
static signed int strbuf_getwholeline(struct strbuf *sb, struct _IO_FILE *fp, signed int term);
// strbuf_grow
// file strbuf.c line 53
void strbuf_grow(struct strbuf *sb, unsigned long int extra);
// strbuf_init
// file strbuf.c line 16
void strbuf_init(struct strbuf *sb, unsigned long int hint);
// strbuf_insert
// file strbuf.c line 67
void strbuf_insert(struct strbuf *sb, unsigned long int pos, const void *data, unsigned long int len);
// strbuf_read
// file strbuf.c line 140
signed long int strbuf_read(struct strbuf *sb, signed int fd, unsigned long int hint);
// strbuf_release
// file strbuf.c line 23
void strbuf_release(struct strbuf *sb);
// strbuf_remove
// file strbuf.c line 96
void strbuf_remove(struct strbuf *sb, unsigned long int pos, unsigned long int len);
// strbuf_reset
// file strbuf.c line 29
void strbuf_reset(struct strbuf *sb);
// strbuf_rtrim
// file strbuf.c line 60
void strbuf_rtrim(struct strbuf *sb);
// strbuf_setlen
// file ../include/strbuf.h line 53
static inline void strbuf_setlen(struct strbuf *sb, unsigned long int len);
// strbuf_splice
// file strbuf.c line 77
void strbuf_splice(struct strbuf *sb, unsigned long int pos, unsigned long int len, const void *data, unsigned long int dlen);
// strbuf_stripout
// file strbuf.c line 201
signed int strbuf_stripout(struct strbuf *sb, void *buf, unsigned long int len);
// strchr
// file /usr/include/string.h line 235
extern char * strchr(const char *, signed int);
// strchrnul
// file /usr/include/string.h line 276
extern char * strchrnul(const char *, signed int);
// strcmp
// file /usr/include/string.h line 144
extern signed int strcmp(const char *, const char *);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strerror
// file /usr/include/string.h line 412
extern char * strerror(signed int);
// strftime
// file /usr/include/time.h line 205
extern unsigned long int strftime(char *, unsigned long int, const char *, struct tm *);
// strlen
// file /usr/include/string.h line 398
extern unsigned long int strlen(const char *);
// strncmp
// file /usr/include/string.h line 147
extern signed int strncmp(const char *, const char *, unsigned long int);
// strsignal
// file /usr/include/string.h line 563
extern char * strsignal(signed int);
// strstr
// file /usr/include/string.h line 341
extern char * strstr(const char *, const char *);
// strtod
// file /usr/include/stdlib.h line 164
extern double strtod(const char *, char ** restrict );
// strtok_r
// file /usr/include/string.h line 358
extern char * strtok_r(char *, const char *, char ** restrict );
// strtol
// file /usr/include/stdlib.h line 183
extern signed long int strtol(const char *, char ** restrict , signed int);
// syscall
// file /usr/include/unistd.h line 1058
extern signed long int syscall(signed long int, ...);
// sysconf
// file /usr/include/unistd.h line 619
extern signed long int sysconf(signed int);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// system
// file /usr/include/stdlib.h line 716
extern signed int system(const char *);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// timer_handler
// file event.c line 25
static void timer_handler(signed int fd, signed int events, void *data);
// timerfd_create
// file /usr/include/x86_64-linux-gnu/sys/timerfd.h line 38
extern signed int timerfd_create(signed int, signed int);
// timerfd_settime
// file /usr/include/x86_64-linux-gnu/sys/timerfd.h line 43
extern signed int timerfd_settime(signed int, signed int, struct itimerspec *, struct itimerspec *);
// tkill
// file util.c line 482
signed int tkill(signed int tid, signed int sig);
// trace_clear_tid_map
// file work.c line 190
static inline void trace_clear_tid_map(signed int tid);
// trace_set_tid_map
// file work.c line 189
static inline void trace_set_tid_map(signed int tid);
// transfer_to_idx_root
// file sd_inode.c line 355
static void transfer_to_idx_root(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), struct sd_inode *inode);
// transfer_to_idx_root::writer_object
//
signed int writer_object(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool);
// traverse_btree
// file sd_inode.c line 139
extern void traverse_btree(signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, void (*fn)(void *, enum btree_node_type, void *), void *arg);
// traverse_btree::fn_object
//
void fn_object(void *, enum btree_node_type, void *);
// traverse_btree::reader_object
//
signed int reader_object(unsigned long int, void **, unsigned int, unsigned long int);
// try_to_free_routine_object
//
void try_to_free_routine_object(unsigned long int);
// uatomic_is_true
// file ../include/util.h line 206
static inline _Bool uatomic_is_true(struct anonymous_29 *val);
// uatomic_set_false
// file ../include/util.h line 217
static inline void uatomic_set_false(struct anonymous_29 *val);
// uatomic_set_true
// file ../include/util.h line 212
static inline _Bool uatomic_set_true(struct anonymous_29 *val);
// unblock_sighup
// file logger.c line 143
static void unblock_sighup(void);
// unlink
// file /usr/include/unistd.h line 826
extern signed int unlink(const char *);
// unregister_event
// file ../include/event.h line 13
void unregister_event(signed int fd);
// usage
// file shepherd.c line 610
static void usage(void);
// usleep
// file /usr/include/unistd.h line 460
extern signed int usleep(unsigned int);
// valloc
// file /usr/include/stdlib.h line 498
extern void * valloc(unsigned long int);
// vid_to_btree_oid
// file ../include/sheepdog_proto.h line 455
static inline unsigned long int vid_to_btree_oid(unsigned int vid, unsigned int btreeid);
// vid_to_vdi_oid
// file ../include/sheepdog_proto.h line 435
static inline unsigned long int vid_to_vdi_oid(unsigned int vid);
// vsnprintf
// file /usr/include/stdio.h line 390
extern signed int vsnprintf(char *, unsigned long int, const char *, void **);
// waitpid
// file /usr/include/x86_64-linux-gnu/sys/wait.h line 125
extern signed int waitpid(signed int, signed int *, signed int);
// work_queue_empty
// file work.c line 445
_Bool work_queue_empty(struct work_queue *q);
// worker_routine
// file work.c line 313
static void * worker_routine(void *arg);
// worker_thread_request_done
// file work.c line 287
static void worker_thread_request_done(signed int fd, signed int events, void *data);
// wq_get_nr_nodes_object
//
unsigned long int wq_get_nr_nodes_object(void);
// wq_get_roof
// file work.c line 202
static inline unsigned long int wq_get_roof(struct wq_info *wi);
// wq_need_grow
// file work.c line 222
static _Bool wq_need_grow(struct wq_info *wi);
// wq_need_shrink
// file work.c line 238
static _Bool wq_need_shrink(struct wq_info *wi);
// wq_trace_init
// file work.c line 188
static inline signed int wq_trace_init(void);
// write
// file /usr/include/unistd.h line 366
extern signed long int write(signed int, const void *, unsigned long int);
// writev
// file /usr/include/x86_64-linux-gnu/sys/uio.h line 50
extern signed long int writev(signed int, struct iovec *, signed int);
// xcalloc
// file ../include/util.h line 94
void * xcalloc(unsigned long int nmemb, unsigned long int size);
// xfallocate
// file util.c line 252
signed int xfallocate(signed int fd, signed int mode, signed long int offset, signed long int len);
// xftruncate
// file util.c line 263
signed int xftruncate(signed int fd, signed long int length);
// xmalloc
// file util.c line 43
void * xmalloc(unsigned long int size);
// xmkdir
// file util.c line 233
signed int xmkdir(const char *pathname, unsigned int mode);
// xpread
// file util.c line 190
signed long int xpread(signed int fd, void *buf, unsigned long int count, signed long int offset);
// xpwrite
// file util.c line 210
signed long int xpwrite(signed int fd, const void *buf, unsigned long int count, signed long int offset);
// xread
// file ../include/util.h line 96
signed long int xread(signed int fd, void *buf, unsigned long int count);
// xrealloc
// file util.c line 64
void * xrealloc(void *ptr, unsigned long int size);
// xvalloc
// file util.c line 97
void * xvalloc(unsigned long int size);
// xwrite
// file ../include/util.h line 97
signed long int xwrite(signed int fd, const void *buf, unsigned long int count);
// xzalloc
// file ../include/util.h line 92
void * xzalloc(unsigned long int size);

struct anonymous_15
{
  // _call_addr
  void *_call_addr;
  // _syscall
  signed int _syscall;
  // _arch
  unsigned int _arch;
};

struct anonymous_12
{
  // si_addr
  void *si_addr;
  // si_addr_lsb
  signed short int si_addr_lsb;
};

struct anonymous_0
{
  // __val
  unsigned long int __val[16l];
};

struct anonymous_24
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_27
{
  // __lock
  signed int __lock;
  // __nr_readers
  unsigned int __nr_readers;
  // __readers_wakeup
  unsigned int __readers_wakeup;
  // __writer_wakeup
  unsigned int __writer_wakeup;
  // __nr_readers_queued
  unsigned int __nr_readers_queued;
  // __nr_writers_queued
  unsigned int __nr_writers_queued;
  // __writer
  signed int __writer;
  // __shared
  signed int __shared;
  // __rwelision
  signed char __rwelision;
  // __pad1
  unsigned char __pad1[7l];
  // __pad2
  unsigned long int __pad2;
  // __flags
  unsigned int __flags;
};

struct anonymous_8
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
};

struct anonymous_11
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_status
  signed int si_status;
  // si_utime
  signed long int si_utime;
  // si_stime
  signed long int si_stime;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct anonymous_10
{
  // si_pid
  signed int si_pid;
  // si_uid
  unsigned int si_uid;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_9
{
  // si_tid
  signed int si_tid;
  // si_overrun
  signed int si_overrun;
  // si_sigval
  union sigval si_sigval;
};

struct anonymous_14
{
  // si_band
  signed long int si_band;
  // si_fd
  signed int si_fd;
};

union anonymous_16
{
  // _pad
  signed int _pad[28l];
  // _kill
  struct anonymous_8 _kill;
  // _timer
  struct anonymous_9 _timer;
  // _rt
  struct anonymous_10 _rt;
  // _sigchld
  struct anonymous_11 _sigchld;
  // _sigfault
  struct anonymous_12 _sigfault;
  // _sigpoll
  struct anonymous_14 _sigpoll;
  // _sigsys
  struct anonymous_15 _sigsys;
};

struct anonymous_1
{
  // si_signo
  signed int si_signo;
  // si_errno
  signed int si_errno;
  // si_code
  signed int si_code;
  // _sifields
  union anonymous_16 _sifields;
};

struct anonymous_4
{
  // __pad
  unsigned int __pad;
  // nr_nodes
  unsigned int nr_nodes;
  // __reserved
  unsigned int __reserved[2l];
  // store_size
  unsigned long int store_size;
  // store_free
  unsigned long int store_free;
};

struct anonymous_3
{
  // __pad
  unsigned int __pad;
  // rsvd
  unsigned int rsvd;
  // vdi_id
  unsigned int vdi_id;
  // attr_id
  unsigned int attr_id;
  // copies
  unsigned char copies;
  // reserved
  unsigned char reserved[3l];
};

struct anonymous_2
{
  // __pad
  unsigned int __pad;
  // copies
  unsigned char copies;
  // reserved
  unsigned char reserved[3l];
  // offset
  unsigned long int offset;
};

struct anonymous_5
{
  // __pad1
  unsigned int __pad1;
  // __pad2
  unsigned int __pad2;
  // digest
  unsigned char digest[20l];
};

struct anonymous_20
{
  // old_vid
  unsigned int old_vid;
  // new_vid
  unsigned int new_vid;
  // copies
  unsigned char copies;
  // set_bitmap
  unsigned char set_bitmap;
  // copy_policy
  unsigned char copy_policy;
};

struct anonymous_17
{
  // oid
  unsigned long int oid;
  // cow_oid
  unsigned long int cow_oid;
  // copies
  unsigned char copies;
  // copy_policy
  unsigned char copy_policy;
  // ec_index
  unsigned char ec_index;
  // reserved
  unsigned char reserved;
  // tgt_epoch
  unsigned int tgt_epoch;
  // offset
  unsigned int offset;
  // __pad
  unsigned int __pad;
};

struct anonymous_19
{
  // oid
  unsigned long int oid;
  // ctime
  unsigned long int ctime;
  // copies
  unsigned char copies;
  // copy_policy
  unsigned char copy_policy;
  // flags
  unsigned short int flags;
  // tag
  unsigned int tag;
};

struct anonymous_29
{
  // val
  unsigned long int val;
};

struct anonymous_18
{
  // vdi_size
  unsigned long int vdi_size;
  // base_vdi_id
  unsigned int base_vdi_id;
  // copies
  unsigned char copies;
  // copy_policy
  unsigned char copy_policy;
  // store_policy
  unsigned char store_policy;
  // reserved
  unsigned char reserved;
  // snapid
  unsigned int snapid;
};

union anonymous_13
{
  // ifu_broadaddr
  struct sockaddr *ifu_broadaddr;
  // ifu_dstaddr
  struct sockaddr *ifu_dstaddr;
};

union anonymous
{
  // sa_handler
  void (*sa_handler)(signed int);
  // sa_sigaction
  void (*sa_sigaction)(signed int, struct anonymous_1 *, void *);
};

union anonymous_21
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

union anonymous_23
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_25
{
  // __data
  struct anonymous_24 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

union anonymous_28
{
  // __data
  struct anonymous_27 __data;
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

union anonymous_7
{
  // obj
  struct anonymous_17 obj;
  // vdi
  struct anonymous_18 vdi;
  // cluster
  struct anonymous_19 cluster;
  // vdi_state
  struct anonymous_20 vdi_state;
  // __pad
  unsigned int __pad[8l];
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_22
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

union anonymous_6
{
  // result
  unsigned int result;
  // obj
  struct anonymous_2 obj;
  // vdi
  struct anonymous_3 vdi;
  // node
  struct anonymous_4 node;
  // hash
  struct anonymous_5 hash;
  // __pad
  unsigned int __pad[8l];
};

union anonymous_30
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_31
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct __uatomic_dummy
{
  // v
  unsigned long int v[10l];
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct connection
{
  // fd
  signed int fd;
  // events
  unsigned int events;
  // port
  unsigned short int port;
  // ipstr
  char ipstr[46l];
  // dead
  _Bool dead;
};

struct dirent
{
  // d_ino
  unsigned long int d_ino;
  // d_off
  signed long int d_off;
  // d_reclen
  unsigned short int d_reclen;
  // d_type
  unsigned char d_type;
  // d_name
  char d_name[256l];
};

union epoll_data
{
  // ptr
  void *ptr;
  // fd
  signed int fd;
  // u32
  unsigned int u32;
  // u64
  unsigned long int u64;
};

struct epoll_event
{
  // events
  unsigned int events;
  // data
  union epoll_data data;
} __attribute__ ((__packed__));

struct rb_node
{
  // rb_parent_color
  unsigned long int rb_parent_color;
  // rb_right
  struct rb_node *rb_right;
  // rb_left
  struct rb_node *rb_left;
};

struct event_info
{
  // handler
  void (*handler)(signed int, signed int, void *);
  // fd
  signed int fd;
  // data
  void *data;
  // rb
  struct rb_node rb;
  // prio
  signed int prio;
};

struct fec
{
  // magic
  unsigned long int magic;
  // d
  unsigned short int d;
  // dp
  unsigned short int dp;
  // enc_matrix
  unsigned char *enc_matrix;
};

struct find_path
{
  // p_idx
  struct sd_extent_idx *p_idx;
  // p_ext
  struct sd_extent *p_ext;
  // p_ext_header
  struct sd_extent_header *p_ext_header;
  // depth
  signed int depth;
};

struct ifaddrs
{
  // ifa_next
  struct ifaddrs *ifa_next;
  // ifa_name
  char *ifa_name;
  // ifa_flags
  unsigned int ifa_flags;
  // ifa_addr
  struct sockaddr *ifa_addr;
  // ifa_netmask
  struct sockaddr *ifa_netmask;
  // ifa_ifu
  union anonymous_13 ifa_ifu;
  // ifa_data
  void *ifa_data;
};

struct in6_addr
{
  // __in6_u
  union anonymous_21 __in6_u;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct iovec
{
  // iov_base
  void *iov_base;
  // iov_len
  unsigned long int iov_len;
};

struct ipc_perm
{
  // __key
  signed int __key;
  // uid
  unsigned int uid;
  // gid
  unsigned int gid;
  // cuid
  unsigned int cuid;
  // cgid
  unsigned int cgid;
  // mode
  unsigned short int mode;
  // __pad1
  unsigned short int __pad1;
  // __seq
  unsigned short int __seq;
  // __pad2
  unsigned short int __pad2;
  // __glibc_reserved1
  unsigned long int __glibc_reserved1;
  // __glibc_reserved2
  unsigned long int __glibc_reserved2;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct itimerspec
{
  // it_interval
  struct timespec it_interval;
  // it_value
  struct timespec it_value;
};

struct linger
{
  // l_onoff
  signed int l_onoff;
  // l_linger
  signed int l_linger;
};

struct list_node
{
  // next
  struct list_node *next;
  // prev
  struct list_node *prev;
};

struct list_head
{
  // n
  struct list_node n;
};

struct log_format
{
  // name
  const char *name;
  // formatter
  signed int (*formatter)(char *, unsigned long int, struct logmsg *, _Bool);
  // list
  struct list_node list;
};

union semun
{
  // val
  signed int val;
  // buf
  struct semid_ds *buf;
  // array
  unsigned short int *array;
  // __buf
  struct seminfo *__buf;
};

struct logarea
{
  // active
  _Bool active;
  // tail
  char *tail;
  // start
  char *start;
  // end
  char *end;
  // semid
  signed int semid;
  // semarg
  union semun semarg;
  // fd
  signed int fd;
};

struct logger_user_info
{
  // port
  signed int port;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct logmsg
{
  // tv
  struct timeval tv;
  // prio
  signed int prio;
  // func
  char func[32l];
  // line
  signed int line;
  // worker_name
  char worker_name[20l];
  // worker_idx
  signed int worker_idx;
  // str_len
  unsigned long int str_len;
  // str
  char str[0l];
};

struct msghdr
{
  // msg_name
  void *msg_name;
  // msg_namelen
  unsigned int msg_namelen;
  // msg_iov
  struct iovec *msg_iov;
  // msg_iovlen
  unsigned long int msg_iovlen;
  // msg_control
  void *msg_control;
  // msg_controllen
  unsigned long int msg_controllen;
  // msg_flags
  signed int msg_flags;
};

struct node_id
{
  // addr
  unsigned char addr[16l];
  // port
  unsigned short int port;
  // io_addr
  unsigned char io_addr[16l];
  // io_port
  unsigned short int io_port;
  // pad
  unsigned char pad[4l];
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

struct option_parser
{
  // option
  const char *option;
  // parser
  signed int (*parser)(const char *);
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rb_root
{
  // rb_node
  struct rb_node *rb_node;
};

struct sd_cond
{
  // cond
  union anonymous_25 cond;
};

struct sd_extent
{
  // idx
  unsigned int idx;
  // vdi_id
  unsigned int vdi_id;
};

struct sd_extent_header
{
  // magic
  unsigned short int magic;
  // depth
  unsigned short int depth;
  // entries
  unsigned int entries;
};

struct sd_extent_idx
{
  // idx
  unsigned int idx;
  // oid
  unsigned long int oid;
};

struct sd_inode
{
  // name
  char name[256l];
  // tag
  char tag[256l];
  // create_time
  unsigned long int create_time;
  // snap_ctime
  unsigned long int snap_ctime;
  // vm_clock_nsec
  unsigned long int vm_clock_nsec;
  // vdi_size
  unsigned long int vdi_size;
  // vm_state_size
  unsigned long int vm_state_size;
  // copy_policy
  unsigned char copy_policy;
  // store_policy
  unsigned char store_policy;
  // nr_copies
  unsigned char nr_copies;
  // block_size_shift
  unsigned char block_size_shift;
  // snap_id
  unsigned int snap_id;
  // vdi_id
  unsigned int vdi_id;
  // parent_vdi_id
  unsigned int parent_vdi_id;
  // child_vdi_id
  unsigned int child_vdi_id[1024l];
  // data_vdi_id
  unsigned int data_vdi_id[1048576l];
  // btree_counter
  unsigned int btree_counter;
};

struct sd_mutex
{
  // mutex
  union anonymous_22 mutex;
};

struct sd_node
{
  // rb
  struct rb_node rb;
  // nid
  struct node_id nid;
  // nr_vnodes
  unsigned short int nr_vnodes;
  // zone
  unsigned int zone;
  // space
  unsigned long int space;
};

struct sd_option
{
  // ch
  signed int ch;
  // name
  const char *name;
  // has_arg
  _Bool has_arg;
  // desc
  const char *desc;
  // help
  const char *help;
};

struct sd_req
{
  // proto_ver
  unsigned char proto_ver;
  // opcode
  unsigned char opcode;
  // flags
  unsigned short int flags;
  // epoch
  unsigned int epoch;
  // id
  unsigned int id;
  // data_length
  unsigned int data_length;
  // _anon0
  union anonymous_7 _anon0;
};

struct sd_rsp
{
  // proto_ver
  unsigned char proto_ver;
  // opcode
  unsigned char opcode;
  // flags
  unsigned short int flags;
  // epoch
  unsigned int epoch;
  // id
  unsigned int id;
  // data_length
  unsigned int data_length;
  // _anon0
  union anonymous_6 _anon0;
};

struct sd_rw_lock
{
  // rwlock
  union anonymous_28 rwlock;
};

struct sembuf
{
  // sem_num
  unsigned short int sem_num;
  // sem_op
  signed short int sem_op;
  // sem_flg
  signed short int sem_flg;
};

struct semid_ds
{
  // sem_perm
  struct ipc_perm sem_perm;
  // sem_otime
  signed long int sem_otime;
  // __glibc_reserved1
  unsigned long int __glibc_reserved1;
  // sem_ctime
  signed long int sem_ctime;
  // __glibc_reserved2
  unsigned long int __glibc_reserved2;
  // sem_nsems
  unsigned long int sem_nsems;
  // __glibc_reserved3
  unsigned long int __glibc_reserved3;
  // __glibc_reserved4
  unsigned long int __glibc_reserved4;
};

struct seminfo
{
  // semmap
  signed int semmap;
  // semmni
  signed int semmni;
  // semmns
  signed int semmns;
  // semmnu
  signed int semmnu;
  // semmsl
  signed int semmsl;
  // semopm
  signed int semopm;
  // semume
  signed int semume;
  // semusz
  signed int semusz;
  // semvmx
  signed int semvmx;
  // semaem
  signed int semaem;
};

struct sha1_ctx
{
  // count
  unsigned long int count;
  // state
  unsigned int state[5l];
  // buffer
  unsigned char buffer[64l];
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sheep
{
  // fd
  signed int fd;
  // node
  struct sd_node node;
  // addr
  struct sockaddr_in addr;
  // state
  enum sheep_state state;
  // sheep_list
  struct list_node sheep_list;
  // join_wait_list
  struct list_node join_wait_list;
};

struct shmid_ds
{
  // shm_perm
  struct ipc_perm shm_perm;
  // shm_segsz
  unsigned long int shm_segsz;
  // shm_atime
  signed long int shm_atime;
  // shm_dtime
  signed long int shm_dtime;
  // shm_ctime
  signed long int shm_ctime;
  // shm_cpid
  signed int shm_cpid;
  // shm_lpid
  signed int shm_lpid;
  // shm_nattch
  unsigned long int shm_nattch;
  // __glibc_reserved4
  unsigned long int __glibc_reserved4;
  // __glibc_reserved5
  unsigned long int __glibc_reserved5;
};

struct sigaction
{
  // __sigaction_handler
  union anonymous __sigaction_handler;
  // sa_mask
  struct anonymous_0 sa_mask;
  // sa_flags
  signed int sa_flags;
  // sa_restorer
  void (*sa_restorer)(void);
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct sockaddr_un
{
  // sun_family
  unsigned short int sun_family;
  // sun_path
  char sun_path[108l];
};

struct sockfd
{
  // fd
  signed int fd;
  // idx
  signed int idx;
};

struct sockfd_cache
{
  // root
  struct rb_root root;
  // lock
  struct sd_rw_lock lock;
  // count
  signed int count;
};

struct sockfd_cache_entry
{
  // rb
  struct rb_node rb;
  // nid
  struct node_id nid;
  // fds
  struct sockfd_cache_fd *fds;
};

struct sockfd_cache_fd
{
  // fd
  signed int fd;
  // in_use
  struct anonymous_29 in_use;
};

struct sph_msg
{
  // type
  unsigned int type;
  // body_len
  unsigned int body_len;
};

struct sph_msg_join
{
  // new_node
  struct sd_node new_node;
  // nodes
  struct sd_node nodes[6144l];
  // nr_nodes
  unsigned int nr_nodes;
  // opaque
  unsigned char opaque[0l];
};

struct sph_msg_join_node_finish
{
  // new_node
  struct sd_node new_node;
  // nodes
  struct sd_node nodes[6144l];
  // nr_nodes
  unsigned int nr_nodes;
  // opaque
  unsigned char opaque[0l];
};

struct sph_msg_join_reply
{
  // nodes
  struct sd_node nodes[6144l];
  // nr_nodes
  unsigned int nr_nodes;
  // opaque
  unsigned char opaque[0l];
};

struct sph_msg_notify
{
  // unblock
  unsigned char unblock;
  // notify_msg
  unsigned char notify_msg[0l];
};

struct sph_msg_notify_forward
{
  // from_node
  struct sd_node from_node;
  // unblock
  unsigned char unblock;
  // notify_msg
  unsigned char notify_msg[0l];
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __glibc_reserved
  signed long int __glibc_reserved[3l];
};

struct strbuf
{
  // alloc
  unsigned long int alloc;
  // len
  unsigned long int len;
  // eof
  signed int eof;
  // buf
  char *buf;
};

struct timer
{
  // callback
  void (*callback)(void *);
  // data
  void *data;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct tm
{
  // tm_sec
  signed int tm_sec;
  // tm_min
  signed int tm_min;
  // tm_hour
  signed int tm_hour;
  // tm_mday
  signed int tm_mday;
  // tm_mon
  signed int tm_mon;
  // tm_year
  signed int tm_year;
  // tm_wday
  signed int tm_wday;
  // tm_yday
  signed int tm_yday;
  // tm_isdst
  signed int tm_isdst;
  // tm_gmtoff
  signed long int tm_gmtoff;
  // tm_zone
  const char *tm_zone;
};

struct work
{
  // w_list
  struct list_node w_list;
  // fn
  void (*fn)(struct work *);
  // done
  void (*done)(struct work *);
};

struct work_queue
{
  // wq_state
  signed int wq_state;
  // pending_list
  struct list_head pending_list;
};

struct wq_info
{
  // name
  const char *name;
  // finished_list
  struct list_head finished_list;
  // list
  struct list_node list;
  // finished_lock
  struct sd_mutex finished_lock;
  // startup_lock
  struct sd_mutex startup_lock;
  // pending_cond
  struct sd_cond pending_cond;
  // pending_lock
  struct sd_mutex pending_lock;
  // q
  struct work_queue q;
  // nr_threads
  unsigned long int nr_threads;
  // nr_queued_work
  unsigned long int nr_queued_work;
  // tm_end_of_protection
  unsigned long int tm_end_of_protection;
  // tc
  enum wq_thread_control tc;
};


// Pp
// file fec.c line 69
static const char * const Pp = "101110001";
// colorize
// file logger.c line 40
static _Bool colorize;
// dst_type
// file logger.c line 123
static enum log_dst_type dst_type = (enum log_dst_type)1;
// efd
// file event.c line 22
static signed int efd;
// efd_link1
// file work.c line 68
static signed int efd_link1;
// event_loop_refresh
// file event.c line 172
static _Bool event_loop_refresh;
// events
// file event.c line 71
static struct epoll_event *events;
// events_tree
// file event.c line 23
static struct rb_root events_tree = { .rb_node=(struct rb_node *)(void *)0 };
// fds_count
// file sockfd_cache.c line 62
static signed int fds_count = 8;
// fds_high_watermark
// file sockfd_cache.c line 243
static signed int fds_high_watermark = (8 * 3) / 4;
// fds_in_grow
// file sockfd_cache.c line 242
static struct anonymous_29 fds_in_grow;
// format
// file logger.c line 107
static struct log_format *format;
// gf_exp
// file fec.c line 80
static unsigned char gf_exp[510l];
// gf_log
// file fec.c line 81
static signed int gf_log[256l];
// gf_mul_table
// file fec.c line 108
static unsigned char gf_mul_table[256l][256l];
// grow_wq
// file sockfd_cache.c line 245
static struct work_queue *grow_wq;
// inverse
// file fec.c line 82
static unsigned char inverse[256l];
// join_wait_queue
// file shepherd.c line 193
static struct list_head join_wait_queue;
// join_wait_queue
// file shepherd.c line 193
static struct list_head join_wait_queue = { .n={ .next=&join_wait_queue.n, .prev=&join_wait_queue.n } };
// la
// file logger.c line 112
static struct logarea *la;
// log_buff
// file logger.c line 119
static char *log_buff;
// log_fd
// file logger.c line 109
static signed int log_fd = -1;
// log_formats
// file logger.c line 106
static struct list_head log_formats;
// log_formats
// file logger.c line 106
static struct list_head log_formats = { .n={ .next=&log_formats.n, .prev=&log_formats.n } };
// log_name
// file logger.c line 113
static const char *log_name;
// log_nowname
// file logger.c line 114
static char *log_nowname;
// logger_pid
// file logger.c line 117
signed int logger_pid = -1;
// logger_user_info
// file logger.c line 63
static struct logger_user_info *logger_user_info;
// max_logsize
// file logger.c line 121
static signed long int max_logsize = (signed long int)(500 * 1024 * 1024);
// msg_handlers
// file shepherd.c line 511
static void (*msg_handlers[5l])(struct sph_msg *, struct sheep *);
// msg_handlers
// file shepherd.c line 511
static void (*msg_handlers[5l])(struct sph_msg *, struct sheep *) = { sph_handle_join, sph_handle_accept, sph_handle_notify, sph_handle_block, sph_handle_leave };
// nr_events
// file event.c line 72
static signed int nr_events;
// nr_nodes
// file work.c line 70
static unsigned long int nr_nodes = (unsigned long int)1;
// optarg
// file /usr/include/getopt.h line 57
extern char *optarg;
// progname
// file shepherd.c line 66
static const char *progname;
// remove_efd
// file shepherd.c line 102
static signed int remove_efd;
// running
// file shepherd.c line 65
static _Bool running;
// sd_def_dmode
// file util.c line 25
unsigned int sd_def_dmode = (unsigned int)(0400 | 0200 | 0100 | 0400 >> 3 | 0200 >> 3 | 0100 >> 3);
// sd_def_fmode
// file util.c line 26
unsigned int sd_def_fmode = (unsigned int)(0400 | 0200 | 0400 >> 3 | 0200 >> 3);
// sd_log_level
// file logger.c line 115
signed int sd_log_level = 6;
// semkey
// file logger.c line 118
static signed int semkey;
// sha1_final
// file ../include/sha1.h line 32
void (*sha1_final)(void *, unsigned char *);
// sha1_init
// file ../include/sha1.h line 30
void (*sha1_init)(void *);
// sha1_update
// file ../include/sha1.h line 31
void (*sha1_update)(void *, const unsigned char *, unsigned int);
// sheep_list_head
// file shepherd.c line 63
static struct list_head sheep_list_head;
// sheep_list_head
// file shepherd.c line 63
static struct list_head sheep_list_head = { .n={ .next=&sheep_list_head.n, .prev=&sheep_list_head.n } };
// sheep_pid
// file logger.c line 116
static signed int sheep_pid;
// shepherd_options
// file shepherd.c line 597
static struct sd_option shepherd_options[8l] = { { .ch=98, .name="bindaddr", .has_arg=(_Bool)1, .desc="specify IP address of interface to listen on",
    .help=((const char *)NULL) },
    { .ch=100, .name="debug", .has_arg=(_Bool)0, .desc="include debug messages in the log",
    .help=((const char *)NULL) },
    { .ch=102, .name="foreground", .has_arg=(_Bool)0, .desc="make the program run in the foreground",
    .help=((const char *)NULL) },
    { .ch=70, .name="log-format", .has_arg=(_Bool)1, .desc="specify log format",
    .help=((const char *)NULL) },
    { .ch=104, .name="help", .has_arg=(_Bool)0, .desc="display this help and exit",
    .help=((const char *)NULL) },
    { .ch=108, .name="log-file", .has_arg=(_Bool)1, .desc="specify a log file for writing logs of shepherd",
    .help=((const char *)NULL) },
    { .ch=112, .name="port", .has_arg=(_Bool)1, .desc="specify TCP port on which to listen",
    .help=((const char *)NULL) },
    { .ch=0, .name=(const char *)(void *)0, .has_arg=(_Bool)0, .desc=(const char *)(void *)0,
    .help=((const char *)NULL) } };
// sockfd_cache
// file sockfd_cache.c line 44
static struct sockfd_cache sockfd_cache = { .root={ .rb_node=(struct rb_node *)(void *)0 }, .lock={ .rwlock={ .__data={ .__lock=0, .__nr_readers=(unsigned int)0, .__readers_wakeup=(unsigned int)0,
    .__writer_wakeup=(unsigned int)0, .__nr_readers_queued=(unsigned int)0,
    .__nr_writers_queued=(unsigned int)0,
    .__writer=0,
    .__shared=0, .__rwelision=(signed char)0, .__pad1={ (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0 },
    .__pad2=(unsigned long int)0,
    .__flags=(unsigned int)0 } } },
    .count=0 };
// state
// file shepherd.c line 44
static enum shepherd_state state = (enum shepherd_state)0;
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// try_to_free_routine
// file util.c line 32
static void (*try_to_free_routine)(unsigned long int);
// try_to_free_routine
// file util.c line 32
static void (*try_to_free_routine)(unsigned long int) = do_nothing;
// worker_idx
// file logger.c line 111
static signed int worker_idx;
// worker_name
// file logger.c line 110
static const char *worker_name;
// wq_get_nr_nodes
// file work.c line 71
static unsigned long int (*wq_get_nr_nodes)(void);
// wq_info_list
// file work.c line 69
static struct list_head wq_info_list;
// wq_info_list
// file work.c line 69
static struct list_head wq_info_list = { .n={ .next=&wq_info_list.n, .prev=&wq_info_list.n } };

// INIT_LIST_HEAD
// file ../include/list.h line 27
static inline void INIT_LIST_HEAD(struct list_head *list)
{
  list->n.next = &list->n;
  list->n.prev = &list->n;
}

// __list_add
// file ../include/list.h line 72
static inline void __list_add(struct list_node *new, struct list_node *prev, struct list_node *next)
{
  next->prev = new;
  new->next = next;
  new->prev = prev;
  prev->next = new;
}

// __list_add_link1
// file ../include/list.h line 72
static inline void __list_add_link1(struct list_node *new_link1, struct list_node *prev_link1, struct list_node *next_link1)
{
  next_link1->prev = new_link1;
  new_link1->next = next_link1;
  new_link1->prev = prev_link1;
  prev_link1->next = new_link1;
}

// __list_del
// file ../include/list.h line 92
static inline void __list_del(struct list_node *prev, struct list_node *next)
{
  next->prev = prev;
  prev->next = next;
}

// __list_del_link1
// file ../include/list.h line 92
static inline void __list_del_link1(struct list_node *prev_link1, struct list_node *next_link1)
{
  next_link1->prev = prev_link1;
  prev_link1->next = next_link1;
}

// __list_splice
// file ../include/list.h line 122
static inline void __list_splice(struct list_head *list, struct list_node *prev, struct list_node *next)
{
  struct list_node *first = list->n.next;
  struct list_node *last = list->n.prev;
  first->prev = prev;
  prev->next = first;
  last->next = next;
  next->prev = last;
}

// __rb_erase_color
// file rbtree.c line 124
static void __rb_erase_color(struct rb_node *node, struct rb_node *parent, struct rb_root *root)
{
  struct rb_node *other;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_8;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_5;
  while((_Bool)1)
  {
    if(!(node == ((struct rb_node *)NULL)))
    {
      if((1ul & node->rb_parent_color) == 0ul)
        goto __CPROVER_DUMP_L42;

    }

    if(node == root->rb_node)
      break;

    if(parent->rb_left == node)
    {
      other = parent->rb_right;
      if((1ul & other->rb_parent_color) == 0ul)
      {
        do
          other->rb_parent_color = other->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        do
          parent->rb_parent_color = parent->rb_parent_color & (unsigned long int)~1;
        while((_Bool)0);
        __rb_rotate_left(parent, root);
        other = parent->rb_right;
      }

      if(other->rb_left == ((struct rb_node *)NULL))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (other->rb_left->rb_parent_color & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
      {
        if(other->rb_right == ((struct rb_node *)NULL))
          tmp_if_expr_3 = (_Bool)1;

        else
          tmp_if_expr_3 = (other->rb_right->rb_parent_color & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
        tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_4 = (_Bool)0;
      if(tmp_if_expr_4)
      {
        do
          other->rb_parent_color = other->rb_parent_color & (unsigned long int)~1;
        while((_Bool)0);
        node = parent;
        parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
      }

      else
      {
        if(other->rb_right == ((struct rb_node *)NULL))
          tmp_if_expr_1 = (_Bool)1;

        else
          tmp_if_expr_1 = (other->rb_right->rb_parent_color & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_1)
        {
          do
            other->rb_left->rb_parent_color = other->rb_left->rb_parent_color | (unsigned long int)1;
          while((_Bool)0);
          do
            other->rb_parent_color = other->rb_parent_color & (unsigned long int)~1;
          while((_Bool)0);
          __rb_rotate_right(other, root);
          other = parent->rb_right;
        }

        rb_set_color(other, (signed int)(parent->rb_parent_color & (unsigned long int)1));
        do
          parent->rb_parent_color = parent->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        do
          other->rb_right->rb_parent_color = other->rb_right->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        __rb_rotate_left(parent, root);
        node = root->rb_node;
        break;
      }
    }

    else
    {
      other = parent->rb_left;
      if((1ul & other->rb_parent_color) == 0ul)
      {
        do
          other->rb_parent_color = other->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        do
          parent->rb_parent_color = parent->rb_parent_color & (unsigned long int)~1;
        while((_Bool)0);
        __rb_rotate_right(parent, root);
        other = parent->rb_left;
      }

      if(other->rb_left == ((struct rb_node *)NULL))
        tmp_if_expr_6 = (_Bool)1;

      else
        tmp_if_expr_6 = (other->rb_left->rb_parent_color & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_6)
      {
        if(other->rb_right == ((struct rb_node *)NULL))
          tmp_if_expr_7 = (_Bool)1;

        else
          tmp_if_expr_7 = (other->rb_right->rb_parent_color & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
        tmp_if_expr_8 = tmp_if_expr_7 ? (_Bool)1 : (_Bool)0;
      }

      else
        tmp_if_expr_8 = (_Bool)0;
      if(tmp_if_expr_8)
      {
        do
          other->rb_parent_color = other->rb_parent_color & (unsigned long int)~1;
        while((_Bool)0);
        node = parent;
        parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
      }

      else
      {
        if(other->rb_left == ((struct rb_node *)NULL))
          tmp_if_expr_5 = (_Bool)1;

        else
          tmp_if_expr_5 = (other->rb_left->rb_parent_color & (unsigned long int)1) != 0ul ? (_Bool)1 : (_Bool)0;
        if(tmp_if_expr_5)
        {
          do
            other->rb_right->rb_parent_color = other->rb_right->rb_parent_color | (unsigned long int)1;
          while((_Bool)0);
          do
            other->rb_parent_color = other->rb_parent_color & (unsigned long int)~1;
          while((_Bool)0);
          __rb_rotate_left(other, root);
          other = parent->rb_left;
        }

        rb_set_color(other, (signed int)(parent->rb_parent_color & (unsigned long int)1));
        do
          parent->rb_parent_color = parent->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        do
          other->rb_left->rb_parent_color = other->rb_left->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        __rb_rotate_right(parent, root);
        node = root->rb_node;
        break;
      }
    }
  }

__CPROVER_DUMP_L42:
  ;
  if(!(node == ((struct rb_node *)NULL)))
    do
      node->rb_parent_color = node->rb_parent_color | (unsigned long int)1;
    while((_Bool)0);

}

// __rb_rotate_left
// file rbtree.c line 25
static void __rb_rotate_left(struct rb_node *node, struct rb_root *root)
{
  struct rb_node *right = node->rb_right;
  struct rb_node *parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
  node->rb_right = right->rb_left;
  if(!(node->rb_right == ((struct rb_node *)NULL)))
    rb_set_parent(right->rb_left, node);

  right->rb_left = node;
  rb_set_parent(right, parent);
  if(!(parent == ((struct rb_node *)NULL)))
  {
    if(node == parent->rb_left)
      parent->rb_left = right;

    else
      parent->rb_right = right;
  }

  else
    root->rb_node = right;
  rb_set_parent(node, right);
}

// __rb_rotate_right
// file rbtree.c line 47
static void __rb_rotate_right(struct rb_node *node, struct rb_root *root)
{
  struct rb_node *left = node->rb_left;
  struct rb_node *parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
  node->rb_left = left->rb_right;
  if(!(node->rb_left == ((struct rb_node *)NULL)))
    rb_set_parent(left->rb_right, node);

  left->rb_right = node;
  rb_set_parent(left, parent);
  if(!(parent == ((struct rb_node *)NULL)))
  {
    if(node == parent->rb_right)
      parent->rb_right = left;

    else
      parent->rb_left = left;
  }

  else
    root->rb_node = left;
  rb_set_parent(node, left);
}

// __sd_dump_variable
// file logger.c line 791
signed int __sd_dump_variable(const char *var)
{
  char cmd[256l];
  snprintf(cmd, sizeof(char [256l]) /*256ul*/ , "p %s", var);
  signed int return_value_gdb_cmd_1;
  return_value_gdb_cmd_1=gdb_cmd(cmd);
  return return_value_gdb_cmd_1;
}

// __uatomic_add_return
// file /usr/include/urcu/uatomic.h line 178
static inline unsigned long int __uatomic_add_return(void *addr, unsigned long int val, signed int len)
{
  unsigned char result;
  unsigned short int __uatomic_add_return__1__1__2__result;
  unsigned int __uatomic_add_return__1__1__3__result;
  unsigned long int __uatomic_add_return__1__1__4__result;
  switch(len)
  {
    case 1:
    {
      result = (unsigned char)val;
      asm("lock; xaddb %1, %0" : "+m"(*((struct __uatomic_dummy *)addr)), "+q"(result) :  : "memory");
      return (unsigned long int)((signed int)result + (signed int)(unsigned char)val);
    }
    case 2:
    {
      __uatomic_add_return__1__1__2__result = (unsigned short int)val;
      asm("lock; xaddw %1, %0" : "+m"(*((struct __uatomic_dummy *)addr)), "+r"(__uatomic_add_return__1__1__2__result) :  : "memory");
      return (unsigned long int)((signed int)__uatomic_add_return__1__1__2__result + (signed int)(unsigned short int)val);
    }
    case 4:
    {
      __uatomic_add_return__1__1__3__result = (unsigned int)val;
      asm("lock; xaddl %1, %0" : "+m"(*((struct __uatomic_dummy *)addr)), "+r"(__uatomic_add_return__1__1__3__result) :  : "memory");
      return (unsigned long int)(__uatomic_add_return__1__1__3__result + (unsigned int)val);
    }
    case 8:
    {
      __uatomic_add_return__1__1__4__result = val;
      asm("lock; xaddq %1, %0" : "+m"(*((struct __uatomic_dummy *)addr)), "+r"(__uatomic_add_return__1__1__4__result) :  : "memory");
      return __uatomic_add_return__1__1__4__result + (unsigned long int)val;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_cmpxchg
// file /usr/include/urcu/uatomic.h line 47
static inline unsigned long int __uatomic_cmpxchg(void *addr, unsigned long int old, unsigned long int _new, signed int len)
{
  unsigned char __uatomic_cmpxchg__1__1__1__result;
  unsigned short int __uatomic_cmpxchg__1__1__2__result;
  unsigned int result;
  unsigned long int __uatomic_cmpxchg__1__1__4__result;
  switch(len)
  {
    case 1:
    {
      __uatomic_cmpxchg__1__1__1__result = (unsigned char)old;
      asm("lock; cmpxchgb %2, %1" : "+a"(__uatomic_cmpxchg__1__1__1__result), "+m"(*((struct __uatomic_dummy *)addr)) : "q"((unsigned char)_new) : "memory");
      return (unsigned long int)__uatomic_cmpxchg__1__1__1__result;
    }
    case 2:
    {
      __uatomic_cmpxchg__1__1__2__result = (unsigned short int)old;
      asm("lock; cmpxchgw %2, %1" : "+a"(__uatomic_cmpxchg__1__1__2__result), "+m"(*((struct __uatomic_dummy *)addr)) : "r"((unsigned short int)_new) : "memory");
      return (unsigned long int)__uatomic_cmpxchg__1__1__2__result;
    }
    case 4:
    {
      result = (unsigned int)old;
      asm("lock; cmpxchgl %2, %1" : "+a"(result), "+m"(*((struct __uatomic_dummy *)addr)) : "r"((unsigned int)_new) : "memory");
      return (unsigned long int)result;
    }
    case 8:
    {
      __uatomic_cmpxchg__1__1__4__result = old;
      asm("lock; cmpxchgq %2, %1" : "+a"(__uatomic_cmpxchg__1__1__4__result), "+m"(*((struct __uatomic_dummy *)addr)) : "r"((unsigned long int)_new) : "memory");
      return __uatomic_cmpxchg__1__1__4__result;
    }
    default:
    {
      asm("ud2");
      return (unsigned long int)0;
    }
  }
}

// __uatomic_dec
// file /usr/include/urcu/uatomic.h line 467
static inline void __uatomic_dec(void *addr, signed int len)
{
  switch(len)
  {
    case 1:
    {
      asm("lock; decb %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    case 2:
    {
      asm("lock; decw %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    case 4:
    {
      asm("lock; decl %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    case 8:
    {
      asm("lock; decq %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// __uatomic_inc
// file /usr/include/urcu/uatomic.h line 414
static inline void __uatomic_inc(void *addr, signed int len)
{
  switch(len)
  {
    case 1:
    {
      asm("lock; incb %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    case 2:
    {
      asm("lock; incw %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    case 4:
    {
      asm("lock; incl %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    case 8:
    {
      asm("lock; incq %0" : "=m"(*((struct __uatomic_dummy *)addr)) :  : "memory");
      break;
    }
    default:
      asm("ud2");
  }
}

// _addmul1
// file fec.c line 216
static void _addmul1(unsigned char *dst, const unsigned char *src, unsigned char c, unsigned long int sz)
{
  unsigned char *__gf_mulc_;
  const unsigned char *lim = &dst[(signed long int)((sz - (unsigned long int)16) + (unsigned long int)1)];
  __gf_mulc_ = gf_mul_table[(signed long int)c];
  for( ; !(dst >= lim); src = src + (signed long int)16)
  {
    dst[(signed long int)0] = dst[(signed long int)0] ^ __gf_mulc_[(signed long int)src[(signed long int)0]];
    dst[(signed long int)1] = dst[(signed long int)1] ^ __gf_mulc_[(signed long int)src[(signed long int)1]];
    dst[(signed long int)2] = dst[(signed long int)2] ^ __gf_mulc_[(signed long int)src[(signed long int)2]];
    dst[(signed long int)3] = dst[(signed long int)3] ^ __gf_mulc_[(signed long int)src[(signed long int)3]];
    dst[(signed long int)4] = dst[(signed long int)4] ^ __gf_mulc_[(signed long int)src[(signed long int)4]];
    dst[(signed long int)5] = dst[(signed long int)5] ^ __gf_mulc_[(signed long int)src[(signed long int)5]];
    dst[(signed long int)6] = dst[(signed long int)6] ^ __gf_mulc_[(signed long int)src[(signed long int)6]];
    dst[(signed long int)7] = dst[(signed long int)7] ^ __gf_mulc_[(signed long int)src[(signed long int)7]];
    dst[(signed long int)8] = dst[(signed long int)8] ^ __gf_mulc_[(signed long int)src[(signed long int)8]];
    dst[(signed long int)9] = dst[(signed long int)9] ^ __gf_mulc_[(signed long int)src[(signed long int)9]];
    dst[(signed long int)10] = dst[(signed long int)10] ^ __gf_mulc_[(signed long int)src[(signed long int)10]];
    dst[(signed long int)11] = dst[(signed long int)11] ^ __gf_mulc_[(signed long int)src[(signed long int)11]];
    dst[(signed long int)12] = dst[(signed long int)12] ^ __gf_mulc_[(signed long int)src[(signed long int)12]];
    dst[(signed long int)13] = dst[(signed long int)13] ^ __gf_mulc_[(signed long int)src[(signed long int)13]];
    dst[(signed long int)14] = dst[(signed long int)14] ^ __gf_mulc_[(signed long int)src[(signed long int)14]];
    dst[(signed long int)15] = dst[(signed long int)15] ^ __gf_mulc_[(signed long int)src[(signed long int)15]];
    dst = dst + (signed long int)16;
  }
  lim = lim + (signed long int)(16 - 1);
  for( ; !(dst >= lim); src = src + 1l)
  {
    *dst = *dst ^ __gf_mulc_[(signed long int)*src];
    dst = dst + 1l;
  }
}

// _init_mul_table
// file fec.c line 127
static void _init_mul_table(void)
{
  signed int i;
  signed int j;
  i = 0;
  unsigned char return_value_modnn_1;
  for( ; !(i >= 256); i = i + 1)
  {
    j = 0;
    for( ; !(j >= 256); j = j + 1)
    {
      return_value_modnn_1=modnn(gf_log[(signed long int)i] + gf_log[(signed long int)j]);
      gf_mul_table[(signed long int)i][(signed long int)j] = gf_exp[(signed long int)return_value_modnn_1];
    }
  }
  j = 0;
  for( ; !(j >= 256); j = j + 1)
  {
    gf_mul_table[(signed long int)j][(signed long int)0] = (unsigned char)0;
    gf_mul_table[(signed long int)0][(signed long int)j] = gf_mul_table[(signed long int)j][(signed long int)0];
  }
}

// _invert_mat
// file fec.c line 278
static void _invert_mat(unsigned char *src, unsigned int d)
{
  unsigned char c;
  unsigned char *p;
  unsigned int irow = (unsigned int)0;
  unsigned int icol = (unsigned int)0;
  unsigned int row;
  unsigned int col;
  unsigned int i;
  unsigned int ix;
  unsigned int *indxc;
  void *return_value_xmalloc_1;
  return_value_xmalloc_1=xmalloc((unsigned long int)d * sizeof(unsigned int) /*4ul*/ );
  indxc = (unsigned int *)return_value_xmalloc_1;
  unsigned int *indxr;
  void *return_value_xmalloc_2;
  return_value_xmalloc_2=xmalloc((unsigned long int)d * sizeof(unsigned int) /*4ul*/ );
  indxr = (unsigned int *)return_value_xmalloc_2;
  unsigned int *ipiv;
  void *return_value_xmalloc_3;
  return_value_xmalloc_3=xmalloc((unsigned long int)d * sizeof(unsigned int) /*4ul*/ );
  ipiv = (unsigned int *)return_value_xmalloc_3;
  unsigned char *id_row;
  void *return_value_xmalloc_4;
  return_value_xmalloc_4=xmalloc((unsigned long int)((unsigned int)1 * d));
  id_row = (unsigned char *)return_value_xmalloc_4;
  memset((void *)id_row, 0, (unsigned long int)d * sizeof(unsigned char) /*1ul*/ );
  i = (unsigned int)0;
  for( ; !(i >= d); i = i + 1u)
    ipiv[(signed long int)i] = (unsigned int)0;
  col = (unsigned int)0;
  for( ; !(col >= d); col = col + 1u)
  {
    unsigned char *pivot_row;
    if(!(ipiv[(signed long int)col] == 1u))
    {
      if((signed int)src[(signed long int)(col * d + col)] == 0)
        goto __CPROVER_DUMP_L4;

      irow = col;
      icol = col;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      row = (unsigned int)0;
      for( ; !(row >= d); row = row + 1u)
        if(!(ipiv[(signed long int)row] == 1u))
        {
          ix = (unsigned int)0;
          for( ; !(ix >= d); ix = ix + 1u)
            if(ipiv[(signed long int)ix] == 0u)
            {
              if(!((signed int)src[(signed long int)(row * d + ix)] == 0))
              {
                irow = row;
                icol = ix;
                goto found_piv;
              }

            }

        }

    }

  found_piv:
    ;
    ipiv[(signed long int)icol] = ipiv[(signed long int)icol] + 1u;
    if(!(irow == icol))
    {
      ix = (unsigned int)0;
      for( ; !(ix >= d); ix = ix + 1u)
      {
        unsigned char tmp = src[(signed long int)(irow * d + ix)];
        src[(signed long int)(irow * d + ix)] = src[(signed long int)(icol * d + ix)];
        src[(signed long int)(icol * d + ix)] = tmp;
      }
    }

    indxr[(signed long int)col] = irow;
    indxc[(signed long int)col] = icol;
    pivot_row = &src[(signed long int)(icol * d)];
    c = pivot_row[(signed long int)icol];
    if(!((signed int)c == 1))
    {
      c = inverse[(signed long int)c];
      pivot_row[(signed long int)icol] = (unsigned char)1;
      ix = (unsigned int)0;
      for( ; !(ix >= d); ix = ix + 1u)
        pivot_row[(signed long int)ix] = gf_mul_table[(signed long int)c][(signed long int)pivot_row[(signed long int)ix]];
    }

    id_row[(signed long int)icol] = (unsigned char)1;
    signed int return_value_memcmp_5;
    return_value_memcmp_5=memcmp((const void *)pivot_row, (const void *)id_row, (unsigned long int)d * sizeof(unsigned char) /*1ul*/ );
    if(!(return_value_memcmp_5 == 0))
    {
      p = src;
      ix = (unsigned int)0;
      for( ; !(ix >= d); p = p + (signed long int)d)
      {
        if(!(ix == icol))
        {
          c = p[(signed long int)icol];
          p[(signed long int)icol] = (unsigned char)0;
          if(!((signed int)c == 0))
            _addmul1(p, pivot_row, c, (unsigned long int)d);

        }

        ix = ix + 1u;
      }
    }

    id_row[(signed long int)icol] = (unsigned char)0;
  }
  col = d;
  for( ; col >= 1u; col = col - 1u)
    if(!(indxr[(signed long int)(col + 4294967295u)] == indxc[(signed long int)(col + 4294967295u)]))
    {
      row = (unsigned int)0;
      for( ; !(row >= d); row = row + 1u)
      {
        unsigned char _invert_mat__1__3__1__1__tmp = src[(signed long int)(row * d + indxr[(signed long int)(col - (unsigned int)1)])];
        src[(signed long int)(row * d + indxr[(signed long int)(col - (unsigned int)1)])] = src[(signed long int)(row * d + indxc[(signed long int)(col - (unsigned int)1)])];
        src[(signed long int)(row * d + indxc[(signed long int)(col - (unsigned int)1)])] = _invert_mat__1__3__1__1__tmp;
      }
    }

  free((void *)indxc);
  free((void *)indxr);
  free((void *)ipiv);
  free((void *)id_row);
}

// _invert_vdm
// file fec.c line 386
static void _invert_vdm(unsigned char *src, unsigned int d)
{
  unsigned int i;
  unsigned int j;
  unsigned int row;
  unsigned int col;
  unsigned char *b;
  unsigned char *c;
  unsigned char *p;
  unsigned char t;
  unsigned char xx;
  if(!(d == 1u))
  {
    void *return_value_xmalloc_1;
    return_value_xmalloc_1=xmalloc((unsigned long int)((unsigned int)1 * d));
    c = (unsigned char *)return_value_xmalloc_1;
    void *return_value_xmalloc_2;
    return_value_xmalloc_2=xmalloc((unsigned long int)((unsigned int)1 * d));
    b = (unsigned char *)return_value_xmalloc_2;
    void *return_value_xmalloc_3;
    return_value_xmalloc_3=xmalloc((unsigned long int)((unsigned int)1 * d));
    p = (unsigned char *)return_value_xmalloc_3;
    j = (unsigned int)1;
    i = (unsigned int)0;
    for( ; !(i >= d); j = j + d)
    {
      c[(signed long int)i] = (unsigned char)0;
      p[(signed long int)i] = src[(signed long int)j];
      i = i + 1u;
    }
    c[(signed long int)(d - (unsigned int)1)] = p[(signed long int)0];
    i = (unsigned int)1;
    for( ; !(i >= d); i = i + 1u)
    {
      unsigned char p_i = p[(signed long int)i];
      j = (d - (unsigned int)1) - (i - (unsigned int)1);
      for( ; !(j >= d + 4294967295u); j = j + 1u)
        c[(signed long int)j] = c[(signed long int)j] ^ gf_mul_table[(signed long int)p_i][(signed long int)c[(signed long int)(j + (unsigned int)1)]];
      c[(signed long int)(d - (unsigned int)1)] = c[(signed long int)(d - (unsigned int)1)] ^ p_i;
    }
    row = (unsigned int)0;
    for( ; !(row >= d); row = row + 1u)
    {
      xx = p[(signed long int)row];
      t = (unsigned char)1;
      b[(signed long int)(d - (unsigned int)1)] = (unsigned char)1;
      i = d - (unsigned int)1;
      for( ; i >= 1u; i = i - 1u)
      {
        b[(signed long int)(i - (unsigned int)1)] = (unsigned char)((signed int)c[(signed long int)i] ^ (signed int)gf_mul_table[(signed long int)xx][(signed long int)b[(signed long int)i]]);
        t = (unsigned char)((signed int)gf_mul_table[(signed long int)xx][(signed long int)t] ^ (signed int)b[(signed long int)(i - (unsigned int)1)]);
      }
      col = (unsigned int)0;
      for( ; !(col >= d); col = col + 1u)
        src[(signed long int)(col * d + row)] = gf_mul_table[(signed long int)inverse[(signed long int)t]][(signed long int)b[(signed long int)col]];
    }
    free((void *)c);
    free((void *)b);
    free((void *)p);
    goto __CPROVER_DUMP_L14;
  }


__CPROVER_DUMP_L14:
  ;
}

// _matmul
// file fec.c line 255
static void _matmul(unsigned char *a, unsigned char *b, unsigned char *c, unsigned int dp, unsigned int d, unsigned int m)
{
  unsigned int row;
  unsigned int col;
  unsigned int i;
  row = (unsigned int)0;
  for( ; !(row >= dp); row = row + 1u)
  {
    col = (unsigned int)0;
    for( ; !(col >= m); col = col + 1u)
    {
      unsigned char *pa = &a[(signed long int)(row * d)];
      unsigned char *pb = &b[(signed long int)col];
      unsigned char acc = (unsigned char)0;
      i = (unsigned int)0;
      for( ; !(i >= d); pb = pb + (signed long int)m)
      {
        acc = acc ^ gf_mul_table[(signed long int)*pa][(signed long int)*pb];
        i = i + 1u;
        pa = pa + 1l;
      }
      c[(signed long int)(row * m + col)] = acc;
    }
  }
}

// _pread
// file util.c line 168
static signed long int _pread(signed int fd, void *buf, unsigned long int len, signed long int offset)
{
  signed long int nr;
  signed int *return_value___errno_location_1;
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  while((_Bool)1)
  {
    nr=pread(fd, buf, len, offset);
    if(!(nr >= 0l))
    {
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 11)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value___errno_location_2=__errno_location();
        tmp_if_expr_3 = *return_value___errno_location_2 == 4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
        continue;

    }

    return nr;
  }
}

// _pwrite
// file util.c line 179
static signed long int _pwrite(signed int fd, const void *buf, unsigned long int len, signed long int offset)
{
  signed long int nr;
  signed int *return_value___errno_location_1;
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  while((_Bool)1)
  {
    nr=pwrite(fd, buf, len, offset);
    if(!(nr >= 0l))
    {
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 11)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value___errno_location_2=__errno_location();
        tmp_if_expr_3 = *return_value___errno_location_2 == 4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
        continue;

    }

    return nr;
  }
}

// _read
// file util.c line 106
static signed long int _read(signed int fd, void *buf, unsigned long int len)
{
  signed long int nr;
  signed int *return_value___errno_location_1;
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  while((_Bool)1)
  {
    nr=read(fd, buf, len);
    if(!(nr >= 0l))
    {
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 11)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value___errno_location_2=__errno_location();
        tmp_if_expr_3 = *return_value___errno_location_2 == 4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
        continue;

    }

    return nr;
  }
}

// _write
// file util.c line 117
static signed long int _write(signed int fd, const void *buf, unsigned long int len)
{
  signed long int nr;
  signed int *return_value___errno_location_1;
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  while((_Bool)1)
  {
    nr=write(fd, buf, len);
    if(!(nr >= 0l))
    {
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 11)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value___errno_location_2=__errno_location();
        tmp_if_expr_3 = *return_value___errno_location_2 == 4 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_3)
        continue;

    }

    return nr;
  }
}

// add_timer
// file event.c line 39
void add_timer(struct timer *t, unsigned int mseconds)
{
  struct itimerspec it;
  signed int tfd;
  tfd=timerfd_create(1, 2048);
  if(!(tfd >= 0))
    log_write(3, "add_timer", 46, "timerfd_create: %m");

  else
  {
    memset((void *)&it, 0, sizeof(struct itimerspec) /*32ul*/ );
    it.it_value.tv_sec = (signed long int)(mseconds / (unsigned int)1000);
    it.it_value.tv_nsec = (signed long int)((mseconds % (unsigned int)1000) * (unsigned int)1000000);
    signed int return_value_timerfd_settime_1;
    return_value_timerfd_settime_1=timerfd_settime(tfd, 0, &it, (struct itimerspec *)(void *)0);
    if(!(return_value_timerfd_settime_1 >= 0))
      log_write(3, "add_timer", 55, "timerfd_settime: %m");

    else
    {
      signed int return_value_register_event_2;
      return_value_register_event_2=register_event_link1(tfd, timer_handler, (void *)t);
      if(!(return_value_register_event_2 >= 0))
        log_write(3, "add_timer", 60, "failed to register timer fd");

    }
  }
}

// addr_to_str
// file ../include/net.h line 56
const char * addr_to_str(const unsigned char *addr, unsigned short int port)
{
  signed int af = 10;
  signed int addr_start_idx = 0;
  const char *ret;
  signed int tmp_post_1;
  if(!(addr[12l] == 0))
  {
    signed int oct_no = 0;
    while(addr[(signed long int)oct_no] == 0)
    {
      tmp_post_1 = oct_no;
      oct_no = oct_no + 1;
      if(tmp_post_1 >= 12)
        break;

    }
    if(oct_no == 12)
    {
      af = 2;
      addr_start_idx = 12;
    }

  }

  static char str[72l];
  ret=inet_ntop(af, (const void *)(addr + (signed long int)addr_start_idx), str, (unsigned int)sizeof(char [72l]) /*72ul*/ );
  if(ret == ((const char *)NULL))
  {
    log_write(0, "addr_to_str", 384, "PANIC: failed to convert addr to string, %m");
    abort();
  }

  if(!(port == 0))
  {
    signed int len;
    unsigned long int return_value_strlen_2;
    return_value_strlen_2=strlen(str);
    len = (signed int)return_value_strlen_2;
    snprintf(str + (signed long int)len, sizeof(char [72l]) /*72ul*/  - (unsigned long int)len, ":%d", port);
  }

  return str;
}

// atomic_create_and_write
// file util.c line 567
signed int atomic_create_and_write(const char *path, const char *buf, unsigned long int len, _Bool force_create)
{
  signed int fd;
  signed int ret;
  char tmp_path[4096l];
  snprintf(tmp_path, (unsigned long int)4096, "%s.tmp", path);
  signed int *return_value___errno_location_1;
  do
  {

  again:
    ;
    fd=open(tmp_path, 01 | 0100 | 04010000 | 0200, sd_def_fmode);
    if(fd >= 0)
      goto __CPROVER_DUMP_L7;

    return_value___errno_location_1=__errno_location();
    if(!(*return_value___errno_location_1 == 17))
      goto __CPROVER_DUMP_L5;

    if(force_create == (_Bool)0)
      break;

    if(sd_log_level == 7)
      log_write(7, "atomic_create_and_write", 580, "clean up a temporary file %s", (const void *)tmp_path);

    unlink(tmp_path);
  }
  while((_Bool)1);
  if(sd_log_level == 7)
    log_write(7, "atomic_create_and_write", 585, "someone else is dealing with %s", (const void *)tmp_path);

  goto __CPROVER_DUMP_L6;

__CPROVER_DUMP_L5:
  ;
  log_write(3, "atomic_create_and_write", 587, "failed to open temporal file %s, %m", (const void *)tmp_path);

__CPROVER_DUMP_L6:
  ;
  ret = -1;
  goto end;

__CPROVER_DUMP_L7:
  ;
  signed long int return_value_xwrite_2;
  return_value_xwrite_2=xwrite(fd, (const void *)buf, len);
  ret = (signed int)return_value_xwrite_2;
  if(!((unsigned long int)ret == len))
  {
    log_write(3, "atomic_create_and_write", 594, "failed to write %s, %m", path);
    ret = -1;
  }

  else
  {
    ret=rename(tmp_path, path);
    if(!(ret >= 0))
    {
      log_write(3, "atomic_create_and_write", 601, "failed to rename %s, %m", path);
      ret = -1;
    }

  }

close_fd:
  ;
  close(fd);

end:
  ;
  return ret;
}

// binary_search
// file sd_inode.c line 222
static void * binary_search(void *first, void *last, void *key, unsigned long int obj_size, signed int (*cmp)(void *, void *))
{
  const char *l;
  const char *r;
  const char *m;
  signed int ret;
  l = (const char *)first;
  r = (const char *)last - (signed long int)obj_size;
  if(r >= l)
  {
    m = l + (signed long int)((((unsigned long int)(r - l) / obj_size) / (unsigned long int)2) * obj_size);
    ret=cmp((void *)key, (void *)m);
    if(!(ret >= 0))
      r = m - (signed long int)obj_size;

    else
      if(ret >= 1)
        l = m + (signed long int)obj_size;

      else
        return (void *)m;
  }

  return (void *)l;
}

// block_sighup
// file logger.c line 130
static void block_sighup(void)
{
  signed int ret;
  struct anonymous_0 new;
  struct anonymous_0 old;
  sigemptyset(&new);
  sigemptyset(&old);
  sigaddset(&new, 1);
  ret=sigprocmask(0, &new, &old);
  if(!(ret >= 0))
    syslog(3, "blocking SIGHUP failed\n");

}

// build_decode_matrix_into_space
// file fec.c line 538
static void build_decode_matrix_into_space(struct fec * const code, const signed int * const idx, const unsigned int d, unsigned char * const matrix)
{
  unsigned char i;
  unsigned char *p;
  i = (unsigned char)0;
  p = matrix;
  for( ; !((unsigned int)i >= d); p = p + (signed long int)d)
  {
    if(!((unsigned int)idx[(signed long int)i] >= d))
    {
      memset((void *)p, 0, (unsigned long int)d);
      p[(signed long int)i] = (unsigned char)1;
    }

    else
      memcpy((void *)p, (const void *)&code->enc_matrix[(signed long int)(idx[(signed long int)i] * (signed int)code->d)], (unsigned long int)d);
    i = i + 1;
  }
  _invert_mat(matrix, d);
}

// build_long_options
// file ../include/option.h line 31
struct option * build_long_options(struct sd_option *sd_opts)
{
  struct sd_option *opt;
  static struct option lopts[256l];
  static struct option *p;
  p = lopts;
  opt = sd_opts;
  for( ; !(opt->name == ((const char *)NULL)); opt = opt + 1l)
  {
    p->name = opt->name;
    p->has_arg = (signed int)opt->has_arg;
    p->flag = (signed int *)(void *)0;
    p->val = opt->ch;
    p = p + 1l;
  }
  memset((void *)p, 0, sizeof(struct option) /*32ul*/ );
  return lopts;
}

// build_node_array
// file shepherd.c line 74
static signed int build_node_array(struct sd_node *nodes)
{
  signed int i;
  struct sheep *s;
  i = 0;
  struct sheep *__n80;
  struct sheep *tmp_statement_expression_1;
  const struct list_node *__mptr = (&sheep_list_head)->n.next;
  tmp_statement_expression_1 = (struct sheep *)((char *)__mptr - (signed long int)112ul);
  s = tmp_statement_expression_1;
  struct sheep *tmp_statement_expression_2;
  const struct list_node *build_node_array__1__1__2____mptr = s->sheep_list.next;
  tmp_statement_expression_2 = (struct sheep *)((char *)build_node_array__1__1__2____mptr - (signed long int)112ul);
  __n80 = tmp_statement_expression_2;
  signed int tmp_post_4;
  struct sheep *tmp_statement_expression_3;
  for( ; !(&s->sheep_list == &(&sheep_list_head)->n); __n80 = tmp_statement_expression_3)
  {
    if((signed int)s->state == SHEEP_STATE_JOINED)
    {
      tmp_post_4 = i;
      i = i + 1;
      nodes[(signed long int)tmp_post_4] = s->node;
    }

    s = __n80;
    const struct list_node *build_node_array__1__1__3____mptr = __n80->sheep_list.next;
    tmp_statement_expression_3 = (struct sheep *)((char *)build_node_array__1__1__3____mptr - (signed long int)112ul);
  }
  return i;
}

// build_short_options
// file ../include/option.h line 30
char * build_short_options(struct sd_option *sd_opts)
{
  struct sd_option *opt;
  static char sopts[256l];
  static char *p;
  p = sopts;
  opt = sd_opts;
  char *tmp_post_1;
  char *tmp_post_2;
  for( ; !(opt->name == ((const char *)NULL)); opt = opt + 1l)
  {
    tmp_post_1 = p;
    p = p + 1l;
    *tmp_post_1 = (char)opt->ch;
    if(!(opt->has_arg == (_Bool)0))
    {
      tmp_post_2 = p;
      p = p + 1l;
      *tmp_post_2 = (char)58;
    }

  }
  *p = (char)0;
  return sopts;
}

// check_gdb
// file logger.c line 753
static _Bool check_gdb(void)
{
  signed int return_value_system_1;
  return_value_system_1=system("which gdb > /dev/null");
  return return_value_system_1 == 0;
}

// check_idx
// file sockfd_cache.c line 277
static inline void check_idx(signed int idx)
{
  struct work *w;
  if(!(fds_high_watermark >= idx))
  {
    _Bool return_value_uatomic_set_true_1;
    return_value_uatomic_set_true_1=uatomic_set_true(&fds_in_grow);
    if(!(return_value_uatomic_set_true_1 == (_Bool)0))
    {
      void *return_value_xmalloc_2;
      return_value_xmalloc_2=xmalloc(sizeof(struct work) /*32ul*/ );
      w = (struct work *)return_value_xmalloc_2;
      w->fn = do_grow_fds;
      w->done = grow_fds_done;
      queue_work(grow_wq, w);
    }

  }

}

// chomp
// file ../include/util.h line 106
char * chomp(char *str)
{
  char *p;
  p=strchr(str, 10);
  if(!(p == ((char *)NULL)))
    *p = (char)0;

  return str;
}

// conn_rx_off
// file net.c line 50
signed int conn_rx_off(struct connection *conn)
{
  conn->events = conn->events & (unsigned int)~1;
  signed int return_value_modify_event_1;
  return_value_modify_event_1=modify_event(conn->fd, conn->events);
  return return_value_modify_event_1;
}

// conn_rx_on
// file net.c line 57
signed int conn_rx_on(struct connection *conn)
{
  conn->events = conn->events | (unsigned int)1;
  signed int return_value_modify_event_1;
  return_value_modify_event_1=modify_event(conn->fd, conn->events);
  return return_value_modify_event_1;
}

// conn_tx_off
// file net.c line 36
signed int conn_tx_off(struct connection *conn)
{
  conn->events = conn->events & (unsigned int)~4;
  signed int return_value_modify_event_1;
  return_value_modify_event_1=modify_event(conn->fd, conn->events);
  return return_value_modify_event_1;
}

// conn_tx_on
// file net.c line 43
signed int conn_tx_on(struct connection *conn)
{
  conn->events = conn->events | (unsigned int)4;
  signed int return_value_modify_event_1;
  return_value_modify_event_1=modify_event(conn->fd, conn->events);
  return return_value_modify_event_1;
}

// connect_to
// file net.c line 137
signed int connect_to(const char *name, signed int port)
{
  char buf[64l];
  char hbuf[1025l];
  char sbuf[32l];
  signed int fd;
  signed int ret;
  struct addrinfo hints;
  struct addrinfo *res;
  struct addrinfo *res0;
  struct linger linger_opt = { .l_onoff=1, .l_linger=0 };
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  snprintf(buf, sizeof(char [64l]) /*64ul*/ , "%d", port);
  hints.ai_socktype = 1;
  ret=getaddrinfo(name, buf, &hints, &res0);
  signed int *return_value___errno_location_1;
  if(!(ret == 0))
  {
    log_write(3, "connect_to", 152, "failed to get address info: %m");
    return -1;
  }

  else
  {
    res = res0;
    for( ; !(res == ((struct addrinfo *)NULL)); res = res->ai_next)
    {
      ret=getnameinfo(res->ai_addr, res->ai_addrlen, hbuf, (unsigned int)sizeof(char [1025l]) /*1025ul*/ , sbuf, (unsigned int)sizeof(char [32l]) /*32ul*/ , 1 | 2);
      if(ret == 0)
      {
        fd=socket(res->ai_family, res->ai_socktype, res->ai_protocol);
        if(fd >= 0)
        {
          ret=setsockopt(fd, 1, 13, (const void *)&linger_opt, (unsigned int)sizeof(struct linger) /*8ul*/ );
          if(!(ret == 0))
          {
            log_write(3, "connect_to", 170, "failed to set SO_LINGER: %m");
            close(fd);
          }

          else
          {
            ret=set_snd_timeout(fd);
            if(!(ret == 0))
            {
              log_write(3, "connect_to", 177, "failed to set send timeout: %m");
              close(fd);
              break;
            }

            ret=set_rcv_timeout(fd);
            if(!(ret == 0))
            {
              log_write(3, "connect_to", 184, "failed to set recv timeout: %m");
              close(fd);
              break;
            }

            do
            {

            reconnect:
              ;
              ret=connect(fd, res->ai_addr, res->ai_addrlen);
              if(ret == 0)
                goto __CPROVER_DUMP_L6;

              return_value___errno_location_1=__errno_location();
            }
            while(*return_value___errno_location_1 == 4);
            log_write(3, "connect_to", 193, "failed to connect to %s:%d: %m", name, port);
            close(fd);
            goto __CPROVER_DUMP_L8;

          __CPROVER_DUMP_L6:
            ;
            ret=set_nodelay(fd);
            if(!(ret == 0))
            {
              log_write(3, "connect_to", 200, "%m");
              close(fd);
              break;
            }

            else
              goto success;
          }
        }

      }


    __CPROVER_DUMP_L8:
      ;
    }
    fd = -1;

  success:
    ;
    freeaddrinfo(res0);
    if(sd_log_level == 7)
      log_write(7, "connect_to", 209, "%d, %s:%d", fd, name, port);

    return fd;
  }
}

// connect_to_addr
// file ../include/net.h line 71
static inline signed int connect_to_addr(const unsigned char *addr, signed int port)
{
  const char *return_value_addr_to_str_1;
  return_value_addr_to_str_1=addr_to_str(addr, (unsigned short int)0);
  signed int return_value_connect_to_2;
  return_value_connect_to_2=connect_to(return_value_addr_to_str_1, port);
  return return_value_connect_to_2;
}

// count_data_objs
// file ../include/sheepdog_proto.h line 411
static inline unsigned long int count_data_objs(struct sd_inode *inode)
{
  return ((inode->vdi_size + (1UL << 22)) - (unsigned long int)1) / (1UL << 22);
}

// crash_handler
// file shepherd.c line 640
static void crash_handler(signed int signo)
{
  char *return_value_strsignal_1;
  return_value_strsignal_1=strsignal(signo);
  log_write(0, "crash_handler", 642, "shepherd exits unexpectedly (%s).", return_value_strsignal_1);
  sd_backtrace();
  reraise_crash_signal(signo, 1);
}

// crash_handler_link1
// file logger.c line 534
static void crash_handler_link1(signed int signo_link1)
{
  _Bool return_value_is_sheep_dead_3;
  return_value_is_sheep_dead_3=is_sheep_dead(signo_link1);
  if(!(return_value_is_sheep_dead_3 == (_Bool)0))
    log_write(3, "crash_handler", 537, "sheep pid %d exited unexpectedly.", sheep_pid);

  else
  {
    signed int return_value_getpid_1;
    return_value_getpid_1=getpid();
    char *return_value_strsignal_2;
    return_value_strsignal_2=strsignal(signo_link1);
    log_write(3, "crash_handler", 540, "logger pid %d exits unexpectedly (%s).", return_value_getpid_1, return_value_strsignal_2);
    sd_backtrace();
  }
  log_flush();
  closelog();
  free_logarea();
  _Bool return_value_is_sheep_dead_4;
  return_value_is_sheep_dead_4=is_sheep_dead(signo_link1);
  if(!(return_value_is_sheep_dead_4 == (_Bool)0))
    exit(1);

  reraise_crash_signal(signo_link1, 1);
}

// create_listen_ports
// file ../include/net.h line 51
signed int create_listen_ports(const char *bindaddr, signed int port, signed int (*callback)(signed int, void *), void *data)
{
  char servname[64l];
  signed int fd;
  signed int ret;
  signed int opt;
  signed int success = 0;
  struct addrinfo hints;
  struct addrinfo *res;
  struct addrinfo *res0;
  memset((void *)servname, 0, sizeof(char [64l]) /*64ul*/ );
  snprintf(servname, sizeof(char [64l]) /*64ul*/ , "%d", port);
  memset((void *)&hints, 0, sizeof(struct addrinfo) /*48ul*/ );
  hints.ai_socktype = 1;
  hints.ai_flags = 0x0001;
  ret=getaddrinfo(bindaddr, servname, &hints, &res0);
  if(!(ret == 0))
  {
    log_write(3, "create_listen_ports", 81, "failed to get address info: %m");
    return 1;
  }

  else
  {
    res = res0;
    for( ; !(res == ((struct addrinfo *)NULL)); res = res->ai_next)
    {
      fd=socket(res->ai_family, res->ai_socktype, res->ai_protocol);
      if(fd >= 0)
      {
        opt = 1;
        ret=setsockopt(fd, 1, 2, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
        if(!(ret == 0))
          log_write(3, "create_listen_ports", 94, "failed to set SO_REUSEADDR: %m");

        opt = 1;
        if(res->ai_family == 10)
        {
          ret=setsockopt(fd, 41, 26, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
          if(ret == 0)
            goto __CPROVER_DUMP_L4;

          close(fd);
        }

        else
        {

        __CPROVER_DUMP_L4:
          ;
          ret=bind(fd, res->ai_addr, res->ai_addrlen);
          if(!(ret == 0))
          {
            log_write(3, "create_listen_ports", 108, "failed to bind server socket: %m");
            close(fd);
          }

          else
          {
            ret=listen(fd, 128);
            if(!(ret == 0))
            {
              log_write(3, "create_listen_ports", 115, "failed to listen on server socket: %m");
              close(fd);
            }

            else
            {
              ret=callback(fd, data);
              if(!(ret == 0))
                close(fd);

              else
                success = success + 1;
            }
          }
        }
      }

    }
    freeaddrinfo(res0);
    if(success == 0)
      log_write(3, "create_listen_ports", 132, "failed to create a listening port");

    return (signed int)!(success != 0);
  }
}

// create_ordered_work_queue
// file work.c line 440
struct work_queue * create_ordered_work_queue(const char *name)
{
  struct work_queue *return_value_create_work_queue_1;
  return_value_create_work_queue_1=create_work_queue(name, (enum wq_thread_control)WQ_ORDERED);
  return return_value_create_work_queue_1;
}

// create_unix_domain_socket
// file net.c line 536
signed int create_unix_domain_socket(const char *unix_path, signed int (*callback)(signed int, void *), void *data)
{
  signed int fd;
  signed int ret;
  struct sockaddr_un addr;
  addr.sun_family = (unsigned short int)1;
  pstrcpy(addr.sun_path, (signed int)sizeof(char [108l]) /*108ul*/ , unix_path);
  fd=socket((signed int)addr.sun_family, 1, 0);
  if(!(fd >= 0))
  {
    log_write(3, "create_unix_domain_socket", 547, "failed to create socket, %m");
    return -1;
  }

  else
  {
    ret=bind(fd, &addr, (unsigned int)sizeof(struct sockaddr_un) /*110ul*/ );
    if(!(ret == 0))
      log_write(3, "create_unix_domain_socket", 553, "failed to bind socket: %m");

    else
    {
      ret=listen(fd, 128);
      if(!(ret == 0))
        log_write(3, "create_unix_domain_socket", 559, "failed to listen on socket: %m");

      else
      {
        ret=callback(fd, data);
        if(ret == 0)
          return 0;

      }
    }

  err:
    ;
    close(fd);
    return -1;
  }
}

// create_work_queue
// file work.c line 404
struct work_queue * create_work_queue(const char *name, enum wq_thread_control tc)
{
  signed int ret;
  struct wq_info *wi;
  void *return_value_xzalloc_1;
  return_value_xzalloc_1=xzalloc(sizeof(struct wq_info) /*264ul*/ );
  wi = (struct wq_info *)return_value_xzalloc_1;
  wi->name = name;
  wi->tc = tc;
  INIT_LIST_HEAD(&wi->q.pending_list);
  INIT_LIST_HEAD(&wi->finished_list);
  sd_cond_init(&wi->pending_cond);
  sd_init_mutex(&wi->finished_lock);
  sd_init_mutex(&wi->pending_lock);
  sd_init_mutex(&wi->startup_lock);
  ret=create_worker_threads(wi, (unsigned long int)1);
  if(ret >= 0)
  {
    list_add_link1(&wi->list, &wq_info_list);
    return &wi->q;
  }

  else
  {

  destroy_threads:
    ;
    sd_mutex_unlock(&wi->startup_lock);
    sd_destroy_cond(&wi->pending_cond);
    sd_destroy_mutex(&wi->pending_lock);
    sd_destroy_mutex(&wi->finished_lock);
    free((void *)wi);
    return (struct work_queue *)(void *)0;
  }
}

// create_worker_threads
// file work.c line 249
static signed int create_worker_threads(struct wq_info *wi, unsigned long int nr_threads)
{
  unsigned long int thread;
  signed int ret;
  sd_mutex_lock(&wi->startup_lock);
  while(!(wi->nr_threads >= nr_threads))
  {
    ret=pthread_create(&thread, (const union pthread_attr_t *)(void *)0, worker_routine, (void *)wi);
    if(!(ret == 0))
    {
      log_write(3, "create_worker_threads", 258, "failed to create worker thread: %m");
      sd_mutex_unlock(&wi->startup_lock);
      return -1;
    }

    wi->nr_threads = wi->nr_threads + 1ul;
    if(sd_log_level == 7)
      log_write(7, "create_worker_threads", 263, "create thread %s %zu", wi->name, wi->nr_threads);

  }
  sd_mutex_unlock(&wi->startup_lock);
  return 0;
}

// data_is_missing
// file fec.c line 618
static inline _Bool data_is_missing(const unsigned char **dp, signed int d)
{
  signed int i = 0;
  for( ; !(i >= d); i = i + 1)
    if(dp[(signed long int)i] == ((const unsigned char *)NULL))
      return (_Bool)1;

  return (_Bool)0;
}

// data_to_str
// file util.c line 417
const char * data_to_str(void *data, unsigned long int data_length)
{
  data_length = data_length < (unsigned long int)256 ? data_length : (unsigned long int)256;
  if(data == NULL)
    return "(null)";

  else
  {
    void *return_value_memchr_1;
    return_value_memchr_1=memchr(data, 0, data_length);
    if(!(return_value_memchr_1 == NULL))
      return (const char *)data;

    else
      return "(not string)";
  }
}

// decode_prepare
// file fec.c line 591
static inline void decode_prepare(struct fec *ctx, const unsigned char **dp, const unsigned char **out, signed int *outidx)
{
  signed int i;
  signed int p = 0;
  i = (signed int)ctx->d;
  for( ; !(i >= (signed int)ctx->dp); i = i + 1)
    if(!(dp[(signed long int)i] == ((const unsigned char *)NULL)))
    {
      p = i;
      break;
    }

  i = 0;
  for( ; !(i >= (signed int)ctx->d); i = i + 1)
    if(!(dp[(signed long int)i] == ((const unsigned char *)NULL)))
    {
      out[(signed long int)i] = dp[(signed long int)i];
      outidx[(signed long int)i] = i;
    }

    else
    {
      out[(signed long int)i] = dp[(signed long int)p];
      outidx[(signed long int)i] = p;
      do
      {
        p = p + 1;
        if(p >= (signed int)ctx->dp)
          break;

        if(!(dp[(signed long int)p] == ((const unsigned char *)NULL)))
          break;

      }
      while((_Bool)1);
    }
}

// destroy_all_slots
// file sockfd_cache.c line 141
static inline void destroy_all_slots(struct sockfd_cache_entry *entry)
{
  signed int i = 0;
  for( ; !(i >= fds_count); i = i + 1)
    if(!((entry->fds + (signed long int)i)->fd == -1))
      close((entry->fds + (signed long int)i)->fd);

}

// do_event_loop
// file event.c line 190
static void do_event_loop(signed int timeout, _Bool sort_with_prio)
{
  signed int i;
  signed int nr;

refresh:
  ;
  event_loop_refresh = (_Bool)0;
  nr=epoll_wait(efd, events, nr_events, timeout);
  if(!(sort_with_prio == (_Bool)0))
  {
    if(nr >= 2)
      qsort((void *)events, (unsigned long int)nr, sizeof(struct epoll_event) /*12ul*/ , (signed int (*)(const void *, const void *))epoll_event_cmp);

  }

  if(!(nr >= 0))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(*return_value___errno_location_1 == 4)
      goto __CPROVER_DUMP_L7;

    log_write(3, "do_event_loop", 203, "epoll_wait failed: %m");
    exit(1);
  }

  else
    if(!(nr == 0))
    {
      i = 0;
      if(!(i >= nr))
      {
        struct event_info *ei = (struct event_info *)(events + (signed long int)i)->data.ptr;
        ei->handler(ei->fd, (signed int)(events + (signed long int)i)->events, ei->data);
        i = i + 1;
      }

    }


__CPROVER_DUMP_L7:
  ;
}

// do_grow_fds
// file sockfd_cache.c line 247
static void do_grow_fds(struct work *work)
{
  struct sockfd_cache_entry *entry;
  signed int old_fds_count;
  signed int new_fds_count;
  signed int new_size;
  signed int i;
  if(sd_log_level == 7)
    log_write(7, "do_grow_fds", 252, "%d", fds_count);

  sd_write_lock(&sockfd_cache.lock);
  old_fds_count = fds_count;
  new_fds_count = fds_count * 2;
  new_size = (signed int)(sizeof(struct sockfd_cache_fd) /*16ul*/  * (unsigned long int)fds_count * (unsigned long int)2);
  struct rb_node *__p257;
  __p257=rb_first(&sockfd_cache.root);
  struct rb_node *__n257;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  struct sockfd_cache_entry *tmp_statement_expression_2;
  do
  {
    if(!(__p257 == ((struct rb_node *)NULL)))
    {
      __n257=rb_next(__p257);
      tmp_if_expr_1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
    {
      const struct rb_node *__mptr = __p257;
      tmp_statement_expression_2 = (struct sockfd_cache_entry *)((char *)__mptr - (signed long int)0ul);
      entry = tmp_statement_expression_2;
      tmp_if_expr_3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    if(!tmp_if_expr_3)
      break;

    void *return_value_xrealloc_4;
    return_value_xrealloc_4=xrealloc((void *)entry->fds, (unsigned long int)new_size);
    entry->fds = (struct sockfd_cache_fd *)return_value_xrealloc_4;
    i = old_fds_count;
    for( ; !(i >= new_fds_count); i = i + 1)
    {
      (entry->fds + (signed long int)i)->fd = -1;
      uatomic_set_false(&(entry->fds + (signed long int)i)->in_use);
    }
    __p257 = __n257;
  }
  while((_Bool)1);
  fds_count = fds_count * 2;
  fds_high_watermark = (fds_count * 3) / 4;
  sd_rw_unlock(&sockfd_cache.lock);
}

// do_nothing
// file util.c line 28
static void do_nothing(unsigned long int size)
{
  ;
}

// do_read
// file net.c line 213
signed int do_read(signed int sockfd, void *buf, signed int len, _Bool (*need_retry)(unsigned int), unsigned int epoch, unsigned int max_count)
{
  signed int ret;
  signed int repeat = (signed int)max_count;
  signed long int return_value_read_1;
  _Bool tmp_if_expr_3;
  _Bool return_value;
  do
  {

  reread:
    ;
    return_value_read_1=read(sockfd, buf, (unsigned long int)len);
    ret = (signed int)return_value_read_1;
    if(ret == 0)
    {
      if(sd_log_level == 7)
        log_write(7, "do_read", 220, "connection is closed (%d bytes left)", len);

      return 1;
    }

    if(!(ret >= 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      if(*return_value___errno_location_2 == 4)
        goto reread;

      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      if(*return_value___errno_location_4 == 11)
      {
        if(!(repeat == 0))
        {
          if(need_retry == ((_Bool (*)(unsigned int))NULL))
            tmp_if_expr_3 = (_Bool)1;

          else
          {
            return_value=need_retry(epoch);
            tmp_if_expr_3 = return_value != (_Bool)0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_3)
          {
            repeat = repeat - 1;
            goto reread;
          }

        }

      }

      log_write(3, "do_read", 236, "failed to read from socket: %d, %m", ret);
      return 1;
    }

    len = len - ret;
    buf = (void *)((char *)buf + (signed long int)ret);
  }
  while(!(len == 0));
  return 0;
}

// do_write
// file net.c line 261
static signed int do_write(signed int sockfd, struct msghdr *msg, signed int len, _Bool (*need_retry)(unsigned int), unsigned int epoch, unsigned int max_count)
{
  signed int ret;
  signed int repeat = (signed int)max_count;
  signed long int return_value_sendmsg_1;
  _Bool tmp_if_expr_3;
  _Bool return_value;
  do
  {

  rewrite:
    ;
    return_value_sendmsg_1=sendmsg(sockfd, msg, 0);
    ret = (signed int)return_value_sendmsg_1;
    if(!(ret >= 0))
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      if(*return_value___errno_location_2 == 4)
        goto rewrite;

      signed int *return_value___errno_location_4;
      return_value___errno_location_4=__errno_location();
      if(*return_value___errno_location_4 == 11)
      {
        if(!(repeat == 0))
        {
          if(need_retry == ((_Bool (*)(unsigned int))NULL))
            tmp_if_expr_3 = (_Bool)1;

          else
          {
            return_value=need_retry(epoch);
            tmp_if_expr_3 = return_value != (_Bool)0 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_3)
          {
            repeat = repeat - 1;
            goto rewrite;
          }

        }

      }

      log_write(3, "do_write", 281, "failed to write to socket: %m");
      return 1;
    }

    len = len - ret;
    if(len == 0)
      break;

    forward_iov(msg, ret);
  }
  while((_Bool)1);
  return 0;
}

// do_writev2
// file ../include/net.h line 65
signed int do_writev2(signed int fd, void *hdr, unsigned long int hdr_len, void *body, unsigned long int body_len)
{
  struct iovec iov[2l];
  iov[(signed long int)0].iov_base = hdr;
  iov[(signed long int)0].iov_len = hdr_len;
  iov[(signed long int)1].iov_base = body;
  iov[(signed long int)1].iov_len = body_len;
  signed long int return_value_writev_1;
  return_value_writev_1=writev(fd, iov, 2);
  return (signed int)return_value_writev_1;
}

// dolog
// file logger.c line 395
static void dolog(signed int prio, const char *func, signed int line, const char *fmt, void **ap)
{
  char buf[(signed long int)(sizeof(struct logmsg) * 12 + 56) /*1112l*/ ];
  char *str = buf + (signed long int)sizeof(struct logmsg) /*88ul*/ ;
  struct logmsg *msg = (struct logmsg *)buf;
  signed int len = 0;
  struct timeval tv;
  gettimeofday(&tv, (struct timezone *)(void *)0);
  len=vsnprintf(str, (unsigned long int)1024, fmt, ap);
  signed int tmp_statement_expression_1;
  signed int tmp_post_4;
  if(!(len >= 0))
    syslog(3, "vsnprintf failed");

  else
  {
    signed int _x = len;
    signed int _y = 1024 - 1;
    (void)(&_x == &_y);
    tmp_statement_expression_1 = _x < _y ? _x : _y;
    msg->str_len = (unsigned long int)tmp_statement_expression_1;
    if(!(la == ((struct logarea *)NULL)))
    {
      struct sembuf ops;
      ops.sem_num = (unsigned short int)0;
      ops.sem_flg = (signed short int)0x1000;
      ops.sem_op = (signed short int)-1;
      signed int return_value_semop_2;
      return_value_semop_2=semop(la->semid, &ops, (unsigned long int)1);
      if(!(return_value_semop_2 >= 0))
      {
        syslog(3, "semop up failed: %m");
        goto __CPROVER_DUMP_L8;
      }

      if(!((unsigned long int)(la->end - la->tail) >= 89ul + (unsigned long int)len))
        syslog(3, "enqueue: log area overrun, dropping message\n");

      else
      {
        msg = (struct logmsg *)la->tail;
        init_logmsg(msg, &tv, prio, func, line);
        memcpy((void *)msg->str, (const void *)str, (unsigned long int)(len + 1));
        msg->str_len = (unsigned long int)len;
        la->tail = la->tail + (signed long int)(sizeof(struct logmsg) /*88ul*/  + (unsigned long int)len + (unsigned long int)1);
      }
      ops.sem_op = (signed short int)1;
      signed int return_value_semop_3;
      return_value_semop_3=semop(la->semid, &ops, (unsigned long int)1);
      if(!(return_value_semop_3 >= 0))
      {
        syslog(3, "semop down failed: %m");
        goto __CPROVER_DUMP_L8;
      }

    }

    else
    {
      char str_final[1024l];
      init_logmsg(msg, &tv, prio, func, line);
      len=format->formatter(str_final, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1, msg, (_Bool)1);
      tmp_post_4 = len;
      len = len + 1;
      str_final[(signed long int)tmp_post_4] = (char)10;
      signed int return_value_fileno_5;
      return_value_fileno_5=fileno(stderr);
      xwrite(return_value_fileno_5, (const void *)str_final, (unsigned long int)len);
      fflush(stderr);
    }
  }

__CPROVER_DUMP_L8:
  ;
}

// dump_btree
// file sd_inode.c line 209
static void dump_btree(signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode)
{
  ;
}

// dump_stack_frames
// file logger.c line 800
static signed int dump_stack_frames(void)
{
  signed int return_value_gdb_cmd_1;
  return_value_gdb_cmd_1=gdb_cmd("thread apply all where full");
  return return_value_gdb_cmd_1;
}

// early_log_init
// file ../include/logger.h line 39
void early_log_init(const char *format_name, struct logger_user_info *user_info)
{
  struct log_format *f;
  logger_user_info = user_info;
  struct log_format *__n640;
  struct log_format *tmp_statement_expression_1;
  const struct list_node *__mptr = (&log_formats)->n.next;
  tmp_statement_expression_1 = (struct log_format *)((char *)__mptr - (signed long int)16ul);
  f = tmp_statement_expression_1;
  struct log_format *tmp_statement_expression_2;
  const struct list_node *early_log_init__1__1__2____mptr = f->list.next;
  tmp_statement_expression_2 = (struct log_format *)((char *)early_log_init__1__1__2____mptr - (signed long int)16ul);
  __n640 = tmp_statement_expression_2;
  struct log_format *tmp_statement_expression_3;
  for( ; !(&f->list == &(&log_formats)->n); __n640 = tmp_statement_expression_3)
  {
    signed int return_value_strcmp_4;
    return_value_strcmp_4=strcmp(f->name, format_name);
    if(return_value_strcmp_4 == 0)
    {
      format = f;
      goto __CPROVER_DUMP_L6;
    }

    f = __n640;
    const struct list_node *early_log_init__1__1__3____mptr = __n640->list.next;
    tmp_statement_expression_3 = (struct log_format *)((char *)early_log_init__1__1__3____mptr - (signed long int)16ul);
  }
  log_write(3, "early_log_init", 647, "invalid log format: %s", format_name);
  log_write(3, "early_log_init", 648, "valid options are:");
  struct log_format *__n649;
  struct log_format *tmp_statement_expression_5;
  const struct list_node *early_log_init__1__2__1____mptr = (&log_formats)->n.next;
  tmp_statement_expression_5 = (struct log_format *)((char *)early_log_init__1__2__1____mptr - (signed long int)16ul);
  f = tmp_statement_expression_5;
  struct log_format *tmp_statement_expression_6;
  const struct list_node *early_log_init__1__2__2____mptr = f->list.next;
  tmp_statement_expression_6 = (struct log_format *)((char *)early_log_init__1__2__2____mptr - (signed long int)16ul);
  __n649 = tmp_statement_expression_6;
  struct log_format *tmp_statement_expression_7;
  for( ; !(&f->list == &(&log_formats)->n); __n649 = tmp_statement_expression_7)
  {
    log_write(3, "early_log_init", 650, "\t%s", f->name);
    f = __n649;
    const struct list_node *early_log_init__1__2__3____mptr = __n649->list.next;
    tmp_statement_expression_7 = (struct log_format *)((char *)early_log_init__1__2__3____mptr - (signed long int)16ul);
  }
  exit(1);

__CPROVER_DUMP_L6:
  ;
}

// ec_decode
// file fec.c line 635
void ec_decode(struct fec *ctx, const unsigned char **input, const signed int *inidx, unsigned char *output, signed int idx)
{
  signed int edp = (signed int)ctx->dp;
  signed int ep = (signed int)ctx->dp - (signed int)ctx->d;
  signed int ed = (signed int)ctx->d;
  const signed long int ed_array_size0 = (signed long int)edp;
  const unsigned char *dp[ed_array_size0];
  const signed long int dp_array_size0 = (signed long int)ed;
  const unsigned char *oin[dp_array_size0];
  const signed long int oin_array_size0 = (signed long int)ed;
  signed int oidx[oin_array_size0];
  signed int i;
  signed int strip_size = 1024 / ed;
  const signed long int strip_size_array_size0 = (signed long int)strip_size;
  const signed long int m0_array_size0 = (signed long int)strip_size;
  const signed long int m1_array_size0 = (signed long int)strip_size;
  const signed long int m2_array_size0 = (signed long int)strip_size;
  const signed long int m3_array_size0 = (signed long int)strip_size;
  const signed long int m4_array_size0 = (signed long int)strip_size;
  const signed long int m5_array_size0 = (signed long int)strip_size;
  const signed long int m6_array_size0 = (signed long int)strip_size;
  const signed long int m7_array_size0 = (signed long int)strip_size;
  const signed long int m8_array_size0 = (signed long int)strip_size;
  const signed long int m9_array_size0 = (signed long int)strip_size;
  const signed long int m10_array_size0 = (signed long int)strip_size;
  const signed long int m11_array_size0 = (signed long int)strip_size;
  const signed long int m12_array_size0 = (signed long int)strip_size;
  const signed long int m13_array_size0 = (signed long int)strip_size;
  const signed long int m14_array_size0 = (signed long int)strip_size;
  const signed long int m15_array_size0 = (signed long int)strip_size;
  const signed long int p0_array_size0 = (signed long int)strip_size;
  const signed long int p1_array_size0 = (signed long int)strip_size;
  const signed long int p2_array_size0 = (signed long int)strip_size;
  const signed long int p3_array_size0 = (signed long int)strip_size;
  const signed long int p4_array_size0 = (signed long int)strip_size;
  const signed long int p5_array_size0 = (signed long int)strip_size;
  const signed long int p6_array_size0 = (signed long int)strip_size;
  const signed long int p7_array_size0 = (signed long int)strip_size;
  const signed long int p8_array_size0 = (signed long int)strip_size;
  const signed long int p9_array_size0 = (signed long int)strip_size;
  const signed long int p10_array_size0 = (signed long int)strip_size;
  const signed long int p11_array_size0 = (signed long int)strip_size;
  const signed long int p12_array_size0 = (signed long int)strip_size;
  const signed long int p13_array_size0 = (signed long int)strip_size;
  unsigned char m0[strip_size_array_size0];
  unsigned char m1[m0_array_size0];
  unsigned char m2[m1_array_size0];
  unsigned char m3[m2_array_size0];
  unsigned char m4[m3_array_size0];
  unsigned char m5[m4_array_size0];
  unsigned char m6[m5_array_size0];
  unsigned char m7[m6_array_size0];
  unsigned char m8[m7_array_size0];
  unsigned char m9[m8_array_size0];
  unsigned char m10[m9_array_size0];
  unsigned char m11[m10_array_size0];
  unsigned char m12[m11_array_size0];
  unsigned char m13[m12_array_size0];
  unsigned char m14[m13_array_size0];
  unsigned char m15[m14_array_size0];
  unsigned char p0[m15_array_size0];
  unsigned char p1[p0_array_size0];
  unsigned char p2[p1_array_size0];
  unsigned char p3[p2_array_size0];
  unsigned char p4[p3_array_size0];
  unsigned char p5[p4_array_size0];
  unsigned char p6[p5_array_size0];
  unsigned char p7[p6_array_size0];
  unsigned char p8[p7_array_size0];
  unsigned char p9[p8_array_size0];
  unsigned char p10[p9_array_size0];
  unsigned char p11[p10_array_size0];
  unsigned char p12[p11_array_size0];
  unsigned char p13[p12_array_size0];
  unsigned char p14[p13_array_size0];
  unsigned char *missing[16l] = { m0, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11, m12, m13, m14, m15 };
  unsigned char *p[15l] = { p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14 };
  i = 0;
  for( ; !(i >= edp); i = i + 1)
    dp[(signed long int)i] = (const unsigned char *)(void *)0;
  i = 0;
  for( ; !(i >= ed); i = i + 1)
    oin[(signed long int)i] = (const unsigned char *)(void *)0;
  i = 0;
  for( ; !(i >= ed); i = i + 1)
    oidx[(signed long int)i] = 0;
  i = 0;
  for( ; !(i >= ed); i = i + 1)
    dp[(signed long int)inidx[(signed long int)i]] = input[(signed long int)i];
  decode_prepare(ctx, dp, oin, oidx);
  _Bool return_value_data_is_missing_2;
  return_value_data_is_missing_2=data_is_missing(dp, ed);
  signed int tmp_post_1;
  if(!(return_value_data_is_missing_2 == (_Bool)0))
  {
    signed int m = 0;
    fec_decode(ctx, oin, missing, oidx, (unsigned long int)strip_size);
    i = 0;
    for( ; !(i >= ed); i = i + 1)
      if(dp[(signed long int)i] == ((const unsigned char *)NULL))
      {
        tmp_post_1 = m;
        m = m + 1;
        dp[(signed long int)i] = missing[(signed long int)tmp_post_1];
      }

  }

  if(idx >= ed)
  {
    ec_encode(ctx, dp, p);
    i = 0;
    for( ; !(i >= ep); i = i + 1)
      dp[(signed long int)(ed + i)] = p[(signed long int)i];
  }


out:
  ;
  memcpy((void *)output, (const void *)dp[(signed long int)idx], (unsigned long int)strip_size);
}

// ec_decode_buffer
// file fec.c line 690
void ec_decode_buffer(struct fec *ctx, unsigned char **input, const signed int *in_idx, char *buf, signed int idx)
{
  signed int i;
  signed int j;
  signed int d = (signed int)ctx->d;
  unsigned long int strip_size = (unsigned long int)(1024 / d);
  i = 0;
  for( ; !((unsigned long int)i >= 4096ul); i = i + 1)
  {
    const signed long int strip_size_array_size0 = (signed long int)d;
    const unsigned char *in[strip_size_array_size0];
    const signed long int in_array_size0 = (signed long int)strip_size;
    unsigned char out[in_array_size0];
    j = 0;
    for( ; !(j >= d); j = j + 1)
      in[(signed long int)j] = input[(signed long int)j] + (signed long int)(strip_size * (unsigned long int)i);
    ec_decode(ctx, in, in_idx, out, idx);
    memcpy((void *)(buf + (signed long int)(strip_size * (unsigned long int)i)), (const void *)out, strip_size);
  }
}

// ec_encode
// file ../include/fec.h line 169
static inline void ec_encode(struct fec *ctx, const unsigned char **ds, unsigned char **ps)
{
  signed int p = (signed int)ctx->dp - (signed int)ctx->d;
  const signed long int p_array_size0 = (signed long int)p;
  signed int pidx[p_array_size0];
  signed int i = 0;
  for( ; !(i >= p); i = i + 1)
    pidx[(signed long int)i] = (signed int)ctx->d + i;
  fec_encode(ctx, ds, ps, pidx, (unsigned long int)p, (unsigned long int)(1024 / (signed int)ctx->d));
}

// epoll_event_cmp
// file event.c line 179
static signed int epoll_event_cmp(struct epoll_event *_a, struct epoll_event *_b)
{
  struct event_info *a;
  struct event_info *b;
  a = (struct event_info *)_a->data.ptr;
  b = (struct event_info *)_b->data.ptr;
  signed int tmp_statement_expression_1;
  signed int _x = b->prio;
  signed int _y = a->prio;
  (void)(&_x == &_y);
  tmp_statement_expression_1 = _x < _y ? -1 : (_x > _y ? 1 : 0);
  return tmp_statement_expression_1;
}

// event_cmp
// file event.c line 74
static signed int event_cmp(struct event_info *e1, struct event_info *e2)
{
  signed int tmp_statement_expression_1;
  signed int _x = e1->fd;
  signed int _y = e2->fd;
  (void)(&_x == &_y);
  tmp_statement_expression_1 = _x < _y ? -1 : (_x > _y ? 1 : 0);
  return tmp_statement_expression_1;
}

// event_force_refresh
// file ../include/event.h line 17
void event_force_refresh(void)
{
  event_loop_refresh = (_Bool)1;
}

// event_loop
// file event.c line 218
void event_loop(signed int timeout)
{
  do_event_loop(timeout, (_Bool)0);
}

// event_loop_prio
// file ../include/event.h line 16
void event_loop_prio(signed int timeout)
{
  do_event_loop(timeout, (_Bool)1);
}

// eventfd_xread
// file ../include/util.h line 103
signed int eventfd_xread(signed int efd)
{
  signed int ret;
  unsigned long int value = (unsigned long int)0;
  _Bool tmp_if_expr_2;
  signed int *return_value___errno_location_1;
  do
  {
    ret=eventfd_read(efd, &value);
    if(!(ret >= 0))
    {
      return_value___errno_location_1=__errno_location();
      tmp_if_expr_2 = *return_value___errno_location_1 == 4 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
  }
  while(tmp_if_expr_2);
  signed int *return_value___errno_location_3;
  if(ret == 0)
    ret = (signed int)value;

  else
  {
    return_value___errno_location_3=__errno_location();
    if(!(*return_value___errno_location_3 == 11))
    {
      log_write(0, "eventfd_xread", 291, "PANIC: eventfd_read() failed, %m");
      abort();
    }

  }
  return ret;
}

// eventfd_xwrite
// file ../include/util.h line 104
void eventfd_xwrite(signed int efd, signed int value)
{
  signed int ret;
  _Bool tmp_if_expr_4;
  signed int *return_value___errno_location_1;
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  do
  {
    ret=eventfd_write(efd, (unsigned long int)value);
    if(!(ret >= 0))
    {
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 4)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value___errno_location_2=__errno_location();
        tmp_if_expr_3 = *return_value___errno_location_2 == 11 ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
  }
  while(tmp_if_expr_4);
  if(!(ret >= 0))
  {
    log_write(0, "eventfd_xwrite", 305, "PANIC: eventfd_write() failed, %m");
    abort();
  }

}

// exec_req
// file net.c line 326
signed int exec_req(signed int sockfd, struct sd_req *hdr, void *data, _Bool (*need_retry)(unsigned int), unsigned int epoch, unsigned int max_count)
{
  signed int ret;
  struct sd_rsp *rsp = (struct sd_rsp *)hdr;
  unsigned int wlen;
  unsigned int rlen;
  if(!((0x01 & (signed int)hdr->flags) == 0))
  {
    wlen = hdr->data_length;
    rlen = (unsigned int)0;
  }

  else
  {
    wlen = (unsigned int)0;
    rlen = hdr->data_length;
  }
  signed int return_value_send_req_1;
  return_value_send_req_1=send_req(sockfd, hdr, data, wlen, need_retry, epoch, max_count);
  if(!(return_value_send_req_1 == 0))
    return 1;

  else
  {
    ret=do_read(sockfd, (void *)rsp, (signed int)sizeof(struct sd_rsp) /*48ul*/ , need_retry, epoch, max_count);
    if(!(ret == 0))
    {
      log_write(3, "exec_req", 347, "failed to read a response");
      return 1;
    }

    else
    {
      if(!(rsp->data_length >= rlen))
        rlen = rsp->data_length;

      if(!(rlen == 0u))
      {
        ret=do_read(sockfd, data, (signed int)rlen, need_retry, epoch, max_count);
        if(ret == 0)
          goto __CPROVER_DUMP_L6;

        log_write(3, "exec_req", 357, "failed to read the response data");
        return 1;
      }

      else
      {

      __CPROVER_DUMP_L6:
        ;
        return 0;
      }
    }
  }
}

// exit_handler
// file shepherd.c line 624
static void exit_handler(void)
{
  log_write(6, "exit_handler", 626, "exiting...");
}

// ext_in_range
// file sd_inode.c line 252
static _Bool ext_in_range(struct sd_extent_header *header, struct sd_extent *ext)
{
  struct sd_extent *last = (struct sd_extent *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)header)->entries;
  if(last - ext >= 1l)
    return (_Bool)1;

  else
    return (_Bool)0;
}

// extent_comp
// file sd_inode.c line 108
static signed int extent_comp(void *a, void *b)
{
  struct sd_extent *ea = (struct sd_extent *)a;
  struct sd_extent *eb = (struct sd_extent *)b;
  if(!(eb->idx >= ea->idx))
    return 1;

  else
    if(!(ea->idx >= eb->idx))
      return -1;

    else
      return 0;
}

// fec_decode
// file fec.c line 555
void fec_decode(struct fec *code, const unsigned char * const * const inpkts, unsigned char * const * const outpkts, const signed int * const idx, unsigned long int sz)
{
  const signed long int fec_decode_array_size0 = (signed long int)((signed int)code->d * (signed int)code->d);
  unsigned char m_dec[fec_decode_array_size0];
  unsigned char outix = (unsigned char)0;
  unsigned char row = (unsigned char)0;
  unsigned char col = (unsigned char)0;
  build_decode_matrix_into_space(code, idx, (const unsigned int)code->d, m_dec);
  row = (unsigned char)0;
  for( ; !((signed int)row >= (signed int)code->d); row = row + 1)
    if(idx[(signed long int)row] >= (signed int)code->d)
    {
      memset((void *)outpkts[(signed long int)outix], 0, sz);
      col = (unsigned char)0;
      for( ; !((signed int)col >= (signed int)code->d); col = col + 1)
        if(!((signed int)m_dec[(signed long int)((signed int)code->d * (signed int)row + (signed int)col)] == 0))
          _addmul1(outpkts[(signed long int)outix], inpkts[(signed long int)col], m_dec[(signed long int)((signed int)row * (signed int)code->d + (signed int)col)], sz);

      outix = outix + 1;
    }

}

// fec_encode
// file fec.c line 508
void fec_encode(struct fec *code, const unsigned char * const * const src, unsigned char * const * const fecs, const signed int * const block_nums, unsigned long int num_block_nums, unsigned long int sz)
{
  unsigned char i;
  unsigned char j;
  unsigned long int d;
  unsigned int fecnum;
  const unsigned char *p;
  d = (unsigned long int)0;
  for( ; !(d >= sz); d = d + (unsigned long int)8192)
  {
    unsigned long int stride = sz - d < (unsigned long int)8192 ? sz - d : (unsigned long int)8192;
    i = (unsigned char)0;
    for( ; !((unsigned long int)i >= num_block_nums); i = i + 1)
    {
      fecnum = (unsigned int)block_nums[(signed long int)i];
      memset((void *)(fecs[(signed long int)i] + (signed long int)d), 0, stride);
      p = &code->enc_matrix[(signed long int)(fecnum * (unsigned int)code->d)];
      j = (unsigned char)0;
      for( ; !((signed int)j >= (signed int)code->d); j = j + 1)
        if(!((signed int)p[(signed long int)j] == 0))
          _addmul1(fecs[(signed long int)i] + (signed long int)d, src[(signed long int)j] + (signed long int)d, p[(signed long int)j], stride);

    }
  }
}

// fec_free
// file fec.c line 452
void fec_free(struct fec *p)
{
  free((void *)p->enc_matrix);
  free((void *)p);
}

// fec_new
// file fec.c line 460
struct fec * fec_new(unsigned short int d, unsigned short int dp)
{
  unsigned int row;
  unsigned int col;
  unsigned char *p;
  unsigned char *tmp_m;
  struct fec *retval;
  void *return_value_xmalloc_1;
  return_value_xmalloc_1=xmalloc(sizeof(struct fec) /*24ul*/ );
  retval = (struct fec *)return_value_xmalloc_1;
  retval->d = d;
  retval->dp = dp;
  void *return_value_xmalloc_2;
  return_value_xmalloc_2=xmalloc((unsigned long int)((signed int)dp * (signed int)d));
  retval->enc_matrix = (unsigned char *)return_value_xmalloc_2;
  retval->magic = (unsigned long int)(0xFECC0DEC ^ (unsigned int)d ^ (unsigned int)dp) ^ (unsigned long int)retval->enc_matrix;
  void *return_value_xmalloc_3;
  return_value_xmalloc_3=xmalloc((unsigned long int)((signed int)dp * (signed int)d));
  tmp_m = (unsigned char *)return_value_xmalloc_3;
  tmp_m[(signed long int)0] = (unsigned char)1;
  col = (unsigned int)1;
  for( ; !(col >= (unsigned int)d); col = col + 1u)
    tmp_m[(signed long int)col] = (unsigned char)0;
  p = tmp_m + (signed long int)d;
  row = (unsigned int)0;
  unsigned char return_value_modnn_4;
  for( ; !(row >= 4294967295u + (unsigned int)(signed int)dp); p = p + (signed long int)d)
  {
    col = (unsigned int)0;
    for( ; !(col >= (unsigned int)d); col = col + 1u)
    {
      return_value_modnn_4=modnn((signed int)(row * col));
      p[(signed long int)col] = gf_exp[(signed long int)return_value_modnn_4];
    }
    row = row + 1u;
  }
  _invert_vdm(tmp_m, (unsigned int)d);
  _matmul(tmp_m + (signed long int)((signed int)d * (signed int)d), tmp_m, retval->enc_matrix + (signed long int)((signed int)d * (signed int)d), (unsigned int)((signed int)dp - (signed int)d), (unsigned int)d, (unsigned int)d);
  memset((void *)retval->enc_matrix, 0, (unsigned long int)((signed int)d * (signed int)d) * sizeof(unsigned char) /*1ul*/ );
  p = retval->enc_matrix;
  col = (unsigned int)0;
  for( ; !(col >= (unsigned int)d); p = p + (signed long int)((signed int)d + 1))
  {
    *p = (unsigned char)1;
    col = col + 1u;
  }
  free((void *)tmp_m);
  return retval;
}

// find_sheep_by_nid
// file shepherd.c line 90
static struct sheep * find_sheep_by_nid(struct node_id *id)
{
  struct sheep *s;
  struct sheep *__n94;
  struct sheep *tmp_statement_expression_1;
  const struct list_node *__mptr = (&sheep_list_head)->n.next;
  tmp_statement_expression_1 = (struct sheep *)((char *)__mptr - (signed long int)112ul);
  s = tmp_statement_expression_1;
  struct sheep *tmp_statement_expression_2;
  const struct list_node *find_sheep_by_nid__1__1__2____mptr = s->sheep_list.next;
  tmp_statement_expression_2 = (struct sheep *)((char *)find_sheep_by_nid__1__1__2____mptr - (signed long int)112ul);
  __n94 = tmp_statement_expression_2;
  struct sheep *tmp_statement_expression_3;
  for( ; !(&s->sheep_list == &(&sheep_list_head)->n); __n94 = tmp_statement_expression_3)
  {
    signed int return_value_node_id_cmp_4;
    return_value_node_id_cmp_4=node_id_cmp(&s->node.nid, id);
    if(return_value_node_id_cmp_4 == 0)
      return s;

    s = __n94;
    const struct list_node *find_sheep_by_nid__1__1__3____mptr = __n94->sheep_list.next;
    tmp_statement_expression_3 = (struct sheep *)((char *)find_sheep_by_nid__1__1__3____mptr - (signed long int)112ul);
  }
  return (struct sheep *)(void *)0;
}

// format_thread_name
// file logger.c line 156
static const char * format_thread_name(char *str, unsigned long int size, const char *name, signed int idx)
{
  _Bool tmp_if_expr_2;
  if(!(name == ((const char *)NULL)))
    tmp_if_expr_2 = name[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_2 = (_Bool)0;
  _Bool tmp_if_expr_1;
  if(!(idx == 0) && tmp_if_expr_2)
    snprintf(str, size, "%s %d", name, idx);

  else
  {
    if(!(name == ((const char *)NULL)))
      tmp_if_expr_1 = name[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
      snprintf(str, size, "%s", name);

    else
      snprintf(str, size, "main");
  }
  return str;
}

// forward_iov
// file net.c line 248
static void forward_iov(struct msghdr *msg, signed int len)
{
  for( ; (unsigned long int)len >= msg->msg_iov->iov_len; msg->msg_iovlen = msg->msg_iovlen - 1ul)
  {
    len = len - (signed int)msg->msg_iov->iov_len;
    msg->msg_iov = msg->msg_iov + 1l;
  }
  msg->msg_iov->iov_base = (void *)((char *)msg->msg_iov->iov_base + (signed long int)len);
  msg->msg_iov->iov_len = msg->msg_iov->iov_len - (unsigned long int)len;
}

// free_cache_entry
// file sockfd_cache.c line 149
static void free_cache_entry(struct sockfd_cache_entry *entry)
{
  free((void *)entry->fds);
  free((void *)entry);
}

// free_logarea
// file logger.c line 350
static void free_logarea(void)
{
  if(log_fd >= 0)
    close(log_fd);

  semctl(la->semid, 0, 0, la->semarg);
  shmdt((const void *)la->start);
  shmdt((const void *)la);
}

// gdb_cmd
// file logger.c line 760
static signed int gdb_cmd(const char *cmd)
{
  signed long int time_str_array_size0;
  time_str_array_size0=sysconf(0);
  char time_str[256l];
  char cmd_str[time_str_array_size0];
  signed long int ti;
  struct tm tm;
  _Bool return_value_check_gdb_1;
  return_value_check_gdb_1=check_gdb();
  if(return_value_check_gdb_1 == (_Bool)0)
  {
    if(sd_log_level == 7)
      log_write(7, "gdb_cmd", 767, "cannot find gdb");

    return -1;
  }

  else
  {
    time(&ti);
    localtime_r(&ti, &tm);
    strftime(time_str, sizeof(char [256l]) /*256ul*/ , "%b %2d %H:%M:%S ", &tm);
    const char *return_value_my_exe_path_2;
    return_value_my_exe_path_2=my_exe_path();
    signed int return_value_getpid_3;
    return_value_getpid_3=getpid();
    const char *return_value_my_exe_path_4;
    return_value_my_exe_path_4=my_exe_path();
    snprintf(cmd_str, (unsigned long int)time_str_array_size0, "gdb -nw %s %d -batch >/dev/null 2>&1 -ex 'set logging on' -ex 'echo \\n' -ex 'echo ==\\n' -ex 'echo == %s\\n' -ex 'echo == program: %s\\n' -ex 'echo == command: %s\\n' -ex 'echo ==\\n' -ex '%s' -ex 'set logging off'", return_value_my_exe_path_2, return_value_getpid_3, (const void *)time_str, return_value_my_exe_path_4, cmd, cmd);
    signed int return_value_system_5;
    return_value_system_5=system(cmd_str);
    return return_value_system_5;
  }
}

// generate_gf
// file fec.c line 143
static void generate_gf(void)
{
  signed int i;
  unsigned char mask = (unsigned char)1;
  gf_exp[(signed long int)8] = (unsigned char)0;
  i = 0;
  for( ; !(i >= 8); mask = mask << 1)
  {
    gf_exp[(signed long int)i] = mask;
    gf_log[(signed long int)gf_exp[(signed long int)i]] = i;
    if((signed int)Pp[(signed long int)i] == 49)
      gf_exp[(signed long int)8] = gf_exp[(signed long int)8] ^ mask;

    i = i + 1;
  }
  gf_log[(signed long int)gf_exp[(signed long int)8]] = 8;
  mask = (unsigned char)(1 << 7);
  i = 9;
  for( ; !(i >= 255); i = i + 1)
  {
    if((signed int)gf_exp[(signed long int)(i + -1)] >= (signed int)mask)
      gf_exp[(signed long int)i] = (unsigned char)((signed int)gf_exp[(signed long int)8] ^ ((signed int)gf_exp[(signed long int)(i - 1)] ^ (signed int)mask) << 1);

    else
      gf_exp[(signed long int)i] = (unsigned char)((signed int)gf_exp[(signed long int)(i - 1)] << 1);
    gf_log[(signed long int)gf_exp[(signed long int)i]] = i;
  }
  gf_log[(signed long int)0] = 255;
  i = 0;
  for( ; !(i >= 255); i = i + 1)
    gf_exp[(signed long int)(i + 255)] = gf_exp[(signed long int)i];
  inverse[(signed long int)0] = (unsigned char)0;
  inverse[(signed long int)1] = (unsigned char)1;
  i = 2;
  for( ; !(i >= 256); i = i + 1)
    inverse[(signed long int)i] = gf_exp[(signed long int)(255 - gf_log[(signed long int)i])];
}

// get_buffer_sha1
// file sha1.c line 337
void get_buffer_sha1(unsigned char *buf, unsigned int len, unsigned char *sha1)
{
  struct sha1_ctx c;
  sha1_init((void *)&c);
  sha1_update((void *)&c, buf, len);
  sha1_final((void *)&c, sha1);
}

// get_free_slot
// file sockfd_cache.c line 94
static inline signed int get_free_slot(struct sockfd_cache_entry *entry)
{
  signed int idx = -1;
  signed int i = 0;
  for( ; !(i >= fds_count); i = i + 1)
  {
    _Bool return_value_uatomic_set_true_1;
    return_value_uatomic_set_true_1=uatomic_set_true(&(entry->fds + (signed long int)i)->in_use);
    if(!(return_value_uatomic_set_true_1 == (_Bool)0))
    {
      idx = i;
      break;
    }

  }
  return idx;
}

// get_local_addr
// file net.c line 493
signed int get_local_addr(unsigned char *bytes)
{
  struct ifaddrs *ifaddr;
  struct ifaddrs *ifa;
  signed int ret = 0;
  signed int return_value_getifaddrs_1;
  return_value_getifaddrs_1=getifaddrs(&ifaddr);
  if(return_value_getifaddrs_1 == -1)
  {
    log_write(3, "get_local_addr", 499, "getifaddrs failed: %m");
    return -1;
  }

  else
  {
    ifa = ifaddr;
    for( ; !(ifa == ((struct ifaddrs *)NULL)); ifa = ifa->ifa_next)
    {
      struct sockaddr_in *sin;
      struct sockaddr_in6 *sin6;
      if((8u & ifa->ifa_flags) == 0u)
      {
        if(!(ifa->ifa_addr == ((struct sockaddr *)NULL)))
          switch((signed int)ifa->ifa_addr->sa_family)
          {
            case 2:
            {
              sin = (struct sockaddr_in *)ifa->ifa_addr;
              memset((void *)bytes, 0, (unsigned long int)12);
              memcpy((void *)(bytes + (signed long int)12), (const void *)&sin->sin_addr, (unsigned long int)4);
              memcpy((void *)(bytes + (signed long int)12), (const void *)&sin->sin_addr, (unsigned long int)4);
              log_write(5, "get_local_addr", 519, "found IPv4 address");
              goto out;
            }
            case 10:
            {
              sin6 = (struct sockaddr_in6 *)ifa->ifa_addr;
              memcpy((void *)bytes, (const void *)&sin6->sin6_addr, (unsigned long int)16);
              log_write(5, "get_local_addr", 524, "found IPv6 address");
              goto out;
            }
            default:
              ;
          }

      }

    }
    log_write(3, "get_local_addr", 529, "no valid interface found");
    ret = -1;

  out:
    ;
    freeifaddrs(ifaddr);
    return ret;
  }
}

// get_loglevel
// file logger.c line 861
signed int get_loglevel(void)
{
  return sd_log_level;
}

// get_msec_time
// file work.c line 194
static unsigned long int get_msec_time(void)
{
  struct timeval tv;
  gettimeofday(&tv, (struct timezone *)(void *)0);
  return (unsigned long int)(tv.tv_sec * (signed long int)1000 + tv.tv_usec / (signed long int)1000);
}

// get_thread_name
// file logger.c line 745
void get_thread_name(char *name)
{
  format_thread_name(name, (unsigned long int)20, worker_name, worker_idx);
}

// gettid
// file ../include/util.h line 114
signed int gettid(void)
{
  signed long int return_value_syscall_1;
  return_value_syscall_1=syscall((signed long int)186);
  return (signed int)return_value_syscall_1;
}

// grow_fds_done
// file sockfd_cache.c line 270
static void grow_fds_done(struct work *work)
{
  if(sd_log_level == 7)
    log_write(7, "grow_fds_done", 272, "fd count has been grown into %d", fds_count);

  uatomic_set_false(&fds_in_grow);
  free((void *)work);
}

// idx_in_range
// file sd_inode.c line 261
static _Bool idx_in_range(struct sd_extent_header *header, struct sd_extent_idx *idx)
{
  struct sd_extent_idx *last = (struct sd_extent_idx *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)header)->entries;
  if(last - idx >= 1l)
    return (_Bool)1;

  else
    return (_Bool)0;
}

// index_comp
// file sd_inode.c line 122
static signed int index_comp(void *a, void *b)
{
  struct sd_extent_idx *ia = (struct sd_extent_idx *)a;
  struct sd_extent_idx *ib = (struct sd_extent_idx *)b;
  if(!(ib->idx >= ia->idx))
    return 1;

  else
    if(!(ia->idx >= ib->idx))
      return -1;

    else
      return 0;
}

// inetaddr_is_valid
// file net.c line 574
_Bool inetaddr_is_valid(char *addr)
{
  unsigned char buf[46l];
  signed int af;
  char *return_value_strstr_1;
  return_value_strstr_1=strstr(addr, ":");
  af = return_value_strstr_1 != ((char *)NULL) ? 10 : 2;
  signed int return_value_inet_pton_2;
  return_value_inet_pton_2=inet_pton(af, addr, (void *)buf);
  if(return_value_inet_pton_2 == 0)
  {
    log_write(3, "inetaddr_is_valid", 581, "Bad address '%s'", addr);
    return (_Bool)0;
  }

  else
    return (_Bool)1;
}

// init_event
// file ../include/event.h line 11
signed int init_event(signed int nr)
{
  nr_events = nr;
  void *return_value_xcalloc_1;
  return_value_xcalloc_1=xcalloc((unsigned long int)nr_events, sizeof(struct epoll_event) /*12ul*/ );
  events = (struct epoll_event *)return_value_xcalloc_1;
  efd=epoll_create(nr);
  if(!(efd >= 0))
  {
    log_write(3, "init_event", 86, "failed to create epoll fd");
    return -1;
  }

  else
    return 0;
}

// init_fec
// file fec.c line 438
void init_fec(void)
{
  generate_gf();
  _init_mul_table();
}

// init_logmsg
// file logger.c line 381
static void init_logmsg(struct logmsg *msg, struct timeval *tv, signed int prio, const char *func, signed int line)
{
  msg->tv = *tv;
  msg->prio = prio;
  pstrcpy(msg->func, 32, func);
  msg->line = line;
  if(!(worker_name == ((const char *)NULL)))
    pstrcpy(msg->worker_name, 20, worker_name);

  else
    msg->worker_name[(signed long int)0] = (char)0;
  msg->worker_idx = worker_idx;
}

// init_work_queue
// file work.c line 364
signed int init_work_queue(unsigned long int (*get_nr_nodes)(void))
{
  signed int ret;
  wq_get_nr_nodes = get_nr_nodes;
  if(!(wq_get_nr_nodes == ((unsigned long int (*)(void))NULL)))
    nr_nodes=wq_get_nr_nodes();

  efd_link1=eventfd((unsigned int)0, 2048);
  if(!(efd_link1 >= 0))
  {
    log_write(3, "init_work_queue", 375, "failed to create event fd: %m");
    return -1;
  }

  else
  {
    ret=wq_trace_init();
    if(!(ret >= 0))
      return ret;

    else
    {
      ret=register_event_link2(efd_link1, worker_thread_request_done, (void *)0);
      if(!(ret == 0))
      {
        log_write(3, "init_work_queue", 385, "failed to register event fd %m");
        close(efd_link1);
        return -1;
      }

      else
        return 0;
    }
  }
}

// insert_ext_entry_nosearch
// file sd_inode.c line 290
static void insert_ext_entry_nosearch(struct sd_extent_header *header, struct sd_extent *ext, unsigned int idx, unsigned int vdi_id)
{
  struct sd_extent *last = (struct sd_extent *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)header)->entries;
  memmove((void *)(ext + (signed long int)1), (const void *)ext, (unsigned long int)(last - ext) * sizeof(struct sd_extent) /*8ul*/ );
  ext->idx = idx;
  ext->vdi_id = vdi_id;
  header->entries = header->entries + 1u;
}

// insert_idx_entry
// file sd_inode.c line 314
static void insert_idx_entry(struct sd_extent_header *header, unsigned int idx, unsigned long int oid)
{
  struct sd_extent_idx *found;
  if(!((unsigned long int)header->entries >= 262143ul))
  {
    if(header->entries == 0u)
    {
      ((struct sd_extent_idx *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ))->idx = idx;
      ((struct sd_extent_idx *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ))->oid = oid;
      header->entries = header->entries + 1u;
    }

    else
    {
      found=search_idx_entry(header, idx);
      insert_idx_entry_nosearch(header, found, idx, oid);
    }
  }


out:
  ;
  goto __CPROVER_DUMP_L3;

__CPROVER_DUMP_L3:
  ;
}

// insert_idx_entry_nosearch
// file sd_inode.c line 302
static void insert_idx_entry_nosearch(struct sd_extent_header *header, struct sd_extent_idx *idx_ext, unsigned int idx, unsigned long int oid)
{
  struct sd_extent_idx *last = (struct sd_extent_idx *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)header)->entries;
  memmove((void *)(idx_ext + (signed long int)1), (const void *)idx_ext, (unsigned long int)(last - idx_ext) * sizeof(struct sd_extent_idx) /*16ul*/ );
  idx_ext->idx = idx;
  idx_ext->oid = oid;
  header->entries = header->entries + 1u;
}

// insert_new_node
// file sd_inode.c line 499
static signed int insert_new_node(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, struct find_path *path, unsigned int idx, unsigned int vdi_id)
{
  struct sd_extent_header *header = (struct sd_extent_header *)inode->data_vdi_id;
  struct sd_extent_header *leaf_node = (struct sd_extent_header *)(void *)0;
  unsigned long int oid;
  signed int ret = 0x00;
  unsigned int tmp_post_2;
  if(path->depth == 1)
  {
    if((unsigned long int)header->entries >= 524287ul)
    {
      transfer_to_idx_root(writer, inode);
      ret = 0x1D;
      goto out;
    }

    insert_ext_entry_nosearch(header, path->p_ext, idx, vdi_id);
  }

  else
    if(path->depth == 2)
    {
      _Bool return_value_idx_in_range_3;
      return_value_idx_in_range_3=idx_in_range(header, path->p_idx);
      if(!(return_value_idx_in_range_3 == (_Bool)0))
      {
        if(path->p_ext_header == ((struct sd_extent_header *)NULL))
        {
          ret = 0x1B;
          goto out;
        }

        if((unsigned long int)path->p_ext_header->entries >= 524287ul)
        {
          split_ext_node(writer, inode, path);
          ret = 0x1D;
          goto out;
        }

        insert_ext_entry_nosearch(path->p_ext_header, path->p_ext, idx, vdi_id);
        writer(path->p_idx->oid, (void *)path->p_ext_header, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0, (unsigned int)0, (signed int)inode->nr_copies, (signed int)inode->copy_policy, (_Bool)0, (_Bool)0);
      }

      else
        if(!(path->p_ext_header == ((struct sd_extent_header *)NULL)))
        {
          insert_ext_entry_nosearch(path->p_ext_header, path->p_ext, idx, vdi_id);
          path->p_idx = path->p_idx - 1l;
          path->p_idx->idx = (((struct sd_extent *)((char *)path->p_ext_header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)path->p_ext_header)->entries) - (signed long int)1)->idx;
          writer(path->p_idx->oid, (void *)path->p_ext_header, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0, (unsigned int)0, (signed int)inode->nr_copies, (signed int)inode->copy_policy, (_Bool)0, (_Bool)0);
        }

        else
        {
          if((unsigned long int)header->entries >= 262143ul)
          {
            log_write(0, "insert_new_node", 545, "PANIC: %s() B-tree is full!", (const void *)"insert_new_node");
            abort();
          }

          void *return_value_xvalloc_1;
          return_value_xvalloc_1=xvalloc(sizeof(unsigned int) /*4ul*/  * (1ULL << 20));
          leaf_node = (struct sd_extent_header *)return_value_xvalloc_1;
          sd_inode_init((void *)leaf_node, 2);
          tmp_post_2 = inode->btree_counter;
          inode->btree_counter = inode->btree_counter + 1u;
          oid=vid_to_btree_oid(inode->vdi_id, tmp_post_2);
          insert_ext_entry_nosearch(leaf_node, (struct sd_extent *)((char *)leaf_node + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ), idx, vdi_id);
          writer(oid, (void *)leaf_node, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0, (unsigned int)0, (signed int)inode->nr_copies, (signed int)inode->copy_policy, (_Bool)1, (_Bool)0);
          insert_idx_entry_nosearch(header, path->p_idx, idx, oid);
        }
    }


out:
  ;
  if(!(leaf_node == ((struct sd_extent_header *)NULL)))
    free((void *)leaf_node);

  return ret;
}

// install_crash_handler
// file ../include/util.h line 112
signed int install_crash_handler(void (*handler)(signed int))
{
  signed int return_value_install_sighandler_1;
  return_value_install_sighandler_1=install_sighandler(11, handler, (_Bool)1);
  _Bool tmp_if_expr_3;
  signed int return_value_install_sighandler_2;
  if(!(return_value_install_sighandler_1 == 0))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    return_value_install_sighandler_2=install_sighandler(6, handler, (_Bool)1);
    tmp_if_expr_3 = return_value_install_sighandler_2 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_5;
  signed int return_value_install_sighandler_4;
  if(tmp_if_expr_3)
    tmp_if_expr_5 = (_Bool)1;

  else
  {
    return_value_install_sighandler_4=install_sighandler(7, handler, (_Bool)1);
    tmp_if_expr_5 = return_value_install_sighandler_4 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_7;
  signed int return_value_install_sighandler_6;
  if(tmp_if_expr_5)
    tmp_if_expr_7 = (_Bool)1;

  else
  {
    return_value_install_sighandler_6=install_sighandler(4, handler, (_Bool)1);
    tmp_if_expr_7 = return_value_install_sighandler_6 != 0 ? (_Bool)1 : (_Bool)0;
  }
  _Bool tmp_if_expr_9;
  signed int return_value_install_sighandler_8;
  if(tmp_if_expr_7)
    tmp_if_expr_9 = (_Bool)1;

  else
  {
    return_value_install_sighandler_8=install_sighandler(8, handler, (_Bool)1);
    tmp_if_expr_9 = return_value_install_sighandler_8 != 0 ? (_Bool)1 : (_Bool)0;
  }
  return (signed int)tmp_if_expr_9;
}

// install_sighandler
// file ../include/util.h line 111
signed int install_sighandler(signed int signum, void (*handler)(signed int), _Bool once)
{
  struct sigaction sa = { .__sigaction_handler={ .sa_handler=((void (*)(signed int))NULL) }, .sa_mask={ .__val={ 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul } },
    .sa_flags=0,
    .sa_restorer=((void (*)(void))NULL) };
  sa.__sigaction_handler.sa_handler = handler;
  if(!(once == (_Bool)0))
    sa.sa_flags = (signed int)(0x80000000 | (unsigned int)0x40000000);

  sigemptyset(&sa.sa_mask);
  signed int return_value_sigaction_1;
  return_value_sigaction_1=sigaction(signum, &sa, (struct sigaction *)(void *)0);
  return return_value_sigaction_1;
}

// is_numeric
// file util.c line 399
_Bool is_numeric(const char *s)
{
  const char *p = s;
  const char *tmp_post_1;
  const unsigned short int **return_value___ctype_b_loc_2;
  if(!(*p == 0))
  {
    char c;
    do
    {
      tmp_post_1 = p;
      p = p + 1l;
      c = *tmp_post_1;
      if(c == 0)
        break;

      return_value___ctype_b_loc_2=__ctype_b_loc();
      if((2048 & (signed int)(*return_value___ctype_b_loc_2)[(signed long int)(signed int)c]) == 0)
        return (_Bool)0;

    }
    while((_Bool)1);
    return (_Bool)1;
  }

  return (_Bool)0;
}

// is_sd_node_zero
// file shepherd.c line 68
static _Bool is_sd_node_zero(struct sd_node *node)
{
  signed int return_value_memcmp_1;
  static struct sd_node zero_node;
  return_value_memcmp_1=memcmp((const void *)node, (const void *)&zero_node, sizeof(struct sd_node) /*80ul*/ );
  return !(return_value_memcmp_1 != 0);
}

// is_sheep_dead
// file logger.c line 529
static _Bool is_sheep_dead(signed int signo)
{
  return signo == 1;
}

// is_stdout_console
// file ../include/util.h line 493
static inline _Bool is_stdout_console(void)
{
  signed int return_value_isatty_1;
  return_value_isatty_1=isatty(1);
  return (_Bool)return_value_isatty_1;
}

// is_xattr_enabled
// file util.c line 487
_Bool is_xattr_enabled(const char *path)
{
  signed int ret;
  signed int dummy;
  signed long int return_value_getxattr_1;
  return_value_getxattr_1=getxattr(path, "user.dummy", (void *)&dummy, sizeof(signed int) /*4ul*/ );
  ret = (signed int)return_value_getxattr_1;
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  if(ret == -1)
  {
    return_value___errno_location_2=__errno_location();
    tmp_if_expr_3 = *return_value___errno_location_2 == 95 ? (_Bool)1 : (_Bool)0;
  }

  else
    tmp_if_expr_3 = (_Bool)0;
  return !tmp_if_expr_3;
}

// list_add
// file ../include/list.h line 82
static inline void list_add(struct list_node *new, struct list_head *head)
{
  __list_add(new, &head->n, head->n.next);
}

// list_add_link1
// file ../include/list.h line 82
static inline void list_add_link1(struct list_node *new_link1, struct list_head *head_link1)
{
  __list_add_link1(new_link1, &head_link1->n, head_link1->n.next);
}

// list_add_tail
// file ../include/list.h line 87
static inline void list_add_tail(struct list_node *new, struct list_head *head)
{
  __list_add(new, head->n.prev, &head->n);
}

// list_add_tail_link1
// file ../include/list.h line 87
static inline void list_add_tail_link1(struct list_node *new_link1, struct list_head *head_link1)
{
  __list_add_link1(new_link1, head_link1->n.prev, &head_link1->n);
}

// list_del
// file ../include/list.h line 103
static inline void list_del(struct list_node *entry)
{
  __list_del(entry->prev, entry->next);
  entry->prev = (struct list_node *)(void *)0;
  entry->next = entry->prev;
}

// list_del_link1
// file ../include/list.h line 103
static inline void list_del_link1(struct list_node *entry_link1)
{
  __list_del_link1(entry_link1->prev, entry_link1->next);
  entry_link1->prev = (struct list_node *)(void *)0;
  entry_link1->next = entry_link1->prev;
}

// list_empty
// file ../include/list.h line 42
static inline _Bool list_empty(struct list_head *head)
{
  return head->n.next == &head->n;
}

// list_empty_link1
// file ../include/list.h line 42
static inline _Bool list_empty_link1(struct list_head *head_link1)
{
  return head_link1->n.next == &head_link1->n;
}

// list_empty_link2
// file ../include/list.h line 42
static inline _Bool list_empty_link2(struct list_head *head_link2)
{
  return head_link2->n.next == &head_link2->n;
}

// list_sort
// file util.c line 700
void list_sort(void *priv, struct list_head *head, signed int (*cmp)(void *, struct list_node *, struct list_node *))
{
  struct list_node *part[21l];
  signed int lev;
  signed int max_lev = 0;
  struct list_node *list;
  _Bool return_value_list_empty_1;
  return_value_list_empty_1=list_empty_link1(head);
  if(return_value_list_empty_1 == (_Bool)0)
  {
    memset((void *)part, 0, sizeof(struct list_node *[21l]) /*168ul*/ );
    head->n.prev->next = (struct list_node *)(void *)0;
    list = head->n.next;
    while(!(list == ((struct list_node *)NULL)))
    {
      struct list_node *cur = list;
      list = list->next;
      cur->next = (struct list_node *)(void *)0;
      lev = 0;
      for( ; !(part[(signed long int)lev] == ((struct list_node *)NULL)); lev = lev + 1)
      {
        cur=merge(priv, cmp, part[(signed long int)lev], cur);
        part[(signed long int)lev] = (struct list_node *)(void *)0;
      }
      if(!(max_lev >= lev))
      {
        if((unsigned long int)lev >= 20ul)
          lev = lev - 1;

        max_lev = lev;
      }

      part[(signed long int)lev] = cur;
    }
    lev = 0;
    for( ; !(lev >= max_lev); lev = lev + 1)
      if(!(part[(signed long int)lev] == ((struct list_node *)NULL)))
        list=merge(priv, cmp, part[(signed long int)lev], list);

    merge_and_restore_back_links(priv, cmp, head, part[(signed long int)max_lev], list);
  }

}

// list_splice_init
// file ../include/list.h line 136
static inline void list_splice_init(struct list_head *list, struct list_head *head)
{
  _Bool return_value_list_empty_1;
  return_value_list_empty_1=list_empty_link2(list);
  if(return_value_list_empty_1 == (_Bool)0)
  {
    __list_splice(list, &head->n, head->n.next);
    INIT_LIST_HEAD(list);
  }

}

// log_close
// file logger.c line 712
void log_close(void)
{
  signed int pid;
  if(!(la == ((struct logarea *)NULL)))
    while((_Bool)1)
    {
      la->active = (_Bool)0;
      pid=waitpid(logger_pid, (signed int *)(void *)0, 1);
      if(pid == 0)
      {
        usleep((unsigned int)100000);
        continue;
      }

      else
        if(pid >= 1)
        {
          syslog(4, "logger pid %d stopped\n", logger_pid);
          closelog();
          free_logarea();
          break;
        }

        else
        {
          syslog(3, "waitpid() failure\n");
          exit(1);
        }
    }

}

// log_flush
// file logger.c line 494
static void log_flush(void)
{
  struct sembuf ops;
  unsigned long int size;
  unsigned long int done = (unsigned long int)0;
  struct logmsg *msg;
  if(!(la->tail == la->start))
  {
    ops.sem_num = (unsigned short int)0;
    ops.sem_flg = (signed short int)0x1000;
    ops.sem_op = (signed short int)-1;
    signed int return_value_semop_1;
    return_value_semop_1=semop(la->semid, &ops, (unsigned long int)1);
    if(!(return_value_semop_1 >= 0))
    {
      syslog(3, "semop up failed: %m");
      exit(1);
    }

    size = (unsigned long int)(la->tail - la->start);
    memcpy((void *)log_buff, (const void *)la->start, size);
    memset((void *)la->start, 0, size);
    la->tail = la->start;
    ops.sem_op = (signed short int)1;
    signed int return_value_semop_2;
    return_value_semop_2=semop(la->semid, &ops, (unsigned long int)1);
    if(!(return_value_semop_2 >= 0))
    {
      syslog(3, "semop down failed: %m");
      exit(1);
    }

    for( ; !(done >= size); done = done + sizeof(struct logmsg) /*88ul*/  + msg->str_len + (unsigned long int)1)
    {
      msg = (struct logmsg *)(log_buff + (signed long int)done);
      log_syslog(msg);
    }
  }

}

// log_init
// file ../include/logger.h line 41
signed int log_init(const char *program_name, enum log_dst_type type, signed int level, char *outfile)
{
  char log_dir[4096l];
  char tmp[4096l];
  signed int size = level == 7 ? 32 * 1024 * 1024 : 1 * 1024 * 1024;
  dst_type = type;
  sd_log_level = level;
  log_name = program_name;
  log_nowname = outfile;
  pstrcpy(tmp, (signed int)sizeof(char [4096l]) /*4096ul*/ , outfile);
  char *return_value_dirname_1;
  return_value_dirname_1=dirname(tmp);
  pstrcpy(log_dir, (signed int)sizeof(char [4096l]) /*4096ul*/ , return_value_dirname_1);
  signed long int return_value_random_2;
  return_value_random_2=random();
  semkey = (signed int)return_value_random_2;
  _Bool return_value_is_stdout_console_3;
  signed int return_value_logarea_init_4;
  switch((signed int)type)
  {
    case LOG_DST_STDOUT:
    {
      return_value_is_stdout_console_3=is_stdout_console();
      if(!(return_value_is_stdout_console_3 == (_Bool)0))
        colorize = (_Bool)1;

      break;
    }
    case LOG_DST_SYSLOG:
      openlog(program_name, 0x01, 3 << 3);
    case LOG_DST_DEFAULT:
    {
      return_value_logarea_init_4=logarea_init(size);
      if(!(return_value_logarea_init_4 == 0))
      {
        syslog(3, "failed to initialize the logger\n");
        return 1;
      }

      sheep_pid=getpid();
      logger_pid=fork();
      if(!(logger_pid >= 0))
      {
        syslog(3, "failed to fork the logger process: %m\n");
        return 1;
      }

      if(!(logger_pid == 0))
        syslog(4, "logger pid %d starting\n", logger_pid);

      else
        logger(log_dir, outfile);
      break;
    }
    default:
    {
      log_write(3, "log_init", 705, "unknown type of log destination type: %d", type);
      return -1;
    }
  }
  return 0;
}

// log_syslog
// file logger.c line 360
static void log_syslog(struct logmsg *msg)
{
  char str[1024l];
  signed int len;
  len=format->formatter(str, sizeof(char [1024l]) /*1024ul*/  - (unsigned long int)1, msg, log_fd >= 0);
  signed int tmp_post_1;
  signed int tmp_post_2;
  if((signed int)dst_type == LOG_DST_DEFAULT)
  {
    tmp_post_1 = len;
    len = len + 1;
    str[(signed long int)tmp_post_1] = (char)10;
  }

  else
  {
    tmp_post_2 = len;
    len = len + 1;
    str[(signed long int)tmp_post_2] = (char)0;
  }
  block_sighup();
  if(log_fd >= 0)
    xwrite(log_fd, (const void *)str, (unsigned long int)len);

  else
    syslog(msg->prio, "%s", (const void *)str);
  unblock_sighup();
}

// log_write
// file ../include/logger.h line 45
void log_write(signed int prio, const char *func, signed int line, const char *fmt, ...)
{
  void **ap;
  if(sd_log_level >= prio)
  {
    ap = (void **)&fmt;
    dolog(prio, func, line, fmt, ap);
    ap = ((void **)NULL);
  }

}

// logarea_init
// file logger.c line 289
static signed int logarea_init(signed int size)
{
  signed int shmid;
  shmid=shmget((signed int)0, sizeof(struct logarea) /*56ul*/ , 0644 | 01000 | 02000);
  if(shmid == -1)
  {
    syslog(3, "shmget logarea failed: %m");
    return 1;
  }

  else
  {
    void *return_value_shmat_1;
    return_value_shmat_1=shmat(shmid, (void *)0, 0);
    la = (struct logarea *)return_value_shmat_1;
    if(la == ((struct logarea *)NULL))
    {
      syslog(3, "shmat logarea failed: %m");
      return 1;
    }

    else
    {
      shmctl(shmid, 0, (struct shmid_ds *)(void *)0);
      if(!(size >= 1024))
        size = 1 * 1024 * 1024;

      shmid=shmget((signed int)0, (unsigned long int)size, 0644 | 01000 | 02000);
      if(shmid == -1)
      {
        syslog(3, "shmget msg failed: %m");
        shmdt((const void *)la);
        return 1;
      }

      else
      {
        void *return_value_shmat_2;
        return_value_shmat_2=shmat(shmid, (void *)0, 0);
        la->start = (char *)return_value_shmat_2;
        if(la->start == ((char *)NULL))
        {
          syslog(3, "shmat msg failed: %m");
          shmdt((const void *)la);
          return 1;
        }

        else
        {
          memset((void *)la->start, 0, (unsigned long int)size);
          shmctl(shmid, 0, (struct shmid_ds *)(void *)0);
          la->end = la->start + (signed long int)size;
          la->tail = la->start;
          la->semid=semget(semkey, 1, 0666 | 01000);
          if(!(la->semid >= 0))
          {
            syslog(3, "semget failed: %m");
            shmdt((const void *)la->start);
            shmdt((const void *)la);
            return 1;
          }

          else
          {
            la->semarg.val = 1;
            signed int return_value_semctl_3;
            return_value_semctl_3=semctl(la->semid, 0, 16, la->semarg);
            if(!(return_value_semctl_3 >= 0))
            {
              syslog(3, "semctl failed: %m");
              shmdt((const void *)la->start);
              shmdt((const void *)la);
              return 1;
            }

            else
              return 0;
          }
        }
      }
    }
  }
}

// logger
// file logger.c line 560
static void logger(char *log_dir, char *outfile)
{
  signed int fd;
  void *return_value_xzalloc_1;
  return_value_xzalloc_1=xzalloc((unsigned long int)(la->end - la->start));
  log_buff = (char *)return_value_xzalloc_1;
  if((signed int)dst_type == LOG_DST_DEFAULT)
  {
    log_fd=open(outfile, 0100 | 02 | 02000, 0644);
    if(!(log_fd >= 0))
    {
      syslog(3, "failed to open %s\n", outfile);
      exit(1);
    }

  }

  la->active = (_Bool)1;
  fd=open("/dev/null", 02);
  if(!(fd >= 0))
  {
    syslog(3, "failed to open /dev/null: %m\n");
    exit(1);
  }

  dup2(fd, 0);
  dup2(fd, 1);
  dup2(fd, 2);
  setsid();
  signed int return_value_chdir_2;
  return_value_chdir_2=chdir(log_dir);
  if(!(return_value_chdir_2 >= 0))
  {
    syslog(3, "failed to chdir to %s: %m\n", log_dir);
    exit(1);
  }

  install_crash_handler(crash_handler_link1);
  install_sighandler(1, sighup_handler, (_Bool)0);
  signed int return_value_kill_3;
  return_value_kill_3=kill(sheep_pid, 0);
  if(!(return_value_kill_3 >= 0))
    kill(logger_pid, 1);

  while(!(la->active == (_Bool)0))
  {
    log_flush();
    block_sighup();
    if((signed int)dst_type == LOG_DST_DEFAULT && !(max_logsize == 0l))
    {
      signed long int offset;
      offset=lseek(log_fd, (signed long int)0, 2);
      if(!(offset >= 0l))
        syslog(3, "sheep log error\n");

      else
      {
        unsigned long int log_size = (unsigned long int)offset;
        if(log_size >= (unsigned long int)max_logsize)
          rotate_log();

      }
    }

    unblock_sighup();
    signed int return_value_getppid_4;
    return_value_getppid_4=getppid();
    if(return_value_getppid_4 == 1)
      break;

    sleep((unsigned int)1);
  }
  log_flush();
  free((void *)log_buff);
  free_logarea();
  exit(0);
}

// lookup_event
// file event.c line 92
static struct event_info * lookup_event(signed int fd)
{
  struct event_info key = { .handler=((void (*)(signed int, signed int, void *))NULL), .fd=fd,
    .data=NULL, .rb={ .rb_parent_color=0ul, .rb_right=((struct rb_node *)NULL), .rb_left=((struct rb_node *)NULL) }, .prio=0 };
  struct event_info *tmp_statement_expression_1;
  struct rb_node *__n = (&events_tree)->rb_node;
  struct event_info *__ret = (struct event_info *)(void *)0;
  struct event_info *__data;
  struct event_info *tmp_statement_expression_2;
  while(!(__n == ((struct rb_node *)NULL)))
  {
    const struct rb_node *__mptr = __n;
    tmp_statement_expression_2 = (struct event_info *)((char *)__mptr - (signed long int)24ul);
    __data = tmp_statement_expression_2;
    signed int __cmp;
    __cmp=event_cmp(&key, __data);
    if(!(__cmp >= 0))
      __n = __n->rb_left;

    else
      if(__cmp >= 1)
        __n = __n->rb_right;

      else
      {
        __ret = __data;
        break;
      }
  }
  tmp_statement_expression_1 = __ret;
  return tmp_statement_expression_1;
}

// main
// file shepherd.c line 649
signed int main(signed int argc, char **argv)
{
  signed int ch;
  signed int ret;
  signed int longindex;
  char *p;
  _Bool daemonize = (_Bool)1;
  signed int log_level = 6;
  const char *log_file = "/var/log/shepherd.log";
  const char *log_format = "server";
  struct logger_user_info shepherd_info;
  signed int port = 2501;
  const char *bindaddr = (const char *)(void *)0;
  struct option *long_options;
  const char *short_options;
  printf("\033[1;31m** WARNING: shepherd is still only suitable for testing and review **\033[0m\n");
  progname = argv[(signed long int)0];
  install_crash_handler(crash_handler);
  long_options=build_long_options(shepherd_options);
  short_options=build_short_options(shepherd_options);
  signed long int return_value_strtol_1;
  do
  {
    ch=getopt_long(argc, argv, short_options, long_options, &longindex);
    if(!(ch >= 0))
      break;

    switch(ch)
    {
      case 98:
      {
        bindaddr = optarg;
        break;
      }
      case 100:
      {
        log_level = 7;
        break;
      }
      case 102:
      {
        daemonize = (_Bool)0;
        break;
      }
      case 70:
      {
        log_format = optarg;
        break;
      }
      case 104:
      {
        usage();
        exit(0);
        break;
      }
      case 108:
      {
        log_file = optarg;
        break;
      }
      case 112:
      {
        return_value_strtol_1=strtol(optarg, &p, 10);
        port = (signed int)return_value_strtol_1;
        if(p == optarg)
        {
          log_write(3, "main", 700, "invalid port: %s", optarg);
          exit(1);
        }

        break;
      }
      default:
      {
        log_write(3, "main", 705, "unknown option: %c", ch);
        usage();
        exit(1);
      }
    }
  }
  while((_Bool)1);
  if(!(daemonize == (_Bool)0))
  {
    ret=daemon(0, 0);
    if(ret == -1)
    {
      log_write(3, "main", 716, "daemon() failed: %m");
      exit(1);
    }

  }

  shepherd_info.port = port;
  early_log_init(log_format, &shepherd_info);
  ret=log_init(progname, (enum log_dst_type)!(daemonize != (_Bool)0), log_level, (char *)log_file);
  if(!(ret == 0))
  {
    log_write(0, "main", 726, "PANIC: initialize logger failed: %m");
    abort();
  }

  atexit(exit_handler);
  init_event(6144);
  remove_efd=eventfd((unsigned int)0, 2048);
  if(!(remove_efd >= 0))
  {
    log_write(0, "main", 733, "PANIC: eventfd() failed: %m");
    abort();
  }

  ret=register_event_prio(remove_efd, remove_handler, (void *)0, 0x7fffffff);
  if(!(ret == 0))
  {
    log_write(0, "main", 738, "PANIC: register_event() failed: %m");
    abort();
  }

  ret=create_listen_ports(bindaddr, port, set_listen_fd_cb, (void *)0);
  if(!(ret == 0))
  {
    log_write(0, "main", 743, "PANIC: create_listen_ports() failed: %m");
    abort();
  }

  running = (_Bool)1;
  while(!(running == (_Bool)0))
    event_loop_prio(-1);
  return 0;
}

// make_path
// file util.c line 554
void make_path(char *path, unsigned long int size, unsigned long int nr_segs, const char **segs)
{
  signed int i = 0;
  for( ; !((unsigned long int)i >= nr_segs); i = i + 1)
  {
    signed int len;
    len=snprintf(path, size, "/%s", segs[(signed long int)i]);
    path = path + (signed long int)len;
    size = size - (unsigned long int)len;
  }
}

// merge
// file util.c line 616
static struct list_node * merge(void *priv, signed int (*cmp)(void *, struct list_node *, struct list_node *), struct list_node *a, struct list_node *b)
{
  struct list_node head;
  struct list_node *tail = &head;
  if(!(a == ((struct list_node *)NULL)) && !(b == ((struct list_node *)NULL)))
  {
    signed int return_value;
    return_value=cmp(priv, a, b);
    if(!(return_value >= 1))
    {
      tail->next = a;
      a = a->next;
    }

    else
    {
      tail->next = b;
      b = b->next;
    }
    tail = tail->next;
  }

  tail->next = (_Bool)a ? a : b;
  return head.next;
}

// merge_and_restore_back_links
// file util.c line 646
static void merge_and_restore_back_links(void *priv, signed int (*cmp)(void *, struct list_node *, struct list_node *), struct list_head *head, struct list_node *a, struct list_node *b)
{
  struct list_node *tail = &head->n;
  if(!(a == ((struct list_node *)NULL)) && !(b == ((struct list_node *)NULL)))
  {
    signed int return_value;
    return_value=cmp(priv, a, b);
    if(!(return_value >= 1))
    {
      tail->next = a;
      a->prev = tail;
      a = a->next;
    }

    else
    {
      tail->next = b;
      b->prev = tail;
      b = b->next;
    }
    tail = tail->next;
  }

  tail->next = (_Bool)a ? a : b;
  cmp(priv, tail->next, tail->next);
  tail->next->prev = tail;
  tail = tail->next;
  tail->next = &head->n;
  head->n.prev = tail;
}

// modify_event
// file event.c line 148
signed int modify_event(signed int fd, unsigned int new_events)
{
  signed int ret;
  struct epoll_event ev;
  struct event_info *ei;
  ei=lookup_event(fd);
  if(ei == ((struct event_info *)NULL))
  {
    log_write(3, "modify_event", 156, "event info for fd %d not found", fd);
    return 1;
  }

  else
  {
    memset((void *)&ev, 0, sizeof(struct epoll_event) /*12ul*/ );
    ev.events = new_events;
    ev.data.ptr = (void *)ei;
    ret=epoll_ctl(efd, 3, fd, &ev);
    if(!(ret == 0))
    {
      log_write(3, "modify_event", 166, "failed to modify epoll event for fd %d: %m", fd);
      return 1;
    }

    else
      return 0;
  }
}

// modnn
// file fec.c line 89
static unsigned char modnn(signed int x)
{
  for( ; x >= 255; x = (x >> 8) + (x & 255))
    x = x - 255;
  return (unsigned char)x;
}

// my_exe_path
// file ../include/util.h line 117
const char * my_exe_path(void)
{
  signed int ret;
  static char path[4096l];
  if((signed int)path[0l] == 0)
  {
    signed long int return_value_readlink_1;
    return_value_readlink_1=readlink("/proc/self/exe", path, sizeof(char [4096l]) /*4096ul*/ );
    ret = (signed int)return_value_readlink_1;
    if(!(ret >= -1))
    {
      log_write(0, "my_exe_path", 504, "PANIC: %m");
      abort();
    }

  }

  return path;
}

// node_id_cmp
// file ../include/sheep.h line 186
static inline signed int node_id_cmp(struct node_id *node1, struct node_id *node2)
{
  signed int cmp;
  cmp=memcmp((const void *)node1->addr, (const void *)node2->addr, sizeof(unsigned char [16l]) /*16ul*/ );
  signed int tmp_statement_expression_1;
  if(!(cmp == 0))
    return cmp;

  else
  {
    unsigned short int _x = node1->port;
    unsigned short int _y = node2->port;
    (void)(&_x == &_y);
    tmp_statement_expression_1 = (signed int)_x < (signed int)_y ? -1 : ((signed int)_x > (signed int)_y ? 1 : 0);
    return tmp_statement_expression_1;
  }
}

// node_id_cmp_link1
// file ../include/sheep.h line 186
static inline signed int node_id_cmp_link1(struct node_id *node1_link1, struct node_id *node2_link1)
{
  signed int cmp_link1;
  cmp_link1=memcmp((const void *)node1_link1->addr, (const void *)node2_link1->addr, sizeof(unsigned char [16l]) /*16ul*/ );
  signed int tmp_statement_expression_1_link1;
  if(!(cmp_link1 == 0))
    return cmp_link1;

  else
  {
    unsigned short int _x_link1 = node1_link1->port;
    unsigned short int _y_link1 = node2_link1->port;
    (void)(&_x_link1 == &_y_link1);
    tmp_statement_expression_1_link1 = (signed int)_x_link1 < (signed int)_y_link1 ? -1 : ((signed int)_x_link1 > (signed int)_y_link1 ? 1 : 0);
    return tmp_statement_expression_1_link1;
  }
}

// node_to_str
// file ../include/sheep.h line 244
static inline const char * node_to_str(struct sd_node *id)
{
  signed int af = 10;
  const unsigned char *addr = id->nid.addr;
  signed int tmp_post_1;
  if(!(addr[12l] == 0))
  {
    signed int oct_no = 0;
    while(addr[(signed long int)oct_no] == 0)
    {
      tmp_post_1 = oct_no;
      oct_no = oct_no + 1;
      if(tmp_post_1 >= 12)
        break;

    }
    if(oct_no == 12)
      af = 2;

  }

  const char *return_value_addr_to_str_2;
  return_value_addr_to_str_2=addr_to_str(id->nid.addr, (unsigned short int)0);
  static char str[256l];
  snprintf(str, sizeof(char [256l]) /*256ul*/ , "%s ip:%s port:%d", af == 2 ? "IPv4" : "IPv6", return_value_addr_to_str_2, id->nid.port);
  return str;
}

// notify_remove_sheep
// file shepherd.c line 115
static signed int notify_remove_sheep(struct sheep *leaving)
{
  signed int ret;
  signed int failed = 0;
  struct sheep *s;
  struct sph_msg snd;
  snd.type = (unsigned int)7;
  snd.body_len = (unsigned int)sizeof(struct sd_node) /*80ul*/ ;
  struct sheep *__n124;
  struct sheep *tmp_statement_expression_1;
  const struct list_node *__mptr = (&sheep_list_head)->n.next;
  tmp_statement_expression_1 = (struct sheep *)((char *)__mptr - (signed long int)112ul);
  s = tmp_statement_expression_1;
  struct sheep *tmp_statement_expression_2;
  const struct list_node *notify_remove_sheep__1__1__2____mptr = s->sheep_list.next;
  tmp_statement_expression_2 = (struct sheep *)((char *)notify_remove_sheep__1__1__2____mptr - (signed long int)112ul);
  __n124 = tmp_statement_expression_2;
  struct sheep *tmp_statement_expression_3;
  for( ; !(&s->sheep_list == &(&sheep_list_head)->n); __n124 = tmp_statement_expression_3)
  {
    if((signed int)s->state == SHEEP_STATE_JOINED)
    {
      ret=do_writev2(s->fd, (void *)&snd, sizeof(struct sph_msg) /*8ul*/ , (void *)&leaving->node, sizeof(struct sd_node) /*80ul*/ );
      if(!((unsigned long int)ret == sizeof(struct sph_msg) * 11 /*88ul*/ ))
      {
        log_write(3, "notify_remove_sheep", 132, "writev2() failed: %m");
        remove_sheep(s);
        failed = failed + 1;
      }

    }

    s = __n124;
    const struct list_node *notify_remove_sheep__1__1__3____mptr = __n124->sheep_list.next;
    tmp_statement_expression_3 = (struct sheep *)((char *)notify_remove_sheep__1__1__3____mptr - (signed long int)112ul);
  }
  return failed;
}

// option_get_help
// file option.c line 53
const char * option_get_help(struct sd_option *sd_opts, signed int ch)
{
  struct sd_option *opt = sd_opts;
  for( ; !(opt->name == ((const char *)NULL)); opt = opt + 1l)
    if(opt->ch == ch)
      return opt->help;

  return (const char *)(void *)0;
}

// option_parse
// file option.c line 104
signed int option_parse(char *arg, const char *delim, struct option_parser *parsers)
{
  char *savep;
  char *opt;
  struct option_parser *iter = (struct option_parser *)(void *)0;
  opt=strtok_r(arg, delim, &savep);
  do
  {
    iter = parsers;
    for( ; !(iter->option == ((const char *)NULL)); iter = iter + 1l)
    {
      signed int len;
      unsigned long int return_value_strlen_1;
      return_value_strlen_1=strlen(iter->option);
      len = (signed int)return_value_strlen_1;
      signed int return_value_strncmp_2;
      return_value_strncmp_2=strncmp(iter->option, opt, (unsigned long int)len);
      if(return_value_strncmp_2 == 0)
      {
        signed int return_value;
        return_value=iter->parser(opt + (signed long int)len);
        if(!(return_value >= 0))
          return -1;

        break;
      }

    }
    if(iter->option == ((const char *)NULL))
    {
      log_write(3, "option_parse", 121, "invalid option %s", opt);
      return -1;
    }

    opt=strtok_r((char *)(void *)0, delim, &savep);
  }
  while(!(opt == ((char *)NULL)));
  return 0;
}

// option_parse_size
// file option.c line 64
signed int option_parse_size(const char *value, unsigned long int *ret)
{
  char *postfix;
  double sizef;
  sizef=strtod(value, &postfix);
  if(!((signed int)*postfix == 0))
  {
    if(!((signed int)postfix[1l] == 0))
      goto err;

  }

  switch((signed int)*postfix)
  {
    case 80:

    case 112:
      sizef = sizef * (double)1024;
    case 84:

    case 116:
      sizef = sizef * (double)1024;
    case 71:

    case 103:
      sizef = sizef * (double)1024;
    case 77:

    case 109:
      sizef = sizef * (double)1024;
    case 75:

    case 107:
      sizef = sizef * (double)1024;
    case 98:

    case 0:
    {
      *ret = (unsigned long int)sizef;
      break;
    }
    default:
    {

    err:
      ;
      log_write(3, "option_parse_size", 95, "Invalid size '%s'", value);
      log_write(3, "option_parse_size", 97, "You may use k, M, G, T or P suffixes for kilobytes, megabytes, gigabytes, terabytes and petabytes.");
      return -1;
    }
  }
  return 0;
}

// pstrcpy
// file ../include/util.h line 105
void pstrcpy(char *buf, signed int buf_size, const char *str)
{
  signed int c;
  char *q = buf;
  const char *tmp_post_1;
  char *tmp_post_2;
  if(buf_size >= 1)
  {
    for( ; (_Bool)1; *tmp_post_2 = (char)c)
    {
      tmp_post_1 = str;
      str = str + 1l;
      c = (signed int)*tmp_post_1;
      if(c == 0 || q >= buf + (signed long int)buf_size + -1l)
        break;

      tmp_post_2 = q;
      q = q + 1l;
    }
    *q = (char)0;
  }

}

// purge_directory
// file util.c line 346
signed int purge_directory(const char *dir_path)
{
  signed int ret = 0;
  struct stat s;
  struct __dirstream *dir;
  struct dirent *d;
  char path[4096l];
  dir=opendir(dir_path);
  if(dir == ((struct __dirstream *)NULL))
  {
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(!(*return_value___errno_location_1 == 2))
      log_write(3, "purge_directory", 357, "failed to open %s: %m", dir_path);

    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    return -(*return_value___errno_location_2);
  }

  _Bool tmp_if_expr_5;
  signed int return_value_strcmp_4;
  do
  {
    d=readdir(dir);
    if(d == ((struct dirent *)NULL))
      break;

    signed int return_value_strcmp_3;
    return_value_strcmp_3=strcmp(d->d_name, ".");
    if(return_value_strcmp_3 == 0)
      tmp_if_expr_5 = (_Bool)1;

    else
    {
      return_value_strcmp_4=strcmp(d->d_name, "..");
      tmp_if_expr_5 = !(return_value_strcmp_4 != 0) ? (_Bool)1 : (_Bool)0;
    }
    if(!tmp_if_expr_5)
    {
      snprintf(path, sizeof(char [4096l]) /*4096ul*/ , "%s/%s", dir_path, (const void *)d->d_name);
      ret=stat(path, &s);
      if(!(ret == 0))
      {
        log_write(3, "purge_directory", 368, "failed to stat %s: %m", (const void *)path);
        break;
      }

      if((61440u & s.st_mode) == 16384u)
        ret=rmdir_r(path);

      else
        ret=unlink(path);
      if(!(ret == 0))
      {
        log_write(3, "purge_directory", 378, "failed to remove %s %s: %m", (s.st_mode & (unsigned int)0170000) == (unsigned int)0040000 ? "directory" : "file", (const void *)path);
        break;
      }

    }

  }
  while((_Bool)1);

out:
  ;
  closedir(dir);
  return ret;
}

// queue_work
// file work.c line 270
void queue_work(struct work_queue *q, struct work *work)
{
  struct wq_info *wi;
  struct wq_info *tmp_statement_expression_1;
  const struct work_queue *__mptr = q;
  tmp_statement_expression_1 = (struct wq_info *)((char *)__mptr - (signed long int)208ul);
  wi = tmp_statement_expression_1;
  __uatomic_inc((void *)&wi->nr_queued_work, (signed int)sizeof(unsigned long int) /*8ul*/ );
  sd_mutex_lock(&wi->pending_lock);
  _Bool return_value_wq_need_grow_2;
  return_value_wq_need_grow_2=wq_need_grow(wi);
  if(!(return_value_wq_need_grow_2 == (_Bool)0))
    create_worker_threads(wi, wi->nr_threads * (unsigned long int)2);

  list_add_tail_link1(&work->w_list, &wi->q.pending_list);
  sd_mutex_unlock(&wi->pending_lock);
  sd_cond_signal(&wi->pending_cond);
}

// rb_erase
// file ../include/rbtree.h line 57
void rb_erase(struct rb_node *node, struct rb_root *root)
{
  struct rb_node *child;
  struct rb_node *parent;
  signed int color;
  if(node->rb_left == ((struct rb_node *)NULL))
    child = node->rb_right;

  else
    if(node->rb_right == ((struct rb_node *)NULL))
      child = node->rb_left;

    else
    {
      struct rb_node *old = node;
      struct rb_node *left;
      node = node->rb_right;
      do
      {
        left = node->rb_left;
        if(left == ((struct rb_node *)NULL))
          break;

        node = left;
      }
      while((_Bool)1);
      if(!((18446744073709551612ul & old->rb_parent_color) == 0ul))
      {
        if(((struct rb_node *)(18446744073709551612ul & old->rb_parent_color))->rb_left == old)
          ((struct rb_node *)(old->rb_parent_color & (unsigned long int)~3))->rb_left = node;

        else
          ((struct rb_node *)(old->rb_parent_color & (unsigned long int)~3))->rb_right = node;
      }

      else
        root->rb_node = node;
      child = node->rb_right;
      parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
      color = (signed int)(node->rb_parent_color & (unsigned long int)1);
      if(parent == old)
        parent = node;

      else
      {
        if(!(child == ((struct rb_node *)NULL)))
          rb_set_parent(child, parent);

        parent->rb_left = child;
        node->rb_right = old->rb_right;
        rb_set_parent(old->rb_right, node);
      }
      node->rb_parent_color = old->rb_parent_color;
      node->rb_left = old->rb_left;
      rb_set_parent(old->rb_left, node);
      goto color;
    }
  parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
  color = (signed int)(node->rb_parent_color & (unsigned long int)1);
  if(!(child == ((struct rb_node *)NULL)))
    rb_set_parent(child, parent);

  if(!(parent == ((struct rb_node *)NULL)))
  {
    if(parent->rb_left == node)
      parent->rb_left = child;

    else
      parent->rb_right = child;
  }

  else
    root->rb_node = child;

color:
  ;
  if(color == 1)
    __rb_erase_color(child, parent, root);

}

// rb_first
// file rbtree.c line 255
struct rb_node * rb_first(struct rb_root *root)
{
  struct rb_node *n = root->rb_node;
  if(n == ((struct rb_node *)NULL))
    return (struct rb_node *)(void *)0;

  else
  {
    for( ; !(n->rb_left == ((struct rb_node *)NULL)); n = n->rb_left)
      ;
    return n;
  }
}

// rb_insert_color
// file ../include/rbtree.h line 56
void rb_insert_color(struct rb_node *node, struct rb_root *root)
{
  struct rb_node *parent;
  struct rb_node *gparent;
  do
  {
    parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
    if(parent == ((struct rb_node *)NULL))
      break;

    if(!((1ul & parent->rb_parent_color) == 0ul))
      break;

    gparent = (struct rb_node *)(parent->rb_parent_color & (unsigned long int)~3);
    if(parent == gparent->rb_left)
    {
      struct rb_node *rb_insert_color__1__1__1__uncle = gparent->rb_right;
      if(!(rb_insert_color__1__1__1__uncle == ((struct rb_node *)NULL)))
      {
        if((1ul & rb_insert_color__1__1__1__uncle->rb_parent_color) == 0ul)
        {
          do
            rb_insert_color__1__1__1__uncle->rb_parent_color = rb_insert_color__1__1__1__uncle->rb_parent_color | (unsigned long int)1;
          while((_Bool)0);
          do
            parent->rb_parent_color = parent->rb_parent_color | (unsigned long int)1;
          while((_Bool)0);
          do
            gparent->rb_parent_color = gparent->rb_parent_color & (unsigned long int)~1;
          while((_Bool)0);
          node = gparent;
          continue;
        }

      }

      if(parent->rb_right == node)
      {
        struct rb_node *rb_insert_color__1__1__1__2__tmp;
        __rb_rotate_left(parent, root);
        rb_insert_color__1__1__1__2__tmp = parent;
        parent = node;
        node = rb_insert_color__1__1__1__2__tmp;
      }

      do
        parent->rb_parent_color = parent->rb_parent_color | (unsigned long int)1;
      while((_Bool)0);
      do
        gparent->rb_parent_color = gparent->rb_parent_color & (unsigned long int)~1;
      while((_Bool)0);
      __rb_rotate_right(gparent, root);
    }

    else
    {
      struct rb_node *uncle = gparent->rb_left;
      if(!(uncle == ((struct rb_node *)NULL)))
      {
        if(!((1ul & uncle->rb_parent_color) == 0ul))
          goto __CPROVER_DUMP_L12;

        do
          uncle->rb_parent_color = uncle->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        do
          parent->rb_parent_color = parent->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        do
          gparent->rb_parent_color = gparent->rb_parent_color & (unsigned long int)~1;
        while((_Bool)0);
        node = gparent;
      }

      else
      {

      __CPROVER_DUMP_L12:
        ;
        if(parent->rb_left == node)
        {
          struct rb_node *tmp;
          __rb_rotate_right(parent, root);
          tmp = parent;
          parent = node;
          node = tmp;
        }

        do
          parent->rb_parent_color = parent->rb_parent_color | (unsigned long int)1;
        while((_Bool)0);
        do
          gparent->rb_parent_color = gparent->rb_parent_color & (unsigned long int)~1;
        while((_Bool)0);
        __rb_rotate_left(gparent, root);
      }
    }
  }
  while((_Bool)1);
  do
    root->rb_node->rb_parent_color = root->rb_node->rb_parent_color | (unsigned long int)1;
  while((_Bool)0);
}

// rb_last
// file rbtree.c line 267
struct rb_node * rb_last(struct rb_root *root)
{
  struct rb_node *n = root->rb_node;
  if(n == ((struct rb_node *)NULL))
    return (struct rb_node *)(void *)0;

  else
  {
    for( ; !(n->rb_right == ((struct rb_node *)NULL)); n = n->rb_right)
      ;
    return n;
  }
}

// rb_link_node
// file ../include/rbtree.h line 69
static inline void rb_link_node(struct rb_node *node, struct rb_node *parent, struct rb_node **rb_link)
{
  node->rb_parent_color = (unsigned long int)parent;
  node->rb_right = (struct rb_node *)(void *)0;
  node->rb_left = node->rb_right;
  *rb_link = node;
}

// rb_link_node_link1
// file ../include/rbtree.h line 69
static inline void rb_link_node_link1(struct rb_node *node_link1, struct rb_node *parent_link1, struct rb_node **rb_link_link1)
{
  node_link1->rb_parent_color = (unsigned long int)parent_link1;
  node_link1->rb_right = (struct rb_node *)(void *)0;
  node_link1->rb_left = node_link1->rb_right;
  *rb_link_link1 = node_link1;
}

// rb_next
// file rbtree.c line 279
struct rb_node * rb_next(struct rb_node *node)
{
  struct rb_node *parent;
  if((struct rb_node *)(18446744073709551612ul & node->rb_parent_color) == node)
    return (struct rb_node *)(void *)0;

  else
    if(!(node->rb_right == ((struct rb_node *)NULL)))
    {
      node = node->rb_right;
      for( ; !(node->rb_left == ((struct rb_node *)NULL)); node = node->rb_left)
        ;
      return (struct rb_node *)node;
    }

    else
    {
      do
      {
        parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
        if(parent == ((struct rb_node *)NULL))
          break;

        if(!(node == parent->rb_right))
          break;

        node = parent;
      }
      while((_Bool)1);
      return parent;
    }
}

// rb_prev
// file rbtree.c line 311
struct rb_node * rb_prev(struct rb_node *node)
{
  struct rb_node *parent;
  if((struct rb_node *)(18446744073709551612ul & node->rb_parent_color) == node)
    return (struct rb_node *)(void *)0;

  else
    if(!(node->rb_left == ((struct rb_node *)NULL)))
    {
      node = node->rb_left;
      for( ; !(node->rb_right == ((struct rb_node *)NULL)); node = node->rb_right)
        ;
      return (struct rb_node *)node;
    }

    else
    {
      do
      {
        parent = (struct rb_node *)(node->rb_parent_color & (unsigned long int)~3);
        if(parent == ((struct rb_node *)NULL))
          break;

        if(!(node == parent->rb_left))
          break;

        node = parent;
      }
      while((_Bool)1);
      return parent;
    }
}

// rb_replace_node
// file rbtree.c line 339
void rb_replace_node(struct rb_node *victim, struct rb_node *new, struct rb_root *root)
{
  struct rb_node *parent = (struct rb_node *)(victim->rb_parent_color & (unsigned long int)~3);
  if(!(parent == ((struct rb_node *)NULL)))
  {
    if(victim == parent->rb_left)
      parent->rb_left = new;

    else
      parent->rb_right = new;
  }

  else
    root->rb_node = new;
  if(!(victim->rb_left == ((struct rb_node *)NULL)))
    rb_set_parent(victim->rb_left, new);

  if(!(victim->rb_right == ((struct rb_node *)NULL)))
    rb_set_parent(victim->rb_right, new);

  *new = *victim;
}

// rb_set_color
// file ../include/rbtree.h line 31
static inline void rb_set_color(struct rb_node *rb, signed int color)
{
  rb->rb_parent_color = rb->rb_parent_color & (unsigned long int)~1 | (unsigned long int)color;
}

// rb_set_parent
// file ../include/rbtree.h line 27
static inline void rb_set_parent(struct rb_node *rb, struct rb_node *p)
{
  rb->rb_parent_color = rb->rb_parent_color & (unsigned long int)3 | (unsigned long int)p;
}

// read_msg_from_sheep
// file shepherd.c line 519
static void read_msg_from_sheep(struct sheep *sheep)
{
  signed int ret;
  struct sph_msg rcv;
  memset((void *)&rcv, 0, sizeof(struct sph_msg) /*8ul*/ );
  signed long int return_value_xread_1;
  return_value_xread_1=xread(sheep->fd, (void *)&rcv, sizeof(struct sph_msg) /*8ul*/ );
  ret = (signed int)return_value_xread_1;
  const char *return_value_sph_cli_msg_to_str_4;
  if(!((unsigned long int)ret == sizeof(struct sph_msg) /*8ul*/ ))
    log_write(3, "read_msg_from_sheep", 528, "xread() failed: %m, ");

  else
  {
    if((unsigned long int)rcv.type >= 5ul)
    {
      log_write(3, "read_msg_from_sheep", 533, "invalid message type: %d, ", rcv.type);
      const char *return_value_node_to_str_2;
      return_value_node_to_str_2=node_to_str(&sheep->node);
      log_write(3, "read_msg_from_sheep", 534, "from node: %s", return_value_node_to_str_2);
      char *return_value_sockaddr_in_to_str_3;
      return_value_sockaddr_in_to_str_3=sockaddr_in_to_str(&sheep->addr);
      log_write(3, "read_msg_from_sheep", 536, "from node (sockaddr): %s", return_value_sockaddr_in_to_str_3);
      log_write(3, "read_msg_from_sheep", 537, "read bytes: %d, body length: %d", ret, rcv.body_len);
      goto remove;
    }

    if(sd_log_level == 7)
    {
      return_value_sph_cli_msg_to_str_4=sph_cli_msg_to_str((enum sph_cli_msg_type)rcv.type);
      log_write(7, "read_msg_from_sheep", 541, "received op: %s", return_value_sph_cli_msg_to_str_4);
    }

    msg_handlers[(signed long int)rcv.type](&rcv, sheep);
  }

remove:
  ;
  const char *return_value_node_to_str_5;
  return_value_node_to_str_5=node_to_str(&sheep->node);
  log_write(3, "read_msg_from_sheep", 546, "removing node: %s", return_value_node_to_str_5);
  remove_sheep(sheep);
}

// register_event
// file ../include/event.h line 30
static inline signed int register_event(signed int fd, void (*h)(signed int, signed int, void *), void *data)
{
  signed int return_value_register_event_prio_1;
  return_value_register_event_prio_1=register_event_prio(fd, h, data, 0);
  return return_value_register_event_prio_1;
}

// register_event_link1
// file ../include/event.h line 30
static inline signed int register_event_link1(signed int fd_link1, void (*h_link1)(signed int, signed int, void *), void *data_link1)
{
  signed int return_value_register_event_prio_1_link1;
  return_value_register_event_prio_1_link1=register_event_prio(fd_link1, h_link1, data_link1, 0);
  return return_value_register_event_prio_1_link1;
}

// register_event_link2
// file ../include/event.h line 30
static inline signed int register_event_link2(signed int fd_link2, void (*h_link2)(signed int, signed int, void *), void *data_link2)
{
  signed int return_value_register_event_prio_1_link2;
  return_value_register_event_prio_1_link2=register_event_prio(fd_link2, h_link2, data_link2, 0);
  return return_value_register_event_prio_1_link2;
}

// register_event_prio
// file ../include/event.h line 12
signed int register_event_prio(signed int fd, void (*h)(signed int, signed int, void *), void *data, signed int prio)
{
  signed int ret;
  struct epoll_event ev;
  struct event_info *ei;
  void *return_value_xzalloc_1;
  return_value_xzalloc_1=xzalloc(sizeof(struct event_info) /*56ul*/ );
  ei = (struct event_info *)return_value_xzalloc_1;
  ei->fd = fd;
  ei->handler = h;
  ei->data = data;
  ei->prio = prio;
  memset((void *)&ev, 0, sizeof(struct epoll_event) /*12ul*/ );
  ev.events = (unsigned int)1;
  ev.data.ptr = (void *)ei;
  ret=epoll_ctl(efd, 1, fd, &ev);
  struct event_info *tmp_statement_expression_2;
  if(!(ret == 0))
  {
    log_write(3, "register_event_prio", 117, "failed to add epoll event for fd %d: %m", fd);
    free((void *)ei);
  }

  else
  {
    struct rb_node **__n = &(&events_tree)->rb_node;
    struct rb_node *__parent = (struct rb_node *)(void *)0;
    struct event_info *__old = (struct event_info *)(void *)0;
    struct event_info *__data;
    while(!(*__n == ((struct rb_node *)NULL)))
    {
      const struct rb_node *__mptr = *__n;
      tmp_statement_expression_2 = (struct event_info *)((char *)__mptr - (signed long int)24ul);
      __data = tmp_statement_expression_2;
      signed int __cmp;
      __cmp=event_cmp(ei, __data);
      __parent = *__n;
      if(!(__cmp >= 0))
        __n = &(*__n)->rb_left;

      else
        if(__cmp >= 1)
          __n = &(*__n)->rb_right;

        else
        {
          __old = __data;
          break;
        }
    }
    if(__old == ((struct event_info *)NULL))
    {
      rb_link_node(&ei->rb, __parent, __n);
      rb_insert_color(&ei->rb, &events_tree);
    }

    __old;
  }
  return ret;
}

// release_joining_sheep
// file shepherd.c line 195
static signed int release_joining_sheep(void)
{
  signed long int wbytes;
  struct sheep *waiting;
  struct sph_msg snd;
  signed int nr_failed = 0;
  _Bool return_value_list_empty_1;
  struct sheep *tmp_statement_expression_2;
  const char *return_value_node_to_str_3;
  do
  {

  retry:
    ;
    return_value_list_empty_1=list_empty(&join_wait_queue);
    if(!(return_value_list_empty_1 == (_Bool)0))
      return nr_failed;

    const struct list_node *__mptr = (&join_wait_queue)->n.next;
    tmp_statement_expression_2 = (struct sheep *)((char *)__mptr - (signed long int)128ul);
    waiting = tmp_statement_expression_2;
    list_del(&waiting->join_wait_list);
    memset((void *)&snd, 0, sizeof(struct sph_msg) /*8ul*/ );
    snd.type = (unsigned int)1;
    wbytes=xwrite(waiting->fd, (const void *)&snd, sizeof(struct sph_msg) /*8ul*/ );
    if((unsigned long int)wbytes == sizeof(struct sph_msg) /*8ul*/ )
      break;

    log_write(3, "release_joining_sheep", 215, "xwrite() failed: %m");
    remove_sheep(waiting);
    return_value_node_to_str_3=node_to_str(&waiting->node);
    log_write(6, "release_joining_sheep", 219, "node %s is failed to join", return_value_node_to_str_3);
    nr_failed = nr_failed + 1;
  }
  while((_Bool)1);
  return nr_failed;
}

// remove_handler
// file shepherd.c line 142
static void remove_handler(signed int fd, signed int events, void *data)
{
  struct sheep *s;
  signed int nr_removed;
  signed int failed = 0;
  nr_removed=eventfd_xread(remove_efd);
  if(sd_log_level == 7)
    log_write(7, "remove_handler", 149, "removed sheeps");

  struct sheep *tmp_statement_expression_1;
  struct sheep *tmp_statement_expression_2;
  const char *return_value_node_to_str_4;
  struct sheep *tmp_statement_expression_3;
  const char *return_value_node_to_str_6;
  do
  {

  remove:
    ;
    struct sheep *__n151;
    const struct list_node *__mptr = (&sheep_list_head)->n.next;
    tmp_statement_expression_1 = (struct sheep *)((char *)__mptr - (signed long int)112ul);
    s = tmp_statement_expression_1;
    const struct list_node *remove_handler__1__2__2____mptr = s->sheep_list.next;
    tmp_statement_expression_2 = (struct sheep *)((char *)remove_handler__1__2__2____mptr - (signed long int)112ul);
    __n151 = tmp_statement_expression_2;
    for( ; !(&s->sheep_list == &(&sheep_list_head)->n); __n151 = tmp_statement_expression_3)
    {
      if((signed int)s->state == SHEEP_STATE_LEAVING)
      {
        if(sd_log_level == 7)
        {
          return_value_node_to_str_4=node_to_str(&s->node);
          log_write(7, "remove_handler", 155, "removing the node: %s", return_value_node_to_str_4);
        }

        _Bool return_value_is_sd_node_zero_5;
        return_value_is_sd_node_zero_5=is_sd_node_zero(&s->node);
        if(return_value_is_sd_node_zero_5 == (_Bool)0)
          notify_remove_sheep(s);

        goto del;
      }

      s = __n151;
      const struct list_node *remove_handler__1__2__3____mptr = __n151->sheep_list.next;
      tmp_statement_expression_3 = (struct sheep *)((char *)remove_handler__1__2__3____mptr - (signed long int)112ul);
    }
    break;

  del:
    ;
    return_value_node_to_str_6=node_to_str(&s->node);
    log_write(6, "remove_handler", 177, "removed node: %s", return_value_node_to_str_6);
    unregister_event(s->fd);
    close(s->fd);
    list_del(&s->sheep_list);
    list_del(&s->join_wait_list);
    free((void *)s);
    nr_removed = nr_removed - 1;
  }
  while(!(nr_removed == 0));

end:
  ;
  if(sd_log_level == 7)
    log_write(7, "remove_handler", 190, "nodes which failed during remove_handler(): %d", failed);

}

// remove_sheep
// file shepherd.c line 104
static inline void remove_sheep(struct sheep *sheep)
{
  const char *return_value_node_to_str_1;
  if(sd_log_level == 7)
  {
    return_value_node_to_str_1=node_to_str(&sheep->node);
    log_write(7, "remove_sheep", 107, "remove_sheep() called, removing %s", return_value_node_to_str_1);
  }

  sheep->state = (enum sheep_state)SHEEP_STATE_LEAVING;
  eventfd_xwrite(remove_efd, 1);
  event_force_refresh();
}

// reraise_crash_signal
// file ../include/util.h line 113
void reraise_crash_signal(signed int signo, signed int status)
{
  signed int ret;
  ret=raise(signo);
  char *return_value_strsignal_1;
  char *return_value_strsignal_2;
  if(!(ret == 0))
  {
    return_value_strsignal_1=strsignal(signo);
    log_write(0, "reraise_crash_signal", 468, "failed to re-raise signal %d (%s).", signo, return_value_strsignal_1);
  }

  else
  {
    return_value_strsignal_2=strsignal(signo);
    log_write(0, "reraise_crash_signal", 472, "default handler for the re-raised signal %d (%s) didn't work expectedly", signo, return_value_strsignal_2);
  }
  exit(status);
}

// revalidate_node
// file sockfd_cache.c line 293
static inline signed int revalidate_node(struct node_id *nid)
{
  _Bool use_io = (_Bool)(nid->io_port != 0 ? 1 : 0);
  signed int fd;
  if(!(use_io == (_Bool)0))
  {
    fd=connect_to_addr(nid->io_addr, (signed int)nid->io_port);
    if(fd >= 0)
      goto alive;

  }

  fd=connect_to_addr(nid->addr, (signed int)nid->port);
  if(!(fd >= 0))
    return 0;

  else
  {

  alive:
    ;
    close(fd);
    sockfd_cache_add(nid);
    return 1;
  }
}

// rmdir_r
// file util.c line 388
signed int rmdir_r(const char *dir_path)
{
  signed int ret;
  ret=purge_directory(dir_path);
  if(ret == 0)
    ret=rmdir(dir_path);

  return ret;
}

// rotate_log
// file logger.c line 453
static void rotate_log(void)
{
  signed int new_fd;
  signed int return_value_access_1;
  return_value_access_1=access(log_nowname, 4);
  if(return_value_access_1 == 0)
  {
    char old_logfile[256l];
    signed long int t;
    struct tm tm;
    time(&t);
    localtime_r((const signed long int *)&t, &tm);
    snprintf(old_logfile, sizeof(char [256l]) /*256ul*/ , "%s.%04d-%02d-%02d-%02d-%02d", log_nowname, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min);
    rename(log_nowname, old_logfile);
  }

  new_fd=open(log_nowname, 02 | 0100 | 02000, 0644);
  if(!(new_fd >= 0))
  {
    syslog(3, "failed to create new log file\n");
    exit(1);
  }

  signed int return_value_dup2_2;
  return_value_dup2_2=dup2(new_fd, log_fd);
  if(!(return_value_dup2_2 >= 0))
  {
    syslog(3, "failed to dup2 the log fd\n");
    exit(1);
  }

  close(new_fd);
}

// sd_backtrace
// file ../include/logger.h line 54
void sd_backtrace(void)
{
  void *addrs[1024l];
  signed int i;
  signed int n;
  n=backtrace(addrs, (signed int)(sizeof(void *[1024l]) /*8192ul*/  / sizeof(void *) /*8ul*/ ));
  i = 1;
  char *return_value_fgets_2;
  _Bool tmp_if_expr_4;
  char *return_value_chomp_3;
  for( ; !(i >= n); i = i + 1)
  {
    void *addr = addrs[(signed long int)i];
    signed long int addr_array_size0;
    addr_array_size0=sysconf(0);
    char cmd[addr_array_size0];
    char info[256l];
    char **str;
    struct _IO_FILE *f;
    addr = (void *)((char *)addr - (signed long int)1);
    const char *return_value_my_exe_path_1;
    return_value_my_exe_path_1=my_exe_path();
    snprintf(cmd, (unsigned long int)addr_array_size0, "addr2line -s -e %s -f -i %p | perl -e '@a=<>; chomp @a; print \"_a[1]: _a[0]\"'", return_value_my_exe_path_1, addr);
    f=popen(cmd, "r");
    if(!(f == ((struct _IO_FILE *)NULL)))
    {
      return_value_fgets_2=fgets(info, (signed int)sizeof(char [256l]) /*256ul*/ , f);
      if(!(return_value_fgets_2 == ((char *)NULL)))
      {
        if(!((signed int)info[0l] == 63))
          tmp_if_expr_4 = (signed int)info[(signed long int)0] != 0 ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_4 = (_Bool)0;
        if(tmp_if_expr_4)
        {
          return_value_chomp_3=chomp(info);
          log_write(0, "sd_backtrace", 833, "%s", return_value_chomp_3);
        }

        else
          goto fallback_close;
        pclose(f);
        goto __CPROVER_DUMP_L8;
      }


    fallback_close:
      ;
      pclose(f);
    }


  fallback:
    ;
    str=backtrace_symbols(&addr, 1);
    log_write(0, "sd_backtrace", 847, "%s", *str);
    free((void *)str);

  __CPROVER_DUMP_L8:
    ;
  }
  dump_stack_frames();
}

// sd_cond_init
// file ../include/util.h line 348
static inline void sd_cond_init(struct sd_cond *cond)
{
  signed int ret;
  do
    ret=pthread_cond_init(&cond->cond, (const union anonymous_23 *)(void *)0);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror_1;
    return_value_strerror_1=strerror(ret);
    log_write(0, "sd_cond_init", 357, "PANIC: failed to initialize a lock, %s", return_value_strerror_1);
    abort();
  }

}

// sd_cond_signal
// file ../include/util.h line 373
static inline signed int sd_cond_signal(struct sd_cond *cond)
{
  signed int return_value_pthread_cond_signal_1;
  return_value_pthread_cond_signal_1=pthread_cond_signal(&cond->cond);
  return return_value_pthread_cond_signal_1;
}

// sd_cond_wait
// file ../include/util.h line 378
static inline signed int sd_cond_wait(struct sd_cond *cond, struct sd_mutex *mutex)
{
  signed int return_value_pthread_cond_wait_1;
  return_value_pthread_cond_wait_1=pthread_cond_wait(&cond->cond, &mutex->mutex);
  return return_value_pthread_cond_wait_1;
}

// sd_destroy_cond
// file ../include/util.h line 361
static inline void sd_destroy_cond(struct sd_cond *cond)
{
  signed int ret;
  do
    ret=pthread_cond_destroy(&cond->cond);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror_1;
    return_value_strerror_1=strerror(ret);
    log_write(0, "sd_destroy_cond", 370, "PANIC: failed to destroy a lock, %s", return_value_strerror_1);
    abort();
  }

}

// sd_destroy_mutex
// file ../include/util.h line 299
static inline void sd_destroy_mutex(struct sd_mutex *mutex)
{
  signed int ret;
  do
    ret=pthread_mutex_destroy(&mutex->mutex);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror_1;
    return_value_strerror_1=strerror(ret);
    log_write(0, "sd_destroy_mutex", 308, "PANIC: failed to destroy a lock, %s", return_value_strerror_1);
    abort();
  }

}

// sd_init_mutex
// file ../include/util.h line 273
static inline void sd_init_mutex(struct sd_mutex *mutex)
{
  signed int ret;
  do
    ret=pthread_mutex_init(&mutex->mutex, (const union anonymous_23 *)(void *)0);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror_1;
    return_value_strerror_1=strerror(ret);
    log_write(0, "sd_init_mutex", 282, "PANIC: failed to initialize a lock, %s", return_value_strerror_1);
    abort();
  }

}

// sd_inode_copy_vdis
// file sd_inode.c line 700
extern void sd_inode_copy_vdis(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), unsigned int *data_vdi_id, unsigned char store_policy, unsigned char nr_copies, unsigned char copy_policy, struct sd_inode *newi)
{
  struct sd_extent_header *header = (struct sd_extent_header *)data_vdi_id;
  struct sd_extent_header *leaf_node;
  struct sd_extent_idx *last_idx;
  struct sd_extent_idx *old_iter_idx;
  struct sd_extent_idx *new_iter_idx;
  unsigned long int oid;
  void *tmp;
  memcpy((void *)newi->data_vdi_id, (const void *)data_vdi_id, sizeof(unsigned int [1048576l]) /*4194304ul*/ );
  unsigned int tmp_post_2;
  if((signed int)store_policy == 1)
  {
    if((signed int)header->depth >= 2)
    {
      last_idx = (struct sd_extent_idx *)((char *)data_vdi_id + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)data_vdi_id)->entries;
      old_iter_idx = (struct sd_extent_idx *)((char *)data_vdi_id + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ );
      new_iter_idx = (struct sd_extent_idx *)((char *)newi->data_vdi_id + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ );
      void *return_value_xvalloc_1;
      return_value_xvalloc_1=xvalloc(sizeof(unsigned int) /*4ul*/  * (1ULL << 20));
      leaf_node = (struct sd_extent_header *)return_value_xvalloc_1;
      tmp = (void *)leaf_node;
      if(!(old_iter_idx == last_idx))
      {
        reader(old_iter_idx->oid, &tmp, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0);
        tmp_post_2 = newi->btree_counter;
        newi->btree_counter = newi->btree_counter + 1u;
        oid=vid_to_btree_oid(newi->vdi_id, tmp_post_2);
        writer(oid, (void *)leaf_node, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0, (unsigned int)0, (signed int)nr_copies, (signed int)copy_policy, (_Bool)1, (_Bool)0);
        new_iter_idx->oid = oid;
        old_iter_idx = old_iter_idx + 1l;
        new_iter_idx = new_iter_idx + 1l;
      }

      free((void *)leaf_node);
    }

  }

}

// sd_inode_get_meta_size
// file sd_inode.c line 626
extern unsigned int sd_inode_get_meta_size(struct sd_inode *inode, unsigned long int size)
{
  struct sd_extent_header *header;
  unsigned int len;
  if((signed int)inode->store_policy == 0)
  {
    unsigned long int return_value_count_data_objs_1;
    return_value_count_data_objs_1=count_data_objs(inode);
    len = (unsigned int)(return_value_count_data_objs_1 * sizeof(unsigned int) /*4ul*/ );
    if(!(size + 18446744073709546952ul + 18446744073709551612ul >= (unsigned long int)len))
      len = (unsigned int)((size - 4664ul) - sizeof(unsigned int) /*4ul*/ );

  }

  else
  {
    header = (struct sd_extent_header *)inode->data_vdi_id;
    len = (unsigned int)sizeof(struct sd_extent_header) /*8ul*/ ;
    if((signed int)header->depth == 1)
      len = len + (unsigned int)(sizeof(struct sd_extent) /*8ul*/  * (unsigned long int)header->entries);

    else
      if((signed int)header->depth == 2)
        len = len + (unsigned int)(sizeof(struct sd_extent_idx) /*16ul*/  * (unsigned long int)header->entries);

      else
      {
        log_write(0, "sd_inode_get_meta_size", 644, "PANIC: Depth of B-tree is out of range(depth: %u)", header->depth);
        abort();
      }
  }
  return len;
}

// sd_inode_get_vid
// file sd_inode.c line 443
extern unsigned int sd_inode_get_vid(signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, unsigned int idx)
{
  struct find_path path;
  signed int ret;
  if((signed int)inode->store_policy == 0)
    return inode->data_vdi_id[(signed long int)idx];

  else
  {
    if(inode->data_vdi_id[0l] == 0u)
      return (unsigned int)0;

    memset((void *)&path, 0, sizeof(struct find_path) /*32ul*/ );
    ret=search_whole_btree(reader, inode, idx, &path);
    if(ret == 0x1C)
      return path.p_ext->vdi_id;

    if(!(path.p_ext_header == ((struct sd_extent_header *)NULL)))
      free((void *)path.p_ext_header);

  }
  return (unsigned int)0;
}

// sd_inode_init
// file sd_inode.c line 243
extern void sd_inode_init(void *data, signed int depth)
{
  struct sd_extent_header *header = (struct sd_extent_header *)data;
  header->magic = (unsigned short int)0x6274;
  header->depth = (unsigned short int)depth;
  header->entries = (unsigned int)0;
}

// sd_inode_set_vid
// file sd_inode.c line 566
extern void sd_inode_set_vid(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, unsigned int idx, unsigned int vdi_id)
{
  struct sd_extent_header *header;
  struct find_path path;
  unsigned long int offset;
  signed int ret;
  path.p_ext_header = (struct sd_extent_header *)(void *)0;
  if((signed int)inode->store_policy == 0)
    inode->data_vdi_id[(signed long int)idx] = vdi_id;

  else
  {
    if(inode->data_vdi_id[0l] == 0u)
      sd_inode_init((void *)inode->data_vdi_id, 1);

    header = (struct sd_extent_header *)inode->data_vdi_id;
    if(!((signed int)header->magic == 0x6274))
    {
      log_write(0, "sd_inode_set_vid", 583, "PANIC: %s() B-tree in inode is corrupt!", (const void *)"sd_inode_set_vid");
      abort();
    }

    while((_Bool)1)
    {
      memset((void *)&path, 0, sizeof(struct find_path) /*32ul*/ );
      ret=search_whole_btree(reader, inode, idx, &path);
      if(ret == 0x1C)
      {
        path.p_ext->vdi_id = vdi_id;
        if(path.p_ext_header == ((struct sd_extent_header *)NULL))
          break;

        offset = (unsigned long int)((unsigned char *)path.p_ext - (unsigned char *)path.p_ext_header) + 4ul;
        writer(path.p_idx->oid, (void *)&vdi_id, (unsigned int)sizeof(unsigned int) /*4ul*/ , offset, (unsigned int)0, (signed int)inode->nr_copies, (signed int)inode->copy_policy, (_Bool)0, (_Bool)0);
        break;
      }

      else
      {
        ret=insert_new_node(writer, reader, inode, &path, idx, vdi_id);
        if(ret == 0x1D)
        {
          if(!(path.p_ext_header == ((struct sd_extent_header *)NULL)))
            free((void *)path.p_ext_header);

          continue;
        }

        else
          break;
      }
    }
  }

out:
  ;
  if(!(path.p_ext_header == ((struct sd_extent_header *)NULL)))
    free((void *)path.p_ext_header);

  if(!((signed int)inode->store_policy == 0))
    dump_btree(reader, inode);

}

// sd_inode_write
// file sd_inode.c line 650
extern signed int sd_inode_write(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), struct sd_inode *inode, signed int flags, _Bool create, _Bool direct)
{
  unsigned int len;
  signed int ret;
  unsigned long int return_value_vid_to_vdi_oid_1;
  if((signed int)inode->store_policy == 0)
  {
    return_value_vid_to_vdi_oid_1=vid_to_vdi_oid(inode->vdi_id);
    ret=writer(return_value_vid_to_vdi_oid_1, (void *)inode, (unsigned int)4664ul, (unsigned long int)0, (unsigned int)flags, (signed int)inode->nr_copies, (signed int)inode->copy_policy, create, direct);
  }

  else
  {
    unsigned int return_value_sd_inode_get_meta_size_2;
    return_value_sd_inode_get_meta_size_2=sd_inode_get_meta_size(inode, (unsigned long int)0);
    len = (unsigned int)(4664ul + (unsigned long int)return_value_sd_inode_get_meta_size_2);
    unsigned long int return_value_vid_to_vdi_oid_3;
    return_value_vid_to_vdi_oid_3=vid_to_vdi_oid(inode->vdi_id);
    ret=writer(return_value_vid_to_vdi_oid_3, (void *)inode, len, (unsigned long int)0, (unsigned int)flags, (signed int)inode->nr_copies, (signed int)inode->copy_policy, create, (_Bool)0);
    if(ret == 0x00)
    {
      unsigned long int return_value_vid_to_vdi_oid_4;
      return_value_vid_to_vdi_oid_4=vid_to_vdi_oid(inode->vdi_id);
      ret=writer(return_value_vid_to_vdi_oid_4, (void *)inode, (unsigned int)sizeof(unsigned int) /*4ul*/ , 4198968ul, (unsigned int)flags, (signed int)inode->nr_copies, (signed int)inode->copy_policy, create, (_Bool)0);
    }

  }

out:
  ;
  return ret;
}

// sd_inode_write_vid
// file sd_inode.c line 679
extern signed int sd_inode_write_vid(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), struct sd_inode *inode, unsigned int idx, unsigned int vid, unsigned int value, signed int flags, _Bool create, _Bool direct)
{
  signed int ret = 0x00;
  unsigned long int return_value_vid_to_vdi_oid_1;
  if((signed int)inode->store_policy == 0)
  {
    return_value_vid_to_vdi_oid_1=vid_to_vdi_oid(vid);
    ret=writer(return_value_vid_to_vdi_oid_1, (void *)&value, (unsigned int)sizeof(unsigned int) /*4ul*/ , 4664ul + sizeof(unsigned int) /*4ul*/  * (unsigned long int)idx, (unsigned int)flags, (signed int)inode->nr_copies, (signed int)inode->copy_policy, create, direct);
  }

  else
    ret=sd_inode_write(writer, inode, flags, create, direct);
  return ret;
}

// sd_mutex_lock
// file ../include/util.h line 311
static inline void sd_mutex_lock(struct sd_mutex *mutex)
{
  signed int ret;
  do
    ret=pthread_mutex_lock(&mutex->mutex);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror_1;
    return_value_strerror_1=strerror(ret);
    log_write(0, "sd_mutex_lock", 320, "PANIC: failed to lock for reading, %s", return_value_strerror_1);
    abort();
  }

}

// sd_mutex_unlock
// file ../include/util.h line 328
static inline void sd_mutex_unlock(struct sd_mutex *mutex)
{
  signed int ret;
  do
    ret=pthread_mutex_unlock(&mutex->mutex);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror_1;
    return_value_strerror_1=strerror(ret);
    log_write(0, "sd_mutex_unlock", 337, "PANIC: failed to unlock, %s", return_value_strerror_1);
    abort();
  }

}

// sd_read_lock
// file ../include/util.h line 429
static inline void sd_read_lock(struct sd_rw_lock *lock)
{
  signed int ret;
  do
    ret=pthread_rwlock_rdlock(&lock->rwlock);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror_1;
    return_value_strerror_1=strerror(ret);
    log_write(0, "sd_read_lock", 438, "PANIC: failed to lock for reading, %s", return_value_strerror_1);
    abort();
  }

}

// sd_rw_unlock
// file ../include/util.h line 457
static inline void sd_rw_unlock(struct sd_rw_lock *lock)
{
  signed int ret;
  do
    ret=pthread_rwlock_unlock(&lock->rwlock);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror_1;
    return_value_strerror_1=strerror(ret);
    log_write(0, "sd_rw_unlock", 466, "PANIC: failed to unlock, %s", return_value_strerror_1);
    abort();
  }

}

// sd_write_lock
// file ../include/util.h line 445
static inline void sd_write_lock(struct sd_rw_lock *lock)
{
  signed int ret;
  do
    ret=pthread_rwlock_wrlock(&lock->rwlock);
  while(ret == 11);
  if(!(ret == 0))
  {
    char *return_value_strerror_1;
    return_value_strerror_1=strerror(ret);
    log_write(0, "sd_write_lock", 454, "PANIC: failed to lock for writing, %s", return_value_strerror_1);
    abort();
  }

}

// search_ext_entry
// file sd_inode.c line 271
static struct sd_extent * search_ext_entry(struct sd_extent_header *header, unsigned int idx)
{
  struct sd_extent tmp;
  tmp.idx = idx;
  void *return_value_binary_search_1;
  return_value_binary_search_1=binary_search((void *)(struct sd_extent *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ), (void *)((struct sd_extent *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)header)->entries), (void *)&tmp, sizeof(struct sd_extent) /*8ul*/ , extent_comp);
  return (struct sd_extent *)return_value_binary_search_1;
}

// search_idx_entry
// file sd_inode.c line 281
static struct sd_extent_idx * search_idx_entry(struct sd_extent_header *header, unsigned int idx)
{
  struct sd_extent_idx tmp;
  tmp.idx = idx;
  void *return_value_binary_search_1;
  return_value_binary_search_1=binary_search((void *)(struct sd_extent_idx *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ), (void *)((struct sd_extent_idx *)((char *)header + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)header)->entries), (void *)&tmp, sizeof(struct sd_extent_idx) /*16ul*/ , index_comp);
  return (struct sd_extent_idx *)return_value_binary_search_1;
}

// search_whole_btree
// file sd_inode.c line 392
static signed int search_whole_btree(signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, unsigned int idx, struct find_path *path)
{
  struct sd_extent_header *header;
  struct sd_extent_header *leaf_node;
  void *tmp;
  unsigned long int oid;
  signed int ret = 0x1B;
  header = (struct sd_extent_header *)inode->data_vdi_id;
  _Bool tmp_if_expr_5;
  if((signed int)header->depth == 2)
  {
    path->depth = 2;
    path->p_idx=search_idx_entry(header, idx);
    void *return_value_xvalloc_1;
    return_value_xvalloc_1=xvalloc(sizeof(unsigned int) /*4ul*/  * (1ULL << 20));
    leaf_node = (struct sd_extent_header *)return_value_xvalloc_1;
    tmp = (void *)leaf_node;
    _Bool return_value_idx_in_range_3;
    return_value_idx_in_range_3=idx_in_range(header, path->p_idx);
    if(!(return_value_idx_in_range_3 == (_Bool)0))
    {
      oid = path->p_idx->oid;
      ret=reader(oid, &tmp, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0);
      path->p_ext=search_ext_entry(leaf_node, idx);
      path->p_ext_header = leaf_node;
      _Bool return_value_ext_in_range_2;
      return_value_ext_in_range_2=ext_in_range(leaf_node, path->p_ext);
      if(!(return_value_ext_in_range_2 == (_Bool)0))
      {
        if(path->p_ext->idx == idx)
          ret = 0x1C;

      }

    }

    else
    {
      oid = (path->p_idx - (signed long int)1)->oid;
      ret=reader(oid, &tmp, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0);
      if(!((unsigned long int)leaf_node->entries >= 524287ul))
      {
        path->p_ext=search_ext_entry(leaf_node, idx);
        path->p_ext_header = leaf_node;
      }

    }
  }

  else
    if((signed int)header->depth == 1)
    {
      path->depth = 1;
      path->p_ext=search_ext_entry(header, idx);
      _Bool return_value_ext_in_range_4;
      return_value_ext_in_range_4=ext_in_range(header, path->p_ext);
      if(!(return_value_ext_in_range_4 == (_Bool)0))
        tmp_if_expr_5 = path->p_ext->idx == idx ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      if(tmp_if_expr_5)
        ret = 0x1C;

      else
        ret = 0x1B;
    }


out:
  ;
  return ret;
}

// send_req
// file net.c line 294
signed int send_req(signed int sockfd, struct sd_req *hdr, void *data, unsigned int wlen, _Bool (*need_retry)(unsigned int), unsigned int epoch, unsigned int max_count)
{
  signed int ret;
  struct msghdr msg;
  struct iovec iov[2l];
  memset((void *)&msg, 0, sizeof(struct msghdr) /*56ul*/ );
  msg.msg_iov = iov;
  msg.msg_iovlen = (unsigned long int)1;
  iov[(signed long int)0].iov_base = (void *)hdr;
  iov[(signed long int)0].iov_len = sizeof(struct sd_req) /*48ul*/ ;
  if(!(wlen == 0u))
  {
    msg.msg_iovlen = msg.msg_iovlen + 1ul;
    iov[(signed long int)1].iov_base = data;
    iov[(signed long int)1].iov_len = (unsigned long int)wlen;
  }

  ret=do_write(sockfd, &msg, (signed int)(sizeof(struct sd_req) /*48ul*/  + (unsigned long int)wlen), need_retry, epoch, max_count);
  if(!(ret == 0))
  {
    log_write(3, "send_req", 319, "failed to send request %x, %d: %m", hdr->opcode, wlen);
    ret = -1;
  }

  return ret;
}

// set_keepalive
// file ../include/net.h line 60
signed int set_keepalive(signed int fd)
{
  signed int val = 1;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(fd, 1, 9, (const void *)&val, (unsigned int)sizeof(signed int) /*4ul*/ );
  if(!(return_value_setsockopt_1 >= 0))
  {
    if(sd_log_level == 7)
      log_write(7, "set_keepalive", 472, "%m");

    return -1;
  }

  else
  {
    val = 5;
    signed int return_value_setsockopt_2;
    return_value_setsockopt_2=setsockopt(fd, 6, 4, (const void *)&val, (unsigned int)sizeof(signed int) /*4ul*/ );
    if(!(return_value_setsockopt_2 >= 0))
    {
      if(sd_log_level == 7)
        log_write(7, "set_keepalive", 477, "%m");

      return -1;
    }

    else
    {
      val = 1;
      signed int return_value_setsockopt_3;
      return_value_setsockopt_3=setsockopt(fd, 6, 5, (const void *)&val, (unsigned int)sizeof(signed int) /*4ul*/ );
      if(!(return_value_setsockopt_3 >= 0))
      {
        if(sd_log_level == 7)
          log_write(7, "set_keepalive", 482, "%m");

        return -1;
      }

      else
      {
        val = 3;
        signed int return_value_setsockopt_4;
        return_value_setsockopt_4=setsockopt(fd, 6, 6, (const void *)&val, (unsigned int)sizeof(signed int) /*4ul*/ );
        if(!(return_value_setsockopt_4 >= 0))
        {
          if(sd_log_level == 7)
            log_write(7, "set_keepalive", 487, "%m");

          return -1;
        }

        else
          return 0;
      }
    }
  }
}

// set_listen_fd_cb
// file shepherd.c line 629
static signed int set_listen_fd_cb(signed int fd, void *data)
{
  signed int ret;
  ret=register_event(fd, sheep_accept_handler, (void *)0);
  if(!(ret == 0))
  {
    log_write(0, "set_listen_fd_cb", 635, "PANIC: register_event() failed: %m");
    abort();
  }

  return 0;
}

// set_loglevel
// file logger.c line 855
void set_loglevel(signed int new_loglevel)
{
  sd_log_level = new_loglevel;
}

// set_nodelay
// file net.c line 452
signed int set_nodelay(signed int fd)
{
  signed int ret;
  signed int opt = 1;
  ret=setsockopt(fd, 6, 1, (const void *)&opt, (unsigned int)sizeof(signed int) /*4ul*/ );
  return ret;
}

// set_rcv_timeout
// file net.c line 438
signed int set_rcv_timeout(signed int fd)
{
  struct timeval timeout;
  timeout.tv_sec = (signed long int)30;
  timeout.tv_usec = (signed long int)0;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(fd, 1, 20, (const void *)(char *)&timeout, (unsigned int)sizeof(struct timeval) /*16ul*/ );
  return return_value_setsockopt_1;
}

// set_snd_timeout
// file net.c line 427
signed int set_snd_timeout(signed int fd)
{
  struct timeval timeout;
  timeout.tv_sec = (signed long int)5;
  timeout.tv_usec = (signed long int)0;
  signed int return_value_setsockopt_1;
  return_value_setsockopt_1=setsockopt(fd, 1, 21, (const void *)(char *)&timeout, (unsigned int)sizeof(struct timeval) /*16ul*/ );
  return return_value_setsockopt_1;
}

// set_thread_name
// file logger.c line 738
void set_thread_name(const char *name, _Bool show_idx)
{
  worker_name = name;
  if(!(show_idx == (_Bool)0))
    worker_idx=gettid();

}

// set_try_to_free_routine
// file util.c line 34
void (*set_try_to_free_routine(void (*routine)(unsigned long int)))(unsigned long int)
{
  void (*old)(unsigned long int) = try_to_free_routine;
  if(routine == ((void (*)(unsigned long int))NULL))
    routine = do_nothing;

  try_to_free_routine = routine;
  return old;
}

// sha1_to_hex
// file sha1.c line 322
const char * sha1_to_hex(const unsigned char *sha1)
{
  static char buffer[50l];
  char *buf = buffer;
  signed int i = 0;
  const unsigned char *tmp_post_1;
  char *tmp_post_2;
  char *tmp_post_3;
  for( ; !(i >= 20); i = i + 1)
  {
    unsigned int val;
    tmp_post_1 = sha1;
    sha1 = sha1 + 1l;
    val = (unsigned int)*tmp_post_1;
    tmp_post_2 = buf;
    buf = buf + 1l;
    static const char hex[17l] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 0 };
    *tmp_post_2 = hex[(signed long int)(val >> 4)];
    tmp_post_3 = buf;
    buf = buf + 1l;
    *tmp_post_3 = hex[(signed long int)(val & (unsigned int)0xf)];
  }
  return buffer;
}

// sheep_accept_handler
// file shepherd.c line 561
static void sheep_accept_handler(signed int fd, signed int events, void *data)
{
  signed int ret;
  struct sheep *new_sheep;
  unsigned int len;
  void *return_value_xzalloc_1;
  return_value_xzalloc_1=xzalloc(sizeof(struct sheep) /*144ul*/ );
  new_sheep = (struct sheep *)return_value_xzalloc_1;
  len = (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ ;
  new_sheep->fd=accept(fd, (struct sockaddr *)&new_sheep->addr, &len);
  signed int return_value_set_keepalive_2;
  if(!(new_sheep->fd >= 0))
    log_write(3, "sheep_accept_handler", 572, "accept() failed: %m");

  else
  {
    return_value_set_keepalive_2=set_keepalive(new_sheep->fd);
    if(return_value_set_keepalive_2 == -1)
      log_write(3, "sheep_accept_handler", 577, "set_keepalive() failed: %m");

    else
    {
      ret=register_event(new_sheep->fd, sheep_comm_handler, (void *)new_sheep);
      if(!(ret >= 0))
        log_write(3, "sheep_accept_handler", 583, "register_event() failed: %m");

      else
      {
        list_add_tail(&new_sheep->sheep_list, &sheep_list_head);
        new_sheep->state = (enum sheep_state)SHEEP_STATE_CONNECTED;
        log_write(6, "sheep_accept_handler", 590, "accepted new sheep connection");
        goto __CPROVER_DUMP_L5;
      }
    }
  }

clean:
  ;
  free((void *)new_sheep);

__CPROVER_DUMP_L5:
  ;
}

// sheep_comm_handler
// file shepherd.c line 550
static void sheep_comm_handler(signed int fd, signed int events, void *data)
{
  if(!((1 & events) == 0))
    read_msg_from_sheep((struct sheep *)data);

  else
    if(!((8 & events) == 0) || !((16 & events) == 0))
    {
      const char *return_value_node_to_str_1;
      return_value_node_to_str_1=node_to_str(&((struct sheep *)data)->node);
      log_write(3, "sheep_comm_handler", 556, "epoll() error: %s", return_value_node_to_str_1);
      remove_sheep((struct sheep *)data);
    }

}

// sighup_handler
// file logger.c line 555
static void sighup_handler(signed int signo)
{
  rotate_log();
}

// slots_all_free
// file sockfd_cache.c line 132
static inline _Bool slots_all_free(struct sockfd_cache_entry *entry)
{
  signed int i = 0;
  _Bool return_value_uatomic_is_true_1;
  for( ; !(i >= fds_count); i = i + 1)
  {
    return_value_uatomic_is_true_1=uatomic_is_true(&(entry->fds + (signed long int)i)->in_use);
    if(!(return_value_uatomic_is_true_1 == (_Bool)0))
      return (_Bool)0;

  }
  return (_Bool)1;
}

// sockaddr_in_to_str
// file ../include/net.h line 58
char * sockaddr_in_to_str(struct sockaddr_in *sockaddr)
{
  signed int i;
  signed int si;
  unsigned char *addr;
  si = 0;
  static char str[32l];
  memset((void *)str, 0, (unsigned long int)32);
  addr = (unsigned char *)&sockaddr->sin_addr.s_addr;
  i = 0;
  for( ; !(i >= 4); i = i + 1)
  {
    signed int return_value_snprintf_1;
    return_value_snprintf_1=snprintf(str + (signed long int)si, (unsigned long int)(32 - si), i != 3 ? "%d." : "%d", addr[(signed long int)i]);
    si = si + return_value_snprintf_1;
  }
  snprintf(str + (signed long int)si, (unsigned long int)(32 - si), ":%u", sockaddr->sin_port);
  return str;
}

// sockfd_cache_add
// file sockfd_cache.c line 220
void sockfd_cache_add(struct node_id *nid)
{
  struct sockfd_cache_entry *new;
  signed int n;
  signed int i;
  sd_write_lock(&sockfd_cache.lock);
  void *return_value_xmalloc_1;
  return_value_xmalloc_1=xmalloc(sizeof(struct sockfd_cache_entry) /*72ul*/ );
  new = (struct sockfd_cache_entry *)return_value_xmalloc_1;
  void *return_value_xzalloc_2;
  return_value_xzalloc_2=xzalloc(sizeof(struct sockfd_cache_fd) /*16ul*/  * (unsigned long int)fds_count);
  new->fds = (struct sockfd_cache_fd *)return_value_xzalloc_2;
  i = 0;
  for( ; !(i >= fds_count); i = i + 1)
    (new->fds + (signed long int)i)->fd = -1;
  memcpy((void *)&new->nid, (const void *)nid, sizeof(struct node_id) /*40ul*/ );
  struct sockfd_cache_entry *return_value_sockfd_cache_insert_3;
  return_value_sockfd_cache_insert_3=sockfd_cache_insert(new);
  const char *return_value_addr_to_str_5;
  if(!(return_value_sockfd_cache_insert_3 == ((struct sockfd_cache_entry *)NULL)))
  {
    free_cache_entry(new);
    sd_rw_unlock(&sockfd_cache.lock);
  }

  else
  {
    sd_rw_unlock(&sockfd_cache.lock);
    unsigned long int return_value___uatomic_add_return_4;
    return_value___uatomic_add_return_4=__uatomic_add_return((void *)&sockfd_cache.count, (unsigned long int)1, (signed int)sizeof(signed int) /*4ul*/ );
    n = (signed int)return_value___uatomic_add_return_4;
    if(sd_log_level == 7)
    {
      return_value_addr_to_str_5=addr_to_str(nid->addr, nid->port);
      log_write(7, "sockfd_cache_add", 239, "%s, count %d", return_value_addr_to_str_5, n);
    }

  }
}

// sockfd_cache_add_group
// file sockfd_cache.c line 208
void sockfd_cache_add_group(struct rb_root *nroot)
{
  struct sd_node *n;
  sd_write_lock(&sockfd_cache.lock);
  struct rb_node *__p213;
  __p213=rb_first(nroot);
  struct rb_node *__n213;
  _Bool tmp_if_expr_1;
  _Bool tmp_if_expr_3;
  struct sd_node *tmp_statement_expression_2;
  do
  {
    if(!(__p213 == ((struct rb_node *)NULL)))
    {
      __n213=rb_next(__p213);
      tmp_if_expr_1 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_1 = (_Bool)0;
    if(tmp_if_expr_1)
    {
      const struct rb_node *__mptr = __p213;
      tmp_statement_expression_2 = (struct sd_node *)((char *)__mptr - (signed long int)0ul);
      n = tmp_statement_expression_2;
      tmp_if_expr_3 = 1 != 0 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_3 = (_Bool)0;
    if(!tmp_if_expr_3)
      break;

    sockfd_cache_add_nolock(&n->nid);
    __p213 = __n213;
  }
  while((_Bool)1);
  sd_rw_unlock(&sockfd_cache.lock);
}

// sockfd_cache_add_nolock
// file sockfd_cache.c line 190
static void sockfd_cache_add_nolock(struct node_id *nid)
{
  struct sockfd_cache_entry *new;
  void *return_value_xmalloc_1;
  return_value_xmalloc_1=xmalloc(sizeof(struct sockfd_cache_entry) /*72ul*/ );
  new = (struct sockfd_cache_entry *)return_value_xmalloc_1;
  signed int i;
  void *return_value_xzalloc_2;
  return_value_xzalloc_2=xzalloc(sizeof(struct sockfd_cache_fd) /*16ul*/  * (unsigned long int)fds_count);
  new->fds = (struct sockfd_cache_fd *)return_value_xzalloc_2;
  i = 0;
  for( ; !(i >= fds_count); i = i + 1)
    (new->fds + (signed long int)i)->fd = -1;
  memcpy((void *)&new->nid, (const void *)nid, sizeof(struct node_id) /*40ul*/ );
  struct sockfd_cache_entry *return_value_sockfd_cache_insert_3;
  return_value_sockfd_cache_insert_3=sockfd_cache_insert(new);
  if(!(return_value_sockfd_cache_insert_3 == ((struct sockfd_cache_entry *)NULL)))
    free_cache_entry(new);

  else
    sockfd_cache.count = sockfd_cache.count + 1;
}

// sockfd_cache_close
// file sockfd_cache.c line 381
static void sockfd_cache_close(struct node_id *nid, signed int idx)
{
  _Bool use_io = (_Bool)(nid->io_port != 0 ? 1 : 0);
  const unsigned char *addr;
  unsigned char *tmp_if_expr_1;
  if(!(use_io == (_Bool)0))
    tmp_if_expr_1 = nid->io_addr;

  else
    tmp_if_expr_1 = nid->addr;
  addr = tmp_if_expr_1;
  signed int port;
  signed int tmp_if_expr_2;
  if(!(use_io == (_Bool)0))
    tmp_if_expr_2 = (signed int)nid->io_port;

  else
    tmp_if_expr_2 = (signed int)nid->port;
  port = tmp_if_expr_2;
  struct sockfd_cache_entry *entry;
  const char *return_value_addr_to_str_3;
  if(sd_log_level == 7)
  {
    return_value_addr_to_str_3=addr_to_str(addr, (unsigned short int)port);
    log_write(7, "sockfd_cache_close", 388, "%s idx %d", return_value_addr_to_str_3, idx);
  }

  sd_write_lock(&sockfd_cache.lock);
  entry=sockfd_cache_search(nid);
  if(!(entry == ((struct sockfd_cache_entry *)NULL)))
  {
    close((entry->fds + (signed long int)idx)->fd);
    (entry->fds + (signed long int)idx)->fd = -1;
    uatomic_set_false(&(entry->fds + (signed long int)idx)->in_use);
  }

  sd_rw_unlock(&sockfd_cache.lock);
}

// sockfd_cache_cmp
// file sockfd_cache.c line 75
static signed int sockfd_cache_cmp(struct sockfd_cache_entry *a, struct sockfd_cache_entry *b)
{
  signed int return_value_node_id_cmp_1;
  return_value_node_id_cmp_1=node_id_cmp_link1(&a->nid, &b->nid);
  return return_value_node_id_cmp_1;
}

// sockfd_cache_del
// file sockfd_cache.c line 485
void sockfd_cache_del(struct node_id *nid, struct sockfd *sfd)
{
  if(sfd->idx == -1)
  {
    if(sd_log_level == 7)
      log_write(7, "sockfd_cache_del", 488, "%d", sfd->fd);

    close(sfd->fd);
    free((void *)sfd);
  }

  else
  {
    sockfd_cache_close(nid, sfd->idx);
    sockfd_cache_del_node(nid);
    free((void *)sfd);
  }
}

// sockfd_cache_del_node
// file sockfd_cache.c line 467
void sockfd_cache_del_node(struct node_id *nid)
{
  signed int n;
  _Bool return_value_sockfd_cache_destroy_1;
  return_value_sockfd_cache_destroy_1=sockfd_cache_destroy(nid);
  const char *return_value_addr_to_str_3;
  if(!(return_value_sockfd_cache_destroy_1 == (_Bool)0))
  {
    unsigned long int return_value___uatomic_add_return_2;
    return_value___uatomic_add_return_2=__uatomic_add_return((void *)&sockfd_cache.count, (unsigned long int)-((unsigned long int)1), (signed int)sizeof(signed int) /*4ul*/ );
    n = (signed int)return_value___uatomic_add_return_2;
    if(sd_log_level == 7)
    {
      return_value_addr_to_str_3=addr_to_str(nid->addr, nid->port);
      log_write(7, "sockfd_cache_del_node", 475, "%s, count %d", return_value_addr_to_str_3, n);
    }

  }

}

// sockfd_cache_destroy
// file sockfd_cache.c line 162
static _Bool sockfd_cache_destroy(struct node_id *nid)
{
  struct sockfd_cache_entry *entry;
  sd_write_lock(&sockfd_cache.lock);
  entry=sockfd_cache_search(nid);
  _Bool return_value_slots_all_free_1;
  if(entry == ((struct sockfd_cache_entry *)NULL))
  {
    if(sd_log_level == 7)
      log_write(7, "sockfd_cache_destroy", 169, "It is already destroyed");

  }

  else
  {
    return_value_slots_all_free_1=slots_all_free(entry);
    if(return_value_slots_all_free_1 == (_Bool)0)
    {
      if(sd_log_level == 7)
        log_write(7, "sockfd_cache_destroy", 174, "Some victim still holds it");

    }

    else
    {
      rb_erase(&entry->rb, &sockfd_cache.root);
      sd_rw_unlock(&sockfd_cache.lock);
      destroy_all_slots(entry);
      free_cache_entry(entry);
      return (_Bool)1;
    }
  }

false_out:
  ;
  sd_rw_unlock(&sockfd_cache.lock);
  return (_Bool)0;
}

// sockfd_cache_get
// file sockfd_cache.c line 425
struct sockfd * sockfd_cache_get(struct node_id *nid)
{
  struct sockfd *sfd;
  signed int fd;
  sfd=sockfd_cache_get_long(nid);
  if(!(sfd == ((struct sockfd *)NULL)))
    return sfd;

  else
  {
    fd=connect_to_addr(nid->addr, (signed int)nid->port);
    if(!(fd >= 0))
      return (struct sockfd *)(void *)0;

    else
    {
      void *return_value_xmalloc_1;
      return_value_xmalloc_1=xmalloc(sizeof(struct sockfd) /*8ul*/ );
      sfd = (struct sockfd *)return_value_xmalloc_1;
      sfd->idx = -1;
      sfd->fd = fd;
      if(sd_log_level == 7)
        log_write(7, "sockfd_cache_get", 442, "%d", fd);

      return sfd;
    }
  }
}

// sockfd_cache_get_long
// file sockfd_cache.c line 313
static struct sockfd * sockfd_cache_get_long(struct node_id *nid)
{
  struct sockfd_cache_entry *entry;
  struct sockfd *sfd;
  _Bool use_io = (_Bool)(nid->io_port != 0 ? 1 : 0);
  const unsigned char *addr;
  unsigned char *tmp_if_expr_1;
  if(!(use_io == (_Bool)0))
    tmp_if_expr_1 = nid->io_addr;

  else
    tmp_if_expr_1 = nid->addr;
  addr = tmp_if_expr_1;
  signed int fd;
  signed int idx = -1;
  signed int port;
  signed int tmp_if_expr_2;
  if(!(use_io == (_Bool)0))
    tmp_if_expr_2 = (signed int)nid->io_port;

  else
    tmp_if_expr_2 = (signed int)nid->port;
  port = tmp_if_expr_2;
  signed int return_value_revalidate_node_3;
  do
  {

  grab:
    ;
    entry=sockfd_cache_grab(nid, &idx);
    if(!(entry == ((struct sockfd_cache_entry *)NULL)))
      break;

    return_value_revalidate_node_3=revalidate_node(nid);
    if(return_value_revalidate_node_3 == 0)
      return (struct sockfd *)(void *)0;

  }
  while((_Bool)1);
  check_idx(idx);
  const char *return_value_addr_to_str_4;
  const char *return_value_addr_to_str_5;
  if(!((entry->fds + (signed long int)idx)->fd == -1))
  {
    if(sd_log_level == 7)
    {
      return_value_addr_to_str_4=addr_to_str(addr, (unsigned short int)port);
      log_write(7, "sockfd_cache_get_long", 338, "%s, idx %d", return_value_addr_to_str_4, idx);
    }

  }

  else
  {
    if(sd_log_level == 7)
    {
      return_value_addr_to_str_5=addr_to_str(addr, (unsigned short int)port);
      log_write(7, "sockfd_cache_get_long", 344, "create cache connection %s idx %d", return_value_addr_to_str_5, idx);
    }

    fd=connect_to_addr(addr, port);
    if(!(fd >= 0))
    {
      if(!(use_io == (_Bool)0))
      {
        log_write(3, "sockfd_cache_get_long", 348, "fallback to non-io connection");
        fd=connect_to_addr(nid->addr, (signed int)nid->port);
        if(fd >= 0)
          goto new;

      }

      uatomic_set_false(&(entry->fds + (signed long int)idx)->in_use);
      return (struct sockfd *)(void *)0;
    }


  new:
    ;
    (entry->fds + (signed long int)idx)->fd = fd;
  }

out:
  ;
  void *return_value_xmalloc_6;
  return_value_xmalloc_6=xmalloc(sizeof(struct sockfd) /*8ul*/ );
  sfd = (struct sockfd *)return_value_xmalloc_6;
  sfd->fd = (entry->fds + (signed long int)idx)->fd;
  sfd->idx = idx;
  return sfd;
}

// sockfd_cache_grab
// file sockfd_cache.c line 112
static struct sockfd_cache_entry * sockfd_cache_grab(struct node_id *nid, signed int *ret_idx)
{
  struct sockfd_cache_entry *entry;
  sd_read_lock(&sockfd_cache.lock);
  entry=sockfd_cache_search(nid);
  const char *return_value_addr_to_str_1;
  if(entry == ((struct sockfd_cache_entry *)NULL))
  {
    if(sd_log_level == 7)
    {
      return_value_addr_to_str_1=addr_to_str(nid->addr, nid->port);
      log_write(7, "sockfd_cache_grab", 120, "failed node %s", return_value_addr_to_str_1);
    }

  }

  else
  {
    *ret_idx=get_free_slot(entry);
    if(*ret_idx == -1)
      entry = (struct sockfd_cache_entry *)(void *)0;

  }

out:
  ;
  sd_rw_unlock(&sockfd_cache.lock);
  return entry;
}

// sockfd_cache_insert
// file sockfd_cache.c line 82
static struct sockfd_cache_entry * sockfd_cache_insert(struct sockfd_cache_entry *new)
{
  struct sockfd_cache_entry *tmp_statement_expression_1;
  struct rb_node **__n = &(&sockfd_cache.root)->rb_node;
  struct rb_node *__parent = (struct rb_node *)(void *)0;
  struct sockfd_cache_entry *__old = (struct sockfd_cache_entry *)(void *)0;
  struct sockfd_cache_entry *__data;
  struct sockfd_cache_entry *tmp_statement_expression_2;
  while(!(*__n == ((struct rb_node *)NULL)))
  {
    const struct rb_node *__mptr = *__n;
    tmp_statement_expression_2 = (struct sockfd_cache_entry *)((char *)__mptr - (signed long int)0ul);
    __data = tmp_statement_expression_2;
    signed int __cmp;
    __cmp=sockfd_cache_cmp(new, __data);
    __parent = *__n;
    if(!(__cmp >= 0))
      __n = &(*__n)->rb_left;

    else
      if(__cmp >= 1)
        __n = &(*__n)->rb_right;

      else
      {
        __old = __data;
        break;
      }
  }
  if(__old == ((struct sockfd_cache_entry *)NULL))
  {
    rb_link_node_link1(&new->rb, __parent, __n);
    rb_insert_color(&new->rb, &sockfd_cache.root);
  }

  tmp_statement_expression_1 = __old;
  return tmp_statement_expression_1;
}

// sockfd_cache_put
// file sockfd_cache.c line 453
void sockfd_cache_put(struct node_id *nid, struct sockfd *sfd)
{
  if(sfd->idx == -1)
  {
    if(sd_log_level == 7)
      log_write(7, "sockfd_cache_put", 456, "%d", sfd->fd);

    close(sfd->fd);
    free((void *)sfd);
  }

  else
  {
    sockfd_cache_put_long(nid, sfd->idx);
    free((void *)sfd);
  }
}

// sockfd_cache_put_long
// file sockfd_cache.c line 365
static void sockfd_cache_put_long(struct node_id *nid, signed int idx)
{
  _Bool use_io = (_Bool)(nid->io_port != 0 ? 1 : 0);
  const unsigned char *addr;
  unsigned char *tmp_if_expr_1;
  if(!(use_io == (_Bool)0))
    tmp_if_expr_1 = nid->io_addr;

  else
    tmp_if_expr_1 = nid->addr;
  addr = tmp_if_expr_1;
  signed int port;
  signed int tmp_if_expr_2;
  if(!(use_io == (_Bool)0))
    tmp_if_expr_2 = (signed int)nid->io_port;

  else
    tmp_if_expr_2 = (signed int)nid->port;
  port = tmp_if_expr_2;
  struct sockfd_cache_entry *entry;
  const char *return_value_addr_to_str_3;
  if(sd_log_level == 7)
  {
    return_value_addr_to_str_3=addr_to_str(addr, (unsigned short int)port);
    log_write(7, "sockfd_cache_put_long", 372, "%s idx %d", return_value_addr_to_str_3, idx);
  }

  sd_read_lock(&sockfd_cache.lock);
  entry=sockfd_cache_search(nid);
  if(!(entry == ((struct sockfd_cache_entry *)NULL)))
    uatomic_set_false(&(entry->fds + (signed long int)idx)->in_use);

  sd_rw_unlock(&sockfd_cache.lock);
}

// sockfd_cache_search
// file sockfd_cache.c line 87
static struct sockfd_cache_entry * sockfd_cache_search(struct node_id *nid)
{
  struct sockfd_cache_entry key = { .rb={ .rb_parent_color=0ul, .rb_right=((struct rb_node *)NULL), .rb_left=((struct rb_node *)NULL) }, .nid=*nid,
    .fds=((struct sockfd_cache_fd *)NULL) };
  struct sockfd_cache_entry *tmp_statement_expression_1;
  struct rb_node *__n = (&sockfd_cache.root)->rb_node;
  struct sockfd_cache_entry *__ret = (struct sockfd_cache_entry *)(void *)0;
  struct sockfd_cache_entry *__data;
  struct sockfd_cache_entry *tmp_statement_expression_2;
  while(!(__n == ((struct rb_node *)NULL)))
  {
    const struct rb_node *__mptr = __n;
    tmp_statement_expression_2 = (struct sockfd_cache_entry *)((char *)__mptr - (signed long int)0ul);
    __data = tmp_statement_expression_2;
    signed int __cmp;
    __cmp=sockfd_cache_cmp(&key, __data);
    if(!(__cmp >= 0))
      __n = __n->rb_left;

    else
      if(__cmp >= 1)
        __n = __n->rb_right;

      else
      {
        __ret = __data;
        break;
      }
  }
  tmp_statement_expression_1 = __ret;
  return tmp_statement_expression_1;
}

// sockfd_init
// file sockfd_cache.c line 404
signed int sockfd_init(void)
{
  grow_wq=create_ordered_work_queue("sockfd_grow");
  if(grow_wq == ((struct work_queue *)NULL))
  {
    log_write(3, "sockfd_init", 409, "error at creating workqueue for sockfd growth");
    return -1;
  }

  else
    return 0;
}

// sph_cli_msg_to_str
// file ../include/shepherd.h line 74
static inline const char * sph_cli_msg_to_str(enum sph_cli_msg_type msg)
{
  signed int i = 0;
  /* tag-#anon#clST[lENtag-sph_cli_msg_type#{U32}_U32_'msg'||U32'_pad0'||l*{cS8}_cS8_'desc'|] */
struct anonymous_26
{
  // msg
  enum sph_cli_msg_type msg;
  // desc
  const char *desc;
};

/* */
  ;
  static struct anonymous_26 msgs[5l] = { { .msg=(enum sph_cli_msg_type)SPH_CLI_MSG_JOIN, .desc="SPH_CLI_MSG_JOIN" },
    { .msg=(enum sph_cli_msg_type)SPH_CLI_MSG_ACCEPT, .desc="SPH_CLI_MSG_ACCEPT" },
    { .msg=(enum sph_cli_msg_type)SPH_CLI_MSG_NOTIFY, .desc="SPH_CLI_MSG_NOTIFY" },
    { .msg=(enum sph_cli_msg_type)SPH_CLI_MSG_BLOCK, .desc="SPH_CLI_MSG_BLOCK" },
    { .msg=(enum sph_cli_msg_type)SPH_CLI_MSG_LEAVE, .desc="SPH_CLI_MSG_LEAVE" } };
  for( ; !((unsigned long int)i >= 5ul); i = i + 1)
    if(msgs[(signed long int)i].msg == msg)
      return msgs[(signed long int)i].desc;

  static char unknown[64l];
  memset((void *)unknown, 0, (unsigned long int)64);
  snprintf(unknown, (unsigned long int)64, "<unknown shepherd client message: %d>", msg);
  return unknown;
}

// sph_handle_accept
// file shepherd.c line 289
static void sph_handle_accept(struct sph_msg *msg, struct sheep *sheep)
{
  signed int fd = sheep->fd;
  signed int removed = 0;
  signed long int rbytes;
  signed long int wbytes;
  char *opaque;
  signed int opaque_len;
  struct sph_msg_join *join;
  struct sheep *s;
  struct sheep *joining_sheep;
  struct sph_msg snd;
  struct sph_msg_join_reply *join_reply_body;
  struct sph_msg_join_node_finish *join_node_finish;
  const char *return_value_node_to_str_1;
  if(sd_log_level == 7)
  {
    return_value_node_to_str_1=node_to_str(&sheep->node);
    log_write(7, "sph_handle_accept", 303, "new node reply from %s", return_value_node_to_str_1);
  }

  void *return_value_xzalloc_2;
  return_value_xzalloc_2=xzalloc((unsigned long int)msg->body_len);
  join = (struct sph_msg_join *)return_value_xzalloc_2;
  rbytes=xread(fd, (void *)join, (unsigned long int)msg->body_len);
  const char *return_value_node_to_str_3;
  void *return_value_xzalloc_4;
  void *return_value_xzalloc_5;
  signed int return_value_build_node_array_6;
  unsigned int tmp_post_7;
  signed int return_value_do_writev2_8;
  void *return_value_xzalloc_9;
  signed int return_value_build_node_array_10;
  unsigned int tmp_post_11;
  struct sheep *tmp_statement_expression_12;
  struct sheep *tmp_statement_expression_13;
  struct sheep *tmp_statement_expression_14;
  signed int return_value_release_joining_sheep_16;
  if(!((signed long int)msg->body_len == rbytes))
  {
    log_write(3, "sph_handle_accept", 308, "xread() failed: %m");
    free((void *)join);
  }

  else
  {
    if(sd_log_level == 7)
    {
      return_value_node_to_str_3=node_to_str(&join->new_node);
      log_write(7, "sph_handle_accept", 314, "joining node is %s", return_value_node_to_str_3);
    }

    joining_sheep=find_sheep_by_nid(&join->new_node.nid);
    opaque_len = (signed int)((unsigned long int)msg->body_len - sizeof(struct sph_msg_join) /*491608ul*/ );
    return_value_xzalloc_4=xzalloc((unsigned long int)opaque_len);
    opaque = (char *)return_value_xzalloc_4;
    memcpy((void *)opaque, (const void *)join->opaque, (unsigned long int)opaque_len);
    if(sd_log_level == 7)
      log_write(7, "sph_handle_accept", 323, "length of opaque: %d", opaque_len);

    memset((void *)&snd, 0, sizeof(struct sph_msg) /*8ul*/ );
    snd.type = (unsigned int)0;
    snd.body_len = (unsigned int)(sizeof(struct sph_msg_join_reply) /*491528ul*/  + (unsigned long int)opaque_len);
    return_value_xzalloc_5=xzalloc((unsigned long int)snd.body_len);
    join_reply_body = (struct sph_msg_join_reply *)return_value_xzalloc_5;
    return_value_build_node_array_6=build_node_array(join_reply_body->nodes);
    join_reply_body->nr_nodes = (unsigned int)return_value_build_node_array_6;
    tmp_post_7 = join_reply_body->nr_nodes;
    join_reply_body->nr_nodes = join_reply_body->nr_nodes + 1u;
    join_reply_body->nodes[(signed long int)tmp_post_7] = joining_sheep->node;
    memcpy((void *)join_reply_body->opaque, (const void *)opaque, (unsigned long int)opaque_len);
    return_value_do_writev2_8=do_writev2(joining_sheep->fd, (void *)&snd, sizeof(struct sph_msg) /*8ul*/ , (void *)join_reply_body, (unsigned long int)snd.body_len);
    wbytes = (signed long int)return_value_do_writev2_8;
    free((void *)join_reply_body);
    free((void *)join);
    if(!(sizeof(struct sph_msg) /*8ul*/  + (unsigned long int)snd.body_len == (unsigned long int)wbytes))
      log_write(3, "sph_handle_accept", 345, "writev2() to master failed: %m");

    else
    {
      snd.type = (unsigned int)3;
      snd.body_len = (unsigned int)(sizeof(struct sph_msg_join_node_finish) /*491608ul*/  + (unsigned long int)opaque_len);
      return_value_xzalloc_9=xzalloc((unsigned long int)snd.body_len);
      join_node_finish = (struct sph_msg_join_node_finish *)return_value_xzalloc_9;
      join_node_finish->new_node = joining_sheep->node;
      memcpy((void *)join_node_finish->opaque, (const void *)opaque, (unsigned long int)opaque_len);
      return_value_build_node_array_10=build_node_array(join_node_finish->nodes);
      join_node_finish->nr_nodes = (unsigned int)return_value_build_node_array_10;
      tmp_post_11 = join_node_finish->nr_nodes;
      join_node_finish->nr_nodes = join_node_finish->nr_nodes + 1u;
      join_node_finish->nodes[(signed long int)tmp_post_11] = joining_sheep->node;
      struct sheep *__n360;
      const struct list_node *__mptr = (&sheep_list_head)->n.next;
      tmp_statement_expression_12 = (struct sheep *)((char *)__mptr - (signed long int)112ul);
      s = tmp_statement_expression_12;
      const struct list_node *sph_handle_accept__1__6__2____mptr = s->sheep_list.next;
      tmp_statement_expression_13 = (struct sheep *)((char *)sph_handle_accept__1__6__2____mptr - (signed long int)112ul);
      __n360 = tmp_statement_expression_13;
      for( ; !(&s->sheep_list == &(&sheep_list_head)->n); __n360 = tmp_statement_expression_14)
      {
        if((signed int)s->state == SHEEP_STATE_JOINED)
        {
          if(!(s == joining_sheep))
          {
            signed int return_value_do_writev2_15;
            return_value_do_writev2_15=do_writev2(s->fd, (void *)&snd, sizeof(struct sph_msg) /*8ul*/ , (void *)join_node_finish, (unsigned long int)snd.body_len);
            wbytes = (signed long int)return_value_do_writev2_15;
            if(!(sizeof(struct sph_msg) /*8ul*/  + (unsigned long int)snd.body_len == (unsigned long int)wbytes))
            {
              log_write(3, "sph_handle_accept", 370, "writev2() failed: %m");
              remove_sheep(s);
              removed = removed + 1;
            }

          }

        }

        s = __n360;
        const struct list_node *sph_handle_accept__1__6__3____mptr = __n360->sheep_list.next;
        tmp_statement_expression_14 = (struct sheep *)((char *)sph_handle_accept__1__6__3____mptr - (signed long int)112ul);
      }
      free((void *)join_node_finish);
      free((void *)opaque);
      joining_sheep->state = (enum sheep_state)SHEEP_STATE_JOINED;
      state = (enum shepherd_state)SPH_STATE_DEFAULT;
      return_value_release_joining_sheep_16=release_joining_sheep();
      removed = removed + return_value_release_joining_sheep_16;
      goto __CPROVER_DUMP_L11;
    }
  }

purge_current_sheep:
  ;
  state = (enum shepherd_state)SPH_STATE_DEFAULT;
  remove_sheep(sheep);

__CPROVER_DUMP_L11:
  ;
}

// sph_handle_block
// file shepherd.c line 447
static void sph_handle_block(struct sph_msg *msg, struct sheep *sheep)
{
  signed int removed = 0;
  struct sheep *s;
  struct sph_msg snd;
  memset((void *)&snd, 0, sizeof(struct sph_msg) /*8ul*/ );
  snd.type = (unsigned int)5;
  snd.body_len = (unsigned int)sizeof(struct sd_node) /*80ul*/ ;
  struct sheep *__n457;
  struct sheep *tmp_statement_expression_1;
  const struct list_node *__mptr = (&sheep_list_head)->n.next;
  tmp_statement_expression_1 = (struct sheep *)((char *)__mptr - (signed long int)112ul);
  s = tmp_statement_expression_1;
  struct sheep *tmp_statement_expression_2;
  const struct list_node *sph_handle_block__1__1__2____mptr = s->sheep_list.next;
  tmp_statement_expression_2 = (struct sheep *)((char *)sph_handle_block__1__1__2____mptr - (signed long int)112ul);
  __n457 = tmp_statement_expression_2;
  struct sheep *tmp_statement_expression_3;
  for( ; !(&s->sheep_list == &(&sheep_list_head)->n); __n457 = tmp_statement_expression_3)
  {
    signed long int wbytes;
    if((signed int)s->state == SHEEP_STATE_JOINED)
    {
      signed int return_value_do_writev2_4;
      return_value_do_writev2_4=do_writev2(s->fd, (void *)&snd, sizeof(struct sph_msg) /*8ul*/ , (void *)&sheep->node, sizeof(struct sd_node) /*80ul*/ );
      wbytes = (signed long int)return_value_do_writev2_4;
      if(!((unsigned long int)wbytes == sizeof(struct sph_msg) * 11 /*88ul*/ ))
        log_write(3, "sph_handle_block", 466, "writev2() failed: %m");

      else
        goto __CPROVER_DUMP_L5;

    block_failed:
      ;
      remove_sheep(s);
      removed = removed + 1;
    }


  __CPROVER_DUMP_L5:
    ;
    s = __n457;
    const struct list_node *sph_handle_block__1__1__3____mptr = __n457->sheep_list.next;
    tmp_statement_expression_3 = (struct sheep *)((char *)sph_handle_block__1__1__3____mptr - (signed long int)112ul);
  }
  goto __CPROVER_DUMP_L7;

__CPROVER_DUMP_L7:
  ;
}

// sph_handle_join
// file shepherd.c line 228
static void sph_handle_join(struct sph_msg *msg, struct sheep *sheep)
{
  signed int fd = sheep->fd;
  signed long int rbytes;
  signed long int wbytes;
  struct sph_msg snd;
  struct sph_msg_join *join;
  if((signed int)state == SPH_STATE_JOINING)
  {
    char *buf;
    void *return_value_xzalloc_1;
    return_value_xzalloc_1=xzalloc((unsigned long int)msg->body_len);
    buf = (char *)return_value_xzalloc_1;
    rbytes=xread(fd, (void *)buf, (unsigned long int)msg->body_len);
    if(!(rbytes == (signed long int)msg->body_len))
    {
      log_write(3, "sph_handle_join", 242, "xread() failed: %m");
      goto purge_current_sheep;
    }

    free((void *)buf);
    list_add(&sheep->join_wait_list, &join_wait_queue);
    if(sd_log_level == 7)
      log_write(7, "sph_handle_join", 249, "there is already a joining sheep");

    goto __CPROVER_DUMP_L8;
  }

  void *return_value_xzalloc_2;
  return_value_xzalloc_2=xzalloc((unsigned long int)msg->body_len);
  join = (struct sph_msg_join *)return_value_xzalloc_2;
  rbytes=xread(fd, (void *)join, (unsigned long int)msg->body_len);
  signed int return_value_build_node_array_3;
  signed int return_value_do_writev2_6;
  if(!((signed long int)msg->body_len == rbytes))
  {
    log_write(3, "sph_handle_join", 256, "xread() failed: %m");
    free((void *)join);
  }

  else
  {
    sheep->node = join->new_node;
    return_value_build_node_array_3=build_node_array(join->nodes);
    join->nr_nodes = (unsigned int)return_value_build_node_array_3;
    snd.type = (unsigned int)2;
    snd.body_len = msg->body_len;
    if(join->nr_nodes >= 1u)
    {
      struct sd_node *n;
      signed int return_value_rand_4;
      return_value_rand_4=rand();
      n = join->nodes + (signed long int)((unsigned int)return_value_rand_4 % join->nr_nodes);
      struct sheep *return_value_find_sheep_by_nid_5;
      return_value_find_sheep_by_nid_5=find_sheep_by_nid(&n->nid);
      fd = return_value_find_sheep_by_nid_5->fd;
    }

    return_value_do_writev2_6=do_writev2(fd, (void *)&snd, sizeof(struct sph_msg) /*8ul*/ , (void *)join, (unsigned long int)msg->body_len);
    wbytes = (signed long int)return_value_do_writev2_6;
    free((void *)join);
    if(!(sizeof(struct sph_msg) /*8ul*/  + (unsigned long int)msg->body_len == (unsigned long int)wbytes))
      log_write(3, "sph_handle_join", 277, "writev2() failed: %m");

    else
    {
      state = (enum shepherd_state)SPH_STATE_JOINING;
      goto __CPROVER_DUMP_L8;
    }
  }

purge_current_sheep:
  ;
  remove_sheep(sheep);

__CPROVER_DUMP_L8:
  ;
}

// sph_handle_leave
// file shepherd.c line 480
static void sph_handle_leave(struct sph_msg *msg, struct sheep *sheep)
{
  struct sheep *s;
  struct sph_msg snd;
  const char *return_value_node_to_str_1;
  return_value_node_to_str_1=node_to_str(&sheep->node);
  log_write(6, "sph_handle_leave", 485, "%s is leaving", return_value_node_to_str_1);
  memset((void *)&snd, 0, sizeof(struct sph_msg) /*8ul*/ );
  snd.type = (unsigned int)6;
  snd.body_len = (unsigned int)sizeof(struct sd_node) /*80ul*/ ;
  struct sheep *__n491;
  struct sheep *tmp_statement_expression_2;
  const struct list_node *sph_handle_leave__1__1__1____mptr = (&sheep_list_head)->n.next;
  tmp_statement_expression_2 = (struct sheep *)((char *)sph_handle_leave__1__1__1____mptr - (signed long int)112ul);
  s = tmp_statement_expression_2;
  struct sheep *tmp_statement_expression_3;
  const struct list_node *sph_handle_leave__1__1__2____mptr = s->sheep_list.next;
  tmp_statement_expression_3 = (struct sheep *)((char *)sph_handle_leave__1__1__2____mptr - (signed long int)112ul);
  __n491 = tmp_statement_expression_3;
  struct sheep *tmp_statement_expression_4;
  for( ; !(&s->sheep_list == &(&sheep_list_head)->n); __n491 = tmp_statement_expression_4)
  {
    signed long int wbytes;
    if((signed int)s->state == SHEEP_STATE_JOINED)
    {
      signed int return_value_do_writev2_5;
      return_value_do_writev2_5=do_writev2(s->fd, (void *)&snd, sizeof(struct sph_msg) /*8ul*/ , (void *)&sheep->node, sizeof(struct sd_node) /*80ul*/ );
      wbytes = (signed long int)return_value_do_writev2_5;
      if(!((unsigned long int)wbytes == sizeof(struct sph_msg) * 11 /*88ul*/ ))
        log_write(3, "sph_handle_leave", 500, "writev2() failed: %m");

      else
        goto __CPROVER_DUMP_L5;

    fwd_leave_failed:
      ;
      remove_sheep(s);
    }


  __CPROVER_DUMP_L5:
    ;
    s = __n491;
    const struct list_node *__mptr = __n491->sheep_list.next;
    tmp_statement_expression_4 = (struct sheep *)((char *)__mptr - (signed long int)112ul);
  }
}

// sph_handle_notify
// file shepherd.c line 392
static void sph_handle_notify(struct sph_msg *msg, struct sheep *sheep)
{
  signed long int rbytes;
  signed long int wbytes;
  signed int fd = sheep->fd;
  signed int removed = 0;
  struct sph_msg snd;
  struct sph_msg_notify *notify;
  signed int notify_msg_len;
  struct sph_msg_notify_forward *notify_forward;
  struct sheep *s;
  void *return_value_xzalloc_1;
  return_value_xzalloc_1=xzalloc((unsigned long int)msg->body_len);
  notify = (struct sph_msg_notify *)return_value_xzalloc_1;
  rbytes=xread(fd, (void *)notify, (unsigned long int)msg->body_len);
  void *return_value_xzalloc_2;
  struct sheep *tmp_statement_expression_3;
  struct sheep *tmp_statement_expression_4;
  struct sheep *tmp_statement_expression_5;
  if(!(rbytes == (signed long int)msg->body_len))
    log_write(3, "sph_handle_notify", 406, "xread() failed: %m");

  else
  {
    return_value_xzalloc_2=xzalloc((unsigned long int)msg->body_len + sizeof(struct sph_msg_notify_forward) /*88ul*/ );
    notify_forward = (struct sph_msg_notify_forward *)return_value_xzalloc_2;
    notify_msg_len = (signed int)((unsigned long int)msg->body_len - sizeof(struct sph_msg_notify) /*1ul*/ );
    memcpy((void *)notify_forward->notify_msg, (const void *)notify->notify_msg, (unsigned long int)notify_msg_len);
    notify_forward->unblock = notify->unblock;
    free((void *)notify);
    memset((void *)&snd, 0, sizeof(struct sph_msg) /*8ul*/ );
    snd.type = (unsigned int)4;
    snd.body_len = (unsigned int)((unsigned long int)notify_msg_len + sizeof(struct sph_msg_notify_forward) /*88ul*/ );
    notify_forward->from_node = sheep->node;
    struct sheep *__n423;
    const struct list_node *__mptr = (&sheep_list_head)->n.next;
    tmp_statement_expression_3 = (struct sheep *)((char *)__mptr - (signed long int)112ul);
    s = tmp_statement_expression_3;
    const struct list_node *sph_handle_notify__1__2__2____mptr = s->sheep_list.next;
    tmp_statement_expression_4 = (struct sheep *)((char *)sph_handle_notify__1__2__2____mptr - (signed long int)112ul);
    __n423 = tmp_statement_expression_4;
    for( ; !(&s->sheep_list == &(&sheep_list_head)->n); __n423 = tmp_statement_expression_5)
    {
      if((signed int)s->state == SHEEP_STATE_JOINED)
      {
        signed int return_value_do_writev2_6;
        return_value_do_writev2_6=do_writev2(s->fd, (void *)&snd, sizeof(struct sph_msg) /*8ul*/ , (void *)notify_forward, (unsigned long int)snd.body_len);
        wbytes = (signed long int)return_value_do_writev2_6;
        if(!(sizeof(struct sph_msg) /*8ul*/  + (unsigned long int)snd.body_len == (unsigned long int)wbytes))
          log_write(3, "sph_handle_notify", 429, "writev2() failed: %m");

        else
          goto __CPROVER_DUMP_L5;

      notify_failed:
        ;
        remove_sheep(s);
        removed = removed + 1;
      }


    __CPROVER_DUMP_L5:
      ;
      s = __n423;
      const struct list_node *sph_handle_notify__1__2__3____mptr = __n423->sheep_list.next;
      tmp_statement_expression_5 = (struct sheep *)((char *)sph_handle_notify__1__2__3____mptr - (signed long int)112ul);
    }
    free((void *)notify_forward);
    goto __CPROVER_DUMP_L8;
  }

purge_current_sheep:
  ;
  remove_sheep(sheep);

__CPROVER_DUMP_L8:
  ;
}

// split_ext_node
// file sd_inode.c line 471
static void split_ext_node(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), struct sd_inode *inode, struct find_path *path)
{
  struct sd_extent_header *old = path->p_ext_header;
  struct sd_extent_header *new_ext;
  unsigned int num = old->entries / (unsigned int)2;
  unsigned long int new_oid;
  void *return_value_xvalloc_1;
  return_value_xvalloc_1=xvalloc(sizeof(unsigned int) /*4ul*/  * (1ULL << 20));
  new_ext = (struct sd_extent_header *)return_value_xvalloc_1;
  split_to_nodes(old, new_ext, old, (signed int)num);
  unsigned int tmp_post_2 = inode->btree_counter;
  inode->btree_counter = inode->btree_counter + 1u;
  new_oid=vid_to_btree_oid(inode->vdi_id, tmp_post_2);
  writer(new_oid, (void *)new_ext, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0, (unsigned int)0, (signed int)inode->nr_copies, (signed int)inode->copy_policy, (_Bool)1, (_Bool)0);
  writer(path->p_idx->oid, (void *)old, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0, (unsigned int)0, (signed int)inode->nr_copies, (signed int)inode->copy_policy, (_Bool)0, (_Bool)0);
  insert_idx_entry((struct sd_extent_header *)inode->data_vdi_id, ((struct sd_extent *)((char *)new_ext + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)new_ext)->entries)->idx, new_oid);
  free((void *)new_ext);
}

// split_path
// file util.c line 525
signed int split_path(const char *path, unsigned long int nr_segs, char **segs)
{
  signed int i = 0;
  for( ; !((unsigned long int)i >= nr_segs); i = i + 1)
  {
    for( ; (signed int)*path == 47; path = path + 1l)
      ;
    if((signed int)*path == 0)
      return i;

    if((unsigned long int)i == nr_segs + 18446744073709551615ul)
    {
      segs[(signed long int)i]=strdup(path);
      if(segs[(signed long int)i] == ((char *)NULL))
      {
        log_write(0, "split_path", 537, "PANIC: OOM");
        abort();
      }

    }

    else
    {
      char *p;
      p=strchrnul(path, 47);
      signed int len = (signed int)(p - path);
      void *return_value_xmalloc_1;
      return_value_xmalloc_1=xmalloc((unsigned long int)(len + 1));
      segs[(signed long int)i] = (char *)return_value_xmalloc_1;
      memcpy((void *)segs[(signed long int)i], (const void *)path, (unsigned long int)len);
      segs[(signed long int)i][(signed long int)len] = (char)0;
      path = p;
    }
  }
  return (signed int)nr_segs;
}

// split_to_nodes
// file sd_inode.c line 335
static void split_to_nodes(struct sd_extent_header *src, struct sd_extent_header *left, struct sd_extent_header *right, signed int num)
{
  memcpy((void *)left, (const void *)src, sizeof(struct sd_extent_header) /*8ul*/  + (unsigned long int)num * sizeof(struct sd_extent) /*8ul*/ );
  left->entries = (unsigned int)num;
  mempcpy((void *)right, (const void *)src, sizeof(struct sd_extent_header) /*8ul*/ );
  mempcpy((void *)(struct sd_extent *)((char *)right + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ), (const void *)((char *)src + (signed long int)sizeof(struct sd_extent_header) /*8ul*/  + (signed long int)((unsigned long int)num * sizeof(struct sd_extent) /*8ul*/ )), (unsigned long int)(src->entries - (unsigned int)num) * sizeof(struct sd_extent) /*8ul*/ );
  right->entries = src->entries - (unsigned int)num;
}

// str_to_addr
// file net.c line 413
unsigned char * str_to_addr(const char *ipstr, unsigned char *addr)
{
  signed int addr_start_idx = 0;
  signed int af;
  char *return_value_strstr_1;
  return_value_strstr_1=strstr(ipstr, ":");
  af = return_value_strstr_1 != ((char *)NULL) ? 10 : 2;
  if(af == 2)
  {
    addr_start_idx = 12;
    memset((void *)addr, 0, (unsigned long int)addr_start_idx);
  }

  signed int return_value_inet_pton_2;
  return_value_inet_pton_2=inet_pton(af, ipstr, (void *)(addr + (signed long int)addr_start_idx));
  if(return_value_inet_pton_2 == 0)
    return (unsigned char *)(void *)0;

  else
    return addr;
}

// strbuf_add
// file strbuf.c line 101
void strbuf_add(struct strbuf *sb, const void *data, unsigned long int len)
{
  strbuf_grow(sb, len);
  memcpy((void *)(sb->buf + (signed long int)sb->len), data, len);
  strbuf_setlen(sb, sb->len + len);
}

// strbuf_addf
// file strbuf.c line 108
void strbuf_addf(struct strbuf *sb, const char *fmt, ...)
{
  signed int len;
  void **ap = (void **)&fmt;
  len=vsnprintf(sb->buf + (signed long int)sb->len, sb->alloc - sb->len, fmt, ap);
  ap = ((void **)NULL);
  if(!(len >= 0))
    len = 0;

  unsigned long int return_value_strbuf_avail_2;
  return_value_strbuf_avail_2=strbuf_avail(sb);
  if(!(return_value_strbuf_avail_2 >= (unsigned long int)len))
  {
    strbuf_grow(sb, (unsigned long int)len);
    ap = (void **)&fmt;
    len=vsnprintf(sb->buf + (signed long int)sb->len, sb->alloc - sb->len, fmt, ap);
    ap = ((void **)NULL);
    unsigned long int return_value_strbuf_avail_1;
    return_value_strbuf_avail_1=strbuf_avail(sb);
    if(!(return_value_strbuf_avail_1 >= (unsigned long int)len))
    {
      log_write(0, "strbuf_addf", 124, "PANIC: this should not happen, your snprintf is broken");
      abort();
    }

  }

  strbuf_setlen(sb, sb->len + (unsigned long int)len);
}

// strbuf_attach
// file strbuf.c line 43
void strbuf_attach(struct strbuf *sb, void *buf, unsigned long int len, unsigned long int alloc)
{
  strbuf_release(sb);
  sb->buf = (char *)buf;
  sb->len = len;
  sb->alloc = alloc;
  strbuf_grow(sb, (unsigned long int)0);
  sb->buf[(signed long int)sb->len] = (char)0;
}

// strbuf_avail
// file ../include/strbuf.h line 49
static inline unsigned long int strbuf_avail(struct strbuf *sb)
{
  unsigned long int tmp_if_expr_1;
  if(!(sb->alloc == 0ul))
    tmp_if_expr_1 = (sb->alloc - sb->len) - (unsigned long int)1;

  else
    tmp_if_expr_1 = (unsigned long int)0;
  return tmp_if_expr_1;
}

// strbuf_copyout
// file strbuf.c line 193
signed int strbuf_copyout(struct strbuf *sb, void *buf, unsigned long int len)
{
  unsigned long int tmp_statement_expression_1;
  unsigned long int _x = len;
  unsigned long int _y = sb->len + (unsigned long int)1;
  (void)(&_x == &_y);
  tmp_statement_expression_1 = _x < _y ? _x : _y;
  len = tmp_statement_expression_1;
  memcpy(buf, (const void *)sb->buf, len);
  return (signed int)len;
}

// strbuf_detach
// file strbuf.c line 36
char * strbuf_detach(struct strbuf *sb)
{
  char *res = sb->buf;
  strbuf_init(sb, (unsigned long int)0);
  return res;
}

// strbuf_fread
// file strbuf.c line 129
unsigned long int strbuf_fread(struct strbuf *sb, unsigned long int size, struct _IO_FILE *f)
{
  unsigned long int res;
  strbuf_grow(sb, size);
  res=fread((void *)(sb->buf + (signed long int)sb->len), (unsigned long int)1, size, f);
  if(res >= 1ul)
    strbuf_setlen(sb, sb->len + res);

  return res;
}

// strbuf_getline
// file strbuf.c line 184
signed int strbuf_getline(struct strbuf *sb, struct _IO_FILE *fp, signed int term)
{
  signed int return_value_strbuf_getwholeline_1;
  return_value_strbuf_getwholeline_1=strbuf_getwholeline(sb, fp, term);
  if(!(return_value_strbuf_getwholeline_1 == 0))
    return -1;

  else
  {
    if((signed int)sb->buf[-1l + (signed long int)sb->len] == term)
      strbuf_setlen(sb, sb->len - (unsigned long int)1);

    return 0;
  }
}

// strbuf_getwholeline
// file strbuf.c line 163
static signed int strbuf_getwholeline(struct strbuf *sb, struct _IO_FILE *fp, signed int term)
{
  signed int ch;
  signed int return_value_feof_1;
  return_value_feof_1=feof(fp);
  unsigned long int tmp_post_2;
  if(!(return_value_feof_1 == 0))
    return -1;

  else
  {
    strbuf_reset(sb);
    do
    {
      ch=fgetc(fp);
      if(ch == -1)
        break;

      strbuf_grow(sb, (unsigned long int)1);
      tmp_post_2 = sb->len;
      sb->len = sb->len + 1ul;
      sb->buf[(signed long int)tmp_post_2] = (char)ch;
      if(ch == term)
        break;

    }
    while((_Bool)1);
    if(ch == -1)
    {
      if(!(sb->len == 0ul))
        goto __CPROVER_DUMP_L4;

      return -1;
    }

    else
    {

    __CPROVER_DUMP_L4:
      ;
      sb->buf[(signed long int)sb->len] = (char)0;
      return 0;
    }
  }
}

// strbuf_grow
// file strbuf.c line 53
void strbuf_grow(struct strbuf *sb, unsigned long int extra)
{
  if(sb->len >= 1ul + sb->len + extra)
  {
    log_write(0, "strbuf_grow", 56, "PANIC: you want to use way too much memory");
    abort();
  }

  do
    if(!(sb->alloc >= 1ul + sb->len + extra))
    {
      if(!(((16ul + sb->alloc) * 3ul) / 2ul >= 1ul + sb->len + extra))
        sb->alloc = sb->len + extra + (unsigned long int)1;

      else
        sb->alloc = ((sb->alloc + (unsigned long int)16) * (unsigned long int)3) / (unsigned long int)2;
      void *return_value_xrealloc_1;
      return_value_xrealloc_1=xrealloc((void *)sb->buf, sb->alloc * sizeof(char) /*1ul*/ );
      sb->buf = (char *)return_value_xrealloc_1;
    }

  while((_Bool)0);
}

// strbuf_init
// file strbuf.c line 16
void strbuf_init(struct strbuf *sb, unsigned long int hint)
{
  memset((void *)sb, 0, sizeof(struct strbuf) /*32ul*/ );
  if(!(hint == 0ul))
    strbuf_grow(sb, hint);

}

// strbuf_insert
// file strbuf.c line 67
void strbuf_insert(struct strbuf *sb, unsigned long int pos, const void *data, unsigned long int len)
{
  strbuf_grow(sb, len);
  if(!(sb->len >= pos))
  {
    log_write(0, "strbuf_insert", 71, "PANIC: `pos' is too far after the end of the buffer");
    abort();
  }

  memmove((void *)(sb->buf + (signed long int)pos + (signed long int)len), (const void *)(sb->buf + (signed long int)pos), sb->len - pos);
  memcpy((void *)(sb->buf + (signed long int)pos), data, len);
  strbuf_setlen(sb, sb->len + len);
}

// strbuf_read
// file strbuf.c line 140
signed long int strbuf_read(struct strbuf *sb, signed int fd, unsigned long int hint)
{
  unsigned long int oldlen = sb->len;
  strbuf_grow(sb, hint != 0ul ? hint : (unsigned long int)8192);
  do
  {
    signed long int cnt;
    cnt=xread(fd, (void *)(sb->buf + (signed long int)sb->len), (sb->alloc - sb->len) - (unsigned long int)1);
    if(!(cnt >= 0l))
    {
      strbuf_setlen(sb, oldlen);
      return (signed long int)-1;
    }

    if(cnt == 0l)
      break;

    sb->len = sb->len + (unsigned long int)cnt;
    strbuf_grow(sb, (unsigned long int)8192);
  }
  while((_Bool)1);
  sb->buf[(signed long int)sb->len] = (char)0;
  return (signed long int)(sb->len - oldlen);
}

// strbuf_release
// file strbuf.c line 23
void strbuf_release(struct strbuf *sb)
{
  free((void *)sb->buf);
  memset((void *)sb, 0, sizeof(struct strbuf) /*32ul*/ );
}

// strbuf_remove
// file strbuf.c line 96
void strbuf_remove(struct strbuf *sb, unsigned long int pos, unsigned long int len)
{
  strbuf_splice(sb, pos, len, (void *)0, (unsigned long int)0);
}

// strbuf_reset
// file strbuf.c line 29
void strbuf_reset(struct strbuf *sb)
{
  if(!(sb->len == 0ul))
    strbuf_setlen(sb, (unsigned long int)0);

  sb->eof = 0;
}

// strbuf_rtrim
// file strbuf.c line 60
void strbuf_rtrim(struct strbuf *sb)
{
  const unsigned short int **return_value___ctype_b_loc_1;
  for( ; sb->len >= 1ul; sb->len = sb->len - 1ul)
  {
    return_value___ctype_b_loc_1=__ctype_b_loc();
    if((8192 & (signed int)(*return_value___ctype_b_loc_1)[(signed long int)(signed int)(unsigned char)sb->buf[-1l + (signed long int)sb->len]]) == 0)
      break;

  }
  sb->buf[(signed long int)sb->len] = (char)0;
}

// strbuf_setlen
// file ../include/strbuf.h line 53
static inline void strbuf_setlen(struct strbuf *sb, unsigned long int len)
{
  sb->len = len;
  sb->buf[(signed long int)len] = (char)0;
}

// strbuf_splice
// file strbuf.c line 77
void strbuf_splice(struct strbuf *sb, unsigned long int pos, unsigned long int len, const void *data, unsigned long int dlen)
{
  if(!(len + pos >= pos))
  {
    log_write(0, "strbuf_splice", 81, "PANIC: you want to use way too much memory");
    abort();
  }

  if(!(sb->len >= pos))
  {
    log_write(0, "strbuf_splice", 83, "PANIC: `pos' is too far after the end of the buffer");
    abort();
  }

  if(!(sb->len >= len + pos))
  {
    log_write(0, "strbuf_splice", 85, "PANIC: `pos + len' is too far after the end of the buffer");
    abort();
  }

  if(dlen >= len)
    strbuf_grow(sb, dlen - len);

  memmove((void *)(sb->buf + (signed long int)pos + (signed long int)dlen), (const void *)(sb->buf + (signed long int)pos + (signed long int)len), (sb->len - pos) - len);
  memcpy((void *)(sb->buf + (signed long int)pos), data, dlen);
  strbuf_setlen(sb, (sb->len + dlen) - len);
}

// strbuf_stripout
// file strbuf.c line 201
signed int strbuf_stripout(struct strbuf *sb, void *buf, unsigned long int len)
{
  unsigned long int tmp_statement_expression_1;
  unsigned long int _x = len;
  unsigned long int _y = sb->len;
  (void)(&_x == &_y);
  tmp_statement_expression_1 = _x < _y ? _x : _y;
  len = tmp_statement_expression_1;
  if(!(len == 0ul))
  {
    memcpy(buf, (const void *)sb->buf, len);
    strbuf_remove(sb, (unsigned long int)0, len);
  }


out:
  ;
  return (signed int)len;
}

// timer_handler
// file event.c line 25
static void timer_handler(signed int fd, signed int events, void *data)
{
  struct timer *t = (struct timer *)data;
  unsigned long int val;
  signed long int return_value_read_1;
  return_value_read_1=read(fd, (void *)&val, sizeof(unsigned long int) /*8ul*/ );
  if(return_value_read_1 >= 0l)
  {
    t->callback(t->data);
    unregister_event(fd);
    close(fd);
  }

}

// tkill
// file util.c line 482
signed int tkill(signed int tid, signed int sig)
{
  signed int return_value_getpid_1;
  return_value_getpid_1=getpid();
  signed long int return_value_syscall_2;
  return_value_syscall_2=syscall((signed long int)234, return_value_getpid_1, tid, sig);
  return (signed int)return_value_syscall_2;
}

// trace_clear_tid_map
// file work.c line 190
static inline void trace_clear_tid_map(signed int tid)
{
  ;
}

// trace_set_tid_map
// file work.c line 189
static inline void trace_set_tid_map(signed int tid)
{
  ;
}

// transfer_to_idx_root
// file sd_inode.c line 355
static void transfer_to_idx_root(signed int (*writer)(unsigned long int, void *, unsigned int, unsigned long int, unsigned int, signed int, signed int, _Bool, _Bool), struct sd_inode *inode)
{
  struct sd_extent_header *left;
  struct sd_extent_header *right;
  struct sd_extent_header *root = (struct sd_extent_header *)inode->data_vdi_id;
  unsigned long int left_oid;
  unsigned long int right_oid;
  unsigned int num = root->entries / (unsigned int)2;
  void *return_value_xvalloc_1;
  return_value_xvalloc_1=xvalloc(sizeof(unsigned int) /*4ul*/  * (1ULL << 20));
  left = (struct sd_extent_header *)return_value_xvalloc_1;
  void *return_value_xvalloc_2;
  return_value_xvalloc_2=xvalloc(sizeof(unsigned int) /*4ul*/  * (1ULL << 20));
  right = (struct sd_extent_header *)return_value_xvalloc_2;
  split_to_nodes(root, left, right, (signed int)num);
  unsigned int tmp_post_3 = inode->btree_counter;
  inode->btree_counter = inode->btree_counter + 1u;
  left_oid=vid_to_btree_oid(inode->vdi_id, tmp_post_3);
  unsigned int tmp_post_4 = inode->btree_counter;
  inode->btree_counter = inode->btree_counter + 1u;
  right_oid=vid_to_btree_oid(inode->vdi_id, tmp_post_4);
  writer(left_oid, (void *)left, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0, (unsigned int)0, (signed int)inode->nr_copies, (signed int)inode->copy_policy, (_Bool)1, (_Bool)0);
  writer(right_oid, (void *)right, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0, (unsigned int)0, (signed int)inode->nr_copies, (signed int)inode->copy_policy, (_Bool)1, (_Bool)0);
  root->entries = (unsigned int)0;
  root->depth = (unsigned short int)2;
  insert_idx_entry(root, (((struct sd_extent *)((char *)left + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)left)->entries) - (signed long int)1)->idx, left_oid);
  insert_idx_entry(root, (((struct sd_extent *)((char *)right + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)right)->entries) - (signed long int)1)->idx, right_oid);
  free((void *)left);
  free((void *)right);
}

// traverse_btree
// file sd_inode.c line 139
extern void traverse_btree(signed int (*reader)(unsigned long int, void **, unsigned int, unsigned long int), struct sd_inode *inode, void (*fn)(void *, enum btree_node_type, void *), void *arg)
{
  struct sd_extent_header *header = (struct sd_extent_header *)inode->data_vdi_id;
  struct sd_extent_header *leaf_node = (struct sd_extent_header *)(void *)0;
  struct sd_extent *last;
  struct sd_extent *iter;
  struct sd_extent_idx *last_idx;
  struct sd_extent_idx *iter_idx;
  void *tmp;
  fn((void *)header, (enum btree_node_type)BTREE_HEAD, arg);
  if((signed int)header->depth == 1)
  {
    last = (struct sd_extent *)((char *)inode->data_vdi_id + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)inode->data_vdi_id)->entries;
    iter = (struct sd_extent *)((char *)inode->data_vdi_id + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ );
    if(!(iter == last))
    {
      fn((void *)iter, (enum btree_node_type)BTREE_EXT, arg);
      iter = iter + 1l;
    }

  }

  else
    if((signed int)header->depth == 2)
    {
      last_idx = (struct sd_extent_idx *)((char *)inode->data_vdi_id + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)inode->data_vdi_id)->entries;
      iter_idx = (struct sd_extent_idx *)((char *)inode->data_vdi_id + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ );
      void *return_value_xvalloc_1;
      return_value_xvalloc_1=xvalloc(sizeof(unsigned int) /*4ul*/  * (1ULL << 20));
      leaf_node = (struct sd_extent_header *)return_value_xvalloc_1;
      tmp = (void *)leaf_node;
      if(!(iter_idx == last_idx))
      {
        reader(iter_idx->oid, &tmp, (unsigned int)(sizeof(unsigned int) /*4ul*/  * (1ULL << 20)), (unsigned long int)0);
        fn((void *)iter_idx, (enum btree_node_type)BTREE_IDX, arg);
        fn((void *)leaf_node, (enum btree_node_type)BTREE_HEAD, arg);
        last = (struct sd_extent *)((char *)leaf_node + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ ) + (signed long int)((struct sd_extent_header *)leaf_node)->entries;
        iter = (struct sd_extent *)((char *)leaf_node + (signed long int)sizeof(struct sd_extent_header) /*8ul*/ );
        if(!(iter == last))
        {
          fn((void *)iter, (enum btree_node_type)BTREE_EXT, arg);
          iter = iter + 1l;
        }

        iter_idx = iter_idx + 1l;
      }

      free((void *)leaf_node);
    }

    else
    {
      log_write(0, "traverse_btree", 180, "PANIC: This B-tree not support depth %u", header->depth);
      abort();
    }
}

// uatomic_is_true
// file ../include/util.h line 206
static inline _Bool uatomic_is_true(struct anonymous_29 *val)
{
  volatile unsigned long int tmp_statement_expression_1;
  asm("" :  :  : "memory");
  tmp_statement_expression_1 = *((volatile unsigned long int *)&(*(&val->val)));
  return tmp_statement_expression_1 == (unsigned long int)1;
}

// uatomic_set_false
// file ../include/util.h line 217
static inline void uatomic_set_false(struct anonymous_29 *val)
{
  unsigned long int _v;
  volatile unsigned long int tmp_statement_expression_1;
  *((volatile unsigned long int *)&(*(&val->val))) = (volatile unsigned long int)0;
  tmp_statement_expression_1 = *((volatile unsigned long int *)&(*(&val->val)));
  _v = tmp_statement_expression_1;
  asm("" :  :  : "memory");
  _v = _v;
}

// uatomic_set_true
// file ../include/util.h line 212
static inline _Bool uatomic_set_true(struct anonymous_29 *val)
{
  unsigned long int return_value___uatomic_cmpxchg_1;
  return_value___uatomic_cmpxchg_1=__uatomic_cmpxchg((void *)&val->val, (unsigned long int)0, (unsigned long int)1, (signed int)sizeof(unsigned long int) /*8ul*/ );
  return (unsigned long int)return_value___uatomic_cmpxchg_1 == (unsigned long int)0;
}

// unblock_sighup
// file logger.c line 143
static void unblock_sighup(void)
{
  signed int ret;
  struct anonymous_0 new;
  struct anonymous_0 old;
  sigemptyset(&new);
  sigemptyset(&old);
  sigaddset(&new, 1);
  ret=sigprocmask(1, &new, &old);
  if(!(ret >= 0))
    syslog(3, "unblock SIGHUP failed\n");

}

// unregister_event
// file ../include/event.h line 13
void unregister_event(signed int fd)
{
  signed int ret;
  struct event_info *ei;
  ei=lookup_event(fd);
  if(!(ei == ((struct event_info *)NULL)))
  {
    ret=epoll_ctl(efd, 2, fd, (struct epoll_event *)(void *)0);
    if(!(ret == 0))
      log_write(3, "unregister_event", 136, "failed to delete epoll event for fd %d: %m", fd);

    rb_erase(&ei->rb, &events_tree);
    free((void *)ei);
    event_force_refresh();
  }

}

// usage
// file shepherd.c line 610
static void usage(void)
{
  struct sd_option *opt;
  printf("shepherd daemon:\nusage: %s <option>...\noptions:\n", progname);
  opt = shepherd_options;
  for( ; !(opt->name == ((const char *)NULL)); opt = opt + 1l)
    printf("  -%c, --%-18s%s\n", opt->ch, opt->name, opt->desc);
}

// vid_to_btree_oid
// file ../include/sheepdog_proto.h line 455
static inline unsigned long int vid_to_btree_oid(unsigned int vid, unsigned int btreeid)
{
  return (unsigned long int)vid << 32 | 1UL << 60 | (unsigned long int)btreeid;
}

// vid_to_vdi_oid
// file ../include/sheepdog_proto.h line 435
static inline unsigned long int vid_to_vdi_oid(unsigned int vid)
{
  return 1UL << 63 | (unsigned long int)vid << 32;
}

// work_queue_empty
// file work.c line 445
_Bool work_queue_empty(struct work_queue *q)
{
  struct wq_info *wi;
  struct wq_info *tmp_statement_expression_1;
  const struct work_queue *__mptr = q;
  tmp_statement_expression_1 = (struct wq_info *)((char *)__mptr - (signed long int)208ul);
  wi = tmp_statement_expression_1;
  volatile unsigned long int tmp_statement_expression_2;
  asm("" :  :  : "memory");
  tmp_statement_expression_2 = *((volatile unsigned long int *)&(*(&wi->nr_queued_work)));
  return tmp_statement_expression_2 == (unsigned long int)0;
}

// worker_routine
// file work.c line 313
static void * worker_routine(void *arg)
{
  struct wq_info *wi = (struct wq_info *)arg;
  struct work *work;
  signed int tid;
  tid=gettid();
  set_thread_name(wi->name, (signed int)wi->tc != WQ_ORDERED);
  sd_mutex_lock(&wi->startup_lock);
  sd_mutex_unlock(&wi->startup_lock);
  trace_set_tid_map(tid);
  _Bool return_value_list_empty_3;
  struct work *tmp_statement_expression_4;
  while((_Bool)1)
  {
    sd_mutex_lock(&wi->pending_lock);
    _Bool return_value_wq_need_shrink_2;
    return_value_wq_need_shrink_2=wq_need_shrink(wi);
    if(!(return_value_wq_need_shrink_2 == (_Bool)0))
    {
      wi->nr_threads = wi->nr_threads - 1ul;
      trace_clear_tid_map(tid);
      sd_mutex_unlock(&wi->pending_lock);
      unsigned long int return_value_pthread_self_1;
      return_value_pthread_self_1=pthread_self();
      pthread_detach(return_value_pthread_self_1);
      if(sd_log_level == 7)
        log_write(7, "worker_routine", 336, "destroy thread %s %d, %zu", wi->name, tid, wi->nr_threads);

      break;
    }

    do
    {

    retest:
      ;
      return_value_list_empty_3=list_empty_link2(&wi->q.pending_list);
      if(return_value_list_empty_3 == (_Bool)0)
        break;

      sd_cond_wait(&wi->pending_cond, &wi->pending_lock);
    }
    while((_Bool)1);
    const struct list_node *__mptr = (&wi->q.pending_list)->n.next;
    tmp_statement_expression_4 = (struct work *)((char *)__mptr - (signed long int)0ul);
    work = tmp_statement_expression_4;
    list_del_link1(&work->w_list);
    sd_mutex_unlock(&wi->pending_lock);
    if(!(work->fn == ((void (*)(struct work *))NULL)))
      work->fn(work);

    sd_mutex_lock(&wi->finished_lock);
    list_add_tail_link1(&work->w_list, &wi->finished_list);
    sd_mutex_unlock(&wi->finished_lock);
    eventfd_xwrite(efd_link1, 1);
  }
  pthread_exit((void *)0);
}

// worker_thread_request_done
// file work.c line 287
static void worker_thread_request_done(signed int fd, signed int events, void *data)
{
  struct wq_info *wi;
  struct work *work;
  struct list_head list = { .n={ .next=&list.n, .prev=&list.n } };
  if(!(wq_get_nr_nodes == ((unsigned long int (*)(void))NULL)))
    nr_nodes=wq_get_nr_nodes();

  eventfd_xread(fd);
  struct wq_info *__n298;
  struct wq_info *tmp_statement_expression_1;
  const struct list_node *__mptr = (&wq_info_list)->n.next;
  tmp_statement_expression_1 = (struct wq_info *)((char *)__mptr - (signed long int)24ul);
  wi = tmp_statement_expression_1;
  struct wq_info *tmp_statement_expression_2;
  const struct list_node *worker_thread_request_done__1__1__2____mptr = wi->list.next;
  tmp_statement_expression_2 = (struct wq_info *)((char *)worker_thread_request_done__1__1__2____mptr - (signed long int)24ul);
  __n298 = tmp_statement_expression_2;
  struct work *tmp_statement_expression_5;
  struct wq_info *tmp_statement_expression_3;
  for( ; !(&wi->list == &(&wq_info_list)->n); __n298 = tmp_statement_expression_3)
  {
    sd_mutex_lock(&wi->finished_lock);
    list_splice_init(&wi->finished_list, &list);
    sd_mutex_unlock(&wi->finished_lock);
    _Bool return_value_list_empty_4;
    return_value_list_empty_4=list_empty_link2(&list);
    if(return_value_list_empty_4 == (_Bool)0)
    {
      const struct list_node *worker_thread_request_done__1__1__4__1__1____mptr = (&list)->n.next;
      tmp_statement_expression_5 = (struct work *)((char *)worker_thread_request_done__1__1__4__1__1____mptr - (signed long int)0ul);
      work = tmp_statement_expression_5;
      list_del_link1(&work->w_list);
      work->done(work);
      __uatomic_dec((void *)&wi->nr_queued_work, (signed int)sizeof(unsigned long int) /*8ul*/ );
    }

    wi = __n298;
    const struct list_node *worker_thread_request_done__1__1__3____mptr = __n298->list.next;
    tmp_statement_expression_3 = (struct wq_info *)((char *)worker_thread_request_done__1__1__3____mptr - (signed long int)24ul);
  }
}

// wq_get_roof
// file work.c line 202
static inline unsigned long int wq_get_roof(struct wq_info *wi)
{
  unsigned long int nr = (unsigned long int)1;
  switch((signed int)wi->tc)
  {
    case WQ_ORDERED:
      break;
    case WQ_DYNAMIC:
    {
      nr = nr_nodes * (unsigned long int)2;
      break;
    }
    case WQ_UNLIMITED:
    {
      nr = 18446744073709551615UL;
      break;
    }
    default:
    {
      log_write(0, "wq_get_roof", 217, "PANIC: Invalid threads control %d", wi->tc);
      abort();
    }
  }
  return nr;
}

// wq_need_grow
// file work.c line 222
static _Bool wq_need_grow(struct wq_info *wi)
{
  volatile unsigned long int tmp_statement_expression_3;
  asm("" :  :  : "memory");
  tmp_statement_expression_3 = *((volatile unsigned long int *)&(*(&wi->nr_queued_work)));
  unsigned long int return_value_wq_get_roof_2;
  if(!(wi->nr_threads >= tmp_statement_expression_3))
  {
    return_value_wq_get_roof_2=wq_get_roof(wi);
    if(return_value_wq_get_roof_2 >= 2ul * wi->nr_threads)
    {
      unsigned long int return_value_get_msec_time_1;
      return_value_get_msec_time_1=get_msec_time();
      wi->tm_end_of_protection = return_value_get_msec_time_1 + (unsigned long int)1000;
      return (_Bool)1;
    }

  }

  return (_Bool)0;
}

// wq_need_shrink
// file work.c line 238
static _Bool wq_need_shrink(struct wq_info *wi)
{
  volatile unsigned long int tmp_statement_expression_2;
  asm("" :  :  : "memory");
  tmp_statement_expression_2 = *((volatile unsigned long int *)&(*(&wi->nr_queued_work)));
  unsigned long int return_value_get_msec_time_1;
  if(!(tmp_statement_expression_2 >= wi->nr_threads / 2ul))
  {
    return_value_get_msec_time_1=get_msec_time();
    return wi->tm_end_of_protection <= return_value_get_msec_time_1;
  }

  else
  {
    unsigned long int return_value_get_msec_time_3;
    return_value_get_msec_time_3=get_msec_time();
    wi->tm_end_of_protection = return_value_get_msec_time_3 + (unsigned long int)1000;
    return (_Bool)0;
  }
}

// wq_trace_init
// file work.c line 188
static inline signed int wq_trace_init(void)
{
  return 0;
}

// xcalloc
// file ../include/util.h line 94
void * xcalloc(unsigned long int nmemb, unsigned long int size)
{
  void *ret;
  ret=calloc(nmemb, size);
  if(ret == NULL && (nmemb == 0ul || size == 0ul))
    ret=calloc((unsigned long int)1, (unsigned long int)1);

  if(ret == NULL)
  {
    try_to_free_routine(nmemb * size);
    ret=calloc(nmemb, size);
    if(ret == NULL && (nmemb == 0ul || size == 0ul))
      ret=calloc((unsigned long int)1, (unsigned long int)1);

    if(ret == NULL)
    {
      log_write(0, "xcalloc", 91, "PANIC: Out of memory");
      abort();
    }

  }

  return ret;
}

// xfallocate
// file util.c line 252
signed int xfallocate(signed int fd, signed int mode, signed long int offset, signed long int len)
{
  signed int ret;
  _Bool tmp_if_expr_4;
  signed int *return_value___errno_location_1;
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  do
  {
    ret=fallocate(fd, mode, offset, len);
    if(!(ret >= 0))
    {
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 11)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value___errno_location_2=__errno_location();
        tmp_if_expr_3 = *return_value___errno_location_2 == 4 ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
  }
  while(tmp_if_expr_4);
  return ret;
}

// xftruncate
// file util.c line 263
signed int xftruncate(signed int fd, signed long int length)
{
  signed int ret;
  _Bool tmp_if_expr_4;
  signed int *return_value___errno_location_1;
  _Bool tmp_if_expr_3;
  signed int *return_value___errno_location_2;
  do
  {
    ret=ftruncate(fd, length);
    if(!(ret >= 0))
    {
      return_value___errno_location_1=__errno_location();
      if(*return_value___errno_location_1 == 11)
        tmp_if_expr_3 = (_Bool)1;

      else
      {
        return_value___errno_location_2=__errno_location();
        tmp_if_expr_3 = *return_value___errno_location_2 == 4 ? (_Bool)1 : (_Bool)0;
      }
      tmp_if_expr_4 = tmp_if_expr_3 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
  }
  while(tmp_if_expr_4);
  return ret;
}

// xmalloc
// file util.c line 43
void * xmalloc(unsigned long int size)
{
  void *ret;
  ret=malloc(size);
  if(ret == NULL && size == 0ul)
    ret=malloc((unsigned long int)1);

  if(ret == NULL)
  {
    try_to_free_routine(size);
    ret=malloc(size);
    if(ret == NULL && size == 0ul)
      ret=malloc((unsigned long int)1);

    if(ret == NULL)
    {
      log_write(0, "xmalloc", 54, "PANIC: Out of memory");
      abort();
    }

  }

  return ret;
}

// xmkdir
// file util.c line 233
signed int xmkdir(const char *pathname, unsigned int mode)
{
  signed int return_value_mkdir_4;
  return_value_mkdir_4=mkdir(pathname, mode);
  if(!(return_value_mkdir_4 >= 0))
  {
    struct stat st;
    signed int *return_value___errno_location_1;
    return_value___errno_location_1=__errno_location();
    if(!(*return_value___errno_location_1 == 17))
      return -1;

    signed int return_value_stat_2;
    return_value_stat_2=stat(pathname, &st);
    if(!(return_value_stat_2 >= 0))
      return -1;

    if(!((61440u & st.st_mode) == 16384u))
    {
      signed int *return_value___errno_location_3;
      return_value___errno_location_3=__errno_location();
      *return_value___errno_location_3 = 17;
      return -1;
    }

  }

  return 0;
}

// xpread
// file util.c line 190
signed long int xpread(signed int fd, void *buf, unsigned long int count, signed long int offset)
{
  char *p = (char *)buf;
  signed long int total = (signed long int)0;
  while(count >= 1ul)
  {
    signed long int loaded;
    loaded=_pread(fd, (void *)p, count, offset);
    if(!(loaded >= 0l))
      return (signed long int)-1;

    if(loaded == 0l)
      return total;

    count = count - (unsigned long int)loaded;
    p = p + loaded;
    total = total + loaded;
    offset = offset + loaded;
  }
  return total;
}

// xpwrite
// file util.c line 210
signed long int xpwrite(signed int fd, const void *buf, unsigned long int count, signed long int offset)
{
  const char *p = (const char *)buf;
  signed long int total = (signed long int)0;
  while(count >= 1ul)
  {
    signed long int written;
    written=_pwrite(fd, (const void *)p, count, offset);
    if(!(written >= 0l))
      return (signed long int)-1;

    if(written == 0l)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = 28;
      return (signed long int)-1;
    }

    count = count - (unsigned long int)written;
    p = p + written;
    total = total + written;
    offset = offset + written;
  }
  return total;
}

// xread
// file ../include/util.h line 96
signed long int xread(signed int fd, void *buf, unsigned long int count)
{
  char *p = (char *)buf;
  signed long int total = (signed long int)0;
  while(count >= 1ul)
  {
    signed long int loaded;
    loaded=_read(fd, (void *)p, count);
    if(!(loaded >= 0l))
      return (signed long int)-1;

    if(loaded == 0l)
      return total;

    count = count - (unsigned long int)loaded;
    p = p + loaded;
    total = total + loaded;
  }
  return total;
}

// xrealloc
// file util.c line 64
void * xrealloc(void *ptr, unsigned long int size)
{
  void *ret;
  ret=realloc(ptr, size);
  if(ret == NULL && size == 0ul)
    ret=realloc(ptr, (unsigned long int)1);

  if(ret == NULL)
  {
    try_to_free_routine(size);
    ret=realloc(ptr, size);
    if(ret == NULL && size == 0ul)
      ret=realloc(ptr, (unsigned long int)1);

    if(ret == NULL)
    {
      log_write(0, "xrealloc", 75, "PANIC: Out of memory");
      abort();
    }

  }

  return ret;
}

// xvalloc
// file util.c line 97
void * xvalloc(unsigned long int size)
{
  void *ret;
  ret=valloc(size);
  if(ret == NULL)
  {
    log_write(0, "xvalloc", 101, "PANIC: Out of memory");
    abort();
  }

  memset(ret, 0, size);
  return ret;
}

// xwrite
// file ../include/util.h line 97
signed long int xwrite(signed int fd, const void *buf, unsigned long int count)
{
  const char *p = (const char *)buf;
  signed long int total = (signed long int)0;
  while(count >= 1ul)
  {
    signed long int written;
    written=_write(fd, (const void *)p, count);
    if(!(written >= 0l))
      return (signed long int)-1;

    if(written == 0l)
    {
      signed int *return_value___errno_location_1;
      return_value___errno_location_1=__errno_location();
      *return_value___errno_location_1 = 28;
      return (signed long int)-1;
    }

    count = count - (unsigned long int)written;
    p = p + written;
    total = total + written;
  }
  return total;
}

// xzalloc
// file ../include/util.h line 92
void * xzalloc(unsigned long int size)
{
  void *return_value_xcalloc_1;
  return_value_xcalloc_1=xcalloc((unsigned long int)1, size);
  return return_value_xcalloc_1;
}

