// #anon_enum_JU_ERRNO_NONE=0_JU_ERRNO_FULL=1_JU_ERRNO_NFMAX=1_JU_ERRNO_NOMEM=2_JU_ERRNO_NULLPPARRAY=3_JU_ERRNO_NONNULLPARRAY=10_JU_ERRNO_NULLPINDEX=4_JU_ERRNO_NULLPVALUE=11_JU_ERRNO_NOTJUDY1=5_JU_ERRNO_NOTJUDYL=6_JU_ERRNO_NOTJUDYSL=7_JU_ERRNO_UNSORTED=12_JU_ERRNO_OVERRUN=8_JU_ERRNO_CORRUPT=9
// file /usr/include/Judy.h line 110
enum anonymous { JU_ERRNO_NONE=0, JU_ERRNO_FULL=1, JU_ERRNO_NFMAX=1, JU_ERRNO_NOMEM=2, JU_ERRNO_NULLPPARRAY=3, JU_ERRNO_NONNULLPARRAY=10, JU_ERRNO_NULLPINDEX=4, JU_ERRNO_NULLPVALUE=11, JU_ERRNO_NOTJUDY1=5, JU_ERRNO_NOTJUDYL=6, JU_ERRNO_NOTJUDYSL=7, JU_ERRNO_UNSORTED=12, JU_ERRNO_OVERRUN=8, JU_ERRNO_CORRUPT=9 };

// tag-#anon#ST[*{V(SYM#tag-sigval#)->V}_V(SYM#tag-sigval#)->V_'_function'||*{SYM#tag-pthread_attr_t#}_SYM#tag-pthread_attr_t#_'_attribute'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 327
struct anonymous_1;

// tag-#anon#ST[ARR1{SYM#tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]#}_SYM#tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]#_'__cancel_jmp_buf'||ARR4{*{V}_V_}_*{V}_V__'__pad'|]
// file /usr/include/pthread.h line 525
struct anonymous_16;

// tag-#anon#ST[ARR8{S64}_S64_'__cancel_jmp_buf'||S32'__mask_was_saved'||U32'_pad0'|]
// file /usr/include/pthread.h line 527
struct anonymous_15;

// tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 141
struct anonymous_12;

// tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}_U8_'__pad1'||U64'__pad2'||U32'__flags'||U32'_pad0'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 177
struct anonymous_14;

// tag-#anon#ST[SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'lock'||S32'count'||U32'_pad0'||U64'last'|]
// file relay.c line 79
struct anonymous_7;

// tag-#anon#ST[SYM#tag-teredo_state#'state'||*{V(*{SYM#tag-teredo_state#}_SYM#tag-teredo_state#_|*{V}_V_)->V}_V(*{SYM#tag-teredo_state#}_SYM#tag-teredo_state#_|*{V}_V_)->V_'cb'||*{V}_V_'opaque'|]
// file maintain.c line 87
struct anonymous_4;

// tag-#anon#ST[U32'prefix'||U32'server_ip'||U16'flags'||U16'client_port'||U32'client_ip'|]
// file teredo.h line 53
struct anonymous_10;

// tag-#anon#ST[U64'thread'||B'running'||U56'_pad0'|]
// file relay.c line 87
struct anonymous_8;

// tag-#anon#UN[ARR12{S32}_S32_'_pad'||S32'_tid'||SYM#tag-#anon#ST[*{V(SYM#tag-sigval#)->V}_V(SYM#tag-sigval#)->V_'_function'||*{SYM#tag-pthread_attr_t#}_SYM#tag-pthread_attr_t#_'_attribute'|]#'_sigev_thread'|]
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 319
union anonymous_2;

// tag-#anon#UN[ARR16{U8}_U8_'__u6_addr8'||ARR8{U16}_U16_'__u6_addr16'||ARR4{U32}_U32_'__u6_addr32'|]
// file /usr/include/netinet/in.h line 211
union anonymous_25;

// tag-#anon#UN[ARR16{U8}_U8_'key'||ARR64{U8}_U8_'ipad'|]
// file security.c line 57
union anonymous_22;

// tag-#anon#UN[ARR16{U8}_U8_'key'||ARR64{U8}_U8_'opad'|]
// file security.c line 63
union anonymous_23;

// tag-#anon#UN[ARR1{U32}_U32_'icmp6_un_data32'||ARR2{U16}_U16_'icmp6_un_data16'||ARR4{U8}_U8_'icmp6_un_data8'|]
// file /usr/include/netinet/icmp6.h line 43
union anonymous_27;

// tag-#anon#UN[ARR1{U64}_U64_'align'||ARR65507{U8}_U8_'fill'||U524096'_pad'|]
// file ../libteredo/teredo-udp.h line 71
union anonymous_18;

// tag-#anon#UN[ARR4{S8}_S8_'__size'||S32'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 130
union anonymous_3;

// tag-#anon#UN[ARR8{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 224
union anonymous_19;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}_V_'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR48{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 139
union anonymous_13;

// tag-#anon#UN[SYM#tag-#anon#ST[S32'__lock'||U32'__nr_readers'||U32'__readers_wakeup'||U32'__writer_wakeup'||U32'__nr_readers_queued'||U32'__nr_writers_queued'||S32'__writer'||S32'__shared'||S8'__rwelision'||ARR7{U8}_U8_'__pad1'||U64'__pad2'||U32'__flags'||U32'_pad0'|]#'__data'||ARR56{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 174
union anonymous_6;

// tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union anonymous_24;

// tag-#anon#UN[SYM#tag-ip6_hdrctl#'ip6_un1'||U8'ip6_un2_vfc'|]
// file /usr/include/netinet/ip6.h line 26
union anonymous_17;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_11;

// tag-#anon#UN[r*{SYM#tag-sockaddr#}_SYM#tag-sockaddr#_'__sockaddr__'||r*{SYM#tag-sockaddr_at#}_SYM#tag-sockaddr_at#_'__sockaddr_at__'||r*{SYM#tag-sockaddr_ax25#}_SYM#tag-sockaddr_ax25#_'__sockaddr_ax25__'||r*{SYM#tag-sockaddr_dl#}_SYM#tag-sockaddr_dl#_'__sockaddr_dl__'||r*{SYM#tag-sockaddr_eon#}_SYM#tag-sockaddr_eon#_'__sockaddr_eon__'||r*{SYM#tag-sockaddr_in#}_SYM#tag-sockaddr_in#_'__sockaddr_in__'||r*{SYM#tag-sockaddr_in6#}_SYM#tag-sockaddr_in6#_'__sockaddr_in6__'||r*{SYM#tag-sockaddr_inarp#}_SYM#tag-sockaddr_inarp#_'__sockaddr_inarp__'||r*{SYM#tag-sockaddr_ipx#}_SYM#tag-sockaddr_ipx#_'__sockaddr_ipx__'||r*{SYM#tag-sockaddr_iso#}_SYM#tag-sockaddr_iso#_'__sockaddr_iso__'||r*{SYM#tag-sockaddr_ns#}_SYM#tag-sockaddr_ns#_'__sockaddr_ns__'||r*{SYM#tag-sockaddr_un#}_SYM#tag-sockaddr_un#_'__sockaddr_un__'||r*{SYM#tag-sockaddr_x25#}_SYM#tag-sockaddr_x25#_'__sockaddr_x25__'|]_transparent
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
union anonymous_9;

// tag-J_UDY_ERROR_STRUCT
// file /usr/include/Judy.h line 181
struct J_UDY_ERROR_STRUCT;

// tag-_IO_FILE
// file /usr/include/stdio.h line 44
struct _IO_FILE;

// tag-_IO_marker
// file /usr/include/libio.h line 160
struct _IO_marker;

// tag-__jmp_buf_tag
// file /usr/include/pthread.h line 744
struct __jmp_buf_tag;

// tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// tag-__rlimit_resource
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 31
enum __rlimit_resource { RLIMIT_CPU=0, RLIMIT_FSIZE=1, RLIMIT_DATA=2, RLIMIT_STACK=3, RLIMIT_CORE=4, __RLIMIT_RSS=5, RLIMIT_NOFILE=7, __RLIMIT_OFILE=7, RLIMIT_AS=9, __RLIMIT_NPROC=6, __RLIMIT_MEMLOCK=8, __RLIMIT_LOCKS=10, __RLIMIT_SIGPENDING=11, __RLIMIT_MSGQUEUE=12, __RLIMIT_NICE=13, __RLIMIT_RTPRIO=14, __RLIMIT_RTTIME=15, __RLIMIT_NLIMITS=16, __RLIM_NLIMITS=16 };

// tag-addrinfo
// file /usr/include/netdb.h line 567
struct addrinfo;

// tag-clock_data_t
// file clock.c line 41
struct clock_data_t;

// tag-cmsghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 242
struct cmsghdr;

// tag-icmp6_hdr
// file /usr/include/netinet/icmp6.h line 38
struct icmp6_hdr;

// tag-in6_addr
// file /usr/include/netinet/in.h line 209
struct in6_addr;

// tag-in_addr
// file /usr/include/netinet/in.h line 31
struct in_addr;

// tag-in_pktinfo
// file /usr/include/x86_64-linux-gnu/bits/in.h line 153
struct in_pktinfo;

// tag-iovec
// file /usr/include/x86_64-linux-gnu/bits/uio.h line 43
struct iovec;

// tag-ip6_hdr
// file /usr/include/netinet/ip6.h line 24
struct ip6_hdr;

// tag-ip6_hdrctl
// file /usr/include/netinet/ip6.h line 28
struct ip6_hdrctl;

// tag-itimerspec
// file /usr/include/time.h line 161
struct itimerspec;

// tag-md5_state_s
// file md5.h line 67
struct md5_state_s;

// tag-msghdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 224
struct msghdr;

// tag-nd_opt_hdr
// file /usr/include/netinet/icmp6.h line 186
struct nd_opt_hdr;

// tag-nd_opt_mtu
// file /usr/include/netinet/icmp6.h line 226
struct nd_opt_mtu;

// tag-nd_opt_prefix_info
// file /usr/include/netinet/icmp6.h line 201
struct nd_opt_prefix_info;

// tag-nd_router_advert
// file /usr/include/netinet/icmp6.h line 122
struct nd_router_advert;

// tag-nd_router_solicit
// file /usr/include/netinet/icmp6.h line 111
struct nd_router_solicit;

// tag-option
// file /usr/include/getopt.h line 104
struct option;

// tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// tag-rlimit
// file /usr/include/x86_64-linux-gnu/bits/resource.h line 139
struct rlimit;

// tag-sigevent
// file /usr/include/time.h line 168
struct sigevent;

// tag-sigval
// file /usr/include/x86_64-linux-gnu/bits/siginfo.h line 32
union sigval;

// tag-sockaddr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 149
struct sockaddr;

// tag-sockaddr_at
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_at;

// tag-sockaddr_ax25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ax25;

// tag-sockaddr_dl
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_dl;

// tag-sockaddr_eon
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_eon;

// tag-sockaddr_in
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in;

// tag-sockaddr_in6
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_in6;

// tag-sockaddr_inarp
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_inarp;

// tag-sockaddr_ipx
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ipx;

// tag-sockaddr_iso
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_iso;

// tag-sockaddr_ns
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_ns;

// tag-sockaddr_un
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_un;

// tag-sockaddr_x25
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 90
struct sockaddr_x25;

// tag-teredo_addr
// file teredo.h line 50
union teredo_addr;

// tag-teredo_listitem
// file peerlist.c line 159
struct teredo_listitem;

// tag-teredo_maintenance
// file maintain.h line 52
struct teredo_maintenance;

// tag-teredo_packet
// file ../libteredo/teredo-udp.h line 41
struct teredo_packet;

// tag-teredo_peer
// file peerlist.h line 31
struct teredo_peer;

// tag-teredo_peerlist
// file peerlist.h line 89
struct teredo_peerlist;

// tag-teredo_queue
// file peerlist.h line 29
struct teredo_queue;

// tag-teredo_state
// file maintain.h line 30
struct teredo_state;

// tag-teredo_tunnel
// file tunnel.h line 83
struct teredo_tunnel;

// tag-timespec
// file /usr/include/time.h line 120
struct timespec;

#ifndef NULL
#define NULL ((void*)0)
#endif

// BuildICMPv6Error
// file packets.h line 145
signed int BuildICMPv6Error(struct icmp6_hdr * restrict out, unsigned char type, unsigned char code, struct ip6_hdr * restrict in, unsigned long int inlen);
// CheckBubble
// file packets.h line 41
signed int CheckBubble(const struct teredo_packet *packet);
// CheckPing
// file packets.h line 40
signed int CheckPing(const struct teredo_packet *packet);
// CountBubble
// file relay.c line 257
static signed int CountBubble(struct teredo_peer *peer, unsigned long int now);
// CountPing
// file relay.c line 220
static signed int CountPing(struct teredo_peer *peer, unsigned long int now);
// IsBubble
// file packets.h line 48
static inline _Bool IsBubble(struct ip6_hdr *hdr);
// IsClient
// file relay.c line 246
static inline _Bool IsClient(const struct teredo_tunnel *tunnel);
// IsValid
// file peerlist.h line 83
static inline _Bool IsValid(const struct teredo_peer *peer, unsigned long int now);
// JudyHSDel
// file /usr/include/Judy.h line 288
extern signed int JudyHSDel(void **, void *, unsigned long int, struct J_UDY_ERROR_STRUCT *);
// JudyHSFreeArray
// file /usr/include/Judy.h line 289
extern unsigned long int JudyHSFreeArray(void **, struct J_UDY_ERROR_STRUCT *);
// JudyHSGet
// file /usr/include/Judy.h line 286
extern void ** JudyHSGet(const void *, void *, unsigned long int);
// JudyHSIns
// file /usr/include/Judy.h line 287
extern void ** JudyHSIns(void **, void *, unsigned long int, struct J_UDY_ERROR_STRUCT *);
// SendBubbleFromDst
// file packets.h line 63
signed int SendBubbleFromDst(signed int fd, struct in6_addr *dst, _Bool indirect);
// SendPing
// file packets.h line 127
signed int SendPing(signed int fd, union teredo_addr *src, struct in6_addr *dst);
// SetMapping
// file peerlist.h line 65
static inline void SetMapping(struct teredo_peer *peer, unsigned int ip, unsigned short int port);
// SetMappingFromPacket
// file relay.c line 296
static inline void SetMappingFromPacket(struct teredo_peer *peer, struct teredo_packet *p);
// TouchReceive
// file peerlist.h line 71
static inline void TouchReceive(struct teredo_peer *peer, unsigned long int now);
// TouchTransmit
// file peerlist.h line 76
static inline void TouchTransmit(struct teredo_peer *peer, unsigned long int now);
// __cmsg_nxthdr
// file /usr/include/x86_64-linux-gnu/bits/socket.h line 272
extern struct cmsghdr * __cmsg_nxthdr(struct msghdr *, struct cmsghdr *);
// __errno_location
// file /usr/include/x86_64-linux-gnu/bits/errno.h line 50
extern signed int * __errno_location(void);
// __pthread_register_cancel
// file /usr/include/pthread.h line 682
extern void __pthread_register_cancel(struct anonymous_16 *);
// __pthread_unregister_cancel
// file /usr/include/pthread.h line 694
extern void __pthread_unregister_cancel(struct anonymous_16 *);
// __pthread_unwind_next
// file /usr/include/pthread.h line 735
extern void __pthread_unwind_next(struct anonymous_16 *);
// __sigsetjmp
// file /usr/include/pthread.h line 745
extern signed int __sigsetjmp(struct __jmp_buf_tag *, signed int);
// bind
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 123
extern signed int bind(signed int, struct sockaddr *, unsigned int);
// bindtextdomain
// file /usr/include/libintl.h line 86
extern char * bindtextdomain(const char *, const char *);
// checkTimeDrift
// file maintain.c line 200
static _Bool checkTimeDrift(struct timespec *ts);
// cleanup_unlock
// file maintain.c line 218
static void cleanup_unlock(void *o);
// client_thread
// file mire.c line 202
static signed int client_thread(signed int fd);
// clock_getres
// file /usr/include/time.h line 339
extern signed int clock_getres(signed int, struct timespec *);
// clock_gettime
// file /usr/include/time.h line 342
extern signed int clock_gettime(signed int, struct timespec *);
// clock_nanosleep
// file /usr/include/time.h line 353
extern signed int clock_nanosleep(signed int, signed int, struct timespec *, struct timespec *);
// clock_tick
// file clock.c line 49
static void clock_tick(union sigval val);
// close
// file /usr/include/unistd.h line 353
extern signed int close(signed int);
// closefrom
// file closefrom.c line 39
signed int closefrom(signed int fd);
// dgettext
// file /usr/include/libintl.h line 44
extern char * dgettext(const char *, const char *);
// do_maintenance
// file maintain.c line 403
static void * do_maintenance(void *opaque);
// exit
// file /usr/include/stdlib.h line 543
extern void exit(signed int);
// fcntl
// file /usr/include/fcntl.h line 137
extern signed int fcntl(signed int, signed int, ...);
// fprintf
// file /usr/include/stdio.h line 356
extern signed int fprintf(struct _IO_FILE *, const char *, ...);
// free
// file /usr/include/stdlib.h line 483
extern void free(void *);
// freeaddrinfo
// file /usr/include/netdb.h line 668
extern void freeaddrinfo(struct addrinfo *);
// gai_strerror
// file /usr/include/netdb.h line 671
extern const char * gai_strerror(signed int);
// garbage_collector
// file peerlist.c line 228
static void * garbage_collector(void *data);
// getaddrinfo
// file /usr/include/netdb.h line 662
extern signed int getaddrinfo(const char *, const char *, struct addrinfo *, struct addrinfo ** restrict );
// getipv4byname
// file maintain.c line 107
static signed int getipv4byname(const char * restrict name, unsigned int * restrict ipv4);
// getopt_long
// file /usr/include/getopt.h line 173
extern signed int getopt_long(signed int, char * const *, const char *, struct option *, signed int *);
// getpid
// file /usr/include/unistd.h line 628
extern signed int getpid(void);
// getrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 50
extern signed int getrlimit(enum __rlimit_resource, struct rlimit *);
// gettime
// file maintain.c line 60
static inline void gettime(struct timespec *now);
// htonl
// file /usr/include/netinet/in.h line 377
extern unsigned int htonl(unsigned int);
// htons
// file /usr/include/netinet/in.h line 379
extern unsigned short int htons(unsigned short int);
// icmp6_checksum
// file ../libteredo/checksum.h line 34
static inline unsigned short int icmp6_checksum(struct ip6_hdr *ip6, struct icmp6_hdr *icmp6);
// icmp6_checksum_link1
// file checksum.h line 34
static inline unsigned short int icmp6_checksum_link1(struct ip6_hdr *ip6_link1, struct icmp6_hdr *icmp6_link1);
// in6_matches_teredo_client
// file teredo.h line 95
static inline signed int in6_matches_teredo_client(struct in6_addr *ip6, unsigned int ip, unsigned short int port);
// in_cksum
// file teredo.c line 338
static unsigned short int in_cksum(struct iovec *iov, unsigned long int n);
// is_ipv4_global_unicast
// file v4global.h line 34
signed int is_ipv4_global_unicast(unsigned int ip);
// listitem_create
// file peerlist.c line 181
static inline struct teredo_listitem * listitem_create(void);
// listitem_destroy
// file peerlist.c line 190
static inline void listitem_destroy(struct teredo_listitem *entry);
// listitem_recdestroy
// file peerlist.c line 197
static void listitem_recdestroy(struct teredo_listitem *entry);
// maintenance_recv
// file maintain.c line 132
static signed int maintenance_recv(const struct teredo_packet * restrict packet, unsigned int server_ip, const unsigned char * restrict nonce, _Bool cone, struct teredo_state * restrict state);
// maintenance_thread
// file maintain.c line 242
static inline void maintenance_thread(struct teredo_maintenance *m);
// maintenance_thread::1::1::__cancel_routine_object
//
void __cancel_routine_object(void *);
// malloc
// file /usr/include/stdlib.h line 466
extern void * malloc(unsigned long int);
// md5_append
// file md5.h line 82
void md5_append(struct md5_state_s *pms, const unsigned char *data, signed int nbytes);
// md5_finish
// file md5.h line 85
void md5_finish(struct md5_state_s *pms, unsigned char *digest);
// md5_init
// file md5.h line 79
void md5_init(struct md5_state_s *pms);
// md5_process
// file md5.c line 147
static void md5_process(struct md5_state_s *pms, const unsigned char *data);
// memcmp
// file /usr/include/string.h line 69
extern signed int memcmp(const void *, const void *, unsigned long int);
// memcpy
// file /usr/include/string.h line 46
extern void * memcpy(void *, const void *, unsigned long int);
// memmove
// file /usr/include/string.h line 50
extern void * memmove(void *, const void *, unsigned long int);
// memset
// file /usr/include/string.h line 66
extern void * memset(void *, signed int, unsigned long int);
// ntohl
// file /usr/include/netinet/in.h line 374
extern unsigned int ntohl(unsigned int);
// ntohs
// file /usr/include/netinet/in.h line 375
extern unsigned short int ntohs(unsigned short int);
// open
// file /usr/include/fcntl.h line 146
extern signed int open(const char *, signed int, ...);
// perror
// file /usr/include/stdio.h line 846
extern void perror(const char *);
// printf
// file /usr/include/stdio.h line 362
extern signed int printf(const char *, ...);
// process_icmpv6
// file mire.c line 69
static void process_icmpv6(signed int fd, struct ip6_hdr *ip6, unsigned long int plen, unsigned int ipv4, unsigned short int port);
// process_none
// file mire.c line 104
static void process_none(signed int fd, struct ip6_hdr *ip6, unsigned long int plen, unsigned int ipv4, unsigned short int port);
// process_unknown
// file mire.c line 115
static void process_unknown(signed int fd, struct ip6_hdr *in, unsigned long int plen, unsigned int ipv4, unsigned short int port);
// pthread_cancel
// file /usr/include/pthread.h line 515
extern signed int pthread_cancel(unsigned long int);
// pthread_cond_destroy
// file /usr/include/pthread.h line 975
extern signed int pthread_cond_destroy(union anonymous_13 *);
// pthread_cond_init
// file /usr/include/pthread.h line 970
extern signed int pthread_cond_init(union anonymous_13 *, const union anonymous_3 *);
// pthread_cond_signal
// file /usr/include/pthread.h line 979
extern signed int pthread_cond_signal(union anonymous_13 *);
// pthread_cond_timedwait
// file /usr/include/pthread.h line 1002
extern signed int pthread_cond_timedwait(union anonymous_13 *, union anonymous_24 *, struct timespec *);
// pthread_cond_wait
// file /usr/include/pthread.h line 991
extern signed int pthread_cond_wait(union anonymous_13 *, union anonymous_24 *);
// pthread_condattr_destroy
// file /usr/include/pthread.h line 1014
extern signed int pthread_condattr_destroy(union anonymous_3 *);
// pthread_condattr_init
// file /usr/include/pthread.h line 1010
extern signed int pthread_condattr_init(union anonymous_3 *);
// pthread_condattr_setclock
// file /usr/include/pthread.h line 1035
extern signed int pthread_condattr_setclock(union anonymous_3 *, signed int);
// pthread_create
// file /usr/include/pthread.h line 235
extern signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// pthread_join
// file /usr/include/pthread.h line 252
extern signed int pthread_join(unsigned long int, void **);
// pthread_mutex_destroy
// file /usr/include/pthread.h line 756
extern signed int pthread_mutex_destroy(union anonymous_24 *);
// pthread_mutex_init
// file /usr/include/pthread.h line 751
extern signed int pthread_mutex_init(union anonymous_24 *, const union anonymous_3 *);
// pthread_mutex_lock
// file /usr/include/pthread.h line 764
extern signed int pthread_mutex_lock(union anonymous_24 *);
// pthread_mutex_unlock
// file /usr/include/pthread.h line 775
extern signed int pthread_mutex_unlock(union anonymous_24 *);
// pthread_rwlock_destroy
// file /usr/include/pthread.h line 895
extern signed int pthread_rwlock_destroy(union anonymous_6 *);
// pthread_rwlock_init
// file /usr/include/pthread.h line 890
extern signed int pthread_rwlock_init(union anonymous_6 *, const union anonymous_19 *);
// pthread_rwlock_rdlock
// file /usr/include/pthread.h line 899
extern signed int pthread_rwlock_rdlock(union anonymous_6 *);
// pthread_rwlock_unlock
// file /usr/include/pthread.h line 929
extern signed int pthread_rwlock_unlock(union anonymous_6 *);
// pthread_rwlock_wrlock
// file /usr/include/pthread.h line 914
extern signed int pthread_rwlock_wrlock(union anonymous_6 *);
// pthread_setcancelstate
// file /usr/include/pthread.h line 508
extern signed int pthread_setcancelstate(signed int, signed int *);
// puts
// file /usr/include/stdio.h line 695
extern signed int puts(const char *);
// read
// file /usr/include/unistd.h line 360
extern signed long int read(signed int, void *, unsigned long int);
// recv_packet
// file mire.c line 158
static signed long int recv_packet(signed int fd, struct teredo_packet *p);
// recvmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 202
extern signed long int recvmsg(signed int, struct msghdr *, signed int);
// sched_yield
// file /usr/include/sched.h line 65
extern signed int sched_yield(void);
// sendmsg
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 184
extern signed long int sendmsg(signed int, struct msghdr *, signed int);
// server_thread
// file mire.c line 185
static void * server_thread(void *data);
// setrlimit
// file /usr/include/x86_64-linux-gnu/sys/resource.h line 69
extern signed int setrlimit(enum __rlimit_resource, struct rlimit *);
// setsockopt
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 226
extern signed int setsockopt(signed int, signed int, signed int, const void *, unsigned int);
// socket
// file /usr/include/x86_64-linux-gnu/sys/socket.h line 113
extern signed int socket(signed int, signed int, signed int);
// strdup
// file /usr/include/string.h line 175
extern char * strdup(const char *);
// strlcpy
// file strlcpy.c line 27
unsigned long int strlcpy(char *tgt, const char *src, unsigned long int bufsize);
// syslog
// file /usr/include/x86_64-linux-gnu/sys/syslog.h line 190
extern void syslog(signed int, const char *, ...);
// teredo_cksum
// file ../libteredo/teredo-udp.h line 152
unsigned short int teredo_cksum(const void *src, const void *dst, unsigned char protocol, struct iovec *data, unsigned long int n);
// teredo_cleanup
// file init.c line 53
void teredo_cleanup(_Bool use_client);
// teredo_clock
// file clock.h line 46
unsigned long int teredo_clock(void);
// teredo_close
// file ../libteredo/teredo-udp.h line 163
void teredo_close(signed int fd);
// teredo_create
// file relay.c line 879
struct teredo_tunnel * teredo_create(unsigned int ipv4, unsigned short int port);
// teredo_deinit_HMAC
// file security.h line 35
void teredo_deinit_HMAC(void);
// teredo_destroy
// file relay.c line 923
void teredo_destroy(struct teredo_tunnel *t);
// teredo_dummy_icmpv6_cb
// file relay.c line 852
static void teredo_dummy_icmpv6_cb(void *o, const void *p, unsigned long int l, struct in6_addr *d);
// teredo_dummy_recv_cb
// file relay.c line 844
static void teredo_dummy_recv_cb(void *o, const void *p, unsigned long int l);
// teredo_dummy_state_down_cb
// file relay.c line 872
static void teredo_dummy_state_down_cb(void *o);
// teredo_dummy_state_up_cb
// file relay.c line 863
static void teredo_dummy_state_up_cb(void *o, struct in6_addr *a, unsigned short int m);
// teredo_encap
// file relay.c line 311
static signed int teredo_encap(struct teredo_tunnel * restrict tunnel, struct teredo_peer * restrict peer, const void * restrict data, unsigned long int len, unsigned long int now);
// teredo_enqueue_in
// file peerlist.h line 52
void teredo_enqueue_in(struct teredo_peer * restrict peer, const void * restrict data, unsigned long int len, unsigned int ip, unsigned short int port);
// teredo_enqueue_out
// file peerlist.h line 55
void teredo_enqueue_out(struct teredo_peer * restrict peer, const void * restrict data, unsigned long int len);
// teredo_get_flbits
// file security.c line 226
unsigned short int teredo_get_flbits(unsigned int timestamp);
// teredo_get_nonce
// file security.c line 241
void teredo_get_nonce(unsigned int timestamp, unsigned int ipv4, unsigned short int port, unsigned char * restrict nonce);
// teredo_get_pinghash
// file security.c line 181
void teredo_get_pinghash(unsigned int timestamp, struct in6_addr *src, struct in6_addr *dst, unsigned char * restrict hash);
// teredo_get_privdata
// file relay.c line 1105
void * teredo_get_privdata(const struct teredo_tunnel *t);
// teredo_hash
// file security.c line 126
static void teredo_hash(const void *src, unsigned long int slen, const void *dst, unsigned long int dlen, unsigned char * restrict hash, unsigned int timestamp);
// teredo_init_HMAC
// file security.h line 34
signed int teredo_init_HMAC(void);
// teredo_list_create
// file peerlist.h line 106
struct teredo_peerlist * teredo_list_create(unsigned int max, unsigned int expiration);
// teredo_list_destroy
// file peerlist.h line 113
void teredo_list_destroy(struct teredo_peerlist *l);
// teredo_list_lookup
// file peerlist.h line 141
struct teredo_peer * teredo_list_lookup(struct teredo_peerlist * restrict list, struct in6_addr * restrict addr, _Bool * restrict create);
// teredo_list_release
// file peerlist.h line 149
void teredo_list_release(struct teredo_peerlist *l);
// teredo_list_reset
// file peerlist.h line 122
void teredo_list_reset(struct teredo_peerlist *l, unsigned int max);
// teredo_maintenance_process
// file maintain.h line 98
signed int teredo_maintenance_process(struct teredo_maintenance * restrict m, const struct teredo_packet * restrict packet);
// teredo_maintenance_start
// file maintain.h line 78
struct teredo_maintenance * teredo_maintenance_start(signed int fd, void (*cb)(struct teredo_state *, void *), void *opaque, const char *s1, const char *s2, unsigned int q_sec, unsigned int q_retries, unsigned int refresh_sec, unsigned int restart_sec);

//

// teredo_maintenance_stop
// file maintain.h line 89
void teredo_maintenance_stop(struct teredo_maintenance *m);
// teredo_parse_ra
// file packets.c line 158
signed int teredo_parse_ra(const struct teredo_packet * restrict packet, union teredo_addr * restrict newaddr, _Bool cone, unsigned short int * restrict mtu);
// teredo_peer_destroy
// file peerlist.c line 77
static inline void teredo_peer_destroy(struct teredo_peer *peer);
// teredo_peer_init
// file peerlist.c line 70
static inline void teredo_peer_init(struct teredo_peer *peer);
// teredo_peer_queue
// file peerlist.c line 92
static void teredo_peer_queue(struct teredo_peer * restrict peer, const void * restrict data, unsigned long int len, unsigned int ip, unsigned short int port, _Bool incoming);
// teredo_peer_queue_yield
// file peerlist.h line 57
struct teredo_queue * teredo_peer_queue_yield(struct teredo_peer *peer);
// teredo_pinghash
// file security.c line 158
static inline void teredo_pinghash(struct in6_addr *src, struct in6_addr *dst, unsigned char * restrict hash, unsigned int timestamp);
// teredo_predecap
// file relay.c line 528
static void teredo_predecap(struct teredo_tunnel * restrict tunnel, struct teredo_peer * restrict peer, unsigned long int now);
// teredo_queue_emit
// file peerlist.h line 58
void teredo_queue_emit(struct teredo_queue *q, signed int fd, unsigned int ipv4, unsigned short int port, void (*cb)(void *, const void *, unsigned long int), void *opaque);

//

// teredo_recv
// file teredo-udp.h line 129
signed int teredo_recv(signed int fd, struct teredo_packet *p);
// teredo_recv_inner
// file teredo.c line 173
static signed int teredo_recv_inner(signed int fd, struct teredo_packet *p, signed int flags);
// teredo_recv_thread
// file relay.c line 952
static void * teredo_recv_thread(void *t);
// teredo_recverr
// file teredo.c line 118
static signed long int teredo_recverr(signed int fd);
// teredo_reply_bubble
// file packets.h line 79
static inline signed int teredo_reply_bubble(signed int fd, unsigned int ip, unsigned short int port, struct ip6_hdr *req);
// teredo_reply_bubble_link1
// file packets.h line 79
static inline signed int teredo_reply_bubble_link1(signed int fd_link1, unsigned int ip_link1, unsigned short int port_link1, struct ip6_hdr *req_link1);
// teredo_run
// file relay.c line 986
void teredo_run(struct teredo_tunnel *tunnel);
// teredo_run_async
// file relay.c line 970
signed int teredo_run_async(struct teredo_tunnel *t);
// teredo_run_inner
// file relay.c line 553
static void teredo_run_inner(struct teredo_tunnel * restrict tunnel, struct teredo_packet * restrict packet);
// teredo_send
// file ../libteredo/teredo-udp.h line 98
signed int teredo_send(signed int fd, const void *packet, unsigned long int plen, unsigned int dest_ip, unsigned short int dest_port);
// teredo_send_bubble
// file packets.h line 75
signed int teredo_send_bubble(signed int fd, unsigned int ip, unsigned short int port, struct in6_addr *src, struct in6_addr *dst);
// teredo_send_rs
// file packets.c line 119
signed int teredo_send_rs(signed int fd, unsigned int server_ip, const unsigned char *nonce, _Bool cone);
// teredo_send_unreach
// file relay.c line 122
static void teredo_send_unreach(struct teredo_tunnel * restrict tunnel, unsigned char code, struct ip6_hdr * restrict in, unsigned long int len);
// teredo_sendv
// file ../libteredo/teredo-udp.h line 113
signed int teredo_sendv(signed int fd, struct iovec *iov, unsigned long int count, unsigned int dest_ip, unsigned short int dest_port);
// teredo_set_client_mode
// file relay.c line 1062
signed int teredo_set_client_mode(struct teredo_tunnel * restrict t, const char *s, const char *s2);
// teredo_set_cone_flag
// file relay.c line 1021
signed int teredo_set_cone_flag(struct teredo_tunnel *t, _Bool cone);
// teredo_set_icmpv6_callback
// file relay.c line 1126
void teredo_set_icmpv6_callback(struct teredo_tunnel * restrict t, void (*cb)(void *, const void *, unsigned long int, struct in6_addr *));

//

// teredo_set_prefix
// file relay.c line 999
signed int teredo_set_prefix(struct teredo_tunnel *t, unsigned int prefix);
// teredo_set_privdata
// file relay.c line 1092
void * teredo_set_privdata(struct teredo_tunnel *t, void *opaque);
// teredo_set_recv_callback
// file relay.c line 1116
void teredo_set_recv_callback(struct teredo_tunnel * restrict t, void (*cb)(void *, const void *, unsigned long int));

//

// teredo_set_relay_mode
// file relay.c line 1045
signed int teredo_set_relay_mode(struct teredo_tunnel *t);
// teredo_set_state_cb
// file relay.c line 1134
void teredo_set_state_cb(struct teredo_tunnel * restrict t, void (*u)(void *, struct in6_addr *, unsigned short int), void (*d)(void *));
// teredo_set_state_cb::d_object
//
void d_object(void *);
// teredo_set_state_cb::u_object
//
void u_object(void *, struct in6_addr *, unsigned short int);
// teredo_socket
// file ../libteredo/teredo-udp.h line 90
signed int teredo_socket(unsigned int bind_ip, unsigned short int port);
// teredo_startup
// file init.c line 36
signed int teredo_startup(_Bool use_client);
// teredo_state_change
// file relay.c line 178
static void teredo_state_change(const struct teredo_state *state, void *self);
// teredo_transmit
// file relay.c line 324
signed int teredo_transmit(struct teredo_tunnel * restrict tunnel, struct ip6_hdr * restrict packet, unsigned long int length);
// teredo_verify_pinghash
// file security.c line 199
signed int teredo_verify_pinghash(unsigned int now, struct in6_addr *src, struct in6_addr *dst, const unsigned char * restrict hash);
// teredo_wait_recv
// file ../libteredo/teredo-udp.h line 145
signed int teredo_wait_recv(signed int fd, struct teredo_packet *p);
// time
// file /usr/include/time.h line 192
extern signed long int time(signed long int *);
// timer_create
// file /usr/include/time.h line 363
extern signed int timer_create(signed int, struct sigevent *, void ** restrict );
// timer_getoverrun
// file /usr/include/time.h line 380
extern signed int timer_getoverrun(void *);
// timer_settime
// file /usr/include/time.h line 371
extern signed int timer_settime(void *, signed int, struct itimerspec *, struct itimerspec *);
// usage
// file mire.c line 231
static signed int usage(const char *path);
// version
// file mire.c line 237
static signed int version(void);
// wait_reply
// file maintain.c line 163
static signed int wait_reply(struct teredo_maintenance * restrict m, struct timespec * restrict deadline);
// wait_reply_ignore
// file maintain.c line 184
static void wait_reply_ignore(struct teredo_maintenance * restrict m, struct timespec * restrict deadline);

struct anonymous_1
{
  // _function
  void (*_function)(union sigval);
  // _attribute
  union pthread_attr_t *_attribute;
};

struct anonymous_15
{
  // __cancel_jmp_buf
  signed long int __cancel_jmp_buf[8l];
  // __mask_was_saved
  signed int __mask_was_saved;
};

struct anonymous_16
{
  // __cancel_jmp_buf
  struct anonymous_15 __cancel_jmp_buf[1l];
  // __pad
  void *__pad[4l];
};

struct anonymous_12
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anonymous_14
{
  // __lock
  signed int __lock;
  // __nr_readers
  unsigned int __nr_readers;
  // __readers_wakeup
  unsigned int __readers_wakeup;
  // __writer_wakeup
  unsigned int __writer_wakeup;
  // __nr_readers_queued
  unsigned int __nr_readers_queued;
  // __nr_writers_queued
  unsigned int __nr_writers_queued;
  // __writer
  signed int __writer;
  // __shared
  signed int __shared;
  // __rwelision
  signed char __rwelision;
  // __pad1
  unsigned char __pad1[7l];
  // __pad2
  unsigned long int __pad2;
  // __flags
  unsigned int __flags;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed short int __spins;
  // __elision
  signed short int __elision;
  // __list
  struct __pthread_internal_list __list;
};

union anonymous_24
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct anonymous_7
{
  // lock
  union anonymous_24 lock;
  // count
  signed int count;
  // last
  unsigned long int last;
};

union anonymous_25
{
  // __u6_addr8
  unsigned char __u6_addr8[16l];
  // __u6_addr16
  unsigned short int __u6_addr16[8l];
  // __u6_addr32
  unsigned int __u6_addr32[4l];
};

struct in6_addr
{
  // __in6_u
  union anonymous_25 __in6_u;
};

struct anonymous_10
{
  // prefix
  unsigned int prefix;
  // server_ip
  unsigned int server_ip;
  // flags
  unsigned short int flags;
  // client_port
  unsigned short int client_port;
  // client_ip
  unsigned int client_ip;
};

union teredo_addr
{
  // ip6
  struct in6_addr ip6;
  // teredo
  struct anonymous_10 teredo;
  // t6_addr32
  unsigned int t6_addr32[4l];
};

struct teredo_state
{
  // addr
  union teredo_addr addr;
  // ipv4
  unsigned int ipv4;
  // mtu
  unsigned short int mtu;
  // up
  _Bool up;
};

struct anonymous_4
{
  // state
  struct teredo_state state;
  // cb
  void (*cb)(struct teredo_state *, void *);
  // opaque
  void *opaque;
};

struct anonymous_8
{
  // thread
  unsigned long int thread;
  // running
  _Bool running;
};

union anonymous_2
{
  // _pad
  signed int _pad[12l];
  // _tid
  signed int _tid;
  // _sigev_thread
  struct anonymous_1 _sigev_thread;
};

union anonymous_22
{
  // key
  unsigned char key[16l];
  // ipad
  unsigned char ipad[64l];
};

union anonymous_23
{
  // key
  unsigned char key[16l];
  // opad
  unsigned char opad[64l];
};

union anonymous_27
{
  // icmp6_un_data32
  unsigned int icmp6_un_data32[1l];
  // icmp6_un_data16
  unsigned short int icmp6_un_data16[2l];
  // icmp6_un_data8
  unsigned char icmp6_un_data8[4l];
};

union anonymous_18
{
  // align
  unsigned long int align[1l];
  // fill
  unsigned char fill[65507l];
};

union anonymous_3
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anonymous_19
{
  // __size
  char __size[8l];
  // __align
  signed long int __align;
};

union anonymous_13
{
  // __data
  struct anonymous_12 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

union anonymous_6
{
  // __data
  struct anonymous_14 __data;
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct ip6_hdrctl
{
  // ip6_un1_flow
  unsigned int ip6_un1_flow;
  // ip6_un1_plen
  unsigned short int ip6_un1_plen;
  // ip6_un1_nxt
  unsigned char ip6_un1_nxt;
  // ip6_un1_hlim
  unsigned char ip6_un1_hlim;
};

union anonymous_17
{
  // ip6_un1
  struct ip6_hdrctl ip6_un1;
  // ip6_un2_vfc
  unsigned char ip6_un2_vfc;
};

union anonymous_11
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
};

union anonymous_9
{
  // __sockaddr__
  struct sockaddr * restrict __sockaddr__;
  // __sockaddr_at__
  struct sockaddr_at * restrict __sockaddr_at__;
  // __sockaddr_ax25__
  struct sockaddr_ax25 * restrict __sockaddr_ax25__;
  // __sockaddr_dl__
  struct sockaddr_dl * restrict __sockaddr_dl__;
  // __sockaddr_eon__
  struct sockaddr_eon * restrict __sockaddr_eon__;
  // __sockaddr_in__
  struct sockaddr_in * restrict __sockaddr_in__;
  // __sockaddr_in6__
  struct sockaddr_in6 * restrict __sockaddr_in6__;
  // __sockaddr_inarp__
  struct sockaddr_inarp * restrict __sockaddr_inarp__;
  // __sockaddr_ipx__
  struct sockaddr_ipx * restrict __sockaddr_ipx__;
  // __sockaddr_iso__
  struct sockaddr_iso * restrict __sockaddr_iso__;
  // __sockaddr_ns__
  struct sockaddr_ns * restrict __sockaddr_ns__;
  // __sockaddr_un__
  struct sockaddr_un * restrict __sockaddr_un__;
  // __sockaddr_x25__
  struct sockaddr_x25 * restrict __sockaddr_x25__;
} __attribute__ ((__transparent_union__));

struct J_UDY_ERROR_STRUCT
{
  // je_Errno
  enum anonymous je_Errno;
  // je_ErrID
  signed int je_ErrID;
  // je_reserved
  unsigned long int je_reserved[4l];
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[(signed long int)(sizeof(signed int) * 5) /*20l*/ ];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct addrinfo
{
  // ai_flags
  signed int ai_flags;
  // ai_family
  signed int ai_family;
  // ai_socktype
  signed int ai_socktype;
  // ai_protocol
  signed int ai_protocol;
  // ai_addrlen
  unsigned int ai_addrlen;
  // ai_addr
  struct sockaddr *ai_addr;
  // ai_canonname
  char *ai_canonname;
  // ai_next
  struct addrinfo *ai_next;
};

struct clock_data_t
{
  // handle
  void *handle;
  // value
  unsigned long int value;
  // active
  _Bool active;
};

struct cmsghdr
{
  // cmsg_len
  unsigned long int cmsg_len;
  // cmsg_level
  signed int cmsg_level;
  // cmsg_type
  signed int cmsg_type;
  // __cmsg_data
  unsigned char __cmsg_data[0l];
};

struct icmp6_hdr
{
  // icmp6_type
  unsigned char icmp6_type;
  // icmp6_code
  unsigned char icmp6_code;
  // icmp6_cksum
  unsigned short int icmp6_cksum;
  // icmp6_dataun
  union anonymous_27 icmp6_dataun;
};

struct in_addr
{
  // s_addr
  unsigned int s_addr;
};

struct in_pktinfo
{
  // ipi_ifindex
  signed int ipi_ifindex;
  // ipi_spec_dst
  struct in_addr ipi_spec_dst;
  // ipi_addr
  struct in_addr ipi_addr;
};

struct iovec
{
  // iov_base
  void *iov_base;
  // iov_len
  unsigned long int iov_len;
};

struct ip6_hdr
{
  // ip6_ctlun
  union anonymous_17 ip6_ctlun;
  // ip6_src
  struct in6_addr ip6_src;
  // ip6_dst
  struct in6_addr ip6_dst;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct itimerspec
{
  // it_interval
  struct timespec it_interval;
  // it_value
  struct timespec it_value;
};

struct md5_state_s
{
  // count
  unsigned int count[2l];
  // abcd
  unsigned int abcd[4l];
  // buf
  unsigned char buf[64l];
};

struct msghdr
{
  // msg_name
  void *msg_name;
  // msg_namelen
  unsigned int msg_namelen;
  // msg_iov
  struct iovec *msg_iov;
  // msg_iovlen
  unsigned long int msg_iovlen;
  // msg_control
  void *msg_control;
  // msg_controllen
  unsigned long int msg_controllen;
  // msg_flags
  signed int msg_flags;
};

struct nd_opt_hdr
{
  // nd_opt_type
  unsigned char nd_opt_type;
  // nd_opt_len
  unsigned char nd_opt_len;
};

struct nd_opt_mtu
{
  // nd_opt_mtu_type
  unsigned char nd_opt_mtu_type;
  // nd_opt_mtu_len
  unsigned char nd_opt_mtu_len;
  // nd_opt_mtu_reserved
  unsigned short int nd_opt_mtu_reserved;
  // nd_opt_mtu_mtu
  unsigned int nd_opt_mtu_mtu;
};

struct nd_opt_prefix_info
{
  // nd_opt_pi_type
  unsigned char nd_opt_pi_type;
  // nd_opt_pi_len
  unsigned char nd_opt_pi_len;
  // nd_opt_pi_prefix_len
  unsigned char nd_opt_pi_prefix_len;
  // nd_opt_pi_flags_reserved
  unsigned char nd_opt_pi_flags_reserved;
  // nd_opt_pi_valid_time
  unsigned int nd_opt_pi_valid_time;
  // nd_opt_pi_preferred_time
  unsigned int nd_opt_pi_preferred_time;
  // nd_opt_pi_reserved2
  unsigned int nd_opt_pi_reserved2;
  // nd_opt_pi_prefix
  struct in6_addr nd_opt_pi_prefix;
};

struct nd_router_advert
{
  // nd_ra_hdr
  struct icmp6_hdr nd_ra_hdr;
  // nd_ra_reachable
  unsigned int nd_ra_reachable;
  // nd_ra_retransmit
  unsigned int nd_ra_retransmit;
};

struct nd_router_solicit
{
  // nd_rs_hdr
  struct icmp6_hdr nd_rs_hdr;
};

struct option
{
  // name
  const char *name;
  // has_arg
  signed int has_arg;
  // flag
  signed int *flag;
  // val
  signed int val;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct rlimit
{
  // rlim_cur
  unsigned long int rlim_cur;
  // rlim_max
  unsigned long int rlim_max;
};

union sigval
{
  // sival_int
  signed int sival_int;
  // sival_ptr
  void *sival_ptr;
};

struct sigevent
{
  // sigev_value
  union sigval sigev_value;
  // sigev_signo
  signed int sigev_signo;
  // sigev_notify
  signed int sigev_notify;
  // _sigev_un
  union anonymous_2 _sigev_un;
};

struct sockaddr
{
  // sa_family
  unsigned short int sa_family;
  // sa_data
  char sa_data[14l];
};

struct sockaddr_in
{
  // sin_family
  unsigned short int sin_family;
  // sin_port
  unsigned short int sin_port;
  // sin_addr
  struct in_addr sin_addr;
  // sin_zero
  unsigned char sin_zero[8l];
};

struct sockaddr_in6
{
  // sin6_family
  unsigned short int sin6_family;
  // sin6_port
  unsigned short int sin6_port;
  // sin6_flowinfo
  unsigned int sin6_flowinfo;
  // sin6_addr
  struct in6_addr sin6_addr;
  // sin6_scope_id
  unsigned int sin6_scope_id;
};

struct teredo_peer
{
  // queue
  struct teredo_queue *queue;
  // queue_left
  unsigned long int queue_left;
  // last_rx
  unsigned long int last_rx;
  // last_tx
  unsigned long int last_tx;
  // mapped_addr
  unsigned int mapped_addr;
  // mapped_port
  unsigned short int mapped_port;
  // trusted
  unsigned int trusted : 1;
  // bubbles
  unsigned int bubbles : 3;
  // pings
  unsigned int pings : 3;
  // last_ping
  unsigned int last_ping : 9;
};

struct teredo_listitem
{
  // key
  union teredo_addr key;
  // pprev
  struct teredo_listitem **pprev;
  // next
  struct teredo_listitem *next;
  // peer
  struct teredo_peer peer;
};

struct teredo_maintenance
{
  // thread
  unsigned long int thread;
  // outer
  union anonymous_24 outer;
  // inner
  union anonymous_24 inner;
  // received
  union anonymous_13 received;
  // processed
  union anonymous_13 processed;
  // incoming
  const struct teredo_packet *incoming;
  // fd
  signed int fd;
  // state
  struct anonymous_4 state;
  // server
  char *server;
  // qualification_delay
  unsigned int qualification_delay;
  // qualification_retries
  unsigned int qualification_retries;
  // refresh_delay
  unsigned int refresh_delay;
  // restart_delay
  unsigned int restart_delay;
};

struct teredo_packet
{
  // ip6
  struct ip6_hdr *ip6;
  // ip6_len
  unsigned long int ip6_len;
  // source_ipv4
  unsigned int source_ipv4;
  // source_port
  unsigned short int source_port;
  // orig_port
  unsigned short int orig_port;
  // orig_ipv4
  unsigned int orig_ipv4;
  // dest_ipv4
  unsigned int dest_ipv4;
  // auth_present
  _Bool auth_present;
  // auth_fail
  _Bool auth_fail;
  // auth_nonce
  unsigned char auth_nonce[8l];
  // buf
  union anonymous_18 buf;
};

struct teredo_peerlist
{
  // recent
  struct teredo_listitem *recent;
  // old
  struct teredo_listitem *old;
  // left
  unsigned int left;
  // expiration
  unsigned int expiration;
  // gc
  unsigned long int gc;
  // lock
  union anonymous_24 lock;
  // PJHSArray
  void *PJHSArray;
};

struct teredo_queue
{
  // next
  struct teredo_queue *next;
  // length
  unsigned long int length;
  // ipv4
  unsigned int ipv4;
  // port
  unsigned short int port;
  // incoming
  _Bool incoming;
  // data
  unsigned char data[0l];
};

struct teredo_tunnel
{
  // list
  struct teredo_peerlist *list;
  // opaque
  void *opaque;
  // maintenance
  struct teredo_maintenance *maintenance;
  // up_cb
  void (*up_cb)(void *, struct in6_addr *, unsigned short int);
  // down_cb
  void (*down_cb)(void *);
  // recv_cb
  void (*recv_cb)(void *, const void *, unsigned long int);
  // icmpv6_cb
  void (*icmpv6_cb)(void *, const void *, unsigned long int, struct in6_addr *);
  // state
  struct teredo_state state;
  // state_lock
  union anonymous_6 state_lock;
  // ratelimit
  struct anonymous_7 ratelimit;
  // recv
  struct anonymous_8 recv;
  // fd
  signed int fd;
};


// QualificationDelay
// file maintain.c line 409
static const unsigned int QualificationDelay = (const unsigned int)4;
// QualificationRetries
// file maintain.c line 410
static const unsigned int QualificationRetries = (const unsigned int)3;
// RefreshDelay
// file maintain.c line 412
static const unsigned int RefreshDelay = (const unsigned int)30;
// RestartDelay
// file maintain.c line 413
static const unsigned int RestartDelay = (const unsigned int)100;
// hmac_pid
// file security.c line 70
static unsigned short int hmac_pid = (unsigned short int)0;
// in6addr_allrouters
// file packets.c line 115
static struct in6_addr in6addr_allrouters = { .__in6_u={ .__u6_addr8={ (unsigned char)0xff, (unsigned char)0x02, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0x2 } } };
// inner_key
// file security.c line 61
static union anonymous_22 inner_key;
// outer_key
// file security.c line 67
static union anonymous_23 outer_key;
// randfile
// file security.c line 46
static const char randfile[12l] = { '/', 'd', 'e', 'v', '/', 'r', 'a', 'n', 'd', 'o', 'm', 0 };
// stderr
// file /usr/include/stdio.h line 170
extern struct _IO_FILE *stderr;
// teredo_MaxQueueBytes
// file peerlist.c line 67
static const unsigned int teredo_MaxQueueBytes = (const unsigned int)1280;
// teredo_cone
// file teredo.c line 63
struct in6_addr teredo_cone = { .__in6_u={ .__u6_addr8={ (unsigned char)0xfe, (unsigned char)0x80, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0x80, (unsigned char)0, (unsigned char)84, (unsigned char)69, (unsigned char)82, (unsigned char)69, (unsigned char)68, (unsigned char)79 } } };
// teredo_restrict
// file teredo.c line 54
struct in6_addr teredo_restrict = { .__in6_u={ .__u6_addr8={ (unsigned char)0xfe, (unsigned char)0x80, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff } } };

// BuildICMPv6Error
// file packets.h line 145
signed int BuildICMPv6Error(struct icmp6_hdr * restrict out, unsigned char type, unsigned char code, struct ip6_hdr * restrict in, unsigned long int inlen)
{
  struct in6_addr *p;
  _Bool tmp_if_expr_5;
  _Bool tmp_statement_expression_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  if(!(inlen >= sizeof(struct ip6_hdr) /*40ul*/ ))
    return 0;

  else
    if((signed int)in->ip6_ctlun.ip6_un1.ip6_un1_nxt == 58)
    {
      if(!((0x80 & (signed int)((struct icmp6_hdr *)(in + 1l))->icmp6_type) == 0))
        goto __CPROVER_DUMP_L2;

      return 0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if((signed int)*((const unsigned char *)&in->ip6_dst) == 0xff)
        return 0;

      else
      {
        p = &in->ip6_src;
        if((signed int)*((const unsigned char *)p) == 0xff)
          tmp_if_expr_5 = (_Bool)1;

        else
        {
          struct in6_addr *__a = (struct in6_addr *)p;
          if(__a->__in6_u.__u6_addr32[0l] == 0u)
            tmp_if_expr_2 = __a->__in6_u.__u6_addr32[(signed long int)1] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_2 = (_Bool)0;
          if(tmp_if_expr_2)
            tmp_if_expr_3 = __a->__in6_u.__u6_addr32[(signed long int)2] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_3 = (_Bool)0;
          if(tmp_if_expr_3)
            tmp_if_expr_4 = __a->__in6_u.__u6_addr32[(signed long int)3] == (unsigned int)0 ? (_Bool)1 : (_Bool)0;

          else
            tmp_if_expr_4 = (_Bool)0;
          tmp_statement_expression_1 = tmp_if_expr_4;
          tmp_if_expr_5 = tmp_statement_expression_1 ? (_Bool)1 : (_Bool)0;
        }
        if(tmp_if_expr_5)
          return 0;

        else
        {
          out->icmp6_type = type;
          out->icmp6_code = code;
          out->icmp6_cksum = (unsigned short int)0;
          out->icmp6_dataun.icmp6_un_data32[(signed long int)0] = (unsigned int)0;
          if(inlen >= 1233ul)
            inlen = (unsigned long int)1280 - (sizeof(struct ip6_hdr) /*40ul*/  + sizeof(struct icmp6_hdr) /*8ul*/ );

          memcpy((void *)(out + (signed long int)1), (const void *)in, inlen);
          return (signed int)(sizeof(struct icmp6_hdr) /*8ul*/  + inlen);
        }
      }
    }
}

// CheckBubble
// file packets.h line 41
signed int CheckBubble(const struct teredo_packet *packet)
{
  struct ip6_hdr *ip6 = packet->ip6;
  struct in6_addr *me = &ip6->ip6_dst;
  struct in6_addr *it = &ip6->ip6_src;
  unsigned char hash[8l];
  teredo_get_nonce((unsigned int)0, (&((union teredo_addr *)it)->teredo)->client_ip ^ 0xffffffff, (unsigned short int)((signed int)(&((union teredo_addr *)it)->teredo)->client_port ^ 0xffff), hash);
  hash[(signed long int)0] = hash[(signed long int)0] & (unsigned char)0xfc;
  signed int return_value_memcmp_1;
  return_value_memcmp_1=memcmp((const void *)hash, (const void *)(me->__in6_u.__u6_addr8 + (signed long int)8), (unsigned long int)8);
  return return_value_memcmp_1 != 0 ? -1 : 0;
}

// CheckPing
// file packets.h line 40
signed int CheckPing(const struct teredo_packet *packet)
{
  struct ip6_hdr *ip6 = packet->ip6;
  unsigned long int length;
  unsigned short int return_value_ntohs_1;
  return_value_ntohs_1=ntohs(ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);
  length = (unsigned long int)return_value_ntohs_1;
  _Bool tmp_if_expr_2;
  _Bool tmp_statement_expression_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  _Bool tmp_if_expr_8;
  _Bool tmp_statement_expression_9;
  _Bool tmp_if_expr_10;
  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_12;
  if(!((signed int)ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt == 58) || !(length >= sizeof(struct icmp6_hdr) * 3 + 2 /*26ul*/ ))
    return -1;

  else
  {
    struct icmp6_hdr *icmp6 = (struct icmp6_hdr *)(ip6 + (signed long int)1);
    struct in6_addr *me = &ip6->ip6_dst;
    struct in6_addr *it = &ip6->ip6_src;
    if((signed int)icmp6->icmp6_type == 1)
    {
      length = length - sizeof(struct icmp6_hdr) /*8ul*/ ;
      ip6 = (struct ip6_hdr *)(icmp6 + (signed long int)1);
      if(!(length >= 66ul))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (signed int)ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt != 58 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        return -1;

      unsigned short int return_value_ntohs_3;
      return_value_ntohs_3=ntohs(ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);
      length = (unsigned long int)return_value_ntohs_3;
      if(!(length == sizeof(struct icmp6_hdr) * 3 + 2 /*26ul*/ ))
        return -1;

      icmp6 = (struct icmp6_hdr *)(ip6 + (signed long int)1);
      struct in6_addr *__a = (struct in6_addr *)&ip6->ip6_src;
      struct in6_addr *CheckPing__1__1__1____b = (struct in6_addr *)me;
      if(__a->__in6_u.__u6_addr32[0l] == CheckPing__1__1__1____b->__in6_u.__u6_addr32[0l])
        tmp_if_expr_5 = __a->__in6_u.__u6_addr32[(signed long int)1] == CheckPing__1__1__1____b->__in6_u.__u6_addr32[(signed long int)1] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_5 = (_Bool)0;
      if(tmp_if_expr_5)
        tmp_if_expr_6 = __a->__in6_u.__u6_addr32[(signed long int)2] == CheckPing__1__1__1____b->__in6_u.__u6_addr32[(signed long int)2] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_6 = (_Bool)0;
      if(tmp_if_expr_6)
        tmp_if_expr_7 = __a->__in6_u.__u6_addr32[(signed long int)3] == CheckPing__1__1__1____b->__in6_u.__u6_addr32[(signed long int)3] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_7 = (_Bool)0;
      tmp_statement_expression_4 = tmp_if_expr_7;
      if(!tmp_statement_expression_4)
        tmp_if_expr_8 = (_Bool)1;

      else
        tmp_if_expr_8 = (signed int)icmp6->icmp6_type != 128 ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_8)
        return -1;

      struct in6_addr *CheckPing__1__1__2____a = (struct in6_addr *)&ip6->ip6_dst;
      struct in6_addr *__b = (struct in6_addr *)it;
      if(CheckPing__1__1__2____a->__in6_u.__u6_addr32[0l] == __b->__in6_u.__u6_addr32[0l])
        tmp_if_expr_10 = CheckPing__1__1__2____a->__in6_u.__u6_addr32[(signed long int)1] == __b->__in6_u.__u6_addr32[(signed long int)1] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_10 = (_Bool)0;
      if(tmp_if_expr_10)
        tmp_if_expr_11 = CheckPing__1__1__2____a->__in6_u.__u6_addr32[(signed long int)2] == __b->__in6_u.__u6_addr32[(signed long int)2] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_11 = (_Bool)0;
      if(tmp_if_expr_11)
        tmp_if_expr_12 = CheckPing__1__1__2____a->__in6_u.__u6_addr32[(signed long int)3] == __b->__in6_u.__u6_addr32[(signed long int)3] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_12 = (_Bool)0;
      tmp_statement_expression_9 = tmp_if_expr_12;
      if(!tmp_statement_expression_9)
        return -1;

      me = &ip6->ip6_src;
      it = &ip6->ip6_dst;
    }

    else
      if(!((signed int)icmp6->icmp6_type == 129))
        return -1;

    if(!((signed int)icmp6->icmp6_code == 0))
      return -1;

    else
    {
      signed long int return_value_time_13;
      return_value_time_13=time((signed long int *)(void *)0);
      signed int return_value_teredo_verify_pinghash_14;
      return_value_teredo_verify_pinghash_14=teredo_verify_pinghash((unsigned int)return_value_time_13, me, it, (const unsigned char *)&icmp6->icmp6_dataun.icmp6_un_data16[(signed long int)0]);
      return return_value_teredo_verify_pinghash_14;
    }
  }
}

// CountBubble
// file relay.c line 257
static signed int CountBubble(struct teredo_peer *peer, unsigned long int now)
{
  signed int res;
  if((signed int)peer->bubbles >= 1)
  {
    if((signed int)peer->bubbles >= 4)
    {
      if(!(now + -peer->last_tx >= 301ul))
        res = -1;

      else
      {
        peer->bubbles = (unsigned int)0;
        res = 0;
      }
    }

    else
      if(!(now + -peer->last_tx >= 3ul))
        res = 1;

      else
        res = 0;
  }

  else
    res = 0;
  if(res == 0)
  {
    peer->last_tx = now;
    peer->bubbles = (unsigned int)peer->bubbles + 1u;
  }

  return res;
}

// CountPing
// file relay.c line 220
static signed int CountPing(struct teredo_peer *peer, unsigned long int now)
{
  signed int res;
  if((signed int)peer->pings == 0)
    res = 0;

  else
    if((signed int)peer->pings >= 4)
      res = -1;

    else
      if(!((now + -((unsigned long int)peer->last_ping) & 511ul) >= 3ul))
        res = 1;

      else
        res = 0;
  if(res == 0)
  {
    peer->last_ping = (unsigned int)now;
    peer->pings = (unsigned int)peer->pings + 1u;
  }

  return res;
}

// IsBubble
// file packets.h line 48
static inline _Bool IsBubble(struct ip6_hdr *hdr)
{
  _Bool tmp_if_expr_1;
  if((signed int)hdr->ip6_ctlun.ip6_un1.ip6_un1_plen == 0)
    tmp_if_expr_1 = (signed int)hdr->ip6_ctlun.ip6_un1.ip6_un1_nxt == 59 ? (_Bool)1 : (_Bool)0;

  else
    tmp_if_expr_1 = (_Bool)0;
  return tmp_if_expr_1;
}

// IsClient
// file relay.c line 246
static inline _Bool IsClient(const struct teredo_tunnel *tunnel)
{
  return tunnel->maintenance != (struct teredo_maintenance *)(void *)0;
}

// IsValid
// file peerlist.h line 83
static inline _Bool IsValid(const struct teredo_peer *peer, unsigned long int now)
{
  return now - peer->last_rx <= (unsigned long int)30;
}

// SendBubbleFromDst
// file packets.h line 63
signed int SendBubbleFromDst(signed int fd, struct in6_addr *dst, _Bool indirect)
{
  unsigned int ip = (&((union teredo_addr *)dst)->teredo)->client_ip ^ 0xffffffff;
  unsigned short int port = (unsigned short int)((signed int)(&((union teredo_addr *)dst)->teredo)->client_port ^ 0xffff);
  struct in6_addr src;
  memcpy((void *)src.__in6_u.__u6_addr8, (const void *)"\0\0\0\0\0\0", (unsigned long int)8);
  teredo_get_nonce((unsigned int)0, ip, port, src.__in6_u.__u6_addr8 + (signed long int)8);
  src.__in6_u.__u6_addr8[(signed long int)8] = src.__in6_u.__u6_addr8[(signed long int)8] & (unsigned char)0xfc;
  if(!(indirect == (_Bool)0))
  {
    ip = (&((union teredo_addr *)dst)->teredo)->server_ip;
    port=htons((unsigned short int)3544);
  }

  signed int return_value_teredo_send_bubble_1;
  return_value_teredo_send_bubble_1=teredo_send_bubble(fd, ip, port, &src, dst);
  return return_value_teredo_send_bubble_1;
}

// SendPing
// file packets.h line 127
signed int SendPing(signed int fd, union teredo_addr *src, struct in6_addr *dst)
{
  /* tag-#anon#lST[lSYM#tag-ip6_hdr#'ip6'||lSYM#tag-icmp6_hdr#'icmp6'||lARR18{U8}_U8_'payload'||U16'_pad0'|] */
struct anonymous_26
{
  // ip6
  struct ip6_hdr ip6;
  // icmp6
  struct icmp6_hdr icmp6;
  // payload
  unsigned char payload[18l];
};

/* */
  ;
  struct anonymous_26 ping;
  ping.ip6.ip6_ctlun.ip6_un1.ip6_un1_flow=htonl((unsigned int)0x60000000);
  ping.ip6.ip6_ctlun.ip6_un1.ip6_un1_plen=htons((unsigned short int)(sizeof(struct icmp6_hdr) /*8ul*/  + (unsigned long int)(22 - 4)));
  ping.ip6.ip6_ctlun.ip6_un1.ip6_un1_nxt = (unsigned char)58;
  ping.ip6.ip6_ctlun.ip6_un1.ip6_un1_hlim = (unsigned char)128;
  ping.ip6.ip6_src = src->ip6;
  ping.ip6.ip6_dst = *dst;
  ping.icmp6.icmp6_type = (unsigned char)128;
  ping.icmp6.icmp6_code = (unsigned char)0;
  ping.icmp6.icmp6_cksum = (unsigned short int)0;
  signed long int return_value_time_1;
  return_value_time_1=time((signed long int *)(void *)0);
  teredo_get_pinghash((unsigned int)return_value_time_1, &ping.ip6.ip6_src, &ping.ip6.ip6_dst, (unsigned char *)&ping.icmp6.icmp6_dataun.icmp6_un_data16[(signed long int)0]);
  ping.icmp6.icmp6_cksum=icmp6_checksum_link1(&ping.ip6, &ping.icmp6);
  unsigned short int return_value_htons_2;
  return_value_htons_2=htons((unsigned short int)3544);
  signed int return_value_teredo_send_3;
  return_value_teredo_send_3=teredo_send(fd, (const void *)&ping, sizeof(struct ip6_hdr) /*40ul*/  + sizeof(struct icmp6_hdr) /*8ul*/  + (unsigned long int)(22 - 4), (&((union teredo_addr *)src)->teredo)->server_ip, return_value_htons_2);
  return return_value_teredo_send_3 > 0 ? 0 : -1;
}

// SetMapping
// file peerlist.h line 65
static inline void SetMapping(struct teredo_peer *peer, unsigned int ip, unsigned short int port)
{
  peer->mapped_addr = ip;
  peer->mapped_port = port;
}

// SetMappingFromPacket
// file relay.c line 296
static inline void SetMappingFromPacket(struct teredo_peer *peer, struct teredo_packet *p)
{
  SetMapping(peer, p->source_ipv4, p->source_port);
}

// TouchReceive
// file peerlist.h line 71
static inline void TouchReceive(struct teredo_peer *peer, unsigned long int now)
{
  peer->last_rx = now;
}

// TouchTransmit
// file peerlist.h line 76
static inline void TouchTransmit(struct teredo_peer *peer, unsigned long int now)
{
  peer->last_tx = now;
}

// checkTimeDrift
// file maintain.c line 200
static _Bool checkTimeDrift(struct timespec *ts)
{
  struct timespec now;
  gettime(&now);
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_2;
  if(!(ts->tv_sec >= now.tv_sec))
    tmp_if_expr_3 = (_Bool)1;

  else
  {
    if(now.tv_sec == ts->tv_sec)
      tmp_if_expr_2 = now.tv_nsec > ts->tv_nsec ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_2 = (_Bool)0;
    tmp_if_expr_3 = tmp_if_expr_2 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_3)
  {
    char *return_value_dgettext_1;
    return_value_dgettext_1=dgettext("miredo", "Too much time drift. Resynchronizing.");
    syslog(4, return_value_dgettext_1);
    *ts = now;
    return (_Bool)0;
  }

  return (_Bool)1;
}

// cleanup_unlock
// file maintain.c line 218
static void cleanup_unlock(void *o)
{
  pthread_mutex_unlock((union anonymous_24 *)o);
}

// client_thread
// file mire.c line 202
static signed int client_thread(signed int fd)
{
  do
  {
    struct teredo_packet p;
    signed long int plen;
    plen=recv_packet(fd, &p);
    if(!(plen == -1l))
      switch((signed int)p.ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt)
      {
        case 58:
        {
          process_icmpv6(fd, p.ip6, (unsigned long int)plen, p.source_ipv4, p.source_port);
          break;
        }
        case 59:

        case 43:
          break;
        default:
          process_unknown(fd, p.ip6, (unsigned long int)plen, p.source_ipv4, p.source_port);
      }

  }
  while((_Bool)1);
}

// clock_tick
// file clock.c line 49
static void clock_tick(union sigval val)
{
  struct clock_data_t *context = (struct clock_data_t *)val.sival_ptr;
  signed int orun;
  orun=timer_getoverrun(context->handle);
  context->value = context->value + (unsigned long int)(1 + orun);
  if(orun == 2147483647)
    context->active = (_Bool)0;

  if(context->active == (_Bool)0)
  {
    struct itimerspec it = { .it_interval={ .tv_sec=0l, .tv_nsec=0l }, .it_value={ .tv_sec=(signed long int)0, .tv_nsec=(signed long int)0 } };
    timer_settime(context->handle, 0, &it, (struct itimerspec *)(void *)0);
  }

  context->active = (_Bool)0;
}

// closefrom
// file closefrom.c line 39
signed int closefrom(signed int fd)
{
  struct rlimit lim;
  unsigned int found = (unsigned int)0;
  signed int saved_errno;
  signed int return_value_getrlimit_1;
  return_value_getrlimit_1=getrlimit((enum __rlimit_resource)RLIMIT_NOFILE, &lim);
  signed int tmp_post_3;
  signed int return_value_close_4;
  if(!(return_value_getrlimit_1 == 0))
    return -1;

  else
  {
    signed int *return_value___errno_location_2;
    return_value___errno_location_2=__errno_location();
    saved_errno = *return_value___errno_location_2;
    if(lim.rlim_max >= 1025ul)
    {
      if(lim.rlim_cur >= 1025ul)
        lim.rlim_cur = (unsigned long int)1024;

      lim.rlim_max = (unsigned long int)1024;
      setrlimit((enum __rlimit_resource)RLIMIT_NOFILE, &lim);
    }

    while(!((unsigned long int)(unsigned int)fd >= lim.rlim_max))
    {
      tmp_post_3 = fd;
      fd = fd + 1;
      return_value_close_4=close(tmp_post_3);
      if(return_value_close_4 == 0)
        found = found + 1u;

    }
    if(found == 0u)
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      *return_value___errno_location_5 = 9;
      return -1;
    }

    signed int *return_value___errno_location_6;
    return_value___errno_location_6=__errno_location();
    *return_value___errno_location_6 = saved_errno;
    return 0;
  }
}

// do_maintenance
// file maintain.c line 403
static void * do_maintenance(void *opaque)
{
  maintenance_thread((struct teredo_maintenance *)opaque);
}

// garbage_collector
// file peerlist.c line 228
static void * garbage_collector(void *data)
{
  struct teredo_peerlist *l = (struct teredo_peerlist *)data;
  signed int return_value_clock_nanosleep_1;
  do
  {
    struct timespec delay = { .tv_sec=(signed long int)l->expiration, .tv_nsec=0l };
    do
    {
      return_value_clock_nanosleep_1=clock_nanosleep(0, 0, &delay, &delay);
      if(return_value_clock_nanosleep_1 == 0)
        break;

    }
    while((_Bool)1);
    signed int state;
    pthread_setcancelstate(1, &state);
    pthread_mutex_lock(&l->lock);
    struct teredo_listitem *p = l->old;
    for( ; !(p == ((struct teredo_listitem *)NULL)); p = p->next)
    {
      signed int Rc_int;
      struct J_UDY_ERROR_STRUCT J_Error;
      Rc_int=JudyHSDel(&l->PJHSArray, (void *)(unsigned char *)&p->key, (unsigned long int)16, &J_Error);
      if(Rc_int == -1)
      {
        fprintf(stderr, "File '%s', line %d: %s(), JU_ERRNO_* == %d, ID == %d\n", (const void *)"peerlist.c", 248, (const void *)"JudyHSDel", (&J_Error)->je_Errno, (&J_Error)->je_ErrID);
        exit(1);
      }

      l->left = l->left + 1u;
    }
    struct teredo_listitem *old = l->old;
    l->old = l->recent;
    l->recent = (struct teredo_listitem *)(void *)0;
    if(!(l->old == ((struct teredo_listitem *)NULL)))
      l->old->pprev = &l->old;

    pthread_mutex_unlock(&l->lock);
    sched_yield();
    listitem_recdestroy(old);
    pthread_setcancelstate(state, (signed int *)(void *)0);
    sched_yield();
  }
  while((_Bool)1);
}

// getipv4byname
// file maintain.c line 107
static signed int getipv4byname(const char * restrict name, unsigned int * restrict ipv4)
{
  struct addrinfo hints = { .ai_flags=0, .ai_family=2, .ai_socktype=2, .ai_protocol=0,
    .ai_addrlen=0u, .ai_addr=((struct sockaddr *)NULL), .ai_canonname=((char *)NULL),
    .ai_next=((struct addrinfo *)NULL) };
  struct addrinfo *res;
  signed int val;
  val=getaddrinfo(name, (const char *)(void *)0, &hints, &res);
  if(!(val == 0))
    return val;

  else
  {
    *ipv4 = ((struct sockaddr_in *)res->ai_addr)->sin_addr.s_addr;
    freeaddrinfo(res);
    return 0;
  }
}

// gettime
// file maintain.c line 60
static inline void gettime(struct timespec *now)
{
  signed int return_value_clock_gettime_1;
  return_value_clock_gettime_1=clock_gettime(1, now);
  if(!(return_value_clock_gettime_1 == 0))
    clock_gettime(0, now);

}

// icmp6_checksum
// file ../libteredo/checksum.h line 34
static inline unsigned short int icmp6_checksum(struct ip6_hdr *ip6, struct icmp6_hdr *icmp6)
{
  struct iovec iov;
  unsigned short int return_value_ntohs_1;
  return_value_ntohs_1=ntohs(ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);
  iov = (struct iovec){ .iov_base=(void *)icmp6, .iov_len=(unsigned long int)return_value_ntohs_1 };
  unsigned short int return_value_teredo_cksum_2;
  return_value_teredo_cksum_2=teredo_cksum((const void *)&ip6->ip6_src, (const void *)&ip6->ip6_dst, (unsigned char)58, &iov, (unsigned long int)1);
  return return_value_teredo_cksum_2;
}

// icmp6_checksum_link1
// file checksum.h line 34
static inline unsigned short int icmp6_checksum_link1(struct ip6_hdr *ip6_link1, struct icmp6_hdr *icmp6_link1)
{
  struct iovec iov_link1;
  unsigned short int return_value_ntohs_1_link1;
  return_value_ntohs_1_link1=ntohs(ip6_link1->ip6_ctlun.ip6_un1.ip6_un1_plen);
  iov_link1 = (struct iovec){ .iov_base=(void *)icmp6_link1, .iov_len=(unsigned long int)return_value_ntohs_1_link1 };
  unsigned short int return_value_teredo_cksum_2_link1;
  return_value_teredo_cksum_2_link1=teredo_cksum((const void *)&ip6_link1->ip6_src, (const void *)&ip6_link1->ip6_dst, (unsigned char)58, &iov_link1, (unsigned long int)1);
  return return_value_teredo_cksum_2_link1;
}

// in6_matches_teredo_client
// file teredo.h line 95
static inline signed int in6_matches_teredo_client(struct in6_addr *ip6, unsigned int ip, unsigned short int port)
{
  _Bool tmp_if_expr_1;
  if(!((0xffffffff ^ ((union teredo_addr *)ip6)->teredo.client_ip ^ ip) == 0u))
    tmp_if_expr_1 = (_Bool)1;

  else
    tmp_if_expr_1 = ((signed int)port ^ (signed int)(&((union teredo_addr *)ip6)->teredo)->client_port ^ 0xffff) != 0 ? (_Bool)1 : (_Bool)0;
  return (signed int)!tmp_if_expr_1;
}

// in_cksum
// file teredo.c line 338
static unsigned short int in_cksum(struct iovec *iov, unsigned long int n)
{
  unsigned int sum = (unsigned int)0;
  /* tag-#anon#lUN[U16'word'||lARR2{U8}_U8_'bytes'|] */
union anonymous_20
{
  // word
  unsigned short int word;
  // bytes
  unsigned char bytes[2l];
};

/* */
  ;
  union anonymous_20 w;
  _Bool odd = (_Bool)0;
  const unsigned char *tmp_post_1;
  const unsigned char *tmp_post_2;
  while(n >= 1ul)
  {
    const unsigned char *ptr = (const unsigned char *)iov->iov_base;
    unsigned long int len = iov->iov_len;
    for( ; len >= 1ul; len = len - 1ul)
    {
      if(!(odd == (_Bool)0))
      {
        tmp_post_1 = ptr;
        ptr = ptr + 1l;
        w.bytes[(signed long int)1] = *tmp_post_1;
        sum = sum + (unsigned int)w.word;
        if(sum >= 65536u)
          sum = sum - (unsigned int)0xffff;

      }

      else
      {
        tmp_post_2 = ptr;
        ptr = ptr + 1l;
        w.bytes[(signed long int)0] = *tmp_post_2;
      }
      odd = !(odd != (_Bool)0);
    }
    iov = iov + 1l;
    n = n - 1ul;
  }
  if(!(odd == (_Bool)0))
  {
    w.bytes[(signed long int)1] = (unsigned char)0;
    sum = sum + (unsigned int)w.word;
    if(sum >= 65536u)
      sum = sum - (unsigned int)0xffff;

  }

  return (unsigned short int)(sum ^ (unsigned int)0xffff);
}

// is_ipv4_global_unicast
// file v4global.h line 34
signed int is_ipv4_global_unicast(unsigned int ip)
{
  unsigned int return_value_htonl_7;
  return_value_htonl_7=htonl(0x80000000);
  _Bool tmp_if_expr_4;
  unsigned int return_value_htonl_3;
  _Bool tmp_if_expr_6;
  unsigned int return_value_htonl_5;
  if((return_value_htonl_7 & ip) == 0u)
  {
    unsigned int return_value_htonl_1;
    return_value_htonl_1=htonl(0xff000000);
    ip = ip & return_value_htonl_1;
    unsigned int return_value_htonl_2;
    return_value_htonl_2=htonl((unsigned int)0x0a000000);
    if(!(ip == return_value_htonl_2))
    {
      return_value_htonl_3=htonl((unsigned int)0x7f000000);
      tmp_if_expr_4 = ip != return_value_htonl_3 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
    {
      return_value_htonl_5=htonl((unsigned int)0x00000000);
      tmp_if_expr_6 = ip != return_value_htonl_5 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_6 = (_Bool)0;
    return (signed int)tmp_if_expr_6;
  }

  unsigned int return_value_htonl_13;
  return_value_htonl_13=htonl((unsigned int)0x40000000);
  _Bool tmp_if_expr_12;
  unsigned int return_value_htonl_10;
  unsigned int return_value_htonl_11;
  if((return_value_htonl_13 & ip) == 0u)
  {
    unsigned int return_value_htonl_8;
    return_value_htonl_8=htonl(0xffff0000);
    unsigned int return_value_htonl_9;
    return_value_htonl_9=htonl(0xa9fe0000);
    if(!((return_value_htonl_8 & ip) == return_value_htonl_9))
    {
      return_value_htonl_10=htonl(0xfff00000);
      return_value_htonl_11=htonl(0xac100000);
      tmp_if_expr_12 = (ip & return_value_htonl_10) != return_value_htonl_11 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_12 = (_Bool)0;
    return (signed int)tmp_if_expr_12;
  }

  unsigned int return_value_htonl_19;
  return_value_htonl_19=htonl((unsigned int)0x20000000);
  _Bool tmp_if_expr_18;
  unsigned int return_value_htonl_16;
  unsigned int return_value_htonl_17;
  if((return_value_htonl_19 & ip) == 0u)
  {
    unsigned int return_value_htonl_14;
    return_value_htonl_14=htonl(0xffff0000);
    unsigned int return_value_htonl_15;
    return_value_htonl_15=htonl(0xc0a80000);
    if(!((return_value_htonl_14 & ip) == return_value_htonl_15))
    {
      return_value_htonl_16=htonl(0xffffff00);
      return_value_htonl_17=htonl(0xc0586200);
      tmp_if_expr_18 = (ip & return_value_htonl_16) != return_value_htonl_17 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_18 = (_Bool)0;
    return (signed int)tmp_if_expr_18;
  }

  unsigned int return_value_htonl_20;
  return_value_htonl_20=htonl((unsigned int)0x10000000);
  if((return_value_htonl_20 & ip) == 0u)
    return 0;

  else
  {
    unsigned int return_value_htonl_21;
    return_value_htonl_21=htonl(0xffffffff);
    return (signed int)(ip != return_value_htonl_21);
  }
}

// listitem_create
// file peerlist.c line 181
static inline struct teredo_listitem * listitem_create(void)
{
  struct teredo_listitem *entry;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct teredo_listitem) /*72ul*/ );
  entry = (struct teredo_listitem *)return_value_malloc_1;
  if(!(entry == ((struct teredo_listitem *)NULL)))
    teredo_peer_init(&entry->peer);

  return entry;
}

// listitem_destroy
// file peerlist.c line 190
static inline void listitem_destroy(struct teredo_listitem *entry)
{
  teredo_peer_destroy(&entry->peer);
  free((void *)entry);
}

// listitem_recdestroy
// file peerlist.c line 197
static void listitem_recdestroy(struct teredo_listitem *entry)
{
  while(!(entry == ((struct teredo_listitem *)NULL)))
  {
    struct teredo_listitem *buf = entry->next;
    listitem_destroy(entry);
    entry = buf;
  }
}

// main
// file mire.c line 243
signed int main(signed int argc, char **argv)
{
  signed int c;
  static struct option opts[3l] = { { .name="help", .has_arg=0, .flag=(signed int *)(void *)0, .val=104 },
    { .name="version", .has_arg=0, .flag=(signed int *)(void *)0, .val=86 },
    { .name=(const char *)(void *)0, .has_arg=0, .flag=(signed int *)(void *)0,
    .val=0 } };
  c=getopt_long(argc, argv, "hV", opts, (signed int *)(void *)0);
  signed int return_value_usage_1;
  signed int return_value_version_2;
  if(!(c == -1))
    switch(c)
    {
      case 104:
      {
        return_value_usage_1=usage(argv[(signed long int)0]);
        return return_value_usage_1;
      }
      case 86:
      {
        return_value_version_2=version();
        return return_value_version_2;
      }
      default:
        return 1;
    }

  signed int socks[2l] = { -1, -1 };
  signed int retval = -1;
  unsigned long int thserv;
  unsigned short int return_value_htons_3;
  return_value_htons_3=htons((unsigned short int)3544);
  socks[(signed long int)0]=teredo_socket((unsigned int)0, return_value_htons_3);
  if(!(socks[0l] == -1))
  {
    unsigned short int return_value_htons_4;
    return_value_htons_4=htons((unsigned short int)(3544 + 1));
    socks[(signed long int)1]=teredo_socket((unsigned int)0, return_value_htons_4);
    if(!(socks[1l] == -1))
    {
      signed int *return_value___errno_location_5;
      return_value___errno_location_5=__errno_location();
      *return_value___errno_location_5=pthread_create(&thserv, (const union pthread_attr_t *)(void *)0, server_thread, (void *)socks);
      signed int *return_value___errno_location_7;
      return_value___errno_location_7=__errno_location();
      if(*return_value___errno_location_7 == 0)
      {
        signed int return_value_client_thread_6;
        return_value_client_thread_6=client_thread(socks[(signed long int)1]);
        retval = -return_value_client_thread_6;
      }

      else
        perror("pthread_create");
      teredo_close(socks[(signed long int)1]);
    }

    else
      perror("teredo_socket");
    teredo_close(socks[(signed long int)0]);
  }

  else
    perror("teredo_socket(server)");
  return retval;
  return 0;
}

// maintenance_recv
// file maintain.c line 132
static signed int maintenance_recv(const struct teredo_packet * restrict packet, unsigned int server_ip, const unsigned char * restrict nonce, _Bool cone, struct teredo_state * restrict state)
{
  signed int return_value_memcmp_1;
  return_value_memcmp_1=memcmp((const void *)packet->auth_nonce, (const void *)nonce, (unsigned long int)8);
  _Bool tmp_if_expr_4;
  if(!(return_value_memcmp_1 == 0))
    return 1;

  else
  {
    if(!(packet->auth_fail == (_Bool)0))
    {
      char *return_value_dgettext_2;
      return_value_dgettext_2=dgettext("miredo", "Authentication with server failed.");
      syslog(3, return_value_dgettext_2);
      return 13;
    }

    signed int return_value_teredo_parse_ra_3;
    return_value_teredo_parse_ra_3=teredo_parse_ra(packet, &state->addr, cone, &state->mtu);
    if(!(return_value_teredo_parse_ra_3 == 0))
      tmp_if_expr_4 = (_Bool)1;

    else
      tmp_if_expr_4 = state->addr.teredo.server_ip != server_ip ? (_Bool)1 : (_Bool)0;
    if(tmp_if_expr_4)
      return 22;

    else
    {
      state->ipv4 = packet->dest_ipv4;
      return 0;
    }
  }
}

// maintenance_thread
// file maintain.c line 242
static inline void maintenance_thread(struct teredo_maintenance *m)
{
  struct timespec deadline = { .tv_sec=(signed long int)0, .tv_nsec=(signed long int)0 };
  struct teredo_state *c_state = &m->state.state;
  unsigned int server_ip = (unsigned int)0;
  unsigned int count = (unsigned int)0;
  /* #anon_enum_TERR_NONE=0_TERR_BLACKHOLE=1 */
enum anonymous_5 { TERR_NONE=0, TERR_BLACKHOLE=1 };

/* */
  ;
  enum anonymous_5 last_error = (enum anonymous_5)TERR_NONE;
  pthread_mutex_lock(&m->inner);
  struct anonymous_16 __cancel_buf;
  void (*__cancel_routine)(void *) = cleanup_unlock;
  void *__cancel_arg = (void *)&m->inner;
  signed int __not_first_call;
  __not_first_call=__sigsetjmp((struct __jmp_buf_tag *)(void *)__cancel_buf.__cancel_jmp_buf, 0);
  if(!((signed long int)__not_first_call == 0l))
  {
    __cancel_routine(__cancel_arg);
    __pthread_unwind_next(&__cancel_buf);
  }

  __pthread_register_cancel(&__cancel_buf);

__CPROVER_DUMP_L3:
  ;
  signed int return_value_is_ipv4_global_unicast_4;
  _Bool return_value_checkTimeDrift_5;
  _Bool tmp_statement_expression_10;
  _Bool tmp_if_expr_11;
  _Bool tmp_if_expr_12;
  _Bool tmp_if_expr_13;
  _Bool tmp_if_expr_19;
  _Bool tmp_statement_expression_15;
  _Bool tmp_if_expr_16;
  _Bool tmp_if_expr_17;
  _Bool tmp_if_expr_18;
  _Bool tmp_if_expr_20;
  while((_Bool)1)
  {
    if(server_ip == 0u)
    {
      signed int val;
      val=getipv4byname(m->server, &server_ip);
      gettime(&deadline);
      if(!(val == 0))
      {
        char *return_value_dgettext_1;
        return_value_dgettext_1=dgettext("miredo", "Cannot resolve Teredo server address \"%s\": %s");
        const char *return_value_gai_strerror_2;
        return_value_gai_strerror_2=gai_strerror(val);
        syslog(3, return_value_dgettext_1, m->server, return_value_gai_strerror_2);
      }

      else
      {
        return_value_is_ipv4_global_unicast_4=is_ipv4_global_unicast(server_ip);
        if(return_value_is_ipv4_global_unicast_4 == 0)
        {
          char *return_value_dgettext_3;
          return_value_dgettext_3=dgettext("miredo", "Teredo server has a non global IPv4 address.");
          syslog(3, return_value_dgettext_3);
        }

        else
        {
          c_state->addr.teredo.server_ip = server_ip;
          m->state.cb(c_state, m->state.opaque);
        }
      }
      deadline.tv_sec = deadline.tv_sec + (signed long int)m->restart_delay;
      server_ip = (unsigned int)0;
      wait_reply_ignore(m, &deadline);
      goto __CPROVER_DUMP_L3;
    }

    do
    {
      deadline.tv_sec = deadline.tv_sec + (signed long int)m->qualification_delay;
      return_value_checkTimeDrift_5=checkTimeDrift(&deadline);
    }
    while(return_value_checkTimeDrift_5 == (_Bool)0);
    unsigned char nonce[8l];
    unsigned short int return_value_htons_6;
    return_value_htons_6=htons((unsigned short int)3544);
    teredo_get_nonce((unsigned int)deadline.tv_sec, server_ip, return_value_htons_6, nonce);
    teredo_send_rs(m->fd, server_ip, nonce, (_Bool)0);
    signed int maintenance_thread__1__1__2__1__1__val = 0;
    struct teredo_state newst;
    newst.mtu = (unsigned short int)1280;
    newst.up = (_Bool)1;
    do
    {
      maintenance_thread__1__1__2__1__1__val=wait_reply(m, &deadline);
      if(maintenance_thread__1__1__2__1__1__val == 0)
      {
        maintenance_thread__1__1__2__1__1__val=maintenance_recv(m->incoming, server_ip, nonce, (_Bool)0, &newst);
        m->incoming = (const struct teredo_packet *)(void *)0;
        pthread_cond_signal(&m->processed);
      }

    }
    while(!(maintenance_thread__1__1__2__1__1__val == 0) && !(maintenance_thread__1__1__2__1__1__val == 110));
    unsigned int delay = (unsigned int)0;
    if(!(maintenance_thread__1__1__2__1__1__val == 0))
    {
      count = count + 1u;
      if(count >= m->qualification_retries)
      {
        count = (unsigned int)0;
        if(!((signed int)last_error == TERR_BLACKHOLE))
        {
          char *return_value_dgettext_7;
          return_value_dgettext_7=dgettext("miredo", "No reply from Teredo server");
          syslog(6, return_value_dgettext_7);
          last_error = (enum anonymous_5)TERR_BLACKHOLE;
        }

        if(!(c_state->up == (_Bool)0))
        {
          char *return_value_dgettext_8;
          return_value_dgettext_8=dgettext("miredo", "Lost Teredo connectivity");
          syslog(5, return_value_dgettext_8);
          c_state->up = (_Bool)0;
          m->state.cb(c_state, m->state.opaque);
          server_ip = (unsigned int)0;
        }

        delay = m->restart_delay;
      }

    }

    else
    {
      count = (unsigned int)0;
      newst.addr.teredo.flags = c_state->addr.teredo.flags;
      struct in6_addr *__a = (struct in6_addr *)&c_state->addr.ip6;
      struct in6_addr *__b = (struct in6_addr *)&newst.addr.ip6;
      if(__a->__in6_u.__u6_addr32[0l] == __b->__in6_u.__u6_addr32[0l])
        tmp_if_expr_11 = __a->__in6_u.__u6_addr32[(signed long int)1] == __b->__in6_u.__u6_addr32[(signed long int)1] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_11 = (_Bool)0;
      if(tmp_if_expr_11)
        tmp_if_expr_12 = __a->__in6_u.__u6_addr32[(signed long int)2] == __b->__in6_u.__u6_addr32[(signed long int)2] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_12 = (_Bool)0;
      if(tmp_if_expr_12)
        tmp_if_expr_13 = __a->__in6_u.__u6_addr32[(signed long int)3] == __b->__in6_u.__u6_addr32[(signed long int)3] ? (_Bool)1 : (_Bool)0;

      else
        tmp_if_expr_13 = (_Bool)0;
      tmp_statement_expression_10 = tmp_if_expr_13;
      if(!tmp_statement_expression_10)
      {
        unsigned short int f;
        f=teredo_get_flbits((unsigned int)deadline.tv_sec);
        unsigned short int return_value_htons_9;
        return_value_htons_9=htons((unsigned short int)0x3cff);
        newst.addr.teredo.flags = (unsigned short int)((signed int)f & (signed int)return_value_htons_9);
      }

      if(c_state->up == (_Bool)0)
        tmp_if_expr_19 = (_Bool)1;

      else
      {
        struct in6_addr *maintenance_thread__1__1__2__1__1__4__3____a = (struct in6_addr *)&c_state->addr.ip6;
        struct in6_addr *maintenance_thread__1__1__2__1__1__4__3____b = (struct in6_addr *)&newst.addr.ip6;
        if(maintenance_thread__1__1__2__1__1__4__3____a->__in6_u.__u6_addr32[0l] == maintenance_thread__1__1__2__1__1__4__3____b->__in6_u.__u6_addr32[0l])
          tmp_if_expr_16 = maintenance_thread__1__1__2__1__1__4__3____a->__in6_u.__u6_addr32[(signed long int)1] == maintenance_thread__1__1__2__1__1__4__3____b->__in6_u.__u6_addr32[(signed long int)1] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_16 = (_Bool)0;
        if(tmp_if_expr_16)
          tmp_if_expr_17 = maintenance_thread__1__1__2__1__1__4__3____a->__in6_u.__u6_addr32[(signed long int)2] == maintenance_thread__1__1__2__1__1__4__3____b->__in6_u.__u6_addr32[(signed long int)2] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_17 = (_Bool)0;
        if(tmp_if_expr_17)
          tmp_if_expr_18 = maintenance_thread__1__1__2__1__1__4__3____a->__in6_u.__u6_addr32[(signed long int)3] == maintenance_thread__1__1__2__1__1__4__3____b->__in6_u.__u6_addr32[(signed long int)3] ? (_Bool)1 : (_Bool)0;

        else
          tmp_if_expr_18 = (_Bool)0;
        tmp_statement_expression_15 = tmp_if_expr_18;
        tmp_if_expr_19 = !tmp_statement_expression_15 ? (_Bool)1 : (_Bool)0;
      }
      if(tmp_if_expr_19)
        tmp_if_expr_20 = (_Bool)1;

      else
        tmp_if_expr_20 = c_state->mtu != newst.mtu ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_20)
      {
        memcpy((void *)c_state, (const void *)&newst, sizeof(struct teredo_state) /*24ul*/ );
        char *return_value_dgettext_14;
        return_value_dgettext_14=dgettext("miredo", "New Teredo address/MTU");
        syslog(5, return_value_dgettext_14);
        m->state.cb(c_state, m->state.opaque);
      }

      last_error = (enum anonymous_5)TERR_NONE;
      delay = m->refresh_delay;
    }
    if(!(delay == 0u))
    {
      deadline.tv_sec = deadline.tv_sec - (signed long int)m->qualification_delay;
      deadline.tv_sec = deadline.tv_sec + (signed long int)delay;
      wait_reply_ignore(m, &deadline);
    }

  }
  __pthread_unregister_cancel(&__cancel_buf);
  __cancel_routine(__cancel_arg);
}

// md5_append
// file md5.h line 82
void md5_append(struct md5_state_s *pms, const unsigned char *data, signed int nbytes)
{
  const unsigned char *p = data;
  signed int left = nbytes;
  signed int offset = (signed int)(pms->count[(signed long int)0] >> 3 & (unsigned int)63);
  unsigned int nbits = (unsigned int)(nbytes << 3);
  if(nbytes >= 1)
  {
    pms->count[(signed long int)1] = pms->count[(signed long int)1] + (unsigned int)(nbytes >> 29);
    pms->count[(signed long int)0] = pms->count[(signed long int)0] + nbits;
    if(!(pms->count[0l] >= nbits))
      pms->count[(signed long int)1] = pms->count[(signed long int)1] + 1u;

    if(!(offset == 0))
    {
      signed int copy = offset + nbytes > 64 ? 64 - offset : nbytes;
      memcpy((void *)(pms->buf + (signed long int)offset), (const void *)p, (unsigned long int)copy);
      if(!(copy + offset >= 64))
        goto __CPROVER_DUMP_L7;

      p = p + (signed long int)copy;
      left = left - copy;
      md5_process(pms, pms->buf);
    }

    for( ; left >= 64; left = left - 64)
    {
      md5_process(pms, p);
      p = p + (signed long int)64;
    }
    if(!(left == 0))
      memcpy((void *)pms->buf, (const void *)p, (unsigned long int)left);

  }


__CPROVER_DUMP_L7:
  ;
}

// md5_finish
// file md5.h line 85
void md5_finish(struct md5_state_s *pms, unsigned char *digest)
{
  unsigned char data[8l];
  signed int i = 0;
  for( ; !(i >= 8); i = i + 1)
    data[(signed long int)i] = (unsigned char)(pms->count[(signed long int)(i >> 2)] >> ((i & 3) << 3));
  static const unsigned char pad[64l] = { (const unsigned char)0x80, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0, (const unsigned char)0 };
  md5_append(pms, pad, (signed int)(((unsigned int)55 - (pms->count[(signed long int)0] >> 3) & (unsigned int)63) + (unsigned int)1));
  md5_append(pms, data, 8);
  i = 0;
  for( ; !(i >= 16); i = i + 1)
    digest[(signed long int)i] = (unsigned char)(pms->abcd[(signed long int)(i >> 2)] >> ((i & 3) << 3));
}

// md5_init
// file md5.h line 79
void md5_init(struct md5_state_s *pms)
{
  pms->count[(signed long int)1] = (unsigned int)0;
  pms->count[(signed long int)0] = pms->count[(signed long int)1];
  pms->abcd[(signed long int)0] = (unsigned int)0x67452301;
  pms->abcd[(signed long int)1] = (unsigned int)~0 ^ (unsigned int)0x10325476;
  pms->abcd[(signed long int)2] = (unsigned int)~0 ^ (unsigned int)0x67452301;
  pms->abcd[(signed long int)3] = (unsigned int)0x10325476;
}

// md5_process
// file md5.c line 147
static void md5_process(struct md5_state_s *pms, const unsigned char *data)
{
  unsigned int a = pms->abcd[(signed long int)0];
  unsigned int b = pms->abcd[(signed long int)1];
  unsigned int c = pms->abcd[(signed long int)2];
  unsigned int d = pms->abcd[(signed long int)3];
  unsigned int t;
  unsigned int xbuf[16l];
  const unsigned int *X;
  if((data - ((const unsigned char *)NULL) & 3l) == 0l)
    X = (const unsigned int *)data;

  else
  {
    memcpy((void *)xbuf, (const void *)data, (unsigned long int)64);
    X = xbuf;
  }
  t = a + (b & c | ~b & d) + X[(signed long int)0] + ((unsigned int)~0 ^ (unsigned int)0x28955b87);
  a = (t << 7 | t >> 32 - 7) + b;
  t = d + (a & b | ~a & c) + X[(signed long int)1] + ((unsigned int)~0 ^ (unsigned int)0x173848a9);
  d = (t << 12 | t >> 32 - 12) + a;
  t = c + (d & a | ~d & b) + X[(signed long int)2] + (unsigned int)0x242070db;
  c = (t << 17 | t >> 32 - 17) + d;
  t = b + (c & d | ~c & a) + X[(signed long int)3] + ((unsigned int)~0 ^ (unsigned int)0x3e423111);
  b = (t << 22 | t >> 32 - 22) + c;
  t = a + (b & c | ~b & d) + X[(signed long int)4] + ((unsigned int)~0 ^ (unsigned int)0x0a83f050);
  a = (t << 7 | t >> 32 - 7) + b;
  t = d + (a & b | ~a & c) + X[(signed long int)5] + (unsigned int)0x4787c62a;
  d = (t << 12 | t >> 32 - 12) + a;
  t = c + (d & a | ~d & b) + X[(signed long int)6] + ((unsigned int)~0 ^ (unsigned int)0x57cfb9ec);
  c = (t << 17 | t >> 32 - 17) + d;
  t = b + (c & d | ~c & a) + X[(signed long int)7] + ((unsigned int)~0 ^ (unsigned int)0x02b96afe);
  b = (t << 22 | t >> 32 - 22) + c;
  t = a + (b & c | ~b & d) + X[(signed long int)8] + (unsigned int)0x698098d8;
  a = (t << 7 | t >> 32 - 7) + b;
  t = d + (a & b | ~a & c) + X[(signed long int)9] + ((unsigned int)~0 ^ (unsigned int)0x74bb0850);
  d = (t << 12 | t >> 32 - 12) + a;
  t = c + (d & a | ~d & b) + X[(signed long int)10] + ((unsigned int)~0 ^ (unsigned int)0x0000a44e);
  c = (t << 17 | t >> 32 - 17) + d;
  t = b + (c & d | ~c & a) + X[(signed long int)11] + ((unsigned int)~0 ^ (unsigned int)0x76a32841);
  b = (t << 22 | t >> 32 - 22) + c;
  t = a + (b & c | ~b & d) + X[(signed long int)12] + (unsigned int)0x6b901122;
  a = (t << 7 | t >> 32 - 7) + b;
  t = d + (a & b | ~a & c) + X[(signed long int)13] + ((unsigned int)~0 ^ (unsigned int)0x02678e6c);
  d = (t << 12 | t >> 32 - 12) + a;
  t = c + (d & a | ~d & b) + X[(signed long int)14] + ((unsigned int)~0 ^ (unsigned int)0x5986bc71);
  c = (t << 17 | t >> 32 - 17) + d;
  t = b + (c & d | ~c & a) + X[(signed long int)15] + (unsigned int)0x49b40821;
  b = (t << 22 | t >> 32 - 22) + c;
  t = a + (b & d | c & ~d) + X[(signed long int)1] + ((unsigned int)~0 ^ (unsigned int)0x09e1da9d);
  a = (t << 5 | t >> 32 - 5) + b;
  t = d + (a & c | b & ~c) + X[(signed long int)6] + ((unsigned int)~0 ^ (unsigned int)0x3fbf4cbf);
  d = (t << 9 | t >> 32 - 9) + a;
  t = c + (d & b | a & ~b) + X[(signed long int)11] + (unsigned int)0x265e5a51;
  c = (t << 14 | t >> 32 - 14) + d;
  t = b + (c & a | d & ~a) + X[(signed long int)0] + ((unsigned int)~0 ^ (unsigned int)0x16493855);
  b = (t << 20 | t >> 32 - 20) + c;
  t = a + (b & d | c & ~d) + X[(signed long int)5] + ((unsigned int)~0 ^ (unsigned int)0x29d0efa2);
  a = (t << 5 | t >> 32 - 5) + b;
  t = d + (a & c | b & ~c) + X[(signed long int)10] + (unsigned int)0x02441453;
  d = (t << 9 | t >> 32 - 9) + a;
  t = c + (d & b | a & ~b) + X[(signed long int)15] + ((unsigned int)~0 ^ (unsigned int)0x275e197e);
  c = (t << 14 | t >> 32 - 14) + d;
  t = b + (c & a | d & ~a) + X[(signed long int)4] + ((unsigned int)~0 ^ (unsigned int)0x182c0437);
  b = (t << 20 | t >> 32 - 20) + c;
  t = a + (b & d | c & ~d) + X[(signed long int)9] + (unsigned int)0x21e1cde6;
  a = (t << 5 | t >> 32 - 5) + b;
  t = d + (a & c | b & ~c) + X[(signed long int)14] + ((unsigned int)~0 ^ (unsigned int)0x3cc8f829);
  d = (t << 9 | t >> 32 - 9) + a;
  t = c + (d & b | a & ~b) + X[(signed long int)3] + ((unsigned int)~0 ^ (unsigned int)0x0b2af278);
  c = (t << 14 | t >> 32 - 14) + d;
  t = b + (c & a | d & ~a) + X[(signed long int)8] + (unsigned int)0x455a14ed;
  b = (t << 20 | t >> 32 - 20) + c;
  t = a + (b & d | c & ~d) + X[(signed long int)13] + ((unsigned int)~0 ^ (unsigned int)0x561c16fa);
  a = (t << 5 | t >> 32 - 5) + b;
  t = d + (a & c | b & ~c) + X[(signed long int)2] + ((unsigned int)~0 ^ (unsigned int)0x03105c07);
  d = (t << 9 | t >> 32 - 9) + a;
  t = c + (d & b | a & ~b) + X[(signed long int)7] + (unsigned int)0x676f02d9;
  c = (t << 14 | t >> 32 - 14) + d;
  t = b + (c & a | d & ~a) + X[(signed long int)12] + ((unsigned int)~0 ^ (unsigned int)0x72d5b375);
  b = (t << 20 | t >> 32 - 20) + c;
  t = a + (b ^ c ^ d) + X[(signed long int)5] + ((unsigned int)~0 ^ (unsigned int)0x0005c6bd);
  a = (t << 4 | t >> 32 - 4) + b;
  t = d + (a ^ b ^ c) + X[(signed long int)8] + ((unsigned int)~0 ^ (unsigned int)0x788e097e);
  d = (t << 11 | t >> 32 - 11) + a;
  t = c + (d ^ a ^ b) + X[(signed long int)11] + (unsigned int)0x6d9d6122;
  c = (t << 16 | t >> 32 - 16) + d;
  t = b + (c ^ d ^ a) + X[(signed long int)14] + ((unsigned int)~0 ^ (unsigned int)0x021ac7f3);
  b = (t << 23 | t >> 32 - 23) + c;
  t = a + (b ^ c ^ d) + X[(signed long int)1] + ((unsigned int)~0 ^ (unsigned int)0x5b4115bb);
  a = (t << 4 | t >> 32 - 4) + b;
  t = d + (a ^ b ^ c) + X[(signed long int)4] + (unsigned int)0x4bdecfa9;
  d = (t << 11 | t >> 32 - 11) + a;
  t = c + (d ^ a ^ b) + X[(signed long int)7] + ((unsigned int)~0 ^ (unsigned int)0x0944b49f);
  c = (t << 16 | t >> 32 - 16) + d;
  t = b + (c ^ d ^ a) + X[(signed long int)10] + ((unsigned int)~0 ^ (unsigned int)0x4140438f);
  b = (t << 23 | t >> 32 - 23) + c;
  t = a + (b ^ c ^ d) + X[(signed long int)13] + (unsigned int)0x289b7ec6;
  a = (t << 4 | t >> 32 - 4) + b;
  t = d + (a ^ b ^ c) + X[(signed long int)0] + ((unsigned int)~0 ^ (unsigned int)0x155ed805);
  d = (t << 11 | t >> 32 - 11) + a;
  t = c + (d ^ a ^ b) + X[(signed long int)3] + ((unsigned int)~0 ^ (unsigned int)0x2b10cf7a);
  c = (t << 16 | t >> 32 - 16) + d;
  t = b + (c ^ d ^ a) + X[(signed long int)6] + (unsigned int)0x04881d05;
  b = (t << 23 | t >> 32 - 23) + c;
  t = a + (b ^ c ^ d) + X[(signed long int)9] + ((unsigned int)~0 ^ (unsigned int)0x262b2fc6);
  a = (t << 4 | t >> 32 - 4) + b;
  t = d + (a ^ b ^ c) + X[(signed long int)12] + ((unsigned int)~0 ^ (unsigned int)0x1924661a);
  d = (t << 11 | t >> 32 - 11) + a;
  t = c + (d ^ a ^ b) + X[(signed long int)15] + (unsigned int)0x1fa27cf8;
  c = (t << 16 | t >> 32 - 16) + d;
  t = b + (c ^ d ^ a) + X[(signed long int)2] + ((unsigned int)~0 ^ (unsigned int)0x3b53a99a);
  b = (t << 23 | t >> 32 - 23) + c;
  t = a + (c ^ (b | ~d)) + X[(signed long int)0] + ((unsigned int)~0 ^ (unsigned int)0x0bd6ddbb);
  a = (t << 6 | t >> 32 - 6) + b;
  t = d + (b ^ (a | ~c)) + X[(signed long int)7] + (unsigned int)0x432aff97;
  d = (t << 10 | t >> 32 - 10) + a;
  t = c + (a ^ (d | ~b)) + X[(signed long int)14] + ((unsigned int)~0 ^ (unsigned int)0x546bdc58);
  c = (t << 15 | t >> 32 - 15) + d;
  t = b + (d ^ (c | ~a)) + X[(signed long int)5] + ((unsigned int)~0 ^ (unsigned int)0x036c5fc6);
  b = (t << 21 | t >> 32 - 21) + c;
  t = a + (c ^ (b | ~d)) + X[(signed long int)12] + (unsigned int)0x655b59c3;
  a = (t << 6 | t >> 32 - 6) + b;
  t = d + (b ^ (a | ~c)) + X[(signed long int)3] + ((unsigned int)~0 ^ (unsigned int)0x70f3336d);
  d = (t << 10 | t >> 32 - 10) + a;
  t = c + (a ^ (d | ~b)) + X[(signed long int)10] + ((unsigned int)~0 ^ (unsigned int)0x00100b82);
  c = (t << 15 | t >> 32 - 15) + d;
  t = b + (d ^ (c | ~a)) + X[(signed long int)1] + ((unsigned int)~0 ^ (unsigned int)0x7a7ba22e);
  b = (t << 21 | t >> 32 - 21) + c;
  t = a + (c ^ (b | ~d)) + X[(signed long int)8] + (unsigned int)0x6fa87e4f;
  a = (t << 6 | t >> 32 - 6) + b;
  t = d + (b ^ (a | ~c)) + X[(signed long int)15] + ((unsigned int)~0 ^ (unsigned int)0x01d3191f);
  d = (t << 10 | t >> 32 - 10) + a;
  t = c + (a ^ (d | ~b)) + X[(signed long int)6] + ((unsigned int)~0 ^ (unsigned int)0x5cfebceb);
  c = (t << 15 | t >> 32 - 15) + d;
  t = b + (d ^ (c | ~a)) + X[(signed long int)13] + (unsigned int)0x4e0811a1;
  b = (t << 21 | t >> 32 - 21) + c;
  t = a + (c ^ (b | ~d)) + X[(signed long int)4] + ((unsigned int)~0 ^ (unsigned int)0x08ac817d);
  a = (t << 6 | t >> 32 - 6) + b;
  t = d + (b ^ (a | ~c)) + X[(signed long int)11] + ((unsigned int)~0 ^ (unsigned int)0x42c50dca);
  d = (t << 10 | t >> 32 - 10) + a;
  t = c + (a ^ (d | ~b)) + X[(signed long int)2] + (unsigned int)0x2ad7d2bb;
  c = (t << 15 | t >> 32 - 15) + d;
  t = b + (d ^ (c | ~a)) + X[(signed long int)9] + ((unsigned int)~0 ^ (unsigned int)0x14792c6e);
  b = (t << 21 | t >> 32 - 21) + c;
  pms->abcd[(signed long int)0] = pms->abcd[(signed long int)0] + a;
  pms->abcd[(signed long int)1] = pms->abcd[(signed long int)1] + b;
  pms->abcd[(signed long int)2] = pms->abcd[(signed long int)2] + c;
  pms->abcd[(signed long int)3] = pms->abcd[(signed long int)3] + d;
}

// process_icmpv6
// file mire.c line 69
static void process_icmpv6(signed int fd, struct ip6_hdr *ip6, unsigned long int plen, unsigned int ipv4, unsigned short int port)
{
  if(plen >= sizeof(struct icmp6_hdr) /*8ul*/ )
  {
    struct icmp6_hdr *hdr = (struct icmp6_hdr *)(ip6 + (signed long int)1);
    if((signed int)hdr->icmp6_type == 128)
    {
      ip6->ip6_ctlun.ip6_un1.ip6_un1_hlim = (unsigned char)255;
      struct in6_addr buf = ip6->ip6_dst;
      ip6->ip6_dst = ip6->ip6_src;
      ip6->ip6_src = buf;
      hdr->icmp6_type = (unsigned char)129;
      hdr->icmp6_code = (unsigned char)0;
      hdr->icmp6_cksum = (unsigned short int)0;
      hdr->icmp6_cksum=icmp6_checksum(ip6, hdr);
      teredo_send(fd, (const void *)ip6, sizeof(struct ip6_hdr) /*40ul*/  + plen, ipv4, port);
    }

  }

}

// process_none
// file mire.c line 104
static void process_none(signed int fd, struct ip6_hdr *ip6, unsigned long int plen, unsigned int ipv4, unsigned short int port)
{
  if(plen == 0ul)
    teredo_reply_bubble(fd, ipv4, port, ip6);

}

// process_unknown
// file mire.c line 115
static void process_unknown(signed int fd, struct ip6_hdr *in, unsigned long int plen, unsigned int ipv4, unsigned short int port)
{
  plen = plen + sizeof(struct ip6_hdr) /*40ul*/ ;
  if(plen >= 1233ul)
    plen = (unsigned long int)1232;

  struct ip6_hdr ip6;
  struct icmp6_hdr icmp6;
  struct iovec iov[3l] = { { .iov_base=(void *)&ip6, .iov_len=sizeof(struct ip6_hdr) /*40ul*/  },
    { .iov_base=(void *)&icmp6, .iov_len=sizeof(struct icmp6_hdr) /*8ul*/  },
    { .iov_base=(void *)in, .iov_len=plen } };
  ip6.ip6_ctlun.ip6_un1.ip6_un1_flow=htonl((unsigned int)(6 << 28));
  ip6.ip6_ctlun.ip6_un1.ip6_un1_plen=htons((unsigned short int)(sizeof(struct icmp6_hdr) /*8ul*/  + plen));
  ip6.ip6_ctlun.ip6_un1.ip6_un1_nxt = (unsigned char)58;
  ip6.ip6_ctlun.ip6_un1.ip6_un1_hlim = (unsigned char)255;
  ip6.ip6_src = in->ip6_dst;
  ip6.ip6_dst = in->ip6_src;
  icmp6.icmp6_type = (unsigned char)4;
  icmp6.icmp6_code = (unsigned char)1;
  icmp6.icmp6_cksum = (unsigned short int)0;
  icmp6.icmp6_dataun.icmp6_un_data32[(signed long int)0]=htonl((unsigned int)6);
  icmp6.icmp6_cksum=teredo_cksum((const void *)&ip6.ip6_src, (const void *)&ip6.ip6_dst, (unsigned char)58, iov + (signed long int)1, (unsigned long int)2);
  teredo_sendv(fd, iov, sizeof(struct iovec [3l]) /*48ul*/  / sizeof(struct iovec) /*16ul*/ , ipv4, port);
}

// recv_packet
// file mire.c line 158
static signed long int recv_packet(signed int fd, struct teredo_packet *p)
{
  signed int return_value_teredo_wait_recv_1;
  return_value_teredo_wait_recv_1=teredo_wait_recv(fd, p);
  _Bool tmp_if_expr_2;
  if(!(return_value_teredo_wait_recv_1 == 0))
    return (signed long int)-1;

  else
  {
    struct ip6_hdr *ip6 = p->ip6;
    unsigned short int plen;
    if(!(p->ip6_len >= sizeof(struct ip6_hdr) /*40ul*/ ))
      return (signed long int)-1;

    else
    {
      plen=ntohs(ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);
      if(!((signed int)ip6->ip6_ctlun.ip6_un2_vfc >> 4 == 6))
        tmp_if_expr_2 = (_Bool)1;

      else
        tmp_if_expr_2 = (unsigned long int)plen + sizeof(struct ip6_hdr) /*40ul*/  > p->ip6_len ? (_Bool)1 : (_Bool)0;
      if(tmp_if_expr_2)
        return (signed long int)-1;

      else
        return (signed long int)plen;
    }
  }
}

// server_thread
// file mire.c line 185
static void * server_thread(void *data)
{
  signed int fdserv = ((signed int *)data)[(signed long int)0];
  signed int fd = ((signed int *)data)[(signed long int)1];
  do
  {
    struct teredo_packet p;
    signed long int plen;
    plen=recv_packet(fdserv, &p);
    if(!(plen == -1l))
    {
      if((signed int)p.ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt == 59)
        process_none(fd, p.ip6, (unsigned long int)plen, p.source_ipv4, p.source_port);

    }

  }
  while((_Bool)1);
}

// strlcpy
// file strlcpy.c line 27
unsigned long int strlcpy(char *tgt, const char *src, unsigned long int bufsize)
{
  unsigned long int length = (unsigned long int)1;
  _Bool tmp_if_expr_1;
  char *tmp_post_2;
  const char *tmp_post_3;
  do
  {
    if(!(length >= bufsize))
      tmp_if_expr_1 = *src != 0 ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_1 = (_Bool)0;
    if(!tmp_if_expr_1)
      break;

    tmp_post_2 = tgt;
    tgt = tgt + 1l;
    tmp_post_3 = src;
    src = src + 1l;
    *tmp_post_2 = *tmp_post_3;
    length = length + 1ul;
  }
  while((_Bool)1);
  if(!(bufsize == 0ul))
    *tgt = (char)0;

  const char *tmp_post_4;
  do
  {
    tmp_post_4 = src;
    src = src + 1l;
    if(*tmp_post_4 == 0)
      break;

    length = length + 1ul;
  }
  while((_Bool)1);
  return length - (unsigned long int)1;
}

// teredo_cksum
// file ../libteredo/teredo-udp.h line 152
unsigned short int teredo_cksum(const void *src, const void *dst, unsigned char protocol, struct iovec *data, unsigned long int n)
{
  const signed long int teredo_cksum_array_size0 = (signed long int)((unsigned long int)3 + n);
  struct iovec iov[teredo_cksum_array_size0];
  unsigned long int plen = (unsigned long int)0;
  unsigned long int i = (unsigned long int)0;
  for( ; !(i >= n); i = i + 1ul)
  {
    iov[(signed long int)((unsigned long int)3 + i)].iov_base = (data + (signed long int)i)->iov_base;
    iov[(signed long int)((unsigned long int)3 + i)].iov_len = (data + (signed long int)i)->iov_len;
    plen = plen + iov[(signed long int)((unsigned long int)3 + i)].iov_len;
  }
  unsigned int pseudo[4l];
  unsigned int return_value_htonl_1;
  return_value_htonl_1=htonl((unsigned int)plen);
  unsigned int return_value_htonl_2;
  return_value_htonl_2=htonl((unsigned int)protocol);
  pseudo[0] = return_value_htonl_1;
  pseudo[1] = return_value_htonl_2;
  pseudo[2] = 0u;
  pseudo[3] = 0u;
  iov[(signed long int)0].iov_base = (void *)src;
  iov[(signed long int)0].iov_len = (unsigned long int)16;
  iov[(signed long int)1].iov_base = (void *)dst;
  iov[(signed long int)1].iov_len = (unsigned long int)16;
  iov[(signed long int)2].iov_base = (void *)pseudo;
  iov[(signed long int)2].iov_len = (unsigned long int)8;
  unsigned short int return_value_in_cksum_3;
  return_value_in_cksum_3=in_cksum(iov, (unsigned long int)3 + n);
  return return_value_in_cksum_3;
}

// teredo_cleanup
// file init.c line 53
void teredo_cleanup(_Bool use_client)
{
  (void)use_client;
  teredo_deinit_HMAC();
}

// teredo_clock
// file clock.h line 46
unsigned long int teredo_clock(void)
{
  unsigned long int value;
  /* tag-#anon#lST[SYM#tag-#anon#UN[SYM#tag-__pthread_mutex_s#'__data'||ARR40{S8}_S8_'__size'||S64'__align'|]#'lock'||S32'id'||B'present'||U24'_pad0'|] */
struct anonymous_0
{
  // lock
  union anonymous_24 lock;
  // id
  signed int id;
  // present
  _Bool present;
};

/* */
  ;
  static struct anonymous_0 priv = { .lock={ .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } }, .id=0,
    .present=(_Bool)0 };
  pthread_mutex_lock(&priv.lock);
  static struct clock_data_t clk = { .handle=NULL, .value=(unsigned long int)0, .active=(_Bool)0 };
  if(priv.present == (_Bool)0)
  {
    struct sigevent ev;
    memset((void *)&ev, 0, sizeof(struct sigevent) /*64ul*/ );
    ev.sigev_notify = 2;
    ev.sigev_value.sival_ptr = (void *)&clk;
    ev._sigev_un._sigev_thread._function = clock_tick;
    struct timespec res;
    signed int return_value_clock_getres_1;
    return_value_clock_getres_1=clock_getres(1, &res);
    if(return_value_clock_getres_1 == 0)
      priv.id = 1;

    signed int return_value_timer_create_2;
    return_value_timer_create_2=timer_create(priv.id, &ev, &clk.handle);
    if(return_value_timer_create_2 == 0)
      priv.present = (_Bool)1;

  }

  if(clk.active == (_Bool)0)
  {
    struct itimerspec it;
    clock_gettime(priv.id, &it.it_value);
    clk.value = (unsigned long int)it.it_value.tv_sec;
    if(!(priv.present == (_Bool)0))
    {
      it.it_value.tv_sec = it.it_value.tv_sec + 1l;
      it.it_value.tv_nsec = (signed long int)0;
      it.it_interval.tv_sec = (signed long int)1;
      it.it_interval.tv_nsec = (signed long int)0;
      clk.active = (_Bool)1;
      timer_settime(clk.handle, 1, &it, (struct itimerspec *)(void *)0);
    }

  }

  value = clk.value;
  pthread_mutex_unlock(&priv.lock);
  return value;
}

// teredo_close
// file ../libteredo/teredo-udp.h line 163
void teredo_close(signed int fd)
{
  close(fd);
}

// teredo_create
// file relay.c line 879
struct teredo_tunnel * teredo_create(unsigned int ipv4, unsigned short int port)
{
  struct teredo_tunnel *tunnel;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct teredo_tunnel) /*216ul*/ );
  tunnel = (struct teredo_tunnel *)return_value_malloc_1;
  if(tunnel == ((struct teredo_tunnel *)NULL))
    return (struct teredo_tunnel *)(void *)0;

  else
  {
    memset((void *)tunnel, 0, sizeof(struct teredo_tunnel) /*216ul*/ );
    tunnel->state.addr.teredo.prefix=htonl((unsigned int)0x20010000);
    tunnel->state.addr.teredo.client_port = (unsigned short int)~((signed int)port);
    tunnel->state.addr.teredo.client_ip = ~ipv4;
    tunnel->state.up = (_Bool)0;
    tunnel->ratelimit.count = 1;
    tunnel->recv_cb = teredo_dummy_recv_cb;
    tunnel->icmpv6_cb = teredo_dummy_icmpv6_cb;
    tunnel->up_cb = teredo_dummy_state_up_cb;
    tunnel->down_cb = teredo_dummy_state_down_cb;
    tunnel->fd=teredo_socket(ipv4, port);
    if(!(tunnel->fd == -1))
    {
      tunnel->list=teredo_list_create((unsigned int)1048576, (unsigned int)30);
      if(!(tunnel->list == ((struct teredo_peerlist *)NULL)))
      {
        pthread_rwlock_init(&tunnel->state_lock, (const union anonymous_19 *)(void *)0);
        pthread_mutex_init(&tunnel->ratelimit.lock, (const union anonymous_3 *)(void *)0);
        return tunnel;
      }

      teredo_close(tunnel->fd);
    }

    free((void *)tunnel);
    return (struct teredo_tunnel *)(void *)0;
  }
}

// teredo_deinit_HMAC
// file security.h line 35
void teredo_deinit_HMAC(void)
{
  ;
}

// teredo_destroy
// file relay.c line 923
void teredo_destroy(struct teredo_tunnel *t)
{
  if(!(t->maintenance == ((struct teredo_maintenance *)NULL)))
    teredo_maintenance_stop(t->maintenance);

  if(!(t->recv.running == (_Bool)0))
  {
    pthread_cancel(t->recv.thread);
    pthread_join(t->recv.thread, (void **)(void *)0);
  }

  teredo_list_destroy(t->list);
  pthread_rwlock_destroy(&t->state_lock);
  pthread_mutex_destroy(&t->ratelimit.lock);
  teredo_close(t->fd);
  free((void *)t);
}

// teredo_dummy_icmpv6_cb
// file relay.c line 852
static void teredo_dummy_icmpv6_cb(void *o, const void *p, unsigned long int l, struct in6_addr *d)
{
  (void)o;
  (void)p;
  (void)l;
  (void)d;
}

// teredo_dummy_recv_cb
// file relay.c line 844
static void teredo_dummy_recv_cb(void *o, const void *p, unsigned long int l)
{
  (void)o;
  (void)p;
  (void)l;
}

// teredo_dummy_state_down_cb
// file relay.c line 872
static void teredo_dummy_state_down_cb(void *o)
{
  (void)o;
}

// teredo_dummy_state_up_cb
// file relay.c line 863
static void teredo_dummy_state_up_cb(void *o, struct in6_addr *a, unsigned short int m)
{
  (void)o;
  (void)a;
  (void)m;
}

// teredo_encap
// file relay.c line 311
static signed int teredo_encap(struct teredo_tunnel * restrict tunnel, struct teredo_peer * restrict peer, const void * restrict data, unsigned long int len, unsigned long int now)
{
  unsigned int ipv4 = peer->mapped_addr;
  unsigned short int port = peer->mapped_port;
  TouchTransmit(peer, now);
  teredo_list_release(tunnel->list);
  signed int return_value_teredo_send_1;
  return_value_teredo_send_1=teredo_send(tunnel->fd, data, len, ipv4, port);
  return return_value_teredo_send_1 == (signed int)len ? 0 : -1;
}

// teredo_enqueue_in
// file peerlist.h line 52
void teredo_enqueue_in(struct teredo_peer * restrict peer, const void * restrict data, unsigned long int len, unsigned int ip, unsigned short int port)
{
  teredo_peer_queue(peer, data, len, ip, port, (_Bool)1);
}

// teredo_enqueue_out
// file peerlist.h line 55
void teredo_enqueue_out(struct teredo_peer * restrict peer, const void * restrict data, unsigned long int len)
{
  teredo_peer_queue(peer, data, len, (unsigned int)0, (unsigned short int)0, (_Bool)0);
}

// teredo_get_flbits
// file security.c line 226
unsigned short int teredo_get_flbits(unsigned int timestamp)
{
  unsigned char buf[16l];
  teredo_hash((void *)0, (unsigned long int)0, (void *)0, (unsigned long int)0, buf, timestamp);
  return (unsigned short int)((signed int)buf[(signed long int)0] << 8 | (signed int)buf[(signed long int)1]);
}

// teredo_get_nonce
// file security.c line 241
void teredo_get_nonce(unsigned int timestamp, unsigned int ipv4, unsigned short int port, unsigned char * restrict nonce)
{
  unsigned char buf[16l];
  teredo_hash((const void *)&ipv4, (unsigned long int)4, (const void *)&port, (unsigned long int)2, buf, timestamp);
  memcpy((void *)nonce, (const void *)buf, (unsigned long int)8);
}

// teredo_get_pinghash
// file security.c line 181
void teredo_get_pinghash(unsigned int timestamp, struct in6_addr *src, struct in6_addr *dst, unsigned char * restrict hash)
{
  memcpy((void *)hash, (const void *)&hmac_pid, sizeof(unsigned short int) /*2ul*/ );
  hash = hash + (signed long int)sizeof(unsigned short int) /*2ul*/ ;
  timestamp=htonl(timestamp);
  memcpy((void *)hash, (const void *)((unsigned char *)&timestamp + (signed long int)2), (unsigned long int)2);
  hash = hash + (signed long int)2;
  memcpy((void *)hash, (const void *)&timestamp, (unsigned long int)2);
  hash = hash + (signed long int)2;
  teredo_pinghash(src, dst, hash, timestamp);
}

// teredo_get_privdata
// file relay.c line 1105
void * teredo_get_privdata(const struct teredo_tunnel *t)
{
  return t->opaque;
}

// teredo_hash
// file security.c line 126
static void teredo_hash(const void *src, unsigned long int slen, const void *dst, unsigned long int dlen, unsigned char * restrict hash, unsigned int timestamp)
{
  struct md5_state_s ctx;
  md5_init(&ctx);
  md5_append(&ctx, inner_key.ipad, (signed int)sizeof(unsigned char [64l]) /*64ul*/ );
  md5_append(&ctx, (const unsigned char *)src, (signed int)slen);
  md5_append(&ctx, (const unsigned char *)dst, (signed int)dlen);
  md5_append(&ctx, (const unsigned char *)&hmac_pid, (signed int)sizeof(unsigned short int) /*2ul*/ );
  md5_append(&ctx, (const unsigned char *)&timestamp, (signed int)sizeof(unsigned int) /*4ul*/ );
  md5_finish(&ctx, hash);
  md5_init(&ctx);
  md5_append(&ctx, outer_key.opad, (signed int)sizeof(unsigned char [64l]) /*64ul*/ );
  md5_append(&ctx, hash, 16);
  md5_finish(&ctx, hash);
}

// teredo_init_HMAC
// file security.h line 34
signed int teredo_init_HMAC(void)
{
  signed int retval = -1;
  static union anonymous_24 mutex = { .__data={ .__lock=0, .__count=(unsigned int)0, .__owner=0, .__nusers=(unsigned int)0,
    .__kind=0, .__spins=(signed short int)0,
    .__elision=(signed short int)0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
  pthread_mutex_lock(&mutex);
  signed int return_value_getpid_3;
  return_value_getpid_3=getpid();
  unsigned short int return_value_htons_4;
  return_value_htons_4=htons((unsigned short int)return_value_getpid_3);
  if(!(hmac_pid == return_value_htons_4))
  {
    signed int fd;
    fd=open(randfile, 00);
    if(fd == -1)
      goto error;

    memset((void *)&inner_key, 0, sizeof(union anonymous_22) /*64ul*/ );
    unsigned int len = (unsigned int)0;
    while(!(len >= 16u))
    {
      signed int val;
      signed long int return_value_read_1;
      return_value_read_1=read(fd, (void *)(inner_key.key + (signed long int)len), (unsigned long int)((unsigned int)16 - len));
      val = (signed int)return_value_read_1;
      if(val >= 1)
        len = len - (unsigned int)val;

    }
    close(fd);
    memcpy((void *)&outer_key, (const void *)&inner_key, sizeof(union anonymous_23) /*64ul*/ );
    unsigned int i = (unsigned int)0;
    for( ; !((unsigned long int)i >= sizeof(union anonymous_22) /*64ul*/ ); i = i + 1u)
    {
      inner_key.ipad[(signed long int)i] = inner_key.ipad[(signed long int)i] ^ (unsigned char)0x36;
      outer_key.opad[(signed long int)i] = outer_key.opad[(signed long int)i] ^ (unsigned char)0x5c;
    }
    signed int return_value_getpid_2;
    return_value_getpid_2=getpid();
    hmac_pid=htons((unsigned short int)return_value_getpid_2);
  }

  retval = 0;

error:
  ;
  pthread_mutex_unlock(&mutex);
  return retval;
}

// teredo_list_create
// file peerlist.h line 106
struct teredo_peerlist * teredo_list_create(unsigned int max, unsigned int expiration)
{
  struct teredo_peerlist *l;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct teredo_peerlist) /*80ul*/ );
  l = (struct teredo_peerlist *)return_value_malloc_1;
  if(l == ((struct teredo_peerlist *)NULL))
    return (struct teredo_peerlist *)(void *)0;

  else
  {
    memset((void *)l, 0, sizeof(struct teredo_peerlist *) /*8ul*/ );
    pthread_mutex_init(&l->lock, (const union anonymous_3 *)(void *)0);
    l->old = (struct teredo_listitem *)(void *)0;
    l->recent = l->old;
    l->left = max;
    l->expiration = expiration;
    l->PJHSArray = (void *)0;
    signed int return_value_pthread_create_2;
    return_value_pthread_create_2=pthread_create(&l->gc, (const union pthread_attr_t *)(void *)0, garbage_collector, (void *)l);
    if(!(return_value_pthread_create_2 == 0))
    {
      pthread_mutex_destroy(&l->lock);
      free((void *)l);
      return (struct teredo_peerlist *)(void *)0;
    }

    else
      return l;
  }
}

// teredo_list_destroy
// file peerlist.h line 113
void teredo_list_destroy(struct teredo_peerlist *l)
{
  teredo_list_reset(l, (unsigned int)0);
  pthread_cancel(l->gc);
  pthread_join(l->gc, (void **)(void *)0);
  pthread_mutex_destroy(&l->lock);
  free((void *)l);
}

// teredo_list_lookup
// file peerlist.h line 141
struct teredo_peer * teredo_list_lookup(struct teredo_peerlist * restrict list, struct in6_addr * restrict addr, _Bool * restrict create)
{
  struct teredo_listitem *p;
  pthread_mutex_lock(&list->lock);
  struct teredo_listitem **pp = (struct teredo_listitem **)(void *)0;
  void *PValue;
  struct teredo_listitem *tmp_if_expr_3;
  if(!(create == ((_Bool *)NULL)))
  {
    struct J_UDY_ERROR_STRUCT J_Error;
    void **return_value_JudyHSIns_1;
    return_value_JudyHSIns_1=JudyHSIns(&list->PJHSArray, (void *)(unsigned char *)addr, (unsigned long int)16, &J_Error);
    PValue = (void *)return_value_JudyHSIns_1;
    if(PValue == (void *)18446744073709551615ul)
    {
      fprintf(stderr, "File '%s', line %d: %s(), JU_ERRNO_* == %d, ID == %d\n", (const void *)"peerlist.c", 376, (const void *)"JudyHSIns", (&J_Error)->je_Errno, (&J_Error)->je_ErrID);
      exit(1);
    }

    if(PValue == (void *)18446744073709551615ul)
      goto error;

    pp = (struct teredo_listitem **)PValue;
    p = *pp;
  }

  else
  {
    void **return_value_JudyHSGet_2;
    return_value_JudyHSGet_2=JudyHSGet(list->PJHSArray, (void *)(unsigned char *)addr, (unsigned long int)16);
    PValue = (void *)return_value_JudyHSGet_2;
    pp = (struct teredo_listitem **)PValue;
    if(!(pp == ((struct teredo_listitem **)NULL)))
      tmp_if_expr_3 = *pp;

    else
      tmp_if_expr_3 = (struct teredo_listitem *)(void *)0;
    p = tmp_if_expr_3;
  }
  if(!(p == ((struct teredo_listitem *)NULL)))
  {
    if(!(create == ((_Bool *)NULL)))
      *create = (_Bool)0;

    if(!(list->recent == p))
    {
      if(!(p->next == ((struct teredo_listitem *)NULL)))
        p->next->pprev = p->pprev;

      *p->pprev = p->next;
      p->next = list->recent;
      if(!(p->next == ((struct teredo_listitem *)NULL)))
        p->next->pprev = &p->next;

      list->recent = p;
      p->pprev = &list->recent;
    }

    return &p->peer;
  }

  else
    if(!(create == ((_Bool *)NULL)))
    {
      *create = (_Bool)1;
      if(list->left >= 1u)
        p=listitem_create();

      if(p == ((struct teredo_listitem *)NULL))
      {
        signed int Rc_int;
        struct J_UDY_ERROR_STRUCT teredo_list_lookup__1__3__1__J_Error;
        Rc_int=JudyHSDel(&list->PJHSArray, (void *)(unsigned char *)addr, sizeof(struct in6_addr) /*16ul*/ , &teredo_list_lookup__1__3__1__J_Error);
        if(Rc_int == -1)
        {
          fprintf(stderr, "File '%s', line %d: %s(), JU_ERRNO_* == %d, ID == %d\n", (const void *)"peerlist.c", 453, (const void *)"JudyHSDel", (&teredo_list_lookup__1__3__1__J_Error)->je_Errno, (&teredo_list_lookup__1__3__1__J_Error)->je_ErrID);
          exit(1);
        }

        goto error;
      }

      p->next = list->recent;
      if(!(p->next == ((struct teredo_listitem *)NULL)))
        p->next->pprev = &p->next;

      p->pprev = &list->recent;
      list->recent = p;
      p->pprev = &list->recent;
      list->left = list->left - 1u;
      *pp = p;
      p->key.ip6 = *addr;
      return &p->peer;
    }

    else
    {

    error:
      ;
      pthread_mutex_unlock(&list->lock);
      return (struct teredo_peer *)(void *)0;
    }
}

// teredo_list_release
// file peerlist.h line 149
void teredo_list_release(struct teredo_peerlist *l)
{
  pthread_mutex_unlock(&l->lock);
}

// teredo_list_reset
// file peerlist.h line 122
void teredo_list_reset(struct teredo_peerlist *l, unsigned int max)
{
  pthread_mutex_lock(&l->lock);
  void *array = l->PJHSArray;
  l->PJHSArray = (void *)0;
  struct teredo_listitem *recent = l->recent;
  struct teredo_listitem *old = l->old;
  l->old = (struct teredo_listitem *)(void *)0;
  l->recent = l->old;
  l->left = max;
  pthread_mutex_unlock(&l->lock);
  listitem_recdestroy(old);
  listitem_recdestroy(recent);
  signed long int Rc_word;
  struct J_UDY_ERROR_STRUCT J_Error;
  unsigned long int return_value_JudyHSFreeArray_1;
  return_value_JudyHSFreeArray_1=JudyHSFreeArray(&array, &J_Error);
  Rc_word = (signed long int)return_value_JudyHSFreeArray_1;
  if(Rc_word == -1l)
  {
    fprintf(stderr, "File '%s', line %d: %s(), JU_ERRNO_* == %d, ID == %d\n", (const void *)"peerlist.c", 340, (const void *)"JudyHSFreeArray", (&J_Error)->je_Errno, (&J_Error)->je_ErrID);
    exit(1);
  }

}

// teredo_maintenance_process
// file maintain.h line 98
signed int teredo_maintenance_process(struct teredo_maintenance * restrict m, const struct teredo_packet * restrict packet)
{
  unsigned short int return_value_htons_1;
  return_value_htons_1=htons((unsigned short int)3544);
  _Bool tmp_if_expr_2;
  if(!(packet->source_port == return_value_htons_1))
    tmp_if_expr_2 = (_Bool)1;

  else
    tmp_if_expr_2 = !(packet->auth_present != (_Bool)0) ? (_Bool)1 : (_Bool)0;
  _Bool tmp_if_expr_7;
  _Bool tmp_statement_expression_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  if(tmp_if_expr_2)
    tmp_if_expr_7 = (_Bool)1;

  else
  {
    struct in6_addr *__a = (struct in6_addr *)&packet->ip6->ip6_dst;
    struct in6_addr *__b = (struct in6_addr *)&teredo_restrict;
    if(__a->__in6_u.__u6_addr32[0l] == __b->__in6_u.__u6_addr32[0l])
      tmp_if_expr_4 = __a->__in6_u.__u6_addr32[(signed long int)1] == __b->__in6_u.__u6_addr32[(signed long int)1] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = __a->__in6_u.__u6_addr32[(signed long int)2] == __b->__in6_u.__u6_addr32[(signed long int)2] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    if(tmp_if_expr_5)
      tmp_if_expr_6 = __a->__in6_u.__u6_addr32[(signed long int)3] == __b->__in6_u.__u6_addr32[(signed long int)3] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_6 = (_Bool)0;
    tmp_statement_expression_3 = tmp_if_expr_6;
    tmp_if_expr_7 = !tmp_statement_expression_3 ? (_Bool)1 : (_Bool)0;
  }
  if(tmp_if_expr_7)
    return -1;

  else
  {
    pthread_mutex_lock(&m->outer);
    pthread_mutex_lock(&m->inner);
    m->incoming = packet;
    pthread_cond_signal(&m->received);
    do
      pthread_cond_wait(&m->processed, &m->inner);
    while(!(m->incoming == ((const struct teredo_packet *)NULL)));
    pthread_mutex_unlock(&m->inner);
    pthread_mutex_unlock(&m->outer);
    return 0;
  }
}

// teredo_maintenance_start
// file maintain.h line 78
struct teredo_maintenance * teredo_maintenance_start(signed int fd, void (*cb)(struct teredo_state *, void *), void *opaque, const char *s1, const char *s2, unsigned int q_sec, unsigned int q_retries, unsigned int refresh_sec, unsigned int restart_sec)
{
  struct teredo_maintenance *m;
  void *return_value_malloc_1;
  return_value_malloc_1=malloc(sizeof(struct teredo_maintenance) /*264ul*/ );
  m = (struct teredo_maintenance *)return_value_malloc_1;
  if(m == ((struct teredo_maintenance *)NULL))
    return (struct teredo_maintenance *)(void *)0;

  else
  {
    memset((void *)m, 0, sizeof(struct teredo_maintenance) /*264ul*/ );
    m->fd = fd;
    m->state.cb = cb;
    m->state.opaque = opaque;
    m->server=strdup(s1);
    (void)s2;
    m->qualification_delay = (_Bool)q_sec ? q_sec : QualificationDelay;
    m->qualification_retries = (_Bool)q_retries ? q_retries : QualificationRetries;
    m->refresh_delay = (_Bool)refresh_sec ? refresh_sec : RefreshDelay;
    m->restart_delay = (_Bool)restart_sec ? restart_sec : RestartDelay;
    if(m->server == ((char *)NULL))
    {
      free((void *)m);
      return (struct teredo_maintenance *)(void *)0;
    }

    else
    {
      union anonymous_3 attr;
      pthread_condattr_init(&attr);
      pthread_condattr_setclock(&attr, 1);
      pthread_cond_init(&m->received, &attr);
      pthread_condattr_destroy(&attr);
    }
    pthread_cond_init(&m->processed, (const union anonymous_3 *)(void *)0);
    pthread_mutex_init(&m->outer, (const union anonymous_3 *)(void *)0);
    pthread_mutex_init(&m->inner, (const union anonymous_3 *)(void *)0);
    signed int err;
    err=pthread_create(&m->thread, (const union pthread_attr_t *)(void *)0, do_maintenance, (void *)m);
    if(err == 0)
      return m;

    else
    {
      signed int *return_value___errno_location_2;
      return_value___errno_location_2=__errno_location();
      *return_value___errno_location_2 = err;
      char *return_value_dgettext_3;
      return_value_dgettext_3=dgettext("miredo", "Error (%s): %m");
      syslog(1, return_value_dgettext_3, (const void *)"pthread_create");
      pthread_cond_destroy(&m->processed);
      pthread_cond_destroy(&m->received);
      pthread_mutex_destroy(&m->outer);
      pthread_mutex_destroy(&m->inner);
      free((void *)m->server);
      free((void *)m);
      return (struct teredo_maintenance *)(void *)0;
    }
  }
}

// teredo_maintenance_stop
// file maintain.h line 89
void teredo_maintenance_stop(struct teredo_maintenance *m)
{
  pthread_cancel(m->thread);
  pthread_join(m->thread, (void **)(void *)0);
  pthread_cond_destroy(&m->processed);
  pthread_cond_destroy(&m->received);
  pthread_mutex_destroy(&m->inner);
  pthread_mutex_destroy(&m->outer);
  free((void *)m->server);
  free((void *)m);
}

// teredo_parse_ra
// file packets.c line 158
signed int teredo_parse_ra(const struct teredo_packet * restrict packet, union teredo_addr * restrict newaddr, _Bool cone, unsigned short int * restrict mtu)
{
  _Bool tmp_statement_expression_2;
  _Bool tmp_if_expr_3;
  _Bool tmp_if_expr_4;
  _Bool tmp_if_expr_5;
  _Bool tmp_if_expr_6;
  _Bool tmp_if_expr_7;
  struct nd_opt_prefix_info *pi;
  _Bool tmp_if_expr_8;
  struct nd_opt_mtu *mo;
  signed int tmp_if_expr_12;
  unsigned short int return_value_htons_11;
  if(packet->orig_ipv4 == 0u)
    return -1;

  else
  {
    struct ip6_hdr *ip6 = packet->ip6;
    unsigned long int length;
    unsigned short int return_value_ntohs_1;
    return_value_ntohs_1=ntohs(ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);
    length = (unsigned long int)return_value_ntohs_1;
    struct in6_addr *__a = (struct in6_addr *)&ip6->ip6_dst;
    struct in6_addr *__b = (struct in6_addr *)(cone != (_Bool)0 ? &teredo_cone : &teredo_restrict);
    if(__a->__in6_u.__u6_addr32[0l] == __b->__in6_u.__u6_addr32[0l])
      tmp_if_expr_3 = __a->__in6_u.__u6_addr32[(signed long int)1] == __b->__in6_u.__u6_addr32[(signed long int)1] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_3 = (_Bool)0;
    if(tmp_if_expr_3)
      tmp_if_expr_4 = __a->__in6_u.__u6_addr32[(signed long int)2] == __b->__in6_u.__u6_addr32[(signed long int)2] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_4 = (_Bool)0;
    if(tmp_if_expr_4)
      tmp_if_expr_5 = __a->__in6_u.__u6_addr32[(signed long int)3] == __b->__in6_u.__u6_addr32[(signed long int)3] ? (_Bool)1 : (_Bool)0;

    else
      tmp_if_expr_5 = (_Bool)0;
    tmp_statement_expression_2 = tmp_if_expr_5;
    if(!tmp_statement_expression_2)
      tmp_if_expr_6 = (_Bool)1;

    else
      tmp_if_expr_6 = (signed int)ip6->ip6_ctlun.ip6_un1.ip6_un1_nxt != 58 ? (_Bool)1 : (_Bool)0;
    if(!(length >= sizeof(struct nd_router_advert) /*16ul*/ ) || tmp_if_expr_6)
      return -1;

    else
    {
      struct nd_router_advert *ra = (struct nd_router_advert *)(ip6 + (signed long int)1);
      length = length - sizeof(struct nd_router_advert) /*16ul*/ ;
      if(!((signed int)ra->nd_ra_hdr.icmp6_type == 134))
        tmp_if_expr_7 = (_Bool)1;

      else
        tmp_if_expr_7 = (signed int)ra->nd_ra_hdr.icmp6_code != 0 ? (_Bool)1 : (_Bool)0;
      if(!(length >= sizeof(struct nd_opt_prefix_info) /*32ul*/ ) || tmp_if_expr_7)
        return -1;

      else
      {
        unsigned int net_mtu = (unsigned int)0;
        newaddr->teredo.server_ip = (unsigned int)0;
        struct nd_opt_hdr *hdr = (struct nd_opt_hdr *)(ra + (signed long int)1);
        for( ; length >= 8ul; hdr = (struct nd_opt_hdr *)((const unsigned char *)hdr + (signed long int)((signed int)hdr->nd_opt_len << 3)))
        {
          unsigned long int optlen = (unsigned long int)((signed int)hdr->nd_opt_len << 3);
          if(optlen == 0ul || !(length >= optlen))
            return -1;

          switch((signed int)hdr->nd_opt_type)
          {
            case 3:
            {
              pi = (struct nd_opt_prefix_info *)hdr;
              if(!(optlen >= sizeof(struct nd_opt_prefix_info) /*32ul*/ ))
                tmp_if_expr_8 = (_Bool)1;

              else
                tmp_if_expr_8 = (signed int)pi->nd_opt_pi_prefix_len != 64 ? (_Bool)1 : (_Bool)0;
              if(tmp_if_expr_8)
                return -1;

              if(!(newaddr->teredo.server_ip == 0u))
              {
                char *return_value_dgettext_9;
                return_value_dgettext_9=dgettext("miredo", "Multiple Teredo prefixes received");
                syslog(3, return_value_dgettext_9);
                return -1;
              }

              memcpy((void *)newaddr, (const void *)&pi->nd_opt_pi_prefix, (unsigned long int)8);
              break;
            }
            case 5:
            {
              mo = (struct nd_opt_mtu *)hdr;
              net_mtu=ntohl(mo->nd_opt_mtu_mtu);
              if(net_mtu >= 65536u || !(net_mtu >= 1280u))
                return -1;

            }
          }
          length = length - optlen;
        }
        unsigned int return_value_htonl_10;
        return_value_htonl_10=htonl((unsigned int)0x3ffe831f);
        if(newaddr->teredo.prefix == return_value_htonl_10)
          newaddr->teredo.prefix=htonl((unsigned int)0x20010000);

        if((0xff000000 & newaddr->teredo.prefix) == 0xff000000)
          return -1;

        else
        {
          if(!(cone == (_Bool)0))
          {
            return_value_htons_11=htons((unsigned short int)0x8000);
            tmp_if_expr_12 = (signed int)return_value_htons_11;
          }

          else
            tmp_if_expr_12 = 0;
          newaddr->teredo.flags = (unsigned short int)tmp_if_expr_12;
          newaddr->teredo.client_port = (unsigned short int)~((signed int)packet->orig_port);
          newaddr->teredo.client_ip = ~packet->orig_ipv4;
          if(!(net_mtu == 0u))
            *mtu = (unsigned short int)net_mtu;

          return 0;
        }
      }
    }
  }
}

// teredo_peer_destroy
// file peerlist.c line 77
static inline void teredo_peer_destroy(struct teredo_peer *peer)
{
  struct teredo_queue *p = peer->queue;
  while(!(p == ((struct teredo_queue *)NULL)))
  {
    struct teredo_queue *buf = p->next;
    free((void *)p);
    p = buf;
  }
}

// teredo_peer_init
// file peerlist.c line 70
static inline void teredo_peer_init(struct teredo_peer *peer)
{
  peer->queue = (struct teredo_queue *)(void *)0;
  peer->queue_left = (unsigned long int)teredo_MaxQueueBytes;
}

// teredo_peer_queue
// file peerlist.c line 92
static void teredo_peer_queue(struct teredo_peer * restrict peer, const void * restrict data, unsigned long int len, unsigned int ip, unsigned short int port, _Bool incoming)
{
  struct teredo_queue *p;
  if(peer->queue_left >= len)
  {
    peer->queue_left = peer->queue_left - len;
    void *return_value_malloc_1;
    return_value_malloc_1=malloc(sizeof(struct teredo_queue) /*24ul*/  + len);
    p = (struct teredo_queue *)return_value_malloc_1;
    p->length = len;
    memcpy((void *)p->data, data, len);
    p->ipv4 = ip;
    p->port = port;
    p->incoming = incoming;
    p->next = peer->queue;
    peer->queue = p;
  }

}

// teredo_peer_queue_yield
// file peerlist.h line 57
struct teredo_queue * teredo_peer_queue_yield(struct teredo_peer *peer)
{
  struct teredo_queue *q = peer->queue;
  peer->queue = (struct teredo_queue *)(void *)0;
  peer->queue_left = (unsigned long int)teredo_MaxQueueBytes;
  return q;
}

// teredo_pinghash
// file security.c line 158
static inline void teredo_pinghash(struct in6_addr *src, struct in6_addr *dst, unsigned char * restrict hash, unsigned int timestamp)
{
  teredo_hash((const void *)src, sizeof(struct in6_addr) /*16ul*/ , (const void *)dst, sizeof(struct in6_addr) /*16ul*/ , hash, timestamp);
}

// teredo_predecap
// file relay.c line 528
static void teredo_predecap(struct teredo_tunnel * restrict tunnel, struct teredo_peer * restrict peer, unsigned long int now)
{
  TouchReceive(peer, now);
  peer->pings = (unsigned int)0;
  peer->bubbles = (unsigned int)peer->pings;
  struct teredo_queue *q;
  q=teredo_peer_queue_yield(peer);
  teredo_list_release(tunnel->list);
  if(!(q == ((struct teredo_queue *)NULL)))
    teredo_queue_emit(q, tunnel->fd, peer->mapped_addr, peer->mapped_port, tunnel->recv_cb, tunnel->opaque);

}

// teredo_queue_emit
// file peerlist.h line 58
void teredo_queue_emit(struct teredo_queue *q, signed int fd, unsigned int ipv4, unsigned short int port, void (*cb)(void *, const void *, unsigned long int), void *opaque)
{
  while(!(q == ((struct teredo_queue *)NULL)))
  {
    struct teredo_queue *buf = q->next;
    if(!(q->incoming == (_Bool)0))
    {
      if(ipv4 == q->ipv4)
      {
        if(port == q->port)
          cb(opaque, (const void *)q->data, q->length);

      }

    }

    else
      teredo_send(fd, (const void *)q->data, q->length, ipv4, port);
    free((void *)q);
    q = buf;
  }
}

// teredo_recv
// file teredo-udp.h line 129
signed int teredo_recv(signed int fd, struct teredo_packet *p)
{
  signed int return_value_teredo_recv_inner_1;
  return_value_teredo_recv_inner_1=teredo_recv_inner(fd, p, 64);
  return return_value_teredo_recv_inner_1;
}

// teredo_recv_inner
// file teredo.c line 173
static signed int teredo_recv_inner(signed int fd, struct teredo_packet *p, signed int flags)
{
  struct sockaddr_in ad;
  char cbuf[32l];
  struct iovec iov = { .iov_base=(void *)p->buf.fill, .iov_len=(unsigned long int)65507 };
  struct msghdr msg = { .msg_name=(void *)&ad, .msg_namelen=(unsigned int)sizeof(struct sockaddr_in) /*16ul*/ , .msg_iov=&iov,
    .msg_iovlen=(unsigned long int)1, .msg_control=(void *)cbuf,
    .msg_controllen=sizeof(char [32l]) /*32ul*/ , .msg_flags=0 };
  signed long int length;
  length=recvmsg(fd, &msg, flags);
  if(length == -1l)
    teredo_recverr(fd);

  struct cmsghdr *tmp_if_expr_1;
  unsigned char *tmp_post_2;
  unsigned char *tmp_post_3;
  if(!(length >= 2l))
    return -1;

  else
  {
    p->source_ipv4 = ad.sin_addr.s_addr;
    p->source_port = ad.sin_port;
    p->dest_ipv4 = (unsigned int)0;
    struct cmsghdr *cmsg;
    if(msg.msg_controllen >= sizeof(struct cmsghdr) /*16ul*/ )
      tmp_if_expr_1 = (struct cmsghdr *)(&msg)->msg_control;

    else
      tmp_if_expr_1 = (struct cmsghdr *)0;
    cmsg = tmp_if_expr_1;
    while(!(cmsg == ((struct cmsghdr *)NULL)))
    {
      if(cmsg->cmsg_level == 0)
      {
        if(cmsg->cmsg_type == 8)
        {
          struct in_pktinfo *nfo = (struct in_pktinfo *)cmsg->__cmsg_data;
          p->dest_ipv4 = nfo->ipi_addr.s_addr;
        }

      }

      cmsg=__cmsg_nxthdr(&msg, cmsg);
    }
    unsigned char *ptr = p->buf.fill;
    p->auth_present = (_Bool)0;
    p->orig_ipv4 = (unsigned int)0;
    p->orig_port = (unsigned short int)0;
    if((signed int)*ptr == 0)
    {
      if((signed int)ptr[1l] == 1)
      {
        unsigned char id_len;
        unsigned char au_len;
        p->auth_present = (_Bool)1;
        length = length - (signed long int)13;
        if(!(length >= 0l))
          return -1;

        ptr = ptr + (signed long int)2;
        tmp_post_2 = ptr;
        ptr = ptr + 1l;
        id_len = *tmp_post_2;
        tmp_post_3 = ptr;
        ptr = ptr + 1l;
        au_len = *tmp_post_3;
        length = length - (signed long int)((signed int)id_len + (signed int)au_len);
        if(!(length >= 0l))
          return -1;

        ptr = ptr + (signed long int)((signed int)id_len + (signed int)au_len);
        memcpy((void *)p->auth_nonce, (const void *)ptr, (unsigned long int)8);
        ptr = ptr + (signed long int)8;
        p->auth_fail = !(!(*ptr != 0));
        ptr = ptr + 1l;
        memmove((void *)p->buf.align, (const void *)ptr, (unsigned long int)length);
        ptr = p->buf.fill;
      }

    }

    if((signed int)*ptr == 0)
    {
      if((signed int)ptr[1l] == 0)
      {
        unsigned int addr;
        unsigned short int port;
        length = length - (signed long int)8;
        if(!(length >= 0l))
          return -1;

        ptr = ptr + (signed long int)2;
        memcpy((void *)&port, (const void *)ptr, (unsigned long int)2);
        ptr = ptr + (signed long int)2;
        p->orig_port = (unsigned short int)~((signed int)port);
        memcpy((void *)&addr, (const void *)ptr, (unsigned long int)4);
        ptr = ptr + (signed long int)4;
        p->orig_ipv4 = ~addr;
      }

    }

    p->ip6_len = (unsigned long int)length;
    p->ip6 = (struct ip6_hdr *)ptr;
    return 0;
  }
}

// teredo_recv_thread
// file relay.c line 952
static void * teredo_recv_thread(void *t)
{
  struct teredo_tunnel *tunnel = (struct teredo_tunnel *)t;
  do
  {
    struct teredo_packet packet;
    signed int return_value_teredo_wait_recv_1;
    return_value_teredo_wait_recv_1=teredo_wait_recv(tunnel->fd, &packet);
    if(return_value_teredo_wait_recv_1 == 0)
    {
      pthread_setcancelstate(1, (signed int *)(void *)0);
      teredo_run_inner(tunnel, &packet);
      pthread_setcancelstate(0, (signed int *)(void *)0);
    }

  }
  while((_Bool)1);
}

// teredo_recverr
// file teredo.c line 118
static signed long int teredo_recverr(signed int fd)
{
  struct msghdr msg;
  memset((void *)&msg, 0, sizeof(struct msghdr) /*56ul*/ );
  signed long int return_value_recvmsg_1;
  return_value_recvmsg_1=recvmsg(fd, &msg, 8192);
  return return_value_recvmsg_1;
}

// teredo_reply_bubble
// file packets.h line 79
static inline signed int teredo_reply_bubble(signed int fd, unsigned int ip, unsigned short int port, struct ip6_hdr *req)
{
  signed int return_value_teredo_send_bubble_1;
  return_value_teredo_send_bubble_1=teredo_send_bubble(fd, ip, port, &req->ip6_dst, &req->ip6_src);
  return return_value_teredo_send_bubble_1;
}

// teredo_reply_bubble_link1
// file packets.h line 79
static inline signed int teredo_reply_bubble_link1(signed int fd_link1, unsigned int ip_link1, unsigned short int port_link1, struct ip6_hdr *req_link1)
{
  signed int return_value_teredo_send_bubble_1_link1;
  return_value_teredo_send_bubble_1_link1=teredo_send_bubble(fd_link1, ip_link1, port_link1, &req_link1->ip6_dst, &req_link1->ip6_src);
  return return_value_teredo_send_bubble_1_link1;
}

// teredo_run
// file relay.c line 986
void teredo_run(struct teredo_tunnel *tunnel)
{
  struct teredo_packet packet;
  signed int return_value_teredo_recv_1;
  return_value_teredo_recv_1=teredo_recv(tunnel->fd, &packet);
  if(return_value_teredo_recv_1 == 0)
    teredo_run_inner(tunnel, &packet);

}

// teredo_run_async
// file relay.c line 970
signed int teredo_run_async(struct teredo_tunnel *t)
{
  if(!(t->recv.running == (_Bool)0))
    return -1;

  else
  {
    signed int return_value_pthread_create_1;
    return_value_pthread_create_1=pthread_create(&t->recv.thread, (const union pthread_attr_t *)(void *)0, teredo_recv_thread, (void *)t);
    if(!(return_value_pthread_create_1 == 0))
      return -1;

    else
    {
      t->recv.running = (_Bool)1;
      return 0;
    }
  }
}

// teredo_run_inner
// file relay.c line 553
static void teredo_run_inner(struct teredo_tunnel * restrict tunnel, struct teredo_packet * restrict packet)
{
  struct ip6_hdr *ip6 = packet->ip6;
  _Bool tmp_if_expr_2;
  unsigned short int return_value_htons_6;
  _Bool return_value_IsBubble_4;
  signed int return_value_CheckPing_8;
  _Bool tmp_if_expr_17;
  _Bool return_value_IsBubble_14;
  _Bool tmp_if_expr_16;
  signed int return_value_CheckBubble_15;
  _Bool literal_10;
  if(packet->ip6_len >= sizeof(struct ip6_hdr) /*40ul*/ )
  {
    unsigned long int length;
    unsigned short int return_value_ntohs_1;
    return_value_ntohs_1=ntohs(ip6->ip6_ctlun.ip6_un1.ip6_un1_plen);
    length = sizeof(struct ip6_hdr) /*40ul*/  + (unsigned long int)return_value_ntohs_1;
    if(!((signed int)ip6->ip6_ctlun.ip6_un2_vfc >> 4 == 6))
      tmp_if_expr_2 = (_Bool)1;

    else
      tmp_if_expr_2 = length > packet->ip6_len ? (_Bool)1 : (_Bool)0;
    if(!tmp_if_expr_2)
    {
      struct teredo_state s;
      pthread_rwlock_rdlock(&tunnel->state_lock);
      s = tunnel->state;
      pthread_rwlock_unlock(&tunnel->state_lock);
      _Bool return_value_IsClient_7;
      return_value_IsClient_7=IsClient(tunnel);
      if(!(return_value_IsClient_7 == (_Bool)0))
      {
        signed int return_value_teredo_maintenance_process_3;
        return_value_teredo_maintenance_process_3=teredo_maintenance_process(tunnel->maintenance, packet);
        if(return_value_teredo_maintenance_process_3 == 0)
          goto __CPROVER_DUMP_L33;

        if(s.up == (_Bool)0)
          goto __CPROVER_DUMP_L33;

        if(packet->source_ipv4 == s.addr.teredo.server_ip)
        {
          return_value_htons_6=htons((unsigned short int)3544);
          if(packet->source_port == return_value_htons_6)
          {
            unsigned int ipv4 = packet->orig_ipv4;
            unsigned short int port = packet->orig_port;
            if(ipv4 == 0u)
            {
              return_value_IsBubble_4=IsBubble(ip6);
              if(!(return_value_IsBubble_4 == (_Bool)0))
              {
                if(((union teredo_addr *)&ip6->ip6_src)->teredo.prefix == s.addr.teredo.prefix)
                {
                  ipv4 = (&((union teredo_addr *)&ip6->ip6_src)->teredo)->client_ip ^ 0xffffffff;
                  port = (unsigned short int)((signed int)(&((union teredo_addr *)&ip6->ip6_src)->teredo)->client_port ^ 0xffff);
                }

              }

            }

            if(!(ipv4 == 0u))
            {
              teredo_reply_bubble_link1(tunnel->fd, ipv4, port, ip6);
              _Bool return_value_IsBubble_5;
              return_value_IsBubble_5=IsBubble(ip6);
              if(!(return_value_IsBubble_5 == (_Bool)0))
                goto __CPROVER_DUMP_L33;

            }

          }

        }

        if((0xff & (signed int)ip6->ip6_src.__in6_u.__u6_addr8[0l]) == 0xfe)
        {
          if((0xc0 & (signed int)ip6->ip6_src.__in6_u.__u6_addr8[1l]) == 0x80)
            goto __CPROVER_DUMP_L33;

        }

      }

      else
        if(!(((union teredo_addr *)&ip6->ip6_src)->teredo.prefix == s.addr.teredo.prefix))
          goto __CPROVER_DUMP_L33;

      if(!((signed int)ip6->ip6_dst.__in6_u.__u6_addr8[0l] == 0xff))
      {
        unsigned long int now;
        now=teredo_clock();
        struct teredo_peerlist *list = tunnel->list;
        struct teredo_peer *p;
        p=teredo_list_lookup(list, &ip6->ip6_src, (_Bool *)(void *)0);
        if(!(p == ((struct teredo_peer *)NULL)))
        {
          if(!(p->trusted == 0u))
          {
            if(packet->source_ipv4 == p->mapped_addr)
            {
              if(packet->source_port == p->mapped_port)
              {
                teredo_predecap(tunnel, p, now);
                tunnel->recv_cb(tunnel->opaque, (const void *)ip6, length);
              }

            }

          }

          _Bool return_value_IsClient_9;
          return_value_IsClient_9=IsClient(tunnel);
          if(!(return_value_IsClient_9 == (_Bool)0))
          {
            return_value_CheckPing_8=CheckPing(packet);
            if(return_value_CheckPing_8 == 0)
            {
              p->trusted = (unsigned int)1;
              SetMappingFromPacket(p, packet);
              teredo_predecap(tunnel, p, now);
              goto __CPROVER_DUMP_L33;
            }

          }

        }

        if(((union teredo_addr *)&ip6->ip6_src)->teredo.prefix == s.addr.teredo.prefix)
        {
          signed int return_value_in6_matches_teredo_client_13;
          return_value_in6_matches_teredo_client_13=in6_matches_teredo_client(&ip6->ip6_src, packet->source_ipv4, packet->source_port);
          if(!(return_value_in6_matches_teredo_client_13 == 0))
            tmp_if_expr_17 = (_Bool)1;

          else
          {
            return_value_IsBubble_14=IsBubble(ip6);
            if(!(return_value_IsBubble_14 == (_Bool)0))
            {
              return_value_CheckBubble_15=CheckBubble(packet);
              tmp_if_expr_16 = return_value_CheckBubble_15 == 0 ? (_Bool)1 : (_Bool)0;
            }

            else
              tmp_if_expr_16 = (_Bool)0;
            tmp_if_expr_17 = tmp_if_expr_16 ? (_Bool)1 : (_Bool)0;
          }
          if(tmp_if_expr_17)
          {
            _Bool return_value_IsClient_11;
            return_value_IsClient_11=IsClient(tunnel);
            if(!(return_value_IsClient_11 == (_Bool)0))
            {
              if(p == ((struct teredo_peer *)NULL))
              {
                literal_10 = (_Bool)0;
                p=teredo_list_lookup(list, &ip6->ip6_src, &literal_10);
              }

            }

            if(p == ((struct teredo_peer *)NULL))
              goto __CPROVER_DUMP_L33;

            SetMappingFromPacket(p, packet);
            p->trusted = (unsigned int)1;
            teredo_predecap(tunnel, p, now);
            _Bool return_value_IsBubble_12;
            return_value_IsBubble_12=IsBubble(ip6);
            if(return_value_IsBubble_12 == (_Bool)0)
              tunnel->recv_cb(tunnel->opaque, (const void *)ip6, length);

            goto __CPROVER_DUMP_L33;
          }

        }

        else
        {
          if(p == ((struct teredo_peer *)NULL))
          {
            _Bool create;
            p=teredo_list_lookup(list, &ip6->ip6_src, &create);
            if(p == ((struct teredo_peer *)NULL))
              goto __CPROVER_DUMP_L33;

            if(!(create == (_Bool)0))
            {
              p->mapped_port = (unsigned short int)0;
              p->mapped_addr = (unsigned int)0;
              p->pings = (unsigned int)0;
              p->bubbles = (unsigned int)p->pings;
              p->trusted = (unsigned int)p->bubbles;
            }

          }

          teredo_enqueue_in(p, (const void *)ip6, length, packet->source_ipv4, packet->source_port);
          TouchReceive(p, now);
          signed int res;
          res=CountPing(p, now);
          teredo_list_release(list);
          if(res == 0)
            SendPing(tunnel->fd, &s.addr, &ip6->ip6_src);

          goto __CPROVER_DUMP_L33;
        }
        if(!(p == ((struct teredo_peer *)NULL)))
          teredo_list_release(list);

      }

    }

  }


__CPROVER_DUMP_L33:
  ;
}

// teredo_send
// file ../libteredo/teredo-udp.h line 98
signed int teredo_send(signed int fd, const void *packet, unsigned long int plen, unsigned int dest_ip, unsigned short int dest_port)
{
  struct iovec iov = { .iov_base=(void *)packet, .iov_len=plen };
  signed int return_value_teredo_sendv_1;
  return_value_teredo_sendv_1=teredo_sendv(fd, &iov, (unsigned long int)1, dest_ip, dest_port);
  return return_value_teredo_sendv_1;
}

// teredo_send_bubble
// file packets.h line 75
signed int teredo_send_bubble(signed int fd, unsigned int ip, unsigned short int port, struct in6_addr *src, struct in6_addr *dst)
{
  signed int return_value_is_ipv4_global_unicast_2;
  return_value_is_ipv4_global_unicast_2=is_ipv4_global_unicast(ip);
  if(!(return_value_is_ipv4_global_unicast_2 == 0))
  {
    static const unsigned char head[9l] = { '`', 0, 0, 0, 0, 0, ';', 0, 0 };
    struct iovec iov[3l] = { { .iov_base=(void *)head, .iov_len=(unsigned long int)8 },
    { .iov_base=(void *)src, .iov_len=(unsigned long int)16 },
    { .iov_base=(void *)dst, .iov_len=(unsigned long int)16 } };
    signed int return_value_teredo_sendv_1;
    return_value_teredo_sendv_1=teredo_sendv(fd, iov, (unsigned long int)3, ip, port);
    return return_value_teredo_sendv_1 == 40 ? 0 : -1;
  }

  return 0;
}

// teredo_send_rs
// file packets.c line 119
signed int teredo_send_rs(signed int fd, unsigned int server_ip, const unsigned char *nonce, _Bool cone)
{
  unsigned char auth[13l] = { (unsigned char)0, (unsigned char)1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  /* tag-#anon#lST[lSYM#tag-ip6_hdr#'ip6'||lSYM#tag-nd_router_solicit#'rs'|] */
struct anonymous_28
{
  // ip6
  struct ip6_hdr ip6;
  // rs
  struct nd_router_solicit rs;
};

/* */
  ;
  struct anonymous_28 rs;
  struct iovec iov[2l] = { { .iov_base=(void *)auth, .iov_len=(unsigned long int)13 },
    { .iov_base=(void *)&rs, .iov_len=sizeof(struct anonymous_28) /*48ul*/  } };
  memcpy((void *)(auth + (signed long int)4), (const void *)nonce, (unsigned long int)8);
  rs.ip6.ip6_ctlun.ip6_un1.ip6_un1_flow=htonl((unsigned int)0x60000000);
  rs.ip6.ip6_ctlun.ip6_un1.ip6_un1_plen=htons((unsigned short int)(sizeof(struct anonymous_28) /*48ul*/  - sizeof(struct ip6_hdr) /*40ul*/ ));
  rs.ip6.ip6_ctlun.ip6_un1.ip6_un1_nxt = (unsigned char)58;
  rs.ip6.ip6_ctlun.ip6_un1.ip6_un1_hlim = (unsigned char)255;
  rs.ip6.ip6_src = cone != (_Bool)0 ? teredo_cone : teredo_restrict;
  rs.ip6.ip6_dst = in6addr_allrouters;
  rs.rs.nd_rs_hdr.icmp6_type = (unsigned char)133;
  rs.rs.nd_rs_hdr.icmp6_code = (unsigned char)0;
  signed int tmp_if_expr_3;
  unsigned short int return_value_htons_1;
  unsigned short int return_value_htons_2;
  if(!(cone == (_Bool)0))
  {
    return_value_htons_1=htons((unsigned short int)0x125d);
    tmp_if_expr_3 = (signed int)return_value_htons_1;
  }

  else
  {
    return_value_htons_2=htons((unsigned short int)0x7d37);
    tmp_if_expr_3 = (signed int)return_value_htons_2;
  }
  rs.rs.nd_rs_hdr.icmp6_cksum = (unsigned short int)tmp_if_expr_3;
  rs.rs.nd_rs_hdr.icmp6_dataun.icmp6_un_data32[(signed long int)0] = (unsigned int)0;
  unsigned short int return_value_htons_4;
  return_value_htons_4=htons((unsigned short int)3544);
  signed int return_value_teredo_sendv_5;
  return_value_teredo_sendv_5=teredo_sendv(fd, iov, sizeof(struct iovec [2l]) /*32ul*/  / sizeof(struct iovec) /*16ul*/ , server_ip, return_value_htons_4);
  return return_value_teredo_sendv_5 > 0 ? 0 : -1;
}

// teredo_send_unreach
// file relay.c line 122
static void teredo_send_unreach(struct teredo_tunnel * restrict tunnel, unsigned char code, struct ip6_hdr * restrict in, unsigned long int len)
{
  /* tag-#anon#lST[lSYM#tag-icmp6_hdr#'hdr'||lARR1232{S8}_S8_'fill'|] */
struct anonymous_21
{
  // hdr
  struct icmp6_hdr hdr;
  // fill
  char fill[1232l];
};

/* */
  ;
  struct anonymous_21 buf;
  unsigned long int now;
  now=teredo_clock();
  pthread_mutex_lock(&tunnel->ratelimit.lock);
  if(!(now == tunnel->ratelimit.last))
  {
    tunnel->ratelimit.last = now;
    tunnel->ratelimit.count = 100 != 0 ? (signed int)(1000 / 100) : -1;
  }

  if(tunnel->ratelimit.count == 0)
    pthread_mutex_unlock(&tunnel->ratelimit.lock);

  else
  {
    if(tunnel->ratelimit.count >= 1)
      tunnel->ratelimit.count = tunnel->ratelimit.count - 1;

    pthread_mutex_unlock(&tunnel->ratelimit.lock);
    signed int return_value_BuildICMPv6Error_1;
    return_value_BuildICMPv6Error_1=BuildICMPv6Error(&buf.hdr, (unsigned char)1, code, in, len);
    len = (unsigned long int)return_value_BuildICMPv6Error_1;
    tunnel->icmpv6_cb(tunnel->opaque, (const void *)&buf.hdr, len, &in->ip6_src);
  }
}

// teredo_sendv
// file ../libteredo/teredo-udp.h line 113
signed int teredo_sendv(signed int fd, struct iovec *iov, unsigned long int count, unsigned int dest_ip, unsigned short int dest_port)
{
  struct sockaddr_in addr = { .sin_family=(unsigned short int)2, .sin_port=dest_port, .sin_addr={ .s_addr=dest_ip },
    .sin_zero={ 0, 0, 0, 0, 0, 0, 0, 0 } };
  struct msghdr msg = { .msg_name=(void *)&addr, .msg_namelen=(unsigned int)sizeof(struct sockaddr_in) /*16ul*/ , .msg_iov=(struct iovec *)iov,
    .msg_iovlen=count, .msg_control=NULL,
    .msg_controllen=0ul, .msg_flags=0 };
  signed long int res;
  _Bool tmp_if_expr_2;
  signed long int return_value_teredo_recverr_1;
  do
  {
    res=sendmsg(fd, &msg, 0);
    if(res == -1l)
    {
      return_value_teredo_recverr_1=teredo_recverr(fd);
      tmp_if_expr_2 = return_value_teredo_recverr_1 != (signed long int)-1 ? (_Bool)1 : (_Bool)0;
    }

    else
      tmp_if_expr_2 = (_Bool)0;
  }
  while(tmp_if_expr_2);
  return (signed int)res;
}

// teredo_set_client_mode
// file relay.c line 1062
signed int teredo_set_client_mode(struct teredo_tunnel * restrict t, const char *s, const char *s2)
{
  pthread_rwlock_wrlock(&t->state_lock);
  if(!(t->maintenance == ((struct teredo_maintenance *)NULL)))
  {
    pthread_rwlock_unlock(&t->state_lock);
    return -1;
  }

  else
  {
    struct teredo_maintenance *m;
    m=teredo_maintenance_start(t->fd, teredo_state_change, (void *)t, s, s2, (unsigned int)0, (unsigned int)0, (unsigned int)0, (unsigned int)0);
    t->maintenance = m;
    pthread_rwlock_unlock(&t->state_lock);
    if(!(m == ((struct teredo_maintenance *)NULL)))
      return 0;

    else
      return -1;
  }
}

// teredo_set_cone_flag
// file relay.c line 1021
signed int teredo_set_cone_flag(struct teredo_tunnel *t, _Bool cone)
{
  signed int retval = 0;
  pthread_rwlock_wrlock(&t->state_lock);
  unsigned short int return_value_htons_1;
  unsigned short int return_value_htons_2;
  if(!(t->maintenance == ((struct teredo_maintenance *)NULL)))
    retval = -1;

  else
    if(!(cone == (_Bool)0))
    {
      return_value_htons_1=htons((unsigned short int)0x8000);
      t->state.addr.teredo.flags = t->state.addr.teredo.flags | return_value_htons_1;
    }

    else
    {
      return_value_htons_2=htons((unsigned short int)0x8000);
      t->state.addr.teredo.flags = t->state.addr.teredo.flags & (unsigned short int)~((signed int)return_value_htons_2);
    }
  pthread_rwlock_unlock(&t->state_lock);
  return retval;
}

// teredo_set_icmpv6_callback
// file relay.c line 1126
void teredo_set_icmpv6_callback(struct teredo_tunnel * restrict t, void (*cb)(void *, const void *, unsigned long int, struct in6_addr *))
{
  t->icmpv6_cb = cb != (void (*)(void *, const void *, unsigned long int, struct in6_addr *))(void *)0 ? cb : teredo_dummy_icmpv6_cb;
}

// teredo_set_prefix
// file relay.c line 999
signed int teredo_set_prefix(struct teredo_tunnel *t, unsigned int prefix)
{
  if((0xff000000 & prefix) == 0xff000000)
    return -1;

  else
  {
    signed int retval = 0;
    pthread_rwlock_wrlock(&t->state_lock);
    if(!(t->maintenance == ((struct teredo_maintenance *)NULL)))
      retval = -1;

    else
      t->state.addr.teredo.prefix = prefix;
    pthread_rwlock_unlock(&t->state_lock);
    return retval;
  }
}

// teredo_set_privdata
// file relay.c line 1092
void * teredo_set_privdata(struct teredo_tunnel *t, void *opaque)
{
  void *prev = t->opaque;
  t->opaque = opaque;
  return prev;
}

// teredo_set_recv_callback
// file relay.c line 1116
void teredo_set_recv_callback(struct teredo_tunnel * restrict t, void (*cb)(void *, const void *, unsigned long int))
{
  t->recv_cb = cb != (void (*)(void *, const void *, unsigned long int))(void *)0 ? cb : teredo_dummy_recv_cb;
}

// teredo_set_relay_mode
// file relay.c line 1045
signed int teredo_set_relay_mode(struct teredo_tunnel *t)
{
  signed int retval;
  pthread_rwlock_wrlock(&t->state_lock);
  retval = t->maintenance != (struct teredo_maintenance *)(void *)0 ? -1 : 0;
  pthread_rwlock_unlock(&t->state_lock);
  return retval;
}

// teredo_set_state_cb
// file relay.c line 1134
void teredo_set_state_cb(struct teredo_tunnel * restrict t, void (*u)(void *, struct in6_addr *, unsigned short int), void (*d)(void *))
{
  pthread_rwlock_wrlock(&t->state_lock);
  t->up_cb = u != (void (*)(void *, struct in6_addr *, unsigned short int))(void *)0 ? u : teredo_dummy_state_up_cb;
  t->down_cb = d != (void (*)(void *))(void *)0 ? d : teredo_dummy_state_down_cb;
  pthread_rwlock_unlock(&t->state_lock);
}

// teredo_socket
// file ../libteredo/teredo-udp.h line 90
signed int teredo_socket(unsigned int bind_ip, unsigned short int port)
{
  struct sockaddr_in myaddr = { .sin_family=(unsigned short int)2, .sin_port=port, .sin_addr={ .s_addr=bind_ip },
    .sin_zero={ 0, 0, 0, 0, 0, 0, 0, 0 } };
  signed int fd;
  fd=socket(2, 2, 17);
  if(fd == -1)
    return -1;

  else
  {
    fcntl(fd, 2, 1);
    signed int return_value_bind_1;
    return_value_bind_1=bind(fd, (struct sockaddr *)&myaddr, (unsigned int)sizeof(struct sockaddr_in) /*16ul*/ );
    if(!(return_value_bind_1 == 0))
    {
      close(fd);
      return -1;
    }

    else
    {
      signed int literal_2 = 0;
      setsockopt(fd, 0, 10, (const void *)&literal_2, (unsigned int)sizeof(signed int) /*4ul*/ );
      signed int literal_3 = 1;
      setsockopt(fd, 0, 11, (const void *)&literal_3, (unsigned int)sizeof(signed int) /*4ul*/ );
      signed int literal_4 = 1;
      setsockopt(fd, 0, 8, (const void *)&literal_4, (unsigned int)sizeof(signed int) /*4ul*/ );
      signed int literal_5 = 1;
      setsockopt(fd, 0, 33, (const void *)&literal_5, (unsigned int)sizeof(signed int) /*4ul*/ );
      return fd;
    }
  }
}

// teredo_startup
// file init.c line 36
signed int teredo_startup(_Bool use_client)
{
  bindtextdomain("miredo", "/usr/share/locale");
  (void)use_client;
  signed int return_value_teredo_init_HMAC_1;
  return_value_teredo_init_HMAC_1=teredo_init_HMAC();
  if(return_value_teredo_init_HMAC_1 == 0)
    return 0;

  else
    return -1;
}

// teredo_state_change
// file relay.c line 178
static void teredo_state_change(const struct teredo_state *state, void *self)
{
  struct teredo_tunnel *tunnel = (struct teredo_tunnel *)self;
  pthread_rwlock_wrlock(&tunnel->state_lock);
  _Bool previously_up = tunnel->state.up;
  tunnel->state = *state;
  if(!(tunnel->state.up == (_Bool)0))
  {
    teredo_list_reset(tunnel->list, (unsigned int)1048576);
    tunnel->up_cb(tunnel->opaque, &tunnel->state.addr.ip6, tunnel->state.mtu);
  }

  else
    if(!(previously_up == (_Bool)0))
      tunnel->down_cb(tunnel->opaque);

  pthread_rwlock_unlock(&tunnel->state_lock);
}

// teredo_transmit
// file relay.c line 324
signed int teredo_transmit(struct teredo_tunnel * restrict tunnel, struct ip6_hdr * restrict packet, unsigned long int length)
{
  union teredo_addr *dst = (union teredo_addr *)&packet->ip6_dst;
  _Bool return_value_IsValid_5;
  signed int return_value_teredo_encap_4;
  signed int return_value_SendBubbleFromDst_6;
  if((signed int)dst->ip6.__in6_u.__u6_addr8[0l] == 0xff)
    return 0;

  else
  {
    struct teredo_state s;
    pthread_rwlock_rdlock(&tunnel->state_lock);
    s = tunnel->state;
    pthread_rwlock_unlock(&tunnel->state_lock);
    _Bool return_value_IsClient_1;
    return_value_IsClient_1=IsClient(tunnel);
    if(!(return_value_IsClient_1 == (_Bool)0))
    {
      if(s.up != (_Bool)0)
        goto __CPROVER_DUMP_L2;

      teredo_send_unreach(tunnel, (unsigned char)3, packet, length);
      return 0;
    }

    else
    {

    __CPROVER_DUMP_L2:
      ;
      if(!(dst->teredo.prefix == s.addr.teredo.prefix))
      {
        _Bool return_value_IsClient_2;
        return_value_IsClient_2=IsClient(tunnel);
        if(!(return_value_IsClient_2 == (_Bool)0))
        {
          union teredo_addr *src = (union teredo_addr *)&packet->ip6_src;
          if(!(src->teredo.prefix == s.addr.teredo.prefix))
          {
            teredo_send_unreach(tunnel, (unsigned char)1, packet, length);
            return 0;
          }

        }

        else
        {
          teredo_send_unreach(tunnel, (unsigned char)3, packet, length);
          return 0;
        }
      }

      else
      {
        unsigned int peer_server = (&((union teredo_addr *)dst)->teredo)->server_ip;
        signed int return_value_is_ipv4_global_unicast_3;
        return_value_is_ipv4_global_unicast_3=is_ipv4_global_unicast(peer_server);
        if(return_value_is_ipv4_global_unicast_3 == 0 || peer_server == 0u)
          return 0;

      }
      _Bool created;
      unsigned long int now;
      now=teredo_clock();
      struct teredo_peerlist *list = tunnel->list;
      struct teredo_peer *p;
      p=teredo_list_lookup(list, &dst->ip6, &created);
      if(p == ((struct teredo_peer *)NULL))
        return -1;

      else
      {
        if(created == (_Bool)0)
        {
          if(!(p->trusted == 0u))
          {
            return_value_IsValid_5=IsValid(p, now);
            if(!(return_value_IsValid_5 == (_Bool)0))
            {
              return_value_teredo_encap_4=teredo_encap(tunnel, p, (const void *)packet, length, now);
              return return_value_teredo_encap_4;
            }

          }

        }

        else
        {
          p->pings = (unsigned int)0;
          p->bubbles = (unsigned int)p->pings;
          p->trusted = (unsigned int)p->bubbles;
        }
        if(!(dst->teredo.prefix == s.addr.teredo.prefix))
        {
          signed int teredo_transmit__1__6__res;
          if(!(created == (_Bool)0))
          {
            p->mapped_port = (unsigned short int)0;
            p->mapped_addr = (unsigned int)0;
          }

          teredo_enqueue_out(p, (const void *)packet, length);
          teredo_transmit__1__6__res=CountPing(p, now);
          teredo_list_release(list);
          if(teredo_transmit__1__6__res == 0)
            teredo_transmit__1__6__res=SendPing(tunnel->fd, &s.addr, &dst->ip6);

          if(teredo_transmit__1__6__res == -1)
            teredo_send_unreach(tunnel, (unsigned char)3, packet, length);

          return 0;
        }

        if(!(created == (_Bool)0))
          SetMapping(p, (&((union teredo_addr *)dst)->teredo)->client_ip ^ 0xffffffff, (unsigned short int)((signed int)(&((union teredo_addr *)dst)->teredo)->client_port ^ 0xffff));

        teredo_enqueue_out(p, (const void *)packet, length);
        signed int res;
        res=CountBubble(p, now);
        teredo_list_release(list);
        if(!(res == 0))
        {
          if(res == -1)
            goto __CPROVER_DUMP_L20;

        }

        else
        {
          unsigned short int return_value_htons_7;
          return_value_htons_7=htons((unsigned short int)0x8000);
          if(((signed int)s.addr.teredo.flags & (signed int)return_value_htons_7) == 0)
          {
            return_value_SendBubbleFromDst_6=SendBubbleFromDst(tunnel->fd, &dst->ip6, (_Bool)0);
            if(!(return_value_SendBubbleFromDst_6 == 0))
              return -1;

          }

          signed int return_value_SendBubbleFromDst_8;
          return_value_SendBubbleFromDst_8=SendBubbleFromDst(tunnel->fd, &dst->ip6, (_Bool)1);
          return return_value_SendBubbleFromDst_8;

        __CPROVER_DUMP_L20:
          ;
          teredo_send_unreach(tunnel, (unsigned char)3, packet, length);
        }
        return 0;
      }
    }
  }
}

// teredo_verify_pinghash
// file security.c line 199
signed int teredo_verify_pinghash(unsigned int now, struct in6_addr *src, struct in6_addr *dst, const unsigned char * restrict hash)
{
  signed int return_value_memcmp_1;
  return_value_memcmp_1=memcmp((const void *)hash, (const void *)&hmac_pid, sizeof(unsigned short int) /*2ul*/ );
  if(!(return_value_memcmp_1 == 0))
    return -1;

  else
  {
    hash = hash + (signed long int)sizeof(unsigned short int) /*2ul*/ ;
    unsigned int timestamp;
    memcpy((void *)((unsigned char *)&timestamp + (signed long int)2), (const void *)hash, (unsigned long int)2);
    hash = hash + (signed long int)2;
    memcpy((void *)&timestamp, (const void *)hash, (unsigned long int)2);
    hash = hash + (signed long int)2;
    unsigned int return_value_ntohl_2;
    return_value_ntohl_2=ntohl(timestamp);
    if((now + -return_value_ntohl_2 & 0xffffffff) >= 30u)
      return -1;

    else
    {
      unsigned char h1[16l];
      teredo_pinghash(src, dst, h1, timestamp);
      signed int return_value_memcmp_3;
      return_value_memcmp_3=memcmp((const void *)h1, (const void *)hash, (unsigned long int)16);
      return return_value_memcmp_3 != 0 ? -1 : 0;
    }
  }
}

// teredo_wait_recv
// file ../libteredo/teredo-udp.h line 145
signed int teredo_wait_recv(signed int fd, struct teredo_packet *p)
{
  signed int return_value_teredo_recv_inner_1;
  return_value_teredo_recv_inner_1=teredo_recv_inner(fd, p, 0);
  return return_value_teredo_recv_inner_1;
}

// usage
// file mire.c line 231
static signed int usage(const char *path)
{
  printf("Usage: %s\n", path);
  return 0;
}

// version
// file mire.c line 237
static signed int version(void)
{
  puts("miredo v1.2.6");
  return 0;
}

// wait_reply
// file maintain.c line 163
static signed int wait_reply(struct teredo_maintenance * restrict m, struct timespec * restrict deadline)
{
  while(m->incoming == ((const struct teredo_packet *)NULL))
  {
    signed int return_value_pthread_cond_timedwait_1;
    return_value_pthread_cond_timedwait_1=pthread_cond_timedwait(&m->received, &m->inner, deadline);
    switch(return_value_pthread_cond_timedwait_1)
    {
      case 0:
        goto __CPROVER_DUMP_L4;
      case 110:
        return 110;
      default:

        __CPROVER_DUMP_L4:
          ;
    }
  }
  return 0;
}

// wait_reply_ignore
// file maintain.c line 184
static void wait_reply_ignore(struct teredo_maintenance * restrict m, struct timespec * restrict deadline)
{
  signed int return_value_wait_reply_1;
  do
  {
    return_value_wait_reply_1=wait_reply(m, deadline);
    if(!(return_value_wait_reply_1 == 0))
      break;

    m->incoming = (const struct teredo_packet *)(void *)0;
    pthread_cond_signal(&m->processed);
  }
  while((_Bool)1);
}

